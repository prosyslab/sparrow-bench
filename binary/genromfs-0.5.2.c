/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 80 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
struct romfh {
   int32_t nextfh ;
   int32_t spec ;
   int32_t size ;
   int32_t checksum ;
};
#line 98
struct filenode;
#line 98
struct filenode;
#line 100 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
struct filehdr {
   struct filenode *head ;
   struct filenode *tail ;
   struct filenode *tailpred ;
   struct filenode *owner ;
};
#line 109 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
struct filenode {
   struct filenode *next ;
   struct filenode *prev ;
   struct filenode *parent ;
   struct filehdr dirlist ;
   struct filenode *orig_link ;
   char *name ;
   char *realname ;
   dev_t ondev ;
   dev_t devnode ;
   ino_t onino ;
   mode_t modes ;
   unsigned int offset ;
   unsigned int size ;
   unsigned int pad ;
};
#line 128 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
struct aligns {
   struct aligns *next ;
   int align ;
   char pattern[0] ;
};
#line 134 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
struct excludes {
   struct excludes *next ;
   char pattern[0] ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 27 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 30
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 33
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                     unsigned int __minor )  __attribute__((__const__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
char *outf  =    (char *)((void *)0);
#line 139 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
void initlist(struct filehdr *fh , struct filenode *owner ) 
{ 


  {
#line 141
  fh->head = (struct filenode *)(& fh->tail);
#line 142
  fh->tail = (struct filenode *)((void *)0);
#line 143
  fh->tailpred = (struct filenode *)(& fh->head);
#line 144
  fh->owner = owner;
#line 145
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
int listisempty(struct filehdr *fh ) 
{ 


  {
#line 149
  return ((unsigned long )fh->head == (unsigned long )((struct filenode *)(& fh->tail)));
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
void append(struct filehdr *fh , struct filenode *n ) 
{ 
  struct filenode *tail ;

  {
#line 154
  tail = (struct filenode *)(& fh->tail);
#line 156
  n->next = tail;
#line 156
  n->prev = tail->prev;
#line 157
  tail->prev = n;
#line 157
  (n->prev)->next = n;
#line 158
  n->parent = fh->owner;
#line 159
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
void shownode(int level , struct filenode *node , FILE *f ) 
{ 
  struct filenode *p ;

  {
  {
#line 164
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%-4d %-20s [0x%-8x, 0x%-8x] %07o, sz %5u, at 0x%-6x",
          level, node->name, (int )node->ondev, (int )node->onino, node->modes, node->size,
          node->offset);
  }
#line 169
  if (node->orig_link) {
    {
#line 170
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" [link to 0x%-6x]",
            (node->orig_link)->offset);
    }
  }
  {
#line 171
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 173
  p = node->dirlist.head;
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! p->next) {
#line 174
      goto while_break;
    }
    {
#line 175
    shownode(level + 1, p, f);
#line 176
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
static char bigbuf[4096]  ;
#line 183 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
static char fixbuf[512]  ;
#line 184 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
static int atoffs  =    0;
#line 185 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
static int align  =    16;
#line 186 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
struct aligns *alignlist  =    (struct aligns *)((void *)0);
#line 187 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
struct excludes *excludelist  =    (struct excludes *)((void *)0);
#line 188 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
int realbase  ;
#line 192 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
int nodematch(char *pattern , struct filenode *node ) 
{ 
  char *start ;
  int tmp ;

  {
#line 194
  start = node->name;
#line 196
  if ((int )*(pattern + 0) == 47) {
#line 196
    start = node->realname + realbase;
  }
  {
#line 197
  tmp = fnmatch((char const   *)pattern, (char const   *)start, 1 | (1 << 2));
  }
#line 197
  return (tmp);
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
int findalign(struct filenode *node ) 
{ 
  struct aligns *pa ;
  int i ;
  int tmp ;

  {
#line 205
  if ((node->modes & 61440U) == 32768U) {
#line 205
    i = align;
  } else {
#line 206
    i = 16;
  }
#line 208
  pa = alignlist;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! pa) {
#line 208
      goto while_break;
    }
#line 209
    if (pa->align > i) {
      {
#line 210
      tmp = nodematch(pa->pattern, node);
      }
#line 210
      if (! tmp) {
#line 210
        i = pa->align;
      }
    }
#line 208
    pa = pa->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return (i);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
int romfs_checksum(void *data , int size ) 
{ 
  int32_t sum ;
  int32_t word ;
  int32_t *ptr ;
  int32_t *tmp ;
  uint32_t tmp___0 ;

  {
#line 220
  sum = 0;
#line 220
  ptr = (int32_t *)data;
#line 221
  size >>= 2;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! (size > 0)) {
#line 222
      goto while_break;
    }
    {
#line 223
    tmp = ptr;
#line 223
    ptr ++;
#line 223
    word = *tmp;
#line 224
    tmp___0 = ntohl((uint32_t )word);
#line 224
    sum = (int32_t )((uint32_t )sum + tmp___0);
#line 225
    size --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  return (sum);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
void fixsum(struct romfh *ri , int size ) 
{ 
  int tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 232
  ri->checksum = 0;
#line 233
  tmp = romfs_checksum((void *)ri, size);
#line 233
  tmp___0 = htonl((uint32_t )(- tmp));
#line 233
  ri->checksum = (int32_t )tmp___0;
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
void dumpdata(void *addr , int len , FILE *f ) 
{ 
  int tocopy ;
  struct romfh *ri ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 241
  if (! len) {
#line 242
    return;
  }
#line 243
  if (atoffs >= 512) {
    {
#line 244
    fwrite((void const   */* __restrict  */)addr, (size_t )len, (size_t )1, (FILE */* __restrict  */)f);
#line 245
    atoffs += len;
    }
#line 246
    return;
  }
#line 249
  if (len < 512 - atoffs) {
#line 249
    tocopy = len;
  } else {
#line 249
    tocopy = 512 - atoffs;
  }
  {
#line 250
  memcpy((void */* __restrict  */)(fixbuf + atoffs), (void const   */* __restrict  */)addr,
         (size_t )tocopy);
#line 251
  atoffs += tocopy;
#line 252
  addr = (void *)((char *)addr + tocopy);
#line 253
  len -= tocopy;
  }
#line 255
  if (atoffs == 512) {
    {
#line 256
    ri = (struct romfh *)(& fixbuf);
#line 257
    tmp___2 = ntohl((uint32_t )ri->size);
    }
#line 257
    if ((uint32_t )atoffs < tmp___2) {
#line 257
      tmp___1 = (uint32_t )atoffs;
    } else {
      {
#line 257
      tmp___0 = ntohl((uint32_t )ri->size);
#line 257
      tmp___1 = tmp___0;
      }
    }
    {
#line 257
    fixsum(ri, (int )tmp___1);
#line 258
    tmp___3 = fwrite((void const   */* __restrict  */)(fixbuf), (size_t )atoffs, (size_t )1,
                     (FILE */* __restrict  */)f);
    }
#line 258
    if (tmp___3 != 1UL) {
      {
#line 259
      perror((char const   *)outf);
#line 260
      exit(1);
      }
    }
  }
#line 263
  if (len) {
    {
#line 264
    tmp___4 = fwrite((void const   */* __restrict  */)addr, (size_t )len, (size_t )1,
                     (FILE */* __restrict  */)f);
    }
#line 264
    if (tmp___4 != 1UL) {
      {
#line 265
      perror((char const   *)outf);
#line 266
      exit(1);
      }
    }
#line 268
    atoffs += len;
  }
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
void dumpzero(int len , FILE *f ) 
{ 


  {
  {
#line 274
  memset((void *)(bigbuf), 0, (size_t )len);
#line 275
  dumpdata((void *)(bigbuf), len, f);
  }
#line 276
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
void dumpdataa(void *addr , int len , FILE *f ) 
{ 


  {
  {
#line 280
  dumpdata(addr, len, f);
  }
#line 281
  if ((len & 15) != 0) {
    {
#line 282
    dumpzero(16 - (len & 15), f);
    }
  }
#line 283
  return;
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
void dumpstring(char *str , FILE *f ) 
{ 
  size_t tmp ;

  {
  {
#line 287
  tmp = strlen((char const   *)str);
#line 287
  dumpdataa((void *)str, (int )(tmp + 1UL), f);
  }
#line 288
  return;
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
void dumpri(struct romfh *ri , struct filenode *n , FILE *f ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 294
  tmp = strlen((char const   *)n->name);
#line 294
  len = (int )(tmp + 1UL);
#line 295
  memcpy((void */* __restrict  */)(bigbuf), (void const   */* __restrict  */)ri, sizeof(*ri));
#line 296
  memcpy((void */* __restrict  */)(bigbuf + 16), (void const   */* __restrict  */)n->name,
         (size_t )len);
  }
#line 297
  if (len & 15) {
    {
#line 298
    memset((void *)((bigbuf + 16) + len), 0, (size_t )(16 - (len & 15)));
#line 299
    len += 16 - (len & 15);
    }
  }
#line 301
  len += 16;
#line 302
  ri = (struct romfh *)(bigbuf);
#line 303
  if (n->offset) {
    {
#line 304
    fixsum(ri, len);
    }
  }
  {
#line 305
  dumpdata((void *)(bigbuf), len, f);
  }
#line 313
  return;
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
void dumpnode(struct filenode *node , FILE *f ) 
{ 
  struct romfh ri ;
  struct filenode *p ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  int tmp___9 ;
  uint32_t tmp___10 ;
  int offset ;
  int len ;
  int fd ;
  int max ;
  int avail ;
  uint32_t tmp___11 ;
  ssize_t tmp___12 ;
  uint32_t tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t tmp___21 ;
  uint32_t tmp___22 ;

  {
  {
#line 320
  ri.nextfh = 0;
#line 321
  ri.spec = 0;
#line 322
  tmp = htonl(node->size);
#line 322
  ri.size = (int32_t )tmp;
#line 323
  tmp___0 = htonl((uint32_t )1431655765);
#line 323
  ri.checksum = (int32_t )tmp___0;
  }
#line 324
  if (node->pad) {
    {
#line 325
    dumpzero((int )node->pad, f);
    }
  }
#line 326
  if (node->next) {
#line 326
    if ((node->next)->next) {
      {
#line 327
      tmp___1 = htonl((node->next)->offset);
#line 327
      ri.nextfh = (int32_t )tmp___1;
      }
    }
  }
#line 328
  if (node->modes & 73U) {
#line 328
    if ((node->modes & 61440U) == 16384U) {
      {
#line 330
      tmp___2 = htonl((uint32_t )8);
#line 330
      ri.nextfh = (int32_t )((unsigned int )ri.nextfh | tmp___2);
      }
    } else
#line 328
    if ((node->modes & 61440U) == 32768U) {
      {
#line 330
      tmp___2 = htonl((uint32_t )8);
#line 330
      ri.nextfh = (int32_t )((unsigned int )ri.nextfh | tmp___2);
      }
    }
  }
#line 332
  if (node->orig_link) {
    {
#line 333
    tmp___3 = htonl((uint32_t )0);
#line 333
    ri.nextfh = (int32_t )((unsigned int )ri.nextfh | tmp___3);
#line 335
    tmp___4 = htonl((uint32_t )8);
#line 335
    ri.nextfh = (int32_t )((unsigned int )ri.nextfh & ~ tmp___4);
#line 336
    tmp___5 = htonl((node->orig_link)->offset);
#line 336
    ri.spec = (int32_t )tmp___5;
#line 337
    dumpri(& ri, node, f);
    }
  } else
#line 338
  if ((node->modes & 61440U) == 16384U) {
    {
#line 339
    tmp___6 = htonl((uint32_t )1);
#line 339
    ri.nextfh = (int32_t )((unsigned int )ri.nextfh | tmp___6);
#line 340
    tmp___9 = listisempty(& node->dirlist);
    }
#line 340
    if (tmp___9) {
      {
#line 341
      tmp___7 = htonl(node->offset);
#line 341
      ri.spec = (int32_t )tmp___7;
      }
    } else {
      {
#line 343
      tmp___8 = htonl((node->dirlist.head)->offset);
#line 343
      ri.spec = (int32_t )tmp___8;
      }
    }
    {
#line 345
    dumpri(& ri, node, f);
    }
  } else
#line 346
  if ((node->modes & 61440U) == 40960U) {
    {
#line 347
    tmp___10 = htonl((uint32_t )3);
#line 347
    ri.nextfh = (int32_t )((unsigned int )ri.nextfh | tmp___10);
#line 348
    dumpri(& ri, node, f);
#line 349
    memset((void *)(bigbuf), 0, sizeof(bigbuf));
#line 350
    readlink((char const   */* __restrict  */)node->realname, (char */* __restrict  */)(bigbuf),
             (size_t )node->size);
#line 351
    dumpdataa((void *)(bigbuf), (int )node->size, f);
    }
  } else
#line 352
  if ((node->modes & 61440U) == 32768U) {
    {
#line 354
    tmp___11 = htonl((uint32_t )2);
#line 354
    ri.nextfh = (int32_t )((unsigned int )ri.nextfh | tmp___11);
#line 355
    dumpri(& ri, node, f);
#line 356
    offset = 0;
#line 357
    max = (int )node->size;
#line 359
    fd = open((char const   *)node->realname, 0);
    }
#line 364
    if (fd) {
      {
#line 365
      while (1) {
        while_continue: /* CIL Label */ ;
#line 365
        if (! (offset < max)) {
#line 365
          goto while_break;
        }
#line 366
        if ((unsigned long )(max - offset) < sizeof(bigbuf)) {
#line 366
          avail = max - offset;
        } else {
#line 366
          avail = (int )sizeof(bigbuf);
        }
        {
#line 367
        tmp___12 = read(fd, (void *)(bigbuf), (size_t )avail);
#line 367
        len = (int )tmp___12;
        }
#line 368
        if (len <= 0) {
#line 369
          goto while_break;
        }
        {
#line 370
        dumpdata((void *)(bigbuf), len, f);
#line 371
        offset += len;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 373
      close(fd);
      }
    }
#line 375
    max = (max + 15) & -16;
    {
#line 376
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 376
      if (! (offset < max)) {
#line 376
        goto while_break___0;
      }
#line 377
      if ((unsigned long )(max - offset) < sizeof(bigbuf)) {
#line 377
        avail = max - offset;
      } else {
#line 377
        avail = (int )sizeof(bigbuf);
      }
      {
#line 378
      memset((void *)(bigbuf), 0, (size_t )avail);
#line 379
      dumpdata((void *)(bigbuf), avail, f);
#line 380
      offset += avail;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 382
  if ((node->modes & 61440U) == 8192U) {
    {
#line 383
    tmp___13 = htonl((uint32_t )5);
#line 383
    ri.nextfh = (int32_t )((unsigned int )ri.nextfh | tmp___13);
#line 384
    tmp___14 = gnu_dev_major((unsigned long long )node->devnode);
#line 384
    tmp___15 = gnu_dev_minor((unsigned long long )node->devnode);
#line 384
    tmp___16 = htonl((tmp___14 << 16) | tmp___15);
#line 384
    ri.spec = (int32_t )tmp___16;
#line 385
    dumpri(& ri, node, f);
    }
  } else
#line 386
  if ((node->modes & 61440U) == 24576U) {
    {
#line 387
    tmp___17 = htonl((uint32_t )4);
#line 387
    ri.nextfh = (int32_t )((unsigned int )ri.nextfh | tmp___17);
#line 388
    tmp___18 = gnu_dev_major((unsigned long long )node->devnode);
#line 388
    tmp___19 = gnu_dev_minor((unsigned long long )node->devnode);
#line 388
    tmp___20 = htonl((tmp___18 << 16) | tmp___19);
#line 388
    ri.spec = (int32_t )tmp___20;
#line 389
    dumpri(& ri, node, f);
    }
  } else
#line 390
  if ((node->modes & 61440U) == 4096U) {
    {
#line 391
    tmp___21 = htonl((uint32_t )7);
#line 391
    ri.nextfh = (int32_t )((unsigned int )ri.nextfh | tmp___21);
#line 392
    dumpri(& ri, node, f);
    }
  } else
#line 393
  if ((node->modes & 61440U) == 49152U) {
    {
#line 394
    tmp___22 = htonl((uint32_t )6);
#line 394
    ri.nextfh = (int32_t )((unsigned int )ri.nextfh | tmp___22);
#line 395
    dumpri(& ri, node, f);
    }
  }
#line 398
  p = node->dirlist.head;
  {
#line 399
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 399
    if (! p->next) {
#line 399
      goto while_break___1;
    }
    {
#line 400
    dumpnode(p, f);
#line 401
    p = p->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 403
  return;
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
void dumpall(struct filenode *node , int lastoff , FILE *f ) 
{ 
  struct romfh ri ;
  struct filenode *p ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
#line 410
  tmp = htonl((uint32_t )762474349);
#line 410
  ri.nextfh = (int32_t )tmp;
#line 411
  tmp___0 = htonl((uint32_t )828797741);
#line 411
  ri.spec = (int32_t )tmp___0;
#line 412
  tmp___1 = htonl((uint32_t )lastoff);
#line 412
  ri.size = (int32_t )tmp___1;
#line 413
  tmp___2 = htonl((uint32_t )1431655765);
#line 413
  ri.checksum = (int32_t )tmp___2;
#line 414
  dumpri(& ri, node, f);
#line 415
  p = node->dirlist.head;
  }
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (! p->next) {
#line 416
      goto while_break;
    }
    {
#line 417
    dumpnode(p, f);
#line 418
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 421
  if (lastoff & 1023) {
    {
#line 422
    dumpzero(1024 - (lastoff & 1023), f);
    }
  }
#line 423
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
void freenode(struct filenode *n ) 
{ 


  {
#line 430
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
void setnode(struct filenode *n , dev_t dev , ino_t ino , mode_t um ) 
{ 


  {
#line 434
  n->ondev = dev;
#line 435
  n->onino = ino;
#line 436
  n->modes = um;
#line 437
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
struct filenode *newnode(char const   *base , char const   *name , int curroffset ) 
{ 
  struct filenode *node ;
  int len ;
  char *str ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  struct filenode *tmp___6 ;

  {
  {
#line 445
  tmp = malloc(sizeof(*node));
#line 445
  node = (struct filenode *)tmp;
  }
#line 446
  if (! node) {
    {
#line 447
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"out of memory\n");
#line 448
    exit(1);
    }
  }
  {
#line 451
  tmp___0 = strlen(name);
#line 451
  len = (int )tmp___0;
#line 452
  tmp___1 = malloc((size_t )(len + 1));
#line 452
  str = (char *)tmp___1;
  }
#line 453
  if (! str) {
    {
#line 454
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"out of memory\n");
#line 455
    exit(1);
    }
  }
  {
#line 457
  strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)name);
#line 458
  node->name = str;
  }
#line 460
  if (! curroffset) {
#line 461
    len = 1;
#line 462
    name = ".";
  }
  {
#line 464
  tmp___2 = strlen(base);
  }
#line 464
  if (tmp___2) {
#line 465
    len ++;
  }
  {
#line 466
  tmp___3 = strlen(base);
#line 466
  tmp___4 = malloc((tmp___3 + (size_t )len) + 1UL);
#line 466
  str = (char *)tmp___4;
  }
#line 467
  if (! str) {
    {
#line 468
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"out of memory\n");
#line 469
    exit(1);
    }
  }
  {
#line 471
  tmp___5 = strlen(base);
  }
#line 471
  if (tmp___5) {
    {
#line 472
    sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%s/%s",
            base, name);
    }
  } else {
    {
#line 474
    strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)name);
    }
  }
  {
#line 477
  node->realname = str;
#line 478
  tmp___6 = (struct filenode *)((void *)0);
#line 478
  node->prev = tmp___6;
#line 478
  node->next = tmp___6;
#line 479
  node->parent = (struct filenode *)((void *)0);
#line 480
  initlist(& node->dirlist, node);
#line 482
  node->ondev = (dev_t )-1;
#line 483
  node->onino = (ino_t )-1;
#line 484
  node->modes = (mode_t )-1;
#line 485
  node->size = 0U;
#line 486
  node->devnode = (dev_t )0;
#line 487
  node->orig_link = (struct filenode *)((void *)0);
#line 488
  node->offset = (unsigned int )curroffset;
#line 489
  node->pad = 0U;
  }
#line 491
  return (node);
}
}
#line 494 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
struct filenode *findnode(struct filenode *node , dev_t dev , ino_t ino ) 
{ 
  struct filenode *found ;
  struct filenode *p ;

  {
#line 499
  if (node->ondev == dev) {
#line 499
    if (node->onino == ino) {
#line 500
      return (node);
    }
  }
#line 501
  p = node->dirlist.head;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! p->next) {
#line 502
      goto while_break;
    }
    {
#line 503
    found = findnode(p, dev, ino);
    }
#line 504
    if (found) {
#line 505
      return (found);
    }
#line 506
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 508
  return ((struct filenode *)((void *)0));
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
int spaceneeded(struct filenode *node ) 
{ 
  size_t tmp ;

  {
  {
#line 515
  tmp = strlen((char const   *)node->name);
  }
#line 515
  return ((int )((16UL + (((tmp + 1UL) + 15UL) & 0xfffffffffffffff0UL)) + (unsigned long )((node->size + 15U) & 4294967280U)));
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
int alignnode(struct filenode *node , int curroffset , int extraspace ) 
{ 
  int align___0 ;
  int tmp ;
  int d ;

  {
  {
#line 520
  tmp = findalign(node);
#line 520
  align___0 = tmp;
#line 522
  d = (curroffset + extraspace) & (align___0 - 1);
  }
#line 523
  if (d) {
#line 524
    align___0 -= d;
#line 525
    curroffset += align___0;
#line 526
    node->offset += (unsigned int )align___0;
#line 527
    node->pad = (unsigned int )align___0;
  }
#line 529
  return (curroffset);
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
int processdir(int level , char const   *base , char const   *dirname , struct stat *sb ,
               struct filenode *dir , struct filenode *root , int curroffset ) 
{ 
  DIR *dirfd___0 ;
  struct dirent *dp ;
  struct filenode *n ;
  struct filenode *link___0 ;
  struct excludes *pe ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char devname[32] ;
  char type ;
  int major ;
  int minor ;
  unsigned long long tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 540
  if (level <= 1) {
    {
#line 545
    link___0 = newnode(base, ".", curroffset);
#line 546
    tmp___4 = lstat((char const   */* __restrict  */)link___0->realname, (struct stat */* __restrict  */)sb);
    }
#line 546
    if (! tmp___4) {
      {
#line 547
      setnode(link___0, sb->st_dev, sb->st_ino, sb->st_mode);
#line 548
      append(& dir->dirlist, link___0);
#line 553
      dir->dirlist.owner = link___0;
#line 555
      tmp = alignnode(link___0, curroffset, 0);
#line 555
      tmp___0 = spaceneeded(link___0);
#line 555
      curroffset = tmp + tmp___0;
#line 556
      n = newnode(base, "..", curroffset);
#line 558
      tmp___3 = lstat((char const   */* __restrict  */)n->realname, (struct stat */* __restrict  */)sb);
      }
#line 558
      if (! tmp___3) {
        {
#line 559
        setnode(n, sb->st_dev, sb->st_ino, sb->st_mode);
#line 560
        append(& dir->dirlist, n);
#line 561
        n->orig_link = link___0;
#line 562
        tmp___1 = alignnode(n, curroffset, 0);
#line 562
        tmp___2 = spaceneeded(n);
#line 562
        curroffset = tmp___1 + tmp___2;
        }
      }
    }
  }
  {
#line 567
  dirfd___0 = opendir((char const   *)dir->realname);
  }
#line 568
  if ((unsigned long )dirfd___0 == (unsigned long )((void *)0)) {
    {
#line 569
    perror((char const   *)dir->realname);
    }
  }
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (dirfd___0) {
      {
#line 571
      dp = readdir(dirfd___0);
      }
#line 571
      if (! dp) {
#line 571
        goto while_break;
      }
    } else {
#line 571
      goto while_break;
    }
#line 573
    if (level <= 1) {
      {
#line 573
      tmp___5 = strcmp((char const   *)(dp->d_name), ".");
      }
#line 573
      if (tmp___5 == 0) {
#line 576
        goto while_continue;
      } else {
        {
#line 573
        tmp___6 = strcmp((char const   *)(dp->d_name), "..");
        }
#line 573
        if (tmp___6 == 0) {
#line 576
          goto while_continue;
        }
      }
    }
    {
#line 577
    n = newnode(base, (char const   *)(dp->d_name), curroffset);
#line 580
    pe = excludelist;
    }
    {
#line 580
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 580
      if (! pe) {
#line 580
        goto while_break___0;
      }
      {
#line 581
      tmp___7 = nodematch(pe->pattern, n);
      }
#line 581
      if (! tmp___7) {
        {
#line 581
        freenode(n);
        }
#line 581
        goto while_break___0;
      }
#line 580
      pe = pe->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 583
    if (pe) {
#line 583
      goto while_continue;
    }
    {
#line 585
    tmp___8 = lstat((char const   */* __restrict  */)n->realname, (struct stat */* __restrict  */)sb);
    }
#line 585
    if (tmp___8) {
      {
#line 586
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ignoring \'%s\' (lstat failed)\n",
              n->realname);
#line 587
      freenode(n);
      }
#line 587
      goto while_continue;
    }
#line 591
    if ((int )*(n->name + 0) == 64) {
#line 592
      if ((sb->st_mode & 61440U) == 40960U) {
        {
#line 594
        (n->name) ++;
#line 595
        memset((void *)(bigbuf), 0, sizeof(bigbuf));
#line 596
        readlink((char const   */* __restrict  */)n->realname, (char */* __restrict  */)(bigbuf),
                 sizeof(bigbuf));
#line 597
        n->realname = strdup((char const   *)(bigbuf));
#line 599
        tmp___9 = lstat((char const   */* __restrict  */)n->realname, (struct stat */* __restrict  */)sb);
        }
#line 599
        if (tmp___9) {
          {
#line 600
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ignoring \'%s\' (lstat failed)\n",
                  n->realname);
#line 602
          freenode(n);
          }
#line 602
          goto while_continue;
        }
      } else
#line 604
      if ((sb->st_mode & 61440U) == 32768U) {
#line 604
        if (sb->st_size == 0L) {
          {
#line 613
          tmp___11 = sscanf((char const   */* __restrict  */)n->name, (char const   */* __restrict  */)"@%[a-zA-Z0-9_+-],%c,%d,%d",
                            devname, & type, & major, & minor);
          }
#line 613
          if (tmp___11 == 4) {
            {
#line 615
            strcpy((char */* __restrict  */)n->name, (char const   */* __restrict  */)(devname));
#line 616
            tmp___10 = gnu_dev_makedev((unsigned int )major, (unsigned int )minor);
#line 616
            sb->st_rdev = (__dev_t )tmp___10;
#line 617
            sb->st_mode &= 4294905855U;
            }
            {
#line 620
            if ((int )type == 117) {
#line 620
              goto case_117;
            }
#line 620
            if ((int )type == 99) {
#line 620
              goto case_117;
            }
#line 623
            if ((int )type == 98) {
#line 623
              goto case_98;
            }
#line 626
            if ((int )type == 112) {
#line 626
              goto case_112;
            }
#line 629
            goto switch_default;
            case_117: /* CIL Label */ 
            case_99: /* CIL Label */ 
#line 621
            sb->st_mode |= 8192U;
#line 622
            goto switch_break;
            case_98: /* CIL Label */ 
#line 624
            sb->st_mode |= 24576U;
#line 625
            goto switch_break;
            case_112: /* CIL Label */ 
#line 627
            sb->st_mode |= 4096U;
#line 628
            goto switch_break;
            switch_default: /* CIL Label */ 
            {
#line 630
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid special device type \'%c\' for file %s\n",
                    (int )type, n->realname);
#line 632
            freenode(n);
            }
#line 633
            goto while_continue;
            switch_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
    {
#line 639
    setnode(n, sb->st_dev, sb->st_ino, sb->st_mode);
    }
#line 641
    if (! ((n->modes & 61440U) == 40960U)) {
      {
#line 641
      tmp___12 = access((char const   *)n->realname, 4);
      }
#line 641
      if (tmp___12) {
        {
#line 642
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ignoring \'%s\' (access failed)\n",
                n->realname);
#line 643
        freenode(n);
        }
#line 643
        goto while_continue;
      }
    }
    {
#line 647
    tmp___14 = strcmp((char const   *)n->name, ".");
    }
#line 647
    if (tmp___14 == 0) {
      {
#line 648
      append(& dir->dirlist, n);
#line 649
      link___0 = n->parent;
      }
    } else {
      {
#line 650
      tmp___13 = strcmp((char const   *)n->name, "..");
      }
#line 650
      if (tmp___13 == 0) {
        {
#line 651
        append(& dir->dirlist, n);
#line 652
        link___0 = (n->parent)->parent;
        }
      } else {
        {
#line 654
        link___0 = findnode(root, n->ondev, n->onino);
#line 655
        append(& dir->dirlist, n);
        }
      }
    }
#line 658
    if (link___0) {
      {
#line 659
      n->orig_link = link___0;
#line 660
      tmp___15 = alignnode(n, curroffset, 0);
#line 660
      tmp___16 = spaceneeded(n);
#line 660
      curroffset = tmp___15 + tmp___16;
      }
#line 661
      goto while_continue;
    }
#line 663
    if ((sb->st_mode & 61440U) == 32768U) {
      {
#line 664
      tmp___17 = spaceneeded(n);
#line 664
      curroffset = alignnode(n, curroffset, tmp___17);
#line 665
      n->size = (unsigned int )sb->st_size;
      }
    } else {
      {
#line 667
      curroffset = alignnode(n, curroffset, 0);
      }
    }
#line 668
    if ((sb->st_mode & 61440U) == 40960U) {
#line 669
      n->size = (unsigned int )sb->st_size;
    }
    {
#line 671
    tmp___18 = spaceneeded(n);
#line 671
    curroffset += tmp___18;
    }
#line 672
    if ((sb->st_mode & 61440U) == 8192U) {
#line 673
      n->devnode = sb->st_rdev;
    } else
#line 672
    if ((sb->st_mode & 61440U) == 24576U) {
#line 673
      n->devnode = sb->st_rdev;
    }
#line 676
    if ((sb->st_mode & 61440U) == 16384U) {
      {
#line 677
      tmp___19 = strcmp((char const   *)n->name, "..");
      }
#line 677
      if (tmp___19) {
        {
#line 681
        curroffset = processdir(level + 1, (char const   *)n->realname, (char const   *)(dp->d_name),
                                sb, n, root, curroffset);
        }
      } else {
        {
#line 678
        curroffset = processdir(level + 1, (char const   *)dir->realname, (char const   *)(dp->d_name),
                                sb, dir, root, curroffset);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if (dirfd___0) {
    {
#line 686
    closedir(dirfd___0);
    }
  }
#line 687
  return (curroffset);
}
}
#line 690 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
void showhelp(char const   *argv0 ) 
{ 


  {
  {
#line 692
  printf((char const   */* __restrict  */)"genromfs %s\n", "0.5.2");
#line 693
  printf((char const   */* __restrict  */)"Usage: %s [OPTIONS] -f IMAGE\n", argv0);
#line 694
  printf((char const   */* __restrict  */)"Create a romfs filesystem image from a directory\n");
#line 695
  printf((char const   */* __restrict  */)"\n");
#line 696
  printf((char const   */* __restrict  */)"  -f IMAGE               Output the image into this file\n");
#line 697
  printf((char const   */* __restrict  */)"  -d DIRECTORY           Use this directory as source\n");
#line 698
  printf((char const   */* __restrict  */)"  -v                     (Too) verbose operation\n");
#line 699
  printf((char const   */* __restrict  */)"  -V VOLUME              Use the specified volume name\n");
#line 700
  printf((char const   */* __restrict  */)"  -a ALIGN               Align regular file data to ALIGN bytes\n");
#line 701
  printf((char const   */* __restrict  */)"  -A ALIGN,PATTERN       Align all objects matching pattern to at least ALIGN bytes\n");
#line 702
  printf((char const   */* __restrict  */)"  -x PATTERN             Exclude all objects matching pattern\n");
#line 703
  printf((char const   */* __restrict  */)"  -h                     Show this help\n");
#line 704
  printf((char const   */* __restrict  */)"\n");
#line 705
  printf((char const   */* __restrict  */)"Report bugs to chexum@shadow.banki.hu\n");
  }
#line 706
  return;
}
}
#line 708 "/home/june/repo/benchmarks/collector/temp/genromfs-0.5.2/genromfs.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  char *dir ;
  char *volname ;
  int verbose ;
  char buf[256] ;
  struct filenode *root ;
  struct stat sb ;
  int lastoff ;
  int i ;
  char *p ;
  struct aligns *pa ;
  struct aligns *pa2 ;
  struct excludes *pe ;
  struct excludes *pe2 ;
  FILE *f ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  time_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
#line 711
  dir = (char *)".";
#line 712
  volname = (char *)((void *)0);
#line 713
  verbose = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 724
    c = getopt(argc, (char * const  *)argv, "V:vd:f:ha:A:x:");
    }
#line 724
    if (! (c != -1)) {
#line 724
      goto while_break;
    }
    {
#line 726
    if (c == 100) {
#line 726
      goto case_100;
    }
#line 729
    if (c == 102) {
#line 729
      goto case_102;
    }
#line 732
    if (c == 86) {
#line 732
      goto case_86;
    }
#line 735
    if (c == 118) {
#line 735
      goto case_118;
    }
#line 738
    if (c == 104) {
#line 738
      goto case_104;
    }
#line 741
    if (c == 97) {
#line 741
      goto case_97;
    }
#line 748
    if (c == 65) {
#line 748
      goto case_65;
    }
#line 771
    if (c == 120) {
#line 771
      goto case_120;
    }
#line 783
    goto switch_default;
    case_100: /* CIL Label */ 
#line 727
    dir = optarg;
#line 728
    goto switch_break;
    case_102: /* CIL Label */ 
#line 730
    outf = optarg;
#line 731
    goto switch_break;
    case_86: /* CIL Label */ 
#line 733
    volname = optarg;
#line 734
    goto switch_break;
    case_118: /* CIL Label */ 
#line 736
    verbose = 1;
#line 737
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 739
    showhelp((char const   *)*(argv + 0));
#line 740
    exit(0);
    }
    case_97: /* CIL Label */ 
    {
#line 742
    tmp = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                  0);
#line 742
    align = (int )tmp;
    }
#line 743
    if (align < 16) {
      {
#line 744
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Align has to be at least 16 bytes and a power of two\n");
#line 745
      exit(1);
      }
    } else
#line 743
    if (align & (align - 1)) {
      {
#line 744
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Align has to be at least 16 bytes and a power of two\n");
#line 745
      exit(1);
      }
    }
#line 747
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 749
    tmp___0 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& p),
                      0);
#line 749
    i = (int )tmp___0;
    }
#line 750
    if (i < 16) {
      {
#line 751
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Align has to be at least 16 bytes and a power of two\n");
#line 752
      exit(1);
      }
    } else
#line 750
    if (i & (i - 1)) {
      {
#line 751
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Align has to be at least 16 bytes and a power of two\n");
#line 752
      exit(1);
      }
    }
#line 754
    if ((int )*p != 44) {
      {
#line 755
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-A takes N,PATTERN format of argument, where N is a number\n");
#line 756
      exit(1);
      }
    } else
#line 754
    if (! *(p + 1)) {
      {
#line 755
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-A takes N,PATTERN format of argument, where N is a number\n");
#line 756
      exit(1);
      }
    }
    {
#line 759
    tmp___1 = strlen((char const   *)p);
#line 759
    tmp___2 = malloc(sizeof(*pa) + tmp___1);
#line 759
    pa = (struct aligns *)tmp___2;
#line 760
    pa->align = i;
#line 761
    pa->next = (struct aligns *)((void *)0);
#line 762
    strcpy((char */* __restrict  */)(pa->pattern), (char const   */* __restrict  */)(p + 1));
    }
#line 763
    if (! alignlist) {
#line 764
      alignlist = pa;
    } else {
#line 766
      pa2 = alignlist;
      {
#line 766
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 766
        if (! pa2->next) {
#line 766
          goto while_break___0;
        }
#line 766
        pa2 = pa2->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 768
      pa2->next = pa;
    }
#line 770
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 772
    tmp___3 = strlen((char const   *)optarg);
#line 772
    tmp___4 = malloc((sizeof(*pe) + tmp___3) + 1UL);
#line 772
    pe = (struct excludes *)tmp___4;
#line 773
    pe->next = (struct excludes *)((void *)0);
#line 774
    strcpy((char */* __restrict  */)(pe->pattern), (char const   */* __restrict  */)optarg);
    }
#line 775
    if (! excludelist) {
#line 776
      excludelist = pe;
    } else {
#line 778
      pe2 = excludelist;
      {
#line 778
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 778
        if (! pe2->next) {
#line 778
          goto while_break___1;
        }
#line 778
        pe2 = pe2->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 780
      pe2->next = pe;
    }
#line 782
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 784
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 788
  if (! volname) {
    {
#line 789
    tmp___5 = time((time_t *)((void *)0));
#line 789
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"rom %08lx",
            tmp___5);
#line 790
    volname = buf;
    }
  }
#line 792
  if (! outf) {
    {
#line 793
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: you must specify the destination file\n",
            *(argv + 0));
#line 794
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s -h\' for more information\n",
            *(argv + 0));
#line 795
    exit(1);
    }
  }
  {
#line 797
  tmp___6 = strcmp((char const   *)outf, "-");
  }
#line 797
  if (tmp___6 == 0) {
    {
#line 798
    f = fdopen(1, "wb");
    }
  } else {
    {
#line 800
    f = fopen((char const   */* __restrict  */)outf, (char const   */* __restrict  */)"wb");
    }
  }
#line 802
  if (! f) {
    {
#line 803
    perror((char const   *)outf);
#line 804
    exit(1);
    }
  }
  {
#line 807
  tmp___7 = strlen((char const   *)dir);
#line 807
  realbase = (int )tmp___7;
#line 808
  root = newnode((char const   *)dir, (char const   *)volname, 0);
#line 809
  root->parent = root;
#line 810
  tmp___8 = spaceneeded(root);
#line 810
  lastoff = processdir(1, (char const   *)dir, (char const   *)dir, & sb, root, root,
                       tmp___8);
  }
#line 811
  if (verbose) {
    {
#line 812
    shownode(0, root, stderr);
    }
  }
  {
#line 813
  dumpall(root, lastoff, f);
#line 815
  exit(0);
  }
}
}
