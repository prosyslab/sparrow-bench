/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 32 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.h"
struct food {
   int ndb_no ;
   int fdgrp ;
   int food_no ;
   char name[61] ;
   float qty ;
   char unit[51] ;
   int refuse ;
   float prot_cal_factor ;
   float fat_cal_factor ;
   float cho_cal_factor ;
   float grams ;
   float nutrient[159] ;
   struct food *next ;
};
#line 28 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.h"
struct meal {
   char meal_date[9] ;
   char meal ;
   int ndb_no ;
   int food_no ;
   float grams ;
   struct meal *next ;
};
#line 28 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.h"
struct opt {
   int delopt ;
   int defanal ;
   int defanalanal ;
   int defanalrec ;
   int screen ;
   int custom ;
   float pcprotein ;
   float pccarb ;
   float pcsatfat ;
   float carbcalpergm ;
   float protcalpergm ;
   float fatcalpergm ;
   float fattyacidfactor ;
   float n6hufa ;
   float epadhamax ;
   int next_recipe ;
   int locknuts[159] ;
   float abnuts[159] ;
   int mealsperday ;
   char grams ;
   char autocal ;
   struct meal *temp_meal_root ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 42 "/home/wheatley/newnew/temp/nut-nutrition-15.5/trendy.c"
struct ep {
   char period[9] ;
   float nutrient[159] ;
   int mealcount ;
   struct ep *next ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 39 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
struct __anonstruct_wjl_ieee754_float_t_be_9 {
   unsigned int sign : 1 ;
   unsigned int exponent : 8 ;
   unsigned int mantissa : 23 ;
};
#line 39 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
typedef struct __anonstruct_wjl_ieee754_float_t_be_9 wjl_ieee754_float_t_be;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long __tm_gmtoff ;
   char const   *__tm_zone ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 49 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.h"
struct food *FoodIndex[9000] ;
#line 53
float DV[159] ;
#line 81
struct food *food_number(int i ) ;
#line 82
int find_ndbno(int ndbno ) ;
#line 38 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.h"
struct meal meal_root  ;
#line 38 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.h"
struct meal theusual_root  ;
#line 38 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.h"
struct meal *new_meal  ;
#line 38 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.h"
struct meal *new_theusual  ;
#line 39
void order_new_meal(void) ;
#line 40
void order_new_theusual(void) ;
#line 41
struct meal *theusual_choice(char *screentitle , char *key___0 ) ;
#line 42
int meal_show(char *meal_date , int meal ) ;
#line 43
int theusual_show(char *meal_date ) ;
#line 44
struct meal *meal_find(char *meal_date , int meal ) ;
#line 45
struct meal *theusual_find(char *meal_date ) ;
#line 46
struct meal *prev_meal(struct meal *meal_after ) ;
#line 47
void modify_meal(char *meal_date , int meal , int num , char *qty ) ;
#line 48
void pcf(char *meal_date , int meal , char *substring ) ;
#line 49
void delete_meal_with_ptr(struct meal *target ) ;
#line 50
void modify_theusual(char *meal_date , int num , char *qty ) ;
#line 51
void delete_theusual_with_ptr(struct meal *target ) ;
#line 52
int meal_count(struct meal *meal_ptr ) ;
#line 53
void delete_meals(int keep ) ;
#line 54
int theusual_list(void) ;
#line 55
void meal_list(char *bufptr ) ;
#line 56
void reindex_meals(int foodnum ) ;
#line 57
void full_meal_reindexing(void) ;
#line 58
float average_cals(void) ;
#line 30 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.h"
void get_string(char *dest , int length ) ;
#line 32
float evaluate_qty(struct food *food_ptr , char *qtystring ) ;
#line 35
void spacer(int lines ) ;
#line 36
void header(char *string ) ;
#line 86 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.h"
struct opt options ;
#line 54 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.h"
int version(int level ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 34 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
void order_new_meal(void) 
{ 
  struct meal *meal_ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 36
  meal_ptr = & meal_root;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if ((unsigned long )meal_ptr->next != (unsigned long )((void *)0)) {
      {
#line 37
      tmp = strcmp((char const   *)(new_meal->meal_date), (char const   *)((meal_ptr->next)->meal_date));
      }
#line 37
      if (! (tmp < 0)) {
#line 37
        goto while_break;
      }
    } else {
#line 37
      goto while_break;
    }
#line 39
    meal_ptr = meal_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if ((unsigned long )meal_ptr->next != (unsigned long )((void *)0)) {
      {
#line 40
      tmp___0 = strcmp((char const   *)(new_meal->meal_date), (char const   *)((meal_ptr->next)->meal_date));
      }
#line 40
      if (tmp___0 <= 0) {
#line 40
        if (! ((int )new_meal->meal < (int )(meal_ptr->next)->meal)) {
#line 40
          goto while_break___0;
        }
      } else {
#line 40
        goto while_break___0;
      }
    } else {
#line 40
      goto while_break___0;
    }
#line 43
    meal_ptr = meal_ptr->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 44
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 44
    if ((unsigned long )meal_ptr->next != (unsigned long )((void *)0)) {
      {
#line 44
      tmp___1 = strcmp((char const   *)(new_meal->meal_date), (char const   *)((meal_ptr->next)->meal_date));
      }
#line 44
      if (tmp___1 <= 0) {
#line 44
        if ((int )new_meal->meal <= (int )(meal_ptr->next)->meal) {
          {
#line 44
          tmp___2 = strcmp((char const   *)((FoodIndex[new_meal->food_no])->name),
                           (char const   *)((FoodIndex[(meal_ptr->next)->food_no])->name));
          }
#line 44
          if (! (tmp___2 > 0)) {
#line 44
            goto while_break___1;
          }
        } else {
#line 44
          goto while_break___1;
        }
      } else {
#line 44
        goto while_break___1;
      }
    } else {
#line 44
      goto while_break___1;
    }
#line 48
    meal_ptr = meal_ptr->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 49
  new_meal->next = meal_ptr->next;
#line 50
  meal_ptr->next = new_meal;
#line 51
  return;
}
}
#line 53 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
void order_new_theusual(void) 
{ 
  struct meal *theusual_ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 55
  theusual_ptr = & theusual_root;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if ((unsigned long )theusual_ptr->next != (unsigned long )((void *)0)) {
      {
#line 56
      tmp = strcmp((char const   *)(new_theusual->meal_date), (char const   *)((theusual_ptr->next)->meal_date));
      }
#line 56
      if (! (tmp > 0)) {
#line 56
        goto while_break;
      }
    } else {
#line 56
      goto while_break;
    }
#line 58
    theusual_ptr = theusual_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 59
    if ((unsigned long )theusual_ptr->next != (unsigned long )((void *)0)) {
      {
#line 59
      tmp___0 = strcmp((char const   *)(new_theusual->meal_date), (char const   *)((theusual_ptr->next)->meal_date));
      }
#line 59
      if (tmp___0 >= 0) {
        {
#line 59
        tmp___1 = strcmp((char const   *)((FoodIndex[new_theusual->food_no])->name),
                         (char const   *)((FoodIndex[(theusual_ptr->next)->food_no])->name));
        }
#line 59
        if (! (tmp___1 > 0)) {
#line 59
          goto while_break___0;
        }
      } else {
#line 59
        goto while_break___0;
      }
    } else {
#line 59
      goto while_break___0;
    }
#line 62
    theusual_ptr = theusual_ptr->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 63
  new_theusual->next = theusual_ptr->next;
#line 64
  theusual_ptr->next = new_theusual;
#line 65
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
struct meal *theusual_choice(char *screentitle , char *key___0 ) 
{ 
  struct meal *theusual_ptr ;
  char meal_date[9] ;
  char new_meal_date[9] ;
  int c ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 73
  c = 8;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (c < 17)) {
#line 73
      goto while_break;
    }
#line 73
    meal_date[c - 8] = *(key___0 + c);
#line 73
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 76
    theusual_ptr = theusual_find(meal_date);
    }
#line 77
    if ((unsigned long )theusual_ptr != (unsigned long )((void *)0)) {
#line 77
      return (theusual_ptr);
    }
    {
#line 78
    header(screentitle);
#line 79
    tmp = theusual_list();
#line 79
    spacer(tmp - 1);
#line 80
    printf((char const   */* __restrict  */)"\nType \"The Usual\" Identifier (max. 8 characters):  ");
#line 81
    get_string(new_meal_date, 8);
#line 82
    tmp___0 = strlen((char const   *)(new_meal_date));
    }
#line 82
    if (tmp___0 == 0UL) {
#line 82
      return ((struct meal *)0);
    }
#line 83
    c = 0;
    {
#line 83
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 83
      if (! (c < 9)) {
#line 83
        goto while_break___1;
      }
      {
#line 83
      tmp___1 = toupper((int )new_meal_date[c]);
#line 83
      meal_date[c] = (char )tmp___1;
#line 83
      c ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 84
    theusual_ptr = theusual_find(meal_date);
    }
#line 85
    if ((unsigned long )theusual_ptr != (unsigned long )((void *)0)) {
#line 85
      return (theusual_ptr);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 89 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
int meal_show(char *meal_date , int meal ) 
{ 
  struct meal *meal_ptr ;
  char namebuf[60] ;
  int count ;
  int tmp ;

  {
  {
#line 91
  meal_ptr = & meal_root;
#line 93
  count = 0;
#line 94
  printf((char const   */* __restrict  */)"Meal Date:  %s                                            Meal Number:  %d\n\n",
         meal_date, meal);
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    tmp = strcmp((char const   *)meal_date, (char const   *)(meal_ptr->meal_date));
    }
#line 97
    if (tmp == 0) {
#line 97
      if (meal == (int )meal_ptr->meal) {
        {
#line 99
        count ++;
#line 100
        strncpy((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)((FoodIndex[meal_ptr->food_no])->name),
                (size_t )59);
#line 100
        namebuf[59] = (char )'\000';
        }
#line 101
        if (options.grams) {
          {
#line 101
          printf((char const   */* __restrict  */)"%2d. %-59s     %9.1f g\n", count,
                 namebuf, (double )meal_ptr->grams);
          }
        }
#line 102
        if (! options.grams) {
          {
#line 102
          printf((char const   */* __restrict  */)"%2d. %-59s     %8.1f oz\n", count,
                 namebuf, (double )meal_ptr->grams / 28.349523);
          }
        }
      }
    }
#line 104
    if ((unsigned long )meal_ptr->next == (unsigned long )((void *)0)) {
#line 104
      goto while_break;
    }
#line 105
    meal_ptr = meal_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  if (count == 0) {
    {
#line 109
    printf((char const   */* __restrict  */)"\n\n\nNo foods have yet been recorded for this meal.\n");
#line 110
    spacer(6);
    }
#line 111
    return (0);
  }
  {
#line 113
  spacer(count + 2);
  }
#line 114
  return (1);
}
}
#line 117 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
int theusual_show(char *meal_date ) 
{ 
  struct meal *theusual_ptr ;
  char namebuf[60] ;
  int count ;
  int tmp ;

  {
  {
#line 119
  theusual_ptr = & theusual_root;
#line 121
  count = 0;
#line 122
  printf((char const   */* __restrict  */)"\"The Usual\" Identifier:  %s\n\n", meal_date);
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 125
    tmp = strcmp((char const   *)meal_date, (char const   *)(theusual_ptr->meal_date));
    }
#line 125
    if (tmp == 0) {
      {
#line 127
      count ++;
#line 128
      strncpy((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)((FoodIndex[theusual_ptr->food_no])->name),
              (size_t )59);
#line 128
      namebuf[59] = (char )'\000';
      }
#line 129
      if (options.grams) {
        {
#line 129
        printf((char const   */* __restrict  */)"%2d. %-59s     %9.1f g\n", count,
               namebuf, (double )theusual_ptr->grams);
        }
      }
#line 130
      if (! options.grams) {
        {
#line 130
        printf((char const   */* __restrict  */)"%2d. %-59s     %8.1f oz\n", count,
               namebuf, (double )theusual_ptr->grams / 28.349523);
        }
      }
    }
#line 132
    if ((unsigned long )theusual_ptr->next == (unsigned long )((void *)0)) {
#line 132
      goto while_break;
    }
#line 133
    theusual_ptr = theusual_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  if (count == 0) {
    {
#line 137
    printf((char const   */* __restrict  */)"\n\n\nNo foods have yet been recorded for this customary meal.\n");
#line 138
    spacer(6);
    }
#line 139
    return (0);
  }
  {
#line 141
  spacer(count + 2);
  }
#line 142
  return (1);
}
}
#line 145 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
struct meal *meal_find(char *meal_date , int meal ) 
{ 
  struct meal *meal_ptr ;
  int tmp ;

  {
#line 147
  meal_ptr = & meal_root;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 148
      goto while_break;
    }
    {
#line 150
    meal_ptr = meal_ptr->next;
#line 151
    tmp = strcmp((char const   *)(meal_ptr->meal_date), (char const   *)meal_date);
    }
#line 151
    if (tmp == 0) {
#line 151
      if ((int )meal_ptr->meal == meal) {
#line 151
        return (meal_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return ((struct meal *)((void *)0));
}
}
#line 156 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
struct meal *theusual_find(char *meal_date ) 
{ 
  struct meal *theusual_ptr ;
  int tmp ;

  {
#line 158
  theusual_ptr = & theusual_root;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! ((unsigned long )theusual_ptr->next != (unsigned long )((void *)0))) {
#line 159
      goto while_break;
    }
    {
#line 161
    theusual_ptr = theusual_ptr->next;
#line 162
    tmp = strcmp((char const   *)(theusual_ptr->meal_date), (char const   *)meal_date);
    }
#line 162
    if (tmp == 0) {
#line 162
      return (theusual_ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return ((struct meal *)((void *)0));
}
}
#line 167 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
struct meal *prev_meal(struct meal *meal_after ) 
{ 
  struct meal *meal_ptr ;

  {
#line 169
  meal_ptr = & meal_root;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! ((unsigned long )meal_ptr->next != (unsigned long )meal_after)) {
#line 170
      goto while_break;
    }
#line 170
    meal_ptr = meal_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return (meal_ptr);
}
}
#line 174 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
void modify_meal(char *meal_date , int meal , int num , char *qty ) 
{ 
  struct meal *m ;
  struct meal *meal_ptr ;
  int count ;
  int nut ;
  float newqty ;
  float total ;
  float thiscontrib ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct food *tmp___6 ;
  int tmp___7 ;

  {
#line 176
  m = (struct meal *)((void *)0);
#line 176
  meal_ptr = & meal_root;
#line 177
  count = 0;
#line 177
  nut = -1;
#line 178
  total = (float )0;
#line 178
  thiscontrib = (float )0;
#line 179
  if ((unsigned long )qty != (unsigned long )((void *)0)) {
    {
#line 179
    tmp = strcmp((char const   *)qty, "protein");
    }
#line 179
    if (tmp == 0) {
#line 179
      nut = 0;
    }
  }
#line 180
  if ((unsigned long )qty != (unsigned long )((void *)0)) {
    {
#line 180
    tmp___0 = strcmp((char const   *)qty, "prot");
    }
#line 180
    if (tmp___0 == 0) {
#line 180
      nut = 0;
    }
  }
#line 181
  if ((unsigned long )qty != (unsigned long )((void *)0)) {
    {
#line 181
    tmp___4 = strcmp((char const   *)qty, "pro");
    }
#line 181
    if (tmp___4 == 0) {
#line 181
      nut = 0;
    } else {
#line 181
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 182
  if ((unsigned long )qty != (unsigned long )((void *)0)) {
    {
#line 182
    tmp___3 = strcmp((char const   *)qty, "carb");
    }
#line 182
    if (tmp___3 == 0) {
#line 182
      nut = 146;
    } else {
#line 182
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 183
  if ((unsigned long )qty != (unsigned long )((void *)0)) {
    {
#line 183
    tmp___2 = strcmp((char const   *)qty, "car");
    }
#line 183
    if (tmp___2 == 0) {
#line 183
      nut = 146;
    } else {
#line 183
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 184
  if ((unsigned long )qty != (unsigned long )((void *)0)) {
    {
#line 184
    tmp___1 = strcmp((char const   *)qty, "fat");
    }
#line 184
    if (tmp___1 == 0) {
#line 184
      nut = 1;
    }
  }
#line 185
  if (nut != -1) {
    {
#line 185
    while (1) {
      while_continue: /* CIL Label */ ;
#line 185
      if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 185
        goto while_break;
      }
      {
#line 187
      tmp___5 = strcmp((char const   *)meal_date, (char const   *)((meal_ptr->next)->meal_date));
      }
#line 187
      if (tmp___5 == 0) {
#line 187
        if (meal == (int )(meal_ptr->next)->meal) {
#line 189
          count ++;
#line 190
          if (count == num) {
#line 190
            m = meal_ptr;
          }
#line 191
          total += (((float )options.mealsperday * (meal_ptr->next)->grams) / (float )100) * (FoodIndex[(meal_ptr->next)->food_no])->nutrient[nut];
        }
      }
#line 193
      meal_ptr = meal_ptr->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 195
  if (nut != -1) {
#line 195
    if ((unsigned long )m != (unsigned long )((void *)0)) {
#line 197
      thiscontrib = (((float )options.mealsperday * (m->next)->grams) / (float )100) * (FoodIndex[(m->next)->food_no])->nutrient[nut];
#line 198
      newqty = (((thiscontrib + DV[nut]) - total) / thiscontrib) * (m->next)->grams;
#line 199
      if (newqty <= (float )0) {
        {
#line 201
        meal_ptr = m->next;
#line 202
        m->next = (m->next)->next;
#line 203
        free((void *)meal_ptr);
        }
      } else
#line 205
      if ((FoodIndex[(m->next)->food_no])->nutrient[nut] > (float )0) {
#line 205
        (m->next)->grams = newqty;
      }
#line 206
      return;
    }
  }
#line 208
  if (nut == -1) {
    {
#line 208
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 208
      if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 208
        goto while_break___0;
      }
      {
#line 210
      tmp___7 = strcmp((char const   *)meal_date, (char const   *)((meal_ptr->next)->meal_date));
      }
#line 210
      if (tmp___7 == 0) {
#line 210
        if (meal == (int )(meal_ptr->next)->meal) {
#line 212
          count ++;
#line 213
          if (count == num) {
            {
#line 215
            tmp___6 = food_number((meal_ptr->next)->food_no);
#line 215
            newqty = evaluate_qty(tmp___6, qty);
            }
#line 216
            if (newqty == (float )0) {
              {
#line 218
              m = meal_ptr->next;
#line 219
              meal_ptr->next = (meal_ptr->next)->next;
#line 220
              free((void *)m);
              }
            } else {
#line 222
              (meal_ptr->next)->grams = newqty;
            }
#line 223
            return;
          }
        }
      }
#line 226
      meal_ptr = meal_ptr->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 228
  return;
}
}
#line 230 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
void pcf(char *meal_date , int meal , char *substring ) 
{ 
  struct meal *start_ptr ;
  struct meal *end_ptr ;
  struct meal *p_ptr ;
  struct meal *c_ptr ;
  struct meal *f_ptr ;
  char buffer[128] ;
  char *token ;
  int p ;
  int c ;
  int f ;
  int count ;
  int i ;
  int j ;
  float contributors[3] ;
  float pcfmatrix[3][4] ;
  float whereweare ;
  int tmp ;
  int tmp___0 ;

  {
#line 232
  start_ptr = & meal_root;
#line 232
  p_ptr = (struct meal *)((void *)0);
#line 232
  c_ptr = (struct meal *)((void *)0);
#line 235
  count = 0;
#line 238
  i = 0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (i < 3)) {
#line 238
      goto while_break;
    }
#line 240
    contributors[i] = (float )0;
#line 241
    j = 0;
    {
#line 241
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 241
      if (! (j < 3)) {
#line 241
        goto while_break___0;
      }
#line 241
      pcfmatrix[i][j] = (float )0;
#line 241
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 238
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 244
  strncpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)substring,
          (size_t )127);
#line 245
  token = strtok((char */* __restrict  */)(buffer), (char const   */* __restrict  */)" ");
#line 247
  token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
  }
#line 248
  if ((unsigned long )token != (unsigned long )((void *)0)) {
    {
#line 248
    p = atoi((char const   *)token);
    }
  } else {
#line 249
    p = 0;
  }
  {
#line 251
  token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
  }
#line 252
  if ((unsigned long )token != (unsigned long )((void *)0)) {
    {
#line 252
    c = atoi((char const   *)token);
    }
  } else {
#line 253
    c = 0;
  }
  {
#line 255
  token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
  }
#line 256
  if ((unsigned long )token != (unsigned long )((void *)0)) {
    {
#line 256
    f = atoi((char const   *)token);
    }
  } else {
#line 257
    f = 0;
  }
#line 259
  if (p < 1) {
#line 259
    return;
  } else
#line 259
  if (c < 1) {
#line 259
    return;
  } else
#line 259
  if (f < 1) {
#line 259
    return;
  }
#line 260
  if (p == c) {
#line 260
    return;
  } else
#line 260
  if (p == f) {
#line 260
    return;
  } else
#line 260
  if (c == f) {
#line 260
    return;
  }
  {
#line 262
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 262
    if (! ((unsigned long )start_ptr != (unsigned long )((void *)0))) {
#line 262
      goto while_break___1;
    }
    {
#line 264
    tmp = strcmp((char const   *)((start_ptr->next)->meal_date), (char const   *)meal_date);
    }
#line 264
    if (tmp == 0) {
#line 264
      if ((int )(start_ptr->next)->meal == meal) {
#line 264
        goto while_break___1;
      }
    }
#line 265
    start_ptr = start_ptr->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 268
  if ((unsigned long )start_ptr == (unsigned long )((void *)0)) {
#line 268
    return;
  }
#line 270
  end_ptr = start_ptr;
#line 271
  p_ptr = (struct meal *)((void *)0);
#line 272
  c_ptr = (struct meal *)((void *)0);
#line 273
  f_ptr = (struct meal *)((void *)0);
  {
#line 275
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 275
    if (! ((unsigned long )end_ptr != (unsigned long )((void *)0))) {
#line 275
      goto while_break___2;
    }
#line 277
    count ++;
#line 278
    if ((unsigned long )end_ptr->next == (unsigned long )((void *)0)) {
#line 278
      goto while_break___2;
    }
    {
#line 279
    tmp___0 = strcmp((char const   *)((end_ptr->next)->meal_date), (char const   *)meal_date);
    }
#line 279
    if (tmp___0 != 0) {
#line 279
      goto while_break___2;
    } else
#line 279
    if ((int )(end_ptr->next)->meal != meal) {
#line 279
      goto while_break___2;
    }
#line 280
    if (p == count) {
#line 282
      p_ptr = end_ptr->next;
#line 283
      pcfmatrix[0][0] = (((FoodIndex[p_ptr->food_no])->nutrient[0] / (float )100) / DV[0]) * (float )options.mealsperday;
#line 284
      pcfmatrix[0][1] = (((FoodIndex[p_ptr->food_no])->nutrient[146] / (float )100) / DV[146]) * (float )options.mealsperday;
#line 285
      pcfmatrix[0][2] = (((FoodIndex[p_ptr->food_no])->nutrient[1] / (float )100) / DV[1]) * (float )options.mealsperday;
#line 286
      pcfmatrix[0][3] = p_ptr->grams;
    } else
#line 288
    if (c == count) {
#line 290
      c_ptr = end_ptr->next;
#line 291
      pcfmatrix[1][0] = (((FoodIndex[c_ptr->food_no])->nutrient[0] / (float )100) / DV[0]) * (float )options.mealsperday;
#line 292
      pcfmatrix[1][1] = (((FoodIndex[c_ptr->food_no])->nutrient[146] / (float )100) / DV[146]) * (float )options.mealsperday;
#line 293
      pcfmatrix[1][2] = (((FoodIndex[c_ptr->food_no])->nutrient[1] / (float )100) / DV[1]) * (float )options.mealsperday;
#line 294
      pcfmatrix[1][3] = c_ptr->grams;
    } else
#line 296
    if (f == count) {
#line 298
      f_ptr = end_ptr->next;
#line 299
      pcfmatrix[2][0] = (((FoodIndex[f_ptr->food_no])->nutrient[0] / (float )100) / DV[0]) * (float )options.mealsperday;
#line 300
      pcfmatrix[2][1] = (((FoodIndex[f_ptr->food_no])->nutrient[146] / (float )100) / DV[146]) * (float )options.mealsperday;
#line 301
      pcfmatrix[2][2] = (((FoodIndex[f_ptr->food_no])->nutrient[1] / (float )100) / DV[1]) * (float )options.mealsperday;
#line 302
      pcfmatrix[2][3] = f_ptr->grams;
    } else {
#line 306
      contributors[0] += ((((FoodIndex[(end_ptr->next)->food_no])->nutrient[0] * (end_ptr->next)->grams) / (float )100) / DV[0]) * (float )options.mealsperday;
#line 307
      contributors[1] += ((((FoodIndex[(end_ptr->next)->food_no])->nutrient[146] * (end_ptr->next)->grams) / (float )100) / DV[146]) * (float )options.mealsperday;
#line 308
      contributors[2] += ((((FoodIndex[(end_ptr->next)->food_no])->nutrient[1] * (end_ptr->next)->grams) / (float )100) / DV[1]) * (float )options.mealsperday;
    }
#line 310
    end_ptr = end_ptr->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 313
  if ((unsigned long )end_ptr == (unsigned long )((void *)0)) {
#line 313
    return;
  }
#line 314
  if ((unsigned long )p_ptr == (unsigned long )((void *)0)) {
#line 314
    return;
  }
#line 315
  if ((unsigned long )c_ptr == (unsigned long )((void *)0)) {
#line 315
    return;
  }
#line 316
  if ((unsigned long )f_ptr == (unsigned long )((void *)0)) {
#line 316
    return;
  }
#line 319
  if (! (pcfmatrix[0][3] == pcfmatrix[0][3])) {
#line 319
    pcfmatrix[0][3] = (float )0;
  } else
#line 320
  if (pcfmatrix[0][3] > (float )100000) {
#line 320
    pcfmatrix[0][3] = (float )0;
  } else
#line 321
  if (pcfmatrix[0][3] < (float )-100000) {
#line 321
    pcfmatrix[0][3] = (float )0;
  }
#line 322
  if (! (pcfmatrix[1][3] == pcfmatrix[1][3])) {
#line 322
    pcfmatrix[1][3] = (float )0;
  } else
#line 323
  if (pcfmatrix[1][3] > (float )100000) {
#line 323
    pcfmatrix[1][3] = (float )0;
  } else
#line 324
  if (pcfmatrix[1][3] < (float )-100000) {
#line 324
    pcfmatrix[1][3] = (float )0;
  }
#line 325
  if (! (pcfmatrix[2][3] == pcfmatrix[2][3])) {
#line 325
    pcfmatrix[2][3] = (float )0;
  } else
#line 326
  if (pcfmatrix[2][3] > (float )100000) {
#line 326
    pcfmatrix[2][3] = (float )0;
  } else
#line 327
  if (pcfmatrix[2][3] < (float )-100000) {
#line 327
    pcfmatrix[2][3] = (float )0;
  }
#line 329
  i = 0;
  {
#line 329
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 329
    if (! (i < 400)) {
#line 329
      goto while_break___3;
    }
#line 331
    whereweare = ((contributors[0] + pcfmatrix[0][3] * pcfmatrix[0][0]) + pcfmatrix[1][3] * pcfmatrix[1][0]) + pcfmatrix[2][3] * pcfmatrix[2][0];
#line 332
    pcfmatrix[0][3] -= (whereweare - (float )1) / pcfmatrix[0][0];
#line 334
    whereweare = ((contributors[1] + pcfmatrix[0][3] * pcfmatrix[0][1]) + pcfmatrix[1][3] * pcfmatrix[1][1]) + pcfmatrix[2][3] * pcfmatrix[2][1];
#line 335
    pcfmatrix[1][3] -= (whereweare - (float )1) / pcfmatrix[1][1];
#line 337
    whereweare = ((contributors[2] + pcfmatrix[0][3] * pcfmatrix[0][2]) + pcfmatrix[1][3] * pcfmatrix[1][2]) + pcfmatrix[2][3] * pcfmatrix[2][2];
#line 338
    pcfmatrix[2][3] -= (whereweare - (float )1) / pcfmatrix[2][2];
#line 329
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 341
  p_ptr->grams = pcfmatrix[0][3];
#line 342
  c_ptr->grams = pcfmatrix[1][3];
#line 343
  f_ptr->grams = pcfmatrix[2][3];
#line 344
  return;
}
}
#line 346 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
void delete_meal_with_ptr(struct meal *target ) 
{ 
  struct meal *meal_ptr ;

  {
#line 348
  meal_ptr = & meal_root;
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 349
      goto while_break;
    }
#line 351
    if ((unsigned long )meal_ptr->next == (unsigned long )target) {
      {
#line 353
      meal_ptr->next = target->next;
#line 354
      free((void *)target);
      }
#line 355
      return;
    }
#line 357
    meal_ptr = meal_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  return;
}
}
#line 361 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
void delete_theusual_with_ptr(struct meal *target ) 
{ 
  struct meal *meal_ptr ;

  {
#line 363
  meal_ptr = & theusual_root;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 364
      goto while_break;
    }
#line 366
    if ((unsigned long )meal_ptr->next == (unsigned long )target) {
      {
#line 368
      meal_ptr->next = target->next;
#line 369
      free((void *)target);
      }
#line 370
      return;
    }
#line 372
    meal_ptr = meal_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return;
}
}
#line 376 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
void modify_theusual(char *meal_date , int num , char *qty ) 
{ 
  struct meal *m ;
  struct meal *theusual_ptr ;
  int count ;
  int nut ;
  float newqty ;
  float total ;
  float thiscontrib ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct food *tmp___6 ;
  int tmp___7 ;

  {
#line 378
  m = (struct meal *)((void *)0);
#line 378
  theusual_ptr = & theusual_root;
#line 379
  count = 0;
#line 379
  nut = -1;
#line 380
  total = (float )0;
#line 380
  thiscontrib = (float )0;
#line 381
  if ((unsigned long )qty != (unsigned long )((void *)0)) {
    {
#line 381
    tmp = strcmp((char const   *)qty, "protein");
    }
#line 381
    if (tmp == 0) {
#line 381
      nut = 0;
    }
  }
#line 382
  if ((unsigned long )qty != (unsigned long )((void *)0)) {
    {
#line 382
    tmp___0 = strcmp((char const   *)qty, "prot");
    }
#line 382
    if (tmp___0 == 0) {
#line 382
      nut = 0;
    }
  }
#line 383
  if ((unsigned long )qty != (unsigned long )((void *)0)) {
    {
#line 383
    tmp___4 = strcmp((char const   *)qty, "pro");
    }
#line 383
    if (tmp___4 == 0) {
#line 383
      nut = 0;
    } else {
#line 383
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 384
  if ((unsigned long )qty != (unsigned long )((void *)0)) {
    {
#line 384
    tmp___3 = strcmp((char const   *)qty, "carb");
    }
#line 384
    if (tmp___3 == 0) {
#line 384
      nut = 146;
    } else {
#line 384
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 385
  if ((unsigned long )qty != (unsigned long )((void *)0)) {
    {
#line 385
    tmp___2 = strcmp((char const   *)qty, "car");
    }
#line 385
    if (tmp___2 == 0) {
#line 385
      nut = 146;
    } else {
#line 385
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 386
  if ((unsigned long )qty != (unsigned long )((void *)0)) {
    {
#line 386
    tmp___1 = strcmp((char const   *)qty, "fat");
    }
#line 386
    if (tmp___1 == 0) {
#line 386
      nut = 1;
    }
  }
#line 387
  if (nut != -1) {
    {
#line 387
    while (1) {
      while_continue: /* CIL Label */ ;
#line 387
      if (! ((unsigned long )theusual_ptr->next != (unsigned long )((void *)0))) {
#line 387
        goto while_break;
      }
      {
#line 389
      tmp___5 = strcmp((char const   *)meal_date, (char const   *)((theusual_ptr->next)->meal_date));
      }
#line 389
      if (tmp___5 == 0) {
#line 391
        count ++;
#line 392
        if (count == num) {
#line 392
          m = theusual_ptr;
        }
#line 393
        total += (((float )options.mealsperday * (theusual_ptr->next)->grams) / (float )100) * (FoodIndex[(theusual_ptr->next)->food_no])->nutrient[nut];
      }
#line 395
      theusual_ptr = theusual_ptr->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 397
  if (nut != -1) {
#line 397
    if ((unsigned long )m != (unsigned long )((void *)0)) {
#line 399
      thiscontrib = (((float )options.mealsperday * (m->next)->grams) / (float )100) * (FoodIndex[(m->next)->food_no])->nutrient[nut];
#line 400
      newqty = (((thiscontrib + DV[nut]) - total) / thiscontrib) * (m->next)->grams;
#line 401
      if (newqty <= (float )0) {
        {
#line 403
        theusual_ptr = m->next;
#line 404
        m->next = (m->next)->next;
#line 405
        free((void *)theusual_ptr);
        }
      } else
#line 407
      if ((FoodIndex[(m->next)->food_no])->nutrient[nut] > (float )0) {
#line 407
        (m->next)->grams = newqty;
      }
#line 408
      return;
    }
  }
#line 410
  if (nut == -1) {
    {
#line 410
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 410
      if (! ((unsigned long )theusual_ptr->next != (unsigned long )((void *)0))) {
#line 410
        goto while_break___0;
      }
      {
#line 412
      tmp___7 = strcmp((char const   *)meal_date, (char const   *)((theusual_ptr->next)->meal_date));
      }
#line 412
      if (tmp___7 == 0) {
#line 414
        count ++;
#line 415
        if (count == num) {
          {
#line 417
          tmp___6 = food_number((theusual_ptr->next)->food_no);
#line 417
          newqty = evaluate_qty(tmp___6, qty);
          }
#line 418
          if (newqty == (float )0) {
            {
#line 420
            m = theusual_ptr->next;
#line 421
            theusual_ptr->next = (theusual_ptr->next)->next;
#line 422
            free((void *)m);
            }
          } else {
#line 424
            (theusual_ptr->next)->grams = newqty;
          }
#line 425
          return;
        }
      }
#line 428
      theusual_ptr = theusual_ptr->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 430
  return;
}
}
#line 432 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
int meal_count(struct meal *meal_ptr ) 
{ 
  int count ;
  char lastdate[9] ;
  int lastmeal ;
  int tmp ;

  {
#line 434
  count = 0;
#line 437
  if ((unsigned long )meal_ptr->next == (unsigned long )((void *)0)) {
#line 437
    return (0);
  }
  {
#line 438
  meal_ptr = meal_ptr->next;
#line 439
  strcpy((char */* __restrict  */)(lastdate), (char const   */* __restrict  */)(meal_ptr->meal_date));
#line 440
  lastmeal = (int )meal_ptr->meal;
#line 441
  count = 1;
  }
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    meal_ptr = meal_ptr->next;
#line 442
    if (! meal_ptr) {
#line 442
      goto while_break;
    }
    {
#line 444
    tmp = strcmp((char const   *)(lastdate), (char const   *)(meal_ptr->meal_date));
    }
#line 444
    if (tmp != 0) {
      {
#line 446
      count ++;
#line 447
      strcpy((char */* __restrict  */)(lastdate), (char const   */* __restrict  */)(meal_ptr->meal_date));
#line 448
      lastmeal = (int )meal_ptr->meal;
      }
    } else
#line 444
    if (lastmeal != (int )meal_ptr->meal) {
      {
#line 446
      count ++;
#line 447
      strcpy((char */* __restrict  */)(lastdate), (char const   */* __restrict  */)(meal_ptr->meal_date));
#line 448
      lastmeal = (int )meal_ptr->meal;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  return (count);
}
}
#line 454 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
void delete_meals(int keep ) 
{ 
  struct meal *meal_ptr ;
  struct meal *last_meal_ptr ;
  int count ;
  char meal_date[9] ;
  char meal ;
  int tmp ;

  {
#line 456
  meal_ptr = & meal_root;
#line 456
  last_meal_ptr = (struct meal *)((void *)0);
#line 457
  count = 0;
#line 458
  meal = (char)0;
#line 459
  if (keep < 0) {
#line 459
    return;
  }
  {
#line 460
  strcpy((char */* __restrict  */)(meal_date), (char const   */* __restrict  */)"");
  }
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (count <= keep) {
#line 461
      if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 461
        goto while_break;
      }
    } else {
#line 461
      goto while_break;
    }
    {
#line 463
    last_meal_ptr = meal_ptr;
#line 464
    meal_ptr = meal_ptr->next;
#line 465
    tmp = strcmp((char const   *)(meal_date), (char const   *)(meal_ptr->meal_date));
    }
#line 465
    if (tmp != 0) {
      {
#line 467
      count ++;
#line 468
      strcpy((char */* __restrict  */)(meal_date), (char const   */* __restrict  */)(meal_ptr->meal_date));
#line 469
      meal = meal_ptr->meal;
      }
    } else
#line 465
    if ((int )meal != (int )meal_ptr->meal) {
      {
#line 467
      count ++;
#line 468
      strcpy((char */* __restrict  */)(meal_date), (char const   */* __restrict  */)(meal_ptr->meal_date));
#line 469
      meal = meal_ptr->meal;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 472
  if (count <= keep) {
#line 472
    return;
  }
#line 473
  last_meal_ptr->next = (struct meal *)((void *)0);
  {
#line 474
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 474
    if (! ((unsigned long )meal_ptr != (unsigned long )((void *)0))) {
#line 474
      goto while_break___0;
    }
    {
#line 476
    last_meal_ptr = meal_ptr;
#line 477
    meal_ptr = meal_ptr->next;
#line 478
    free((void *)last_meal_ptr);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 480
  return;
}
}
#line 482 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
int theusual_list(void) 
{ 
  struct meal *theusual_ptr ;
  char last_meal_date[9] ;
  int c ;
  int tmp ;

  {
  {
#line 484
  theusual_ptr = & theusual_root;
#line 486
  c = 0;
#line 487
  last_meal_date[0] = (char )'\000';
#line 488
  printf((char const   */* __restrict  */)"Customary Meals so far:\n\n");
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! ((unsigned long )theusual_ptr->next != (unsigned long )((void *)0))) {
#line 489
      goto while_break;
    }
    {
#line 491
    theusual_ptr = theusual_ptr->next;
#line 492
    tmp = strcmp((char const   *)(last_meal_date), (char const   *)(theusual_ptr->meal_date));
    }
#line 492
    if (tmp == 0) {
#line 492
      goto while_continue;
    }
    {
#line 493
    strcpy((char */* __restrict  */)(last_meal_date), (char const   */* __restrict  */)(theusual_ptr->meal_date));
#line 494
    printf((char const   */* __restrict  */)" %-8s", theusual_ptr->meal_date);
#line 495
    c ++;
    }
#line 496
    if (c % 7 == 0) {
      {
#line 496
      printf((char const   */* __restrict  */)"\n");
      }
    } else {
      {
#line 497
      printf((char const   */* __restrict  */)"  ");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 499
  return (c / 7 + 3);
}
}
#line 502 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
void meal_list(char *bufptr ) 
{ 
  struct meal *meal_ptr ;
  int c ;
  int missing[20] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 504
  meal_ptr = & meal_root;
#line 507
  c = 0;
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (! (c < 20)) {
#line 507
      goto while_break;
    }
#line 507
    missing[c] = 0;
#line 507
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 508
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 508
    if ((unsigned long )meal_ptr->next != (unsigned long )((void *)0)) {
      {
#line 508
      tmp = strcmp((char const   *)bufptr, (char const   *)(meal_ptr->meal_date));
      }
#line 508
      if (! (tmp != 0)) {
#line 508
        goto while_break___0;
      }
    } else {
#line 508
      goto while_break___0;
    }
#line 508
    meal_ptr = meal_ptr->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 509
  if ((unsigned long )meal_ptr->next == (unsigned long )((void *)0)) {
    {
#line 509
    tmp___1 = strcmp((char const   *)bufptr, (char const   *)(meal_ptr->meal_date));
    }
#line 509
    if (tmp___1 != 0) {
#line 511
      c = options.mealsperday;
      {
#line 511
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 511
        if (! (c >= 1)) {
#line 511
          goto while_break___1;
        }
#line 513
        (missing[0]) ++;
#line 514
        missing[c] = 1;
#line 511
        c --;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 509
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 517
    c = options.mealsperday;
    {
#line 517
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 517
      if (! (c >= 1)) {
#line 517
        goto while_break___2;
      }
#line 519
      if (c != (int )meal_ptr->meal) {
#line 521
        (missing[0]) ++;
#line 522
        missing[c] = 1;
      }
      {
#line 524
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 524
        if (c == (int )meal_ptr->meal) {
#line 524
          if ((unsigned long )meal_ptr->next != (unsigned long )((void *)0)) {
            {
#line 524
            tmp___0 = strcmp((char const   *)bufptr, (char const   *)((meal_ptr->next)->meal_date));
            }
#line 524
            if (! (tmp___0 == 0)) {
#line 524
              goto while_break___3;
            }
          } else {
#line 524
            goto while_break___3;
          }
        } else {
#line 524
          goto while_break___3;
        }
#line 524
        meal_ptr = meal_ptr->next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 517
      c --;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 526
  if (missing[0] == 0) {
    {
#line 526
    printf((char const   */* __restrict  */)"\n\n\n");
    }
  } else {
    {
#line 529
    printf((char const   */* __restrict  */)"Missing Meals:\n\n");
#line 530
    c = 1;
    }
    {
#line 530
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 530
      if (! (c < 20)) {
#line 530
        goto while_break___4;
      }
#line 530
      if (missing[c] == 1) {
        {
#line 530
        printf((char const   */* __restrict  */)"%-4d", c);
        }
      }
#line 530
      c ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 531
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 533
  return;
}
}
#line 535 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
void reindex_meals(int foodnum ) 
{ 
  struct meal *meal_ptr ;

  {
#line 537
  meal_ptr = & meal_root;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 538
      goto while_break;
    }
#line 540
    meal_ptr = meal_ptr->next;
#line 541
    if (meal_ptr->food_no >= foodnum) {
#line 541
      (meal_ptr->food_no) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 543
  meal_ptr = & theusual_root;
  {
#line 544
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 544
    if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 544
      goto while_break___0;
    }
#line 546
    meal_ptr = meal_ptr->next;
#line 547
    if (meal_ptr->food_no >= foodnum) {
#line 547
      (meal_ptr->food_no) ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 549
  return;
}
}
#line 551 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
void full_meal_reindexing(void) 
{ 
  struct meal *meal_ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 553
  meal_ptr = & meal_root;
#line 554
  printf((char const   */* __restrict  */)"\nStarting to re-index meals...\n");
  }
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 555
      goto while_break;
    }
#line 557
    if ((meal_ptr->next)->ndb_no == 0) {
      {
#line 557
      tmp = version(0);
      }
#line 557
      if (tmp < 9) {
#line 557
        (meal_ptr->next)->ndb_no = 42231;
      }
    }
    {
#line 558
    (meal_ptr->next)->food_no = find_ndbno((meal_ptr->next)->ndb_no);
    }
    {
#line 559
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 559
      if (! ((meal_ptr->next)->food_no == -1)) {
#line 559
        goto while_break___0;
      }
      {
#line 561
      delete_meal_with_ptr(meal_ptr->next);
      }
#line 562
      if ((unsigned long )meal_ptr->next == (unsigned long )((void *)0)) {
#line 562
        goto while_break___0;
      }
#line 563
      if ((meal_ptr->next)->ndb_no == 0) {
        {
#line 563
        tmp___0 = version(0);
        }
#line 563
        if (tmp___0 < 9) {
#line 563
          (meal_ptr->next)->ndb_no = 42231;
        }
      }
      {
#line 564
      (meal_ptr->next)->food_no = find_ndbno((meal_ptr->next)->ndb_no);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 566
    if ((unsigned long )meal_ptr->next != (unsigned long )((void *)0)) {
#line 566
      meal_ptr = meal_ptr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  if (meal_ptr->ndb_no == 0) {
    {
#line 568
    tmp___1 = version(0);
    }
#line 568
    if (tmp___1 < 9) {
#line 568
      meal_ptr->ndb_no = 42231;
    }
  }
  {
#line 569
  meal_ptr->food_no = find_ndbno(meal_ptr->ndb_no);
  }
#line 570
  if (meal_ptr->food_no == -1) {
    {
#line 570
    delete_meal_with_ptr(meal_ptr);
    }
  }
#line 572
  meal_ptr = & theusual_root;
  {
#line 573
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 573
    if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 573
      goto while_break___1;
    }
#line 575
    if ((meal_ptr->next)->ndb_no == 0) {
      {
#line 575
      tmp___2 = version(0);
      }
#line 575
      if (tmp___2 < 9) {
#line 575
        (meal_ptr->next)->ndb_no = 42231;
      }
    }
    {
#line 576
    (meal_ptr->next)->food_no = find_ndbno((meal_ptr->next)->ndb_no);
    }
    {
#line 577
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 577
      if (! ((meal_ptr->next)->food_no == -1)) {
#line 577
        goto while_break___2;
      }
      {
#line 579
      delete_theusual_with_ptr(meal_ptr->next);
      }
#line 580
      if ((unsigned long )meal_ptr->next == (unsigned long )((void *)0)) {
#line 580
        return;
      }
#line 581
      if ((meal_ptr->next)->ndb_no == 0) {
        {
#line 581
        tmp___3 = version(0);
        }
#line 581
        if (tmp___3 < 9) {
#line 581
          (meal_ptr->next)->ndb_no = 42231;
        }
      }
      {
#line 582
      (meal_ptr->next)->food_no = find_ndbno((meal_ptr->next)->ndb_no);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 584
    if ((unsigned long )meal_ptr->next != (unsigned long )((void *)0)) {
#line 584
      meal_ptr = meal_ptr->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 586
  if (meal_ptr->ndb_no == 0) {
    {
#line 586
    tmp___4 = version(0);
    }
#line 586
    if (tmp___4 < 9) {
#line 586
      meal_ptr->ndb_no = 42231;
    }
  }
  {
#line 587
  meal_ptr->food_no = find_ndbno(meal_ptr->ndb_no);
  }
#line 588
  if (meal_ptr->food_no == -1) {
    {
#line 588
    delete_theusual_with_ptr(meal_ptr);
    }
  }
#line 589
  return;
}
}
#line 591 "/home/wheatley/newnew/temp/nut-nutrition-15.5/meal.c"
float average_cals(void) 
{ 
  struct meal *meal_ptr ;
  float calsum ;
  int count ;

  {
#line 593
  meal_ptr = & meal_root;
#line 594
  calsum = (float )0;
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;
#line 596
    if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 596
      goto while_break;
    }
#line 598
    meal_ptr = meal_ptr->next;
#line 599
    calsum += (meal_ptr->grams / (float )100) * (FoodIndex[meal_ptr->food_no])->nutrient[4];
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 601
  count = meal_count(& meal_root);
  }
#line 602
  if (count > 0) {
#line 602
    return ((calsum / (float )count) * (float )options.mealsperday);
  } else {
#line 603
    return ((float )2000);
  }
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 49 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.h"
struct food food_root  ;
#line 49 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.h"
struct food recipe_root  ;
#line 49 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.h"
struct food food_work  ;
#line 49 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.h"
struct food *new_food  ;
#line 49 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.h"
struct food *new_recipe  ;
#line 49 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.h"
struct food *FoodIndex[9000]  ;
#line 50
char *Nutrient[159] ;
#line 51
char *Unit[159] ;
#line 52
char *FdGrp[37] ;
#line 53 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.h"
float DV[159]  ;
#line 54 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.h"
float DVBase[159]  ;
#line 55 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.h"
float NoData  ;
#line 56
int DVMap[40] ;
#line 58
int CarbAminoMap[32] ;
#line 59
int MiscMap[34] ;
#line 60
int SatMonoMap[28] ;
#line 61
int PolyTransMap[30] ;
#line 62
int *ScreenMap[6] ;
#line 63
char *ScreenTitle[6] ;
#line 64
int FdGrpMap[26] ;
#line 65
int MaxScreen ;
#line 66
int MaxFdGrp ;
#line 67 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.h"
int LookupNutrNo[143]  ;
#line 68 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.h"
int LookupNut[859]  ;
#line 69
int FoodCount ;
#line 71
void initializations(void) ;
#line 72
int order_new_food(void) ;
#line 73
void order_new_food_already_sorted(void) ;
#line 74
int namestrcmp(char *name1 , char *name2 ) ;
#line 75
int substring_finder(char *food_name , char *substr ) ;
#line 76
struct food *food_choice(char *screentitle , int usual ) ;
#line 77
void food_subcat(char *substring , char *key___0 , struct food **ptrlist , int count ) ;
#line 78
void food_show(struct food *food_ptr , float *ratio ) ;
#line 79
void make_food_index(void) ;
#line 80
int modify_food_index(int foodnum , struct food *food_ptr ) ;
#line 83
struct food *find_ndbno_ptr(int ndbno ) ;
#line 84
void clear_work(void) ;
#line 85
void food_display(FILE *fp___0 ) ;
#line 86
void food_display_line(FILE *fp___0 , int nut , int dv , int eol , int precision ,
                       int indent ) ;
#line 87
void order_new_recipe(void) ;
#line 88
void modify_recipe_food(int num , char *qty ) ;
#line 89
void modify_label_food(int num , char *command ) ;
#line 90
void compute_derived_fields(struct food *food_ptr ) ;
#line 91
char *format_serving(char *buffer , float *ratio , struct food *food_ptr ) ;
#line 92
float n6hufa(float p3 , float p6 , float h3 , float h6 , float o , float c ) ;
#line 28 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.h"
int get_int(void) ;
#line 33
int evaluate_action(char *actionstring ) ;
#line 37
void key_clean(void) ;
#line 39
void key_encode(char *substring , char *key___0 ) ;
#line 40
char *key_take(void) ;
#line 41
void key_decode(char *substring , char *key___0 ) ;
#line 42
void test_signsense(float *value ) ;
#line 43
int test_for_negative_zero(float *value ) ;
#line 22 "/home/wheatley/newnew/temp/nut-nutrition-15.5/nutrient.h"
char *Nutrient[159]  = 
#line 22 "/home/wheatley/newnew/temp/nut-nutrition-15.5/nutrient.h"
  {      (char *)"Protein",      (char *)"Total Fat",      (char *)"Total Carb",      (char *)"Ash", 
        (char *)"Calories",      (char *)"Starch",      (char *)"Sucrose",      (char *)"Glucose", 
        (char *)"Fructose",      (char *)"Lactose",      (char *)"Maltose",      (char *)"Ethyl Alcohol", 
        (char *)"Water",      (char *)"Adj. Protein",      (char *)"Caffeine",      (char *)"Theobromine", 
        (char *)"Energy",      (char *)"Sugars",      (char *)"Galactose",      (char *)"Fiber", 
        (char *)"Calcium",      (char *)"Iron",      (char *)"Magnesium",      (char *)"Phosphorus", 
        (char *)"Potassium",      (char *)"Sodium",      (char *)"Zinc",      (char *)"Copper", 
        (char *)"Fluoride",      (char *)"Manganese",      (char *)"Selenium",      (char *)"Vitamin A", 
        (char *)"Retinol",      (char *)"Vit. A, RAE",      (char *)"B-Carotene",      (char *)"A-Carotene", 
        (char *)"A-Tocopherol",      (char *)"Vitamin D",      (char *)"Vitamin D2",      (char *)"Vitamin D3", 
        (char *)"Vitamin D2+D3",      (char *)"B-Cryptoxanth.",      (char *)"Lycopene",      (char *)"Lutein+Zeaxan.", 
        (char *)"B-Tocopherol",      (char *)"G-Tocopherol",      (char *)"D-Tocopherol",      (char *)"Vitamin C", 
        (char *)"Thiamin",      (char *)"Riboflavin",      (char *)"Niacin",      (char *)"Panto. Acid", 
        (char *)"Vitamin B-6",      (char *)"Folate",      (char *)"Vitamin B-12",      (char *)"Choline", 
        (char *)"Vitamin K",      (char *)"Folic Acid",      (char *)"Folate, food",      (char *)"Folate, DFE", 
        (char *)"Betaine",      (char *)"Tryptophan",      (char *)"Threonine",      (char *)"Isoleucine", 
        (char *)"Leucine",      (char *)"Lysine",      (char *)"Methionine",      (char *)"Cystine", 
        (char *)"Phenylalanine",      (char *)"Tyrosine",      (char *)"Valine",      (char *)"Arginine", 
        (char *)"Histidine",      (char *)"Alanine",      (char *)"Aspartic acid",      (char *)"Glutamic acid", 
        (char *)"Glycine",      (char *)"Proline",      (char *)"Serine",      (char *)"Hydroxyproline", 
        (char *)"Vit. E added",      (char *)"Vit. B12 added",      (char *)"Cholesterol",      (char *)"Trans Fat", 
        (char *)"Sat Fat",      (char *)"4:0",      (char *)"6:0",      (char *)"8:0", 
        (char *)"10:0",      (char *)"12:0",      (char *)"14:0",      (char *)"16:0", 
        (char *)"18:0",      (char *)"20:0",      (char *)"18:1",      (char *)"18:2", 
        (char *)"18:3",      (char *)"20:4",      (char *)"22:6n-3",      (char *)"22:0", 
        (char *)"14:1",      (char *)"16:1",      (char *)"18:4",      (char *)"20:1", 
        (char *)"20:5n-3",      (char *)"22:1",      (char *)"22:5n-3",      (char *)"Phytosterols", 
        (char *)"Stigmasterol",      (char *)"Campesterol",      (char *)"BetaSitosterol",      (char *)"Mono Fat", 
        (char *)"Poly Fat",      (char *)"15:0",      (char *)"17:0",      (char *)"24:0", 
        (char *)"16:1t",      (char *)"18:1t",      (char *)"22:1t",      (char *)"18:2t", 
        (char *)"18:2i",      (char *)"18:2t,t",      (char *)"18:2CLA",      (char *)"24:1c", 
        (char *)"20:2n-6c,c",      (char *)"16:1c",      (char *)"18:1c",      (char *)"18:2n-6c,c", 
        (char *)"22:1c",      (char *)"18:3n-6c,c,c",      (char *)"17:1",      (char *)"20:3", 
        (char *)"TransMonoenoic",      (char *)"TransPolyenoic",      (char *)"13:0",      (char *)"15:1", 
        (char *)"18:3n-3c,c,c",      (char *)"20:3n-3",      (char *)"20:3n-6",      (char *)"20:4n-6", 
        (char *)"18:3i",      (char *)"21:5",      (char *)"22:4",      (char *)"Protein Calories", 
        (char *)"Fat Calories",      (char *)"Carb Calories",      (char *)"Non-Fiber Carb",      (char *)"LA", 
        (char *)"AA",      (char *)"ALA",      (char *)"EPA",      (char *)"DHA", 
        (char *)"Omega-6",      (char *)"Short-chain Omega-6",      (char *)"Long-chain Omega-6",      (char *)"Omega-3", 
        (char *)"Short-chain Omega-3",      (char *)"Long-chain Omega-3",      (char *)"Vitamin E"};
#line 24 "/home/wheatley/newnew/temp/nut-nutrition-15.5/nutrient.h"
char *Unit[159]  = 
#line 24
  {      (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"kc",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"mg",      (char *)"mg", 
        (char *)"kJ",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"mg",      (char *)"mg",      (char *)"mg",      (char *)"mg", 
        (char *)"mg",      (char *)"mg",      (char *)"mg",      (char *)"mg", 
        (char *)"mcg",      (char *)"mg",      (char *)"mcg",      (char *)"IU", 
        (char *)"mcg",      (char *)"mcg",      (char *)"mcg",      (char *)"mcg", 
        (char *)"mg",      (char *)"IU",      (char *)"mcg",      (char *)"mcg", 
        (char *)"mcg",      (char *)"mcg",      (char *)"mcg",      (char *)"mcg", 
        (char *)"mg",      (char *)"mg",      (char *)"mg",      (char *)"mg", 
        (char *)"mg",      (char *)"mg",      (char *)"mg",      (char *)"mg", 
        (char *)"mg",      (char *)"mcg",      (char *)"mcg",      (char *)"mg", 
        (char *)"mcg",      (char *)"mcg",      (char *)"mcg",      (char *)"mcg", 
        (char *)"mg",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"mg",      (char *)"mcg",      (char *)"mg",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"mg", 
        (char *)"mg",      (char *)"mg",      (char *)"mg",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"kc", 
        (char *)"kc",      (char *)"kc",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"g",      (char *)"g", 
        (char *)"g",      (char *)"g",      (char *)"IU"};
#line 20 "/home/wheatley/newnew/temp/nut-nutrition-15.5/abbrev.h"
int Abbrev_Count  =    650;
#line 21 "/home/wheatley/newnew/temp/nut-nutrition-15.5/abbrev.h"
char *Abbreviations[650]  = 
#line 21
  {      (char *)"ABOUT",      (char *)"ABT",      (char *)"ACID",      (char *)"AC", 
        (char *)"ADDED",      (char *)"ADD",      (char *)"ALASKA",      (char *)"AK", 
        (char *)"ALMOND",      (char *)"ALMND",      (char *)"ALUMINUM",      (char *)"AL", 
        (char *)"AND",      (char *)"&",      (char *)"ANTIFOAMING",      (char *)"ANTIFOAM", 
        (char *)"APPLE",      (char *)"APPL",      (char *)"APPLES",      (char *)"APPLS", 
        (char *)"APPROXIMATELY",      (char *)"APPX",      (char *)"ARTIFICIAL",      (char *)"ART", 
        (char *)"ASPARTAME",      (char *)"ASPRT",      (char *)"AUSTRALIAN",      (char *)"AUS", 
        (char *)"BAKED",      (char *)"BKD",      (char *)"BAKING",      (char *)"BAK", 
        (char *)"BARBECUE-FLAVOR",      (char *)"BBQ",      (char *)"BEANS",      (char *)"BNS", 
        (char *)"BEEF",      (char *)"BF",      (char *)"BEGINNINGS",      (char *)"BGNINGS", 
        (char *)"BEVERAGE",      (char *)"BEV",      (char *)"BLADE",      (char *)"BLD", 
        (char *)"BLUEBERRY",      (char *)"BLUEBR",      (char *)"BOILED",      (char *)"BLD", 
        (char *)"BOILING",      (char *)"BLNG",      (char *)"BONELESS",      (char *)"BNLESS", 
        (char *)"BOTTLED",      (char *)"BTLD",      (char *)"BOTTOM",      (char *)"BTTM", 
        (char *)"BRAISED",      (char *)"BRSD",      (char *)"BREADING",      (char *)"BRDNG", 
        (char *)"BREAKFAST",      (char *)"BRKFST",      (char *)"BREAST",      (char *)"BRST", 
        (char *)"BROILED",      (char *)"BRLD",      (char *)"BROWN",      (char *)"BRN", 
        (char *)"BURGER",      (char *)"BRGR",      (char *)"BUTTER",      (char *)"BTR", 
        (char *)"BUTTERMILK",      (char *)"BTRMLK",      (char *)"CAFFEINE",      (char *)"CFFN", 
        (char *)"CALCIUM",      (char *)"CA",      (char *)"CALORIE",      (char *)"CAL", 
        (char *)"CANNED",      (char *)"CND",      (char *)"CARBONATED",      (char *)"CARB", 
        (char *)"CENTER",      (char *)"CNT",      (char *)"CEREAL",      (char *)"CRL", 
        (char *)"CEREALS",      (char *)"CRLS",      (char *)"CHEDDAR",      (char *)"CHEDR", 
        (char *)"CHEESE",      (char *)"CHS",      (char *)"CHEESEBURGER",      (char *)"CHSBRGR", 
        (char *)"CHERRY",      (char *)"CHRRY",      (char *)"CHICKEN",      (char *)"CHIC", 
        (char *)"CHOCOLATE",      (char *)"CHOC",      (char *)"CHOICE",      (char *)"CHOIC", 
        (char *)"CHOLESTEROL",      (char *)"CHOL",      (char *)"CHOLESTEROL-FREE",      (char *)"CHOL-FR", 
        (char *)"CHOPPED",      (char *)"CHOPD",      (char *)"CHOWDER",      (char *)"CHDR", 
        (char *)"CHUCK",      (char *)"CHK",      (char *)"CINNAMON",      (char *)"CINN", 
        (char *)"CLEAR",      (char *)"CLR",      (char *)"COATED",      (char *)"CTD", 
        (char *)"COCKTAIL",      (char *)"CKTL",      (char *)"COTTAGE-CUT",      (char *)"COTG-CUT", 
        (char *)"COMMON",      (char *)"CMN",      (char *)"COVERED",      (char *)"CVRD", 
        (char *)"COCONUT",      (char *)"COCNT",      (char *)"COMMERCIAL",      (char *)"COMM", 
        (char *)"COMMERCIALLY",      (char *)"COMMLY",      (char *)"COMMODITY",      (char *)"CMDTY", 
        (char *)"COMPOSITE",      (char *)"COMP",      (char *)"CONCENTRATE",      (char *)"CONC", 
        (char *)"CONDENSED",      (char *)"COND",      (char *)"CONDIMENTS",      (char *)"CONDMNT", 
        (char *)"CONTAINS",      (char *)"W/",      (char *)"COOK",      (char *)"CK", 
        (char *)"COOKED",      (char *)"CKD",      (char *)"COTTONSEED",      (char *)"CTTNSD", 
        (char *)"CREAM",      (char *)"CRM",      (char *)"CRINKLE",      (char *)"CRNKL", 
        (char *)"CRUST",      (char *)"CRST",      (char *)"CUISINE",      (char *)"CUIS", 
        (char *)"DARK",      (char *)"DK",      (char *)"DECAFFEINATED",      (char *)"DECAF", 
        (char *)"DECORTICATED",      (char *)"DECORT",      (char *)"DEHYDRATED",      (char *)"DEHYD", 
        (char *)"DESSERT",      (char *)"DSSRT",      (char *)"DESSERTS",      (char *)"DSSRT", 
        (char *)"DILUTED",      (char *)"DIL",      (char *)"DINOSAUR",      (char *)"DINO", 
        (char *)"DOMESTIC",      (char *)"DOM",      (char *)"DRAINED",      (char *)"DRND", 
        (char *)"DRESSING",      (char *)"DRSNG",      (char *)"DRINK",      (char *)"DRK", 
        (char *)"DRUMSTICK",      (char *)"DRUMSTK",      (char *)"ENCHILADA",      (char *)"ENCL", 
        (char *)"ENERGY",      (char *)"ENRGY",      (char *)"ENFAMIL",      (char *)"ENFML", 
        (char *)"ENGLAND",      (char *)"ENG",      (char *)"ENHANCED",      (char *)"ENH", 
        (char *)"ENRICHED",      (char *)"ENR",      (char *)"EQUAL",      (char *)"EQ", 
        (char *)"EXCEPT",      (char *)"XCPT",      (char *)"EXPRESS",      (char *)"EXP", 
        (char *)"EXTRA",      (char *)"EX",      (char *)"EXTRUDED",      (char *)"EXTRDED", 
        (char *)"FARMS",      (char *)"FM",      (char *)"FAT-FREE",      (char *)"FAT-FR", 
        (char *)"FILLING",      (char *)"FLLNG",      (char *)"FLAVOR",      (char *)"FLV", 
        (char *)"FLAVORED",      (char *)"FLAV",      (char *)"FLAVORING",      (char *)"FLVRNG", 
        (char *)"FLOUR",      (char *)"FLR",      (char *)"FLUID",      (char *)"FLD", 
        (char *)"FOODS",      (char *)"FDS",      (char *)"FORMULA",      (char *)"FRM", 
        (char *)"FORMULATED",      (char *)"FRMULTD",      (char *)"FORTIFIED",      (char *)"FORT", 
        (char *)"FREE",      (char *)"FR",      (char *)"FRENCH",      (char *)"FRCH", 
        (char *)"FRESH",      (char *)"FRS",      (char *)"FRESHLY",      (char *)"FRSH", 
        (char *)"FRIED",      (char *)"FRD",      (char *)"FROSTED",      (char *)"FRSTD", 
        (char *)"FROSTING",      (char *)"FRSTNG",      (char *)"FROZEN",      (char *)"FRZ", 
        (char *)"FRUCTOSE",      (char *)"FRCTSE",      (char *)"GIBLETS",      (char *)"GBLT", 
        (char *)"GELATIN",      (char *)"GEL",      (char *)"GENERAL",      (char *)"GENRL", 
        (char *)"GOLDEN",      (char *)"GLD",      (char *)"GRADES",      (char *)"GRDS", 
        (char *)"GRAM",      (char *)"GM",      (char *)"GRANULES",      (char *)"GRNLS", 
        (char *)"GRAPES",      (char *)"GRP",      (char *)"GRAVY",      (char *)"GVY", 
        (char *)"GREEN",      (char *)"GRN",      (char *)"GRILLED",      (char *)"GRLD", 
        (char *)"HEATED",      (char *)"HTD",      (char *)"HEAVY",      (char *)"HVY", 
        (char *)"HIGH",      (char *)"HI",      (char *)"HIGHER",      (char *)"HIGHER", 
        (char *)"HYDROGENATED",      (char *)"HYDR",      (char *)"III",      (char *)"3", 
        (char *)"IMITATION",      (char *)"IMITN",      (char *)"IMPORTED",      (char *)"IMP", 
        (char *)"INCLUDE",      (char *)"INC",      (char *)"INCLUDES",      (char *)"INC", 
        (char *)"INDUSTRIAL",      (char *)"INDST",      (char *)"INFANT",      (char *)"INF", 
        (char *)"INSTANT",      (char *)"INST",      (char *)"INTERNATIONAL",      (char *)"INTL", 
        (char *)"IRON",      (char *)"IR",      (char *)"ITALIAN",      (char *)"ITLN", 
        (char *)"JAWBREAKERS",      (char *)"JAWBRKR",      (char *)"JOHNSON",      (char *)"JNS", 
        (char *)"JUICE",      (char *)"JUC",      (char *)"KERNELS",      (char *)"KRNLS", 
        (char *)"LACTOFREE",      (char *)"LACTFR",      (char *)"LARGE",      (char *)"LRG", 
        (char *)"LEAN",      (char *)"LN",      (char *)"LEMON",      (char *)"LMN", 
        (char *)"LIGHT",      (char *)"LT",      (char *)"LINOLEIC",      (char *)"18:2", 
        (char *)"LIPIL",      (char *)"LPL",      (char *)"LIQUID",      (char *)"LIQ", 
        (char *)"LOW",      (char *)"LO",      (char *)"LOWER",      (char *)"LOWER", 
        (char *)"LUNCHEON",      (char *)"LUNCH",      (char *)"MARATHON",      (char *)"MRTHN", 
        (char *)"MARGARINE",      (char *)"MARG",      (char *)"MARSHMALLOW",      (char *)"MARSHMLLW", 
        (char *)"MASHED",      (char *)"MSH",      (char *)"MAYONNAISE",      (char *)"MAYO", 
        (char *)"MEAT",      (char *)"MT",      (char *)"MEDALLION",      (char *)"MDLLN", 
        (char *)"MEDIUM",      (char *)"MED",      (char *)"MEDLEY",      (char *)"MDLY", 
        (char *)"MESQUITE",      (char *)"MESQ",      (char *)"MEXICAN",      (char *)"MEX", 
        (char *)"MEXICAN-STYLE",      (char *)"MEX",      (char *)"MILKFAT",      (char *)"MLKFT", 
        (char *)"MIXED",      (char *)"MXD",      (char *)"MONTEREY",      (char *)"MONT", 
        (char *)"MUSHROOMS",      (char *)"MSHRM",      (char *)"NATURAL",      (char *)"NAT", 
        (char *)"NONFAT",      (char *)"NFT",      (char *)"NOUGATS",      (char *)"NOUG", 
        (char *)"NUGGETS",      (char *)"NUGTS",      (char *)"NUTRAMIGEN",      (char *)"NUTRMGN", 
        (char *)"NUTRIENTS",      (char *)"NUTR",      (char *)"OLD-FASHIONED",      (char *)"OLD-FSHN", 
        (char *)"ORANGE",      (char *)"ORNG",      (char *)"ORGANIC",      (char *)"ORG", 
        (char *)"ORIENTAL",      (char *)"ORNTL",      (char *)"ORIGINAL",      (char *)"ORIG", 
        (char *)"OUTSIDE",      (char *)"OUT",      (char *)"PACK",      (char *)"PK", 
        (char *)"PANTOTHENIC",      (char *)"PANTO",      (char *)"PARTIALLY",      (char *)"PART", 
        (char *)"PASTEURIZED",      (char *)"PAST",      (char *)"PEACHES",      (char *)"PCH", 
        (char *)"PEANUT",      (char *)"PNUT",      (char *)"PEKIN",      (char *)"PKN", 
        (char *)"PERFORMANCE",      (char *)"PERF",      (char *)"PHOSPHATE",      (char *)"PO4", 
        (char *)"PHOSPHORUS",      (char *)"P",      (char *)"PINEAPPLE",      (char *)"PNAPPL", 
        (char *)"PLAIN",      (char *)"PLN",      (char *)"PLUS",      (char *)"+", 
        (char *)"PORTERHOUSE",      (char *)"PRTRHS",      (char *)"POTASSIUM",      (char *)"K", 
        (char *)"POTATO",      (char *)"POT",      (char *)"POTATOES",      (char *)"POT", 
        (char *)"POWDER",      (char *)"PDR",      (char *)"PREPARED",      (char *)"PREP", 
        (char *)"PRESWEETENED",      (char *)"PRESWTND",      (char *)"PRINCIPAL",      (char *)"PRI", 
        (char *)"PROCESSING",      (char *)"PROC",      (char *)"PRODUCED",      (char *)"PROD", 
        (char *)"PRODUCT",      (char *)"PROD",      (char *)"PROPIONATE",      (char *)"PROP", 
        (char *)"PROTEIN",      (char *)"PROT",      (char *)"PUDDING",      (char *)"PUDD", 
        (char *)"PURCHASED",      (char *)"PURCH",      (char *)"RAISIN",      (char *)"RSN", 
        (char *)"RASPBERRY",      (char *)"RSPBR",      (char *)"READY-TO-DRINK",      (char *)"RTD", 
        (char *)"RESTAURANT",      (char *)"REST",      (char *)"READY-TO-EAT",      (char *)"RTE", 
        (char *)"READY-TO-FEED",      (char *)"RTF",      (char *)"READY-TO-SERVE",      (char *)"RTS", 
        (char *)"RECIPE",      (char *)"RECP",      (char *)"RECONSTITUTED",      (char *)"RECON", 
        (char *)"REDUCED",      (char *)"RDC",      (char *)"REFRIGERATED",      (char *)"REFR", 
        (char *)"REGULAR",      (char *)"REG",      (char *)"REMOVED",      (char *)"REMVD", 
        (char *)"RETAIL",      (char *)"RTL",      (char *)"ROAST",      (char *)"RST", 
        (char *)"ROASTED",      (char *)"RSTD",      (char *)"ROTISSERIE",      (char *)"ROTIS", 
        (char *)"ROUND",      (char *)"RND",      (char *)"SACCHARIN",      (char *)"SACC", 
        (char *)"SAFFLOWER",      (char *)"SAFF",      (char *)"SALISBURY",      (char *)"SLS", 
        (char *)"SALT",      (char *)"SLT",      (char *)"SALTED",      (char *)"SLT", 
        (char *)"SANDWICH",      (char *)"SNDWCH",      (char *)"SAUCE",      (char *)"SAU", 
        (char *)"SEASONING",      (char *)"SEASON",      (char *)"SEED",      (char *)"SD", 
        (char *)"SELECT",      (char *)"SEL",      (char *)"SEPARABLE",      (char *)"SEP", 
        (char *)"SERVE",      (char *)"SRV",      (char *)"SHORT",      (char *)"SHRT", 
        (char *)"SHORTENING",      (char *)"SHRTNG",      (char *)"SHOULDER",      (char *)"SHLD", 
        (char *)"SILICON",      (char *)"SI",      (char *)"SIMMERED",      (char *)"SIMMRD", 
        (char *)"SIRLOIN",      (char *)"SRLN",      (char *)"SIZE",      (char *)"SZ", 
        (char *)"SKIN",      (char *)"SKN",      (char *)"SKINLESS",      (char *)"SKNLS", 
        (char *)"SLICE",      (char *)"SLC",      (char *)"SLICED",      (char *)"SLCD", 
        (char *)"SMALL",      (char *)"SM",      (char *)"SNICKERS",      (char *)"SNCKRS", 
        (char *)"SODIUM",      (char *)"NA",      (char *)"SOFT",      (char *)"SFT", 
        (char *)"SOLIDS",      (char *)"SOL",      (char *)"SOUR",      (char *)"SR", 
        (char *)"SOUTHERN",      (char *)"STHRN",      (char *)"SOYBEAN",      (char *)"SOYBN", 
        (char *)"SPARERIBS",      (char *)"SPARERB",      (char *)"SPECIAL",      (char *)"SPL", 
        (char *)"SPREAD",      (char *)"SPRD",      (char *)"STABILIZERS",      (char *)"STBLZRS", 
        (char *)"STEAK",      (char *)"STK",      (char *)"STEWED",      (char *)"STWD", 
        (char *)"STUFFING",      (char *)"STFNG",      (char *)"STICK",      (char *)"STK", 
        (char *)"STICKS",      (char *)"STKS",      (char *)"STRAINED",      (char *)"STR", 
        (char *)"STRAWBERRIES",      (char *)"STRWBR",      (char *)"STRAWBERRY",      (char *)"STRWBR", 
        (char *)"STUFFED",      (char *)"STFD",      (char *)"STYLE",      (char *)"STL", 
        (char *)"SUGAR",      (char *)"SGR",      (char *)"SWEETENED",      (char *)"SWTND", 
        (char *)"SWEETENER",      (char *)"SWTNR",      (char *)"SYRUP",      (char *)"SYR", 
        (char *)"TENDER",      (char *)"TNDR",      (char *)"TOASTED",      (char *)"TSTD", 
        (char *)"TOMATO",      (char *)"TOM",      (char *)"TOP",      (char *)"TP", 
        (char *)"TOPPING",      (char *)"TPPNG",      (char *)"TOSSED",      (char *)"TOSSD", 
        (char *)"TRADITIONAL",      (char *)"TRAD",      (char *)"TRIMMED",      (char *)"TRIM", 
        (char *)"TROPICAL",      (char *)"TROP",      (char *)"TURKEY",      (char *)"TURK", 
        (char *)"UNCOATED",      (char *)"UNCTD",      (char *)"UNDILUTED",      (char *)"UNDIL", 
        (char *)"UNENRICHED",      (char *)"UNENR",      (char *)"UNHEATED",      (char *)"UNHTD", 
        (char *)"UNPREPARED",      (char *)"UNPREP",      (char *)"UNSPECIFIED",      (char *)"UNSPEC", 
        (char *)"UNSWEETENED",      (char *)"UNSWTND",      (char *)"VANILLA",      (char *)"VAN", 
        (char *)"VARIETY",      (char *)"VAR",      (char *)"VEGETABLE",      (char *)"VEG", 
        (char *)"VEGETABLES",      (char *)"VEG",      (char *)"VITAMIN",      (char *)"VIT", 
        (char *)"VITAMINS",      (char *)"VIT",      (char *)"VOLUME",      (char *)"VOL", 
        (char *)"WALNUTS",      (char *)"WLNT",      (char *)"WATCHERS",      (char *)"WATCHR", 
        (char *)"WATER",      (char *)"H2O",      (char *)"WHIPPED",      (char *)"WHPD", 
        (char *)"WHITE",      (char *)"WH",      (char *)"WHITENER",      (char *)"WHTNR", 
        (char *)"WHOLE",      (char *)"WHL",      (char *)"WINTERIZED",      (char *)"WNTRZD", 
        (char *)"WITH",      (char *)"W/",      (char *)"WITHOUT",      (char *)"WO/", 
        (char *)"YELLOW",      (char *)"YEL"};
#line 22 "/home/wheatley/newnew/temp/nut-nutrition-15.5/fdgrp.h"
char *FdGrp[37]  = 
#line 22 "/home/wheatley/newnew/temp/nut-nutrition-15.5/fdgrp.h"
  {      (char *)"Added Recipes and Labeled Foods",      (char *)"Dairy and Egg Products",      (char *)"Spices and Herbs",      (char *)"Baby Foods", 
        (char *)"Fats and Oils",      (char *)"Poultry Products",      (char *)"Soups, Sauces, and Gravies",      (char *)"Sausages and Luncheon Meats", 
        (char *)"Breakfast Cereals",      (char *)"Fruits and Fruit Juices",      (char *)"Pork Products",      (char *)"Vegetables and Vegetable Products", 
        (char *)"Nut and Seed Products",      (char *)"Beef Products",      (char *)"Beverages",      (char *)"Finfish and Shellfish Products", 
        (char *)"Legumes and Legume Products",      (char *)"Lamb, Veal, and Game Products",      (char *)"Baked Products",      (char *)"Sweets", 
        (char *)"Cereal Grains and Pasta",      (char *)"Fast Foods",      (char *)"Meals, Entrees, and Sidedishes",      (char *)"", 
        (char *)"",      (char *)"Snacks",      (char *)"",      (char *)"", 
        (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"",      (char *)"",      (char *)"",      (char *)"Ethnic Foods", 
        (char *)"Restaurant Foods"};
#line 24 "/home/wheatley/newnew/temp/nut-nutrition-15.5/fdgrp.h"
int FdGrpMap[26]  = 
#line 24
  {      0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      9,      10,      11, 
        12,      13,      14,      15, 
        16,      17,      18,      19, 
        20,      21,      22,      25, 
        35,      36};
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 36 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
int DVMap[40]  = 
#line 36 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
  {      39,      4,      1,      84, 
        111,      112,      152,      147, 
        148,      155,      149,      150, 
        151,      82,      2,      19, 
        146,      0,      31,      48, 
        49,      50,      51,      52, 
        53,      54,      47,      37, 
        158,      56,      20,      27, 
        21,      22,      29,      23, 
        24,      30,      25,      26};
#line 44 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
int CarbAminoMap[32]  = 
#line 44
  {      31,      2,      19,      5, 
        17,      8,      18,      7, 
        9,      10,      6,      0, 
        13,      73,      71,      74, 
        67,      75,      76,      72, 
        79,      63,      64,      65, 
        66,      68,      77,      78, 
        62,      61,      69,      70};
#line 51 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
int MiscMap[34]  = 
#line 51
  {      33,      16,      3,      12, 
        14,      15,      11,      28, 
        60,      55,      57,      58, 
        59,      32,      33,      38, 
        39,      40,      81,      80, 
        36,      44,      45,      46, 
        35,      34,      41,      43, 
        42,      82,      107,      110, 
        109,      108};
#line 61 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
int SatMonoMap[28]  = 
#line 61
  {      27,      84,      85,      86, 
        87,      88,      89,      134, 
        90,      113,      91,      114, 
        92,      93,      99,      115, 
        111,      100,      135,      101, 
        125,      130,      94,      126, 
        103,      105,      128,      123};
#line 69 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
int PolyTransMap[30]  = 
#line 69
  {      29,      112,      95,      127, 
        96,      136,      129,      102, 
        124,      131,      137,      138, 
        97,      139,      104,      141, 
        142,      106,      98,      83, 
        132,      116,      117,      118, 
        133,      119,      121,      120, 
        122,      140};
#line 77 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
int *ScreenMap[6]  = {      DVMap,      DVMap,      CarbAminoMap,      MiscMap, 
        SatMonoMap,      PolyTransMap};
#line 82 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
char *ScreenTitle[6]  = {      (char *)"Daily Value Percentages",      (char *)"Daily Value Absolute Amounts",      (char *)"Carbohydrates and Amino Acids",      (char *)"Miscellaneous Nutrients", 
        (char *)"Saturated and Monounsaturated Fatty Acids",      (char *)"Polyunsaturated and Trans Fatty Acids"};
#line 89 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
int MaxScreen  =    6;
#line 91 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
int MaxFdGrp  =    26;
#line 102 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
int FoodCount  =    0;
#line 104 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
void initializations(void) 
{ 
  int c ;
  double tmp ;

  {
  {
#line 107
  tmp = atof("-0");
#line 107
  NoData = (float )tmp;
#line 108
  test_signsense(& NoData);
#line 109
  c = 0;
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (c < 159)) {
#line 109
      goto while_break;
    }
#line 109
    DVBase[c] = (float )0;
#line 109
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  DVBase[4] = (float )2000;
#line 112
  DVBase[0] = (float )50;
#line 113
  DVBase[1] = (float )65;
#line 114
  DVBase[2] = (float )300;
#line 115
  DVBase[19] = (float )25;
#line 116
  DVBase[146] = DVBase[2] - DVBase[19];
#line 117
  DVBase[20] = (float )1000;
#line 118
  DVBase[23] = (float )1000;
#line 119
  DVBase[21] = (float )18;
#line 120
  DVBase[25] = (float )2400;
#line 121
  DVBase[24] = (float )3500;
#line 122
  DVBase[22] = (float )400;
#line 123
  DVBase[26] = (float )15;
#line 124
  DVBase[27] = (float )2;
#line 125
  DVBase[29] = (float )2;
#line 126
  DVBase[30] = (float )70;
#line 127
  DVBase[31] = (float )5000;
#line 128
  DVBase[158] = (float )30;
#line 129
  DVBase[56] = (float )80;
#line 130
  DVBase[48] = (float )1.5;
#line 131
  DVBase[49] = (float )1.7;
#line 132
  DVBase[50] = (float )20;
#line 133
  DVBase[51] = (float )10;
#line 134
  DVBase[52] = (float )2;
#line 135
  DVBase[53] = (float )400;
#line 136
  DVBase[54] = (float )6;
#line 137
  DVBase[47] = (float )60;
#line 138
  DVBase[84] = (float )20;
#line 139
  DVBase[82] = (float )300;
#line 140
  DVBase[37] = (float )400;
#line 141
  DVBase[147] = (float )9;
#line 142
  DVBase[148] = (float )0.16;
#line 143
  DVBase[152] = DVBase[147] + DVBase[148];
#line 144
  DVBase[149] = DVBase[147] / (float )6;
#line 145
  DVBase[150] = (float )0.3;
#line 146
  DVBase[151] = (float )0.3;
#line 147
  DVBase[155] = (DVBase[149] + DVBase[150]) + DVBase[151];
#line 148
  DVBase[112] = DVBase[152] + DVBase[155];
#line 149
  DVBase[111] = (float )((61.5 - (double )DVBase[84]) - (double )DVBase[112]);
#line 150
  c = 0;
  {
#line 150
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 150
    if (! (c < 859)) {
#line 150
      goto while_break___0;
    }
#line 150
    LookupNut[c] = -1;
#line 150
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 151
  c = 0;
  {
#line 151
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 151
    if (! (c < 143)) {
#line 151
      goto while_break___1;
    }
#line 151
    LookupNutrNo[c] = -1;
#line 151
    c ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 22 "/home/wheatley/newnew/temp/nut-nutrition-15.5/lookup.h"
  LookupNutrNo[0] = 203;
#line 23
  LookupNut[203] = 0;
#line 24
  LookupNutrNo[1] = 204;
#line 25
  LookupNut[204] = 1;
#line 26
  LookupNutrNo[2] = 205;
#line 27
  LookupNut[205] = 2;
#line 28
  LookupNutrNo[3] = 207;
#line 29
  LookupNut[207] = 3;
#line 30
  LookupNutrNo[4] = 208;
#line 31
  LookupNut[208] = 4;
#line 32
  LookupNutrNo[5] = 209;
#line 33
  LookupNut[209] = 5;
#line 34
  LookupNutrNo[6] = 210;
#line 35
  LookupNut[210] = 6;
#line 36
  LookupNutrNo[7] = 211;
#line 37
  LookupNut[211] = 7;
#line 38
  LookupNutrNo[8] = 212;
#line 39
  LookupNut[212] = 8;
#line 40
  LookupNutrNo[9] = 213;
#line 41
  LookupNut[213] = 9;
#line 42
  LookupNutrNo[10] = 214;
#line 43
  LookupNut[214] = 10;
#line 44
  LookupNutrNo[11] = 221;
#line 45
  LookupNut[221] = 11;
#line 46
  LookupNutrNo[12] = 255;
#line 47
  LookupNut[255] = 12;
#line 48
  LookupNutrNo[13] = 257;
#line 49
  LookupNut[257] = 13;
#line 50
  LookupNutrNo[14] = 262;
#line 51
  LookupNut[262] = 14;
#line 52
  LookupNutrNo[15] = 263;
#line 53
  LookupNut[263] = 15;
#line 54
  LookupNutrNo[16] = 268;
#line 55
  LookupNut[268] = 16;
#line 56
  LookupNutrNo[17] = 269;
#line 57
  LookupNut[269] = 17;
#line 58
  LookupNutrNo[18] = 287;
#line 59
  LookupNut[287] = 18;
#line 60
  LookupNutrNo[19] = 291;
#line 61
  LookupNut[291] = 19;
#line 62
  LookupNutrNo[20] = 301;
#line 63
  LookupNut[301] = 20;
#line 64
  LookupNutrNo[21] = 303;
#line 65
  LookupNut[303] = 21;
#line 66
  LookupNutrNo[22] = 304;
#line 67
  LookupNut[304] = 22;
#line 68
  LookupNutrNo[23] = 305;
#line 69
  LookupNut[305] = 23;
#line 70
  LookupNutrNo[24] = 306;
#line 71
  LookupNut[306] = 24;
#line 72
  LookupNutrNo[25] = 307;
#line 73
  LookupNut[307] = 25;
#line 74
  LookupNutrNo[26] = 309;
#line 75
  LookupNut[309] = 26;
#line 76
  LookupNutrNo[27] = 312;
#line 77
  LookupNut[312] = 27;
#line 78
  LookupNutrNo[28] = 313;
#line 79
  LookupNut[313] = 28;
#line 80
  LookupNutrNo[29] = 315;
#line 81
  LookupNut[315] = 29;
#line 82
  LookupNutrNo[30] = 317;
#line 83
  LookupNut[317] = 30;
#line 84
  LookupNutrNo[31] = 318;
#line 85
  LookupNut[318] = 31;
#line 86
  LookupNutrNo[32] = 319;
#line 87
  LookupNut[319] = 32;
#line 88
  LookupNutrNo[33] = 320;
#line 89
  LookupNut[320] = 33;
#line 90
  LookupNutrNo[34] = 321;
#line 91
  LookupNut[321] = 34;
#line 92
  LookupNutrNo[35] = 322;
#line 93
  LookupNut[322] = 35;
#line 94
  LookupNutrNo[36] = 323;
#line 95
  LookupNut[323] = 36;
#line 96
  LookupNutrNo[37] = 324;
#line 97
  LookupNut[324] = 37;
#line 98
  LookupNutrNo[38] = 325;
#line 99
  LookupNut[325] = 38;
#line 100
  LookupNutrNo[39] = 326;
#line 101
  LookupNut[326] = 39;
#line 102
  LookupNutrNo[40] = 328;
#line 103
  LookupNut[328] = 40;
#line 104
  LookupNutrNo[41] = 334;
#line 105
  LookupNut[334] = 41;
#line 106
  LookupNutrNo[42] = 337;
#line 107
  LookupNut[337] = 42;
#line 108
  LookupNutrNo[43] = 338;
#line 109
  LookupNut[338] = 43;
#line 110
  LookupNutrNo[44] = 341;
#line 111
  LookupNut[341] = 44;
#line 112
  LookupNutrNo[45] = 342;
#line 113
  LookupNut[342] = 45;
#line 114
  LookupNutrNo[46] = 343;
#line 115
  LookupNut[343] = 46;
#line 116
  LookupNutrNo[47] = 401;
#line 117
  LookupNut[401] = 47;
#line 118
  LookupNutrNo[48] = 404;
#line 119
  LookupNut[404] = 48;
#line 120
  LookupNutrNo[49] = 405;
#line 121
  LookupNut[405] = 49;
#line 122
  LookupNutrNo[50] = 406;
#line 123
  LookupNut[406] = 50;
#line 124
  LookupNutrNo[51] = 410;
#line 125
  LookupNut[410] = 51;
#line 126
  LookupNutrNo[52] = 415;
#line 127
  LookupNut[415] = 52;
#line 128
  LookupNutrNo[53] = 417;
#line 129
  LookupNut[417] = 53;
#line 130
  LookupNutrNo[54] = 418;
#line 131
  LookupNut[418] = 54;
#line 132
  LookupNutrNo[55] = 421;
#line 133
  LookupNut[421] = 55;
#line 134
  LookupNutrNo[56] = 430;
#line 135
  LookupNut[430] = 56;
#line 136
  LookupNutrNo[57] = 431;
#line 137
  LookupNut[431] = 57;
#line 138
  LookupNutrNo[58] = 432;
#line 139
  LookupNut[432] = 58;
#line 140
  LookupNutrNo[59] = 435;
#line 141
  LookupNut[435] = 59;
#line 142
  LookupNutrNo[60] = 454;
#line 143
  LookupNut[454] = 60;
#line 144
  LookupNutrNo[61] = 501;
#line 145
  LookupNut[501] = 61;
#line 146
  LookupNutrNo[62] = 502;
#line 147
  LookupNut[502] = 62;
#line 148
  LookupNutrNo[63] = 503;
#line 149
  LookupNut[503] = 63;
#line 150
  LookupNutrNo[64] = 504;
#line 151
  LookupNut[504] = 64;
#line 152
  LookupNutrNo[65] = 505;
#line 153
  LookupNut[505] = 65;
#line 154
  LookupNutrNo[66] = 506;
#line 155
  LookupNut[506] = 66;
#line 156
  LookupNutrNo[67] = 507;
#line 157
  LookupNut[507] = 67;
#line 158
  LookupNutrNo[68] = 508;
#line 159
  LookupNut[508] = 68;
#line 160
  LookupNutrNo[69] = 509;
#line 161
  LookupNut[509] = 69;
#line 162
  LookupNutrNo[70] = 510;
#line 163
  LookupNut[510] = 70;
#line 164
  LookupNutrNo[71] = 511;
#line 165
  LookupNut[511] = 71;
#line 166
  LookupNutrNo[72] = 512;
#line 167
  LookupNut[512] = 72;
#line 168
  LookupNutrNo[73] = 513;
#line 169
  LookupNut[513] = 73;
#line 170
  LookupNutrNo[74] = 514;
#line 171
  LookupNut[514] = 74;
#line 172
  LookupNutrNo[75] = 515;
#line 173
  LookupNut[515] = 75;
#line 174
  LookupNutrNo[76] = 516;
#line 175
  LookupNut[516] = 76;
#line 176
  LookupNutrNo[77] = 517;
#line 177
  LookupNut[517] = 77;
#line 178
  LookupNutrNo[78] = 518;
#line 179
  LookupNut[518] = 78;
#line 180
  LookupNutrNo[79] = 521;
#line 181
  LookupNut[521] = 79;
#line 182
  LookupNutrNo[80] = 573;
#line 183
  LookupNut[573] = 80;
#line 184
  LookupNutrNo[81] = 578;
#line 185
  LookupNut[578] = 81;
#line 186
  LookupNutrNo[82] = 601;
#line 187
  LookupNut[601] = 82;
#line 188
  LookupNutrNo[83] = 605;
#line 189
  LookupNut[605] = 83;
#line 190
  LookupNutrNo[84] = 606;
#line 191
  LookupNut[606] = 84;
#line 192
  LookupNutrNo[85] = 607;
#line 193
  LookupNut[607] = 85;
#line 194
  LookupNutrNo[86] = 608;
#line 195
  LookupNut[608] = 86;
#line 196
  LookupNutrNo[87] = 609;
#line 197
  LookupNut[609] = 87;
#line 198
  LookupNutrNo[88] = 610;
#line 199
  LookupNut[610] = 88;
#line 200
  LookupNutrNo[89] = 611;
#line 201
  LookupNut[611] = 89;
#line 202
  LookupNutrNo[90] = 612;
#line 203
  LookupNut[612] = 90;
#line 204
  LookupNutrNo[91] = 613;
#line 205
  LookupNut[613] = 91;
#line 206
  LookupNutrNo[92] = 614;
#line 207
  LookupNut[614] = 92;
#line 208
  LookupNutrNo[93] = 615;
#line 209
  LookupNut[615] = 93;
#line 210
  LookupNutrNo[94] = 617;
#line 211
  LookupNut[617] = 94;
#line 212
  LookupNutrNo[95] = 618;
#line 213
  LookupNut[618] = 95;
#line 214
  LookupNutrNo[96] = 619;
#line 215
  LookupNut[619] = 96;
#line 216
  LookupNutrNo[97] = 620;
#line 217
  LookupNut[620] = 97;
#line 218
  LookupNutrNo[98] = 621;
#line 219
  LookupNut[621] = 98;
#line 220
  LookupNutrNo[99] = 624;
#line 221
  LookupNut[624] = 99;
#line 222
  LookupNutrNo[100] = 625;
#line 223
  LookupNut[625] = 100;
#line 224
  LookupNutrNo[101] = 626;
#line 225
  LookupNut[626] = 101;
#line 226
  LookupNutrNo[102] = 627;
#line 227
  LookupNut[627] = 102;
#line 228
  LookupNutrNo[103] = 628;
#line 229
  LookupNut[628] = 103;
#line 230
  LookupNutrNo[104] = 629;
#line 231
  LookupNut[629] = 104;
#line 232
  LookupNutrNo[105] = 630;
#line 233
  LookupNut[630] = 105;
#line 234
  LookupNutrNo[106] = 631;
#line 235
  LookupNut[631] = 106;
#line 236
  LookupNutrNo[107] = 636;
#line 237
  LookupNut[636] = 107;
#line 238
  LookupNutrNo[108] = 638;
#line 239
  LookupNut[638] = 108;
#line 240
  LookupNutrNo[109] = 639;
#line 241
  LookupNut[639] = 109;
#line 242
  LookupNutrNo[110] = 641;
#line 243
  LookupNut[641] = 110;
#line 244
  LookupNutrNo[111] = 645;
#line 245
  LookupNut[645] = 111;
#line 246
  LookupNutrNo[112] = 646;
#line 247
  LookupNut[646] = 112;
#line 248
  LookupNutrNo[113] = 652;
#line 249
  LookupNut[652] = 113;
#line 250
  LookupNutrNo[114] = 653;
#line 251
  LookupNut[653] = 114;
#line 252
  LookupNutrNo[115] = 654;
#line 253
  LookupNut[654] = 115;
#line 254
  LookupNutrNo[116] = 662;
#line 255
  LookupNut[662] = 116;
#line 256
  LookupNutrNo[117] = 663;
#line 257
  LookupNut[663] = 117;
#line 258
  LookupNutrNo[118] = 664;
#line 259
  LookupNut[664] = 118;
#line 260
  LookupNutrNo[119] = 665;
#line 261
  LookupNut[665] = 119;
#line 262
  LookupNutrNo[120] = 666;
#line 263
  LookupNut[666] = 120;
#line 264
  LookupNutrNo[121] = 669;
#line 265
  LookupNut[669] = 121;
#line 266
  LookupNutrNo[122] = 670;
#line 267
  LookupNut[670] = 122;
#line 268
  LookupNutrNo[123] = 671;
#line 269
  LookupNut[671] = 123;
#line 270
  LookupNutrNo[124] = 672;
#line 271
  LookupNut[672] = 124;
#line 272
  LookupNutrNo[125] = 673;
#line 273
  LookupNut[673] = 125;
#line 274
  LookupNutrNo[126] = 674;
#line 275
  LookupNut[674] = 126;
#line 276
  LookupNutrNo[127] = 675;
#line 277
  LookupNut[675] = 127;
#line 278
  LookupNutrNo[128] = 676;
#line 279
  LookupNut[676] = 128;
#line 280
  LookupNutrNo[129] = 685;
#line 281
  LookupNut[685] = 129;
#line 282
  LookupNutrNo[130] = 687;
#line 283
  LookupNut[687] = 130;
#line 284
  LookupNutrNo[131] = 689;
#line 285
  LookupNut[689] = 131;
#line 286
  LookupNutrNo[132] = 693;
#line 287
  LookupNut[693] = 132;
#line 288
  LookupNutrNo[133] = 695;
#line 289
  LookupNut[695] = 133;
#line 290
  LookupNutrNo[134] = 696;
#line 291
  LookupNut[696] = 134;
#line 292
  LookupNutrNo[135] = 697;
#line 293
  LookupNut[697] = 135;
#line 294
  LookupNutrNo[136] = 851;
#line 295
  LookupNut[851] = 136;
#line 296
  LookupNutrNo[137] = 852;
#line 297
  LookupNut[852] = 137;
#line 298
  LookupNutrNo[138] = 853;
#line 299
  LookupNut[853] = 138;
#line 300
  LookupNutrNo[139] = 855;
#line 301
  LookupNut[855] = 139;
#line 302
  LookupNutrNo[140] = 856;
#line 303
  LookupNut[856] = 140;
#line 304
  LookupNutrNo[141] = 857;
#line 305
  LookupNut[857] = 141;
#line 306
  LookupNutrNo[142] = 858;
#line 307
  LookupNut[858] = 142;
#line 153 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
  return;
}
}
#line 155 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
int order_new_food(void) 
{ 
  struct food *food_ptr ;
  int foodnum ;
  int tmp ;

  {
#line 157
  food_ptr = & food_root;
#line 158
  foodnum = 0;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if ((unsigned long )food_ptr->next != (unsigned long )((void *)0)) {
      {
#line 159
      tmp = namestrcmp(new_food->name, (food_ptr->next)->name);
      }
#line 159
      if (! (tmp >= 0)) {
#line 159
        goto while_break;
      }
    } else {
#line 159
      goto while_break;
    }
#line 161
    food_ptr = food_ptr->next;
#line 162
    foodnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  new_food->next = food_ptr->next;
#line 165
  food_ptr->next = new_food;
#line 166
  return (foodnum);
}
}
#line 169 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
void order_new_food_already_sorted(void) 
{ 
  struct food *food_ptr ;

  {
#line 171
  food_ptr = & food_root;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! ((unsigned long )food_ptr->next != (unsigned long )((void *)0))) {
#line 172
      goto while_break;
    }
#line 172
    food_ptr = food_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  new_food->next = (struct food *)((void *)0);
#line 174
  food_ptr->next = new_food;
#line 175
  return;
}
}
#line 177 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
int namestrcmp(char *name1 , char *name2 ) 
{ 
  char namebuf1[61] ;
  char namebuf2[61] ;
  int count ;
  int tmp ;

  {
#line 181
  count = 0;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (count <= 60)) {
#line 181
      goto while_break;
    }
#line 183
    if ((int )*(name1 + count) == 44) {
#line 183
      namebuf1[count] = (char )'\a';
    } else {
#line 184
      namebuf1[count] = *(name1 + count);
    }
#line 185
    if ((int )*(name2 + count) == 44) {
#line 185
      namebuf2[count] = (char )'\a';
    } else {
#line 186
      namebuf2[count] = *(name2 + count);
    }
#line 181
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  tmp = strcmp((char const   *)(namebuf1), (char const   *)(namebuf2));
  }
#line 188
  return (tmp);
}
}
#line 191 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
int substring_finder(char *food_name , char *substr ) 
{ 
  int i ;
  char *token ;
  char substring[61] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 196
  strcpy((char */* __restrict  */)(substring), (char const   */* __restrict  */)substr);
#line 197
  token = strtok((char */* __restrict  */)(substring), (char const   */* __restrict  */)", ");
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! ((unsigned long )token != (unsigned long )((void *)0))) {
#line 198
      goto while_break;
    }
    {
#line 200
    tmp = strstr((char const   *)food_name, (char const   *)token);
    }
#line 200
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
#line 202
      token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)", ");
      }
#line 203
      goto while_continue;
    }
#line 205
    i = 0;
    {
#line 205
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 205
      if (! (i < Abbrev_Count)) {
#line 205
        goto while_break___0;
      }
      {
#line 205
      tmp___0 = strcmp((char const   *)token, (char const   *)Abbreviations[i]);
      }
#line 205
      if (tmp___0 == 0) {
#line 205
        goto while_break___0;
      }
#line 205
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 206
    if (i == Abbrev_Count) {
#line 206
      return (0);
    }
#line 207
    if (i % 2 == 0) {
#line 207
      tmp___1 = i + 1;
    } else {
#line 207
      tmp___1 = i - 1;
    }
    {
#line 207
    tmp___2 = strstr((char const   *)food_name, (char const   *)Abbreviations[tmp___1]);
    }
#line 207
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 207
      return (0);
    }
    {
#line 208
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)", ");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return (1);
}
}
#line 213 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
struct food *food_choice(char *screentitle , int usual ) 
{ 
  struct food *food_ptr ;
  struct food *ptrlist[9000] ;
  int count ;
  int charcount ;
  int keysize ;
  int lines ;
  int junk ;
  char substring[61] ;
  char key___0[61] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 217
  count = 0;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 221
    key_decode(substring, key___0);
#line 222
    tmp___0 = strcmp((char const   *)(substring), "");
    }
#line 222
    if (tmp___0 == 0) {
      {
#line 224
      header(screentitle);
#line 225
      spacer(0);
#line 226
      tmp = strcmp((char const   *)screentitle, "NUT:  Add Recipes");
      }
#line 226
      if (tmp == 0) {
        {
#line 226
        printf((char const   */* __restrict  */)"\nType food name to add to recipe (or <enter> to quit):  ");
        }
      } else {
        {
#line 227
        printf((char const   */* __restrict  */)"\nType food name to select (or <enter> to quit):  ");
        }
      }
      {
#line 228
      get_string(substring, 60);
#line 229
      key___0[0] = (char )'\000';
#line 230
      key_clean();
      }
    }
#line 232
    if ((int )substring[0] == 0) {
#line 232
      return ((struct food *)-1);
    }
#line 233
    charcount = 0;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (charcount < 60)) {
#line 233
        goto while_break___0;
      }
      {
#line 233
      tmp___1 = toupper((int )substring[charcount]);
#line 233
      substring[charcount] = (char )tmp___1;
#line 233
      charcount ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 234
    key_encode(substring, key___0);
#line 235
    tmp___2 = strncmp((char const   *)(substring), "THEUSUAL", (size_t )8);
    }
#line 235
    if (tmp___2 == 0) {
#line 235
      if (usual) {
#line 235
        return ((struct food *)-2);
      }
    }
    {
#line 236
    tmp___3 = strncmp((char const   *)(substring), "PCF ", (size_t )4);
    }
#line 236
    if (tmp___3 == 0) {
#line 236
      if (usual) {
#line 236
        return ((struct food *)-3);
      }
    }
    {
#line 237
    header(screentitle);
#line 238
    food_ptr = & food_root;
#line 239
    tmp___4 = strlen((char const   *)(key___0));
#line 239
    keysize = (int )tmp___4;
#line 239
    lines = 0;
#line 239
    count = 0;
    }
    {
#line 240
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 240
      food_ptr = food_ptr->next;
#line 240
      if (! food_ptr) {
#line 240
        goto while_break___1;
      }
      {
#line 240
      tmp___5 = substring_finder(food_ptr->name, substring);
      }
#line 240
      if (tmp___5) {
        {
#line 240
        tmp___6 = strncmp((char const   *)(key___0), (char const   *)(food_ptr->name),
                          (size_t )keysize);
        }
#line 240
        if (tmp___6 == 0) {
#line 240
          count ++;
#line 240
          ptrlist[count] = food_ptr;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 241
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 241
      if (! (count == 0)) {
#line 241
        goto while_break___2;
      }
      {
#line 243
      key_clean();
#line 244
      spacer(-1);
#line 245
      printf((char const   */* __restrict  */)"No food named \"%s\".  Try another (or <enter> to quit):  ",
             substring);
#line 246
      get_string(substring, 60);
      }
#line 247
      if ((int )substring[0] == 0) {
#line 247
        return ((struct food *)0);
      }
#line 248
      charcount = 0;
      {
#line 248
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 248
        if (! (charcount < 60)) {
#line 248
          goto while_break___3;
        }
        {
#line 248
        tmp___7 = toupper((int )substring[charcount]);
#line 248
        substring[charcount] = (char )tmp___7;
#line 248
        charcount ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 249
      key_encode(substring, key___0);
#line 250
      tmp___8 = strncmp((char const   *)(substring), "THEUSUAL", (size_t )8);
      }
#line 250
      if (tmp___8 == 0) {
#line 250
        if (usual) {
#line 250
          return ((struct food *)-2);
        }
      }
      {
#line 251
      tmp___9 = strncmp((char const   *)(substring), "PCF ", (size_t )4);
      }
#line 251
      if (tmp___9 == 0) {
#line 251
        if (usual) {
#line 251
          return ((struct food *)-3);
        }
      }
      {
#line 252
      header(screentitle);
#line 253
      food_ptr = & food_root;
#line 254
      tmp___10 = strlen((char const   *)(key___0));
#line 254
      keysize = (int )tmp___10;
#line 254
      lines = 0;
#line 254
      count = 0;
      }
      {
#line 255
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 255
        food_ptr = food_ptr->next;
#line 255
        if (! food_ptr) {
#line 255
          goto while_break___4;
        }
        {
#line 255
        tmp___11 = substring_finder(food_ptr->name, substring);
        }
#line 255
        if (tmp___11) {
          {
#line 255
          tmp___12 = strncmp((char const   *)(key___0), (char const   *)(food_ptr->name),
                             (size_t )keysize);
          }
#line 255
          if (tmp___12 == 0) {
#line 255
            count ++;
#line 255
            ptrlist[count] = food_ptr;
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 257
    if (count == 1) {
#line 257
      return (ptrlist[1]);
    }
#line 258
    if (count < 21) {
#line 260
      lines = 1;
      {
#line 260
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 260
        if (! (lines <= count)) {
#line 260
          goto while_break___5;
        }
        {
#line 260
        printf((char const   */* __restrict  */)"%2d. %s\n", lines, (ptrlist[lines])->name);
#line 260
        lines ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 261
      spacer(lines - 2);
#line 262
      printf((char const   */* __restrict  */)"Type number of food category (\"b\" to go back, <enter> to quit):  ");
#line 263
      get_string(key___0, 60);
#line 264
      junk = 0;
#line 265
      tmp___13 = strcmp((char const   *)(key___0), "b");
      }
#line 265
      if (tmp___13 == 0) {
#line 265
        junk = -38;
      } else {
        {
#line 265
        tmp___14 = strcmp((char const   *)(key___0), "B");
        }
#line 265
        if (tmp___14 == 0) {
#line 265
          junk = -38;
        }
      }
#line 266
      if (junk == -38) {
        {
#line 268
        key_decode(substring, key___0);
        }
#line 269
        goto __Cont;
      }
      {
#line 271
      junk = atoi((char const   *)(key___0));
      }
#line 272
      if (junk > 0) {
#line 272
        if (junk <= count) {
          {
#line 274
          key_encode(substring, (ptrlist[junk])->name);
          }
#line 275
          return (ptrlist[junk]);
        } else {
#line 277
          return ((struct food *)0);
        }
      } else {
#line 277
        return ((struct food *)0);
      }
    }
#line 279
    if (count > 20) {
      {
#line 279
      food_subcat(substring, key___0, ptrlist, count);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 283 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
void food_subcat(char *substring , char *key___0 , struct food **ptrlist , int count ) 
{ 
  char food_screen[2000] ;
  char *fsptr[500] ;
  char *thisfsptr ;
  char *bufptr ;
  char buffer[61] ;
  char format[11] ;
  char format100[11] ;
  char tokenhead[61] ;
  char junkstring[120] ;
  char *col[10] ;
  char colformat1[110] ;
  char colformat2[110] ;
  int i ;
  int l ;
  int s ;
  int subcount ;
  int charcount ;
  int tokencount ;
  int nlength ;
  int tokenlength ;
  int tokenunique ;
  int headlength ;
  int linecount ;
  int savelinecount ;
  int tokenmax ;
  int colcount ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 288
  subcount = 0;
#line 288
  headlength = 0;
#line 288
  savelinecount = 0;
#line 288
  tokenmax = 0;
#line 289
  linecount = 1;
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (linecount <= 20)) {
#line 289
      goto while_break;
    }
#line 289
    fsptr[linecount] = food_screen + 61 * linecount;
#line 289
    linecount ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  linecount = 1;
  {
#line 290
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 290
    if (! (linecount <= count)) {
#line 290
      goto while_break___0;
    }
    {
#line 292
    tokencount = 0;
#line 293
    tmp = strlen((char const   *)((*(ptrlist + linecount))->name));
#line 293
    nlength = (int )tmp;
#line 294
    charcount = 0;
    }
    {
#line 294
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 294
      if (! (charcount <= nlength)) {
#line 294
        goto while_break___1;
      }
#line 294
      if ((int )(*(ptrlist + linecount))->name[charcount] == 44) {
#line 294
        tokencount ++;
      }
#line 294
      charcount ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 295
    if (tokencount > tokenmax) {
#line 295
      tokenmax = tokencount;
    }
#line 290
    linecount ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 297
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 297
    if (subcount < count) {
#line 297
      if (! (tokenmax > -1)) {
#line 297
        goto while_break___2;
      }
    } else {
#line 297
      goto while_break___2;
    }
#line 299
    tokenmax --;
#line 300
    subcount = 0;
#line 301
    linecount = 1;
    {
#line 301
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 301
      if (subcount < count) {
#line 301
        if (! (linecount <= 20)) {
#line 301
          goto while_break___3;
        }
      } else {
#line 301
        goto while_break___3;
      }
      {
#line 303
      subcount ++;
#line 304
      tmp___0 = strlen((char const   *)((*(ptrlist + subcount))->name));
#line 304
      nlength = (int )tmp___0;
#line 305
      thisfsptr = fsptr[linecount];
#line 306
      tokencount = 0;
#line 307
      charcount = 0;
      }
      {
#line 307
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 307
        if (! (charcount <= nlength)) {
#line 307
          goto while_break___4;
        }
#line 309
        if ((int )(*(ptrlist + subcount))->name[charcount] == 44) {
#line 309
          tokencount ++;
        }
#line 310
        if (tokencount == tokenmax) {
#line 312
          *(thisfsptr + charcount) = (char )'\000';
#line 313
          goto while_break___4;
        }
#line 315
        *(thisfsptr + charcount) = (*(ptrlist + subcount))->name[charcount];
#line 316
        if ((int )(*(ptrlist + subcount))->name[charcount] == 0) {
#line 316
          goto while_break___4;
        }
#line 307
        charcount ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 318
      if (linecount > 1) {
        {
#line 318
        tmp___1 = strcmp((char const   *)fsptr[linecount], (char const   *)fsptr[linecount - 1]);
        }
#line 318
        if (0 == tmp___1) {
#line 318
          linecount --;
        }
      }
#line 301
      linecount ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 320
    linecount --;
#line 320
    savelinecount = linecount;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 322
  if (savelinecount > 1) {
#line 324
    linecount = 1;
    {
#line 324
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 324
      if (! (linecount <= savelinecount)) {
#line 324
        goto while_break___5;
      }
      {
#line 324
      printf((char const   */* __restrict  */)"%2d.  %s\n", linecount, fsptr[linecount]);
#line 324
      linecount ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 325
    spacer(savelinecount - 1);
#line 326
    printf((char const   */* __restrict  */)"Type number of food category (\"b\" to go back, <enter> to quit):  ");
#line 327
    get_string(junkstring, 20);
#line 328
    tmp___2 = strcmp((char const   *)(junkstring), "b");
    }
#line 328
    if (tmp___2 == 0) {
      {
#line 330
      key_take();
      }
#line 331
      return;
    } else {
      {
#line 328
      tmp___3 = strcmp((char const   *)(junkstring), "B");
      }
#line 328
      if (tmp___3 == 0) {
        {
#line 330
        key_take();
        }
#line 331
        return;
      }
    }
    {
#line 333
    linecount = atoi((char const   *)(junkstring));
    }
#line 334
    if (linecount > 0) {
#line 334
      if (linecount <= savelinecount) {
#line 336
        if (headlength < 1) {
          {
#line 336
          strcpy((char */* __restrict  */)key___0, (char const   */* __restrict  */)fsptr[linecount]);
          }
        }
#line 337
        if (headlength > 0) {
          {
#line 339
          strcpy((char */* __restrict  */)key___0, (char const   */* __restrict  */)(tokenhead));
#line 340
          strcat((char */* __restrict  */)key___0, (char const   */* __restrict  */)fsptr[linecount]);
          }
        }
#line 342
        subcount = 1;
        {
#line 342
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 342
          if (! (subcount <= count)) {
#line 342
            goto while_break___6;
          }
          {
#line 342
          tmp___4 = strcmp((char const   *)key___0, (char const   *)((*(ptrlist + subcount))->name));
          }
#line 342
          if (tmp___4 == 0) {
#line 342
            goto while_break___6;
          }
#line 342
          subcount ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 343
        subcount --;
#line 343
        if (subcount == count) {
          {
#line 343
          strcat((char */* __restrict  */)key___0, (char const   */* __restrict  */)",");
          }
        }
      } else {
#line 347
        *(key___0 + 0) = (char )'\000';
#line 348
        *(substring + 0) = (char )'\000';
      }
    } else {
#line 347
      *(key___0 + 0) = (char )'\000';
#line 348
      *(substring + 0) = (char )'\000';
    }
    {
#line 350
    key_encode(substring, key___0);
    }
  } else {
#line 354
    tokenhead[0] = (char )'\000';
#line 355
    tokenmax = 1;
    {
#line 355
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 357
      buffer[0] = (char )'\000';
#line 358
      tokenunique = 0;
#line 359
      tokenlength = 0;
#line 360
      subcount = 1;
      {
#line 360
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 360
        if (! (subcount <= count)) {
#line 360
          goto while_break___8;
        }
#line 362
        bufptr = (*(ptrlist + subcount))->name;
#line 363
        nlength = 0;
#line 364
        tokencount = 1;
        {
#line 364
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 364
          if (! (tokencount <= tokenmax)) {
#line 364
            goto while_break___9;
          }
          {
#line 366
          bufptr += nlength;
#line 367
          tmp___5 = strspn((char const   *)bufptr, ",");
#line 367
          bufptr += tmp___5;
#line 368
          tmp___6 = strcspn((char const   *)bufptr, ",");
#line 368
          nlength = (int )tmp___6;
#line 364
          tokencount ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 370
        if (nlength > tokenlength) {
          {
#line 372
          tokenlength = nlength;
#line 373
          tokenunique ++;
#line 374
          strncpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)bufptr,
                  (size_t )nlength);
#line 375
          buffer[nlength] = (char )'\000';
          }
        } else
#line 377
        if (nlength < tokenlength) {
          {
#line 379
          tokenunique ++;
#line 380
          strncpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)bufptr,
                  (size_t )nlength);
#line 381
          buffer[nlength] = (char )'\000';
          }
        } else {
          {
#line 383
          tmp___7 = strncmp((char const   *)(buffer), (char const   *)bufptr, (size_t )nlength);
          }
#line 383
          if (tmp___7 != 0) {
            {
#line 385
            tokenunique ++;
#line 386
            strncpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)bufptr,
                    (size_t )nlength);
#line 387
            buffer[nlength] = (char )'\000';
            }
          }
        }
#line 360
        subcount ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 390
      if (tokenunique == 1) {
        {
#line 392
        strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)",");
#line 393
        strcat((char */* __restrict  */)(tokenhead), (char const   */* __restrict  */)(buffer));
        }
      }
#line 395
      if (tokenunique != 1) {
#line 395
        goto while_break___7;
      }
#line 355
      tokenmax ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 397
    if ((int )tokenhead[0] == 0) {
#line 397
      savelinecount = 20;
    } else {
#line 398
      savelinecount = 19;
    }
    {
#line 399
    tmp___8 = strlen((char const   *)(tokenhead));
#line 399
    headlength = (int )tmp___8;
    }
    {
#line 401
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 401
      if (! (savelinecount * (81 / (tokenlength + 5)) < tokenunique)) {
#line 401
        goto while_break___10;
      }
#line 406
      buffer[0] = (char )'\000';
#line 407
      tokenunique = 0;
#line 408
      tokenlength --;
#line 409
      subcount = 1;
      {
#line 409
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 409
        if (! (subcount <= count)) {
#line 409
          goto while_break___11;
        }
        {
#line 411
        bufptr = (*(ptrlist + subcount))->name + headlength;
#line 412
        tmp___9 = strcspn((char const   *)bufptr, ",");
#line 412
        nlength = (int )tmp___9;
        }
        {
#line 413
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 413
          if (! ((int )*((bufptr + nlength) - 1) == 32)) {
#line 413
            goto while_break___12;
          }
#line 413
          nlength --;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 414
        if (nlength > tokenlength) {
#line 414
          nlength = tokenlength;
        }
        {
#line 415
        tmp___10 = strncmp((char const   *)(buffer), (char const   *)bufptr, (size_t )nlength);
        }
#line 415
        if (tmp___10 != 0) {
          {
#line 417
          tokenunique ++;
#line 418
          strncpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)bufptr,
                  (size_t )nlength);
#line 419
          buffer[nlength] = (char )'\000';
          }
        }
#line 409
        subcount ++;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
#line 423
    linecount = 0;
    {
#line 423
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 423
      if (! (linecount <= tokenunique + 2)) {
#line 423
        goto while_break___13;
      }
#line 423
      fsptr[linecount] = food_screen + (tokenlength + 1) * linecount;
#line 423
      linecount ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 424
    food_screen[0] = (char )'\000';
#line 425
    linecount = 0;
#line 426
    subcount = 1;
    {
#line 426
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 426
      if (! (subcount <= count)) {
#line 426
        goto while_break___14;
      }
      {
#line 428
      bufptr = (*(ptrlist + subcount))->name + headlength;
#line 429
      tmp___11 = strcspn((char const   *)bufptr, ",");
#line 429
      nlength = (int )tmp___11;
      }
#line 430
      if (nlength > tokenlength) {
#line 430
        nlength = tokenlength;
      }
      {
#line 431
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 431
        if (! ((int )*((bufptr + nlength) - 1) == 32)) {
#line 431
          goto while_break___15;
        }
#line 431
        nlength --;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 432
      strncpy((char */* __restrict  */)fsptr[linecount + 1], (char const   */* __restrict  */)bufptr,
              (size_t )nlength);
#line 433
      thisfsptr = fsptr[linecount + 1];
#line 434
      *(thisfsptr + nlength) = (char )'\000';
#line 435
      tmp___12 = strncmp((char const   *)fsptr[linecount], (char const   *)fsptr[linecount + 1],
                         (size_t )nlength);
      }
#line 435
      if (tmp___12 != 0) {
#line 435
        linecount ++;
      }
#line 426
      subcount ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 437
    sprintf((char */* __restrict  */)(format), (char const   */* __restrict  */)"%%2d. %%-%ds",
            tokenlength);
#line 438
    sprintf((char */* __restrict  */)(format100), (char const   */* __restrict  */)"%%3d. %%-%ds",
            tokenlength);
#line 439
    strcpy((char */* __restrict  */)(colformat1), (char const   */* __restrict  */)(format));
#line 440
    strcpy((char */* __restrict  */)(colformat2), (char const   */* __restrict  */)(format));
    }
#line 441
    if (linecount % savelinecount == 0) {
#line 441
      tmp___13 = 0;
    } else {
#line 441
      tmp___13 = 1;
    }
#line 441
    colcount = tmp___13 + linecount / savelinecount;
#line 442
    if (colcount > 7) {
      {
#line 444
      spacer(-1);
#line 445
      printf((char const   */* __restrict  */)"Too many foods meet criterion.  Press <enter> to continue...");
#line 446
      i = get_int();
#line 447
      key_take();
      }
#line 448
      return;
    }
#line 450
    if (colcount < 8) {
#line 452
      i = 2;
      {
#line 452
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 452
        if (! (i <= colcount)) {
#line 452
          goto while_break___16;
        }
#line 454
        if (i != colcount) {
          {
#line 454
          strcat((char */* __restrict  */)(colformat1), (char const   */* __restrict  */)" ");
          }
        }
        {
#line 455
        strcat((char */* __restrict  */)(colformat2), (char const   */* __restrict  */)" ");
        }
#line 456
        if (i * savelinecount < 100) {
#line 456
          goto _L;
        } else
#line 456
        if (tokenunique < 100) {
          _L: /* CIL Label */ 
#line 458
          if (i != colcount) {
            {
#line 458
            strcat((char */* __restrict  */)(colformat1), (char const   */* __restrict  */)(format));
            }
          }
          {
#line 459
          strcat((char */* __restrict  */)(colformat2), (char const   */* __restrict  */)(format));
          }
        } else {
#line 463
          if (i != colcount) {
            {
#line 463
            strcat((char */* __restrict  */)(colformat1), (char const   */* __restrict  */)(format100));
            }
          }
          {
#line 464
          strcat((char */* __restrict  */)(colformat2), (char const   */* __restrict  */)(format100));
          }
        }
#line 452
        i ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 467
      strcat((char */* __restrict  */)(colformat1), (char const   */* __restrict  */)"\n");
#line 468
      strcat((char */* __restrict  */)(colformat2), (char const   */* __restrict  */)"\n");
#line 469
      col[colcount - 1] = colformat1;
#line 470
      col[colcount] = colformat2;
      }
#line 471
      if (headlength > 0) {
        {
#line 471
        printf((char const   */* __restrict  */)"%-s\n", tokenhead);
        }
      }
#line 472
      if (linecount < savelinecount) {
#line 472
        savelinecount = linecount;
      }
#line 473
      l = linecount;
#line 473
      s = savelinecount;
#line 474
      i = 1;
      {
#line 474
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 474
        if (! (i <= savelinecount)) {
#line 474
          goto while_break___17;
        }
#line 476
        if (i + s > l) {
          {
#line 476
          printf((char const   */* __restrict  */)col[1], i, fsptr[i]);
          }
        } else
#line 477
        if (i + 2 * s > l) {
          {
#line 477
          printf((char const   */* __restrict  */)col[2], i, fsptr[i], i + s, fsptr[i + s]);
          }
        } else
#line 478
        if (i + 3 * s > l) {
          {
#line 478
          printf((char const   */* __restrict  */)col[3], i, fsptr[i], i + s, fsptr[i + s],
                 i + 2 * s, fsptr[i + 2 * s]);
          }
        } else
#line 479
        if (i + 4 * s > l) {
          {
#line 479
          printf((char const   */* __restrict  */)col[4], i, fsptr[i], i + s, fsptr[i + s],
                 i + 2 * s, fsptr[i + 2 * s], i + 3 * s, fsptr[i + 3 * s]);
          }
        } else
#line 480
        if (i + 5 * s > l) {
          {
#line 480
          printf((char const   */* __restrict  */)col[5], i, fsptr[i], i + s, fsptr[i + s],
                 i + 2 * s, fsptr[i + 2 * s], i + 3 * s, fsptr[i + 3 * s], i + 4 * s,
                 fsptr[i + 4 * s]);
          }
        } else
#line 481
        if (i + 6 * s > l) {
          {
#line 481
          printf((char const   */* __restrict  */)col[6], i, fsptr[i], i + s, fsptr[i + s],
                 i + 2 * s, fsptr[i + 2 * s], i + 3 * s, fsptr[i + 3 * s], i + 4 * s,
                 fsptr[i + 4 * s], i + 5 * s, fsptr[i + 5 * s]);
          }
        } else
#line 482
        if (i + 7 * s > l) {
          {
#line 482
          printf((char const   */* __restrict  */)col[7], i, fsptr[i], i + s, fsptr[i + s],
                 i + 2 * s, fsptr[i + 2 * s], i + 3 * s, fsptr[i + 3 * s], i + 4 * s,
                 fsptr[i + 4 * s], i + 5 * s, fsptr[i + 5 * s], i + 6 * s, fsptr[i + 6 * s]);
          }
        } else
#line 483
        if (i + 8 * s > l) {
          {
#line 483
          printf((char const   */* __restrict  */)col[8], i, fsptr[i], i + s, fsptr[i + s],
                 i + 2 * s, fsptr[i + 2 * s], i + 3 * s, fsptr[i + 3 * s], i + 4 * s,
                 fsptr[i + 4 * s], i + 5 * s, fsptr[i + 5 * s], i + 6 * s, fsptr[i + 6 * s],
                 i + 7 * s, fsptr[i + 7 * s]);
          }
        } else
#line 484
        if (i + 9 * s > l) {
          {
#line 484
          printf((char const   */* __restrict  */)col[9], i, fsptr[i], i + s, fsptr[i + s],
                 i + 2 * s, fsptr[i + 2 * s], i + 3 * s, fsptr[i + 3 * s], i + 4 * s,
                 fsptr[i + 4 * s], i + 5 * s, fsptr[i + 5 * s], i + 6 * s, fsptr[i + 6 * s],
                 i + 7 * s, fsptr[i + 7 * s], i + 8 * s, fsptr[i + 8 * s]);
          }
        }
#line 474
        i ++;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 486
      if (savelinecount < 19) {
#line 486
        tmp___14 = savelinecount;
      } else {
#line 486
        tmp___14 = 19;
      }
      {
#line 486
      spacer(tmp___14);
#line 487
      printf((char const   */* __restrict  */)"Type number of food category (\"b\" to go back, <enter> to quit):  ");
#line 488
      get_string(junkstring, 20);
#line 489
      tmp___15 = strcmp((char const   *)(junkstring), "b");
      }
#line 489
      if (tmp___15 == 0) {
        {
#line 491
        key_take();
        }
#line 492
        return;
      } else {
        {
#line 489
        tmp___16 = strcmp((char const   *)(junkstring), "B");
        }
#line 489
        if (tmp___16 == 0) {
          {
#line 491
          key_take();
          }
#line 492
          return;
        }
      }
      {
#line 494
      i = atoi((char const   *)(junkstring));
      }
#line 495
      if (i > 0) {
#line 495
        if (i <= linecount) {
#line 497
          if (headlength > 0) {
            {
#line 499
            strcpy((char */* __restrict  */)key___0, (char const   */* __restrict  */)(tokenhead));
#line 500
            strcat((char */* __restrict  */)key___0, (char const   */* __restrict  */)fsptr[i]);
            }
          } else {
            {
#line 502
            strcpy((char */* __restrict  */)key___0, (char const   */* __restrict  */)fsptr[i]);
            }
          }
        } else {
#line 506
          *(key___0 + 0) = (char )'\000';
#line 507
          *(substring + 0) = (char )'\000';
        }
      } else {
#line 506
        *(key___0 + 0) = (char )'\000';
#line 507
        *(substring + 0) = (char )'\000';
      }
      {
#line 509
      key_encode(substring, key___0);
      }
    }
  }
#line 512
  return;
}
}
#line 514 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
void food_show(struct food *food_ptr , float *ratio ) 
{ 
  char servingstring[62] ;
  int count ;
  char *tmp ;
  double tmp___0 ;

  {
  {
#line 518
  printf((char const   */* __restrict  */)"%-60s   Grams  %8.2f\n", food_ptr->name,
         (double )(food_ptr->grams * *ratio));
#line 519
  tmp = format_serving(servingstring, ratio, food_ptr);
#line 519
  printf((char const   */* __restrict  */)"Serving:  %-50s   Ounces  %7.2f\n", tmp,
         (double )(*ratio * food_ptr->grams) / 28.349523);
  }
#line 520
  if (food_ptr->nutrient[12] > (float )0) {
#line 520
    tmp___0 = (double )food_ptr->nutrient[12];
  } else {
#line 520
    tmp___0 = 0.0;
  }
  {
#line 520
  printf((char const   */* __restrict  */)"          %-50s   Water    %6.2f%%\n",
         " ", tmp___0);
  }
#line 521
  if (! options.custom) {
#line 521
    if (options.screen == 0) {
      {
#line 521
      printf((char const   */* __restrict  */)"Percentages of \"Daily Values\" in this serving:                 Refuse   %3d%%\n\n",
             food_ptr->refuse);
      }
    }
  }
#line 522
  if (options.custom) {
#line 522
    if (options.screen == 0) {
      {
#line 522
      printf((char const   */* __restrict  */)"Percentages of customized DV in this serving:                  Refuse   %3d%%\n\n",
             food_ptr->refuse);
      }
    }
  }
#line 523
  if (options.screen > 0) {
    {
#line 523
    printf((char const   */* __restrict  */)"Nutrients in this serving:                                     Refuse   %3d%%\n\n",
           food_ptr->refuse);
    }
  }
#line 524
  count = 0;
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 524
    if (! (count < 159)) {
#line 524
      goto while_break;
    }
#line 524
    food_work.nutrient[count] = ((*ratio * food_ptr->nutrient[count]) * food_ptr->grams) / (float )100;
#line 524
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 525
  food_display(stdout);
#line 526
  spacer(20);
  }
#line 527
  return;
}
}
#line 529 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
struct food *food_number(int i ) 
{ 


  {
#line 531
  return (FoodIndex[i]);
}
}
#line 534 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
int find_ndbno(int ndbno ) 
{ 
  struct food *food_ptr ;

  {
#line 536
  food_ptr = & food_root;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! ((unsigned long )food_ptr->next != (unsigned long )((void *)0))) {
#line 537
      goto while_break;
    }
#line 539
    food_ptr = food_ptr->next;
#line 540
    if (food_ptr->ndb_no == ndbno) {
#line 540
      return (food_ptr->food_no);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  return (-1);
}
}
#line 545 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
struct food *find_ndbno_ptr(int ndbno ) 
{ 
  struct food *food_ptr ;

  {
#line 547
  food_ptr = & food_root;
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
#line 548
    if (! ((unsigned long )food_ptr->next != (unsigned long )((void *)0))) {
#line 548
      goto while_break;
    }
#line 550
    food_ptr = food_ptr->next;
#line 551
    if (food_ptr->ndb_no == ndbno) {
#line 551
      return (food_ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 553
  return ((struct food *)((void *)0));
}
}
#line 556 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
void make_food_index(void) 
{ 
  struct food *food_ptr ;
  int tmp ;

  {
#line 558
  food_ptr = & food_root;
#line 559
  FoodCount = 0;
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    if (! ((unsigned long )food_ptr->next != (unsigned long )((void *)0))) {
#line 560
      goto while_break;
    }
#line 562
    food_ptr = food_ptr->next;
#line 563
    food_ptr->food_no = FoodCount;
#line 564
    tmp = FoodCount;
#line 564
    FoodCount ++;
#line 564
    FoodIndex[tmp] = food_ptr;
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  return;
}
}
#line 568 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
int modify_food_index(int foodnum , struct food *food_ptr ) 
{ 
  int count ;

  {
#line 571
  count = FoodCount;
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! (count > foodnum)) {
#line 571
      goto while_break;
    }
#line 571
    FoodIndex[count] = FoodIndex[count - 1];
#line 571
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 572
  FoodIndex[foodnum] = food_ptr;
#line 573
  FoodCount ++;
#line 574
  food_ptr = & food_root;
#line 575
  count = 0;
  {
#line 575
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 575
    if (! (count < FoodCount)) {
#line 575
      goto while_break___0;
    }
#line 577
    food_ptr = food_ptr->next;
#line 578
    food_ptr->food_no = count;
#line 575
    count ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 580
  return (foodnum);
}
}
#line 583 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
void clear_work(void) 
{ 
  int count ;

  {
#line 586
  count = 0;
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (! (count < 159)) {
#line 586
      goto while_break;
    }
#line 586
    food_work.nutrient[count] = NoData;
#line 586
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 587
  food_work.grams = (float )0;
#line 588
  food_work.refuse = 0;
#line 589
  return;
}
}
#line 591 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
void food_display(FILE *fp___0 ) 
{ 
  int i ;
  int n6 ;
  float pctfat ;
  float pctcarb ;
  float pctprot ;
  float p3 ;
  float p6 ;
  float h3 ;
  float h6 ;
  float o ;
  char carbprotfat[9] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  float tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  float tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 594
  pctfat = (float )0;
#line 594
  pctcarb = (float )0;
#line 594
  pctprot = (float )0;
#line 597
  if ((double )food_work.nutrient[4] > 0.05) {
    {
#line 599
    pctcarb = ((float )100 * food_work.nutrient[145]) / food_work.nutrient[4];
#line 600
    pctprot = ((float )100 * food_work.nutrient[143]) / food_work.nutrient[4];
#line 601
    pctfat = ((float )100 * food_work.nutrient[144]) / food_work.nutrient[4];
#line 602
    tmp = test_for_negative_zero(& pctcarb);
    }
#line 602
    if (tmp) {
#line 602
      pctcarb = (float )0;
    }
    {
#line 603
    tmp___0 = test_for_negative_zero(& pctprot);
    }
#line 603
    if (tmp___0) {
#line 603
      pctprot = (float )0;
    }
    {
#line 604
    tmp___1 = test_for_negative_zero(& pctfat);
    }
#line 604
    if (tmp___1) {
#line 604
      pctfat = (float )0;
    }
  } else {
#line 608
    pctcarb = (float )0;
#line 608
    pctprot = (float )0;
#line 608
    pctfat = (float )0;
  }
  {
#line 610
  sprintf((char */* __restrict  */)(carbprotfat), (char const   */* __restrict  */)"%1.0f/%1.0f/%1.0f",
          (double )pctcarb, (double )pctprot, (double )pctfat);
  }
  {
#line 613
  if (options.screen == 1) {
#line 613
    goto case_1;
  }
#line 660
  if (options.screen == 2) {
#line 660
    goto case_2;
  }
#line 679
  if (options.screen == 3) {
#line 679
    goto case_3;
  }
#line 689
  if (options.screen == 4) {
#line 689
    goto case_4;
  }
#line 700
  if (options.screen == 5) {
#line 700
    goto case_5;
  }
#line 715
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 614
  food_display_line(fp___0, *(ScreenMap[options.screen] + 1), 0, 0, 0, 0);
#line 615
  food_display_line(fp___0, *(ScreenMap[options.screen] + 14), 0, 0, 0, 0);
#line 616
  food_display_line(fp___0, *(ScreenMap[options.screen] + 17), 0, 1, 0, 0);
#line 617
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"Carb/Prot/Fat    %8s  ",
          carbprotfat);
#line 618
  food_display_line(fp___0, *(ScreenMap[options.screen] + 15), 0, 0, 0, 0);
#line 619
  food_display_line(fp___0, *(ScreenMap[options.screen] + 16), 0, 1, 0, 0);
#line 620
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"\n");
#line 621
  food_display_line(fp___0, *(ScreenMap[options.screen] + 2), 0, 0, 0, 0);
#line 622
  food_display_line(fp___0, *(ScreenMap[options.screen] + 18), 0, 0, 0, 0);
#line 623
  food_display_line(fp___0, *(ScreenMap[options.screen] + 30), 0, 1, 0, 0);
#line 624
  i = 3;
  }
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 624
    if (! (i < 6)) {
#line 624
      goto while_break;
    }
    {
#line 626
    food_display_line(fp___0, *(ScreenMap[options.screen] + i), 0, 0, 0, 1);
#line 627
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 16)), 0, 0, 0, 0);
#line 628
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 28)), 0, 1, 0, 0);
#line 624
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 630
  food_display_line(fp___0, *(ScreenMap[options.screen] + i), 0, 0, 0, 2);
#line 631
  food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 16)), 0, 0, 0, 0);
#line 632
  food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 28)), 0, 1, 0, 0);
#line 633
  i = 7;
  }
  {
#line 633
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 633
    if (! (i < 9)) {
#line 633
      goto while_break___0;
    }
    {
#line 635
    food_display_line(fp___0, *(ScreenMap[options.screen] + i), 0, 0, 0, 4);
#line 636
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 16)), 0, 0, 0, 0);
#line 637
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 28)), 0, 1, 0, 0);
#line 633
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 639
  food_display_line(fp___0, *(ScreenMap[options.screen] + i), 0, 0, 0, 2);
#line 640
  food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 16)), 0, 0, 0, 0);
#line 641
  food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 28)), 0, 1, 0, 0);
#line 642
  i = 10;
  }
  {
#line 642
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 642
    if (! (i < 12)) {
#line 642
      goto while_break___1;
    }
    {
#line 644
    food_display_line(fp___0, *(ScreenMap[options.screen] + i), 0, 0, 0, 4);
#line 645
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 16)), 0, 0, 0, 0);
#line 646
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 28)), 0, 1, 0, 0);
#line 642
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 648
  food_display_line(fp___0, *(ScreenMap[options.screen] + i), 0, 0, 0, 4);
#line 649
  food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 16)), 0, 1, 0, 0);
#line 650
  food_display_line(fp___0, *(ScreenMap[options.screen] + 13), 0, 0, 0, 0);
#line 651
  food_display_line(fp___0, *(ScreenMap[options.screen] + 29), 0, 0, 0, 0);
#line 652
  p3 = ((float )902 * food_work.nutrient[156]) / food_work.nutrient[4];
#line 653
  p6 = ((float )902 * food_work.nutrient[153]) / food_work.nutrient[4];
#line 654
  h3 = ((float )902 * food_work.nutrient[157]) / food_work.nutrient[4];
#line 655
  h6 = ((float )902 * food_work.nutrient[154]) / food_work.nutrient[4];
#line 656
  o = ((((((float )902 * food_work.nutrient[1]) * options.fattyacidfactor) / food_work.nutrient[4] - food_work.nutrient[153]) - food_work.nutrient[154]) - food_work.nutrient[156]) - food_work.nutrient[157];
#line 657
  tmp___2 = n6hufa(p3, p6, h3, h6, o, food_work.nutrient[4]);
#line 657
  n6 = (int )tmp___2;
  }
#line 658
  if (n6 == 0) {
#line 658
    tmp___3 = 0;
  } else {
#line 658
    tmp___3 = 100 - n6;
  }
#line 658
  if (n6 == 0) {
#line 658
    tmp___4 = 0;
  } else {
#line 658
    tmp___4 = n6;
  }
  {
#line 658
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"Omega-6/3 Balance %2d/%1d\n",
          tmp___4, tmp___3);
  }
#line 659
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 661
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%-27s",
          "Carbohydrates");
#line 662
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%-27s\n\n",
          "Amino Acids");
#line 663
  i = 1;
  }
  {
#line 663
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 663
    if (! (i < 5)) {
#line 663
      goto while_break___2;
    }
    {
#line 665
    food_display_line(fp___0, *(ScreenMap[options.screen] + i), 0, 0, 0, 0);
#line 666
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 10)), 0, 0, 0, 0);
#line 667
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 21)), 0, 1, 0, 0);
#line 663
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 669
  i = 5;
  {
#line 669
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 669
    if (! (i < 11)) {
#line 669
      goto while_break___3;
    }
    {
#line 671
    food_display_line(fp___0, *(ScreenMap[options.screen] + i), 0, 0, 0, 1);
#line 672
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 10)), 0, 0, 0, 0);
#line 673
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 21)), 0, 1, 0, 0);
#line 669
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 675
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%-27s",
          " ");
#line 676
  food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 10)), 0, 1, 0, 0);
#line 677
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"\n\n");
  }
#line 678
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 680
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"Miscellaneous Nutrients\n\n");
#line 681
  i = 1;
  }
  {
#line 681
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 681
    if (! (i < 12)) {
#line 681
      goto while_break___4;
    }
    {
#line 683
    food_display_line(fp___0, *(ScreenMap[options.screen] + i), 0, 0, 0, 0);
#line 684
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 11)), 0, 0, 0, 0);
#line 685
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 22)), 0, 1, 0, 0);
#line 681
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 687
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"\n\n");
  }
#line 688
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 690
  food_display_line(fp___0, *(ScreenMap[options.screen] + 1), 0, 0, 1, 0);
#line 691
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"Saturated and Monounsaturated Fatty Acids\n");
#line 692
  food_display_line(fp___0, *(ScreenMap[options.screen] + 2), 0, 1, 1, 0);
#line 693
  i = 3;
  }
  {
#line 693
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 693
    if (! (i < 15)) {
#line 693
      goto while_break___5;
    }
    {
#line 695
    food_display_line(fp___0, *(ScreenMap[options.screen] + i), 0, 0, 1, 0);
#line 696
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 13)), 0, 1, 1, 0);
#line 693
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 698
  food_display_line(fp___0, *(ScreenMap[options.screen] + i), 0, 1, 1, 0);
  }
#line 699
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 701
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%-27s",
          "Polyunsaturated and Trans Fatty Acids\n\n");
#line 702
  i = 1;
  }
  {
#line 702
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 702
    if (! (i < 10)) {
#line 702
      goto while_break___6;
    }
    {
#line 704
    food_display_line(fp___0, *(ScreenMap[options.screen] + i), 0, 0, 1, 0);
#line 705
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 9)), 0, 0, 1, 0);
#line 706
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 18)), 0, 1, 1, 0);
#line 702
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 708
  i = 10;
  {
#line 708
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 708
    if (! (i < 12)) {
#line 708
      goto while_break___7;
    }
    {
#line 710
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%-54s",
            " ");
#line 711
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 18)), 0, 1, 1, 0);
#line 708
    i ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 713
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"\n\n");
  }
#line 714
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 716
  tmp___5 = test_for_negative_zero(& food_work.nutrient[*(ScreenMap[options.screen] + 1)]);
  }
#line 716
  if (tmp___5) {
    {
#line 717
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"Calories(%4.0f)    %5s     ",
            (double )DV[*(ScreenMap[options.screen] + 1)], "(nd)");
    }
  } else {
    {
#line 716
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"Calories(%4.0f)   %5.0f%%     ",
            (double )DV[*(ScreenMap[options.screen] + 1)], (double )((food_work.nutrient[*(ScreenMap[options.screen] + 1)] / DV[*(ScreenMap[options.screen] + 1)]) * (float )100));
    }
  }
  {
#line 718
  tmp___6 = test_for_negative_zero(& food_work.nutrient[*(ScreenMap[options.screen] + 14)]);
  }
#line 718
  if (tmp___6) {
    {
#line 719
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%-14s    %5s     ",
            Nutrient[*(ScreenMap[options.screen] + 14)], "(nd)");
    }
  } else {
    {
#line 718
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%-14s   %5.0f%%     ",
            Nutrient[*(ScreenMap[options.screen] + 14)], (double )((food_work.nutrient[*(ScreenMap[options.screen] + 14)] / DV[*(ScreenMap[options.screen] + 14)]) * (float )100));
    }
  }
  {
#line 720
  tmp___7 = test_for_negative_zero(& food_work.nutrient[*(ScreenMap[options.screen] + 17)]);
  }
#line 720
  if (tmp___7) {
    {
#line 721
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%-14s    %5s\n",
            Nutrient[*(ScreenMap[options.screen] + 17)], "(nd)");
    }
  } else {
    {
#line 720
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%-14s   %5.0f%%\n",
            Nutrient[*(ScreenMap[options.screen] + 17)], (double )((food_work.nutrient[*(ScreenMap[options.screen] + 17)] / DV[*(ScreenMap[options.screen] + 17)]) * (float )100));
    }
  }
  {
#line 722
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"Carb/Prot/Fat  %8s     ",
          carbprotfat);
#line 723
  food_display_line(fp___0, *(ScreenMap[options.screen] + 15), 1, 0, 0, 0);
#line 724
  tmp___8 = test_for_negative_zero(& food_work.nutrient[*(ScreenMap[options.screen] + 16)]);
  }
#line 724
  if (tmp___8) {
    {
#line 725
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%-15s   %5s\n",
            Nutrient[*(ScreenMap[options.screen] + 16)], "(nd)");
    }
  } else {
    {
#line 724
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%-15s  %5.0f%-1s\n",
            Nutrient[*(ScreenMap[options.screen] + 16)], (double )food_work.nutrient[*(ScreenMap[options.screen] + 16)],
            Unit[*(ScreenMap[options.screen] + 16)]);
    }
  }
  {
#line 726
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"\n");
#line 727
  tmp___9 = test_for_negative_zero(& food_work.nutrient[*(ScreenMap[options.screen] + 2)]);
  }
#line 727
  if (tmp___9) {
    {
#line 728
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%-14s    %5s     ",
            Nutrient[*(ScreenMap[options.screen] + 2)], "(nd)");
    }
  } else {
    {
#line 727
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%-14s   %5.0f%%     ",
            Nutrient[*(ScreenMap[options.screen] + 2)], (double )((food_work.nutrient[*(ScreenMap[options.screen] + 2)] / DV[*(ScreenMap[options.screen] + 2)]) * (float )100));
    }
  }
  {
#line 729
  food_display_line(fp___0, *(ScreenMap[options.screen] + 18), 1, 0, 0, 0);
#line 730
  food_display_line(fp___0, *(ScreenMap[options.screen] + 30), 1, 1, 0, 0);
#line 731
  food_display_line(fp___0, *(ScreenMap[options.screen] + 3), 1, 0, 0, 1);
#line 732
  food_display_line(fp___0, *(ScreenMap[options.screen] + 19), 1, 0, 0, 0);
#line 733
  food_display_line(fp___0, *(ScreenMap[options.screen] + 31), 1, 1, 0, 0);
#line 734
  tmp___10 = test_for_negative_zero(& food_work.nutrient[*(ScreenMap[options.screen] + 4)]);
  }
#line 734
  if (tmp___10) {
    {
#line 735
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)" %-13s    %5s     ",
            Nutrient[*(ScreenMap[options.screen] + 4)], "(nd)");
    }
  } else {
    {
#line 734
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)" %-13s   %5.0f%%     ",
            Nutrient[*(ScreenMap[options.screen] + 4)], (double )((food_work.nutrient[*(ScreenMap[options.screen] + 4)] / DV[111]) * (float )100));
    }
  }
  {
#line 736
  food_display_line(fp___0, *(ScreenMap[options.screen] + 20), 1, 0, 0, 0);
#line 737
  food_display_line(fp___0, *(ScreenMap[options.screen] + 32), 1, 1, 0, 0);
#line 738
  food_display_line(fp___0, *(ScreenMap[options.screen] + 5), 1, 0, 0, 1);
#line 739
  food_display_line(fp___0, *(ScreenMap[options.screen] + 21), 1, 0, 0, 0);
#line 740
  food_display_line(fp___0, *(ScreenMap[options.screen] + 33), 1, 1, 0, 0);
#line 741
  food_display_line(fp___0, *(ScreenMap[options.screen] + 6), 1, 0, 0, 2);
#line 742
  food_display_line(fp___0, *(ScreenMap[options.screen] + 22), 1, 0, 0, 0);
#line 743
  food_display_line(fp___0, *(ScreenMap[options.screen] + 34), 1, 1, 0, 0);
#line 744
  i = 7;
  }
  {
#line 744
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 744
    if (! (i < 9)) {
#line 744
      goto while_break___8;
    }
    {
#line 746
    food_display_line(fp___0, *(ScreenMap[options.screen] + i), 1, 0, 0, 4);
#line 747
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 16)), 1, 0, 0, 0);
#line 748
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 28)), 1, 1, 0, 0);
#line 744
    i ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 750
  food_display_line(fp___0, *(ScreenMap[options.screen] + i), 1, 0, 0, 2);
#line 751
  food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 16)), 1, 0, 0, 0);
#line 752
  food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 28)), 1, 1, 0, 0);
#line 753
  i = 10;
  }
  {
#line 753
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 753
    if (! (i < 12)) {
#line 753
      goto while_break___9;
    }
    {
#line 755
    food_display_line(fp___0, *(ScreenMap[options.screen] + i), 1, 0, 0, 4);
#line 756
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 16)), 1, 0, 0, 0);
#line 757
    food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 28)), 1, 1, 0, 0);
#line 753
    i ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 759
  food_display_line(fp___0, *(ScreenMap[options.screen] + i), 1, 0, 0, 4);
#line 760
  food_display_line(fp___0, *(ScreenMap[options.screen] + (i + 16)), 1, 1, 0, 0);
#line 761
  food_display_line(fp___0, *(ScreenMap[options.screen] + 13), 1, 0, 0, 0);
#line 762
  food_display_line(fp___0, *(ScreenMap[options.screen] + 29), 1, 0, 0, 0);
#line 763
  p3 = ((float )902 * food_work.nutrient[156]) / food_work.nutrient[4];
#line 764
  p6 = ((float )902 * food_work.nutrient[153]) / food_work.nutrient[4];
#line 765
  h3 = ((float )902 * food_work.nutrient[157]) / food_work.nutrient[4];
#line 766
  h6 = ((float )902 * food_work.nutrient[154]) / food_work.nutrient[4];
#line 767
  o = ((((((float )902 * food_work.nutrient[1]) * options.fattyacidfactor) / food_work.nutrient[4] - food_work.nutrient[153]) - food_work.nutrient[154]) - food_work.nutrient[156]) - food_work.nutrient[157];
#line 768
  tmp___11 = n6hufa(p3, p6, h3, h6, o, food_work.nutrient[4]);
#line 768
  n6 = (int )tmp___11;
  }
#line 769
  if (n6 == 0) {
#line 769
    tmp___12 = 0;
  } else {
#line 769
    tmp___12 = 100 - n6;
  }
#line 769
  if (n6 == 0) {
#line 769
    tmp___13 = 0;
  } else {
#line 769
    tmp___13 = n6;
  }
  {
#line 769
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"Omega-6/3 Balance %2d/%1d\n",
          tmp___13, tmp___12);
  }
#line 770
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 772
  return;
}
}
#line 774 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
void food_display_line(FILE *fp___0 , int nut , int dv , int eol , int precision ,
                       int indent ) 
{ 
  int flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 777
  flags = (100 * dv + 10 * eol) + precision;
  {
#line 780
  if (indent == 1) {
#line 780
    goto case_1;
  }
#line 782
  if (indent == 2) {
#line 782
    goto case_2;
  }
#line 784
  if (indent == 4) {
#line 784
    goto case_4;
  }
#line 786
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 780
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)" %-13s",
          Nutrient[nut]);
  }
#line 781
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 782
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"  %-12s",
          Nutrient[nut]);
  }
#line 783
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 784
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"    %-10s",
          Nutrient[nut]);
  }
#line 785
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 786
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%-14s",
          Nutrient[nut]);
  }
#line 787
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 792
  if (flags == 0) {
#line 792
    goto case_0;
  }
#line 796
  if (flags == 1) {
#line 796
    goto case_1___0;
  }
#line 800
  if (flags == 10) {
#line 800
    goto case_10;
  }
#line 817
  if (flags == 11) {
#line 817
    goto case_11;
  }
#line 834
  if (flags == 110) {
#line 834
    goto case_110;
  }
#line 838
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
#line 793
  tmp = test_for_negative_zero(& food_work.nutrient[nut]);
  }
#line 793
  if (tmp) {
    {
#line 794
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%9s%-3s ",
            "(nd)", " ");
    }
  } else {
    {
#line 793
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%8.1f %-3s ",
            (double )food_work.nutrient[nut], Unit[nut]);
    }
  }
#line 795
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 797
  tmp___0 = test_for_negative_zero(& food_work.nutrient[nut]);
  }
#line 797
  if (tmp___0) {
    {
#line 798
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%9s%-3s ",
            "(nd)", " ");
    }
  } else {
    {
#line 797
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%8.2f %-3s ",
            (double )food_work.nutrient[nut], Unit[nut]);
    }
  }
#line 799
  goto switch_break___0;
  case_10: /* CIL Label */ 
  {
#line 802
  tmp___1 = test_for_negative_zero(& food_work.nutrient[nut]);
  }
#line 802
  if (tmp___1) {
    {
#line 803
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%9s%-3s\n",
            "(nd)", " ");
    }
  } else {
    {
#line 802
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%8.1f %-3s\n",
            (double )food_work.nutrient[nut], Unit[nut]);
    }
  }
#line 816
  goto switch_break___0;
  case_11: /* CIL Label */ 
  {
#line 819
  tmp___2 = test_for_negative_zero(& food_work.nutrient[nut]);
  }
#line 819
  if (tmp___2) {
    {
#line 820
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%9s%-3s\n",
            "(nd)", " ");
    }
  } else {
    {
#line 819
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%8.2f %-3s\n",
            (double )food_work.nutrient[nut], Unit[nut]);
    }
  }
#line 833
  goto switch_break___0;
  case_110: /* CIL Label */ 
  {
#line 835
  tmp___3 = test_for_negative_zero(& food_work.nutrient[nut]);
  }
#line 835
  if (tmp___3) {
    {
#line 836
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"     %4s\n",
            "(nd)");
    }
  } else {
    {
#line 835
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"   %5.0f%%\n",
            (double )((food_work.nutrient[nut] / DV[nut]) * (float )100));
    }
  }
#line 837
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 839
  tmp___4 = test_for_negative_zero(& food_work.nutrient[nut]);
  }
#line 839
  if (tmp___4) {
    {
#line 840
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"    %5s     ",
            "(nd)");
    }
  } else {
    {
#line 839
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"   %5.0f%%     ",
            (double )((food_work.nutrient[nut] / DV[nut]) * (float )100));
    }
  }
#line 841
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 843
  return;
}
}
#line 845 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
void order_new_recipe(void) 
{ 
  struct food *food_ptr ;

  {
#line 847
  food_ptr = & recipe_root;
  {
#line 848
  while (1) {
    while_continue: /* CIL Label */ ;
#line 848
    if (! ((unsigned long )food_ptr->next != (unsigned long )((void *)0))) {
#line 848
      goto while_break;
    }
#line 848
    food_ptr = food_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 849
  new_recipe->next = (struct food *)((void *)0);
#line 850
  food_ptr->next = new_recipe;
#line 851
  return;
}
}
#line 853 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
void modify_recipe_food(int num , char *qty ) 
{ 
  struct food *m ;
  struct food *recipe_ptr ;
  int count ;
  float newqty ;
  struct food *tmp ;

  {
#line 855
  recipe_ptr = & recipe_root;
#line 856
  count = 0;
  {
#line 858
  while (1) {
    while_continue: /* CIL Label */ ;
#line 858
    if (! ((unsigned long )recipe_ptr->next != (unsigned long )((void *)0))) {
#line 858
      goto while_break;
    }
#line 860
    count ++;
#line 861
    if (count == num) {
      {
#line 863
      tmp = food_number((recipe_ptr->next)->food_no);
#line 863
      newqty = evaluate_qty(tmp, qty);
      }
#line 864
      if (newqty == (float )0) {
        {
#line 866
        m = recipe_ptr->next;
#line 867
        recipe_ptr->next = (recipe_ptr->next)->next;
#line 868
        free((void *)m);
        }
      } else {
#line 870
        (recipe_ptr->next)->grams = newqty;
      }
#line 871
      return;
    }
#line 873
    recipe_ptr = recipe_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 875
  return;
}
}
#line 877 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
void modify_label_food(int num , char *command ) 
{ 
  struct food *m ;
  struct food *pm ;
  struct food *am ;
  struct food *po ;
  struct food *ao ;
  struct food *recipe_ptr ;
  int count ;
  int action ;

  {
  {
#line 879
  m = (struct food *)((void *)0);
#line 879
  pm = (struct food *)((void *)0);
#line 879
  am = (struct food *)((void *)0);
#line 879
  po = (struct food *)((void *)0);
#line 879
  ao = (struct food *)((void *)0);
#line 879
  recipe_ptr = & recipe_root;
#line 880
  count = 0;
#line 882
  action = evaluate_action(command);
  }
#line 883
  if (num == action) {
#line 883
    return;
  }
  {
#line 884
  while (1) {
    while_continue: /* CIL Label */ ;
#line 884
    if (! ((unsigned long )recipe_ptr->next != (unsigned long )((void *)0))) {
#line 884
      goto while_break;
    }
#line 886
    count ++;
#line 887
    if (count == action) {
#line 887
      if (action > 0) {
#line 887
        if (num > action) {
#line 889
          ao = recipe_ptr;
#line 890
          po = recipe_ptr->next;
        }
      }
    }
#line 892
    if (count == action) {
#line 892
      if (action > 0) {
#line 892
        if (num < action) {
#line 894
          ao = recipe_ptr->next;
#line 895
          if ((unsigned long )recipe_ptr->next != (unsigned long )((void *)0)) {
#line 895
            po = (recipe_ptr->next)->next;
          } else {
#line 896
            po = (struct food *)((void *)0);
          }
        }
      }
    }
#line 898
    if (count == num) {
#line 900
      m = recipe_ptr->next;
#line 901
      pm = (recipe_ptr->next)->next;
#line 902
      am = recipe_ptr;
#line 903
      if (action == 0) {
        {
#line 905
        recipe_ptr->next = (recipe_ptr->next)->next;
#line 906
        free((void *)m);
        }
#line 907
        return;
      }
#line 909
      if (action < 0) {
#line 911
        if (action == -1) {
#line 911
          if (m->refuse >= 0) {
#line 911
            (m->refuse) ++;
          }
        }
#line 912
        if (action == -1) {
#line 912
          if (m->refuse < 0) {
#line 912
            m->refuse = 1;
          }
        }
#line 913
        if (action == -2) {
#line 913
          if (m->refuse <= 0) {
#line 913
            (m->refuse) --;
          }
        }
#line 914
        if (action == -2) {
#line 914
          if (m->refuse > 0) {
#line 914
            m->refuse = -1;
          }
        }
#line 915
        if (action == -3) {
#line 915
          if (m->refuse < 0) {
#line 915
            (m->refuse) ++;
          }
        }
#line 916
        if (action == -3) {
#line 916
          if (m->refuse > 0) {
#line 916
            (m->refuse) --;
          }
        }
#line 917
        return;
      }
    }
#line 920
    recipe_ptr = recipe_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 922
  if (num > count) {
#line 922
    return;
  } else
#line 922
  if (action > count) {
#line 922
    return;
  }
#line 923
  am->next = pm;
#line 924
  ao->next = m;
#line 925
  m->next = po;
#line 926
  return;
}
}
#line 928 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
void compute_derived_fields(struct food *food_ptr ) 
{ 
  float ratio ;
  float realcal ;
  float alcCalFactor ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 930
  alcCalFactor = (float )6.93;
#line 931
  food_ptr->nutrient[158] = (float )((double )food_ptr->nutrient[80] / 0.45 + (double )(food_ptr->nutrient[36] - food_ptr->nutrient[80]) / 0.67);
#line 932
  if (food_ptr->nutrient[127] > (float )0) {
#line 932
    food_ptr->nutrient[147] = food_ptr->nutrient[127];
  } else {
#line 932
    food_ptr->nutrient[147] = (((food_ptr->nutrient[95] - food_ptr->nutrient[119]) - food_ptr->nutrient[121]) - food_ptr->nutrient[120]) - food_ptr->nutrient[122];
  }
#line 933
  if (food_ptr->nutrient[147] == (float )0) {
    {
#line 933
    tmp = test_for_negative_zero(& food_ptr->nutrient[95]);
    }
#line 933
    if (tmp) {
#line 933
      food_ptr->nutrient[147] = NoData;
    }
  }
#line 934
  if (food_ptr->nutrient[147] < (float )0) {
#line 934
    food_ptr->nutrient[147] = (float )0;
  }
#line 935
  food_ptr->nutrient[153] = food_ptr->nutrient[147];
#line 936
  food_ptr->nutrient[153] += food_ptr->nutrient[129];
#line 937
  if (food_ptr->nutrient[136] > (float )0) {
#line 937
    food_ptr->nutrient[149] = food_ptr->nutrient[136];
  } else {
#line 937
    food_ptr->nutrient[149] = (food_ptr->nutrient[96] - food_ptr->nutrient[129]) - food_ptr->nutrient[140];
  }
#line 938
  if (food_ptr->nutrient[149] == (float )0) {
    {
#line 938
    tmp___0 = test_for_negative_zero(& food_ptr->nutrient[96]);
    }
#line 938
    if (tmp___0) {
#line 938
      food_ptr->nutrient[149] = NoData;
    }
  }
#line 939
  if (food_ptr->nutrient[149] < (float )0) {
#line 939
    food_ptr->nutrient[149] = (float )0;
  }
#line 940
  food_ptr->nutrient[156] = food_ptr->nutrient[149];
#line 941
  food_ptr->nutrient[156] += food_ptr->nutrient[102];
#line 942
  food_ptr->nutrient[154] = food_ptr->nutrient[124];
#line 943
  if (food_ptr->nutrient[137] > (float )0) {
#line 943
    food_ptr->nutrient[157] += food_ptr->nutrient[137];
  }
#line 944
  if (food_ptr->nutrient[138] > (float )0) {
#line 944
    food_ptr->nutrient[154] += food_ptr->nutrient[138];
  }
#line 945
  if (food_ptr->nutrient[137] == (float )0) {
#line 945
    if (food_ptr->nutrient[138] == (float )0) {
#line 945
      food_ptr->nutrient[154] += food_ptr->nutrient[131];
    }
  }
#line 946
  food_ptr->nutrient[148] = food_ptr->nutrient[97];
#line 947
  if (food_ptr->nutrient[139] > (float )0) {
#line 947
    food_ptr->nutrient[148] = food_ptr->nutrient[139];
  }
#line 948
  food_ptr->nutrient[154] += food_ptr->nutrient[148];
#line 949
  food_ptr->nutrient[150] = food_ptr->nutrient[104];
#line 950
  food_ptr->nutrient[157] = food_ptr->nutrient[104];
#line 951
  food_ptr->nutrient[157] += food_ptr->nutrient[106];
#line 952
  food_ptr->nutrient[151] = food_ptr->nutrient[98];
#line 953
  food_ptr->nutrient[157] += food_ptr->nutrient[98];
#line 954
  if (food_ptr->nutrient[156] == (float )0) {
    {
#line 954
    tmp___1 = test_for_negative_zero(& food_ptr->nutrient[149]);
    }
#line 954
    if (tmp___1) {
      {
#line 954
      tmp___2 = test_for_negative_zero(& food_ptr->nutrient[102]);
      }
#line 954
      if (tmp___2) {
#line 954
        food_ptr->nutrient[156] = NoData;
      }
    }
  }
#line 955
  if (food_ptr->nutrient[157] == (float )0) {
    {
#line 955
    tmp___3 = test_for_negative_zero(& food_ptr->nutrient[150]);
    }
#line 955
    if (tmp___3) {
      {
#line 955
      tmp___4 = test_for_negative_zero(& food_ptr->nutrient[106]);
      }
#line 955
      if (tmp___4) {
        {
#line 955
        tmp___5 = test_for_negative_zero(& food_ptr->nutrient[151]);
        }
#line 955
        if (tmp___5) {
#line 955
          food_ptr->nutrient[157] = NoData;
        }
      }
    }
  }
#line 956
  if (food_ptr->nutrient[153] == (float )0) {
    {
#line 956
    tmp___6 = test_for_negative_zero(& food_ptr->nutrient[147]);
    }
#line 956
    if (tmp___6) {
      {
#line 956
      tmp___7 = test_for_negative_zero(& food_ptr->nutrient[129]);
      }
#line 956
      if (tmp___7) {
#line 956
        food_ptr->nutrient[153] = NoData;
      }
    }
  }
#line 957
  if (food_ptr->nutrient[154] == (float )0) {
    {
#line 957
    tmp___8 = test_for_negative_zero(& food_ptr->nutrient[124]);
    }
#line 957
    if (tmp___8) {
      {
#line 957
      tmp___9 = test_for_negative_zero(& food_ptr->nutrient[131]);
      }
#line 957
      if (tmp___9) {
        {
#line 957
        tmp___10 = test_for_negative_zero(& food_ptr->nutrient[138]);
        }
#line 957
        if (tmp___10) {
          {
#line 957
          tmp___11 = test_for_negative_zero(& food_ptr->nutrient[148]);
          }
#line 957
          if (tmp___11) {
#line 957
            food_ptr->nutrient[154] = NoData;
          }
        }
      }
    }
  }
#line 958
  food_ptr->nutrient[152] = food_ptr->nutrient[153] + food_ptr->nutrient[154];
#line 959
  if (food_ptr->nutrient[152] == (float )0) {
    {
#line 959
    tmp___12 = test_for_negative_zero(& food_ptr->nutrient[153]);
    }
#line 959
    if (tmp___12) {
      {
#line 959
      tmp___13 = test_for_negative_zero(& food_ptr->nutrient[154]);
      }
#line 959
      if (tmp___13) {
#line 959
        food_ptr->nutrient[152] = NoData;
      }
    }
  }
#line 960
  food_ptr->nutrient[155] = food_ptr->nutrient[156] + food_ptr->nutrient[157];
#line 961
  if (food_ptr->nutrient[155] == (float )0) {
    {
#line 961
    tmp___14 = test_for_negative_zero(& food_ptr->nutrient[156]);
    }
#line 961
    if (tmp___14) {
      {
#line 961
      tmp___15 = test_for_negative_zero(& food_ptr->nutrient[157]);
      }
#line 961
      if (tmp___15) {
#line 961
        food_ptr->nutrient[155] = NoData;
      }
    }
  }
#line 963
  if (food_ptr->prot_cal_factor == (float )0) {
#line 963
    if (food_ptr->fat_cal_factor == (float )0) {
#line 963
      if (food_ptr->cho_cal_factor == (float )0) {
#line 963
        if (food_ptr->nutrient[4] > (float )0) {
#line 965
          food_ptr->prot_cal_factor = (float )4;
#line 966
          food_ptr->fat_cal_factor = (float )9;
#line 967
          food_ptr->cho_cal_factor = (float )4;
#line 968
          food_ptr->nutrient[143] = food_ptr->prot_cal_factor * food_ptr->nutrient[0];
#line 969
          food_ptr->nutrient[144] = food_ptr->fat_cal_factor * food_ptr->nutrient[1];
#line 970
          food_ptr->nutrient[145] = food_ptr->cho_cal_factor * food_ptr->nutrient[2];
#line 971
          realcal = food_ptr->nutrient[4] - food_ptr->nutrient[11] * alcCalFactor;
#line 972
          ratio = realcal / ((food_ptr->nutrient[143] + food_ptr->nutrient[144]) + food_ptr->nutrient[145]);
#line 973
          food_ptr->prot_cal_factor *= ratio;
#line 974
          food_ptr->fat_cal_factor *= ratio;
#line 975
          food_ptr->cho_cal_factor *= ratio;
        }
      }
    }
  }
#line 977
  food_ptr->nutrient[143] = food_ptr->prot_cal_factor * food_ptr->nutrient[0];
#line 978
  food_ptr->nutrient[144] = food_ptr->fat_cal_factor * food_ptr->nutrient[1];
#line 979
  food_ptr->nutrient[145] = food_ptr->cho_cal_factor * food_ptr->nutrient[2];
#line 980
  food_ptr->nutrient[146] = food_ptr->nutrient[2] - food_ptr->nutrient[19];
#line 981
  if (food_ptr->nutrient[146] < (float )0) {
#line 981
    food_ptr->nutrient[146] = (float )0;
  }
#line 982
  return;
}
}
#line 984 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
char *format_serving(char *buffer , float *ratio , struct food *food_ptr ) 
{ 


  {
  {
#line 986
  sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)"%1.3g",
          (double )(food_ptr->qty * *ratio));
#line 987
  strncat((char */* __restrict  */)buffer, (char const   */* __restrict  */)" ", (size_t )50);
#line 988
  strncat((char */* __restrict  */)buffer, (char const   */* __restrict  */)(food_ptr->unit),
          (size_t )50);
#line 989
  *(buffer + 49) = (char )'\000';
  }
#line 990
  return (buffer);
}
}
#line 993 "/home/wheatley/newnew/temp/nut-nutrition-15.5/food.c"
float n6hufa(float p3 , float p6 , float h3 , float h6 , float o , float c ) 
{ 
  float pc6 ;
  float pc3 ;
  float co ;
  float ks ;
  float hc6 ;
  float hc3 ;
  float hi3 ;
  float answer ;

  {
#line 995
  pc6 = (float ).0441;
#line 995
  pc3 = (float ).0555;
#line 995
  co = (float )5;
#line 995
  ks = (float ).175;
#line 995
  hc6 = (float ).7;
#line 995
  hc3 = (float )3;
#line 996
  hi3 = (float ).005;
#line 1003
  if (p3 == (float )0) {
#line 1003
    if (p6 == (float )0) {
#line 1003
      if (h3 == (float )0) {
#line 1003
        if (h6 == (float )0) {
#line 1003
          return ((float )0);
        }
      }
    }
  }
#line 1004
  if (c == (float )0) {
#line 1004
    return ((float )0);
  }
#line 1005
  answer = (float )100 / ((float )1 + (pc6 / p6) * (((((float )1 + p3 / pc3) + h3 / hi3) + o / co) + p6 / ks)) + (float )100 / ((float )1 + (hc6 / h6) * ((float )1 + h3 / hc3));
#line 1006
  if (answer <= (float )90) {
#line 1006
    if (answer >= (float )15) {
#line 1006
      return (answer);
    }
  }
#line 1007
  if (answer > (float )90) {
#line 1007
    return ((float )90);
  } else {
#line 1008
    return ((float )15);
  }
}
}
#line 25 "/home/wheatley/newnew/temp/nut-nutrition-15.5/menu.h"
void menu(void) ;
#line 34 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.h"
void read_food_files(void) ;
#line 41
int read_food_db(void) ;
#line 42
void read_meal_db(void) ;
#line 43
void read_theusual_db(void) ;
#line 50
void read_OPTIONS(int dontwrite ) ;
#line 53
void make_filenames(char *sub ) ;
#line 55
void write_version(void) ;
#line 87 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.h"
int mealdb_mealsperday  ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 31 "/home/wheatley/newnew/temp/nut-nutrition-15.5/main.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 33
  food_root.next = (struct food *)((void *)0);
#line 34
  meal_root.next = (struct meal *)((void *)0);
#line 35
  recipe_root.next = (struct food *)((void *)0);
#line 36
  theusual_root.next = (struct meal *)((void *)0);
#line 37
  initializations();
  }
#line 38
  if (argc > 1) {
    {
#line 38
    make_filenames(*(argv + 1));
    }
  } else {
    {
#line 39
    make_filenames((char *)"");
    }
  }
  {
#line 40
  tmp = version(0);
  }
#line 40
  if (tmp == 15) {
    {
#line 40
    tmp___0 = version(1);
    }
#line 40
    if (tmp___0 == 5) {
      {
#line 40
      tmp___1 = read_food_db();
      }
#line 40
      if (tmp___1) {
        {
#line 42
        read_meal_db();
#line 43
        read_theusual_db();
#line 44
        read_OPTIONS(0);
        }
      } else {
        {
#line 46
        read_food_files();
        }
      }
    } else {
      {
#line 46
      read_food_files();
      }
    }
  } else {
    {
#line 46
    read_food_files();
    }
  }
  {
#line 47
  tmp___8 = version(0);
  }
#line 47
  if (tmp___8 != 15) {
#line 47
    goto _L___2;
  } else {
    {
#line 47
    tmp___9 = version(1);
    }
#line 47
    if (tmp___9 != 5) {
      _L___2: /* CIL Label */ 
      {
#line 49
      tmp___5 = version(0);
      }
#line 49
      if (tmp___5 == 10) {
        {
#line 49
        tmp___6 = version(1);
        }
#line 49
        if (tmp___6 < 8) {
#line 49
          goto _L___0;
        } else {
#line 49
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 49
        tmp___7 = version(0);
        }
#line 49
        if (tmp___7 < 10) {
          _L___0: /* CIL Label */ 
#line 51
          if (mealdb_mealsperday > 0) {
            {
#line 51
            tmp___2 = version(0);
            }
#line 51
            if (tmp___2 == 10) {
              {
#line 51
              tmp___3 = version(1);
              }
#line 51
              if (tmp___3 < 8) {
#line 51
                options.mealsperday = mealdb_mealsperday;
              } else {
#line 51
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
#line 51
              tmp___4 = version(0);
              }
#line 51
              if (tmp___4 < 10) {
#line 51
                options.mealsperday = mealdb_mealsperday;
              } else {
#line 52
                options.mealsperday = 3;
              }
            }
          } else {
#line 52
            options.mealsperday = 3;
          }
        }
      }
    }
  }
  {
#line 55
  tmp___10 = version(0);
  }
#line 55
  if (tmp___10 != 15) {
    {
#line 55
    write_version();
    }
  } else {
    {
#line 55
    tmp___11 = version(1);
    }
#line 55
    if (tmp___11 != 5) {
      {
#line 55
      write_version();
      }
    }
  }
  {
#line 56
  menu();
#line 57
  exit(0);
  }
}
}
#line 25 "/home/wheatley/newnew/temp/nut-nutrition-15.5/theusual.h"
void theusual(void) ;
#line 31 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.h"
void get_qty(float *result , float *grams , float *calories ) ;
#line 38
void key_put(char *key___0 ) ;
#line 45 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.h"
void write_theusual_db(void) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 32 "/home/wheatley/newnew/temp/nut-nutrition-15.5/theusual.c"
void theusual(void) 
{ 
  struct food *food_ptr ;
  char meal_date[9] ;
  char new_meal_date[9] ;
  char key___0[121] ;
  char buff[128] ;
  char *token ;
  int c ;
  int d ;
  int modfood ;
  int junk ;
  float ratio ;
  float one ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct meal *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 41
  ratio = (float )0;
#line 41
  one = (float )1;
#line 42
  key___0[0] = (char )'\000';
#line 43
  header((char *)"NUT:  Record \"The Usual\"--Customary Meals");
#line 45
  printf((char const   */* __restrict  */)"When you record Customary Meals, you can save time on data entry.  For instance,\n");
#line 49
  printf((char const   */* __restrict  */)"if you record a customary meal named \"LUNCH\", you can then type \"theusuallunch\"\n");
#line 50
  printf((char const   */* __restrict  */)"on the \"Record Meals\" screen and all the foods will added as specified.\n\n");
#line 51
  tmp = theusual_list();
#line 51
  spacer(tmp + 3);
#line 52
  printf((char const   */* __restrict  */)"\nType \"The Usual\" Identifier (max. 8 characters):  ");
#line 53
  get_string(new_meal_date, 8);
#line 54
  tmp___0 = strlen((char const   *)(new_meal_date));
  }
#line 54
  if (tmp___0 == 0UL) {
#line 54
    return;
  }
#line 55
  c = 0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (c < 9)) {
#line 55
      goto while_break;
    }
    {
#line 55
    tmp___1 = toupper((int )new_meal_date[c]);
#line 55
    meal_date[c] = (char )tmp___1;
#line 55
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  c = 0;
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 56
    if (! (c < 9)) {
#line 56
      goto while_break___0;
    }
#line 56
    if ((int )meal_date[c] == 32) {
#line 56
      goto while_break___0;
    }
#line 56
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 57
  d = c;
  {
#line 57
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 57
    if (! (d < 9)) {
#line 57
      goto while_break___1;
    }
#line 57
    meal_date[d] = (char )'\000';
#line 57
    d ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 58
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 60
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 62
      if (ratio != (float )-383838) {
        {
#line 62
        tmp___4 = theusual_find(meal_date);
        }
#line 62
        if ((unsigned long )tmp___4 != (unsigned long )((struct meal *)0)) {
          {
#line 64
          header((char *)"NUT:  Record \"The Usual\"--Customary Meals");
#line 65
          tmp___3 = theusual_show(meal_date);
          }
#line 65
          if (tmp___3) {
            {
#line 72
            printf((char const   */* __restrict  */)"\nEnter food name, # to delete, <enter> to quit:  ");
#line 73
            get_string(key___0, 60);
#line 74
            tmp___2 = strcmp((char const   *)(key___0), "");
            }
#line 74
            if (tmp___2 == 0) {
              {
#line 76
              meal_date[0] = (char )'\000';
#line 77
              theusual();
              }
            }
          } else {
            {
#line 67
            printf((char const   */* __restrict  */)"\nPress <enter> to continue...");
#line 68
            junk = get_int();
            }
          }
        }
      }
#line 81
      if ((int )meal_date[0] == 0) {
#line 81
        return;
      }
      {
#line 82
      modfood = atoi((char const   *)(key___0));
#line 83
      strncpy((char */* __restrict  */)(buff), (char const   */* __restrict  */)(key___0),
              (size_t )60);
#line 84
      token = strtok((char */* __restrict  */)(buff), (char const   */* __restrict  */)", ");
#line 85
      token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)", ");
#line 86
      tmp___5 = strcmp((char const   *)(key___0), "");
      }
#line 86
      if (tmp___5 == 0) {
#line 86
        goto while_break___3;
      } else
#line 86
      if (modfood == 0) {
#line 86
        goto while_break___3;
      }
      {
#line 87
      modify_theusual(meal_date, modfood, token);
#line 88
      write_theusual_db();
#line 89
      strcpy((char */* __restrict  */)(key___0), (char const   */* __restrict  */)"");
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 91
    key_put(key___0);
#line 92
    food_ptr = food_choice((char *)"NUT:  Record \"The Usual\"--Customary Meals",
                           0);
    }
#line 93
    if ((unsigned long )food_ptr == (unsigned long )((struct food *)-1)) {
      {
#line 95
      theusual();
      }
#line 96
      return;
    }
#line 98
    if ((unsigned long )food_ptr == (unsigned long )((struct food *)0)) {
      {
#line 98
      key_clean();
      }
    }
#line 99
    if ((unsigned long )food_ptr == (unsigned long )((struct food *)0)) {
#line 99
      goto __Cont;
    }
    {
#line 100
    header((char *)"NUT:  Record \"The Usual\"--Customary Meals");
#line 101
    food_show(food_ptr, & one);
#line 102
    get_qty(& ratio, & food_ptr->grams, & food_ptr->nutrient[4]);
    }
#line 103
    if (ratio == (float )-383838) {
      {
#line 105
      key_take();
#line 106
      tmp___6 = key_take();
#line 106
      strcpy((char */* __restrict  */)(key___0), (char const   */* __restrict  */)tmp___6);
      }
    }
#line 108
    if (ratio != (float )0) {
#line 108
      if (ratio != (float )-383838) {
        {
#line 110
        tmp___7 = malloc(sizeof(struct food ));
#line 110
        new_theusual = (struct meal *)tmp___7;
        }
#line 110
        if ((unsigned long )new_theusual == (unsigned long )((void *)0)) {
          {
#line 112
          printf((char const   */* __restrict  */)"We are out of memory.  Bummer.\n");
#line 113
          abort();
          }
        }
        {
#line 115
        new_theusual->ndb_no = food_ptr->ndb_no;
#line 116
        new_theusual->food_no = food_ptr->food_no;
#line 117
        strcpy((char */* __restrict  */)(new_theusual->meal_date), (char const   */* __restrict  */)(meal_date));
#line 118
        new_theusual->meal = (char)38;
#line 119
        new_theusual->grams = food_ptr->grams * ratio;
#line 120
        order_new_theusual();
#line 121
        write_theusual_db();
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
}
}
#line 178 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 32 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.h"
char subuser[2000]  ;
#line 35
void read_joined_db(char *textfile ) ;
#line 36
void read_FOOD(char *textfile ) ;
#line 37
void read_NUT(char *textfile ) ;
#line 38
void read_WEIGHT(char *textfile ) ;
#line 39
void read_weightlib(int ndbno , char *buffer , int bufsize , char **result , int *resultparm ) ;
#line 40
void write_food_db(void) ;
#line 44
void write_meal_db(void) ;
#line 46
void write_OPTIONS(void) ;
#line 47
void write_recipe(struct food *food_ptr ) ;
#line 48
void write_serving(struct food *food_ptr ) ;
#line 49
void read_options_db(int dontwrite ) ;
#line 51
void read_WLOG(int *n , int *fatn , int *up , float *weightslope , float *fatslope ) ;
#line 52
void write_WLOG(float *weight , float *bf , float *stardate ) ;
#line 56
void check_version_file(void) ;
#line 57
void meal_export(void) ;
#line 89 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.h"
void initialize_options(void) ;
#line 99
void auto_cal(float *bufptr , int analflag ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 35 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char nutdir1[15]  = 
#line 35 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
  {      (char )'.',      (char )'n',      (char )'u',      (char )'t', 
        (char )'-',      (char )'n',      (char )'u',      (char )'t', 
        (char )'r',      (char )'i',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'\000'};
#line 38 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char USDAjoined1[9]  = 
#line 38
  {      (char )'s',      (char )'r',      (char )'2',      (char )'2', 
        (char )'.',      (char )'n',      (char )'u',      (char )'t', 
        (char )'\000'};
#line 39 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char globalFOOD1[13]  = 
#line 39
  {      (char )'F',      (char )'O',      (char )'O',      (char )'D', 
        (char )'_',      (char )'D',      (char )'E',      (char )'S', 
        (char )'.',      (char )'t',      (char )'x',      (char )'t', 
        (char )'\000'};
#line 40 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char globalNUT1[13]  = 
#line 40
  {      (char )'N',      (char )'U',      (char )'T',      (char )'_', 
        (char )'D',      (char )'A',      (char )'T',      (char )'A', 
        (char )'.',      (char )'t',      (char )'x',      (char )'t', 
        (char )'\000'};
#line 41 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char globalWEIGHT1[11]  = 
#line 41
  {      (char )'W',      (char )'E',      (char )'I',      (char )'G', 
        (char )'H',      (char )'T',      (char )'.',      (char )'t', 
        (char )'x',      (char )'t',      (char )'\000'};
#line 42 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char weightlib1[11]  = 
#line 42
  {      (char )'W',      (char )'E',      (char )'I',      (char )'G', 
        (char )'H',      (char )'T',      (char )'.',      (char )'l', 
        (char )'i',      (char )'b',      (char )'\000'};
#line 43 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char WLOG1[9]  = 
#line 43
  {      (char )'W',      (char )'L',      (char )'O',      (char )'G', 
        (char )'.',      (char )'t',      (char )'x',      (char )'t', 
        (char )'\000'};
#line 44 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char WLOGold1[9]  = 
#line 44
  {      (char )'W',      (char )'L',      (char )'O',      (char )'G', 
        (char )'.',      (char )'o',      (char )'l',      (char )'d', 
        (char )'\000'};
#line 45 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char localFOOD1[13]  = 
#line 45
  {      (char )'F',      (char )'O',      (char )'O',      (char )'D', 
        (char )'_',      (char )'D',      (char )'E',      (char )'S', 
        (char )'.',      (char )'t',      (char )'x',      (char )'t', 
        (char )'\000'};
#line 46 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char localNUT1[13]  = 
#line 46
  {      (char )'N',      (char )'U',      (char )'T',      (char )'_', 
        (char )'D',      (char )'A',      (char )'T',      (char )'A', 
        (char )'.',      (char )'t',      (char )'x',      (char )'t', 
        (char )'\000'};
#line 47 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char localWEIGHT1[11]  = 
#line 47
  {      (char )'W',      (char )'E',      (char )'I',      (char )'G', 
        (char )'H',      (char )'T',      (char )'.',      (char )'t', 
        (char )'x',      (char )'t',      (char )'\000'};
#line 48 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char foodfile1[8]  = 
#line 48
  {      (char )'f',      (char )'o',      (char )'o',      (char )'d', 
        (char )'.',      (char )'d',      (char )'b',      (char )'\000'};
#line 49 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char mealfile1[8]  = 
#line 49
  {      (char )'m',      (char )'e',      (char )'a',      (char )'l', 
        (char )'.',      (char )'d',      (char )'b',      (char )'\000'};
#line 50 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char mealexpfile1[9]  = 
#line 50
  {      (char )'m',      (char )'e',      (char )'a',      (char )'l', 
        (char )'.',      (char )'e',      (char )'x',      (char )'p', 
        (char )'\000'};
#line 51 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char theusualexpfile1[13]  = 
#line 51
  {      (char )'t',      (char )'h',      (char )'e',      (char )'u', 
        (char )'s',      (char )'u',      (char )'a',      (char )'l', 
        (char )'.',      (char )'e',      (char )'x',      (char )'p', 
        (char )'\000'};
#line 52 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char theusualfile1[12]  = 
#line 52
  {      (char )'t',      (char )'h',      (char )'e',      (char )'u', 
        (char )'s',      (char )'u',      (char )'a',      (char )'l', 
        (char )'.',      (char )'d',      (char )'b',      (char )'\000'};
#line 53 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char optionsfile1[11]  = 
#line 53
  {      (char )'o',      (char )'p',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'s',      (char )'.', 
        (char )'d',      (char )'b',      (char )'\000'};
#line 54 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char localOPTIONS1[12]  = 
#line 54
  {      (char )'O',      (char )'P',      (char )'T',      (char )'I', 
        (char )'O',      (char )'N',      (char )'S',      (char )'.', 
        (char )'t',      (char )'x',      (char )'t',      (char )'\000'};
#line 55 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char versionfile1[8]  = 
#line 55
  {      (char )'v',      (char )'e',      (char )'r',      (char )'s', 
        (char )'i',      (char )'o',      (char )'n',      (char )'\000'};
#line 56 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char oldversionfile1[9]  = 
#line 56
  {      (char )'.',      (char )'v',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )'\000'};
#line 58 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char USDAjoined[2000]  ;
#line 59 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char globalFOOD[2000]  ;
#line 60 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char globalNUT[2000]  ;
#line 61 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char globalWEIGHT[2000]  ;
#line 62 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char weightlib[2000]  ;
#line 63 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char WLOG[2000]  ;
#line 64 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char WLOGold[2000]  ;
#line 65 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char localFOOD[2000]  ;
#line 66 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char localNUT[2000]  ;
#line 67 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char localWEIGHT[2000]  ;
#line 68 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char foodfile[2000]  ;
#line 69 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char mealfile[2000]  ;
#line 70 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char mealexpfile[2000]  ;
#line 71 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char theusualexpfile[2000]  ;
#line 72 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char theusualfile[2000]  ;
#line 73 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char optionsfile[2000]  ;
#line 74 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char localOPTIONS[2000]  ;
#line 75 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char versionfile[2000]  ;
#line 76 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char oldversionfile[2000]  ;
#line 77 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char nutdir[2000]  ;
#line 78 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
char nutdirsubuser[2000]  ;
#line 83 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
FILE *fp  ;
#line 85 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void read_food_files(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 87
  tmp = version(0);
  }
#line 87
  if (tmp < 10) {
    {
#line 87
    remove((char const   *)(optionsfile));
    }
  }
  {
#line 88
  read_joined_db(USDAjoined);
#line 89
  tmp___0 = version(0);
  }
#line 89
  if (tmp___0 == 10) {
    {
#line 89
    tmp___1 = version(1);
    }
#line 89
    if (tmp___1 < 7) {
      {
#line 89
      read_options_db(1);
      }
    } else {
      {
#line 90
      read_OPTIONS(1);
      }
    }
  } else {
    {
#line 90
    read_OPTIONS(1);
    }
  }
  {
#line 91
  read_FOOD(globalFOOD);
#line 92
  read_NUT(globalNUT);
#line 93
  read_WEIGHT(globalWEIGHT);
#line 94
  read_FOOD(localFOOD);
#line 95
  read_NUT(localNUT);
#line 96
  read_WEIGHT(localWEIGHT);
#line 97
  make_food_index();
#line 98
  read_meal_db();
#line 99
  read_theusual_db();
#line 100
  full_meal_reindexing();
#line 101
  write_food_db();
#line 102
  write_meal_db();
#line 103
  write_theusual_db();
#line 104
  read_OPTIONS(0);
#line 105
  write_OPTIONS();
  }
#line 106
  return;
}
}
#line 108 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void read_joined_db(char *textfile ) 
{ 
  char buffer[800] ;
  char *bufptr ;
  char *fieldptr ;
  int count ;
  int junk ;
  int foodcount ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 113
  foodcount = 0;
#line 114
  fp = fopen((char const   */* __restrict  */)textfile, (char const   */* __restrict  */)"rb");
  }
#line 114
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 116
    printf((char const   */* __restrict  */)"Can\'t open food file \"%s\" to create food database.\n",
           textfile);
#line 117
    printf((char const   */* __restrict  */)"Press <enter> to continue...\n");
#line 118
    junk = get_int();
#line 119
    abort();
    }
  }
  {
#line 121
  printf((char const   */* __restrict  */)"\nReading food file \"%s\"\n", textfile);
#line 122
  printf((char const   */* __restrict  */)"to create food database \"%s\"...\n", foodfile);
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 123
    tmp___9 = fgets((char */* __restrict  */)(buffer), 800, (FILE */* __restrict  */)fp);
    }
#line 123
    if (! ((unsigned long )tmp___9 != (unsigned long )((void *)0))) {
#line 123
      goto while_break;
    }
    {
#line 125
    tmp = malloc(sizeof(struct food ));
#line 125
    new_food = (struct food *)tmp;
    }
#line 125
    if ((unsigned long )new_food == (unsigned long )((void *)0)) {
      {
#line 127
      printf((char const   */* __restrict  */)"We are out of memory.  Bummer.\n");
#line 128
      abort();
      }
    }
#line 130
    bufptr = buffer;
#line 131
    fieldptr = bufptr;
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      if (! ((int )*bufptr != 94)) {
#line 132
        goto while_break___0;
      }
#line 132
      bufptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 133
    *bufptr = (char )'\000';
#line 133
    bufptr ++;
#line 134
    new_food->ndb_no = atoi((char const   *)fieldptr);
#line 135
    fieldptr = bufptr;
    }
    {
#line 136
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 136
      if (! ((int )*bufptr != 94)) {
#line 136
        goto while_break___1;
      }
#line 136
      bufptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 137
    *bufptr = (char )'\000';
#line 137
    bufptr ++;
#line 138
    new_food->fdgrp = atoi((char const   *)fieldptr);
#line 139
    fieldptr = new_food->name;
    }
    {
#line 140
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 140
      if (! ((int )*bufptr != 94)) {
#line 140
        goto while_break___2;
      }
#line 142
      tmp___0 = fieldptr;
#line 142
      fieldptr ++;
#line 142
      tmp___1 = bufptr;
#line 142
      bufptr ++;
#line 142
      *tmp___0 = *tmp___1;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 144
    *fieldptr = (char )'\000';
#line 144
    bufptr ++;
    {
#line 145
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 145
      if (! ((int )*bufptr != 94)) {
#line 145
        goto while_break___3;
      }
#line 145
      bufptr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 146
    bufptr ++;
#line 147
    fieldptr = bufptr;
    {
#line 148
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 148
      if (! ((int )*bufptr != 94)) {
#line 148
        goto while_break___4;
      }
#line 148
      bufptr ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 149
    *bufptr = (char )'\000';
#line 149
    bufptr ++;
#line 150
    tmp___2 = atoi((char const   *)fieldptr);
#line 150
    new_food->refuse = (int )((float )tmp___2);
#line 151
    fieldptr = bufptr;
    }
    {
#line 152
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 152
      if (! ((int )*bufptr != 94)) {
#line 152
        goto while_break___5;
      }
#line 152
      bufptr ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 153
    *bufptr = (char )'\000';
#line 153
    bufptr ++;
#line 154
    tmp___3 = atof((char const   *)fieldptr);
#line 154
    new_food->prot_cal_factor = (float )tmp___3;
#line 155
    fieldptr = bufptr;
    }
    {
#line 156
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 156
      if (! ((int )*bufptr != 94)) {
#line 156
        goto while_break___6;
      }
#line 156
      bufptr ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 157
    *bufptr = (char )'\000';
#line 157
    bufptr ++;
#line 158
    tmp___4 = atof((char const   *)fieldptr);
#line 158
    new_food->fat_cal_factor = (float )tmp___4;
#line 159
    fieldptr = bufptr;
    }
    {
#line 160
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 160
      if (! ((int )*bufptr != 94)) {
#line 160
        goto while_break___7;
      }
#line 160
      bufptr ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 161
    *bufptr = (char )'\000';
#line 161
    bufptr ++;
#line 162
    tmp___5 = atof((char const   *)fieldptr);
#line 162
    new_food->cho_cal_factor = (float )tmp___5;
#line 163
    count = 0;
    }
    {
#line 163
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 163
      if (! (count < 143)) {
#line 163
        goto while_break___8;
      }
#line 165
      fieldptr = bufptr;
      {
#line 166
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 166
        if (! ((int )*bufptr != 94)) {
#line 166
          goto while_break___9;
        }
#line 166
        bufptr ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 167
      *bufptr = (char )'\000';
#line 167
      bufptr ++;
#line 168
      tmp___6 = atof((char const   *)fieldptr);
#line 168
      new_food->nutrient[count] = (float )tmp___6;
#line 163
      count ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
#line 170
    fieldptr = bufptr;
    {
#line 171
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 171
      if (! ((int )*bufptr != 94)) {
#line 171
        goto while_break___10;
      }
#line 171
      bufptr ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 172
    *bufptr = (char )'\000';
#line 172
    bufptr ++;
#line 173
    tmp___7 = atof((char const   *)fieldptr);
#line 173
    new_food->qty = (float )tmp___7;
    }
#line 173
    if (new_food->qty <= (float )0) {
#line 173
      new_food->qty = (float )1;
    }
#line 174
    fieldptr = bufptr;
    {
#line 175
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 175
      if (! ((int )*bufptr != 94)) {
#line 175
        goto while_break___11;
      }
#line 175
      bufptr ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 176
    *bufptr = (char )'\000';
#line 176
    bufptr ++;
#line 177
    strncpy((char */* __restrict  */)(new_food->unit), (char const   */* __restrict  */)fieldptr,
            (size_t )50);
#line 178
    fieldptr = bufptr;
    }
    {
#line 179
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 179
      if (! ((int )*bufptr != 10)) {
#line 179
        goto while_break___12;
      }
#line 179
      bufptr ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 180
    *bufptr = (char )'\000';
#line 181
    tmp___8 = atof((char const   *)fieldptr);
#line 181
    new_food->grams = (float )tmp___8;
#line 182
    compute_derived_fields(new_food);
#line 183
    junk = order_new_food();
#line 184
    foodcount ++;
    }
#line 184
    if (foodcount % 500 == 0) {
      {
#line 184
      printf((char const   */* __restrict  */)"Read %d foods...\n", foodcount);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 186
  fclose(fp);
  }
#line 187
  return;
}
}
#line 189 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void read_FOOD(char *textfile ) 
{ 
  struct food *food_ptr ;
  char buffer[400] ;
  char *bufptr ;
  char *fieldptr ;
  int count ;
  int junk ;
  int ndbno ;
  char *tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 196
  fp = fopen((char const   */* __restrict  */)textfile, (char const   */* __restrict  */)"rb");
  }
#line 196
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 196
    return;
  }
  {
#line 197
  printf((char const   */* __restrict  */)"\nReading food description file \"%s\"\n",
         textfile);
#line 198
  printf((char const   */* __restrict  */)"to update food database \"%s\"...\n", foodfile);
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 199
    tmp___5 = fgets((char */* __restrict  */)(buffer), 400, (FILE */* __restrict  */)fp);
    }
#line 199
    if (! ((unsigned long )tmp___5 != (unsigned long )((void *)0))) {
#line 199
      goto while_break;
    }
#line 201
    bufptr = buffer;
#line 202
    bufptr ++;
#line 203
    tmp = bufptr;
#line 203
    bufptr ++;
#line 203
    fieldptr = tmp;
    {
#line 204
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 204
      if (! ((int )*bufptr != 126)) {
#line 204
        goto while_break___0;
      }
#line 204
      bufptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 205
    *bufptr = (char )'\000';
#line 205
    bufptr ++;
#line 205
    *bufptr = (char )'\000';
#line 206
    ndbno = atoi((char const   *)fieldptr);
#line 207
    food_ptr = find_ndbno_ptr(ndbno);
#line 208
    new_food = (struct food *)((void *)0);
    }
#line 209
    if ((unsigned long )food_ptr == (unsigned long )((void *)0)) {
      {
#line 211
      tmp___0 = malloc(sizeof(struct food ));
#line 211
      new_food = (struct food *)tmp___0;
      }
#line 211
      if ((unsigned long )new_food == (unsigned long )((void *)0)) {
        {
#line 213
        printf((char const   */* __restrict  */)"We are out of memory.  Bummer.\n");
#line 214
        abort();
        }
      }
#line 216
      new_food->ndb_no = ndbno;
#line 217
      if (ndbno >= 99000) {
#line 217
        new_food->fdgrp = 0;
      }
#line 218
      count = 0;
      {
#line 218
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 218
        if (! (count < 159)) {
#line 218
          goto while_break___1;
        }
#line 218
        new_food->nutrient[count] = NoData;
#line 218
        count ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 219
      if (ndbno >= options.next_recipe) {
#line 219
        options.next_recipe = ndbno + 1;
      }
#line 220
      food_ptr = new_food;
    }
    {
#line 223
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 223
      if (! ((int )*bufptr != 94)) {
#line 223
        goto while_break___2;
      }
#line 223
      bufptr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 224
    *bufptr = (char )'\000';
    {
#line 226
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 226
      if (! ((int )*bufptr != 94)) {
#line 226
        goto while_break___3;
      }
#line 226
      bufptr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 227
    *bufptr = (char )'\000';
#line 229
    fieldptr = bufptr;
#line 230
    fieldptr ++;
#line 230
    fieldptr ++;
    {
#line 231
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 231
      if (! ((int )*bufptr != 126)) {
#line 231
        goto while_break___4;
      }
#line 231
      bufptr ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 232
    *bufptr = (char )'\000';
#line 232
    bufptr ++;
    {
#line 233
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 233
      if (! ((int )*bufptr != 126)) {
#line 233
        goto while_break___5;
      }
#line 233
      bufptr ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 234
    *bufptr = (char )'\000';
#line 234
    bufptr ++;
#line 235
    strcpy((char */* __restrict  */)(food_ptr->name), (char const   */* __restrict  */)fieldptr);
    }
    {
#line 237
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 237
      if (! ((int )*bufptr != 94)) {
#line 237
        goto while_break___6;
      }
#line 237
      bufptr ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 238
    *bufptr = (char )'\000';
    {
#line 240
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 240
      if (! ((int )*bufptr != 94)) {
#line 240
        goto while_break___7;
      }
#line 240
      bufptr ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 241
    *bufptr = (char )'\000';
    {
#line 243
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 243
      if (! ((int )*bufptr != 94)) {
#line 243
        goto while_break___8;
      }
#line 243
      bufptr ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 244
    *bufptr = (char )'\000';
    {
#line 246
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 246
      if (! ((int )*bufptr != 94)) {
#line 246
        goto while_break___9;
      }
#line 246
      bufptr ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 247
    *bufptr = (char )'\000';
    {
#line 249
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 249
      if (! ((int )*bufptr != 94)) {
#line 249
        goto while_break___10;
      }
#line 249
      bufptr ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 250
    *bufptr = (char )'\000';
#line 252
    fieldptr = bufptr;
#line 253
    fieldptr ++;
    {
#line 254
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 254
      if (! ((int )*bufptr != 94)) {
#line 254
        goto while_break___11;
      }
#line 254
      bufptr ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 255
    *bufptr = (char )'\000';
#line 256
    tmp___1 = atof((char const   *)fieldptr);
#line 256
    food_ptr->refuse = (int )tmp___1;
    }
    {
#line 258
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 258
      if (! ((int )*bufptr != 94)) {
#line 258
        goto while_break___12;
      }
#line 258
      bufptr ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 259
    *bufptr = (char )'\000';
    {
#line 261
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 261
      if (! ((int )*bufptr != 94)) {
#line 261
        goto while_break___13;
      }
#line 261
      bufptr ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 262
    *bufptr = (char )'\000';
#line 264
    fieldptr = bufptr;
#line 265
    fieldptr ++;
    {
#line 266
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 266
      if (! ((int )*bufptr != 94)) {
#line 266
        goto while_break___14;
      }
#line 266
      bufptr ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 267
    *bufptr = (char )'\000';
#line 268
    tmp___2 = atof((char const   *)fieldptr);
#line 268
    food_ptr->prot_cal_factor = (float )tmp___2;
#line 270
    fieldptr = bufptr;
#line 271
    fieldptr ++;
    }
    {
#line 272
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 272
      if (! ((int )*bufptr != 94)) {
#line 272
        goto while_break___15;
      }
#line 272
      bufptr ++;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 273
    *bufptr = (char )'\000';
#line 274
    tmp___3 = atof((char const   *)fieldptr);
#line 274
    food_ptr->fat_cal_factor = (float )tmp___3;
#line 276
    fieldptr = bufptr;
#line 277
    fieldptr ++;
#line 278
    tmp___4 = atof((char const   *)fieldptr);
#line 278
    food_ptr->cho_cal_factor = (float )tmp___4;
    }
#line 279
    if ((unsigned long )food_ptr == (unsigned long )new_food) {
      {
#line 279
      junk = order_new_food();
      }
    }
    {
#line 280
    compute_derived_fields(food_ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 282
  fclose(fp);
  }
#line 283
  return;
}
}
#line 285 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void read_NUT(char *textfile ) 
{ 
  struct food *food_ptr ;
  char buffer[400] ;
  char *bufptr ;
  char *fieldptr ;
  int ndbno ;
  int nutrno ;
  float value ;
  char *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 293
  fp = fopen((char const   */* __restrict  */)textfile, (char const   */* __restrict  */)"rb");
  }
#line 293
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 293
    return;
  }
  {
#line 294
  printf((char const   */* __restrict  */)"\nReading nutrient file \"%s\"\n", textfile);
#line 295
  printf((char const   */* __restrict  */)"to update food database \"%s\"...\n", foodfile);
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 296
    tmp___2 = fgets((char */* __restrict  */)(buffer), 400, (FILE */* __restrict  */)fp);
    }
#line 296
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 296
      goto while_break;
    }
#line 298
    bufptr = buffer;
#line 299
    bufptr ++;
#line 300
    tmp = bufptr;
#line 300
    bufptr ++;
#line 300
    fieldptr = tmp;
    {
#line 301
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 301
      if (! ((int )*bufptr != 126)) {
#line 301
        goto while_break___0;
      }
#line 301
      bufptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 302
    *bufptr = (char )'\000';
#line 302
    bufptr ++;
#line 302
    *bufptr = (char )'\000';
#line 303
    ndbno = atoi((char const   *)fieldptr);
#line 304
    food_ptr = find_ndbno_ptr(ndbno);
    }
#line 305
    if ((unsigned long )food_ptr == (unsigned long )((void *)0)) {
#line 305
      goto while_continue;
    }
#line 307
    fieldptr = bufptr;
#line 308
    fieldptr ++;
#line 308
    fieldptr ++;
    {
#line 309
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 309
      if (! ((int )*bufptr != 126)) {
#line 309
        goto while_break___1;
      }
#line 309
      bufptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 310
    *bufptr = (char )'\000';
    {
#line 311
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 311
      if (! ((int )*bufptr != 126)) {
#line 311
        goto while_break___2;
      }
#line 311
      bufptr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 312
    *bufptr = (char )'\000';
#line 312
    bufptr ++;
#line 312
    *bufptr = (char )'\000';
#line 313
    tmp___0 = atof((char const   *)fieldptr);
#line 313
    nutrno = (int )tmp___0;
#line 315
    fieldptr = bufptr;
#line 316
    fieldptr ++;
    }
    {
#line 317
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 317
      if (! ((int )*bufptr != 94)) {
#line 317
        goto while_break___3;
      }
#line 317
      bufptr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 318
    *bufptr = (char )'\000';
#line 319
    tmp___1 = atof((char const   *)fieldptr);
#line 319
    value = (float )tmp___1;
    }
#line 321
    if (LookupNut[nutrno] != -1) {
      {
#line 323
      food_ptr->nutrient[LookupNut[nutrno]] = value;
#line 324
      compute_derived_fields(food_ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  fclose(fp);
  }
#line 328
  return;
}
}
#line 330 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void read_WEIGHT(char *textfile ) 
{ 
  struct food *food_ptr ;
  char buffer[400] ;
  char *bufptr ;
  char *fieldptr ;
  int ndbno ;
  char *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 337
  fp = fopen((char const   */* __restrict  */)textfile, (char const   */* __restrict  */)"rb");
  }
#line 337
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 337
    return;
  }
  {
#line 338
  printf((char const   */* __restrict  */)"\nReading food weight file \"%s\"\n", textfile);
#line 339
  printf((char const   */* __restrict  */)"to update food database \"%s\"...\n", foodfile);
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 340
    tmp___2 = fgets((char */* __restrict  */)(buffer), 400, (FILE */* __restrict  */)fp);
    }
#line 340
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 340
      goto while_break;
    }
#line 342
    bufptr = buffer;
#line 343
    bufptr ++;
#line 344
    tmp = bufptr;
#line 344
    bufptr ++;
#line 344
    fieldptr = tmp;
    {
#line 345
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 345
      if (! ((int )*bufptr != 126)) {
#line 345
        goto while_break___0;
      }
#line 345
      bufptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 346
    *bufptr = (char )'\000';
#line 346
    bufptr ++;
#line 346
    *bufptr = (char )'\000';
#line 347
    ndbno = atoi((char const   *)fieldptr);
#line 348
    food_ptr = find_ndbno_ptr(ndbno);
    }
#line 349
    if ((unsigned long )food_ptr == (unsigned long )((void *)0)) {
#line 349
      goto while_continue;
    }
    {
#line 351
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 351
      if (! ((int )*bufptr != 94)) {
#line 351
        goto while_break___1;
      }
#line 351
      bufptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 352
    *bufptr = (char )'\000';
#line 354
    fieldptr = bufptr;
#line 355
    fieldptr ++;
    {
#line 356
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 356
      if (! ((int )*bufptr != 94)) {
#line 356
        goto while_break___2;
      }
#line 356
      bufptr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 357
    *bufptr = (char )'\000';
#line 358
    tmp___0 = atof((char const   *)fieldptr);
#line 358
    food_ptr->qty = (float )tmp___0;
    }
#line 359
    if (food_ptr->qty <= (float )0) {
#line 359
      food_ptr->qty = (float )1;
    }
#line 361
    fieldptr = bufptr;
#line 362
    fieldptr ++;
#line 362
    fieldptr ++;
    {
#line 363
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 363
      if (! ((int )*bufptr != 126)) {
#line 363
        goto while_break___3;
      }
#line 363
      bufptr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 364
    *bufptr = (char )'\000';
#line 364
    bufptr ++;
    {
#line 365
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 365
      if (! ((int )*bufptr != 126)) {
#line 365
        goto while_break___4;
      }
#line 365
      bufptr ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 366
    *bufptr = (char )'\000';
#line 366
    bufptr ++;
#line 366
    *bufptr = (char )'\000';
#line 368
    strncpy((char */* __restrict  */)(food_ptr->unit), (char const   */* __restrict  */)fieldptr,
            (size_t )50);
#line 370
    fieldptr = bufptr;
#line 371
    fieldptr ++;
    }
    {
#line 372
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 372
      if (! ((int )*bufptr != 94)) {
#line 372
        goto while_break___5;
      }
#line 372
      bufptr ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 373
    *bufptr = (char )'\000';
#line 374
    tmp___1 = atof((char const   *)fieldptr);
#line 374
    food_ptr->grams = (float )tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 376
  fclose(fp);
  }
#line 377
  return;
}
}
#line 379 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void read_weightlib(int ndbno , char *buffer , int bufsize , char **result , int *resultparm ) 
{ 
  char *bufptr ;
  char *fieldptr ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 383
  fp = fopen((char const   */* __restrict  */)(weightlib), (char const   */* __restrict  */)"rb");
  }
#line 383
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 383
    return;
  }
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 384
    tmp___0 = fgets((char */* __restrict  */)buffer, bufsize, (FILE */* __restrict  */)fp);
    }
#line 384
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 384
      goto while_break;
    }
#line 386
    bufptr = buffer;
#line 387
    fieldptr = buffer;
    {
#line 388
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 388
      if (! ((int )*bufptr != 94)) {
#line 388
        goto while_break___0;
      }
#line 388
      bufptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 389
    tmp = atoi((char const   *)fieldptr);
    }
#line 389
    if (tmp != ndbno) {
#line 389
      goto while_continue;
    } else {
#line 392
      *bufptr = (char )'\000';
#line 393
      bufptr ++;
#line 394
      *(result + *resultparm) = bufptr;
#line 395
      (*resultparm) ++;
      {
#line 396
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 396
        if (! ((int )*bufptr != 10)) {
#line 396
          goto while_break___1;
        }
#line 398
        bufptr ++;
#line 399
        if ((int )*bufptr == 94) {
#line 401
          *bufptr = (char )'\000';
#line 402
          *(result + *resultparm) = bufptr + 1;
#line 403
          (*resultparm) ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 406
      fclose(fp);
      }
#line 407
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 410
  fclose(fp);
  }
#line 411
  return;
}
}
#line 414 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
int read_food_db(void) 
{ 
  int block ;
  int foodcount ;
  struct food *food_ptr ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 416
  foodcount = 0;
#line 417
  food_ptr = & food_root;
#line 418
  fp = fopen((char const   */* __restrict  */)(foodfile), (char const   */* __restrict  */)"rb");
  }
#line 418
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 418
    return (0);
  }
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 421
    tmp = malloc(sizeof(struct food ));
#line 421
    new_food = (struct food *)tmp;
    }
#line 421
    if ((unsigned long )new_food == (unsigned long )((void *)0)) {
      {
#line 423
      printf((char const   */* __restrict  */)"Bad news.  We are out of memory...");
#line 424
      abort();
      }
    }
    {
#line 426
    tmp___0 = fread((void */* __restrict  */)new_food, sizeof(struct food ), (size_t )1,
                    (FILE */* __restrict  */)fp);
#line 426
    block = (int )tmp___0;
    }
#line 426
    if (block != 0) {
#line 428
      food_ptr->next = new_food;
#line 429
      food_ptr = new_food;
#line 430
      foodcount ++;
    } else {
#line 432
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 434
  fclose(fp);
#line 435
  make_food_index();
  }
#line 436
  return (1);
}
}
#line 439 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void read_meal_db(void) 
{ 
  int block ;
  struct meal *meal_ptr ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 442
  meal_ptr = & meal_root;
#line 443
  fp = fopen((char const   */* __restrict  */)(mealfile), (char const   */* __restrict  */)"rb");
  }
#line 443
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 445
    write_meal_db();
    }
#line 446
    return;
  }
#line 448
  mealdb_mealsperday = 0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 451
    tmp = malloc(sizeof(struct meal ));
#line 451
    new_meal = (struct meal *)tmp;
    }
#line 451
    if ((unsigned long )new_meal == (unsigned long )((void *)0)) {
      {
#line 453
      printf((char const   */* __restrict  */)"Bad news.  We are out of memory...");
#line 454
      abort();
      }
    }
    {
#line 456
    tmp___0 = fread((void */* __restrict  */)new_meal, sizeof(struct meal ), (size_t )1,
                    (FILE */* __restrict  */)fp);
#line 456
    block = (int )tmp___0;
    }
#line 456
    if (block != 0) {
#line 458
      meal_ptr->next = new_meal;
#line 459
      meal_ptr = new_meal;
#line 460
      if ((int )meal_ptr->meal > mealdb_mealsperday) {
#line 460
        mealdb_mealsperday = (int )meal_ptr->meal;
      }
    } else {
#line 462
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 464
  fclose(fp);
  }
#line 465
  return;
}
}
#line 467 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void read_theusual_db(void) 
{ 
  int block ;
  struct meal *theusual_ptr ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 470
  theusual_ptr = & theusual_root;
#line 471
  fp = fopen((char const   */* __restrict  */)(theusualfile), (char const   */* __restrict  */)"rb");
  }
#line 471
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 473
    write_theusual_db();
    }
#line 474
    return;
  }
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 478
    tmp = malloc(sizeof(struct meal ));
#line 478
    new_theusual = (struct meal *)tmp;
    }
#line 478
    if ((unsigned long )new_theusual == (unsigned long )((void *)0)) {
      {
#line 480
      printf((char const   */* __restrict  */)"Bad news.  We are out of memory...");
#line 481
      abort();
      }
    }
    {
#line 483
    tmp___0 = fread((void */* __restrict  */)new_theusual, sizeof(struct meal ), (size_t )1,
                    (FILE */* __restrict  */)fp);
#line 483
    block = (int )tmp___0;
    }
#line 483
    if (block != 0) {
#line 485
      theusual_ptr->next = new_theusual;
#line 486
      theusual_ptr = new_theusual;
    } else {
#line 488
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 490
  fclose(fp);
  }
#line 491
  return;
}
}
#line 493 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void write_meal_db(void) 
{ 
  int block ;
  struct meal *meal_ptr ;
  size_t tmp ;

  {
  {
#line 496
  meal_ptr = & meal_root;
#line 497
  fp = fopen((char const   */* __restrict  */)(mealfile), (char const   */* __restrict  */)"wb");
  }
#line 497
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 499
    printf((char const   */* __restrict  */)"Can\'t open meal database %s to write.\n",
           mealfile);
#line 500
    abort();
    }
  }
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 502
      goto while_break;
    }
    {
#line 504
    meal_ptr = meal_ptr->next;
#line 505
    tmp = fwrite((void const   */* __restrict  */)meal_ptr, sizeof(struct meal ),
                 (size_t )1, (FILE */* __restrict  */)fp);
#line 505
    block = (int )tmp;
    }
#line 505
    if (block != 1) {
      {
#line 507
      printf((char const   */* __restrict  */)"Cannot write to the disk.  Aborting...\n");
#line 508
      abort();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 511
  fclose(fp);
  }
#line 512
  return;
}
}
#line 514 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void write_theusual_db(void) 
{ 
  int block ;
  struct meal *theusual_ptr ;
  size_t tmp ;

  {
  {
#line 517
  theusual_ptr = & theusual_root;
#line 518
  fp = fopen((char const   */* __restrict  */)(theusualfile), (char const   */* __restrict  */)"wb");
  }
#line 518
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 520
    printf((char const   */* __restrict  */)"Can\'t open theusual database %s to write.\n",
           theusualfile);
#line 521
    abort();
    }
  }
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! ((unsigned long )theusual_ptr->next != (unsigned long )((void *)0))) {
#line 523
      goto while_break;
    }
    {
#line 525
    theusual_ptr = theusual_ptr->next;
#line 526
    tmp = fwrite((void const   */* __restrict  */)theusual_ptr, sizeof(struct meal ),
                 (size_t )1, (FILE */* __restrict  */)fp);
#line 526
    block = (int )tmp;
    }
#line 526
    if (block != 1) {
      {
#line 528
      printf((char const   */* __restrict  */)"Cannot write to the disk.  Aborting...\n");
#line 529
      abort();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 532
  fclose(fp);
  }
#line 533
  return;
}
}
#line 535 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void write_food_db(void) 
{ 
  int block ;
  struct food *food_ptr ;
  size_t tmp ;

  {
  {
#line 538
  food_ptr = & food_root;
#line 539
  fp = fopen((char const   */* __restrict  */)(foodfile), (char const   */* __restrict  */)"wb");
  }
#line 539
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 541
    printf((char const   */* __restrict  */)"Can\'t open food database %s to write.\n",
           foodfile);
#line 542
    abort();
    }
  }
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 544
    if (! ((unsigned long )food_ptr->next != (unsigned long )((void *)0))) {
#line 544
      goto while_break;
    }
    {
#line 546
    food_ptr = food_ptr->next;
#line 547
    tmp = fwrite((void const   */* __restrict  */)food_ptr, sizeof(struct food ),
                 (size_t )1, (FILE */* __restrict  */)fp);
#line 547
    block = (int )tmp;
    }
#line 547
    if (block != 1) {
      {
#line 549
      printf((char const   */* __restrict  */)"Cannot write to the disk.  Aborting...\n");
#line 550
      abort();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 553
  fclose(fp);
  }
#line 554
  return;
}
}
#line 556 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void write_recipe(struct food *food_ptr ) 
{ 
  char buffer[300] ;
  char numbuf[11] ;
  char textbuf[100] ;
  int block ;
  int c ;
  int i ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 560
  fp = fopen((char const   */* __restrict  */)(localFOOD), (char const   */* __restrict  */)"ab");
  }
#line 560
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 562
    printf((char const   */* __restrict  */)"Can\'t open recipe description file %s to append.\n",
           localFOOD);
#line 563
    abort();
    }
  }
  {
#line 565
  strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"~\000");
#line 566
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%d",
          food_ptr->ndb_no);
#line 567
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(numbuf));
#line 568
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"~^~9999~^~\000");
#line 569
  strcpy((char */* __restrict  */)(textbuf), (char const   */* __restrict  */)(food_ptr->name));
#line 570
  tmp = strlen((char const   *)(textbuf));
#line 570
  c = (int )tmp;
#line 571
  i = 1;
  }
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! (i < c)) {
#line 571
      goto while_break;
    }
    {
#line 571
    tmp___0 = tolower((int )textbuf[i]);
#line 571
    textbuf[i] = (char )tmp___0;
#line 571
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 572
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(textbuf));
#line 573
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"~^~\000");
#line 574
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(food_ptr->name));
#line 575
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"~^~~^~~^~~^~~^\000");
#line 576
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%d",
          food_ptr->refuse);
#line 577
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(numbuf));
#line 578
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"^~~^^\000");
  }
#line 579
  if (food_ptr->nutrient[0] > (float )0) {
    {
#line 579
    sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%1.2f",
            (double )(food_ptr->nutrient[143] / food_ptr->nutrient[0]));
    }
  } else {
    {
#line 580
    sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%d",
            0);
    }
  }
  {
#line 581
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(numbuf));
#line 582
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"^\000");
  }
#line 583
  if (food_ptr->nutrient[1] > (float )0) {
    {
#line 583
    sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%1.2f",
            (double )(food_ptr->nutrient[144] / food_ptr->nutrient[1]));
    }
  } else {
    {
#line 584
    sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%d",
            0);
    }
  }
  {
#line 585
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(numbuf));
#line 586
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"^\000");
  }
#line 587
  if (food_ptr->nutrient[2] > (float )0) {
    {
#line 587
    sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%1.2f",
            (double )(food_ptr->nutrient[145] / food_ptr->nutrient[2]));
    }
  } else {
    {
#line 588
    sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%d",
            0);
    }
  }
  {
#line 589
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(numbuf));
#line 590
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\n");
#line 591
  tmp___1 = strlen((char const   *)(buffer));
#line 591
  c = (int )tmp___1;
#line 592
  tmp___2 = fwrite((void const   */* __restrict  */)(buffer), (size_t )c, (size_t )1,
                   (FILE */* __restrict  */)fp);
#line 592
  block = (int )tmp___2;
  }
#line 592
  if (block != 1) {
    {
#line 594
    printf((char const   */* __restrict  */)"Cannot write to the disk.  Aborting...\n");
#line 595
    abort();
    }
  }
  {
#line 597
  fclose(fp);
#line 599
  fp = fopen((char const   */* __restrict  */)(localNUT), (char const   */* __restrict  */)"ab");
  }
#line 599
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 601
    printf((char const   */* __restrict  */)"Can\'t open recipe nutrient file %s to append.\n",
           localNUT);
#line 602
    abort();
    }
  }
#line 604
  i = 0;
  {
#line 604
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 604
    if (! (i < 143)) {
#line 604
      goto while_break___0;
    }
    {
#line 606
    tmp___3 = test_for_negative_zero(& food_ptr->nutrient[i]);
    }
#line 606
    if (tmp___3) {
#line 606
      goto __Cont;
    }
    {
#line 607
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"~\000");
#line 608
    sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%d",
            food_ptr->ndb_no);
#line 609
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(numbuf));
#line 610
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"~^~\000");
#line 611
    sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%d",
            LookupNutrNo[i]);
#line 612
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(numbuf));
#line 613
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"~^\000");
#line 614
    sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%1.3f",
            (double )food_ptr->nutrient[i]);
#line 615
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(numbuf));
#line 616
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"^0^^~4~^~~^~~^~~^^^^^^^~~^^~~\n");
#line 617
    tmp___4 = strlen((char const   *)(buffer));
#line 617
    c = (int )tmp___4;
#line 618
    tmp___5 = fwrite((void const   */* __restrict  */)(buffer), (size_t )c, (size_t )1,
                     (FILE */* __restrict  */)fp);
#line 618
    block = (int )tmp___5;
    }
#line 618
    if (block != 1) {
      {
#line 620
      printf((char const   */* __restrict  */)"Cannot write to the disk.  Aborting...\n");
#line 621
      abort();
      }
    }
    __Cont: /* CIL Label */ 
#line 604
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 624
  fclose(fp);
#line 626
  fp = fopen((char const   */* __restrict  */)(localWEIGHT), (char const   */* __restrict  */)"ab");
  }
#line 626
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 628
    printf((char const   */* __restrict  */)"Can\'t open recipe weight file %s to append.\n",
           localWEIGHT);
#line 629
    abort();
    }
  }
  {
#line 631
  strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"~\000");
#line 632
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%d",
          food_ptr->ndb_no);
#line 633
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(numbuf));
#line 634
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"~^1^\000");
#line 635
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%g",
          (double )food_ptr->qty);
#line 636
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(numbuf));
#line 637
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"^~\000");
#line 638
  strcpy((char */* __restrict  */)(textbuf), (char const   */* __restrict  */)(food_ptr->unit));
#line 639
  tmp___6 = strspn((char const   *)(textbuf), " 0123456789.");
#line 639
  c = (int )tmp___6;
#line 640
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(textbuf + c));
#line 641
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"~^\000");
#line 642
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%g",
          (double )food_ptr->grams);
#line 643
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(numbuf));
#line 644
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"^^\n");
#line 645
  tmp___7 = strlen((char const   *)(buffer));
#line 645
  c = (int )tmp___7;
#line 646
  tmp___8 = fwrite((void const   */* __restrict  */)(buffer), (size_t )c, (size_t )1,
                   (FILE */* __restrict  */)fp);
#line 646
  block = (int )tmp___8;
  }
#line 646
  if (block != 1) {
    {
#line 648
    printf((char const   */* __restrict  */)"Cannot write to the disk.  Aborting...\n");
#line 649
    abort();
    }
  }
  {
#line 651
  fclose(fp);
  }
#line 652
  return;
}
}
#line 654 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void write_serving(struct food *food_ptr ) 
{ 
  char buffer[300] ;
  char numbuf[11] ;
  int block ;
  int c ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 659
  fp = fopen((char const   */* __restrict  */)(localWEIGHT), (char const   */* __restrict  */)"ab");
  }
#line 659
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 661
    printf((char const   */* __restrict  */)"Can\'t open weight file %s to append.\n",
           localWEIGHT);
#line 662
    abort();
    }
  }
  {
#line 664
  strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"~\000");
#line 665
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%d",
          food_ptr->ndb_no);
#line 666
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(numbuf));
#line 667
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"~^1^\000");
#line 668
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%g",
          (double )food_ptr->qty);
#line 669
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(numbuf));
#line 670
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"^~\000");
#line 671
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(food_ptr->unit));
#line 672
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"~^\000");
#line 673
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%g",
          (double )food_ptr->grams);
#line 674
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(numbuf));
#line 675
  strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"^^\n");
#line 676
  tmp = strlen((char const   *)(buffer));
#line 676
  c = (int )tmp;
#line 677
  tmp___0 = fwrite((void const   */* __restrict  */)(buffer), (size_t )c, (size_t )1,
                   (FILE */* __restrict  */)fp);
#line 677
  block = (int )tmp___0;
  }
#line 677
  if (block != 1) {
    {
#line 679
    printf((char const   */* __restrict  */)"Cannot write to the disk.  Aborting...\n");
#line 680
    abort();
    }
  }
  {
#line 682
  fclose(fp);
  }
#line 683
  return;
}
}
#line 685 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void write_OPTIONS(void) 
{ 
  int block ;
  int i ;
  int field ;

  {
  {
#line 688
  fp = fopen((char const   */* __restrict  */)(localOPTIONS), (char const   */* __restrict  */)"wb");
  }
#line 688
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 690
    printf((char const   */* __restrict  */)"Can\'t open options file \"%s\" to write.\n",
           localOPTIONS);
#line 691
    printf((char const   */* __restrict  */)"Press <enter> to continue...");
#line 692
    block = get_int();
#line 693
    abort();
    }
  }
  {
#line 695
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%d^\n",
          1000, options.delopt);
#line 696
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%d^\n",
          1001, options.defanal);
#line 697
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%d^\n",
          1002, options.screen);
#line 698
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%d^\n",
          1003, options.custom);
#line 699
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%f^\n",
          1004, (double )options.pcprotein);
#line 700
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%f^\n",
          1005, (double )options.pccarb);
#line 701
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%f^\n",
          1006, (double )options.pcsatfat);
#line 702
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%d^\n",
          1008, options.next_recipe);
#line 703
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%d^\n",
          1009, options.mealsperday);
#line 704
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%d^\n",
          1010, (int )options.grams);
#line 705
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%d^\n",
          1011, (int )options.autocal);
#line 706
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%f^\n",
          1012, (double )options.protcalpergm);
#line 707
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%f^\n",
          1013, (double )options.carbcalpergm);
#line 708
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%f^\n",
          1014, (double )options.fatcalpergm);
#line 709
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%f^\n",
          1015, (double )options.fattyacidfactor);
#line 710
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%f^\n",
          1016, (double )options.n6hufa);
#line 711
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%f^\n",
          1018, (double )options.epadhamax);
#line 712
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%d^\n",
          1019, options.defanalanal);
#line 713
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%d^\n",
          1020, options.defanalrec);
#line 714
  i = 1;
  }
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;
#line 714
    if (! (i <= 39)) {
#line 714
      goto while_break;
    }
    {
#line 718
    if (DVMap[i] == 146) {
#line 718
      goto case_146;
    }
#line 720
    if (DVMap[i] == 147) {
#line 720
      goto case_147;
    }
#line 722
    if (DVMap[i] == 148) {
#line 722
      goto case_148;
    }
#line 724
    if (DVMap[i] == 149) {
#line 724
      goto case_149;
    }
#line 726
    if (DVMap[i] == 150) {
#line 726
      goto case_150;
    }
#line 728
    if (DVMap[i] == 151) {
#line 728
      goto case_151;
    }
#line 730
    if (DVMap[i] == 152) {
#line 730
      goto case_152;
    }
#line 732
    if (DVMap[i] == 155) {
#line 732
      goto case_155;
    }
#line 734
    if (DVMap[i] == 158) {
#line 734
      goto case_158;
    }
#line 736
    goto switch_default;
    case_146: /* CIL Label */ 
#line 718
    field = 2000;
#line 719
    goto switch_break;
    case_147: /* CIL Label */ 
#line 720
    field = 2001;
#line 721
    goto switch_break;
    case_148: /* CIL Label */ 
#line 722
    field = 2002;
#line 723
    goto switch_break;
    case_149: /* CIL Label */ 
#line 724
    field = 2003;
#line 725
    goto switch_break;
    case_150: /* CIL Label */ 
#line 726
    field = 2004;
#line 727
    goto switch_break;
    case_151: /* CIL Label */ 
#line 728
    field = 2005;
#line 729
    goto switch_break;
    case_152: /* CIL Label */ 
#line 730
    field = 2006;
#line 731
    goto switch_break;
    case_155: /* CIL Label */ 
#line 732
    field = 2007;
#line 733
    goto switch_break;
    case_158: /* CIL Label */ 
#line 734
    field = 2008;
#line 735
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 736
    field = LookupNutrNo[DVMap[i]];
#line 737
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 739
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d^%f^%d\n",
            field, (double )options.abnuts[DVMap[i]], options.locknuts[DVMap[i]]);
#line 714
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 741
  fclose(fp);
  }
#line 742
  return;
}
}
#line 744 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void read_options_db(int dontwrite ) 
{ 
  int block ;
  int need_to_find_next_recipe ;
  struct food *food_ptr ;

  {
  {
#line 746
  need_to_find_next_recipe = 0;
#line 747
  food_ptr = & food_root;
#line 748
  initialize_options();
#line 749
  fp = fopen((char const   */* __restrict  */)(optionsfile), (char const   */* __restrict  */)"rb");
  }
#line 749
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 751
    write_OPTIONS();
    }
#line 752
    if (! dontwrite) {
#line 752
      need_to_find_next_recipe = 1;
    }
  }
  {
#line 754
  fp = fopen((char const   */* __restrict  */)(optionsfile), (char const   */* __restrict  */)"rb");
  }
#line 754
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 756
    printf((char const   */* __restrict  */)"Can\'t open options database \"%s\" to read.\n",
           optionsfile);
#line 757
    printf((char const   */* __restrict  */)"Press <enter> to continue...");
#line 758
    block = get_int();
#line 759
    abort();
    }
  }
  {
#line 761
  fread((void */* __restrict  */)(& options), sizeof(struct opt ), (size_t )1, (FILE */* __restrict  */)fp);
#line 762
  fclose(fp);
#line 763
  remove((char const   *)(optionsfile));
#line 764
  options.temp_meal_root = & meal_root;
#line 765
  auto_cal(& options.abnuts[4], 0);
#line 766
  delete_meals(options.delopt);
  }
#line 767
  if (! dontwrite) {
    {
#line 767
    write_meal_db();
    }
  }
#line 768
  if (need_to_find_next_recipe) {
    {
#line 768
    while (1) {
      while_continue: /* CIL Label */ ;
#line 768
      if (! ((unsigned long )food_ptr->next != (unsigned long )((void *)0))) {
#line 768
        goto while_break;
      }
#line 770
      food_ptr = food_ptr->next;
#line 771
      if (food_ptr->ndb_no >= options.next_recipe) {
#line 771
        options.next_recipe = food_ptr->ndb_no + 1;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 773
  return;
}
}
#line 775 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void read_OPTIONS(int dontwrite ) 
{ 
  int block ;
  int need_to_find_next_recipe ;
  int field ;
  char buffer[101] ;
  char valbuf1[51] ;
  char valbuf2[51] ;
  struct food *food_ptr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  char *tmp___23 ;

  {
  {
#line 777
  need_to_find_next_recipe = 0;
#line 779
  food_ptr = & food_root;
#line 780
  initialize_options();
#line 781
  fp = fopen((char const   */* __restrict  */)(localOPTIONS), (char const   */* __restrict  */)"rb");
  }
#line 781
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 783
    write_OPTIONS();
    }
#line 784
    if (! dontwrite) {
#line 784
      need_to_find_next_recipe = 1;
    }
  }
  {
#line 786
  fp = fopen((char const   */* __restrict  */)(localOPTIONS), (char const   */* __restrict  */)"rb");
  }
#line 786
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 788
    printf((char const   */* __restrict  */)"Can\'t open options file \"%s\" to read.\n",
           localOPTIONS);
#line 789
    printf((char const   */* __restrict  */)"Press <enter> to continue...");
#line 790
    block = get_int();
#line 791
    abort();
    }
  }
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 793
    tmp___23 = fgets((char */* __restrict  */)(buffer), 100, (FILE */* __restrict  */)fp);
    }
#line 793
    if (! ((unsigned long )tmp___23 != (unsigned long )((void *)0))) {
#line 793
      goto while_break;
    }
    {
#line 795
    tmp = strtok((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"^");
#line 795
    field = atoi((char const   *)tmp);
#line 796
    tmp___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"^");
#line 796
    strcpy((char */* __restrict  */)(valbuf1), (char const   */* __restrict  */)tmp___0);
#line 797
    tmp___1 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"^");
#line 797
    strcpy((char */* __restrict  */)(valbuf2), (char const   */* __restrict  */)tmp___1);
    }
    {
#line 800
    if (field == 1000) {
#line 800
      goto case_1000;
    }
#line 802
    if (field == 1001) {
#line 802
      goto case_1001;
    }
#line 804
    if (field == 1002) {
#line 804
      goto case_1002;
    }
#line 806
    if (field == 1003) {
#line 806
      goto case_1003;
    }
#line 808
    if (field == 1004) {
#line 808
      goto case_1004;
    }
#line 810
    if (field == 1005) {
#line 810
      goto case_1005;
    }
#line 812
    if (field == 1006) {
#line 812
      goto case_1006;
    }
#line 814
    if (field == 1008) {
#line 814
      goto case_1008;
    }
#line 816
    if (field == 1009) {
#line 816
      goto case_1009;
    }
#line 818
    if (field == 1010) {
#line 818
      goto case_1010;
    }
#line 820
    if (field == 1011) {
#line 820
      goto case_1011;
    }
#line 822
    if (field == 1012) {
#line 822
      goto case_1012;
    }
#line 824
    if (field == 1013) {
#line 824
      goto case_1013;
    }
#line 826
    if (field == 1014) {
#line 826
      goto case_1014;
    }
#line 828
    if (field == 1015) {
#line 828
      goto case_1015;
    }
#line 830
    if (field == 1016) {
#line 830
      goto case_1016;
    }
#line 832
    if (field == 1018) {
#line 832
      goto case_1018;
    }
#line 834
    if (field == 1019) {
#line 834
      goto case_1019;
    }
#line 836
    if (field == 1020) {
#line 836
      goto case_1020;
    }
#line 838
    if (field == 2000) {
#line 838
      goto case_2000;
    }
#line 841
    if (field == 2001) {
#line 841
      goto case_2001;
    }
#line 844
    if (field == 2002) {
#line 844
      goto case_2002;
    }
#line 847
    if (field == 2003) {
#line 847
      goto case_2003;
    }
#line 850
    if (field == 2004) {
#line 850
      goto case_2004;
    }
#line 853
    if (field == 2005) {
#line 853
      goto case_2005;
    }
#line 856
    if (field == 2006) {
#line 856
      goto case_2006;
    }
#line 859
    if (field == 2007) {
#line 859
      goto case_2007;
    }
#line 862
    if (field == 2008) {
#line 862
      goto case_2008;
    }
#line 865
    goto switch_default;
    case_1000: /* CIL Label */ 
    {
#line 800
    options.delopt = atoi((char const   *)(valbuf1));
    }
#line 801
    goto switch_break;
    case_1001: /* CIL Label */ 
    {
#line 802
    options.defanal = atoi((char const   *)(valbuf1));
    }
#line 803
    goto switch_break;
    case_1002: /* CIL Label */ 
    {
#line 804
    options.screen = atoi((char const   *)(valbuf1));
    }
#line 805
    goto switch_break;
    case_1003: /* CIL Label */ 
    {
#line 806
    options.custom = atoi((char const   *)(valbuf1));
    }
#line 807
    goto switch_break;
    case_1004: /* CIL Label */ 
    {
#line 808
    tmp___2 = atof((char const   *)(valbuf1));
#line 808
    options.pcprotein = (float )tmp___2;
    }
#line 809
    goto switch_break;
    case_1005: /* CIL Label */ 
    {
#line 810
    tmp___3 = atof((char const   *)(valbuf1));
#line 810
    options.pccarb = (float )tmp___3;
    }
#line 811
    goto switch_break;
    case_1006: /* CIL Label */ 
    {
#line 812
    tmp___4 = atof((char const   *)(valbuf1));
#line 812
    options.pcsatfat = (float )tmp___4;
    }
#line 813
    goto switch_break;
    case_1008: /* CIL Label */ 
    {
#line 814
    options.next_recipe = atoi((char const   *)(valbuf1));
    }
#line 815
    goto switch_break;
    case_1009: /* CIL Label */ 
    {
#line 816
    options.mealsperday = atoi((char const   *)(valbuf1));
    }
#line 817
    goto switch_break;
    case_1010: /* CIL Label */ 
    {
#line 818
    tmp___5 = atoi((char const   *)(valbuf1));
#line 818
    options.grams = (char )tmp___5;
    }
#line 819
    goto switch_break;
    case_1011: /* CIL Label */ 
    {
#line 820
    tmp___6 = atoi((char const   *)(valbuf1));
#line 820
    options.autocal = (char )tmp___6;
    }
#line 821
    goto switch_break;
    case_1012: /* CIL Label */ 
    {
#line 822
    tmp___7 = atof((char const   *)(valbuf1));
#line 822
    options.protcalpergm = (float )tmp___7;
    }
#line 823
    goto switch_break;
    case_1013: /* CIL Label */ 
    {
#line 824
    tmp___8 = atof((char const   *)(valbuf1));
#line 824
    options.carbcalpergm = (float )tmp___8;
    }
#line 825
    goto switch_break;
    case_1014: /* CIL Label */ 
    {
#line 826
    tmp___9 = atof((char const   *)(valbuf1));
#line 826
    options.fatcalpergm = (float )tmp___9;
    }
#line 827
    goto switch_break;
    case_1015: /* CIL Label */ 
    {
#line 828
    tmp___10 = atof((char const   *)(valbuf1));
#line 828
    options.fattyacidfactor = (float )tmp___10;
    }
#line 829
    goto switch_break;
    case_1016: /* CIL Label */ 
    {
#line 830
    tmp___11 = atof((char const   *)(valbuf1));
#line 830
    options.n6hufa = (float )tmp___11;
    }
#line 831
    goto switch_break;
    case_1018: /* CIL Label */ 
    {
#line 832
    tmp___12 = atof((char const   *)(valbuf1));
#line 832
    options.epadhamax = (float )tmp___12;
    }
#line 833
    goto switch_break;
    case_1019: /* CIL Label */ 
    {
#line 834
    options.defanalanal = atoi((char const   *)(valbuf1));
    }
#line 835
    goto switch_break;
    case_1020: /* CIL Label */ 
    {
#line 836
    options.defanalrec = atoi((char const   *)(valbuf1));
    }
#line 837
    goto switch_break;
    case_2000: /* CIL Label */ 
    {
#line 838
    tmp___13 = atof((char const   *)(valbuf1));
#line 838
    options.abnuts[146] = (float )tmp___13;
#line 839
    options.locknuts[146] = atoi((char const   *)(valbuf2));
    }
#line 840
    goto switch_break;
    case_2001: /* CIL Label */ 
    {
#line 841
    tmp___14 = atof((char const   *)(valbuf1));
#line 841
    options.abnuts[147] = (float )tmp___14;
#line 842
    options.locknuts[147] = atoi((char const   *)(valbuf2));
    }
#line 843
    goto switch_break;
    case_2002: /* CIL Label */ 
    {
#line 844
    tmp___15 = atof((char const   *)(valbuf1));
#line 844
    options.abnuts[148] = (float )tmp___15;
#line 845
    options.locknuts[148] = atoi((char const   *)(valbuf2));
    }
#line 846
    goto switch_break;
    case_2003: /* CIL Label */ 
    {
#line 847
    tmp___16 = atof((char const   *)(valbuf1));
#line 847
    options.abnuts[149] = (float )tmp___16;
#line 848
    options.locknuts[149] = atoi((char const   *)(valbuf2));
    }
#line 849
    goto switch_break;
    case_2004: /* CIL Label */ 
    {
#line 850
    tmp___17 = atof((char const   *)(valbuf1));
#line 850
    options.abnuts[150] = (float )tmp___17;
#line 851
    options.locknuts[150] = atoi((char const   *)(valbuf2));
    }
#line 852
    goto switch_break;
    case_2005: /* CIL Label */ 
    {
#line 853
    tmp___18 = atof((char const   *)(valbuf1));
#line 853
    options.abnuts[151] = (float )tmp___18;
#line 854
    options.locknuts[151] = atoi((char const   *)(valbuf2));
    }
#line 855
    goto switch_break;
    case_2006: /* CIL Label */ 
    {
#line 856
    tmp___19 = atof((char const   *)(valbuf1));
#line 856
    options.abnuts[152] = (float )tmp___19;
#line 857
    options.locknuts[152] = atoi((char const   *)(valbuf2));
    }
#line 858
    goto switch_break;
    case_2007: /* CIL Label */ 
    {
#line 859
    tmp___20 = atof((char const   *)(valbuf1));
#line 859
    options.abnuts[155] = (float )tmp___20;
#line 860
    options.locknuts[155] = atoi((char const   *)(valbuf2));
    }
#line 861
    goto switch_break;
    case_2008: /* CIL Label */ 
    {
#line 862
    tmp___21 = atof((char const   *)(valbuf1));
#line 862
    options.abnuts[158] = (float )tmp___21;
#line 863
    options.locknuts[158] = atoi((char const   *)(valbuf2));
    }
#line 864
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 865
    tmp___22 = atof((char const   *)(valbuf1));
#line 865
    options.abnuts[LookupNut[field]] = (float )tmp___22;
#line 866
    options.locknuts[LookupNut[field]] = atoi((char const   *)(valbuf2));
    }
#line 867
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 870
  fclose(fp);
#line 871
  options.temp_meal_root = & meal_root;
#line 872
  auto_cal(& options.abnuts[4], 0);
#line 873
  delete_meals(options.delopt);
  }
#line 874
  if (! dontwrite) {
    {
#line 874
    write_meal_db();
    }
  }
#line 875
  if (need_to_find_next_recipe) {
    {
#line 875
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 875
      if (! ((unsigned long )food_ptr->next != (unsigned long )((void *)0))) {
#line 875
        goto while_break___0;
      }
#line 877
      food_ptr = food_ptr->next;
#line 878
      if (food_ptr->ndb_no >= options.next_recipe) {
#line 878
        options.next_recipe = food_ptr->ndb_no + 1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 880
  return;
}
}
#line 882 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void read_WLOG(int *n , int *fatn , int *up , float *weightslope , float *fatslope ) 
{ 
  char buffer[101] ;
  float weight ;
  float bf ;
  float stardate ;
  float fat ;
  float sumweightx ;
  float sumweighty ;
  float sumweightxx ;
  float sumweightxy ;
  float sumfatx ;
  float sumfaty ;
  float sumfatxx ;
  float sumfatxy ;
  char *tmp ;
  double tmp___0 ;
  char *tmp___1 ;
  double tmp___2 ;
  char *tmp___3 ;
  double tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 887
  sumweightx = (float )0;
#line 887
  sumweighty = (float )0;
#line 887
  sumweightxx = (float )0;
#line 887
  sumweightxy = (float )0;
#line 888
  sumfatx = (float )0;
#line 888
  sumfaty = (float )0;
#line 888
  sumfatxx = (float )0;
#line 888
  sumfatxy = (float )0;
#line 890
  *n = 0;
#line 891
  *fatn = 0;
#line 892
  *up = 1;
#line 893
  fp = fopen((char const   */* __restrict  */)(WLOG), (char const   */* __restrict  */)"rb");
  }
#line 893
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 893
    return;
  }
  {
#line 894
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 894
    tmp___5 = fgets((char */* __restrict  */)(buffer), 100, (FILE */* __restrict  */)fp);
    }
#line 894
    if (! ((unsigned long )tmp___5 != (unsigned long )((void *)0))) {
#line 894
      goto while_break;
    }
    {
#line 896
    tmp = strtok((char */* __restrict  */)(buffer), (char const   */* __restrict  */)" ");
#line 896
    tmp___0 = atof((char const   *)tmp);
#line 896
    weight = (float )tmp___0;
#line 897
    tmp___1 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 897
    tmp___2 = atof((char const   *)tmp___1);
#line 897
    bf = (float )tmp___2;
#line 898
    tmp___3 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 898
    tmp___4 = atof((char const   *)tmp___3);
#line 898
    stardate = (float )tmp___4;
#line 899
    (*n) ++;
#line 900
    sumweightx += stardate;
#line 901
    sumweightxx += stardate * stardate;
#line 902
    sumweighty += weight;
#line 903
    sumweightxy += stardate * weight;
#line 904
    fat = (weight * bf) / (float )100;
    }
#line 905
    if (fat > (float )0) {
#line 907
      (*fatn) ++;
#line 908
      sumfatx += stardate;
#line 909
      sumfatxx += stardate * stardate;
#line 910
      sumfaty += fat;
#line 911
      sumfatxy += stardate * fat;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 914
  fclose(fp);
#line 915
  *weightslope = (sumweightxy - (sumweightx * sumweighty) / (float )*n) / (sumweightxx - (sumweightx * sumweightx) / (float )*n);
  }
#line 916
  if (*fatn > 1) {
#line 918
    *fatslope = (sumfatxy - (sumfatx * sumfaty) / (float )*fatn) / (sumfatxx - (sumfatx * sumfatx) / (float )*fatn);
#line 919
    if (*fatslope > (float )0) {
#line 919
      *up = 0;
    } else
#line 920
    if ((int )options.autocal == 2) {
#line 920
      if (*weightslope - *fatslope > (float )0) {
#line 920
        *up = 0;
      }
    }
#line 921
    *fatslope = (float )((int )((float )1000 * *fatslope));
#line 922
    *fatslope /= (float )1000;
  }
#line 924
  *weightslope = (float )((int )((float )1000 * *weightslope));
#line 925
  *weightslope /= (float )1000;
#line 926
  return;
}
}
#line 928 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void write_WLOG(float *weight , float *bf , float *stardate ) 
{ 
  char buffer[128] ;
  int block ;
  int c ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 932
  if (*weight == (float )0) {
    {
#line 934
    rename((char const   *)(WLOG), (char const   *)(WLOGold));
    }
#line 935
    return;
  }
  {
#line 937
  fp = fopen((char const   */* __restrict  */)(WLOG), (char const   */* __restrict  */)"ab");
  }
#line 937
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 939
    printf((char const   */* __restrict  */)"Can\'t open weight log file %s to append.\n",
           WLOG);
#line 940
    abort();
    }
  }
  {
#line 942
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%g %g %g\n",
          (double )*weight, (double )*bf, (double )*stardate);
#line 943
  tmp = strlen((char const   *)(buffer));
#line 943
  c = (int )tmp;
#line 944
  tmp___0 = fwrite((void const   */* __restrict  */)(buffer), (size_t )c, (size_t )1,
                   (FILE */* __restrict  */)fp);
#line 944
  block = (int )tmp___0;
  }
#line 944
  if (block != 1) {
    {
#line 946
    printf((char const   */* __restrict  */)"Cannot write to the disk.  Aborting...\n");
#line 947
    abort();
    }
  }
  {
#line 949
  fclose(fp);
  }
#line 950
  return;
}
}
#line 952 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void make_filenames(char *sub ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 954
  strcpy((char */* __restrict  */)(subuser), (char const   */* __restrict  */)sub);
#line 979
  tmp = getenv("HOME");
#line 979
  sprintf((char */* __restrict  */)(nutdir), (char const   */* __restrict  */)"%s/%s",
          tmp, nutdir1);
#line 980
  mkdir((char const   *)(nutdir), (__mode_t )448);
#line 981
  tmp___0 = getenv("HOME");
#line 981
  sprintf((char */* __restrict  */)(nutdirsubuser), (char const   */* __restrict  */)"%s/%s/%s",
          tmp___0, nutdir1, subuser);
#line 982
  mkdir((char const   *)(nutdirsubuser), (__mode_t )448);
#line 983
  sprintf((char */* __restrict  */)(USDAjoined), (char const   */* __restrict  */)"%s/%s",
          "/usr/share/nut-nutrition/", USDAjoined1);
#line 984
  sprintf((char */* __restrict  */)(globalFOOD), (char const   */* __restrict  */)"%s/%s",
          "/usr/share/nut-nutrition/", globalFOOD1);
#line 985
  sprintf((char */* __restrict  */)(globalNUT), (char const   */* __restrict  */)"%s/%s",
          "/usr/share/nut-nutrition/", globalNUT1);
#line 986
  sprintf((char */* __restrict  */)(globalWEIGHT), (char const   */* __restrict  */)"%s/%s",
          "/usr/share/nut-nutrition/", globalWEIGHT1);
#line 987
  sprintf((char */* __restrict  */)(weightlib), (char const   */* __restrict  */)"%s/%s",
          "/usr/share/nut-nutrition/", weightlib1);
#line 988
  tmp___1 = getenv("HOME");
#line 988
  sprintf((char */* __restrict  */)(WLOG), (char const   */* __restrict  */)"%s/%s/%s/%s",
          tmp___1, nutdir1, subuser, WLOG1);
#line 989
  tmp___2 = getenv("HOME");
#line 989
  sprintf((char */* __restrict  */)(WLOGold), (char const   */* __restrict  */)"%s/%s/%s/%s",
          tmp___2, nutdir1, subuser, WLOGold1);
#line 990
  tmp___3 = getenv("HOME");
#line 990
  sprintf((char */* __restrict  */)(localFOOD), (char const   */* __restrict  */)"%s/%s/%s/%s",
          tmp___3, nutdir1, subuser, localFOOD1);
#line 991
  tmp___4 = getenv("HOME");
#line 991
  sprintf((char */* __restrict  */)(localNUT), (char const   */* __restrict  */)"%s/%s/%s/%s",
          tmp___4, nutdir1, subuser, localNUT1);
#line 992
  tmp___5 = getenv("HOME");
#line 992
  sprintf((char */* __restrict  */)(localWEIGHT), (char const   */* __restrict  */)"%s/%s/%s/%s",
          tmp___5, nutdir1, subuser, localWEIGHT1);
#line 993
  tmp___6 = getenv("HOME");
#line 993
  sprintf((char */* __restrict  */)(foodfile), (char const   */* __restrict  */)"%s/%s/%s/%s",
          tmp___6, nutdir1, subuser, foodfile1);
#line 994
  tmp___7 = getenv("HOME");
#line 994
  sprintf((char */* __restrict  */)(mealfile), (char const   */* __restrict  */)"%s/%s/%s/%s",
          tmp___7, nutdir1, subuser, mealfile1);
#line 995
  tmp___8 = getenv("HOME");
#line 995
  sprintf((char */* __restrict  */)(mealexpfile), (char const   */* __restrict  */)"%s/%s/%s/%s",
          tmp___8, nutdir1, subuser, mealexpfile1);
#line 996
  tmp___9 = getenv("HOME");
#line 996
  sprintf((char */* __restrict  */)(theusualexpfile), (char const   */* __restrict  */)"%s/%s/%s/%s",
          tmp___9, nutdir1, subuser, theusualexpfile1);
#line 997
  tmp___10 = getenv("HOME");
#line 997
  sprintf((char */* __restrict  */)(theusualfile), (char const   */* __restrict  */)"%s/%s/%s/%s",
          tmp___10, nutdir1, subuser, theusualfile1);
#line 998
  tmp___11 = getenv("HOME");
#line 998
  sprintf((char */* __restrict  */)(optionsfile), (char const   */* __restrict  */)"%s/%s/%s/%s",
          tmp___11, nutdir1, subuser, optionsfile1);
#line 999
  tmp___12 = getenv("HOME");
#line 999
  sprintf((char */* __restrict  */)(localOPTIONS), (char const   */* __restrict  */)"%s/%s/%s/%s",
          tmp___12, nutdir1, subuser, localOPTIONS1);
#line 1000
  tmp___13 = getenv("HOME");
#line 1000
  sprintf((char */* __restrict  */)(versionfile), (char const   */* __restrict  */)"%s/%s/%s/%s",
          tmp___13, nutdir1, subuser, versionfile1);
#line 1001
  tmp___14 = getenv("HOME");
#line 1001
  sprintf((char */* __restrict  */)(oldversionfile), (char const   */* __restrict  */)"%s/%s/%s/%s",
          tmp___14, nutdir1, subuser, oldversionfile1);
#line 1002
  check_version_file();
  }
#line 1004
  return;
}
}
#line 1006 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void check_version_file(void) 
{ 
  char release_string[9] ;
  int majrelease ;
  int minrelease ;
  int majreleasedot ;
  int minreleasedot ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1010
  fp = fopen((char const   */* __restrict  */)(oldversionfile), (char const   */* __restrict  */)"rb");
  }
#line 1010
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1010
    return;
  }
  {
#line 1011
  fread((void */* __restrict  */)(& release_string), (size_t )8, (size_t )1, (FILE */* __restrict  */)fp);
#line 1012
  fclose(fp);
#line 1013
  tmp = strtok((char */* __restrict  */)(release_string), (char const   */* __restrict  */)".");
#line 1013
  majreleasedot = atoi((char const   *)tmp);
#line 1014
  tmp___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)".");
#line 1014
  minreleasedot = atoi((char const   *)tmp___0);
#line 1015
  remove((char const   *)(oldversionfile));
#line 1016
  fp = fopen((char const   */* __restrict  */)(versionfile), (char const   */* __restrict  */)"rb");
  }
#line 1016
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 1018
    fp = fopen((char const   */* __restrict  */)(versionfile), (char const   */* __restrict  */)"wb");
    }
#line 1018
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1018
      return;
    }
    {
#line 1019
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d.%d",
            majreleasedot, minreleasedot);
#line 1020
    fclose(fp);
    }
#line 1021
    return;
  }
  {
#line 1023
  fread((void */* __restrict  */)(& release_string), (size_t )8, (size_t )1, (FILE */* __restrict  */)fp);
#line 1024
  fclose(fp);
#line 1025
  tmp___1 = strtok((char */* __restrict  */)(release_string), (char const   */* __restrict  */)".");
#line 1025
  majrelease = atoi((char const   *)tmp___1);
#line 1026
  tmp___2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)".");
#line 1026
  minrelease = atoi((char const   *)tmp___2);
  }
#line 1027
  if (majreleasedot < majrelease) {
#line 1027
    return;
  }
#line 1028
  if (majreleasedot == majrelease) {
#line 1028
    if (minreleasedot <= minrelease) {
#line 1028
      return;
    }
  }
  {
#line 1029
  fp = fopen((char const   */* __restrict  */)(versionfile), (char const   */* __restrict  */)"wb");
  }
#line 1029
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1029
    return;
  }
  {
#line 1030
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d.%d", majreleasedot,
          minreleasedot);
#line 1031
  fclose(fp);
  }
#line 1032
  return;
}
}
#line 1034 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
int version(int level ) 
{ 
  char release_string[128] ;
  int majrelease ;
  int minrelease ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1039
  fp = fopen((char const   */* __restrict  */)(versionfile), (char const   */* __restrict  */)"rb");
  }
#line 1039
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1039
    return (0);
  }
  {
#line 1040
  fread((void */* __restrict  */)(& release_string), (size_t )8, (size_t )1, (FILE */* __restrict  */)fp);
#line 1041
  fclose(fp);
#line 1042
  tmp = strstr((char const   *)(release_string), ".");
  }
#line 1042
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1042
    return (0);
  }
  {
#line 1043
  tmp___0 = strtok((char */* __restrict  */)(release_string), (char const   */* __restrict  */)".");
#line 1043
  majrelease = atoi((char const   *)tmp___0);
#line 1044
  tmp___1 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)".");
#line 1044
  minrelease = atoi((char const   *)tmp___1);
  }
#line 1045
  if (level > 0) {
#line 1045
    tmp___2 = minrelease;
  } else {
#line 1045
    tmp___2 = majrelease;
  }
#line 1045
  return (tmp___2);
}
}
#line 1048 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void write_version(void) 
{ 
  char release_string[5] ;
  int block ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 1050
  release_string[0] = (char )'1';
#line 1050
  release_string[1] = (char )'5';
#line 1050
  release_string[2] = (char )'.';
#line 1050
  release_string[3] = (char )'5';
#line 1050
  release_string[4] = (char )'\000';
#line 1052
  fp = fopen((char const   */* __restrict  */)(versionfile), (char const   */* __restrict  */)"wb");
  }
#line 1052
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 1054
    printf((char const   */* __restrict  */)"Can\'t write version number to disk in \"%s\".\n",
           versionfile);
#line 1055
    printf((char const   */* __restrict  */)"Press <enter> to continue...");
#line 1056
    block = get_int();
#line 1057
    abort();
    }
  }
  {
#line 1059
  tmp = strlen((char const   *)(release_string));
#line 1059
  tmp___0 = fwrite((void const   */* __restrict  */)(release_string), tmp + 1UL, (size_t )1,
                   (FILE */* __restrict  */)fp);
#line 1059
  block = (int )tmp___0;
  }
#line 1059
  if (block != 1) {
    {
#line 1061
    printf((char const   */* __restrict  */)"Cannot write to the disk.  Aborting...\n");
#line 1062
    abort();
    }
  }
  {
#line 1064
  fclose(fp);
  }
#line 1065
  return;
}
}
#line 1067 "/home/wheatley/newnew/temp/nut-nutrition-15.5/db.c"
void meal_export(void) 
{ 
  FILE *fp___0 ;
  struct meal *meal_ptr ;

  {
#line 1070
  meal_ptr = & meal_root;
#line 1071
  if ((unsigned long )meal_ptr->next == (unsigned long )((void *)0)) {
#line 1071
    return;
  }
  {
#line 1072
  fp___0 = fopen((char const   */* __restrict  */)(mealexpfile), (char const   */* __restrict  */)"w");
  }
#line 1072
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
#line 1072
    return;
  }
  {
#line 1073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1073
    if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 1073
      goto while_break;
    }
    {
#line 1075
    meal_ptr = meal_ptr->next;
#line 1076
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%s^%d^%d^%f\n",
            meal_ptr->meal_date, (int )meal_ptr->meal, meal_ptr->ndb_no, (double )meal_ptr->grams);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1079
  fclose(fp___0);
#line 1080
  meal_ptr = & theusual_root;
  }
#line 1081
  if ((unsigned long )meal_ptr->next == (unsigned long )((void *)0)) {
#line 1081
    return;
  }
  {
#line 1082
  fp___0 = fopen((char const   */* __restrict  */)(theusualexpfile), (char const   */* __restrict  */)"w");
  }
#line 1082
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
#line 1082
    return;
  }
  {
#line 1083
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1083
    if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 1083
      goto while_break___0;
    }
    {
#line 1085
    meal_ptr = meal_ptr->next;
#line 1086
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%s^%d^%d^%f\n",
            meal_ptr->meal_date, (int )meal_ptr->meal, meal_ptr->ndb_no, (double )meal_ptr->grams);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1089
  fclose(fp___0);
  }
#line 1090
  return;
}
}
#line 25 "/home/wheatley/newnew/temp/nut-nutrition-15.5/trendy.h"
char trendy(char mode ) ;
#line 26
int get_trendy(char *mode ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 31 "/home/wheatley/newnew/temp/nut-nutrition-15.5/ranking.h"
void nut_list(void) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 184 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 32 "/home/wheatley/newnew/temp/nut-nutrition-15.5/trendy.c"
char trendy(char mode ) 
{ 
  int nutnum ;
  int count ;
  int caldv ;
  int nutdv ;
  int linecount ;
  int graphwidth ;
  int daycount ;
  float calunit ;
  float nutunit ;
  char last_meal ;
  char last_meal_date[9] ;
  char nutname[36] ;
  char roundbuf[20] ;
  char calstring[36] ;
  char nutstring[36] ;
  char caldvstring[38] ;
  char nutdvstring[38] ;
  struct meal *meal_ptr ;
  struct meal *another_crazy_meal_ptr ;
  struct ep eachmonth ;
  struct ep eachday ;
  struct ep *ep_ptr ;
  struct ep *saveep_ptr ;
  struct ep *whichep_ptr ;
  int tmp ;
  struct ep *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  size_t tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;
  double tmp___27 ;
  double tmp___28 ;
  double tmp___29 ;
  double tmp___30 ;
  double tmp___31 ;
  double tmp___32 ;
  double tmp___33 ;
  double tmp___34 ;
  double tmp___35 ;
  double tmp___36 ;
  double tmp___37 ;
  double tmp___38 ;
  double tmp___39 ;
  double tmp___40 ;
  double tmp___41 ;
  double tmp___42 ;
  double tmp___43 ;
  double tmp___44 ;

  {
  {
#line 35
  caldv = 0;
#line 35
  nutdv = 0;
#line 35
  graphwidth = 35;
#line 37
  last_meal = (char )'0';
#line 38
  last_meal_date[0] = (char )'0';
#line 38
  last_meal_date[1] = (char )'0';
#line 38
  last_meal_date[2] = (char )'0';
#line 38
  last_meal_date[3] = (char )'0';
#line 38
  last_meal_date[4] = (char )'0';
#line 38
  last_meal_date[5] = (char )'0';
#line 38
  last_meal_date[6] = (char )'0';
#line 38
  last_meal_date[7] = (char )'0';
#line 38
  last_meal_date[8] = (char )'\000';
#line 51
  ep_ptr = & eachmonth;
#line 52
  strcpy((char */* __restrict  */)(ep_ptr->period), (char const   */* __restrict  */)"00000000");
#line 53
  ep_ptr->next = (struct ep *)((void *)0);
#line 54
  count = 1;
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (count <= *(ScreenMap[options.screen]))) {
#line 54
      goto while_break;
    }
#line 54
    ep_ptr->nutrient[*(ScreenMap[options.screen] + count)] = (float )0;
#line 54
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  ep_ptr->nutrient[4] = (float )0;
#line 56
  ep_ptr->nutrient[143] = (float )0;
#line 57
  ep_ptr->nutrient[144] = (float )0;
#line 58
  ep_ptr->nutrient[145] = (float )0;
#line 60
  ep_ptr = & eachday;
#line 61
  strcpy((char */* __restrict  */)(ep_ptr->period), (char const   */* __restrict  */)"00000000");
#line 62
  ep_ptr->next = (struct ep *)((void *)0);
#line 63
  count = 1;
  }
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (! (count <= *(ScreenMap[options.screen]))) {
#line 63
      goto while_break___0;
    }
#line 63
    ep_ptr->nutrient[*(ScreenMap[options.screen] + count)] = (float )0;
#line 63
    count ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 64
  ep_ptr->nutrient[4] = (float )0;
#line 65
  ep_ptr->nutrient[143] = (float )0;
#line 66
  ep_ptr->nutrient[144] = (float )0;
#line 67
  ep_ptr->nutrient[145] = (float )0;
#line 69
  tmp = meal_count(& meal_root);
  }
#line 69
  if (tmp == 0) {
    {
#line 71
    header((char *)"NUT:  Plot Daily and Monthly Trends");
#line 72
    spacer(0);
#line 73
    printf((char const   */* __restrict  */)"\nThere are no meals in database.  Press <enter> to continue...");
#line 74
    count = get_int();
    }
#line 75
    return ((char )'X');
  }
  {
#line 78
  header((char *)"NUT:  Plot Daily and Monthly Trends");
#line 79
  nut_list();
#line 80
  printf((char const   */* __restrict  */)"\nType number of nutrient to graph and \"d\" or \"m\" (or <enter> to quit):  ");
#line 81
  nutnum = get_trendy(& mode);
  }
#line 82
  if (nutnum < 1) {
#line 82
    return (mode);
  } else
#line 82
  if (nutnum > *(ScreenMap[options.screen])) {
#line 82
    return (mode);
  }
#line 83
  nutnum = *(ScreenMap[options.screen] + nutnum);
#line 85
  ep_ptr = & eachmonth;
#line 86
  saveep_ptr = & eachmonth;
#line 87
  meal_ptr = & meal_root;
#line 88
  daycount = 0;
  {
#line 89
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 91
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 91
      if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 91
        goto while_break___2;
      }
#line 93
      meal_ptr = meal_ptr->next;
#line 94
      if ((unsigned long )saveep_ptr == (unsigned long )(& eachmonth)) {
        {
#line 94
        tmp___2 = strncmp((char const   *)(ep_ptr->period), (char const   *)(meal_ptr->meal_date),
                          (size_t )6);
        }
#line 94
        if (tmp___2 != 0) {
#line 94
          goto _L;
        } else {
#line 94
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 94
      if ((unsigned long )saveep_ptr == (unsigned long )(& eachday)) {
        {
#line 94
        tmp___3 = strncmp((char const   *)(ep_ptr->period), (char const   *)(meal_ptr->meal_date),
                          (size_t )8);
        }
#line 94
        if (tmp___3 != 0) {
          _L: /* CIL Label */ 
#line 96
          if (daycount == 36) {
#line 96
            goto while_break___2;
          }
          {
#line 97
          tmp___1 = malloc(sizeof(struct ep ));
#line 97
          tmp___0 = (struct ep *)tmp___1;
#line 97
          ep_ptr->next = tmp___0;
          }
#line 97
          if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
            {
#line 99
            printf((char const   */* __restrict  */)"We are out of memory.  Bummer.\n");
#line 100
            abort();
            }
          }
#line 102
          ep_ptr = ep_ptr->next;
#line 103
          ep_ptr->next = (struct ep *)((void *)0);
#line 104
          if ((unsigned long )saveep_ptr == (unsigned long )(& eachmonth)) {
            {
#line 106
            strncpy((char */* __restrict  */)(ep_ptr->period), (char const   */* __restrict  */)(meal_ptr->meal_date),
                    (size_t )6);
#line 107
            ep_ptr->period[6] = (char )'\000';
            }
          }
#line 109
          if ((unsigned long )saveep_ptr == (unsigned long )(& eachday)) {
            {
#line 111
            strncpy((char */* __restrict  */)(ep_ptr->period), (char const   */* __restrict  */)(meal_ptr->meal_date),
                    (size_t )8);
#line 112
            ep_ptr->period[8] = (char )'\000';
#line 113
            daycount ++;
            }
          }
#line 115
          count = 1;
          {
#line 115
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 115
            if (! (count <= *(ScreenMap[options.screen]))) {
#line 115
              goto while_break___3;
            }
#line 115
            ep_ptr->nutrient[*(ScreenMap[options.screen] + count)] = (float )0;
#line 115
            count ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 116
          ep_ptr->nutrient[4] = (float )0;
#line 117
          ep_ptr->nutrient[143] = (float )0;
#line 118
          ep_ptr->nutrient[144] = (float )0;
#line 119
          ep_ptr->nutrient[145] = (float )0;
#line 120
          ep_ptr->mealcount = 0;
        }
      }
      {
#line 122
      tmp___4 = strcmp((char const   *)(last_meal_date), (char const   *)(meal_ptr->meal_date));
      }
#line 122
      if (tmp___4 != 0) {
        {
#line 124
        (ep_ptr->mealcount) ++;
#line 125
        strcpy((char */* __restrict  */)(last_meal_date), (char const   */* __restrict  */)(meal_ptr->meal_date));
#line 126
        last_meal = meal_ptr->meal;
        }
      } else
#line 122
      if ((int )last_meal != (int )meal_ptr->meal) {
        {
#line 124
        (ep_ptr->mealcount) ++;
#line 125
        strcpy((char */* __restrict  */)(last_meal_date), (char const   */* __restrict  */)(meal_ptr->meal_date));
#line 126
        last_meal = meal_ptr->meal;
        }
      }
#line 128
      count = 1;
      {
#line 128
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 128
        if (! (count <= *(ScreenMap[options.screen]))) {
#line 128
          goto while_break___4;
        }
#line 128
        ep_ptr->nutrient[*(ScreenMap[options.screen] + count)] += ((FoodIndex[meal_ptr->food_no])->nutrient[*(ScreenMap[options.screen] + count)] * meal_ptr->grams) / (float )100;
#line 128
        count ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 129
      if (options.screen > 1) {
#line 129
        ep_ptr->nutrient[4] += ((FoodIndex[meal_ptr->food_no])->nutrient[4] * meal_ptr->grams) / (float )100;
      }
#line 130
      ep_ptr->nutrient[143] += ((FoodIndex[meal_ptr->food_no])->nutrient[143] * meal_ptr->grams) / (float )100;
#line 131
      ep_ptr->nutrient[144] += ((FoodIndex[meal_ptr->food_no])->nutrient[144] * meal_ptr->grams) / (float )100;
#line 132
      ep_ptr->nutrient[145] += ((FoodIndex[meal_ptr->food_no])->nutrient[145] * meal_ptr->grams) / (float )100;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 134
    ep_ptr = saveep_ptr;
    {
#line 135
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 135
      if (! ((unsigned long )ep_ptr->next != (unsigned long )((void *)0))) {
#line 135
        goto while_break___5;
      }
#line 137
      ep_ptr = ep_ptr->next;
#line 138
      count = 1;
      {
#line 138
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 138
        if (! (count <= *(ScreenMap[options.screen]))) {
#line 138
          goto while_break___6;
        }
#line 140
        ep_ptr->nutrient[*(ScreenMap[options.screen] + count)] = (ep_ptr->nutrient[*(ScreenMap[options.screen] + count)] * (float )options.mealsperday) / (float )ep_ptr->mealcount;
#line 141
        if (ep_ptr->nutrient[*(ScreenMap[options.screen] + count)] > saveep_ptr->nutrient[*(ScreenMap[options.screen] + count)]) {
#line 141
          saveep_ptr->nutrient[*(ScreenMap[options.screen] + count)] = ep_ptr->nutrient[*(ScreenMap[options.screen] + count)];
        }
#line 138
        count ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 143
      if (options.screen > 1) {
#line 145
        ep_ptr->nutrient[4] = (ep_ptr->nutrient[4] * (float )options.mealsperday) / (float )ep_ptr->mealcount;
#line 146
        if (ep_ptr->nutrient[4] > saveep_ptr->nutrient[4]) {
#line 146
          saveep_ptr->nutrient[4] = ep_ptr->nutrient[4];
        }
      }
#line 148
      ep_ptr->nutrient[143] = (ep_ptr->nutrient[143] * (float )options.mealsperday) / (float )ep_ptr->mealcount;
#line 149
      if (ep_ptr->nutrient[143] > saveep_ptr->nutrient[143]) {
#line 149
        saveep_ptr->nutrient[143] = ep_ptr->nutrient[143];
      }
#line 150
      ep_ptr->nutrient[144] = (ep_ptr->nutrient[144] * (float )options.mealsperday) / (float )ep_ptr->mealcount;
#line 151
      if (ep_ptr->nutrient[144] > saveep_ptr->nutrient[144]) {
#line 151
        saveep_ptr->nutrient[144] = ep_ptr->nutrient[144];
      }
#line 152
      ep_ptr->nutrient[145] = (ep_ptr->nutrient[145] * (float )options.mealsperday) / (float )ep_ptr->mealcount;
#line 153
      if (ep_ptr->nutrient[145] > saveep_ptr->nutrient[145]) {
#line 153
        saveep_ptr->nutrient[145] = ep_ptr->nutrient[145];
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 155
    if ((unsigned long )saveep_ptr == (unsigned long )(& eachday)) {
#line 155
      goto while_break___1;
    }
    {
#line 156
    ep_ptr = & eachday;
#line 157
    saveep_ptr = & eachday;
#line 158
    last_meal = (char )'0';
#line 159
    strcpy((char */* __restrict  */)(last_meal_date), (char const   */* __restrict  */)"00000000");
#line 160
    meal_ptr = options.temp_meal_root;
#line 161
    another_crazy_meal_ptr = (options.temp_meal_root)->next;
    }
    {
#line 162
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 162
      tmp___5 = strcmp((char const   *)(another_crazy_meal_ptr->meal_date), (char const   *)(meal_ptr->meal_date));
      }
#line 162
      if (! (tmp___5 == 0)) {
#line 162
        goto while_break___7;
      }
      {
#line 162
      meal_ptr = prev_meal(meal_ptr);
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 165
  whichep_ptr = & eachday;
  {
#line 166
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 168
    if ((int )mode == 100) {
#line 170
      whichep_ptr = & eachday;
#line 171
      graphwidth = 34;
    }
#line 173
    if ((int )mode == 109) {
#line 175
      whichep_ptr = & eachmonth;
#line 176
      graphwidth = 35;
    }
#line 178
    saveep_ptr = whichep_ptr;
#line 179
    linecount = 0;
#line 180
    calunit = whichep_ptr->nutrient[4] / (float )graphwidth;
#line 181
    nutunit = whichep_ptr->nutrient[nutnum] / (float )graphwidth;
#line 182
    if (whichep_ptr->nutrient[4] < DV[4]) {
#line 182
      calunit = DV[4] / (float )graphwidth;
    }
#line 183
    if (options.screen == 0) {
#line 183
      if (whichep_ptr->nutrient[nutnum] < DV[nutnum]) {
#line 183
        nutunit = DV[nutnum] / (float )graphwidth;
      }
    }
#line 184
    if (calunit > (float )0) {
      {
#line 184
      tmp___6 = floor((double )(DV[4] / calunit) + .5);
#line 184
      caldv = (int )tmp___6;
      }
    }
#line 185
    if (nutunit > (float )0) {
#line 187
      if (options.screen == 0) {
        {
#line 187
        tmp___7 = floor((double )((float )graphwidth - DV[nutnum] / nutunit) + .5);
#line 187
        nutdv = (int )tmp___7;
        }
      } else {
        {
#line 190
        sprintf((char */* __restrict  */)(roundbuf), (char const   */* __restrict  */)"%1.0e",
                (double )(whichep_ptr->nutrient[nutnum] / (float )2));
#line 191
        tmp___8 = atof((char const   *)(roundbuf));
#line 191
        tmp___9 = floor((double )graphwidth - (tmp___8 / (double )nutunit + .5));
#line 191
        nutdv = (int )tmp___9;
        }
      }
    }
#line 194
    count = 0;
    {
#line 194
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 194
      if (! (count < graphwidth)) {
#line 194
        goto while_break___9;
      }
#line 196
      caldvstring[count] = (char )' ';
#line 197
      nutdvstring[count] = (char )' ';
#line 198
      nutname[count] = (char )' ';
#line 194
      count ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 200
    if (calunit > (float )0) {
#line 202
      caldvstring[caldv - 2] = (char )'D';
#line 203
      caldvstring[caldv - 1] = (char )'V';
    }
#line 205
    if (nutunit > (float )0) {
#line 207
      if (options.screen == 0) {
#line 209
        nutdvstring[nutdv] = (char )'D';
#line 210
        nutdvstring[nutdv + 1] = (char )'V';
      } else {
        {
#line 212
        tmp___10 = atof((char const   *)(roundbuf));
#line 212
        sprintf((char */* __restrict  */)(nutdvstring + nutdv), (char const   */* __restrict  */)"%g%-3s",
                tmp___10, Unit[nutnum]);
        }
      }
    }
#line 214
    caldvstring[graphwidth] = (char )'\000';
#line 215
    if (nutdv != graphwidth - 1) {
#line 215
      nutdvstring[graphwidth] = (char )'\000';
    } else {
#line 216
      nutdvstring[graphwidth + 1] = (char )'\000';
    }
    {
#line 217
    tmp___11 = strlen((char const   *)Nutrient[nutnum]);
#line 217
    strcpy((char */* __restrict  */)(nutname + ((size_t )(21 + graphwidth) - tmp___11) / 2UL),
           (char const   */* __restrict  */)Nutrient[nutnum]);
#line 218
    nutname[graphwidth] = (char )'\000';
    }
#line 219
    if ((int )mode == 109) {
      {
#line 221
      header((char *)"NUT:  Plot Monthly Trends");
#line 222
      printf((char const   */* __restrict  */)"%6s %-s %-s\n", " ", "Protein/Carb/Fat Calories",
             nutname);
#line 223
      printf((char const   */* __restrict  */)"%6s %-s %-s\n", " ", caldvstring, nutdvstring);
      }
    }
#line 225
    if ((int )mode == 100) {
      {
#line 227
      header((char *)"NUT:  Plot Daily Trends");
#line 228
      printf((char const   */* __restrict  */)"%8s %-s %-s\n", " ", "Protein/Carb/Fat Calories",
             nutname);
#line 229
      printf((char const   */* __restrict  */)"%8s %-s %-s\n", " ", caldvstring, nutdvstring);
      }
    }
#line 231
    ep_ptr = saveep_ptr;
    {
#line 232
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 232
      if (! ((unsigned long )ep_ptr->next != (unsigned long )((void *)0))) {
#line 232
        goto while_break___10;
      }
#line 234
      ep_ptr = ep_ptr->next;
#line 235
      count = 0;
      {
#line 235
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 235
        if (! (count < graphwidth)) {
#line 235
          goto while_break___11;
        }
#line 237
        calstring[count] = (char )' ';
#line 238
        nutstring[count] = (char )' ';
#line 235
        count ++;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 240
      if (calunit > (float )0) {
#line 242
        count = 0;
        {
#line 242
        while (1) {
          while_continue___12: /* CIL Label */ ;
          {
#line 242
          tmp___12 = floor((double )(ep_ptr->nutrient[4] / calunit) + .5);
          }
#line 242
          if (! ((double )count < tmp___12)) {
#line 242
            goto while_break___12;
          }
#line 242
          calstring[count] = (char )'F';
#line 242
          count ++;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 243
        count = 0;
        {
#line 243
        while (1) {
          while_continue___13: /* CIL Label */ ;
          {
#line 243
          tmp___13 = floor((double )(ep_ptr->nutrient[143] / calunit + ep_ptr->nutrient[145] / calunit) + .5);
          }
#line 243
          if (! ((double )count < tmp___13)) {
#line 243
            goto while_break___13;
          }
#line 243
          calstring[count] = (char )'c';
#line 243
          count ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 244
        count = 0;
        {
#line 244
        while (1) {
          while_continue___14: /* CIL Label */ ;
          {
#line 244
          tmp___14 = floor((double )(ep_ptr->nutrient[143] / calunit) + .5);
          }
#line 244
          if (! ((double )count < tmp___14)) {
#line 244
            goto while_break___14;
          }
#line 244
          calstring[count] = (char )'P';
#line 244
          count ++;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
      {
#line 248
      if (nutnum == 1) {
#line 248
        goto case_1;
      }
#line 254
      if (nutnum == 84) {
#line 254
        goto case_84;
      }
#line 256
      if (nutnum == 111) {
#line 256
        goto case_111;
      }
#line 258
      if (nutnum == 112) {
#line 258
        goto case_112;
      }
#line 266
      if (nutnum == 152) {
#line 266
        goto case_152;
      }
#line 270
      if (nutnum == 147) {
#line 270
        goto case_147;
      }
#line 272
      if (nutnum == 148) {
#line 272
        goto case_148;
      }
#line 274
      if (nutnum == 155) {
#line 274
        goto case_155;
      }
#line 279
      if (nutnum == 149) {
#line 279
        goto case_149;
      }
#line 281
      if (nutnum == 150) {
#line 281
        goto case_150;
      }
#line 283
      if (nutnum == 151) {
#line 283
        goto case_151;
      }
#line 285
      if (nutnum == 2) {
#line 285
        goto case_2;
      }
#line 288
      if (nutnum == 19) {
#line 288
        goto case_19;
      }
#line 290
      goto switch_default;
      case_1: /* CIL Label */ 
#line 248
      count = 0;
      {
#line 248
      while (1) {
        while_continue___15: /* CIL Label */ ;
        {
#line 248
        tmp___15 = floor((double )(ep_ptr->nutrient[1] / nutunit) + .5);
        }
#line 248
        if (! ((double )count < tmp___15)) {
#line 248
          goto while_break___15;
        }
#line 248
        nutstring[(graphwidth - 1) - count] = (char )'.';
#line 248
        count ++;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 249
      count = 0;
      {
#line 249
      while (1) {
        while_continue___16: /* CIL Label */ ;
        {
#line 249
        tmp___16 = floor((double )(((ep_ptr->nutrient[84] / nutunit + ep_ptr->nutrient[111] / nutunit) + ep_ptr->nutrient[152] / nutunit) + ep_ptr->nutrient[155] / nutunit) + .5);
        }
#line 249
        if (! ((double )count < tmp___16)) {
#line 249
          goto while_break___16;
        }
#line 249
        nutstring[(graphwidth - 1) - count] = (char )'s';
#line 249
        count ++;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 250
      count = 0;
      {
#line 250
      while (1) {
        while_continue___17: /* CIL Label */ ;
        {
#line 250
        tmp___17 = floor((double )((ep_ptr->nutrient[111] / nutunit + ep_ptr->nutrient[152] / nutunit) + ep_ptr->nutrient[155] / nutunit) + .5);
        }
#line 250
        if (! ((double )count < tmp___17)) {
#line 250
          goto while_break___17;
        }
#line 250
        nutstring[(graphwidth - 1) - count] = (char )'m';
#line 250
        count ++;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 251
      count = 0;
      {
#line 251
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 251
        tmp___18 = floor((double )(ep_ptr->nutrient[152] / nutunit + ep_ptr->nutrient[155] / nutunit) + .5);
        }
#line 251
        if (! ((double )count < tmp___18)) {
#line 251
          goto while_break___18;
        }
#line 251
        nutstring[(graphwidth - 1) - count] = (char )'6';
#line 251
        count ++;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 252
      count = 0;
      {
#line 252
      while (1) {
        while_continue___19: /* CIL Label */ ;
        {
#line 252
        tmp___19 = floor((double )(ep_ptr->nutrient[155] / nutunit) + .5);
        }
#line 252
        if (! ((double )count < tmp___19)) {
#line 252
          goto while_break___19;
        }
#line 252
        nutstring[(graphwidth - 1) - count] = (char )'3';
#line 252
        count ++;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 253
      goto switch_break;
      case_84: /* CIL Label */ 
#line 254
      count = 0;
      {
#line 254
      while (1) {
        while_continue___20: /* CIL Label */ ;
        {
#line 254
        tmp___20 = floor((double )(ep_ptr->nutrient[84] / nutunit) + .5);
        }
#line 254
        if (! ((double )count < tmp___20)) {
#line 254
          goto while_break___20;
        }
#line 254
        nutstring[(graphwidth - 1) - count] = (char )'s';
#line 254
        count ++;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 255
      goto switch_break;
      case_111: /* CIL Label */ 
#line 256
      count = 0;
      {
#line 256
      while (1) {
        while_continue___21: /* CIL Label */ ;
        {
#line 256
        tmp___21 = floor((double )(ep_ptr->nutrient[111] / nutunit) + .5);
        }
#line 256
        if (! ((double )count < tmp___21)) {
#line 256
          goto while_break___21;
        }
#line 256
        nutstring[(graphwidth - 1) - count] = (char )'m';
#line 256
        count ++;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 257
      goto switch_break;
      case_112: /* CIL Label */ 
#line 258
      count = 0;
      {
#line 258
      while (1) {
        while_continue___22: /* CIL Label */ ;
        {
#line 258
        tmp___22 = floor((double )(ep_ptr->nutrient[112] / nutunit) + .5);
        }
#line 258
        if (! ((double )count < tmp___22)) {
#line 258
          goto while_break___22;
        }
#line 258
        nutstring[(graphwidth - 1) - count] = (char )'6';
#line 258
        count ++;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 259
      count = 0;
      {
#line 259
      while (1) {
        while_continue___23: /* CIL Label */ ;
        {
#line 259
        tmp___23 = floor((double )((ep_ptr->nutrient[147] / nutunit + ep_ptr->nutrient[148] / nutunit) + ep_ptr->nutrient[155] / nutunit) + .5);
        }
#line 259
        if (! ((double )count < tmp___23)) {
#line 259
          goto while_break___23;
        }
#line 259
        nutstring[(graphwidth - 1) - count] = (char )'L';
#line 259
        count ++;
      }
      while_break___23: /* CIL Label */ ;
      }
#line 260
      count = 0;
      {
#line 260
      while (1) {
        while_continue___24: /* CIL Label */ ;
        {
#line 260
        tmp___24 = floor((double )(ep_ptr->nutrient[148] / nutunit + ep_ptr->nutrient[155] / nutunit) + .5);
        }
#line 260
        if (! ((double )count < tmp___24)) {
#line 260
          goto while_break___24;
        }
#line 260
        nutstring[(graphwidth - 1) - count] = (char )'A';
#line 260
        count ++;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 261
      count = 0;
      {
#line 261
      while (1) {
        while_continue___25: /* CIL Label */ ;
        {
#line 261
        tmp___25 = floor((double )(ep_ptr->nutrient[155] / nutunit) + .5);
        }
#line 261
        if (! ((double )count < tmp___25)) {
#line 261
          goto while_break___25;
        }
#line 261
        nutstring[(graphwidth - 1) - count] = (char )'3';
#line 261
        count ++;
      }
      while_break___25: /* CIL Label */ ;
      }
#line 262
      count = 0;
      {
#line 262
      while (1) {
        while_continue___26: /* CIL Label */ ;
        {
#line 262
        tmp___26 = floor((double )((ep_ptr->nutrient[149] / nutunit + ep_ptr->nutrient[150] / nutunit) + ep_ptr->nutrient[151] / nutunit) + .5);
        }
#line 262
        if (! ((double )count < tmp___26)) {
#line 262
          goto while_break___26;
        }
#line 262
        nutstring[(graphwidth - 1) - count] = (char )'n';
#line 262
        count ++;
      }
      while_break___26: /* CIL Label */ ;
      }
#line 263
      count = 0;
      {
#line 263
      while (1) {
        while_continue___27: /* CIL Label */ ;
        {
#line 263
        tmp___27 = floor((double )(ep_ptr->nutrient[150] / nutunit + ep_ptr->nutrient[151] / nutunit) + .5);
        }
#line 263
        if (! ((double )count < tmp___27)) {
#line 263
          goto while_break___27;
        }
#line 263
        nutstring[(graphwidth - 1) - count] = (char )'e';
#line 263
        count ++;
      }
      while_break___27: /* CIL Label */ ;
      }
#line 264
      count = 0;
      {
#line 264
      while (1) {
        while_continue___28: /* CIL Label */ ;
        {
#line 264
        tmp___28 = floor((double )(ep_ptr->nutrient[151] / nutunit) + .5);
        }
#line 264
        if (! ((double )count < tmp___28)) {
#line 264
          goto while_break___28;
        }
#line 264
        nutstring[(graphwidth - 1) - count] = (char )'d';
#line 264
        count ++;
      }
      while_break___28: /* CIL Label */ ;
      }
#line 265
      goto switch_break;
      case_152: /* CIL Label */ 
#line 266
      count = 0;
      {
#line 266
      while (1) {
        while_continue___29: /* CIL Label */ ;
        {
#line 266
        tmp___29 = floor((double )(ep_ptr->nutrient[152] / nutunit) + .5);
        }
#line 266
        if (! ((double )count < tmp___29)) {
#line 266
          goto while_break___29;
        }
#line 266
        nutstring[(graphwidth - 1) - count] = (char )'6';
#line 266
        count ++;
      }
      while_break___29: /* CIL Label */ ;
      }
#line 267
      count = 0;
      {
#line 267
      while (1) {
        while_continue___30: /* CIL Label */ ;
        {
#line 267
        tmp___30 = floor((double )(ep_ptr->nutrient[147] / nutunit + ep_ptr->nutrient[148] / nutunit) + .5);
        }
#line 267
        if (! ((double )count < tmp___30)) {
#line 267
          goto while_break___30;
        }
#line 267
        nutstring[(graphwidth - 1) - count] = (char )'L';
#line 267
        count ++;
      }
      while_break___30: /* CIL Label */ ;
      }
#line 268
      count = 0;
      {
#line 268
      while (1) {
        while_continue___31: /* CIL Label */ ;
        {
#line 268
        tmp___31 = floor((double )(ep_ptr->nutrient[148] / nutunit) + .5);
        }
#line 268
        if (! ((double )count < tmp___31)) {
#line 268
          goto while_break___31;
        }
#line 268
        nutstring[(graphwidth - 1) - count] = (char )'A';
#line 268
        count ++;
      }
      while_break___31: /* CIL Label */ ;
      }
#line 269
      goto switch_break;
      case_147: /* CIL Label */ 
#line 270
      count = 0;
      {
#line 270
      while (1) {
        while_continue___32: /* CIL Label */ ;
        {
#line 270
        tmp___32 = floor((double )(ep_ptr->nutrient[147] / nutunit) + .5);
        }
#line 270
        if (! ((double )count < tmp___32)) {
#line 270
          goto while_break___32;
        }
#line 270
        nutstring[(graphwidth - 1) - count] = (char )'L';
#line 270
        count ++;
      }
      while_break___32: /* CIL Label */ ;
      }
#line 271
      goto switch_break;
      case_148: /* CIL Label */ 
#line 272
      count = 0;
      {
#line 272
      while (1) {
        while_continue___33: /* CIL Label */ ;
        {
#line 272
        tmp___33 = floor((double )(ep_ptr->nutrient[148] / nutunit) + .5);
        }
#line 272
        if (! ((double )count < tmp___33)) {
#line 272
          goto while_break___33;
        }
#line 272
        nutstring[(graphwidth - 1) - count] = (char )'A';
#line 272
        count ++;
      }
      while_break___33: /* CIL Label */ ;
      }
#line 273
      goto switch_break;
      case_155: /* CIL Label */ 
#line 274
      count = 0;
      {
#line 274
      while (1) {
        while_continue___34: /* CIL Label */ ;
        {
#line 274
        tmp___34 = floor((double )(ep_ptr->nutrient[155] / nutunit) + .5);
        }
#line 274
        if (! ((double )count < tmp___34)) {
#line 274
          goto while_break___34;
        }
#line 274
        nutstring[(graphwidth - 1) - count] = (char )'3';
#line 274
        count ++;
      }
      while_break___34: /* CIL Label */ ;
      }
#line 275
      count = 0;
      {
#line 275
      while (1) {
        while_continue___35: /* CIL Label */ ;
        {
#line 275
        tmp___35 = floor((double )((ep_ptr->nutrient[149] / nutunit + ep_ptr->nutrient[150] / nutunit) + ep_ptr->nutrient[151] / nutunit) + .5);
        }
#line 275
        if (! ((double )count < tmp___35)) {
#line 275
          goto while_break___35;
        }
#line 275
        nutstring[(graphwidth - 1) - count] = (char )'n';
#line 275
        count ++;
      }
      while_break___35: /* CIL Label */ ;
      }
#line 276
      count = 0;
      {
#line 276
      while (1) {
        while_continue___36: /* CIL Label */ ;
        {
#line 276
        tmp___36 = floor((double )(ep_ptr->nutrient[150] / nutunit + ep_ptr->nutrient[151] / nutunit) + .5);
        }
#line 276
        if (! ((double )count < tmp___36)) {
#line 276
          goto while_break___36;
        }
#line 276
        nutstring[(graphwidth - 1) - count] = (char )'e';
#line 276
        count ++;
      }
      while_break___36: /* CIL Label */ ;
      }
#line 277
      count = 0;
      {
#line 277
      while (1) {
        while_continue___37: /* CIL Label */ ;
        {
#line 277
        tmp___37 = floor((double )(ep_ptr->nutrient[151] / nutunit) + .5);
        }
#line 277
        if (! ((double )count < tmp___37)) {
#line 277
          goto while_break___37;
        }
#line 277
        nutstring[(graphwidth - 1) - count] = (char )'d';
#line 277
        count ++;
      }
      while_break___37: /* CIL Label */ ;
      }
#line 278
      goto switch_break;
      case_149: /* CIL Label */ 
#line 279
      count = 0;
      {
#line 279
      while (1) {
        while_continue___38: /* CIL Label */ ;
        {
#line 279
        tmp___38 = floor((double )(ep_ptr->nutrient[149] / nutunit) + .5);
        }
#line 279
        if (! ((double )count < tmp___38)) {
#line 279
          goto while_break___38;
        }
#line 279
        nutstring[(graphwidth - 1) - count] = (char )'n';
#line 279
        count ++;
      }
      while_break___38: /* CIL Label */ ;
      }
#line 280
      goto switch_break;
      case_150: /* CIL Label */ 
#line 281
      count = 0;
      {
#line 281
      while (1) {
        while_continue___39: /* CIL Label */ ;
        {
#line 281
        tmp___39 = floor((double )(ep_ptr->nutrient[150] / nutunit) + .5);
        }
#line 281
        if (! ((double )count < tmp___39)) {
#line 281
          goto while_break___39;
        }
#line 281
        nutstring[(graphwidth - 1) - count] = (char )'e';
#line 281
        count ++;
      }
      while_break___39: /* CIL Label */ ;
      }
#line 282
      goto switch_break;
      case_151: /* CIL Label */ 
#line 283
      count = 0;
      {
#line 283
      while (1) {
        while_continue___40: /* CIL Label */ ;
        {
#line 283
        tmp___40 = floor((double )(ep_ptr->nutrient[151] / nutunit) + .5);
        }
#line 283
        if (! ((double )count < tmp___40)) {
#line 283
          goto while_break___40;
        }
#line 283
        nutstring[(graphwidth - 1) - count] = (char )'d';
#line 283
        count ++;
      }
      while_break___40: /* CIL Label */ ;
      }
#line 284
      goto switch_break;
      case_2: /* CIL Label */ 
#line 285
      count = 0;
      {
#line 285
      while (1) {
        while_continue___41: /* CIL Label */ ;
        {
#line 285
        tmp___41 = floor((double )(ep_ptr->nutrient[2] / nutunit) + .5);
        }
#line 285
        if (! ((double )count < tmp___41)) {
#line 285
          goto while_break___41;
        }
#line 285
        nutstring[(graphwidth - 1) - count] = (char )'.';
#line 285
        count ++;
      }
      while_break___41: /* CIL Label */ ;
      }
#line 286
      count = 0;
      {
#line 286
      while (1) {
        while_continue___42: /* CIL Label */ ;
        {
#line 286
        tmp___42 = floor((double )(ep_ptr->nutrient[19] / nutunit) + .5);
        }
#line 286
        if (! ((double )count < tmp___42)) {
#line 286
          goto while_break___42;
        }
#line 286
        nutstring[(graphwidth - 1) - count] = (char )':';
#line 286
        count ++;
      }
      while_break___42: /* CIL Label */ ;
      }
#line 287
      goto switch_break;
      case_19: /* CIL Label */ 
#line 288
      count = 0;
      {
#line 288
      while (1) {
        while_continue___43: /* CIL Label */ ;
        {
#line 288
        tmp___43 = floor((double )(ep_ptr->nutrient[19] / nutunit) + .5);
        }
#line 288
        if (! ((double )count < tmp___43)) {
#line 288
          goto while_break___43;
        }
#line 288
        nutstring[(graphwidth - 1) - count] = (char )':';
#line 288
        count ++;
      }
      while_break___43: /* CIL Label */ ;
      }
#line 289
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 290
      count = 0;
      {
#line 290
      while (1) {
        while_continue___44: /* CIL Label */ ;
        {
#line 290
        tmp___44 = floor((double )(ep_ptr->nutrient[nutnum] / nutunit) + .5);
        }
#line 290
        if (! ((double )count < tmp___44)) {
#line 290
          goto while_break___44;
        }
#line 290
        nutstring[(graphwidth - 1) - count] = (char )'.';
#line 290
        count ++;
      }
      while_break___44: /* CIL Label */ ;
      }
#line 291
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 293
      if (calunit > (float )0) {
#line 293
        if ((int )calstring[caldv - 2] == (int )calstring[caldv]) {
#line 293
          calstring[caldv - 1] = (char )'|';
        } else
#line 293
        if ((int )calstring[caldv] == 32) {
#line 293
          if ((int )calstring[caldv - 1] == 32) {
#line 293
            calstring[caldv - 1] = (char )'|';
          } else {
#line 293
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 293
        if (caldv == graphwidth) {
#line 293
          if ((int )calstring[caldv - 1] == 32) {
#line 293
            calstring[caldv - 1] = (char )'|';
          }
        }
      }
#line 294
      if (nutunit > (float )0) {
#line 294
        if ((int )nutstring[nutdv + 1] == (int )nutstring[nutdv - 1]) {
#line 294
          nutstring[nutdv] = (char )'|';
        } else
#line 294
        if ((int )nutstring[nutdv - 1] == 32) {
#line 294
          if ((int )nutstring[nutdv] == 32) {
#line 294
            nutstring[nutdv] = (char )'|';
          } else {
#line 294
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 294
        if (nutdv == 0) {
#line 294
          if ((int )nutstring[nutdv] == 32) {
#line 294
            nutstring[nutdv] = (char )'|';
          }
        }
      }
      {
#line 295
      calstring[graphwidth] = (char )'\000';
#line 296
      nutstring[graphwidth] = (char )'\000';
#line 297
      printf((char const   */* __restrict  */)"%-s %-s %-s\n", ep_ptr->period, calstring,
             nutstring);
#line 298
      linecount ++;
      }
#line 299
      if ((int )mode == 109) {
#line 299
        if (linecount == 12) {
#line 299
          saveep_ptr = ep_ptr;
        }
      }
#line 300
      if (linecount == 18) {
#line 300
        if ((unsigned long )ep_ptr->next != (unsigned long )((void *)0)) {
          {
#line 302
          spacer(linecount + 2);
#line 303
          printf((char const   */* __restrict  */)"\nPress <enter> to scroll...");
#line 304
          count = get_int();
#line 305
          linecount = 0;
          }
#line 306
          if ((int )mode == 109) {
            {
#line 308
            header((char *)"NUT:  Plot Monthly Trends");
#line 309
            printf((char const   */* __restrict  */)"%6s %-s %-s\n", " ", "Protein/Carb/Fat Calories",
                   nutname);
#line 310
            printf((char const   */* __restrict  */)"%6s %-s %-s\n", " ", caldvstring,
                   nutdvstring);
            }
          }
#line 312
          if ((int )mode == 100) {
            {
#line 314
            saveep_ptr = ep_ptr;
#line 315
            header((char *)"NUT:  Plot Daily Trends");
#line 316
            printf((char const   */* __restrict  */)"%8s %-s %-s\n", " ", "Protein/Carb/Fat Calories",
                   nutname);
#line 317
            printf((char const   */* __restrict  */)"%8s %-s %-s\n", " ", caldvstring,
                   nutdvstring);
            }
          }
#line 319
          ep_ptr = saveep_ptr;
        }
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 322
    spacer(linecount + 2);
#line 323
    printf((char const   */* __restrict  */)"\nPress <enter> to quit...");
#line 324
    count = get_int();
    }
#line 325
    if ((int )mode == 109) {
      {
#line 325
      header((char *)"NUT:  Plot Monthly Trends");
      }
    }
#line 326
    if ((int )mode == 100) {
      {
#line 326
      header((char *)"NUT:  Plot Daily Trends");
      }
    }
    {
#line 327
    nut_list();
#line 328
    printf((char const   */* __restrict  */)"\nType number of nutrient to graph and \"d\" or \"m\" (or <enter> to quit):  ");
#line 329
    nutnum = get_trendy(& mode);
    }
#line 330
    if (nutnum < 1) {
#line 330
      goto _L___3;
    } else
#line 330
    if (nutnum > *(ScreenMap[options.screen])) {
      _L___3: /* CIL Label */ 
#line 332
      saveep_ptr = eachmonth.next;
      {
#line 333
      while (1) {
        while_continue___45: /* CIL Label */ ;
#line 333
        if (! ((unsigned long )saveep_ptr != (unsigned long )((void *)0))) {
#line 333
          goto while_break___45;
        }
        {
#line 335
        ep_ptr = saveep_ptr;
#line 336
        saveep_ptr = ep_ptr->next;
#line 337
        free((void *)ep_ptr);
        }
      }
      while_break___45: /* CIL Label */ ;
      }
#line 339
      saveep_ptr = eachday.next;
      {
#line 340
      while (1) {
        while_continue___46: /* CIL Label */ ;
#line 340
        if (! ((unsigned long )saveep_ptr != (unsigned long )((void *)0))) {
#line 340
          goto while_break___46;
        }
        {
#line 342
        ep_ptr = saveep_ptr;
#line 343
        saveep_ptr = ep_ptr->next;
#line 344
        free((void *)ep_ptr);
        }
      }
      while_break___46: /* CIL Label */ ;
      }
#line 346
      return (mode);
    }
#line 348
    nutnum = *(ScreenMap[options.screen] + nutnum);
  }
  while_break___8: /* CIL Label */ ;
  }
}
}
#line 352 "/home/wheatley/newnew/temp/nut-nutrition-15.5/trendy.c"
int get_trendy(char *mode ) 
{ 
  char buff[128] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 355
  fgets((char */* __restrict  */)(buff), 128, (FILE */* __restrict  */)stdin);
#line 356
  tmp = strchr((char const   *)(buff), 'M');
  }
#line 356
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 356
    *mode = (char )'m';
  }
  {
#line 357
  tmp___0 = strchr((char const   *)(buff), 'm');
  }
#line 357
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 357
    *mode = (char )'m';
  }
  {
#line 358
  tmp___1 = strchr((char const   *)(buff), 'D');
  }
#line 358
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 358
    *mode = (char )'d';
  }
  {
#line 359
  tmp___2 = strchr((char const   *)(buff), 'd');
  }
#line 359
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 359
    *mode = (char )'d';
  }
  {
#line 360
  tmp___3 = atoi((char const   *)(buff));
  }
#line 360
  return (tmp___3);
}
}
#line 25 "/home/wheatley/newnew/temp/nut-nutrition-15.5/prtmenu.h"
void print_menus(void) ;
#line 31 "/home/wheatley/newnew/temp/nut-nutrition-15.5/prtmenu.c"
void print_menus(void) 
{ 
  FILE *fp___0 ;
  struct meal *meal_ptr ;
  int firstpage ;
  int count ;
  int mealcount ;
  char last_meal_date[9] ;
  char last_meal ;
  char newpage ;
  int tmp ;

  {
#line 34
  meal_ptr = options.temp_meal_root;
#line 35
  firstpage = 1;
#line 35
  mealcount = 0;
#line 36
  last_meal = (char )'0';
#line 36
  newpage = (char)12;
#line 37
  if ((unsigned long )meal_ptr->next == (unsigned long )((void *)0)) {
    {
#line 39
    header((char *)"NUT:  Print Menus from Meal Database");
#line 40
    spacer(0);
#line 41
    printf((char const   */* __restrict  */)"\nThere are no meals in database.  Press <enter> to continue...");
#line 42
    firstpage = get_int();
    }
#line 43
    return;
  }
  {
#line 45
  fp___0 = fopen((char const   */* __restrict  */)"menus.txt", (char const   */* __restrict  */)"w");
  }
#line 45
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
    {
#line 47
    printf((char const   */* __restrict  */)"Can\'t open file \"menus.txt\" to write.\n");
#line 48
    printf((char const   */* __restrict  */)"Press <enter> to continue...");
#line 49
    firstpage = get_int();
    }
#line 50
    return;
  }
  {
#line 52
  strcpy((char */* __restrict  */)(last_meal_date), (char const   */* __restrict  */)"");
#line 53
  clear_work();
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! ((unsigned long )meal_ptr->next != (unsigned long )((void *)0))) {
#line 54
      goto while_break;
    }
    {
#line 56
    meal_ptr = meal_ptr->next;
#line 57
    tmp = strcmp((char const   *)(last_meal_date), (char const   *)(meal_ptr->meal_date));
    }
#line 57
    if (tmp != 0) {
#line 57
      goto _L;
    } else
#line 57
    if ((int )last_meal != (int )meal_ptr->meal) {
      _L: /* CIL Label */ 
      {
#line 59
      strcpy((char */* __restrict  */)(last_meal_date), (char const   */* __restrict  */)(meal_ptr->meal_date));
#line 60
      last_meal = meal_ptr->meal;
#line 61
      mealcount ++;
      }
#line 62
      if (mealcount > options.defanal) {
#line 62
        if (options.defanal != 0) {
#line 62
          goto while_break;
        }
      }
#line 63
      if (firstpage == 1) {
        {
#line 65
        firstpage = 0;
#line 66
        fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"Meal Date:  %s                                           Meal Number:  %d\n\n",
                last_meal_date, (int )last_meal);
        }
      } else {
        {
#line 70
        fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"\n");
#line 71
        food_display(fp___0);
        }
#line 72
        if (mealcount % 2) {
          {
#line 72
          fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%c",
                  (int )newpage);
          }
        } else {
          {
#line 73
          fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"________________________________________________________________________________\n\n");
          }
        }
        {
#line 74
        fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"Meal Date:  %s                                           Meal Number:  %d\n\n",
                last_meal_date, (int )last_meal);
#line 75
        clear_work();
        }
      }
    }
    {
#line 78
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%4.0f gm or %4.1f oz %-60s\n",
            (double )meal_ptr->grams, (double )meal_ptr->grams / 28.349523, (FoodIndex[meal_ptr->food_no])->name);
#line 79
    count = 0;
    }
    {
#line 79
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 79
      if (! (count < 159)) {
#line 79
        goto while_break___0;
      }
#line 79
      food_work.nutrient[count] += ((FoodIndex[meal_ptr->food_no])->nutrient[count] * meal_ptr->grams) / (float )100;
#line 79
      count ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"\n");
#line 82
  food_display(fp___0);
#line 83
  clear_work();
#line 84
  fclose(fp___0);
#line 86
  header((char *)"NUT:  Print Menus from Meal Database");
#line 87
  spacer(0);
#line 88
  printf((char const   */* __restrict  */)"\nMenus printed to \"menus.txt\".  Press <enter> to continue...");
#line 89
  firstpage = get_int();
  }
#line 90
  return;
}
}
#line 25 "/home/wheatley/newnew/temp/nut-nutrition-15.5/remmeal.h"
void remove_meals(void) ;
#line 26
void remove_meals_menu(void) ;
#line 27 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.h"
int get_char(void) ;
#line 100 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.h"
void auto_del(void) ;
#line 32 "/home/wheatley/newnew/temp/nut-nutrition-15.5/remmeal.c"
void remove_meals(void) 
{ 
  int menu_choice ;
  int junk ;
  int tmp ;

  {
  {
#line 35
  header((char *)"NUT:  Delete Meals and Set Meals Per Day");
#line 36
  remove_meals_menu();
#line 37
  spacer(14);
#line 38
  printf((char const   */* __restrict  */)"\nEnter your choice (or just <enter> to quit):  ");
#line 39
  menu_choice = get_int();
  }
#line 40
  if (menu_choice < 1) {
#line 40
    return;
  } else
#line 40
  if (menu_choice > 6) {
#line 40
    return;
  }
#line 41
  if (menu_choice == 6) {
    {
#line 43
    auto_del();
    }
#line 44
    return;
  }
  {
#line 46
  tmp = meal_count(& meal_root);
  }
#line 46
  if (tmp > 0) {
    {
#line 48
    header((char *)"NUT:  Delete Meals and Set Meals Per Day");
#line 49
    remove_meals_menu();
#line 50
    spacer(14);
#line 51
    printf((char const   */* __restrict  */)"\nAre you sure you want to ");
    }
    {
#line 54
    if (menu_choice == 1) {
#line 54
      goto case_1;
    }
#line 56
    if (menu_choice == 2) {
#line 56
      goto case_2;
    }
#line 58
    if (menu_choice == 3) {
#line 58
      goto case_3;
    }
#line 60
    if (menu_choice == 4) {
#line 60
      goto case_4;
    }
#line 62
    if (menu_choice == 5) {
#line 62
      goto case_5;
    }
#line 52
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 54
    printf((char const   */* __restrict  */)"delete all except last month\'s meals?  (y/n):  ");
    }
#line 55
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 56
    printf((char const   */* __restrict  */)"delete all except last week\'s meals?  (y/n):  ");
    }
#line 57
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 58
    printf((char const   */* __restrict  */)"delete all except last day\'s meals?  (y/n):  ");
    }
#line 59
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 60
    printf((char const   */* __restrict  */)"delete all except last meal?  (y/n):  ");
    }
#line 61
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 62
    printf((char const   */* __restrict  */)"delete all meals?  (y/n):  ");
    }
#line 63
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 65
    junk = get_char();
    }
#line 66
    if (junk != 89) {
#line 66
      if (junk != 121) {
#line 66
        return;
      }
    }
  }
  {
#line 70
  if (menu_choice == 1) {
#line 70
    goto case_1___0;
  }
#line 72
  if (menu_choice == 2) {
#line 72
    goto case_2___0;
  }
#line 74
  if (menu_choice == 3) {
#line 74
    goto case_3___0;
  }
#line 76
  if (menu_choice == 4) {
#line 76
    goto case_4___0;
  }
#line 78
  if (menu_choice == 5) {
#line 78
    goto case_5___0;
  }
#line 68
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 70
  delete_meals(30 * options.mealsperday);
  }
#line 71
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 72
  delete_meals(7 * options.mealsperday);
  }
#line 73
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 74
  delete_meals(options.mealsperday);
  }
#line 75
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
  {
#line 76
  delete_meals(1);
  }
#line 77
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
  {
#line 78
  delete_meals(0);
  }
#line 79
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 81
  write_meal_db();
  }
#line 82
  if (menu_choice == 5) {
    {
#line 84
    header((char *)"NUT:  Delete Meals and Set Meals Per Day");
#line 85
    spacer(1);
#line 86
    printf((char const   */* __restrict  */)"\nMeals per day currently set at %d.",
           options.mealsperday);
#line 87
    printf((char const   */* __restrict  */)"\nEnter 1-19 or just <enter> to retain current value:  ");
#line 88
    junk = get_int();
    }
#line 89
    if (junk > 0) {
#line 89
      if (junk < 20) {
#line 89
        options.mealsperday = junk;
      }
    }
    {
#line 90
    write_OPTIONS();
    }
  }
#line 92
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/nut-nutrition-15.5/remmeal.c"
void remove_meals_menu(void) 
{ 


  {
  {
#line 96
  printf((char const   */* __restrict  */)"\n\n                  1  --  Delete All Except Last Month\'s Meals\n\n");
#line 97
  printf((char const   */* __restrict  */)"                  2  --  Delete All Except Last Week\'s Meals\n\n");
#line 98
  printf((char const   */* __restrict  */)"                  3  --  Delete All Except Last Day\'s Meals\n\n");
#line 99
  printf((char const   */* __restrict  */)"                  4  --  Delete All Except Last Meal\n\n");
#line 100
  printf((char const   */* __restrict  */)"                  5  --  Delete All Meals and Set Meals Per Day\n\n");
#line 101
  printf((char const   */* __restrict  */)"                  6  --  Automatic Deletion of Meals\n\n");
  }
#line 102
  return;
}
}
#line 25 "/home/wheatley/newnew/temp/nut-nutrition-15.5/ranking.h"
int Minut ;
#line 26
int Fdgrp ;
#line 28
void view_nuts(int opt ) ;
#line 29
void rank_foods(int num , int opt ) ;
#line 30
int max_array(float *abacus ) ;
#line 32
void fdgrp_list(void) ;
#line 29 "/home/wheatley/newnew/temp/nut-nutrition-15.5/ranking.c"
int Minut  =    -1;
#line 30 "/home/wheatley/newnew/temp/nut-nutrition-15.5/ranking.c"
int Fdgrp  =    -1;
#line 32 "/home/wheatley/newnew/temp/nut-nutrition-15.5/ranking.c"
void view_nuts(int opt ) 
{ 
  int num ;
  char head[80] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 34
  num = 0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (opt == 0) {
#line 38
      if (options.screen == 0) {
        {
#line 38
        header((char *)"NUT:  View \"Daily Values\" and Rank Foods by Nutrients per 100 Calories");
        }
      }
    }
#line 39
    if (opt == 1) {
#line 39
      if (options.screen == 0) {
        {
#line 39
        header((char *)"NUT:  View \"Daily Values\" and Rank Foods by Nutrients per 100 Grams");
        }
      }
    }
#line 40
    if (opt == 3) {
#line 40
      if (options.screen == 0) {
        {
#line 40
        header((char *)"NUT:  View \"Daily Values\" and Rank Foods by Nutrients per 100 Grams Dry Weight");
        }
      }
    }
#line 41
    if (opt == 4) {
#line 41
      if (options.screen == 0) {
        {
#line 41
        header((char *)"NUT:  View \"Daily Values\" and Rank Foods by Nutrients per Serving");
        }
      }
    }
#line 42
    if (opt == 2) {
#line 42
      if (options.screen == 0) {
        {
#line 42
        header((char *)"NUT:  View \"Daily Values\" and Rank Foods by Nutrients per Daily Recorded Meals");
        }
      }
    }
#line 43
    if (opt == 0) {
#line 43
      if (options.screen > 0) {
        {
#line 43
        header((char *)"NUT:  View Nutrients and Rank Foods by Nutrients per 100 Calories");
        }
      }
    }
#line 44
    if (opt == 1) {
#line 44
      if (options.screen > 0) {
        {
#line 44
        header((char *)"NUT:  View Nutrients and Rank Foods by Nutrients per 100 Grams");
        }
      }
    }
#line 45
    if (opt == 3) {
#line 45
      if (options.screen > 0) {
        {
#line 45
        header((char *)"NUT:  View Nutrients and Rank Foods by Nutrients per 100 Grams Dry Weight");
        }
      }
    }
#line 46
    if (opt == 4) {
#line 46
      if (options.screen > 0) {
        {
#line 46
        header((char *)"NUT:  View Nutrients and Rank Foods by Nutrients per Serving");
        }
      }
    }
#line 47
    if (opt == 2) {
#line 47
      if (options.screen > 0) {
        {
#line 47
        header((char *)"NUT:  View Nutrients and Rank Foods by Nutrients per Daily Recorded Meals");
        }
      }
    }
#line 48
    if (opt == 5) {
      {
#line 50
      strcpy((char */* __restrict  */)(head), (char const   */* __restrict  */)"NUT:  Rank Foods by Nutrients per Serving, Minimize ");
      }
#line 51
      if (Minut == -1) {
#line 51
        tmp = "?";
      } else {
#line 51
        tmp = (char const   *)Nutrient[Minut];
      }
      {
#line 51
      strcat((char */* __restrict  */)(head), (char const   */* __restrict  */)tmp);
#line 52
      header(head);
#line 53
      nut_list();
      }
#line 54
      if (Minut == -1) {
        {
#line 56
        printf((char const   */* __restrict  */)"\nType number of Nutrient to Minimize (or <enter> to quit):  ");
#line 57
        num = get_int();
        }
#line 58
        if (num < 1) {
#line 58
          return;
        } else
#line 58
        if (num > *(ScreenMap[options.screen])) {
#line 58
          return;
        }
#line 59
        Minut = *(ScreenMap[options.screen] + num);
      }
      {
#line 61
      strcpy((char */* __restrict  */)(head), (char const   */* __restrict  */)"NUT:  Rank Foods by Nutrients per Serving, Minimize ");
      }
#line 62
      if (Minut == -1) {
#line 62
        tmp___0 = "?";
      } else {
#line 62
        tmp___0 = (char const   *)Nutrient[Minut];
      }
      {
#line 62
      strcat((char */* __restrict  */)(head), (char const   */* __restrict  */)tmp___0);
#line 63
      header(head);
      }
    }
#line 65
    if (opt == 6) {
      {
#line 67
      strcpy((char */* __restrict  */)(head), (char const   */* __restrict  */)"NUT:  Rank Foods by Nutrients within ");
      }
#line 68
      if (Fdgrp == -1) {
#line 68
        tmp___1 = "?";
      } else {
#line 68
        tmp___1 = (char const   *)FdGrp[Fdgrp];
      }
      {
#line 68
      strcat((char */* __restrict  */)(head), (char const   */* __restrict  */)tmp___1);
#line 69
      header(head);
#line 70
      fdgrp_list();
      }
#line 71
      if (Fdgrp == -1) {
        {
#line 73
        printf((char const   */* __restrict  */)"\nType number of Food Group (or <enter> to quit):  ");
#line 74
        num = get_int();
        }
#line 75
        if (num < 1) {
#line 75
          return;
        } else
#line 75
        if (num > MaxFdGrp) {
#line 75
          return;
        }
#line 76
        Fdgrp = FdGrpMap[num - 1];
      }
      {
#line 78
      strcpy((char */* __restrict  */)(head), (char const   */* __restrict  */)"NUT:  Rank Foods by Nutrients within ");
      }
#line 79
      if (Fdgrp == -1) {
#line 79
        tmp___2 = "?";
      } else {
#line 79
        tmp___2 = (char const   *)FdGrp[Fdgrp];
      }
      {
#line 79
      strcat((char */* __restrict  */)(head), (char const   */* __restrict  */)tmp___2);
#line 80
      header(head);
      }
    }
    {
#line 82
    nut_list();
#line 83
    printf((char const   */* __restrict  */)"\nType number of Nutrient to see food rankings (or <enter> to quit):  ");
#line 84
    num = get_int();
    }
#line 85
    if (num < 1) {
#line 85
      return;
    } else
#line 85
    if (num > *(ScreenMap[options.screen])) {
#line 85
      return;
    }
    {
#line 86
    rank_foods(*(ScreenMap[options.screen] + num), opt);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 90 "/home/wheatley/newnew/temp/nut-nutrition-15.5/ranking.c"
void rank_foods(int num , int opt ) 
{ 
  int count ;
  int max ;
  int junk ;
  int displayed ;
  int meal ;
  int meals ;
  int maxmeal ;
  int mincount ;
  float minavg ;
  float abacus[9000] ;
  struct food *food_ptr ;
  struct meal *meal_ptr ;
  char head[80] ;
  char thisname[60] ;
  char meal_date[9] ;
  float theseounces ;
  float days ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 92
  max = 0;
#line 92
  displayed = 0;
#line 92
  meal = 0;
#line 92
  meals = 0;
#line 92
  maxmeal = options.defanal;
#line 93
  mincount = 0;
#line 94
  minavg = (float )0;
#line 96
  food_ptr = & food_root;
#line 97
  meal_ptr = & meal_root;
#line 101
  if (options.screen == 0) {
    {
#line 101
    strcpy((char */* __restrict  */)(head), (char const   */* __restrict  */)"NUT:  Foods Ranked by % of ");
    }
  } else {
    {
#line 102
    strcpy((char */* __restrict  */)(head), (char const   */* __restrict  */)"NUT:  Foods Ranked by ");
    }
  }
  {
#line 103
  tmp___0 = meal_count(options.temp_meal_root);
  }
#line 103
  if (tmp___0 < options.defanal) {
    {
#line 105
    tmp = meal_count(options.temp_meal_root);
#line 105
    days = (float )tmp / (float )options.mealsperday;
#line 106
    maxmeal = meal_count(options.temp_meal_root);
    }
  } else
#line 103
  if (options.defanal == 0) {
    {
#line 105
    tmp = meal_count(options.temp_meal_root);
#line 105
    days = (float )tmp / (float )options.mealsperday;
#line 106
    maxmeal = meal_count(options.temp_meal_root);
    }
  } else {
#line 110
    days = (float )options.defanal / (float )options.mealsperday;
#line 111
    maxmeal = options.defanal;
  }
  {
#line 113
  strcat((char */* __restrict  */)(head), (char const   */* __restrict  */)Nutrient[num]);
  }
#line 114
  if (opt == 0) {
#line 114
    if (options.screen == 0) {
      {
#line 114
      strcat((char */* __restrict  */)(head), (char const   */* __restrict  */)" DV per 100 Calories");
      }
    }
  }
#line 115
  if (opt == 1) {
#line 115
    if (options.screen == 0) {
      {
#line 115
      strcat((char */* __restrict  */)(head), (char const   */* __restrict  */)" DV per 100 Grams (3.5 oz)");
      }
    }
  }
#line 116
  if (opt == 4) {
#line 116
    if (options.screen == 0) {
      {
#line 116
      strcat((char */* __restrict  */)(head), (char const   */* __restrict  */)" DV per Serving");
      }
    }
  }
#line 117
  if (opt == 2) {
#line 117
    if (options.screen == 0) {
      {
#line 117
      strcat((char */* __restrict  */)(head), (char const   */* __restrict  */)" DV per Daily Recorded Meals");
      }
    }
  }
#line 118
  if (opt == 3) {
#line 118
    if (options.screen == 0) {
      {
#line 118
      strcat((char */* __restrict  */)(head), (char const   */* __restrict  */)" DV per 100 Grams Dry Weight");
      }
    }
  }
#line 119
  if (opt == 0) {
#line 119
    if (options.screen > 0) {
      {
#line 119
      strcat((char */* __restrict  */)(head), (char const   */* __restrict  */)" per 100 Calories");
      }
    }
  }
#line 120
  if (opt == 1) {
#line 120
    if (options.screen > 0) {
      {
#line 120
      strcat((char */* __restrict  */)(head), (char const   */* __restrict  */)" per 100 Grams (3.5 oz)");
      }
    }
  }
#line 121
  if (opt == 3) {
#line 121
    if (options.screen > 0) {
      {
#line 121
      strcat((char */* __restrict  */)(head), (char const   */* __restrict  */)" per 100 Grams Dry Weight");
      }
    }
  }
#line 122
  if (opt == 4) {
#line 122
    if (options.screen > 0) {
      {
#line 122
      strcat((char */* __restrict  */)(head), (char const   */* __restrict  */)" per Serving");
      }
    }
  }
#line 123
  if (opt == 2) {
#line 123
    if (options.screen > 0) {
      {
#line 123
      strcat((char */* __restrict  */)(head), (char const   */* __restrict  */)" per Daily Recorded Meals");
      }
    }
  }
#line 124
  if (opt == 5) {
    {
#line 124
    sprintf((char */* __restrict  */)(head), (char const   */* __restrict  */)"%-49s%14s %14s",
            "NUT:  Foods Ranked by Nutrients per Serving:", Nutrient[num], Nutrient[Minut]);
    }
  }
#line 125
  if (opt == 6) {
#line 125
    if (options.screen > 0) {
      {
#line 125
      sprintf((char */* __restrict  */)(head), (char const   */* __restrict  */)"%-21s %1s %2s %-1s",
              "NUT:  Foods Ranked by", Nutrient[num], "in 100g", FdGrp[Fdgrp]);
      }
    }
  }
#line 126
  if (opt == 6) {
#line 126
    if (options.screen == 0) {
      {
#line 126
      sprintf((char */* __restrict  */)(head), (char const   */* __restrict  */)"%-21s %1s %2s %-1s",
              "NUT:  Foods Ranked by %DV", Nutrient[num], "in 100g", FdGrp[Fdgrp]);
      }
    }
  }
#line 127
  if (opt == 2) {
    {
#line 127
    tmp___1 = meal_count(options.temp_meal_root);
    }
#line 127
    if (tmp___1 == 0) {
      {
#line 129
      header(head);
#line 130
      printf((char const   */* __restrict  */)"These rankings show which foods actually eaten are contributing to the Daily\n");
#line 131
      printf((char const   */* __restrict  */)"Values, but there are no meals in the meal database.\n");
#line 132
      spacer(2);
#line 133
      printf((char const   */* __restrict  */)"\nPress <enter> to continue...  ");
#line 134
      junk = get_int();
      }
#line 135
      return;
    }
  }
#line 137
  if (num == 4) {
#line 137
    if (opt == 0) {
#line 137
      if (options.screen == 0) {
        {
#line 139
        header(head);
#line 140
        printf((char const   */* __restrict  */)"These rankings are percentages of the \"Daily Value\" per 100 calories, to\n");
#line 141
        printf((char const   */* __restrict  */)"identify the foods which provide a high daily percentage of a nutrient with\n");
#line 142
        printf((char const   */* __restrict  */)"a low daily percentage of calories.  Thus, calories are not ranked.\n");
#line 143
        spacer(3);
#line 144
        printf((char const   */* __restrict  */)"\nPress <enter> to continue...  ");
#line 145
        junk = get_int();
        }
#line 146
        return;
      }
    }
  }
#line 148
  if (num == 4) {
#line 148
    goto _L;
  } else
#line 148
  if (num == 16) {
    _L: /* CIL Label */ 
#line 148
    if (opt == 0) {
#line 148
      if (options.screen > 0) {
        {
#line 150
        header(head);
#line 151
        printf((char const   */* __restrict  */)"These rankings are greatest nutrient values per 100 calories, to identify\n");
#line 152
        printf((char const   */* __restrict  */)"foods which provide a high amount of a nutrient with low energy values.\n");
#line 153
        printf((char const   */* __restrict  */)"Thus energy in kilocalories or kilojoules is not ranked.\n");
#line 154
        spacer(3);
#line 155
        printf((char const   */* __restrict  */)"\nPress <enter> to continue...  ");
#line 156
        junk = get_int();
        }
#line 157
        return;
      }
    }
  }
#line 159
  if (opt == 3) {
#line 159
    if (num == 12) {
      {
#line 161
      header(head);
#line 162
      printf((char const   */* __restrict  */)"These rankings subtract water from the food, so water itself is not ranked.\n");
#line 163
      spacer(1);
#line 164
      printf((char const   */* __restrict  */)"\nPress <enter> to continue...  ");
#line 165
      junk = get_int();
      }
#line 166
      return;
    }
  }
#line 168
  if (opt == 1) {
#line 168
    count = 0;
    {
#line 168
    while (1) {
      while_continue: /* CIL Label */ ;
#line 168
      if (! (count < FoodCount)) {
#line 168
        goto while_break;
      }
#line 170
      food_ptr = food_ptr->next;
#line 171
      if (options.screen == 0) {
#line 171
        abacus[count] = ((float )100 * food_ptr->nutrient[num]) / DV[num];
      } else {
#line 172
        abacus[count] = food_ptr->nutrient[num];
      }
#line 168
      count ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 174
  if (opt == 6) {
#line 174
    count = 0;
    {
#line 174
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 174
      if (! (count < FoodCount)) {
#line 174
        goto while_break___0;
      }
#line 176
      food_ptr = food_ptr->next;
#line 177
      if (options.screen == 0) {
#line 177
        abacus[count] = ((float )100 * food_ptr->nutrient[num]) / DV[num];
      } else {
#line 178
        abacus[count] = food_ptr->nutrient[num];
      }
#line 179
      if (food_ptr->fdgrp != Fdgrp) {
#line 179
        abacus[count] = (float )-1;
      }
#line 174
      count ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 181
  if (opt == 5) {
#line 183
    count = 0;
    {
#line 183
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 183
      if (! (count < FoodCount)) {
#line 183
        goto while_break___1;
      }
      {
#line 185
      food_ptr = food_ptr->next;
#line 186
      tmp___2 = test_for_negative_zero(& food_ptr->nutrient[Minut]);
      }
#line 186
      if (! tmp___2) {
#line 188
        minavg += food_ptr->nutrient[Minut];
#line 189
        mincount ++;
      }
#line 183
      count ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 192
    if (mincount > 0) {
#line 192
      minavg /= (float )mincount;
    }
#line 193
    food_ptr = & food_root;
#line 194
    count = 0;
    {
#line 194
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 194
      if (! (count < FoodCount)) {
#line 194
        goto while_break___2;
      }
#line 196
      food_ptr = food_ptr->next;
#line 197
      if (mincount == 0) {
#line 211
        abacus[count] = (float )0;
      } else {
        {
#line 197
        tmp___3 = test_for_negative_zero(& food_ptr->nutrient[num]);
        }
#line 197
        if (tmp___3) {
#line 211
          abacus[count] = (float )0;
        } else
#line 197
        if (Minut == num) {
#line 211
          abacus[count] = (float )0;
        } else
#line 197
        if (num == 158) {
#line 197
          if (Minut == 36) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 197
            goto _L___14;
          }
        } else
        _L___14: /* CIL Label */ 
#line 197
        if (num == 36) {
#line 197
          if (Minut == 158) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 197
            goto _L___13;
          }
        } else
        _L___13: /* CIL Label */ 
#line 197
        if (num == 147) {
#line 197
          if (Minut == 95) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 197
            goto _L___12;
          }
        } else
        _L___12: /* CIL Label */ 
#line 197
        if (num == 95) {
#line 197
          if (Minut == 147) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 197
            goto _L___11;
          }
        } else
        _L___11: /* CIL Label */ 
#line 197
        if (num == 147) {
#line 197
          if (Minut == 127) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 197
            goto _L___10;
          }
        } else
        _L___10: /* CIL Label */ 
#line 197
        if (num == 127) {
#line 197
          if (Minut == 147) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 197
            goto _L___9;
          }
        } else
        _L___9: /* CIL Label */ 
#line 197
        if (num == 148) {
#line 197
          if (Minut == 97) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 197
            goto _L___8;
          }
        } else
        _L___8: /* CIL Label */ 
#line 197
        if (num == 97) {
#line 197
          if (Minut == 148) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 197
            goto _L___7;
          }
        } else
        _L___7: /* CIL Label */ 
#line 197
        if (num == 149) {
#line 197
          if (Minut == 96) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 197
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 197
        if (num == 96) {
#line 197
          if (Minut == 149) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 197
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 197
        if (num == 149) {
#line 197
          if (Minut == 136) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 197
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 197
        if (num == 136) {
#line 197
          if (Minut == 149) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 197
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 197
        if (num == 150) {
#line 197
          if (Minut == 104) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 197
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 197
        if (num == 104) {
#line 197
          if (Minut == 150) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 197
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 197
        if (num == 151) {
#line 197
          if (Minut == 98) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 197
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 197
        if (num == 98) {
#line 197
          if (Minut == 151) {
#line 211
            abacus[count] = (float )0;
          } else {
#line 212
            abacus[count] = ((food_ptr->grams / (float )-100) * food_ptr->nutrient[num]) * (((food_ptr->grams / (float )100) * food_ptr->nutrient[Minut]) / minavg - (float )1);
          }
        } else {
#line 212
          abacus[count] = ((food_ptr->grams / (float )-100) * food_ptr->nutrient[num]) * (((food_ptr->grams / (float )100) * food_ptr->nutrient[Minut]) / minavg - (float )1);
        }
      }
#line 194
      count ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 215
  if (opt == 0) {
#line 215
    count = 0;
    {
#line 215
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 215
      if (! (count < FoodCount)) {
#line 215
        goto while_break___3;
      }
#line 217
      food_ptr = food_ptr->next;
#line 218
      if (food_ptr->nutrient[4] > (float )0) {
#line 220
        if (options.screen == 0) {
#line 220
          abacus[count] = ((float )10000 * food_ptr->nutrient[num]) / (food_ptr->nutrient[4] * DV[num]);
        } else {
#line 221
          abacus[count] = ((float )100 * food_ptr->nutrient[num]) / food_ptr->nutrient[4];
        }
      } else {
#line 223
        abacus[count] = (float )0;
      }
#line 215
      count ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 225
  if (opt == 4) {
#line 225
    count = 0;
    {
#line 225
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 225
      if (! (count < FoodCount)) {
#line 225
        goto while_break___4;
      }
#line 227
      food_ptr = food_ptr->next;
#line 228
      if (options.screen == 0) {
#line 228
        abacus[count] = (food_ptr->grams * food_ptr->nutrient[num]) / DV[num];
      } else {
#line 229
        abacus[count] = (food_ptr->grams / (float )100) * food_ptr->nutrient[num];
      }
#line 225
      count ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 231
  if (opt == 3) {
#line 231
    count = 0;
    {
#line 231
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 231
      if (! (count < FoodCount)) {
#line 231
        goto while_break___5;
      }
#line 233
      food_ptr = food_ptr->next;
#line 234
      if (options.screen == 0) {
#line 234
        abacus[count] = ((float )10000 * food_ptr->nutrient[num]) / (((float )100 - food_ptr->nutrient[12]) * DV[num]);
      }
#line 235
      if (options.screen > 0) {
#line 235
        abacus[count] = ((float )100 * food_ptr->nutrient[num]) / ((float )100 - food_ptr->nutrient[12]);
      }
#line 231
      count ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 237
  if (opt == 2) {
#line 239
    count = 0;
    {
#line 239
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 239
      if (! (count < FoodCount)) {
#line 239
        goto while_break___6;
      }
#line 239
      abacus[count] = (float )0;
#line 239
      count ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 240
    meal_ptr = options.temp_meal_root;
#line 241
    meals = 0;
    {
#line 242
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 242
      if ((unsigned long )meal_ptr->next != (unsigned long )((void *)0)) {
#line 242
        if (! (meals <= maxmeal)) {
#line 242
          goto while_break___7;
        }
      } else {
#line 242
        goto while_break___7;
      }
      {
#line 244
      meal_ptr = meal_ptr->next;
#line 245
      tmp___4 = strcmp((char const   *)(meal_date), (char const   *)(meal_ptr->meal_date));
      }
#line 245
      if (tmp___4 != 0) {
        {
#line 247
        strcpy((char */* __restrict  */)(meal_date), (char const   */* __restrict  */)(meal_ptr->meal_date));
#line 248
        meal = (int )meal_ptr->meal;
#line 249
        meals ++;
        }
      } else
#line 245
      if (meal != (int )meal_ptr->meal) {
        {
#line 247
        strcpy((char */* __restrict  */)(meal_date), (char const   */* __restrict  */)(meal_ptr->meal_date));
#line 248
        meal = (int )meal_ptr->meal;
#line 249
        meals ++;
        }
      }
#line 251
      if (meals <= maxmeal) {
#line 251
        abacus[meal_ptr->food_no] += meal_ptr->grams;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 253
    count = 0;
    {
#line 253
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 253
      if (! (count < FoodCount)) {
#line 253
        goto while_break___8;
      }
#line 255
      abacus[count] /= days;
#line 256
      if (options.screen == 0) {
#line 256
        abacus[count] *= (FoodIndex[count])->nutrient[num] / DV[num];
      }
#line 257
      if (options.screen > 0) {
#line 257
        abacus[count] *= (FoodIndex[count])->nutrient[num];
      }
#line 253
      count ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  {
#line 260
  junk = 'm';
#line 261
  max = max_array(abacus);
  }
  {
#line 262
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 262
    if (displayed <= FoodCount - 20) {
#line 262
      if (! (junk == 109)) {
#line 262
        if (! (junk == 77)) {
#line 262
          goto while_break___9;
        }
      }
    } else {
#line 262
      goto while_break___9;
    }
    {
#line 264
    header(head);
#line 265
    count = 0;
    }
    {
#line 265
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 265
      if (! (count < 20)) {
#line 265
        goto while_break___10;
      }
#line 267
      if (abacus[max] == (float )0) {
        {
#line 269
        max = FoodCount + 1;
#line 270
        displayed = FoodCount + 1;
#line 271
        spacer(count);
#line 272
        count = 20;
#line 273
        printf((char const   */* __restrict  */)"\nPress <enter> to quit...  ");
#line 274
        junk = get_char();
        }
#line 275
        goto while_break___10;
      }
      {
#line 277
      food_ptr = food_number(max);
#line 278
      strncpy((char */* __restrict  */)(thisname), (char const   */* __restrict  */)(food_ptr->name),
              (size_t )54);
#line 278
      thisname[54] = (char )'\000';
      }
#line 279
      if (opt == 5) {
        {
#line 279
        strncpy((char */* __restrict  */)(thisname), (char const   */* __restrict  */)(food_ptr->name),
                (size_t )52);
        }
      }
#line 279
      thisname[52] = (char )'\000';
#line 280
      if (opt == 2) {
#line 280
        if (options.screen == 0) {
#line 282
          theseounces = (float )((double )(abacus[max] * DV[num]) / ((double )food_ptr->nutrient[num] * 28.349523));
#line 283
          if (options.grams) {
            {
#line 283
            printf((char const   */* __restrict  */)"%-54s        %7.1f g %5.0f%%\n",
                   thisname, (double )theseounces * 28.349523, (double )abacus[max]);
            }
          }
#line 284
          if (! options.grams) {
            {
#line 284
            printf((char const   */* __restrict  */)"%-54s        %6.1f oz %5.0f%%\n",
                   thisname, (double )theseounces, (double )abacus[max]);
            }
          }
        }
      }
#line 286
      if (opt == 2) {
#line 286
        if (options.screen > 0) {
#line 286
          if (options.screen < 4) {
#line 288
            theseounces = (float )((double )abacus[max] / ((double )food_ptr->nutrient[num] * 28.349523));
#line 289
            if (options.grams) {
              {
#line 289
              printf((char const   */* __restrict  */)"%-54s %7.1f g %9.1f %-3s\n",
                     thisname, (double )theseounces * 28.349523, (double )(abacus[max] / (float )100),
                     Unit[num]);
              }
            }
#line 290
            if (! options.grams) {
              {
#line 290
              printf((char const   */* __restrict  */)"%-54s %6.1f oz %9.1f %-3s\n",
                     thisname, (double )theseounces, (double )(abacus[max] / (float )100),
                     Unit[num]);
              }
            }
          }
        }
      }
#line 292
      if (opt == 2) {
#line 292
        if (options.screen > 3) {
#line 294
          theseounces = (float )((double )abacus[max] / ((double )food_ptr->nutrient[num] * 28.349523));
#line 295
          if (options.grams) {
            {
#line 295
            printf((char const   */* __restrict  */)"%-54s %7.1f g %9.2f %-3s\n",
                   thisname, (double )theseounces * 28.349523, (double )(abacus[max] / (float )100),
                   Unit[num]);
            }
          }
#line 296
          if (! options.grams) {
            {
#line 296
            printf((char const   */* __restrict  */)"%-54s %6.1f oz %9.2f %-3s\n",
                   thisname, (double )theseounces, (double )(abacus[max] / (float )100),
                   Unit[num]);
            }
          }
        }
      }
#line 298
      if (opt == 1) {
#line 298
        if (options.screen == 0) {
          {
#line 298
          printf((char const   */* __restrict  */)"%-54s                  %5.0f%%\n",
                 thisname, (double )abacus[max]);
          }
        }
      }
#line 299
      if (opt == 1) {
#line 299
        if (options.screen > 0) {
#line 299
          if (options.screen < 4) {
            {
#line 299
            printf((char const   */* __restrict  */)"%-54s          %10.1f %-3s\n",
                   thisname, (double )abacus[max], Unit[num]);
            }
          }
        }
      }
#line 300
      if (opt == 1) {
#line 300
        if (options.screen > 0) {
#line 300
          if (options.screen > 3) {
            {
#line 300
            printf((char const   */* __restrict  */)"%-54s          %10.2f %-3s\n",
                   thisname, (double )abacus[max], Unit[num]);
            }
          }
        }
      }
#line 301
      if (opt == 6) {
#line 301
        if (options.screen == 0) {
          {
#line 301
          printf((char const   */* __restrict  */)"%-54s                  %5.0f%%\n",
                 thisname, (double )abacus[max]);
          }
        }
      }
#line 302
      if (opt == 6) {
#line 302
        if (options.screen > 0) {
#line 302
          if (options.screen < 4) {
            {
#line 302
            printf((char const   */* __restrict  */)"%-54s          %10.1f %-3s\n",
                   thisname, (double )abacus[max], Unit[num]);
            }
          }
        }
      }
#line 303
      if (opt == 6) {
#line 303
        if (options.screen > 0) {
#line 303
          if (options.screen > 3) {
            {
#line 303
            printf((char const   */* __restrict  */)"%-54s          %10.2f %-3s\n",
                   thisname, (double )abacus[max], Unit[num]);
            }
          }
        }
      }
#line 304
      if (opt == 3) {
#line 304
        if (options.screen == 0) {
#line 304
          if (options.grams) {
            {
#line 304
            printf((char const   */* __restrict  */)"%-54s        %7.1f g %5.0f%%\n",
                   thisname, (double )((float )10000 / ((float )100 - food_ptr->nutrient[12])),
                   (double )abacus[max]);
            }
          }
        }
      }
#line 305
      if (opt == 3) {
#line 305
        if (options.screen == 0) {
#line 305
          if (! options.grams) {
            {
#line 305
            printf((char const   */* __restrict  */)"%-54s        %6.1f oz %5.0f%%\n",
                   thisname, (double )((float )10000 / ((float )100 - food_ptr->nutrient[12])) / 28.349523,
                   (double )abacus[max]);
            }
          }
        }
      }
#line 306
      if (opt == 3) {
#line 306
        if (options.screen > 0) {
#line 306
          if (options.screen < 4) {
#line 306
            if (options.grams) {
              {
#line 306
              printf((char const   */* __restrict  */)"%-54s %7.1f g %9.1f %-3s\n",
                     thisname, (double )((float )10000 / ((float )100 - food_ptr->nutrient[12])),
                     (double )abacus[max], Unit[num]);
              }
            }
          }
        }
      }
#line 307
      if (opt == 3) {
#line 307
        if (options.screen > 0) {
#line 307
          if (options.screen < 4) {
#line 307
            if (! options.grams) {
              {
#line 307
              printf((char const   */* __restrict  */)"%-54s %6.1f oz %9.1f %-3s\n",
                     thisname, (double )((float )10000 / ((float )100 - food_ptr->nutrient[12])) / 28.349523,
                     (double )abacus[max], Unit[num]);
              }
            }
          }
        }
      }
#line 308
      if (opt == 3) {
#line 308
        if (options.screen > 0) {
#line 308
          if (options.screen > 3) {
#line 308
            if (options.grams) {
              {
#line 308
              printf((char const   */* __restrict  */)"%-54s %7.1f g %9.2f %-3s\n",
                     thisname, (double )((float )10000 / ((float )100 - food_ptr->nutrient[12])),
                     (double )abacus[max], Unit[num]);
              }
            }
          }
        }
      }
#line 309
      if (opt == 3) {
#line 309
        if (options.screen > 0) {
#line 309
          if (options.screen > 3) {
#line 309
            if (! options.grams) {
              {
#line 309
              printf((char const   */* __restrict  */)"%-54s %6.1f oz %9.2f %-3s\n",
                     thisname, (double )((float )10000 / ((float )100 - food_ptr->nutrient[12])) / 28.349523,
                     (double )abacus[max], Unit[num]);
              }
            }
          }
        }
      }
#line 310
      if (opt == 0) {
#line 310
        if (options.screen == 0) {
#line 310
          if (options.grams) {
            {
#line 310
            printf((char const   */* __restrict  */)"%-54s        %7.1f g %5.0f%%\n",
                   thisname, (double )((float )10000 / food_ptr->nutrient[4]), (double )abacus[max]);
            }
          }
        }
      }
#line 311
      if (opt == 0) {
#line 311
        if (options.screen == 0) {
#line 311
          if (! options.grams) {
            {
#line 311
            printf((char const   */* __restrict  */)"%-54s        %6.1f oz %5.0f%%\n",
                   thisname, (double )((float )10000 / food_ptr->nutrient[4]) / 28.349523,
                   (double )abacus[max]);
            }
          }
        }
      }
#line 312
      if (opt == 0) {
#line 312
        if (options.screen > 0) {
#line 312
          if (options.screen < 4) {
#line 312
            if (options.grams) {
              {
#line 312
              printf((char const   */* __restrict  */)"%-54s %7.1f g %9.1f %-3s\n",
                     thisname, (double )((float )10000 / food_ptr->nutrient[4]), (double )abacus[max],
                     Unit[num]);
              }
            }
          }
        }
      }
#line 313
      if (opt == 0) {
#line 313
        if (options.screen > 0) {
#line 313
          if (options.screen < 4) {
#line 313
            if (! options.grams) {
              {
#line 313
              printf((char const   */* __restrict  */)"%-54s %6.1f oz %9.1f %-3s\n",
                     thisname, (double )((float )10000 / food_ptr->nutrient[4]) / 28.349523,
                     (double )abacus[max], Unit[num]);
              }
            }
          }
        }
      }
#line 314
      if (opt == 0) {
#line 314
        if (options.screen > 0) {
#line 314
          if (options.screen > 3) {
#line 314
            if (options.grams) {
              {
#line 314
              printf((char const   */* __restrict  */)"%-54s %7.1f g %9.2f %-3s\n",
                     thisname, (double )((float )10000 / food_ptr->nutrient[4]), (double )abacus[max],
                     Unit[num]);
              }
            }
          }
        }
      }
#line 315
      if (opt == 0) {
#line 315
        if (options.screen > 0) {
#line 315
          if (options.screen > 3) {
#line 315
            if (! options.grams) {
              {
#line 315
              printf((char const   */* __restrict  */)"%-54s %6.1f oz %9.2f %-3s\n",
                     thisname, (double )((float )10000 / food_ptr->nutrient[4]) / 28.349523,
                     (double )abacus[max], Unit[num]);
              }
            }
          }
        }
      }
#line 316
      if (opt == 5) {
        {
#line 316
        tmp___5 = test_for_negative_zero(& food_ptr->nutrient[Minut]);
        }
#line 316
        if (! tmp___5) {
          {
#line 316
          printf((char const   */* __restrict  */)"%-52s %7.1f %-3s    %7.1f %-3s\n",
                 thisname, (double )((food_ptr->grams / (float )100) * food_ptr->nutrient[num]),
                 Unit[num], (double )((food_ptr->grams / (float )100) * food_ptr->nutrient[Minut]),
                 Unit[Minut]);
          }
        }
      }
#line 317
      if (opt == 5) {
        {
#line 317
        tmp___6 = test_for_negative_zero(& food_ptr->nutrient[Minut]);
        }
#line 317
        if (tmp___6) {
          {
#line 317
          printf((char const   */* __restrict  */)"%-52s %7.1f %-3s        (nd)\n",
                 thisname, (double )((food_ptr->grams / (float )100) * food_ptr->nutrient[num]),
                 Unit[num]);
          }
        }
      }
#line 318
      if (opt == 4) {
#line 318
        if (options.screen == 0) {
#line 318
          if (options.grams) {
            {
#line 318
            printf((char const   */* __restrict  */)"%-54s        %7.1f g %5.0f%%\n",
                   thisname, (double )food_ptr->grams, (double )abacus[max]);
            }
          }
        }
      }
#line 319
      if (opt == 4) {
#line 319
        if (options.screen == 0) {
#line 319
          if (! options.grams) {
            {
#line 319
            printf((char const   */* __restrict  */)"%-54s        %6.1f oz %5.0f%%\n",
                   thisname, (double )food_ptr->grams / 28.349523, (double )abacus[max]);
            }
          }
        }
      }
#line 320
      if (opt == 4) {
#line 320
        if (options.screen > 0) {
#line 320
          if (options.screen < 4) {
#line 320
            if (options.grams) {
              {
#line 320
              printf((char const   */* __restrict  */)"%-54s %7.1f g %9.1f %-3s\n",
                     thisname, (double )food_ptr->grams, (double )abacus[max], Unit[num]);
              }
            }
          }
        }
      }
#line 321
      if (opt == 4) {
#line 321
        if (options.screen > 0) {
#line 321
          if (options.screen < 4) {
#line 321
            if (! options.grams) {
              {
#line 321
              printf((char const   */* __restrict  */)"%-54s %6.1f oz %9.1f %-3s\n",
                     thisname, (double )food_ptr->grams / 28.349523, (double )abacus[max],
                     Unit[num]);
              }
            }
          }
        }
      }
#line 322
      if (opt == 4) {
#line 322
        if (options.screen > 0) {
#line 322
          if (options.screen > 3) {
#line 322
            if (options.grams) {
              {
#line 322
              printf((char const   */* __restrict  */)"%-54s %7.1f g %9.2f %-3s\n",
                     thisname, (double )food_ptr->grams, (double )abacus[max], Unit[num]);
              }
            }
          }
        }
      }
#line 323
      if (opt == 4) {
#line 323
        if (options.screen > 0) {
#line 323
          if (options.screen > 3) {
#line 323
            if (! options.grams) {
              {
#line 323
              printf((char const   */* __restrict  */)"%-54s %6.1f oz %9.2f %-3s\n",
                     thisname, (double )food_ptr->grams / 28.349523, (double )abacus[max],
                     Unit[num]);
              }
            }
          }
        }
      }
      {
#line 324
      abacus[max] = (float )0;
#line 325
      max = max_array(abacus);
#line 265
      count ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
#line 327
    displayed += 20;
#line 328
    if (max < FoodCount) {
#line 328
      if (abacus[max] != (float )0) {
        {
#line 330
        printf((char const   */* __restrict  */)"\nPress \"m\" for more (or just <enter> to quit)...  ");
#line 331
        junk = get_char();
        }
      }
    }
#line 333
    if (abacus[max] == (float )0) {
#line 333
      if (max < FoodCount) {
        {
#line 335
        max = FoodCount + 1;
#line 336
        spacer(count);
#line 337
        printf((char const   */* __restrict  */)"\nPress <enter> to quit...  ");
#line 338
        junk = get_char();
        }
#line 339
        goto while_break___9;
      }
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 342
  return;
}
}
#line 344 "/home/wheatley/newnew/temp/nut-nutrition-15.5/ranking.c"
int max_array(float *abacus ) 
{ 
  int count ;
  int i ;

  {
#line 346
  i = 0;
#line 347
  count = 1;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! (count < FoodCount)) {
#line 347
      goto while_break;
    }
#line 347
    if (*(abacus + count) > *(abacus + i)) {
#line 347
      i = count;
    }
#line 347
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  return (i);
}
}
#line 351 "/home/wheatley/newnew/temp/nut-nutrition-15.5/ranking.c"
void nut_list(void) 
{ 
  int count ;
  int intdiv ;
  int tmp ;
  int tmp___0 ;

  {
#line 354
  if (*(ScreenMap[options.screen]) % 2 == 0) {
#line 354
    tmp = 0;
  } else {
#line 354
    tmp = 1;
  }
#line 354
  intdiv = *(ScreenMap[options.screen]) / 2 + tmp;
#line 355
  count = 0;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (*(ScreenMap[options.screen]) % 2 == 0) {
#line 355
      tmp___0 = 1;
    } else {
#line 355
      tmp___0 = 0;
    }
#line 355
    if (! (count <= *(ScreenMap[options.screen]) / 2 - tmp___0)) {
#line 355
      goto while_break;
    }
#line 357
    if (options.screen == 0) {
      {
#line 359
      printf((char const   */* __restrict  */)"     %2d. %-14s %7.1f %-3s  ", count + 1,
             Nutrient[*(ScreenMap[options.screen] + (count + 1))], (double )DV[*(ScreenMap[options.screen] + (count + 1))],
             Unit[*(ScreenMap[options.screen] + (count + 1))]);
      }
#line 360
      if (count + intdiv < *(ScreenMap[options.screen])) {
        {
#line 360
        printf((char const   */* __restrict  */)"    %2d. %-14s %7.1f %-3s    \n",
               (count + 1) + intdiv, Nutrient[*(ScreenMap[options.screen] + ((count + 1) + intdiv))],
               (double )DV[*(ScreenMap[options.screen] + ((count + 1) + intdiv))],
               Unit[*(ScreenMap[options.screen] + ((count + 1) + intdiv))]);
        }
      }
    } else {
      {
#line 364
      printf((char const   */* __restrict  */)"             %2d. %-14s %7s ", count + 1,
             Nutrient[*(ScreenMap[options.screen] + (count + 1))], " ");
      }
#line 365
      if (count + intdiv < *(ScreenMap[options.screen])) {
        {
#line 365
        printf((char const   */* __restrict  */)"          %2d. %-14s\n", (count + 1) + intdiv,
               Nutrient[*(ScreenMap[options.screen] + ((count + 1) + intdiv))]);
        }
      }
    }
#line 367
    if (count + intdiv >= *(ScreenMap[options.screen])) {
      {
#line 367
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 355
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 369
  spacer(count);
  }
#line 370
  return;
}
}
#line 372 "/home/wheatley/newnew/temp/nut-nutrition-15.5/ranking.c"
void fdgrp_list(void) 
{ 
  int count ;
  int intdiv ;
  int tmp ;
  int tmp___0 ;

  {
#line 375
  if (MaxFdGrp % 2 == 0) {
#line 375
    tmp = 0;
  } else {
#line 375
    tmp = 1;
  }
  {
#line 375
  intdiv = MaxFdGrp / 2 + tmp;
#line 376
  printf((char const   */* __restrict  */)"\n\n");
#line 377
  count = 0;
  }
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (MaxFdGrp % 2 == 0) {
#line 377
      tmp___0 = 1;
    } else {
#line 377
      tmp___0 = 0;
    }
#line 377
    if (! (count <= MaxFdGrp / 2 - tmp___0)) {
#line 377
      goto while_break;
    }
    {
#line 379
    printf((char const   */* __restrict  */)"%2d. %-33s %1s ", count + 1, FdGrp[FdGrpMap[count]],
           " ");
    }
#line 380
    if (count + intdiv < MaxFdGrp) {
      {
#line 380
      printf((char const   */* __restrict  */)"%2d. %-33s\n", (count + 1) + intdiv,
             FdGrp[FdGrpMap[count + intdiv]]);
      }
    }
#line 381
    if (count + intdiv >= MaxFdGrp) {
      {
#line 381
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 377
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 383
  spacer(count + 2);
  }
#line 384
  return;
}
}
#line 86 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.h"
struct opt options  ;
#line 90
void personal_cal(void) ;
#line 91
void efa_options(void) ;
#line 92
void efa_method(void) ;
#line 93
void protein_percent(void) ;
#line 94
void carb_percent(void) ;
#line 95
void satfat_percent(void) ;
#line 96
void protein_absolute(void) ;
#line 97
void carb_absolute(void) ;
#line 98
void fiber_absolute(void) ;
#line 101
void screen(void) ;
#line 102
void screen_previous(void) ;
#line 103
void get_cals(float *cals ) ;
#line 104
void new_nut_levels(void) ;
#line 105
void restore_defaults(int removelock ) ;
#line 106
void efa_dynamics(void) ;
#line 107
void weight_log(void) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 32 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
static float DefaultTarget  =    (float )50;
#line 32 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
static float DefaultEPADHA  =    (float )2.2;
#line 34 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void initialize_options(void) 
{ 
  int c ;

  {
#line 37
  options.delopt = -1;
#line 38
  options.defanal = 0;
#line 39
  options.defanalanal = 0;
#line 40
  options.defanalrec = 0;
#line 41
  options.screen = 0;
#line 42
  options.custom = 0;
#line 43
  options.pcprotein = (float )0;
#line 44
  options.pccarb = (float )0;
#line 45
  options.pcsatfat = (float )0;
#line 46
  options.protcalpergm = (float )4;
#line 47
  options.carbcalpergm = (float )4;
#line 48
  options.fatcalpergm = (float )9.2307692;
#line 49
  options.fattyacidfactor = (float )0.956;
#line 50
  options.next_recipe = 99000;
#line 51
  c = 0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (c < 159)) {
#line 51
      goto while_break;
    }
#line 53
    options.locknuts[c] = 0;
#line 54
    options.abnuts[c] = (float )0;
#line 51
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  if (mealdb_mealsperday > 0) {
#line 56
    if (mealdb_mealsperday < 20) {
#line 56
      options.mealsperday = mealdb_mealsperday;
    } else {
#line 57
      options.mealsperday = 3;
    }
  } else {
#line 57
    options.mealsperday = 3;
  }
#line 58
  options.grams = (char)0;
#line 59
  options.autocal = (char)0;
#line 60
  options.temp_meal_root = & meal_root;
#line 61
  return;
}
}
#line 63 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void personal_cal(void) 
{ 
  float buf ;
  int choice ;

  {
  {
#line 65
  buf = (float )0;
#line 67
  options.abnuts[111] = (float )0;
#line 68
  header((char *)"NUT:  Set Personal Calorie Level");
  }
#line 69
  if ((int )options.autocal == 0) {
    {
#line 69
    printf((char const   */* __restrict  */)"\n  Calorie level is set to %0.0f.\n\n",
           (double )DV[4]);
    }
  } else {
    {
#line 70
    printf((char const   */* __restrict  */)"\n  Calorie level is set to %0.0f.  Option is #%d.\n\n",
           (double )DV[4], (int )options.autocal + 2);
    }
  }
  {
#line 71
  printf((char const   */* __restrict  */)"\n  1.  I will type a new calorie level.\n");
#line 72
  printf((char const   */* __restrict  */)"\n  2.  I want to return to the program default of 2000.\n");
#line 73
  printf((char const   */* __restrict  */)"\n  3.  I want NUT to automatically use the average calories from all my meals.\n");
#line 74
  printf((char const   */* __restrict  */)"\n  4.  When I make a daily \"Weight Log Regression\" entry, make a small calorie\n");
#line 75
  printf((char const   */* __restrict  */)"      adjustment to promote loss of fat mass without loss of lean mass.\n");
#line 76
  printf((char const   */* __restrict  */)"\n  5.  When I make a daily \"Weight Log Regression\" entry, make a small calorie\n");
#line 77
  printf((char const   */* __restrict  */)"      adjustment to promote gain of lean mass without gain of fat mass.\n");
#line 78
  spacer(15);
#line 79
  printf((char const   */* __restrict  */)"\nEnter your choice (just <enter> to retain current setting):  ");
#line 80
  choice = get_int();
  }
  {
#line 83
  if (choice == 1) {
#line 83
    goto case_1;
  }
#line 98
  if (choice == 3) {
#line 98
    goto case_3;
  }
#line 107
  if (choice == 4) {
#line 107
    goto case_4;
  }
#line 115
  if (choice == 5) {
#line 115
    goto case_5;
  }
#line 123
  if (choice == 2) {
#line 123
    goto case_2;
  }
#line 130
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 84
  header((char *)"NUT:  Set Personal Calorie Level");
#line 85
  spacer(0);
#line 86
  printf((char const   */* __restrict  */)"\nCalorie level is set to %0.0f.  Type new level (just <enter> for default):  ",
         (double )DV[4]);
#line 87
  get_cals(& buf);
  }
#line 88
  if (buf <= (float )0) {
#line 88
    options.locknuts[4] = 0;
  } else {
#line 91
    options.locknuts[4] = 1;
#line 92
    options.abnuts[4] = buf;
  }
#line 94
  if (! options.locknuts[1]) {
#line 94
    options.abnuts[1] = (float )0;
  }
#line 95
  options.abnuts[111] = (float )0;
#line 96
  options.autocal = (char)0;
#line 97
  goto switch_break;
  case_3: /* CIL Label */ 
#line 99
  options.locknuts[4] = 0;
#line 100
  options.abnuts[4] = (float )0;
#line 101
  options.locknuts[1] = 0;
#line 102
  options.abnuts[1] = (float )0;
#line 103
  options.locknuts[111] = 0;
#line 104
  options.abnuts[111] = (float )0;
#line 105
  options.autocal = (char)1;
#line 106
  goto switch_break;
  case_4: /* CIL Label */ 
#line 108
  options.locknuts[4] = 1;
#line 109
  options.locknuts[1] = 0;
#line 110
  options.abnuts[1] = (float )0;
#line 111
  options.locknuts[111] = 0;
#line 112
  options.abnuts[111] = (float )0;
#line 113
  options.autocal = (char)2;
#line 114
  goto switch_break;
  case_5: /* CIL Label */ 
#line 116
  options.locknuts[4] = 1;
#line 117
  options.locknuts[1] = 0;
#line 118
  options.abnuts[1] = (float )0;
#line 119
  options.locknuts[111] = 0;
#line 120
  options.abnuts[111] = (float )0;
#line 121
  options.autocal = (char)3;
#line 122
  goto switch_break;
  case_2: /* CIL Label */ 
#line 124
  options.locknuts[4] = 0;
#line 125
  options.abnuts[4] = (float )0;
#line 126
  if (! options.locknuts[1]) {
#line 126
    options.abnuts[1] = (float )0;
  }
#line 127
  options.abnuts[111] = (float )0;
#line 128
  options.autocal = (char)0;
#line 129
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 131
  buf = options.abnuts[4];
#line 132
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 134
  auto_cal(& buf, 0);
#line 135
  header((char *)"NUT:  Set Personal Calorie Level");
#line 136
  new_nut_levels();
  }
#line 137
  return;
}
}
#line 139 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void efa_options(void) 
{ 
  char buf[128] ;
  int menu_choice ;
  float tempfloat ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  double tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  float tmp___8 ;
  double tmp___9 ;

  {
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 147
    header((char *)"NUT:  Essential Fatty Acid Options");
#line 148
    printf((char const   */* __restrict  */)"\n\n");
    }
#line 149
    if (options.locknuts[112] != 1) {
      {
#line 149
      printf((char const   */* __restrict  */)"           1.  Accept current reference values as absolute amounts.\n\n");
      }
    } else {
      {
#line 150
      printf((char const   */* __restrict  */)"           1.  Allow reference values to change with analysis resets.\n\n");
      }
    }
#line 151
    if (options.locknuts[112] != 1) {
#line 151
      if (options.n6hufa == (float )0) {
#line 151
        tmp = (float )100 - DefaultTarget;
      } else {
#line 151
        tmp = (float )100 - options.n6hufa;
      }
#line 151
      if (options.n6hufa == (float )0) {
#line 151
        tmp___0 = DefaultTarget;
      } else {
#line 151
        tmp___0 = options.n6hufa;
      }
      {
#line 151
      printf((char const   */* __restrict  */)"           2.  Change target for Omega-6/3 Balance (currently %2.0f/%2.0f).\n\n",
             (double )tmp___0, (double )tmp);
      }
    }
#line 152
    if (options.locknuts[112] != 1) {
#line 152
      if (options.epadhamax == (float )0) {
#line 152
        tmp___1 = DefaultEPADHA;
      } else {
#line 152
        tmp___1 = options.epadhamax;
      }
      {
#line 152
      printf((char const   */* __restrict  */)"           3.  Change EPA+DHA maximum grams (currently %3.1f grams).\n\n",
             (double )tmp___1);
      }
    }
#line 153
    if (options.locknuts[112] != 1) {
      {
#line 153
      printf((char const   */* __restrict  */)"\n\n\n      If you change options #2 or #3, you will have to reset the analysis\n");
      }
    }
#line 154
    if (options.locknuts[112] != 1) {
      {
#line 154
      printf((char const   */* __restrict  */)"      screen with a \"c\", \"m\", or \"o\" to have the new settings take effect.\n");
      }
    }
#line 155
    if (options.locknuts[112] != 1) {
      {
#line 155
      spacer(13);
      }
    } else {
      {
#line 156
      spacer(4);
      }
    }
    {
#line 157
    printf((char const   */* __restrict  */)"\nEnter your choice (just <enter> to quit):  ");
#line 158
    menu_choice = get_char();
    }
    {
#line 162
    if (menu_choice == 49) {
#line 162
      goto case_49;
    }
#line 166
    if (menu_choice == 50) {
#line 166
      goto case_50;
    }
#line 183
    if (menu_choice == 51) {
#line 183
      goto case_51;
    }
#line 200
    goto switch_default;
    case_49: /* CIL Label */ 
    {
#line 162
    efa_method();
#line 163
    write_OPTIONS();
    }
#line 164
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 167
    header((char *)"NUT:  Essential Fatty Acid Options");
#line 168
    printf((char const   */* __restrict  */)"\n\n");
    }
#line 169
    if (options.locknuts[112] != 1) {
      {
#line 169
      printf((char const   */* __restrict  */)"           1.  Accept current reference values as absolute amounts.\n\n");
      }
    } else {
      {
#line 170
      printf((char const   */* __restrict  */)"           1.  Allow reference values to change with analysis resets.\n\n");
      }
    }
#line 171
    if (options.locknuts[112] != 1) {
#line 171
      if (options.n6hufa == (float )0) {
#line 171
        tmp___2 = (float )100 - DefaultTarget;
      } else {
#line 171
        tmp___2 = (float )100 - options.n6hufa;
      }
#line 171
      if (options.n6hufa == (float )0) {
#line 171
        tmp___3 = DefaultTarget;
      } else {
#line 171
        tmp___3 = options.n6hufa;
      }
      {
#line 171
      printf((char const   */* __restrict  */)"           2.  Change target for Omega-6/3 Balance (currently %2.0f/%2.0f).\n\n",
             (double )tmp___3, (double )tmp___2);
      }
    }
#line 172
    if (options.locknuts[112] != 1) {
#line 172
      if (options.epadhamax == (float )0) {
#line 172
        tmp___4 = DefaultEPADHA;
      } else {
#line 172
        tmp___4 = options.epadhamax;
      }
      {
#line 172
      printf((char const   */* __restrict  */)"           3.  Change EPA+DHA maximum grams (currently %3.1f grams).\n\n",
             (double )tmp___4);
      }
    }
#line 173
    if (options.locknuts[112] != 1) {
      {
#line 173
      spacer(8);
      }
    } else {
      {
#line 174
      spacer(4);
      }
    }
    {
#line 175
    printf((char const   */* __restrict  */)"\nEnter new Omega-6 percentage (15-90, 90 = off):  ");
#line 176
    get_string(buf, 127);
#line 177
    tmp___5 = atof((char const   *)(buf));
#line 177
    tempfloat = (float )tmp___5;
    }
#line 178
    if (tempfloat < (float )15) {
#line 178
      goto switch_break;
    } else
#line 178
    if (tempfloat > (float )90) {
#line 178
      goto switch_break;
    } else {
#line 179
      options.n6hufa = tempfloat;
    }
    {
#line 180
    write_OPTIONS();
    }
#line 181
    goto switch_break;
    case_51: /* CIL Label */ 
    {
#line 184
    header((char *)"NUT:  Essential Fatty Acid Options");
#line 185
    printf((char const   */* __restrict  */)"\n\n");
    }
#line 186
    if (options.locknuts[112] != 1) {
      {
#line 186
      printf((char const   */* __restrict  */)"           1.  Accept current reference values as absolute amounts.\n\n");
      }
    } else {
      {
#line 187
      printf((char const   */* __restrict  */)"           1.  Allow reference values to change with analysis resets.\n\n");
      }
    }
#line 188
    if (options.locknuts[112] != 1) {
#line 188
      if (options.n6hufa == (float )0) {
#line 188
        tmp___6 = (float )100 - DefaultTarget;
      } else {
#line 188
        tmp___6 = (float )100 - options.n6hufa;
      }
#line 188
      if (options.n6hufa == (float )0) {
#line 188
        tmp___7 = DefaultTarget;
      } else {
#line 188
        tmp___7 = options.n6hufa;
      }
      {
#line 188
      printf((char const   */* __restrict  */)"           2.  Change target for Omega-6/3 Balance (currently %2.0f/%2.0f).\n\n",
             (double )tmp___7, (double )tmp___6);
      }
    }
#line 189
    if (options.locknuts[112] != 1) {
#line 189
      if (options.epadhamax == (float )0) {
#line 189
        tmp___8 = DefaultEPADHA;
      } else {
#line 189
        tmp___8 = options.epadhamax;
      }
      {
#line 189
      printf((char const   */* __restrict  */)"           3.  Change EPA+DHA maximum grams (currently %3.1f grams).\n\n",
             (double )tmp___8);
      }
    }
#line 190
    if (options.locknuts[112] != 1) {
      {
#line 190
      spacer(8);
      }
    } else {
      {
#line 191
      spacer(4);
      }
    }
    {
#line 192
    printf((char const   */* __restrict  */)"\nEnter new EPA+DHA maximum grams:  ");
#line 193
    get_string(buf, 127);
#line 194
    tmp___9 = atof((char const   *)(buf));
#line 194
    tempfloat = (float )tmp___9;
    }
#line 195
    if (tempfloat <= (float )0) {
#line 195
      goto switch_break;
    } else {
#line 196
      options.epadhamax = tempfloat;
    }
    {
#line 197
    write_OPTIONS();
    }
#line 198
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 200
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 205 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void efa_method(void) 
{ 


  {
#line 207
  if (options.locknuts[112] == 1) {
#line 209
    if (! options.locknuts[1]) {
#line 209
      options.abnuts[1] = (float )0;
    }
#line 210
    options.abnuts[111] = (float )0;
#line 211
    options.abnuts[112] = (float )0;
#line 211
    options.locknuts[112] = 0;
#line 212
    options.abnuts[152] = (float )0;
#line 212
    options.locknuts[152] = 0;
#line 213
    options.abnuts[147] = (float )0;
#line 213
    options.locknuts[147] = 0;
#line 214
    options.abnuts[148] = (float )0;
#line 214
    options.locknuts[148] = 0;
#line 215
    options.abnuts[155] = (float )0;
#line 215
    options.locknuts[155] = 0;
#line 216
    options.abnuts[149] = (float )0;
#line 216
    options.locknuts[149] = 0;
#line 217
    options.abnuts[150] = (float )0;
#line 217
    options.locknuts[150] = 0;
#line 218
    options.abnuts[151] = (float )0;
#line 218
    options.locknuts[151] = 0;
#line 219
    return;
  }
  {
#line 222
  options.abnuts[112] = DV[112];
#line 222
  options.locknuts[112] = 1;
#line 223
  options.abnuts[152] = DV[152];
#line 223
  options.locknuts[152] = 1;
#line 224
  options.abnuts[147] = DV[147];
#line 224
  options.locknuts[147] = 1;
#line 225
  options.abnuts[148] = DV[148];
#line 225
  options.locknuts[148] = 1;
#line 226
  options.abnuts[155] = DV[155];
#line 226
  options.locknuts[155] = 1;
#line 227
  options.abnuts[149] = DV[149];
#line 227
  options.locknuts[149] = 1;
#line 228
  options.abnuts[150] = DV[150];
#line 228
  options.locknuts[150] = 1;
#line 229
  options.abnuts[151] = DV[151];
#line 229
  options.locknuts[151] = 1;
#line 230
  auto_cal(& DV[4], 0);
  }
#line 231
  return;
}
}
#line 233 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void protein_percent(void) 
{ 
  char buf[128] ;
  double tmp ;

  {
  {
#line 236
  header((char *)"NUT:  Protein Percentage");
#line 237
  spacer(0);
#line 238
  printf((char const   */* __restrict  */)"\nEnter percentage of protein (just <enter> for default):  ");
#line 239
  get_string(buf, 127);
#line 240
  tmp = atof((char const   *)(buf));
#line 240
  options.pcprotein = (float )tmp;
  }
#line 241
  if (options.pcprotein <= (float )0) {
#line 241
    goto _L;
  } else
#line 241
  if (options.pcprotein + options.pccarb > (float )90) {
    _L: /* CIL Label */ 
#line 243
    options.pcprotein = (float )0;
#line 244
    if (options.abnuts[0] == (float )0) {
#line 244
      options.locknuts[0] = 0;
    }
  }
#line 246
  if (options.pcprotein > (float )0) {
#line 248
    options.abnuts[0] = (float )0;
#line 249
    options.locknuts[0] = 1;
  }
#line 251
  if (! options.locknuts[1]) {
#line 251
    options.abnuts[1] = (float )0;
  }
  {
#line 252
  options.abnuts[111] = (float )0;
#line 253
  options.locknuts[111] = 0;
#line 254
  auto_cal(& DV[4], 0);
#line 255
  header((char *)"NUT:  Protein Percentage");
#line 256
  new_nut_levels();
  }
#line 257
  return;
}
}
#line 259 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void carb_percent(void) 
{ 
  char buf[128] ;
  double tmp ;

  {
  {
#line 262
  header((char *)"NUT:  Carbohydrate Percentage");
#line 263
  spacer(0);
#line 264
  printf((char const   */* __restrict  */)"\nEnter percentage of carbohydrate (just <enter> for default):  ");
#line 265
  get_string(buf, 127);
#line 266
  tmp = atof((char const   *)(buf));
#line 266
  options.pccarb = (float )tmp;
#line 267
  options.locknuts[2] = 1;
  }
#line 268
  if (options.pccarb <= (float )0) {
#line 270
    options.pccarb = (float )0;
#line 271
    options.locknuts[2] = 0;
  } else
#line 268
  if (options.pcprotein + options.pccarb > (float )90) {
#line 270
    options.pccarb = (float )0;
#line 271
    options.locknuts[2] = 0;
  }
#line 273
  if (options.pccarb > (float )0) {
#line 273
    options.abnuts[2] = (float )0;
  }
#line 274
  if (! options.locknuts[1]) {
#line 274
    options.abnuts[1] = (float )0;
  }
  {
#line 275
  options.abnuts[111] = (float )0;
#line 276
  options.locknuts[111] = 0;
#line 277
  auto_cal(& DV[4], 0);
#line 278
  header((char *)"NUT:  Carbohydrate Percentage");
#line 279
  new_nut_levels();
  }
#line 280
  return;
}
}
#line 282 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void satfat_percent(void) 
{ 
  char buf[128] ;
  double tmp ;

  {
  {
#line 285
  header((char *)"NUT:  Saturated Fat Percentage");
#line 286
  spacer(0);
#line 287
  printf((char const   */* __restrict  */)"\nEnter percentage of saturated fat (just <enter> for default):  ");
#line 288
  get_string(buf, 127);
#line 289
  tmp = atof((char const   *)(buf));
#line 289
  options.pcsatfat = (float )tmp;
#line 290
  options.locknuts[84] = 1;
  }
#line 291
  if (options.pcsatfat <= (float )0) {
#line 293
    options.pcsatfat = (float )0;
#line 294
    options.locknuts[84] = 0;
#line 295
    options.abnuts[84] = (float )0;
  } else
#line 291
  if (options.pcsatfat > (float )90) {
#line 293
    options.pcsatfat = (float )0;
#line 294
    options.locknuts[84] = 0;
#line 295
    options.abnuts[84] = (float )0;
  }
#line 297
  if (! options.locknuts[1]) {
#line 297
    options.abnuts[1] = (float )0;
  }
  {
#line 298
  options.abnuts[111] = (float )0;
#line 299
  options.locknuts[111] = 0;
#line 300
  auto_cal(& DV[4], 0);
#line 301
  header((char *)"NUT:  Saturated Fat Percentage");
#line 302
  new_nut_levels();
  }
#line 303
  return;
}
}
#line 305 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void protein_absolute(void) 
{ 
  char buf[128] ;
  double tmp ;

  {
  {
#line 308
  header((char *)"NUT:  Protein Absolute Amount");
#line 309
  spacer(0);
#line 310
  printf((char const   */* __restrict  */)"\nEnter grams of protein (just <enter> for default):  ");
#line 311
  get_string(buf, 127);
#line 312
  tmp = atof((char const   *)(buf));
#line 312
  options.abnuts[0] = (float )tmp;
  }
#line 313
  if (options.abnuts[0] <= (float )0) {
#line 315
    options.abnuts[0] = (float )0;
#line 316
    if (options.pcprotein == (float )0) {
#line 316
      options.locknuts[0] = 0;
    }
  }
#line 318
  if (options.abnuts[0] > (float )0) {
#line 320
    options.pcprotein = (float )0;
#line 321
    options.locknuts[0] = 1;
  }
#line 323
  if (! options.locknuts[1]) {
#line 323
    options.abnuts[1] = (float )0;
  }
  {
#line 324
  options.abnuts[111] = (float )0;
#line 325
  options.locknuts[111] = 0;
#line 326
  auto_cal(& DV[4], 0);
#line 327
  header((char *)"NUT:  Protein Absolute Amount");
#line 328
  new_nut_levels();
  }
#line 329
  return;
}
}
#line 331 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void carb_absolute(void) 
{ 
  char buf[128] ;
  double tmp ;

  {
  {
#line 334
  header((char *)"NUT:  Carbohydrate Absolute Amount");
#line 335
  spacer(1);
#line 336
  printf((char const   */* __restrict  */)"\nEnter grams of carbohydrate, or a negative value to set grams of non-fiber carb");
#line 337
  printf((char const   */* __restrict  */)"\nindependent of fiber (just <enter> for default):  ");
#line 338
  get_string(buf, 127);
#line 339
  tmp = atof((char const   *)(buf));
#line 339
  options.abnuts[2] = (float )tmp;
#line 340
  options.locknuts[2] = 0;
  }
#line 341
  if (options.abnuts[2] != (float )0) {
#line 343
    options.pccarb = (float )0;
#line 344
    options.locknuts[2] = 1;
  }
#line 346
  if (! options.locknuts[1]) {
#line 346
    options.abnuts[1] = (float )0;
  }
  {
#line 347
  options.abnuts[111] = (float )0;
#line 348
  options.locknuts[111] = 0;
#line 349
  auto_cal(& DV[4], 0);
#line 350
  header((char *)"NUT:  Carbohydrate Absolute Amount");
#line 351
  new_nut_levels();
  }
#line 352
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void fiber_absolute(void) 
{ 
  char buf[128] ;
  double tmp ;

  {
  {
#line 357
  header((char *)"NUT:  Fiber Absolute Amount");
#line 358
  spacer(0);
#line 359
  printf((char const   */* __restrict  */)"\nEnter grams of fiber (just <enter> for default):  ");
#line 360
  get_string(buf, 127);
#line 361
  tmp = atof((char const   *)(buf));
#line 361
  options.abnuts[19] = (float )tmp;
#line 362
  options.locknuts[19] = 1;
  }
#line 363
  if (options.abnuts[19] < (float )1) {
#line 365
    options.abnuts[19] = (float )0;
#line 366
    options.locknuts[19] = 0;
  } else
#line 363
  if (options.abnuts[19] > (float )999) {
#line 365
    options.abnuts[19] = (float )0;
#line 366
    options.locknuts[19] = 0;
  }
  {
#line 368
  auto_cal(& DV[4], 0);
#line 369
  header((char *)"NUT:  Fiber Absolute Amount");
#line 370
  new_nut_levels();
  }
#line 371
  return;
}
}
#line 373 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void screen(void) 
{ 


  {
  {
#line 375
  (options.screen) ++;
#line 376
  options.screen %= MaxScreen;
#line 377
  write_OPTIONS();
  }
#line 378
  return;
}
}
#line 380 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void screen_previous(void) 
{ 


  {
#line 382
  (options.screen) --;
#line 382
  if (options.screen < 0) {
#line 383
    options.screen = MaxScreen - 1;
  }
  {
#line 385
  write_OPTIONS();
  }
#line 386
  return;
}
}
#line 388 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void get_cals(float *cals ) 
{ 
  char buff[128] ;
  double tmp ;

  {
  {
#line 391
  fgets((char */* __restrict  */)(buff), 128, (FILE */* __restrict  */)stdin);
#line 392
  tmp = atof((char const   *)(buff));
#line 392
  *cals = (float )tmp;
  }
#line 393
  return;
}
}
#line 395 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void auto_cal(float *bufptr , int analflag ) 
{ 
  float buf ;
  float temp ;
  int i ;

  {
#line 397
  buf = *bufptr;
#line 397
  temp = (float )0;
#line 399
  if ((int )options.autocal == 1) {
    {
#line 399
    buf = average_cals();
    }
  }
#line 400
  if (analflag) {
#line 402
    if (food_work.nutrient[143] > (float )0) {
#line 402
      if (food_work.nutrient[0] > (float )0) {
#line 402
        options.protcalpergm = food_work.nutrient[143] / food_work.nutrient[0];
      }
    }
#line 403
    if (food_work.nutrient[145] > (float )0) {
#line 403
      if (food_work.nutrient[2] > (float )0) {
#line 403
        options.carbcalpergm = food_work.nutrient[145] / food_work.nutrient[2];
      }
    }
#line 404
    if (food_work.nutrient[144] > (float )0) {
#line 404
      if (food_work.nutrient[1] > (float )0) {
#line 404
        options.fatcalpergm = food_work.nutrient[144] / food_work.nutrient[1];
      }
    }
#line 405
    if (food_work.nutrient[1] > (float )0) {
#line 405
      if ((food_work.nutrient[84] + food_work.nutrient[111]) + food_work.nutrient[112] > (float )0) {
#line 405
        options.fattyacidfactor = ((food_work.nutrient[84] + food_work.nutrient[111]) + food_work.nutrient[112]) / food_work.nutrient[1];
      }
    }
  }
#line 407
  i = 1;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! (i <= *(ScreenMap[0]))) {
#line 407
      goto while_break;
    }
#line 407
    DV[*(ScreenMap[0] + i)] = DVBase[*(ScreenMap[0] + i)];
#line 407
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 408
  if (buf <= (float )0) {
#line 410
    buf = (float )2000;
#line 411
    if (! options.locknuts[4]) {
#line 411
      options.abnuts[4] = DVBase[4];
    }
#line 412
    if (options.locknuts[4]) {
#line 412
      buf = options.abnuts[4];
    }
  } else
#line 414
  if (buf > (float )0) {
#line 414
    if (buf <= (float )100) {
#line 414
      buf = (float )100;
    } else {
#line 414
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 415
  if (buf > (float )9999) {
#line 415
    buf = (float )9999;
  }
#line 416
  buf /= DVBase[4];
#line 417
  DV[4] = buf * DVBase[4];
#line 418
  if (buf != (float )1) {
#line 420
    DV[0] = ((buf * DVBase[0]) * (float )4) / options.protcalpergm;
#line 421
    DV[1] = (float )(((double )(buf * DVBase[1]) * 9.2307692) / (double )options.fatcalpergm);
#line 422
    DV[2] = ((buf * DVBase[2]) * (float )4) / options.carbcalpergm;
  }
#line 424
  if (buf == (float )1) {
#line 426
    DV[0] = DVBase[0];
#line 427
    DV[1] = DVBase[1];
#line 428
    DV[2] = DVBase[2];
#line 429
    options.protcalpergm = (float )4;
#line 430
    options.carbcalpergm = (float )4;
#line 431
    options.fatcalpergm = (float )9.2307692;
  }
#line 433
  DV[19] = buf * DVBase[19];
#line 434
  DV[84] = buf * DVBase[84];
#line 435
  DV[112] = buf * DVBase[112];
#line 436
  DV[111] = (options.fattyacidfactor * DV[1] - DV[84]) - DV[112];
#line 437
  DV[152] = buf * DVBase[152];
#line 438
  DV[147] = buf * DVBase[147];
#line 439
  DV[148] = buf * DVBase[148];
#line 440
  DV[155] = buf * DVBase[155];
#line 441
  DV[149] = buf * DVBase[149];
#line 442
  DV[150] = buf * DVBase[150];
#line 443
  DV[151] = buf * DVBase[151];
#line 444
  if (options.locknuts[4]) {
#line 444
    DV[4] = options.abnuts[4];
  }
#line 445
  if (! options.locknuts[4]) {
#line 445
    options.abnuts[4] = DV[4];
  }
#line 446
  if (options.abnuts[19] > (float )0) {
#line 446
    DV[19] = options.abnuts[19];
  }
#line 447
  if (options.pcprotein > (float )0) {
#line 447
    DV[0] = ((options.pcprotein / (float )100) * DV[4]) / options.protcalpergm;
  }
#line 448
  if (options.abnuts[0] > (float )0) {
#line 448
    DV[0] = options.abnuts[0];
  }
#line 449
  if (options.pccarb > (float )0) {
#line 449
    DV[2] = ((options.pccarb / (float )100) * DV[4]) / options.carbcalpergm;
  }
#line 450
  if (options.abnuts[2] > (float )0) {
#line 450
    DV[2] = options.abnuts[2];
  }
#line 451
  if (options.abnuts[2] < (float )0) {
#line 451
    DV[2] = DV[19] + (float )-1 * options.abnuts[2];
  }
#line 452
  if (DV[0] != DVBase[0]) {
#line 454
    temp = (float )1 - (DV[0] * options.protcalpergm + DV[2] * options.carbcalpergm) / DV[4];
#line 455
    DV[1] = (temp * DV[4]) / options.fatcalpergm;
  } else
#line 452
  if (DV[2] != DVBase[2]) {
#line 454
    temp = (float )1 - (DV[0] * options.protcalpergm + DV[2] * options.carbcalpergm) / DV[4];
#line 455
    DV[1] = (temp * DV[4]) / options.fatcalpergm;
  }
#line 457
  DV[111] = (options.fattyacidfactor * DV[1] - DV[84]) - DV[112];
#line 458
  if (analflag) {
#line 458
    if (options.abnuts[112] == (float )0) {
      {
#line 458
      efa_dynamics();
      }
    }
  }
#line 459
  if (options.abnuts[112] > (float )0) {
#line 461
    DV[111] = (DV[111] - options.abnuts[112]) + DV[112];
#line 462
    DV[112] = options.abnuts[112];
#line 463
    if (options.abnuts[152] > (float )0) {
#line 463
      DV[152] = options.abnuts[152];
    }
#line 464
    if (options.abnuts[147] > (float )0) {
#line 464
      DV[147] = options.abnuts[147];
    }
#line 465
    if (options.abnuts[148] > (float )0) {
#line 465
      DV[148] = options.abnuts[148];
    }
#line 466
    if (options.abnuts[155] > (float )0) {
#line 466
      DV[155] = options.abnuts[155];
    }
#line 467
    if (options.abnuts[149] > (float )0) {
#line 467
      DV[149] = options.abnuts[149];
    }
#line 468
    if (options.abnuts[150] > (float )0) {
#line 468
      DV[150] = options.abnuts[150];
    }
#line 469
    if (options.abnuts[151] > (float )0) {
#line 469
      DV[151] = options.abnuts[151];
    }
  }
#line 471
  if (options.abnuts[112] == (float )0) {
#line 473
    if (options.abnuts[152] != (float )0) {
#line 473
      DV[152] = options.abnuts[152];
    }
#line 474
    if (options.abnuts[147] != (float )0) {
#line 474
      DV[147] = options.abnuts[147];
    }
#line 475
    if (options.abnuts[148] != (float )0) {
#line 475
      DV[148] = options.abnuts[148];
    }
#line 476
    if (options.abnuts[155] != (float )0) {
#line 476
      DV[155] = options.abnuts[155];
    }
#line 477
    if (options.abnuts[149] != (float )0) {
#line 477
      DV[149] = options.abnuts[149];
    }
#line 478
    if (options.abnuts[150] != (float )0) {
#line 478
      DV[150] = options.abnuts[150];
    }
#line 479
    if (options.abnuts[151] != (float )0) {
#line 479
      DV[151] = options.abnuts[151];
    }
#line 480
    temp = (DV[152] + DV[155]) - DV[112];
#line 481
    if (analflag) {
#line 481
      temp += (food_work.nutrient[112] - food_work.nutrient[152]) - food_work.nutrient[155];
    }
#line 482
    DV[112] += temp;
#line 483
    DV[111] -= temp;
  }
#line 485
  if (options.pcsatfat > (float )0) {
#line 487
    temp = DV[84] + DV[111];
#line 488
    DV[84] = (float )((double )((DVBase[84] * buf) * options.pcsatfat) * .1);
#line 489
    DV[111] = temp - DV[84];
  }
#line 491
  if (options.abnuts[2] != (float )0) {
#line 491
    if (options.abnuts[0] > (float )0) {
#line 491
      if (options.abnuts[1] > (float )0) {
#line 491
        DV[1] = options.abnuts[1];
      }
    }
  }
#line 492
  if (options.abnuts[2] != (float )0) {
#line 492
    if (options.abnuts[0] > (float )0) {
#line 492
      if (options.abnuts[111] > (float )0) {
#line 492
        DV[111] = options.abnuts[111];
      }
    }
  }
#line 493
  if (options.abnuts[82] > (float )0) {
#line 493
    DV[82] = options.abnuts[82];
  }
#line 494
  if (options.abnuts[31] > (float )0) {
#line 494
    DV[31] = options.abnuts[31];
  }
#line 495
  if (options.abnuts[48] > (float )0) {
#line 495
    DV[48] = options.abnuts[48];
  }
#line 496
  if (options.abnuts[49] > (float )0) {
#line 496
    DV[49] = options.abnuts[49];
  }
#line 497
  if (options.abnuts[50] > (float )0) {
#line 497
    DV[50] = options.abnuts[50];
  }
#line 498
  if (options.abnuts[51] > (float )0) {
#line 498
    DV[51] = options.abnuts[51];
  }
#line 499
  if (options.abnuts[52] > (float )0) {
#line 499
    DV[52] = options.abnuts[52];
  }
#line 500
  if (options.abnuts[53] > (float )0) {
#line 500
    DV[53] = options.abnuts[53];
  }
#line 501
  if (options.abnuts[54] > (float )0) {
#line 501
    DV[54] = options.abnuts[54];
  }
#line 502
  if (options.abnuts[47] > (float )0) {
#line 502
    DV[47] = options.abnuts[47];
  }
#line 503
  if (options.abnuts[37] > (float )0) {
#line 503
    DV[37] = options.abnuts[37];
  }
#line 504
  if (options.abnuts[158] > (float )0) {
#line 504
    DV[158] = options.abnuts[158];
  }
#line 505
  if (options.abnuts[56] > (float )0) {
#line 505
    DV[56] = options.abnuts[56];
  }
#line 506
  if (options.abnuts[20] > (float )0) {
#line 506
    DV[20] = options.abnuts[20];
  }
#line 507
  if (options.abnuts[27] > (float )0) {
#line 507
    DV[27] = options.abnuts[27];
  }
#line 508
  if (options.abnuts[21] > (float )0) {
#line 508
    DV[21] = options.abnuts[21];
  }
#line 509
  if (options.abnuts[22] > (float )0) {
#line 509
    DV[22] = options.abnuts[22];
  }
#line 510
  if (options.abnuts[29] > (float )0) {
#line 510
    DV[29] = options.abnuts[29];
  }
#line 511
  if (options.abnuts[23] > (float )0) {
#line 511
    DV[23] = options.abnuts[23];
  }
#line 512
  if (options.abnuts[24] > (float )0) {
#line 512
    DV[24] = options.abnuts[24];
  }
#line 513
  if (options.abnuts[30] > (float )0) {
#line 513
    DV[30] = options.abnuts[30];
  }
#line 514
  if (options.abnuts[25] > (float )0) {
#line 514
    DV[25] = options.abnuts[25];
  }
#line 515
  if (options.abnuts[26] > (float )0) {
#line 515
    DV[26] = options.abnuts[26];
  }
#line 516
  if (! options.abnuts[146]) {
#line 516
    if (DV[2] - DV[19] < (float )0) {
#line 516
      DV[146] = (float )0;
    } else {
#line 516
      DV[146] = DV[2] - DV[19];
    }
  } else {
#line 517
    DV[146] = options.abnuts[146];
  }
#line 518
  if (options.pcsatfat > (float )0) {
#line 518
    options.custom = 1;
  } else
#line 518
  if (options.pcprotein > (float )0) {
#line 518
    options.custom = 1;
  } else
#line 518
  if (options.pccarb > (float )0) {
#line 518
    options.custom = 1;
  } else
#line 518
  if (options.abnuts[0] > (float )0) {
#line 518
    options.custom = 1;
  } else
#line 518
  if (options.abnuts[2] != (float )0) {
#line 518
    options.custom = 1;
  } else
#line 518
  if (options.abnuts[19] > (float )0) {
#line 518
    options.custom = 1;
  } else
#line 518
  if (options.abnuts[158]) {
#line 518
    options.custom = 1;
  } else {
#line 519
    options.custom = 0;
  }
  {
#line 520
  write_OPTIONS();
  }
#line 521
  return;
}
}
#line 523 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void auto_del(void) 
{ 
  char buf[128] ;
  int junk ;

  {
  {
#line 527
  header((char *)"NUT:  Automatic Deletion of Meals");
#line 528
  spacer(0);
#line 529
  printf((char const   */* __restrict  */)"\nDo you want to have meals deleted automatically from database?  (y/n):  ");
#line 530
  junk = get_char();
  }
#line 531
  if (junk != 89) {
#line 531
    if (junk != 121) {
#line 531
      if (junk != 78) {
#line 531
        if (junk != 110) {
#line 531
          return;
        }
      }
    }
  }
#line 532
  if (junk != 89) {
#line 532
    if (junk != 121) {
      {
#line 534
      header((char *)"NUT:  Automatic Deletion of Meals");
#line 535
      spacer(0);
#line 536
      options.delopt = -1;
#line 537
      write_OPTIONS();
#line 538
      printf((char const   */* __restrict  */)"\nMeals will not be deleted automatically.  Press <enter> to continue...");
#line 539
      junk = get_int();
      }
#line 540
      return;
    }
  }
  {
#line 542
  junk = 0;
#line 543
  header((char *)"NUT:  Automatic Deletion of Meals");
#line 544
  spacer(0);
#line 545
  printf((char const   */* __restrict  */)"\nHow many meals should be kept in database?  ");
  }
  {
#line 546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 546
    if (! (junk < 1)) {
#line 546
      goto while_break;
    }
    {
#line 548
    get_string(buf, 127);
#line 549
    junk = atoi((char const   *)(buf));
    }
#line 550
    if (junk > 0) {
      {
#line 552
      options.delopt = junk;
#line 553
      write_OPTIONS();
#line 554
      delete_meals(options.delopt);
#line 555
      write_meal_db();
#line 556
      header((char *)"NUT:  Automatic Deletion of Meals");
#line 557
      spacer(0);
      }
#line 558
      if (junk == 1) {
        {
#line 558
        printf((char const   */* __restrict  */)"\n%d meal will be kept in database.  Press <enter> to continue...",
               junk);
        }
      } else {
        {
#line 559
        printf((char const   */* __restrict  */)"\n%d meals will be kept in database.  Press <enter> to continue...",
               junk);
        }
      }
      {
#line 560
      junk = get_int();
      }
#line 561
      return;
    }
    {
#line 563
    header((char *)"NUT:  Automatic Deletion of Meals");
#line 564
    spacer(0);
#line 565
    printf((char const   */* __restrict  */)"\nMust keep at least one meal in database.  How many?  ");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 567
  return;
}
}
#line 569 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void new_nut_levels(void) 
{ 
  int junk ;

  {
  {
#line 572
  printf((char const   */* __restrict  */)"\n      New Nutrient Levels:    %-15s %6.1f %-s\n",
         Nutrient[4], (double )DV[4], Unit[4]);
#line 573
  printf((char const   */* __restrict  */)"                              %-15s %6.1f %-s\n",
         Nutrient[1], (double )DV[1], Unit[1]);
#line 574
  printf((char const   */* __restrict  */)"                              %-15s %6.1f %-s\n",
         Nutrient[84], (double )DV[84], Unit[84]);
#line 575
  printf((char const   */* __restrict  */)"                              %-15s %6.1f %-s\n",
         Nutrient[111], (double )DV[111], Unit[111]);
#line 576
  printf((char const   */* __restrict  */)"                              %-15s %6.1f %-s\n",
         Nutrient[112], (double )DV[112], Unit[112]);
#line 577
  printf((char const   */* __restrict  */)"                              %-15s %6.1f %-s\n",
         Nutrient[152], (double )DV[152], Unit[152]);
#line 578
  printf((char const   */* __restrict  */)"                              %-15s %6.1f %-s\n",
         Nutrient[147], (double )DV[147], Unit[147]);
#line 579
  printf((char const   */* __restrict  */)"                              %-15s %6.1f %-s\n",
         Nutrient[148], (double )DV[148], Unit[148]);
#line 580
  printf((char const   */* __restrict  */)"                              %-15s %6.1f %-s\n",
         Nutrient[155], (double )DV[155], Unit[155]);
#line 581
  printf((char const   */* __restrict  */)"                              %-15s %6.1f %-s\n",
         Nutrient[149], (double )DV[149], Unit[149]);
#line 582
  printf((char const   */* __restrict  */)"                              %-15s %6.1f %-s\n",
         Nutrient[150], (double )DV[150], Unit[150]);
#line 583
  printf((char const   */* __restrict  */)"                              %-15s %6.1f %-s\n",
         Nutrient[151], (double )DV[151], Unit[151]);
#line 584
  printf((char const   */* __restrict  */)"                              %-15s %6.1f %-s\n",
         Nutrient[2], (double )DV[2], Unit[2]);
#line 585
  printf((char const   */* __restrict  */)"                              %-15s %6.1f %-s\n",
         Nutrient[19], (double )DV[19], Unit[19]);
#line 586
  printf((char const   */* __restrict  */)"                              %-15s %6.1f %-s\n",
         Nutrient[146], (double )DV[146], Unit[146]);
#line 587
  printf((char const   */* __restrict  */)"                              %-15s %6.1f %-s\n",
         Nutrient[0], (double )DV[0], Unit[0]);
#line 588
  spacer(17);
#line 589
  printf((char const   */* __restrict  */)"\nPress <enter> to continue...");
#line 590
  junk = get_int();
  }
#line 591
  return;
}
}
#line 593 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void restore_defaults(int removelock ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 596
  if (removelock) {
#line 596
    i = 0;
    {
#line 596
    while (1) {
      while_continue: /* CIL Label */ ;
#line 596
      if (! (i < 159)) {
#line 596
        goto while_break;
      }
#line 596
      options.locknuts[i] = 0;
#line 596
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 597
  if (! options.locknuts[0]) {
#line 597
    options.pcprotein = (float )0;
  }
#line 598
  if (! options.locknuts[2]) {
#line 598
    options.pccarb = (float )0;
  }
#line 599
  if (! options.locknuts[84]) {
#line 599
    options.pcsatfat = (float )0;
  }
#line 600
  if (removelock) {
#line 602
    options.autocal = (char)0;
#line 603
    options.n6hufa = (float )0;
#line 604
    options.epadhamax = (float )0;
  }
#line 606
  i = 0;
  {
#line 606
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 606
    if (! (i < 159)) {
#line 606
      goto while_break___0;
    }
#line 606
    if (! options.locknuts[i]) {
#line 606
      options.abnuts[i] = (float )0;
    }
#line 606
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 607
  if (! options.locknuts[4]) {
#line 607
    if (removelock) {
#line 607
      tmp = 0;
    } else {
#line 607
      tmp = 1;
    }
    {
#line 607
    auto_cal(& DVBase[4], tmp);
    }
  } else {
#line 608
    if (removelock) {
#line 608
      tmp___0 = 0;
    } else {
#line 608
      tmp___0 = 1;
    }
    {
#line 608
    auto_cal(& options.abnuts[4], tmp___0);
    }
  }
#line 609
  return;
}
}
#line 611 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void efa_dynamics(void) 
{ 
  int i ;
  float temp ;
  float temp1 ;
  float temp_la ;
  float temp_aa ;
  float hufapct ;
  float p3 ;
  float h3 ;
  float h6 ;
  float p6 ;
  float o ;
  float kludgefactor ;
  float target ;
  float epadhalimit ;
  float extra_ala ;

  {
#line 614
  temp_la = (float )0;
#line 614
  temp_aa = (float )0;
#line 615
  kludgefactor = (float ).9;
#line 616
  target = DefaultTarget + kludgefactor;
#line 618
  if (options.n6hufa != (float )0) {
#line 620
    if (options.n6hufa < (float )15) {
#line 620
      options.n6hufa = (float )15;
    }
#line 621
    if (options.n6hufa > (float )90) {
#line 621
      options.n6hufa = (float )90;
    }
  }
#line 624
  if (options.epadhamax <= (float )0) {
#line 624
    epadhalimit = DefaultEPADHA;
  } else {
#line 625
    epadhalimit = options.epadhamax;
  }
#line 627
  options.abnuts[149] = food_work.nutrient[149];
#line 628
  if (options.abnuts[149] < DV[149]) {
#line 628
    options.abnuts[149] = DV[149];
  }
#line 629
  extra_ala = options.abnuts[149] - food_work.nutrient[149];
#line 631
  if (DefaultTarget == (float )90) {
#line 631
    if (options.n6hufa == (float )0) {
#line 631
      goto _L;
    } else {
#line 631
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 631
  if (options.n6hufa == (float )90) {
#line 631
    goto _L;
  } else
#line 631
  if (options.n6hufa == (float )15) {
    _L: /* CIL Label */ 
#line 633
    options.abnuts[152] = food_work.nutrient[152];
#line 634
    if (options.abnuts[152] <= (float )0) {
#line 634
      options.abnuts[152] = (float ).00001;
    }
#line 635
    options.abnuts[147] = food_work.nutrient[147];
#line 636
    if (options.abnuts[147] <= (float )0) {
#line 636
      options.abnuts[147] = (float ).00001;
    }
#line 637
    options.abnuts[148] = food_work.nutrient[148];
#line 638
    if (options.abnuts[148] <= (float )0) {
#line 638
      options.abnuts[148] = (float ).00001;
    }
#line 639
    options.abnuts[155] = food_work.nutrient[155] + extra_ala;
#line 640
    if (options.abnuts[155] <= (float )0) {
#line 640
      options.abnuts[155] = (float ).00001;
    }
#line 641
    options.abnuts[150] = food_work.nutrient[150];
#line 642
    if (options.abnuts[150] <= (float )0) {
#line 642
      options.abnuts[150] = (float ).00001;
    }
#line 643
    options.abnuts[151] = food_work.nutrient[151];
#line 644
    if (options.abnuts[151] <= (float )0) {
#line 644
      options.abnuts[151] = (float ).00001;
    }
#line 645
    if (options.abnuts[150] + options.abnuts[151] < DefaultEPADHA) {
#line 645
      if ((double )food_work.nutrient[150] > .01) {
#line 647
        temp1 = epadhalimit - (options.abnuts[150] + options.abnuts[151]);
#line 648
        temp = epadhalimit / (options.abnuts[150] + options.abnuts[151]);
#line 649
        options.abnuts[150] *= temp;
#line 650
        options.abnuts[151] *= temp;
#line 651
        options.abnuts[155] += temp1;
      } else
#line 645
      if ((double )food_work.nutrient[151] > .01) {
#line 647
        temp1 = epadhalimit - (options.abnuts[150] + options.abnuts[151]);
#line 648
        temp = epadhalimit / (options.abnuts[150] + options.abnuts[151]);
#line 649
        options.abnuts[150] *= temp;
#line 650
        options.abnuts[151] *= temp;
#line 651
        options.abnuts[155] += temp1;
      } else
#line 645
      if ((double )food_work.nutrient[148] > .01) {
#line 647
        temp1 = epadhalimit - (options.abnuts[150] + options.abnuts[151]);
#line 648
        temp = epadhalimit / (options.abnuts[150] + options.abnuts[151]);
#line 649
        options.abnuts[150] *= temp;
#line 650
        options.abnuts[151] *= temp;
#line 651
        options.abnuts[155] += temp1;
      }
    }
#line 653
    return;
  }
#line 656
  if (options.n6hufa != (float )0) {
#line 656
    target = options.n6hufa + kludgefactor;
  }
#line 658
  options.abnuts[148] = food_work.nutrient[148];
#line 659
  options.abnuts[147] = food_work.nutrient[147];
#line 660
  extra_ala = options.abnuts[149] - food_work.nutrient[149];
#line 661
  p3 = ((float )902 * (food_work.nutrient[156] + extra_ala)) / food_work.nutrient[4];
#line 662
  p6 = ((float )902 * food_work.nutrient[153]) / food_work.nutrient[4];
#line 663
  h6 = ((float )902 * food_work.nutrient[154]) / food_work.nutrient[4];
#line 664
  o = ((((((float )902 * food_work.nutrient[1]) * options.fattyacidfactor) / food_work.nutrient[4] - food_work.nutrient[153]) - food_work.nutrient[154]) - food_work.nutrient[156]) - food_work.nutrient[157];
#line 666
  if ((double )food_work.nutrient[150] > .01) {
#line 666
    goto _L___1;
  } else
#line 666
  if ((double )food_work.nutrient[151] > .01) {
#line 666
    goto _L___1;
  } else
#line 666
  if ((double )food_work.nutrient[148] > .01) {
    _L___1: /* CIL Label */ 
#line 666
    i = 1;
    {
#line 666
    while (1) {
      while_continue: /* CIL Label */ ;
#line 666
      if (! (i < 200000)) {
#line 666
        goto while_break;
      }
      {
#line 668
      temp = (float )((double )i * .001);
#line 669
      h3 = ((float )902 * temp) / food_work.nutrient[4];
#line 670
      hufapct = n6hufa(p3, p6, h3, h6, o, food_work.nutrient[4]);
      }
#line 672
      if (hufapct > target) {
#line 672
        goto __Cont;
      }
#line 674
      options.abnuts[152] = food_work.nutrient[153] + food_work.nutrient[154];
#line 675
      options.abnuts[155] = (food_work.nutrient[156] + extra_ala) + temp;
#line 676
      temp -= (food_work.nutrient[157] - food_work.nutrient[150]) - food_work.nutrient[151];
#line 677
      if (food_work.nutrient[150] > (float )0) {
#line 679
        temp /= food_work.nutrient[150] + food_work.nutrient[151];
#line 680
        options.abnuts[150] = food_work.nutrient[150] * temp;
#line 681
        options.abnuts[151] = food_work.nutrient[151] * temp;
      } else
#line 677
      if (food_work.nutrient[151] > (float )0) {
#line 679
        temp /= food_work.nutrient[150] + food_work.nutrient[151];
#line 680
        options.abnuts[150] = food_work.nutrient[150] * temp;
#line 681
        options.abnuts[151] = food_work.nutrient[151] * temp;
      }
#line 683
      if (food_work.nutrient[150] <= (float )0) {
#line 683
        if (food_work.nutrient[151] <= (float )0) {
#line 685
          options.abnuts[150] = temp / (float )2;
#line 686
          options.abnuts[151] = temp / (float )2;
        }
      }
#line 688
      if (options.abnuts[150] + options.abnuts[151] > epadhalimit) {
#line 690
        temp = (options.abnuts[150] + options.abnuts[151]) - epadhalimit;
#line 691
        temp1 = options.abnuts[150] / (options.abnuts[150] + options.abnuts[151]);
#line 692
        options.abnuts[150] -= temp * temp1;
#line 693
        options.abnuts[151] -= temp * ((float )1 - temp1);
#line 694
        options.abnuts[155] -= temp;
#line 695
        h3 -= ((float )902 * temp) / food_work.nutrient[4];
#line 696
        i = 1;
        {
#line 696
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 696
          if (! (i < 200000)) {
#line 696
            goto while_break___0;
          }
          {
#line 698
          temp_la = (float )((double )(p6 * (float )i) * .00001);
#line 699
          temp_aa = (float )((double )(h6 * (float )i) * .00001);
#line 700
          hufapct = n6hufa(p3, p6 - temp_la, h3, h6 - temp_aa, o, food_work.nutrient[4]);
          }
#line 701
          if (hufapct < target) {
#line 701
            goto while_break___0;
          }
#line 696
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 703
        options.abnuts[147] -= (temp_la / (float )902) * food_work.nutrient[4];
#line 704
        temp_aa = (((float )902 / food_work.nutrient[4]) * food_work.nutrient[148]) * ((float )1 - options.abnuts[147] / food_work.nutrient[147]);
#line 705
        options.abnuts[148] -= (temp_aa / (float )902) * food_work.nutrient[4];
#line 706
        options.abnuts[152] -= ((temp_la + temp_aa) / (float )902) * food_work.nutrient[4];
      }
#line 708
      if (options.abnuts[152] <= (float )0) {
#line 708
        options.abnuts[152] = (float ).01;
      }
#line 709
      if (options.abnuts[147] <= (float )0) {
#line 709
        options.abnuts[147] = (float ).01;
      }
#line 710
      if (options.abnuts[148] <= (float )0) {
#line 710
        options.abnuts[148] = (float ).01;
      }
#line 711
      if (options.abnuts[155] <= (float )0) {
#line 711
        options.abnuts[155] = (float ).01;
      }
#line 712
      if (options.abnuts[150] <= (float )0) {
#line 712
        options.abnuts[150] = (float ).01;
      }
#line 713
      if (options.abnuts[151] <= (float )0) {
#line 713
        options.abnuts[151] = (float ).01;
      }
#line 714
      return;
      __Cont: /* CIL Label */ 
#line 666
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 718
    h3 = ((float )902 * food_work.nutrient[157]) / food_work.nutrient[4];
#line 719
    i = 1;
    {
#line 719
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 719
      if (! (i < 200000)) {
#line 719
        goto while_break___1;
      }
      {
#line 721
      temp = (float )((double )i * .001);
#line 723
      p3 = ((float )902 * temp) / food_work.nutrient[4];
#line 724
      o = ((float )902 * (food_work.nutrient[84] + food_work.nutrient[111])) / food_work.nutrient[4];
#line 725
      hufapct = n6hufa(p3, p6, h3, h6, o, food_work.nutrient[4]);
      }
#line 727
      if (hufapct > target) {
#line 727
        goto __Cont___0;
      }
#line 728
      options.abnuts[152] = food_work.nutrient[153] + food_work.nutrient[154];
#line 729
      options.abnuts[155] = food_work.nutrient[157] + temp;
#line 730
      temp -= food_work.nutrient[156] - food_work.nutrient[149];
#line 731
      options.abnuts[149] = temp;
#line 732
      options.abnuts[150] = (float ).01;
#line 733
      options.abnuts[151] = (float ).01;
#line 734
      if (options.abnuts[152] <= (float )0) {
#line 734
        options.abnuts[152] = (float ).01;
      }
#line 735
      if (options.abnuts[147] <= (float )0) {
#line 735
        options.abnuts[147] = (float ).01;
      }
#line 736
      if (options.abnuts[148] <= (float )0) {
#line 736
        options.abnuts[148] = (float ).01;
      }
#line 737
      if (options.abnuts[155] <= (float )0) {
#line 737
        options.abnuts[155] = (float ).01;
      }
#line 738
      if (options.abnuts[149] <= (float )0) {
#line 738
        options.abnuts[149] = (float ).01;
      }
#line 739
      if (options.abnuts[150] <= (float )0) {
#line 739
        options.abnuts[150] = (float ).01;
      }
#line 740
      if (options.abnuts[151] <= (float )0) {
#line 740
        options.abnuts[151] = (float ).01;
      }
#line 741
      return;
      __Cont___0: /* CIL Label */ 
#line 719
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 744
  return;
}
}
#line 746 "/home/wheatley/newnew/temp/nut-nutrition-15.5/options.c"
void weight_log(void) 
{ 
  char newentry[128] ;
  int n ;
  int nfat ;
  int up ;
  int justmadenewentry ;
  float weightslope ;
  float fatslope ;
  float weight ;
  float bf ;
  float stardate ;
  time_t t ;
  size_t tmp ;
  char *tmp___0 ;
  double tmp___1 ;
  char *tmp___2 ;
  double tmp___3 ;
  char *tmp___4 ;
  double tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;

  {
#line 749
  justmadenewentry = 0;
  {
#line 754
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 756
    header((char *)"NUT:  Weight Log Regression");
#line 757
    read_WLOG(& n, & nfat, & up, & weightslope, & fatslope);
    }
#line 758
    if (justmadenewentry) {
#line 758
      if ((int )options.autocal > 1) {
#line 758
        if (nfat > 1) {
#line 760
          if (up) {
#line 760
            options.abnuts[4] += (float )20;
          } else {
#line 761
            options.abnuts[4] -= (float )20;
          }
          {
#line 762
          auto_cal(& options.abnuts[4], 0);
          }
        }
      }
    }
    {
#line 764
    justmadenewentry = 0;
#line 765
    printf((char const   */* __restrict  */)"\n\n");
#line 766
    printf((char const   */* __restrict  */)"                           data points:   %6d\n",
           n);
#line 767
    printf((char const   */* __restrict  */)"\n\n");
#line 768
    printf((char const   */* __restrict  */)"  Based on the trend\n");
#line 769
    printf((char const   */* __restrict  */)"  of data points so far...\n\n\n");
    }
#line 770
    if (n < 2) {
      {
#line 770
      printf((char const   */* __restrict  */)"         Predicted daily weight change:        ?\n\n");
      }
    } else {
      {
#line 771
      printf((char const   */* __restrict  */)"         Predicted daily weight change:   %+10.3f\n\n",
             (double )weightslope);
      }
    }
#line 772
    if (nfat < 2) {
      {
#line 774
      printf((char const   */* __restrict  */)"      Predicted daily lean mass change:        ?\n\n");
#line 775
      printf((char const   */* __restrict  */)"       Predicted daily fat mass change:        ?\n\n");
      }
    } else {
      {
#line 779
      printf((char const   */* __restrict  */)"      Predicted daily lean mass change:   %+10.3f\n\n",
             (double )(weightslope - fatslope));
#line 780
      printf((char const   */* __restrict  */)"       Predicted daily fat mass change:   %+10.3f\n\n",
             (double )fatslope);
      }
    }
    {
#line 782
    spacer(14);
    }
#line 783
    if (n > 0) {
      {
#line 783
      printf((char const   */* __restrict  */)"Type daily weight and body fat %% (! to clear log, <enter> to quit):  ");
      }
    } else {
      {
#line 784
      printf((char const   */* __restrict  */)"Type daily weight and body fat %% (<enter> to quit):  ");
      }
    }
    {
#line 785
    get_string(newentry, 127);
#line 786
    tmp = strlen((char const   *)(newentry));
    }
#line 786
    if (tmp == 0UL) {
#line 786
      return;
    } else
#line 786
    if ((int )newentry[0] == 32) {
#line 786
      return;
    }
    {
#line 787
    tmp___8 = strchr((char const   *)(newentry), '!');
    }
#line 787
    if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 789
      weight = (float )0;
#line 790
      if (n > 0) {
        {
#line 790
        write_WLOG(& weight, & bf, & stardate);
        }
      }
    } else {
      {
#line 794
      time(& t);
#line 795
      tmp___6 = strchr((char const   *)(newentry), ' ');
      }
#line 795
      if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
        {
#line 797
        tmp___0 = strtok((char */* __restrict  */)(newentry), (char const   */* __restrict  */)" ");
#line 797
        tmp___1 = atof((char const   *)tmp___0);
#line 797
        weight = (float )tmp___1;
#line 798
        bf = (float )0;
        }
      } else {
        {
#line 795
        tmp___7 = strlen((char const   *)(newentry));
        }
#line 795
        if ((int )newentry[tmp___7 - 1UL] == 32) {
          {
#line 797
          tmp___0 = strtok((char */* __restrict  */)(newentry), (char const   */* __restrict  */)" ");
#line 797
          tmp___1 = atof((char const   *)tmp___0);
#line 797
          weight = (float )tmp___1;
#line 798
          bf = (float )0;
          }
        } else {
          {
#line 802
          tmp___2 = strtok((char */* __restrict  */)(newentry), (char const   */* __restrict  */)" ");
#line 802
          tmp___3 = atof((char const   *)tmp___2);
#line 802
          weight = (float )tmp___3;
#line 803
          tmp___4 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 803
          tmp___5 = atof((char const   *)tmp___4);
#line 803
          bf = (float )tmp___5;
#line 804
          justmadenewentry = 1;
          }
        }
      }
#line 806
      stardate = (float )t / (float )86400 - (float )14486;
#line 807
      if (weight > (float )0) {
        {
#line 807
        write_WLOG(& weight, & bf, & stardate);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 29 "/home/wheatley/newnew/temp/nut-nutrition-15.5/anameal.h"
void analyze_meals(struct meal *meal_ptr_origin , int specialheader ) ;
#line 30
void deficsort(float *deficpct , int *deficnut , int deficnuts ) ;
#line 31
int random_max_var_array(float *abacus , int last ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 30 "/home/wheatley/newnew/temp/nut-nutrition-15.5/anameal.c"
void analyze_meals(struct meal *meal_ptr_origin , int specialheader ) 
{ 
  struct food *food_ptr ;
  struct food *food_ptr_abacus[9000] ;
  struct food *food_recommended[18] ;
  struct meal *meal_ptr ;
  int max ;
  int meals ;
  int count ;
  int mealcount ;
  int meal ;
  int deficnuts ;
  int i ;
  int abacuscount ;
  int spacecount ;
  int frcount ;
  int high_grams ;
  char meal_date[9] ;
  char inbuf[128] ;
  float newcal ;
  float deficpct[39] ;
  float food_abacus[9000] ;
  float serving_ratio_abacus[9000] ;
  int deficnut[39] ;
  float prodefic ;
  float thispct ;
  float totaldefic ;
  float serving_ratio ;
  int tmp ;
  int tmp___0 ;
  struct meal *tmp___1 ;
  struct meal *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
  {
#line 35
  meal = 0;
#line 36
  spacecount = 0;
#line 42
  options.temp_meal_root = meal_ptr_origin;
#line 43
  mealcount = meal_count(meal_ptr_origin);
#line 44
  max = mealcount;
  }
#line 45
  if (specialheader) {
#line 45
    options.defanal = options.defanalrec;
  } else {
#line 46
    options.defanal = options.defanalanal;
  }
#line 47
  if (options.defanal > 0) {
#line 47
    if (options.defanal < mealcount) {
#line 47
      max = options.defanal;
    }
  }
#line 48
  if (mealcount == 0) {
#line 50
    if (specialheader == 1) {
      {
#line 50
      header((char *)"NUT:  Record Meals");
      }
    } else {
      {
#line 51
      header((char *)"NUT:  Analyze Meals");
      }
    }
    {
#line 52
    spacer(0);
#line 53
    printf((char const   */* __restrict  */)"\nThere are no meals in database.  Press <enter> to continue...");
#line 54
    count = get_int();
    }
#line 55
    return;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (max > 0)) {
#line 57
      goto while_break;
    }
    {
#line 59
    meal_ptr = meal_ptr_origin;
#line 60
    strcpy((char */* __restrict  */)(meal_date), (char const   */* __restrict  */)"");
    }
#line 61
    if (max > mealcount) {
#line 61
      max = mealcount;
    }
    {
#line 62
    meals = 0;
#line 63
    clear_work();
    }
    {
#line 64
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 64
      if ((unsigned long )meal_ptr->next != (unsigned long )((void *)0)) {
#line 64
        if (! (meals <= max)) {
#line 64
          goto while_break___0;
        }
      } else {
#line 64
        goto while_break___0;
      }
      {
#line 66
      meal_ptr = meal_ptr->next;
#line 67
      tmp = strcmp((char const   *)(meal_date), (char const   *)(meal_ptr->meal_date));
      }
#line 67
      if (tmp != 0) {
        {
#line 69
        strcpy((char */* __restrict  */)(meal_date), (char const   */* __restrict  */)(meal_ptr->meal_date));
#line 70
        meal = (int )meal_ptr->meal;
#line 71
        meals ++;
        }
      } else
#line 67
      if (meal != (int )meal_ptr->meal) {
        {
#line 69
        strcpy((char */* __restrict  */)(meal_date), (char const   */* __restrict  */)(meal_ptr->meal_date));
#line 70
        meal = (int )meal_ptr->meal;
#line 71
        meals ++;
        }
      }
#line 73
      if (meals > max) {
#line 73
        goto while_break___0;
      }
#line 74
      count = 1;
      {
#line 74
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 74
        if (! (count <= *(ScreenMap[options.screen]))) {
#line 74
          goto while_break___1;
        }
        {
#line 74
        tmp___0 = test_for_negative_zero(& (FoodIndex[meal_ptr->food_no])->nutrient[*(ScreenMap[options.screen] + count)]);
        }
#line 74
        if (! tmp___0) {
#line 74
          food_work.nutrient[*(ScreenMap[options.screen] + count)] += ((((float )options.mealsperday * meal_ptr->grams) / (float )100) * (FoodIndex[meal_ptr->food_no])->nutrient[*(ScreenMap[options.screen] + count)]) / (float )max;
        }
#line 74
        count ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 75
      food_work.nutrient[144] += ((((float )options.mealsperday * meal_ptr->grams) / (float )100) * (FoodIndex[meal_ptr->food_no])->nutrient[144]) / (float )max;
#line 76
      food_work.nutrient[143] += ((((float )options.mealsperday * meal_ptr->grams) / (float )100) * (FoodIndex[meal_ptr->food_no])->nutrient[143]) / (float )max;
#line 77
      food_work.nutrient[145] += ((((float )options.mealsperday * meal_ptr->grams) / (float )100) * (FoodIndex[meal_ptr->food_no])->nutrient[145]) / (float )max;
#line 78
      food_work.nutrient[156] += ((((float )options.mealsperday * meal_ptr->grams) / (float )100) * (FoodIndex[meal_ptr->food_no])->nutrient[156]) / (float )max;
#line 79
      food_work.nutrient[157] += ((((float )options.mealsperday * meal_ptr->grams) / (float )100) * (FoodIndex[meal_ptr->food_no])->nutrient[157]) / (float )max;
#line 80
      food_work.nutrient[153] += ((((float )options.mealsperday * meal_ptr->grams) / (float )100) * (FoodIndex[meal_ptr->food_no])->nutrient[153]) / (float )max;
#line 81
      food_work.nutrient[154] += ((((float )options.mealsperday * meal_ptr->grams) / (float )100) * (FoodIndex[meal_ptr->food_no])->nutrient[154]) / (float )max;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 83
    if (specialheader == 1) {
      {
#line 83
      header((char *)"NUT:  Record Meals");
      }
    } else {
      {
#line 84
      header((char *)"NUT:  Analyze Meals");
      }
    }
#line 85
    if (max != 1) {
#line 85
      if (options.screen == 0) {
#line 85
        if (! options.custom) {
          {
#line 85
          printf((char const   */* __restrict  */)"Here are \"Daily Value\" average percentages for your previous %d meals:\n",
                 max);
          }
        }
      }
    }
#line 86
    if (max == 1) {
#line 86
      if (options.screen == 0) {
#line 86
        if (! options.custom) {
          {
#line 86
          printf((char const   */* __restrict  */)"Here are \"Daily Value\" average percentages for your previous 1 meal:\n");
          }
        }
      }
    }
#line 87
    if (max != 1) {
#line 87
      if (options.screen == 0) {
#line 87
        if (options.custom) {
          {
#line 87
          printf((char const   */* __restrict  */)"Here are customized DV average percentages for your previous %d meals:\n",
                 max);
          }
        }
      }
    }
#line 88
    if (max == 1) {
#line 88
      if (options.screen == 0) {
#line 88
        if (options.custom) {
          {
#line 88
          printf((char const   */* __restrict  */)"Here are customized DV average percentages for your previous 1 meal:\n");
          }
        }
      }
    }
#line 89
    if (max != 1) {
#line 89
      if (options.screen > 0) {
        {
#line 89
        printf((char const   */* __restrict  */)"Here are average daily nutrient levels for your previous %d meals:\n",
               max);
        }
      }
    }
#line 90
    if (max == 1) {
#line 90
      if (options.screen > 0) {
        {
#line 90
        printf((char const   */* __restrict  */)"Here are average daily nutrient levels for your previous 1 meal:\n");
        }
      }
    }
#line 91
    if (max != 1) {
#line 91
      if (max == mealcount) {
        {
#line 91
        printf((char const   */* __restrict  */)" -> Meals %s/%d through %s/%d\n\n",
               meal_ptr->meal_date, (int )meal_ptr->meal, (meal_ptr_origin->next)->meal_date,
               (int )(meal_ptr_origin->next)->meal);
        }
      }
    }
#line 92
    if (max != 1) {
#line 92
      if (max != mealcount) {
        {
#line 92
        tmp___1 = prev_meal(meal_ptr);
#line 92
        tmp___2 = prev_meal(meal_ptr);
#line 92
        printf((char const   */* __restrict  */)" -> Meals %s/%d through %s/%d\n\n",
               tmp___2->meal_date, (int )tmp___1->meal, (meal_ptr_origin->next)->meal_date,
               (int )(meal_ptr_origin->next)->meal);
        }
      }
    }
#line 93
    if (max == 1) {
      {
#line 93
      printf((char const   */* __restrict  */)" -> Meal %s/%d\n\n", (meal_ptr_origin->next)->meal_date,
             (int )(meal_ptr_origin->next)->meal);
      }
    }
    {
#line 94
    food_display(stdout);
#line 95
    spacer(19);
    }
#line 96
    if (options.screen == 0) {
      {
#line 98
      printf((char const   */* __restrict  */)"Type # of meals to analyze,  \"s\" for food suggestions, \"c\" to reset calories,\n");
#line 99
      printf((char const   */* __restrict  */)"\"m\" to reset macronutrients, \"e\" to reset everything,  \"o\" to restore defaults,\n");
#line 100
      printf((char const   */* __restrict  */)"\"d\" for alternate displays,  or just press <enter> to quit:  ");
      }
    }
#line 102
    if (options.screen > 0) {
      {
#line 102
      printf((char const   */* __restrict  */)"\n\nType # of meals to analyze, \"d\" alternate displays, <enter> to quit: ");
      }
    }
    {
#line 103
    get_string(inbuf, 127);
#line 104
    tmp___30 = strncmp((char const   *)(inbuf), "c", (size_t )1);
    }
#line 104
    if (tmp___30 == 0) {
#line 106
      if (options.screen != 0) {
#line 106
        goto while_continue;
      }
#line 107
      if (options.locknuts[4]) {
#line 107
        goto while_continue;
      }
#line 109
      newcal = food_work.nutrient[4];
#line 110
      if (! options.locknuts[1]) {
#line 110
        options.abnuts[1] = (float )0;
      }
#line 111
      if (! options.locknuts[111]) {
#line 111
        options.abnuts[111] = (float )0;
      }
#line 112
      if (options.abnuts[0]) {
#line 112
        options.pccarb = (float )0;
      }
      {
#line 113
      auto_cal(& newcal, 1);
      }
    } else {
      {
#line 115
      tmp___29 = strncmp((char const   *)(inbuf), "d", (size_t )1);
      }
#line 115
      if (tmp___29 == 0) {
        {
#line 115
        screen();
        }
      } else {
        {
#line 116
        tmp___28 = strncmp((char const   *)(inbuf), "p", (size_t )1);
        }
#line 116
        if (tmp___28 == 0) {
          {
#line 116
          screen_previous();
          }
        } else {
          {
#line 117
          tmp___27 = strncmp((char const   *)(inbuf), "e", (size_t )1);
          }
#line 117
          if (tmp___27 == 0) {
#line 119
            if (options.screen != 0) {
#line 119
              goto while_continue;
            }
            {
#line 120
            restore_defaults(0);
#line 121
            i = 1;
            }
            {
#line 121
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 121
              if (! (i < DVMap[0])) {
#line 121
                goto while_break___2;
              }
#line 121
              if (! options.locknuts[DVMap[i + 1]]) {
#line 121
                options.abnuts[DVMap[i + 1]] = food_work.nutrient[DVMap[i + 1]];
              }
#line 121
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 122
            options.abnuts[111] = (float )0;
#line 123
            if (! options.locknuts[4]) {
#line 123
              if (! options.autocal) {
#line 123
                newcal = food_work.nutrient[4];
              }
            }
#line 124
            if (options.locknuts[4]) {
#line 124
              newcal = DV[4];
            } else
#line 124
            if (options.autocal) {
#line 124
              newcal = DV[4];
            }
#line 125
            if (! options.locknuts[84]) {
#line 125
              options.pcsatfat = ((((float )10 * food_work.nutrient[84]) / DVBase[84]) * DVBase[4]) / newcal;
            }
            {
#line 126
            auto_cal(& newcal, 1);
            }
          } else {
            {
#line 128
            tmp___26 = strncmp((char const   *)(inbuf), "m", (size_t )1);
            }
#line 128
            if (tmp___26 == 0) {
#line 130
              if (options.screen != 0) {
#line 130
                goto while_continue;
              }
              {
#line 131
              restore_defaults(0);
              }
#line 132
              if (! options.locknuts[19]) {
#line 132
                options.abnuts[19] = food_work.nutrient[19];
              }
#line 133
              if (! options.locknuts[84]) {
#line 133
                options.abnuts[84] = food_work.nutrient[84];
              }
#line 134
              if (! options.locknuts[0]) {
#line 134
                options.abnuts[0] = food_work.nutrient[0];
              }
#line 135
              if (! options.locknuts[2]) {
#line 135
                options.abnuts[2] = food_work.nutrient[2];
              }
#line 136
              if (! options.locknuts[4]) {
#line 136
                if (! options.autocal) {
#line 136
                  newcal = food_work.nutrient[4];
                }
              }
#line 137
              if (options.locknuts[4]) {
#line 137
                newcal = DV[4];
              } else
#line 137
              if (options.autocal) {
#line 137
                newcal = DV[4];
              }
#line 138
              if (! options.locknuts[84]) {
#line 138
                options.pcsatfat = ((((float )10 * food_work.nutrient[84]) / DVBase[84]) * DVBase[4]) / newcal;
              }
              {
#line 139
              auto_cal(& newcal, 1);
              }
            } else {
              {
#line 141
              tmp___25 = strncmp((char const   *)(inbuf), "o", (size_t )1);
              }
#line 141
              if (tmp___25 == 0) {
#line 143
                if (options.screen != 0) {
#line 143
                  goto while_continue;
                }
                {
#line 144
                restore_defaults(0);
                }
              } else {
                {
#line 146
                tmp___24 = strncmp((char const   *)(inbuf), "n", (size_t )1);
                }
#line 146
                if (tmp___24 == 0) {
#line 148
                  if (options.screen != 0) {
#line 148
                    goto while_continue;
                  }
                  {
#line 149
                  restore_defaults(0);
                  }
#line 150
                  if (! options.locknuts[19]) {
#line 150
                    options.abnuts[19] = food_work.nutrient[19];
                  }
#line 151
                  if (! options.locknuts[84]) {
#line 151
                    options.abnuts[84] = food_work.nutrient[84];
                  }
#line 152
                  if (! options.locknuts[4]) {
#line 152
                    if (! options.autocal) {
#line 154
                      newcal = food_work.nutrient[4];
#line 155
                      if (! options.locknuts[0]) {
#line 155
                        options.pcprotein = (food_work.nutrient[143] / food_work.nutrient[4]) * (float )100;
                      }
#line 156
                      if (! options.locknuts[2]) {
#line 156
                        options.pccarb = (food_work.nutrient[145] / food_work.nutrient[4]) * (float )100;
                      }
#line 157
                      if (! options.locknuts[84]) {
#line 157
                        options.pcsatfat = ((((float )10 * food_work.nutrient[84]) / DVBase[84]) * DVBase[4]) / newcal;
                      }
                    }
                  }
#line 159
                  if (options.locknuts[4]) {
#line 159
                    goto _L;
                  } else
#line 159
                  if (options.autocal) {
                    _L: /* CIL Label */ 
#line 161
                    newcal = DV[4];
#line 162
                    if (! options.locknuts[0]) {
#line 162
                      options.pcprotein = (food_work.nutrient[143] / DV[4]) * (float )100;
                    }
#line 163
                    if (! options.locknuts[2]) {
#line 163
                      options.pccarb = (food_work.nutrient[145] / DV[4]) * (float )100;
                    }
#line 164
                    if (! options.locknuts[84]) {
#line 164
                      options.pcsatfat = ((((float )10 * food_work.nutrient[84]) / DVBase[84]) * DVBase[4]) / newcal;
                    }
                  }
                  {
#line 166
                  auto_cal(& newcal, 1);
                  }
                } else {
                  {
#line 168
                  tmp___23 = strncmp((char const   *)(inbuf), "s", (size_t )1);
                  }
#line 168
                  if (tmp___23 == 0) {
#line 170
                    if (options.screen != 0) {
#line 170
                      goto while_continue;
                    }
                    {
#line 171
                    header((char *)"NUT:  Food Suggestions");
#line 172
                    deficnuts = -1;
#line 173
                    totaldefic = (float )0;
#line 174
                    count = 0;
                    }
                    {
#line 174
                    while (1) {
                      while_continue___3: /* CIL Label */ ;
#line 174
                      if (! (count < DVMap[0])) {
#line 174
                        goto while_break___3;
                      }
#line 176
                      if (DVMap[count + 1] == 4) {
#line 185
                        deficpct[count] = (float )0;
                      } else
#line 176
                      if (DVMap[count + 1] == 1) {
#line 185
                        deficpct[count] = (float )0;
                      } else
#line 176
                      if (DVMap[count + 1] == 25) {
#line 185
                        deficpct[count] = (float )0;
                      } else
#line 176
                      if (DVMap[count + 1] == 84) {
#line 185
                        deficpct[count] = (float )0;
                      } else
#line 176
                      if (DVMap[count + 1] == 111) {
#line 185
                        deficpct[count] = (float )0;
                      } else
#line 176
                      if (DVMap[count + 1] == 112) {
#line 185
                        deficpct[count] = (float )0;
                      } else
#line 176
                      if (DVMap[count + 1] == 82) {
#line 185
                        deficpct[count] = (float )0;
                      } else
#line 176
                      if (DVMap[count + 1] == 152) {
#line 185
                        deficpct[count] = (float )0;
                      } else
#line 176
                      if (DVMap[count + 1] == 146) {
#line 185
                        deficpct[count] = (float )0;
                      } else
#line 176
                      if (DVMap[count + 1] == 155) {
#line 185
                        deficpct[count] = (float )0;
                      } else
#line 176
                      if (DVMap[count + 1] == 2) {
#line 185
                        deficpct[count] = (float )0;
                      } else
#line 176
                      if (DVMap[count + 1] == 148) {
#line 176
                        if ((double )DV[148] - 0.01 < .00001) {
#line 176
                          if ((double )DV[150] - 0.01 < .00001) {
#line 176
                            if ((double )DV[151] - 0.01 < .00001) {
#line 185
                              deficpct[count] = (float )0;
                            } else {
#line 176
                              goto _L___8;
                            }
                          } else {
#line 176
                            goto _L___8;
                          }
                        } else {
#line 176
                          goto _L___8;
                        }
                      } else
                      _L___8: /* CIL Label */ 
#line 176
                      if (DVMap[count + 1] == 150) {
#line 176
                        if ((double )DV[148] - 0.01 < .00001) {
#line 176
                          if ((double )DV[150] - 0.01 < .00001) {
#line 176
                            if ((double )DV[151] - 0.01 < .00001) {
#line 185
                              deficpct[count] = (float )0;
                            } else {
#line 176
                              goto _L___5;
                            }
                          } else {
#line 176
                            goto _L___5;
                          }
                        } else {
#line 176
                          goto _L___5;
                        }
                      } else
                      _L___5: /* CIL Label */ 
#line 176
                      if (DVMap[count + 1] == 151) {
#line 176
                        if ((double )DV[148] - 0.01 < .00001) {
#line 176
                          if ((double )DV[150] - 0.01 < .00001) {
#line 176
                            if ((double )DV[151] - 0.01 < .00001) {
#line 185
                              deficpct[count] = (float )0;
                            } else {
#line 176
                              goto _L___2;
                            }
                          } else {
#line 176
                            goto _L___2;
                          }
                        } else {
#line 176
                          goto _L___2;
                        }
                      } else
                      _L___2: /* CIL Label */ 
#line 176
                      if ((double )(food_work.nutrient[DVMap[count + 1]] / DV[DVMap[count + 1]]) >= .9999) {
#line 185
                        deficpct[count] = (float )0;
                      } else {
#line 188
                        deficnuts ++;
#line 189
                        deficnut[deficnuts] = count;
#line 190
                        deficpct[deficnuts] = (((float )max / (float )options.mealsperday) * (float )100) * ((float )1 - food_work.nutrient[DVMap[count + 1]] / DV[DVMap[count + 1]]);
#line 191
                        totaldefic += deficpct[deficnuts];
                      }
#line 174
                      count ++;
                    }
                    while_break___3: /* CIL Label */ ;
                    }
#line 194
                    if (deficnuts > 0) {
                      {
#line 194
                      deficsort(deficpct, deficnut, deficnuts);
                      }
                    }
#line 195
                    if (deficnuts == -1) {
                      {
#line 197
                      printf((char const   */* __restrict  */)"You have achieved the \"Daily Value\" for all nutrients.");
#line 198
                      spacer(0);
#line 199
                      printf((char const   */* __restrict  */)"\nPress <enter> to continue...");
#line 200
                      count = get_int();
                      }
                    } else
#line 195
                    if (deficpct[0] == (float )0) {
                      {
#line 197
                      printf((char const   */* __restrict  */)"You have achieved the \"Daily Value\" for all nutrients.");
#line 198
                      spacer(0);
#line 199
                      printf((char const   */* __restrict  */)"\nPress <enter> to continue...");
#line 200
                      count = get_int();
                      }
                    } else {
                      {
#line 204
                      printf((char const   */* __restrict  */)"Here are nutrients with additional daily percentages in the \"Daily Values\":\n\n");
#line 205
                      spacecount = 0;
#line 206
                      count = 0;
                      }
                      {
#line 206
                      while (1) {
                        while_continue___4: /* CIL Label */ ;
#line 206
                        if (! (count <= deficnuts)) {
#line 206
                          goto while_break___4;
                        }
#line 208
                        if (totaldefic >= (float )1) {
                          {
#line 208
                          printf((char const   */* __restrict  */)"%-29s%-15s %6.0f%%\n",
                                 " ", Nutrient[DVMap[deficnut[count] + 1]], (double )deficpct[count]);
                          }
                        } else {
                          {
#line 209
                          printf((char const   */* __restrict  */)"%-29s%-15s %f%%\n",
                                 " ", Nutrient[DVMap[deficnut[count] + 1]], (double )deficpct[count]);
                          }
                        }
#line 210
                        if (deficnuts > count) {
#line 210
                          if (count == 16) {
                            {
#line 210
                            printf((char const   */* __restrict  */)"%-29s%-23s\n",
                                   " ", "plus additional nutrients...");
                            }
                          }
                        }
#line 211
                        if (deficnuts > count) {
#line 211
                          if (count == 16) {
#line 211
                            goto while_break___4;
                          }
                        }
#line 206
                        count ++;
                      }
                      while_break___4: /* CIL Label */ ;
                      }
                      {
#line 213
                      spacer(deficnuts + 3);
#line 214
                      printf((char const   */* __restrict  */)"\nPress <enter> to continue...");
#line 215
                      count = get_int();
#line 216
                      header((char *)"NUT:  Food Suggestions");
#line 217
                      printf((char const   */* __restrict  */)"Here are randomly selected foods that provide the additional nutrients noted:\n\n");
#line 218
                      frcount = -1;
                      }
                      {
#line 219
                      while (1) {
                        while_continue___5: /* CIL Label */ ;
#line 219
                        if (! (totaldefic > (float )0)) {
#line 219
                          goto while_break___5;
                        }
#line 221
                        food_ptr = & food_root;
#line 222
                        abacuscount = -1;
                        {
#line 223
                        while (1) {
                          while_continue___6: /* CIL Label */ ;
#line 223
                          if (! ((unsigned long )food_ptr->next != (unsigned long )((void *)0))) {
#line 223
                            goto while_break___6;
                          }
#line 225
                          food_ptr = food_ptr->next;
#line 226
                          abacuscount ++;
#line 226
                          food_ptr_abacus[abacuscount] = food_ptr;
#line 227
                          prodefic = (float )0;
#line 228
                          serving_ratio_abacus[abacuscount] = (float )10;
#line 229
                          high_grams = 114;
#line 230
                          count = 0;
                          {
#line 230
                          while (1) {
                            while_continue___7: /* CIL Label */ ;
#line 230
                            if (! (count <= deficnuts)) {
#line 230
                              goto while_break___7;
                            }
#line 232
                            thispct = ((float )100 * food_ptr->nutrient[DVMap[deficnut[count] + 1]]) / DV[DVMap[deficnut[count] + 1]];
#line 233
                            serving_ratio = deficpct[count] / thispct;
#line 234
                            if (serving_ratio < serving_ratio_abacus[abacuscount]) {
#line 234
                              if (serving_ratio * food_ptr->grams > (float )14) {
#line 234
                                serving_ratio_abacus[abacuscount] = serving_ratio;
                              }
                            }
#line 230
                            count ++;
                          }
                          while_break___7: /* CIL Label */ ;
                          }
                          {
#line 242
                          tmp___3 = strstr((char const   *)(food_ptr->name), "DRY");
                          }
#line 242
                          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 242
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 243
                          tmp___4 = strstr((char const   *)(food_ptr->name), "FREEZE-DRIED");
                          }
#line 243
                          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 243
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 244
                          tmp___5 = strstr((char const   *)(food_ptr->name), "DEHYD");
                          }
#line 244
                          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 244
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 245
                          tmp___6 = strstr((char const   *)(food_ptr->name), "ALASKA NATIVE");
                          }
#line 245
                          if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 245
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 246
                          tmp___7 = strstr((char const   *)(food_ptr->name), "AK NATIVE");
                          }
#line 246
                          if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 246
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 247
                          tmp___8 = strstr((char const   *)(food_ptr->name), "NAVAJO");
                          }
#line 247
                          if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 247
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 248
                          tmp___9 = strstr((char const   *)(food_ptr->name), "SHOSHONE BANNOCK");
                          }
#line 248
                          if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 248
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 249
                          tmp___10 = strstr((char const   *)(food_ptr->name), "PACIFIC NORTHWEST INDIANS");
                          }
#line 249
                          if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 249
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 250
                          tmp___11 = strstr((char const   *)(food_ptr->name), "INST BRKFST PDR");
                          }
#line 250
                          if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
#line 250
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 251
                          tmp___12 = strstr((char const   *)(food_ptr->name), "INSTANT BREAKFAST");
                          }
#line 251
                          if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
#line 251
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 252
                          tmp___13 = strstr((char const   *)(food_ptr->name), "ENSURE");
                          }
#line 252
                          if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
#line 252
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 253
                          tmp___14 = strstr((char const   *)(food_ptr->name), "PROTEIN SUPPLEMENT");
                          }
#line 253
                          if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
#line 253
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 254
                          tmp___15 = strstr((char const   *)(food_ptr->name), "SOY PROTEIN ISOLATE");
                          }
#line 254
                          if ((unsigned long )tmp___15 != (unsigned long )((void *)0)) {
#line 254
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 255
                          tmp___16 = strstr((char const   *)(food_ptr->name), "SOY PROTEIN CONC");
                          }
#line 255
                          if ((unsigned long )tmp___16 != (unsigned long )((void *)0)) {
#line 255
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 256
                          tmp___17 = strstr((char const   *)(food_ptr->name), "MEAT EXTENDER");
                          }
#line 256
                          if ((unsigned long )tmp___17 != (unsigned long )((void *)0)) {
#line 256
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 257
                          tmp___18 = strstr((char const   *)(food_ptr->name), "VITAMIN AND MINERAL FORTIFIED");
                          }
#line 257
                          if ((unsigned long )tmp___18 != (unsigned long )((void *)0)) {
#line 257
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 258
                          tmp___19 = strstr((char const   *)(food_ptr->name), "EGG MIX,USDA COMMODITY");
                          }
#line 258
                          if ((unsigned long )tmp___19 != (unsigned long )((void *)0)) {
#line 258
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 259
                          tmp___20 = strstr((char const   *)(food_ptr->name), "INDUSTRIAL");
                          }
#line 259
                          if ((unsigned long )tmp___20 != (unsigned long )((void *)0)) {
#line 259
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 260
                          tmp___21 = strstr((char const   *)(food_ptr->name), "MEATLESS");
                          }
#line 260
                          if ((unsigned long )tmp___21 != (unsigned long )((void *)0)) {
#line 260
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
                          {
#line 261
                          tmp___22 = strstr((char const   *)(food_ptr->name), "MARGARINE");
                          }
#line 261
                          if ((unsigned long )tmp___22 != (unsigned long )((void *)0)) {
#line 261
                            high_grams = 14;
                          }
#line 262
                          if (food_ptr->fdgrp == 2) {
#line 262
                            serving_ratio_abacus[abacuscount] = (float )0;
                          } else
#line 262
                          if (food_ptr->fdgrp == 3) {
#line 262
                            serving_ratio_abacus[abacuscount] = (float )0;
                          } else
#line 262
                          if (food_ptr->fdgrp == 8) {
#line 262
                            serving_ratio_abacus[abacuscount] = (float )0;
                          } else
#line 262
                          if (food_ptr->fdgrp == 14) {
#line 262
                            serving_ratio_abacus[abacuscount] = (float )0;
                          } else
#line 262
                          if (food_ptr->fdgrp == 19) {
#line 262
                            serving_ratio_abacus[abacuscount] = (float )0;
                          } else
#line 262
                          if (food_ptr->fdgrp == 25) {
#line 262
                            serving_ratio_abacus[abacuscount] = (float )0;
                          }
#line 263
                          if (serving_ratio_abacus[abacuscount] > (float )1) {
#line 263
                            if (high_grams == 114) {
#line 263
                              serving_ratio_abacus[abacuscount] = (float )1;
                            }
                          }
#line 264
                          if (serving_ratio_abacus[abacuscount] * food_ptr->grams > (float )high_grams) {
#line 264
                            serving_ratio_abacus[abacuscount] = (float )high_grams / food_ptr->grams;
                          }
#line 265
                          count = 0;
                          {
#line 265
                          while (1) {
                            while_continue___8: /* CIL Label */ ;
#line 265
                            if (! (count <= deficnuts)) {
#line 265
                              goto while_break___8;
                            }
#line 267
                            thispct = ((serving_ratio_abacus[abacuscount] * food_ptr->grams) * food_ptr->nutrient[DVMap[deficnut[count] + 1]]) / DV[DVMap[deficnut[count] + 1]];
#line 268
                            if (thispct > deficpct[count]) {
#line 268
                              thispct = deficpct[count];
                            }
#line 269
                            prodefic += thispct;
#line 265
                            count ++;
                          }
                          while_break___8: /* CIL Label */ ;
                          }
#line 271
                          if (serving_ratio_abacus[abacuscount] == (float )0) {
#line 271
                            prodefic = (float )0;
                          }
#line 272
                          food_abacus[abacuscount] = prodefic;
#line 273
                          count = 0;
                          {
#line 273
                          while (1) {
                            while_continue___9: /* CIL Label */ ;
#line 273
                            if (! (count <= frcount)) {
#line 273
                              goto while_break___9;
                            }
#line 273
                            if ((unsigned long )food_ptr_abacus[abacuscount] == (unsigned long )food_recommended[count]) {
#line 273
                              food_abacus[abacuscount] = (float )-1;
                            }
#line 273
                            count ++;
                          }
                          while_break___9: /* CIL Label */ ;
                          }
                        }
                        while_break___6: /* CIL Label */ ;
                        }
                        {
#line 275
                        abacuscount = random_max_var_array(food_abacus, abacuscount);
#line 276
                        food_ptr = food_ptr_abacus[abacuscount];
#line 277
                        frcount ++;
#line 277
                        food_recommended[frcount] = food_ptr;
#line 278
                        printf((char const   */* __restrict  */)"%4.0f gm or %4.1f oz %-60s\n",
                               (double )(serving_ratio_abacus[abacuscount] * food_ptr->grams),
                               (double )(serving_ratio_abacus[abacuscount] * food_ptr->grams) / 28.349523,
                               food_ptr->name);
#line 279
                        spacecount ++;
                        }
#line 280
                        if (spacecount == 19) {
#line 280
                          goto while_break___5;
                        }
#line 281
                        totaldefic = (float )0;
#line 282
                        count = 0;
                        {
#line 282
                        while (1) {
                          while_continue___10: /* CIL Label */ ;
#line 282
                          if (! (count <= deficnuts)) {
#line 282
                            goto while_break___10;
                          }
#line 284
                          thispct = ((serving_ratio_abacus[abacuscount] * food_ptr->grams) * food_ptr->nutrient[DVMap[deficnut[count] + 1]]) / DV[DVMap[deficnut[count] + 1]];
#line 285
                          if (thispct > deficpct[count]) {
#line 285
                            thispct = deficpct[count];
                          }
#line 286
                          deficpct[count] -= thispct;
#line 287
                          totaldefic += deficpct[count];
#line 282
                          count ++;
                        }
                        while_break___10: /* CIL Label */ ;
                        }
                      }
                      while_break___5: /* CIL Label */ ;
                      }
                      {
#line 290
                      spacecount ++;
#line 290
                      spacer(spacecount);
#line 291
                      printf((char const   */* __restrict  */)"Press <enter> to continue...");
#line 292
                      count = get_int();
                      }
                    }
                  } else {
                    {
#line 297
                    max = atoi((char const   *)(inbuf));
                    }
#line 298
                    if (max > 0) {
#line 298
                      options.defanal = max;
                    }
#line 299
                    if (options.defanal == mealcount) {
#line 299
                      options.defanal = 0;
                    }
#line 300
                    if (specialheader) {
#line 300
                      options.defanalrec = options.defanal;
                    }
#line 301
                    if (! specialheader) {
#line 301
                      options.defanalanal = options.defanal;
                    }
                    {
#line 302
                    write_OPTIONS();
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return;
}
}
#line 307 "/home/wheatley/newnew/temp/nut-nutrition-15.5/anameal.c"
void deficsort(float *deficpct , int *deficnut , int deficnuts ) 
{ 
  int count ;
  int subcount ;
  int tempint ;
  float tempfloat ;

  {
#line 311
  count = 0;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! (count < deficnuts)) {
#line 311
      goto while_break;
    }
#line 313
    subcount = count + 1;
    {
#line 313
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 313
      if (! (subcount <= deficnuts)) {
#line 313
        goto while_break___0;
      }
#line 315
      if (*(deficpct + subcount) > *(deficpct + count)) {
#line 317
        tempfloat = *(deficpct + count);
#line 318
        *(deficpct + count) = *(deficpct + subcount);
#line 319
        *(deficpct + subcount) = tempfloat;
#line 320
        tempint = *(deficnut + count);
#line 321
        *(deficnut + count) = *(deficnut + subcount);
#line 322
        *(deficnut + subcount) = tempint;
      }
#line 313
      subcount ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 311
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  return;
}
}
#line 328 "/home/wheatley/newnew/temp/nut-nutrition-15.5/anameal.c"
int random_max_var_array(float *abacus , int last ) 
{ 
  int count ;
  int i ;
  int max_count ;
  int rand_count ;
  unsigned int seed ;
  time_t t ;
  int tmp ;

  {
#line 330
  i = 0;
#line 330
  max_count = 1;
#line 333
  count = 1;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (count < last)) {
#line 333
      goto while_break;
    }
#line 335
    if (*(abacus + count) > *(abacus + i)) {
#line 337
      i = count;
#line 338
      max_count = 1;
    } else
#line 340
    if (*(abacus + count) == *(abacus + i)) {
#line 340
      max_count ++;
    }
#line 333
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 342
  time(& t);
#line 343
  seed = (unsigned int )t;
#line 344
  srand(seed);
#line 345
  tmp = rand();
#line 345
  rand_count = tmp % max_count;
#line 346
  count = 0;
  }
  {
#line 346
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 346
    if (! (count < last)) {
#line 346
      goto while_break___0;
    }
#line 348
    if (*(abacus + count) == *(abacus + i)) {
#line 348
      rand_count --;
    }
#line 349
    if (rand_count < 0) {
#line 349
      return (count);
    }
#line 346
    count ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 351
  return (i);
}
}
#line 538 "/usr/include/stdio.h"
extern int getchar(void) ;
#line 29 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.h"
float get_float(void) ;
#line 34
void get_select(float *result ) ;
#line 52 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
int wjl_isnan(float x ) 
{ 
  void *tmp ;
  wjl_ieee754_float_t_be *f ;
  int tmp___0 ;

  {
#line 53
  tmp = (void *)(& x);
#line 54
  f = (wjl_ieee754_float_t_be *)tmp;
#line 55
  if (f->exponent != 255U) {
#line 55
    if (f->mantissa == 0U) {
#line 55
      tmp___0 = 1;
    } else {
#line 55
      tmp___0 = 0;
    }
  } else {
#line 55
    tmp___0 = 0;
  }
#line 55
  return (tmp___0);
}
}
#line 59 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
int wjl_isinf(float x ) 
{ 
  void *tmp ;
  wjl_ieee754_float_t_be *f ;
  unsigned int tmp___0 ;

  {
#line 60
  tmp = (void *)(& x);
#line 61
  f = (wjl_ieee754_float_t_be *)tmp;
#line 62
  tmp___0 = 255U;
#line 62
  f->exponent = tmp___0;
#line 62
  if (tmp___0) {
#line 62
    if (f->mantissa == 0U) {
#line 63
      if (f->sign == 0U) {
#line 63
        return (1);
      } else {
#line 64
        return (-1);
      }
    }
  }
#line 66
  return (0);
}
}
#line 70 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
int wjl_iszero(float x ) 
{ 
  void *tmp ;
  wjl_ieee754_float_t_be *f ;

  {
#line 71
  tmp = (void *)(& x);
#line 72
  f = (wjl_ieee754_float_t_be *)tmp;
#line 73
  if (f->exponent == 0U) {
#line 73
    if (f->mantissa == 0U) {
#line 74
      if (f->sign == 0U) {
#line 74
        return (1);
      } else {
#line 75
        return (-1);
      }
    }
  }
#line 77
  return (0);
}
}
#line 81 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
int wjl_isfinite(float x ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 82
  tmp = wjl_isnan(x);
  }
#line 82
  if (tmp) {
#line 82
    tmp___1 = 0;
  } else {
    {
#line 82
    tmp___0 = wjl_isinf(x);
    }
#line 82
    if (tmp___0) {
#line 82
      tmp___1 = 0;
    } else {
#line 82
      tmp___1 = 1;
    }
  }
#line 82
  return (tmp___1);
}
}
#line 85 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
int signsense  ;
#line 86 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
char KeyArray[960]  ;
#line 87 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
char *Key[8]  = 
#line 87
  {      KeyArray,      KeyArray + 120,      KeyArray + 240,      KeyArray + 360, 
        KeyArray + 480,      KeyArray + 600,      KeyArray + 720,      KeyArray + 840};
#line 89 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
int get_char(void) 
{ 
  int ch ;
  int junk ;

  {
  {
#line 93
  ch = getchar();
  }
#line 94
  if (ch == 10) {
#line 94
    return (ch);
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 95
    junk = getchar();
    }
#line 95
    if (! (junk != 10)) {
#line 95
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  return (ch);
}
}
#line 99 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
void get_qty(float *result , float *grams , float *calories ) 
{ 
  char buff[128] ;
  float lastresult ;
  float dividend ;
  float divisor ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  char *tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
#line 102
  lastresult = *result;
#line 104
  if (lastresult <= (float )0) {
#line 104
    lastresult = (float )1;
  }
  {
#line 105
  printf((char const   */* __restrict  */)"\n# servings, #g grams, #o oz, #c calories, \"b\" back, \"d\" alt:  ");
#line 106
  fgets((char */* __restrict  */)(buff), 128, (FILE */* __restrict  */)stdin);
#line 107
  tmp___15 = strchr((char const   *)(buff), 'g');
  }
#line 107
  if ((unsigned long )tmp___15 != (unsigned long )((void *)0)) {
    {
#line 109
    tmp = atof((char const   *)(buff));
#line 109
    *result = (float )(tmp / (double )*grams);
#line 110
    options.grams = (char)1;
    }
  } else {
    {
#line 112
    tmp___14 = strchr((char const   *)(buff), 'o');
    }
#line 112
    if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
      {
#line 114
      tmp___0 = atof((char const   *)(buff));
#line 114
      *result = (float )((tmp___0 * 28.349523) / (double )*grams);
#line 115
      options.grams = (char)0;
      }
    } else {
      {
#line 117
      tmp___13 = strchr((char const   *)(buff), 'c');
      }
#line 117
      if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
        {
#line 117
        tmp___1 = atof((char const   *)(buff));
#line 117
        *result = (float )(((tmp___1 * (double )100) / (double )*grams) / (double )*calories);
        }
      } else {
        {
#line 118
        tmp___11 = strchr((char const   *)(buff), 'b');
        }
#line 118
        if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
#line 118
          *result = (float )-383838;
        } else {
          {
#line 118
          tmp___12 = strchr((char const   *)(buff), 'B');
          }
#line 118
          if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
#line 118
            *result = (float )-383838;
          } else {
            {
#line 119
            tmp___9 = strchr((char const   *)(buff), 'd');
            }
#line 119
            if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
              {
#line 119
              screen();
#line 119
              *result = lastresult;
              }
            } else {
              {
#line 119
              tmp___10 = strchr((char const   *)(buff), 'D');
              }
#line 119
              if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
                {
#line 119
                screen();
#line 119
                *result = lastresult;
                }
              } else {
                {
#line 120
                tmp___7 = strchr((char const   *)(buff), 'p');
                }
#line 120
                if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
                  {
#line 120
                  screen_previous();
#line 120
                  *result = lastresult;
                  }
                } else {
                  {
#line 120
                  tmp___8 = strchr((char const   *)(buff), 'P');
                  }
#line 120
                  if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
                    {
#line 120
                    screen_previous();
#line 120
                    *result = lastresult;
                    }
                  } else {
                    {
#line 121
                    tmp___6 = strchr((char const   *)(buff), '/');
                    }
#line 121
                    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
                      {
#line 123
                      tmp___2 = atof((char const   *)(buff));
#line 123
                      dividend = (float )tmp___2;
#line 124
                      tmp___3 = strchr((char const   *)(buff), '/');
#line 124
                      tmp___4 = atof((char const   *)(tmp___3 + 1));
#line 124
                      divisor = (float )tmp___4;
#line 125
                      *result = dividend / divisor;
                      }
                    } else {
                      {
#line 127
                      tmp___5 = atof((char const   *)(buff));
#line 127
                      *result = (float )tmp___5;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 128
  write_OPTIONS();
  }
#line 129
  return;
}
}
#line 131 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
float evaluate_qty(struct food *food_ptr , char *qtystring ) 
{ 
  float dividend ;
  float divisor ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  char *tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 134
  if ((unsigned long )qtystring == (unsigned long )((void *)0)) {
#line 134
    return ((float )0);
  }
  {
#line 135
  tmp___9 = strchr((char const   *)qtystring, 'g');
  }
#line 135
  if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
    {
#line 137
    options.grams = (char)1;
#line 138
    tmp = atof((char const   *)qtystring);
    }
#line 138
    return ((float )tmp);
  } else {
    {
#line 140
    tmp___8 = strchr((char const   *)qtystring, 'o');
    }
#line 140
    if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
      {
#line 142
      options.grams = (char)0;
#line 143
      tmp___0 = atof((char const   *)qtystring);
      }
#line 143
      return ((float )(tmp___0 * 28.349523));
    } else {
      {
#line 145
      tmp___7 = strchr((char const   *)qtystring, 'c');
      }
#line 145
      if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
        {
#line 145
        tmp___1 = atof((char const   *)qtystring);
        }
#line 145
        return ((float )((tmp___1 * (double )100) / (double )food_ptr->nutrient[4]));
      } else {
        {
#line 146
        tmp___6 = strchr((char const   *)qtystring, '/');
        }
#line 146
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
          {
#line 148
          tmp___2 = atof((char const   *)qtystring);
#line 148
          dividend = (float )tmp___2;
#line 149
          tmp___3 = strchr((char const   *)qtystring, '/');
#line 149
          tmp___4 = atof((char const   *)(tmp___3 + 1));
#line 149
          divisor = (float )tmp___4;
          }
#line 150
          return ((food_ptr->grams * dividend) / divisor);
        } else {
          {
#line 152
          tmp___5 = atof((char const   *)qtystring);
          }
#line 152
          return ((float )(tmp___5 * (double )food_ptr->grams));
        }
      }
    }
  }
  {
#line 153
  write_OPTIONS();
  }
}
}
#line 156 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
int evaluate_action(char *actionstring ) 
{ 
  int newpos ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 159
  tmp___3 = strchr((char const   *)actionstring, '(');
  }
#line 159
  if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 159
    return (-1);
  } else {
    {
#line 160
    tmp___2 = strchr((char const   *)actionstring, ')');
    }
#line 160
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 160
      return (-2);
    } else {
      {
#line 161
      tmp___1 = strchr((char const   *)actionstring, '!');
      }
#line 161
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 161
        return (-3);
      } else {
        {
#line 162
        tmp___0 = strchr((char const   *)actionstring, 'm');
        }
#line 162
        if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
          {
#line 164
          tmp = strchr((char const   *)actionstring, 'm');
#line 164
          newpos = atoi((char const   *)(tmp + 1));
          }
#line 165
          if (newpos < 1) {
#line 165
            newpos = 1;
          }
#line 166
          return (newpos);
        } else {
#line 168
          return (0);
        }
      }
    }
  }
}
}
#line 171 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
void get_select(float *result ) 
{ 
  char buff[128] ;
  float lastresult ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 174
  lastresult = *result;
#line 175
  if (lastresult <= (float )0) {
#line 175
    lastresult = (float )1;
  }
  {
#line 176
  printf((char const   */* __restrict  */)"\n\"b\" to go back, <enter> to select:  ");
#line 177
  fgets((char */* __restrict  */)(buff), 128, (FILE */* __restrict  */)stdin);
#line 178
  tmp = strchr((char const   *)(buff), 'b');
  }
#line 178
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 178
    *result = (float )-383838;
  } else {
    {
#line 178
    tmp___0 = strchr((char const   *)(buff), 'B');
    }
#line 178
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 178
      *result = (float )-383838;
    } else {
#line 179
      *result = (float )0;
    }
  }
#line 180
  return;
}
}
#line 182 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
int get_int(void) 
{ 
  char buff[128] ;
  int tmp ;

  {
  {
#line 185
  fgets((char */* __restrict  */)(buff), 128, (FILE */* __restrict  */)stdin);
#line 186
  tmp = atoi((char const   *)(buff));
  }
#line 186
  return (tmp);
}
}
#line 189 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
float get_float(void) 
{ 
  char buff[128] ;
  double tmp ;

  {
  {
#line 192
  fgets((char */* __restrict  */)(buff), 128, (FILE */* __restrict  */)stdin);
#line 193
  tmp = atof((char const   *)(buff));
  }
#line 193
  return ((float )tmp);
}
}
#line 196 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
void get_string(char *dest , int length ) 
{ 
  char temp[128] ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 199
  fgets((char */* __restrict  */)(temp), 128, (FILE */* __restrict  */)stdin);
#line 200
  tmp___0 = strchr((char const   *)(temp), '\n');
  }
#line 200
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 200
    tmp = strchr((char const   *)(temp), '\n');
#line 200
    *tmp = (char )'\000';
    }
  } else {
#line 201
    length = 0;
  }
  {
#line 202
  strncpy((char */* __restrict  */)dest, (char const   */* __restrict  */)(temp),
          (size_t )length);
#line 203
  *(dest + length) = (char )'\000';
  }
#line 204
  return;
}
}
#line 206 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
void header(char *string ) 
{ 
  char buffer[81] ;
  int count ;
  size_t size ;
  size_t tmp ;

  {
  {
#line 210
  size = (size_t )80;
#line 211
  tmp = strlen((char const   *)string);
#line 211
  size -= tmp;
#line 212
  size /= 2UL;
#line 213
  count = 0;
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! ((size_t )count < size)) {
#line 213
      goto while_break;
    }
#line 213
    buffer[count] = (char )' ';
#line 213
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  buffer[count] = (char )'\000';
#line 216
  if ((int )subuser[0] != 0) {
    {
#line 216
    printf((char const   */* __restrict  */)"\033[2J%s%s\n[DB] %s\n", buffer, string,
           subuser);
    }
  } else {
    {
#line 217
    printf((char const   */* __restrict  */)"\033[2J%s%s\n\n", buffer, string);
    }
  }
#line 222
  return;
}
}
#line 224 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
void spacer(int lines ) 
{ 


  {
#line 226
  lines = 20 - lines;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (lines > 0)) {
#line 227
      goto while_break;
    }
    {
#line 227
    printf((char const   */* __restrict  */)"\n");
#line 227
    lines --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return;
}
}
#line 230 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
void key_clean(void) 
{ 
  int i ;

  {
#line 233
  i = 0;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (i < 8)) {
#line 233
      goto while_break;
    }
    {
#line 233
    strcpy((char */* __restrict  */)Key[i], (char const   */* __restrict  */)"");
#line 233
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 236 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
void key_put(char *key___0 ) 
{ 
  int i ;

  {
#line 239
  i = 6;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! (i >= 0)) {
#line 239
      goto while_break;
    }
    {
#line 239
    strcpy((char */* __restrict  */)Key[i + 1], (char const   */* __restrict  */)Key[i]);
#line 239
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 240
  strcpy((char */* __restrict  */)Key[0], (char const   */* __restrict  */)key___0);
  }
#line 241
  return;
}
}
#line 243 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
void key_encode(char *substring , char *key___0 ) 
{ 
  int i ;

  {
#line 246
  i = 6;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (i >= 0)) {
#line 246
      goto while_break;
    }
    {
#line 246
    strcpy((char */* __restrict  */)Key[i + 1], (char const   */* __restrict  */)Key[i]);
#line 246
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 247
  strncpy((char */* __restrict  */)Key[0], (char const   */* __restrict  */)substring,
          (size_t )59);
#line 248
  strncat((char */* __restrict  */)Key[0], (char const   */* __restrict  */)"\001",
          (size_t )60);
#line 249
  strncat((char */* __restrict  */)Key[0], (char const   */* __restrict  */)key___0,
          (size_t )120);
  }
#line 250
  return;
}
}
#line 254 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
static char key[121]  ;
#line 252 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
char *key_take(void) 
{ 
  int i ;

  {
  {
#line 256
  strcpy((char */* __restrict  */)(key), (char const   */* __restrict  */)Key[0]);
#line 257
  i = 0;
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! (i < 7)) {
#line 257
      goto while_break;
    }
    {
#line 257
    strcpy((char */* __restrict  */)Key[i], (char const   */* __restrict  */)Key[i + 1]);
#line 257
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 258
  strcpy((char */* __restrict  */)Key[7], (char const   */* __restrict  */)"");
  }
#line 259
  return (key);
}
}
#line 262 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
void key_decode(char *substring , char *key___0 ) 
{ 
  int i ;
  char *pos ;

  {
  {
#line 266
  pos = strchr((char const   *)Key[0], '\001');
  }
#line 267
  if ((unsigned long )pos != (unsigned long )((void *)0)) {
    {
#line 269
    strcpy((char */* __restrict  */)key___0, (char const   */* __restrict  */)(pos + 1));
#line 270
    *pos = (char )'\000';
#line 271
    strcpy((char */* __restrict  */)substring, (char const   */* __restrict  */)Key[0]);
    }
  }
#line 273
  if ((unsigned long )pos == (unsigned long )((void *)0)) {
#line 273
    *key___0 = (char )'\000';
  }
  {
#line 274
  strcpy((char */* __restrict  */)substring, (char const   */* __restrict  */)Key[0]);
#line 275
  i = 0;
  }
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! (i < 7)) {
#line 275
      goto while_break;
    }
    {
#line 275
    strcpy((char */* __restrict  */)Key[i], (char const   */* __restrict  */)Key[i + 1]);
#line 275
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  strcpy((char */* __restrict  */)Key[7], (char const   */* __restrict  */)"");
  }
#line 277
  return;
}
}
#line 279 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
void test_signsense(float *value ) 
{ 
  wjl_ieee754_float_t_be *f ;

  {
#line 281
  f = (wjl_ieee754_float_t_be *)value;
#line 282
  signsense = (int )f->sign;
#line 283
  return;
}
}
#line 285 "/home/wheatley/newnew/temp/nut-nutrition-15.5/util.c"
int test_for_negative_zero(float *value ) 
{ 
  wjl_ieee754_float_t_be *f ;

  {
#line 286
  f = (wjl_ieee754_float_t_be *)value;
#line 287
  if (*value != (float )0) {
#line 287
    return (0);
  } else
#line 288
  if (f->sign != (unsigned int )signsense) {
#line 288
    return (0);
  } else {
#line 289
    return (1);
  }
}
}
#line 25 "/home/wheatley/newnew/temp/nut-nutrition-15.5/recmeal.h"
void record_meals(void) ;
#line 26
void today(char *whatever ) ;
#line 27
void time_machine(char *whatever ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 261
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) asctime)(struct tm  const  *__tp ) ;
#line 34 "/home/wheatley/newnew/temp/nut-nutrition-15.5/recmeal.c"
void record_meals(void) 
{ 
  struct food *food_ptr ;
  struct meal *meal_ptr ;
  char meal_date[9] ;
  char new_meal_date[9] ;
  char theusual_id[9] ;
  char substring[61] ;
  char buff[61] ;
  char key___0[61] ;
  char *token ;
  int meal ;
  int modfood ;
  int junk ;
  float ratio ;
  float one ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  struct meal *tmp___2 ;
  struct meal *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct meal *tmp___6 ;
  struct meal *tmp___7 ;
  struct meal *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  struct meal *tmp___12 ;
  struct meal *tmp___13 ;
  char *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;

  {
  {
#line 45
  meal = 0;
#line 46
  ratio = (float )0;
#line 46
  one = (float )1;
#line 47
  key___0[0] = (char )'\000';
#line 48
  today(meal_date);
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 51
    header((char *)"NUT:  Record Meals");
#line 52
    printf((char const   */* __restrict  */)"\n\n\n\n\n\nMeal Date:    %s\n\n", meal_date);
#line 53
    spacer(8);
#line 54
    printf((char const   */* __restrict  */)"\nType meal date (yyyymmdd) or just press <enter> for today\'s date:  ");
#line 55
    get_string(new_meal_date, 8);
    }
#line 56
    if ((int )new_meal_date[0] == 45) {
      {
#line 56
      time_machine(new_meal_date);
      }
    } else
#line 56
    if ((int )new_meal_date[0] == 43) {
      {
#line 56
      time_machine(new_meal_date);
      }
    }
    {
#line 57
    tmp = strlen((char const   *)(new_meal_date));
    }
#line 57
    if (tmp == 8UL) {
      {
#line 57
      strcpy((char */* __restrict  */)(meal_date), (char const   */* __restrict  */)(new_meal_date));
      }
    }
    {
#line 58
    tmp___0 = strlen((char const   *)(new_meal_date));
    }
#line 58
    if (tmp___0 == 8UL) {
#line 58
      goto while_break;
    } else {
      {
#line 58
      tmp___1 = strlen((char const   *)(new_meal_date));
      }
#line 58
      if (tmp___1 == 0UL) {
#line 58
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  if (options.mealsperday > 1) {
    {
#line 62
    header((char *)"NUT:  Record Meals");
#line 63
    printf((char const   */* __restrict  */)"\n\n\n\n\n\nMeal Date:    %s\n\n", meal_date);
#line 64
    printf((char const   */* __restrict  */)"Meal Number:\n\n\n\n");
#line 65
    meal_list(meal_date);
#line 66
    spacer(15);
#line 67
    printf((char const   */* __restrict  */)"\nType meal number (1 to %d) or just <enter> to quit:  ",
           options.mealsperday);
#line 68
    meal = get_int();
    }
#line 69
    if (meal < 1) {
#line 69
      return;
    } else
#line 69
    if (meal > options.mealsperday) {
#line 69
      return;
    }
  }
#line 71
  if (options.mealsperday == 1) {
#line 71
    meal = 1;
  }
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 74
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 76
      if (ratio != (float )-383838) {
        {
#line 76
        tmp___6 = meal_find(meal_date, meal);
        }
#line 76
        if ((unsigned long )tmp___6 != (unsigned long )((struct meal *)0)) {
          {
#line 78
          header((char *)"NUT:  Record Meals");
#line 79
          tmp___5 = meal_show(meal_date, meal);
          }
#line 79
          if (tmp___5) {
            {
#line 86
            printf((char const   */* __restrict  */)"\nEnter food name, # to del/chg, \".\" to analyze:  ");
#line 87
            get_string(key___0, 60);
#line 88
            tmp___4 = strcmp((char const   *)(key___0), "");
            }
#line 88
            if (tmp___4 == 0) {
              {
#line 90
              delete_meals(options.delopt);
#line 91
              tmp___3 = meal_find(meal_date, meal);
              }
#line 91
              if ((unsigned long )tmp___3 != (unsigned long )((struct meal *)0)) {
                {
#line 91
                tmp___2 = meal_find(meal_date, meal);
#line 91
                options.temp_meal_root = prev_meal(tmp___2);
                }
              }
#line 92
              return;
            }
          } else {
            {
#line 81
            printf((char const   */* __restrict  */)"\nPress <enter> to continue...");
#line 82
            junk = get_int();
            }
          }
        }
      }
      {
#line 96
      tmp___10 = strcmp((char const   *)(key___0), ".");
      }
#line 96
      if (tmp___10 == 0) {
        {
#line 96
        tmp___7 = meal_find(meal_date, meal);
#line 96
        tmp___8 = prev_meal(tmp___7);
#line 96
        analyze_meals(tmp___8, 1);
        }
      } else {
        {
#line 96
        tmp___11 = strcmp((char const   *)(key___0), ",");
        }
#line 96
        if (tmp___11 == 0) {
          {
#line 96
          tmp___7 = meal_find(meal_date, meal);
#line 96
          tmp___8 = prev_meal(tmp___7);
#line 96
          analyze_meals(tmp___8, 1);
          }
        } else {
          {
#line 99
          modfood = atoi((char const   *)(key___0));
#line 100
          strncpy((char */* __restrict  */)(buff), (char const   */* __restrict  */)(key___0),
                  (size_t )60);
#line 101
          token = strtok((char */* __restrict  */)(buff), (char const   */* __restrict  */)", ");
#line 102
          token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)", ");
#line 103
          tmp___9 = strcmp((char const   *)(key___0), "");
          }
#line 103
          if (tmp___9 == 0) {
#line 103
            goto while_break___1;
          } else
#line 103
          if (modfood == 0) {
#line 103
            goto while_break___1;
          }
          {
#line 104
          modify_meal(meal_date, meal, modfood, token);
#line 105
          write_meal_db();
#line 106
          strcpy((char */* __restrict  */)(key___0), (char const   */* __restrict  */)"");
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 109
    key_put(key___0);
#line 110
    food_ptr = food_choice((char *)"NUT:  Record Meals", 1);
    }
#line 111
    if ((unsigned long )food_ptr == (unsigned long )((struct food *)-1)) {
      {
#line 111
      tmp___13 = meal_find(meal_date, meal);
      }
#line 111
      if ((unsigned long )tmp___13 != (unsigned long )((struct meal *)0)) {
        {
#line 111
        tmp___12 = meal_find(meal_date, meal);
#line 111
        options.temp_meal_root = prev_meal(tmp___12);
        }
      }
    }
#line 112
    if ((unsigned long )food_ptr == (unsigned long )((struct food *)-1)) {
#line 112
      return;
    }
#line 113
    if ((unsigned long )food_ptr == (unsigned long )((struct food *)0)) {
      {
#line 113
      key_clean();
      }
    }
#line 114
    if ((unsigned long )food_ptr == (unsigned long )((struct food *)0)) {
#line 114
      key___0[0] = (char )'\000';
    }
#line 115
    if ((unsigned long )food_ptr == (unsigned long )((struct food *)0)) {
#line 115
      goto __Cont;
    }
#line 116
    if ((unsigned long )food_ptr != (unsigned long )((struct food *)-2)) {
#line 116
      if ((unsigned long )food_ptr != (unsigned long )((struct food *)-3)) {
        {
#line 118
        header((char *)"NUT:  Record Meals");
#line 119
        food_show(food_ptr, & one);
#line 120
        get_qty(& ratio, & food_ptr->grams, & food_ptr->nutrient[4]);
        }
#line 121
        if (ratio == (float )-383838) {
          {
#line 123
          key_take();
#line 124
          tmp___14 = key_take();
#line 124
          strcpy((char */* __restrict  */)(key___0), (char const   */* __restrict  */)tmp___14);
          }
        }
#line 126
        if (ratio != (float )0) {
#line 126
          if (ratio != (float )-383838) {
            {
#line 128
            tmp___15 = malloc(sizeof(struct food ));
#line 128
            new_meal = (struct meal *)tmp___15;
            }
#line 128
            if ((unsigned long )new_meal == (unsigned long )((void *)0)) {
              {
#line 130
              printf((char const   */* __restrict  */)"We are out of memory.  Bummer.\n");
#line 131
              abort();
              }
            }
            {
#line 133
            new_meal->ndb_no = food_ptr->ndb_no;
#line 134
            new_meal->food_no = food_ptr->food_no;
#line 135
            strcpy((char */* __restrict  */)(new_meal->meal_date), (char const   */* __restrict  */)(meal_date));
#line 136
            new_meal->meal = (char )meal;
#line 137
            new_meal->grams = food_ptr->grams * ratio;
#line 138
            order_new_meal();
#line 139
            write_meal_db();
            }
          }
        }
      }
    }
#line 142
    if ((unsigned long )food_ptr == (unsigned long )((struct food *)-2)) {
      {
#line 144
      key_decode(substring, key___0);
#line 145
      meal_ptr = theusual_choice((char *)"NUT:  Record Meals", substring);
      }
#line 146
      if ((unsigned long )meal_ptr == (unsigned long )((struct meal *)0)) {
#line 146
        goto __Cont;
      }
      {
#line 147
      strcpy((char */* __restrict  */)(theusual_id), (char const   */* __restrict  */)(meal_ptr->meal_date));
      }
      {
#line 148
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 148
        tmp___17 = strcmp((char const   *)(meal_ptr->meal_date), (char const   *)(theusual_id));
        }
#line 148
        if (! (tmp___17 == 0)) {
#line 148
          goto while_break___2;
        }
        {
#line 150
        tmp___16 = malloc(sizeof(struct meal ));
#line 150
        new_meal = (struct meal *)tmp___16;
        }
#line 150
        if ((unsigned long )new_meal == (unsigned long )((void *)0)) {
          {
#line 152
          printf((char const   */* __restrict  */)"We are out of memory.  Bummer.\n");
#line 153
          abort();
          }
        }
        {
#line 155
        memcpy((void */* __restrict  */)new_meal, (void const   */* __restrict  */)meal_ptr,
               sizeof(struct meal ));
#line 156
        strcpy((char */* __restrict  */)(new_meal->meal_date), (char const   */* __restrict  */)(meal_date));
#line 157
        new_meal->meal = (char )meal;
#line 158
        order_new_meal();
#line 159
        meal_ptr = meal_ptr->next;
        }
#line 160
        if ((unsigned long )meal_ptr == (unsigned long )((void *)0)) {
#line 160
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 162
      write_meal_db();
      }
    }
#line 164
    if ((unsigned long )food_ptr == (unsigned long )((struct food *)-3)) {
      {
#line 166
      key_decode(substring, key___0);
#line 167
      pcf(meal_date, meal, substring);
#line 168
      write_meal_db();
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 173 "/home/wheatley/newnew/temp/nut-nutrition-15.5/recmeal.c"
void today(char *whatever ) 
{ 
  int c ;
  int month ;
  struct tm *p ;
  time_t t ;
  char timestamp[26] ;
  char meal_date[9] ;
  char *thismonth ;
  char *Months[12] ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 175
  month = 0;
#line 181
  Months[0] = (char *)"Jan";
#line 181
  Months[1] = (char *)"Feb";
#line 181
  Months[2] = (char *)"Mar";
#line 181
  Months[3] = (char *)"Apr";
#line 181
  Months[4] = (char *)"May";
#line 181
  Months[5] = (char *)"Jun";
#line 181
  Months[6] = (char *)"Jul";
#line 181
  Months[7] = (char *)"Aug";
#line 181
  Months[8] = (char *)"Sep";
#line 181
  Months[9] = (char *)"Oct";
#line 181
  Months[10] = (char *)"Nov";
#line 181
  Months[11] = (char *)"Dec";
#line 183
  time(& t);
#line 184
  p = localtime((time_t const   *)(& t));
#line 185
  tmp = asctime((struct tm  const  *)p);
#line 185
  strcpy((char */* __restrict  */)(timestamp), (char const   */* __restrict  */)tmp);
#line 186
  meal_date[0] = timestamp[20];
#line 187
  meal_date[1] = timestamp[21];
#line 188
  meal_date[2] = timestamp[22];
#line 189
  meal_date[3] = timestamp[23];
#line 190
  thismonth = timestamp + 4;
#line 191
  c = 0;
  }
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (c < 12)) {
#line 191
      goto while_break;
    }
    {
#line 191
    tmp___0 = strncmp((char const   *)thismonth, (char const   *)Months[c], (size_t )3);
    }
#line 191
    if (tmp___0 == 0) {
#line 191
      month = c + 1;
    }
#line 191
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  sprintf((char */* __restrict  */)(meal_date + 4), (char const   */* __restrict  */)"%02d",
          month);
#line 193
  meal_date[6] = timestamp[8];
#line 194
  meal_date[7] = timestamp[9];
#line 195
  meal_date[8] = (char )'\000';
  }
#line 196
  if ((int )meal_date[6] == 32) {
#line 196
    meal_date[6] = (char )'0';
  }
  {
#line 197
  strncpy((char */* __restrict  */)whatever, (char const   */* __restrict  */)(meal_date),
          (size_t )9);
  }
#line 198
  return;
}
}
#line 200 "/home/wheatley/newnew/temp/nut-nutrition-15.5/recmeal.c"
void time_machine(char *whatever ) 
{ 
  int c ;
  int month ;
  int time_travel ;
  struct tm *p ;
  time_t t ;
  char timestamp[26] ;
  char meal_date[9] ;
  char *thismonth ;
  char *Months[12] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 202
  month = 0;
#line 208
  Months[0] = (char *)"Jan";
#line 208
  Months[1] = (char *)"Feb";
#line 208
  Months[2] = (char *)"Mar";
#line 208
  Months[3] = (char *)"Apr";
#line 208
  Months[4] = (char *)"May";
#line 208
  Months[5] = (char *)"Jun";
#line 208
  Months[6] = (char *)"Jul";
#line 208
  Months[7] = (char *)"Aug";
#line 208
  Months[8] = (char *)"Sep";
#line 208
  Months[9] = (char *)"Oct";
#line 208
  Months[10] = (char *)"Nov";
#line 208
  Months[11] = (char *)"Dec";
#line 210
  tmp = atoi((char const   *)whatever);
#line 210
  time_travel = 86400 * tmp;
#line 211
  time(& t);
#line 212
  t += (time_t )time_travel;
#line 213
  p = localtime((time_t const   *)(& t));
#line 214
  tmp___0 = asctime((struct tm  const  *)p);
#line 214
  strcpy((char */* __restrict  */)(timestamp), (char const   */* __restrict  */)tmp___0);
#line 215
  meal_date[0] = timestamp[20];
#line 216
  meal_date[1] = timestamp[21];
#line 217
  meal_date[2] = timestamp[22];
#line 218
  meal_date[3] = timestamp[23];
#line 219
  thismonth = timestamp + 4;
#line 220
  c = 0;
  }
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (c < 12)) {
#line 220
      goto while_break;
    }
    {
#line 220
    tmp___1 = strncmp((char const   *)thismonth, (char const   *)Months[c], (size_t )3);
    }
#line 220
    if (tmp___1 == 0) {
#line 220
      month = c + 1;
    }
#line 220
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 221
  sprintf((char */* __restrict  */)(meal_date + 4), (char const   */* __restrict  */)"%02d",
          month);
#line 222
  meal_date[6] = timestamp[8];
#line 223
  meal_date[7] = timestamp[9];
#line 224
  meal_date[8] = (char )'\000';
  }
#line 225
  if ((int )meal_date[6] == 32) {
#line 225
    meal_date[6] = (char )'0';
  }
  {
#line 226
  strncpy((char */* __restrict  */)whatever, (char const   */* __restrict  */)(meal_date),
          (size_t )9);
  }
#line 227
  return;
}
}
#line 25 "/home/wheatley/newnew/temp/nut-nutrition-15.5/viewfood.h"
void view_foods(void) ;
#line 28 "/home/wheatley/newnew/temp/nut-nutrition-15.5/viewfood.c"
void view_foods(void) 
{ 
  struct food *food_ptr ;
  float ratio ;
  float one ;

  {
  {
#line 30
  food_ptr = (struct food *)((void *)0);
#line 31
  ratio = (float )-1;
#line 31
  one = (float )1;
#line 32
  key_clean();
  }
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (ratio <= (float )0) {
      {
#line 37
      food_ptr = food_choice((char *)"NUT:  View Foods", 0);
      }
#line 38
      if ((unsigned long )food_ptr == (unsigned long )((struct food *)-1)) {
#line 38
        return;
      }
#line 39
      if ((unsigned long )food_ptr == (unsigned long )((struct food *)0)) {
        {
#line 39
        key_clean();
        }
      }
#line 40
      if ((unsigned long )food_ptr == (unsigned long )((struct food *)0)) {
#line 40
        goto __Cont;
      }
    }
    {
#line 42
    header((char *)"NUT:  View Foods");
    }
#line 43
    if (ratio > (float )0) {
      {
#line 43
      food_show(food_ptr, & ratio);
      }
    } else {
      {
#line 44
      food_show(food_ptr, & one);
      }
    }
    {
#line 45
    get_qty(& ratio, & food_ptr->grams, & food_ptr->nutrient[4]);
    }
#line 46
    if (ratio == (float )-383838) {
      {
#line 46
      key_take();
      }
    } else
#line 47
    if (ratio > (float )0) {
#line 47
      if (ratio > (float )100) {
#line 47
        ratio = (float )100;
      } else {
#line 47
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 48
    if (ratio == (float )0) {
      {
#line 48
      key_clean();
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 27 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.h"
void add_foods(int label ) ;
#line 28
void new_recipe_show(void) ;
#line 29
void get_recipe_qty(float *result ) ;
#line 30
int recipe_show(int trace , int level ) ;
#line 31
void add_labels(void) ;
#line 32
void screen_subvert_label(int dv ) ;
#line 33
void set_nut_table(void) ;
#line 34
void label_nut_list(int selection ) ;
#line 35
void get_nut_value(float *dest ) ;
#line 36
void guess_recipe(void) ;
#line 37
void solve_it(int foodno , int *oldlevelcumbuf , int *oldlevelminbuf , int *oldlevelmaxbuf ) ;
#line 38
void modify_servings(void) ;
#line 32 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
float GRquantamatrix[39][78]  ;
#line 33 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
float GRnutslots[39]  ;
#line 34 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
int GRfoodslots[78]  ;
#line 35 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
int GRsaveslots[78]  ;
#line 36 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
int GRfoodlevel[78]  ;
#line 37 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
int GRlowestlevelchange[78]  ;
#line 38 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
int GRgroupsremaining[78][39]  ;
#line 39 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
int GRtotalquanta  ;
#line 40 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
int GRfoodcount  ;
#line 41 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
int GRnutcount  ;
#line 42 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
float GRbestvariance  ;
#line 44 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
void add_foods(int label ) 
{ 
  struct food *food_ptr ;
  char key___0[121] ;
  char buff[128] ;
  char *token ;
  int c ;
  int modfood ;
  int junk ;
  int likeit ;
  int dupname ;
  int resname ;
  float ratio ;
  float one ;
  float servings ;
  float savegrams ;
  float savewater ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  void *tmp___16 ;

  {
  {
#line 46
  food_ptr = & food_root;
#line 50
  likeit = 'n';
#line 50
  dupname = 0;
#line 50
  resname = 0;
#line 51
  one = (float )1;
#line 51
  servings = (float )0;
#line 52
  key___0[0] = (char )'\000';
#line 53
  key_clean();
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (likeit == 78)) {
#line 54
      if (! (likeit == 110)) {
#line 54
        goto while_break;
      }
    }
#line 56
    dupname = 0;
#line 56
    resname = 0;
#line 57
    if (! label) {
      {
#line 57
      header((char *)"NUT:  Add a Recipe");
      }
    }
#line 58
    if (label) {
      {
#line 58
      header((char *)"NUT:  Add a Labeled Food");
      }
    }
    {
#line 59
    spacer(-1);
    }
#line 60
    if (! label) {
      {
#line 60
      printf((char const   */* __restrict  */)"Type name of new recipe (or <enter> to quit):  ");
      }
    }
#line 61
    if (label) {
      {
#line 61
      printf((char const   */* __restrict  */)"Type labeled food name (or <enter> to quit):  ");
      }
    }
    {
#line 62
    get_string(food_work.name, 60);
#line 63
    tmp = strcmp((char const   *)(food_work.name), "");
    }
#line 63
    if (tmp == 0) {
#line 63
      return;
    }
    {
#line 64
    tmp___0 = strlen((char const   *)(food_work.name));
#line 64
    junk = (int )tmp___0;
#line 65
    c = 0;
    }
    {
#line 65
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 65
      if (! (c < junk)) {
#line 65
        goto while_break___0;
      }
      {
#line 65
      tmp___1 = toupper((int )food_work.name[c]);
#line 65
      food_work.name[c] = (char )tmp___1;
#line 65
      c ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 66
    c = junk;
    {
#line 66
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 66
      if (! (c >= 0)) {
#line 66
        goto while_break___1;
      }
#line 68
      if ((int )food_work.name[c] == 32) {
#line 68
        food_work.name[c] = (char )'\000';
      } else {
#line 69
        goto while_break___1;
      }
#line 66
      c --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 71
    food_ptr = & food_root;
    {
#line 72
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 72
      if (! ((unsigned long )food_ptr->next != (unsigned long )((void *)0))) {
#line 72
        goto while_break___2;
      }
#line 74
      food_ptr = food_ptr->next;
#line 75
      if ((int )food_work.name[0] == (int )food_ptr->name[0]) {
        {
#line 75
        tmp___2 = strcmp((char const   *)(food_work.name), (char const   *)(food_ptr->name));
        }
#line 75
        if (tmp___2 == 0) {
#line 75
          dupname = 1;
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 77
    tmp___3 = strncmp((char const   *)(food_work.name), "THEUSUAL", (size_t )8);
    }
#line 77
    if (tmp___3 == 0) {
#line 77
      resname = 1;
    }
#line 78
    if (! dupname) {
#line 78
      goto _L;
    } else
#line 78
    if (resname) {
      _L: /* CIL Label */ 
#line 80
      if (! label) {
        {
#line 80
        header((char *)"NUT:  Add a Recipe");
        }
      }
#line 81
      if (label) {
        {
#line 81
        header((char *)"NUT:  Add a Labeled Food");
        }
      }
      {
#line 82
      spacer(0);
#line 83
      printf((char const   */* __restrict  */)"Recipe name is \"%-s.\"\n", food_work.name);
#line 84
      printf((char const   */* __restrict  */)"Is this correct?  (y/n):  ");
#line 85
      likeit = get_char();
      }
    }
#line 87
    if (dupname) {
#line 89
      if (! label) {
        {
#line 89
        header((char *)"NUT:  Add a Recipe");
        }
      }
#line 90
      if (label) {
        {
#line 90
        header((char *)"NUT:  Add a Labeled Food");
        }
      }
      {
#line 91
      spacer(0);
#line 92
      printf((char const   */* __restrict  */)"\"%-s\"\n", food_work.name);
#line 93
      printf((char const   */* __restrict  */)"is a duplicate name.  Press <enter> to continue...");
#line 94
      junk = get_char();
#line 95
      likeit = 'n';
      }
    }
#line 97
    if (resname) {
#line 99
      if (! label) {
        {
#line 99
        header((char *)"NUT:  Add a Recipe");
        }
      }
#line 100
      if (label) {
        {
#line 100
        header((char *)"NUT:  Add a Labeled Food");
        }
      }
      {
#line 101
      spacer(0);
#line 102
      printf((char const   */* __restrict  */)"\"%-s\"\n", food_work.name);
#line 103
      printf((char const   */* __restrict  */)"is a reserved name.  Press <enter> to continue...");
#line 104
      junk = get_char();
#line 105
      likeit = 'n';
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  tmp___4 = strcmp((char const   *)(food_work.name), "");
  }
#line 108
  if (tmp___4 == 0) {
#line 108
    return;
  }
#line 109
  if (label) {
    {
#line 111
    header((char *)"NUT:  Add a Labeled Food");
#line 112
    printf((char const   */* __restrict  */)"\n    Now select the ingredients in the order they appear on the ingredients");
#line 113
    printf((char const   */* __restrict  */)"\n    statement.  Don\'t worry if you can\'t find some of the ingredients, but");
#line 114
    printf((char const   */* __restrict  */)"\n    for all of them that you do find, keep the order the same.");
#line 115
    printf((char const   */* __restrict  */)"\n");
#line 116
    printf((char const   */* __restrict  */)"\n    Here are some additional commands that facilitate the creation of");
#line 117
    printf((char const   */* __restrict  */)"\n    the ordered ingredients statement.  (The symbol \"#\" stands for a number");
#line 118
    printf((char const   */* __restrict  */)"\n    representing an ingredient in the list):");
#line 119
    printf((char const   */* __restrict  */)"\n");
#line 120
    printf((char const   */* __restrict  */)"\n         #         Delete this ingredient");
#line 121
    printf((char const   */* __restrict  */)"\n         #m#       Move this ingredient to the new position");
#line 122
    printf((char const   */* __restrict  */)"\n         #(        Begin here a group that constitutes a single ingredient");
#line 123
    printf((char const   */* __restrict  */)"\n         #)        End here a group that constitutes a single ingredient");
#line 124
    printf((char const   */* __restrict  */)"\n         #!        Remove a group indicator from this ingredient");
#line 125
    printf((char const   */* __restrict  */)"\n");
#line 126
    spacer(14);
#line 127
    printf((char const   */* __restrict  */)"\nPress <enter> to continue...");
#line 128
    junk = get_int();
    }
  }
  {
#line 130
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 132
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 134
      if ((unsigned long )recipe_root.next != (unsigned long )((void *)0)) {
#line 136
        if (! label) {
          {
#line 136
          header((char *)"NUT:  Add a Recipe");
          }
        }
#line 137
        if (label) {
          {
#line 137
          header((char *)"NUT:  Add a Labeled Food");
          }
        }
#line 138
        if (label) {
#line 138
          tmp___12 = 1;
        } else {
#line 138
          tmp___12 = 0;
        }
        {
#line 138
        tmp___13 = recipe_show(0, tmp___12);
        }
#line 138
        if (tmp___13) {
          {
#line 145
          printf((char const   */* __restrict  */)"\nEnter number to delete or food name (or <enter> to quit):  ");
#line 146
          get_string(key___0, 60);
#line 147
          tmp___11 = strcmp((char const   *)(key___0), "");
          }
#line 147
          if (tmp___11 == 0) {
#line 149
            if (! label) {
              {
#line 151
              header((char *)"NUT:  Add a Recipe");
#line 152
              recipe_show(0, 0);
#line 153
              printf((char const   */* __restrict  */)"\nDo you want to save recipe in the food database?  (y/n):  ");
#line 154
              junk = get_char();
              }
#line 155
              if (junk == 110) {
#line 155
                goto _L___0;
              } else
#line 155
              if (junk == 78) {
                _L___0: /* CIL Label */ 
#line 157
                token = (char *)((void *)0);
                {
#line 158
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 158
                  if (! ((unsigned long )recipe_root.next != (unsigned long )((void *)0))) {
#line 158
                    goto while_break___5;
                  }
                  {
#line 158
                  modify_recipe_food(1, token);
                  }
                }
                while_break___5: /* CIL Label */ ;
                }
#line 159
                return;
              }
            }
#line 162
            junk = 'z';
            {
#line 163
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 163
              if (junk != 89) {
#line 163
                if (junk != 121) {
#line 163
                  if (junk != 78) {
#line 163
                    if (! (junk != 110)) {
#line 163
                      goto while_break___6;
                    }
                  } else {
#line 163
                    goto while_break___6;
                  }
                } else {
#line 163
                  goto while_break___6;
                }
              } else {
#line 163
                goto while_break___6;
              }
#line 165
              if (! label) {
                {
#line 165
                header((char *)"NUT:  Add a Recipe");
                }
              }
#line 166
              if (label) {
                {
#line 166
                header((char *)"NUT:  Add a Labeled Food");
                }
              }
#line 167
              if (label) {
#line 167
                tmp___5 = 1;
              } else {
#line 167
                tmp___5 = 0;
              }
              {
#line 167
              recipe_show(0, tmp___5);
              }
#line 168
              if (! label) {
                {
#line 168
                printf((char const   */* __restrict  */)"\nDo you want to add more foods to recipe?  (y/n):  ");
                }
              }
#line 169
              if (label) {
                {
#line 169
                printf((char const   */* __restrict  */)"\nDo you want to add more ingredients?  (y/n):  ");
                }
              }
              {
#line 170
              junk = get_char();
              }
            }
            while_break___6: /* CIL Label */ ;
            }
#line 172
            if (junk == 121) {
#line 172
              goto __Cont;
            } else
#line 172
            if (junk == 89) {
#line 172
              goto __Cont;
            }
            {
#line 173
            clear_work();
            }
#line 174
            if (label) {
              {
#line 174
              add_labels();
              }
            }
#line 175
            food_ptr = & recipe_root;
            {
#line 176
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 176
              if ((unsigned long )food_ptr->next != (unsigned long )((void *)0)) {
#line 176
                if (! (! label)) {
#line 176
                  goto while_break___7;
                }
              } else {
#line 176
                goto while_break___7;
              }
#line 178
              food_ptr = food_ptr->next;
#line 179
              c = 0;
              {
#line 179
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 179
                if (! (c < 159)) {
#line 179
                  goto while_break___8;
                }
#line 179
                food_work.nutrient[c] += (food_ptr->nutrient[c] * food_ptr->grams) / (float )100;
#line 179
                c ++;
              }
              while_break___8: /* CIL Label */ ;
              }
#line 180
              food_work.grams += food_ptr->grams;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 182
            token = (char *)((void *)0);
            {
#line 183
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 183
              if ((unsigned long )recipe_root.next != (unsigned long )((void *)0)) {
#line 183
                if (! (! label)) {
#line 183
                  goto while_break___9;
                }
              } else {
#line 183
                goto while_break___9;
              }
              {
#line 183
              modify_recipe_food(1, token);
              }
            }
            while_break___9: /* CIL Label */ ;
            }
#line 184
            if (label) {
#line 184
              servings = (float )1;
            }
#line 185
            c = 0;
            {
#line 185
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 185
              if (! (c < 159)) {
#line 185
                goto while_break___10;
              }
#line 185
              if (food_work.nutrient[c] < (float )0) {
#line 185
                food_work.nutrient[c] = NoData;
              }
#line 185
              c ++;
            }
            while_break___10: /* CIL Label */ ;
            }
            {
#line 186
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 186
              if (! (servings <= (float )0)) {
#line 186
                goto while_break___11;
              }
              {
#line 188
              header((char *)"NUT:  Add a Recipe");
#line 189
              new_recipe_show();
#line 190
              printf((char const   */* __restrict  */)"\nHow many servings does this recipe make?  ");
#line 191
              get_string(key___0, 60);
#line 192
              tmp___6 = atof((char const   *)(key___0));
#line 192
              servings = (float )tmp___6;
              }
#line 193
              if (servings <= (float )0) {
#line 193
                goto while_continue___11;
              }
              {
#line 194
              header((char *)"NUT:  Add a Recipe");
#line 195
              new_recipe_show();
#line 196
              printf((char const   */* __restrict  */)"\nIs \"%-s\" the correct number of servings for this recipe?  (y/n)  ",
                     key___0);
#line 197
              junk = get_char();
              }
#line 198
              if (junk == 78) {
#line 198
                servings = (float )0;
              } else
#line 198
              if (junk == 110) {
#line 198
                servings = (float )0;
              }
            }
            while_break___11: /* CIL Label */ ;
            }
#line 200
            c = 0;
            {
#line 200
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 200
              if (! (c < 159)) {
#line 200
                goto while_break___12;
              }
#line 200
              food_work.nutrient[c] /= servings;
#line 200
              c ++;
            }
            while_break___12: /* CIL Label */ ;
            }
#line 201
            food_work.grams /= servings;
#line 202
            junk = 'n';
            {
#line 203
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 203
              if (! (junk == 110)) {
#line 203
                goto while_break___13;
              }
              {
#line 205
              new_recipe_show();
#line 206
              printf((char const   */* __restrict  */)"\nPlease enter serving unit (cup, tbsp, piece...):  ");
#line 207
              get_string(food_work.unit, 50);
#line 208
              new_recipe_show();
#line 209
              printf((char const   */* __restrict  */)"\nIs \"%-s\" correct?  (y/n)  ",
                     food_work.unit);
#line 210
              junk = get_char();
              }
#line 211
              if (junk == 78) {
#line 211
                junk = 'n';
              }
            }
            while_break___13: /* CIL Label */ ;
            }
#line 213
            junk = 'n';
            {
#line 214
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 214
              if (! (junk == 110)) {
#line 214
                goto while_break___14;
              }
              {
#line 216
              new_recipe_show();
#line 217
              printf((char const   */* __restrict  */)"\nPlease enter number of serving units:  ");
#line 218
              food_work.qty = get_float();
              }
#line 219
              if (food_work.qty <= (float )0) {
#line 219
                food_work.qty = (float )1;
              }
              {
#line 220
              new_recipe_show();
#line 221
              printf((char const   */* __restrict  */)"\nIs \"%-1.2f\" the correct number of serving units?  (y/n)  ",
                     (double )food_work.qty);
#line 222
              junk = get_char();
              }
#line 223
              if (junk == 78) {
#line 223
                junk = 'n';
              }
            }
            while_break___14: /* CIL Label */ ;
            }
#line 225
            if (! label) {
              {
#line 227
              new_recipe_show();
#line 228
              printf((char const   */* __restrict  */)"\nWould you like to change weight of serving?  (y/n):  ");
#line 229
              junk = get_char();
              }
#line 230
              if (junk == 121) {
#line 230
                goto _L___1;
              } else
#line 230
              if (junk == 89) {
                _L___1: /* CIL Label */ 
#line 232
                savegrams = food_work.grams;
#line 233
                savewater = food_work.nutrient[12];
#line 234
                junk = 'n';
                {
#line 235
                while (1) {
                  while_continue___15: /* CIL Label */ ;
#line 235
                  if (! (junk == 110)) {
#line 235
                    if (! (junk == 78)) {
#line 235
                      goto while_break___15;
                    }
                  }
                  {
#line 237
                  food_work.grams = savegrams;
#line 238
                  food_work.nutrient[12] = savewater;
#line 239
                  new_recipe_show();
#line 240
                  printf((char const   */* __restrict  */)"\nType new weight of serving {#g for grams, #o for oz}:  ");
#line 241
                  get_recipe_qty(& food_work.grams);
#line 242
                  food_work.nutrient[12] -= savegrams - food_work.grams;
#line 243
                  new_recipe_show();
#line 244
                  printf((char const   */* __restrict  */)"\nIs weight now correct?  (y/n):  ");
#line 245
                  junk = get_char();
                  }
                }
                while_break___15: /* CIL Label */ ;
                }
              }
            }
            {
#line 249
            tmp___7 = malloc(sizeof(struct food ));
#line 249
            new_food = (struct food *)tmp___7;
            }
#line 249
            if ((unsigned long )new_food == (unsigned long )((void *)0)) {
              {
#line 251
              printf((char const   */* __restrict  */)"We are out of memory.  Bummer.\n");
#line 252
              abort();
              }
            }
#line 254
            c = 0;
            {
#line 254
            while (1) {
              while_continue___16: /* CIL Label */ ;
#line 254
              if (! (c < 159)) {
#line 254
                goto while_break___16;
              }
#line 254
              food_work.nutrient[c] /= food_work.grams / (float )100;
#line 254
              c ++;
            }
            while_break___16: /* CIL Label */ ;
            }
            {
#line 255
            memcpy((void */* __restrict  */)new_food, (void const   */* __restrict  */)(& food_work),
                   sizeof(struct food ));
#line 256
            c = 0;
            }
            {
#line 256
            while (1) {
              while_continue___17: /* CIL Label */ ;
#line 256
              if (! (c < 159)) {
#line 256
                goto while_break___17;
              }
#line 256
              food_work.nutrient[c] *= food_work.grams / (float )100;
#line 256
              c ++;
            }
            while_break___17: /* CIL Label */ ;
            }
            {
#line 257
            tmp___8 = options.next_recipe;
#line 257
            (options.next_recipe) ++;
#line 257
            new_food->ndb_no = tmp___8;
#line 258
            write_OPTIONS();
#line 259
            tmp___9 = order_new_food();
#line 259
            tmp___10 = modify_food_index(tmp___9, new_food);
#line 259
            reindex_meals(tmp___10);
#line 260
            write_meal_db();
#line 261
            write_theusual_db();
#line 262
            write_food_db();
#line 263
            write_recipe(new_food);
#line 264
            new_recipe_show();
#line 265
            printf((char const   */* __restrict  */)"\nRecipe saved in food database.  Press <enter> to continue...  ");
#line 266
            junk = get_int();
#line 267
            food_work.name[0] = (char )'\000';
#line 268
            food_work.unit[0] = (char )'\000';
#line 269
            food_work.qty = (float )1;
            }
#line 270
            return;
          }
        } else {
          {
#line 140
          printf((char const   */* __restrict  */)"\nPress <enter> to continue...");
#line 141
          junk = get_int();
          }
        }
      }
      {
#line 274
      modfood = atoi((char const   *)(key___0));
#line 275
      strncpy((char */* __restrict  */)(buff), (char const   */* __restrict  */)(key___0),
              (size_t )60);
#line 276
      token = strtok((char */* __restrict  */)(buff), (char const   */* __restrict  */)", ");
#line 277
      token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)", ");
#line 278
      tmp___14 = strcmp((char const   *)(key___0), "");
      }
#line 278
      if (tmp___14 == 0) {
#line 278
        goto while_break___4;
      } else
#line 278
      if (modfood == 0) {
#line 278
        goto while_break___4;
      }
#line 279
      if (! label) {
        {
#line 279
        modify_recipe_food(modfood, token);
        }
      }
#line 280
      if (label) {
        {
#line 280
        modify_label_food(modfood, key___0);
        }
      }
      {
#line 281
      strcpy((char */* __restrict  */)(key___0), (char const   */* __restrict  */)"");
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 283
    ratio = (float )-383838;
    {
#line 284
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 284
      if (! (ratio == (float )-383838)) {
#line 284
        goto while_break___18;
      }
      {
#line 286
      key_put(key___0);
      }
#line 287
      if (! label) {
        {
#line 287
        food_ptr = food_choice((char *)"NUT:  Add a Recipe", 0);
        }
      }
#line 288
      if (label) {
        {
#line 288
        food_ptr = food_choice((char *)"NUT:  Add a Labeled Food", 0);
        }
      }
#line 289
      if ((unsigned long )food_ptr == (unsigned long )((struct food *)-1)) {
#line 289
        return;
      }
#line 290
      if ((unsigned long )food_ptr == (unsigned long )((struct food *)0)) {
        {
#line 290
        key_clean();
        }
      }
#line 291
      if ((unsigned long )food_ptr == (unsigned long )((struct food *)0)) {
#line 291
        goto while_break___18;
      }
#line 292
      if (! label) {
        {
#line 292
        header((char *)"NUT:  Add a Recipe");
        }
      }
#line 293
      if (label) {
        {
#line 293
        header((char *)"NUT:  Add a Labeled Food");
        }
      }
      {
#line 294
      food_show(food_ptr, & one);
      }
#line 295
      if (! label) {
        {
#line 295
        get_qty(& ratio, & food_ptr->grams, & food_ptr->nutrient[4]);
        }
      }
#line 296
      if (label) {
        {
#line 296
        get_select(& ratio);
        }
      }
#line 297
      if (ratio == (float )-383838) {
        {
#line 299
        key_take();
#line 300
        tmp___15 = key_take();
#line 300
        strcpy((char */* __restrict  */)(key___0), (char const   */* __restrict  */)tmp___15);
        }
      }
    }
    while_break___18: /* CIL Label */ ;
    }
#line 303
    if (ratio == (float )0) {
      {
#line 305
      key_clean();
#line 306
      strcpy((char */* __restrict  */)(key___0), (char const   */* __restrict  */)"");
      }
    }
#line 308
    if (ratio != (float )-383838) {
      {
#line 310
      key_clean();
#line 311
      strcpy((char */* __restrict  */)(key___0), (char const   */* __restrict  */)"");
#line 312
      tmp___16 = malloc(sizeof(struct food ));
#line 312
      new_recipe = (struct food *)tmp___16;
      }
#line 312
      if ((unsigned long )new_recipe == (unsigned long )((void *)0)) {
        {
#line 314
        printf((char const   */* __restrict  */)"We are out of memory.  Bummer.\n");
#line 315
        abort();
        }
      }
      {
#line 317
      memcpy((void */* __restrict  */)new_recipe, (void const   */* __restrict  */)food_ptr,
             sizeof(struct food ));
#line 318
      new_recipe->grams *= ratio;
      }
#line 319
      if (label) {
#line 319
        new_recipe->refuse = 0;
      }
      {
#line 320
      order_new_recipe();
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
}
}
#line 325 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
void new_recipe_show(void) 
{ 
  float one ;
  char buffer[100] ;
  char *tmp ;

  {
  {
#line 327
  one = (float )1;
#line 329
  header((char *)"NUT:  Add a Recipe");
#line 330
  printf((char const   */* __restrict  */)"%-60s   Grams:  %7.2f\n", food_work.name,
         (double )food_work.grams);
#line 331
  tmp = format_serving(buffer, & one, & food_work);
#line 331
  printf((char const   */* __restrict  */)"Serving:  %-50s   Ounces: %7.2f\n", tmp,
         (double )food_work.grams / 28.349523);
#line 332
  printf((char const   */* __restrict  */)"          %-50s   Water:   %6.2f%%\n",
         " ", (double )(((float )100 * food_work.nutrient[12]) / food_work.grams));
#line 333
  printf((char const   */* __restrict  */)"Percentages of \"Daily Values\" in this serving:                 Refuse:  %3d%%\n\n",
         food_work.refuse);
#line 334
  food_display(stdout);
#line 335
  spacer(21);
  }
#line 336
  return;
}
}
#line 338 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
void get_recipe_qty(float *result ) 
{ 
  char buff[128] ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 341
  fgets((char */* __restrict  */)(buff), 128, (FILE */* __restrict  */)stdin);
#line 342
  tmp___3 = strchr((char const   *)(buff), 'g');
  }
#line 342
  if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
    {
#line 342
    tmp = atof((char const   *)(buff));
#line 342
    *result = (float )tmp;
    }
  } else {
    {
#line 343
    tmp___2 = strchr((char const   *)(buff), 'o');
    }
#line 343
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
      {
#line 343
      tmp___0 = atof((char const   *)(buff));
#line 343
      *result = (float )((double )((float )tmp___0) * 28.349523);
      }
    } else {
      {
#line 344
      tmp___1 = atof((char const   *)(buff));
#line 344
      *result = (float )tmp___1;
      }
    }
  }
#line 345
  return;
}
}
#line 347 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
int recipe_show(int trace , int level ) 
{ 
  struct food *recipe_ptr ;
  int i ;
  int count ;
  int cumlevel ;
  int trimlength ;
  char nametrim[61] ;

  {
  {
#line 349
  recipe_ptr = & recipe_root;
#line 350
  i = 0;
#line 350
  count = 0;
#line 350
  cumlevel = 0;
#line 350
  trimlength = 60;
#line 352
  printf((char const   */* __restrict  */)"Recipe Name:  %-s\n\n", food_work.name);
  }
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! ((unsigned long )recipe_ptr->next != (unsigned long )((void *)0))) {
#line 353
      goto while_break;
    }
#line 355
    recipe_ptr = recipe_ptr->next;
#line 356
    count ++;
#line 357
    if (! level) {
#line 359
      if (options.grams) {
        {
#line 359
        printf((char const   */* __restrict  */)"%2d. %-60s    %9.1f g\n", count,
               recipe_ptr->name, (double )recipe_ptr->grams);
        }
      }
#line 360
      if (! options.grams) {
        {
#line 360
        printf((char const   */* __restrict  */)"%2d. %-60s    %8.1f oz\n", count,
               recipe_ptr->name, (double )recipe_ptr->grams / 28.349523);
        }
      }
    }
#line 362
    if (level) {
      {
#line 364
      printf((char const   */* __restrict  */)"%2d. ", count);
#line 365
      i = 0;
      }
      {
#line 365
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 365
        if (! (i < cumlevel)) {
#line 365
          goto while_break___0;
        }
        {
#line 365
        printf((char const   */* __restrict  */)" ");
#line 365
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 366
      if (recipe_ptr->refuse > 0) {
#line 366
        i = 0;
        {
#line 366
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 366
          if (! (i < recipe_ptr->refuse)) {
#line 366
            goto while_break___1;
          }
          {
#line 366
          printf((char const   */* __restrict  */)"(");
#line 366
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 367
      if (recipe_ptr->refuse > 0) {
#line 367
        cumlevel += recipe_ptr->refuse;
      }
#line 368
      i = 0;
      {
#line 368
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 368
        if (! (i < 60)) {
#line 368
          goto while_break___2;
        }
#line 368
        nametrim[i] = (char )' ';
#line 368
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 369
      trimlength = 60 - cumlevel;
#line 370
      i = 0;
      {
#line 370
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 370
        if (! (i < trimlength)) {
#line 370
          goto while_break___3;
        }
#line 372
        if ((int )recipe_ptr->name[i] == 0) {
#line 372
          goto while_break___3;
        }
#line 373
        nametrim[i] = recipe_ptr->name[i];
#line 370
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 375
      if (recipe_ptr->refuse < 0) {
#line 375
        if (cumlevel + recipe_ptr->refuse < 0) {
#line 375
          recipe_ptr->refuse = 0 - cumlevel;
        }
      }
#line 376
      if (recipe_ptr->refuse < 0) {
#line 378
        i = 0;
        {
#line 378
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 378
          if (! (i < trimlength)) {
#line 378
            goto while_break___4;
          }
#line 380
          if ((int )recipe_ptr->name[i] == 0) {
#line 380
            goto while_break___4;
          }
#line 381
          nametrim[i] = recipe_ptr->name[i];
#line 378
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 383
        i = recipe_ptr->refuse;
        {
#line 383
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 383
          if (! (i < 0)) {
#line 383
            goto while_break___5;
          }
#line 383
          nametrim[trimlength + i] = (char )')';
#line 383
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 384
        cumlevel += recipe_ptr->refuse;
      }
      {
#line 389
      nametrim[trimlength] = (char )'\000';
#line 390
      printf((char const   */* __restrict  */)"%-s", nametrim);
      }
#line 391
      if (options.grams) {
#line 391
        if (! trace) {
          {
#line 391
          printf((char const   */* __restrict  */)"    %9.1f g\n", (double )recipe_ptr->grams);
          }
        }
      }
#line 392
      if (options.grams) {
#line 392
        if (trace) {
#line 392
          if (recipe_ptr->grams > (float )0) {
            {
#line 392
            printf((char const   */* __restrict  */)"    %9.2f g\n", (double )recipe_ptr->grams);
            }
          }
        }
      }
#line 393
      if (options.grams) {
#line 393
        if (trace) {
#line 393
          if (recipe_ptr->grams == (float )0) {
            {
#line 393
            printf((char const   */* __restrict  */)"      %9s\n", "trace");
            }
          }
        }
      }
#line 394
      if (! options.grams) {
        {
#line 394
        printf((char const   */* __restrict  */)"    %8.1f oz\n", (double )recipe_ptr->grams / 28.349523);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  if (count == 0) {
    {
#line 399
    printf((char const   */* __restrict  */)"\n\n\nNo foods have yet been recorded for this recipe.\n");
#line 400
    spacer(6);
    }
#line 401
    return (0);
  }
  {
#line 403
  spacer(count + 2);
  }
#line 404
  return (1);
}
}
#line 407 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
void add_labels(void) 
{ 
  int i ;
  int tmp ;

  {
#line 410
  i = 0;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    if (! (i < 159)) {
#line 410
      goto while_break;
    }
#line 410
    food_work.nutrient[i] = (float )-1;
#line 410
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 411
  header((char *)"NUT:  Add a Labeled Food");
#line 412
  printf((char const   */* __restrict  */)"\n\n    Now enter the information from the nutrition statement on the package.");
#line 413
  printf((char const   */* __restrict  */)"\n    Use grams rather than percentages whenever possible and ignore zero");
#line 414
  printf((char const   */* __restrict  */)"\n    amounts, as only greater-than-zero Daily Value nutrients are used.");
#line 415
  printf((char const   */* __restrict  */)"\n    There will be another opportunity later to review and correct the");
#line 416
  printf((char const   */* __restrict  */)"\n    nutrient values after the recipe is determined, so wait until then");
#line 417
  printf((char const   */* __restrict  */)"\n    to add vitamins and minerals if the food is heavily fortified and");
#line 418
  printf((char const   */* __restrict  */)"\n    the individual vitamins are not part of the food ingredients.");
#line 419
  printf((char const   */* __restrict  */)"\n\n    If you enter nutrients as a percentage of the Daily Value, this is");
#line 420
  printf((char const   */* __restrict  */)"\n    the standard USA Daily Value for 2000-calorie diets, and not any");
#line 421
  printf((char const   */* __restrict  */)"\n    customized values you may have set.");
#line 422
  printf((char const   */* __restrict  */)"\n\n    Each time you quit from a nutrient screen, you will be able to select");
#line 423
  printf((char const   */* __restrict  */)"\n    another group of nutrients to add.  Leave blank all the nutrients you");
#line 424
  printf((char const   */* __restrict  */)"\n    don\'t find on the nutrition statement.");
#line 425
  spacer(16);
#line 426
  printf((char const   */* __restrict  */)"\nPress <enter> to continue...");
#line 427
  i = get_int();
#line 428
  screen_subvert_label(1);
  }
  {
#line 429
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 431
    header((char *)"NUT:  Add a Labeled Food");
#line 432
    printf((char const   */* __restrict  */)"\n\n    Now enter the serving size in grams.  If the food is liquid and measured");
#line 433
    printf((char const   */* __restrict  */)"\n    by volume, use the approximations 1 mL = 1 gram (1 liter = 1000 grams)");
#line 434
    printf((char const   */* __restrict  */)"\n    and 1 fluid ounce = 30 grams (1 quart = 960 grams).");
#line 435
    spacer(4);
#line 436
    printf((char const   */* __restrict  */)"\nEnter weight of serving in grams:  ");
#line 437
    get_nut_value(& food_work.grams);
    }
#line 438
    if (food_work.grams > (float )0) {
#line 438
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 440
  guess_recipe();
#line 441
  i = 0;
  }
  {
#line 441
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 441
    if (! (i < 159)) {
#line 441
      goto while_break___1;
    }
    {
#line 441
    tmp = test_for_negative_zero(& food_work.nutrient[i]);
    }
#line 441
    if (tmp) {
#line 441
      food_work.nutrient[i] = (float )-1;
    }
#line 441
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 442
  printf((char const   */* __restrict  */)"\nDo you want to again view or edit the nutrient values (y/n)?  ");
#line 443
  i = get_char();
  }
#line 444
  if (i != 78) {
#line 444
    if (i != 110) {
      {
#line 444
      screen_subvert_label(0);
      }
    }
  }
#line 445
  i = 0;
  {
#line 445
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 445
    if (! (i < 159)) {
#line 445
      goto while_break___2;
    }
#line 445
    if (food_work.nutrient[i] == (float )-1) {
#line 445
      food_work.nutrient[i] = NoData;
    }
#line 445
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 446
  compute_derived_fields(& food_work);
  }
#line 447
  return;
}
}
#line 449 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
void screen_subvert_label(int dv ) 
{ 
  int screen_choice ;
  int savescreen ;
  int i ;
  char yn ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 453
  savescreen = options.screen;
#line 454
  options.screen = 1;
#line 455
  set_nut_table();
  }
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 458
    yn = (char )'\000';
#line 459
    header((char *)"NUT:  Add a Labeled Food");
#line 460
    printf((char const   */* __restrict  */)"\n      Change group of nutrients to view?\n\n\n");
#line 461
    i = 0;
    }
    {
#line 461
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 461
      if (dv) {
#line 461
        tmp = dv + 1;
      } else {
#line 461
        tmp = MaxScreen;
      }
#line 461
      if (! (i < tmp)) {
#line 461
        goto while_break___0;
      }
      {
#line 461
      printf((char const   */* __restrict  */)"                    %d  --  %s\n\n",
             i + 1, ScreenTitle[i]);
#line 461
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 462
    if (dv) {
#line 462
      tmp___0 = dv + 1;
    } else {
#line 462
      tmp___0 = MaxScreen;
    }
    {
#line 462
    spacer(tmp___0 * 2 + 4);
#line 463
    printf((char const   */* __restrict  */)"\nEnter your choice (just <enter> to quit):  ");
#line 464
    screen_choice = get_int();
    }
#line 465
    if (screen_choice < 1) {
#line 465
      goto _L;
    } else {
#line 465
      if (dv) {
#line 465
        tmp___2 = dv + 1;
      } else {
#line 465
        tmp___2 = MaxScreen;
      }
#line 465
      if (screen_choice > tmp___2) {
        _L: /* CIL Label */ 
        {
#line 467
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 467
          if ((int )yn != 89) {
#line 467
            if ((int )yn != 121) {
#line 467
              if ((int )yn != 78) {
#line 467
                if (! ((int )yn != 110)) {
#line 467
                  goto while_break___1;
                }
              } else {
#line 467
                goto while_break___1;
              }
            } else {
#line 467
              goto while_break___1;
            }
          } else {
#line 467
            goto while_break___1;
          }
          {
#line 469
          header((char *)"NUT:  Add a Labeled Food");
#line 470
          spacer(-1);
#line 471
          printf((char const   */* __restrict  */)"Do you want to further edit the nutrient values (y/n)?  ");
#line 472
          tmp___1 = get_char();
#line 472
          yn = (char )tmp___1;
          }
#line 473
          if ((int )yn == 78) {
#line 475
            options.screen = savescreen;
#line 476
            return;
          } else
#line 473
          if ((int )yn == 110) {
#line 475
            options.screen = savescreen;
#line 476
            return;
          }
#line 478
          if ((int )yn == 89) {
#line 478
            goto while_break___1;
          } else
#line 478
          if ((int )yn == 121) {
#line 478
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 481
    if ((int )yn == 89) {
#line 481
      goto __Cont;
    } else
#line 481
    if ((int )yn == 121) {
#line 481
      goto __Cont;
    }
    {
#line 482
    options.screen = screen_choice - 1;
#line 483
    set_nut_table();
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 487 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
void set_nut_table(void) 
{ 
  float tempfloat ;
  int nutnum ;

  {
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 493
    header((char *)"NUT:  Add a Labeled Food");
#line 494
    label_nut_list(-1);
#line 495
    printf((char const   */* __restrict  */)"\nType number of nutrient to set (or <enter> to quit):  ");
#line 496
    nutnum = get_int();
    }
#line 497
    if (nutnum < 1) {
#line 497
      return;
    } else
#line 497
    if (nutnum > *(ScreenMap[options.screen])) {
#line 497
      return;
    }
    {
#line 498
    nutnum = *(ScreenMap[options.screen] + nutnum);
#line 500
    header((char *)"NUT:  Add a Labeled Food");
#line 501
    label_nut_list(nutnum);
#line 502
    printf((char const   */* __restrict  */)"\nEnter value for %s or <enter> to blank value:  ",
           Nutrient[nutnum]);
#line 503
    get_nut_value(& tempfloat);
    }
#line 504
    if (options.screen == 0) {
#line 504
      if (nutnum != 111) {
#line 504
        if (nutnum != 112) {
#line 504
          if (nutnum != 152) {
#line 504
            if (nutnum != 147) {
#line 504
              if (nutnum != 148) {
#line 504
                if (nutnum != 155) {
#line 504
                  if (nutnum != 149) {
#line 504
                    if (nutnum != 150) {
#line 504
                      if (nutnum != 151) {
#line 504
                        if (nutnum != 146) {
#line 504
                          tempfloat = (tempfloat / (float )100) * DVBase[nutnum];
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 505
    food_work.nutrient[nutnum] = tempfloat;
#line 506
    if (nutnum == 158) {
#line 506
      food_work.nutrient[36] = (tempfloat * (float )2) / (float )3;
    }
#line 507
    if (nutnum == 147) {
#line 507
      food_work.nutrient[95] = tempfloat;
    }
#line 508
    if (nutnum == 148) {
#line 508
      food_work.nutrient[97] = tempfloat;
    }
#line 509
    if (nutnum == 149) {
#line 509
      food_work.nutrient[96] = tempfloat;
    }
#line 510
    if (nutnum == 150) {
#line 510
      food_work.nutrient[104] = tempfloat;
    }
#line 511
    if (nutnum == 151) {
#line 511
      food_work.nutrient[98] = tempfloat;
    }
#line 512
    if (nutnum == 4) {
#line 512
      food_work.nutrient[16] = (float )((double )tempfloat * 4.1835);
    }
#line 513
    if (nutnum == 36) {
#line 513
      food_work.nutrient[158] = (tempfloat * (float )3) / (float )2;
    }
#line 514
    if (nutnum == 95) {
#line 514
      food_work.nutrient[147] = tempfloat;
    }
#line 515
    if (nutnum == 97) {
#line 515
      food_work.nutrient[148] = tempfloat;
    }
#line 516
    if (nutnum == 96) {
#line 516
      food_work.nutrient[149] = tempfloat;
    }
#line 517
    if (nutnum == 104) {
#line 517
      food_work.nutrient[150] = tempfloat;
    }
#line 518
    if (nutnum == 98) {
#line 518
      food_work.nutrient[151] = tempfloat;
    }
#line 519
    if (nutnum == 16) {
#line 519
      food_work.nutrient[4] = (float )((double )tempfloat / 4.1835);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 523 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
void label_nut_list(int selection ) 
{ 
  int count ;
  int intdiv ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;

  {
#line 526
  if (*(ScreenMap[options.screen]) % 2 == 0) {
#line 526
    tmp = 0;
  } else {
#line 526
    tmp = 1;
  }
#line 526
  intdiv = *(ScreenMap[options.screen]) / 2 + tmp;
#line 527
  count = 0;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (*(ScreenMap[options.screen]) % 2 == 0) {
#line 527
      tmp___10 = 1;
    } else {
#line 527
      tmp___10 = 0;
    }
#line 527
    if (! (count <= *(ScreenMap[options.screen]) / 2 - tmp___10)) {
#line 527
      goto while_break;
    }
#line 529
    if (options.screen == 0) {
#line 531
      if (food_work.nutrient[*(ScreenMap[options.screen] + (count + 1))] >= (float )0) {
#line 531
        if (*(ScreenMap[options.screen] + (count + 1)) != 111) {
#line 531
          if (*(ScreenMap[options.screen] + (count + 1)) != 112) {
#line 531
            if (*(ScreenMap[options.screen] + (count + 1)) != 152) {
#line 531
              if (*(ScreenMap[options.screen] + (count + 1)) != 147) {
#line 531
                if (*(ScreenMap[options.screen] + (count + 1)) != 148) {
#line 531
                  if (*(ScreenMap[options.screen] + (count + 1)) != 155) {
#line 531
                    if (*(ScreenMap[options.screen] + (count + 1)) != 149) {
#line 531
                      if (*(ScreenMap[options.screen] + (count + 1)) != 150) {
#line 531
                        if (*(ScreenMap[options.screen] + (count + 1)) != 151) {
#line 531
                          if (*(ScreenMap[options.screen] + (count + 1)) != 146) {
#line 531
                            if (*(ScreenMap[options.screen] + (count + 1)) == selection) {
#line 531
                              tmp___0 = "*";
                            } else {
#line 531
                              tmp___0 = ".";
                            }
                            {
#line 531
                            printf((char const   */* __restrict  */)"     %2d%s %-14s%7.0f%% DV   ",
                                   count + 1, tmp___0, Nutrient[*(ScreenMap[options.screen] + (count + 1))],
                                   (double )((food_work.nutrient[*(ScreenMap[options.screen] + (count + 1))] / DVBase[*(ScreenMap[options.screen] + (count + 1))]) * (float )100));
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 532
      if (food_work.nutrient[*(ScreenMap[options.screen] + (count + 1))] < (float )0) {
#line 532
        if (*(ScreenMap[options.screen] + (count + 1)) != 111) {
#line 532
          if (*(ScreenMap[options.screen] + (count + 1)) != 112) {
#line 532
            if (*(ScreenMap[options.screen] + (count + 1)) != 152) {
#line 532
              if (*(ScreenMap[options.screen] + (count + 1)) != 147) {
#line 532
                if (*(ScreenMap[options.screen] + (count + 1)) != 148) {
#line 532
                  if (*(ScreenMap[options.screen] + (count + 1)) != 155) {
#line 532
                    if (*(ScreenMap[options.screen] + (count + 1)) != 149) {
#line 532
                      if (*(ScreenMap[options.screen] + (count + 1)) != 150) {
#line 532
                        if (*(ScreenMap[options.screen] + (count + 1)) != 151) {
#line 532
                          if (*(ScreenMap[options.screen] + (count + 1)) != 146) {
#line 532
                            if (*(ScreenMap[options.screen] + (count + 1)) == selection) {
#line 532
                              tmp___1 = "*";
                            } else {
#line 532
                              tmp___1 = ".";
                            }
                            {
#line 532
                            printf((char const   */* __restrict  */)"     %2d%s %-14s%7s%% DV   ",
                                   count + 1, tmp___1, Nutrient[*(ScreenMap[options.screen] + (count + 1))],
                                   "       ");
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 533
      if (food_work.nutrient[*(ScreenMap[options.screen] + (count + 1))] >= (float )0) {
#line 533
        if (*(ScreenMap[options.screen] + (count + 1)) == 111) {
#line 533
          goto _L;
        } else
#line 533
        if (*(ScreenMap[options.screen] + (count + 1)) == 112) {
#line 533
          goto _L;
        } else
#line 533
        if (*(ScreenMap[options.screen] + (count + 1)) == 152) {
#line 533
          goto _L;
        } else
#line 533
        if (*(ScreenMap[options.screen] + (count + 1)) == 147) {
#line 533
          goto _L;
        } else
#line 533
        if (*(ScreenMap[options.screen] + (count + 1)) == 148) {
#line 533
          goto _L;
        } else
#line 533
        if (*(ScreenMap[options.screen] + (count + 1)) == 155) {
#line 533
          goto _L;
        } else
#line 533
        if (*(ScreenMap[options.screen] + (count + 1)) == 149) {
#line 533
          goto _L;
        } else
#line 533
        if (*(ScreenMap[options.screen] + (count + 1)) == 150) {
#line 533
          goto _L;
        } else
#line 533
        if (*(ScreenMap[options.screen] + (count + 1)) == 151) {
#line 533
          goto _L;
        } else
#line 533
        if (*(ScreenMap[options.screen] + (count + 1)) == 146) {
          _L: /* CIL Label */ 
#line 533
          if (*(ScreenMap[options.screen] + (count + 1)) == selection) {
#line 533
            tmp___2 = "*";
          } else {
#line 533
            tmp___2 = ".";
          }
          {
#line 533
          printf((char const   */* __restrict  */)"     %2d%s %-14s %7.2f %-3s  ",
                 count + 1, tmp___2, Nutrient[*(ScreenMap[options.screen] + (count + 1))],
                 (double )food_work.nutrient[*(ScreenMap[options.screen] + (count + 1))],
                 Unit[*(ScreenMap[options.screen] + (count + 1))]);
          }
        }
      }
#line 534
      if (food_work.nutrient[*(ScreenMap[options.screen] + (count + 1))] < (float )0) {
#line 534
        if (*(ScreenMap[options.screen] + (count + 1)) == 111) {
#line 534
          goto _L___0;
        } else
#line 534
        if (*(ScreenMap[options.screen] + (count + 1)) == 112) {
#line 534
          goto _L___0;
        } else
#line 534
        if (*(ScreenMap[options.screen] + (count + 1)) == 152) {
#line 534
          goto _L___0;
        } else
#line 534
        if (*(ScreenMap[options.screen] + (count + 1)) == 147) {
#line 534
          goto _L___0;
        } else
#line 534
        if (*(ScreenMap[options.screen] + (count + 1)) == 148) {
#line 534
          goto _L___0;
        } else
#line 534
        if (*(ScreenMap[options.screen] + (count + 1)) == 155) {
#line 534
          goto _L___0;
        } else
#line 534
        if (*(ScreenMap[options.screen] + (count + 1)) == 149) {
#line 534
          goto _L___0;
        } else
#line 534
        if (*(ScreenMap[options.screen] + (count + 1)) == 150) {
#line 534
          goto _L___0;
        } else
#line 534
        if (*(ScreenMap[options.screen] + (count + 1)) == 151) {
#line 534
          goto _L___0;
        } else
#line 534
        if (*(ScreenMap[options.screen] + (count + 1)) == 146) {
          _L___0: /* CIL Label */ 
#line 534
          if (*(ScreenMap[options.screen] + (count + 1)) == selection) {
#line 534
            tmp___3 = "*";
          } else {
#line 534
            tmp___3 = ".";
          }
          {
#line 534
          printf((char const   */* __restrict  */)"     %2d%s %-14s %7s %-3s  ", count + 1,
                 tmp___3, Nutrient[*(ScreenMap[options.screen] + (count + 1))], "       ",
                 Unit[*(ScreenMap[options.screen] + (count + 1))]);
          }
        }
      }
#line 535
      if (count + intdiv < *(ScreenMap[options.screen])) {
#line 535
        if (food_work.nutrient[*(ScreenMap[options.screen] + ((count + 1) + intdiv))] >= (float )0) {
#line 535
          if (*(ScreenMap[options.screen] + ((count + 1) + intdiv)) == selection) {
#line 535
            tmp___4 = "*";
          } else {
#line 535
            tmp___4 = ".";
          }
          {
#line 535
          printf((char const   */* __restrict  */)"    %2d%s %-14s%7.0f%% DV\n", (count + 1) + intdiv,
                 tmp___4, Nutrient[*(ScreenMap[options.screen] + ((count + 1) + intdiv))],
                 (double )((food_work.nutrient[*(ScreenMap[options.screen] + ((count + 1) + intdiv))] / DVBase[*(ScreenMap[options.screen] + ((count + 1) + intdiv))]) * (float )100));
          }
        }
      }
#line 536
      if (count + intdiv < *(ScreenMap[options.screen])) {
#line 536
        if (food_work.nutrient[*(ScreenMap[options.screen] + ((count + 1) + intdiv))] < (float )0) {
#line 536
          if (*(ScreenMap[options.screen] + ((count + 1) + intdiv)) == selection) {
#line 536
            tmp___5 = "*";
          } else {
#line 536
            tmp___5 = ".";
          }
          {
#line 536
          printf((char const   */* __restrict  */)"    %2d%s %-14s%7s%% DV\n", (count + 1) + intdiv,
                 tmp___5, Nutrient[*(ScreenMap[options.screen] + ((count + 1) + intdiv))],
                 "       ");
          }
        }
      }
    } else {
#line 540
      if (food_work.nutrient[*(ScreenMap[options.screen] + (count + 1))] >= (float )0) {
#line 540
        if (*(ScreenMap[options.screen] + (count + 1)) == selection) {
#line 540
          tmp___6 = "*";
        } else {
#line 540
          tmp___6 = ".";
        }
        {
#line 540
        printf((char const   */* __restrict  */)"     %2d%s %-14s %7.2f %-3s  ", count + 1,
               tmp___6, Nutrient[*(ScreenMap[options.screen] + (count + 1))], (double )food_work.nutrient[*(ScreenMap[options.screen] + (count + 1))],
               Unit[*(ScreenMap[options.screen] + (count + 1))]);
        }
      }
#line 541
      if (food_work.nutrient[*(ScreenMap[options.screen] + (count + 1))] < (float )0) {
#line 541
        if (*(ScreenMap[options.screen] + (count + 1)) == selection) {
#line 541
          tmp___7 = "*";
        } else {
#line 541
          tmp___7 = ".";
        }
        {
#line 541
        printf((char const   */* __restrict  */)"     %2d%s %-14s %7s %-3s  ", count + 1,
               tmp___7, Nutrient[*(ScreenMap[options.screen] + (count + 1))], "       ",
               Unit[*(ScreenMap[options.screen] + (count + 1))]);
        }
      }
#line 542
      if (count + intdiv < *(ScreenMap[options.screen])) {
#line 542
        if (food_work.nutrient[*(ScreenMap[options.screen] + ((count + 1) + intdiv))] >= (float )0) {
#line 542
          if (*(ScreenMap[options.screen] + ((count + 1) + intdiv)) == selection) {
#line 542
            tmp___8 = "*";
          } else {
#line 542
            tmp___8 = ".";
          }
          {
#line 542
          printf((char const   */* __restrict  */)"    %2d%s %-14s %7.2f %-3s    \n",
                 (count + 1) + intdiv, tmp___8, Nutrient[*(ScreenMap[options.screen] + ((count + 1) + intdiv))],
                 (double )food_work.nutrient[*(ScreenMap[options.screen] + ((count + 1) + intdiv))],
                 Unit[*(ScreenMap[options.screen] + ((count + 1) + intdiv))]);
          }
        }
      }
#line 543
      if (count + intdiv < *(ScreenMap[options.screen])) {
#line 543
        if (food_work.nutrient[*(ScreenMap[options.screen] + ((count + 1) + intdiv))] < (float )0) {
#line 543
          if (*(ScreenMap[options.screen] + ((count + 1) + intdiv)) == selection) {
#line 543
            tmp___9 = "*";
          } else {
#line 543
            tmp___9 = ".";
          }
          {
#line 543
          printf((char const   */* __restrict  */)"    %2d%s %-14s %7s %-3s    \n",
                 (count + 1) + intdiv, tmp___9, Nutrient[*(ScreenMap[options.screen] + ((count + 1) + intdiv))],
                 "       ", Unit[*(ScreenMap[options.screen] + ((count + 1) + intdiv))]);
          }
        }
      }
    }
#line 545
    if (count + intdiv >= *(ScreenMap[options.screen])) {
      {
#line 545
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 527
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 547
  spacer(count);
  }
#line 548
  return;
}
}
#line 550 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
void get_nut_value(float *dest ) 
{ 
  char buff[128] ;
  double tmp ;
  int tmp___0 ;

  {
  {
#line 553
  fgets((char */* __restrict  */)(buff), 128, (FILE */* __restrict  */)stdin);
#line 554
  tmp___0 = strcmp((char const   *)(buff), "\n");
  }
#line 554
  if (tmp___0 == 0) {
#line 554
    *dest = (float )-1;
  } else {
    {
#line 555
    tmp = atof((char const   *)(buff));
#line 555
    *dest = (float )tmp;
    }
  }
#line 556
  return;
}
}
#line 558 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
void guess_recipe(void) 
{ 
  int i ;
  int j ;
  int savegramoption ;
  int cumlevel ;
  int ok ;
  int gt0dvnuts[39] ;
  int remaininggroupsassigner[39] ;
  int levelcumbuf[39] ;
  unsigned int tmp ;
  int levelminbuf[39] ;
  unsigned int tmp___0 ;
  int levelmaxbuf[39] ;
  unsigned int tmp___1 ;
  int parentheses[78] ;
  float gt0dvnutfactors[39] ;
  char *token ;
  struct food *recipe_ptr ;
  struct food *foodlist[78] ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 560
  cumlevel = 0;
#line 560
  ok = 0;
#line 563
  levelcumbuf[0] = 0;
#line 563
  levelcumbuf[1] = 0;
#line 563
  levelcumbuf[2] = 0;
#line 563
  levelcumbuf[3] = 0;
#line 563
  levelcumbuf[4] = 0;
#line 563
  levelcumbuf[5] = 0;
#line 563
  levelcumbuf[6] = 0;
#line 563
  levelcumbuf[7] = 0;
#line 563
  levelcumbuf[8] = 0;
#line 563
  levelcumbuf[9] = 0;
#line 563
  levelcumbuf[10] = 0;
#line 563
  levelcumbuf[11] = 0;
#line 563
  tmp = 12U;
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    if (tmp >= 39U) {
#line 563
      goto while_break;
    }
#line 563
    levelcumbuf[tmp] = 0;
#line 563
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  levelminbuf[0] = 0;
#line 564
  levelminbuf[1] = 0;
#line 564
  levelminbuf[2] = 0;
#line 564
  levelminbuf[3] = 0;
#line 564
  levelminbuf[4] = 0;
#line 564
  levelminbuf[5] = 0;
#line 564
  levelminbuf[6] = 0;
#line 564
  levelminbuf[7] = 0;
#line 564
  levelminbuf[8] = 0;
#line 564
  levelminbuf[9] = 0;
#line 564
  levelminbuf[10] = 0;
#line 564
  levelminbuf[11] = 0;
#line 564
  tmp___0 = 12U;
  {
#line 564
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 564
    if (tmp___0 >= 39U) {
#line 564
      goto while_break___0;
    }
#line 564
    levelminbuf[tmp___0] = 0;
#line 564
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 565
  levelmaxbuf[0] = 0;
#line 565
  levelmaxbuf[1] = 0;
#line 565
  levelmaxbuf[2] = 0;
#line 565
  levelmaxbuf[3] = 0;
#line 565
  levelmaxbuf[4] = 0;
#line 565
  levelmaxbuf[5] = 0;
#line 565
  levelmaxbuf[6] = 0;
#line 565
  levelmaxbuf[7] = 0;
#line 565
  levelmaxbuf[8] = 0;
#line 565
  levelmaxbuf[9] = 0;
#line 565
  levelmaxbuf[10] = 0;
#line 565
  levelmaxbuf[11] = 0;
#line 565
  tmp___1 = 12U;
  {
#line 565
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 565
    if (tmp___1 >= 39U) {
#line 565
      goto while_break___1;
    }
#line 565
    levelmaxbuf[tmp___1] = 0;
#line 565
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 573
  GRtotalquanta = 100;
#line 574
  GRfoodcount = 0;
#line 575
  GRnutcount = 0;
#line 576
  i = 0;
  {
#line 576
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 576
    if (! (i < 39)) {
#line 576
      goto while_break___2;
    }
#line 576
    remaininggroupsassigner[i] = 0;
#line 576
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 578
  j = 0;
  {
#line 578
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 578
    if (! (j < 39)) {
#line 578
      goto while_break___3;
    }
#line 578
    if (food_work.nutrient[DVMap[j]] > (float )0) {
#line 578
      tmp___2 = GRnutcount;
#line 578
      GRnutcount ++;
#line 578
      gt0dvnuts[tmp___2] = DVMap[j];
    }
#line 578
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 580
  recipe_ptr = & recipe_root;
  {
#line 581
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 581
    if ((unsigned long )recipe_ptr->next != (unsigned long )((void *)0)) {
#line 581
      if (! (GRfoodcount < 78)) {
#line 581
        goto while_break___4;
      }
    } else {
#line 581
      goto while_break___4;
    }
#line 583
    parentheses[GRfoodcount] = (recipe_ptr->next)->refuse;
#line 584
    tmp___3 = GRfoodcount;
#line 584
    GRfoodcount ++;
#line 584
    foodlist[tmp___3] = recipe_ptr->next;
#line 585
    recipe_ptr = recipe_ptr->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 588
  j = 0;
  {
#line 588
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 588
    if (! (j < GRnutcount)) {
#line 588
      goto while_break___5;
    }
#line 588
    gt0dvnutfactors[j] = food_work.grams / ((float )100 * food_work.nutrient[gt0dvnuts[j]]);
#line 588
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 589
  j = 0;
  {
#line 589
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 589
    if (! (j < GRnutcount)) {
#line 589
      goto while_break___6;
    }
#line 589
    i = 0;
    {
#line 589
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 589
      if (! (i < GRfoodcount)) {
#line 589
        goto while_break___7;
      }
#line 589
      GRquantamatrix[j][i] = (foodlist[i])->nutrient[gt0dvnuts[j]] * gt0dvnutfactors[j];
#line 589
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 589
    j ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 591
  i = GRfoodcount - 1;
  {
#line 591
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 591
    if (! (i >= 0)) {
#line 591
      goto while_break___8;
    }
#line 591
    cumlevel += parentheses[i];
#line 591
    i --;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 592
  if (cumlevel != 0) {
#line 592
    parentheses[GRfoodcount - 1] -= cumlevel;
  }
#line 593
  cumlevel = 1;
  {
#line 595
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 597
    i = GRfoodcount - 1;
    {
#line 597
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 597
      if (! (i >= 0)) {
#line 597
        goto while_break___10;
      }
#line 597
      if (parentheses[i] > -2) {
#line 597
        if (parentheses[i] < 2) {
#line 597
          ok = 1;
        }
      }
#line 597
      i --;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 598
    if (ok) {
#line 598
      goto while_break___9;
    }
#line 599
    i = GRfoodcount - 1;
    {
#line 599
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 599
      if (! (i >= 0)) {
#line 599
        goto while_break___11;
      }
#line 601
      if (parentheses[i] < -1) {
#line 601
        (parentheses[i]) ++;
      }
#line 602
      if (parentheses[i] > -1) {
#line 602
        (parentheses[i]) --;
      }
#line 599
      i --;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 606
  i = 0;
  {
#line 606
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 606
    if (! (i < GRfoodcount)) {
#line 606
      goto while_break___12;
    }
#line 608
    if (parentheses[i] > 1) {
#line 610
      j = i + 1;
      {
#line 610
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 610
        if (! (j < GRfoodcount)) {
#line 610
          goto while_break___13;
        }
#line 610
        if (parentheses[j] < 0) {
#line 610
          goto while_break___13;
        }
#line 610
        j ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 611
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 611
        if (parentheses[i] > 1) {
#line 611
          if (! (parentheses[j] < -1)) {
#line 611
            goto while_break___14;
          }
        } else {
#line 611
          goto while_break___14;
        }
#line 613
        (parentheses[i]) --;
#line 614
        (parentheses[j]) ++;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 606
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 619
  i = GRfoodcount - 1;
  {
#line 619
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 619
    if (! (i >= 0)) {
#line 619
      goto while_break___15;
    }
#line 621
    if (parentheses[i] < 0) {
#line 623
      cumlevel -= parentheses[i];
#line 624
      GRfoodlevel[i] = cumlevel;
    } else
#line 626
    if (parentheses[i] == 0) {
#line 628
      GRfoodlevel[i] = cumlevel;
    } else
#line 630
    if (parentheses[i] > 0) {
#line 632
      GRfoodlevel[i] = cumlevel;
#line 633
      cumlevel -= parentheses[i];
    }
#line 619
    i --;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 637
  i = GRfoodcount - 1;
  {
#line 637
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 637
    if (! (i >= 0)) {
#line 637
      goto while_break___16;
    }
#line 639
    if (parentheses[i] < 0) {
#line 641
      j = GRfoodlevel[i] + parentheses[i];
      {
#line 641
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 641
        if (! (j < GRfoodlevel[i])) {
#line 641
          goto while_break___17;
        }
#line 641
        (remaininggroupsassigner[j]) ++;
#line 641
        j ++;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 642
      j = GRfoodlevel[i];
      {
#line 642
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 642
        if (! (j < 39)) {
#line 642
          goto while_break___18;
        }
#line 642
        remaininggroupsassigner[j] = 1;
#line 642
        j ++;
      }
      while_break___18: /* CIL Label */ ;
      }
    } else {
#line 644
      (remaininggroupsassigner[GRfoodlevel[i]]) ++;
    }
#line 645
    j = GRfoodlevel[i];
    {
#line 645
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 645
      if (! (j >= 0)) {
#line 645
        goto while_break___19;
      }
#line 645
      GRgroupsremaining[i][j] = remaininggroupsassigner[j];
#line 645
      j --;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 637
    i --;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 648
  GRlowestlevelchange[0] = 0;
#line 649
  i = GRfoodcount - 1;
  {
#line 649
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 649
    if (! (i > 0)) {
#line 649
      goto while_break___20;
    }
#line 651
    j = 0;
    {
#line 651
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 651
      if (! (j <= GRfoodlevel[i])) {
#line 651
        goto while_break___21;
      }
#line 653
      if (GRgroupsremaining[i - 1][j] == GRgroupsremaining[i][j]) {
#line 653
        goto __Cont;
      }
#line 654
      GRlowestlevelchange[i] = j;
#line 655
      goto while_break___21;
      __Cont: /* CIL Label */ 
#line 651
      j ++;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 649
    i --;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 659
  GRbestvariance = (float )1e38;
#line 661
  i = 0;
  {
#line 661
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 661
    if (! (i < GRfoodcount)) {
#line 661
      goto while_break___22;
    }
#line 661
    GRfoodslots[i] = 0;
#line 661
    i ++;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 662
  if (GRfoodcount > 10) {
#line 662
    GRtotalquanta = 40;
  }
  {
#line 663
  levelminbuf[0] = GRtotalquanta;
#line 663
  levelcumbuf[0] = levelminbuf[0];
#line 665
  solve_it(0, levelcumbuf, levelminbuf, levelmaxbuf);
#line 667
  i = 0;
  }
  {
#line 667
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 667
    if (! (i < GRfoodcount)) {
#line 667
      goto while_break___23;
    }
#line 667
    (foodlist[i])->grams = ((float )GRsaveslots[i] * food_work.grams) / (float )GRtotalquanta;
#line 667
    i ++;
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 669
  header((char *)"NUT:  Add a Labeled Food");
#line 670
  savegramoption = (int )options.grams;
#line 671
  options.grams = (char)1;
#line 672
  recipe_show(1, 1);
#line 673
  options.grams = (char )savegramoption;
#line 674
  options.screen = 0;
#line 675
  i = 0;
  }
  {
#line 675
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 675
    if (! (i < 159)) {
#line 675
      goto while_break___24;
    }
#line 675
    recipe_root.nutrient[i] = NoData;
#line 675
    i ++;
  }
  while_break___24: /* CIL Label */ ;
  }
#line 676
  recipe_ptr = & recipe_root;
  {
#line 677
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 677
    if (! ((unsigned long )recipe_ptr->next != (unsigned long )((void *)0))) {
#line 677
      goto while_break___25;
    }
#line 679
    recipe_ptr = recipe_ptr->next;
#line 680
    i = 0;
    {
#line 680
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 680
      if (! (i < 159)) {
#line 680
        goto while_break___26;
      }
#line 680
      recipe_root.nutrient[i] += (recipe_ptr->nutrient[i] * recipe_ptr->grams) / (float )100;
#line 680
      i ++;
    }
    while_break___26: /* CIL Label */ ;
    }
  }
  while_break___25: /* CIL Label */ ;
  }
#line 682
  i = 0;
  {
#line 682
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 682
    if (! (i < 159)) {
#line 682
      goto while_break___27;
    }
#line 684
    if (food_work.nutrient[i] > (float )0) {
#line 684
      recipe_root.nutrient[i] = food_work.nutrient[i];
    }
#line 685
    food_work.nutrient[i] = recipe_root.nutrient[i];
#line 686
    recipe_root.nutrient[i] = (float )0;
#line 682
    i ++;
  }
  while_break___27: /* CIL Label */ ;
  }
  {
#line 688
  compute_derived_fields(& food_work);
#line 689
  token = (char *)((void *)0);
  }
  {
#line 690
  while (1) {
    while_continue___28: /* CIL Label */ ;
#line 690
    if (! ((unsigned long )recipe_root.next != (unsigned long )((void *)0))) {
#line 690
      goto while_break___28;
    }
    {
#line 690
    modify_recipe_food(1, token);
    }
  }
  while_break___28: /* CIL Label */ ;
  }
#line 691
  return;
}
}
#line 693 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
void solve_it(int foodno , int *oldlevelcumbuf , int *oldlevelminbuf , int *oldlevelmaxbuf ) 
{ 
  float newvariance ;
  int max ;
  int min ;
  int x ;
  int i ;
  int j ;
  int prevquanta ;
  int availquanta ;
  int localavailquanta ;
  int levelcumbuf[39] ;
  int levelminbuf[39] ;
  int levelmaxbuf[39] ;
  int progressfactor ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 698
  progressfactor = 0;
#line 700
  i = 0;
  {
#line 700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 700
    if (! (i <= GRfoodlevel[foodno])) {
#line 700
      goto while_break;
    }
#line 700
    levelcumbuf[i] = *(oldlevelcumbuf + i);
#line 700
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 701
  i = 0;
  {
#line 701
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 701
    if (! (i <= GRfoodlevel[foodno])) {
#line 701
      goto while_break___0;
    }
#line 701
    levelminbuf[i] = *(oldlevelminbuf + i);
#line 701
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 702
  i = 0;
  {
#line 702
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 702
    if (! (i <= GRfoodlevel[foodno])) {
#line 702
      goto while_break___1;
    }
#line 702
    levelmaxbuf[i] = *(oldlevelmaxbuf + i);
#line 702
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 703
  if (GRlowestlevelchange[foodno] < GRfoodlevel[foodno]) {
#line 705
    levelmaxbuf[GRlowestlevelchange[foodno]] = *(oldlevelcumbuf + GRlowestlevelchange[foodno]);
#line 706
    levelmaxbuf[0] = GRlowestlevelchange[foodno];
  }
#line 708
  if (foodno == 0) {
#line 710
    i = 0;
    {
#line 710
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 710
      if (! (i <= GRfoodlevel[foodno])) {
#line 710
        goto while_break___2;
      }
#line 710
      levelmaxbuf[i] = *(oldlevelcumbuf + 0);
#line 710
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 711
    levelmaxbuf[0] = 1;
  }
#line 714
  prevquanta = levelcumbuf[GRlowestlevelchange[foodno]];
#line 715
  i = GRlowestlevelchange[foodno];
  {
#line 715
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 715
    if (! (i <= GRfoodlevel[foodno])) {
#line 715
      goto while_break___3;
    }
#line 715
    levelcumbuf[i] = 0;
#line 715
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 716
  availquanta = levelminbuf[0] - levelcumbuf[0];
#line 718
  if (availquanta < prevquanta) {
#line 718
    max = availquanta;
  } else {
#line 718
    max = prevquanta;
  }
#line 718
  localavailquanta = max;
#line 719
  if (GRlowestlevelchange[foodno] == GRfoodlevel[foodno]) {
#line 721
    i = 1;
    {
#line 721
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 721
      if (! (i <= levelmaxbuf[0])) {
#line 721
        goto while_break___4;
      }
#line 721
      if (localavailquanta > levelmaxbuf[i] - levelcumbuf[i]) {
#line 721
        localavailquanta = levelmaxbuf[i] - levelcumbuf[i];
      }
#line 721
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 722
    max = localavailquanta;
  }
#line 725
  if (GRlowestlevelchange[foodno] <= 1) {
#line 727
    if (availquanta % GRgroupsremaining[foodno][1] > 0) {
#line 727
      tmp = 1;
    } else {
#line 727
      tmp = 0;
    }
#line 727
    levelminbuf[1] = availquanta / GRgroupsremaining[foodno][1] + tmp;
#line 728
    i = 2;
    {
#line 728
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 728
      if (! (i <= GRfoodlevel[foodno])) {
#line 728
        goto while_break___5;
      }
#line 728
      if (levelminbuf[i - 1] % GRgroupsremaining[foodno][i] > 0) {
#line 728
        tmp___0 = 1;
      } else {
#line 728
        tmp___0 = 0;
      }
#line 728
      levelminbuf[i] = levelminbuf[i - 1] / GRgroupsremaining[foodno][i] + tmp___0;
#line 728
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
#line 733
    if ((levelminbuf[GRlowestlevelchange[foodno] - 1] - levelcumbuf[GRlowestlevelchange[foodno] - 1]) % GRgroupsremaining[foodno][GRlowestlevelchange[foodno]] > 0) {
#line 733
      tmp___1 = 1;
    } else {
#line 733
      tmp___1 = 0;
    }
#line 733
    levelminbuf[GRlowestlevelchange[foodno]] = (levelminbuf[GRlowestlevelchange[foodno] - 1] - levelcumbuf[GRlowestlevelchange[foodno] - 1]) / GRgroupsremaining[foodno][GRlowestlevelchange[foodno]] + tmp___1;
#line 734
    i = GRlowestlevelchange[foodno] + 1;
    {
#line 734
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 734
      if (! (i <= GRfoodlevel[foodno])) {
#line 734
        goto while_break___6;
      }
#line 734
      if (levelminbuf[i - 1] % GRgroupsremaining[foodno][i] > 0) {
#line 734
        tmp___2 = 1;
      } else {
#line 734
        tmp___2 = 0;
      }
#line 734
      levelminbuf[i] = levelminbuf[i - 1] / GRgroupsremaining[foodno][i] + tmp___2;
#line 734
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 737
  min = levelminbuf[GRfoodlevel[foodno]];
#line 738
  if (min < 0) {
#line 738
    min = 0;
  }
#line 740
  if (! foodno) {
    {
#line 742
    progressfactor = min + 79;
#line 743
    printf((char const   */* __restrict  */)"\nStarting calculation...\n");
    }
  }
#line 746
  i = 0;
  {
#line 746
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 746
    if (! (i <= GRfoodlevel[foodno])) {
#line 746
      goto while_break___7;
    }
#line 746
    levelcumbuf[i] += max + 1;
#line 746
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 748
  x = max;
  {
#line 748
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 748
    if (! (x >= min)) {
#line 748
      goto while_break___8;
    }
#line 750
    newvariance = (float )0;
#line 751
    i = 0;
    {
#line 751
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 751
      if (! (i <= GRfoodlevel[foodno])) {
#line 751
        goto while_break___9;
      }
#line 751
      (levelcumbuf[i]) --;
#line 751
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 752
    if (! foodno) {
#line 754
      i = 0;
      {
#line 754
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 754
        if (! (i < progressfactor - x)) {
#line 754
          goto while_break___10;
        }
        {
#line 754
        printf((char const   */* __restrict  */)"=");
#line 754
        i ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 755
      if (i > 0) {
        {
#line 755
        printf((char const   */* __restrict  */)">\n");
        }
      }
    }
#line 757
    GRfoodslots[foodno] = x;
#line 758
    i = foodno + 1;
    {
#line 758
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 758
      if (! (i < GRfoodcount)) {
#line 758
        goto while_break___11;
      }
#line 758
      GRfoodslots[i] = 0;
#line 758
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 759
    if (availquanta - x > 0) {
      {
#line 759
      solve_it(foodno + 1, levelcumbuf, levelminbuf, levelmaxbuf);
      }
    } else {
#line 762
      j = 0;
      {
#line 762
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 762
        if (! (j < GRnutcount)) {
#line 762
          goto while_break___12;
        }
#line 764
        GRnutslots[j] = (float )(0 - GRtotalquanta);
#line 765
        i = 0;
        {
#line 765
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 765
          if (! (i <= foodno)) {
#line 765
            goto while_break___13;
          }
#line 765
          GRnutslots[j] += (float )GRfoodslots[i] * GRquantamatrix[j][i];
#line 765
          i ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 766
        newvariance += GRnutslots[j] * GRnutslots[j];
#line 762
        j ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 768
      if (newvariance < GRbestvariance) {
#line 770
        GRbestvariance = newvariance;
#line 771
        i = 0;
        {
#line 771
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 771
          if (! (i < GRfoodcount)) {
#line 771
            goto while_break___14;
          }
#line 771
          GRsaveslots[i] = GRfoodslots[i];
#line 771
          i ++;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
    }
#line 748
    x --;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 775
  return;
}
}
#line 777 "/home/wheatley/newnew/temp/nut-nutrition-15.5/addfood.c"
void modify_servings(void) 
{ 
  char buf[1000] ;
  char *result[61] ;
  char servdisp[120] ;
  char junk ;
  struct food *food_ptr ;
  float ratio ;
  float one ;
  int resultcount ;
  int i ;
  int choice ;
  int *resultparm ;
  char *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 783
  food_ptr = (struct food *)((void *)0);
#line 784
  ratio = (float )-1;
#line 784
  one = (float )1;
#line 786
  resultparm = & resultcount;
#line 787
  key_clean();
  }
  {
#line 788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 790
    if (ratio <= (float )0) {
      {
#line 792
      food_ptr = food_choice((char *)"NUT:  Modify Serving Sizes", 0);
      }
#line 793
      if ((unsigned long )food_ptr == (unsigned long )((struct food *)-1)) {
#line 793
        return;
      }
#line 794
      if ((unsigned long )food_ptr == (unsigned long )((struct food *)0)) {
        {
#line 794
        key_clean();
        }
      }
#line 795
      if ((unsigned long )food_ptr == (unsigned long )((struct food *)0)) {
#line 795
        goto __Cont;
      }
    }
    {
#line 797
    header((char *)"NUT:  Modify Serving Sizes");
    }
#line 798
    if (ratio > (float )0) {
      {
#line 798
      food_show(food_ptr, & ratio);
      }
    } else {
      {
#line 799
      food_show(food_ptr, & one);
      }
    }
    {
#line 800
    get_select(& ratio);
    }
#line 801
    if (ratio == (float )-383838) {
      {
#line 801
      key_take();
      }
    } else {
      {
#line 804
      resultcount = 0;
#line 805
      read_weightlib(food_ptr->ndb_no, buf, (int )sizeof(buf), result, resultparm);
#line 806
      header((char *)"NUT:  Modify Serving Sizes");
#line 807
      printf((char const   */* __restrict  */)"%-60s   Grams  %8.2f\n", food_ptr->name,
             (double )food_ptr->grams);
#line 808
      tmp = format_serving(servdisp, & one, food_ptr);
#line 808
      printf((char const   */* __restrict  */)"Serving:  %-50s   Ounces: %7.2f\n\n",
             tmp, (double )food_ptr->grams / 28.349523);
#line 809
      i = 1;
      }
      {
#line 809
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 809
        if (! (i <= resultcount / 3)) {
#line 809
          goto while_break___0;
        }
        {
#line 811
        strcpy((char */* __restrict  */)(servdisp), (char const   */* __restrict  */)result[3 * i - 3]);
#line 812
        strcat((char */* __restrict  */)(servdisp), (char const   */* __restrict  */)" ");
#line 813
        strcat((char */* __restrict  */)(servdisp), (char const   */* __restrict  */)result[3 * i - 2]);
#line 814
        servdisp[60] = (char )'\000';
#line 815
        tmp___0 = atof((char const   *)result[3 * i - 1]);
#line 815
        printf((char const   */* __restrict  */)"%2d.  %-60s %6.1f grams\n", i, servdisp,
               tmp___0);
#line 809
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 817
      printf((char const   */* __restrict  */)"%2d.  I will enter my own serving size in grams or ounces.\n",
             i);
#line 818
      spacer(i + 2);
#line 819
      printf((char const   */* __restrict  */)"Select your choice, or just press <enter> to retain current serving:  ");
#line 820
      choice = get_int();
      }
#line 821
      if (choice < 1) {
        {
#line 823
        ratio = (float )0;
#line 824
        key_clean();
        }
#line 825
        goto __Cont;
      } else
#line 821
      if (choice > i) {
        {
#line 823
        ratio = (float )0;
#line 824
        key_clean();
        }
#line 825
        goto __Cont;
      }
#line 827
      if (choice != i) {
        {
#line 829
        tmp___1 = atof((char const   *)result[3 * choice - 3]);
#line 829
        food_ptr->qty = (float )tmp___1;
#line 830
        strncpy((char */* __restrict  */)(food_ptr->unit), (char const   */* __restrict  */)result[3 * choice - 2],
                (size_t )50);
#line 831
        tmp___2 = atof((char const   *)result[3 * choice - 1]);
#line 831
        food_ptr->grams = (float )tmp___2;
        }
      }
#line 833
      if (choice == i) {
        {
#line 835
        junk = (char )'n';
#line 836
        header((char *)"NUT:  Modify Serving Sizes");
#line 837
        printf((char const   */* __restrict  */)"%-60s   Grams  %8s\n", food_ptr->name,
               "?");
#line 838
        printf((char const   */* __restrict  */)"Serving:  %-50s   Ounces  %7s\n\n",
               " ", "?");
#line 839
        spacer(3);
        }
        {
#line 840
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 840
          if (! ((int )junk == 110)) {
#line 840
            if (! ((int )junk == 78)) {
#line 840
              goto while_break___1;
            }
          }
          {
#line 842
          printf((char const   */* __restrict  */)"\nType new weight of serving {#g for grams, #o for oz}:  ");
#line 843
          get_recipe_qty(& food_work.grams);
#line 844
          header((char *)"NUT:  Modify Serving Sizes");
#line 845
          printf((char const   */* __restrict  */)"%-60s   Grams  %8.2f\n", food_ptr->name,
                 (double )food_work.grams);
#line 846
          printf((char const   */* __restrict  */)"Serving:  %-50s   Ounces  %7.2f\n\n",
                 " ", (double )food_work.grams / 28.349523);
#line 847
          spacer(3);
#line 848
          printf((char const   */* __restrict  */)"\nIs weight now correct?  (y/n):  ");
#line 849
          tmp___3 = get_char();
#line 849
          junk = (char )tmp___3;
          }
#line 850
          if (food_work.grams == (float )0) {
#line 850
            junk = (char )'n';
          }
#line 851
          if ((int )junk == 110) {
#line 851
            if ((int )junk == 121) {
#line 851
              if ((int )junk == 78) {
#line 851
                if ((int )junk == 89) {
#line 851
                  junk = (char )'n';
                }
              }
            }
          }
#line 852
          if ((int )junk == 110) {
            {
#line 854
            header((char *)"NUT:  Modify Serving Sizes");
#line 855
            printf((char const   */* __restrict  */)"%-60s   Grams  %8s\n", food_ptr->name,
                   "?");
#line 856
            printf((char const   */* __restrict  */)"Serving:  %-50s   Ounces  %7s\n\n",
                   " ", "?");
#line 857
            spacer(3);
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 860
        header((char *)"NUT:  Modify Serving Sizes");
#line 861
        printf((char const   */* __restrict  */)"%-60s   Grams  %8.2f\n", food_ptr->name,
               (double )food_work.grams);
#line 862
        printf((char const   */* __restrict  */)"Serving:  %-50s   Ounces  %7.2f\n\n",
               "?", (double )food_work.grams / 28.349523);
#line 863
        spacer(3);
#line 864
        junk = (char )'n';
        }
        {
#line 865
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 865
          if (! ((int )junk == 110)) {
#line 865
            goto while_break___2;
          }
          {
#line 867
          printf((char const   */* __restrict  */)"\nPlease enter serving unit (cup, tbsp, piece...):  ");
#line 868
          get_string(food_work.unit, 50);
#line 869
          header((char *)"NUT:  Modify Serving Sizes");
#line 870
          printf((char const   */* __restrict  */)"%-60s   Grams  %8.2f\n", food_ptr->name,
                 (double )food_work.grams);
#line 871
          printf((char const   */* __restrict  */)"Serving:  %-50s   Ounces  %7.2f\n\n",
                 "?", (double )food_work.grams / 28.349523);
#line 872
          spacer(3);
#line 873
          printf((char const   */* __restrict  */)"\nIs \"%-s\" correct?  (y/n)  ",
                 food_work.unit);
#line 874
          tmp___4 = get_char();
#line 874
          junk = (char )tmp___4;
          }
#line 875
          if ((int )junk == 78) {
#line 875
            junk = (char )'n';
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 877
        junk = (char )'n';
        {
#line 878
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 878
          if (! ((int )junk == 110)) {
#line 878
            goto while_break___3;
          }
          {
#line 880
          header((char *)"NUT:  Modify Serving Sizes");
#line 881
          printf((char const   */* __restrict  */)"%-60s   Grams  %8.2f\n", food_ptr->name,
                 (double )food_work.grams);
#line 882
          tmp___5 = format_serving(servdisp, & one, & food_work);
#line 882
          printf((char const   */* __restrict  */)"Serving:  %-50s   Ounces  %7.2f\n\n",
                 tmp___5, (double )food_work.grams / 28.349523);
#line 883
          spacer(3);
#line 884
          printf((char const   */* __restrict  */)"\nPlease enter number of serving units:  ");
#line 885
          food_work.qty = get_float();
          }
#line 886
          if (food_work.qty <= (float )0) {
#line 886
            food_work.qty = (float )1;
          }
          {
#line 887
          header((char *)"NUT:  Modify Serving Sizes");
#line 888
          printf((char const   */* __restrict  */)"%-60s   Grams  %8.2f\n", food_ptr->name,
                 (double )food_work.grams);
#line 889
          tmp___6 = format_serving(servdisp, & one, & food_work);
#line 889
          printf((char const   */* __restrict  */)"Serving:  %-50s   Ounces  %7.2f\n\n",
                 tmp___6, (double )food_work.grams / 28.349523);
#line 890
          spacer(3);
#line 891
          printf((char const   */* __restrict  */)"\nIs \"%-1.2f\" the correct number of serving units?  (y/n)  ",
                 (double )food_work.qty);
#line 892
          tmp___7 = get_char();
#line 892
          junk = (char )tmp___7;
          }
#line 893
          if ((int )junk == 78) {
#line 893
            junk = (char )'n';
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 895
        food_ptr->grams = food_work.grams;
#line 896
        food_ptr->qty = food_work.qty;
#line 897
        strncpy((char */* __restrict  */)(food_ptr->unit), (char const   */* __restrict  */)(food_work.unit),
                (size_t )50);
        }
      }
      {
#line 899
      ratio = (float )1;
#line 900
      write_food_db();
#line 901
      write_serving(food_ptr);
#line 902
      header((char *)"NUT:  Modify Serving Sizes");
#line 903
      food_show(food_ptr, & ratio);
#line 904
      printf((char const   */* __restrict  */)"\nServing size saved in food database.  Press <enter> to continue...  ");
#line 905
      tmp___8 = get_int();
#line 905
      junk = (char )tmp___8;
#line 906
      food_work.name[0] = (char )'\000';
#line 907
      food_work.unit[0] = (char )'\000';
#line 908
      ratio = (float )0;
#line 909
      key_clean();
      }
#line 910
      goto __Cont;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 26 "/home/wheatley/newnew/temp/nut-nutrition-15.5/menu.h"
void view_nuts_menu(void) ;
#line 27
void add_foods_menu(void) ;
#line 28
void personal_menu(void) ;
#line 29
void screen_subvert_rank(int choice ) ;
#line 30
void screen_subvert_trendy(void) ;
#line 40 "/home/wheatley/newnew/temp/nut-nutrition-15.5/menu.c"
void menu(void) 
{ 
  int menu_choice ;

  {
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 45
    header((char *)"NUT:  Main Menu");
#line 46
    printf((char const   */* __restrict  */)"                  1  --  Record Meals\n\n");
#line 47
    printf((char const   */* __restrict  */)"                  2  --  Analyze Meals and Food Suggestions\n\n");
#line 48
    printf((char const   */* __restrict  */)"                  3  --  Delete Meals and Set Meals Per Day\n\n");
#line 49
    printf((char const   */* __restrict  */)"                  4  --  View Foods\n\n");
#line 50
    printf((char const   */* __restrict  */)"                  5  --  Add Foods and Modify Serving Sizes\n\n");
#line 51
    printf((char const   */* __restrict  */)"                  6  --  View Nutrients and Rank Foods\n\n");
#line 52
    printf((char const   */* __restrict  */)"                  7  --  Set Personal Options and Log Weight\n\n");
#line 53
    printf((char const   */* __restrict  */)"                  8  --  Plot Daily and Monthly Trends\n\n");
#line 54
    printf((char const   */* __restrict  */)"                  9  --  Record \"The Usual\"--Customary Meals\n\n");
#line 55
    printf((char const   */* __restrict  */)"                  P  --  Print Menus from Meal Database\n\n");
#line 56
    spacer(19);
#line 57
    printf((char const   */* __restrict  */)"Enter your choice (\"Q\" to quit):  ");
#line 58
    menu_choice = get_char();
    }
    {
#line 63
    if (menu_choice == 113) {
#line 63
      goto case_113;
    }
#line 63
    if (menu_choice == 81) {
#line 63
      goto case_113;
    }
#line 69
    if (menu_choice == 49) {
#line 69
      goto case_49;
    }
#line 71
    if (menu_choice == 50) {
#line 71
      goto case_50;
    }
#line 73
    if (menu_choice == 51) {
#line 73
      goto case_51;
    }
#line 75
    if (menu_choice == 52) {
#line 75
      goto case_52;
    }
#line 77
    if (menu_choice == 53) {
#line 77
      goto case_53;
    }
#line 79
    if (menu_choice == 54) {
#line 79
      goto case_54;
    }
#line 81
    if (menu_choice == 55) {
#line 81
      goto case_55;
    }
#line 83
    if (menu_choice == 56) {
#line 83
      goto case_56;
    }
#line 85
    if (menu_choice == 57) {
#line 85
      goto case_57;
    }
#line 88
    if (menu_choice == 112) {
#line 88
      goto case_112;
    }
#line 88
    if (menu_choice == 80) {
#line 88
      goto case_112;
    }
#line 90
    goto switch_default;
    case_113: /* CIL Label */ 
    case_81: /* CIL Label */ 
    {
#line 63
    printf((char const   */* __restrict  */)"\033[2JNUT has ended.\n\n");
    }
#line 67
    return;
#line 68
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 69
    record_meals();
    }
#line 70
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 71
    analyze_meals(& meal_root, 0);
    }
#line 72
    goto switch_break;
    case_51: /* CIL Label */ 
    {
#line 73
    remove_meals();
    }
#line 74
    goto switch_break;
    case_52: /* CIL Label */ 
    {
#line 75
    view_foods();
    }
#line 76
    goto switch_break;
    case_53: /* CIL Label */ 
    {
#line 77
    add_foods_menu();
    }
#line 78
    goto switch_break;
    case_54: /* CIL Label */ 
    {
#line 79
    view_nuts_menu();
    }
#line 80
    goto switch_break;
    case_55: /* CIL Label */ 
    {
#line 81
    personal_menu();
    }
#line 82
    goto switch_break;
    case_56: /* CIL Label */ 
    {
#line 83
    screen_subvert_trendy();
    }
#line 84
    goto switch_break;
    case_57: /* CIL Label */ 
    {
#line 85
    theusual();
    }
#line 86
    goto switch_break;
    case_112: /* CIL Label */ 
    case_80: /* CIL Label */ 
    {
#line 88
    print_menus();
    }
#line 89
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 90
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 95 "/home/wheatley/newnew/temp/nut-nutrition-15.5/menu.c"
void view_nuts_menu(void) 
{ 
  int menu_choice ;

  {
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 100
    header((char *)"NUT:  View Nutrients and Rank Foods");
#line 101
    printf((char const   */* __restrict  */)"\n\n                          1  --  Per 100 Grams\n\n");
#line 102
    printf((char const   */* __restrict  */)"                          2  --  Per 100 Grams Dry Weight\n\n");
#line 103
    printf((char const   */* __restrict  */)"                          3  --  Per 100 Grams within Food Group ?\n\n");
#line 104
    printf((char const   */* __restrict  */)"                          4  --  Per 100 Calories\n\n");
#line 105
    printf((char const   */* __restrict  */)"                          5  --  Per Serving\n\n");
#line 106
    printf((char const   */* __restrict  */)"                          6  --  Per Serving, Minimize ?\n\n");
#line 107
    printf((char const   */* __restrict  */)"                          7  --  Per Daily Recorded Meals\n\n");
#line 108
    spacer(16);
#line 109
    printf((char const   */* __restrict  */)"\nEnter your choice (just <enter> to quit):  ");
#line 110
    menu_choice = get_char();
#line 111
    Minut = -1;
#line 112
    Fdgrp = -1;
    }
    {
#line 115
    if (menu_choice == 49) {
#line 115
      goto case_49;
    }
#line 117
    if (menu_choice == 50) {
#line 117
      goto case_50;
    }
#line 119
    if (menu_choice == 51) {
#line 119
      goto case_51;
    }
#line 121
    if (menu_choice == 52) {
#line 121
      goto case_52;
    }
#line 123
    if (menu_choice == 53) {
#line 123
      goto case_53;
    }
#line 125
    if (menu_choice == 54) {
#line 125
      goto case_54;
    }
#line 127
    if (menu_choice == 55) {
#line 127
      goto case_55;
    }
#line 129
    goto switch_default;
    case_49: /* CIL Label */ 
    {
#line 115
    screen_subvert_rank(1);
    }
#line 116
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 117
    screen_subvert_rank(3);
    }
#line 118
    goto switch_break;
    case_51: /* CIL Label */ 
    {
#line 119
    screen_subvert_rank(6);
    }
#line 120
    goto switch_break;
    case_52: /* CIL Label */ 
    {
#line 121
    screen_subvert_rank(0);
    }
#line 122
    goto switch_break;
    case_53: /* CIL Label */ 
    {
#line 123
    screen_subvert_rank(4);
    }
#line 124
    goto switch_break;
    case_54: /* CIL Label */ 
    {
#line 125
    screen_subvert_rank(5);
    }
#line 126
    goto switch_break;
    case_55: /* CIL Label */ 
    {
#line 127
    screen_subvert_rank(2);
    }
#line 128
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 129
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 134 "/home/wheatley/newnew/temp/nut-nutrition-15.5/menu.c"
void add_foods_menu(void) 
{ 
  int menu_choice ;

  {
  {
#line 137
  header((char *)"NUT:  Add Foods and Modify Serving Sizes");
#line 138
  printf((char const   */* __restrict  */)"\n\n                           1  --  Add a Recipe\n\n");
#line 139
  printf((char const   */* __restrict  */)"                           2  --  Add a Labeled Food\n\n");
#line 140
  printf((char const   */* __restrict  */)"                           3  --  Modify Serving Sizes\n\n");
#line 141
  spacer(8);
#line 142
  printf((char const   */* __restrict  */)"\nEnter your choice (just <enter> to quit):  ");
#line 143
  menu_choice = get_char();
  }
  {
#line 146
  if (menu_choice == 49) {
#line 146
    goto case_49;
  }
#line 148
  if (menu_choice == 50) {
#line 148
    goto case_50;
  }
#line 150
  if (menu_choice == 51) {
#line 150
    goto case_51;
  }
#line 152
  goto switch_default;
  case_49: /* CIL Label */ 
  {
#line 146
  add_foods(0);
  }
#line 147
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 148
  add_foods(1);
  }
#line 149
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 150
  modify_servings();
  }
#line 151
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 152
  return;
  switch_break: /* CIL Label */ ;
  }
#line 154
  return;
}
}
#line 156 "/home/wheatley/newnew/temp/nut-nutrition-15.5/menu.c"
void screen_subvert_rank(int choice ) 
{ 
  int screen_choice ;
  int i ;

  {
  {
#line 159
  view_nuts(choice);
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    header((char *)"NUT:  View Nutrients and Rank Foods");
#line 163
    printf((char const   */* __restrict  */)"\n      Change group of nutrients to view?\n\n\n");
#line 164
    i = 0;
    }
    {
#line 164
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 164
      if (! (i < MaxScreen)) {
#line 164
        goto while_break___0;
      }
      {
#line 164
      printf((char const   */* __restrict  */)"                    %d  --  %s\n\n",
             i + 1, ScreenTitle[i]);
#line 164
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 165
    spacer(MaxScreen * 2 + 4);
#line 166
    printf((char const   */* __restrict  */)"\nEnter your choice (just <enter> to quit):  ");
#line 167
    screen_choice = get_int();
    }
#line 168
    if (screen_choice < 1) {
#line 168
      return;
    } else
#line 168
    if (screen_choice > MaxScreen) {
#line 168
      return;
    }
    {
#line 169
    options.screen = screen_choice - 1;
#line 170
    write_OPTIONS();
#line 171
    view_nuts(choice);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 175 "/home/wheatley/newnew/temp/nut-nutrition-15.5/menu.c"
void screen_subvert_trendy(void) 
{ 
  int screen_choice ;
  int i ;
  char mode ;

  {
  {
#line 178
  mode = (char )'d';
#line 179
  mode = trendy(mode);
  }
#line 180
  if ((int )mode == 88) {
#line 180
    return;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if ((int )mode == 100) {
      {
#line 183
      header((char *)"NUT:  Plot Daily Trends");
      }
    }
#line 184
    if ((int )mode != 100) {
      {
#line 184
      header((char *)"NUT:  Plot Monthly Trends");
      }
    }
    {
#line 185
    printf((char const   */* __restrict  */)"\n      Change group of nutrients to view?\n\n\n");
#line 186
    i = 0;
    }
    {
#line 186
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 186
      if (! (i < MaxScreen)) {
#line 186
        goto while_break___0;
      }
      {
#line 186
      printf((char const   */* __restrict  */)"                    %d  --  %s\n\n",
             i + 1, ScreenTitle[i]);
#line 186
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 187
    spacer(MaxScreen * 2 + 4);
#line 188
    printf((char const   */* __restrict  */)"\nEnter your choice (just <enter> to quit):  ");
#line 189
    screen_choice = get_int();
    }
#line 190
    if (screen_choice < 1) {
#line 190
      return;
    } else
#line 190
    if (screen_choice > MaxScreen) {
#line 190
      return;
    }
    {
#line 191
    options.screen = screen_choice - 1;
#line 192
    write_OPTIONS();
#line 193
    mode = trendy(mode);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 197 "/home/wheatley/newnew/temp/nut-nutrition-15.5/menu.c"
void personal_menu(void) 
{ 
  int menu_choice ;
  char calflag[40] ;
  char pcproteinflag[40] ;
  char pccarbflag[40] ;
  char pcsatfatflag[40] ;
  char abproteinflag[40] ;
  char abcarbflag[40] ;
  char abfiberflag[40] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;

  {
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (options.locknuts[4]) {
#line 209
      if ((int )options.autocal == 0) {
#line 209
        tmp___0 = "(LOCKED:";
      } else {
#line 209
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 209
      if ((int )options.autocal > 0) {
#line 209
        tmp = "(AUTO-SET:";
      } else {
#line 209
        tmp = "(SET:";
      }
#line 209
      tmp___0 = tmp;
    }
    {
#line 209
    sprintf((char */* __restrict  */)(calflag), (char const   */* __restrict  */)"%s  %5.1f %s",
            tmp___0, (double )options.abnuts[4], "kc)");
    }
#line 210
    if (options.locknuts[0]) {
#line 210
      if (options.pcprotein > (float )0) {
#line 210
        tmp___1 = "(LOCKED:";
      } else {
#line 210
        tmp___1 = "(SET:";
      }
    } else {
#line 210
      tmp___1 = "(SET:";
    }
    {
#line 210
    sprintf((char */* __restrict  */)(pcproteinflag), (char const   */* __restrict  */)"%s %5.1f%s",
            tmp___1, (double )options.pcprotein, "%)");
    }
#line 211
    if (options.locknuts[2]) {
#line 211
      if (options.pccarb > (float )0) {
#line 211
        tmp___2 = "(LOCKED:";
      } else {
#line 211
        tmp___2 = "(SET:";
      }
    } else {
#line 211
      tmp___2 = "(SET:";
    }
    {
#line 211
    sprintf((char */* __restrict  */)(pccarbflag), (char const   */* __restrict  */)"%s %5.1f%s",
            tmp___2, (double )options.pccarb, "%)");
    }
#line 212
    if (options.locknuts[84]) {
#line 212
      tmp___3 = "(LOCKED:";
    } else {
#line 212
      tmp___3 = "(SET:";
    }
    {
#line 212
    sprintf((char */* __restrict  */)(pcsatfatflag), (char const   */* __restrict  */)"%s %5.1f%s",
            tmp___3, (double )options.pcsatfat, "%)");
    }
#line 213
    if (options.locknuts[0]) {
#line 213
      if (options.abnuts[0] > (float )0) {
#line 213
        tmp___4 = "(LOCKED:";
      } else {
#line 213
        tmp___4 = "(SET:";
      }
    } else {
#line 213
      tmp___4 = "(SET:";
    }
    {
#line 213
    sprintf((char */* __restrict  */)(abproteinflag), (char const   */* __restrict  */)"%s  %5.1f %s",
            tmp___4, (double )options.abnuts[0], "g)");
    }
#line 214
    if (options.abnuts[2] >= (float )0) {
#line 214
      if (options.locknuts[2]) {
#line 214
        if (options.abnuts[2] > (float )0) {
#line 214
          tmp___5 = "(LOCKED:";
        } else {
#line 214
          tmp___5 = "(SET:";
        }
      } else {
#line 214
        tmp___5 = "(SET:";
      }
      {
#line 214
      sprintf((char */* __restrict  */)(abcarbflag), (char const   */* __restrict  */)"%s  %5.1f %s",
              tmp___5, (double )options.abnuts[2], "g)");
      }
    } else {
      {
#line 215
      sprintf((char */* __restrict  */)(abcarbflag), (char const   */* __restrict  */)"%s %5.1f %s",
              "(LOCKED:  Fiber +", (double )((float )-1 * options.abnuts[2]), "g)");
      }
    }
#line 216
    if (options.locknuts[19]) {
#line 216
      tmp___6 = "(LOCKED:";
    } else {
#line 216
      tmp___6 = "(SET:";
    }
    {
#line 216
    sprintf((char */* __restrict  */)(abfiberflag), (char const   */* __restrict  */)"%s %5.1f %s",
            tmp___6, (double )options.abnuts[19], "g)");
#line 217
    header((char *)"NUT:  Personal Options");
    }
#line 218
    if (options.abnuts[4] != (float )2000) {
#line 218
      tmp___7 = (char const   *)(calflag);
    } else
#line 218
    if (options.locknuts[4]) {
#line 218
      tmp___7 = (char const   *)(calflag);
    } else
#line 218
    if ((int )options.autocal > 0) {
#line 218
      tmp___7 = (char const   *)(calflag);
    } else {
#line 218
      tmp___7 = "(default)";
    }
    {
#line 218
    printf((char const   */* __restrict  */)"                1  --  Change Calorie Level %s\n\n",
           tmp___7);
    }
#line 219
    if (options.n6hufa == (float )0) {
#line 219
      if (options.abnuts[112] == (float )0) {
        {
#line 219
        printf((char const   */* __restrict  */)"                2  --  Essential Fatty Acid Options (default)\n\n");
        }
      } else {
#line 219
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 220
    if (options.locknuts[112] == 1) {
      {
#line 220
      printf((char const   */* __restrict  */)"                2  --  Essential Fatty Acid Options (LOCKED:  %3.1f g)\n\n",
             (double )options.abnuts[112]);
      }
    } else
#line 221
    if (options.n6hufa == (float )90) {
#line 221
      if (options.abnuts[112] == (float )0) {
        {
#line 221
        printf((char const   */* __restrict  */)"                2  --  Essential Fatty Acid Options (SET:  off)\n\n");
        }
      } else {
#line 221
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 222
    if (options.n6hufa > (float )0) {
#line 222
      if (options.abnuts[112] == (float )0) {
        {
#line 222
        printf((char const   */* __restrict  */)"                2  --  Essential Fatty Acid Options (SET:  %2.0f/%2.0f)\n\n",
               (double )options.n6hufa, (double )((float )100 - options.n6hufa));
        }
      } else {
#line 222
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 223
    if (options.abnuts[112] > (float )0) {
      {
#line 223
      printf((char const   */* __restrict  */)"                2  --  Essential Fatty Acid Options (SET:  %3.1f g)\n\n",
             (double )options.abnuts[112]);
      }
    }
#line 224
    if (options.pcsatfat) {
#line 224
      tmp___8 = (char const   *)(pcsatfatflag);
    } else {
#line 224
      tmp___8 = "(default)";
    }
    {
#line 224
    printf((char const   */* __restrict  */)"                3  --  Saturated Fat Percentage %s\n\n",
           tmp___8);
    }
#line 225
    if (options.abnuts[19]) {
#line 225
      tmp___9 = (char const   *)(abfiberflag);
    } else {
#line 225
      tmp___9 = "(default)";
    }
    {
#line 225
    printf((char const   */* __restrict  */)"                4  --  Fiber Absolute Amount %s\n\n",
           tmp___9);
    }
#line 226
    if (options.pccarb) {
#line 226
      tmp___10 = (char const   *)(pccarbflag);
    } else {
#line 226
      tmp___10 = "(default)";
    }
    {
#line 226
    printf((char const   */* __restrict  */)"                5  --  Carbohydrate Percentage %s\n\n",
           tmp___10);
    }
#line 227
    if (options.pcprotein) {
#line 227
      tmp___11 = (char const   *)(pcproteinflag);
    } else {
#line 227
      tmp___11 = "(default)";
    }
    {
#line 227
    printf((char const   */* __restrict  */)"                6  --  Protein Percentage %s\n\n",
           tmp___11);
    }
#line 228
    if (options.abnuts[2]) {
#line 228
      tmp___12 = (char const   *)(abcarbflag);
    } else {
#line 228
      tmp___12 = "(default)";
    }
    {
#line 228
    printf((char const   */* __restrict  */)"                7  --  Carbohydrate Absolute Amount %s\n\n",
           tmp___12);
    }
#line 229
    if (options.abnuts[0]) {
#line 229
      tmp___13 = (char const   *)(abproteinflag);
    } else {
#line 229
      tmp___13 = "(default)";
    }
    {
#line 229
    printf((char const   */* __restrict  */)"                8  --  Protein Absolute Amount %s\n\n",
           tmp___13);
#line 230
    printf((char const   */* __restrict  */)"                0  --  Restore All Defaults\n\n");
#line 231
    printf((char const   */* __restrict  */)"                W  --  Weight Log Regression\n");
#line 232
    spacer(19);
#line 233
    printf((char const   */* __restrict  */)"\nEnter your choice (just <enter> to quit):  ");
#line 234
    menu_choice = get_char();
    }
    {
#line 237
    if (menu_choice == 49) {
#line 237
      goto case_49;
    }
#line 239
    if (menu_choice == 50) {
#line 239
      goto case_50;
    }
#line 241
    if (menu_choice == 51) {
#line 241
      goto case_51;
    }
#line 243
    if (menu_choice == 52) {
#line 243
      goto case_52;
    }
#line 245
    if (menu_choice == 53) {
#line 245
      goto case_53;
    }
#line 247
    if (menu_choice == 54) {
#line 247
      goto case_54;
    }
#line 249
    if (menu_choice == 55) {
#line 249
      goto case_55;
    }
#line 251
    if (menu_choice == 56) {
#line 251
      goto case_56;
    }
#line 253
    if (menu_choice == 48) {
#line 253
      goto case_48;
    }
#line 256
    if (menu_choice == 87) {
#line 256
      goto case_87;
    }
#line 256
    if (menu_choice == 119) {
#line 256
      goto case_87;
    }
#line 258
    goto switch_default;
    case_49: /* CIL Label */ 
    {
#line 237
    personal_cal();
    }
#line 238
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 239
    efa_options();
    }
#line 240
    goto switch_break;
    case_51: /* CIL Label */ 
    {
#line 241
    satfat_percent();
    }
#line 242
    goto switch_break;
    case_52: /* CIL Label */ 
    {
#line 243
    fiber_absolute();
    }
#line 244
    goto switch_break;
    case_53: /* CIL Label */ 
    {
#line 245
    carb_percent();
    }
#line 246
    goto switch_break;
    case_54: /* CIL Label */ 
    {
#line 247
    protein_percent();
    }
#line 248
    goto switch_break;
    case_55: /* CIL Label */ 
    {
#line 249
    carb_absolute();
    }
#line 250
    goto switch_break;
    case_56: /* CIL Label */ 
    {
#line 251
    protein_absolute();
    }
#line 252
    goto switch_break;
    case_48: /* CIL Label */ 
    {
#line 253
    restore_defaults(1);
    }
#line 254
    goto switch_break;
    case_87: /* CIL Label */ 
    case_119: /* CIL Label */ 
    {
#line 256
    weight_log();
    }
#line 257
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 258
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
