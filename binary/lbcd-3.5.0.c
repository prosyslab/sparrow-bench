/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 52 "./server/protocol.h"
struct lbcd_service {
   uint32_t host_weight ;
   uint32_t host_incr ;
};
#line 61 "./server/protocol.h"
struct lbcd_header {
   uint16_t version ;
   uint16_t id ;
   uint16_t op ;
   uint16_t status ;
};
#line 75 "./server/protocol.h"
struct lbcd_reply {
   struct lbcd_header h ;
   uint32_t boot_time ;
   uint32_t current_time ;
   uint32_t user_mtime ;
   uint16_t l1 ;
   uint16_t l5 ;
   uint16_t l15 ;
   uint16_t tot_users ;
   uint16_t uniq_users ;
   uint8_t on_console ;
   uint8_t reserved ;
   uint8_t tmp_full ;
   uint8_t tmpdir_full ;
   uint8_t pad ;
   uint8_t services ;
   struct lbcd_service weights[6] ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 49 "./server/protocol.h"
typedef char lbcd_name_type[32];
#line 69 "./server/protocol.h"
struct lbcd_request {
   struct lbcd_header h ;
   lbcd_name_type names[5] ;
};
#line 32 "./server/internal.h"
struct vector;
#line 33 "./util/vector.h"
struct vector {
   size_t count ;
   size_t allocated ;
   char **strings ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 62 "/usr/include/search.h"
enum __anonenum_ACTION_30 {
    FIND = 0,
    ENTER = 1
} ;
#line 62 "/usr/include/search.h"
typedef enum __anonenum_ACTION_30 ACTION;
#line 69 "/usr/include/search.h"
struct entry {
   char *key ;
   void *data ;
};
#line 69 "/usr/include/search.h"
typedef struct entry ENTRY;
#line 42 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct __exit_status {
   short e_termination ;
   short e_exit ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct __anonstruct_ut_tv_32 {
   __int32_t tv_sec ;
   __int32_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct utmpx {
   short ut_type ;
   __pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct __exit_status ut_exit ;
   __int32_t ut_session ;
   struct __anonstruct_ut_tv_32 ut_tv ;
   __int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 271 "./portable/socket.h"
typedef int socket_type;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 38 "./server/internal.h"
typedef int weight_func_type(uint32_t * , uint32_t * , int  , char const   * , struct lbcd_reply * );
#line 24 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
struct service_mapping {
   char service[32] ;
   weight_func_type *function ;
};
#line 279 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 278 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_22 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_22 __in6_u ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_44 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_45 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_46 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_47 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_48 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_49 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_50 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_43 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_44 _kill ;
   struct __anonstruct__timer_45 _timer ;
   struct __anonstruct__rt_46 _rt ;
   struct __anonstruct__sigchld_47 _sigchld ;
   struct __anonstruct__sigfault_48 _sigfault ;
   struct __anonstruct__sigpoll_49 _sigpoll ;
   struct __anonstruct__sigsys_50 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_42 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_43 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_42 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_59 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_59 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 39 "./server/protocol.h"
enum lbcd_status {
    LBCD_STATUS_REQUEST = 0,
    LBCD_STATUS_OK = 1,
    LBCD_STATUS_ERROR = 2,
    LBCD_STATUS_VERSION = 3,
    LBCD_STATUS_PROTOCOL = 4,
    LBCD_STATUS_UNKNOWN_OP = 5
} ;
#line 55 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
struct lbcd_config {
   struct vector *bindaddrs ;
   _Bool log ;
   unsigned short port ;
   char const   *pid_file ;
   struct vector *services ;
   _Bool simple ;
   _Bool upstart ;
};
#line 69 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
struct request {
   struct sockaddr *addr ;
   socklen_t addrlen ;
   char *source ;
   unsigned int protocol ;
   unsigned int id ;
   unsigned int operation ;
   struct vector *services ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 166 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 29 "/usr/include/x86_64-linux-gnu/bits/statvfs.h"
struct statvfs {
   unsigned long f_bsize ;
   unsigned long f_frsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsfilcnt_t f_favail ;
   unsigned long f_fsid ;
   unsigned long f_flag ;
   unsigned long f_namemax ;
   int __f_spare[6] ;
};
#line 31 "./modules/monlist.h"
union __anonunion_Ul_i_44 {
   uint32_t Xl_ui ;
   int Xl_i ;
};
#line 31 "./modules/monlist.h"
union __anonunion_Ul_f_45 {
   uint32_t Xl_uf ;
   int Xl_f ;
};
#line 31 "./modules/monlist.h"
struct __anonstruct_l_fp_43 {
   union __anonunion_Ul_i_44 Ul_i ;
   union __anonunion_Ul_f_45 Ul_f ;
};
#line 31 "./modules/monlist.h"
typedef struct __anonstruct_l_fp_43 l_fp;
#line 44 "./modules/monlist.h"
struct req_pkt {
   uint8_t rm_vn_mode ;
   uint8_t auth_seq ;
   uint8_t implementation ;
   uint8_t request ;
   uint16_t err_nitems ;
   uint16_t mbz_itemsize ;
   char data[32] ;
   l_fp tstamp ;
   uint32_t keyid ;
};
#line 67 "./modules/monlist.h"
struct resp_pkt {
   uint8_t rm_vn_mode ;
   uint8_t auth_seq ;
   uint8_t implementation ;
   uint8_t request ;
   uint16_t err_nitems ;
   uint16_t mbz_itemsize ;
   char data[500] ;
};
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 216 "./portable/socket.h"
#pragma GCC visibility push(hidden)
#line 275
#pragma GCC visibility pop
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 74 "./server/internal.h"
int lbcd_load_weight(uint32_t *weight_val , uint32_t *incr_val , int timeout  __attribute__((__unused__)) ,
                     char const   *portarg  __attribute__((__unused__)) , struct lbcd_reply *lb ) ;
#line 27 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/load.c"
static int penalty[11]  = 
#line 27 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/load.c"
  {      2,      2,      2,      2, 
        4,      4,      4,      8, 
        8,      16,      32};
#line 44 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/load.c"
int lbcd_load_weight(uint32_t *weight_val , uint32_t *incr_val , int timeout  __attribute__((__unused__)) ,
                     char const   *portarg  __attribute__((__unused__)) , struct lbcd_reply *lb ) 
{ 
  int fudge ;
  int weight ;
  int tmp_used ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 51
  tmp = ntohs(lb->tot_users);
#line 51
  tmp___0 = ntohs(lb->uniq_users);
#line 51
  fudge = ((int )tmp - (int )tmp___0) * 20;
#line 52
  tmp___1 = ntohs(lb->uniq_users);
#line 52
  tmp___2 = ntohs(lb->l1);
#line 52
  weight = ((int )tmp___1 * 100 + 3 * (int )tmp___2) + fudge;
  }
#line 55
  if ((int )lb->tmp_full > (int )lb->tmpdir_full) {
#line 55
    tmp_used = (int )lb->tmp_full;
  } else {
#line 55
    tmp_used = (int )lb->tmpdir_full;
  }
#line 56
  if (tmp_used >= 90) {
#line 57
    if (tmp_used > 100) {
#line 58
      weight = (int )((uint32_t )-1);
    } else {
#line 60
      weight *= penalty[tmp_used - 90];
    }
  }
  {
#line 64
  tmp___3 = access("/etc/nologin", 0);
  }
#line 64
  if (tmp___3 == 0) {
#line 65
    weight = (int )((uint32_t )-1);
  }
#line 68
  *weight_val = (uint32_t )weight;
#line 69
  *incr_val = (uint32_t )200;
#line 70
  return (weight);
}
}
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 216 "./portable/socket.h"
#pragma GCC visibility push(hidden)
#line 275
#pragma GCC visibility pop
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 44 "./server/internal.h"
int kernel_getload(double *l1 , double *l5 , double *l15 ) ;
#line 45
int kernel_getboottime(time_t *boottime ) ;
#line 48
int get_user_stats(int *total , int *uniq , int *on_console , time_t *user_mtime ) ;
#line 52
int tmp_full(char const   *path ) ;
#line 55
void lbcd_pack_info(struct lbcd_reply *lb , unsigned int protocol , struct vector *services ,
                    int simple ) ;
#line 57
void lbcd_test(int argc , char **argv ) ;
#line 63
void lbcd_setweight(struct lbcd_reply *lb , int offset , char const   *service ) ;
#line 48 "./util/vector.h"
#pragma GCC visibility push(hidden)
#line 51
extern struct vector *( __attribute__((__warn_unused_result__)) vector_new)(void)  __attribute__((__malloc__)) ;
#line 57
extern void ( __attribute__((__nonnull__)) vector_add)(struct vector * , char const   *string ) ;
#line 89
extern void vector_free(struct vector * ) ;
#line 144
#pragma GCC visibility pop
#line 26 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/server.c"
static void lbcd_set_load(struct lbcd_reply *lb , struct vector *services ) 
{ 
  int i ;
  int numserv ;
  int tmp ;

  {
  {
#line 32
  lb->pad = (uint8_t )0;
#line 33
  numserv = (int )services->count;
#line 33
  lb->services = (uint8_t )numserv;
#line 36
  lbcd_setweight(lb, 0, "default");
#line 39
  tmp = access("/usr/local/etc/nolbcd", 0);
  }
#line 39
  if (tmp == 0) {
#line 40
    lb->weights[0].host_weight = (uint32_t )-1;
  }
  {
#line 43
  lb->weights[0].host_weight = htonl(lb->weights[0].host_weight);
#line 44
  lb->weights[0].host_incr = htonl(lb->weights[0].host_incr);
#line 47
  i = 1;
  }
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i <= numserv)) {
#line 47
      goto while_break;
    }
    {
#line 48
    lbcd_setweight(lb, i, (char const   *)*(services->strings + (i - 1)));
#line 49
    lb->weights[i].host_weight = htonl(lb->weights[i].host_weight);
#line 50
    lb->weights[i].host_incr = htonl(lb->weights[i].host_incr);
#line 47
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return;
}
}
#line 65 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/server.c"
static void lbcd_proto2_convert(struct lbcd_reply *lb ) 
{ 
  uint32_t weightval_i ;
  uint16_t weightval_s ;

  {
  {
#line 72
  weightval_i = ntohl(lb->weights[0].host_weight);
  }
#line 73
  if (weightval_i > 65535U) {
#line 74
    weightval_s = (uint16_t )-1;
  } else {
#line 76
    weightval_s = (uint16_t )weightval_i;
  }
  {
#line 82
  lb->l1 = htons(weightval_s);
#line 83
  lb->l5 = htons(weightval_s);
#line 84
  lb->l15 = htons(weightval_s);
#line 85
  lb->tot_users = (uint16_t )0;
#line 86
  lb->uniq_users = (uint16_t )0;
  }
#line 87
  return;
}
}
#line 93 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/server.c"
void lbcd_pack_info(struct lbcd_reply *lb , unsigned int protocol , struct vector *services ,
                    int simple ) 
{ 
  double l1 ;
  double l5 ;
  double l15 ;
  time_t bt ;
  time_t ct ;
  int tu ;
  int uu ;
  int oc ;
  time_t umtime ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 103
  kernel_getboottime(& bt);
#line 104
  lb->boot_time = htonl((uint32_t )bt);
#line 105
  time(& ct);
#line 106
  lb->current_time = htonl((uint32_t )ct);
#line 109
  kernel_getload(& l1, & l5, & l15);
#line 110
  lb->l1 = htons((uint16_t )(l1 * (double )100));
#line 111
  lb->l5 = htons((uint16_t )(l5 * (double )100));
#line 112
  lb->l15 = htons((uint16_t )(l15 * (double )100));
#line 115
  get_user_stats(& tu, & uu, & oc, & umtime);
#line 116
  lb->tot_users = htons((uint16_t )tu);
#line 117
  lb->uniq_users = htons((uint16_t )uu);
#line 118
  lb->on_console = (uint8_t )oc;
#line 119
  lb->user_mtime = htonl((uint32_t )umtime);
#line 122
  lb->reserved = (uint8_t )0;
#line 123
  tmp = tmp_full("/tmp");
#line 123
  lb->tmp_full = (uint8_t )tmp;
#line 125
  tmp___0 = tmp_full("/tmp");
#line 125
  lb->tmpdir_full = (uint8_t )tmp___0;
#line 131
  lbcd_set_load(lb, services);
  }
#line 134
  if (! simple) {
#line 134
    if (protocol < 3U) {
      {
#line 135
      lbcd_proto2_convert(lb);
      }
    }
  }
#line 136
  return;
}
}
#line 146 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/server.c"
void lbcd_test(int argc , char **argv ) 
{ 
  struct lbcd_reply lb ;
  struct lbcd_request ph ;
  struct vector *services ;
  int i ;
  int tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint16_t tmp___6 ;
  uint16_t tmp___7 ;
  char const   *tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;

  {
#line 155
  ph.h.version = (uint16_t )3;
#line 155
  lb.h.version = ph.h.version;
#line 156
  ph.h.id = (uint16_t )0;
#line 156
  lb.h.id = ph.h.id;
#line 157
  ph.h.op = (uint16_t )1;
#line 157
  lb.h.op = ph.h.op;
#line 158
  ph.h.status = (uint16_t )0;
#line 158
  lb.h.status = ph.h.status;
#line 161
  if (*(argv + 0)) {
    {
#line 161
    tmp = strcmp((char const   *)*(argv + 0), "v2");
    }
#line 161
    if (tmp == 0) {
#line 162
      argc --;
#line 163
      argv ++;
#line 164
      ph.h.version = (uint16_t )2;
#line 164
      lb.h.version = ph.h.version;
    }
  }
  {
#line 168
  services = vector_new();
  }
#line 169
  if (argc > 0) {
#line 169
    if ((int )lb.h.version == 3) {
#line 170
      if (argc > 5) {
#line 170
        ph.h.status = (uint16_t )5;
      } else {
#line 170
        ph.h.status = (uint16_t )argc;
      }
#line 171
      i = 0;
      {
#line 171
      while (1) {
        while_continue: /* CIL Label */ ;
#line 171
        if (! (i < argc)) {
#line 171
          goto while_break;
        }
#line 172
        if (i >= 5) {
#line 173
          goto while_break;
        }
#line 174
        if ((unsigned long )*(argv + i) == (unsigned long )((void *)0)) {
#line 175
          goto while_break;
        }
        {
#line 176
        vector_add(services, (char const   *)*(argv + i));
#line 171
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 181
  lbcd_pack_info(& lb, (unsigned int )lb.h.version, services, 0);
#line 184
  printf((char const   */* __restrict  */)"PROTOCOL %u\n", (unsigned int )lb.h.version);
#line 185
  printf((char const   */* __restrict  */)"\n");
#line 186
  printf((char const   */* __restrict  */)"MACHINE STATUS:\n");
#line 187
  tmp___0 = ntohs(lb.l1);
#line 187
  printf((char const   */* __restrict  */)"l1           = %u\n", (unsigned int )tmp___0);
#line 188
  tmp___1 = ntohs(lb.l5);
#line 188
  printf((char const   */* __restrict  */)"l5           = %u\n", (unsigned int )tmp___1);
#line 189
  tmp___2 = ntohs(lb.l15);
#line 189
  printf((char const   */* __restrict  */)"l15          = %u\n", (unsigned int )tmp___2);
#line 190
  tmp___3 = ntohl(lb.current_time);
#line 190
  printf((char const   */* __restrict  */)"current_time = %lu\n", (unsigned long )tmp___3);
#line 191
  tmp___4 = ntohl(lb.boot_time);
#line 191
  printf((char const   */* __restrict  */)"boot_time    = %lu\n", (unsigned long )tmp___4);
#line 192
  tmp___5 = ntohl(lb.user_mtime);
#line 192
  printf((char const   */* __restrict  */)"user_mtime   = %lu\n", (unsigned long )tmp___5);
#line 193
  tmp___6 = ntohs(lb.tot_users);
#line 193
  printf((char const   */* __restrict  */)"tot_users    = %u\n", (unsigned int )tmp___6);
#line 194
  tmp___7 = ntohs(lb.uniq_users);
#line 194
  printf((char const   */* __restrict  */)"uniq_users   = %u\n", (unsigned int )tmp___7);
#line 195
  printf((char const   */* __restrict  */)"on_console   = %u\n", (unsigned int )lb.on_console);
#line 196
  printf((char const   */* __restrict  */)"tmp_full     = %u\n", (unsigned int )lb.tmp_full);
#line 197
  printf((char const   */* __restrict  */)"tmpdir_full  = %u\n", (unsigned int )lb.tmpdir_full);
#line 198
  printf((char const   */* __restrict  */)"\n");
#line 199
  printf((char const   */* __restrict  */)"SERVICES: %u\n", (unsigned int )lb.services);
#line 200
  i = 0;
  }
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 200
    if (! (i <= (int )lb.services)) {
#line 200
      goto while_break___0;
    }
#line 201
    if (i) {
#line 201
      tmp___8 = (char const   *)(ph.names[i - 1]);
    } else {
#line 201
      tmp___8 = "default";
    }
    {
#line 201
    tmp___9 = ntohl(lb.weights[i].host_incr);
#line 201
    tmp___10 = ntohl(lb.weights[i].host_weight);
#line 201
    printf((char const   */* __restrict  */)"%d: weight %10lu increment %10lu name %s\n",
           i, (unsigned long )tmp___10, (unsigned long )tmp___9, tmp___8);
#line 200
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 205
  vector_free(services);
#line 206
  exit(0);
  }
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 87 "/usr/include/search.h"
extern  __attribute__((__nothrow__)) ENTRY *( __attribute__((__leaf__)) hsearch)(ENTRY __item ,
                                                                                 ACTION __action ) ;
#line 90
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) hcreate)(size_t __nel ) ;
#line 93
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) hdestroy)(void) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 53 "/usr/include/utmpx.h"
extern void setutxent(void) ;
#line 59
extern void endutxent(void) ;
#line 65
extern struct utmpx *getutxent(void) ;
#line 42 "./util/messages.h"
#pragma GCC visibility push(hidden)
#line 110
#pragma GCC visibility pop
#line 48 "./util/vector.h"
#pragma GCC visibility push(hidden)
#line 144
#pragma GCC visibility pop
#line 72 "./util/xmalloc.h"
#pragma GCC visibility push(hidden)
#line 86
extern char *( __attribute__((__nonnull__)) x_strndup)(char const   * , size_t  ,
                                                       char const   * , int  )  __attribute__((__malloc__)) ;
#line 118
#pragma GCC visibility pop
#line 57 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/get_user.c"
static char const   *utmp  =    "/var/run/utmp";
#line 60 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/get_user.c"
static struct vector *users  =    (struct vector *)((void *)0);
#line 67 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/get_user.c"
static void uniq_start(void) 
{ 


  {
  {
#line 71
  hcreate((size_t )211);
#line 73
  users = vector_new();
  }
#line 74
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/get_user.c"
static void uniq_end(void) 
{ 


  {
  {
#line 84
  hdestroy();
  }
#line 86
  if ((unsigned long )users != (unsigned long )((void *)0)) {
    {
#line 87
    vector_free(users);
    }
  }
#line 88
  return;
}
}
#line 97 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/get_user.c"
static void uniq_add(char *name ) 
{ 
  ENTRY item ;
  ENTRY *i ;

  {
  {
#line 102
  item.key = name;
#line 103
  item.data = (void *)0;
#line 104
  i = hsearch(item, (ACTION )0);
  }
#line 105
  if ((unsigned long )i == (unsigned long )((void *)0)) {
    {
#line 106
    vector_add(users, (char const   *)name);
#line 107
    item.key = *(users->strings + (users->count - 1UL));
#line 108
    hsearch(item, (ACTION )1);
    }
  }
#line 110
  return;
}
}
#line 131 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/get_user.c"
static size_t uniq_count(void) 
{ 


  {
#line 134
  return (users->count);
}
}
#line 151 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/get_user.c"
static int last_total  =    0;
#line 152 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/get_user.c"
static int last_uniq  =    0;
#line 153 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/get_user.c"
static int last_on_console  =    0;
#line 154 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/get_user.c"
static time_t last_user_mtime  =    (time_t )0;
#line 146 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/get_user.c"
int get_user_stats(int *total , int *uniq , int *on_console , time_t *user_mtime ) 
{ 
  char *name ;
  struct stat sbuf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct utmpx *ut ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 156
  *total = 0;
#line 157
  *uniq = 0;
#line 158
  *on_console = 0;
#line 159
  *user_mtime = (time_t )0;
#line 165
  tmp = stat((char const   */* __restrict  */)utmp, (struct stat */* __restrict  */)(& sbuf));
  }
#line 165
  if (tmp == 0) {
#line 166
    *user_mtime = sbuf.st_mtim.tv_sec;
  }
#line 167
  if (*user_mtime > 0L) {
#line 167
    if (*user_mtime == last_user_mtime) {
#line 168
      *total = last_total;
#line 169
      *uniq = last_uniq;
#line 170
      *on_console = last_on_console;
#line 171
      return (0);
    }
  }
  {
#line 178
  tmp___0 = stat((char const   */* __restrict  */)"/dev/console", (struct stat */* __restrict  */)(& sbuf));
  }
#line 178
  if (tmp___0 == 0) {
#line 178
    if (sbuf.st_uid != 0U) {
#line 179
      *on_console = 1;
    }
  }
  {
#line 180
  tmp___1 = stat((char const   */* __restrict  */)"/dev/tty1", (struct stat */* __restrict  */)(& sbuf));
  }
#line 180
  if (tmp___1 == 0) {
#line 180
    if (sbuf.st_uid != 0U) {
#line 181
      *on_console = 1;
    }
  }
  {
#line 188
  uniq_start();
#line 193
  setutxent();
  }
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 194
    ut = getutxent();
    }
#line 194
    if (! ((unsigned long )ut != (unsigned long )((void *)0))) {
#line 194
      goto while_break;
    }
#line 195
    if ((int )ut->ut_type != 7) {
#line 196
      goto while_continue;
    }
    {
#line 197
    (*total) ++;
#line 198
    tmp___2 = strncmp((char const   *)(ut->ut_line), "console", (size_t )7);
    }
#line 198
    if (tmp___2 == 0) {
#line 199
      *on_console = 1;
    }
    {
#line 200
    tmp___3 = strncmp((char const   *)(ut->ut_host), ":0", (size_t )2);
    }
#line 200
    if (tmp___3 == 0) {
#line 201
      *on_console = 1;
    }
    {
#line 202
    name = x_strndup((char const   *)(ut->ut_user), sizeof(ut->ut_user), "/home/wheatley/newnew/temp/lbcd-3.5.0/server/get_user.c",
                     202);
#line 203
    uniq_add(name);
#line 204
    free((void *)name);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  endutxent();
#line 238
  tmp___4 = uniq_count();
#line 238
  *uniq = (int )tmp___4;
#line 239
  uniq_end();
#line 242
  last_total = *total;
#line 243
  last_uniq = *uniq;
#line 244
  last_on_console = *on_console;
#line 245
  last_user_mtime = *user_mtime;
  }
#line 247
  return (0);
}
}
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 100 "./server/internal.h"
int lbcd_smtp_weight(uint32_t *weight_val , uint32_t *incr_val  __attribute__((__unused__)) ,
                     int timeout , char const   *portarg  __attribute__((__unused__)) ,
                     struct lbcd_reply *lb  __attribute__((__unused__)) ) ;
#line 216 "./portable/socket.h"
#pragma GCC visibility push(hidden)
#line 275
#pragma GCC visibility pop
#line 21 "./modules/modules.h"
extern int probe_tcp(char const   *host , char const   *service , short port , char const   *replycheck ,
                     int timeout ) ;
#line 23 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/smtp.c"
static int probe_smtp(char const   *host , int timeout ) 
{ 
  int tmp ;

  {
  {
#line 26
  tmp = probe_tcp(host, "smtp", (short)25, "220", timeout);
  }
#line 26
  return (tmp);
}
}
#line 33 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/smtp.c"
int lbcd_smtp_weight(uint32_t *weight_val , uint32_t *incr_val  __attribute__((__unused__)) ,
                     int timeout , char const   *portarg  __attribute__((__unused__)) ,
                     struct lbcd_reply *lb  __attribute__((__unused__)) ) 
{ 
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 37
  tmp___0 = probe_smtp("localhost", timeout);
#line 37
  tmp = (uint32_t )tmp___0;
#line 37
  *weight_val = tmp;
  }
#line 37
  return ((int )tmp);
}
}
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 97 "./server/internal.h"
int lbcd_pop_weight(uint32_t *weight_val , uint32_t *incr_val  __attribute__((__unused__)) ,
                    int timeout , char const   *portarg  __attribute__((__unused__)) ,
                    struct lbcd_reply *lb  __attribute__((__unused__)) ) ;
#line 216 "./portable/socket.h"
#pragma GCC visibility push(hidden)
#line 275
#pragma GCC visibility pop
#line 23 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/pop.c"
static int probe_pop(char const   *host , int timeout ) 
{ 
  int tmp ;

  {
  {
#line 26
  tmp = probe_tcp(host, "pop", (short)110, "+OK", timeout);
  }
#line 26
  return (tmp);
}
}
#line 33 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/pop.c"
int lbcd_pop_weight(uint32_t *weight_val , uint32_t *incr_val  __attribute__((__unused__)) ,
                    int timeout , char const   *portarg  __attribute__((__unused__)) ,
                    struct lbcd_reply *lb  __attribute__((__unused__)) ) 
{ 
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 37
  tmp___0 = probe_pop("localhost", timeout);
#line 37
  tmp = (uint32_t )tmp___0;
#line 37
  *weight_val = tmp;
  }
#line 37
  return ((int )tmp);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 216 "./portable/socket.h"
#pragma GCC visibility push(hidden)
#line 275
#pragma GCC visibility pop
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 80 "./server/internal.h"
int lbcd_http_weight(uint32_t *weight_val , uint32_t *incr_val  __attribute__((__unused__)) ,
                     int timeout , char const   *portarg , struct lbcd_reply *lb  __attribute__((__unused__)) ) ;
#line 24 "./modules/modules.h"
extern socket_type tcp_connect(char const   *host , char const   *protocol , int port ) ;
#line 37 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/http.c"
static int probe_http(char const   *host , int timeout , char const   *portarg ) 
{ 
  socket_type sd ;
  int retval ;
  short port ;
  char const   *service ;
  int tmp ;
  char const   *tmp___0 ;
  struct timeval tv ;
  fd_set rset ;
  char buf[17] ;
  char *p ;
  ssize_t tmp___1 ;
  int __d0 ;
  int __d1 ;
  unsigned short const   **tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;

  {
#line 41
  retval = 0;
#line 42
  port = (short)80;
#line 43
  service = "http";
#line 45
  if ((unsigned long )portarg != (unsigned long )((void *)0)) {
    {
#line 46
    tmp = atoi(portarg);
#line 46
    port = (short )tmp;
    }
#line 47
    if ((int )port < 1) {
#line 48
      port = (short)80;
    } else {
#line 50
      service = (char const   *)((void *)0);
    }
  }
#line 52
  if (host) {
#line 52
    tmp___0 = host;
  } else {
#line 52
    tmp___0 = "localhost";
  }
  {
#line 52
  sd = tcp_connect(tmp___0, service, (int )port);
  }
#line 53
  if (sd == -1) {
#line 54
    return (-1);
  } else {
    {
#line 56
    tv.tv_sec = (__time_t )0;
#line 56
    tv.tv_usec = (__suseconds_t )0;
#line 61
    tv.tv_sec = (__time_t )timeout;
#line 62
    tmp___1 = write(sd, (void const   *)"GET / HTTP/1.0\r\n\r\n", sizeof("GET / HTTP/1.0\r\n\r\n"));
    }
#line 62
    if (tmp___1 < (ssize_t )sizeof("GET / HTTP/1.0\r\n\r\n")) {
      {
#line 63
      close(sd);
      }
#line 64
      return (-1);
    }
    {
#line 66
    while (1) {
      while_continue: /* CIL Label */ ;
#line 66
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rset.fds_bits[0]): "memory");
#line 66
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 67
    rset.fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sd % (8 * (int )sizeof(__fd_mask ));
#line 68
    retval = -1;
#line 69
    tmp___4 = select(sd + 1, (fd_set */* __restrict  */)(& rset), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 69
    if (tmp___4 > 0) {
      {
#line 70
      buf[sizeof(buf) - 1UL] = (char )'\000';
#line 73
      tmp___3 = read(sd, (void *)(buf), sizeof(buf) - 1UL);
      }
#line 73
      if (tmp___3 > 0L) {
        {
#line 74
        p = strstr((char const   *)(buf), "20");
        }
#line 75
        if ((unsigned long )p == (unsigned long )((void *)0)) {
          {
#line 76
          p = strstr((char const   *)(buf), "30");
          }
        }
#line 77
        if ((unsigned long )p != (unsigned long )((void *)0)) {
          {
#line 77
          tmp___2 = __ctype_b_loc();
          }
#line 77
          if ((int const   )*(*tmp___2 + (int )*(p + 2)) & 2048) {
#line 78
            retval = 0;
          }
        }
      }
    }
    {
#line 81
    close(sd);
    }
  }
#line 83
  return (retval);
}
}
#line 91 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/http.c"
int lbcd_http_weight(uint32_t *weight_val , uint32_t *incr_val  __attribute__((__unused__)) ,
                     int timeout , char const   *portarg , struct lbcd_reply *lb  __attribute__((__unused__)) ) 
{ 
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 96
  tmp___0 = probe_http("localhost", timeout, portarg);
#line 96
  tmp = (uint32_t )tmp___0;
#line 96
  *weight_val = tmp;
  }
#line 96
  return ((int )tmp);
}
}
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 216 "./portable/socket.h"
#pragma GCC visibility push(hidden)
#line 275
#pragma GCC visibility pop
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 142
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 149
#pragma GCC visibility pop
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 62 "./server/internal.h"
int lbcd_weight_init(char const   *cmd , char const   *service , int timeout ) ;
#line 66
int lbcd_rr_weight(uint32_t *weight_val , uint32_t *incr_val , int timeout  __attribute__((__unused__)) ,
                   char const   *portarg  __attribute__((__unused__)) , struct lbcd_reply *lb  __attribute__((__unused__)) ) ;
#line 67
int lbcd_cmd_weight(uint32_t *weight_val , uint32_t *incr_val , int timeout , char const   *portarg ,
                    struct lbcd_reply *lb ) ;
#line 68
int lbcd_unknown_weight(uint32_t *weight_val , uint32_t *incr_val , int timeout  __attribute__((__unused__)) ,
                        char const   *portarg  __attribute__((__unused__)) , struct lbcd_reply *lb  __attribute__((__unused__)) ) ;
#line 71
extern weight_func_type lbcd_tcp_weight ;
#line 77
int lbcd_ftp_weight(uint32_t *weight_val , uint32_t *incr_val  __attribute__((__unused__)) ,
                    int timeout , char const   *portarg  __attribute__((__unused__)) ,
                    struct lbcd_reply *lb  __attribute__((__unused__)) ) ;
#line 83
int lbcd_imap_weight(uint32_t *weight_val , uint32_t *incr_val  __attribute__((__unused__)) ,
                     int timeout , char const   *portarg  __attribute__((__unused__)) ,
                     struct lbcd_reply *lb  __attribute__((__unused__)) ) ;
#line 91
int lbcd_nntp_weight(uint32_t *weight_val , uint32_t *incr_val  __attribute__((__unused__)) ,
                     int timeout , char const   *portarg  __attribute__((__unused__)) ,
                     struct lbcd_reply *lb  __attribute__((__unused__)) ) ;
#line 94
int lbcd_ntp_weight(uint32_t *weight_val , uint32_t *incr_val  __attribute__((__unused__)) ,
                    int timeout , char const   *portarg  __attribute__((__unused__)) ,
                    struct lbcd_reply *lb  __attribute__((__unused__)) ) ;
#line 42 "./util/messages.h"
#pragma GCC visibility push(hidden)
#line 59
extern  __attribute__((__noreturn__)) void ( /* format attribute */ __attribute__((__nonnull__)) die)(char const   * 
                                                                                                      , ...) ;
#line 110
#pragma GCC visibility pop
#line 24 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
struct service_mapping service_table[13]  = 
#line 24 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
  {      {{(char )'l', (char )'o', (char )'a', (char )'d', (char )'\000'}, & lbcd_load_weight}, 
        {{(char )'c',
       (char )'m', (char )'d', (char )'\000'}, & lbcd_cmd_weight}, 
        {{(char )'r', (char )'r', (char )'\000'}, & lbcd_rr_weight}, 
        {{(char )'u', (char )'n', (char )'k', (char )'n', (char )'o', (char )'w', (char )'n',
       (char )'\000'}, & lbcd_unknown_weight}, 
        {{(char )'f', (char )'t', (char )'p', (char )'\000'}, & lbcd_ftp_weight}, 
        {{(char )'h', (char )'t', (char )'t', (char )'p', (char )'\000'}, & lbcd_http_weight}, 
        {{(char )'i',
       (char )'m', (char )'a', (char )'p', (char )'\000'}, & lbcd_imap_weight}, 
        {{(char )'n', (char )'n', (char )'t', (char )'p', (char )'\000'}, & lbcd_nntp_weight}, 
        {{(char )'n',
       (char )'t', (char )'p', (char )'\000'}, & lbcd_ntp_weight}, 
        {{(char )'p', (char )'o', (char )'p', (char )'\000'}, & lbcd_pop_weight}, 
        {{(char )'s', (char )'m', (char )'t', (char )'p', (char )'\000'}, & lbcd_smtp_weight}, 
        {{(char )'t',
       (char )'c', (char )'p', (char )'\000'}, & lbcd_tcp_weight}, 
        {{(char )'\000'}, (weight_func_type *)((void *)0)}};
#line 54 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
static char const   *lbcd_command  ;
#line 55 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
static char const   *lbcd_service  ;
#line 56 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
static uint32_t default_weight  ;
#line 57 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
static uint32_t default_increment  ;
#line 58 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
static struct service_mapping  const  *lbcd_default_functab  ;
#line 59 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
static int lbcd_timeout  ;
#line 72 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
static int is_weights(char const   *service ) 
{ 
  char const   *cp ;
  int sawcolon ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 79
  if ((unsigned long )service == (unsigned long )((void *)0)) {
#line 80
    return (-1);
  }
  {
#line 83
  tmp = __ctype_b_loc();
  }
#line 83
  if (! ((int const   )*(*tmp + (int )*service) & 2048)) {
#line 84
    return (-1);
  }
  {
#line 85
  tmp___0 = __ctype_b_loc();
#line 85
  tmp___1 = strlen(service);
  }
#line 85
  if (! ((int const   )*(*tmp___0 + (int )*(service + (tmp___1 - 1UL))) & 2048)) {
#line 86
    return (-1);
  }
#line 89
  sawcolon = 0;
#line 90
  cp = service;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! *cp) {
#line 90
      goto while_break;
    }
#line 91
    if ((int const   )*cp != 58) {
      {
#line 91
      tmp___2 = __ctype_b_loc();
      }
#line 91
      if (! ((int const   )*(*tmp___2 + (int )*cp) & 2048)) {
#line 92
        return (-1);
      }
    }
#line 93
    sawcolon += (int const   )*cp == 58;
#line 90
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  if (sawcolon != 1) {
#line 96
    return (-1);
  }
#line 99
  return (0);
}
}
#line 107 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
static struct service_mapping  const  *service_to_func(char const   *service ) 
{ 
  struct service_mapping  const  *stp ;
  lbcd_name_type name ;
  char *cp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 115
  if ((unsigned long )service == (unsigned long )((void *)0)) {
#line 116
    return (lbcd_default_functab);
  } else {
    {
#line 115
    tmp = strcmp("default", service);
    }
#line 115
    if (tmp == 0) {
#line 116
      return (lbcd_default_functab);
    }
  }
  {
#line 119
  strlcpy(name, service, sizeof(name));
#line 120
  cp = strchr((char const   *)(name), ':');
  }
#line 121
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 122
    *cp = (char )'\000';
  }
#line 125
  stp = (struct service_mapping  const  *)(service_table);
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! ((int )stp->service[0] != 0)) {
#line 125
      goto while_break;
    }
    {
#line 126
    tmp___0 = strcmp((char const   *)(name), (char const   *)(stp->service));
    }
#line 126
    if (tmp___0 == 0) {
#line 127
      return (stp);
    }
#line 125
    stp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  stp = (struct service_mapping  const  *)(service_table);
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 130
    if (! ((int )stp->service[0] != 0)) {
#line 130
      goto while_break___0;
    }
    {
#line 131
    tmp___1 = strcmp("unknown", (char const   *)(stp->service));
    }
#line 131
    if (tmp___1 == 0) {
#line 132
      return (stp);
    }
#line 130
    stp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 133
  die("internal error: cannot locate unknown service");
  }
}
}
#line 140 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
int lbcd_weight_init(char const   *cmd , char const   *service , int timeout ) 
{ 
  char *cp ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
#line 143
  lbcd_command = cmd;
#line 144
  lbcd_service = service;
#line 145
  lbcd_timeout = timeout;
#line 148
  if ((unsigned long )service != (unsigned long )((void *)0)) {
    {
#line 148
    tmp___3 = is_weights(service);
    }
#line 148
    if (tmp___3 == 0) {
      {
#line 151
      cp = strchr(service, ':');
#line 152
      tmp = cp;
#line 152
      cp ++;
#line 152
      *tmp = (char )'\000';
#line 153
      tmp___0 = atoi(service);
#line 153
      default_weight = (uint32_t )tmp___0;
#line 154
      tmp___1 = atoi((char const   *)cp);
#line 154
      default_increment = (uint32_t )tmp___1;
#line 155
      lbcd_default_functab = service_to_func("rr");
      }
    } else {
#line 148
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 158
  if (cmd) {
    {
#line 159
    lbcd_default_functab = service_to_func("cmd");
    }
  } else {
#line 164
    default_weight = (uint32_t )1;
#line 165
    default_increment = (uint32_t )1;
#line 168
    if (service) {
#line 168
      tmp___2 = service;
    } else {
#line 168
      tmp___2 = "load";
    }
    {
#line 168
    lbcd_default_functab = service_to_func(tmp___2);
    }
  }
#line 170
  return (0);
}
}
#line 179 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
void lbcd_setweight(struct lbcd_reply *lb , int offset , char const   *service ) 
{ 
  uint32_t *weight_ptr ;
  uint32_t *incr_ptr ;
  struct service_mapping  const  *functab ;
  char const   *cp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 184
  cp = (char const   *)((void *)0);
#line 186
  weight_ptr = & lb->weights[offset].host_weight;
#line 187
  incr_ptr = & lb->weights[offset].host_incr;
#line 188
  *incr_ptr = default_increment;
#line 190
  functab = service_to_func(service);
#line 191
  tmp___0 = strcmp(service, "default");
  }
#line 191
  if (tmp___0 == 0) {
#line 191
    cp = (char const   *)(functab->service);
  } else {
#line 191
    cp = service;
  }
  {
#line 192
  tmp___1 = strchr(cp, ':');
#line 192
  cp = (char const   *)tmp___1;
  }
#line 193
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 194
    cp ++;
  }
  {
#line 195
  (*(functab->function))(weight_ptr, incr_ptr, lbcd_timeout, cp, lb);
  }
#line 196
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
int lbcd_unknown_weight(uint32_t *weight_val , uint32_t *incr_val , int timeout  __attribute__((__unused__)) ,
                        char const   *portarg  __attribute__((__unused__)) , struct lbcd_reply *lb  __attribute__((__unused__)) ) 
{ 


  {
#line 207
  *weight_val = (uint32_t )-1;
#line 208
  *incr_val = (uint32_t )0;
#line 209
  return (0);
}
}
#line 216 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
int lbcd_rr_weight(uint32_t *weight_val , uint32_t *incr_val , int timeout  __attribute__((__unused__)) ,
                   char const   *portarg  __attribute__((__unused__)) , struct lbcd_reply *lb  __attribute__((__unused__)) ) 
{ 


  {
#line 220
  *weight_val = default_weight;
#line 221
  *incr_val = default_increment;
#line 222
  return (0);
}
}
#line 229 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/weight.c"
int lbcd_cmd_weight(uint32_t *weight_val , uint32_t *incr_val , int timeout , char const   *portarg ,
                    struct lbcd_reply *lb ) 
{ 
  int fd[2] ;
  pid_t child ;
  int tmp ;
  int stat_loc ;
  FILE *fp ;
  char buf[128] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  __pid_t tmp___4 ;
  int tmp___5 ;
  union __anonunion_56 __constr_expr_0 ;
  int tmp___6 ;
  int tmp___7 ;
  union __anonunion_57 __constr_expr_1 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 239
  tmp___13 = pipe((int *)(fd));
  }
#line 239
  if (tmp___13 == 0) {
    {
#line 242
    child = fork();
    }
#line 243
    if (child < 0) {
      {
#line 244
      tmp = lbcd_unknown_weight(weight_val, incr_val, timeout, portarg, lb);
      }
#line 244
      return (tmp);
    } else
#line 246
    if (child == 0) {
      {
#line 247
      close(fd[0]);
#line 248
      close(2);
      }
#line 249
      if (fd[1] != 1) {
        {
#line 250
        dup2(fd[1], 1);
#line 251
        close(fd[1]);
        }
      }
      {
#line 253
      execl(lbcd_command, lbcd_command, (char *)0);
#line 254
      exit(1);
      }
    } else {
      {
#line 260
      close(fd[1]);
#line 261
      fp = fdopen(fd[0], "r");
      }
#line 262
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
        {
#line 263
        kill(15, child);
#line 264
        waitpid(child, (int *)((void *)0), 0);
#line 265
        tmp___0 = lbcd_unknown_weight(weight_val, incr_val, timeout, portarg, lb);
        }
#line 265
        return (tmp___0);
      }
      {
#line 268
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 268
        tmp___4 = waitpid(child, & stat_loc, 0);
        }
#line 268
        if (! (tmp___4 < 0)) {
#line 268
          goto while_break;
        }
        {
#line 269
        tmp___3 = __errno_location();
        }
#line 269
        if (*tmp___3 != 4) {
          {
#line 270
          fclose(fp);
#line 271
          tmp___1 = kill(15, child);
          }
#line 271
          if (tmp___1 == -1) {
            {
#line 272
            kill(9, child);
            }
          }
          {
#line 273
          waitpid(child, (int *)((void *)0), 0);
#line 274
          tmp___2 = lbcd_unknown_weight(weight_val, incr_val, timeout, portarg, lb);
          }
#line 274
          return (tmp___2);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 278
      __constr_expr_1.__in = stat_loc;
#line 278
      if ((__constr_expr_1.__i & 127) == 0) {
#line 279
        __constr_expr_0.__in = stat_loc;
#line 279
        if ((__constr_expr_0.__i & 65280) >> 8 != 0) {
          {
#line 280
          fclose(fp);
#line 281
          tmp___5 = lbcd_unknown_weight(weight_val, incr_val, timeout, portarg, lb);
          }
#line 281
          return (tmp___5);
        }
      } else {
        {
#line 285
        tmp___6 = kill(15, child);
        }
#line 285
        if (tmp___6 == -1) {
          {
#line 286
          kill(9, child);
          }
        }
        {
#line 287
        fclose(fp);
#line 288
        tmp___7 = lbcd_unknown_weight(weight_val, incr_val, timeout, portarg, lb);
        }
#line 288
        return (tmp___7);
      }
      {
#line 292
      tmp___11 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
      }
#line 292
      if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
        {
#line 293
        fclose(fp);
#line 294
        tmp___9 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%d%d",
                         weight_val, incr_val);
        }
#line 294
        if (tmp___9 != 2) {
          {
#line 295
          tmp___8 = lbcd_unknown_weight(weight_val, incr_val, timeout, portarg, lb);
          }
#line 295
          return (tmp___8);
        }
      } else {
        {
#line 298
        fclose(fp);
#line 299
        tmp___10 = lbcd_unknown_weight(weight_val, incr_val, timeout, portarg, lb);
        }
#line 299
        return (tmp___10);
      }
    }
  } else {
    {
#line 304
    tmp___12 = lbcd_unknown_weight(weight_val, incr_val, timeout, portarg, lb);
    }
#line 304
    return (tmp___12);
  }
#line 306
  return (0);
}
}
#line 216 "./portable/socket.h"
#pragma GCC visibility push(hidden)
#line 275
#pragma GCC visibility pop
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 19 "./modules/modules.h"
int lbcd_check_reply(int sd , int timeout , char const   *token ) ;
#line 33 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/check_reply.c"
int lbcd_check_reply(int sd , int timeout , char const   *token ) 
{ 
  struct timeval tv ;
  fd_set rset ;
  int retval ;
  char *buf ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  int __d0 ;
  int __d1 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
#line 36
  tv.tv_sec = (__time_t )0;
#line 36
  tv.tv_usec = (__suseconds_t )0;
#line 38
  retval = 0;
#line 42
  tv.tv_sec = (__time_t )timeout;
#line 43
  if ((unsigned long )token == (unsigned long )((void *)0)) {
#line 44
    return (-1);
  }
  {
#line 45
  tmp = strlen(token);
#line 45
  len = (int )tmp;
#line 46
  tmp___0 = malloc((size_t )(len + 1));
#line 46
  buf = (char *)tmp___0;
  }
#line 47
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 48
    return (-1);
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rset.fds_bits[0]): "memory");
#line 50
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 51
  rset.fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sd % (8 * (int )sizeof(__fd_mask ));
#line 52
  tmp___3 = select(sd + 1, (fd_set */* __restrict  */)(& rset), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
  }
#line 52
  if (tmp___3 > 0) {
    {
#line 53
    *(buf + len) = (char )'\000';
#line 54
    tmp___2 = read(sd, (void *)buf, (size_t )len);
    }
#line 54
    if (tmp___2 > 0L) {
      {
#line 55
      tmp___1 = strcmp((char const   *)buf, token);
      }
#line 55
      if (tmp___1 != 0) {
#line 56
        retval = -1;
      }
    } else {
#line 58
      retval = -1;
    }
  } else {
#line 61
    retval = -1;
  }
  {
#line 63
  free((void *)buf);
  }
#line 64
  return (retval);
}
}
#line 216 "./portable/socket.h"
#pragma GCC visibility push(hidden)
#line 275
#pragma GCC visibility pop
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 25 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/imap.c"
static int probe_imap(char const   *host , int timeout ) 
{ 
  socket_type sd ;
  int retval ;
  char const   *tmp ;
  ssize_t tmp___0 ;

  {
#line 29
  retval = 0;
#line 31
  if (host) {
#line 31
    tmp = host;
  } else {
#line 31
    tmp = "localhost";
  }
  {
#line 31
  sd = tcp_connect(tmp, "imap", 143);
  }
#line 32
  if (sd == -1) {
#line 33
    return (-1);
  } else {
    {
#line 35
    retval = lbcd_check_reply(sd, timeout, "* OK");
#line 37
    tmp___0 = write(sd, (void const   *)"tag logout\r\n", (size_t )12);
#line 38
    close(sd);
    }
  }
#line 40
  return (retval);
}
}
#line 47 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/imap.c"
int lbcd_imap_weight(uint32_t *weight_val , uint32_t *incr_val  __attribute__((__unused__)) ,
                     int timeout , char const   *portarg  __attribute__((__unused__)) ,
                     struct lbcd_reply *lb  __attribute__((__unused__)) ) 
{ 
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 51
  tmp___0 = probe_imap("localhost", timeout);
#line 51
  tmp = (uint32_t )tmp___0;
#line 51
  *weight_val = tmp;
  }
#line 51
  return ((int )tmp);
}
}
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 42 "./util/messages.h"
#pragma GCC visibility push(hidden)
#line 55
extern void ( /* format attribute */ __attribute__((__nonnull__)) warn)(char const   * 
                                                                        , ...) ;
#line 57
extern void ( /* format attribute */ __attribute__((__nonnull__)) syswarn)(char const   * 
                                                                           , ...) ;
#line 110
#pragma GCC visibility pop
#line 25 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/arch/linux.c"
int kernel_getload(double *l1 , double *l5 , double *l15 ) 
{ 
  FILE *fp ;
  int tmp ;

  {
  {
#line 30
  fp = fopen((char const   */* __restrict  */)"/proc/loadavg", (char const   */* __restrict  */)"r");
  }
#line 31
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 32
    syswarn("cannot open /proc/loadavg");
    }
#line 33
    return (-1);
  }
  {
#line 35
  tmp = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lf %lf %lf",
               l1, l5, l15);
  }
#line 35
  if (tmp < 3) {
    {
#line 36
    fclose(fp);
#line 37
    warn("cannot parse /proc/loadavg");
    }
#line 38
    return (-1);
  }
  {
#line 40
  fclose(fp);
  }
#line 41
  return (0);
}
}
#line 49 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/arch/linux.c"
int kernel_getboottime(time_t *boottime ) 
{ 
  FILE *fp ;
  double uptime ;
  time_t curr ;
  int tmp ;

  {
  {
#line 56
  fp = fopen((char const   */* __restrict  */)"/proc/uptime", (char const   */* __restrict  */)"r");
  }
#line 57
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 58
    syswarn("cannot open /proc/uptime");
    }
#line 59
    return (-1);
  }
  {
#line 61
  tmp = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lf",
               & uptime);
  }
#line 61
  if (tmp < 1) {
    {
#line 62
    fclose(fp);
#line 63
    warn("cannot parse /proc/uptime");
    }
#line 64
    return (-1);
  }
  {
#line 66
  fclose(fp);
#line 67
  curr = time((time_t *)((void *)0));
#line 68
  *boottime = (time_t )((double )curr - uptime);
  }
#line 69
  return (0);
}
}
#line 163 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 216 "./portable/socket.h"
#pragma GCC visibility push(hidden)
#line 275
#pragma GCC visibility pop
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 937 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 139 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) raise)(int __sig ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 42 "./util/messages.h"
#pragma GCC visibility push(hidden)
#line 51
extern void ( /* format attribute */ __attribute__((__nonnull__)) notice)(char const   * 
                                                                          , ...) ;
#line 61
extern  __attribute__((__noreturn__)) void ( /* format attribute */ __attribute__((__nonnull__)) sysdie)(char const   * 
                                                                                                         , ...) ;
#line 71
extern void message_handlers_notice(unsigned int count  , ...) ;
#line 72
extern void message_handlers_warn(unsigned int count  , ...) ;
#line 73
extern void message_handlers_die(unsigned int count  , ...) ;
#line 86
extern void ( __attribute__((__nonnull__)) message_log_syslog_info)(size_t  , char const   * ,
                                                                    va_list  , int  ) ;
#line 90
extern void ( __attribute__((__nonnull__)) message_log_syslog_warning)(size_t  , char const   * ,
                                                                       va_list  ,
                                                                       int  ) ;
#line 92
extern void ( __attribute__((__nonnull__)) message_log_syslog_err)(size_t  , char const   * ,
                                                                   va_list  , int  ) ;
#line 107
extern char const   *message_program_name ;
#line 110
#pragma GCC visibility pop
#line 44 "./util/network.h"
#pragma GCC visibility push(hidden)
#line 52
extern socket_type ( __attribute__((__nonnull__)) network_bind_ipv4)(int type , char const   *addr ,
                                                                     unsigned short port ) ;
#line 54
extern socket_type ( __attribute__((__nonnull__)) network_bind_ipv6)(int type , char const   *addr ,
                                                                     unsigned short port ) ;
#line 68
extern _Bool ( __attribute__((__nonnull__)) network_bind_all)(int type , unsigned short port ,
                                                              socket_type **fds ,
                                                              unsigned int *count ) ;
#line 82
extern socket_type ( __attribute__((__nonnull__)) network_wait_any)(socket_type *fds ,
                                                                    unsigned int count ) ;
#line 144
extern _Bool ( __attribute__((__nonnull__)) network_sockaddr_sprint)(char * , size_t  ,
                                                                     struct sockaddr  const  * ) ;
#line 167
#pragma GCC visibility pop
#line 48 "./util/vector.h"
#pragma GCC visibility push(hidden)
#line 144
#pragma GCC visibility pop
#line 72 "./util/xmalloc.h"
#pragma GCC visibility push(hidden)
#line 78
extern void *( __attribute__((__nonnull__)) x_calloc)(size_t  , size_t  , char const   * ,
                                                      int  )  __attribute__((__malloc__,
__alloc_size__(1,2))) ;
#line 80
extern void *( __attribute__((__nonnull__)) x_malloc)(size_t  , char const   * , int  )  __attribute__((__malloc__,
__alloc_size__(1))) ;
#line 84
extern char *( __attribute__((__nonnull__)) x_strdup)(char const   * , char const   * ,
                                                      int  )  __attribute__((__malloc__)) ;
#line 118
#pragma GCC visibility pop
#line 32 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
static int volatile   exit_signaled  =    (sig_atomic_t volatile   )0;
#line 35 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
char const   usage_message[823]  = 
#line 35
  {      (char const   )'U',      (char const   )'s',      (char const   )'a',      (char const   )'g', 
        (char const   )'e',      (char const   )':',      (char const   )' ',      (char const   )'l', 
        (char const   )'b',      (char const   )'c',      (char const   )'d',      (char const   )' ', 
        (char const   )'[',      (char const   )'o',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'s', 
        (char const   )']',      (char const   )' ',      (char const   )'[',      (char const   )'-', 
        (char const   )'d',      (char const   )']',      (char const   )' ',      (char const   )'[', 
        (char const   )'-',      (char const   )'p',      (char const   )' ',      (char const   )'<', 
        (char const   )'p',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'>',      (char const   )']',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'b', 
        (char const   )' ',      (char const   )'<',      (char const   )'a',      (char const   )'d', 
        (char const   )'d',      (char const   )'r',      (char const   )'>',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'b', 
        (char const   )'i',      (char const   )'n',      (char const   )'d',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )' ',      (char const   )'<', 
        (char const   )'a',      (char const   )'d',      (char const   )'d',      (char const   )'r', 
        (char const   )'>',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'s',      (char const   )'t',      (char const   )'e',      (char const   )'a', 
        (char const   )'d',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'a',      (char const   )'l',      (char const   )'l', 
        (char const   )' ',      (char const   )'a',      (char const   )'v',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'e',      (char const   )'s', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )'c',      (char const   )' ',      (char const   )'<', 
        (char const   )'c',      (char const   )'m',      (char const   )'d',      (char const   )'>', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'r',      (char const   )'u',      (char const   )'n', 
        (char const   )' ',      (char const   )'<',      (char const   )'c',      (char const   )'m', 
        (char const   )'d',      (char const   )'>',      (char const   )' ',      (char const   )'(', 
        (char const   )'f',      (char const   )'u',      (char const   )'l',      (char const   )'l', 
        (char const   )' ',      (char const   )'p',      (char const   )'a',      (char const   )'t', 
        (char const   )'h',      (char const   )')',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'o',      (char const   )'b', 
        (char const   )'t',      (char const   )'a',      (char const   )'i',      (char const   )'n', 
        (char const   )' ',      (char const   )'l',      (char const   )'o',      (char const   )'a', 
        (char const   )'d',      (char const   )' ',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'u',      (char const   )'e',      (char const   )'s', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )'d',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'d',      (char const   )'e',      (char const   )'b', 
        (char const   )'u',      (char const   )'g',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'d',      (char const   )'e',      (char const   )',', 
        (char const   )' ',      (char const   )'d',      (char const   )'o',      (char const   )'n', 
        (char const   )'\'',      (char const   )'t',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'k',      (char const   )' ', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'l', 
        (char const   )'o',      (char const   )'g',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'s',      (char const   )'y', 
        (char const   )'s',      (char const   )'l',      (char const   )'o',      (char const   )'g', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )'f',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'r',      (char const   )'u',      (char const   )'n', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )'e', 
        (char const   )'g',      (char const   )'r',      (char const   )'o',      (char const   )'u', 
        (char const   )'n',      (char const   )'d',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'h', 
        (char const   )',',      (char const   )' ',      (char const   )'-',      (char const   )'-', 
        (char const   )'h',      (char const   )'e',      (char const   )'l',      (char const   )'p', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'l', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'l', 
        (char const   )'o',      (char const   )'g',      (char const   )' ',      (char const   )'v', 
        (char const   )'a',      (char const   )'r',      (char const   )'i',      (char const   )'o', 
        (char const   )'u',      (char const   )'s',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'q',      (char const   )'u',      (char const   )'e', 
        (char const   )'s',      (char const   )'t',      (char const   )'s',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'P',      (char const   )' ',      (char const   )'<',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )'>', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'w',      (char const   )'r',      (char const   )'i',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'P',      (char const   )'I', 
        (char const   )'D',      (char const   )' ',      (char const   )'t',      (char const   )'o', 
        (char const   )' ',      (char const   )'<',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )'>',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'p',      (char const   )' ',      (char const   )'<',      (char const   )'p', 
        (char const   )'o',      (char const   )'r',      (char const   )'t',      (char const   )'>', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'r',      (char const   )'u',      (char const   )'n',      (char const   )' ', 
        (char const   )'u',      (char const   )'s',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'f',      (char const   )'f',      (char const   )'e',      (char const   )'r', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'p',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )' ',      (char const   )'n',      (char const   )'u',      (char const   )'m', 
        (char const   )'b',      (char const   )'e',      (char const   )'r',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'R',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'r',      (char const   )'o',      (char const   )'u',      (char const   )'n', 
        (char const   )'d',      (char const   )'-',      (char const   )'r',      (char const   )'o', 
        (char const   )'b',      (char const   )'i',      (char const   )'n',      (char const   )' ', 
        (char const   )'p',      (char const   )'o',      (char const   )'l',      (char const   )'l', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'S',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'d',      (char const   )'o',      (char const   )'n',      (char const   )'\'', 
        (char const   )'t',      (char const   )' ',      (char const   )'a',      (char const   )'d', 
        (char const   )'j',      (char const   )'u',      (char const   )'s',      (char const   )'t', 
        (char const   )' ',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )'s',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'t',      (char const   )'w',      (char const   )'o', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'p',      (char const   )'o',      (char const   )'n',      (char const   )'s', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'c', 
        (char const   )'u',      (char const   )'s',      (char const   )'t',      (char const   )'o', 
        (char const   )'m',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'r',      (char const   )'v',      (char const   )'i',      (char const   )'c', 
        (char const   )'e',      (char const   )'s',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'T', 
        (char const   )' ',      (char const   )'<',      (char const   )'s',      (char const   )'e', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'d', 
        (char const   )'s',      (char const   )'>',      (char const   )' ',      (char const   )'t', 
        (char const   )'i',      (char const   )'m',      (char const   )'e',      (char const   )'o', 
        (char const   )'u',      (char const   )'t',      (char const   )' ',      (char const   )'(', 
        (char const   )'1',      (char const   )'-',      (char const   )'3',      (char const   )'0', 
        (char const   )'0',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'d', 
        (char const   )'s',      (char const   )',',      (char const   )' ',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'a',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )' ',      (char const   )'5', 
        (char const   )')',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'t',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'t',      (char const   )'e', 
        (char const   )'s',      (char const   )'t',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'d',      (char const   )'e',      (char const   )' ', 
        (char const   )'(',      (char const   )'p',      (char const   )'r',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )' ',      (char const   )'s', 
        (char const   )'t',      (char const   )'a',      (char const   )'t',      (char const   )'s', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'i', 
        (char const   )'t',      (char const   )')',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'w', 
        (char const   )' ',      (char const   )'<',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'>',      (char const   )' ',      (char const   )' ',      (char const   )'s', 
        (char const   )'p',      (char const   )'e',      (char const   )'c',      (char const   )'i', 
        (char const   )'f',      (char const   )'y',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'t',      (char const   )'u',      (char const   )'r', 
        (char const   )'n',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'w',      (char const   )'e',      (char const   )'i',      (char const   )'g', 
        (char const   )'h',      (char const   )'t',      (char const   )';',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'s',      (char const   )':', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'e', 
        (char const   )'i',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'\"',      (char const   )'l', 
        (char const   )'o',      (char const   )'a',      (char const   )'d',      (char const   )':', 
        (char const   )'i',      (char const   )'n',      (char const   )'c',      (char const   )'r', 
        (char const   )'\"',      (char const   )' ',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'\"',      (char const   )'s',      (char const   )'e', 
        (char const   )'r',      (char const   )'v',      (char const   )'i',      (char const   )'c', 
        (char const   )'e',      (char const   )'\"',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'-', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )' ',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'t',      (char const   )'o',      (char const   )'c',      (char const   )'o', 
        (char const   )'l',      (char const   )' ',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'i',      (char const   )'t',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'Z', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'r', 
        (char const   )'a',      (char const   )'i',      (char const   )'s',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'I',      (char const   )'G', 
        (char const   )'S',      (char const   )'T',      (char const   )'O',      (char const   )'P', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )'c', 
        (char const   )'e',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'a',      (char const   )'d',      (char const   )'y',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'s',      (char const   )'w',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'q',      (char const   )'u', 
        (char const   )'e',      (char const   )'r',      (char const   )'i',      (char const   )'e', 
        (char const   )'s',      (char const   )'\n',      (char const   )'\000'};
#line 85 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
static void usage(int status ) 
{ 
  struct _IO_FILE *tmp ;

  {
#line 88
  if (status == 0) {
#line 88
    tmp = stdout;
  } else {
#line 88
    tmp = stderr;
  }
  {
#line 88
  fprintf((FILE */* __restrict  */)tmp, (char const   */* __restrict  */)"%s", usage_message);
#line 89
  exit(status);
  }
}
}
#line 96 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
static void version(void) 
{ 


  {
  {
#line 99
  printf((char const   */* __restrict  */)"lbcd protocol %d version %s\n", 3, "3.5.0");
#line 100
  exit(0);
  }
}
}
#line 109 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
static void exit_handler(int sig  __attribute__((__unused__)) ) 
{ 


  {
#line 112
  exit_signaled = (int volatile   )1;
#line 113
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
static void request_free(struct request *request ) 
{ 


  {
#line 122
  if ((unsigned long )request == (unsigned long )((void *)0)) {
#line 123
    return;
  }
  {
#line 124
  free((void *)request->addr);
#line 125
  free((void *)request->source);
#line 126
  vector_free(request->services);
#line 127
  free((void *)request);
  }
#line 128
  return;
}
}
#line 135 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
static void send_status(struct request *request , socket_type fd , enum lbcd_status status ) 
{ 
  struct lbcd_header header ;
  size_t size ;
  ssize_t result ;

  {
  {
#line 143
  header.version = htons((uint16_t )3);
#line 144
  header.id = htons((uint16_t )request->id);
#line 145
  header.op = htons((uint16_t )request->operation);
#line 146
  header.status = htons((uint16_t )status);
#line 149
  size = sizeof(header);
#line 150
  result = sendto(fd, (void const   *)(& header), size, 0, (struct sockaddr  const  */* __restrict  */)request->addr,
                  request->addrlen);
  }
#line 151
  if (result != (ssize_t )size) {
    {
#line 152
    syswarn("client %s: cannot send reply", request->source);
    }
  }
#line 153
  return;
}
}
#line 161 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
static _Bool service_allowed(struct lbcd_config *config , char const   *service ) 
{ 
  size_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 167
  tmp = strcmp(service, "default");
  }
#line 167
  if (tmp == 0) {
#line 168
    return ((_Bool)1);
  }
  {
#line 171
  tmp___0 = strcmp(service, "cmd");
  }
#line 171
  if (tmp___0 == 0) {
#line 172
    return ((_Bool)0);
  } else {
    {
#line 171
    tmp___1 = strncmp(service, "cmd:", (size_t )4);
    }
#line 171
    if (tmp___1 == 0) {
#line 172
      return ((_Bool)0);
    }
  }
#line 175
  i = (size_t )0;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i < (config->services)->count)) {
#line 175
      goto while_break;
    }
    {
#line 176
    tmp___2 = strcmp((char const   *)*((config->services)->strings + i), service);
    }
#line 176
    if (tmp___2 == 0) {
#line 177
      return ((_Bool)1);
    }
#line 175
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return ((_Bool)0);
}
}
#line 190 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
static struct request *request_recv(struct lbcd_config *config , socket_type fd ) 
{ 
  struct sockaddr_storage addr ;
  struct sockaddr *sockaddr ;
  socklen_t addrlen ;
  ssize_t result ;
  char raw[2048] ;
  char source[46] ;
  unsigned int tmp ;
  struct lbcd_request *packet ;
  unsigned int protocol ;
  unsigned int id ;
  unsigned int operation ;
  unsigned int nservices ;
  unsigned int i ;
  size_t expected ;
  struct request *request ;
  char *service ;
  _Bool tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  _Bool tmp___7 ;

  {
#line 198
  source[0] = (char )'U';
#line 198
  source[1] = (char )'N';
#line 198
  source[2] = (char )'K';
#line 198
  source[3] = (char )'N';
#line 198
  source[4] = (char )'O';
#line 198
  source[5] = (char )'W';
#line 198
  source[6] = (char )'N';
#line 198
  source[7] = (char )'\000';
#line 198
  tmp = 8U;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (tmp >= 46U) {
#line 198
      goto while_break;
    }
#line 198
    source[tmp] = (char)0;
#line 198
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  addrlen = (socklen_t )sizeof(addr);
#line 207
  sockaddr = (struct sockaddr *)(& addr);
#line 208
  result = recvfrom(fd, (void */* __restrict  */)(raw), sizeof(raw), 0, (struct sockaddr */* __restrict  */)sockaddr,
                    (socklen_t */* __restrict  */)(& addrlen));
  }
#line 209
  if (result <= 0L) {
    {
#line 210
    syswarn("cannot receive packet");
    }
#line 211
    return ((struct request *)((void *)0));
  }
  {
#line 215
  tmp___0 = network_sockaddr_sprint(source, sizeof(source), (struct sockaddr  const  *)sockaddr);
  }
#line 215
  if (! tmp___0) {
    {
#line 216
    syswarn("cannot convert client address to string");
    }
  }
#line 219
  if ((size_t )result < sizeof(struct lbcd_header )) {
    {
#line 220
    warn("client %s: short packet received (length %lu)", source, (unsigned long )result);
    }
#line 222
    return ((struct request *)((void *)0));
  }
  {
#line 226
  packet = (struct lbcd_request *)(raw);
#line 227
  tmp___1 = ntohs(packet->h.version);
#line 227
  protocol = (unsigned int )tmp___1;
#line 228
  tmp___2 = ntohs(packet->h.id);
#line 228
  id = (unsigned int )tmp___2;
#line 229
  tmp___3 = ntohs(packet->h.op);
#line 229
  operation = (unsigned int )tmp___3;
#line 230
  tmp___4 = ntohs(packet->h.status);
#line 230
  nservices = (unsigned int )tmp___4;
#line 233
  expected = sizeof(struct lbcd_header );
  }
#line 234
  if (protocol == 3U) {
#line 235
    if (nservices > 5U) {
      {
#line 236
      warn("client %s: too many services in request (%u)", source, nservices);
      }
#line 238
      return ((struct request *)((void *)0));
    }
#line 240
    expected += (unsigned long )nservices * sizeof(lbcd_name_type );
  }
#line 242
  if ((size_t )result != expected) {
    {
#line 243
    warn("client %s: incorrect packet size (%lu != %lu)", source, (unsigned long )result,
         expected);
    }
#line 245
    return ((struct request *)((void *)0));
  }
  {
#line 249
  tmp___5 = x_calloc((size_t )1, sizeof(struct request ), "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c",
                     249);
#line 249
  request = (struct request *)tmp___5;
#line 250
  request->source = x_strdup((char const   *)(source), "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c",
                             250);
#line 251
  request->addrlen = addrlen;
#line 252
  tmp___6 = x_malloc((size_t )addrlen, "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c",
                     252);
#line 252
  request->addr = (struct sockaddr *)tmp___6;
#line 253
  memcpy((void */* __restrict  */)request->addr, (void const   */* __restrict  */)(& addr),
         (size_t )addrlen);
#line 254
  request->protocol = protocol;
#line 255
  request->id = id;
#line 256
  request->operation = operation;
#line 257
  request->services = vector_new();
  }
#line 260
  if (protocol != 2U) {
#line 260
    if (protocol != 3U) {
      {
#line 261
      warn("client %s: protocol version %u unsupported", source, protocol);
#line 262
      send_status(request, fd, (enum lbcd_status )3);
      }
#line 263
      goto fail;
    }
  }
#line 271
  if (request->protocol == 3U) {
#line 272
    i = 0U;
    {
#line 272
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 272
      if (! (i < nservices)) {
#line 272
        goto while_break___0;
      }
      {
#line 273
      service = x_strndup((char const   *)(packet->names[i]), sizeof(lbcd_name_type ),
                          "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c", 273);
#line 274
      tmp___7 = service_allowed(config, (char const   *)service);
      }
#line 274
      if (! tmp___7) {
        {
#line 275
        warn("client %s: service %s not allowed", source, service);
#line 276
        send_status(request, fd, (enum lbcd_status )2);
#line 277
        free((void *)service);
        }
#line 278
        goto fail;
      }
      {
#line 280
      vector_add(request->services, (char const   *)service);
#line 281
      free((void *)service);
#line 272
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 283
  return (request);
  fail: 
  {
#line 286
  request_free(request);
  }
#line 287
  return ((struct request *)((void *)0));
}
}
#line 295 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
static void handle_lb_request(struct lbcd_config *config , struct request *request ,
                              socket_type fd ) 
{ 
  struct lbcd_reply reply ;
  size_t size ;
  size_t unused ;
  ssize_t result ;

  {
#line 304
  if (config->log) {
    {
#line 305
    notice("request from %s (version %d)", request->source, request->protocol);
    }
  }
  {
#line 309
  reply.h.version = htons((uint16_t )request->protocol);
#line 310
  reply.h.id = htons((uint16_t )request->id);
#line 311
  reply.h.op = htons((uint16_t )request->operation);
#line 312
  reply.h.status = htons((uint16_t )1);
#line 315
  lbcd_pack_info(& reply, request->protocol, request->services, (int )config->simple);
#line 319
  unused = 5UL - (request->services)->count;
#line 320
  size = sizeof(reply) - unused * sizeof(struct lbcd_service );
#line 323
  result = sendto(fd, (void const   *)(& reply), size, 0, (struct sockaddr  const  */* __restrict  */)request->addr,
                  request->addrlen);
  }
#line 324
  if (result < 0L) {
    {
#line 325
    syswarn("client %s: cannot send reply", request->source);
    }
  } else
#line 324
  if ((size_t )result != size) {
    {
#line 325
    syswarn("client %s: cannot send reply", request->source);
    }
  }
#line 326
  return;
}
}
#line 334 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
static _Bool is_ipv6(char const   *string ) 
{ 
  struct in6_addr addr ;
  int tmp ;

  {
  {
#line 338
  tmp = inet_pton(10, (char const   */* __restrict  */)string, (void */* __restrict  */)(& addr));
  }
#line 338
  return ((_Bool )(tmp == 1));
}
}
#line 358 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
static void bind_socket(struct lbcd_config *config , socket_type **fds , unsigned int *count ) 
{ 
  int status ;
  size_t i ;
  char const   *addr ;
  char *tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  void *tmp___2 ;
  _Bool tmp___3 ;

  {
#line 367
  status = 0;
#line 368
  if (status < 0) {
    {
#line 369
    tmp = strerror(- status);
#line 369
    die("using systemd-bound sockets failed: %s", tmp);
    }
  }
#line 370
  if (status > 0) {
    {
#line 371
    tmp___0 = x_calloc((size_t )status, sizeof(socket_type ), "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c",
                       371);
#line 371
    *fds = (socket_type *)tmp___0;
#line 372
    i = (size_t )0;
    }
    {
#line 372
    while (1) {
      while_continue: /* CIL Label */ ;
#line 372
      if (! (i < (size_t )status)) {
#line 372
        goto while_break;
      }
#line 373
      *(*fds + i) = (socket_type )(3UL + i);
#line 372
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 374
    *count = (unsigned int )status;
#line 375
    return;
  }
#line 384
  if ((config->bindaddrs)->count == 0UL) {
    {
#line 385
    tmp___1 = network_bind_all(2, config->port, fds, count);
    }
#line 385
    if (! tmp___1) {
      {
#line 386
      sysdie("cannot create UDP socket");
      }
    }
  } else {
    {
#line 388
    *count = (unsigned int )(config->bindaddrs)->count;
#line 389
    tmp___2 = x_calloc((size_t )*count, sizeof(socket_type ), "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c",
                       389);
#line 389
    *fds = (socket_type *)tmp___2;
#line 390
    i = (size_t )0;
    }
    {
#line 390
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 390
      if (! (i < (config->bindaddrs)->count)) {
#line 390
        goto while_break___0;
      }
      {
#line 391
      addr = (char const   *)*((config->bindaddrs)->strings + i);
#line 392
      tmp___3 = is_ipv6(addr);
      }
#line 392
      if (tmp___3) {
        {
#line 393
        *(*fds + i) = network_bind_ipv6(2, addr, config->port);
        }
      } else {
        {
#line 395
        *(*fds + i) = network_bind_ipv4(2, addr, config->port);
        }
      }
#line 396
      if (*(*fds + i) == -1) {
        {
#line 397
        sysdie("cannot bind to address %s, port %hu", addr, (int )config->port);
        }
      }
#line 390
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 401
  return;
}
}
#line 408 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
static void handle_requests(struct lbcd_config *config ) 
{ 
  int status ;
  socket_type *fds ;
  unsigned int count ;
  unsigned int i ;
  FILE *pid ;
  struct sigaction sa ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  socket_type fd ;
  struct request *request ;
  int *tmp___5 ;

  {
  {
#line 422
  memset((void *)(& sa), 0, sizeof(sa));
#line 423
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 424
  tmp = sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 424
  if (tmp < 0) {
    {
#line 425
    syswarn("cannot set SIGHUP handler");
    }
  }
  {
#line 428
  sa.__sigaction_handler.sa_handler = & exit_handler;
#line 429
  tmp___0 = sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 429
  if (tmp___0 < 0) {
    {
#line 430
    syswarn("cannot set SIGINT handler");
    }
  }
  {
#line 431
  tmp___1 = sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 431
  if (tmp___1 < 0) {
    {
#line 432
    syswarn("cannot set SIGTERM handler");
    }
  }
  {
#line 435
  bind_socket(config, & fds, & count);
  }
#line 438
  if ((unsigned long )config->pid_file != (unsigned long )((void *)0)) {
    {
#line 439
    pid = fopen((char const   */* __restrict  */)config->pid_file, (char const   */* __restrict  */)"w");
    }
#line 440
    if ((unsigned long )pid == (unsigned long )((void *)0)) {
      {
#line 441
      warn("cannot create PID file %s", config->pid_file);
      }
    } else {
      {
#line 443
      tmp___2 = getpid();
#line 443
      fprintf((FILE */* __restrict  */)pid, (char const   */* __restrict  */)"%d\n",
              tmp___2);
#line 444
      fclose(pid);
      }
    }
  }
  {
#line 447
  notice("ready to accept requests");
#line 450
  status = 0;
  }
#line 451
  if (status < 0) {
    {
#line 452
    tmp___3 = strerror(- status);
#line 452
    warn("cannot notify systemd of startup: %s", tmp___3);
    }
  }
#line 455
  if (config->upstart) {
    {
#line 456
    tmp___4 = raise(19);
    }
#line 456
    if (tmp___4 < 0) {
      {
#line 457
      syswarn("cannot notify upstart of startup");
      }
    }
  }
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (exit_signaled) {
      {
#line 466
      notice("signal received, exiting");
      }
#line 467
      goto while_break;
    }
    {
#line 475
    fd = network_wait_any(fds, count);
    }
#line 476
    if (fd == -1) {
      {
#line 477
      tmp___5 = __errno_location();
      }
#line 477
      if (*tmp___5 != 4) {
        {
#line 478
        sysdie("cannot wait for incoming connections");
        }
      }
#line 479
      goto while_continue;
    }
    {
#line 483
    request = request_recv(config, fd);
    }
#line 484
    if ((unsigned long )request == (unsigned long )((void *)0)) {
#line 485
      goto while_continue;
    }
    {
#line 487
    if (request->operation == 1U) {
#line 487
      goto case_1;
    }
#line 490
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 488
    handle_lb_request(config, request, fd);
    }
#line 489
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 491
    warn("client %s: unknown op %d requested", request->source, request->operation);
#line 493
    send_status(request, fd, (enum lbcd_status )5);
    }
#line 494
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 496
    request_free(request);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 500
  if ((unsigned long )config->pid_file != (unsigned long )((void *)0)) {
    {
#line 501
    unlink(config->pid_file);
    }
  }
#line 502
  i = 0U;
  {
#line 502
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 502
    if (! (i < count)) {
#line 502
      goto while_break___0;
    }
    {
#line 503
    close(*(fds + i));
#line 502
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 504
  free((void *)fds);
  }
#line 505
  return;
}
}
#line 512 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/lbcd.c"
int main(int argc , char **argv ) 
{ 
  struct lbcd_config config ;
  int debugging ;
  int testmode ;
  int foreground ;
  char *lbcd_helper ;
  char const   *service_weight ;
  int service_timeout ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 516
  debugging = 0;
#line 517
  testmode = 0;
#line 518
  foreground = 0;
#line 519
  lbcd_helper = (char *)((void *)0);
#line 520
  service_weight = (char const   *)((void *)0);
#line 521
  service_timeout = 5;
#line 525
  message_program_name = "lbcd";
#line 528
  if ((unsigned long )*(argv + 1) != (unsigned long )((void *)0)) {
#line 529
    if ((int )*(*(argv + 1) + 0) == 45) {
#line 529
      if ((int )*(*(argv + 1) + 1) == 45) {
#line 529
        if ((int )*(*(argv + 1) + 2) != 0) {
          {
#line 531
          if ((int )*(*(argv + 1) + 2) == 104) {
#line 531
            goto case_104;
          }
#line 533
          if ((int )*(*(argv + 1) + 2) == 118) {
#line 533
            goto case_118;
          }
#line 535
          goto switch_default;
          case_104: /* CIL Label */ 
          {
#line 532
          usage(0);
          }
          case_118: /* CIL Label */ 
          {
#line 534
          version();
          }
          switch_default: /* CIL Label */ 
          {
#line 536
          usage(1);
          }
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 541
  memset((void *)(& config), 0, sizeof(config));
#line 542
  config.bindaddrs = vector_new();
#line 543
  config.port = (unsigned short)4330;
#line 544
  config.services = vector_new();
#line 547
  opterr = 1;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 548
    c = getopt(argc, (char * const  *)argv, "a:b:c:dfhlP:p:RStT:w:Z");
    }
#line 548
    if (! (c != -1)) {
#line 548
      goto while_break;
    }
    {
#line 550
    if (c == 97) {
#line 550
      goto case_97;
    }
#line 553
    if (c == 98) {
#line 553
      goto case_98;
    }
#line 556
    if (c == 99) {
#line 556
      goto case_99;
    }
#line 561
    if (c == 100) {
#line 561
      goto case_100;
    }
#line 565
    if (c == 102) {
#line 565
      goto case_102;
    }
#line 568
    if (c == 104) {
#line 568
      goto case_104___0;
    }
#line 571
    if (c == 108) {
#line 571
      goto case_108;
    }
#line 574
    if (c == 80) {
#line 574
      goto case_80;
    }
#line 577
    if (c == 112) {
#line 577
      goto case_112;
    }
#line 580
    if (c == 82) {
#line 580
      goto case_82;
    }
#line 583
    if (c == 83) {
#line 583
      goto case_83;
    }
#line 586
    if (c == 116) {
#line 586
      goto case_116;
    }
#line 589
    if (c == 84) {
#line 589
      goto case_84;
    }
#line 595
    if (c == 119) {
#line 595
      goto case_119;
    }
#line 599
    if (c == 90) {
#line 599
      goto case_90;
    }
#line 602
    goto switch_default___0;
    case_97: /* CIL Label */ 
    {
#line 551
    vector_add(config.services, (char const   *)optarg);
    }
#line 552
    goto switch_break___0;
    case_98: /* CIL Label */ 
    {
#line 554
    vector_add(config.bindaddrs, (char const   *)optarg);
    }
#line 555
    goto switch_break___0;
    case_99: /* CIL Label */ 
    {
#line 557
    lbcd_helper = optarg;
#line 558
    tmp = access((char const   *)lbcd_helper, 1);
    }
#line 558
    if (tmp != 0) {
      {
#line 559
      sysdie("cannot access %s", optarg);
      }
    }
#line 560
    goto switch_break___0;
    case_100: /* CIL Label */ 
#line 562
    debugging = 1;
#line 563
    foreground = 1;
#line 564
    goto switch_break___0;
    case_102: /* CIL Label */ 
#line 566
    foreground = 1;
#line 567
    goto switch_break___0;
    case_104___0: /* CIL Label */ 
    {
#line 569
    usage(0);
    }
#line 570
    goto switch_break___0;
    case_108: /* CIL Label */ 
#line 572
    config.log = (_Bool)1;
#line 573
    goto switch_break___0;
    case_80: /* CIL Label */ 
#line 575
    config.pid_file = (char const   *)optarg;
#line 576
    goto switch_break___0;
    case_112: /* CIL Label */ 
    {
#line 578
    tmp___0 = atoi((char const   *)optarg);
#line 578
    config.port = (unsigned short )tmp___0;
    }
#line 579
    goto switch_break___0;
    case_82: /* CIL Label */ 
#line 581
    service_weight = "rr";
#line 582
    goto switch_break___0;
    case_83: /* CIL Label */ 
#line 584
    config.simple = (_Bool)1;
#line 585
    goto switch_break___0;
    case_116: /* CIL Label */ 
#line 587
    testmode = 1;
#line 588
    goto switch_break___0;
    case_84: /* CIL Label */ 
    {
#line 590
    service_timeout = atoi((char const   *)optarg);
    }
#line 591
    if (service_timeout < 1) {
      {
#line 592
      die("timeout (%d) must be between 1 and 300 seconds", service_timeout);
      }
    } else
#line 591
    if (service_timeout > 300) {
      {
#line 592
      die("timeout (%d) must be between 1 and 300 seconds", service_timeout);
      }
    }
#line 594
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 596
    service_weight = (char const   *)optarg;
#line 597
    vector_add(config.services, (char const   *)optarg);
    }
#line 598
    goto switch_break___0;
    case_90: /* CIL Label */ 
#line 600
    config.upstart = (_Bool)1;
#line 601
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 603
    usage(1);
    }
#line 604
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 609
  tmp___1 = lbcd_weight_init((char const   *)lbcd_helper, service_weight, service_timeout);
  }
#line 609
  if (tmp___1 != 0) {
    {
#line 610
    die("cannot initialize service handler");
    }
  }
#line 613
  if (testmode) {
    {
#line 614
    lbcd_test(argc - optind, argv + optind);
    }
  }
#line 621
  if (! foreground) {
    {
#line 622
    tmp___2 = daemon(1, 0);
    }
#line 622
    if (tmp___2 < 0) {
      {
#line 623
      sysdie("cannot daemonize");
      }
    }
  }
#line 626
  if (! debugging) {
    {
#line 627
    openlog("lbcd", 9, 3 << 3);
#line 628
    message_handlers_notice(1U, & message_log_syslog_info);
#line 629
    message_handlers_warn(1U, & message_log_syslog_warning);
#line 630
    message_handlers_die(1U, & message_log_syslog_err);
    }
  }
  {
#line 634
  handle_requests(& config);
#line 642
  vector_free(config.bindaddrs);
#line 643
  vector_free(config.services);
  }
#line 644
  return (0);
}
}
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 216 "./portable/socket.h"
#pragma GCC visibility push(hidden)
#line 275
#pragma GCC visibility pop
#line 23 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/ftp.c"
static int probe_ftp(char const   *host , int timeout ) 
{ 
  int tmp ;

  {
  {
#line 26
  tmp = probe_tcp(host, "ftp", (short)21, "220", timeout);
  }
#line 26
  return (tmp);
}
}
#line 33 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/ftp.c"
int lbcd_ftp_weight(uint32_t *weight_val , uint32_t *incr_val  __attribute__((__unused__)) ,
                    int timeout , char const   *portarg  __attribute__((__unused__)) ,
                    struct lbcd_reply *lb  __attribute__((__unused__)) ) 
{ 
  int tmp ;

  {
  {
#line 37
  tmp = probe_ftp("localhost", timeout);
#line 37
  *weight_val = (uint32_t )tmp;
  }
#line 38
  return ((int )*weight_val);
}
}
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 216 "./portable/socket.h"
#pragma GCC visibility push(hidden)
#line 275
#pragma GCC visibility pop
#line 26 "./modules/modules.h"
extern int udp_connect(char const   *host , char const   *protocol , int port ) ;
#line 123 "./modules/monlist.h"
int monlist(int sd , int timeout ) ;
#line 25 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/ntp.c"
static int probe_ntp(char const   *host , int timeout ) 
{ 
  int sd ;
  int retval ;
  char const   *tmp ;

  {
#line 29
  retval = 0;
#line 31
  if (host) {
#line 31
    tmp = host;
  } else {
#line 31
    tmp = "localhost";
  }
  {
#line 31
  sd = udp_connect(tmp, "ntp", 123);
  }
#line 32
  if (sd == -1) {
#line 33
    return (-1);
  } else {
    {
#line 35
    retval = monlist(sd, timeout);
#line 36
    close(sd);
    }
  }
#line 38
  return (retval);
}
}
#line 45 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/ntp.c"
int lbcd_ntp_weight(uint32_t *weight_val , uint32_t *incr_val  __attribute__((__unused__)) ,
                    int timeout , char const   *portarg  __attribute__((__unused__)) ,
                    struct lbcd_reply *lb  __attribute__((__unused__)) ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 49
  tmp = probe_ntp("localhost", timeout);
#line 49
  *weight_val = (uint32_t )tmp;
  }
#line 50
  if (*weight_val == 4294967295U) {
#line 50
    tmp___0 = -1;
  } else {
#line 50
    tmp___0 = 0;
  }
#line 50
  return (tmp___0);
}
}
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 216 "./portable/socket.h"
#pragma GCC visibility push(hidden)
#line 275
#pragma GCC visibility pop
#line 23 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/nntp.c"
static int probe_nntp(char const   *host , int timeout ) 
{ 
  int tmp ;

  {
  {
#line 26
  tmp = probe_tcp(host, "nntp", (short)119, "200", timeout);
  }
#line 26
  return (tmp);
}
}
#line 33 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/nntp.c"
int lbcd_nntp_weight(uint32_t *weight_val , uint32_t *incr_val  __attribute__((__unused__)) ,
                     int timeout , char const   *portarg  __attribute__((__unused__)) ,
                     struct lbcd_reply *lb  __attribute__((__unused__)) ) 
{ 
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 37
  tmp___0 = probe_nntp("localhost", timeout);
#line 37
  tmp = (uint32_t )tmp___0;
#line 37
  *weight_val = tmp;
  }
#line 37
  return ((int )tmp);
}
}
#line 51 "/usr/include/x86_64-linux-gnu/sys/statvfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) statvfs)(char const   * __restrict  __file ,
                                                                                                struct statvfs * __restrict  __buf ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 29 "/home/wheatley/newnew/temp/lbcd-3.5.0/server/tmp_full.c"
int tmp_full(char const   *path ) 
{ 
  struct statvfs info ;
  int percent ;
  double total ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 33
  percent = 0;
#line 36
  tmp = chdir(path);
  }
#line 36
  if (tmp == 0) {
    {
#line 36
    tmp___0 = statvfs((char const   */* __restrict  */)".", (struct statvfs */* __restrict  */)(& info));
    }
#line 36
    if (tmp___0 == 0) {
#line 37
      if ((double )info.f_bavail > (double )info.f_blocks * 0.95) {
#line 38
        total = (double )info.f_blocks;
      } else {
#line 40
        total = (double )info.f_blocks * 0.95;
      }
#line 41
      percent = (int )(((total - (double )info.f_bavail) * 100.0) / total + 0.5);
#line 42
      if (percent < 0) {
#line 43
        percent = 0;
      }
#line 44
      if (percent > 100) {
#line 45
        percent = 100;
      }
    }
  }
#line 47
  return (percent);
}
}
#line 149 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 216 "./portable/socket.h"
#pragma GCC visibility push(hidden)
#line 275
#pragma GCC visibility pop
#line 113 "./portable/system.h"
#pragma GCC visibility push(hidden)
#line 149
#pragma GCC visibility pop
#line 42 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/monlist.c"
static int sendrequest(int sd , int implcode , int reqcode ) 
{ 
  struct req_pkt qpkt ;
  ssize_t tmp ;

  {
  {
#line 47
  memset((void *)(& qpkt), 0, sizeof(qpkt));
#line 48
  qpkt.rm_vn_mode = (uint8_t )((3 << 3) | 7);
#line 49
  qpkt.implementation = (uint8_t )implcode;
#line 50
  qpkt.request = (uint8_t )reqcode;
#line 51
  qpkt.err_nitems = htons((uint16_t )0);
#line 52
  qpkt.mbz_itemsize = htons((uint16_t )0);
#line 53
  qpkt.auth_seq = (uint8_t )0;
#line 55
  tmp = send(sd, (void const   *)(& qpkt), sizeof(struct req_pkt ), 0);
  }
#line 55
  if (tmp == -1L) {
#line 56
    return (-1);
  }
#line 57
  return (0);
}
}
#line 64 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/monlist.c"
static int getresponse(int sd , int implcode , int reqcode , int *ritems , int timeout ) 
{ 
  struct resp_pkt rpkt ;
  struct timeval tv ;
  int seq ;
  fd_set fds ;
  int n ;
  int seenpacket[100] ;
  int lastseq ;
  int numrecv ;
  int __d0 ;
  int __d1 ;
  ssize_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;

  {
  {
#line 68
  tv.tv_sec = (__time_t )0;
#line 68
  tv.tv_usec = (__suseconds_t )0;
#line 73
  lastseq = 999;
#line 74
  numrecv = 0;
#line 76
  tv.tv_sec = (__time_t )timeout;
#line 77
  *ritems = 0;
#line 78
  memset((void *)(seenpacket), 0, sizeof(seenpacket));
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 82
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 82
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.fds_bits[0]): "memory");
#line 82
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 83
    fds.fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sd % (8 * (int )sizeof(__fd_mask ));
#line 84
    n = select(sd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 85
    if (n < 1) {
#line 86
      return (-1);
    }
    {
#line 87
    tmp = recv(sd, (void *)((char *)(& rpkt)), sizeof(rpkt), 0);
#line 87
    n = (int )tmp;
    }
#line 88
    if (n == -1) {
#line 89
      return (-1);
    }
#line 92
    if (n < 8) {
#line 98
      goto while_continue;
    } else
#line 92
    if ((int )((uint8_t )(((int )rpkt.rm_vn_mode >> 3) & 7)) != 3) {
#line 98
      goto while_continue;
    } else
#line 92
    if (((int )rpkt.rm_vn_mode & 7) != 7) {
#line 98
      goto while_continue;
    } else
#line 92
    if (((int )rpkt.auth_seq & 128) != 0) {
#line 98
      goto while_continue;
    } else
#line 92
    if (! (((int )rpkt.rm_vn_mode & 128) != 0)) {
#line 98
      goto while_continue;
    } else {
      {
#line 92
      tmp___0 = ntohs(rpkt.mbz_itemsize);
      }
#line 92
      if ((((int )tmp___0 >> 12) & 15) != 0) {
#line 98
        goto while_continue;
      }
    }
#line 101
    if ((int )rpkt.implementation != implcode) {
#line 102
      goto while_continue;
    } else
#line 101
    if ((int )rpkt.request != reqcode) {
#line 102
      goto while_continue;
    }
    {
#line 105
    tmp___2 = ntohs(rpkt.err_nitems);
    }
#line 105
    if ((int )((uint16_t )(((int )tmp___2 >> 12) & 15)) != 0) {
      {
#line 106
      tmp___1 = ntohs(rpkt.err_nitems);
      }
#line 106
      return ((int )((uint16_t )(((int )tmp___1 >> 12) & 15)));
    }
#line 109
    seq = (int )rpkt.auth_seq & 127;
#line 110
    if (seq >= 100) {
#line 111
      goto while_continue;
    }
#line 112
    if (seenpacket[seq]) {
#line 113
      goto while_continue;
    }
    {
#line 114
    (seenpacket[seq]) ++;
#line 117
    tmp___3 = ntohs(rpkt.err_nitems);
#line 117
    *ritems += (int )((uint16_t )((int )tmp___3 & 4095));
    }
#line 120
    if (! (((int )rpkt.rm_vn_mode & 64) != 0)) {
#line 121
      if (lastseq != 999) {
#line 122
        goto while_continue;
      }
#line 123
      lastseq = seq;
    }
#line 127
    numrecv ++;
#line 128
    if (numrecv <= lastseq) {
#line 129
      goto while_continue;
    }
#line 130
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return (0);
}
}
#line 139 "/home/wheatley/newnew/temp/lbcd-3.5.0/modules/monlist.c"
int monlist(int sd , int timeout ) 
{ 
  int res ;
  int peers ;

  {
  {
#line 145
  res = sendrequest(sd, 2, 20);
  }
#line 146
  if (res != 0) {
#line 147
    return (-1);
  }
  {
#line 150
  res = getresponse(sd, 2, 20, & peers, timeout);
  }
#line 151
  if (res != 0) {
#line 152
    return (-1);
  }
#line 153
  return (peers);
}
}
