/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 154 "/usr/include/linux/cdrom.h"
struct cdrom_msf0 {
   __u8 minute ;
   __u8 second ;
   __u8 frame ;
};
#line 162 "/usr/include/linux/cdrom.h"
union cdrom_addr {
   struct cdrom_msf0 msf ;
   int lba ;
};
#line 189 "/usr/include/linux/cdrom.h"
struct cdrom_tochdr {
   __u8 cdth_trk0 ;
   __u8 cdth_trk1 ;
};
#line 219 "/usr/include/linux/cdrom.h"
struct cdrom_tocentry {
   __u8 cdte_track ;
   __u8 cdte_adr : 4 ;
   __u8 cdte_ctrl : 4 ;
   __u8 cdte_format ;
   union cdrom_addr cdte_addr ;
   __u8 cdte_datamode ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 102 "/home/june/repo/benchmarks/collector/temp/cd-discid-1.4/cd-discid.c"
int cddb_sum(int n ) 
{ 
  int ret ;

  {
#line 105
  ret = 0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (n > 0)) {
#line 107
      goto while_break;
    }
#line 108
    ret += n % 10;
#line 109
    n /= 10;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (ret);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/cd-discid-1.4/cd-discid.c"
void usage(void) 
{ 


  {
  {
#line 117
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: cd-discid [<option> ...]\n\n");
#line 118
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options:\n");
#line 119
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  --musicbrainz   Output a TOC that is suitable for calculating the MusicBrainz disc id.\n");
#line 121
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  --help          Show this message.\n");
#line 122
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  --version       Show the version.\n");
#line 123
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  devicename      CD-ROM block device name that contains the CD to be queried.\n");
  }
#line 125
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cd-discid-1.4/cd-discid.c"
int main(int argc , char **argv ) 
{ 
  int len ;
  int drive ;
  int i ;
  int totaltime ;
  long cksum ;
  int musicbrainz ;
  unsigned char first ;
  unsigned char last ;
  char *devicename ;
  struct cdrom_tochdr hdr ;
  struct cdrom_tocentry *TocEntry ;
  char *command ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 131
  cksum = 0L;
#line 132
  musicbrainz = 0;
#line 133
  first = (unsigned char)1;
#line 133
  last = (unsigned char)1;
#line 134
  devicename = (char *)"/dev/cdrom";
#line 137
  command = *(argv + 0);
#line 145
  if (argc == 2) {
    {
#line 145
    tmp = strcmp((char const   *)*(argv + 1), "--help");
    }
#line 145
    if (! tmp) {
      {
#line 146
      usage();
#line 147
      exit(0);
      }
    }
  }
#line 149
  if (argc == 2) {
    {
#line 149
    tmp___0 = strcmp((char const   *)*(argv + 1), "--version");
    }
#line 149
    if (! tmp___0) {
      {
#line 150
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cd-discid %s.\n",
              "1.4");
#line 151
      exit(0);
      }
    }
  }
#line 153
  if (argc >= 2) {
    {
#line 153
    tmp___1 = strcmp((char const   *)*(argv + 1), "--musicbrainz");
    }
#line 153
    if (! tmp___1) {
#line 154
      musicbrainz = 1;
#line 155
      argc --;
#line 156
      argv ++;
    }
  }
#line 158
  if (argc == 2) {
#line 159
    devicename = *(argv + 1);
  } else
#line 160
  if (argc > 2) {
    {
#line 161
    usage();
#line 162
    exit(1);
    }
  }
  {
#line 165
  drive = open((char const   *)devicename, 2048);
  }
#line 166
  if (drive < 0) {
    {
#line 167
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: ",
            command, devicename);
#line 168
    perror("open");
#line 169
    exit(1);
    }
  }
  {
#line 183
  tmp___2 = ioctl(drive, 21253UL, & hdr);
  }
#line 183
  if (tmp___2 < 0) {
    {
#line 184
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: ",
            command, devicename);
#line 185
    perror("CDROMREADTOCHDR");
#line 186
    exit(1);
    }
  }
  {
#line 190
  first = hdr.cdth_trk0;
#line 191
  last = hdr.cdth_trk1;
#line 193
  len = (int )((unsigned long )((int )last + 1) * sizeof(struct cdrom_tocentry ));
#line 195
  tmp___3 = malloc((size_t )len);
#line 195
  TocEntry = (struct cdrom_tocentry *)tmp___3;
  }
#line 196
  if (! TocEntry) {
    {
#line 197
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: Can\'t allocate memory for TOC entries\n",
            command, devicename);
#line 200
    exit(1);
    }
  }
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < (int )last)) {
#line 242
      goto while_break;
    }
    {
#line 244
    (TocEntry + i)->cdte_track = (__u8 )(i + 1);
#line 245
    (TocEntry + i)->cdte_format = (__u8 )1;
#line 246
    tmp___4 = ioctl(drive, 21254UL, TocEntry + i);
    }
#line 246
    if (tmp___4 < 0) {
      {
#line 247
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: ",
              command, devicename);
#line 248
      perror("CDROMREADTOCENTRY");
      }
    }
#line 242
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 252
  (TocEntry + last)->cdte_track = (__u8 )170;
#line 253
  (TocEntry + last)->cdte_format = (__u8 )1;
#line 254
  tmp___5 = ioctl(drive, 21254UL, TocEntry + i);
  }
#line 254
  if (tmp___5 < 0) {
    {
#line 255
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: ",
            command, devicename);
#line 256
    perror("CDROMREADTOCENTRY");
    }
  }
  {
#line 261
  close(drive);
#line 267
  i = 0;
  }
  {
#line 267
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 267
    if (! (i < (int )last)) {
#line 267
      goto while_break___0;
    }
    {
#line 271
    tmp___6 = cddb_sum(((TocEntry + i)->cdte_addr.lba + 150) / 75);
#line 271
    cksum += (long )tmp___6;
#line 267
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 274
  totaltime = ((TocEntry + last)->cdte_addr.lba + 150) / 75 - ((TocEntry + 0)->cdte_addr.lba + 150) / 75;
#line 278
  if (! musicbrainz) {
    {
#line 279
    printf((char const   */* __restrict  */)"%08lx ", ((cksum % 255L << 24) | (long )(totaltime << 8)) | (long )last);
    }
  }
  {
#line 282
  printf((char const   */* __restrict  */)"%d", (int )last);
#line 285
  i = 0;
  }
  {
#line 285
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 285
    if (! (i < (int )last)) {
#line 285
      goto while_break___1;
    }
    {
#line 286
    printf((char const   */* __restrict  */)" %d", (TocEntry + i)->cdte_addr.lba + 150);
#line 285
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 288
  if (musicbrainz) {
    {
#line 289
    printf((char const   */* __restrict  */)" %d\n", (TocEntry + last)->cdte_addr.lba + 150);
    }
  } else {
    {
#line 292
    printf((char const   */* __restrict  */)" %d\n", ((TocEntry + last)->cdte_addr.lba + 150) / 75);
    }
  }
  {
#line 294
  free((void *)TocEntry);
  }
#line 296
  return (0);
}
}
