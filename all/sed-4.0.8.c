/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 213 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef unsigned int size_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef long long __off64_t;
#line 182 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 43 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 173 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 179 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 264 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 328 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 77 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 52 "../basicdefs.h"
enum __anonenum_flagT_27 {
    FALSE = 0,
    TRUE = 1
} ;
#line 52 "../basicdefs.h"
typedef enum __anonenum_flagT_27 flagT;
#line 40 "utils.h"
struct buffer;
#line 82 "utils.c"
struct id {
   FILE *fp ;
   char *name ;
   struct id *link ;
};
#line 337 "utils.c"
struct buffer {
   size_t allocated ;
   size_t length ;
   char *b ;
};
#line 41 "/usr/include/bits/types.h"
typedef unsigned char __uint8_t;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 53 "regex.h"
typedef unsigned long reg_syntax_t;
#line 300
enum __anonenum_reg_errcode_t_8 {
    REG_NOERROR = 0,
    REG_NOMATCH = 1,
    REG_BADPAT = 2,
    REG_ECOLLATE = 3,
    REG_ECTYPE = 4,
    REG_EESCAPE = 5,
    REG_ESUBREG = 6,
    REG_EBRACK = 7,
    REG_EPAREN = 8,
    REG_EBRACE = 9,
    REG_BADBR = 10,
    REG_ERANGE = 11,
    REG_ESPACE = 12,
    REG_BADRPT = 13,
    REG_EEND = 14,
    REG_ESIZE = 15,
    REG_ERPAREN = 16
} ;
#line 300 "regex.h"
typedef enum __anonenum_reg_errcode_t_8 reg_errcode_t;
#line 340 "regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 408 "regex.h"
typedef struct re_pattern_buffer regex_t;
#line 411 "regex.h"
typedef int regoff_t;
#line 416 "regex.h"
struct re_registers {
   unsigned int num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 435 "regex.h"
struct __anonstruct_regmatch_t_9 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 435 "regex.h"
typedef struct __anonstruct_regmatch_t_9 regmatch_t;
#line 325 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef long wchar_t;
#line 354 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef unsigned int wint_t;
#line 76 "/usr/include/wchar.h"
union __anonunion___value_12 {
   wint_t __wch ;
   char __wchb[4] ;
};
#line 76 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_11 {
   int __count ;
   union __anonunion___value_12 __value ;
};
#line 76 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_11 __mbstate_t;
#line 95 "/usr/include/wchar.h"
typedef __mbstate_t mbstate_t;
#line 67 "/usr/include/wctype.h"
typedef unsigned long wctype_t;
#line 122 "regex_internal.h"
typedef unsigned int bitset[((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)];
#line 123 "regex_internal.h"
typedef unsigned int *re_bitset_ptr_t;
#line 147
enum __anonenum_re_context_type_24 {
    INSIDE_WORD = 5,
    WORD_FIRST = 6,
    WORD_LAST = 9,
    LINE_FIRST = 16,
    LINE_LAST = 32,
    BUF_FIRST = 64,
    BUF_LAST = 128,
    WORD_DELIM = 256
} ;
#line 147 "regex_internal.h"
typedef enum __anonenum_re_context_type_24 re_context_type;
#line 159 "regex_internal.h"
struct __anonstruct_re_node_set_25 {
   int alloc ;
   int nelem ;
   int *elems ;
};
#line 159 "regex_internal.h"
typedef struct __anonstruct_re_node_set_25 re_node_set;
#line 166
enum __anonenum_re_token_type_t_26 {
    NON_TYPE = 0,
    OP_OPEN_BRACKET = 1,
    OP_CLOSE_BRACKET = 2,
    OP_CHARSET_RANGE = 3,
    OP_OPEN_DUP_NUM = 4,
    OP_CLOSE_DUP_NUM = 5,
    OP_NON_MATCH_LIST = 6,
    OP_OPEN_COLL_ELEM = 7,
    OP_CLOSE_COLL_ELEM = 8,
    OP_OPEN_EQUIV_CLASS = 9,
    OP_CLOSE_EQUIV_CLASS = 10,
    OP_OPEN_CHAR_CLASS = 11,
    OP_CLOSE_CHAR_CLASS = 12,
    OP_WORD = 13,
    OP_NOTWORD = 14,
    OP_SPACE = 15,
    OP_NOTSPACE = 16,
    BACK_SLASH = 17,
    CONCAT = 18,
    ALT = 19,
    SUBEXP = 20,
    SIMPLE_BRACKET = 21,
    COMPLEX_BRACKET = 22,
    OP_OPEN_SUBEXP = 23,
    OP_CLOSE_SUBEXP = 24,
    OP_PERIOD = 25,
    CHARACTER = 26,
    END_OF_RE = 27,
    OP_ALT = 28,
    OP_DUP_ASTERISK = 29,
    OP_DUP_PLUS = 30,
    OP_DUP_QUESTION = 31,
    OP_BACK_REF = 32,
    ANCHOR = 33,
    END_OF_RE_TOKEN_T = 34
} ;
#line 166 "regex_internal.h"
typedef enum __anonenum_re_token_type_t_26 re_token_type_t;
#line 216 "regex_internal.h"
struct __anonstruct_re_charset_t_27 {
   wchar_t *mbchars ;
   wchar_t *range_starts ;
   wchar_t *range_ends ;
   wctype_t *char_classes ;
   unsigned int non_match : 1 ;
   int nmbchars ;
   int ncoll_syms ;
   int nequiv_classes ;
   int nranges ;
   int nchar_classes ;
};
#line 216 "regex_internal.h"
typedef struct __anonstruct_re_charset_t_27 re_charset_t;
#line 263 "regex_internal.h"
union __anonunion_opr_29 {
   unsigned char c ;
   re_bitset_ptr_t sbcset ;
   re_charset_t *mbcset ;
   int idx ;
   re_context_type ctx_type ;
};
#line 263 "regex_internal.h"
struct __anonstruct_re_token_t_28 {
   union __anonunion_opr_29 opr ;
   re_token_type_t type : 8 ;
   unsigned int constraint : 10 ;
   unsigned int duplicated : 1 ;
   unsigned int mb_partial : 1 ;
};
#line 263 "regex_internal.h"
typedef struct __anonstruct_re_token_t_28 re_token_t;
#line 295 "regex_internal.h"
struct re_string_t {
   unsigned char const   *raw_mbs ;
   unsigned char *mbs ;
   unsigned char *mbs_case ;
   wint_t *wcs ;
   mbstate_t cur_state ;
   int raw_mbs_idx ;
   int valid_len ;
   int bufs_len ;
   int cur_idx ;
   int len ;
   int stop ;
   unsigned int tip_context ;
   char *trans ;
   unsigned int icase : 1 ;
};
#line 338 "regex_internal.h"
typedef struct re_string_t re_string_t;
#line 395 "regex_internal.h"
struct bin_tree_t {
   struct bin_tree_t *parent ;
   struct bin_tree_t *left ;
   struct bin_tree_t *right ;
   re_token_type_t type ;
   int node_idx ;
   int first ;
   int next ;
   re_node_set eclosure ;
};
#line 410 "regex_internal.h"
typedef struct bin_tree_t bin_tree_t;
#line 441 "regex_internal.h"
struct re_dfastate_t {
   unsigned int hash ;
   re_node_set nodes ;
   re_node_set *entrance_nodes ;
   struct re_dfastate_t **trtable ;
   struct re_dfastate_t **trtable_search ;
   unsigned int context : 2 ;
   unsigned int halt : 1 ;
   unsigned int accept_mb : 1 ;
   unsigned int has_backref : 1 ;
   unsigned int has_constraint : 1 ;
};
#line 461 "regex_internal.h"
typedef struct re_dfastate_t re_dfastate_t;
#line 463 "regex_internal.h"
struct __anonstruct_re_subexp_t_30 {
   int start ;
   int end ;
};
#line 463 "regex_internal.h"
typedef struct __anonstruct_re_subexp_t_30 re_subexp_t;
#line 470 "regex_internal.h"
struct re_state_table_entry {
   int num ;
   int alloc ;
   re_dfastate_t **array ;
};
#line 479 "regex_internal.h"
struct __anonstruct_state_array_t_31 {
   int next_idx ;
   int alloc ;
   re_dfastate_t **array ;
};
#line 479 "regex_internal.h"
typedef struct __anonstruct_state_array_t_31 state_array_t;
#line 488 "regex_internal.h"
struct __anonstruct_re_sub_match_last_t_32 {
   int node ;
   int str_idx ;
   state_array_t path ;
};
#line 488 "regex_internal.h"
typedef struct __anonstruct_re_sub_match_last_t_32 re_sub_match_last_t;
#line 499 "regex_internal.h"
struct __anonstruct_re_sub_match_top_t_33 {
   int str_idx ;
   int node ;
   int next_last_offset ;
   state_array_t *path ;
   int alasts ;
   int nlasts ;
   re_sub_match_last_t **lasts ;
};
#line 499 "regex_internal.h"
typedef struct __anonstruct_re_sub_match_top_t_33 re_sub_match_top_t;
#line 510 "regex_internal.h"
struct re_backref_cache_entry {
   int node ;
   int str_idx ;
   int subexp_from ;
   int subexp_to ;
   int flag ;
};
#line 519 "regex_internal.h"
struct __anonstruct_re_match_context_t_34 {
   int eflags ;
   int match_last ;
   int last_node ;
   re_string_t *input ;
   re_dfastate_t **state_log ;
   int state_log_top ;
   int nbkref_ents ;
   int abkref_ents ;
   struct re_backref_cache_entry *bkref_ents ;
   int max_mb_elem_len ;
   int nsub_tops ;
   int asub_tops ;
   re_sub_match_top_t **sub_tops ;
};
#line 519 "regex_internal.h"
typedef struct __anonstruct_re_match_context_t_34 re_match_context_t;
#line 541 "regex_internal.h"
struct __anonstruct_re_sift_context_t_35 {
   int cur_bkref ;
   int cls_subexp_idx ;
   re_dfastate_t **sifted_states ;
   re_dfastate_t **limited_states ;
   re_node_set limits ;
   int last_node ;
   int last_str_idx ;
   int check_subexp ;
};
#line 541 "regex_internal.h"
typedef struct __anonstruct_re_sift_context_t_35 re_sift_context_t;
#line 556 "regex_internal.h"
struct re_fail_stack_ent_t {
   int idx ;
   int node ;
   regmatch_t *regs ;
   re_node_set eps_via_nodes ;
};
#line 564 "regex_internal.h"
struct re_fail_stack_t {
   int num ;
   int alloc ;
   struct re_fail_stack_ent_t *stack ;
};
#line 571 "regex_internal.h"
struct re_dfa_t {
   re_bitset_ptr_t word_char ;
   int subexps_alloc ;
   re_subexp_t *subexps ;
   re_token_t *nodes ;
   int nodes_alloc ;
   int nodes_len ;
   bin_tree_t *str_tree ;
   int *nexts ;
   int *org_indices ;
   re_node_set *edests ;
   re_node_set *eclosures ;
   re_node_set *inveclosures ;
   struct re_state_table_entry *state_table ;
   unsigned int state_hash_mask ;
   re_dfastate_t *init_state ;
   re_dfastate_t *init_state_word ;
   re_dfastate_t *init_state_nl ;
   re_dfastate_t *init_state_begbuf ;
   int states_alloc ;
   int init_node ;
   int nbackref ;
   unsigned int used_bkref_map ;
   unsigned int has_plural_match : 1 ;
   unsigned int has_mb_node : 1 ;
};
#line 608 "regex_internal.h"
typedef struct re_dfa_t re_dfa_t;
#line 644
enum __anonenum_bracket_elem_type_36 {
    SB_CHAR = 0,
    MB_CHAR = 1,
    EQUIV_CLASS = 2,
    COLL_SYM = 3,
    CHAR_CLASS = 4
} ;
#line 644 "regex_internal.h"
typedef enum __anonenum_bracket_elem_type_36 bracket_elem_type;
#line 653 "regex_internal.h"
union __anonunion_opr_38 {
   unsigned char ch ;
   unsigned char *name ;
   wchar_t wch ;
};
#line 653 "regex_internal.h"
struct __anonstruct_bracket_elem_t_37 {
   bracket_elem_type type ;
   union __anonunion_opr_38 opr ;
};
#line 653 "regex_internal.h"
typedef struct __anonstruct_bracket_elem_t_37 bracket_elem_t;
#line 173 "regex_internal.c"
union __anonunion___u_39 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 389 "regex_internal.c"
union __anonunion___u_40 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 632 "regex_internal.c"
union __anonunion___u_41 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 708 "regex_internal.c"
union __anonunion___u_42 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 280 "regcomp.c"
union __anonunion___u_43 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 367 "regcomp.c"
union __anonunion___u_44 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 375 "regcomp.c"
union __anonunion___u_45 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 769 "regcomp.c"
union __anonunion___u_46 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 936 "regcomp.c"
union __anonunion___u_47 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 937 "regcomp.c"
union __anonunion___u_48 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 938 "regcomp.c"
union __anonunion___u_49 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 1312 "regcomp.c"
union __anonunion___u_50 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 1313 "regcomp.c"
union __anonunion___u_51 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 1314 "regcomp.c"
union __anonunion___u_52 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 3507 "regcomp.c"
union __anonunion___u_53 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 601 "regexec.c"
union __anonunion___u_54 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 602 "regexec.c"
union __anonunion___u_55 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 853 "regexec.c"
union __anonunion___u_56 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 1284 "regexec.c"
union __anonunion___u_57 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 1434 "regexec.c"
union __anonunion___u_58 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 1529 "regexec.c"
union __anonunion___u_59 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 1651 "regexec.c"
union __anonunion___u_60 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 2696 "regexec.c"
union __anonunion___u_61 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 2733 "regexec.c"
union __anonunion___u_62 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 2844 "regexec.c"
union __anonunion___u_63 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 3204 "regexec.c"
union __anonunion___u_64 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 3344 "regexec.c"
union __anonunion___u_65 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 3363 "regexec.c"
union __anonunion___u_66 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 3379 "regexec.c"
union __anonunion___u_67 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 3387 "regexec.c"
union __anonunion___u_68 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 3456 "regexec.c"
union __anonunion___u_69 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 3901 "regexec.c"
union __anonunion___u_70 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 4020 "regexec.c"
union __anonunion___u_71 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 52 "fmt.c"
typedef long COST;
#line 114
struct Word;
#line 114 "fmt.c"
typedef struct Word WORD;
#line 116 "fmt.c"
struct Word {
   char const   *text ;
   short length ;
   short space ;
   flagT paren : 1 ;
   flagT period : 1 ;
   flagT punct : 1 ;
   flagT final : 1 ;
   short line_length ;
   COST best_cost ;
   WORD *next_break ;
};
#line 136 "/usr/include/bits/types.h"
typedef unsigned long long __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long long __ino64_t;
#line 141 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 151 "/usr/include/bits/types.h"
typedef long __time_t;
#line 166 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long long __blkcnt64_t;
#line 118 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
#line 93 "/usr/include/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   unsigned int __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned int __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
#line 38 "../basicdefs.h"
typedef unsigned long countT;
#line 26 "sed.h"
struct sed_cmd;
#line 26 "sed.h"
struct vector {
   struct sed_cmd *v ;
   size_t v_allocated ;
   size_t v_length ;
};
#line 33 "sed.h"
struct text_buf {
   char *text ;
   size_t text_length ;
};
#line 38
enum replacement_types {
    repl_asis = 0,
    repl_uppercase = 1,
    repl_lowercase = 2,
    repl_uppercase_first = 4,
    repl_lowercase_first = 8,
    repl_modifiers = 12,
    repl_uppercase_uppercase = 5,
    repl_uppercase_lowercase = 6,
    repl_lowercase_uppercase = 9,
    repl_lowercase_lowercase = 10
} ;
#line 53
enum addr_types {
    addr_is_null = 0,
    addr_is_regex = 1,
    addr_is_num = 2,
    addr_is_num_mod = 3,
    addr_is_num2 = 4,
    addr_is_step = 5,
    addr_is_step_mod = 6,
    addr_is_last = 7
} ;
#line 64 "sed.h"
struct addr {
   enum addr_types addr_type ;
   countT addr_number ;
   countT addr_step ;
   regex_t *addr_regex ;
};
#line 72 "sed.h"
struct replacement {
   char *prefix ;
   size_t prefix_length ;
   int subst_id ;
   enum replacement_types repl_type ;
   struct replacement *next ;
};
#line 80 "sed.h"
struct subst {
   regex_t *regx ;
   struct replacement *replacement ;
   countT numb ;
   FILE *fp ;
   unsigned int global : 1 ;
   unsigned int print : 2 ;
   unsigned int eval : 1 ;
   unsigned int max_id : 4 ;
};
#line 104 "sed.h"
union __anonunion_x_35 {
   struct text_buf cmd_txt ;
   int int_arg ;
   countT jump_index ;
   char *fname ;
   struct subst *cmd_subst ;
   FILE *fp ;
   unsigned char *translate ;
   char **translatemb ;
};
#line 104 "sed.h"
struct sed_cmd {
   struct addr *a1 ;
   struct addr *a2 ;
   char a1_matched ;
   char addr_bang ;
   char cmd ;
   union __anonunion_x_35 x ;
};
#line 88 "execute.c"
struct line {
   char *text ;
   char *active ;
   size_t length ;
   size_t alloc ;
   flagT chomped ;
};
#line 98 "execute.c"
struct append_queue {
   char const   *fname ;
   char *text ;
   size_t textlen ;
   struct append_queue *next ;
   flagT free ;
};
#line 107 "execute.c"
struct input {
   char **file_list ;
   countT bad_count ;
   countT line_number ;
   flagT (*read_fn)(struct input * ) ;
   char *out_file_name ;
   char const   *in_file_name ;
   FILE *fp ;
   flagT no_buffering ;
};
#line 1356 "execute.c"
union __anonunion___u_36 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 790 "/usr/include/stdio.h"
struct obstack;
#line 162 "../lib/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 169 "../lib/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   int temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 71 "compile.c"
struct prog_info {
   unsigned char const   *base ;
   unsigned char const   *cur ;
   unsigned char const   *end ;
   FILE *file ;
};
#line 88 "compile.c"
struct error_info {
   char const   *name ;
   countT line ;
   countT string_expr_count ;
};
#line 101 "compile.c"
struct sed_label {
   countT v_index ;
   char *name ;
   struct error_info err_info ;
   struct sed_label *next ;
};
#line 108 "compile.c"
struct special_files {
   char *name ;
   FILE **pfp ;
};
#line 124 "compile.c"
struct fp_list {
   char *name ;
   int special ;
   FILE *fp ;
   struct fp_list *link ;
};
#line 1250 "compile.c"
union __anonunion___u_33 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 1265 "compile.c"
union __anonunion___u_34 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 81 "../lib/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 404 "/usr/include/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 405
extern int __overflow(_IO_FILE * , int  ) ;
#line 433
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 434
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 143
extern struct _IO_FILE *stdout ;
#line 144
extern struct _IO_FILE *stderr ;
#line 206
extern int fclose(FILE *__stream ) ;
#line 211
extern int fflush(FILE *__stream ) ;
#line 252
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 329
extern int sprintf(char * __restrict  __s , char const   * __restrict  __format  , ...) ;
#line 336
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 342
__inline extern int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) ;
#line 442
__inline extern int getchar(void) ;
#line 454
__inline extern int getc_unlocked(FILE *__fp ) ;
#line 455
__inline extern int getchar_unlocked(void) ;
#line 484
__inline extern int putchar(int __c ) ;
#line 498
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 506
__inline extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 507
__inline extern int putchar_unlocked(int __c ) ;
#line 559
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
#line 572
__inline extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                                  FILE * __restrict  __stream ) ;
#line 603
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 609
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 720
extern void clearerr(FILE *__stream ) ;
#line 724
extern int ferror(FILE *__stream ) ;
#line 730
__inline extern int feof_unlocked(FILE *__stream ) ;
#line 731
__inline extern int ferror_unlocked(FILE *__stream ) ;
#line 33 "/usr/include/bits/stdio.h"
__inline extern int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  {
  {
#line 36
  tmp = vfprintf((FILE */* __restrict  */)stdout, __fmt, __arg);
  }
  }
#line 36
  return (tmp);
}
}
#line 40 "/usr/include/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int tmp ;

  {
  {
  {
#line 43
  tmp = _IO_getc(stdin);
  }
  }
#line 43
  return (tmp);
}
}
#line 49 "/usr/include/bits/stdio.h"
__inline extern int getc_unlocked(FILE *__fp ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 52
  if ((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end) {
    {
    {
#line 52
    tmp = __uflow(__fp);
    }
#line 52
    tmp___1 = tmp;
    }
  } else {
#line 52
    tmp___0 = __fp->_IO_read_ptr;
#line 52
    (__fp->_IO_read_ptr) ++;
#line 52
    tmp___1 = (int )*((unsigned char *)tmp___0);
  }
#line 52
  return (tmp___1);
}
}
#line 56 "/usr/include/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 59
  if ((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end) {
    {
    {
#line 59
    tmp = __uflow(stdin);
    }
#line 59
    tmp___1 = tmp;
    }
  } else {
#line 59
    tmp___0 = stdin->_IO_read_ptr;
#line 59
    (stdin->_IO_read_ptr) ++;
#line 59
    tmp___1 = (int )*((unsigned char *)tmp___0);
  }
#line 59
  return (tmp___1);
}
}
#line 65 "/usr/include/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int tmp ;

  {
  {
  {
#line 68
  tmp = _IO_putc(__c, stdout);
  }
  }
#line 68
  return (tmp);
}
}
#line 74 "/usr/include/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;

  {
#line 77
  if ((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end) {
    {
    {
#line 77
    tmp = __overflow(__stream, (int )((unsigned char )__c));
    }
#line 77
    tmp___2 = tmp;
    }
  } else {
#line 77
    tmp___0 = __stream->_IO_write_ptr;
#line 77
    (__stream->_IO_write_ptr) ++;
#line 77
    tmp___1 = (char )__c;
#line 77
    *tmp___0 = tmp___1;
#line 77
    tmp___2 = (int )((unsigned char )tmp___1);
  }
#line 77
  return (tmp___2);
}
}
#line 91 "/usr/include/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;

  {
#line 94
  if ((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end) {
    {
    {
#line 94
    tmp = __overflow(stdout, (int )((unsigned char )__c));
    }
#line 94
    tmp___2 = tmp;
    }
  } else {
#line 94
    tmp___0 = stdout->_IO_write_ptr;
#line 94
    (stdout->_IO_write_ptr) ++;
#line 94
    tmp___1 = (char )__c;
#line 94
    *tmp___0 = tmp___1;
#line 94
    tmp___2 = (int )((unsigned char )tmp___1);
  }
#line 94
  return (tmp___2);
}
}
#line 101 "/usr/include/bits/stdio.h"
__inline extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                                  FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  {
  {
#line 104
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  }
  }
#line 104
  return (tmp);
}
}
#line 111 "/usr/include/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 114
  return ((__stream->_flags & 16) != 0);
}
}
#line 118 "/usr/include/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 121
  return ((__stream->_flags & 32) != 0);
}
}
#line 38 "/usr/include/bits/errno.h"
extern int *__errno_location(void)  __attribute__((__const__)) ;
#line 142 "/usr/include/stdlib.h"
__inline extern double atof(char const   *__nptr )  __attribute__((__pure__)) ;
#line 144
__inline extern int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
#line 146
__inline extern long atol(char const   *__nptr )  __attribute__((__pure__)) ;
#line 152
__inline extern long long atoll(char const   *__nptr )  __attribute__((__pure__)) ;
#line 159
__inline extern double strtod(char const   * __restrict  __nptr , char ** __restrict  __endptr ) ;
#line 166
__inline extern float strtof(char const   * __restrict  __nptr , char ** __restrict  __endptr ) ;
#line 169
__inline extern long double strtold(char const   * __restrict  __nptr , char ** __restrict  __endptr ) ;
#line 176
__inline extern long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) ;
#line 179
__inline extern unsigned long strtoul(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                      int __base ) ;
#line 187
__inline extern long long strtoq(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                 int __base ) ;
#line 191
__inline extern unsigned long long strtouq(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                           int __base ) ;
#line 200
__inline extern long long strtoll(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                  int __base ) ;
#line 204
__inline extern unsigned long long strtoull(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                            int __base ) ;
#line 264
extern double __strtod_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                int __group ) ;
#line 267
extern float __strtof_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                               int __group ) ;
#line 270
extern long double __strtold_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                      int __group ) ;
#line 274
extern long __strtol_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                              int __base , int __group ) ;
#line 280
extern unsigned long __strtoul_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                        int __base , int __group ) ;
#line 288
extern long long __strtoll_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                    int __base , int __group ) ;
#line 295
extern unsigned long long __strtoull_internal(char const   * __restrict  __nptr ,
                                              char ** __restrict  __endptr , int __base ,
                                              int __group ) ;
#line 308 "/usr/include/stdlib.h"
__inline extern double strtod(char const   * __restrict  __nptr , char ** __restrict  __endptr ) 
{ 
  double tmp ;

  {
  {
  {
#line 311
  tmp = __strtod_internal(__nptr, __endptr, 0);
  }
  }
#line 311
  return (tmp);
}
}
#line 313 "/usr/include/stdlib.h"
__inline extern long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ 
  long tmp ;

  {
  {
  {
#line 317
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 317
  return (tmp);
}
}
#line 319 "/usr/include/stdlib.h"
__inline extern unsigned long strtoul(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                      int __base ) 
{ 
  unsigned long tmp ;

  {
  {
  {
#line 323
  tmp = __strtoul_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 323
  return (tmp);
}
}
#line 329 "/usr/include/stdlib.h"
__inline extern float strtof(char const   * __restrict  __nptr , char ** __restrict  __endptr ) 
{ 
  float tmp ;

  {
  {
  {
#line 332
  tmp = __strtof_internal(__nptr, __endptr, 0);
  }
  }
#line 332
  return (tmp);
}
}
#line 334 "/usr/include/stdlib.h"
__inline extern long double strtold(char const   * __restrict  __nptr , char ** __restrict  __endptr ) 
{ 
  long double tmp ;

  {
  {
  {
#line 337
  tmp = __strtold_internal(__nptr, __endptr, 0);
  }
  }
#line 337
  return (tmp);
}
}
#line 343 "/usr/include/stdlib.h"
__inline extern long long strtoq(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                 int __base ) 
{ 
  long long tmp ;

  {
  {
  {
#line 347
  tmp = __strtoll_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 347
  return (tmp);
}
}
#line 349 "/usr/include/stdlib.h"
__inline extern unsigned long long strtouq(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                           int __base ) 
{ 
  unsigned long long tmp ;

  {
  {
  {
#line 353
  tmp = __strtoull_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 353
  return (tmp);
}
}
#line 375
__inline extern double atof(char const   *__nptr )  __attribute__((__pure__)) ;
#line 375 "/usr/include/stdlib.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double tmp ;

  {
  {
  {
#line 378
  tmp = strtod((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)));
  }
  }
#line 378
  return (tmp);
}
}
#line 380
__inline extern int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
#line 380 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long tmp ;

  {
  {
  {
#line 383
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
  }
#line 383
  return ((int )tmp);
}
}
#line 385
__inline extern long atol(char const   *__nptr )  __attribute__((__pure__)) ;
#line 385 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long tmp ;

  {
  {
  {
#line 388
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
  }
#line 388
  return (tmp);
}
}
#line 394
__inline extern long long atoll(char const   *__nptr )  __attribute__((__pure__)) ;
#line 394 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  {
  {
#line 397
  tmp = strtoq((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
  }
#line 397
  return (tmp);
}
}
#line 558
extern void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 567
extern void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
#line 569
extern void free(void *__ptr ) ;
#line 612
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
#line 626
extern char *getenv(char const   *__name ) ;
#line 51 "/usr/include/libintl.h"
extern char *dcgettext(char const   *__domainname , char const   *__msgid , int __category ) ;
#line 72
extern char *dcngettext(char const   *__domainname , char const   *__msgid1 , char const   *__msgid2 ,
                        unsigned long __n , int __category )  __attribute__((__format_arg__(3),
__format_arg__(2))) ;
#line 38 "/usr/include/string.h"
extern void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                    size_t __n ) ;
#line 82
extern char *strcpy(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 162
extern char *strchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
#line 230
extern size_t strlen(char const   *__s )  __attribute__((__pure__)) ;
#line 243
extern char *strerror(int __errnum ) ;
#line 919 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) ;
#line 920 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) 
{ 
  register size_t __result ;

  {
#line 923
  __result = (size_t )0;
  {
  {
#line 924
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 924
    if ((int const   )*(__s + __result) != 0) {
#line 924
      if (! ((int const   )*(__s + __result) != (int const   )__reject)) {
#line 924
        goto while_break;
      }
    } else {
#line 924
      goto while_break;
    }
#line 925
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 926
  return (__result);
}
}
#line 929
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) ;
#line 931 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) 
{ 
  register size_t __result ;

  {
#line 934
  __result = (size_t )0;
  {
  {
#line 935
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 935
    if ((int const   )*(__s + __result) != 0) {
#line 935
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 935
        if (! ((int const   )*(__s + __result) != (int const   )__reject2)) {
#line 935
          goto while_break;
        }
      } else {
#line 935
        goto while_break;
      }
    } else {
#line 935
      goto while_break;
    }
#line 937
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 938
  return (__result);
}
}
#line 941
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) ;
#line 943 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) 
{ 
  register size_t __result ;

  {
#line 947
  __result = (size_t )0;
  {
  {
#line 948
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 948
    if ((int const   )*(__s + __result) != 0) {
#line 948
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 948
        if ((int const   )*(__s + __result) != (int const   )__reject2) {
#line 948
          if (! ((int const   )*(__s + __result) != (int const   )__reject3)) {
#line 948
            goto while_break;
          }
        } else {
#line 948
          goto while_break;
        }
      } else {
#line 948
        goto while_break;
      }
    } else {
#line 948
      goto while_break;
    }
#line 950
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 951
  return (__result);
}
}
#line 976
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) ;
#line 977 "/usr/include/bits/string2.h"
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) 
{ 
  register size_t __result ;

  {
#line 980
  __result = (size_t )0;
  {
  {
#line 982
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 982
    if (! ((int const   )*(__s + __result) == (int const   )__accept)) {
#line 982
      goto while_break;
    }
#line 983
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 984
  return (__result);
}
}
#line 987
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 989 "/usr/include/bits/string2.h"
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  register size_t __result ;

  {
#line 992
  __result = (size_t )0;
  {
  {
#line 994
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 994
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 994
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 994
        goto while_break;
      }
    }
#line 995
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 996
  return (__result);
}
}
#line 999
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1001 "/usr/include/bits/string2.h"
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  register size_t __result ;

  {
#line 1004
  __result = (size_t )0;
  {
  {
#line 1006
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1006
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1006
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1006
        if (! ((int const   )*(__s + __result) == (int const   )__accept3)) {
#line 1006
          goto while_break;
        }
      }
    }
#line 1008
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1009
  return (__result);
}
}
#line 1033
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1035 "/usr/include/bits/string2.h"
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  char *tmp ;

  {
  {
  {
#line 1039
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1039
    if ((int const   )*__s != 0) {
#line 1039
      if ((int const   )*__s != (int const   )__accept1) {
#line 1039
        if (! ((int const   )*__s != (int const   )__accept2)) {
#line 1039
          goto while_break;
        }
      } else {
#line 1039
        goto while_break;
      }
    } else {
#line 1039
      goto while_break;
    }
#line 1040
    __s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1041
  if ((int const   )*__s == 0) {
#line 1041
    tmp = (char *)((void *)0);
  } else {
#line 1041
    tmp = (char *)((size_t )__s);
  }
#line 1041
  return (tmp);
}
}
#line 1044
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1046 "/usr/include/bits/string2.h"
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  char *tmp ;

  {
  {
  {
#line 1051
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1051
    if ((int const   )*__s != 0) {
#line 1051
      if ((int const   )*__s != (int const   )__accept1) {
#line 1051
        if ((int const   )*__s != (int const   )__accept2) {
#line 1051
          if (! ((int const   )*__s != (int const   )__accept3)) {
#line 1051
            goto while_break;
          }
        } else {
#line 1051
          goto while_break;
        }
      } else {
#line 1051
        goto while_break;
      }
    } else {
#line 1051
      goto while_break;
    }
#line 1053
    __s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1054
  if ((int const   )*__s == 0) {
#line 1054
    tmp = (char *)((void *)0);
  } else {
#line 1054
    tmp = (char *)((size_t )__s);
  }
#line 1054
  return (tmp);
}
}
#line 1085
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) ;
#line 1086 "/usr/include/bits/string2.h"
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) 
{ 
  char *__result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1090
  if ((unsigned long )__s == (unsigned long )((void *)0)) {
#line 1091
    __s = *__nextp;
  }
  {
  {
#line 1092
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1092
    if (! ((int )*__s == (int )__sep)) {
#line 1092
      goto while_break;
    }
#line 1093
    __s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1094
  __result = (char *)((void *)0);
#line 1095
  if ((int )*__s != 0) {
#line 1097
    tmp = __s;
#line 1097
    __s ++;
#line 1097
    __result = tmp;
    {
    {
#line 1098
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1098
      if (! ((int )*__s != 0)) {
#line 1098
        goto while_break___0;
      }
#line 1099
      tmp___0 = __s;
#line 1099
      __s ++;
#line 1099
      if ((int )*tmp___0 == (int )__sep) {
#line 1101
        *(__s + -1) = (char )'\000';
#line 1102
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1104
    *__nextp = __s;
  }
#line 1106
  return (__result);
}
}
#line 1135
__inline extern char *__strsep_1c(char **__s , char __reject ) ;
#line 1136 "/usr/include/bits/string2.h"
__inline extern char *__strsep_1c(char **__s , char __reject ) 
{ 
  register char *__retval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___2 ;

  {
#line 1139
  __retval = *__s;
#line 1140
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
    {
    {
#line 1140
    tmp___2 = strchr((char const   *)__retval, (int )__reject);
    }
#line 1140
    tmp___0 = tmp___2;
#line 1140
    *__s = tmp___0;
    }
#line 1140
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1141
      tmp = *__s;
#line 1141
      (*__s) ++;
#line 1141
      *tmp = (char )'\000';
    }
  }
#line 1142
  return (__retval);
}
}
#line 1145
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) ;
#line 1146 "/usr/include/bits/string2.h"
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1149
  __retval = *__s;
#line 1150
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1152
    __cp = __retval;
    {
    {
#line 1153
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1155
      if ((int )*__cp == 0) {
#line 1157
        __cp = (char *)((void *)0);
#line 1158
        goto while_break;
      }
#line 1160
      if ((int )*__cp == (int )__reject1) {
#line 1162
        tmp = __cp;
#line 1162
        __cp ++;
#line 1162
        *tmp = (char )'\000';
#line 1163
        goto while_break;
      } else
#line 1160
      if ((int )*__cp == (int )__reject2) {
#line 1162
        tmp = __cp;
#line 1162
        __cp ++;
#line 1162
        *tmp = (char )'\000';
#line 1163
        goto while_break;
      }
#line 1165
      __cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1167
    *__s = __cp;
  }
#line 1169
  return (__retval);
}
}
#line 1172
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) ;
#line 1174 "/usr/include/bits/string2.h"
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1177
  __retval = *__s;
#line 1178
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1180
    __cp = __retval;
    {
    {
#line 1181
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1183
      if ((int )*__cp == 0) {
#line 1185
        __cp = (char *)((void *)0);
#line 1186
        goto while_break;
      }
#line 1188
      if ((int )*__cp == (int )__reject1) {
#line 1190
        tmp = __cp;
#line 1190
        __cp ++;
#line 1190
        *tmp = (char )'\000';
#line 1191
        goto while_break;
      } else
#line 1188
      if ((int )*__cp == (int )__reject2) {
#line 1190
        tmp = __cp;
#line 1190
        __cp ++;
#line 1190
        *tmp = (char )'\000';
#line 1191
        goto while_break;
      } else
#line 1188
      if ((int )*__cp == (int )__reject3) {
#line 1190
        tmp = __cp;
#line 1190
        __cp ++;
#line 1190
        *tmp = (char )'\000';
#line 1191
        goto while_break;
      }
#line 1193
      __cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1195
    *__s = __cp;
  }
#line 1197
  return (__retval);
}
}
#line 23 "utils.h"
void panic(char const   *str  , ...) ;
#line 25
FILE *ck_fopen(char const   *name , char const   *mode , flagT fail ) ;
#line 26
void ck_fwrite(void const   *ptr , size_t size , size_t nmemb , FILE *stream ) ;
#line 27
size_t ck_fread(void *ptr , size_t size , size_t nmemb , FILE *stream ) ;
#line 28
void ck_fflush(FILE *stream ) ;
#line 29
void ck_fclose(FILE *stream ) ;
#line 31
char *temp_file_template(char const   *tmpdir , char *program ) ;
#line 33
void *ck_malloc(size_t size ) ;
#line 34
void *xmalloc(size_t size ) ;
#line 35
void *ck_realloc(void *ptr , size_t size ) ;
#line 36
char *ck_strdup(char const   *str ) ;
#line 37
void *ck_memdup(void const   *buf , size_t len ) ;
#line 38
void ck_free(void *ptr ) ;
#line 40
struct buffer *init_buffer(void) ;
#line 41
char *get_buffer(struct buffer *b___0 ) ;
#line 42
size_t size_buffer(struct buffer *b___0 ) ;
#line 43
void add_buffer(struct buffer *b___0 , char const   *p , size_t n ) ;
#line 44
void add1_buffer(struct buffer *b___0 , int c ) ;
#line 45
void free_buffer(struct buffer *b___0 ) ;
#line 47 "utils.h"
char const   *myname  ;
#line 42 "utils.c"
void do_ck_fclose(FILE *stream ) ;
#line 55 "utils.c"
void panic(char const   *str  , ...) 
{ 
  va_list iggy ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 61
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          myname);
  }
  {
#line 62
  __builtin_va_start(iggy, str);
  }
  {
#line 70
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)str,
           iggy);
  }
  {
#line 72
  __builtin_va_end(iggy);
  }
  {
#line 73
  _IO_putc('\n', stderr);
  }
  {
#line 74
  exit(4);
  }
  }
}
}
#line 89 "utils.c"
static struct id *utils_id_s  =    (struct id *)((void *)0);
#line 92
static char const   *utils_fp_name(FILE *fp ) ;
#line 93 "utils.c"
static char const   *utils_fp_name(FILE *fp ) 
{ 
  struct id *p ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 99
  p = utils_id_s;
  {
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
#line 100
    if ((unsigned long )p->fp == (unsigned long )fp) {
#line 101
      return ((char const   *)p->name);
    }
#line 99
    p = p->link;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  if ((unsigned long )fp == (unsigned long )stdin) {
#line 103
    return ("stdin");
  } else
#line 104
  if ((unsigned long )fp == (unsigned long )stdout) {
#line 105
    return ("stdout");
  } else
#line 106
  if ((unsigned long )fp == (unsigned long )stderr) {
#line 107
    return ("stderr");
  }
#line 109
  return ("<unknown>");
}
}
#line 113 "utils.c"
FILE *ck_fopen(char const   *name , char const   *mode , flagT fail ) 
{ 
  FILE *fp ;
  struct id *p ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 122
  fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)mode);
  }
  }
#line 123
  if (! fp) {
#line 125
    if (fail) {
      {
      {
#line 126
      tmp = __errno_location();
      }
      {
#line 126
      tmp___0 = strerror(*tmp);
      }
      {
#line 126
      tmp___1 = dcgettext((char const   *)((void *)0), "Couldn\'t open file %s: %s",
                          5);
      }
      {
#line 126
      panic((char const   *)tmp___1, name, tmp___0);
      }
      }
    }
#line 128
    return ((FILE *)((void *)0));
  }
#line 131
  p = utils_id_s;
  {
  {
#line 131
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 131
    if (! p) {
#line 131
      goto while_break;
    }
#line 133
    if ((unsigned long )fp == (unsigned long )p->fp) {
      {
      {
#line 135
      ck_free((void *)p->name);
      }
      }
#line 136
      goto while_break;
    }
#line 131
    p = p->link;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (! p) {
    {
    {
#line 141
    tmp___2 = ck_malloc((size_t )sizeof(struct id ));
    }
#line 141
    p = (struct id *)tmp___2;
#line 142
    p->link = utils_id_s;
#line 143
    utils_id_s = p;
    }
  }
  {
  {
#line 145
  p->name = ck_strdup(name);
  }
#line 146
  p->fp = fp;
  }
#line 147
  return (fp);
}
}
#line 151 "utils.c"
void ck_fwrite(void const   *ptr , size_t size , size_t nmemb , FILE *stream ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 158
  clearerr(stream);
  }
  }
#line 159
  if (size) {
    {
    {
#line 159
    tmp___3 = fwrite((void const   */* __restrict  */)ptr, size, nmemb, (FILE */* __restrict  */)stream);
    }
    }
#line 159
    if (tmp___3 != nmemb) {
      {
      {
#line 160
      tmp = __errno_location();
      }
      {
#line 160
      tmp___0 = strerror(*tmp);
      }
      {
#line 160
      tmp___1 = utils_fp_name(stream);
      }
      {
#line 160
      tmp___2 = dcngettext((char const   *)((void *)0), "couldn\'t write %d item to %s: %s",
                           "couldn\'t write %d items to %s: %s", (unsigned long )nmemb,
                           5);
      }
      {
#line 160
      panic((char const   *)tmp___2, nmemb, tmp___1, tmp___0);
      }
      }
    }
  }
#line 163
  return;
}
}
#line 166 "utils.c"
size_t ck_fread(void *ptr , size_t size , size_t nmemb , FILE *stream ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 173
  clearerr(stream);
  }
  }
#line 174
  if (size) {
    {
    {
#line 174
    nmemb = fread((void */* __restrict  */)ptr, size, nmemb, (FILE */* __restrict  */)stream);
    }
    }
#line 174
    if (nmemb <= 0U) {
      {
      {
#line 174
      tmp___3 = ferror(stream);
      }
      }
#line 174
      if (tmp___3) {
        {
        {
#line 175
        tmp = __errno_location();
        }
        {
#line 175
        tmp___0 = strerror(*tmp);
        }
        {
#line 175
        tmp___1 = utils_fp_name(stream);
        }
        {
#line 175
        tmp___2 = dcgettext((char const   *)((void *)0), "read error on %s: %s", 5);
        }
        {
#line 175
        panic((char const   *)tmp___2, tmp___1, tmp___0);
        }
        }
      }
    }
  }
#line 177
  return (nmemb);
}
}
#line 181 "utils.c"
void ck_fflush(FILE *stream ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 185
  clearerr(stream);
  }
  {
#line 186
  tmp___2 = fflush(stream);
  }
  }
#line 186
  if (tmp___2 == -1) {
    {
    {
#line 186
    tmp___3 = __errno_location();
    }
    }
#line 186
    if (*tmp___3 != 9) {
      {
      {
#line 187
      tmp = __errno_location();
      }
      {
#line 187
      tmp___0 = strerror(*tmp);
      }
      {
#line 187
      tmp___1 = utils_fp_name(stream);
      }
      {
#line 187
      panic("Couldn\'t flush %s: %s", tmp___1, tmp___0);
      }
      }
    }
  }
#line 188
  return;
}
}
#line 191 "utils.c"
void ck_fclose(FILE *stream ) 
{ 
  struct id r ;
  struct id *prev ;
  struct id *cur ;

  {
#line 200
  r.link = utils_id_s;
#line 201
  prev = & r;
  {
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 202
    cur = prev->link;
#line 202
    if (! cur) {
#line 202
      goto while_break;
    }
#line 204
    if (! stream) {
      {
      {
#line 206
      do_ck_fclose(cur->fp);
      }
#line 207
      prev->link = cur->link;
      {
#line 208
      ck_free((void *)cur->name);
      }
      {
#line 209
      ck_free((void *)cur);
      }
      }
    } else
#line 204
    if ((unsigned long )stream == (unsigned long )cur->fp) {
      {
      {
#line 206
      do_ck_fclose(cur->fp);
      }
#line 207
      prev->link = cur->link;
      {
#line 208
      ck_free((void *)cur->name);
      }
      {
#line 209
      ck_free((void *)cur);
      }
      }
    } else {
#line 212
      prev = cur;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  utils_id_s = r.link;
#line 220
  if (! stream) {
    {
    {
#line 222
    do_ck_fclose(stdout);
    }
    {
#line 223
    do_ck_fclose(stderr);
    }
    }
  }
#line 225
  return;
}
}
#line 228 "utils.c"
void do_ck_fclose(FILE *stream ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 232
  ck_fflush(stream);
  }
  {
#line 233
  clearerr(stream);
  }
  {
#line 234
  tmp___2 = fclose(stream);
  }
  }
#line 234
  if (tmp___2 == -1) {
    {
    {
#line 235
    tmp = __errno_location();
    }
    {
#line 235
    tmp___0 = strerror(*tmp);
    }
    {
#line 235
    tmp___1 = utils_fp_name(stream);
    }
    {
#line 235
    panic("Couldn\'t close %s: %s", tmp___1, tmp___0);
    }
    }
  }
#line 236
  return;
}
}
#line 240 "utils.c"
char *temp_file_template(char const   *tmpdir , char *program ) 
{ 
  char *template ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 246
  if ((unsigned long )tmpdir == (unsigned long )((void *)0)) {
    {
    {
#line 247
    tmp = getenv("TMPDIR");
    }
#line 247
    tmpdir = (char const   *)tmp;
    }
  }
#line 248
  if ((unsigned long )tmpdir == (unsigned long )((void *)0)) {
    {
    {
#line 250
    tmp___0 = getenv("TMP");
    }
#line 250
    tmpdir = (char const   *)tmp___0;
    }
#line 251
    if ((unsigned long )tmpdir == (unsigned long )((void *)0)) {
#line 253
      tmpdir = "/tmp";
    }
  }
  {
  {
#line 259
  tmp___1 = strlen(tmpdir);
  }
  {
#line 259
  tmp___2 = strlen((char const   *)program);
  }
  {
#line 259
  tmp___3 = xmalloc((tmp___1 + tmp___2) + 8U);
  }
#line 259
  template = (char *)tmp___3;
  {
#line 260
  sprintf((char */* __restrict  */)template, (char const   */* __restrict  */)"%s/%sXXXXXX",
          tmpdir, program);
  }
  }
#line 261
  return (template);
}
}
#line 266 "utils.c"
void *ck_malloc(size_t size ) 
{ 
  void *ret ;
  size_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp5 ;

  {
#line 270
  if (size) {
#line 270
    tmp = size;
  } else {
#line 270
    tmp = (size_t )1;
  }
  {
  {
#line 270
  tmp___0 = calloc((size_t )1, tmp);
  }
#line 270
  ret = tmp___0;
  }
#line 271
  if (! ret) {
    {
    {
#line 272
    panic("Couldn\'t allocate memory");
    }
    }
  }
#line 273
  return (ret);
}
}
#line 277 "utils.c"
void *xmalloc(size_t size ) 
{ 
  void *tmp ;

  {
  {
  {
#line 281
  tmp = ck_malloc(size);
  }
  }
#line 281
  return (tmp);
}
}
#line 285 "utils.c"
void *ck_realloc(void *ptr , size_t size ) 
{ 
  void *ret ;
  void *tmp ;
  char *__cil_tmp5 ;

  {
#line 292
  if (size == 0U) {
    {
    {
#line 294
    ck_free(ptr);
    }
    }
#line 295
    return ((void *)0);
  }
#line 297
  if (! ptr) {
    {
    {
#line 298
    tmp = ck_malloc(size);
    }
    }
#line 298
    return (tmp);
  }
  {
  {
#line 299
  ret = realloc(ptr, size);
  }
  }
#line 300
  if (! ret) {
    {
    {
#line 301
    panic("Couldn\'t re-allocate memory");
    }
    }
  }
#line 302
  return (ret);
}
}
#line 306 "utils.c"
char *ck_strdup(char const   *str ) 
{ 
  char *ret ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
  {
#line 310
  tmp = strlen(str);
  }
  {
#line 310
  tmp___0 = ck_malloc((size_t )((unsigned long )(tmp + 1U) * sizeof(char )));
  }
#line 310
  ret = (char *)tmp___0;
  {
#line 311
  tmp___1 = strcpy((char */* __restrict  */)ret, (char const   */* __restrict  */)str);
  }
  }
#line 311
  return (tmp___1);
}
}
#line 315 "utils.c"
void *ck_memdup(void const   *buf , size_t len ) 
{ 
  void *ret ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 320
  tmp = ck_malloc(len);
  }
#line 320
  ret = tmp;
  {
#line 321
  tmp___0 = memcpy((void */* __restrict  */)ret, (void const   */* __restrict  */)buf,
                   len);
  }
  }
#line 321
  return (tmp___0);
}
}
#line 325 "utils.c"
void ck_free(void *ptr ) 
{ 


  {
#line 329
  if (ptr) {
    {
    {
#line 330
    free(ptr);
    }
    }
  }
#line 331
  return;
}
}
#line 346 "utils.c"
struct buffer *init_buffer(void) 
{ 
  struct buffer *b___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 349
  tmp = ck_malloc((size_t )sizeof(struct buffer ));
  }
#line 349
  b___0 = (struct buffer *)tmp;
  {
#line 350
  tmp___0 = ck_malloc((size_t )(50UL * sizeof(char )));
  }
#line 350
  b___0->b = (char *)tmp___0;
#line 351
  b___0->allocated = (size_t )50;
#line 352
  b___0->length = (size_t )0;
  }
#line 353
  return (b___0);
}
}
#line 356 "utils.c"
char *get_buffer(struct buffer *b___0 ) 
{ 


  {
#line 360
  return (b___0->b);
}
}
#line 363 "utils.c"
size_t size_buffer(struct buffer *b___0 ) 
{ 


  {
#line 367
  return (b___0->length);
}
}
#line 370
static void resize_buffer(struct buffer *b___0 , size_t newlen ) ;
#line 371 "utils.c"
static void resize_buffer(struct buffer *b___0 , size_t newlen ) 
{ 
  char *try ;
  size_t alen ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 376
  try = (char *)((void *)0);
#line 377
  alen = b___0->allocated;
#line 379
  if (newlen <= alen) {
#line 380
    return;
  }
#line 381
  alen *= 2U;
#line 382
  if (newlen < alen) {
    {
    {
#line 383
    tmp = realloc((void *)b___0->b, alen);
    }
#line 383
    try = (char *)tmp;
    }
  }
#line 384
  if (! try) {
    {
#line 386
    alen = newlen;
    {
#line 387
    tmp___0 = ck_realloc((void *)b___0->b, (size_t )((unsigned long )alen * sizeof(char )));
    }
#line 387
    try = (char *)tmp___0;
    }
  }
#line 389
  b___0->allocated = alen;
#line 390
  b___0->b = try;
#line 391
  return;
}
}
#line 393 "utils.c"
void add_buffer(struct buffer *b___0 , char const   *p , size_t n ) 
{ 


  {
#line 399
  if (b___0->allocated - b___0->length < n) {
    {
    {
#line 400
    resize_buffer(b___0, b___0->length + n);
    }
    }
  }
  {
  {
#line 401
  memcpy((void */* __restrict  */)(b___0->b + b___0->length), (void const   */* __restrict  */)p,
         n);
  }
#line 402
  b___0->length += n;
  }
#line 403
  return;
}
}
#line 405 "utils.c"
void add1_buffer(struct buffer *b___0 , int c ) 
{ 
  size_t tmp ;

  {
#line 416
  if (c != -1) {
#line 418
    if (b___0->allocated - b___0->length < 1U) {
      {
      {
#line 419
      resize_buffer(b___0, b___0->length + 1U);
      }
      }
    }
#line 420
    tmp = b___0->length;
#line 420
    (b___0->length) ++;
#line 420
    *(b___0->b + tmp) = (char )c;
  }
#line 422
  return;
}
}
#line 424 "utils.c"
void free_buffer(struct buffer *b___0 ) 
{ 


  {
#line 428
  if (b___0) {
    {
    {
#line 429
    ck_free((void *)b___0->b);
    }
    }
  }
  {
  {
#line 430
  ck_free((void *)b___0);
  }
  }
#line 431
  return;
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
#line 182 "regex.h"
reg_syntax_t re_syntax_options  ;
#line 461
reg_syntax_t re_set_syntax(reg_syntax_t syntax ) ;
#line 466
char const   *re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) ;
#line 474
int re_compile_fastmap(struct re_pattern_buffer *bufp ) ;
#line 482
int re_search(struct re_pattern_buffer *bufp , char const   *string , int length ,
              int start , int range , struct re_registers *regs___0 ) ;
#line 489
int re_search_2(struct re_pattern_buffer *bufp , char const   *string1 , int length1 ,
                char const   *string2 , int length2 , int start , int range , struct re_registers *regs___0 ,
                int stop ) ;
#line 497
int re_match(struct re_pattern_buffer *bufp , char const   *string , int length ,
             int start , struct re_registers *regs___0 ) ;
#line 503
int re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , int length1 ,
               char const   *string2 , int length2 , int start , struct re_registers *regs___0 ,
               int stop ) ;
#line 521
void re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs___0 ,
                      unsigned int num_regs , regoff_t *starts , regoff_t *ends ) ;
#line 554
int regcomp(regex_t * __restrict  preg , char const   * __restrict  pattern , int cflags ) ;
#line 558
int regexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
            size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) ;
#line 563
size_t regerror(int errcode , regex_t const   *preg , char *errbuf , size_t errbuf_size ) ;
#line 566
void regfree(regex_t *preg ) ;
#line 70 "/usr/include/assert.h"
extern  __attribute__((__noreturn__)) void __assert_fail(char const   *__assertion ,
                                                         char const   *__file , unsigned int __line ,
                                                         char const   *__function ) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 83
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 85
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 116
__inline extern int tolower(int __c ) ;
#line 119
__inline extern int toupper(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
      {
      {
#line 193
      tmp = __ctype_tolower_loc();
      }
#line 193
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 193
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 193
    tmp___0 = (__int32_t const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 196 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
      {
      {
#line 199
      tmp = __ctype_toupper_loc();
      }
#line 199
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 199
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 199
    tmp___0 = (__int32_t const   )__c;
  }
#line 199
  return ((int )tmp___0);
}
}
#line 137 "/usr/include/stdlib.h"
extern size_t __ctype_get_mb_cur_max(void) ;
#line 556
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 594
extern  __attribute__((__noreturn__)) void abort(void) ;
#line 42 "/usr/include/string.h"
extern void *memmove(void *__dest , void const   *__src , size_t __n ) ;
#line 58
extern void *memset(void *__s , int __c , size_t __n ) ;
#line 61
extern int memcmp(void const   *__s1 , void const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 96
extern int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 178 "/usr/include/wchar.h"
extern int wcscoll(wchar_t const   *__s1 , wchar_t const   *__s2 ) ;
#line 294
extern wint_t btowc(int __c ) ;
#line 306
extern size_t mbrtowc(wchar_t * __restrict  __pwc , char const   * __restrict  __s ,
                      size_t __n , mbstate_t *__p ) ;
#line 311
extern size_t wcrtomb(char * __restrict  __s , wchar_t __wc , mbstate_t * __restrict  __ps ) ;
#line 315
extern size_t __mbrlen(char const   * __restrict  __s , size_t __n , mbstate_t * __restrict  __ps ) ;
#line 317
__inline extern size_t mbrlen(char const   * __restrict  __s , size_t __n , mbstate_t * __restrict  __ps ) ;
#line 323 "/usr/include/wchar.h"
__inline extern size_t mbrlen(char const   * __restrict  __s , size_t __n , mbstate_t * __restrict  __ps ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 325
  if ((unsigned long )__ps != (unsigned long )((void *)0)) {
    {
    {
#line 325
    tmp = mbrtowc((wchar_t */* __restrict  */)((void *)0), __s, __n, (mbstate_t *)__ps);
    }
#line 325
    tmp___1 = tmp;
    }
  } else {
    {
    {
#line 325
    tmp___0 = __mbrlen(__s, __n, (mbstate_t */* __restrict  */)((void *)0));
    }
#line 325
    tmp___1 = tmp___0;
    }
  }
#line 325
  return (tmp___1);
}
}
#line 374
__inline extern double wcstod(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ) ;
#line 388
__inline extern long wcstol(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                            int __base ) ;
#line 393
__inline extern unsigned long wcstoul(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                                      int __base ) ;
#line 483
extern double __wcstod_internal(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                                int __group ) ;
#line 494
extern long __wcstol_internal(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                              int __base , int __group ) ;
#line 500
extern unsigned long __wcstoul_internal(wchar_t const   * __restrict  __npt , wchar_t ** __restrict  __endptr ,
                                        int __base , int __group ) ;
#line 528 "/usr/include/wchar.h"
__inline extern double wcstod(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ) 
{ 
  double tmp ;

  {
  {
  {
#line 530
  tmp = __wcstod_internal(__nptr, __endptr, 0);
  }
  }
#line 530
  return (tmp);
}
}
#line 531 "/usr/include/wchar.h"
__inline extern long wcstol(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                            int __base ) 
{ 
  long tmp ;

  {
  {
  {
#line 534
  tmp = __wcstol_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 534
  return (tmp);
}
}
#line 535 "/usr/include/wchar.h"
__inline extern unsigned long wcstoul(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                                      int __base ) 
{ 
  unsigned long tmp ;

  {
  {
  {
#line 538
  tmp = __wcstoul_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 538
  return (tmp);
}
}
#line 126 "/usr/include/wctype.h"
extern int iswalnum(wint_t __wc ) ;
#line 148
extern int iswlower(wint_t __wc ) ;
#line 186
extern wctype_t wctype(char const   *__property ) ;
#line 190
extern int iswctype(wint_t __wc , wctype_t __desc ) ;
#line 212
extern wint_t towupper(wint_t __wc ) ;
#line 115 "regex_internal.h"
char const   __re_error_msgid[369] ;
#line 116
size_t const   __re_error_msgid_idx[17] ;
#line 133
__inline static void bitset_not(unsigned int *set ) ;
#line 134
__inline static void bitset_merge(unsigned int *dest , unsigned int * const  src ) ;
#line 346
static reg_errcode_t re_string_allocate(re_string_t *pstr , char const   *str , int len ,
                                        int init_len , char *trans , int icase ) ;
#line 349
static reg_errcode_t re_string_construct(re_string_t *pstr , char const   *str , int len ,
                                         char *trans , int icase ) ;
#line 352
static reg_errcode_t re_string_reconstruct(re_string_t *pstr , int idx , int eflags ,
                                           int newline ) ;
#line 354
static reg_errcode_t re_string_realloc_buffers(re_string_t *pstr , int new_buf_len ) ;
#line 357
static void build_wcs_buffer(re_string_t *pstr ) ;
#line 358
static void build_wcs_upper_buffer(re_string_t *pstr ) ;
#line 360
static void build_upper_buffer(re_string_t *pstr ) ;
#line 361
static void re_string_translate_buffer(re_string_t *pstr ) ;
#line 362
static void re_string_destruct(re_string_t *pstr ) ;
#line 364
static int re_string_elem_size_at(re_string_t const   *pstr , int idx ) ;
#line 365
__inline static int re_string_char_size_at(re_string_t const   *pstr , int idx ) ;
#line 366
__inline static wint_t re_string_wchar_at(re_string_t const   *pstr , int idx ) ;
#line 368
static unsigned int re_string_context_at(re_string_t const   *input , int idx , int eflags ,
                                         int newline_anchor ) ;
#line 610
static reg_errcode_t re_node_set_alloc(re_node_set *set , int size ) ;
#line 611
static reg_errcode_t re_node_set_init_1(re_node_set *set , int elem ) ;
#line 612
static reg_errcode_t re_node_set_init_2(re_node_set *set , int elem1 , int elem2 ) ;
#line 615
static reg_errcode_t re_node_set_init_copy(re_node_set *dest , re_node_set const   *src ) ;
#line 617
static reg_errcode_t re_node_set_add_intersect(re_node_set *dest , re_node_set const   *src1 ,
                                               re_node_set const   *src2 ) ;
#line 620
static reg_errcode_t re_node_set_init_union(re_node_set *dest , re_node_set const   *src1 ,
                                            re_node_set const   *src2 ) ;
#line 623
static reg_errcode_t re_node_set_merge(re_node_set *dest , re_node_set const   *src ) ;
#line 625
static int re_node_set_insert(re_node_set *set , int elem ) ;
#line 626
static int re_node_set_compare(re_node_set const   *set1 , re_node_set const   *set2 ) ;
#line 628
static int re_node_set_contains(re_node_set const   *set , int elem ) ;
#line 629
static void re_node_set_remove_at(re_node_set *set , int idx ) ;
#line 634
static int re_dfa_add_node(re_dfa_t *dfa , re_token_t token , int mode ) ;
#line 635
static re_dfastate_t *re_acquire_state(reg_errcode_t *err , re_dfa_t *dfa , re_node_set const   *nodes ) ;
#line 637
static re_dfastate_t *re_acquire_state_context(reg_errcode_t *err , re_dfa_t *dfa ,
                                               re_node_set const   *nodes , unsigned int context ) ;
#line 641
static void free_state(re_dfastate_t *state ) ;
#line 666 "regex_internal.h"
__inline static void bitset_not(unsigned int *set ) 
{ 
  int bitset_i ;

  {
#line 671
  bitset_i = 0;
  {
  {
#line 671
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 671
    if (! ((unsigned long )bitset_i < ((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) {
#line 671
      goto while_break;
    }
#line 672
    *(set + bitset_i) = ~ *(set + bitset_i);
#line 671
    bitset_i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 673
  return;
}
}
#line 675 "regex_internal.h"
__inline static void bitset_merge(unsigned int *dest , unsigned int * const  src ) 
{ 
  int bitset_i ;

  {
#line 681
  bitset_i = 0;
  {
  {
#line 681
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 681
    if (! ((unsigned long )bitset_i < ((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) {
#line 681
      goto while_break;
    }
#line 682
    *(dest + bitset_i) |= *(src + bitset_i);
#line 681
    bitset_i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 683
  return;
}
}
#line 697 "regex_internal.h"
__inline static int re_string_char_size_at(re_string_t const   *pstr , int idx ) 
{ 
  int byte_idx ;
  size_t tmp ;

  {
  {
  {
#line 703
  tmp = __ctype_get_mb_cur_max();
  }
  }
#line 703
  if (tmp == 1U) {
#line 704
    return (1);
  }
#line 705
  byte_idx = 1;
  {
  {
#line 705
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 705
    if (! (idx + byte_idx < (int )pstr->len)) {
#line 705
      goto while_break;
    }
#line 706
    if (*(pstr->wcs + (idx + byte_idx)) != 4294967295U) {
#line 707
      goto while_break;
    }
#line 705
    byte_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  return (byte_idx);
}
}
#line 711 "regex_internal.h"
__inline static wint_t re_string_wchar_at(re_string_t const   *pstr , int idx ) 
{ 
  size_t tmp ;

  {
  {
  {
#line 716
  tmp = __ctype_get_mb_cur_max();
  }
  }
#line 716
  if (tmp == 1U) {
#line 717
    return ((wint_t )*(pstr->mbs + idx));
  }
#line 718
  return (*(pstr->wcs + idx));
}
}
#line 721 "regex_internal.h"
static int re_string_elem_size_at(re_string_t const   *pstr , int idx ) 
{ 


  {
#line 746
  return (1);
}
}
#line 21 "regex_internal.c"
static void re_string_construct_common(char const   *str , int len , re_string_t *pstr ,
                                       char *trans , int icase ) ;
#line 25
static int re_string_skip_chars(re_string_t *pstr , int new_raw_idx , wint_t *last_wc ) ;
#line 28
static re_dfastate_t *create_newstate_common(re_dfa_t *dfa , re_node_set const   *nodes ,
                                             unsigned int hash ) ;
#line 31
static reg_errcode_t register_state(re_dfa_t *dfa , re_dfastate_t *newstate , unsigned int hash ) ;
#line 33
static re_dfastate_t *create_ci_newstate(re_dfa_t *dfa , re_node_set const   *nodes ,
                                         unsigned int hash ) ;
#line 36
static re_dfastate_t *create_cd_newstate(re_dfa_t *dfa , re_node_set const   *nodes ,
                                         unsigned int context , unsigned int hash ) ;
#line 40
__inline static unsigned int calc_state_hash(re_node_set const   *nodes , unsigned int context ) ;
#line 48 "regex_internal.c"
static reg_errcode_t re_string_allocate(re_string_t *pstr , char const   *str , int len ,
                                        int init_len , char *trans , int icase ) 
{ 
  reg_errcode_t ret ;
  int init_buf_len ;
  int tmp ;
  long tmp___0 ;
  size_t tmp___2 ;

  {
#line 56
  if (len + 1 < init_len) {
#line 56
    tmp = len + 1;
  } else {
#line 56
    tmp = init_len;
  }
  {
#line 56
  init_buf_len = tmp;
  {
#line 57
  re_string_construct_common(str, len, pstr, trans, icase);
  }
#line 58
  pstr->stop = pstr->len;
  {
#line 60
  ret = re_string_realloc_buffers(pstr, init_buf_len);
  }
  {
#line 61
  tmp___0 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
  }
  }
#line 61
  if (tmp___0) {
#line 62
    return (ret);
  }
#line 64
  if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
#line 64
    pstr->mbs_case = pstr->mbs_case;
  } else {
#line 64
    pstr->mbs_case = (unsigned char *)str;
  }
#line 66
  if (pstr->icase) {
#line 66
    pstr->mbs = pstr->mbs;
  } else {
#line 66
    pstr->mbs = pstr->mbs_case;
  }
#line 67
  if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
#line 67
    pstr->valid_len = pstr->valid_len;
  } else
#line 67
  if (pstr->icase) {
#line 67
    pstr->valid_len = pstr->valid_len;
  } else {
    {
    {
#line 67
    tmp___2 = __ctype_get_mb_cur_max();
    }
    }
#line 67
    if (tmp___2 > 1U) {
#line 67
      pstr->valid_len = pstr->valid_len;
    } else {
#line 67
      pstr->valid_len = len;
    }
  }
#line 69
  return ((reg_errcode_t )0);
}
}
#line 74 "regex_internal.c"
static reg_errcode_t re_string_construct(re_string_t *pstr , char const   *str , int len ,
                                         char *trans , int icase ) 
{ 
  reg_errcode_t ret ;
  long tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
  {
#line 82
  re_string_construct_common(str, len, pstr, trans, icase);
  }
#line 83
  pstr->stop = pstr->len;
#line 85
  pstr->valid_len = 0;
  }
#line 87
  if (len > 0) {
    {
    {
#line 89
    ret = re_string_realloc_buffers(pstr, len + 1);
    }
    {
#line 90
    tmp = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
    }
    }
#line 90
    if (tmp) {
#line 91
      return (ret);
    }
  }
#line 93
  if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
#line 93
    pstr->mbs_case = pstr->mbs_case;
  } else {
#line 93
    pstr->mbs_case = (unsigned char *)str;
  }
#line 95
  if (pstr->icase) {
#line 95
    pstr->mbs = pstr->mbs;
  } else {
#line 95
    pstr->mbs = pstr->mbs_case;
  }
#line 97
  if (icase) {
    {
    {
#line 100
    tmp___0 = __ctype_get_mb_cur_max();
    }
    }
#line 100
    if (tmp___0 > 1U) {
      {
      {
#line 101
      build_wcs_upper_buffer(pstr);
      }
      }
    } else {
      {
      {
#line 104
      build_upper_buffer(pstr);
      }
      }
    }
  } else {
    {
    {
#line 109
    tmp___1 = __ctype_get_mb_cur_max();
    }
    }
#line 109
    if (tmp___1 > 1U) {
      {
      {
#line 110
      build_wcs_buffer(pstr);
      }
      }
    } else
#line 114
    if ((unsigned long )trans != (unsigned long )((void *)0)) {
      {
      {
#line 115
      re_string_translate_buffer(pstr);
      }
      }
    } else {
#line 117
      pstr->valid_len = len;
    }
  }
#line 122
  pstr->valid_len = pstr->bufs_len;
#line 123
  return ((reg_errcode_t )0);
}
}
#line 128 "regex_internal.c"
static reg_errcode_t re_string_realloc_buffers(re_string_t *pstr , int new_buf_len ) 
{ 
  wint_t *new_array ;
  void *tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  unsigned char *new_array___0 ;
  void *tmp___2 ;
  long tmp___3 ;
  unsigned char *new_array___1 ;
  void *tmp___4 ;
  long tmp___5 ;

  {
  {
  {
#line 134
  tmp___1 = __ctype_get_mb_cur_max();
  }
  }
#line 134
  if (tmp___1 > 1U) {
    {
    {
#line 136
    tmp = realloc((void *)pstr->wcs, (size_t )((unsigned long )new_buf_len * sizeof(wint_t )));
    }
#line 136
    new_array = (wint_t *)tmp;
    {
#line 137
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 137
    if (tmp___0) {
#line 138
      return ((reg_errcode_t )12);
    }
#line 139
    pstr->wcs = new_array;
  }
#line 142
  if (pstr->icase) {
    {
    {
#line 144
    tmp___2 = realloc((void *)pstr->mbs, (size_t )((unsigned long )new_buf_len * sizeof(unsigned char )));
    }
#line 144
    new_array___0 = (unsigned char *)tmp___2;
    {
#line 146
    tmp___3 = __builtin_expect((long )((unsigned long )new_array___0 == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 146
    if (tmp___3) {
#line 147
      return ((reg_errcode_t )12);
    }
#line 148
    pstr->mbs = new_array___0;
  }
#line 150
  if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
    {
    {
#line 152
    tmp___4 = realloc((void *)pstr->mbs_case, (size_t )((unsigned long )new_buf_len * sizeof(unsigned char )));
    }
#line 152
    new_array___1 = (unsigned char *)tmp___4;
    {
#line 154
    tmp___5 = __builtin_expect((long )((unsigned long )new_array___1 == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 154
    if (tmp___5) {
#line 155
      return ((reg_errcode_t )12);
    }
#line 156
    pstr->mbs_case = new_array___1;
#line 157
    if (! pstr->icase) {
#line 158
      pstr->mbs = pstr->mbs_case;
    }
  }
#line 160
  pstr->bufs_len = new_buf_len;
#line 161
  return ((reg_errcode_t )0);
}
}
#line 165 "regex_internal.c"
static void re_string_construct_common(char const   *str , int len , re_string_t *pstr ,
                                       char *trans , int icase ) 
{ 
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_39 *__u ;
  __uint8_t __c ;
  void *__s___1 ;

  {
#line 173
  if (sizeof(re_string_t ) <= 16UL) {
#line 173
    if (sizeof(re_string_t ) == 1UL) {
#line 173
      __s___1 = (void *)pstr;
#line 173
      *((__uint8_t *)__s___1) = (__uint8_t )'\000';
    } else {
#line 173
      __s___0 = (void *)pstr;
#line 173
      __u = (union __anonunion___u_39 *)__s___0;
#line 173
      __c = (__uint8_t )'\000';
      {
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 15U) {
#line 173
        goto case_15;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 11U) {
#line 173
        goto case_11;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 7U) {
#line 173
        goto case_7;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 3U) {
#line 173
        goto case_3;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 14U) {
#line 173
        goto case_14;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 10U) {
#line 173
        goto case_10;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 6U) {
#line 173
        goto case_6;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 2U) {
#line 173
        goto case_2;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 13U) {
#line 173
        goto case_13;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 9U) {
#line 173
        goto case_9;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 5U) {
#line 173
        goto case_5;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 1U) {
#line 173
        goto case_1;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 16U) {
#line 173
        goto case_16;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 12U) {
#line 173
        goto case_12;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 8U) {
#line 173
        goto case_8;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 4U) {
#line 173
        goto case_4;
      }
#line 173
      if ((unsigned int )sizeof(re_string_t ) == 0U) {
#line 173
        goto case_0;
      }
#line 173
      goto switch_break;
      case_15: /* CIL Label */ 
#line 173
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 173
      __u = (union __anonunion___u_39 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 173
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 173
      __u = (union __anonunion___u_39 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 173
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 173
      __u = (union __anonunion___u_39 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 173
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 173
      __u = (union __anonunion___u_39 *)((void *)__u + 2);
#line 173
      __u->__uc = __c;
#line 173
      goto switch_break;
      case_14: /* CIL Label */ 
#line 173
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 173
      __u = (union __anonunion___u_39 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 173
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 173
      __u = (union __anonunion___u_39 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 173
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 173
      __u = (union __anonunion___u_39 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 173
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 173
      goto switch_break;
      case_13: /* CIL Label */ 
#line 173
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 173
      __u = (union __anonunion___u_39 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 173
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 173
      __u = (union __anonunion___u_39 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 173
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 173
      __u = (union __anonunion___u_39 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 173
      __u->__uc = __c;
#line 173
      goto switch_break;
      case_16: /* CIL Label */ 
#line 173
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 173
      __u = (union __anonunion___u_39 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 173
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 173
      __u = (union __anonunion___u_39 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 173
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 173
      __u = (union __anonunion___u_39 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 173
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 173
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 173
    __s = (void *)pstr;
    {
#line 173
    __builtin_memset(__s, '\000', (int )sizeof(re_string_t ));
    }
    }
  }
#line 174
  pstr->raw_mbs = (unsigned char const   *)str;
#line 175
  pstr->len = len;
#line 176
  pstr->trans = trans;
#line 177
  if (icase) {
#line 177
    pstr->icase = 1U;
  } else {
#line 177
    pstr->icase = 0U;
  }
#line 178
  return;
}
}
#line 193 "regex_internal.c"
static void build_wcs_buffer(re_string_t *pstr ) 
{ 
  mbstate_t prev_st ;
  int byte_idx ;
  int end_idx ;
  int mbclen ;
  int remain_len ;
  wchar_t wc ;
  size_t tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int ch ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 201
  if (pstr->bufs_len > pstr->len) {
#line 201
    end_idx = pstr->len;
  } else {
#line 201
    end_idx = pstr->bufs_len;
  }
#line 202
  byte_idx = pstr->valid_len;
  {
  {
#line 202
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 202
    if (! (byte_idx < end_idx)) {
#line 202
      goto while_break;
    }
    {
#line 205
    remain_len = end_idx - byte_idx;
#line 206
    prev_st = pstr->cur_state;
    {
#line 207
    tmp = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)(((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx),
                  (size_t )remain_len, & pstr->cur_state);
    }
#line 207
    mbclen = (int )tmp;
    {
#line 209
    tmp___2 = __builtin_expect((long )((size_t )mbclen == 4294967294U), 0L);
    }
    }
#line 209
    if (tmp___2) {
#line 212
      pstr->cur_state = prev_st;
#line 213
      goto while_break;
    } else {
#line 215
      if ((size_t )mbclen == 4294967295U) {
#line 215
        tmp___0 = 1;
      } else
#line 215
      if (mbclen == 0) {
#line 215
        tmp___0 = 1;
      } else {
#line 215
        tmp___0 = 0;
      }
      {
      {
#line 215
      tmp___1 = __builtin_expect((long )tmp___0, 0L);
      }
      }
#line 215
      if (tmp___1) {
#line 218
        mbclen = 1;
#line 219
        wc = (wchar_t )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx));
#line 220
        pstr->cur_state = prev_st;
      }
    }
#line 224
    if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
#line 224
      if (mbclen == 1) {
#line 226
        ch = (int )*(pstr->trans + *(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx)));
#line 227
        *(pstr->mbs_case + byte_idx) = (unsigned char )ch;
      }
    }
#line 230
    tmp___3 = byte_idx;
#line 230
    byte_idx ++;
#line 230
    *(pstr->wcs + tmp___3) = (wint_t )wc;
#line 232
    remain_len = (byte_idx + mbclen) - 1;
    {
    {
#line 232
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 232
      if (! (byte_idx < remain_len)) {
#line 232
        goto while_break___0;
      }
#line 233
      tmp___4 = byte_idx;
#line 233
      byte_idx ++;
#line 233
      *(pstr->wcs + tmp___4) = 4294967295U;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  pstr->valid_len = byte_idx;
#line 236
  return;
}
}
#line 241 "regex_internal.c"
static void build_wcs_upper_buffer(re_string_t *pstr ) 
{ 
  mbstate_t prev_st ;
  int byte_idx ;
  int end_idx ;
  int mbclen ;
  int remain_len ;
  wchar_t wc ;
  size_t tmp ;
  int ch ;
  int __res ;
  __int32_t const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __res___0 ;
  __int32_t const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  long tmp___9 ;
  wint_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int __res___1 ;
  __int32_t const   **tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  long tmp___18 ;

  {
#line 249
  if (pstr->bufs_len > pstr->len) {
#line 249
    end_idx = pstr->len;
  } else {
#line 249
    end_idx = pstr->bufs_len;
  }
#line 250
  byte_idx = pstr->valid_len;
  {
  {
#line 250
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 250
    if (! (byte_idx < end_idx)) {
#line 250
      goto while_break;
    }
    {
#line 253
    remain_len = end_idx - byte_idx;
#line 254
    prev_st = pstr->cur_state;
    {
#line 255
    tmp = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)(((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx),
                  (size_t )remain_len, & pstr->cur_state);
    }
#line 255
    mbclen = (int )tmp;
    {
#line 257
    tmp___18 = __builtin_expect((long )((size_t )mbclen == 4294967294U), 0L);
    }
    }
#line 257
    if (tmp___18) {
#line 260
      pstr->cur_state = prev_st;
#line 261
      goto while_break;
    } else
#line 263
    if (mbclen == 1) {
#line 263
      goto _L;
    } else
#line 263
    if ((size_t )mbclen == 4294967295U) {
#line 263
      goto _L;
    } else
#line 263
    if (mbclen == 0) {
      _L: /* CIL Label */ 
#line 266
      ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx));
#line 268
      if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
#line 268
        if (mbclen == 1) {
#line 270
          ch = (int )*(pstr->trans + ch);
#line 271
          *(pstr->mbs_case + byte_idx) = (unsigned char )ch;
        }
      }
      {
      {
#line 273
      tmp___3 = iswlower((wint_t )wc);
      }
      }
#line 273
      if (tmp___3) {
#line 273
        if (sizeof(wc) > 1UL) {
          {
          {
#line 273
          __res = toupper((int )wc);
          }
          }
        } else {
          {
          {
#line 273
          tmp___2 = __ctype_toupper_loc();
          }
#line 273
          __res = (int )*(*tmp___2 + (int )wc);
          }
        }
#line 273
        *(pstr->wcs + byte_idx) = (wint_t )__res;
      } else {
#line 273
        *(pstr->wcs + byte_idx) = (wint_t )wc;
      }
      {
#line 274
      tmp___4 = byte_idx;
#line 274
      byte_idx ++;
      {
#line 274
      tmp___8 = __ctype_b_loc();
      }
      }
#line 274
      if ((int const   )*(*tmp___8 + ch) & 512) {
#line 274
        if (sizeof(ch) > 1UL) {
          {
          {
#line 274
          __res___0 = toupper(ch);
          }
          }
        } else {
          {
          {
#line 274
          tmp___7 = __ctype_toupper_loc();
          }
#line 274
          __res___0 = (int )*(*tmp___7 + ch);
          }
        }
#line 274
        *(pstr->mbs + tmp___4) = (unsigned char )__res___0;
      } else {
#line 274
        *(pstr->mbs + tmp___4) = (unsigned char )ch;
      }
      {
      {
#line 275
      tmp___9 = __builtin_expect((long )((size_t )mbclen == 4294967295U), 0L);
      }
      }
#line 275
      if (tmp___9) {
#line 276
        pstr->cur_state = prev_st;
      }
    } else {
      {
      {
#line 280
      tmp___11 = iswlower((wint_t )wc);
      }
      }
#line 280
      if (tmp___11) {
        {
        {
#line 281
        tmp___10 = towupper((wint_t )wc);
        }
        {
#line 281
        wcrtomb((char */* __restrict  */)((char *)pstr->mbs + byte_idx), (wchar_t )tmp___10,
                (mbstate_t */* __restrict  */)(& prev_st));
        }
        }
      } else {
        {
        {
#line 283
        memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)((pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx),
               (size_t )mbclen);
        }
        }
      }
      {
#line 285
      tmp___12 = byte_idx;
#line 285
      byte_idx ++;
      {
#line 285
      tmp___16 = iswlower((wint_t )wc);
      }
      }
#line 285
      if (tmp___16) {
#line 285
        if (sizeof(wc) > 1UL) {
          {
          {
#line 285
          __res___1 = toupper((int )wc);
          }
          }
        } else {
          {
          {
#line 285
          tmp___15 = __ctype_toupper_loc();
          }
#line 285
          __res___1 = (int )*(*tmp___15 + (int )wc);
          }
        }
#line 285
        *(pstr->wcs + tmp___12) = (wint_t )__res___1;
      } else {
#line 285
        *(pstr->wcs + tmp___12) = (wint_t )wc;
      }
#line 287
      remain_len = (byte_idx + mbclen) - 1;
      {
      {
#line 287
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 287
        if (! (byte_idx < remain_len)) {
#line 287
          goto while_break___0;
        }
#line 288
        tmp___17 = byte_idx;
#line 288
        byte_idx ++;
#line 288
        *(pstr->wcs + tmp___17) = 4294967295U;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  pstr->valid_len = byte_idx;
#line 292
  return;
}
}
#line 297 "regex_internal.c"
static int re_string_skip_chars(re_string_t *pstr , int new_raw_idx , wint_t *last_wc ) 
{ 
  mbstate_t prev_st ;
  int rawbuf_idx ;
  int mbclen ;
  wchar_t wc ;
  int remain_len ;
  size_t tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 305
  wc = (wchar_t )0;
#line 308
  rawbuf_idx = pstr->raw_mbs_idx + pstr->valid_len;
  {
  {
#line 308
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 308
    if (! (rawbuf_idx < new_raw_idx)) {
#line 308
      goto while_break;
    }
    {
#line 312
    remain_len = pstr->len - rawbuf_idx;
#line 313
    prev_st = pstr->cur_state;
    {
#line 314
    tmp = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)((char const   *)pstr->raw_mbs + rawbuf_idx),
                  (size_t )remain_len, & pstr->cur_state);
    }
#line 314
    mbclen = (int )tmp;
    }
#line 316
    if ((size_t )mbclen == 4294967294U) {
#line 316
      tmp___0 = 1;
    } else
#line 316
    if ((size_t )mbclen == 4294967295U) {
#line 316
      tmp___0 = 1;
    } else
#line 316
    if (mbclen == 0) {
#line 316
      tmp___0 = 1;
    } else {
#line 316
      tmp___0 = 0;
    }
    {
    {
#line 316
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
    }
#line 316
    if (tmp___1) {
#line 319
      mbclen = 1;
#line 320
      pstr->cur_state = prev_st;
    }
#line 323
    rawbuf_idx += mbclen;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  *last_wc = (wint_t )wc;
#line 326
  return (rawbuf_idx);
}
}
#line 333 "regex_internal.c"
static void build_upper_buffer(re_string_t *pstr ) 
{ 
  int char_idx ;
  int end_idx ;
  int ch ;
  int __res ;
  __int32_t const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 338
  if (pstr->bufs_len > pstr->len) {
#line 338
    end_idx = pstr->len;
  } else {
#line 338
    end_idx = pstr->bufs_len;
  }
#line 340
  char_idx = pstr->valid_len;
  {
  {
#line 340
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 340
    if (! (char_idx < end_idx)) {
#line 340
      goto while_break;
    }
#line 342
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + char_idx));
#line 343
    if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
#line 345
      ch = (int )*(pstr->trans + ch);
#line 346
      *(pstr->mbs_case + char_idx) = (unsigned char )ch;
    }
    {
    {
#line 348
    tmp___1 = __ctype_b_loc();
    }
    }
#line 348
    if ((int const   )*(*tmp___1 + ch) & 512) {
#line 349
      if (sizeof(ch) > 1UL) {
        {
        {
#line 349
        __res = toupper(ch);
        }
        }
      } else {
        {
        {
#line 349
        tmp___0 = __ctype_toupper_loc();
        }
#line 349
        __res = (int )*(*tmp___0 + ch);
        }
      }
#line 349
      *(pstr->mbs + char_idx) = (unsigned char )__res;
    } else {
#line 351
      *(pstr->mbs + char_idx) = (unsigned char )ch;
    }
#line 340
    char_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  pstr->valid_len = char_idx;
#line 354
  return;
}
}
#line 358 "regex_internal.c"
static void re_string_translate_buffer(re_string_t *pstr ) 
{ 
  int buf_idx ;
  int end_idx ;
  int ch ;

  {
#line 363
  if (pstr->bufs_len > pstr->len) {
#line 363
    end_idx = pstr->len;
  } else {
#line 363
    end_idx = pstr->bufs_len;
  }
#line 365
  buf_idx = pstr->valid_len;
  {
  {
#line 365
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 365
    if (! (buf_idx < end_idx)) {
#line 365
      goto while_break;
    }
#line 367
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + buf_idx));
#line 368
    *(pstr->mbs_case + buf_idx) = (unsigned char )*(pstr->trans + ch);
#line 365
    buf_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  pstr->valid_len = buf_idx;
#line 372
  return;
}
}
#line 378 "regex_internal.c"
static reg_errcode_t re_string_reconstruct(re_string_t *pstr , int idx , int eflags ,
                                           int newline ) 
{ 
  int offset ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_40 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int wcs_idx ;
  wint_t wc ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int c ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 383
  offset = idx - pstr->raw_mbs_idx;
#line 384
  if (offset < 0) {
    {
    {
#line 388
    tmp = __ctype_get_mb_cur_max();
    }
    }
#line 388
    if (tmp > 1U) {
#line 389
      if (sizeof(mbstate_t ) <= 16UL) {
#line 389
        if (sizeof(mbstate_t ) == 1UL) {
#line 389
          __s___1 = (void *)(& pstr->cur_state);
#line 389
          *((__uint8_t *)__s___1) = (__uint8_t )'\000';
        } else {
#line 389
          __s___0 = (void *)(& pstr->cur_state);
#line 389
          __u = (union __anonunion___u_40 *)__s___0;
#line 389
          __c = (__uint8_t )'\000';
          {
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 15U) {
#line 389
            goto case_15;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 11U) {
#line 389
            goto case_11;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 7U) {
#line 389
            goto case_7;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 3U) {
#line 389
            goto case_3;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 14U) {
#line 389
            goto case_14;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 10U) {
#line 389
            goto case_10;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 6U) {
#line 389
            goto case_6;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 2U) {
#line 389
            goto case_2;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 13U) {
#line 389
            goto case_13;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 9U) {
#line 389
            goto case_9;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 5U) {
#line 389
            goto case_5;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 1U) {
#line 389
            goto case_1;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 16U) {
#line 389
            goto case_16;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 12U) {
#line 389
            goto case_12;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 8U) {
#line 389
            goto case_8;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 4U) {
#line 389
            goto case_4;
          }
#line 389
          if ((unsigned int )sizeof(mbstate_t ) == 0U) {
#line 389
            goto case_0;
          }
#line 389
          goto switch_break;
          case_15: /* CIL Label */ 
#line 389
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 389
          __u = (union __anonunion___u_40 *)((void *)__u + 4);
          case_11: /* CIL Label */ 
#line 389
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 389
          __u = (union __anonunion___u_40 *)((void *)__u + 4);
          case_7: /* CIL Label */ 
#line 389
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 389
          __u = (union __anonunion___u_40 *)((void *)__u + 4);
          case_3: /* CIL Label */ 
#line 389
          __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 389
          __u = (union __anonunion___u_40 *)((void *)__u + 2);
#line 389
          __u->__uc = __c;
#line 389
          goto switch_break;
          case_14: /* CIL Label */ 
#line 389
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 389
          __u = (union __anonunion___u_40 *)((void *)__u + 4);
          case_10: /* CIL Label */ 
#line 389
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 389
          __u = (union __anonunion___u_40 *)((void *)__u + 4);
          case_6: /* CIL Label */ 
#line 389
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 389
          __u = (union __anonunion___u_40 *)((void *)__u + 4);
          case_2: /* CIL Label */ 
#line 389
          __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 389
          goto switch_break;
          case_13: /* CIL Label */ 
#line 389
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 389
          __u = (union __anonunion___u_40 *)((void *)__u + 4);
          case_9: /* CIL Label */ 
#line 389
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 389
          __u = (union __anonunion___u_40 *)((void *)__u + 4);
          case_5: /* CIL Label */ 
#line 389
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 389
          __u = (union __anonunion___u_40 *)((void *)__u + 4);
          case_1: /* CIL Label */ 
#line 389
          __u->__uc = __c;
#line 389
          goto switch_break;
          case_16: /* CIL Label */ 
#line 389
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 389
          __u = (union __anonunion___u_40 *)((void *)__u + 4);
          case_12: /* CIL Label */ 
#line 389
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 389
          __u = (union __anonunion___u_40 *)((void *)__u + 4);
          case_8: /* CIL Label */ 
#line 389
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 389
          __u = (union __anonunion___u_40 *)((void *)__u + 4);
          case_4: /* CIL Label */ 
#line 389
          __u->__ui = (unsigned int )((int )__c * 16843009);
          case_0: /* CIL Label */ 
#line 389
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 389
        __s = (void *)(& pstr->cur_state);
        {
#line 389
        __builtin_memset(__s, '\000', (int )sizeof(mbstate_t ));
        }
        }
      }
    }
#line 391
    pstr->len += pstr->raw_mbs_idx;
#line 392
    pstr->stop += pstr->raw_mbs_idx;
#line 393
    tmp___0 = 0;
#line 393
    pstr->raw_mbs_idx = tmp___0;
#line 393
    pstr->valid_len = tmp___0;
#line 394
    if (eflags & 1) {
#line 394
      pstr->tip_context = (unsigned int )((1 << 1) << 1);
    } else {
#line 394
      pstr->tip_context = (unsigned int )((1 << 1) | ((1 << 1) << 1));
    }
#line 396
    if (! ((unsigned long )pstr->trans != (unsigned long )((void *)0))) {
#line 397
      pstr->mbs_case = (unsigned char *)pstr->raw_mbs;
    }
#line 398
    if (! pstr->icase) {
#line 398
      if (! ((unsigned long )pstr->trans != (unsigned long )((void *)0))) {
#line 399
        pstr->mbs = (unsigned char *)pstr->raw_mbs;
      }
    }
#line 400
    offset = idx;
  }
#line 403
  if (offset != 0) {
#line 406
    if (offset < pstr->valid_len) {
      {
      {
#line 409
      pstr->tip_context = re_string_context_at((re_string_t const   *)pstr, offset - 1,
                                               eflags, newline);
      }
      {
#line 412
      tmp___1 = __ctype_get_mb_cur_max();
      }
      }
#line 412
      if (tmp___1 > 1U) {
        {
        {
#line 413
        memmove((void *)pstr->wcs, (void const   *)(pstr->wcs + offset), (size_t )((unsigned long )(pstr->valid_len - offset) * sizeof(wint_t )));
        }
        }
      }
#line 416
      if (pstr->icase) {
        {
        {
#line 417
        memmove((void *)pstr->mbs, (void const   *)(pstr->mbs + offset), (size_t )(pstr->valid_len - offset));
        }
        }
      }
#line 419
      if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
        {
        {
#line 420
        memmove((void *)pstr->mbs_case, (void const   *)(pstr->mbs_case + offset),
                (size_t )(pstr->valid_len - offset));
        }
        }
      }
#line 422
      pstr->valid_len -= offset;
    } else {
      {
#line 430
      pstr->valid_len = 0;
      {
#line 432
      tmp___9 = __ctype_get_mb_cur_max();
      }
      }
#line 432
      if (tmp___9 > 1U) {
        {
        {
#line 436
        tmp___2 = re_string_skip_chars(pstr, idx, & wc);
        }
#line 436
        pstr->valid_len = tmp___2 - idx;
#line 437
        wcs_idx = 0;
        }
        {
        {
#line 437
        while (1) {
          while_continue___0: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;
#line 437
          if (! (wcs_idx < pstr->valid_len)) {
#line 437
            goto while_break;
          }
#line 438
          *(pstr->wcs + wcs_idx) = 4294967295U;
#line 437
          wcs_idx ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
#line 439
        if (pstr->trans) {
#line 439
          if (wc <= 255U) {
#line 440
            wc = (wint_t )*(pstr->trans + wc);
          }
        }
        {
        {
#line 441
        tmp___5 = iswalnum(wc);
        }
        }
#line 441
        if (tmp___5) {
#line 441
          pstr->tip_context = 1U;
        } else
#line 441
        if (wc == 95U) {
#line 441
          pstr->tip_context = 1U;
        } else {
#line 441
          if (newline) {
#line 441
            if (wc == 10U) {
#line 441
              tmp___4 = 1 << 1;
            } else {
#line 441
              tmp___4 = 0;
            }
          } else {
#line 441
            tmp___4 = 0;
          }
#line 441
          pstr->tip_context = (unsigned int )tmp___4;
        }
      } else {
#line 448
        c = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + offset) - 1));
#line 449
        if (pstr->trans) {
#line 450
          c = (int )*(pstr->trans + c);
        }
        {
        {
#line 451
        tmp___8 = __ctype_b_loc();
        }
        }
#line 451
        if ((int const   )*(*tmp___8 + c) & 8) {
#line 451
          pstr->tip_context = 1U;
        } else
#line 451
        if (c == 95) {
#line 451
          pstr->tip_context = 1U;
        } else {
#line 451
          if (newline) {
#line 451
            if (c == 10) {
#line 451
              tmp___7 = 1 << 1;
            } else {
#line 451
              tmp___7 = 0;
            }
          } else {
#line 451
            tmp___7 = 0;
          }
#line 451
          pstr->tip_context = (unsigned int )tmp___7;
        }
      }
    }
#line 456
    if (! ((unsigned long )pstr->trans != (unsigned long )((void *)0))) {
#line 458
      pstr->mbs_case += offset;
#line 460
      if (! pstr->icase) {
#line 461
        pstr->mbs += offset;
      }
    }
  }
  {
#line 464
  pstr->raw_mbs_idx = idx;
#line 465
  pstr->len -= offset;
#line 466
  pstr->stop -= offset;
  {
#line 470
  tmp___10 = __ctype_get_mb_cur_max();
  }
  }
#line 470
  if (tmp___10 > 1U) {
#line 472
    if (pstr->icase) {
      {
      {
#line 473
      build_wcs_upper_buffer(pstr);
      }
      }
    } else {
      {
      {
#line 475
      build_wcs_buffer(pstr);
      }
      }
    }
  } else
#line 480
  if (pstr->icase) {
    {
    {
#line 481
    build_upper_buffer(pstr);
    }
    }
  } else
#line 482
  if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
    {
    {
#line 483
    re_string_translate_buffer(pstr);
    }
    }
  }
#line 485
  pstr->cur_idx = 0;
#line 487
  return ((reg_errcode_t )0);
}
}
#line 490 "regex_internal.c"
static void re_string_destruct(re_string_t *pstr ) 
{ 


  {
  {
  {
#line 495
  free((void *)pstr->wcs);
  }
  }
#line 497
  if (pstr->icase) {
    {
    {
#line 498
    free((void *)pstr->mbs);
    }
    }
  }
#line 499
  if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
    {
    {
#line 500
    free((void *)pstr->mbs_case);
    }
    }
  }
#line 501
  return;
}
}
#line 505 "regex_internal.c"
static unsigned int re_string_context_at(re_string_t const   *input , int idx , int eflags ,
                                         int newline_anchor ) 
{ 
  int c ;
  int tmp ;
  wint_t wc ;
  int wc_idx ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 511
  if (idx < 0) {
#line 511
    goto _L;
  } else
#line 511
  if (idx == (int )input->len) {
    _L: /* CIL Label */ 
#line 513
    if (idx < 0) {
#line 516
      return ((unsigned int )input->tip_context);
    } else {
#line 518
      if (eflags & (1 << 1)) {
#line 518
        tmp = ((1 << 1) << 1) << 1;
      } else {
#line 518
        tmp = (1 << 1) | (((1 << 1) << 1) << 1);
      }
#line 518
      return ((unsigned int )tmp);
    }
  }
  {
  {
#line 522
  tmp___4 = __ctype_get_mb_cur_max();
  }
  }
#line 522
  if (tmp___4 > 1U) {
#line 525
    wc_idx = idx;
    {
    {
#line 526
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 526
      if (! (*(input->wcs + wc_idx) == 4294967295U)) {
#line 526
        goto while_break;
      }
#line 532
      wc_idx --;
#line 533
      if (wc_idx < 0) {
#line 534
        return ((unsigned int )input->tip_context);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 536
    wc = *(input->wcs + wc_idx);
    {
#line 537
    tmp___0 = iswalnum(wc);
    }
    }
#line 537
    if (tmp___0) {
#line 538
      return (1U);
    } else
#line 537
    if (wc == 95U) {
#line 538
      return (1U);
    }
#line 539
    if (newline_anchor) {
#line 539
      if (wc == 10U) {
#line 539
        tmp___1 = 1 << 1;
      } else {
#line 539
        tmp___1 = 0;
      }
    } else {
#line 539
      tmp___1 = 0;
    }
#line 539
    return ((unsigned int )tmp___1);
  } else {
    {
#line 544
    c = (int )*(input->mbs + idx);
    {
#line 545
    tmp___2 = __ctype_b_loc();
    }
    }
#line 545
    if ((int const   )*(*tmp___2 + c) & 8) {
#line 546
      return (1U);
    } else
#line 545
    if (c == 95) {
#line 546
      return (1U);
    }
#line 547
    if (newline_anchor) {
#line 547
      if (c == 10) {
#line 547
        tmp___3 = 1 << 1;
      } else {
#line 547
        tmp___3 = 0;
      }
    } else {
#line 547
      tmp___3 = 0;
    }
#line 547
    return ((unsigned int )tmp___3);
  }
}
}
#line 553 "regex_internal.c"
static reg_errcode_t re_node_set_alloc(re_node_set *set , int size ) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 558
  set->alloc = size;
#line 559
  set->nelem = 0;
  {
#line 560
  tmp = malloc((size_t )((unsigned long )size * sizeof(int )));
  }
#line 560
  set->elems = (int *)tmp;
  {
#line 561
  tmp___0 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
  }
#line 561
  if (tmp___0) {
#line 562
    return ((reg_errcode_t )12);
  }
#line 563
  return ((reg_errcode_t )0);
}
}
#line 566 "regex_internal.c"
static reg_errcode_t re_node_set_init_1(re_node_set *set , int elem ) 
{ 
  void *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 571
  set->alloc = 1;
#line 572
  set->nelem = 1;
  {
#line 573
  tmp = malloc((size_t )sizeof(int ));
  }
#line 573
  set->elems = (int *)tmp;
  {
#line 574
  tmp___1 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
  }
#line 574
  if (tmp___1) {
#line 576
    tmp___0 = 0;
#line 576
    set->nelem = tmp___0;
#line 576
    set->alloc = tmp___0;
#line 577
    return ((reg_errcode_t )12);
  }
#line 579
  *(set->elems + 0) = elem;
#line 580
  return ((reg_errcode_t )0);
}
}
#line 583 "regex_internal.c"
static reg_errcode_t re_node_set_init_2(re_node_set *set , int elem1 , int elem2 ) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 588
  set->alloc = 2;
  {
#line 589
  tmp = malloc((size_t )(2UL * sizeof(int )));
  }
#line 589
  set->elems = (int *)tmp;
  {
#line 590
  tmp___0 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
  }
#line 590
  if (tmp___0) {
#line 591
    return ((reg_errcode_t )12);
  }
#line 592
  if (elem1 == elem2) {
#line 594
    set->nelem = 1;
#line 595
    *(set->elems + 0) = elem1;
  } else {
#line 599
    set->nelem = 2;
#line 600
    if (elem1 < elem2) {
#line 602
      *(set->elems + 0) = elem1;
#line 603
      *(set->elems + 1) = elem2;
    } else {
#line 607
      *(set->elems + 0) = elem2;
#line 608
      *(set->elems + 1) = elem1;
    }
  }
#line 611
  return ((reg_errcode_t )0);
}
}
#line 614 "regex_internal.c"
static reg_errcode_t re_node_set_init_copy(re_node_set *dest , re_node_set const   *src ) 
{ 
  void *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_41 *__u ;
  __uint8_t __c ;
  void *__s___1 ;

  {
#line 619
  dest->nelem = (int )src->nelem;
#line 620
  if (src->nelem > 0) {
    {
#line 622
    dest->alloc = dest->nelem;
    {
#line 623
    tmp = malloc((size_t )((unsigned long )dest->alloc * sizeof(int )));
    }
#line 623
    dest->elems = (int *)tmp;
    {
#line 624
    tmp___1 = __builtin_expect((long )((unsigned long )dest->elems == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 624
    if (tmp___1) {
#line 626
      tmp___0 = 0;
#line 626
      dest->nelem = tmp___0;
#line 626
      dest->alloc = tmp___0;
#line 627
      return ((reg_errcode_t )12);
    }
    {
    {
#line 629
    memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)src->elems,
           (size_t )((unsigned long )src->nelem * sizeof(int )));
    }
    }
  } else
#line 632
  if (sizeof(re_node_set ) <= 16UL) {
#line 632
    if (sizeof(re_node_set ) == 1UL) {
#line 632
      __s___1 = (void *)dest;
#line 632
      *((__uint8_t *)__s___1) = (__uint8_t )'\000';
    } else {
#line 632
      __s___0 = (void *)dest;
#line 632
      __u = (union __anonunion___u_41 *)__s___0;
#line 632
      __c = (__uint8_t )'\000';
      {
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 15U) {
#line 632
        goto case_15;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 11U) {
#line 632
        goto case_11;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 7U) {
#line 632
        goto case_7;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 3U) {
#line 632
        goto case_3;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 14U) {
#line 632
        goto case_14;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 10U) {
#line 632
        goto case_10;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 6U) {
#line 632
        goto case_6;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 2U) {
#line 632
        goto case_2;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 13U) {
#line 632
        goto case_13;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 9U) {
#line 632
        goto case_9;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 5U) {
#line 632
        goto case_5;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 1U) {
#line 632
        goto case_1;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 16U) {
#line 632
        goto case_16;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 12U) {
#line 632
        goto case_12;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 8U) {
#line 632
        goto case_8;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 4U) {
#line 632
        goto case_4;
      }
#line 632
      if ((unsigned int )sizeof(re_node_set ) == 0U) {
#line 632
        goto case_0;
      }
#line 632
      goto switch_break;
      case_15: /* CIL Label */ 
#line 632
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 632
      __u = (union __anonunion___u_41 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 632
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 632
      __u = (union __anonunion___u_41 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 632
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 632
      __u = (union __anonunion___u_41 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 632
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 632
      __u = (union __anonunion___u_41 *)((void *)__u + 2);
#line 632
      __u->__uc = __c;
#line 632
      goto switch_break;
      case_14: /* CIL Label */ 
#line 632
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 632
      __u = (union __anonunion___u_41 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 632
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 632
      __u = (union __anonunion___u_41 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 632
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 632
      __u = (union __anonunion___u_41 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 632
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 632
      goto switch_break;
      case_13: /* CIL Label */ 
#line 632
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 632
      __u = (union __anonunion___u_41 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 632
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 632
      __u = (union __anonunion___u_41 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 632
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 632
      __u = (union __anonunion___u_41 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 632
      __u->__uc = __c;
#line 632
      goto switch_break;
      case_16: /* CIL Label */ 
#line 632
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 632
      __u = (union __anonunion___u_41 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 632
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 632
      __u = (union __anonunion___u_41 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 632
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 632
      __u = (union __anonunion___u_41 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 632
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 632
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 632
    __s = (void *)dest;
    {
#line 632
    __builtin_memset(__s, '\000', (int )sizeof(re_node_set ));
    }
    }
  }
#line 633
  return ((reg_errcode_t )0);
}
}
#line 640 "regex_internal.c"
static reg_errcode_t re_node_set_add_intersect(re_node_set *dest , re_node_set const   *src1 ,
                                               re_node_set const   *src2 ) 
{ 
  int i1 ;
  int i2 ;
  int id ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 646
  if (src1->nelem > 0) {
#line 646
    if (src2->nelem > 0) {
#line 648
      if ((src1->nelem + src2->nelem) + (int const   )dest->nelem > (int const   )dest->alloc) {
        {
#line 650
        dest->alloc = (int )((src1->nelem + src2->nelem) + (int const   )dest->nelem);
        {
#line 651
        tmp = realloc((void *)dest->elems, (size_t )((unsigned long )dest->alloc * sizeof(int )));
        }
#line 651
        dest->elems = (int *)tmp;
        {
#line 652
        tmp___0 = __builtin_expect((long )((unsigned long )dest->elems == (unsigned long )((void *)0)),
                                   0L);
        }
        }
#line 652
        if (tmp___0) {
#line 653
          return ((reg_errcode_t )12);
        }
      }
    } else {
#line 657
      return ((reg_errcode_t )0);
    }
  } else {
#line 657
    return ((reg_errcode_t )0);
  }
#line 659
  id = 0;
#line 659
  i2 = id;
#line 659
  i1 = i2;
  {
  {
#line 659
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 659
    if (i1 < (int )src1->nelem) {
#line 659
      if (! (i2 < (int )src2->nelem)) {
#line 659
        goto while_break;
      }
    } else {
#line 659
      goto while_break;
    }
#line 661
    if (*(src1->elems + i1) > *(src2->elems + i2)) {
#line 663
      i2 ++;
#line 664
      goto __Cont;
    }
#line 666
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
      {
      {
#line 668
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 668
        if (id < dest->nelem) {
#line 668
          if (! (*(dest->elems + id) < *(src2->elems + i2))) {
#line 668
            goto while_break___0;
          }
        } else {
#line 668
          goto while_break___0;
        }
#line 669
        id ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 670
      if (id < dest->nelem) {
#line 670
        if (*(dest->elems + id) == *(src2->elems + i2)) {
#line 671
          id ++;
        } else {
#line 670
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
        {
#line 674
        memmove((void *)((dest->elems + id) + 1), (void const   *)(dest->elems + id),
                (size_t )(sizeof(int ) * (unsigned long )(dest->nelem - id)));
        }
#line 676
        tmp___1 = id;
#line 676
        id ++;
#line 676
        tmp___2 = i2;
#line 676
        i2 ++;
#line 676
        *(dest->elems + tmp___1) = *(src2->elems + tmp___2);
#line 677
        (dest->nelem) ++;
        }
      }
    }
#line 680
    i1 ++;
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 682
  return ((reg_errcode_t )0);
}
}
#line 688 "regex_internal.c"
static reg_errcode_t re_node_set_init_union(re_node_set *dest , re_node_set const   *src1 ,
                                            re_node_set const   *src2 ) 
{ 
  int i1 ;
  int i2 ;
  int id ;
  void *tmp ;
  long tmp___0 ;
  reg_errcode_t tmp___1 ;
  reg_errcode_t tmp___2 ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_42 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 694
  if ((unsigned long )src1 != (unsigned long )((void *)0)) {
#line 694
    if (src1->nelem > 0) {
#line 694
      if ((unsigned long )src2 != (unsigned long )((void *)0)) {
#line 694
        if (src2->nelem > 0) {
          {
#line 696
          dest->alloc = (int )(src1->nelem + src2->nelem);
          {
#line 697
          tmp = malloc((size_t )((unsigned long )dest->alloc * sizeof(int )));
          }
#line 697
          dest->elems = (int *)tmp;
          {
#line 698
          tmp___0 = __builtin_expect((long )((unsigned long )dest->elems == (unsigned long )((void *)0)),
                                     0L);
          }
          }
#line 698
          if (tmp___0) {
#line 699
            return ((reg_errcode_t )12);
          }
        } else {
#line 694
          goto _L___3;
        }
      } else {
#line 694
        goto _L___3;
      }
    } else {
#line 694
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 703
    if ((unsigned long )src1 != (unsigned long )((void *)0)) {
#line 703
      if (src1->nelem > 0) {
        {
        {
#line 704
        tmp___1 = re_node_set_init_copy(dest, src1);
        }
        }
#line 704
        return (tmp___1);
      } else {
#line 703
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 705
    if ((unsigned long )src2 != (unsigned long )((void *)0)) {
#line 705
      if (src2->nelem > 0) {
        {
        {
#line 706
        tmp___2 = re_node_set_init_copy(dest, src2);
        }
        }
#line 706
        return (tmp___2);
      } else {
#line 705
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 708
    if (sizeof(re_node_set ) <= 16UL) {
#line 708
      if (sizeof(re_node_set ) == 1UL) {
#line 708
        __s___1 = (void *)dest;
#line 708
        *((__uint8_t *)__s___1) = (__uint8_t )'\000';
      } else {
#line 708
        __s___0 = (void *)dest;
#line 708
        __u = (union __anonunion___u_42 *)__s___0;
#line 708
        __c = (__uint8_t )'\000';
        {
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 15U) {
#line 708
          goto case_15;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 11U) {
#line 708
          goto case_11;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 7U) {
#line 708
          goto case_7;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 3U) {
#line 708
          goto case_3;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 14U) {
#line 708
          goto case_14;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 10U) {
#line 708
          goto case_10;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 6U) {
#line 708
          goto case_6;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 2U) {
#line 708
          goto case_2;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 13U) {
#line 708
          goto case_13;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 9U) {
#line 708
          goto case_9;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 5U) {
#line 708
          goto case_5;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 1U) {
#line 708
          goto case_1;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 16U) {
#line 708
          goto case_16;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 12U) {
#line 708
          goto case_12;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 8U) {
#line 708
          goto case_8;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 4U) {
#line 708
          goto case_4;
        }
#line 708
        if ((unsigned int )sizeof(re_node_set ) == 0U) {
#line 708
          goto case_0;
        }
#line 708
        goto switch_break;
        case_15: /* CIL Label */ 
#line 708
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 708
        __u = (union __anonunion___u_42 *)((void *)__u + 4);
        case_11: /* CIL Label */ 
#line 708
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 708
        __u = (union __anonunion___u_42 *)((void *)__u + 4);
        case_7: /* CIL Label */ 
#line 708
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 708
        __u = (union __anonunion___u_42 *)((void *)__u + 4);
        case_3: /* CIL Label */ 
#line 708
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 708
        __u = (union __anonunion___u_42 *)((void *)__u + 2);
#line 708
        __u->__uc = __c;
#line 708
        goto switch_break;
        case_14: /* CIL Label */ 
#line 708
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 708
        __u = (union __anonunion___u_42 *)((void *)__u + 4);
        case_10: /* CIL Label */ 
#line 708
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 708
        __u = (union __anonunion___u_42 *)((void *)__u + 4);
        case_6: /* CIL Label */ 
#line 708
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 708
        __u = (union __anonunion___u_42 *)((void *)__u + 4);
        case_2: /* CIL Label */ 
#line 708
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 708
        goto switch_break;
        case_13: /* CIL Label */ 
#line 708
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 708
        __u = (union __anonunion___u_42 *)((void *)__u + 4);
        case_9: /* CIL Label */ 
#line 708
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 708
        __u = (union __anonunion___u_42 *)((void *)__u + 4);
        case_5: /* CIL Label */ 
#line 708
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 708
        __u = (union __anonunion___u_42 *)((void *)__u + 4);
        case_1: /* CIL Label */ 
#line 708
        __u->__uc = __c;
#line 708
        goto switch_break;
        case_16: /* CIL Label */ 
#line 708
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 708
        __u = (union __anonunion___u_42 *)((void *)__u + 4);
        case_12: /* CIL Label */ 
#line 708
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 708
        __u = (union __anonunion___u_42 *)((void *)__u + 4);
        case_8: /* CIL Label */ 
#line 708
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 708
        __u = (union __anonunion___u_42 *)((void *)__u + 4);
        case_4: /* CIL Label */ 
#line 708
        __u->__ui = (unsigned int )((int )__c * 16843009);
        case_0: /* CIL Label */ 
#line 708
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 708
      __s = (void *)dest;
      {
#line 708
      __builtin_memset(__s, '\000', (int )sizeof(re_node_set ));
      }
      }
    }
#line 709
    return ((reg_errcode_t )0);
  }
#line 711
  id = 0;
#line 711
  i2 = id;
#line 711
  i1 = i2;
  {
  {
#line 711
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 711
    if (i1 < (int )src1->nelem) {
#line 711
      if (! (i2 < (int )src2->nelem)) {
#line 711
        goto while_break;
      }
    } else {
#line 711
      goto while_break;
    }
#line 713
    if (*(src1->elems + i1) > *(src2->elems + i2)) {
#line 715
      tmp___3 = id;
#line 715
      id ++;
#line 715
      tmp___4 = i2;
#line 715
      i2 ++;
#line 715
      *(dest->elems + tmp___3) = *(src2->elems + tmp___4);
#line 716
      goto __Cont;
    }
#line 718
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
#line 719
      i2 ++;
    }
#line 720
    tmp___5 = id;
#line 720
    id ++;
#line 720
    tmp___6 = i1;
#line 720
    i1 ++;
#line 720
    *(dest->elems + tmp___5) = *(src1->elems + tmp___6);
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 722
  if (i1 < (int )src1->nelem) {
    {
    {
#line 724
    memcpy((void */* __restrict  */)(dest->elems + id), (void const   */* __restrict  */)(src1->elems + i1),
           (size_t )((unsigned long )(src1->nelem - (int const   )i1) * sizeof(int )));
    }
#line 726
    id += (int )(src1->nelem - (int const   )i1);
    }
  } else
#line 728
  if (i2 < (int )src2->nelem) {
    {
    {
#line 730
    memcpy((void */* __restrict  */)(dest->elems + id), (void const   */* __restrict  */)(src2->elems + i2),
           (size_t )((unsigned long )(src2->nelem - (int const   )i2) * sizeof(int )));
    }
#line 732
    id += (int )(src2->nelem - (int const   )i2);
    }
  }
#line 734
  dest->nelem = id;
#line 735
  return ((reg_errcode_t )0);
}
}
#line 741 "regex_internal.c"
static reg_errcode_t re_node_set_merge(re_node_set *dest , re_node_set const   *src ) 
{ 
  int si ;
  int di ;
  int *new_buffer ;
  void *tmp ;
  long tmp___0 ;
  int cp_from ;
  int ncp ;
  int mid ;
  int right ;
  int src_elem ;

  {
#line 747
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 748
    return ((reg_errcode_t )0);
  } else
#line 747
  if (src->nelem == 0) {
#line 748
    return ((reg_errcode_t )0);
  }
#line 749
  if (dest->alloc < (int )(src->nelem + (int const   )dest->nelem)) {
    {
#line 752
    dest->alloc = 2 * (int )(src->nelem + (int const   )dest->alloc);
    {
#line 753
    tmp = realloc((void *)dest->elems, (size_t )((unsigned long )dest->alloc * sizeof(int )));
    }
#line 753
    new_buffer = (int *)tmp;
    {
#line 754
    tmp___0 = __builtin_expect((long )((unsigned long )new_buffer == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 754
    if (tmp___0) {
#line 755
      return ((reg_errcode_t )12);
    }
#line 756
    dest->elems = new_buffer;
  }
#line 759
  si = 0;
#line 759
  di = 0;
  {
  {
#line 759
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 759
    if (si < (int )src->nelem) {
#line 759
      if (! (di < dest->nelem)) {
#line 759
        goto while_break;
      }
    } else {
#line 759
      goto while_break;
    }
#line 761
    src_elem = *(src->elems + si);
#line 763
    right = dest->nelem;
    {
    {
#line 764
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 764
      if (! (di < right)) {
#line 764
        goto while_break___0;
      }
#line 766
      mid = (di + right) / 2;
#line 767
      if (*(dest->elems + mid) < src_elem) {
#line 768
        di = mid + 1;
      } else {
#line 770
        right = mid;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 772
    if (di >= dest->nelem) {
#line 773
      goto while_break;
    }
#line 775
    if (*(dest->elems + di) == src_elem) {
#line 778
      di ++;
#line 779
      si ++;
#line 780
      goto __Cont;
    }
#line 784
    cp_from = si;
    {
    {
#line 785
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 785
      if (si < (int )src->nelem) {
#line 785
        if (! (*(src->elems + si) < *(dest->elems + di))) {
#line 785
          goto while_break___1;
        }
      } else {
#line 785
        goto while_break___1;
      }
#line 786
      si ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 788
    ncp = si - cp_from;
    {
#line 789
    memmove((void *)((dest->elems + di) + ncp), (void const   *)(dest->elems + di),
            (size_t )(sizeof(int ) * (unsigned long )(dest->nelem - di)));
    }
    {
#line 791
    memcpy((void */* __restrict  */)(dest->elems + di), (void const   */* __restrict  */)(src->elems + cp_from),
           (size_t )(sizeof(int ) * (unsigned long )ncp));
    }
#line 794
    di += ncp;
#line 795
    dest->nelem += ncp;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 799
  if (si < (int )src->nelem) {
    {
    {
#line 801
    memcpy((void */* __restrict  */)(dest->elems + di), (void const   */* __restrict  */)(src->elems + si),
           (size_t )(sizeof(int ) * (unsigned long )(src->nelem - (int const   )si)));
    }
#line 803
    dest->nelem += (int )(src->nelem - (int const   )si);
    }
  }
#line 805
  return ((reg_errcode_t )0);
}
}
#line 812 "regex_internal.c"
static int re_node_set_insert(re_node_set *set , int elem ) 
{ 
  int idx ;
  int right ;
  int mid ;
  reg_errcode_t tmp ;
  long tmp___0 ;
  int *new_array ;
  void *tmp___1 ;
  long tmp___2 ;

  {
#line 819
  if ((unsigned long )set->elems == (unsigned long )((void *)0)) {
#line 819
    goto _L;
  } else
#line 819
  if (set->alloc == 0) {
    _L: /* CIL Label */ 
    {
    {
#line 821
    tmp = re_node_set_init_1(set, elem);
    }
    {
#line 821
    tmp___0 = __builtin_expect((long )((unsigned int )tmp == 0U), 1L);
    }
    }
#line 821
    if (tmp___0) {
#line 822
      return (1);
    } else {
#line 824
      return (-1);
    }
  }
#line 828
  idx = 0;
#line 829
  right = set->nelem;
  {
  {
#line 830
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 830
    if (! (idx < right)) {
#line 830
      goto while_break;
    }
#line 832
    mid = (idx + right) / 2;
#line 833
    if (*(set->elems + mid) < elem) {
#line 834
      idx = mid + 1;
    } else {
#line 836
      right = mid;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 840
  if (set->alloc < set->nelem + 1) {
    {
#line 843
    set->alloc *= 2;
    {
#line 844
    tmp___1 = malloc((size_t )((unsigned long )set->alloc * sizeof(int )));
    }
#line 844
    new_array = (int *)tmp___1;
    {
#line 845
    tmp___2 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 845
    if (tmp___2) {
#line 846
      return (-1);
    }
#line 848
    if (idx > 0) {
      {
      {
#line 849
      memcpy((void */* __restrict  */)new_array, (void const   */* __restrict  */)set->elems,
             (size_t )(sizeof(int ) * (unsigned long )idx));
      }
      }
    }
#line 851
    if (set->nelem - idx > 0) {
      {
      {
#line 852
      memcpy((void */* __restrict  */)((new_array + idx) + 1), (void const   */* __restrict  */)(set->elems + idx),
             (size_t )(sizeof(int ) * (unsigned long )(set->nelem - idx)));
      }
      }
    }
    {
    {
#line 854
    free((void *)set->elems);
    }
#line 855
    set->elems = new_array;
    }
  } else
#line 860
  if (set->nelem - idx > 0) {
    {
    {
#line 861
    memmove((void *)((set->elems + idx) + 1), (void const   *)(set->elems + idx),
            (size_t )(sizeof(int ) * (unsigned long )(set->nelem - idx)));
    }
    }
  }
#line 865
  *(set->elems + idx) = elem;
#line 866
  (set->nelem) ++;
#line 867
  return (1);
}
}
#line 873 "regex_internal.c"
static int re_node_set_compare(re_node_set const   *set1 , re_node_set const   *set2 ) 
{ 
  int i ;

  {
#line 878
  if ((unsigned long )set1 == (unsigned long )((void *)0)) {
#line 879
    return (0);
  } else
#line 878
  if ((unsigned long )set2 == (unsigned long )((void *)0)) {
#line 879
    return (0);
  } else
#line 878
  if (set1->nelem != set2->nelem) {
#line 879
    return (0);
  }
#line 880
  i = 0;
  {
  {
#line 880
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 880
    if (! (i < (int )set1->nelem)) {
#line 880
      goto while_break;
    }
#line 881
    if (*(set1->elems + i) != *(set2->elems + i)) {
#line 882
      return (0);
    }
#line 880
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 883
  return (1);
}
}
#line 888 "regex_internal.c"
static int re_node_set_contains(re_node_set const   *set , int elem ) 
{ 
  int idx ;
  int right ;
  int mid ;
  int tmp ;

  {
#line 894
  if (set->nelem <= 0) {
#line 895
    return (0);
  }
#line 898
  idx = 0;
#line 899
  right = (int )(set->nelem - 1);
  {
  {
#line 900
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 900
    if (! (idx < right)) {
#line 900
      goto while_break;
    }
#line 902
    mid = (idx + right) / 2;
#line 903
    if (*(set->elems + mid) < elem) {
#line 904
      idx = mid + 1;
    } else {
#line 906
      right = mid;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 908
  if (*(set->elems + idx) == elem) {
#line 908
    tmp = idx + 1;
  } else {
#line 908
    tmp = 0;
  }
#line 908
  return (tmp);
}
}
#line 911 "regex_internal.c"
static void re_node_set_remove_at(re_node_set *set , int idx ) 
{ 


  {
#line 916
  if (idx < 0) {
#line 917
    return;
  } else
#line 916
  if (idx >= set->nelem) {
#line 917
    return;
  }
#line 918
  if (idx < set->nelem - 1) {
    {
    {
#line 919
    memmove((void *)(set->elems + idx), (void const   *)((set->elems + idx) + 1),
            (size_t )(sizeof(int ) * (unsigned long )((set->nelem - idx) - 1)));
    }
    }
  }
#line 921
  (set->nelem) --;
#line 922
  return;
}
}
#line 928 "regex_internal.c"
static int re_dfa_add_node(re_dfa_t *dfa , re_token_t token , int mode ) 
{ 
  re_token_t *new_array ;
  void *tmp ;
  long tmp___0 ;
  int *new_nexts ;
  int *new_indices ;
  re_node_set *new_edests ;
  re_node_set *new_eclosures ;
  re_node_set *new_inveclosures ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;

  {
#line 934
  if (dfa->nodes_len >= dfa->nodes_alloc) {
    {
#line 937
    dfa->nodes_alloc *= 2;
    {
#line 938
    tmp = realloc((void *)dfa->nodes, (size_t )((unsigned long )dfa->nodes_alloc * sizeof(re_token_t )));
    }
#line 938
    new_array = (re_token_t *)tmp;
    {
#line 939
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 939
    if (tmp___0) {
#line 940
      return (-1);
    } else {
#line 942
      dfa->nodes = new_array;
    }
#line 943
    if (mode) {
      {
      {
#line 948
      tmp___1 = realloc((void *)dfa->nexts, (size_t )((unsigned long )dfa->nodes_alloc * sizeof(int )));
      }
#line 948
      new_nexts = (int *)tmp___1;
      {
#line 949
      tmp___2 = realloc((void *)dfa->org_indices, (size_t )((unsigned long )dfa->nodes_alloc * sizeof(int )));
      }
#line 949
      new_indices = (int *)tmp___2;
      {
#line 950
      tmp___3 = realloc((void *)dfa->edests, (size_t )((unsigned long )dfa->nodes_alloc * sizeof(re_node_set )));
      }
#line 950
      new_edests = (re_node_set *)tmp___3;
      {
#line 951
      tmp___4 = realloc((void *)dfa->eclosures, (size_t )((unsigned long )dfa->nodes_alloc * sizeof(re_node_set )));
      }
#line 951
      new_eclosures = (re_node_set *)tmp___4;
      {
#line 953
      tmp___5 = realloc((void *)dfa->inveclosures, (size_t )((unsigned long )dfa->nodes_alloc * sizeof(re_node_set )));
      }
#line 953
      new_inveclosures = (re_node_set *)tmp___5;
      }
#line 955
      if ((unsigned long )new_nexts == (unsigned long )((void *)0)) {
#line 955
        tmp___6 = 1;
      } else
#line 955
      if ((unsigned long )new_indices == (unsigned long )((void *)0)) {
#line 955
        tmp___6 = 1;
      } else
#line 955
      if ((unsigned long )new_edests == (unsigned long )((void *)0)) {
#line 955
        tmp___6 = 1;
      } else
#line 955
      if ((unsigned long )new_eclosures == (unsigned long )((void *)0)) {
#line 955
        tmp___6 = 1;
      } else
#line 955
      if ((unsigned long )new_inveclosures == (unsigned long )((void *)0)) {
#line 955
        tmp___6 = 1;
      } else {
#line 955
        tmp___6 = 0;
      }
      {
      {
#line 955
      tmp___7 = __builtin_expect((long )tmp___6, 0L);
      }
      }
#line 955
      if (tmp___7) {
#line 958
        return (-1);
      }
#line 959
      dfa->nexts = new_nexts;
#line 960
      dfa->org_indices = new_indices;
#line 961
      dfa->edests = new_edests;
#line 962
      dfa->eclosures = new_eclosures;
#line 963
      dfa->inveclosures = new_inveclosures;
    }
  }
#line 966
  *(dfa->nodes + dfa->nodes_len) = token;
#line 967
  (dfa->nodes + dfa->nodes_len)->duplicated = 0U;
#line 968
  (dfa->nodes + dfa->nodes_len)->constraint = 0U;
#line 969
  tmp___8 = dfa->nodes_len;
#line 969
  (dfa->nodes_len) ++;
#line 969
  return (tmp___8);
}
}
#line 972 "regex_internal.c"
__inline static unsigned int calc_state_hash(re_node_set const   *nodes , unsigned int context ) 
{ 
  unsigned int hash ;
  int i ;

  {
#line 977
  hash = (unsigned int )nodes->nelem + context;
#line 979
  i = 0;
  {
  {
#line 979
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 979
    if (! (i < (int )nodes->nelem)) {
#line 979
      goto while_break;
    }
#line 980
    hash += (unsigned int )*(nodes->elems + i);
#line 979
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 981
  return (hash);
}
}
#line 993 "regex_internal.c"
static re_dfastate_t *re_acquire_state(reg_errcode_t *err , re_dfa_t *dfa , re_node_set const   *nodes ) 
{ 
  unsigned int hash ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  int i ;
  long tmp ;
  re_dfastate_t *state ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  {
#line 1003
  tmp = __builtin_expect((long )(nodes->nelem == 0), 0L);
  }
  }
#line 1003
  if (tmp) {
#line 1005
    *err = (reg_errcode_t )0;
#line 1006
    return ((re_dfastate_t *)((void *)0));
  }
  {
  {
#line 1008
  hash = calc_state_hash(nodes, 0U);
  }
#line 1009
  spot = dfa->state_table + (hash & dfa->state_hash_mask);
#line 1011
  i = 0;
  }
  {
  {
#line 1011
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1011
    if (! (i < spot->num)) {
#line 1011
      goto while_break;
    }
#line 1013
    state = *(spot->array + i);
#line 1014
    if (hash != state->hash) {
#line 1015
      goto __Cont;
    }
    {
    {
#line 1016
    tmp___0 = re_node_set_compare((re_node_set const   *)(& state->nodes), nodes);
    }
    }
#line 1016
    if (tmp___0) {
#line 1017
      return (state);
    }
    __Cont: /* CIL Label */ 
#line 1011
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1021
  new_state = create_ci_newstate(dfa, nodes, hash);
  }
  {
#line 1022
  tmp___1 = __builtin_expect((long )((unsigned long )new_state != (unsigned long )((void *)0)),
                             1L);
  }
  }
#line 1022
  if (tmp___1) {
#line 1023
    return (new_state);
  } else {
#line 1026
    *err = (reg_errcode_t )12;
#line 1027
    return ((re_dfastate_t *)((void *)0));
  }
}
}
#line 1041 "regex_internal.c"
static re_dfastate_t *re_acquire_state_context(reg_errcode_t *err , re_dfa_t *dfa ,
                                               re_node_set const   *nodes , unsigned int context ) 
{ 
  unsigned int hash ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  int i ;
  re_dfastate_t *state ;
  int tmp ;
  long tmp___0 ;

  {
#line 1052
  if (nodes->nelem == 0) {
#line 1054
    *err = (reg_errcode_t )0;
#line 1055
    return ((re_dfastate_t *)((void *)0));
  }
  {
  {
#line 1057
  hash = calc_state_hash(nodes, context);
  }
#line 1058
  spot = dfa->state_table + (hash & dfa->state_hash_mask);
#line 1060
  i = 0;
  }
  {
  {
#line 1060
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1060
    if (! (i < spot->num)) {
#line 1060
      goto while_break;
    }
#line 1062
    state = *(spot->array + i);
#line 1063
    if (hash != state->hash) {
#line 1064
      goto __Cont;
    }
    {
    {
#line 1065
    tmp = re_node_set_compare((re_node_set const   *)state->entrance_nodes, nodes);
    }
    }
#line 1065
    if (tmp) {
#line 1065
      if (state->context == context) {
#line 1067
        return (state);
      }
    }
    __Cont: /* CIL Label */ 
#line 1060
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1070
  new_state = create_cd_newstate(dfa, nodes, context, hash);
  }
  {
#line 1071
  tmp___0 = __builtin_expect((long )((unsigned long )new_state != (unsigned long )((void *)0)),
                             1L);
  }
  }
#line 1071
  if (tmp___0) {
#line 1072
    return (new_state);
  } else {
#line 1075
    *err = (reg_errcode_t )12;
#line 1076
    return ((re_dfastate_t *)((void *)0));
  }
}
}
#line 1083 "regex_internal.c"
static re_dfastate_t *create_newstate_common(re_dfa_t *dfa , re_node_set const   *nodes ,
                                             unsigned int hash ) 
{ 
  re_dfastate_t *newstate ;
  reg_errcode_t err ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
  {
#line 1091
  tmp = calloc((size_t )sizeof(re_dfastate_t ), (size_t )1);
  }
#line 1091
  newstate = (re_dfastate_t *)tmp;
  {
#line 1092
  tmp___0 = __builtin_expect((long )((unsigned long )newstate == (unsigned long )((void *)0)),
                             0L);
  }
  }
#line 1092
  if (tmp___0) {
#line 1093
    return ((re_dfastate_t *)((void *)0));
  }
  {
  {
#line 1094
  err = re_node_set_init_copy(& newstate->nodes, nodes);
  }
  {
#line 1095
  tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 1095
  if (tmp___1) {
    {
    {
#line 1097
    free((void *)newstate);
    }
    }
#line 1098
    return ((re_dfastate_t *)((void *)0));
  }
#line 1100
  newstate->trtable = (struct re_dfastate_t **)((void *)0);
#line 1101
  newstate->trtable_search = (struct re_dfastate_t **)((void *)0);
#line 1102
  newstate->hash = hash;
#line 1103
  return (newstate);
}
}
#line 1109 "regex_internal.c"
static reg_errcode_t register_state(re_dfa_t *dfa , re_dfastate_t *newstate , unsigned int hash ) 
{ 
  struct re_state_table_entry *spot ;
  re_dfastate_t **new_array ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 1116
  spot = dfa->state_table + (hash & dfa->state_hash_mask);
#line 1118
  if (spot->alloc <= spot->num) {
    {
#line 1121
    spot->alloc = 2 * spot->num + 2;
    {
#line 1122
    tmp = realloc((void *)spot->array, (size_t )((unsigned long )spot->alloc * sizeof(re_dfastate_t *)));
    }
#line 1122
    new_array = (re_dfastate_t **)tmp;
    {
#line 1123
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 1123
    if (tmp___0) {
#line 1124
      return ((reg_errcode_t )12);
    }
#line 1125
    spot->array = new_array;
  }
#line 1127
  tmp___1 = spot->num;
#line 1127
  (spot->num) ++;
#line 1127
  *(spot->array + tmp___1) = newstate;
#line 1128
  return ((reg_errcode_t )0);
}
}
#line 1134 "regex_internal.c"
static re_dfastate_t *create_ci_newstate(re_dfa_t *dfa , re_node_set const   *nodes ,
                                         unsigned int hash ) 
{ 
  int i ;
  reg_errcode_t err ;
  re_dfastate_t *newstate ;
  long tmp ;
  re_token_t *node ;
  re_token_type_t type ;
  size_t tmp___0 ;
  long tmp___1 ;

  {
  {
  {
#line 1143
  newstate = create_newstate_common(dfa, nodes, hash);
  }
  {
#line 1144
  tmp = __builtin_expect((long )((unsigned long )newstate == (unsigned long )((void *)0)),
                         0L);
  }
  }
#line 1144
  if (tmp) {
#line 1145
    return ((re_dfastate_t *)((void *)0));
  }
#line 1146
  newstate->entrance_nodes = & newstate->nodes;
#line 1148
  i = 0;
  {
  {
#line 1148
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1148
    if (! (i < (int )nodes->nelem)) {
#line 1148
      goto while_break;
    }
#line 1150
    node = dfa->nodes + *(nodes->elems + i);
#line 1151
    type = node->type;
#line 1152
    if ((unsigned int )type == 26U) {
#line 1152
      if (! node->constraint) {
#line 1153
        goto __Cont;
      } else {
#line 1152
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1156
    if ((unsigned int )type == 27U) {
#line 1157
      newstate->halt = 1U;
    } else
#line 1159
    if ((unsigned int )type == 22U) {
#line 1161
      newstate->accept_mb = 1U;
    } else
#line 1159
    if ((unsigned int )type == 25U) {
      {
      {
#line 1159
      tmp___0 = __ctype_get_mb_cur_max();
      }
      }
#line 1159
      if (tmp___0 > 1U) {
#line 1161
        newstate->accept_mb = 1U;
      } else {
#line 1159
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1163
    if ((unsigned int )type == 32U) {
#line 1164
      newstate->has_backref = 1U;
    } else
#line 1165
    if ((unsigned int )type == 33U) {
#line 1166
      newstate->has_constraint = 1U;
    } else
#line 1165
    if (node->constraint) {
#line 1166
      newstate->has_constraint = 1U;
    }
    __Cont: /* CIL Label */ 
#line 1148
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1168
  err = register_state(dfa, newstate, hash);
  }
  {
#line 1169
  tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 1169
  if (tmp___1) {
    {
    {
#line 1171
    free_state(newstate);
    }
#line 1172
    newstate = (re_dfastate_t *)((void *)0);
    }
  }
#line 1174
  return (newstate);
}
}
#line 1180 "regex_internal.c"
static re_dfastate_t *create_cd_newstate(re_dfa_t *dfa , re_node_set const   *nodes ,
                                         unsigned int context , unsigned int hash ) 
{ 
  int i ;
  int nctx_nodes ;
  reg_errcode_t err ;
  re_dfastate_t *newstate ;
  long tmp ;
  unsigned int constraint ;
  re_token_t *node ;
  re_token_type_t type ;
  size_t tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 1186
  nctx_nodes = 0;
  {
#line 1190
  newstate = create_newstate_common(dfa, nodes, hash);
  }
  {
#line 1191
  tmp = __builtin_expect((long )((unsigned long )newstate == (unsigned long )((void *)0)),
                         0L);
  }
  }
#line 1191
  if (tmp) {
#line 1192
    return ((re_dfastate_t *)((void *)0));
  }
#line 1193
  newstate->context = context;
#line 1194
  newstate->entrance_nodes = & newstate->nodes;
#line 1196
  i = 0;
  {
  {
#line 1196
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1196
    if (! (i < (int )nodes->nelem)) {
#line 1196
      goto while_break;
    }
#line 1198
    constraint = 0U;
#line 1199
    node = dfa->nodes + *(nodes->elems + i);
#line 1200
    type = node->type;
#line 1201
    if (node->constraint) {
#line 1202
      constraint = node->constraint;
    }
#line 1204
    if ((unsigned int )type == 26U) {
#line 1204
      if (! constraint) {
#line 1205
        goto __Cont;
      } else {
#line 1204
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1207
    if ((unsigned int )type == 27U) {
#line 1208
      newstate->halt = 1U;
    } else
#line 1210
    if ((unsigned int )type == 22U) {
#line 1212
      newstate->accept_mb = 1U;
    } else
#line 1210
    if ((unsigned int )type == 25U) {
      {
      {
#line 1210
      tmp___0 = __ctype_get_mb_cur_max();
      }
      }
#line 1210
      if (tmp___0 > 1U) {
#line 1212
        newstate->accept_mb = 1U;
      } else {
#line 1210
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1214
    if ((unsigned int )type == 32U) {
#line 1215
      newstate->has_backref = 1U;
    } else
#line 1216
    if ((unsigned int )type == 33U) {
#line 1217
      constraint = (unsigned int )node->opr.ctx_type;
    }
#line 1219
    if (constraint) {
#line 1221
      if ((unsigned long )newstate->entrance_nodes == (unsigned long )(& newstate->nodes)) {
        {
        {
#line 1223
        tmp___1 = malloc((size_t )sizeof(re_node_set ));
        }
#line 1223
        newstate->entrance_nodes = (re_node_set *)tmp___1;
        {
#line 1224
        tmp___2 = __builtin_expect((long )((unsigned long )newstate->entrance_nodes == (unsigned long )((void *)0)),
                                   0L);
        }
        }
#line 1224
        if (tmp___2) {
          {
          {
#line 1226
          free_state(newstate);
          }
          }
#line 1227
          return ((re_dfastate_t *)((void *)0));
        }
        {
        {
#line 1229
        re_node_set_init_copy(newstate->entrance_nodes, nodes);
        }
#line 1230
        nctx_nodes = 0;
#line 1231
        newstate->has_constraint = 1U;
        }
      }
#line 1234
      if (constraint & 1U) {
#line 1234
        if (! (context & 1U)) {
          {
          {
#line 1236
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
          }
#line 1237
          nctx_nodes ++;
          }
        } else {
#line 1234
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 1234
      if (constraint & 2U) {
#line 1234
        if (context & 1U) {
          {
          {
#line 1236
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
          }
#line 1237
          nctx_nodes ++;
          }
        } else {
#line 1234
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 1234
      if (constraint & 16U) {
#line 1234
        if (! (context & (unsigned int )(1 << 1))) {
          {
          {
#line 1236
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
          }
#line 1237
          nctx_nodes ++;
          }
        } else {
#line 1234
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1234
      if (constraint & 64U) {
#line 1234
        if (! (context & (unsigned int )((1 << 1) << 1))) {
          {
          {
#line 1236
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
          }
#line 1237
          nctx_nodes ++;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1196
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1241
  err = register_state(dfa, newstate, hash);
  }
  {
#line 1242
  tmp___3 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 1242
  if (tmp___3) {
    {
    {
#line 1244
    free_state(newstate);
    }
#line 1245
    newstate = (re_dfastate_t *)((void *)0);
    }
  }
#line 1247
  return (newstate);
}
}
#line 1250 "regex_internal.c"
static void free_state(re_dfastate_t *state ) 
{ 


  {
#line 1254
  if ((unsigned long )state->entrance_nodes != (unsigned long )(& state->nodes)) {
    {
    {
#line 1256
    free((void *)(state->entrance_nodes)->elems);
    }
    {
#line 1257
    free((void *)state->entrance_nodes);
    }
    }
  }
  {
  {
#line 1259
  free((void *)state->nodes.elems);
  }
  {
#line 1260
  free((void *)state->trtable);
  }
  {
#line 1261
  free((void *)state->trtable_search);
  }
  {
#line 1262
  free((void *)state);
  }
  }
#line 1263
  return;
}
}
#line 21 "regcomp.c"
static reg_errcode_t re_compile_internal(regex_t *preg , char const   *pattern , int length ,
                                         reg_syntax_t syntax ) ;
#line 23
static void re_compile_fastmap_iter(regex_t *bufp , re_dfastate_t const   *init_state ,
                                    char *fastmap ) ;
#line 26
static reg_errcode_t init_dfa(re_dfa_t *dfa , int pat_len ) ;
#line 27
static reg_errcode_t init_word_char(re_dfa_t *dfa ) ;
#line 29
static void free_charset(re_charset_t *cset ) ;
#line 31
static void free_workarea_compile(regex_t *preg ) ;
#line 32
static reg_errcode_t create_initial_state(re_dfa_t *dfa ) ;
#line 33
static reg_errcode_t analyze(re_dfa_t *dfa ) ;
#line 34
static reg_errcode_t analyze_tree(re_dfa_t *dfa , bin_tree_t *node ) ;
#line 35
static void calc_first(re_dfa_t *dfa , bin_tree_t *node ) ;
#line 36
static void calc_next(re_dfa_t *dfa , bin_tree_t *node ) ;
#line 37
static void calc_epsdest(re_dfa_t *dfa , bin_tree_t *node ) ;
#line 38
static reg_errcode_t duplicate_node_closure(re_dfa_t *dfa , int top_org_node , int top_clone_node ,
                                            int root_node , unsigned int init_constraint ) ;
#line 41
static reg_errcode_t duplicate_node(int *new_idx , re_dfa_t *dfa , int org_idx , unsigned int constraint ) ;
#line 43
static int search_duplicated_node(re_dfa_t *dfa , int org_node , unsigned int constraint ) ;
#line 45
static reg_errcode_t calc_eclosure(re_dfa_t *dfa ) ;
#line 46
static reg_errcode_t calc_eclosure_iter(re_node_set *new_set , re_dfa_t *dfa , int node ,
                                        int root ) ;
#line 48
static void calc_inveclosure(re_dfa_t *dfa ) ;
#line 49
static int fetch_number(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) ;
#line 51
static re_token_t fetch_token(re_string_t *input , reg_syntax_t syntax ) ;
#line 52
static int peek_token(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) ;
#line 54
static int peek_token_bracket(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) ;
#line 56
static bin_tree_t *parse(re_string_t *regexp , regex_t *preg , reg_syntax_t syntax ,
                         reg_errcode_t *err ) ;
#line 58
static bin_tree_t *parse_reg_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , int nest , reg_errcode_t *err ) ;
#line 61
static bin_tree_t *parse_branch(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                reg_syntax_t syntax , int nest , reg_errcode_t *err ) ;
#line 64
static bin_tree_t *parse_expression(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , int nest , reg_errcode_t *err ) ;
#line 67
static bin_tree_t *parse_sub_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , int nest , reg_errcode_t *err ) ;
#line 70
static bin_tree_t *parse_dup_op(bin_tree_t *dup_elem , re_string_t *regexp , re_dfa_t *dfa ,
                                re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err ) ;
#line 73
static bin_tree_t *parse_bracket_exp(re_string_t *regexp , re_dfa_t *dfa , re_token_t *token ,
                                     reg_syntax_t syntax , reg_errcode_t *err ) ;
#line 76
static reg_errcode_t parse_bracket_element(bracket_elem_t *elem , re_string_t *regexp ,
                                           re_token_t *token , int token_len , re_dfa_t *dfa ,
                                           reg_syntax_t syntax ) ;
#line 81
static reg_errcode_t parse_bracket_symbol(bracket_elem_t *elem , re_string_t *regexp ,
                                          re_token_t *token ) ;
#line 86
static reg_errcode_t build_range_exp(re_bitset_ptr_t sbcset , re_charset_t *mbcset ,
                                     int *range_alloc , bracket_elem_t *start_elem ,
                                     bracket_elem_t *end_elem ) ;
#line 90
static reg_errcode_t build_collating_symbol(re_bitset_ptr_t sbcset , re_charset_t *mbcset ,
                                            int *coll_sym_alloc , unsigned char const   *name ) ;
#line 103
static reg_errcode_t build_equiv_class(re_bitset_ptr_t sbcset , re_charset_t *mbcset ,
                                       int *equiv_class_alloc , unsigned char const   *name ) ;
#line 107
static reg_errcode_t build_charclass(char *trans , re_bitset_ptr_t sbcset , re_charset_t *mbcset ,
                                     int *char_class_alloc , unsigned char const   *class_name ,
                                     reg_syntax_t syntax ) ;
#line 121
static bin_tree_t *build_charclass_op(re_dfa_t *dfa , char *trans , unsigned char const   *class_name ,
                                      unsigned char const   *extra , int not , reg_errcode_t *err ) ;
#line 125
static void free_bin_tree(bin_tree_t *tree ) ;
#line 126
static bin_tree_t *create_tree(bin_tree_t *left , bin_tree_t *right , re_token_type_t type ,
                               int index___0 ) ;
#line 128
static bin_tree_t *duplicate_tree(bin_tree_t const   *src , re_dfa_t *dfa ) ;
#line 135 "regcomp.c"
char const   __re_error_msgid[369]  = 
#line 135
  {      (char const   )'S',      (char const   )'u',      (char const   )'c',      (char const   )'c', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'\000', 
        (char const   )'N',      (char const   )'o',      (char const   )' ',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'\000',      (char const   )'I',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'l',      (char const   )'l', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'h',      (char const   )'a',      (char const   )'r', 
        (char const   )'a',      (char const   )'c',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'c',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'n',      (char const   )'a',      (char const   )'m',      (char const   )'e', 
        (char const   )'\000',      (char const   )'T',      (char const   )'r',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'b',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'s',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'h',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )'e',      (char const   )'n', 
        (char const   )'c',      (char const   )'e',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'[',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'[',      (char const   )'^', 
        (char const   )'\000',      (char const   )'U',      (char const   )'n',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'(', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'\\',      (char const   )'(',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'\\',      (char const   )'{',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'\\', 
        (char const   )'{',      (char const   )'\\',      (char const   )'}',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'g', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'M',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'r',      (char const   )'y', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'h', 
        (char const   )'a',      (char const   )'u',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )'\000',      (char const   )'I', 
        (char const   )'n',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'i',      (char const   )'d',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'e', 
        (char const   )'d',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'P',      (char const   )'r',      (char const   )'e',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'R',      (char const   )'e',      (char const   )'g',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )'o',      (char const   )' ',      (char const   )'b', 
        (char const   )'i',      (char const   )'g',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )')',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'\\',      (char const   )')', 
        (char const   )'\000'};
#line 189 "regcomp.c"
size_t const   __re_error_msgid_idx[17]  = 
#line 189
  {      (size_t const   )0,      (size_t const   )sizeof("Success"),      (size_t const   )(sizeof("Success") + sizeof("No match")),      (size_t const   )((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")), 
        (size_t const   )(((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")),      (size_t const   )((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")),      (size_t const   )(((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")),      (size_t const   )((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")), 
        (size_t const   )(((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")),      (size_t const   )((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")),      (size_t const   )(((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")),      (size_t const   )((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")), 
        (size_t const   )(((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")),      (size_t const   )((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")),      (size_t const   )(((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")),      (size_t const   )((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")), 
        (size_t const   )(((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")) + sizeof("Regular expression too big"))};
#line 219 "regcomp.c"
char const   *re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) 
{ 
  reg_errcode_t ret ;

  {
  {
#line 230
  bufp->no_sub = 0U;
#line 233
  bufp->newline_anchor = 1U;
  {
#line 235
  ret = re_compile_internal(bufp, pattern, (int )length, re_syntax_options);
  }
  }
#line 237
  if (! ret) {
#line 238
    return ((char const   *)((void *)0));
  }
#line 239
  return (__re_error_msgid + __re_error_msgid_idx[(int )ret]);
}
}
#line 260 "regcomp.c"
reg_syntax_t re_set_syntax(reg_syntax_t syntax ) 
{ 
  reg_syntax_t ret ;

  {
#line 264
  ret = re_syntax_options;
#line 266
  re_syntax_options = syntax;
#line 267
  return (ret);
}
}
#line 273 "regcomp.c"
int re_compile_fastmap(struct re_pattern_buffer *bufp ) 
{ 
  re_dfa_t *dfa ;
  char *fastmap ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_43 *__u ;
  __uint8_t __c ;
  void *__s___1 ;

  {
#line 277
  dfa = (re_dfa_t *)bufp->buffer;
#line 278
  fastmap = bufp->fastmap;
#line 280
  if (sizeof(char ) * 256UL <= 16UL) {
#line 280
    if (sizeof(char ) * 256UL == 1UL) {
#line 280
      __s___1 = (void *)fastmap;
#line 280
      *((__uint8_t *)__s___1) = (__uint8_t )'\000';
    } else {
#line 280
      __s___0 = (void *)fastmap;
#line 280
      __u = (union __anonunion___u_43 *)__s___0;
#line 280
      __c = (__uint8_t )'\000';
      {
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 15U) {
#line 280
        goto case_15;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 11U) {
#line 280
        goto case_11;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 7U) {
#line 280
        goto case_7;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 3U) {
#line 280
        goto case_3;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 14U) {
#line 280
        goto case_14;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 10U) {
#line 280
        goto case_10;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 6U) {
#line 280
        goto case_6;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 2U) {
#line 280
        goto case_2;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 13U) {
#line 280
        goto case_13;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 9U) {
#line 280
        goto case_9;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 5U) {
#line 280
        goto case_5;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 1U) {
#line 280
        goto case_1;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 16U) {
#line 280
        goto case_16;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 12U) {
#line 280
        goto case_12;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 8U) {
#line 280
        goto case_8;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 4U) {
#line 280
        goto case_4;
      }
#line 280
      if ((unsigned int )(sizeof(char ) * 256UL) == 0U) {
#line 280
        goto case_0;
      }
#line 280
      goto switch_break;
      case_15: /* CIL Label */ 
#line 280
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 280
      __u = (union __anonunion___u_43 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 280
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 280
      __u = (union __anonunion___u_43 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 280
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 280
      __u = (union __anonunion___u_43 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 280
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 280
      __u = (union __anonunion___u_43 *)((void *)__u + 2);
#line 280
      __u->__uc = __c;
#line 280
      goto switch_break;
      case_14: /* CIL Label */ 
#line 280
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 280
      __u = (union __anonunion___u_43 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 280
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 280
      __u = (union __anonunion___u_43 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 280
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 280
      __u = (union __anonunion___u_43 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 280
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 280
      goto switch_break;
      case_13: /* CIL Label */ 
#line 280
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 280
      __u = (union __anonunion___u_43 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 280
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 280
      __u = (union __anonunion___u_43 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 280
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 280
      __u = (union __anonunion___u_43 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 280
      __u->__uc = __c;
#line 280
      goto switch_break;
      case_16: /* CIL Label */ 
#line 280
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 280
      __u = (union __anonunion___u_43 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 280
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 280
      __u = (union __anonunion___u_43 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 280
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 280
      __u = (union __anonunion___u_43 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 280
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 280
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 280
    __s = (void *)fastmap;
    {
#line 280
    __builtin_memset(__s, '\000', (int )(sizeof(char ) * 256UL));
    }
    }
  }
  {
  {
#line 281
  re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state, fastmap);
  }
  }
#line 282
  if ((unsigned long )dfa->init_state != (unsigned long )dfa->init_state_word) {
    {
    {
#line 283
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_word, fastmap);
    }
    }
  }
#line 284
  if ((unsigned long )dfa->init_state != (unsigned long )dfa->init_state_nl) {
    {
    {
#line 285
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_nl, fastmap);
    }
    }
  }
#line 286
  if ((unsigned long )dfa->init_state != (unsigned long )dfa->init_state_begbuf) {
    {
    {
#line 287
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_begbuf,
                            fastmap);
    }
    }
  }
#line 288
  bufp->fastmap_accurate = 1U;
#line 289
  return (0);
}
}
#line 295 "regcomp.c"
__inline static void ( __attribute__((__always_inline__)) re_set_fastmap)(char *fastmap ,
                                                                          int icase ,
                                                                          int ch ) 
{ 
  int __res ;
  __int32_t const   **tmp___0 ;

  {
#line 299
  *(fastmap + ch) = (char)1;
#line 300
  if (icase) {
#line 301
    if (sizeof(ch) > 1UL) {
      {
      {
#line 301
      __res = tolower(ch);
      }
      }
    } else {
      {
      {
#line 301
      tmp___0 = __ctype_tolower_loc();
      }
#line 301
      __res = (int )*(*tmp___0 + ch);
      }
    }
#line 301
    *(fastmap + __res) = (char)1;
  }
#line 302
  return;
}
}
#line 307 "regcomp.c"
static void re_compile_fastmap_iter(regex_t *bufp , re_dfastate_t const   *init_state ,
                                    char *fastmap ) 
{ 
  re_dfa_t *dfa ;
  int node_cnt ;
  int icase ;
  size_t tmp ;
  int tmp___0 ;
  int node ;
  re_token_type_t type ;
  int i ;
  int j ;
  int ch ;
  int i___0 ;
  re_charset_t *cset ;
  wint_t tmp___1 ;
  size_t tmp___2 ;
  char buf[256] ;
  mbstate_t state ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_44 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  void *__s___3 ;
  union __anonunion___u_45 *__u___0 ;
  __uint8_t __c___0 ;
  void *__s___4 ;
  void *__cil_tmp30 ;

  {
  {
#line 313
  dfa = (re_dfa_t *)bufp->buffer;
  {
#line 315
  tmp = __ctype_get_mb_cur_max();
  }
  }
#line 315
  if (tmp == 1U) {
#line 315
    if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 315
      tmp___0 = 1;
    } else {
#line 315
      tmp___0 = 0;
    }
  } else {
#line 315
    tmp___0 = 0;
  }
#line 315
  icase = tmp___0;
#line 316
  node_cnt = 0;
  {
  {
#line 316
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 316
    if (! (node_cnt < (int )init_state->nodes.nelem)) {
#line 316
      goto while_break;
    }
#line 318
    node = *(init_state->nodes.elems + node_cnt);
#line 319
    type = (dfa->nodes + node)->type;
#line 321
    if ((unsigned int )type == 26U) {
      {
      {
#line 322
      re_set_fastmap(fastmap, icase, (int )(dfa->nodes + node)->opr.c);
      }
      }
    } else
#line 323
    if ((unsigned int )type == 21U) {
#line 326
      i = 0;
#line 326
      ch = 0;
      {
      {
#line 326
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 326
        if (! ((unsigned long )i < ((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) {
#line 326
          goto while_break___0;
        }
#line 327
        j = 0;
        {
        {
#line 327
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 327
          if (! ((unsigned long )j < sizeof(unsigned int ) * 8UL)) {
#line 327
            goto while_break___1;
          }
#line 328
          if (*((dfa->nodes + node)->opr.sbcset + i) & (unsigned int )(1 << j)) {
            {
            {
#line 329
            re_set_fastmap(fastmap, icase, ch);
            }
            }
          }
#line 327
          j ++;
#line 327
          ch ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 326
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 332
    if ((unsigned int )type == 22U) {
#line 335
      cset = (dfa->nodes + node)->opr.mbcset;
#line 336
      if (cset->non_match) {
#line 336
        goto _L;
      } else
#line 336
      if (cset->ncoll_syms) {
#line 336
        goto _L;
      } else
#line 336
      if (cset->nequiv_classes) {
#line 336
        goto _L;
      } else
#line 336
      if (cset->nranges) {
#line 336
        goto _L;
      } else
#line 336
      if (cset->nchar_classes) {
        _L: /* CIL Label */ 
        {
        {
#line 357
        tmp___2 = __ctype_get_mb_cur_max();
        }
        }
#line 357
        if (tmp___2 > 1U) {
#line 358
          i___0 = 0;
          {
          {
#line 358
          while (1) {
            while_continue___7: /* CIL Label */ ;
            while_continue___2: /* CIL Label */ ;
#line 358
            if (! (i___0 < 256)) {
#line 358
              goto while_break___2;
            }
            {
            {
#line 359
            tmp___1 = btowc(i___0);
            }
            }
#line 359
            if (tmp___1 == 4294967295U) {
              {
              {
#line 360
              re_set_fastmap(fastmap, icase, i___0);
              }
              }
            }
#line 358
            i___0 ++;
          }
          while_break___7: /* CIL Label */ ;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
#line 363
      i___0 = 0;
      {
      {
#line 363
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 363
        if (! (i___0 < cset->nmbchars)) {
#line 363
          goto while_break___3;
        }
#line 367
        if (sizeof(state) <= 16UL) {
#line 367
          if (sizeof(state) == 1UL) {
#line 367
            __s___1 = (void *)(& state);
#line 367
            *((__uint8_t *)__s___1) = (__uint8_t )'\000';
          } else {
#line 367
            __s___0 = (void *)(& state);
#line 367
            __u = (union __anonunion___u_44 *)__s___0;
#line 367
            __c = (__uint8_t )'\000';
            {
#line 367
            if ((unsigned int )sizeof(state) == 15U) {
#line 367
              goto case_15;
            }
#line 367
            if ((unsigned int )sizeof(state) == 11U) {
#line 367
              goto case_11;
            }
#line 367
            if ((unsigned int )sizeof(state) == 7U) {
#line 367
              goto case_7;
            }
#line 367
            if ((unsigned int )sizeof(state) == 3U) {
#line 367
              goto case_3;
            }
#line 367
            if ((unsigned int )sizeof(state) == 14U) {
#line 367
              goto case_14;
            }
#line 367
            if ((unsigned int )sizeof(state) == 10U) {
#line 367
              goto case_10;
            }
#line 367
            if ((unsigned int )sizeof(state) == 6U) {
#line 367
              goto case_6;
            }
#line 367
            if ((unsigned int )sizeof(state) == 2U) {
#line 367
              goto case_2;
            }
#line 367
            if ((unsigned int )sizeof(state) == 13U) {
#line 367
              goto case_13;
            }
#line 367
            if ((unsigned int )sizeof(state) == 9U) {
#line 367
              goto case_9;
            }
#line 367
            if ((unsigned int )sizeof(state) == 5U) {
#line 367
              goto case_5;
            }
#line 367
            if ((unsigned int )sizeof(state) == 1U) {
#line 367
              goto case_1;
            }
#line 367
            if ((unsigned int )sizeof(state) == 16U) {
#line 367
              goto case_16;
            }
#line 367
            if ((unsigned int )sizeof(state) == 12U) {
#line 367
              goto case_12;
            }
#line 367
            if ((unsigned int )sizeof(state) == 8U) {
#line 367
              goto case_8;
            }
#line 367
            if ((unsigned int )sizeof(state) == 4U) {
#line 367
              goto case_4;
            }
#line 367
            if ((unsigned int )sizeof(state) == 0U) {
#line 367
              goto case_0;
            }
#line 367
            goto switch_break;
            case_15: /* CIL Label */ 
#line 367
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 367
            __u = (union __anonunion___u_44 *)((void *)__u + 4);
            case_11: /* CIL Label */ 
#line 367
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 367
            __u = (union __anonunion___u_44 *)((void *)__u + 4);
            case_7: /* CIL Label */ 
#line 367
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 367
            __u = (union __anonunion___u_44 *)((void *)__u + 4);
            case_3: /* CIL Label */ 
#line 367
            __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 367
            __u = (union __anonunion___u_44 *)((void *)__u + 2);
#line 367
            __u->__uc = __c;
#line 367
            goto switch_break;
            case_14: /* CIL Label */ 
#line 367
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 367
            __u = (union __anonunion___u_44 *)((void *)__u + 4);
            case_10: /* CIL Label */ 
#line 367
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 367
            __u = (union __anonunion___u_44 *)((void *)__u + 4);
            case_6: /* CIL Label */ 
#line 367
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 367
            __u = (union __anonunion___u_44 *)((void *)__u + 4);
            case_2: /* CIL Label */ 
#line 367
            __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 367
            goto switch_break;
            case_13: /* CIL Label */ 
#line 367
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 367
            __u = (union __anonunion___u_44 *)((void *)__u + 4);
            case_9: /* CIL Label */ 
#line 367
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 367
            __u = (union __anonunion___u_44 *)((void *)__u + 4);
            case_5: /* CIL Label */ 
#line 367
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 367
            __u = (union __anonunion___u_44 *)((void *)__u + 4);
            case_1: /* CIL Label */ 
#line 367
            __u->__uc = __c;
#line 367
            goto switch_break;
            case_16: /* CIL Label */ 
#line 367
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 367
            __u = (union __anonunion___u_44 *)((void *)__u + 4);
            case_12: /* CIL Label */ 
#line 367
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 367
            __u = (union __anonunion___u_44 *)((void *)__u + 4);
            case_8: /* CIL Label */ 
#line 367
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 367
            __u = (union __anonunion___u_44 *)((void *)__u + 4);
            case_4: /* CIL Label */ 
#line 367
            __u->__ui = (unsigned int )((int )__c * 16843009);
            case_0: /* CIL Label */ 
#line 367
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          }
        } else {
          {
#line 367
          __s = (void *)(& state);
          {
#line 367
          __builtin_memset(__s, '\000', (int )sizeof(state));
          }
          }
        }
        {
        {
#line 368
        wcrtomb((char */* __restrict  */)(buf), *(cset->mbchars + i___0), (mbstate_t */* __restrict  */)(& state));
        }
        {
#line 369
        re_set_fastmap(fastmap, icase, (int )*((unsigned char *)(buf)));
        }
#line 363
        i___0 ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else
#line 373
    if ((unsigned int )type == 27U) {
#line 373
      goto _L___0;
    } else
#line 373
    if ((unsigned int )type == 25U) {
      _L___0: /* CIL Label */ 
#line 375
      if (sizeof(char ) * 256UL <= 16UL) {
#line 375
        if (sizeof(char ) * 256UL == 1UL) {
#line 375
          __s___4 = (void *)fastmap;
#line 375
          *((__uint8_t *)__s___4) = (__uint8_t )'\001';
        } else {
#line 375
          __s___3 = (void *)fastmap;
#line 375
          __u___0 = (union __anonunion___u_45 *)__s___3;
#line 375
          __c___0 = (__uint8_t )'\001';
          {
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 15U) {
#line 375
            goto case_15___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 11U) {
#line 375
            goto case_11___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 7U) {
#line 375
            goto case_7___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 3U) {
#line 375
            goto case_3___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 14U) {
#line 375
            goto case_14___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 10U) {
#line 375
            goto case_10___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 6U) {
#line 375
            goto case_6___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 2U) {
#line 375
            goto case_2___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 13U) {
#line 375
            goto case_13___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 9U) {
#line 375
            goto case_9___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 5U) {
#line 375
            goto case_5___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 1U) {
#line 375
            goto case_1___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 16U) {
#line 375
            goto case_16___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 12U) {
#line 375
            goto case_12___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 8U) {
#line 375
            goto case_8___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 4U) {
#line 375
            goto case_4___0;
          }
#line 375
          if ((unsigned int )(sizeof(char ) * 256UL) == 0U) {
#line 375
            goto case_0___0;
          }
#line 375
          goto switch_break___0;
          case_15___0: /* CIL Label */ 
#line 375
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 375
          __u___0 = (union __anonunion___u_45 *)((void *)__u___0 + 4);
          case_11___0: /* CIL Label */ 
#line 375
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 375
          __u___0 = (union __anonunion___u_45 *)((void *)__u___0 + 4);
          case_7___0: /* CIL Label */ 
#line 375
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 375
          __u___0 = (union __anonunion___u_45 *)((void *)__u___0 + 4);
          case_3___0: /* CIL Label */ 
#line 375
          __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 375
          __u___0 = (union __anonunion___u_45 *)((void *)__u___0 + 2);
#line 375
          __u___0->__uc = __c___0;
#line 375
          goto switch_break___0;
          case_14___0: /* CIL Label */ 
#line 375
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 375
          __u___0 = (union __anonunion___u_45 *)((void *)__u___0 + 4);
          case_10___0: /* CIL Label */ 
#line 375
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 375
          __u___0 = (union __anonunion___u_45 *)((void *)__u___0 + 4);
          case_6___0: /* CIL Label */ 
#line 375
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 375
          __u___0 = (union __anonunion___u_45 *)((void *)__u___0 + 4);
          case_2___0: /* CIL Label */ 
#line 375
          __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 375
          goto switch_break___0;
          case_13___0: /* CIL Label */ 
#line 375
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 375
          __u___0 = (union __anonunion___u_45 *)((void *)__u___0 + 4);
          case_9___0: /* CIL Label */ 
#line 375
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 375
          __u___0 = (union __anonunion___u_45 *)((void *)__u___0 + 4);
          case_5___0: /* CIL Label */ 
#line 375
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 375
          __u___0 = (union __anonunion___u_45 *)((void *)__u___0 + 4);
          case_1___0: /* CIL Label */ 
#line 375
          __u___0->__uc = __c___0;
#line 375
          goto switch_break___0;
          case_16___0: /* CIL Label */ 
#line 375
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 375
          __u___0 = (union __anonunion___u_45 *)((void *)__u___0 + 4);
          case_12___0: /* CIL Label */ 
#line 375
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 375
          __u___0 = (union __anonunion___u_45 *)((void *)__u___0 + 4);
          case_8___0: /* CIL Label */ 
#line 375
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 375
          __u___0 = (union __anonunion___u_45 *)((void *)__u___0 + 4);
          case_4___0: /* CIL Label */ 
#line 375
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
          case_0___0: /* CIL Label */ 
#line 375
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        }
      } else {
        {
        {
#line 375
        memset((void *)fastmap, '\001', (size_t )(sizeof(char ) * 256UL));
        }
        }
      }
#line 376
      if ((unsigned int )type == 27U) {
#line 377
        bufp->can_be_null = 1U;
      }
#line 378
      return;
    }
#line 316
    node_cnt ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  return;
}
}
#line 419 "regcomp.c"
int regcomp(regex_t * __restrict  preg , char const   * __restrict  pattern , int cflags ) 
{ 
  reg_errcode_t ret ;
  reg_syntax_t syntax ;
  unsigned long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
#line 426
  if (cflags & 1) {
#line 426
    tmp = ((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
#line 426
    tmp = ((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1);
  }
  {
#line 426
  syntax = tmp;
#line 429
  preg->buffer = (unsigned char *)((void *)0);
#line 430
  preg->allocated = 0UL;
#line 431
  preg->used = 0UL;
  {
#line 434
  tmp___0 = malloc((size_t )(256UL * sizeof(char )));
  }
#line 434
  preg->fastmap = (char *)tmp___0;
  {
#line 435
  tmp___1 = __builtin_expect((long )((unsigned long )preg->fastmap == (unsigned long )((void *)0)),
                             0L);
  }
  }
#line 435
  if (tmp___1) {
#line 436
    return (12);
  }
#line 438
  if (cflags & (1 << 1)) {
#line 438
    tmp___2 = (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  } else {
#line 438
    tmp___2 = 0UL;
  }
#line 438
  syntax |= tmp___2;
#line 441
  if (cflags & ((1 << 1) << 1)) {
#line 443
    syntax &= ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1);
#line 444
    syntax |= (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
#line 446
    preg->newline_anchor = 1U;
  } else {
#line 449
    preg->newline_anchor = 0U;
  }
  {
#line 450
  preg->no_sub = (unsigned int )(! (! (cflags & (((1 << 1) << 1) << 1))));
#line 451
  preg->translate = (char *)((void *)0);
  {
#line 453
  tmp___3 = strlen((char const   *)pattern);
  }
  {
#line 453
  ret = re_compile_internal((regex_t *)preg, (char const   *)pattern, (int )tmp___3,
                            syntax);
  }
  }
#line 457
  if ((unsigned int )ret == 16U) {
#line 458
    ret = (reg_errcode_t )8;
  }
  {
  {
#line 461
  tmp___4 = __builtin_expect((long )((unsigned int )ret == 0U), 1L);
  }
  }
#line 461
  if (tmp___4) {
    {
    {
#line 464
    re_compile_fastmap((struct re_pattern_buffer *)preg);
    }
    }
  } else {
    {
    {
#line 468
    free((void *)preg->fastmap);
    }
#line 469
    preg->fastmap = (char *)((void *)0);
    }
  }
#line 472
  return ((int )ret);
}
}
#line 509
extern int ( /* missing proto */  mempcpy)() ;
#line 481 "regcomp.c"
size_t regerror(int errcode , regex_t const   *preg , char *errbuf , size_t errbuf_size ) 
{ 
  char const   *msg ;
  size_t msg_size ;
  int tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 491
  if (errcode < 0) {
#line 491
    tmp = 1;
  } else
#line 491
  if (errcode >= (int )(sizeof(__re_error_msgid_idx) / sizeof(__re_error_msgid_idx[0]))) {
#line 491
    tmp = 1;
  } else {
#line 491
    tmp = 0;
  }
  {
  {
#line 491
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
  }
#line 491
  if (tmp___0) {
    {
    {
#line 498
    abort();
    }
    }
  }
  {
#line 500
  msg = __re_error_msgid + __re_error_msgid_idx[errcode];
  {
#line 502
  tmp___1 = strlen(msg);
  }
#line 502
  msg_size = tmp___1 + 1U;
  {
#line 504
  tmp___4 = __builtin_expect((long )(errbuf_size != 0U), 1L);
  }
  }
#line 504
  if (tmp___4) {
    {
    {
#line 506
    tmp___3 = __builtin_expect((long )(msg_size > errbuf_size), 0L);
    }
    }
#line 506
    if (tmp___3) {
      {
      {
#line 509
      tmp___2 = mempcpy(errbuf, msg, errbuf_size - 1U);
      }
#line 509
      *((char *)tmp___2) = (char )'\000';
      }
    } else {
      {
      {
#line 516
      memcpy((void */* __restrict  */)errbuf, (void const   */* __restrict  */)msg,
             msg_size);
      }
      }
    }
  }
#line 519
  return (msg_size);
}
}
#line 526 "regcomp.c"
static void free_dfa_content(re_dfa_t *dfa ) 
{ 
  int i ;
  int j ;
  re_token_t *node ;
  struct re_state_table_entry *entry ;
  re_dfastate_t *state ;

  {
  {
  {
#line 531
  free((void *)dfa->subexps);
  }
#line 533
  i = 0;
  }
  {
  {
#line 533
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 533
    if (! (i < dfa->nodes_len)) {
#line 533
      goto while_break;
    }
#line 535
    node = dfa->nodes + i;
#line 537
    if ((unsigned int )node->type == 22U) {
#line 537
      if (node->duplicated == 0U) {
        {
        {
#line 538
        free_charset(node->opr.mbcset);
        }
        }
      } else {
#line 537
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 541
    if ((unsigned int )node->type == 21U) {
#line 541
      if (node->duplicated == 0U) {
        {
        {
#line 542
        free((void *)node->opr.sbcset);
        }
        }
      }
    }
#line 533
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 544
  free((void *)dfa->nexts);
  }
#line 545
  i = 0;
  }
  {
  {
#line 545
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 545
    if (! (i < dfa->nodes_len)) {
#line 545
      goto while_break___0;
    }
#line 547
    if ((unsigned long )dfa->eclosures != (unsigned long )((void *)0)) {
      {
      {
#line 548
      free((void *)(dfa->eclosures + i)->elems);
      }
      }
    }
#line 549
    if ((unsigned long )dfa->inveclosures != (unsigned long )((void *)0)) {
      {
      {
#line 550
      free((void *)(dfa->inveclosures + i)->elems);
      }
      }
    }
#line 551
    if ((unsigned long )dfa->edests != (unsigned long )((void *)0)) {
      {
      {
#line 552
      free((void *)(dfa->edests + i)->elems);
      }
      }
    }
#line 545
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 554
  free((void *)dfa->edests);
  }
  {
#line 555
  free((void *)dfa->eclosures);
  }
  {
#line 556
  free((void *)dfa->inveclosures);
  }
  {
#line 557
  free((void *)dfa->nodes);
  }
#line 559
  i = 0;
  }
  {
  {
#line 559
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 559
    if (! ((unsigned int )i <= dfa->state_hash_mask)) {
#line 559
      goto while_break___1;
    }
#line 561
    entry = dfa->state_table + i;
#line 562
    j = 0;
    {
    {
#line 562
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 562
      if (! (j < entry->num)) {
#line 562
        goto while_break___2;
      }
      {
#line 564
      state = *(entry->array + j);
      {
#line 565
      free_state(state);
      }
#line 562
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    {
#line 567
    free((void *)entry->array);
    }
#line 559
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 569
  free((void *)dfa->state_table);
  }
  }
#line 571
  if ((unsigned long )dfa->word_char != (unsigned long )((void *)0)) {
    {
    {
#line 572
    free((void *)dfa->word_char);
    }
    }
  }
  {
  {
#line 577
  free((void *)dfa);
  }
  }
#line 578
  return;
}
}
#line 583 "regcomp.c"
void regfree(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;
  long tmp ;

  {
  {
#line 587
  dfa = (re_dfa_t *)preg->buffer;
  {
#line 588
  tmp = __builtin_expect((long )((unsigned long )dfa != (unsigned long )((void *)0)),
                         1L);
  }
  }
#line 588
  if (tmp) {
    {
    {
#line 589
    free_dfa_content(dfa);
    }
    }
  }
  {
  {
#line 591
  free((void *)preg->fastmap);
  }
  }
#line 592
  return;
}
}
#line 670 "regcomp.c"
static reg_errcode_t re_compile_internal(regex_t *preg , char const   *pattern , int length ,
                                         reg_syntax_t syntax ) 
{ 
  reg_errcode_t err ;
  re_dfa_t *dfa ;
  re_string_t regexp ;
  unsigned int tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
#line 677
  err = (reg_errcode_t )0;
#line 682
  preg->fastmap_accurate = 0U;
#line 683
  preg->syntax = syntax;
#line 684
  tmp = 0U;
#line 684
  preg->not_eol = tmp;
#line 684
  preg->not_bol = tmp;
#line 685
  preg->used = 0UL;
#line 686
  preg->re_nsub = (size_t )0;
#line 687
  preg->can_be_null = 0U;
#line 688
  preg->regs_allocated = 0U;
#line 691
  dfa = (re_dfa_t *)preg->buffer;
#line 692
  if (preg->allocated < sizeof(re_dfa_t )) {
    {
    {
#line 698
    tmp___0 = realloc((void *)preg->buffer, (size_t )sizeof(re_dfa_t ));
    }
#line 698
    dfa = (re_dfa_t *)tmp___0;
    }
#line 699
    if ((unsigned long )dfa == (unsigned long )((void *)0)) {
#line 700
      return ((reg_errcode_t )12);
    }
#line 701
    preg->allocated = sizeof(re_dfa_t );
  }
  {
#line 703
  preg->buffer = (unsigned char *)dfa;
#line 704
  preg->used = sizeof(re_dfa_t );
  {
#line 706
  err = init_dfa(dfa, length);
  }
  {
#line 707
  tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 707
  if (tmp___1) {
    {
    {
#line 709
    free((void *)dfa);
    }
#line 710
    preg->buffer = (unsigned char *)((void *)0);
#line 711
    preg->allocated = 0UL;
    }
#line 712
    return (err);
  }
  {
  {
#line 719
  err = re_string_construct(& regexp, pattern, length, preg->translate, (int )(syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
  }
  {
#line 721
  tmp___2 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 721
  if (tmp___2) {
    {
    {
#line 723
    free((void *)dfa);
    }
#line 724
    preg->buffer = (unsigned char *)((void *)0);
#line 725
    preg->allocated = 0UL;
    }
#line 726
    return (err);
  }
  {
#line 730
  preg->re_nsub = (size_t )0;
  {
#line 731
  dfa->str_tree = parse(& regexp, preg, syntax, & err);
  }
  {
#line 732
  tmp___3 = __builtin_expect((long )((unsigned long )dfa->str_tree == (unsigned long )((void *)0)),
                             0L);
  }
  }
#line 732
  if (tmp___3) {
#line 733
    goto re_compile_internal_free_return;
  }
  {
  {
#line 737
  err = analyze(dfa);
  }
  {
#line 738
  tmp___4 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 738
  if (tmp___4) {
#line 739
    goto re_compile_internal_free_return;
  }
  {
  {
#line 742
  err = create_initial_state(dfa);
  }
  {
#line 745
  free_workarea_compile(preg);
  }
  {
#line 746
  re_string_destruct(& regexp);
  }
  {
#line 748
  tmp___5 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 748
  if (tmp___5) {
    re_compile_internal_free_return: 
    {
    {
#line 751
    free_dfa_content(dfa);
    }
#line 752
    preg->buffer = (unsigned char *)((void *)0);
#line 753
    preg->allocated = 0UL;
    }
  }
#line 756
  return (err);
}
}
#line 762 "regcomp.c"
static reg_errcode_t init_dfa(re_dfa_t *dfa , int pat_len ) 
{ 
  int table_size ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_46 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 769
  if (sizeof(re_dfa_t ) <= 16UL) {
#line 769
    if (sizeof(re_dfa_t ) == 1UL) {
#line 769
      __s___1 = (void *)dfa;
#line 769
      *((__uint8_t *)__s___1) = (__uint8_t )'\000';
    } else {
#line 769
      __s___0 = (void *)dfa;
#line 769
      __u = (union __anonunion___u_46 *)__s___0;
#line 769
      __c = (__uint8_t )'\000';
      {
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 15U) {
#line 769
        goto case_15;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 11U) {
#line 769
        goto case_11;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 7U) {
#line 769
        goto case_7;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 3U) {
#line 769
        goto case_3;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 14U) {
#line 769
        goto case_14;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 10U) {
#line 769
        goto case_10;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 6U) {
#line 769
        goto case_6;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 2U) {
#line 769
        goto case_2;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 13U) {
#line 769
        goto case_13;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 9U) {
#line 769
        goto case_9;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 5U) {
#line 769
        goto case_5;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 1U) {
#line 769
        goto case_1;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 16U) {
#line 769
        goto case_16;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 12U) {
#line 769
        goto case_12;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 8U) {
#line 769
        goto case_8;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 4U) {
#line 769
        goto case_4;
      }
#line 769
      if ((unsigned int )sizeof(re_dfa_t ) == 0U) {
#line 769
        goto case_0;
      }
#line 769
      goto switch_break;
      case_15: /* CIL Label */ 
#line 769
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 769
      __u = (union __anonunion___u_46 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 769
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 769
      __u = (union __anonunion___u_46 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 769
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 769
      __u = (union __anonunion___u_46 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 769
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 769
      __u = (union __anonunion___u_46 *)((void *)__u + 2);
#line 769
      __u->__uc = __c;
#line 769
      goto switch_break;
      case_14: /* CIL Label */ 
#line 769
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 769
      __u = (union __anonunion___u_46 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 769
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 769
      __u = (union __anonunion___u_46 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 769
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 769
      __u = (union __anonunion___u_46 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 769
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 769
      goto switch_break;
      case_13: /* CIL Label */ 
#line 769
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 769
      __u = (union __anonunion___u_46 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 769
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 769
      __u = (union __anonunion___u_46 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 769
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 769
      __u = (union __anonunion___u_46 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 769
      __u->__uc = __c;
#line 769
      goto switch_break;
      case_16: /* CIL Label */ 
#line 769
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 769
      __u = (union __anonunion___u_46 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 769
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 769
      __u = (union __anonunion___u_46 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 769
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 769
      __u = (union __anonunion___u_46 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 769
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 769
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 769
    __s = (void *)dfa;
    {
#line 769
    __builtin_memset(__s, '\000', (int )sizeof(re_dfa_t ));
    }
    }
  }
  {
#line 771
  dfa->nodes_alloc = pat_len + 1;
  {
#line 772
  tmp = malloc((size_t )((unsigned long )dfa->nodes_alloc * sizeof(re_token_t )));
  }
#line 772
  dfa->nodes = (re_token_t *)tmp;
#line 774
  dfa->states_alloc = pat_len + 1;
#line 777
  table_size = 1;
  }
  {
  {
#line 777
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 777
    if (! (table_size > 0)) {
#line 777
      goto while_break;
    }
#line 778
    if (table_size > pat_len) {
#line 779
      goto while_break;
    }
#line 777
    table_size <<= 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 781
  tmp___0 = calloc((size_t )sizeof(struct re_state_table_entry ), (size_t )table_size);
  }
#line 781
  dfa->state_table = (struct re_state_table_entry *)tmp___0;
#line 782
  dfa->state_hash_mask = (unsigned int )(table_size - 1);
#line 784
  dfa->subexps_alloc = 1;
  {
#line 785
  tmp___1 = malloc((size_t )((unsigned long )dfa->subexps_alloc * sizeof(re_subexp_t )));
  }
#line 785
  dfa->subexps = (re_subexp_t *)tmp___1;
#line 786
  dfa->word_char = (re_bitset_ptr_t )((void *)0);
  }
#line 788
  if ((unsigned long )dfa->nodes == (unsigned long )((void *)0)) {
#line 788
    tmp___2 = 1;
  } else
#line 788
  if ((unsigned long )dfa->state_table == (unsigned long )((void *)0)) {
#line 788
    tmp___2 = 1;
  } else
#line 788
  if ((unsigned long )dfa->subexps == (unsigned long )((void *)0)) {
#line 788
    tmp___2 = 1;
  } else {
#line 788
    tmp___2 = 0;
  }
  {
  {
#line 788
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
  }
  }
#line 788
  if (tmp___3) {
#line 793
    dfa->subexps = (re_subexp_t *)((void *)0);
#line 794
    dfa->state_table = (struct re_state_table_entry *)((void *)0);
#line 795
    dfa->nodes = (re_token_t *)((void *)0);
#line 796
    return ((reg_errcode_t )12);
  }
#line 798
  return ((reg_errcode_t )0);
}
}
#line 805 "regcomp.c"
static reg_errcode_t init_word_char(re_dfa_t *dfa ) 
{ 
  int i ;
  int j ;
  int ch ;
  void *tmp ;
  long tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
  {
#line 810
  tmp = calloc((size_t )sizeof(bitset ), (size_t )1);
  }
#line 810
  dfa->word_char = (re_bitset_ptr_t )tmp;
  {
#line 811
  tmp___0 = __builtin_expect((long )((unsigned long )dfa->word_char == (unsigned long )((void *)0)),
                             0L);
  }
  }
#line 811
  if (tmp___0) {
#line 812
    return ((reg_errcode_t )12);
  }
#line 813
  i = 0;
#line 813
  ch = 0;
  {
  {
#line 813
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 813
    if (! ((unsigned long )i < ((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) {
#line 813
      goto while_break;
    }
#line 814
    j = 0;
    {
    {
#line 814
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 814
      if (! ((unsigned long )j < sizeof(unsigned int ) * 8UL)) {
#line 814
        goto while_break___0;
      }
      {
      {
#line 815
      tmp___1 = __ctype_b_loc();
      }
      }
#line 815
      if ((int const   )*(*tmp___1 + ch) & 8) {
#line 816
        *(dfa->word_char + i) |= (unsigned int )(1 << j);
      } else
#line 815
      if (ch == 95) {
#line 816
        *(dfa->word_char + i) |= (unsigned int )(1 << j);
      }
#line 814
      j ++;
#line 814
      ch ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 813
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 817
  return ((reg_errcode_t )0);
}
}
#line 822 "regcomp.c"
static void free_workarea_compile(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;

  {
  {
#line 826
  dfa = (re_dfa_t *)preg->buffer;
  {
#line 827
  free_bin_tree(dfa->str_tree);
  }
#line 828
  dfa->str_tree = (bin_tree_t *)((void *)0);
  {
#line 829
  free((void *)dfa->org_indices);
  }
#line 830
  dfa->org_indices = (int *)((void *)0);
  }
#line 831
  return;
}
}
#line 835 "regcomp.c"
static reg_errcode_t create_initial_state(re_dfa_t *dfa ) 
{ 
  int first ;
  int i ;
  reg_errcode_t err ;
  re_node_set init_nodes ;
  long tmp ;
  int node_idx ;
  re_token_type_t type ;
  int clexp_idx ;
  re_token_t *clexp_node ;
  int dest_idx ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  re_dfastate_t *tmp___4 ;
  re_dfastate_t *tmp___5 ;

  {
  {
#line 845
  first = (dfa->str_tree)->first;
#line 846
  dfa->init_node = first;
  {
#line 847
  err = re_node_set_init_copy(& init_nodes, (re_node_set const   *)(dfa->eclosures + first));
  }
  {
#line 848
  tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 848
  if (tmp) {
#line 849
    return (err);
  }
#line 855
  if (dfa->nbackref > 0) {
#line 856
    i = 0;
    {
    {
#line 856
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 856
      if (! (i < init_nodes.nelem)) {
#line 856
        goto while_break;
      }
#line 858
      node_idx = *(init_nodes.elems + i);
#line 859
      type = (dfa->nodes + node_idx)->type;
#line 862
      if ((unsigned int )type != 32U) {
#line 863
        goto __Cont;
      }
#line 864
      clexp_idx = 0;
      {
      {
#line 864
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 864
        if (! (clexp_idx < init_nodes.nelem)) {
#line 864
          goto while_break___0;
        }
#line 867
        clexp_node = dfa->nodes + *(init_nodes.elems + clexp_idx);
#line 868
        if ((unsigned int )clexp_node->type == 24U) {
#line 868
          if (clexp_node->opr.idx + 1 == (dfa->nodes + node_idx)->opr.idx) {
#line 870
            goto while_break___0;
          }
        }
#line 864
        clexp_idx ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 872
      if (clexp_idx == init_nodes.nelem) {
#line 873
        goto __Cont;
      }
#line 875
      if ((unsigned int )type == 32U) {
        {
#line 877
        dest_idx = *((dfa->edests + node_idx)->elems + 0);
        {
#line 878
        tmp___0 = re_node_set_contains((re_node_set const   *)(& init_nodes), dest_idx);
        }
        }
#line 878
        if (! tmp___0) {
          {
          {
#line 880
          re_node_set_merge(& init_nodes, (re_node_set const   *)(dfa->eclosures + dest_idx));
          }
#line 881
          i = 0;
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 856
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 887
  dfa->init_state = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& init_nodes),
                                             0U);
  }
  {
#line 889
  tmp___1 = __builtin_expect((long )((unsigned long )dfa->init_state == (unsigned long )((void *)0)),
                             0L);
  }
  }
#line 889
  if (tmp___1) {
#line 890
    return (err);
  }
#line 891
  if ((dfa->init_state)->has_constraint) {
    {
    {
#line 893
    dfa->init_state_word = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& init_nodes),
                                                    1U);
    }
    {
#line 895
    dfa->init_state_nl = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& init_nodes),
                                                  (unsigned int )(1 << 1));
    }
    {
#line 897
    dfa->init_state_begbuf = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& init_nodes),
                                                      (unsigned int )((1 << 1) | ((1 << 1) << 1)));
    }
    }
#line 901
    if ((unsigned long )dfa->init_state_word == (unsigned long )((void *)0)) {
#line 901
      tmp___2 = 1;
    } else
#line 901
    if ((unsigned long )dfa->init_state_nl == (unsigned long )((void *)0)) {
#line 901
      tmp___2 = 1;
    } else
#line 901
    if ((unsigned long )dfa->init_state_begbuf == (unsigned long )((void *)0)) {
#line 901
      tmp___2 = 1;
    } else {
#line 901
      tmp___2 = 0;
    }
    {
    {
#line 901
    tmp___3 = __builtin_expect((long )tmp___2, 0L);
    }
    }
#line 901
    if (tmp___3) {
#line 903
      return (err);
    }
  } else {
#line 906
    tmp___5 = dfa->init_state;
#line 906
    dfa->init_state_begbuf = tmp___5;
#line 906
    tmp___4 = tmp___5;
#line 906
    dfa->init_state_nl = tmp___4;
#line 906
    dfa->init_state_word = tmp___4;
  }
  {
  {
#line 909
  free((void *)init_nodes.elems);
  }
  }
#line 910
  return ((reg_errcode_t )0);
}
}
#line 916 "regcomp.c"
static reg_errcode_t analyze(re_dfa_t *dfa ) 
{ 
  int i ;
  reg_errcode_t ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_47 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  void *__s___2 ;
  void *__s___3 ;
  union __anonunion___u_48 *__u___0 ;
  __uint8_t __c___0 ;
  void *__s___4 ;
  void *__s___5 ;
  void *__s___6 ;
  union __anonunion___u_49 *__u___1 ;
  __uint8_t __c___1 ;
  void *__s___7 ;
  long tmp___6 ;

  {
  {
  {
#line 924
  tmp = malloc((size_t )((unsigned long )dfa->nodes_alloc * sizeof(int )));
  }
#line 924
  dfa->nexts = (int *)tmp;
  {
#line 925
  tmp___0 = malloc((size_t )((unsigned long )dfa->nodes_alloc * sizeof(int )));
  }
#line 925
  dfa->org_indices = (int *)tmp___0;
  {
#line 926
  tmp___1 = malloc((size_t )((unsigned long )dfa->nodes_alloc * sizeof(re_node_set )));
  }
#line 926
  dfa->edests = (re_node_set *)tmp___1;
  {
#line 927
  tmp___2 = malloc((size_t )((unsigned long )dfa->nodes_alloc * sizeof(re_node_set )));
  }
#line 927
  dfa->eclosures = (re_node_set *)tmp___2;
  {
#line 928
  tmp___3 = malloc((size_t )((unsigned long )dfa->nodes_alloc * sizeof(re_node_set )));
  }
#line 928
  dfa->inveclosures = (re_node_set *)tmp___3;
  }
#line 929
  if ((unsigned long )dfa->nexts == (unsigned long )((void *)0)) {
#line 929
    tmp___4 = 1;
  } else
#line 929
  if ((unsigned long )dfa->org_indices == (unsigned long )((void *)0)) {
#line 929
    tmp___4 = 1;
  } else
#line 929
  if ((unsigned long )dfa->edests == (unsigned long )((void *)0)) {
#line 929
    tmp___4 = 1;
  } else
#line 929
  if ((unsigned long )dfa->eclosures == (unsigned long )((void *)0)) {
#line 929
    tmp___4 = 1;
  } else
#line 929
  if ((unsigned long )dfa->inveclosures == (unsigned long )((void *)0)) {
#line 929
    tmp___4 = 1;
  } else {
#line 929
    tmp___4 = 0;
  }
  {
  {
#line 929
  tmp___5 = __builtin_expect((long )tmp___4, 0L);
  }
  }
#line 929
  if (tmp___5) {
#line 931
    return ((reg_errcode_t )12);
  }
#line 933
  i = 0;
  {
  {
#line 933
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 933
    if (! (i < dfa->nodes_len)) {
#line 933
      goto while_break;
    }
#line 935
    *(dfa->nexts + i) = -1;
#line 936
    if (sizeof(re_node_set ) <= 16UL) {
#line 936
      if (sizeof(re_node_set ) == 1UL) {
#line 936
        __s___1 = (void *)(dfa->edests + i);
#line 936
        *((__uint8_t *)__s___1) = (__uint8_t )'\000';
      } else {
#line 936
        __s___0 = (void *)(dfa->edests + i);
#line 936
        __u = (union __anonunion___u_47 *)__s___0;
#line 936
        __c = (__uint8_t )'\000';
        {
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 15U) {
#line 936
          goto case_15;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 11U) {
#line 936
          goto case_11;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 7U) {
#line 936
          goto case_7;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 3U) {
#line 936
          goto case_3;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 14U) {
#line 936
          goto case_14;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 10U) {
#line 936
          goto case_10;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 6U) {
#line 936
          goto case_6;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 2U) {
#line 936
          goto case_2;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 13U) {
#line 936
          goto case_13;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 9U) {
#line 936
          goto case_9;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 5U) {
#line 936
          goto case_5;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 1U) {
#line 936
          goto case_1;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 16U) {
#line 936
          goto case_16;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 12U) {
#line 936
          goto case_12;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 8U) {
#line 936
          goto case_8;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 4U) {
#line 936
          goto case_4;
        }
#line 936
        if ((unsigned int )sizeof(re_node_set ) == 0U) {
#line 936
          goto case_0;
        }
#line 936
        goto switch_break;
        case_15: /* CIL Label */ 
#line 936
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 936
        __u = (union __anonunion___u_47 *)((void *)__u + 4);
        case_11: /* CIL Label */ 
#line 936
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 936
        __u = (union __anonunion___u_47 *)((void *)__u + 4);
        case_7: /* CIL Label */ 
#line 936
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 936
        __u = (union __anonunion___u_47 *)((void *)__u + 4);
        case_3: /* CIL Label */ 
#line 936
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 936
        __u = (union __anonunion___u_47 *)((void *)__u + 2);
#line 936
        __u->__uc = __c;
#line 936
        goto switch_break;
        case_14: /* CIL Label */ 
#line 936
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 936
        __u = (union __anonunion___u_47 *)((void *)__u + 4);
        case_10: /* CIL Label */ 
#line 936
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 936
        __u = (union __anonunion___u_47 *)((void *)__u + 4);
        case_6: /* CIL Label */ 
#line 936
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 936
        __u = (union __anonunion___u_47 *)((void *)__u + 4);
        case_2: /* CIL Label */ 
#line 936
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 936
        goto switch_break;
        case_13: /* CIL Label */ 
#line 936
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 936
        __u = (union __anonunion___u_47 *)((void *)__u + 4);
        case_9: /* CIL Label */ 
#line 936
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 936
        __u = (union __anonunion___u_47 *)((void *)__u + 4);
        case_5: /* CIL Label */ 
#line 936
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 936
        __u = (union __anonunion___u_47 *)((void *)__u + 4);
        case_1: /* CIL Label */ 
#line 936
        __u->__uc = __c;
#line 936
        goto switch_break;
        case_16: /* CIL Label */ 
#line 936
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 936
        __u = (union __anonunion___u_47 *)((void *)__u + 4);
        case_12: /* CIL Label */ 
#line 936
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 936
        __u = (union __anonunion___u_47 *)((void *)__u + 4);
        case_8: /* CIL Label */ 
#line 936
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 936
        __u = (union __anonunion___u_47 *)((void *)__u + 4);
        case_4: /* CIL Label */ 
#line 936
        __u->__ui = (unsigned int )((int )__c * 16843009);
        case_0: /* CIL Label */ 
#line 936
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 936
      __s = (void *)(dfa->edests + i);
      {
#line 936
      __builtin_memset(__s, '\000', (int )sizeof(re_node_set ));
      }
      }
    }
#line 937
    if (sizeof(re_node_set ) <= 16UL) {
#line 937
      if (sizeof(re_node_set ) == 1UL) {
#line 937
        __s___4 = (void *)(dfa->eclosures + i);
#line 937
        *((__uint8_t *)__s___4) = (__uint8_t )'\000';
      } else {
#line 937
        __s___3 = (void *)(dfa->eclosures + i);
#line 937
        __u___0 = (union __anonunion___u_48 *)__s___3;
#line 937
        __c___0 = (__uint8_t )'\000';
        {
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 15U) {
#line 937
          goto case_15___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 11U) {
#line 937
          goto case_11___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 7U) {
#line 937
          goto case_7___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 3U) {
#line 937
          goto case_3___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 14U) {
#line 937
          goto case_14___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 10U) {
#line 937
          goto case_10___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 6U) {
#line 937
          goto case_6___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 2U) {
#line 937
          goto case_2___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 13U) {
#line 937
          goto case_13___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 9U) {
#line 937
          goto case_9___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 5U) {
#line 937
          goto case_5___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 1U) {
#line 937
          goto case_1___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 16U) {
#line 937
          goto case_16___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 12U) {
#line 937
          goto case_12___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 8U) {
#line 937
          goto case_8___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 4U) {
#line 937
          goto case_4___0;
        }
#line 937
        if ((unsigned int )sizeof(re_node_set ) == 0U) {
#line 937
          goto case_0___0;
        }
#line 937
        goto switch_break___0;
        case_15___0: /* CIL Label */ 
#line 937
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 937
        __u___0 = (union __anonunion___u_48 *)((void *)__u___0 + 4);
        case_11___0: /* CIL Label */ 
#line 937
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 937
        __u___0 = (union __anonunion___u_48 *)((void *)__u___0 + 4);
        case_7___0: /* CIL Label */ 
#line 937
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 937
        __u___0 = (union __anonunion___u_48 *)((void *)__u___0 + 4);
        case_3___0: /* CIL Label */ 
#line 937
        __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 937
        __u___0 = (union __anonunion___u_48 *)((void *)__u___0 + 2);
#line 937
        __u___0->__uc = __c___0;
#line 937
        goto switch_break___0;
        case_14___0: /* CIL Label */ 
#line 937
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 937
        __u___0 = (union __anonunion___u_48 *)((void *)__u___0 + 4);
        case_10___0: /* CIL Label */ 
#line 937
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 937
        __u___0 = (union __anonunion___u_48 *)((void *)__u___0 + 4);
        case_6___0: /* CIL Label */ 
#line 937
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 937
        __u___0 = (union __anonunion___u_48 *)((void *)__u___0 + 4);
        case_2___0: /* CIL Label */ 
#line 937
        __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 937
        goto switch_break___0;
        case_13___0: /* CIL Label */ 
#line 937
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 937
        __u___0 = (union __anonunion___u_48 *)((void *)__u___0 + 4);
        case_9___0: /* CIL Label */ 
#line 937
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 937
        __u___0 = (union __anonunion___u_48 *)((void *)__u___0 + 4);
        case_5___0: /* CIL Label */ 
#line 937
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 937
        __u___0 = (union __anonunion___u_48 *)((void *)__u___0 + 4);
        case_1___0: /* CIL Label */ 
#line 937
        __u___0->__uc = __c___0;
#line 937
        goto switch_break___0;
        case_16___0: /* CIL Label */ 
#line 937
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 937
        __u___0 = (union __anonunion___u_48 *)((void *)__u___0 + 4);
        case_12___0: /* CIL Label */ 
#line 937
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 937
        __u___0 = (union __anonunion___u_48 *)((void *)__u___0 + 4);
        case_8___0: /* CIL Label */ 
#line 937
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 937
        __u___0 = (union __anonunion___u_48 *)((void *)__u___0 + 4);
        case_4___0: /* CIL Label */ 
#line 937
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
        case_0___0: /* CIL Label */ 
#line 937
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 937
      __s___2 = (void *)(dfa->eclosures + i);
      {
#line 937
      __builtin_memset(__s___2, '\000', (int )sizeof(re_node_set ));
      }
      }
    }
#line 938
    if (sizeof(re_node_set ) <= 16UL) {
#line 938
      if (sizeof(re_node_set ) == 1UL) {
#line 938
        __s___7 = (void *)(dfa->inveclosures + i);
#line 938
        *((__uint8_t *)__s___7) = (__uint8_t )'\000';
      } else {
#line 938
        __s___6 = (void *)(dfa->inveclosures + i);
#line 938
        __u___1 = (union __anonunion___u_49 *)__s___6;
#line 938
        __c___1 = (__uint8_t )'\000';
        {
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 15U) {
#line 938
          goto case_15___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 11U) {
#line 938
          goto case_11___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 7U) {
#line 938
          goto case_7___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 3U) {
#line 938
          goto case_3___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 14U) {
#line 938
          goto case_14___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 10U) {
#line 938
          goto case_10___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 6U) {
#line 938
          goto case_6___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 2U) {
#line 938
          goto case_2___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 13U) {
#line 938
          goto case_13___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 9U) {
#line 938
          goto case_9___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 5U) {
#line 938
          goto case_5___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 1U) {
#line 938
          goto case_1___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 16U) {
#line 938
          goto case_16___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 12U) {
#line 938
          goto case_12___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 8U) {
#line 938
          goto case_8___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 4U) {
#line 938
          goto case_4___1;
        }
#line 938
        if ((unsigned int )sizeof(re_node_set ) == 0U) {
#line 938
          goto case_0___1;
        }
#line 938
        goto switch_break___1;
        case_15___1: /* CIL Label */ 
#line 938
        __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 938
        __u___1 = (union __anonunion___u_49 *)((void *)__u___1 + 4);
        case_11___1: /* CIL Label */ 
#line 938
        __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 938
        __u___1 = (union __anonunion___u_49 *)((void *)__u___1 + 4);
        case_7___1: /* CIL Label */ 
#line 938
        __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 938
        __u___1 = (union __anonunion___u_49 *)((void *)__u___1 + 4);
        case_3___1: /* CIL Label */ 
#line 938
        __u___1->__usi = (unsigned short )((int )((unsigned short )__c___1) * 257);
#line 938
        __u___1 = (union __anonunion___u_49 *)((void *)__u___1 + 2);
#line 938
        __u___1->__uc = __c___1;
#line 938
        goto switch_break___1;
        case_14___1: /* CIL Label */ 
#line 938
        __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 938
        __u___1 = (union __anonunion___u_49 *)((void *)__u___1 + 4);
        case_10___1: /* CIL Label */ 
#line 938
        __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 938
        __u___1 = (union __anonunion___u_49 *)((void *)__u___1 + 4);
        case_6___1: /* CIL Label */ 
#line 938
        __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 938
        __u___1 = (union __anonunion___u_49 *)((void *)__u___1 + 4);
        case_2___1: /* CIL Label */ 
#line 938
        __u___1->__usi = (unsigned short )((int )((unsigned short )__c___1) * 257);
#line 938
        goto switch_break___1;
        case_13___1: /* CIL Label */ 
#line 938
        __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 938
        __u___1 = (union __anonunion___u_49 *)((void *)__u___1 + 4);
        case_9___1: /* CIL Label */ 
#line 938
        __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 938
        __u___1 = (union __anonunion___u_49 *)((void *)__u___1 + 4);
        case_5___1: /* CIL Label */ 
#line 938
        __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 938
        __u___1 = (union __anonunion___u_49 *)((void *)__u___1 + 4);
        case_1___1: /* CIL Label */ 
#line 938
        __u___1->__uc = __c___1;
#line 938
        goto switch_break___1;
        case_16___1: /* CIL Label */ 
#line 938
        __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 938
        __u___1 = (union __anonunion___u_49 *)((void *)__u___1 + 4);
        case_12___1: /* CIL Label */ 
#line 938
        __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 938
        __u___1 = (union __anonunion___u_49 *)((void *)__u___1 + 4);
        case_8___1: /* CIL Label */ 
#line 938
        __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 938
        __u___1 = (union __anonunion___u_49 *)((void *)__u___1 + 4);
        case_4___1: /* CIL Label */ 
#line 938
        __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
        case_0___1: /* CIL Label */ 
#line 938
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 938
      __s___5 = (void *)(dfa->inveclosures + i);
      {
#line 938
      __builtin_memset(__s___5, '\000', (int )sizeof(re_node_set ));
      }
      }
    }
#line 933
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 941
  ret = analyze_tree(dfa, dfa->str_tree);
  }
  {
#line 942
  tmp___6 = __builtin_expect((long )((unsigned int )ret == 0U), 1L);
  }
  }
#line 942
  if (tmp___6) {
    {
    {
#line 944
    ret = calc_eclosure(dfa);
    }
    }
#line 945
    if ((unsigned int )ret == 0U) {
      {
      {
#line 946
      calc_inveclosure(dfa);
      }
      }
    }
  }
#line 948
  return (ret);
}
}
#line 955 "regcomp.c"
static reg_errcode_t analyze_tree(re_dfa_t *dfa , bin_tree_t *node ) 
{ 
  reg_errcode_t ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 961
  if (node->first == -1) {
    {
    {
#line 962
    calc_first(dfa, node);
    }
    }
  }
#line 963
  if (node->next == -1) {
    {
    {
#line 964
    calc_next(dfa, node);
    }
    }
  }
#line 965
  if (node->eclosure.nelem == 0) {
    {
    {
#line 966
    calc_epsdest(dfa, node);
    }
    }
  }
#line 968
  if ((unsigned long )node->left != (unsigned long )((void *)0)) {
    {
    {
#line 970
    ret = analyze_tree(dfa, node->left);
    }
    {
#line 971
    tmp = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
    }
    }
#line 971
    if (tmp) {
#line 972
      return (ret);
    }
  }
#line 975
  if ((unsigned long )node->right != (unsigned long )((void *)0)) {
    {
    {
#line 977
    ret = analyze_tree(dfa, node->right);
    }
    {
#line 978
    tmp___0 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
    }
    }
#line 978
    if (tmp___0) {
#line 979
      return (ret);
    }
  }
#line 981
  return ((reg_errcode_t )0);
}
}
#line 985 "regcomp.c"
static void calc_first(re_dfa_t *dfa , bin_tree_t *node ) 
{ 
  int idx ;
  int type ;

  {
#line 991
  idx = node->node_idx;
#line 992
  if ((unsigned int )node->type == 0U) {
#line 992
    type = (int )(dfa->nodes + idx)->type;
  } else {
#line 992
    type = (int )node->type;
  }
  {
#line 1023
  if (type == 24) {
#line 1023
    goto case_24;
  }
#line 1023
  if (type == 23) {
#line 1023
    goto case_24;
  }
#line 1023
  if (type == 33) {
#line 1023
    goto case_24;
  }
#line 1023
  if (type == 32) {
#line 1023
    goto case_24;
  }
#line 1023
  if (type == 21) {
#line 1023
    goto case_24;
  }
#line 1023
  if (type == 22) {
#line 1023
    goto case_24;
  }
#line 1023
  if (type == 31) {
#line 1023
    goto case_24;
  }
#line 1023
  if (type == 29) {
#line 1023
    goto case_24;
  }
#line 1023
  if (type == 25) {
#line 1023
    goto case_24;
  }
#line 1023
  if (type == 26) {
#line 1023
    goto case_24;
  }
#line 1023
  if (type == 27) {
#line 1023
    goto case_24;
  }
#line 1026
  if (type == 30) {
#line 1026
    goto case_30;
  }
#line 1034
  if (type == 28) {
#line 1034
    goto case_28;
  }
#line 1038
  goto switch_default;
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_27: /* CIL Label */ 
#line 1024
  node->first = idx;
#line 1025
  goto switch_break;
  case_30: /* CIL Label */ 
#line 1030
  if ((node->left)->first == -1) {
    {
    {
#line 1031
    calc_first(dfa, node->left);
    }
    }
  }
#line 1032
  node->first = (node->left)->first;
#line 1033
  goto switch_break;
  case_28: /* CIL Label */ 
#line 1035
  node->first = idx;
#line 1036
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1042
  if ((node->left)->first == -1) {
    {
    {
#line 1043
    calc_first(dfa, node->left);
    }
    }
  }
#line 1044
  node->first = (node->left)->first;
#line 1045
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1047
  return;
}
}
#line 1051 "regcomp.c"
static void calc_next(re_dfa_t *dfa , bin_tree_t *node ) 
{ 
  int idx ;
  int type ;
  bin_tree_t *parent ;

  {
#line 1057
  parent = node->parent;
#line 1058
  if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 1060
    node->next = -1;
#line 1061
    idx = node->node_idx;
#line 1062
    if ((unsigned int )node->type == 0U) {
#line 1063
      *(dfa->nexts + idx) = node->next;
    }
#line 1064
    return;
  }
#line 1067
  idx = parent->node_idx;
#line 1068
  if ((unsigned int )parent->type == 0U) {
#line 1068
    type = (int )(dfa->nodes + idx)->type;
  } else {
#line 1068
    type = (int )parent->type;
  }
  {
#line 1073
  if (type == 30) {
#line 1073
    goto case_30;
  }
#line 1073
  if (type == 29) {
#line 1073
    goto case_30;
  }
#line 1076
  if (type == 18) {
#line 1076
    goto case_18;
  }
#line 1085
  goto switch_default;
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
#line 1074
  node->next = idx;
#line 1075
  goto switch_break;
  case_18: /* CIL Label */ 
#line 1077
  if ((unsigned long )parent->left == (unsigned long )node) {
#line 1079
    if ((parent->right)->first == -1) {
      {
      {
#line 1080
      calc_first(dfa, parent->right);
      }
      }
    }
#line 1081
    node->next = (parent->right)->first;
#line 1082
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
#line 1086
  if (parent->next == -1) {
    {
    {
#line 1087
    calc_next(dfa, parent);
    }
    }
  }
#line 1088
  node->next = parent->next;
#line 1089
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1091
  idx = node->node_idx;
#line 1092
  if ((unsigned int )node->type == 0U) {
#line 1093
    *(dfa->nexts + idx) = node->next;
  }
#line 1094
  return;
}
}
#line 1098 "regcomp.c"
static void calc_epsdest(re_dfa_t *dfa , bin_tree_t *node ) 
{ 
  int idx ;
  int left ;
  int right ;
  int tmp ;
  long tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1104
  idx = node->node_idx;
#line 1105
  if ((unsigned int )node->type == 0U) {
#line 1107
    if ((unsigned int )(dfa->nodes + idx)->type == 29U) {
#line 1107
      goto _L;
    } else
#line 1107
    if ((unsigned int )(dfa->nodes + idx)->type == 30U) {
#line 1107
      goto _L;
    } else
#line 1107
    if ((unsigned int )(dfa->nodes + idx)->type == 31U) {
      _L: /* CIL Label */ 
#line 1111
      if ((node->left)->first == -1) {
        {
        {
#line 1112
        calc_first(dfa, node->left);
        }
        }
      }
#line 1113
      if (node->next == -1) {
        {
        {
#line 1114
        calc_next(dfa, node);
        }
        }
      }
      {
      {
#line 1115
      re_node_set_init_2(dfa->edests + idx, (node->left)->first, node->next);
      }
      }
    } else
#line 1118
    if ((unsigned int )(dfa->nodes + idx)->type == 28U) {
#line 1121
      if ((unsigned long )node->left != (unsigned long )((void *)0)) {
#line 1123
        if ((node->left)->first == -1) {
          {
          {
#line 1124
          calc_first(dfa, node->left);
          }
          }
        }
#line 1125
        left = (node->left)->first;
      } else {
#line 1129
        if (node->next == -1) {
          {
          {
#line 1130
          calc_next(dfa, node);
          }
          }
        }
#line 1131
        left = node->next;
      }
#line 1133
      if ((unsigned long )node->right != (unsigned long )((void *)0)) {
#line 1135
        if ((node->right)->first == -1) {
          {
          {
#line 1136
          calc_first(dfa, node->right);
          }
          }
        }
#line 1137
        right = (node->right)->first;
      } else {
#line 1141
        if (node->next == -1) {
          {
          {
#line 1142
          calc_next(dfa, node);
          }
          }
        }
#line 1143
        right = node->next;
      }
      {
      {
#line 1145
      re_node_set_init_2(dfa->edests + idx, left, right);
      }
      }
    } else
#line 1147
    if ((unsigned int )(dfa->nodes + idx)->type == 33U) {
      {
      {
#line 1151
      re_node_set_init_1(dfa->edests + idx, node->next);
      }
      }
    } else
#line 1147
    if ((unsigned int )(dfa->nodes + idx)->type == 23U) {
      {
      {
#line 1151
      re_node_set_init_1(dfa->edests + idx, node->next);
      }
      }
    } else
#line 1147
    if ((unsigned int )(dfa->nodes + idx)->type == 24U) {
      {
      {
#line 1151
      re_node_set_init_1(dfa->edests + idx, node->next);
      }
      }
    } else
#line 1147
    if ((unsigned int )(dfa->nodes + idx)->type == 32U) {
      {
      {
#line 1151
      re_node_set_init_1(dfa->edests + idx, node->next);
      }
      }
    } else {
#line 1153
      if ((unsigned int )(dfa->nodes + idx)->type == 28U) {
#line 1153
        tmp = 0;
      } else
#line 1153
      if ((unsigned int )(dfa->nodes + idx)->type == 29U) {
#line 1153
        tmp = 0;
      } else
#line 1153
      if ((unsigned int )(dfa->nodes + idx)->type == 30U) {
#line 1153
        tmp = 0;
      } else
#line 1153
      if ((unsigned int )(dfa->nodes + idx)->type == 31U) {
#line 1153
        tmp = 0;
      } else
#line 1153
      if ((unsigned int )(dfa->nodes + idx)->type == 33U) {
#line 1153
        tmp = 0;
      } else
#line 1153
      if ((unsigned int )(dfa->nodes + idx)->type == 23U) {
#line 1153
        tmp = 0;
      } else
#line 1153
      if ((unsigned int )(dfa->nodes + idx)->type == 24U) {
#line 1153
        tmp = 0;
      } else {
#line 1153
        tmp = 1;
      }
      {
      {
#line 1153
      tmp___0 = __builtin_expect((long )tmp, 1L);
      }
      }
#line 1153
      if (! tmp___0) {
        {
        {
#line 1153
        __assert_fail("!((dfa->nodes[idx].type) == OP_ALT || (dfa->nodes[idx].type) == OP_DUP_ASTERISK || (dfa->nodes[idx].type) == OP_DUP_PLUS || (dfa->nodes[idx].type) == OP_DUP_QUESTION || (dfa->nodes[idx].type) == ANCHOR || (dfa->nodes[idx].type) == OP_OPEN_SUBEXP || (dfa->nodes[idx].type) == OP_CLOSE_SUBEXP)",
                      "regcomp.c", 1153U, "calc_epsdest");
        }
        }
      }
    }
  }
#line 1155
  return;
}
}
#line 1161 "regcomp.c"
static reg_errcode_t duplicate_node_closure(re_dfa_t *dfa , int top_org_node , int top_clone_node ,
                                            int root_node , unsigned int init_constraint ) 
{ 
  reg_errcode_t err ;
  int org_node ;
  int clone_node ;
  int ret ;
  unsigned int constraint ;
  int org_dest ;
  int clone_dest ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;

  {
#line 1170
  constraint = init_constraint;
#line 1171
  org_node = top_org_node;
#line 1171
  clone_node = top_clone_node;
  {
  {
#line 1171
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1174
    if ((unsigned int )(dfa->nodes + org_node)->type == 32U) {
      {
#line 1180
      org_dest = *(dfa->nexts + org_node);
#line 1181
      (dfa->edests + clone_node)->nelem = 0;
      {
#line 1182
      err = duplicate_node(& clone_dest, dfa, org_dest, constraint);
      }
      {
#line 1183
      tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 1183
      if (tmp) {
#line 1184
        return (err);
      }
      {
#line 1185
      *(dfa->nexts + clone_node) = *(dfa->nexts + org_node);
      {
#line 1186
      ret = re_node_set_insert(dfa->edests + clone_node, clone_dest);
      }
      {
#line 1187
      tmp___0 = __builtin_expect((long )(ret < 0), 0L);
      }
      }
#line 1187
      if (tmp___0) {
#line 1188
        return ((reg_errcode_t )12);
      }
    } else
#line 1190
    if ((dfa->edests + org_node)->nelem == 0) {
#line 1195
      *(dfa->nexts + clone_node) = *(dfa->nexts + org_node);
#line 1196
      goto while_break;
    } else
#line 1198
    if ((dfa->edests + org_node)->nelem == 1) {
#line 1202
      org_dest = *((dfa->edests + org_node)->elems + 0);
#line 1203
      (dfa->edests + clone_node)->nelem = 0;
#line 1204
      if ((unsigned int )(dfa->nodes + org_node)->type == 33U) {
#line 1207
        if (org_node == root_node) {
#line 1207
          if (clone_node != org_node) {
            {
            {
#line 1212
            ret = re_node_set_insert(dfa->edests + clone_node, org_dest);
            }
            {
#line 1214
            tmp___1 = __builtin_expect((long )(ret < 0), 0L);
            }
            }
#line 1214
            if (tmp___1) {
#line 1215
              return ((reg_errcode_t )12);
            }
#line 1216
            goto while_break;
          }
        }
#line 1218
        constraint |= (unsigned int )(dfa->nodes + org_node)->opr.ctx_type;
      }
      {
      {
#line 1220
      err = duplicate_node(& clone_dest, dfa, org_dest, constraint);
      }
      {
#line 1221
      tmp___2 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 1221
      if (tmp___2) {
#line 1222
        return (err);
      }
      {
      {
#line 1223
      ret = re_node_set_insert(dfa->edests + clone_node, clone_dest);
      }
      {
#line 1224
      tmp___3 = __builtin_expect((long )(ret < 0), 0L);
      }
      }
#line 1224
      if (tmp___3) {
#line 1225
        return ((reg_errcode_t )12);
      }
    } else {
      {
#line 1231
      org_dest = *((dfa->edests + org_node)->elems + 0);
#line 1232
      (dfa->edests + clone_node)->nelem = 0;
      {
#line 1234
      clone_dest = search_duplicated_node(dfa, org_dest, constraint);
      }
      }
#line 1235
      if (clone_dest == -1) {
        {
        {
#line 1238
        err = duplicate_node(& clone_dest, dfa, org_dest, constraint);
        }
        {
#line 1239
        tmp___4 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        }
#line 1239
        if (tmp___4) {
#line 1240
          return (err);
        }
        {
        {
#line 1241
        ret = re_node_set_insert(dfa->edests + clone_node, clone_dest);
        }
        {
#line 1242
        tmp___5 = __builtin_expect((long )(ret < 0), 0L);
        }
        }
#line 1242
        if (tmp___5) {
#line 1243
          return ((reg_errcode_t )12);
        }
        {
        {
#line 1244
        err = duplicate_node_closure(dfa, org_dest, clone_dest, root_node, constraint);
        }
        {
#line 1246
        tmp___6 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        }
#line 1246
        if (tmp___6) {
#line 1247
          return (err);
        }
      } else {
        {
        {
#line 1253
        ret = re_node_set_insert(dfa->edests + clone_node, clone_dest);
        }
        {
#line 1254
        tmp___7 = __builtin_expect((long )(ret < 0), 0L);
        }
        }
#line 1254
        if (tmp___7) {
#line 1255
          return ((reg_errcode_t )12);
        }
      }
      {
#line 1258
      org_dest = *((dfa->edests + org_node)->elems + 1);
      {
#line 1259
      err = duplicate_node(& clone_dest, dfa, org_dest, constraint);
      }
      {
#line 1260
      tmp___8 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 1260
      if (tmp___8) {
#line 1261
        return (err);
      }
      {
      {
#line 1262
      ret = re_node_set_insert(dfa->edests + clone_node, clone_dest);
      }
      {
#line 1263
      tmp___9 = __builtin_expect((long )(ret < 0), 0L);
      }
      }
#line 1263
      if (tmp___9) {
#line 1264
        return ((reg_errcode_t )12);
      }
    }
#line 1266
    org_node = org_dest;
#line 1267
    clone_node = clone_dest;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1269
  return ((reg_errcode_t )0);
}
}
#line 1275 "regcomp.c"
static int search_duplicated_node(re_dfa_t *dfa , int org_node , unsigned int constraint ) 
{ 
  int idx ;

  {
#line 1282
  idx = dfa->nodes_len - 1;
  {
  {
#line 1282
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1282
    if ((dfa->nodes + idx)->duplicated) {
#line 1282
      if (! (idx > 0)) {
#line 1282
        goto while_break;
      }
    } else {
#line 1282
      goto while_break;
    }
#line 1284
    if (org_node == *(dfa->org_indices + idx)) {
#line 1284
      if (constraint == (dfa->nodes + idx)->constraint) {
#line 1286
        return (idx);
      }
    }
#line 1282
    idx --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1288
  return (-1);
}
}
#line 1295 "regcomp.c"
static reg_errcode_t duplicate_node(int *new_idx , re_dfa_t *dfa , int org_idx , unsigned int constraint ) 
{ 
  re_token_t dup ;
  int dup_idx ;
  long tmp ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_50 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  void *__s___2 ;
  void *__s___3 ;
  union __anonunion___u_51 *__u___0 ;
  __uint8_t __c___0 ;
  void *__s___4 ;
  void *__s___5 ;
  void *__s___6 ;
  union __anonunion___u_52 *__u___1 ;
  __uint8_t __c___1 ;
  void *__s___7 ;

  {
  {
#line 1304
  dup = *(dfa->nodes + org_idx);
  {
#line 1305
  dup_idx = re_dfa_add_node(dfa, dup, 1);
  }
  {
#line 1306
  tmp = __builtin_expect((long )(dup_idx == -1), 0L);
  }
  }
#line 1306
  if (tmp) {
#line 1307
    return ((reg_errcode_t )12);
  }
#line 1308
  (dfa->nodes + dup_idx)->constraint = constraint;
#line 1309
  if ((unsigned int )(dfa->nodes + org_idx)->type == 33U) {
#line 1310
    (dfa->nodes + dup_idx)->constraint |= (unsigned int )(dfa->nodes + org_idx)->opr.ctx_type;
  }
#line 1311
  (dfa->nodes + dup_idx)->duplicated = 1U;
#line 1312
  if (sizeof(re_node_set ) <= 16UL) {
#line 1312
    if (sizeof(re_node_set ) == 1UL) {
#line 1312
      __s___1 = (void *)(dfa->edests + dup_idx);
#line 1312
      *((__uint8_t *)__s___1) = (__uint8_t )'\000';
    } else {
#line 1312
      __s___0 = (void *)(dfa->edests + dup_idx);
#line 1312
      __u = (union __anonunion___u_50 *)__s___0;
#line 1312
      __c = (__uint8_t )'\000';
      {
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 15U) {
#line 1312
        goto case_15;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 11U) {
#line 1312
        goto case_11;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 7U) {
#line 1312
        goto case_7;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 3U) {
#line 1312
        goto case_3;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 14U) {
#line 1312
        goto case_14;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 10U) {
#line 1312
        goto case_10;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 6U) {
#line 1312
        goto case_6;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 2U) {
#line 1312
        goto case_2;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 13U) {
#line 1312
        goto case_13;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 9U) {
#line 1312
        goto case_9;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 5U) {
#line 1312
        goto case_5;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 1U) {
#line 1312
        goto case_1;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 16U) {
#line 1312
        goto case_16;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 12U) {
#line 1312
        goto case_12;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 8U) {
#line 1312
        goto case_8;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 4U) {
#line 1312
        goto case_4;
      }
#line 1312
      if ((unsigned int )sizeof(re_node_set ) == 0U) {
#line 1312
        goto case_0;
      }
#line 1312
      goto switch_break;
      case_15: /* CIL Label */ 
#line 1312
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1312
      __u = (union __anonunion___u_50 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 1312
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1312
      __u = (union __anonunion___u_50 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 1312
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1312
      __u = (union __anonunion___u_50 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 1312
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1312
      __u = (union __anonunion___u_50 *)((void *)__u + 2);
#line 1312
      __u->__uc = __c;
#line 1312
      goto switch_break;
      case_14: /* CIL Label */ 
#line 1312
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1312
      __u = (union __anonunion___u_50 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 1312
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1312
      __u = (union __anonunion___u_50 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 1312
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1312
      __u = (union __anonunion___u_50 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 1312
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1312
      goto switch_break;
      case_13: /* CIL Label */ 
#line 1312
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1312
      __u = (union __anonunion___u_50 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 1312
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1312
      __u = (union __anonunion___u_50 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 1312
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1312
      __u = (union __anonunion___u_50 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 1312
      __u->__uc = __c;
#line 1312
      goto switch_break;
      case_16: /* CIL Label */ 
#line 1312
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1312
      __u = (union __anonunion___u_50 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 1312
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1312
      __u = (union __anonunion___u_50 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 1312
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1312
      __u = (union __anonunion___u_50 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 1312
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 1312
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1312
    __s = (void *)(dfa->edests + dup_idx);
    {
#line 1312
    __builtin_memset(__s, '\000', (int )sizeof(re_node_set ));
    }
    }
  }
#line 1313
  if (sizeof(re_node_set ) <= 16UL) {
#line 1313
    if (sizeof(re_node_set ) == 1UL) {
#line 1313
      __s___4 = (void *)(dfa->eclosures + dup_idx);
#line 1313
      *((__uint8_t *)__s___4) = (__uint8_t )'\000';
    } else {
#line 1313
      __s___3 = (void *)(dfa->eclosures + dup_idx);
#line 1313
      __u___0 = (union __anonunion___u_51 *)__s___3;
#line 1313
      __c___0 = (__uint8_t )'\000';
      {
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 15U) {
#line 1313
        goto case_15___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 11U) {
#line 1313
        goto case_11___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 7U) {
#line 1313
        goto case_7___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 3U) {
#line 1313
        goto case_3___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 14U) {
#line 1313
        goto case_14___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 10U) {
#line 1313
        goto case_10___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 6U) {
#line 1313
        goto case_6___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 2U) {
#line 1313
        goto case_2___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 13U) {
#line 1313
        goto case_13___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 9U) {
#line 1313
        goto case_9___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 5U) {
#line 1313
        goto case_5___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 1U) {
#line 1313
        goto case_1___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 16U) {
#line 1313
        goto case_16___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 12U) {
#line 1313
        goto case_12___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 8U) {
#line 1313
        goto case_8___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 4U) {
#line 1313
        goto case_4___0;
      }
#line 1313
      if ((unsigned int )sizeof(re_node_set ) == 0U) {
#line 1313
        goto case_0___0;
      }
#line 1313
      goto switch_break___0;
      case_15___0: /* CIL Label */ 
#line 1313
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1313
      __u___0 = (union __anonunion___u_51 *)((void *)__u___0 + 4);
      case_11___0: /* CIL Label */ 
#line 1313
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1313
      __u___0 = (union __anonunion___u_51 *)((void *)__u___0 + 4);
      case_7___0: /* CIL Label */ 
#line 1313
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1313
      __u___0 = (union __anonunion___u_51 *)((void *)__u___0 + 4);
      case_3___0: /* CIL Label */ 
#line 1313
      __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 1313
      __u___0 = (union __anonunion___u_51 *)((void *)__u___0 + 2);
#line 1313
      __u___0->__uc = __c___0;
#line 1313
      goto switch_break___0;
      case_14___0: /* CIL Label */ 
#line 1313
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1313
      __u___0 = (union __anonunion___u_51 *)((void *)__u___0 + 4);
      case_10___0: /* CIL Label */ 
#line 1313
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1313
      __u___0 = (union __anonunion___u_51 *)((void *)__u___0 + 4);
      case_6___0: /* CIL Label */ 
#line 1313
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1313
      __u___0 = (union __anonunion___u_51 *)((void *)__u___0 + 4);
      case_2___0: /* CIL Label */ 
#line 1313
      __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 1313
      goto switch_break___0;
      case_13___0: /* CIL Label */ 
#line 1313
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1313
      __u___0 = (union __anonunion___u_51 *)((void *)__u___0 + 4);
      case_9___0: /* CIL Label */ 
#line 1313
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1313
      __u___0 = (union __anonunion___u_51 *)((void *)__u___0 + 4);
      case_5___0: /* CIL Label */ 
#line 1313
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1313
      __u___0 = (union __anonunion___u_51 *)((void *)__u___0 + 4);
      case_1___0: /* CIL Label */ 
#line 1313
      __u___0->__uc = __c___0;
#line 1313
      goto switch_break___0;
      case_16___0: /* CIL Label */ 
#line 1313
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1313
      __u___0 = (union __anonunion___u_51 *)((void *)__u___0 + 4);
      case_12___0: /* CIL Label */ 
#line 1313
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1313
      __u___0 = (union __anonunion___u_51 *)((void *)__u___0 + 4);
      case_8___0: /* CIL Label */ 
#line 1313
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1313
      __u___0 = (union __anonunion___u_51 *)((void *)__u___0 + 4);
      case_4___0: /* CIL Label */ 
#line 1313
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
      case_0___0: /* CIL Label */ 
#line 1313
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1313
    __s___2 = (void *)(dfa->eclosures + dup_idx);
    {
#line 1313
    __builtin_memset(__s___2, '\000', (int )sizeof(re_node_set ));
    }
    }
  }
#line 1314
  if (sizeof(re_node_set ) <= 16UL) {
#line 1314
    if (sizeof(re_node_set ) == 1UL) {
#line 1314
      __s___7 = (void *)(dfa->inveclosures + dup_idx);
#line 1314
      *((__uint8_t *)__s___7) = (__uint8_t )'\000';
    } else {
#line 1314
      __s___6 = (void *)(dfa->inveclosures + dup_idx);
#line 1314
      __u___1 = (union __anonunion___u_52 *)__s___6;
#line 1314
      __c___1 = (__uint8_t )'\000';
      {
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 15U) {
#line 1314
        goto case_15___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 11U) {
#line 1314
        goto case_11___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 7U) {
#line 1314
        goto case_7___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 3U) {
#line 1314
        goto case_3___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 14U) {
#line 1314
        goto case_14___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 10U) {
#line 1314
        goto case_10___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 6U) {
#line 1314
        goto case_6___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 2U) {
#line 1314
        goto case_2___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 13U) {
#line 1314
        goto case_13___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 9U) {
#line 1314
        goto case_9___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 5U) {
#line 1314
        goto case_5___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 1U) {
#line 1314
        goto case_1___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 16U) {
#line 1314
        goto case_16___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 12U) {
#line 1314
        goto case_12___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 8U) {
#line 1314
        goto case_8___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 4U) {
#line 1314
        goto case_4___1;
      }
#line 1314
      if ((unsigned int )sizeof(re_node_set ) == 0U) {
#line 1314
        goto case_0___1;
      }
#line 1314
      goto switch_break___1;
      case_15___1: /* CIL Label */ 
#line 1314
      __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 1314
      __u___1 = (union __anonunion___u_52 *)((void *)__u___1 + 4);
      case_11___1: /* CIL Label */ 
#line 1314
      __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 1314
      __u___1 = (union __anonunion___u_52 *)((void *)__u___1 + 4);
      case_7___1: /* CIL Label */ 
#line 1314
      __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 1314
      __u___1 = (union __anonunion___u_52 *)((void *)__u___1 + 4);
      case_3___1: /* CIL Label */ 
#line 1314
      __u___1->__usi = (unsigned short )((int )((unsigned short )__c___1) * 257);
#line 1314
      __u___1 = (union __anonunion___u_52 *)((void *)__u___1 + 2);
#line 1314
      __u___1->__uc = __c___1;
#line 1314
      goto switch_break___1;
      case_14___1: /* CIL Label */ 
#line 1314
      __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 1314
      __u___1 = (union __anonunion___u_52 *)((void *)__u___1 + 4);
      case_10___1: /* CIL Label */ 
#line 1314
      __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 1314
      __u___1 = (union __anonunion___u_52 *)((void *)__u___1 + 4);
      case_6___1: /* CIL Label */ 
#line 1314
      __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 1314
      __u___1 = (union __anonunion___u_52 *)((void *)__u___1 + 4);
      case_2___1: /* CIL Label */ 
#line 1314
      __u___1->__usi = (unsigned short )((int )((unsigned short )__c___1) * 257);
#line 1314
      goto switch_break___1;
      case_13___1: /* CIL Label */ 
#line 1314
      __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 1314
      __u___1 = (union __anonunion___u_52 *)((void *)__u___1 + 4);
      case_9___1: /* CIL Label */ 
#line 1314
      __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 1314
      __u___1 = (union __anonunion___u_52 *)((void *)__u___1 + 4);
      case_5___1: /* CIL Label */ 
#line 1314
      __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 1314
      __u___1 = (union __anonunion___u_52 *)((void *)__u___1 + 4);
      case_1___1: /* CIL Label */ 
#line 1314
      __u___1->__uc = __c___1;
#line 1314
      goto switch_break___1;
      case_16___1: /* CIL Label */ 
#line 1314
      __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 1314
      __u___1 = (union __anonunion___u_52 *)((void *)__u___1 + 4);
      case_12___1: /* CIL Label */ 
#line 1314
      __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 1314
      __u___1 = (union __anonunion___u_52 *)((void *)__u___1 + 4);
      case_8___1: /* CIL Label */ 
#line 1314
      __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 1314
      __u___1 = (union __anonunion___u_52 *)((void *)__u___1 + 4);
      case_4___1: /* CIL Label */ 
#line 1314
      __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
      case_0___1: /* CIL Label */ 
#line 1314
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1314
    __s___5 = (void *)(dfa->inveclosures + dup_idx);
    {
#line 1314
    __builtin_memset(__s___5, '\000', (int )sizeof(re_node_set ));
    }
    }
  }
#line 1317
  *(dfa->org_indices + dup_idx) = org_idx;
#line 1318
  *new_idx = dup_idx;
#line 1319
  return ((reg_errcode_t )0);
}
}
#line 1322 "regcomp.c"
static void calc_inveclosure(re_dfa_t *dfa ) 
{ 
  int src ;
  int idx ;
  int dest ;

  {
#line 1327
  src = 0;
  {
  {
#line 1327
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1327
    if (! (src < dfa->nodes_len)) {
#line 1327
      goto while_break;
    }
#line 1329
    idx = 0;
    {
    {
#line 1329
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1329
      if (! (idx < (dfa->eclosures + src)->nelem)) {
#line 1329
        goto while_break___0;
      }
      {
#line 1331
      dest = *((dfa->eclosures + src)->elems + idx);
      {
#line 1332
      re_node_set_insert(dfa->inveclosures + dest, src);
      }
#line 1329
      idx ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1327
    src ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1335
  return;
}
}
#line 1339 "regcomp.c"
static reg_errcode_t calc_eclosure(re_dfa_t *dfa ) 
{ 
  int node_idx ;
  int incomplete ;
  reg_errcode_t err ;
  re_node_set eclosure_elem ;
  long tmp ;

  {
#line 1347
  incomplete = 0;
#line 1349
  node_idx = 0;
  {
  {
#line 1349
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1353
    if (node_idx == dfa->nodes_len) {
#line 1355
      if (! incomplete) {
#line 1356
        goto while_break;
      }
#line 1357
      incomplete = 0;
#line 1358
      node_idx = 0;
    }
#line 1365
    if ((dfa->eclosures + node_idx)->nelem != 0) {
#line 1366
      goto __Cont;
    }
    {
    {
#line 1368
    err = calc_eclosure_iter(& eclosure_elem, dfa, node_idx, 1);
    }
    {
#line 1369
    tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    }
#line 1369
    if (tmp) {
#line 1370
      return (err);
    }
#line 1372
    if ((dfa->eclosures + node_idx)->nelem == 0) {
      {
#line 1374
      incomplete = 1;
      {
#line 1375
      free((void *)eclosure_elem.elems);
      }
      }
    }
    __Cont: /* CIL Label */ 
#line 1349
    node_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1378
  return ((reg_errcode_t )0);
}
}
#line 1383 "regcomp.c"
static reg_errcode_t calc_eclosure_iter(re_node_set *new_set , re_dfa_t *dfa , int node ,
                                        int root ) 
{ 
  reg_errcode_t err ;
  unsigned int constraint ;
  int i ;
  int incomplete ;
  re_node_set eclosure ;
  long tmp ;
  int org_node ;
  int cur_node ;
  long tmp___0 ;
  re_node_set eclosure_elem ;
  int edest ;
  long tmp___1 ;

  {
  {
#line 1393
  incomplete = 0;
  {
#line 1394
  err = re_node_set_alloc(& eclosure, (dfa->edests + node)->nelem + 1);
  }
  {
#line 1395
  tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 1395
  if (tmp) {
#line 1396
    return (err);
  }
#line 1400
  (dfa->eclosures + node)->nelem = -1;
#line 1402
  if ((unsigned int )(dfa->nodes + node)->type == 33U) {
#line 1402
    constraint = (unsigned int )(dfa->nodes + node)->opr.ctx_type;
  } else {
#line 1402
    constraint = 0U;
  }
#line 1406
  if (constraint) {
#line 1406
    if (! (dfa->nodes + *((dfa->edests + node)->elems + 0))->duplicated) {
      {
#line 1409
      cur_node = node;
#line 1409
      org_node = cur_node;
      {
#line 1410
      err = duplicate_node_closure(dfa, node, node, node, constraint);
      }
      {
#line 1411
      tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 1411
      if (tmp___0) {
#line 1412
        return (err);
      }
    }
  }
#line 1416
  if ((unsigned int )(dfa->nodes + node)->type == 28U) {
#line 1416
    goto _L;
  } else
#line 1416
  if ((unsigned int )(dfa->nodes + node)->type == 29U) {
#line 1416
    goto _L;
  } else
#line 1416
  if ((unsigned int )(dfa->nodes + node)->type == 30U) {
#line 1416
    goto _L;
  } else
#line 1416
  if ((unsigned int )(dfa->nodes + node)->type == 31U) {
#line 1416
    goto _L;
  } else
#line 1416
  if ((unsigned int )(dfa->nodes + node)->type == 33U) {
#line 1416
    goto _L;
  } else
#line 1416
  if ((unsigned int )(dfa->nodes + node)->type == 23U) {
#line 1416
    goto _L;
  } else
#line 1416
  if ((unsigned int )(dfa->nodes + node)->type == 24U) {
    _L: /* CIL Label */ 
#line 1417
    i = 0;
    {
    {
#line 1417
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1417
      if (! (i < (dfa->edests + node)->nelem)) {
#line 1417
        goto while_break;
      }
#line 1420
      edest = *((dfa->edests + node)->elems + i);
#line 1423
      if ((dfa->eclosures + edest)->nelem == -1) {
#line 1425
        incomplete = 1;
#line 1426
        goto __Cont;
      }
#line 1430
      if ((dfa->eclosures + edest)->nelem == 0) {
        {
        {
#line 1432
        err = calc_eclosure_iter(& eclosure_elem, dfa, edest, 0);
        }
        {
#line 1433
        tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        }
#line 1433
        if (tmp___1) {
#line 1434
          return (err);
        }
      } else {
#line 1437
        eclosure_elem = *(dfa->eclosures + edest);
      }
      {
      {
#line 1439
      re_node_set_merge(& eclosure, (re_node_set const   *)(& eclosure_elem));
      }
      }
#line 1442
      if ((dfa->eclosures + edest)->nelem == 0) {
        {
#line 1444
        incomplete = 1;
        {
#line 1445
        free((void *)eclosure_elem.elems);
        }
        }
      }
      __Cont: /* CIL Label */ 
#line 1417
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 1450
  re_node_set_insert(& eclosure, node);
  }
  }
#line 1451
  if (incomplete) {
#line 1451
    if (! root) {
#line 1452
      (dfa->eclosures + node)->nelem = 0;
    } else {
#line 1454
      *(dfa->eclosures + node) = eclosure;
    }
  } else {
#line 1454
    *(dfa->eclosures + node) = eclosure;
  }
#line 1455
  *new_set = eclosure;
#line 1456
  return ((reg_errcode_t )0);
}
}
#line 1464 "regcomp.c"
static re_token_t fetch_token(re_string_t *input , reg_syntax_t syntax ) 
{ 
  re_token_t token ;
  int consumed_byte ;

  {
  {
  {
#line 1471
  consumed_byte = peek_token(& token, input, syntax);
  }
#line 1472
  input->cur_idx += consumed_byte;
  }
#line 1473
  return (token);
}
}
#line 1479 "regcomp.c"
static int peek_token(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ 
  unsigned char c ;
  size_t tmp ;
  unsigned char c2 ;
  char prev ;
  re_token_t next ;

  {
#line 1487
  if (input->stop <= input->cur_idx) {
#line 1489
    token->type = (re_token_type_t )27;
#line 1490
    return (0);
  }
  {
#line 1493
  c = *(input->mbs + input->cur_idx);
#line 1494
  token->opr.c = c;
#line 1497
  token->mb_partial = 0U;
  {
#line 1498
  tmp = __ctype_get_mb_cur_max();
  }
  }
#line 1498
  if (tmp > 1U) {
#line 1498
    if (! (input->cur_idx == input->len)) {
#line 1498
      if (! (*(input->wcs + input->cur_idx) != 4294967295U)) {
#line 1501
        token->type = (re_token_type_t )26;
#line 1502
        token->mb_partial = 1U;
#line 1503
        return (1);
      }
    }
  }
#line 1506
  if ((int )c == 92) {
#line 1509
    if (input->cur_idx + 1 >= input->len) {
#line 1511
      token->type = (re_token_type_t )17;
#line 1512
      return (1);
    }
#line 1515
    c2 = *(input->mbs_case + (input->cur_idx + 1));
#line 1516
    token->opr.c = c2;
#line 1517
    token->type = (re_token_type_t )26;
    {
#line 1520
    if ((int )c2 == 124) {
#line 1520
      goto case_124;
    }
#line 1525
    if ((int )c2 == 57) {
#line 1525
      goto case_57;
    }
#line 1525
    if ((int )c2 == 56) {
#line 1525
      goto case_57;
    }
#line 1525
    if ((int )c2 == 55) {
#line 1525
      goto case_57;
    }
#line 1525
    if ((int )c2 == 54) {
#line 1525
      goto case_57;
    }
#line 1525
    if ((int )c2 == 53) {
#line 1525
      goto case_57;
    }
#line 1525
    if ((int )c2 == 52) {
#line 1525
      goto case_57;
    }
#line 1525
    if ((int )c2 == 51) {
#line 1525
      goto case_57;
    }
#line 1525
    if ((int )c2 == 50) {
#line 1525
      goto case_57;
    }
#line 1525
    if ((int )c2 == 49) {
#line 1525
      goto case_57;
    }
#line 1532
    if ((int )c2 == 60) {
#line 1532
      goto case_60;
    }
#line 1539
    if ((int )c2 == 62) {
#line 1539
      goto case_62;
    }
#line 1546
    if ((int )c2 == 98) {
#line 1546
      goto case_98;
    }
#line 1553
    if ((int )c2 == 66) {
#line 1553
      goto case_66;
    }
#line 1560
    if ((int )c2 == 119) {
#line 1560
      goto case_119;
    }
#line 1564
    if ((int )c2 == 87) {
#line 1564
      goto case_87;
    }
#line 1568
    if ((int )c2 == 115) {
#line 1568
      goto case_115;
    }
#line 1572
    if ((int )c2 == 83) {
#line 1572
      goto case_83;
    }
#line 1576
    if ((int )c2 == 96) {
#line 1576
      goto case_96;
    }
#line 1583
    if ((int )c2 == 39) {
#line 1583
      goto case_39;
    }
#line 1590
    if ((int )c2 == 40) {
#line 1590
      goto case_40;
    }
#line 1594
    if ((int )c2 == 41) {
#line 1594
      goto case_41;
    }
#line 1598
    if ((int )c2 == 43) {
#line 1598
      goto case_43;
    }
#line 1602
    if ((int )c2 == 63) {
#line 1602
      goto case_63;
    }
#line 1606
    if ((int )c2 == 123) {
#line 1606
      goto case_123;
    }
#line 1610
    if ((int )c2 == 125) {
#line 1610
      goto case_125;
    }
#line 1614
    goto switch_default;
    case_124: /* CIL Label */ 
#line 1521
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1521
      if (! (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1522
        token->type = (re_token_type_t )28;
      }
    }
#line 1523
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 1526
    if (! (syntax & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1528
      token->type = (re_token_type_t )32;
#line 1529
      token->opr.idx = (int )c2 - 48;
    }
#line 1531
    goto switch_break;
    case_60: /* CIL Label */ 
#line 1533
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1535
      token->type = (re_token_type_t )33;
#line 1536
      token->opr.idx = 6;
    }
#line 1538
    goto switch_break;
    case_62: /* CIL Label */ 
#line 1540
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1542
      token->type = (re_token_type_t )33;
#line 1543
      token->opr.idx = 9;
    }
#line 1545
    goto switch_break;
    case_98: /* CIL Label */ 
#line 1547
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1549
      token->type = (re_token_type_t )33;
#line 1550
      token->opr.idx = 256;
    }
#line 1552
    goto switch_break;
    case_66: /* CIL Label */ 
#line 1554
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1556
      token->type = (re_token_type_t )33;
#line 1557
      token->opr.idx = 5;
    }
#line 1559
    goto switch_break;
    case_119: /* CIL Label */ 
#line 1561
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1562
      token->type = (re_token_type_t )13;
    }
#line 1563
    goto switch_break;
    case_87: /* CIL Label */ 
#line 1565
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1566
      token->type = (re_token_type_t )14;
    }
#line 1567
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1569
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1570
      token->type = (re_token_type_t )15;
    }
#line 1571
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1573
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1574
      token->type = (re_token_type_t )16;
    }
#line 1575
    goto switch_break;
    case_96: /* CIL Label */ 
#line 1577
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1579
      token->type = (re_token_type_t )33;
#line 1580
      token->opr.idx = 64;
    }
#line 1582
    goto switch_break;
    case_39: /* CIL Label */ 
#line 1584
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1586
      token->type = (re_token_type_t )33;
#line 1587
      token->opr.idx = 128;
    }
#line 1589
    goto switch_break;
    case_40: /* CIL Label */ 
#line 1591
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1592
      token->type = (re_token_type_t )23;
    }
#line 1593
    goto switch_break;
    case_41: /* CIL Label */ 
#line 1595
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1596
      token->type = (re_token_type_t )24;
    }
#line 1597
    goto switch_break;
    case_43: /* CIL Label */ 
#line 1599
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1599
      if (syntax & (1UL << 1)) {
#line 1600
        token->type = (re_token_type_t )30;
      }
    }
#line 1601
    goto switch_break;
    case_63: /* CIL Label */ 
#line 1603
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1603
      if (syntax & (1UL << 1)) {
#line 1604
        token->type = (re_token_type_t )31;
      }
    }
#line 1605
    goto switch_break;
    case_123: /* CIL Label */ 
#line 1607
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1607
      if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1608
        token->type = (re_token_type_t )4;
      }
    }
#line 1609
    goto switch_break;
    case_125: /* CIL Label */ 
#line 1611
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1611
      if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1612
        token->type = (re_token_type_t )5;
      }
    }
#line 1613
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1615
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1617
    return (2);
  }
#line 1620
  token->type = (re_token_type_t )26;
  {
#line 1623
  if ((int )c == 10) {
#line 1623
    goto case_10;
  }
#line 1627
  if ((int )c == 124) {
#line 1627
    goto case_124___0;
  }
#line 1631
  if ((int )c == 42) {
#line 1631
    goto case_42;
  }
#line 1634
  if ((int )c == 43) {
#line 1634
    goto case_43___0;
  }
#line 1638
  if ((int )c == 63) {
#line 1638
    goto case_63___0;
  }
#line 1642
  if ((int )c == 123) {
#line 1642
    goto case_123___0;
  }
#line 1646
  if ((int )c == 125) {
#line 1646
    goto case_125___0;
  }
#line 1650
  if ((int )c == 40) {
#line 1650
    goto case_40___0;
  }
#line 1654
  if ((int )c == 41) {
#line 1654
    goto case_41___0;
  }
#line 1658
  if ((int )c == 91) {
#line 1658
    goto case_91;
  }
#line 1661
  if ((int )c == 46) {
#line 1661
    goto case_46;
  }
#line 1664
  if ((int )c == 94) {
#line 1664
    goto case_94;
  }
#line 1675
  if ((int )c == 36) {
#line 1675
    goto case_36;
  }
#line 1689
  goto switch_default___0;
  case_10: /* CIL Label */ 
#line 1624
  if (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1625
    token->type = (re_token_type_t )28;
  }
#line 1626
  goto switch_break___0;
  case_124___0: /* CIL Label */ 
#line 1628
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1628
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1629
      token->type = (re_token_type_t )28;
    }
  }
#line 1630
  goto switch_break___0;
  case_42: /* CIL Label */ 
#line 1632
  token->type = (re_token_type_t )29;
#line 1633
  goto switch_break___0;
  case_43___0: /* CIL Label */ 
#line 1635
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1635
    if (! (syntax & (1UL << 1))) {
#line 1636
      token->type = (re_token_type_t )30;
    }
  }
#line 1637
  goto switch_break___0;
  case_63___0: /* CIL Label */ 
#line 1639
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1639
    if (! (syntax & (1UL << 1))) {
#line 1640
      token->type = (re_token_type_t )31;
    }
  }
#line 1641
  goto switch_break___0;
  case_123___0: /* CIL Label */ 
#line 1643
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1643
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1644
      token->type = (re_token_type_t )4;
    }
  }
#line 1645
  goto switch_break___0;
  case_125___0: /* CIL Label */ 
#line 1647
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1647
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1648
      token->type = (re_token_type_t )5;
    }
  }
#line 1649
  goto switch_break___0;
  case_40___0: /* CIL Label */ 
#line 1651
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1652
    token->type = (re_token_type_t )23;
  }
#line 1653
  goto switch_break___0;
  case_41___0: /* CIL Label */ 
#line 1655
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1656
    token->type = (re_token_type_t )24;
  }
#line 1657
  goto switch_break___0;
  case_91: /* CIL Label */ 
#line 1659
  token->type = (re_token_type_t )1;
#line 1660
  goto switch_break___0;
  case_46: /* CIL Label */ 
#line 1662
  token->type = (re_token_type_t )25;
#line 1663
  goto switch_break___0;
  case_94: /* CIL Label */ 
#line 1665
  if (! (syntax & ((((1UL << 1) << 1) << 1) | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1665
    if (input->cur_idx != 0) {
#line 1668
      prev = (char )*(input->mbs + (input->cur_idx + -1));
#line 1669
      if (! (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1670
        goto switch_break___0;
      } else
#line 1669
      if ((int )prev != 10) {
#line 1670
        goto switch_break___0;
      }
    }
  }
#line 1672
  token->type = (re_token_type_t )33;
#line 1673
  token->opr.idx = 16;
#line 1674
  goto switch_break___0;
  case_36: /* CIL Label */ 
#line 1676
  if (! (syntax & (((1UL << 1) << 1) << 1))) {
#line 1676
    if (input->cur_idx + 1 != input->len) {
      {
#line 1680
      (input->cur_idx) ++;
      {
#line 1681
      peek_token(& next, input, syntax);
      }
#line 1682
      (input->cur_idx) --;
      }
#line 1683
      if ((unsigned int )next.type != 28U) {
#line 1683
        if ((unsigned int )next.type != 24U) {
#line 1684
          goto switch_break___0;
        }
      }
    }
  }
#line 1686
  token->type = (re_token_type_t )33;
#line 1687
  token->opr.idx = 32;
#line 1688
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1690
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1692
  return (1);
}
}
#line 1698 "regcomp.c"
static int peek_token_bracket(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ 
  unsigned char c ;
  size_t tmp ;
  unsigned char c2 ;
  unsigned char c2___0 ;
  int token_len ;

  {
#line 1705
  if (input->stop <= input->cur_idx) {
#line 1707
    token->type = (re_token_type_t )27;
#line 1708
    return (0);
  }
  {
#line 1710
  c = *(input->mbs + input->cur_idx);
#line 1711
  token->opr.c = c;
  {
#line 1714
  tmp = __ctype_get_mb_cur_max();
  }
  }
#line 1714
  if (tmp > 1U) {
#line 1714
    if (! (input->cur_idx == input->len)) {
#line 1714
      if (! (*(input->wcs + input->cur_idx) != 4294967295U)) {
#line 1717
        token->type = (re_token_type_t )26;
#line 1718
        return (1);
      }
    }
  }
#line 1722
  if ((int )c == 92) {
#line 1722
    if (syntax & 1UL) {
#line 1726
      (input->cur_idx) ++;
#line 1727
      c2 = *(input->mbs + input->cur_idx);
#line 1728
      token->opr.c = c2;
#line 1729
      token->type = (re_token_type_t )26;
#line 1730
      return (1);
    }
  }
#line 1732
  if ((int )c == 91) {
#line 1736
    c2___0 = *(input->mbs + (input->cur_idx + 1));
#line 1737
    token->opr.c = c2___0;
#line 1738
    token_len = 2;
    {
#line 1741
    if ((int )c2___0 == 46) {
#line 1741
      goto case_46;
    }
#line 1744
    if ((int )c2___0 == 61) {
#line 1744
      goto case_61;
    }
#line 1747
    if ((int )c2___0 == 58) {
#line 1747
      goto case_58;
    }
#line 1754
    goto switch_default;
    case_46: /* CIL Label */ 
#line 1742
    token->type = (re_token_type_t )7;
#line 1743
    goto switch_break;
    case_61: /* CIL Label */ 
#line 1745
    token->type = (re_token_type_t )9;
#line 1746
    goto switch_break;
    case_58: /* CIL Label */ 
#line 1748
    if (syntax & ((1UL << 1) << 1)) {
#line 1750
      token->type = (re_token_type_t )11;
#line 1751
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 1755
    token->type = (re_token_type_t )26;
#line 1756
    token->opr.c = c;
#line 1757
    token_len = 1;
#line 1758
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1760
    return (token_len);
  }
  {
#line 1764
  if ((int )c == 45) {
#line 1764
    goto case_45;
  }
#line 1767
  if ((int )c == 93) {
#line 1767
    goto case_93;
  }
#line 1770
  if ((int )c == 94) {
#line 1770
    goto case_94;
  }
#line 1773
  goto switch_default___0;
  case_45: /* CIL Label */ 
#line 1765
  token->type = (re_token_type_t )3;
#line 1766
  goto switch_break___0;
  case_93: /* CIL Label */ 
#line 1768
  token->type = (re_token_type_t )2;
#line 1769
  goto switch_break___0;
  case_94: /* CIL Label */ 
#line 1771
  token->type = (re_token_type_t )6;
#line 1772
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1774
  token->type = (re_token_type_t )26;
  switch_break___0: /* CIL Label */ ;
  }
#line 1776
  return (1);
}
}
#line 1793 "regcomp.c"
static bin_tree_t *parse(re_string_t *regexp , regex_t *preg , reg_syntax_t syntax ,
                         reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *eor ;
  bin_tree_t *root ;
  re_token_t current_token ;
  int new_idx ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1800
  dfa = (re_dfa_t *)preg->buffer;
  {
#line 1804
  current_token = fetch_token(regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
  {
#line 1805
  tree = parse_reg_exp(regexp, preg, & current_token, syntax, 0, err);
  }
  }
#line 1806
  if ((unsigned int )*err != 0U) {
#line 1806
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1806
      tmp = 1;
    } else {
#line 1806
      tmp = 0;
    }
  } else {
#line 1806
    tmp = 0;
  }
  {
  {
#line 1806
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
  }
#line 1806
  if (tmp___0) {
#line 1807
    return ((bin_tree_t *)((void *)0));
  }
  {
  {
#line 1808
  new_idx = re_dfa_add_node(dfa, current_token, 0);
  }
  {
#line 1809
  eor = create_tree((bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )0,
                    new_idx);
  }
  }
#line 1810
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
    {
    {
#line 1811
    root = create_tree(tree, eor, (re_token_type_t )18, 0);
    }
    }
  } else {
#line 1813
    root = eor;
  }
#line 1814
  if (new_idx == -1) {
#line 1814
    tmp___1 = 1;
  } else
#line 1814
  if ((unsigned long )eor == (unsigned long )((void *)0)) {
#line 1814
    tmp___1 = 1;
  } else
#line 1814
  if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 1814
    tmp___1 = 1;
  } else {
#line 1814
    tmp___1 = 0;
  }
  {
  {
#line 1814
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  }
#line 1814
  if (tmp___2) {
#line 1816
    *err = (reg_errcode_t )12;
#line 1817
    return ((bin_tree_t *)((void *)0));
  }
#line 1819
  return (root);
}
}
#line 1831 "regcomp.c"
static bin_tree_t *parse_reg_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , int nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *branch ;
  int new_idx ;
  int tmp ;
  long tmp___0 ;
  re_token_t alt_token ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 1840
  dfa = (re_dfa_t *)preg->buffer;
#line 1841
  branch = (bin_tree_t *)((void *)0);
  {
#line 1843
  tree = parse_branch(regexp, preg, token, syntax, nest, err);
  }
  }
#line 1844
  if ((unsigned int )*err != 0U) {
#line 1844
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1844
      tmp = 1;
    } else {
#line 1844
      tmp = 0;
    }
  } else {
#line 1844
    tmp = 0;
  }
  {
  {
#line 1844
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
  }
#line 1844
  if (tmp___0) {
#line 1845
    return ((bin_tree_t *)((void *)0));
  }
  {
  {
#line 1847
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1847
    if (! ((unsigned int )token->type == 28U)) {
#line 1847
      goto while_break;
    }
    {
#line 1849
    alt_token = *token;
    {
#line 1850
    new_idx = re_dfa_add_node(dfa, alt_token, 0);
    }
    {
#line 1851
    *token = fetch_token(regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    }
    }
#line 1852
    if ((unsigned int )token->type != 28U) {
#line 1852
      if ((unsigned int )token->type != 27U) {
#line 1852
        if (nest == 0) {
#line 1852
          goto _L;
        } else
#line 1852
        if ((unsigned int )token->type != 24U) {
          _L: /* CIL Label */ 
          {
          {
#line 1855
          branch = parse_branch(regexp, preg, token, syntax, nest, err);
          }
          }
#line 1856
          if ((unsigned int )*err != 0U) {
#line 1856
            if ((unsigned long )branch == (unsigned long )((void *)0)) {
#line 1856
              tmp___1 = 1;
            } else {
#line 1856
              tmp___1 = 0;
            }
          } else {
#line 1856
            tmp___1 = 0;
          }
          {
          {
#line 1856
          tmp___2 = __builtin_expect((long )tmp___1, 0L);
          }
          }
#line 1856
          if (tmp___2) {
            {
            {
#line 1858
            free_bin_tree(tree);
            }
            }
#line 1859
            return ((bin_tree_t *)((void *)0));
          }
        } else {
#line 1863
          branch = (bin_tree_t *)((void *)0);
        }
      } else {
#line 1863
        branch = (bin_tree_t *)((void *)0);
      }
    } else {
#line 1863
      branch = (bin_tree_t *)((void *)0);
    }
    {
    {
#line 1864
    tree = create_tree(tree, branch, (re_token_type_t )0, new_idx);
    }
    }
#line 1865
    if (new_idx == -1) {
#line 1865
      tmp___3 = 1;
    } else
#line 1865
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1865
      tmp___3 = 1;
    } else {
#line 1865
      tmp___3 = 0;
    }
    {
    {
#line 1865
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
    }
    }
#line 1865
    if (tmp___4) {
#line 1867
      *err = (reg_errcode_t )12;
#line 1868
      return ((bin_tree_t *)((void *)0));
    }
#line 1870
    dfa->has_plural_match = 1U;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1872
  return (tree);
}
}
#line 1884 "regcomp.c"
static bin_tree_t *parse_branch(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                reg_syntax_t syntax , int nest , reg_errcode_t *err ) 
{ 
  bin_tree_t *tree ;
  bin_tree_t *exp ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  {
#line 1894
  tree = parse_expression(regexp, preg, token, syntax, nest, err);
  }
  }
#line 1895
  if ((unsigned int )*err != 0U) {
#line 1895
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1895
      tmp = 1;
    } else {
#line 1895
      tmp = 0;
    }
  } else {
#line 1895
    tmp = 0;
  }
  {
  {
#line 1895
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
  }
#line 1895
  if (tmp___0) {
#line 1896
    return ((bin_tree_t *)((void *)0));
  }
  {
  {
#line 1898
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1898
    if ((unsigned int )token->type != 28U) {
#line 1898
      if ((unsigned int )token->type != 27U) {
#line 1898
        if (! (nest == 0)) {
#line 1898
          if (! ((unsigned int )token->type != 24U)) {
#line 1898
            goto while_break;
          }
        }
      } else {
#line 1898
        goto while_break;
      }
    } else {
#line 1898
      goto while_break;
    }
    {
    {
#line 1901
    exp = parse_expression(regexp, preg, token, syntax, nest, err);
    }
    }
#line 1902
    if ((unsigned int )*err != 0U) {
#line 1902
      if ((unsigned long )exp == (unsigned long )((void *)0)) {
#line 1902
        tmp___1 = 1;
      } else {
#line 1902
        tmp___1 = 0;
      }
    } else {
#line 1902
      tmp___1 = 0;
    }
    {
    {
#line 1902
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    }
#line 1902
    if (tmp___2) {
      {
      {
#line 1904
      free_bin_tree(tree);
      }
      }
#line 1905
      return ((bin_tree_t *)((void *)0));
    }
#line 1907
    if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 1907
      if ((unsigned long )exp != (unsigned long )((void *)0)) {
        {
        {
#line 1909
        tree = create_tree(tree, exp, (re_token_type_t )18, 0);
        }
        }
#line 1910
        if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1912
          *err = (reg_errcode_t )12;
#line 1913
          return ((bin_tree_t *)((void *)0));
        }
      } else {
#line 1907
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1916
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1917
      tree = exp;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1920
  return (tree);
}
}
#line 1929 "regcomp.c"
static bin_tree_t *parse_expression(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , int nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  int new_idx ;
  int tmp ;
  long tmp___0 ;
  bin_tree_t *mbc_remain ;
  int tmp___1 ;
  long tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  bin_tree_t *tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  bin_tree_t *tree_first ;
  bin_tree_t *tree_last ;
  int idx_first ;
  int idx_last ;
  int tmp___16 ;
  long tmp___17 ;
  int tmp___18 ;
  long tmp___19 ;
  int tmp___20 ;
  long tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  long tmp___24 ;
  int tmp___25 ;
  long tmp___26 ;
  int tmp___27 ;
  long tmp___28 ;
  int tmp___29 ;
  long tmp___30 ;
  int tmp___31 ;
  long tmp___32 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
#line 1938
  dfa = (re_dfa_t *)preg->buffer;
  {
#line 1943
  if ((unsigned int )token->type == 26U) {
#line 1943
    goto case_26;
  }
#line 1971
  if ((unsigned int )token->type == 23U) {
#line 1971
    goto case_23;
  }
#line 1976
  if ((unsigned int )token->type == 1U) {
#line 1976
    goto case_1;
  }
#line 1981
  if ((unsigned int )token->type == 32U) {
#line 1981
    goto case_32;
  }
#line 2002
  if ((unsigned int )token->type == 4U) {
#line 2002
    goto case_4;
  }
#line 2002
  if ((unsigned int )token->type == 31U) {
#line 2002
    goto case_4;
  }
#line 2002
  if ((unsigned int )token->type == 30U) {
#line 2002
    goto case_4;
  }
#line 2002
  if ((unsigned int )token->type == 29U) {
#line 2002
    goto case_4;
  }
#line 2014
  if ((unsigned int )token->type == 24U) {
#line 2014
    goto case_24;
  }
#line 2022
  if ((unsigned int )token->type == 5U) {
#line 2022
    goto case_5;
  }
#line 2035
  if ((unsigned int )token->type == 33U) {
#line 2035
    goto case_33;
  }
#line 2079
  if ((unsigned int )token->type == 25U) {
#line 2079
    goto case_25;
  }
#line 2090
  if ((unsigned int )token->type == 13U) {
#line 2090
    goto case_13;
  }
#line 2095
  if ((unsigned int )token->type == 14U) {
#line 2095
    goto case_14;
  }
#line 2100
  if ((unsigned int )token->type == 15U) {
#line 2100
    goto case_15;
  }
#line 2105
  if ((unsigned int )token->type == 16U) {
#line 2105
    goto case_16;
  }
#line 2111
  if ((unsigned int )token->type == 27U) {
#line 2111
    goto case_27;
  }
#line 2111
  if ((unsigned int )token->type == 28U) {
#line 2111
    goto case_27;
  }
#line 2113
  if ((unsigned int )token->type == 17U) {
#line 2113
    goto case_17;
  }
#line 2116
  goto switch_default;
  case_26: /* CIL Label */ 
  {
  {
#line 1944
  new_idx = re_dfa_add_node(dfa, *token, 0);
  }
  {
#line 1945
  tree = create_tree((bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )0,
                     new_idx);
  }
  }
#line 1946
  if (new_idx == -1) {
#line 1946
    tmp = 1;
  } else
#line 1946
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1946
    tmp = 1;
  } else {
#line 1946
    tmp = 0;
  }
  {
  {
#line 1946
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
  }
#line 1946
  if (tmp___0) {
#line 1948
    *err = (reg_errcode_t )12;
#line 1949
    return ((bin_tree_t *)((void *)0));
  }
  {
  {
#line 1952
  tmp___3 = __ctype_get_mb_cur_max();
  }
  }
#line 1952
  if (tmp___3 > 1U) {
    {
    {
#line 1954
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1954
      if (! (regexp->stop <= regexp->cur_idx)) {
#line 1954
        if (regexp->cur_idx == regexp->len) {
#line 1954
          goto while_break;
        } else
#line 1954
        if (*(regexp->wcs + regexp->cur_idx) != 4294967295U) {
#line 1954
          goto while_break;
        }
      } else {
#line 1954
        goto while_break;
      }
      {
      {
#line 1958
      *token = fetch_token(regexp, syntax);
      }
      {
#line 1959
      new_idx = re_dfa_add_node(dfa, *token, 0);
      }
      {
#line 1960
      mbc_remain = create_tree((bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                               (re_token_type_t )0, new_idx);
      }
      {
#line 1961
      tree = create_tree(tree, mbc_remain, (re_token_type_t )18, 0);
      }
      }
#line 1962
      if (new_idx == -1) {
#line 1962
        tmp___1 = 1;
      } else
#line 1962
      if ((unsigned long )mbc_remain == (unsigned long )((void *)0)) {
#line 1962
        tmp___1 = 1;
      } else
#line 1962
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1962
        tmp___1 = 1;
      } else {
#line 1962
        tmp___1 = 0;
      }
      {
      {
#line 1962
      tmp___2 = __builtin_expect((long )tmp___1, 0L);
      }
      }
#line 1962
      if (tmp___2) {
#line 1964
        *err = (reg_errcode_t )12;
#line 1965
        return ((bin_tree_t *)((void *)0));
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1970
  goto switch_break;
  case_23: /* CIL Label */ 
  {
  {
#line 1972
  tree = parse_sub_exp(regexp, preg, token, syntax, nest + 1, err);
  }
  }
#line 1973
  if ((unsigned int )*err != 0U) {
#line 1973
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1973
      tmp___4 = 1;
    } else {
#line 1973
      tmp___4 = 0;
    }
  } else {
#line 1973
    tmp___4 = 0;
  }
  {
  {
#line 1973
  tmp___5 = __builtin_expect((long )tmp___4, 0L);
  }
  }
#line 1973
  if (tmp___5) {
#line 1974
    return ((bin_tree_t *)((void *)0));
  }
#line 1975
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 1977
  tree = parse_bracket_exp(regexp, dfa, token, syntax, err);
  }
  }
#line 1978
  if ((unsigned int )*err != 0U) {
#line 1978
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1978
      tmp___6 = 1;
    } else {
#line 1978
      tmp___6 = 0;
    }
  } else {
#line 1978
    tmp___6 = 0;
  }
  {
  {
#line 1978
  tmp___7 = __builtin_expect((long )tmp___6, 0L);
  }
  }
#line 1978
  if (tmp___7) {
#line 1979
    return ((bin_tree_t *)((void *)0));
  }
#line 1980
  goto switch_break;
  case_32: /* CIL Label */ 
#line 1982
  if (preg->re_nsub < (size_t )token->opr.idx) {
#line 1982
    tmp___8 = 1;
  } else
#line 1982
  if ((dfa->subexps + (token->opr.idx - 1))->end == -1) {
#line 1982
    tmp___8 = 1;
  } else {
#line 1982
    tmp___8 = 0;
  }
  {
  {
#line 1982
  tmp___9 = __builtin_expect((long )tmp___8, 0L);
  }
  }
#line 1982
  if (tmp___9) {
#line 1985
    *err = (reg_errcode_t )6;
#line 1986
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 1988
  dfa->used_bkref_map |= (unsigned int )(1 << (token->opr.idx - 1));
  {
#line 1989
  new_idx = re_dfa_add_node(dfa, *token, 0);
  }
  {
#line 1990
  tree = create_tree((bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )0,
                     new_idx);
  }
  }
#line 1991
  if (new_idx == -1) {
#line 1991
    tmp___10 = 1;
  } else
#line 1991
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1991
    tmp___10 = 1;
  } else {
#line 1991
    tmp___10 = 0;
  }
  {
  {
#line 1991
  tmp___11 = __builtin_expect((long )tmp___10, 0L);
  }
  }
#line 1991
  if (tmp___11) {
#line 1993
    *err = (reg_errcode_t )12;
#line 1994
    return ((bin_tree_t *)((void *)0));
  }
#line 1996
  (dfa->nbackref) ++;
#line 1997
  dfa->has_mb_node = 1U;
#line 1998
  goto switch_break;
  case_4: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
#line 2003
  if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
#line 2005
    *err = (reg_errcode_t )13;
#line 2006
    return ((bin_tree_t *)((void *)0));
  } else
#line 2008
  if (syntax & ((((1UL << 1) << 1) << 1) << 1)) {
    {
    {
#line 2010
    *token = fetch_token(regexp, syntax);
    }
    {
#line 2011
    tmp___12 = parse_expression(regexp, preg, token, syntax, nest, err);
    }
    }
#line 2011
    return (tmp___12);
  }
  case_24: /* CIL Label */ 
#line 2015
  if ((unsigned int )token->type == 24U) {
#line 2015
    if (! (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2018
      *err = (reg_errcode_t )16;
#line 2019
      return ((bin_tree_t *)((void *)0));
    }
  }
  case_5: /* CIL Label */ 
  {
#line 2026
  token->type = (re_token_type_t )26;
  {
#line 2027
  new_idx = re_dfa_add_node(dfa, *token, 0);
  }
  {
#line 2028
  tree = create_tree((bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )0,
                     new_idx);
  }
  }
#line 2029
  if (new_idx == -1) {
#line 2029
    tmp___13 = 1;
  } else
#line 2029
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2029
    tmp___13 = 1;
  } else {
#line 2029
    tmp___13 = 0;
  }
  {
  {
#line 2029
  tmp___14 = __builtin_expect((long )tmp___13, 0L);
  }
  }
#line 2029
  if (tmp___14) {
#line 2031
    *err = (reg_errcode_t )12;
#line 2032
    return ((bin_tree_t *)((void *)0));
  }
#line 2034
  goto switch_break;
  case_33: /* CIL Label */ 
#line 2036
  if ((unsigned long )dfa->word_char == (unsigned long )((void *)0)) {
    {
    {
#line 2038
    *err = init_word_char(dfa);
    }
    {
#line 2039
    tmp___15 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
    }
    }
#line 2039
    if (tmp___15) {
#line 2040
      return ((bin_tree_t *)((void *)0));
    }
  }
#line 2042
  if ((unsigned int )token->opr.ctx_type == 256U) {
    {
#line 2046
    token->opr.ctx_type = (re_context_type )6;
    {
#line 2047
    idx_first = re_dfa_add_node(dfa, *token, 0);
    }
    {
#line 2048
    tree_first = create_tree((bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                             (re_token_type_t )0, idx_first);
    }
#line 2049
    token->opr.ctx_type = (re_context_type )9;
    {
#line 2050
    idx_last = re_dfa_add_node(dfa, *token, 0);
    }
    {
#line 2051
    tree_last = create_tree((bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                            (re_token_type_t )0, idx_last);
    }
#line 2052
    token->type = (re_token_type_t )28;
    {
#line 2053
    new_idx = re_dfa_add_node(dfa, *token, 0);
    }
    {
#line 2054
    tree = create_tree(tree_first, tree_last, (re_token_type_t )0, new_idx);
    }
    }
#line 2055
    if (idx_first == -1) {
#line 2055
      tmp___16 = 1;
    } else
#line 2055
    if (idx_last == -1) {
#line 2055
      tmp___16 = 1;
    } else
#line 2055
    if (new_idx == -1) {
#line 2055
      tmp___16 = 1;
    } else
#line 2055
    if ((unsigned long )tree_first == (unsigned long )((void *)0)) {
#line 2055
      tmp___16 = 1;
    } else
#line 2055
    if ((unsigned long )tree_last == (unsigned long )((void *)0)) {
#line 2055
      tmp___16 = 1;
    } else
#line 2055
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2055
      tmp___16 = 1;
    } else {
#line 2055
      tmp___16 = 0;
    }
    {
    {
#line 2055
    tmp___17 = __builtin_expect((long )tmp___16, 0L);
    }
    }
#line 2055
    if (tmp___17) {
#line 2059
      *err = (reg_errcode_t )12;
#line 2060
      return ((bin_tree_t *)((void *)0));
    }
  } else {
    {
    {
#line 2065
    new_idx = re_dfa_add_node(dfa, *token, 0);
    }
    {
#line 2066
    tree = create_tree((bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )0,
                       new_idx);
    }
    }
#line 2067
    if (new_idx == -1) {
#line 2067
      tmp___18 = 1;
    } else
#line 2067
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2067
      tmp___18 = 1;
    } else {
#line 2067
      tmp___18 = 0;
    }
    {
    {
#line 2067
    tmp___19 = __builtin_expect((long )tmp___18, 0L);
    }
    }
#line 2067
    if (tmp___19) {
#line 2069
      *err = (reg_errcode_t )12;
#line 2070
      return ((bin_tree_t *)((void *)0));
    }
  }
  {
  {
#line 2077
  *token = fetch_token(regexp, syntax);
  }
  }
#line 2078
  return (tree);
  case_25: /* CIL Label */ 
  {
  {
#line 2080
  new_idx = re_dfa_add_node(dfa, *token, 0);
  }
  {
#line 2081
  tree = create_tree((bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )0,
                     new_idx);
  }
  }
#line 2082
  if (new_idx == -1) {
#line 2082
    tmp___20 = 1;
  } else
#line 2082
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2082
    tmp___20 = 1;
  } else {
#line 2082
    tmp___20 = 0;
  }
  {
  {
#line 2082
  tmp___21 = __builtin_expect((long )tmp___20, 0L);
  }
  }
#line 2082
  if (tmp___21) {
#line 2084
    *err = (reg_errcode_t )12;
#line 2085
    return ((bin_tree_t *)((void *)0));
  }
  {
  {
#line 2087
  tmp___22 = __ctype_get_mb_cur_max();
  }
  }
#line 2087
  if (tmp___22 > 1U) {
#line 2088
    dfa->has_mb_node = 1U;
  }
#line 2089
  goto switch_break;
  case_13: /* CIL Label */ 
  {
  {
#line 2091
  tree = build_charclass_op(dfa, regexp->trans, (unsigned char const   *)"alnum",
                            (unsigned char const   *)"_", 0, err);
  }
  }
#line 2092
  if ((unsigned int )*err != 0U) {
#line 2092
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2092
      tmp___23 = 1;
    } else {
#line 2092
      tmp___23 = 0;
    }
  } else {
#line 2092
    tmp___23 = 0;
  }
  {
  {
#line 2092
  tmp___24 = __builtin_expect((long )tmp___23, 0L);
  }
  }
#line 2092
  if (tmp___24) {
#line 2093
    return ((bin_tree_t *)((void *)0));
  }
#line 2094
  goto switch_break;
  case_14: /* CIL Label */ 
  {
  {
#line 2096
  tree = build_charclass_op(dfa, regexp->trans, (unsigned char const   *)"alnum",
                            (unsigned char const   *)"_", 1, err);
  }
  }
#line 2097
  if ((unsigned int )*err != 0U) {
#line 2097
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2097
      tmp___25 = 1;
    } else {
#line 2097
      tmp___25 = 0;
    }
  } else {
#line 2097
    tmp___25 = 0;
  }
  {
  {
#line 2097
  tmp___26 = __builtin_expect((long )tmp___25, 0L);
  }
  }
#line 2097
  if (tmp___26) {
#line 2098
    return ((bin_tree_t *)((void *)0));
  }
#line 2099
  goto switch_break;
  case_15: /* CIL Label */ 
  {
  {
#line 2101
  tree = build_charclass_op(dfa, regexp->trans, (unsigned char const   *)"space",
                            (unsigned char const   *)"", 0, err);
  }
  }
#line 2102
  if ((unsigned int )*err != 0U) {
#line 2102
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2102
      tmp___27 = 1;
    } else {
#line 2102
      tmp___27 = 0;
    }
  } else {
#line 2102
    tmp___27 = 0;
  }
  {
  {
#line 2102
  tmp___28 = __builtin_expect((long )tmp___27, 0L);
  }
  }
#line 2102
  if (tmp___28) {
#line 2103
    return ((bin_tree_t *)((void *)0));
  }
#line 2104
  goto switch_break;
  case_16: /* CIL Label */ 
  {
  {
#line 2106
  tree = build_charclass_op(dfa, regexp->trans, (unsigned char const   *)"space",
                            (unsigned char const   *)"", 1, err);
  }
  }
#line 2107
  if ((unsigned int )*err != 0U) {
#line 2107
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2107
      tmp___29 = 1;
    } else {
#line 2107
      tmp___29 = 0;
    }
  } else {
#line 2107
    tmp___29 = 0;
  }
  {
  {
#line 2107
  tmp___30 = __builtin_expect((long )tmp___29, 0L);
  }
  }
#line 2107
  if (tmp___30) {
#line 2108
    return ((bin_tree_t *)((void *)0));
  }
#line 2109
  goto switch_break;
  case_27: /* CIL Label */ 
  case_28: /* CIL Label */ 
#line 2112
  return ((bin_tree_t *)((void *)0));
  case_17: /* CIL Label */ 
#line 2114
  *err = (reg_errcode_t )5;
#line 2115
  return ((bin_tree_t *)((void *)0));
  switch_default: /* CIL Label */ 
#line 2121
  return ((bin_tree_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 2123
  *token = fetch_token(regexp, syntax);
  }
  }
  {
  {
#line 2125
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 2125
    if (! ((unsigned int )token->type == 29U)) {
#line 2125
      if (! ((unsigned int )token->type == 30U)) {
#line 2125
        if (! ((unsigned int )token->type == 31U)) {
#line 2125
          if (! ((unsigned int )token->type == 4U)) {
#line 2125
            goto while_break___0;
          }
        }
      }
    }
    {
    {
#line 2128
    tree = parse_dup_op(tree, regexp, dfa, token, syntax, err);
    }
    }
#line 2129
    if ((unsigned int )*err != 0U) {
#line 2129
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2129
        tmp___31 = 1;
      } else {
#line 2129
        tmp___31 = 0;
      }
    } else {
#line 2129
      tmp___31 = 0;
    }
    {
    {
#line 2129
    tmp___32 = __builtin_expect((long )tmp___31, 0L);
    }
    }
#line 2129
    if (tmp___32) {
#line 2130
      return ((bin_tree_t *)((void *)0));
    }
#line 2131
    dfa->has_plural_match = 1U;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2134
  return (tree);
}
}
#line 2144 "regcomp.c"
static bin_tree_t *parse_sub_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , int nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *left_par ;
  bin_tree_t *right_par ;
  size_t cur_nsub ;
  int new_idx ;
  size_t tmp ;
  re_subexp_t *new_array ;
  void *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  bin_tree_t *tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;

  {
#line 2153
  dfa = (re_dfa_t *)preg->buffer;
#line 2157
  tmp = preg->re_nsub;
#line 2157
  (preg->re_nsub) ++;
#line 2157
  cur_nsub = tmp;
#line 2158
  if ((size_t )dfa->subexps_alloc < preg->re_nsub) {
    {
#line 2161
    dfa->subexps_alloc *= 2;
    {
#line 2162
    tmp___0 = realloc((void *)dfa->subexps, (size_t )((unsigned long )dfa->subexps_alloc * sizeof(re_subexp_t )));
    }
#line 2162
    new_array = (re_subexp_t *)tmp___0;
    {
#line 2163
    tmp___1 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 2163
    if (tmp___1) {
#line 2165
      dfa->subexps_alloc /= 2;
#line 2166
      *err = (reg_errcode_t )12;
#line 2167
      return ((bin_tree_t *)((void *)0));
    }
#line 2169
    dfa->subexps = new_array;
  }
  {
#line 2171
  (dfa->subexps + cur_nsub)->start = dfa->nodes_len;
#line 2172
  (dfa->subexps + cur_nsub)->end = -1;
  {
#line 2174
  new_idx = re_dfa_add_node(dfa, *token, 0);
  }
  {
#line 2175
  left_par = create_tree((bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )0,
                         new_idx);
  }
  }
#line 2176
  if (new_idx == -1) {
#line 2176
    tmp___2 = 1;
  } else
#line 2176
  if ((unsigned long )left_par == (unsigned long )((void *)0)) {
#line 2176
    tmp___2 = 1;
  } else {
#line 2176
    tmp___2 = 0;
  }
  {
  {
#line 2176
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
  }
  }
#line 2176
  if (tmp___3) {
#line 2178
    *err = (reg_errcode_t )12;
#line 2179
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2181
  (dfa->nodes + new_idx)->opr.idx = (int )cur_nsub;
  {
#line 2182
  *token = fetch_token(regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
  }
#line 2185
  if ((unsigned int )token->type == 24U) {
#line 2186
    tree = (bin_tree_t *)((void *)0);
  } else {
    {
    {
#line 2189
    tree = parse_reg_exp(regexp, preg, token, syntax, nest, err);
    }
    }
#line 2190
    if ((unsigned int )*err != 0U) {
#line 2190
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2190
        tmp___4 = 1;
      } else {
#line 2190
        tmp___4 = 0;
      }
    } else {
#line 2190
      tmp___4 = 0;
    }
    {
    {
#line 2190
    tmp___5 = __builtin_expect((long )tmp___4, 0L);
    }
    }
#line 2190
    if (tmp___5) {
#line 2191
      return ((bin_tree_t *)((void *)0));
    }
  }
  {
  {
#line 2193
  tmp___6 = __builtin_expect((long )((unsigned int )token->type != 24U), 0L);
  }
  }
#line 2193
  if (tmp___6) {
    {
    {
#line 2195
    free_bin_tree(tree);
    }
#line 2196
    *err = (reg_errcode_t )2;
    }
#line 2197
    return ((bin_tree_t *)((void *)0));
  }
  {
  {
#line 2199
  new_idx = re_dfa_add_node(dfa, *token, 0);
  }
#line 2200
  (dfa->subexps + cur_nsub)->end = dfa->nodes_len;
  {
#line 2201
  right_par = create_tree((bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )0,
                          new_idx);
  }
  }
#line 2202
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2202
    tree = right_par;
  } else {
    {
    {
#line 2202
    tmp___7 = create_tree(tree, right_par, (re_token_type_t )18, 0);
    }
#line 2202
    tree = tmp___7;
    }
  }
  {
  {
#line 2204
  tree = create_tree(left_par, tree, (re_token_type_t )18, 0);
  }
  }
#line 2205
  if (new_idx == -1) {
#line 2205
    tmp___8 = 1;
  } else
#line 2205
  if ((unsigned long )right_par == (unsigned long )((void *)0)) {
#line 2205
    tmp___8 = 1;
  } else
#line 2205
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2205
    tmp___8 = 1;
  } else {
#line 2205
    tmp___8 = 0;
  }
  {
  {
#line 2205
  tmp___9 = __builtin_expect((long )tmp___8, 0L);
  }
  }
#line 2205
  if (tmp___9) {
#line 2207
    *err = (reg_errcode_t )12;
#line 2208
    return ((bin_tree_t *)((void *)0));
  }
#line 2210
  (dfa->nodes + new_idx)->opr.idx = (int )cur_nsub;
#line 2212
  return (tree);
}
}
#line 2217 "regcomp.c"
static bin_tree_t *parse_dup_op(bin_tree_t *dup_elem , re_string_t *regexp , re_dfa_t *dfa ,
                                re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err ) 
{ 
  re_token_t dup_token ;
  bin_tree_t *tree ;
  bin_tree_t *work_tree ;
  int new_idx ;
  int start_idx ;
  re_token_t start_token ;
  int i ;
  int end ;
  int start ;
  int tmp ;
  bin_tree_t *elem ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  long tmp___16 ;
  int tmp___17 ;
  long tmp___18 ;
  int tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;

  {
#line 2227
  tree = dup_elem;
#line 2228
  start_idx = regexp->cur_idx;
#line 2229
  start_token = *token;
#line 2230
  if ((unsigned int )token->type == 4U) {
    {
#line 2233
    end = 0;
    {
#line 2234
    tmp = fetch_number(regexp, token, syntax);
    }
#line 2234
    start = tmp;
    }
#line 2236
    if (start == -1) {
#line 2238
      if ((unsigned int )token->type == 26U) {
#line 2238
        if ((int )token->opr.c == 44) {
#line 2239
          start = 0;
        } else {
#line 2242
          *err = (reg_errcode_t )10;
#line 2243
          return ((bin_tree_t *)((void *)0));
        }
      } else {
#line 2242
        *err = (reg_errcode_t )10;
#line 2243
        return ((bin_tree_t *)((void *)0));
      }
    }
    {
    {
#line 2246
    tmp___2 = __builtin_expect((long )(start != -2), 1L);
    }
    }
#line 2246
    if (tmp___2) {
#line 2249
      if ((unsigned int )token->type == 5U) {
#line 2249
        end = start;
      } else {
#line 2249
        if ((unsigned int )token->type == 26U) {
#line 2249
          if ((int )token->opr.c == 44) {
            {
            {
#line 2249
            tmp___0 = fetch_number(regexp, token, syntax);
            }
#line 2249
            tmp___1 = tmp___0;
            }
          } else {
#line 2249
            tmp___1 = -2;
          }
        } else {
#line 2249
          tmp___1 = -2;
        }
#line 2249
        end = tmp___1;
      }
    }
#line 2253
    if (start == -2) {
#line 2253
      tmp___3 = 1;
    } else
#line 2253
    if (end == -2) {
#line 2253
      tmp___3 = 1;
    } else {
#line 2253
      tmp___3 = 0;
    }
    {
    {
#line 2253
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
    }
    }
#line 2253
    if (tmp___4) {
#line 2256
      if ((unsigned int )token->type == 5U) {
#line 2257
        goto parse_dup_op_invalid_interval;
      } else {
#line 2259
        goto parse_dup_op_ebrace;
      }
    }
#line 2261
    if (start == 0) {
#line 2261
      if (end == 0) {
#line 2261
        tmp___5 = 1;
      } else {
#line 2261
        tmp___5 = 0;
      }
    } else {
#line 2261
      tmp___5 = 0;
    }
    {
    {
#line 2261
    tmp___6 = __builtin_expect((long )tmp___5, 0L);
    }
    }
#line 2261
    if (tmp___6) {
      {
      {
#line 2264
      *token = fetch_token(regexp, syntax);
      }
      {
#line 2265
      free_bin_tree(dup_elem);
      }
      }
#line 2266
      return ((bin_tree_t *)((void *)0));
    }
#line 2270
    elem = tree;
#line 2271
    i = 0;
    {
    {
#line 2271
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 2271
      if (! (i < start)) {
#line 2271
        goto while_break;
      }
#line 2272
      if (i != 0) {
        {
        {
#line 2274
        work_tree = duplicate_tree((bin_tree_t const   *)elem, dfa);
        }
        {
#line 2275
        tree = create_tree(tree, work_tree, (re_token_type_t )18, 0);
        }
        }
#line 2276
        if ((unsigned long )work_tree == (unsigned long )((void *)0)) {
#line 2276
          tmp___7 = 1;
        } else
#line 2276
        if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2276
          tmp___7 = 1;
        } else {
#line 2276
          tmp___7 = 0;
        }
        {
        {
#line 2276
        tmp___8 = __builtin_expect((long )tmp___7, 0L);
        }
        }
#line 2276
        if (tmp___8) {
#line 2277
          goto parse_dup_op_espace;
        }
      }
#line 2271
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 2280
    if (end == -1) {
#line 2283
      dup_token.type = (re_token_type_t )29;
#line 2284
      if (start > 0) {
        {
        {
#line 2286
        elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
        }
        {
#line 2287
        new_idx = re_dfa_add_node(dfa, dup_token, 0);
        }
        {
#line 2288
        work_tree = create_tree(elem, (bin_tree_t *)((void *)0), (re_token_type_t )0,
                                new_idx);
        }
        {
#line 2289
        tree = create_tree(tree, work_tree, (re_token_type_t )18, 0);
        }
        }
#line 2290
        if ((unsigned long )elem == (unsigned long )((void *)0)) {
#line 2290
          tmp___9 = 1;
        } else
#line 2290
        if (new_idx == -1) {
#line 2290
          tmp___9 = 1;
        } else
#line 2290
        if ((unsigned long )work_tree == (unsigned long )((void *)0)) {
#line 2290
          tmp___9 = 1;
        } else
#line 2290
        if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2290
          tmp___9 = 1;
        } else {
#line 2290
          tmp___9 = 0;
        }
        {
        {
#line 2290
        tmp___10 = __builtin_expect((long )tmp___9, 0L);
        }
        }
#line 2290
        if (tmp___10) {
#line 2292
          goto parse_dup_op_espace;
        }
      } else {
        {
        {
#line 2296
        new_idx = re_dfa_add_node(dfa, dup_token, 0);
        }
        {
#line 2297
        tree = create_tree(elem, (bin_tree_t *)((void *)0), (re_token_type_t )0, new_idx);
        }
        }
#line 2298
        if (new_idx == -1) {
#line 2298
          tmp___11 = 1;
        } else
#line 2298
        if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2298
          tmp___11 = 1;
        } else {
#line 2298
          tmp___11 = 0;
        }
        {
        {
#line 2298
        tmp___12 = __builtin_expect((long )tmp___11, 0L);
        }
        }
#line 2298
        if (tmp___12) {
#line 2299
          goto parse_dup_op_espace;
        }
      }
    } else
#line 2302
    if (end - start > 0) {
#line 2305
      dup_token.type = (re_token_type_t )31;
#line 2306
      if (start > 0) {
        {
        {
#line 2308
        elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
        }
        {
#line 2309
        new_idx = re_dfa_add_node(dfa, dup_token, 0);
        }
        {
#line 2310
        elem = create_tree(elem, (bin_tree_t *)((void *)0), (re_token_type_t )0, new_idx);
        }
        {
#line 2311
        tree = create_tree(tree, elem, (re_token_type_t )18, 0);
        }
        }
#line 2312
        if ((unsigned long )elem == (unsigned long )((void *)0)) {
#line 2312
          tmp___13 = 1;
        } else
#line 2312
        if (new_idx == -1) {
#line 2312
          tmp___13 = 1;
        } else
#line 2312
        if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2312
          tmp___13 = 1;
        } else {
#line 2312
          tmp___13 = 0;
        }
        {
        {
#line 2312
        tmp___14 = __builtin_expect((long )tmp___13, 0L);
        }
        }
#line 2312
        if (tmp___14) {
#line 2313
          goto parse_dup_op_espace;
        }
      } else {
        {
        {
#line 2317
        new_idx = re_dfa_add_node(dfa, dup_token, 0);
        }
        {
#line 2318
        elem = create_tree(elem, (bin_tree_t *)((void *)0), (re_token_type_t )0, new_idx);
        }
#line 2318
        tree = elem;
        }
#line 2319
        if (new_idx == -1) {
#line 2319
          tmp___15 = 1;
        } else
#line 2319
        if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2319
          tmp___15 = 1;
        } else {
#line 2319
          tmp___15 = 0;
        }
        {
        {
#line 2319
        tmp___16 = __builtin_expect((long )tmp___15, 0L);
        }
        }
#line 2319
        if (tmp___16) {
#line 2320
          goto parse_dup_op_espace;
        }
      }
#line 2322
      i = 1;
      {
      {
#line 2322
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 2322
        if (! (i < end - start)) {
#line 2322
          goto while_break___0;
        }
        {
        {
#line 2324
        work_tree = duplicate_tree((bin_tree_t const   *)elem, dfa);
        }
        {
#line 2325
        tree = create_tree(tree, work_tree, (re_token_type_t )18, 0);
        }
        }
#line 2326
        if ((unsigned long )work_tree == (unsigned long )((void *)0)) {
#line 2326
          tmp___17 = 1;
        } else
#line 2326
        if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2326
          tmp___17 = 1;
        } else {
#line 2326
          tmp___17 = 0;
        }
        {
        {
#line 2326
        tmp___18 = __builtin_expect((long )tmp___17, 0L);
        }
        }
#line 2326
        if (tmp___18) {
#line 2328
          *err = (reg_errcode_t )12;
#line 2329
          return ((bin_tree_t *)((void *)0));
        }
#line 2322
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
    {
    {
#line 2336
    new_idx = re_dfa_add_node(dfa, *token, 0);
    }
    {
#line 2337
    tree = create_tree(tree, (bin_tree_t *)((void *)0), (re_token_type_t )0, new_idx);
    }
    }
#line 2338
    if (new_idx == -1) {
#line 2338
      tmp___19 = 1;
    } else
#line 2338
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2338
      tmp___19 = 1;
    } else {
#line 2338
      tmp___19 = 0;
    }
    {
    {
#line 2338
    tmp___20 = __builtin_expect((long )tmp___19, 0L);
    }
    }
#line 2338
    if (tmp___20) {
#line 2340
      *err = (reg_errcode_t )12;
#line 2341
      return ((bin_tree_t *)((void *)0));
    }
  }
  {
  {
#line 2344
  *token = fetch_token(regexp, syntax);
  }
  }
#line 2345
  return (tree);
  parse_dup_op_espace: 
  {
  {
#line 2348
  free_bin_tree(tree);
  }
#line 2349
  *err = (reg_errcode_t )12;
  }
#line 2350
  return ((bin_tree_t *)((void *)0));
  parse_dup_op_ebrace: 
  {
  {
#line 2353
  tmp___21 = __builtin_expect((long )(! (syntax & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))),
                              0L);
  }
  }
#line 2353
  if (tmp___21) {
#line 2355
    *err = (reg_errcode_t )9;
#line 2356
    return ((bin_tree_t *)((void *)0));
  }
#line 2358
  goto parse_dup_op_rollback;
  parse_dup_op_invalid_interval: 
  {
  {
#line 2360
  tmp___22 = __builtin_expect((long )(! (syntax & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))),
                              0L);
  }
  }
#line 2360
  if (tmp___22) {
#line 2362
    *err = (reg_errcode_t )10;
#line 2363
    return ((bin_tree_t *)((void *)0));
  }
  parse_dup_op_rollback: 
#line 2366
  regexp->cur_idx = start_idx;
#line 2367
  *token = start_token;
#line 2368
  token->type = (re_token_type_t )26;
#line 2369
  return (dup_elem);
}
}
#line 2384 "regcomp.c"
static reg_errcode_t build_range_exp(re_bitset_ptr_t sbcset , re_charset_t *mbcset ,
                                     int *range_alloc , bracket_elem_t *start_elem ,
                                     bracket_elem_t *end_elem ) 
{ 
  unsigned int start_ch ;
  unsigned int end_ch ;
  int tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  wchar_t wc ;
  wchar_t start_wc ;
  wchar_t end_wc ;
  wchar_t cmp_buf[6] ;
  int tmp___5 ;
  int tmp___6 ;
  wint_t tmp___7 ;
  wint_t tmp___8 ;
  int tmp___9 ;
  wchar_t *new_array_start ;
  wchar_t *new_array_end ;
  int new_nranges ;
  void *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  void *__cil_tmp33 ;

  {
#line 2397
  if ((unsigned int )start_elem->type == 2U) {
#line 2397
    tmp = 1;
  } else
#line 2397
  if ((unsigned int )start_elem->type == 4U) {
#line 2397
    tmp = 1;
  } else
#line 2397
  if ((unsigned int )end_elem->type == 2U) {
#line 2397
    tmp = 1;
  } else
#line 2397
  if ((unsigned int )end_elem->type == 4U) {
#line 2397
    tmp = 1;
  } else {
#line 2397
    tmp = 0;
  }
  {
  {
#line 2397
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
  }
#line 2397
  if (tmp___0) {
#line 2400
    return ((reg_errcode_t )11);
  }
#line 2404
  if ((unsigned int )start_elem->type == 3U) {
    {
    {
#line 2404
    tmp___1 = strlen((char const   *)((char *)start_elem->opr.name));
    }
    }
#line 2404
    if (tmp___1 > 1U) {
#line 2404
      tmp___3 = 1;
    } else {
#line 2404
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2404
  if ((unsigned int )end_elem->type == 3U) {
    {
    {
#line 2404
    tmp___2 = strlen((char const   *)((char *)end_elem->opr.name));
    }
    }
#line 2404
    if (tmp___2 > 1U) {
#line 2404
      tmp___3 = 1;
    } else {
#line 2404
      tmp___3 = 0;
    }
  } else {
#line 2404
    tmp___3 = 0;
  }
  {
  {
#line 2404
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
  }
#line 2404
  if (tmp___4) {
#line 2408
    return ((reg_errcode_t )3);
  }
#line 2413
  cmp_buf[0] = (wchar_t )0;
#line 2413
  cmp_buf[1] = (wchar_t )0;
#line 2413
  cmp_buf[2] = (wchar_t )0;
#line 2413
  cmp_buf[3] = (wchar_t )0;
#line 2413
  cmp_buf[4] = (wchar_t )0;
#line 2413
  cmp_buf[5] = (wchar_t )0;
#line 2415
  if ((unsigned int )start_elem->type == 0U) {
#line 2415
    start_ch = (unsigned int )start_elem->opr.ch;
  } else {
#line 2415
    if ((unsigned int )start_elem->type == 3U) {
#line 2415
      tmp___5 = (int )*(start_elem->opr.name + 0);
    } else {
#line 2415
      tmp___5 = 0;
    }
#line 2415
    start_ch = (unsigned int )tmp___5;
  }
#line 2418
  if ((unsigned int )end_elem->type == 0U) {
#line 2418
    end_ch = (unsigned int )end_elem->opr.ch;
  } else {
#line 2418
    if ((unsigned int )end_elem->type == 3U) {
#line 2418
      tmp___6 = (int )*(end_elem->opr.name + 0);
    } else {
#line 2418
      tmp___6 = 0;
    }
#line 2418
    end_ch = (unsigned int )tmp___6;
  }
#line 2421
  if ((unsigned int )start_elem->type == 0U) {
    {
    {
#line 2421
    tmp___7 = btowc((int )start_ch);
    }
#line 2421
    start_wc = (wchar_t )tmp___7;
    }
  } else
#line 2421
  if ((unsigned int )start_elem->type == 3U) {
    {
    {
#line 2421
    tmp___7 = btowc((int )start_ch);
    }
#line 2421
    start_wc = (wchar_t )tmp___7;
    }
  } else {
#line 2421
    start_wc = start_elem->opr.wch;
  }
#line 2423
  if ((unsigned int )end_elem->type == 0U) {
    {
    {
#line 2423
    tmp___8 = btowc((int )end_ch);
    }
#line 2423
    end_wc = (wchar_t )tmp___8;
    }
  } else
#line 2423
  if ((unsigned int )end_elem->type == 3U) {
    {
    {
#line 2423
    tmp___8 = btowc((int )end_ch);
    }
#line 2423
    end_wc = (wchar_t )tmp___8;
    }
  } else {
#line 2423
    end_wc = end_elem->opr.wch;
  }
  {
#line 2425
  cmp_buf[0] = start_wc;
#line 2426
  cmp_buf[4] = end_wc;
  {
#line 2427
  tmp___9 = wcscoll((wchar_t const   *)(cmp_buf), (wchar_t const   *)(cmp_buf + 4));
  }
  }
#line 2427
  if (tmp___9 > 0) {
#line 2428
    return ((reg_errcode_t )11);
  }
#line 2431
  if (*range_alloc == mbcset->nranges) {
    {
#line 2438
    new_nranges = 2 * mbcset->nranges + 1;
    {
#line 2441
    tmp___10 = realloc((void *)mbcset->range_starts, (size_t )((unsigned long )new_nranges * sizeof(wchar_t )));
    }
#line 2441
    new_array_start = (wchar_t *)tmp___10;
    {
#line 2443
    tmp___11 = realloc((void *)mbcset->range_ends, (size_t )((unsigned long )new_nranges * sizeof(wchar_t )));
    }
#line 2443
    new_array_end = (wchar_t *)tmp___11;
    }
#line 2446
    if ((unsigned long )new_array_start == (unsigned long )((void *)0)) {
#line 2446
      tmp___12 = 1;
    } else
#line 2446
    if ((unsigned long )new_array_end == (unsigned long )((void *)0)) {
#line 2446
      tmp___12 = 1;
    } else {
#line 2446
      tmp___12 = 0;
    }
    {
    {
#line 2446
    tmp___13 = __builtin_expect((long )tmp___12, 0L);
    }
    }
#line 2446
    if (tmp___13) {
#line 2447
      return ((reg_errcode_t )12);
    }
#line 2449
    mbcset->range_starts = new_array_start;
#line 2450
    mbcset->range_ends = new_array_end;
#line 2451
    *range_alloc = new_nranges;
  }
#line 2454
  *(mbcset->range_starts + mbcset->nranges) = start_wc;
#line 2455
  tmp___14 = mbcset->nranges;
#line 2455
  (mbcset->nranges) ++;
#line 2455
  *(mbcset->range_ends + tmp___14) = end_wc;
#line 2458
  wc = (wchar_t )0;
  {
  {
#line 2458
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2458
    if (! (wc <= 256L)) {
#line 2458
      goto while_break;
    }
    {
#line 2460
    cmp_buf[2] = wc;
    {
#line 2461
    tmp___15 = wcscoll((wchar_t const   *)(cmp_buf), (wchar_t const   *)(cmp_buf + 2));
    }
    }
#line 2461
    if (tmp___15 <= 0) {
      {
      {
#line 2461
      tmp___16 = wcscoll((wchar_t const   *)(cmp_buf + 2), (wchar_t const   *)(cmp_buf + 4));
      }
      }
#line 2461
      if (tmp___16 <= 0) {
#line 2463
        *(sbcset + (unsigned long )wc / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )wc % (sizeof(unsigned int ) * 8UL));
      }
    }
#line 2458
    wc ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2483
  return ((reg_errcode_t )0);
}
}
#line 2494 "regcomp.c"
static reg_errcode_t build_collating_symbol(re_bitset_ptr_t sbcset , re_charset_t *mbcset ,
                                            int *coll_sym_alloc , unsigned char const   *name ) 
{ 
  size_t name_len ;
  size_t tmp ;
  long tmp___0 ;

  {
  {
  {
#line 2505
  tmp = strlen((char const   *)name);
  }
#line 2505
  name_len = tmp;
  {
#line 2506
  tmp___0 = __builtin_expect((long )(name_len != 1U), 0L);
  }
  }
#line 2506
  if (tmp___0) {
#line 2507
    return ((reg_errcode_t )3);
  } else {
#line 2510
    *(sbcset + (unsigned long )*(name + 0) / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )*(name + 0) % (sizeof(unsigned int ) * 8UL));
#line 2511
    return ((reg_errcode_t )0);
  }
}
}
#line 2519 "regcomp.c"
static bin_tree_t *parse_bracket_exp(re_string_t *regexp , re_dfa_t *dfa , re_token_t *token ,
                                     reg_syntax_t syntax , reg_errcode_t *err ) 
{ 
  re_token_t br_token ;
  re_bitset_ptr_t sbcset ;
  re_charset_t *mbcset ;
  int coll_sym_alloc ;
  int range_alloc ;
  int mbchar_alloc ;
  int equiv_class_alloc ;
  int char_class_alloc ;
  bin_tree_t *work_tree ;
  int token_len ;
  int new_idx ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int i ;
  long tmp___4 ;
  wint_t tmp___5 ;
  size_t tmp___6 ;
  bracket_elem_t start_elem ;
  bracket_elem_t end_elem ;
  unsigned char start_name_buf[32] ;
  unsigned char end_name_buf[32] ;
  reg_errcode_t ret ;
  int token_len2 ;
  int is_range_exp ;
  re_token_t token2 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  void *tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  int tmp___20 ;
  long tmp___21 ;
  re_token_t alt_token ;
  bin_tree_t *mbc_tree ;
  int tmp___22 ;
  long tmp___23 ;
  int tmp___24 ;
  long tmp___25 ;
  size_t tmp___26 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
  {
#line 2797
  coll_sym_alloc = 0;
#line 2797
  range_alloc = 0;
#line 2797
  mbchar_alloc = 0;
#line 2798
  equiv_class_alloc = 0;
#line 2798
  char_class_alloc = 0;
  {
#line 2821
  tmp = calloc((size_t )sizeof(unsigned int ), (size_t )(((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)));
  }
#line 2821
  sbcset = (re_bitset_ptr_t )tmp;
  {
#line 2823
  tmp___0 = calloc((size_t )sizeof(re_charset_t ), (size_t )1);
  }
#line 2823
  mbcset = (re_charset_t *)tmp___0;
  }
#line 2826
  if ((unsigned long )sbcset == (unsigned long )((void *)0)) {
#line 2826
    tmp___1 = 1;
  } else
#line 2826
  if ((unsigned long )mbcset == (unsigned long )((void *)0)) {
#line 2826
    tmp___1 = 1;
  } else {
#line 2826
    tmp___1 = 0;
  }
  {
  {
#line 2826
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  }
#line 2826
  if (tmp___2) {
#line 2831
    *err = (reg_errcode_t )12;
#line 2832
    return ((bin_tree_t *)((void *)0));
  }
  {
  {
#line 2835
  token_len = peek_token_bracket(token, regexp, syntax);
  }
  {
#line 2836
  tmp___3 = __builtin_expect((long )((unsigned int )token->type == 27U), 0L);
  }
  }
#line 2836
  if (tmp___3) {
#line 2838
    *err = (reg_errcode_t )2;
#line 2839
    goto parse_bracket_exp_free_return;
  }
#line 2841
  if ((unsigned int )token->type == 6U) {
#line 2845
    mbcset->non_match = 1U;
#line 2849
    if (syntax & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2850
      *(sbcset + 0UL / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << 0UL % (sizeof(unsigned int ) * 8UL));
    }
    {
#line 2851
    regexp->cur_idx += token_len;
    {
#line 2852
    token_len = peek_token_bracket(token, regexp, syntax);
    }
    {
#line 2853
    tmp___4 = __builtin_expect((long )((unsigned int )token->type == 27U), 0L);
    }
    }
#line 2853
    if (tmp___4) {
#line 2855
      *err = (reg_errcode_t )2;
#line 2856
      goto parse_bracket_exp_free_return;
    }
    {
    {
#line 2859
    tmp___6 = __ctype_get_mb_cur_max();
    }
    }
#line 2859
    if (tmp___6 > 1U) {
#line 2860
      i = 0;
      {
      {
#line 2860
      while (1) {
        while_continue___1: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 2860
        if (! (i < 256)) {
#line 2860
          goto while_break;
        }
        {
        {
#line 2861
        tmp___5 = btowc(i);
        }
        }
#line 2861
        if (tmp___5 == 4294967295U) {
#line 2862
          *(sbcset + (unsigned long )i / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )i % (sizeof(unsigned int ) * 8UL));
        }
#line 2860
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 2867
  if ((unsigned int )token->type == 2U) {
#line 2868
    token->type = (re_token_type_t )26;
  }
  {
  {
#line 2870
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
#line 2876
    token_len2 = 0;
#line 2876
    is_range_exp = 0;
#line 2879
    start_elem.opr.name = start_name_buf;
    {
#line 2880
    ret = parse_bracket_element(& start_elem, regexp, token, token_len, dfa, syntax);
    }
    {
#line 2882
    tmp___7 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
    }
    }
#line 2882
    if (tmp___7) {
#line 2884
      *err = ret;
#line 2885
      goto parse_bracket_exp_free_return;
    }
    {
    {
#line 2888
    token_len = peek_token_bracket(token, regexp, syntax);
    }
    {
#line 2889
    tmp___8 = __builtin_expect((long )((unsigned int )token->type == 27U), 0L);
    }
    }
#line 2889
    if (tmp___8) {
#line 2891
      *err = (reg_errcode_t )2;
#line 2892
      goto parse_bracket_exp_free_return;
    }
#line 2894
    if ((unsigned int )token->type == 3U) {
      {
#line 2896
      regexp->cur_idx += token_len;
      {
#line 2897
      token_len2 = peek_token_bracket(& token2, regexp, syntax);
      }
      {
#line 2898
      tmp___9 = __builtin_expect((long )((unsigned int )token->type == 27U), 0L);
      }
      }
#line 2898
      if (tmp___9) {
#line 2900
        *err = (reg_errcode_t )2;
#line 2901
        goto parse_bracket_exp_free_return;
      }
#line 2903
      if ((unsigned int )token2.type == 2U) {
#line 2906
        regexp->cur_idx += - token_len;
#line 2907
        token->type = (re_token_type_t )26;
      } else {
#line 2910
        is_range_exp = 1;
      }
    }
#line 2913
    if (is_range_exp == 1) {
      {
#line 2915
      end_elem.opr.name = end_name_buf;
      {
#line 2916
      ret = parse_bracket_element(& end_elem, regexp, & token2, token_len2, dfa, syntax);
      }
      {
#line 2918
      tmp___10 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
      }
      }
#line 2918
      if (tmp___10) {
#line 2920
        *err = ret;
#line 2921
        goto parse_bracket_exp_free_return;
      }
      {
      {
#line 2924
      token_len = peek_token_bracket(token, regexp, syntax);
      }
      {
#line 2925
      tmp___11 = __builtin_expect((long )((unsigned int )token->type == 27U), 0L);
      }
      }
#line 2925
      if (tmp___11) {
#line 2927
        *err = (reg_errcode_t )2;
#line 2928
        goto parse_bracket_exp_free_return;
      }
      {
      {
#line 2930
      *err = build_range_exp(sbcset, mbcset, & range_alloc, & start_elem, & end_elem);
      }
      {
#line 2935
      tmp___12 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
      }
      }
#line 2935
      if (tmp___12) {
#line 2936
        goto parse_bracket_exp_free_return;
      }
    } else {
      {
#line 2942
      if ((unsigned int )start_elem.type == 0U) {
#line 2942
        goto case_0;
      }
#line 2946
      if ((unsigned int )start_elem.type == 1U) {
#line 2946
        goto case_1;
      }
#line 2962
      if ((unsigned int )start_elem.type == 2U) {
#line 2962
        goto case_2;
      }
#line 2971
      if ((unsigned int )start_elem.type == 3U) {
#line 2971
        goto case_3;
      }
#line 2980
      if ((unsigned int )start_elem.type == 4U) {
#line 2980
        goto case_4;
      }
#line 2989
      goto switch_default;
      case_0: /* CIL Label */ 
#line 2943
      *(sbcset + (unsigned long )start_elem.opr.ch / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )start_elem.opr.ch % (sizeof(unsigned int ) * 8UL));
#line 2944
      goto switch_break;
      case_1: /* CIL Label */ 
#line 2948
      if (mbchar_alloc == mbcset->nmbchars) {
        {
#line 2952
        mbchar_alloc = 2 * mbcset->nmbchars + 1;
        {
#line 2954
        tmp___13 = realloc((void *)mbcset->mbchars, (size_t )((unsigned long )mbchar_alloc * sizeof(wchar_t )));
        }
#line 2954
        mbcset->mbchars = (wchar_t *)tmp___13;
        {
#line 2956
        tmp___14 = __builtin_expect((long )((unsigned long )mbcset->mbchars == (unsigned long )((void *)0)),
                                    0L);
        }
        }
#line 2956
        if (tmp___14) {
#line 2957
          goto parse_bracket_exp_espace;
        }
      }
#line 2959
      tmp___15 = mbcset->nmbchars;
#line 2959
      (mbcset->nmbchars) ++;
#line 2959
      *(mbcset->mbchars + tmp___15) = start_elem.opr.wch;
#line 2960
      goto switch_break;
      case_2: /* CIL Label */ 
      {
      {
#line 2963
      *err = build_equiv_class(sbcset, mbcset, & equiv_class_alloc, (unsigned char const   *)start_elem.opr.name);
      }
      {
#line 2968
      tmp___16 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
      }
      }
#line 2968
      if (tmp___16) {
#line 2969
        goto parse_bracket_exp_free_return;
      }
#line 2970
      goto switch_break;
      case_3: /* CIL Label */ 
      {
      {
#line 2972
      *err = build_collating_symbol(sbcset, mbcset, & coll_sym_alloc, (unsigned char const   *)start_elem.opr.name);
      }
      {
#line 2977
      tmp___17 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
      }
      }
#line 2977
      if (tmp___17) {
#line 2978
        goto parse_bracket_exp_free_return;
      }
#line 2979
      goto switch_break;
      case_4: /* CIL Label */ 
      {
      {
#line 2981
      *err = build_charclass(regexp->trans, sbcset, mbcset, & char_class_alloc, (unsigned char const   *)start_elem.opr.name,
                             syntax);
      }
      {
#line 2986
      tmp___18 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
      }
      }
#line 2986
      if (tmp___18) {
#line 2987
        goto parse_bracket_exp_free_return;
      }
#line 2988
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 2990
      tmp___19 = __builtin_expect(0L, 1L);
      }
      }
#line 2990
      if (! tmp___19) {
        {
        {
#line 2990
        __assert_fail("0", "regcomp.c", 2990U, "parse_bracket_exp");
        }
        }
      }
#line 2991
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 2994
    if ((unsigned int )token->type == 2U) {
#line 2995
      goto while_break___0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2998
  regexp->cur_idx += token_len;
#line 3002
  if (mbcset->non_match) {
    {
    {
#line 3006
    bitset_not((unsigned int *)sbcset);
    }
    }
  }
  {
#line 3009
  br_token.type = (re_token_type_t )21;
#line 3010
  br_token.opr.sbcset = sbcset;
  {
#line 3011
  new_idx = re_dfa_add_node(dfa, br_token, 0);
  }
  {
#line 3012
  work_tree = create_tree((bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )0,
                          new_idx);
  }
  }
#line 3013
  if (new_idx == -1) {
#line 3013
    tmp___20 = 1;
  } else
#line 3013
  if ((unsigned long )work_tree == (unsigned long )((void *)0)) {
#line 3013
    tmp___20 = 1;
  } else {
#line 3013
    tmp___20 = 0;
  }
  {
  {
#line 3013
  tmp___21 = __builtin_expect((long )tmp___20, 0L);
  }
  }
#line 3013
  if (tmp___21) {
#line 3014
    goto parse_bracket_exp_espace;
  }
#line 3017
  if (mbcset->nmbchars) {
#line 3017
    goto _L___0;
  } else
#line 3017
  if (mbcset->ncoll_syms) {
#line 3017
    goto _L___0;
  } else
#line 3017
  if (mbcset->nequiv_classes) {
#line 3017
    goto _L___0;
  } else
#line 3017
  if (mbcset->nranges) {
#line 3017
    goto _L___0;
  } else {
    {
    {
#line 3017
    tmp___26 = __ctype_get_mb_cur_max();
    }
    }
#line 3017
    if (tmp___26 > 1U) {
#line 3017
      if (mbcset->nchar_classes) {
#line 3017
        goto _L___0;
      } else
#line 3017
      if (mbcset->non_match) {
        _L___0: /* CIL Label */ 
        {
#line 3024
        br_token.type = (re_token_type_t )22;
#line 3025
        br_token.opr.mbcset = mbcset;
#line 3026
        dfa->has_mb_node = 1U;
        {
#line 3027
        new_idx = re_dfa_add_node(dfa, br_token, 0);
        }
        {
#line 3028
        mbc_tree = create_tree((bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                               (re_token_type_t )0, new_idx);
        }
        }
#line 3029
        if (new_idx == -1) {
#line 3029
          tmp___22 = 1;
        } else
#line 3029
        if ((unsigned long )mbc_tree == (unsigned long )((void *)0)) {
#line 3029
          tmp___22 = 1;
        } else {
#line 3029
          tmp___22 = 0;
        }
        {
        {
#line 3029
        tmp___23 = __builtin_expect((long )tmp___22, 0L);
        }
        }
#line 3029
        if (tmp___23) {
#line 3030
          goto parse_bracket_exp_espace;
        }
        {
#line 3032
        dfa->has_plural_match = 1U;
#line 3033
        alt_token.type = (re_token_type_t )28;
        {
#line 3034
        new_idx = re_dfa_add_node(dfa, alt_token, 0);
        }
        {
#line 3035
        work_tree = create_tree(work_tree, mbc_tree, (re_token_type_t )0, new_idx);
        }
        }
#line 3036
        if (new_idx != -1) {
#line 3036
          if ((unsigned long )mbc_tree != (unsigned long )((void *)0)) {
#line 3036
            tmp___24 = 1;
          } else {
#line 3036
            tmp___24 = 0;
          }
        } else {
#line 3036
          tmp___24 = 0;
        }
        {
        {
#line 3036
        tmp___25 = __builtin_expect((long )tmp___24, 1L);
        }
        }
#line 3036
        if (tmp___25) {
#line 3037
          return (work_tree);
        }
      } else {
        {
        {
#line 3041
        free_charset(mbcset);
        }
        }
#line 3042
        return (work_tree);
      }
    } else {
      {
      {
#line 3041
      free_charset(mbcset);
      }
      }
#line 3042
      return (work_tree);
    }
  }
  parse_bracket_exp_espace: 
#line 3049
  *err = (reg_errcode_t )12;
  parse_bracket_exp_free_return: 
  {
  {
#line 3051
  free((void *)sbcset);
  }
  {
#line 3053
  free_charset(mbcset);
  }
  }
#line 3055
  return ((bin_tree_t *)((void *)0));
}
}
#line 3060 "regcomp.c"
static reg_errcode_t parse_bracket_element(bracket_elem_t *elem , re_string_t *regexp ,
                                           re_token_t *token , int token_len , re_dfa_t *dfa ,
                                           reg_syntax_t syntax ) 
{ 
  int cur_char_size ;
  wint_t tmp ;
  reg_errcode_t tmp___0 ;

  {
  {
  {
#line 3071
  cur_char_size = re_string_char_size_at((re_string_t const   *)regexp, regexp->cur_idx);
  }
  }
#line 3072
  if (cur_char_size > 1) {
    {
#line 3074
    elem->type = (bracket_elem_type )1;
    {
#line 3075
    tmp = re_string_wchar_at((re_string_t const   *)regexp, regexp->cur_idx);
    }
#line 3075
    elem->opr.wch = (wchar_t )tmp;
#line 3076
    regexp->cur_idx += cur_char_size;
    }
#line 3077
    return ((reg_errcode_t )0);
  }
#line 3080
  regexp->cur_idx += token_len;
#line 3081
  if ((unsigned int )token->type == 7U) {
    {
    {
#line 3083
    tmp___0 = parse_bracket_symbol(elem, regexp, token);
    }
    }
#line 3083
    return (tmp___0);
  } else
#line 3081
  if ((unsigned int )token->type == 11U) {
    {
    {
#line 3083
    tmp___0 = parse_bracket_symbol(elem, regexp, token);
    }
    }
#line 3083
    return (tmp___0);
  } else
#line 3081
  if ((unsigned int )token->type == 9U) {
    {
    {
#line 3083
    tmp___0 = parse_bracket_symbol(elem, regexp, token);
    }
    }
#line 3083
    return (tmp___0);
  }
#line 3084
  elem->type = (bracket_elem_type )0;
#line 3085
  elem->opr.ch = token->opr.c;
#line 3086
  return ((reg_errcode_t )0);
}
}
#line 3093 "regcomp.c"
static reg_errcode_t parse_bracket_symbol(bracket_elem_t *elem , re_string_t *regexp ,
                                          re_token_t *token ) 
{ 
  unsigned char ch ;
  unsigned char delim ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 3099
  delim = token->opr.c;
#line 3100
  i = 0;
  {
  {
#line 3101
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3103
    if (regexp->stop <= regexp->cur_idx) {
#line 3104
      return ((reg_errcode_t )7);
    } else
#line 3103
    if (i >= 32) {
#line 3104
      return ((reg_errcode_t )7);
    }
#line 3105
    if ((unsigned int )token->type == 11U) {
#line 3106
      tmp = regexp->cur_idx;
#line 3106
      (regexp->cur_idx) ++;
#line 3106
      ch = *(regexp->mbs_case + tmp);
    } else {
#line 3108
      tmp___0 = regexp->cur_idx;
#line 3108
      (regexp->cur_idx) ++;
#line 3108
      ch = *(regexp->mbs + tmp___0);
    }
#line 3109
    if ((int )ch == (int )delim) {
#line 3109
      if ((int )*(regexp->mbs + regexp->cur_idx) == 93) {
#line 3110
        goto while_break;
      }
    }
#line 3111
    *(elem->opr.name + i) = ch;
#line 3101
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3113
  (regexp->cur_idx) ++;
#line 3114
  *(elem->opr.name + i) = (unsigned char )'\000';
  {
#line 3117
  if ((unsigned int )token->type == 7U) {
#line 3117
    goto case_7;
  }
#line 3120
  if ((unsigned int )token->type == 9U) {
#line 3120
    goto case_9;
  }
#line 3123
  if ((unsigned int )token->type == 11U) {
#line 3123
    goto case_11;
  }
#line 3126
  goto switch_default;
  case_7: /* CIL Label */ 
#line 3118
  elem->type = (bracket_elem_type )3;
#line 3119
  goto switch_break;
  case_9: /* CIL Label */ 
#line 3121
  elem->type = (bracket_elem_type )2;
#line 3122
  goto switch_break;
  case_11: /* CIL Label */ 
#line 3124
  elem->type = (bracket_elem_type )4;
#line 3125
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3127
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3129
  return ((reg_errcode_t )0);
}
}
#line 3138 "regcomp.c"
static reg_errcode_t build_equiv_class(re_bitset_ptr_t sbcset , re_charset_t *mbcset ,
                                       int *equiv_class_alloc , unsigned char const   *name ) 
{ 
  size_t tmp ;
  long tmp___0 ;

  {
  {
  {
#line 3217
  tmp = strlen((char const   *)name);
  }
  {
#line 3217
  tmp___0 = __builtin_expect((long )(tmp != 1U), 0L);
  }
  }
#line 3217
  if (tmp___0) {
#line 3218
    return ((reg_errcode_t )3);
  }
#line 3219
  *(sbcset + (unsigned long )*name / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )*name % (sizeof(unsigned int ) * 8UL));
#line 3221
  return ((reg_errcode_t )0);
}
}
#line 3295
extern int ( /* missing proto */  isblank)() ;
#line 3230 "regcomp.c"
static reg_errcode_t build_charclass(char *trans , re_bitset_ptr_t sbcset , re_charset_t *mbcset ,
                                     int *char_class_alloc , unsigned char const   *class_name ,
                                     reg_syntax_t syntax ) 
{ 
  int i ;
  char const   *name ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  int ch ;
  int tmp___14 ;
  unsigned short const   **tmp___15 ;
  int ch___0 ;
  int tmp___16 ;
  unsigned short const   **tmp___17 ;
  int ch___1 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;
  int ch___2 ;
  int tmp___20 ;
  unsigned short const   **tmp___21 ;
  int ch___3 ;
  int tmp___22 ;
  unsigned short const   **tmp___23 ;
  int ch___4 ;
  int tmp___24 ;
  unsigned short const   **tmp___25 ;
  int ch___5 ;
  int tmp___26 ;
  unsigned short const   **tmp___27 ;
  int ch___6 ;
  int tmp___28 ;
  unsigned short const   **tmp___29 ;
  int ch___7 ;
  int tmp___30 ;
  int tmp___31 ;
  int ch___8 ;
  int tmp___32 ;
  unsigned short const   **tmp___33 ;
  int ch___9 ;
  int tmp___34 ;
  unsigned short const   **tmp___35 ;
  int ch___10 ;
  int tmp___36 ;
  unsigned short const   **tmp___37 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  size_t tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  size_t tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  size_t tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  size_t tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  size_t tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  size_t tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  size_t tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  size_t tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  size_t tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  size_t tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  size_t tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  size_t tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;
  char *__cil_tmp250 ;
  char *__cil_tmp251 ;
  char *__cil_tmp252 ;
  char *__cil_tmp253 ;
  char *__cil_tmp254 ;
  char *__cil_tmp255 ;
  char *__cil_tmp256 ;
  char *__cil_tmp257 ;
  char *__cil_tmp258 ;
  char *__cil_tmp259 ;
  char *__cil_tmp260 ;
  char *__cil_tmp261 ;
  char *__cil_tmp262 ;
  char *__cil_tmp263 ;
  char *__cil_tmp264 ;
  char *__cil_tmp265 ;
  char *__cil_tmp266 ;
  char *__cil_tmp267 ;
  char *__cil_tmp268 ;
  char *__cil_tmp269 ;
  char *__cil_tmp270 ;
  char *__cil_tmp271 ;
  char *__cil_tmp272 ;
  char *__cil_tmp273 ;
  char *__cil_tmp274 ;
  char *__cil_tmp275 ;
  char *__cil_tmp276 ;
  char *__cil_tmp277 ;
  char *__cil_tmp278 ;
  char *__cil_tmp279 ;
  char *__cil_tmp280 ;
  char *__cil_tmp281 ;
  char *__cil_tmp282 ;
  char *__cil_tmp283 ;
  char *__cil_tmp284 ;
  char *__cil_tmp285 ;
  char *__cil_tmp286 ;
  char *__cil_tmp287 ;
  char *__cil_tmp288 ;
  char *__cil_tmp289 ;
  char *__cil_tmp290 ;
  char *__cil_tmp291 ;
  char *__cil_tmp292 ;
  char *__cil_tmp293 ;
  char *__cil_tmp294 ;
  char *__cil_tmp295 ;
  char *__cil_tmp296 ;
  char *__cil_tmp297 ;
  char *__cil_tmp298 ;
  char *__cil_tmp299 ;
  char *__cil_tmp300 ;
  char *__cil_tmp301 ;
  char *__cil_tmp302 ;
  char *__cil_tmp303 ;
  char *__cil_tmp304 ;
  char *__cil_tmp305 ;
  char *__cil_tmp306 ;
  char *__cil_tmp307 ;
  char *__cil_tmp308 ;
  char *__cil_tmp309 ;
  char *__cil_tmp310 ;
  char *__cil_tmp311 ;
  char *__cil_tmp312 ;
  char *__cil_tmp313 ;
  char *__cil_tmp314 ;
  char *__cil_tmp315 ;
  char *__cil_tmp316 ;
  char *__cil_tmp317 ;
  char *__cil_tmp318 ;
  char *__cil_tmp319 ;
  char *__cil_tmp320 ;
  char *__cil_tmp321 ;
  char *__cil_tmp322 ;
  char *__cil_tmp323 ;
  char *__cil_tmp324 ;
  char *__cil_tmp325 ;
  char *__cil_tmp326 ;
  char *__cil_tmp327 ;
  char *__cil_tmp328 ;
  char *__cil_tmp329 ;
  char *__cil_tmp330 ;
  char *__cil_tmp331 ;
  char *__cil_tmp332 ;
  char *__cil_tmp333 ;
  char *__cil_tmp334 ;
  char *__cil_tmp335 ;
  char *__cil_tmp336 ;
  char *__cil_tmp337 ;
  char *__cil_tmp338 ;
  char *__cil_tmp339 ;
  char *__cil_tmp340 ;
  char *__cil_tmp341 ;
  char *__cil_tmp342 ;
  char *__cil_tmp343 ;
  char *__cil_tmp344 ;
  char *__cil_tmp345 ;
  char *__cil_tmp346 ;
  char *__cil_tmp347 ;
  char *__cil_tmp348 ;
  char *__cil_tmp349 ;
  char *__cil_tmp350 ;
  char *__cil_tmp351 ;
  char *__cil_tmp352 ;
  char *__cil_tmp353 ;
  char *__cil_tmp354 ;
  char *__cil_tmp355 ;
  char *__cil_tmp356 ;
  char *__cil_tmp357 ;

  {
#line 3244
  name = (char const   *)class_name;
#line 3249
  if (syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3249
    if (0) {
      {
      {
#line 3249
      __s1_len = strlen(name);
      }
      {
#line 3249
      __s2_len = strlen("upper");
      }
      }
#line 3249
      if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1U)) {
#line 3249
        goto _L___0;
      } else
#line 3249
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 3249
        if (! ((size_t )((void const   *)("upper" + 1)) - (size_t )((void const   *)"upper") == 1U)) {
#line 3249
          tmp___4 = 1;
        } else
#line 3249
        if (__s2_len >= 4U) {
#line 3249
          tmp___4 = 1;
        } else {
#line 3249
          tmp___4 = 0;
        }
      } else {
#line 3249
        tmp___4 = 0;
      }
#line 3249
      if (tmp___4) {
#line 3249
        if (__s1_len < __s2_len) {
#line 3249
          tmp___0 = __s1_len;
        } else {
#line 3249
          tmp___0 = __s2_len;
        }
        {
        {
#line 3249
        tmp___1 = memcmp((void const   *)name, (void const   *)"upper", tmp___0 + 1U);
        }
#line 3249
        tmp___3 = tmp___1;
        }
      } else {
        {
        {
#line 3249
        tmp___2 = strcmp(name, "upper");
        }
#line 3249
        tmp___3 = tmp___2;
        }
      }
    } else {
      {
      {
#line 3249
      tmp___2 = strcmp(name, "upper");
      }
#line 3249
      tmp___3 = tmp___2;
      }
    }
#line 3249
    if (tmp___3 == 0) {
#line 3250
      name = "alpha";
    } else {
#line 3249
      if (0) {
        {
        {
#line 3249
        __s1_len___0 = strlen(name);
        }
        {
#line 3249
        __s2_len___0 = strlen("lower");
        }
        }
#line 3249
        if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1U)) {
#line 3249
          goto _L___2;
        } else
#line 3249
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 3249
          if (! ((size_t )((void const   *)("lower" + 1)) - (size_t )((void const   *)"lower") == 1U)) {
#line 3249
            tmp___10 = 1;
          } else
#line 3249
          if (__s2_len___0 >= 4U) {
#line 3249
            tmp___10 = 1;
          } else {
#line 3249
            tmp___10 = 0;
          }
        } else {
#line 3249
          tmp___10 = 0;
        }
#line 3249
        if (tmp___10) {
#line 3249
          if (__s1_len___0 < __s2_len___0) {
#line 3249
            tmp___6 = __s1_len___0;
          } else {
#line 3249
            tmp___6 = __s2_len___0;
          }
          {
          {
#line 3249
          tmp___7 = memcmp((void const   *)name, (void const   *)"lower", tmp___6 + 1U);
          }
#line 3249
          tmp___9 = tmp___7;
          }
        } else {
          {
          {
#line 3249
          tmp___8 = strcmp(name, "lower");
          }
#line 3249
          tmp___9 = tmp___8;
          }
        }
      } else {
        {
        {
#line 3249
        tmp___8 = strcmp(name, "lower");
        }
#line 3249
        tmp___9 = tmp___8;
        }
      }
#line 3249
      if (tmp___9 == 0) {
#line 3250
        name = "alpha";
      }
    }
  }
#line 3254
  if (*char_class_alloc == mbcset->nchar_classes) {
    {
#line 3258
    *char_class_alloc = 2 * mbcset->nchar_classes + 1;
    {
#line 3260
    tmp___11 = realloc((void *)mbcset->char_classes, (size_t )((unsigned long )*char_class_alloc * sizeof(wctype_t )));
    }
#line 3260
    mbcset->char_classes = (wctype_t *)tmp___11;
    {
#line 3262
    tmp___12 = __builtin_expect((long )((unsigned long )mbcset->char_classes == (unsigned long )((void *)0)),
                                0L);
    }
    }
#line 3262
    if (tmp___12) {
#line 3263
      return ((reg_errcode_t )12);
    }
  }
  {
#line 3265
  tmp___13 = mbcset->nchar_classes;
#line 3265
  (mbcset->nchar_classes) ++;
  {
#line 3265
  *(mbcset->char_classes + tmp___13) = wctype(name);
  }
  }
#line 3278
  if (0) {
    {
    {
#line 3278
    __s1_len___12 = strlen(name);
    }
    {
#line 3278
    __s2_len___12 = strlen("alnum");
    }
    }
#line 3278
    if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1U)) {
#line 3278
      goto _L___26;
    } else
#line 3278
    if (__s1_len___12 >= 4U) {
      _L___26: /* CIL Label */ 
#line 3278
      if (! ((size_t )((void const   *)("alnum" + 1)) - (size_t )((void const   *)"alnum") == 1U)) {
#line 3278
        tmp___109 = 1;
      } else
#line 3278
      if (__s2_len___12 >= 4U) {
#line 3278
        tmp___109 = 1;
      } else {
#line 3278
        tmp___109 = 0;
      }
    } else {
#line 3278
      tmp___109 = 0;
    }
#line 3278
    if (tmp___109) {
#line 3278
      if (__s1_len___12 < __s2_len___12) {
#line 3278
        tmp___105 = __s1_len___12;
      } else {
#line 3278
        tmp___105 = __s2_len___12;
      }
      {
      {
#line 3278
      tmp___106 = memcmp((void const   *)name, (void const   *)"alnum", tmp___105 + 1U);
      }
#line 3278
      tmp___108 = tmp___106;
      }
    } else {
      {
      {
#line 3278
      tmp___107 = strcmp(name, "alnum");
      }
#line 3278
      tmp___108 = tmp___107;
      }
    }
  } else {
    {
    {
#line 3278
    tmp___107 = strcmp(name, "alnum");
    }
#line 3278
    tmp___108 = tmp___107;
    }
  }
#line 3278
  if (tmp___108 == 0) {
#line 3279
    i = 0;
    {
    {
#line 3279
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 3279
      if (! (i < 256)) {
#line 3279
        goto while_break;
      }
      {
      {
#line 3279
      tmp___15 = __ctype_b_loc();
      }
      }
#line 3279
      if ((int const   )*(*tmp___15 + i) & 8) {
#line 3279
        if (trans) {
#line 3279
          tmp___14 = (int )*(trans + i);
        } else {
#line 3279
          tmp___14 = i;
        }
#line 3279
        ch = tmp___14;
#line 3279
        *(sbcset + (unsigned long )ch / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )ch % (sizeof(unsigned int ) * 8UL));
      }
#line 3279
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 3280
    if (0) {
      {
      {
#line 3280
      __s1_len___11 = strlen(name);
      }
      {
#line 3280
      __s2_len___11 = strlen("cntrl");
      }
      }
#line 3280
      if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1U)) {
#line 3280
        goto _L___24;
      } else
#line 3280
      if (__s1_len___11 >= 4U) {
        _L___24: /* CIL Label */ 
#line 3280
        if (! ((size_t )((void const   *)("cntrl" + 1)) - (size_t )((void const   *)"cntrl") == 1U)) {
#line 3280
          tmp___103 = 1;
        } else
#line 3280
        if (__s2_len___11 >= 4U) {
#line 3280
          tmp___103 = 1;
        } else {
#line 3280
          tmp___103 = 0;
        }
      } else {
#line 3280
        tmp___103 = 0;
      }
#line 3280
      if (tmp___103) {
#line 3280
        if (__s1_len___11 < __s2_len___11) {
#line 3280
          tmp___99 = __s1_len___11;
        } else {
#line 3280
          tmp___99 = __s2_len___11;
        }
        {
        {
#line 3280
        tmp___100 = memcmp((void const   *)name, (void const   *)"cntrl", tmp___99 + 1U);
        }
#line 3280
        tmp___102 = tmp___100;
        }
      } else {
        {
        {
#line 3280
        tmp___101 = strcmp(name, "cntrl");
        }
#line 3280
        tmp___102 = tmp___101;
        }
      }
    } else {
      {
      {
#line 3280
      tmp___101 = strcmp(name, "cntrl");
      }
#line 3280
      tmp___102 = tmp___101;
      }
    }
#line 3280
    if (tmp___102 == 0) {
#line 3281
      i = 0;
      {
      {
#line 3281
      while (1) {
        while_continue___12: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 3281
        if (! (i < 256)) {
#line 3281
          goto while_break___0;
        }
        {
        {
#line 3281
        tmp___17 = __ctype_b_loc();
        }
        }
#line 3281
        if ((int const   )*(*tmp___17 + i) & 2) {
#line 3281
          if (trans) {
#line 3281
            tmp___16 = (int )*(trans + i);
          } else {
#line 3281
            tmp___16 = i;
          }
#line 3281
          ch___0 = tmp___16;
#line 3281
          *(sbcset + (unsigned long )ch___0 / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )ch___0 % (sizeof(unsigned int ) * 8UL));
        }
#line 3281
        i ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 3282
      if (0) {
        {
        {
#line 3282
        __s1_len___10 = strlen(name);
        }
        {
#line 3282
        __s2_len___10 = strlen("lower");
        }
        }
#line 3282
        if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1U)) {
#line 3282
          goto _L___22;
        } else
#line 3282
        if (__s1_len___10 >= 4U) {
          _L___22: /* CIL Label */ 
#line 3282
          if (! ((size_t )((void const   *)("lower" + 1)) - (size_t )((void const   *)"lower") == 1U)) {
#line 3282
            tmp___97 = 1;
          } else
#line 3282
          if (__s2_len___10 >= 4U) {
#line 3282
            tmp___97 = 1;
          } else {
#line 3282
            tmp___97 = 0;
          }
        } else {
#line 3282
          tmp___97 = 0;
        }
#line 3282
        if (tmp___97) {
#line 3282
          if (__s1_len___10 < __s2_len___10) {
#line 3282
            tmp___93 = __s1_len___10;
          } else {
#line 3282
            tmp___93 = __s2_len___10;
          }
          {
          {
#line 3282
          tmp___94 = memcmp((void const   *)name, (void const   *)"lower", tmp___93 + 1U);
          }
#line 3282
          tmp___96 = tmp___94;
          }
        } else {
          {
          {
#line 3282
          tmp___95 = strcmp(name, "lower");
          }
#line 3282
          tmp___96 = tmp___95;
          }
        }
      } else {
        {
        {
#line 3282
        tmp___95 = strcmp(name, "lower");
        }
#line 3282
        tmp___96 = tmp___95;
        }
      }
#line 3282
      if (tmp___96 == 0) {
#line 3283
        i = 0;
        {
        {
#line 3283
        while (1) {
          while_continue___13: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 3283
          if (! (i < 256)) {
#line 3283
            goto while_break___1;
          }
          {
          {
#line 3283
          tmp___19 = __ctype_b_loc();
          }
          }
#line 3283
          if ((int const   )*(*tmp___19 + i) & 512) {
#line 3283
            if (trans) {
#line 3283
              tmp___18 = (int )*(trans + i);
            } else {
#line 3283
              tmp___18 = i;
            }
#line 3283
            ch___1 = tmp___18;
#line 3283
            *(sbcset + (unsigned long )ch___1 / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )ch___1 % (sizeof(unsigned int ) * 8UL));
          }
#line 3283
          i ++;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 3284
        if (0) {
          {
          {
#line 3284
          __s1_len___9 = strlen(name);
          }
          {
#line 3284
          __s2_len___9 = strlen("space");
          }
          }
#line 3284
          if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1U)) {
#line 3284
            goto _L___20;
          } else
#line 3284
          if (__s1_len___9 >= 4U) {
            _L___20: /* CIL Label */ 
#line 3284
            if (! ((size_t )((void const   *)("space" + 1)) - (size_t )((void const   *)"space") == 1U)) {
#line 3284
              tmp___91 = 1;
            } else
#line 3284
            if (__s2_len___9 >= 4U) {
#line 3284
              tmp___91 = 1;
            } else {
#line 3284
              tmp___91 = 0;
            }
          } else {
#line 3284
            tmp___91 = 0;
          }
#line 3284
          if (tmp___91) {
#line 3284
            if (__s1_len___9 < __s2_len___9) {
#line 3284
              tmp___87 = __s1_len___9;
            } else {
#line 3284
              tmp___87 = __s2_len___9;
            }
            {
            {
#line 3284
            tmp___88 = memcmp((void const   *)name, (void const   *)"space", tmp___87 + 1U);
            }
#line 3284
            tmp___90 = tmp___88;
            }
          } else {
            {
            {
#line 3284
            tmp___89 = strcmp(name, "space");
            }
#line 3284
            tmp___90 = tmp___89;
            }
          }
        } else {
          {
          {
#line 3284
          tmp___89 = strcmp(name, "space");
          }
#line 3284
          tmp___90 = tmp___89;
          }
        }
#line 3284
        if (tmp___90 == 0) {
#line 3285
          i = 0;
          {
          {
#line 3285
          while (1) {
            while_continue___14: /* CIL Label */ ;
            while_continue___2: /* CIL Label */ ;
#line 3285
            if (! (i < 256)) {
#line 3285
              goto while_break___2;
            }
            {
            {
#line 3285
            tmp___21 = __ctype_b_loc();
            }
            }
#line 3285
            if ((int const   )*(*tmp___21 + i) & 8192) {
#line 3285
              if (trans) {
#line 3285
                tmp___20 = (int )*(trans + i);
              } else {
#line 3285
                tmp___20 = i;
              }
#line 3285
              ch___2 = tmp___20;
#line 3285
              *(sbcset + (unsigned long )ch___2 / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )ch___2 % (sizeof(unsigned int ) * 8UL));
            }
#line 3285
            i ++;
          }
          while_break___14: /* CIL Label */ ;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 3286
          if (0) {
            {
            {
#line 3286
            __s1_len___8 = strlen(name);
            }
            {
#line 3286
            __s2_len___8 = strlen("alpha");
            }
            }
#line 3286
            if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1U)) {
#line 3286
              goto _L___18;
            } else
#line 3286
            if (__s1_len___8 >= 4U) {
              _L___18: /* CIL Label */ 
#line 3286
              if (! ((size_t )((void const   *)("alpha" + 1)) - (size_t )((void const   *)"alpha") == 1U)) {
#line 3286
                tmp___85 = 1;
              } else
#line 3286
              if (__s2_len___8 >= 4U) {
#line 3286
                tmp___85 = 1;
              } else {
#line 3286
                tmp___85 = 0;
              }
            } else {
#line 3286
              tmp___85 = 0;
            }
#line 3286
            if (tmp___85) {
#line 3286
              if (__s1_len___8 < __s2_len___8) {
#line 3286
                tmp___81 = __s1_len___8;
              } else {
#line 3286
                tmp___81 = __s2_len___8;
              }
              {
              {
#line 3286
              tmp___82 = memcmp((void const   *)name, (void const   *)"alpha", tmp___81 + 1U);
              }
#line 3286
              tmp___84 = tmp___82;
              }
            } else {
              {
              {
#line 3286
              tmp___83 = strcmp(name, "alpha");
              }
#line 3286
              tmp___84 = tmp___83;
              }
            }
          } else {
            {
            {
#line 3286
            tmp___83 = strcmp(name, "alpha");
            }
#line 3286
            tmp___84 = tmp___83;
            }
          }
#line 3286
          if (tmp___84 == 0) {
#line 3287
            i = 0;
            {
            {
#line 3287
            while (1) {
              while_continue___15: /* CIL Label */ ;
              while_continue___3: /* CIL Label */ ;
#line 3287
              if (! (i < 256)) {
#line 3287
                goto while_break___3;
              }
              {
              {
#line 3287
              tmp___23 = __ctype_b_loc();
              }
              }
#line 3287
              if ((int const   )*(*tmp___23 + i) & 1024) {
#line 3287
                if (trans) {
#line 3287
                  tmp___22 = (int )*(trans + i);
                } else {
#line 3287
                  tmp___22 = i;
                }
#line 3287
                ch___3 = tmp___22;
#line 3287
                *(sbcset + (unsigned long )ch___3 / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )ch___3 % (sizeof(unsigned int ) * 8UL));
              }
#line 3287
              i ++;
            }
            while_break___15: /* CIL Label */ ;
            }
            while_break___3: /* CIL Label */ ;
            }
          } else {
#line 3288
            if (0) {
              {
              {
#line 3288
              __s1_len___7 = strlen(name);
              }
              {
#line 3288
              __s2_len___7 = strlen("digit");
              }
              }
#line 3288
              if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1U)) {
#line 3288
                goto _L___16;
              } else
#line 3288
              if (__s1_len___7 >= 4U) {
                _L___16: /* CIL Label */ 
#line 3288
                if (! ((size_t )((void const   *)("digit" + 1)) - (size_t )((void const   *)"digit") == 1U)) {
#line 3288
                  tmp___79 = 1;
                } else
#line 3288
                if (__s2_len___7 >= 4U) {
#line 3288
                  tmp___79 = 1;
                } else {
#line 3288
                  tmp___79 = 0;
                }
              } else {
#line 3288
                tmp___79 = 0;
              }
#line 3288
              if (tmp___79) {
#line 3288
                if (__s1_len___7 < __s2_len___7) {
#line 3288
                  tmp___75 = __s1_len___7;
                } else {
#line 3288
                  tmp___75 = __s2_len___7;
                }
                {
                {
#line 3288
                tmp___76 = memcmp((void const   *)name, (void const   *)"digit", tmp___75 + 1U);
                }
#line 3288
                tmp___78 = tmp___76;
                }
              } else {
                {
                {
#line 3288
                tmp___77 = strcmp(name, "digit");
                }
#line 3288
                tmp___78 = tmp___77;
                }
              }
            } else {
              {
              {
#line 3288
              tmp___77 = strcmp(name, "digit");
              }
#line 3288
              tmp___78 = tmp___77;
              }
            }
#line 3288
            if (tmp___78 == 0) {
#line 3289
              i = 0;
              {
              {
#line 3289
              while (1) {
                while_continue___16: /* CIL Label */ ;
                while_continue___4: /* CIL Label */ ;
#line 3289
                if (! (i < 256)) {
#line 3289
                  goto while_break___4;
                }
                {
                {
#line 3289
                tmp___25 = __ctype_b_loc();
                }
                }
#line 3289
                if ((int const   )*(*tmp___25 + i) & 2048) {
#line 3289
                  if (trans) {
#line 3289
                    tmp___24 = (int )*(trans + i);
                  } else {
#line 3289
                    tmp___24 = i;
                  }
#line 3289
                  ch___4 = tmp___24;
#line 3289
                  *(sbcset + (unsigned long )ch___4 / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )ch___4 % (sizeof(unsigned int ) * 8UL));
                }
#line 3289
                i ++;
              }
              while_break___16: /* CIL Label */ ;
              }
              while_break___4: /* CIL Label */ ;
              }
            } else {
#line 3290
              if (0) {
                {
                {
#line 3290
                __s1_len___6 = strlen(name);
                }
                {
#line 3290
                __s2_len___6 = strlen("print");
                }
                }
#line 3290
                if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1U)) {
#line 3290
                  goto _L___14;
                } else
#line 3290
                if (__s1_len___6 >= 4U) {
                  _L___14: /* CIL Label */ 
#line 3290
                  if (! ((size_t )((void const   *)("print" + 1)) - (size_t )((void const   *)"print") == 1U)) {
#line 3290
                    tmp___73 = 1;
                  } else
#line 3290
                  if (__s2_len___6 >= 4U) {
#line 3290
                    tmp___73 = 1;
                  } else {
#line 3290
                    tmp___73 = 0;
                  }
                } else {
#line 3290
                  tmp___73 = 0;
                }
#line 3290
                if (tmp___73) {
#line 3290
                  if (__s1_len___6 < __s2_len___6) {
#line 3290
                    tmp___69 = __s1_len___6;
                  } else {
#line 3290
                    tmp___69 = __s2_len___6;
                  }
                  {
                  {
#line 3290
                  tmp___70 = memcmp((void const   *)name, (void const   *)"print",
                                    tmp___69 + 1U);
                  }
#line 3290
                  tmp___72 = tmp___70;
                  }
                } else {
                  {
                  {
#line 3290
                  tmp___71 = strcmp(name, "print");
                  }
#line 3290
                  tmp___72 = tmp___71;
                  }
                }
              } else {
                {
                {
#line 3290
                tmp___71 = strcmp(name, "print");
                }
#line 3290
                tmp___72 = tmp___71;
                }
              }
#line 3290
              if (tmp___72 == 0) {
#line 3291
                i = 0;
                {
                {
#line 3291
                while (1) {
                  while_continue___17: /* CIL Label */ ;
                  while_continue___5: /* CIL Label */ ;
#line 3291
                  if (! (i < 256)) {
#line 3291
                    goto while_break___5;
                  }
                  {
                  {
#line 3291
                  tmp___27 = __ctype_b_loc();
                  }
                  }
#line 3291
                  if ((int const   )*(*tmp___27 + i) & 16384) {
#line 3291
                    if (trans) {
#line 3291
                      tmp___26 = (int )*(trans + i);
                    } else {
#line 3291
                      tmp___26 = i;
                    }
#line 3291
                    ch___5 = tmp___26;
#line 3291
                    *(sbcset + (unsigned long )ch___5 / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )ch___5 % (sizeof(unsigned int ) * 8UL));
                  }
#line 3291
                  i ++;
                }
                while_break___17: /* CIL Label */ ;
                }
                while_break___5: /* CIL Label */ ;
                }
              } else {
#line 3292
                if (0) {
                  {
                  {
#line 3292
                  __s1_len___5 = strlen(name);
                  }
                  {
#line 3292
                  __s2_len___5 = strlen("upper");
                  }
                  }
#line 3292
                  if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1U)) {
#line 3292
                    goto _L___12;
                  } else
#line 3292
                  if (__s1_len___5 >= 4U) {
                    _L___12: /* CIL Label */ 
#line 3292
                    if (! ((size_t )((void const   *)("upper" + 1)) - (size_t )((void const   *)"upper") == 1U)) {
#line 3292
                      tmp___67 = 1;
                    } else
#line 3292
                    if (__s2_len___5 >= 4U) {
#line 3292
                      tmp___67 = 1;
                    } else {
#line 3292
                      tmp___67 = 0;
                    }
                  } else {
#line 3292
                    tmp___67 = 0;
                  }
#line 3292
                  if (tmp___67) {
#line 3292
                    if (__s1_len___5 < __s2_len___5) {
#line 3292
                      tmp___63 = __s1_len___5;
                    } else {
#line 3292
                      tmp___63 = __s2_len___5;
                    }
                    {
                    {
#line 3292
                    tmp___64 = memcmp((void const   *)name, (void const   *)"upper",
                                      tmp___63 + 1U);
                    }
#line 3292
                    tmp___66 = tmp___64;
                    }
                  } else {
                    {
                    {
#line 3292
                    tmp___65 = strcmp(name, "upper");
                    }
#line 3292
                    tmp___66 = tmp___65;
                    }
                  }
                } else {
                  {
                  {
#line 3292
                  tmp___65 = strcmp(name, "upper");
                  }
#line 3292
                  tmp___66 = tmp___65;
                  }
                }
#line 3292
                if (tmp___66 == 0) {
#line 3293
                  i = 0;
                  {
                  {
#line 3293
                  while (1) {
                    while_continue___18: /* CIL Label */ ;
                    while_continue___6: /* CIL Label */ ;
#line 3293
                    if (! (i < 256)) {
#line 3293
                      goto while_break___6;
                    }
                    {
                    {
#line 3293
                    tmp___29 = __ctype_b_loc();
                    }
                    }
#line 3293
                    if ((int const   )*(*tmp___29 + i) & 256) {
#line 3293
                      if (trans) {
#line 3293
                        tmp___28 = (int )*(trans + i);
                      } else {
#line 3293
                        tmp___28 = i;
                      }
#line 3293
                      ch___6 = tmp___28;
#line 3293
                      *(sbcset + (unsigned long )ch___6 / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )ch___6 % (sizeof(unsigned int ) * 8UL));
                    }
#line 3293
                    i ++;
                  }
                  while_break___18: /* CIL Label */ ;
                  }
                  while_break___6: /* CIL Label */ ;
                  }
                } else {
#line 3294
                  if (0) {
                    {
                    {
#line 3294
                    __s1_len___4 = strlen(name);
                    }
                    {
#line 3294
                    __s2_len___4 = strlen("blank");
                    }
                    }
#line 3294
                    if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1U)) {
#line 3294
                      goto _L___10;
                    } else
#line 3294
                    if (__s1_len___4 >= 4U) {
                      _L___10: /* CIL Label */ 
#line 3294
                      if (! ((size_t )((void const   *)("blank" + 1)) - (size_t )((void const   *)"blank") == 1U)) {
#line 3294
                        tmp___61 = 1;
                      } else
#line 3294
                      if (__s2_len___4 >= 4U) {
#line 3294
                        tmp___61 = 1;
                      } else {
#line 3294
                        tmp___61 = 0;
                      }
                    } else {
#line 3294
                      tmp___61 = 0;
                    }
#line 3294
                    if (tmp___61) {
#line 3294
                      if (__s1_len___4 < __s2_len___4) {
#line 3294
                        tmp___57 = __s1_len___4;
                      } else {
#line 3294
                        tmp___57 = __s2_len___4;
                      }
                      {
                      {
#line 3294
                      tmp___58 = memcmp((void const   *)name, (void const   *)"blank",
                                        tmp___57 + 1U);
                      }
#line 3294
                      tmp___60 = tmp___58;
                      }
                    } else {
                      {
                      {
#line 3294
                      tmp___59 = strcmp(name, "blank");
                      }
#line 3294
                      tmp___60 = tmp___59;
                      }
                    }
                  } else {
                    {
                    {
#line 3294
                    tmp___59 = strcmp(name, "blank");
                    }
#line 3294
                    tmp___60 = tmp___59;
                    }
                  }
#line 3294
                  if (tmp___60 == 0) {
#line 3295
                    i = 0;
                    {
                    {
#line 3295
                    while (1) {
                      while_continue___19: /* CIL Label */ ;
                      while_continue___7: /* CIL Label */ ;
#line 3295
                      if (! (i < 256)) {
#line 3295
                        goto while_break___7;
                      }
                      {
                      {
#line 3295
                      tmp___31 = isblank(i);
                      }
                      }
#line 3295
                      if (tmp___31) {
#line 3295
                        if (trans) {
#line 3295
                          tmp___30 = (int )*(trans + i);
                        } else {
#line 3295
                          tmp___30 = i;
                        }
#line 3295
                        ch___7 = tmp___30;
#line 3295
                        *(sbcset + (unsigned long )ch___7 / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )ch___7 % (sizeof(unsigned int ) * 8UL));
                      }
#line 3295
                      i ++;
                    }
                    while_break___19: /* CIL Label */ ;
                    }
                    while_break___7: /* CIL Label */ ;
                    }
                  } else {
#line 3296
                    if (0) {
                      {
                      {
#line 3296
                      __s1_len___3 = strlen(name);
                      }
                      {
#line 3296
                      __s2_len___3 = strlen("graph");
                      }
                      }
#line 3296
                      if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1U)) {
#line 3296
                        goto _L___8;
                      } else
#line 3296
                      if (__s1_len___3 >= 4U) {
                        _L___8: /* CIL Label */ 
#line 3296
                        if (! ((size_t )((void const   *)("graph" + 1)) - (size_t )((void const   *)"graph") == 1U)) {
#line 3296
                          tmp___55 = 1;
                        } else
#line 3296
                        if (__s2_len___3 >= 4U) {
#line 3296
                          tmp___55 = 1;
                        } else {
#line 3296
                          tmp___55 = 0;
                        }
                      } else {
#line 3296
                        tmp___55 = 0;
                      }
#line 3296
                      if (tmp___55) {
#line 3296
                        if (__s1_len___3 < __s2_len___3) {
#line 3296
                          tmp___51 = __s1_len___3;
                        } else {
#line 3296
                          tmp___51 = __s2_len___3;
                        }
                        {
                        {
#line 3296
                        tmp___52 = memcmp((void const   *)name, (void const   *)"graph",
                                          tmp___51 + 1U);
                        }
#line 3296
                        tmp___54 = tmp___52;
                        }
                      } else {
                        {
                        {
#line 3296
                        tmp___53 = strcmp(name, "graph");
                        }
#line 3296
                        tmp___54 = tmp___53;
                        }
                      }
                    } else {
                      {
                      {
#line 3296
                      tmp___53 = strcmp(name, "graph");
                      }
#line 3296
                      tmp___54 = tmp___53;
                      }
                    }
#line 3296
                    if (tmp___54 == 0) {
#line 3297
                      i = 0;
                      {
                      {
#line 3297
                      while (1) {
                        while_continue___20: /* CIL Label */ ;
                        while_continue___8: /* CIL Label */ ;
#line 3297
                        if (! (i < 256)) {
#line 3297
                          goto while_break___8;
                        }
                        {
                        {
#line 3297
                        tmp___33 = __ctype_b_loc();
                        }
                        }
#line 3297
                        if ((int const   )*(*tmp___33 + i) & 32768) {
#line 3297
                          if (trans) {
#line 3297
                            tmp___32 = (int )*(trans + i);
                          } else {
#line 3297
                            tmp___32 = i;
                          }
#line 3297
                          ch___8 = tmp___32;
#line 3297
                          *(sbcset + (unsigned long )ch___8 / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )ch___8 % (sizeof(unsigned int ) * 8UL));
                        }
#line 3297
                        i ++;
                      }
                      while_break___20: /* CIL Label */ ;
                      }
                      while_break___8: /* CIL Label */ ;
                      }
                    } else {
#line 3298
                      if (0) {
                        {
                        {
#line 3298
                        __s1_len___2 = strlen(name);
                        }
                        {
#line 3298
                        __s2_len___2 = strlen("punct");
                        }
                        }
#line 3298
                        if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1U)) {
#line 3298
                          goto _L___6;
                        } else
#line 3298
                        if (__s1_len___2 >= 4U) {
                          _L___6: /* CIL Label */ 
#line 3298
                          if (! ((size_t )((void const   *)("punct" + 1)) - (size_t )((void const   *)"punct") == 1U)) {
#line 3298
                            tmp___49 = 1;
                          } else
#line 3298
                          if (__s2_len___2 >= 4U) {
#line 3298
                            tmp___49 = 1;
                          } else {
#line 3298
                            tmp___49 = 0;
                          }
                        } else {
#line 3298
                          tmp___49 = 0;
                        }
#line 3298
                        if (tmp___49) {
#line 3298
                          if (__s1_len___2 < __s2_len___2) {
#line 3298
                            tmp___45 = __s1_len___2;
                          } else {
#line 3298
                            tmp___45 = __s2_len___2;
                          }
                          {
                          {
#line 3298
                          tmp___46 = memcmp((void const   *)name, (void const   *)"punct",
                                            tmp___45 + 1U);
                          }
#line 3298
                          tmp___48 = tmp___46;
                          }
                        } else {
                          {
                          {
#line 3298
                          tmp___47 = strcmp(name, "punct");
                          }
#line 3298
                          tmp___48 = tmp___47;
                          }
                        }
                      } else {
                        {
                        {
#line 3298
                        tmp___47 = strcmp(name, "punct");
                        }
#line 3298
                        tmp___48 = tmp___47;
                        }
                      }
#line 3298
                      if (tmp___48 == 0) {
#line 3299
                        i = 0;
                        {
                        {
#line 3299
                        while (1) {
                          while_continue___21: /* CIL Label */ ;
                          while_continue___9: /* CIL Label */ ;
#line 3299
                          if (! (i < 256)) {
#line 3299
                            goto while_break___9;
                          }
                          {
                          {
#line 3299
                          tmp___35 = __ctype_b_loc();
                          }
                          }
#line 3299
                          if ((int const   )*(*tmp___35 + i) & 4) {
#line 3299
                            if (trans) {
#line 3299
                              tmp___34 = (int )*(trans + i);
                            } else {
#line 3299
                              tmp___34 = i;
                            }
#line 3299
                            ch___9 = tmp___34;
#line 3299
                            *(sbcset + (unsigned long )ch___9 / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )ch___9 % (sizeof(unsigned int ) * 8UL));
                          }
#line 3299
                          i ++;
                        }
                        while_break___21: /* CIL Label */ ;
                        }
                        while_break___9: /* CIL Label */ ;
                        }
                      } else {
#line 3300
                        if (0) {
                          {
                          {
#line 3300
                          __s1_len___1 = strlen(name);
                          }
                          {
#line 3300
                          __s2_len___1 = strlen("xdigit");
                          }
                          }
#line 3300
                          if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1U)) {
#line 3300
                            goto _L___4;
                          } else
#line 3300
                          if (__s1_len___1 >= 4U) {
                            _L___4: /* CIL Label */ 
#line 3300
                            if (! ((size_t )((void const   *)("xdigit" + 1)) - (size_t )((void const   *)"xdigit") == 1U)) {
#line 3300
                              tmp___43 = 1;
                            } else
#line 3300
                            if (__s2_len___1 >= 4U) {
#line 3300
                              tmp___43 = 1;
                            } else {
#line 3300
                              tmp___43 = 0;
                            }
                          } else {
#line 3300
                            tmp___43 = 0;
                          }
#line 3300
                          if (tmp___43) {
#line 3300
                            if (__s1_len___1 < __s2_len___1) {
#line 3300
                              tmp___39 = __s1_len___1;
                            } else {
#line 3300
                              tmp___39 = __s2_len___1;
                            }
                            {
                            {
#line 3300
                            tmp___40 = memcmp((void const   *)name, (void const   *)"xdigit",
                                              tmp___39 + 1U);
                            }
#line 3300
                            tmp___42 = tmp___40;
                            }
                          } else {
                            {
                            {
#line 3300
                            tmp___41 = strcmp(name, "xdigit");
                            }
#line 3300
                            tmp___42 = tmp___41;
                            }
                          }
                        } else {
                          {
                          {
#line 3300
                          tmp___41 = strcmp(name, "xdigit");
                          }
#line 3300
                          tmp___42 = tmp___41;
                          }
                        }
#line 3300
                        if (tmp___42 == 0) {
#line 3301
                          i = 0;
                          {
                          {
#line 3301
                          while (1) {
                            while_continue___22: /* CIL Label */ ;
                            while_continue___10: /* CIL Label */ ;
#line 3301
                            if (! (i < 256)) {
#line 3301
                              goto while_break___10;
                            }
                            {
                            {
#line 3301
                            tmp___37 = __ctype_b_loc();
                            }
                            }
#line 3301
                            if ((int const   )*(*tmp___37 + i) & 4096) {
#line 3301
                              if (trans) {
#line 3301
                                tmp___36 = (int )*(trans + i);
                              } else {
#line 3301
                                tmp___36 = i;
                              }
#line 3301
                              ch___10 = tmp___36;
#line 3301
                              *(sbcset + (unsigned long )ch___10 / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )ch___10 % (sizeof(unsigned int ) * 8UL));
                            }
#line 3301
                            i ++;
                          }
                          while_break___22: /* CIL Label */ ;
                          }
                          while_break___10: /* CIL Label */ ;
                          }
                        } else {
#line 3303
                          return ((reg_errcode_t )4);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 3305
  return ((reg_errcode_t )0);
}
}
#line 3308 "regcomp.c"
static bin_tree_t *build_charclass_op(re_dfa_t *dfa , char *trans , unsigned char const   *class_name ,
                                      unsigned char const   *extra , int not , reg_errcode_t *err ) 
{ 
  re_bitset_ptr_t sbcset ;
  re_charset_t *mbcset ;
  int alloc ;
  reg_errcode_t ret ;
  re_token_t br_token ;
  bin_tree_t *tree ;
  int new_idx ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int i ;
  wint_t tmp___3 ;
  size_t tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  re_token_t alt_token ;
  bin_tree_t *mbc_tree ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 3320
  alloc = 0;
  {
#line 3329
  tmp = calloc((size_t )sizeof(unsigned int ), (size_t )(((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)));
  }
#line 3329
  sbcset = (re_bitset_ptr_t )tmp;
  {
#line 3331
  tmp___0 = calloc((size_t )sizeof(re_charset_t ), (size_t )1);
  }
#line 3331
  mbcset = (re_charset_t *)tmp___0;
  }
#line 3335
  if ((unsigned long )sbcset == (unsigned long )((void *)0)) {
#line 3335
    tmp___1 = 1;
  } else
#line 3335
  if ((unsigned long )mbcset == (unsigned long )((void *)0)) {
#line 3335
    tmp___1 = 1;
  } else {
#line 3335
    tmp___1 = 0;
  }
  {
  {
#line 3335
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  }
#line 3335
  if (tmp___2) {
#line 3340
    *err = (reg_errcode_t )12;
#line 3341
    return ((bin_tree_t *)((void *)0));
  }
#line 3344
  if (not) {
    {
#line 3352
    mbcset->non_match = 1U;
    {
#line 3353
    tmp___4 = __ctype_get_mb_cur_max();
    }
    }
#line 3353
    if (tmp___4 > 1U) {
#line 3354
      i = 0;
      {
      {
#line 3354
      while (1) {
        while_continue___1: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 3354
        if (! (i < 256)) {
#line 3354
          goto while_break;
        }
        {
        {
#line 3355
        tmp___3 = btowc(i);
        }
        }
#line 3355
        if (tmp___3 == 4294967295U) {
#line 3356
          *(sbcset + (unsigned long )i / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )i % (sizeof(unsigned int ) * 8UL));
        }
#line 3354
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
  {
#line 3363
  ret = build_charclass(trans, sbcset, mbcset, & alloc, class_name, (reg_syntax_t )0);
  }
  {
#line 3369
  tmp___5 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
  }
  }
#line 3369
  if (tmp___5) {
    {
    {
#line 3371
    free((void *)sbcset);
    }
    {
#line 3373
    free_charset(mbcset);
    }
#line 3375
    *err = ret;
    }
#line 3376
    return ((bin_tree_t *)((void *)0));
  }
  {
  {
#line 3379
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 3379
    if (! *extra) {
#line 3379
      goto while_break___0;
    }
#line 3380
    *(sbcset + (unsigned long )*extra / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )*extra % (sizeof(unsigned int ) * 8UL));
#line 3379
    extra ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3384
  if (mbcset->non_match) {
    {
    {
#line 3388
    bitset_not((unsigned int *)sbcset);
    }
    }
  }
  {
#line 3391
  br_token.type = (re_token_type_t )21;
#line 3392
  br_token.opr.sbcset = sbcset;
  {
#line 3393
  new_idx = re_dfa_add_node(dfa, br_token, 0);
  }
  {
#line 3394
  tree = create_tree((bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )0,
                     new_idx);
  }
  }
#line 3395
  if (new_idx == -1) {
#line 3395
    tmp___6 = 1;
  } else
#line 3395
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 3395
    tmp___6 = 1;
  } else {
#line 3395
    tmp___6 = 0;
  }
  {
  {
#line 3395
  tmp___7 = __builtin_expect((long )tmp___6, 0L);
  }
  }
#line 3395
  if (tmp___7) {
#line 3396
    goto build_word_op_espace;
  }
  {
  {
#line 3399
  tmp___12 = __ctype_get_mb_cur_max();
  }
  }
#line 3399
  if (tmp___12 > 1U) {
    {
#line 3404
    br_token.type = (re_token_type_t )22;
#line 3405
    br_token.opr.mbcset = mbcset;
#line 3406
    dfa->has_mb_node = 1U;
    {
#line 3407
    new_idx = re_dfa_add_node(dfa, br_token, 0);
    }
    {
#line 3408
    mbc_tree = create_tree((bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )0,
                           new_idx);
    }
    }
#line 3409
    if (new_idx == -1) {
#line 3409
      tmp___8 = 1;
    } else
#line 3409
    if ((unsigned long )mbc_tree == (unsigned long )((void *)0)) {
#line 3409
      tmp___8 = 1;
    } else {
#line 3409
      tmp___8 = 0;
    }
    {
    {
#line 3409
    tmp___9 = __builtin_expect((long )tmp___8, 0L);
    }
    }
#line 3409
    if (tmp___9) {
#line 3410
      goto build_word_op_espace;
    }
    {
#line 3412
    alt_token.type = (re_token_type_t )28;
    {
#line 3413
    new_idx = re_dfa_add_node(dfa, alt_token, 0);
    }
    {
#line 3414
    tree = create_tree(tree, mbc_tree, (re_token_type_t )0, new_idx);
    }
    }
#line 3415
    if (new_idx != -1) {
#line 3415
      if ((unsigned long )mbc_tree != (unsigned long )((void *)0)) {
#line 3415
        tmp___10 = 1;
      } else {
#line 3415
        tmp___10 = 0;
      }
    } else {
#line 3415
      tmp___10 = 0;
    }
    {
    {
#line 3415
    tmp___11 = __builtin_expect((long )tmp___10, 1L);
    }
    }
#line 3415
    if (tmp___11) {
#line 3416
      return (tree);
    }
  } else {
    {
    {
#line 3420
    free_charset(mbcset);
    }
    }
#line 3421
    return (tree);
  }
  build_word_op_espace: 
  {
  {
#line 3428
  free((void *)sbcset);
  }
  {
#line 3430
  free_charset(mbcset);
  }
#line 3432
  *err = (reg_errcode_t )12;
  }
#line 3433
  return ((bin_tree_t *)((void *)0));
}
}
#line 3441 "regcomp.c"
static int fetch_number(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) 
{ 
  int num ;
  unsigned char c ;
  long tmp ;
  int tmp___0 ;

  {
#line 3447
  num = -1;
  {
  {
#line 3449
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 3451
    *token = fetch_token(input, syntax);
    }
#line 3452
    c = token->opr.c;
    {
#line 3453
    tmp = __builtin_expect((long )((unsigned int )token->type == 27U), 0L);
    }
    }
#line 3453
    if (tmp) {
#line 3454
      return (-2);
    }
#line 3455
    if ((unsigned int )token->type == 5U) {
#line 3456
      goto while_break;
    } else
#line 3455
    if ((int )c == 44) {
#line 3456
      goto while_break;
    }
#line 3457
    if ((unsigned int )token->type != 26U) {
#line 3457
      num = -2;
    } else
#line 3457
    if ((int )c < 48) {
#line 3457
      num = -2;
    } else
#line 3457
    if (57 < (int )c) {
#line 3457
      num = -2;
    } else
#line 3457
    if (num == -2) {
#line 3457
      num = -2;
    } else {
#line 3457
      if (num == -1) {
#line 3457
        tmp___0 = (int )c - 48;
      } else {
#line 3457
        tmp___0 = (num * 10 + (int )c) - 48;
      }
#line 3457
      num = tmp___0;
    }
#line 3459
    if (num > 32767) {
#line 3459
      num = -2;
    } else {
#line 3459
      num = num;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3461
  return (num);
}
}
#line 3465 "regcomp.c"
static void free_charset(re_charset_t *cset ) 
{ 


  {
  {
  {
#line 3468
  free((void *)cset->mbchars);
  }
  {
#line 3475
  free((void *)cset->char_classes);
  }
  {
#line 3476
  free((void *)cset);
  }
  }
#line 3477
  return;
}
}
#line 3485 "regcomp.c"
static bin_tree_t *create_tree(bin_tree_t *left , bin_tree_t *right , re_token_type_t type ,
                               int index___0 ) 
{ 
  bin_tree_t *tree ;
  void *tmp ;
  long tmp___0 ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_53 *__u ;
  __uint8_t __c ;
  void *__s___1 ;

  {
  {
  {
#line 3493
  tmp = malloc((size_t )sizeof(bin_tree_t ));
  }
#line 3493
  tree = (bin_tree_t *)tmp;
  {
#line 3494
  tmp___0 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
  }
#line 3494
  if (tmp___0) {
    {
    {
#line 3496
    free_bin_tree(left);
    }
    {
#line 3497
    free_bin_tree(right);
    }
    }
#line 3498
    return ((bin_tree_t *)((void *)0));
  }
#line 3500
  tree->parent = (struct bin_tree_t *)((void *)0);
#line 3501
  tree->left = left;
#line 3502
  tree->right = right;
#line 3503
  tree->type = type;
#line 3504
  tree->node_idx = index___0;
#line 3505
  tree->first = -1;
#line 3506
  tree->next = -1;
#line 3507
  if (sizeof(re_node_set ) <= 16UL) {
#line 3507
    if (sizeof(re_node_set ) == 1UL) {
#line 3507
      __s___1 = (void *)(& tree->eclosure);
#line 3507
      *((__uint8_t *)__s___1) = (__uint8_t )'\000';
    } else {
#line 3507
      __s___0 = (void *)(& tree->eclosure);
#line 3507
      __u = (union __anonunion___u_53 *)__s___0;
#line 3507
      __c = (__uint8_t )'\000';
      {
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 15U) {
#line 3507
        goto case_15;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 11U) {
#line 3507
        goto case_11;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 7U) {
#line 3507
        goto case_7;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 3U) {
#line 3507
        goto case_3;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 14U) {
#line 3507
        goto case_14;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 10U) {
#line 3507
        goto case_10;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 6U) {
#line 3507
        goto case_6;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 2U) {
#line 3507
        goto case_2;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 13U) {
#line 3507
        goto case_13;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 9U) {
#line 3507
        goto case_9;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 5U) {
#line 3507
        goto case_5;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 1U) {
#line 3507
        goto case_1;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 16U) {
#line 3507
        goto case_16;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 12U) {
#line 3507
        goto case_12;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 8U) {
#line 3507
        goto case_8;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 4U) {
#line 3507
        goto case_4;
      }
#line 3507
      if ((unsigned int )sizeof(re_node_set ) == 0U) {
#line 3507
        goto case_0;
      }
#line 3507
      goto switch_break;
      case_15: /* CIL Label */ 
#line 3507
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3507
      __u = (union __anonunion___u_53 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 3507
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3507
      __u = (union __anonunion___u_53 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 3507
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3507
      __u = (union __anonunion___u_53 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 3507
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 3507
      __u = (union __anonunion___u_53 *)((void *)__u + 2);
#line 3507
      __u->__uc = __c;
#line 3507
      goto switch_break;
      case_14: /* CIL Label */ 
#line 3507
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3507
      __u = (union __anonunion___u_53 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 3507
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3507
      __u = (union __anonunion___u_53 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 3507
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3507
      __u = (union __anonunion___u_53 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 3507
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 3507
      goto switch_break;
      case_13: /* CIL Label */ 
#line 3507
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3507
      __u = (union __anonunion___u_53 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 3507
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3507
      __u = (union __anonunion___u_53 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 3507
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3507
      __u = (union __anonunion___u_53 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 3507
      __u->__uc = __c;
#line 3507
      goto switch_break;
      case_16: /* CIL Label */ 
#line 3507
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3507
      __u = (union __anonunion___u_53 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 3507
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3507
      __u = (union __anonunion___u_53 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 3507
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3507
      __u = (union __anonunion___u_53 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 3507
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 3507
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 3507
    __s = (void *)(& tree->eclosure);
    {
#line 3507
    __builtin_memset(__s, '\000', (int )sizeof(re_node_set ));
    }
    }
  }
#line 3509
  if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 3510
    left->parent = tree;
  }
#line 3511
  if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 3512
    right->parent = tree;
  }
#line 3513
  return (tree);
}
}
#line 3518 "regcomp.c"
static void free_bin_tree(bin_tree_t *tree ) 
{ 


  {
#line 3522
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 3523
    return;
  }
  {
  {
#line 3525
  free_bin_tree(tree->left);
  }
  {
#line 3526
  free_bin_tree(tree->right);
  }
  {
#line 3527
  free((void *)tree);
  }
  }
#line 3528
  return;
}
}
#line 3532 "regcomp.c"
static bin_tree_t *duplicate_tree(bin_tree_t const   *src , re_dfa_t *dfa ) 
{ 
  bin_tree_t *left ;
  bin_tree_t *right ;
  bin_tree_t *new_tree ;
  int new_node_idx ;
  long tmp ;
  long tmp___0 ;

  {
#line 3537
  left = (bin_tree_t *)((void *)0);
#line 3537
  right = (bin_tree_t *)((void *)0);
#line 3541
  if ((unsigned long )src->left != (unsigned long )((void *)0)) {
    {
    {
#line 3543
    left = duplicate_tree((bin_tree_t const   *)src->left, dfa);
    }
    }
#line 3544
    if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 3545
      return ((bin_tree_t *)((void *)0));
    }
  }
#line 3549
  if ((unsigned long )src->right != (unsigned long )((void *)0)) {
    {
    {
#line 3551
    right = duplicate_tree((bin_tree_t const   *)src->right, dfa);
    }
    }
#line 3552
    if ((unsigned long )right == (unsigned long )((void *)0)) {
      {
      {
#line 3554
      free_bin_tree(left);
      }
      }
#line 3555
      return ((bin_tree_t *)((void *)0));
    }
  }
#line 3560
  if ((unsigned int const   )src->type == 0U) {
    {
    {
#line 3562
    new_node_idx = re_dfa_add_node(dfa, *(dfa->nodes + src->node_idx), 0);
    }
#line 3563
    (dfa->nodes + new_node_idx)->duplicated = 1U;
    {
#line 3564
    tmp = __builtin_expect((long )(new_node_idx == -1), 0L);
    }
    }
#line 3564
    if (tmp) {
      {
      {
#line 3566
      free_bin_tree(left);
      }
      {
#line 3567
      free_bin_tree(right);
      }
      }
#line 3568
      return ((bin_tree_t *)((void *)0));
    }
  } else {
#line 3572
    new_node_idx = (int )src->type;
  }
  {
  {
#line 3574
  new_tree = create_tree(left, right, (re_token_type_t )src->type, new_node_idx);
  }
  {
#line 3575
  tmp___0 = __builtin_expect((long )((unsigned long )new_tree == (unsigned long )((void *)0)),
                             0L);
  }
  }
#line 3575
  if (tmp___0) {
    {
    {
#line 3577
    free_bin_tree(left);
    }
    {
#line 3578
    free_bin_tree(right);
    }
    }
  }
#line 3580
  return (new_tree);
}
}
#line 21 "regexec.c"
static reg_errcode_t match_ctx_init(re_match_context_t *mctx , int eflags , re_string_t *input ,
                                    int n ) ;
#line 23
static void match_ctx_clean(re_match_context_t *mctx ) ;
#line 24
static void match_ctx_free(re_match_context_t *mctx ) ;
#line 25
static void match_ctx_free_subtops(re_match_context_t *mctx ) ;
#line 26
static reg_errcode_t match_ctx_add_entry(re_match_context_t *mctx , int node , int str_idx ,
                                         int from , int to ) ;
#line 28
static int search_cur_bkref_entry(re_match_context_t *mctx , int str_idx ) ;
#line 29
static void match_ctx_clear_flag(re_match_context_t *mctx ) ;
#line 30
static reg_errcode_t match_ctx_add_subtop(re_match_context_t *mctx , int node , int str_idx ) ;
#line 32
static re_sub_match_last_t *match_ctx_add_sublast(re_sub_match_top_t *subtop , int node ,
                                                  int str_idx ) ;
#line 34
static void sift_ctx_init(re_sift_context_t *sctx , re_dfastate_t **sifted_sts , re_dfastate_t **limited_sts ,
                          int last_node , int last_str_idx , int check_subexp ) ;
#line 37
static reg_errcode_t re_search_internal(regex_t const   *preg , char const   *string ,
                                        int length , int start , int range , int stop ,
                                        size_t nmatch , regmatch_t *pmatch , int eflags ) ;
#line 42
static int re_search_2_stub(struct re_pattern_buffer *bufp , char const   *string1 ,
                            int length1 , char const   *string2 , int length2 , int start ,
                            int range , struct re_registers *regs___0 , int stop ,
                            int ret_len ) ;
#line 47
static int re_search_stub(struct re_pattern_buffer *bufp , char const   *string ,
                          int length , int start , int range , int stop , struct re_registers *regs___0 ,
                          int ret_len ) ;
#line 51
static unsigned int re_copy_regs(struct re_registers *regs___0 , regmatch_t *pmatch ,
                                 int nregs , int regs_allocated ) ;
#line 53
static re_dfastate_t *acquire_init_state_context(reg_errcode_t *err , regex_t const   *preg ,
                                                 re_match_context_t const   *mctx ,
                                                 int idx ) ;
#line 57
static reg_errcode_t prune_impossible_nodes(regex_t const   *preg , re_match_context_t *mctx ) ;
#line 59
static int check_matching(regex_t const   *preg , re_match_context_t *mctx , int fl_search ,
                          int fl_longest_match ) ;
#line 61
static int check_halt_node_context(re_dfa_t const   *dfa , int node , unsigned int context ) ;
#line 63
static int check_halt_state_context(regex_t const   *preg , re_dfastate_t const   *state ,
                                    re_match_context_t const   *mctx , int idx ) ;
#line 66
static void update_regs(re_dfa_t *dfa , regmatch_t *pmatch , int cur_node , int cur_idx ,
                        int nmatch ) ;
#line 68
static int proceed_next_node(regex_t const   *preg , int nregs , regmatch_t *regs___0 ,
                             re_match_context_t const   *mctx , int *pidx , int node ,
                             re_node_set *eps_via_nodes , struct re_fail_stack_t *fs ) ;
#line 72
static reg_errcode_t push_fail_stack(struct re_fail_stack_t *fs , int str_idx , int *dests ,
                                     int nregs , regmatch_t *regs___0 , re_node_set *eps_via_nodes ) ;
#line 76
static int pop_fail_stack(struct re_fail_stack_t *fs , int *pidx , int nregs , regmatch_t *regs___0 ,
                          re_node_set *eps_via_nodes ) ;
#line 78
static reg_errcode_t set_regs(regex_t const   *preg , re_match_context_t const   *mctx ,
                              size_t nmatch , regmatch_t *pmatch , int fl_backtrack ) ;
#line 82
static reg_errcode_t free_fail_stack_return(struct re_fail_stack_t *fs ) ;
#line 85
static int sift_states_iter_mb(regex_t const   *preg , re_match_context_t const   *mctx ,
                               re_sift_context_t *sctx , int node_idx , int str_idx ,
                               int max_str_idx ) ;
#line 90
static reg_errcode_t sift_states_backward(regex_t const   *preg , re_match_context_t *mctx ,
                                          re_sift_context_t *sctx ) ;
#line 93
static reg_errcode_t update_cur_sifted_state(regex_t const   *preg , re_match_context_t *mctx ,
                                             re_sift_context_t *sctx , int str_idx ,
                                             re_node_set *dest_nodes ) ;
#line 98
static reg_errcode_t add_epsilon_src_nodes(re_dfa_t *dfa , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) ;
#line 101
static reg_errcode_t sub_epsilon_src_nodes(re_dfa_t *dfa , int node , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) ;
#line 104
static int check_dst_limits(re_dfa_t *dfa , re_node_set *limits , re_match_context_t *mctx ,
                            int dst_node , int dst_idx , int src_node , int src_idx ) ;
#line 107
static int check_dst_limits_calc_pos(re_dfa_t *dfa , re_match_context_t *mctx , int limit ,
                                     re_node_set *eclosures , int subexp_idx , int from_node ,
                                     int str_idx ) ;
#line 110
static reg_errcode_t check_subexp_limits(re_dfa_t *dfa , re_node_set *dest_nodes ,
                                         re_node_set const   *candidates , re_node_set *limits ,
                                         struct re_backref_cache_entry *bkref_ents ,
                                         int str_idx ) ;
#line 116
static reg_errcode_t sift_states_bkref(regex_t const   *preg , re_match_context_t *mctx ,
                                       re_sift_context_t *sctx , int str_idx , re_node_set *dest_nodes ) ;
#line 120
static reg_errcode_t clean_state_log_if_need(re_match_context_t *mctx , int next_state_log_idx ) ;
#line 122
static reg_errcode_t merge_state_array(re_dfa_t *dfa , re_dfastate_t **dst , re_dfastate_t **src ,
                                       int num ) ;
#line 124
static re_dfastate_t *transit_state(reg_errcode_t *err , regex_t const   *preg , re_match_context_t *mctx ,
                                    re_dfastate_t *state , int fl_search ) ;
#line 127
static reg_errcode_t check_subexp_matching_top(re_dfa_t *dfa , re_match_context_t *mctx ,
                                               re_node_set *cur_nodes , int str_idx ) ;
#line 136
static reg_errcode_t transit_state_mb(regex_t const   *preg , re_dfastate_t *pstate ,
                                      re_match_context_t *mctx ) ;
#line 140
static reg_errcode_t transit_state_bkref(regex_t const   *preg , re_node_set *nodes ,
                                         re_match_context_t *mctx ) ;
#line 143
static reg_errcode_t get_subexp(regex_t const   *preg , re_match_context_t *mctx ,
                                int bkref_node , int bkref_str_idx ) ;
#line 145
static reg_errcode_t get_subexp_sub(regex_t const   *preg , re_match_context_t *mctx ,
                                    re_sub_match_top_t *sub_top , re_sub_match_last_t *sub_last ,
                                    int bkref_node , int bkref_str ) ;
#line 150
static int find_subexp_node(re_dfa_t *dfa , re_node_set *nodes , int subexp_idx ,
                            int fl_open ) ;
#line 152
static reg_errcode_t check_arrival(regex_t const   *preg , re_match_context_t *mctx ,
                                   state_array_t *path , int top_node , int top_str ,
                                   int last_node , int last_str , int fl_open ) ;
#line 157
static reg_errcode_t check_arrival_add_next_nodes(regex_t const   *preg , re_dfa_t *dfa ,
                                                  re_match_context_t *mctx , int str_idx ,
                                                  re_node_set *cur_nodes , re_node_set *next_nodes ) ;
#line 163
static reg_errcode_t check_arrival_expand_ecl(re_dfa_t *dfa , re_node_set *cur_nodes ,
                                              int ex_subexp , int fl_open ) ;
#line 166
static reg_errcode_t check_arrival_expand_ecl_sub(re_dfa_t *dfa , re_node_set *dst_nodes ,
                                                  int target , int ex_subexp , int fl_open ) ;
#line 170
static reg_errcode_t expand_bkref_cache(regex_t const   *preg , re_match_context_t *mctx ,
                                        re_node_set *cur_nodes , int cur_str , int last_str ,
                                        int subexp_num , int fl_open ) ;
#line 175
static re_dfastate_t **build_trtable(regex_t const   *preg , re_dfastate_t const   *state ,
                                     int fl_search ) ;
#line 179
static int check_node_accept_bytes(regex_t const   *preg , int node_idx , re_string_t const   *input ,
                                   int str_idx ) ;
#line 186
static int group_nodes_into_DFAstates(regex_t const   *preg , re_dfastate_t const   *state ,
                                      re_node_set *dests_node , bitset *dests_ch ) ;
#line 190
static int check_node_accept(regex_t const   *preg , re_token_t const   *node , re_match_context_t const   *mctx ,
                             int idx ) ;
#line 192
static reg_errcode_t extend_buffers(re_match_context_t *mctx ) ;
#line 210 "regexec.c"
int regexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
            size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) 
{ 
  reg_errcode_t err ;
  int length ;
  size_t tmp ;

  {
  {
  {
#line 219
  tmp = strlen((char const   *)string);
  }
#line 219
  length = (int )tmp;
  }
#line 220
  if (preg->no_sub) {
    {
    {
#line 221
    err = re_search_internal((regex_t const   *)preg, (char const   *)string, length,
                             0, length, length, (size_t )0, (regmatch_t *)((void *)0),
                             eflags);
    }
    }
  } else {
    {
    {
#line 224
    err = re_search_internal((regex_t const   *)preg, (char const   *)string, length,
                             0, length, length, nmatch, (regmatch_t *)pmatch, eflags);
    }
    }
  }
#line 226
  return ((unsigned int )err != 0U);
}
}
#line 261 "regexec.c"
int re_match(struct re_pattern_buffer *bufp , char const   *string , int length ,
             int start , struct re_registers *regs___0 ) 
{ 
  int tmp ;

  {
  {
  {
#line 268
  tmp = re_search_stub(bufp, string, length, start, 0, length, regs___0, 1);
  }
  }
#line 268
  return (tmp);
}
}
#line 274 "regexec.c"
int re_search(struct re_pattern_buffer *bufp , char const   *string , int length ,
              int start , int range , struct re_registers *regs___0 ) 
{ 
  int tmp ;

  {
  {
  {
#line 281
  tmp = re_search_stub(bufp, string, length, start, range, length, regs___0, 0);
  }
  }
#line 281
  return (tmp);
}
}
#line 287 "regexec.c"
int re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , int length1 ,
               char const   *string2 , int length2 , int start , struct re_registers *regs___0 ,
               int stop ) 
{ 
  int tmp ;

  {
  {
  {
#line 294
  tmp = re_search_2_stub(bufp, string1, length1, string2, length2, start, 0, regs___0,
                         stop, 1);
  }
  }
#line 294
  return (tmp);
}
}
#line 301 "regexec.c"
int re_search_2(struct re_pattern_buffer *bufp , char const   *string1 , int length1 ,
                char const   *string2 , int length2 , int start , int range , struct re_registers *regs___0 ,
                int stop ) 
{ 
  int tmp ;

  {
  {
  {
#line 308
  tmp = re_search_2_stub(bufp, string1, length1, string2, length2, start, range, regs___0,
                         stop, 0);
  }
  }
#line 308
  return (tmp);
}
}
#line 315 "regexec.c"
static int re_search_2_stub(struct re_pattern_buffer *bufp , char const   *string1 ,
                            int length1 , char const   *string2 , int length2 , int start ,
                            int range , struct re_registers *regs___0 , int stop ,
                            int ret_len ) 
{ 
  char const   *str ;
  int rval ;
  int len ;
  int free_str ;
  int tmp ;
  long tmp___0 ;
  char *s ;
  void *tmp___1 ;
  long tmp___2 ;

  {
#line 325
  len = length1 + length2;
#line 326
  free_str = 0;
#line 328
  if (length1 < 0) {
#line 328
    tmp = 1;
  } else
#line 328
  if (length2 < 0) {
#line 328
    tmp = 1;
  } else
#line 328
  if (stop < 0) {
#line 328
    tmp = 1;
  } else {
#line 328
    tmp = 0;
  }
  {
  {
#line 328
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
  }
#line 328
  if (tmp___0) {
#line 329
    return (-2);
  }
#line 332
  if (length2 > 0) {
#line 333
    if (length1 > 0) {
      {
      {
#line 335
      tmp___1 = malloc((size_t )((unsigned long )len * sizeof(char )));
      }
#line 335
      s = (char *)tmp___1;
      {
#line 337
      tmp___2 = __builtin_expect((long )((unsigned long )s == (unsigned long )((void *)0)),
                                 0L);
      }
      }
#line 337
      if (tmp___2) {
#line 338
        return (-2);
      }
      {
      {
#line 339
      memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)string1,
             (size_t )length1);
      }
      {
#line 340
      memcpy((void */* __restrict  */)(s + length1), (void const   */* __restrict  */)string2,
             (size_t )length2);
      }
#line 341
      str = (char const   *)s;
#line 342
      free_str = 1;
      }
    } else {
#line 345
      str = string2;
    }
  } else {
#line 347
    str = string1;
  }
  {
  {
#line 349
  rval = re_search_stub(bufp, str, len, start, range, stop, regs___0, ret_len);
  }
  }
#line 351
  if (free_str) {
    {
    {
#line 352
    free((void *)((char *)str));
    }
    }
  }
#line 353
  return (rval);
}
}
#line 361 "regexec.c"
static int re_search_stub(struct re_pattern_buffer *bufp , char const   *string ,
                          int length , int start , int range , int stop , struct re_registers *regs___0 ,
                          int ret_len ) 
{ 
  reg_errcode_t result ;
  regmatch_t *pmatch ;
  int nregs ;
  int rval ;
  int eflags ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  void *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 371
  eflags = 0;
#line 374
  if (start < 0) {
#line 374
    tmp = 1;
  } else
#line 374
  if (start > length) {
#line 374
    tmp = 1;
  } else {
#line 374
    tmp = 0;
  }
  {
  {
#line 374
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
  }
#line 374
  if (tmp___0) {
#line 375
    return (-1);
  }
  {
  {
#line 376
  tmp___2 = __builtin_expect((long )(start + range > length), 0L);
  }
  }
#line 376
  if (tmp___2) {
#line 377
    range = length - start;
  } else {
    {
    {
#line 378
    tmp___1 = __builtin_expect((long )(start + range < 0), 0L);
    }
    }
#line 378
    if (tmp___1) {
#line 379
      range = - start;
    }
  }
#line 381
  if (bufp->not_bol) {
#line 381
    tmp___3 = 1;
  } else {
#line 381
    tmp___3 = 0;
  }
#line 381
  eflags |= tmp___3;
#line 382
  if (bufp->not_eol) {
#line 382
    tmp___4 = 1 << 1;
  } else {
#line 382
    tmp___4 = 0;
  }
#line 382
  eflags |= tmp___4;
#line 385
  if (range > 0) {
#line 385
    if ((unsigned long )bufp->fastmap != (unsigned long )((void *)0)) {
#line 385
      if (! bufp->fastmap_accurate) {
        {
        {
#line 386
        re_compile_fastmap(bufp);
        }
        }
      }
    }
  }
  {
  {
#line 388
  tmp___5 = __builtin_expect((long )bufp->no_sub, 0L);
  }
  }
#line 388
  if (tmp___5) {
#line 389
    regs___0 = (struct re_registers *)((void *)0);
  }
#line 392
  if ((unsigned long )regs___0 == (unsigned long )((void *)0)) {
#line 393
    nregs = 1;
  } else {
#line 394
    if (bufp->regs_allocated == 2U) {
#line 394
      if (regs___0->num_regs < bufp->re_nsub + 1U) {
#line 394
        tmp___7 = 1;
      } else {
#line 394
        tmp___7 = 0;
      }
    } else {
#line 394
      tmp___7 = 0;
    }
    {
    {
#line 394
    tmp___8 = __builtin_expect((long )tmp___7, 0L);
    }
    }
#line 394
    if (tmp___8) {
      {
#line 397
      nregs = (int )regs___0->num_regs;
      {
#line 398
      tmp___6 = __builtin_expect((long )(nregs < 1), 0L);
      }
      }
#line 398
      if (tmp___6) {
#line 401
        regs___0 = (struct re_registers *)((void *)0);
#line 402
        nregs = 1;
      }
    } else {
#line 406
      nregs = (int )(bufp->re_nsub + 1U);
    }
  }
  {
  {
#line 407
  tmp___9 = malloc((size_t )((unsigned long )nregs * sizeof(regmatch_t )));
  }
#line 407
  pmatch = (regmatch_t *)tmp___9;
  {
#line 408
  tmp___10 = __builtin_expect((long )((unsigned long )pmatch == (unsigned long )((void *)0)),
                              0L);
  }
  }
#line 408
  if (tmp___10) {
#line 409
    return (-2);
  }
  {
  {
#line 411
  result = re_search_internal((regex_t const   *)bufp, string, length, start, range,
                              stop, (size_t )nregs, pmatch, eflags);
  }
#line 414
  rval = 0;
  }
#line 417
  if ((unsigned int )result != 0U) {
#line 418
    rval = -1;
  } else
#line 419
  if ((unsigned long )regs___0 != (unsigned long )((void *)0)) {
    {
    {
#line 422
    bufp->regs_allocated = re_copy_regs(regs___0, pmatch, nregs, (int )bufp->regs_allocated);
    }
    {
#line 424
    tmp___11 = __builtin_expect((long )(bufp->regs_allocated == 0U), 0L);
    }
    }
#line 424
    if (tmp___11) {
#line 425
      rval = -2;
    }
  }
  {
  {
#line 428
  tmp___13 = __builtin_expect((long )(rval == 0), 1L);
  }
  }
#line 428
  if (tmp___13) {
#line 430
    if (ret_len) {
      {
      {
#line 432
      tmp___12 = __builtin_expect((long )(! (! ((pmatch + 0)->rm_so == start))), 1L);
      }
      }
#line 432
      if (! tmp___12) {
        {
        {
#line 432
        __assert_fail("pmatch[0].rm_so == start", "regexec.c", 432U, "re_search_stub");
        }
        }
      }
#line 433
      rval = (pmatch + 0)->rm_eo - start;
    } else {
#line 436
      rval = (pmatch + 0)->rm_so;
    }
  }
  {
  {
#line 438
  free((void *)pmatch);
  }
  }
#line 439
  return (rval);
}
}
#line 442 "regexec.c"
static unsigned int re_copy_regs(struct re_registers *regs___0 , regmatch_t *pmatch ,
                                 int nregs , int regs_allocated ) 
{ 
  int rval ;
  int i ;
  int need_regs ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  regoff_t tmp___9 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 448
  rval = 1;
#line 450
  need_regs = nregs + 1;
#line 455
  if (regs_allocated == 0) {
    {
    {
#line 457
    tmp = malloc((size_t )((unsigned long )need_regs * sizeof(regoff_t )));
    }
#line 457
    regs___0->start = (regoff_t *)tmp;
    {
#line 458
    tmp___0 = __builtin_expect((long )((unsigned long )regs___0->start == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 458
    if (tmp___0) {
#line 459
      return (0U);
    }
    {
    {
#line 460
    tmp___1 = malloc((size_t )((unsigned long )need_regs * sizeof(regoff_t )));
    }
#line 460
    regs___0->end = (regoff_t *)tmp___1;
    {
#line 461
    tmp___2 = __builtin_expect((long )((unsigned long )regs___0->end == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 461
    if (tmp___2) {
      {
      {
#line 463
      free((void *)regs___0->start);
      }
      }
#line 464
      return (0U);
    }
#line 466
    regs___0->num_regs = (unsigned int )need_regs;
  } else
#line 468
  if (regs_allocated == 1) {
#line 472
    if ((unsigned int )need_regs > regs___0->num_regs) {
      {
      {
#line 474
      tmp___3 = realloc((void *)regs___0->start, (size_t )((unsigned long )need_regs * sizeof(regoff_t )));
      }
#line 474
      regs___0->start = (regoff_t *)tmp___3;
      {
#line 475
      tmp___4 = __builtin_expect((long )((unsigned long )regs___0->start == (unsigned long )((void *)0)),
                                 0L);
      }
      }
#line 475
      if (tmp___4) {
#line 477
        if ((unsigned long )regs___0->end != (unsigned long )((void *)0)) {
          {
          {
#line 478
          free((void *)regs___0->end);
          }
          }
        }
#line 479
        return (0U);
      }
      {
      {
#line 481
      tmp___5 = realloc((void *)regs___0->end, (size_t )((unsigned long )need_regs * sizeof(regoff_t )));
      }
#line 481
      regs___0->end = (regoff_t *)tmp___5;
      {
#line 482
      tmp___6 = __builtin_expect((long )((unsigned long )regs___0->end == (unsigned long )((void *)0)),
                                 0L);
      }
      }
#line 482
      if (tmp___6) {
        {
        {
#line 484
        free((void *)regs___0->start);
        }
        }
#line 485
        return (0U);
      }
#line 487
      regs___0->num_regs = (unsigned int )need_regs;
    }
  } else {
    {
    {
#line 492
    tmp___7 = __builtin_expect((long )(! (! (regs_allocated == 2))), 1L);
    }
    }
#line 492
    if (! tmp___7) {
      {
      {
#line 492
      __assert_fail("regs_allocated == 2", "regexec.c", 492U, "re_copy_regs");
      }
      }
    }
    {
    {
#line 494
    tmp___8 = __builtin_expect((long )(! (! (regs___0->num_regs >= (unsigned int )nregs))),
                               1L);
    }
    }
#line 494
    if (! tmp___8) {
      {
      {
#line 494
      __assert_fail("regs->num_regs >= nregs", "regexec.c", 494U, "re_copy_regs");
      }
      }
    }
#line 495
    rval = 2;
  }
#line 499
  i = 0;
  {
  {
#line 499
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 499
    if (! (i < nregs)) {
#line 499
      goto while_break;
    }
#line 501
    *(regs___0->start + i) = (pmatch + i)->rm_so;
#line 502
    *(regs___0->end + i) = (pmatch + i)->rm_eo;
#line 499
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 504
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 504
    if (! ((unsigned int )i < regs___0->num_regs)) {
#line 504
      goto while_break___0;
    }
#line 505
    tmp___9 = -1;
#line 505
    *(regs___0->end + i) = tmp___9;
#line 505
    *(regs___0->start + i) = tmp___9;
#line 504
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 507
  return ((unsigned int )rval);
}
}
#line 523 "regexec.c"
void re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs___0 ,
                      unsigned int num_regs , regoff_t *starts , regoff_t *ends ) 
{ 
  regoff_t *tmp ;

  {
#line 530
  if (num_regs) {
#line 532
    bufp->regs_allocated = 1U;
#line 533
    regs___0->num_regs = num_regs;
#line 534
    regs___0->start = starts;
#line 535
    regs___0->end = ends;
  } else {
#line 539
    bufp->regs_allocated = 0U;
#line 540
    regs___0->num_regs = 0U;
#line 541
    tmp = (regoff_t *)0;
#line 541
    regs___0->end = tmp;
#line 541
    regs___0->start = tmp;
  }
#line 543
  return;
}
}
#line 563 "regexec.c"
static re_node_set empty_set  ;
#line 576 "regexec.c"
static reg_errcode_t re_search_internal(regex_t const   *preg , char const   *string ,
                                        int length , int start , int range , int stop ,
                                        size_t nmatch , regmatch_t *pmatch , int eflags ) 
{ 
  reg_errcode_t err ;
  re_dfa_t *dfa ;
  re_string_t input ;
  int left_lim ;
  int right_lim ;
  int incr ;
  int fl_longest_match ;
  int match_first ;
  int match_last ;
  int fast_translate ;
  int sb ;
  re_match_context_t mctx ;
  char *fastmap ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_54 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  void *__s___2 ;
  void *__s___3 ;
  union __anonunion___u_55 *__u___0 ;
  __uint8_t __c___0 ;
  void *__s___4 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  unsigned char *t ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  int ch ;
  int tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  int ch___0 ;
  int tmp___15 ;
  int tmp___16 ;
  long tmp___17 ;
  int ch___1 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  re_dfastate_t *pstate ;
  long tmp___21 ;
  long tmp___22 ;
  int reg_idx ;
  regoff_t tmp___23 ;
  int tmp___24 ;
  long tmp___25 ;

  {
#line 586
  dfa = (re_dfa_t *)preg->buffer;
#line 589
  match_last = -1;
#line 592
  if ((unsigned long )preg->fastmap != (unsigned long )((void *)0)) {
#line 592
    if (preg->fastmap_accurate) {
#line 592
      if (range) {
#line 592
        if (! preg->can_be_null) {
#line 592
          tmp = preg->fastmap;
        } else {
#line 592
          tmp = (char */* const  */)((void *)0);
        }
      } else {
#line 592
        tmp = (char */* const  */)((void *)0);
      }
    } else {
#line 592
      tmp = (char */* const  */)((void *)0);
    }
  } else {
#line 592
    tmp = (char */* const  */)((void *)0);
  }
#line 592
  fastmap = (char *)tmp;
#line 596
  if (preg->used == 0UL) {
#line 596
    tmp___0 = 1;
  } else
#line 596
  if ((unsigned long )dfa->init_state == (unsigned long )((void *)0)) {
#line 596
    tmp___0 = 1;
  } else
#line 596
  if ((unsigned long )dfa->init_state_word == (unsigned long )((void *)0)) {
#line 596
    tmp___0 = 1;
  } else
#line 596
  if ((unsigned long )dfa->init_state_nl == (unsigned long )((void *)0)) {
#line 596
    tmp___0 = 1;
  } else
#line 596
  if ((unsigned long )dfa->init_state_begbuf == (unsigned long )((void *)0)) {
#line 596
    tmp___0 = 1;
  } else {
#line 596
    tmp___0 = 0;
  }
  {
  {
#line 596
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  }
#line 596
  if (tmp___1) {
#line 599
    return ((reg_errcode_t )1);
  }
#line 601
  if (sizeof(re_node_set ) <= 16UL) {
#line 601
    if (sizeof(re_node_set ) == 1UL) {
#line 601
      __s___1 = (void *)(& empty_set);
#line 601
      *((__uint8_t *)__s___1) = (__uint8_t )'\000';
    } else {
#line 601
      __s___0 = (void *)(& empty_set);
#line 601
      __u = (union __anonunion___u_54 *)__s___0;
#line 601
      __c = (__uint8_t )'\000';
      {
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 15U) {
#line 601
        goto case_15;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 11U) {
#line 601
        goto case_11;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 7U) {
#line 601
        goto case_7;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 3U) {
#line 601
        goto case_3;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 14U) {
#line 601
        goto case_14;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 10U) {
#line 601
        goto case_10;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 6U) {
#line 601
        goto case_6;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 2U) {
#line 601
        goto case_2;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 13U) {
#line 601
        goto case_13;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 9U) {
#line 601
        goto case_9;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 5U) {
#line 601
        goto case_5;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 1U) {
#line 601
        goto case_1;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 16U) {
#line 601
        goto case_16;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 12U) {
#line 601
        goto case_12;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 8U) {
#line 601
        goto case_8;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 4U) {
#line 601
        goto case_4;
      }
#line 601
      if ((unsigned int )sizeof(re_node_set ) == 0U) {
#line 601
        goto case_0;
      }
#line 601
      goto switch_break;
      case_15: /* CIL Label */ 
#line 601
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 601
      __u = (union __anonunion___u_54 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 601
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 601
      __u = (union __anonunion___u_54 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 601
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 601
      __u = (union __anonunion___u_54 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 601
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 601
      __u = (union __anonunion___u_54 *)((void *)__u + 2);
#line 601
      __u->__uc = __c;
#line 601
      goto switch_break;
      case_14: /* CIL Label */ 
#line 601
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 601
      __u = (union __anonunion___u_54 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 601
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 601
      __u = (union __anonunion___u_54 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 601
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 601
      __u = (union __anonunion___u_54 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 601
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 601
      goto switch_break;
      case_13: /* CIL Label */ 
#line 601
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 601
      __u = (union __anonunion___u_54 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 601
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 601
      __u = (union __anonunion___u_54 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 601
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 601
      __u = (union __anonunion___u_54 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 601
      __u->__uc = __c;
#line 601
      goto switch_break;
      case_16: /* CIL Label */ 
#line 601
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 601
      __u = (union __anonunion___u_54 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 601
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 601
      __u = (union __anonunion___u_54 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 601
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 601
      __u = (union __anonunion___u_54 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 601
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 601
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 601
    __s = (void *)(& empty_set);
    {
#line 601
    __builtin_memset(__s, '\000', (int )sizeof(re_node_set ));
    }
    }
  }
#line 602
  if (sizeof(re_match_context_t ) <= 16UL) {
#line 602
    if (sizeof(re_match_context_t ) == 1UL) {
#line 602
      __s___4 = (void *)(& mctx);
#line 602
      *((__uint8_t *)__s___4) = (__uint8_t )'\000';
    } else {
#line 602
      __s___3 = (void *)(& mctx);
#line 602
      __u___0 = (union __anonunion___u_55 *)__s___3;
#line 602
      __c___0 = (__uint8_t )'\000';
      {
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 15U) {
#line 602
        goto case_15___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 11U) {
#line 602
        goto case_11___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 7U) {
#line 602
        goto case_7___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 3U) {
#line 602
        goto case_3___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 14U) {
#line 602
        goto case_14___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 10U) {
#line 602
        goto case_10___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 6U) {
#line 602
        goto case_6___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 2U) {
#line 602
        goto case_2___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 13U) {
#line 602
        goto case_13___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 9U) {
#line 602
        goto case_9___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 5U) {
#line 602
        goto case_5___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 1U) {
#line 602
        goto case_1___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 16U) {
#line 602
        goto case_16___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 12U) {
#line 602
        goto case_12___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 8U) {
#line 602
        goto case_8___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 4U) {
#line 602
        goto case_4___0;
      }
#line 602
      if ((unsigned int )sizeof(re_match_context_t ) == 0U) {
#line 602
        goto case_0___0;
      }
#line 602
      goto switch_break___0;
      case_15___0: /* CIL Label */ 
#line 602
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 602
      __u___0 = (union __anonunion___u_55 *)((void *)__u___0 + 4);
      case_11___0: /* CIL Label */ 
#line 602
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 602
      __u___0 = (union __anonunion___u_55 *)((void *)__u___0 + 4);
      case_7___0: /* CIL Label */ 
#line 602
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 602
      __u___0 = (union __anonunion___u_55 *)((void *)__u___0 + 4);
      case_3___0: /* CIL Label */ 
#line 602
      __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 602
      __u___0 = (union __anonunion___u_55 *)((void *)__u___0 + 2);
#line 602
      __u___0->__uc = __c___0;
#line 602
      goto switch_break___0;
      case_14___0: /* CIL Label */ 
#line 602
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 602
      __u___0 = (union __anonunion___u_55 *)((void *)__u___0 + 4);
      case_10___0: /* CIL Label */ 
#line 602
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 602
      __u___0 = (union __anonunion___u_55 *)((void *)__u___0 + 4);
      case_6___0: /* CIL Label */ 
#line 602
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 602
      __u___0 = (union __anonunion___u_55 *)((void *)__u___0 + 4);
      case_2___0: /* CIL Label */ 
#line 602
      __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 602
      goto switch_break___0;
      case_13___0: /* CIL Label */ 
#line 602
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 602
      __u___0 = (union __anonunion___u_55 *)((void *)__u___0 + 4);
      case_9___0: /* CIL Label */ 
#line 602
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 602
      __u___0 = (union __anonunion___u_55 *)((void *)__u___0 + 4);
      case_5___0: /* CIL Label */ 
#line 602
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 602
      __u___0 = (union __anonunion___u_55 *)((void *)__u___0 + 4);
      case_1___0: /* CIL Label */ 
#line 602
      __u___0->__uc = __c___0;
#line 602
      goto switch_break___0;
      case_16___0: /* CIL Label */ 
#line 602
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 602
      __u___0 = (union __anonunion___u_55 *)((void *)__u___0 + 4);
      case_12___0: /* CIL Label */ 
#line 602
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 602
      __u___0 = (union __anonunion___u_55 *)((void *)__u___0 + 4);
      case_8___0: /* CIL Label */ 
#line 602
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 602
      __u___0 = (union __anonunion___u_55 *)((void *)__u___0 + 4);
      case_4___0: /* CIL Label */ 
#line 602
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
      case_0___0: /* CIL Label */ 
#line 602
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 602
    __s___2 = (void *)(& mctx);
    {
#line 602
    __builtin_memset(__s___2, '\000', (int )sizeof(re_match_context_t ));
    }
    }
  }
#line 605
  if (nmatch != 0U) {
#line 605
    tmp___2 = 1;
  } else
#line 605
  if (dfa->nbackref) {
#line 605
    tmp___2 = 1;
  } else {
#line 605
    tmp___2 = 0;
  }
  {
#line 605
  fl_longest_match = tmp___2;
  {
#line 607
  err = re_string_allocate(& input, string, length, dfa->nodes_len + 1, (char *)preg->translate,
                           (int )(preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
  }
  {
#line 609
  tmp___3 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 609
  if (tmp___3) {
#line 610
    goto free_return;
  }
  {
#line 611
  input.stop = stop;
  {
#line 613
  err = match_ctx_init(& mctx, eflags, & input, dfa->nbackref * 2);
  }
  {
#line 614
  tmp___4 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 614
  if (tmp___4) {
#line 615
    goto free_return;
  }
#line 621
  if (nmatch > 1U) {
#line 621
    goto _L;
  } else
#line 621
  if (dfa->has_mb_node) {
    _L: /* CIL Label */ 
    {
    {
#line 623
    tmp___5 = malloc((size_t )((unsigned long )(dfa->nodes_len + 1) * sizeof(re_dfastate_t *)));
    }
#line 623
    mctx.state_log = (re_dfastate_t **)tmp___5;
    {
#line 624
    tmp___6 = __builtin_expect((long )((unsigned long )mctx.state_log == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 624
    if (tmp___6) {
#line 626
      err = (reg_errcode_t )12;
#line 627
      goto free_return;
    }
  } else {
#line 631
    mctx.state_log = (re_dfastate_t **)((void *)0);
  }
#line 638
  match_first = start;
#line 639
  if (eflags & 1) {
#line 639
    input.tip_context = (unsigned int )((1 << 1) << 1);
  } else {
#line 639
    input.tip_context = (unsigned int )((1 << 1) | ((1 << 1) << 1));
  }
#line 643
  if (range < 0) {
#line 643
    incr = -1;
  } else {
#line 643
    incr = 1;
  }
#line 644
  if (range < 0) {
#line 644
    left_lim = start + range;
  } else {
#line 644
    left_lim = start;
  }
#line 645
  if (range < 0) {
#line 645
    right_lim = start;
  } else {
#line 645
    right_lim = start + range;
  }
  {
  {
#line 646
  tmp___7 = __ctype_get_mb_cur_max();
  }
#line 646
  sb = tmp___7 == 1U;
  }
#line 647
  if (sb) {
#line 647
    tmp___8 = 1;
  } else
#line 647
  if (preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 647
    tmp___8 = 0;
  } else
#line 647
  if (preg->translate) {
#line 647
    tmp___8 = 0;
  } else {
#line 647
    tmp___8 = 1;
  }
#line 647
  fast_translate = tmp___8;
  {
  {
#line 649
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 652
    if (fastmap) {
      {
      {
#line 654
      tmp___19 = __builtin_expect((long )fast_translate, 1L);
      }
      }
#line 654
      if (tmp___19) {
        {
#line 656
        t = (unsigned char *)preg->translate;
        {
#line 658
        tmp___17 = __builtin_expect((long )(range >= 0), 1L);
        }
        }
#line 658
        if (tmp___17) {
          {
          {
#line 660
          tmp___11 = __builtin_expect((long )((unsigned long )t != (unsigned long )((void *)0)),
                                      0L);
          }
          }
#line 660
          if (tmp___11) {
            {
            {
#line 662
            while (1) {
              while_continue___7: /* CIL Label */ ;
              while_continue___0: /* CIL Label */ ;
              {
              {
#line 662
              tmp___9 = __builtin_expect((long )(match_first < right_lim), 1L);
              }
              }
#line 662
              if (tmp___9) {
#line 662
                if (! (! *(fastmap + *(t + (unsigned char )*(string + match_first))))) {
#line 662
                  goto while_break___0;
                }
              } else {
#line 662
                goto while_break___0;
              }
#line 664
              match_first ++;
            }
            while_break___7: /* CIL Label */ ;
            }
            while_break___0: /* CIL Label */ ;
            }
          } else {
            {
            {
#line 668
            while (1) {
              while_continue___8: /* CIL Label */ ;
              while_continue___1: /* CIL Label */ ;
              {
              {
#line 668
              tmp___10 = __builtin_expect((long )(match_first < right_lim), 1L);
              }
              }
#line 668
              if (tmp___10) {
#line 668
                if (! (! *(fastmap + (unsigned char )*(string + match_first)))) {
#line 668
                  goto while_break___1;
                }
              } else {
#line 668
                goto while_break___1;
              }
#line 670
              match_first ++;
            }
            while_break___8: /* CIL Label */ ;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
          {
          {
#line 672
          tmp___14 = __builtin_expect((long )(match_first == right_lim), 0L);
          }
          }
#line 672
          if (tmp___14) {
#line 674
            if (match_first >= length) {
#line 674
              tmp___12 = 0;
            } else {
#line 674
              tmp___12 = (int )((unsigned char )*(string + match_first));
            }
#line 674
            ch = tmp___12;
#line 676
            if (t) {
#line 676
              tmp___13 = (int )*(t + ch);
            } else {
#line 676
              tmp___13 = ch;
            }
#line 676
            if (! *(fastmap + tmp___13)) {
#line 677
              goto while_break;
            }
          }
        } else {
          {
          {
#line 682
          while (1) {
            while_continue___9: /* CIL Label */ ;
            while_continue___2: /* CIL Label */ ;
#line 682
            if (! (match_first >= left_lim)) {
#line 682
              goto while_break___2;
            }
#line 684
            if (match_first >= length) {
#line 684
              tmp___15 = 0;
            } else {
#line 684
              tmp___15 = (int )((unsigned char )*(string + match_first));
            }
#line 684
            ch___0 = tmp___15;
#line 686
            if (t) {
#line 686
              tmp___16 = (int )*(t + ch___0);
            } else {
#line 686
              tmp___16 = ch___0;
            }
#line 686
            if (*(fastmap + tmp___16)) {
#line 687
              goto while_break___2;
            }
#line 688
            match_first --;
          }
          while_break___9: /* CIL Label */ ;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 690
          if (match_first < left_lim) {
#line 691
            goto while_break;
          }
        }
      } else {
        {
        {
#line 698
        while (1) {
          while_continue___10: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 706
          if (input.raw_mbs_idx + input.valid_len <= match_first) {
#line 706
            goto _L___0;
          } else
#line 706
          if (match_first < input.raw_mbs_idx) {
            _L___0: /* CIL Label */ 
            {
            {
#line 709
            err = re_string_reconstruct(& input, match_first, eflags, (int )preg->newline_anchor);
            }
            {
#line 711
            tmp___18 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
            }
            }
#line 711
            if (tmp___18) {
#line 712
              goto free_return;
            }
          }
#line 716
          if (match_first >= length) {
#line 716
            ch___1 = 0;
          } else {
#line 716
            ch___1 = (int )*(input.mbs + (match_first - input.raw_mbs_idx));
          }
#line 719
          if (*(fastmap + ch___1)) {
#line 720
            goto while_break___3;
          }
#line 721
          match_first += incr;
#line 698
          if (match_first >= left_lim) {
#line 698
            if (! (match_first <= right_lim)) {
#line 698
              goto while_break___3;
            }
          } else {
#line 698
            goto while_break___3;
          }
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 724
        if (! *(fastmap + ch___1)) {
#line 725
          goto while_break;
        }
      }
    }
    {
    {
#line 731
    err = re_string_reconstruct(& input, match_first, eflags, (int )preg->newline_anchor);
    }
    {
#line 733
    tmp___20 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    }
#line 733
    if (tmp___20) {
#line 734
      goto free_return;
    }
#line 738
    if (sb) {
#line 738
      goto _L___6;
    } else
#line 738
    if (0 == input.len) {
#line 738
      goto _L___6;
    } else
#line 738
    if (*(input.wcs + 0) != 4294967295U) {
      _L___6: /* CIL Label */ 
      {
#line 743
      mctx.max_mb_elem_len = 0;
#line 743
      mctx.nbkref_ents = mctx.max_mb_elem_len;
#line 743
      mctx.state_log_top = mctx.nbkref_ents;
      {
#line 744
      match_last = check_matching(preg, & mctx, 0, fl_longest_match);
      }
      }
#line 745
      if (match_last != -1) {
        {
        {
#line 747
        tmp___22 = __builtin_expect((long )(match_last == -2), 0L);
        }
        }
#line 747
        if (tmp___22) {
#line 749
          err = (reg_errcode_t )12;
#line 750
          goto free_return;
        } else {
#line 754
          mctx.match_last = match_last;
#line 755
          if (! preg->no_sub) {
#line 755
            if (nmatch > 1U) {
              {
#line 757
              pstate = *(mctx.state_log + match_last);
              {
#line 758
              mctx.last_node = check_halt_state_context(preg, (re_dfastate_t const   *)pstate,
                                                        (re_match_context_t const   *)(& mctx),
                                                        match_last);
              }
              }
            } else {
#line 755
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 755
          if (dfa->nbackref) {
            {
#line 757
            pstate = *(mctx.state_log + match_last);
            {
#line 758
            mctx.last_node = check_halt_state_context(preg, (re_dfastate_t const   *)pstate,
                                                      (re_match_context_t const   *)(& mctx),
                                                      match_last);
            }
            }
          }
#line 761
          if (! preg->no_sub) {
#line 761
            if (nmatch > 1U) {
#line 761
              if (dfa->has_plural_match) {
#line 761
                goto _L___2;
              } else {
#line 761
                goto _L___4;
              }
            } else {
#line 761
              goto _L___4;
            }
          } else
          _L___4: /* CIL Label */ 
#line 761
          if (dfa->nbackref) {
            _L___2: /* CIL Label */ 
            {
            {
#line 764
            err = prune_impossible_nodes(preg, & mctx);
            }
            }
#line 765
            if ((unsigned int )err == 0U) {
#line 766
              goto while_break;
            }
            {
            {
#line 767
            tmp___21 = __builtin_expect((long )((unsigned int )err != 1U), 0L);
            }
            }
#line 767
            if (tmp___21) {
#line 768
              goto free_return;
            }
          } else {
#line 771
            goto while_break;
          }
        }
      }
      {
      {
#line 774
      match_ctx_clean(& mctx);
      }
      }
    }
#line 777
    match_first += incr;
#line 778
    if (match_first < left_lim) {
#line 779
      goto while_break;
    } else
#line 778
    if (right_lim < match_first) {
#line 779
      goto while_break;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 783
  if (match_last != -1) {
#line 783
    if (nmatch > 0U) {
#line 788
      reg_idx = 0;
      {
      {
#line 788
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 788
        if (! ((size_t )reg_idx < nmatch)) {
#line 788
          goto while_break___4;
        }
#line 789
        tmp___23 = -1;
#line 789
        (pmatch + reg_idx)->rm_eo = tmp___23;
#line 789
        (pmatch + reg_idx)->rm_so = tmp___23;
#line 788
        reg_idx ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 792
      (pmatch + 0)->rm_so = 0;
#line 793
      (pmatch + 0)->rm_eo = mctx.match_last;
#line 795
      if (! preg->no_sub) {
#line 795
        if (nmatch > 1U) {
#line 797
          if (dfa->has_plural_match) {
#line 797
            if (dfa->nbackref > 0) {
#line 797
              tmp___24 = 1;
            } else {
#line 797
              tmp___24 = 0;
            }
          } else {
#line 797
            tmp___24 = 0;
          }
          {
          {
#line 797
          err = set_regs(preg, (re_match_context_t const   *)(& mctx), nmatch, pmatch,
                         tmp___24);
          }
          {
#line 799
          tmp___25 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
          }
          }
#line 799
          if (tmp___25) {
#line 800
            goto free_return;
          }
        }
      }
#line 805
      reg_idx = 0;
      {
      {
#line 805
      while (1) {
        while_continue___12: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
#line 805
        if (! ((size_t )reg_idx < nmatch)) {
#line 805
          goto while_break___5;
        }
#line 806
        if ((pmatch + reg_idx)->rm_so != -1) {
#line 808
          (pmatch + reg_idx)->rm_so += match_first;
#line 809
          (pmatch + reg_idx)->rm_eo += match_first;
        }
#line 805
        reg_idx ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
#line 812
  if (match_last == -1) {
#line 812
    err = (reg_errcode_t )1;
  } else {
#line 812
    err = (reg_errcode_t )0;
  }
  free_return: 
  {
  {
#line 814
  free((void *)mctx.state_log);
  }
  }
#line 815
  if (dfa->nbackref) {
    {
    {
#line 816
    match_ctx_free(& mctx);
    }
    }
  }
  {
  {
#line 817
  re_string_destruct(& input);
  }
  }
#line 818
  return (err);
}
}
#line 821 "regexec.c"
static reg_errcode_t prune_impossible_nodes(regex_t const   *preg , re_match_context_t *mctx ) 
{ 
  int halt_node ;
  int match_last ;
  reg_errcode_t ret ;
  re_dfa_t *dfa ;
  re_dfastate_t **sifted_states ;
  re_dfastate_t **lim_states ;
  re_sift_context_t sctx ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_56 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
  {
#line 828
  dfa = (re_dfa_t *)preg->buffer;
#line 830
  lim_states = (re_dfastate_t **)((void *)0);
#line 835
  match_last = mctx->match_last;
#line 836
  halt_node = mctx->last_node;
  {
#line 837
  tmp = malloc((size_t )((unsigned long )(match_last + 1) * sizeof(re_dfastate_t *)));
  }
#line 837
  sifted_states = (re_dfastate_t **)tmp;
  {
#line 838
  tmp___0 = __builtin_expect((long )((unsigned long )sifted_states == (unsigned long )((void *)0)),
                             0L);
  }
  }
#line 838
  if (tmp___0) {
#line 840
    ret = (reg_errcode_t )12;
#line 841
    goto free_return;
  }
#line 843
  if (dfa->nbackref) {
    {
    {
#line 845
    tmp___1 = malloc((size_t )((unsigned long )(match_last + 1) * sizeof(re_dfastate_t *)));
    }
#line 845
    lim_states = (re_dfastate_t **)tmp___1;
    {
#line 846
    tmp___2 = __builtin_expect((long )((unsigned long )lim_states == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 846
    if (tmp___2) {
#line 848
      ret = (reg_errcode_t )12;
#line 849
      goto free_return;
    }
    {
    {
#line 851
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 853
      if (0) {
#line 853
        if (sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1) == 1UL) {
#line 853
          __s___1 = (void *)lim_states;
#line 853
          *((__uint8_t *)__s___1) = (__uint8_t )'\000';
        } else {
#line 853
          __s___0 = (void *)lim_states;
#line 853
          __u = (union __anonunion___u_56 *)__s___0;
#line 853
          __c = (__uint8_t )'\000';
          {
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 15U) {
#line 853
            goto case_15;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 11U) {
#line 853
            goto case_11;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 7U) {
#line 853
            goto case_7;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 3U) {
#line 853
            goto case_3;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 14U) {
#line 853
            goto case_14;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 10U) {
#line 853
            goto case_10;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 6U) {
#line 853
            goto case_6;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 2U) {
#line 853
            goto case_2;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 13U) {
#line 853
            goto case_13;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 9U) {
#line 853
            goto case_9;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 5U) {
#line 853
            goto case_5;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 1U) {
#line 853
            goto case_1;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 16U) {
#line 853
            goto case_16;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 12U) {
#line 853
            goto case_12;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 8U) {
#line 853
            goto case_8;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 4U) {
#line 853
            goto case_4;
          }
#line 853
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)) == 0U) {
#line 853
            goto case_0;
          }
#line 853
          goto switch_break;
          case_15: /* CIL Label */ 
#line 853
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 853
          __u = (union __anonunion___u_56 *)((void *)__u + 4);
          case_11: /* CIL Label */ 
#line 853
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 853
          __u = (union __anonunion___u_56 *)((void *)__u + 4);
          case_7: /* CIL Label */ 
#line 853
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 853
          __u = (union __anonunion___u_56 *)((void *)__u + 4);
          case_3: /* CIL Label */ 
#line 853
          __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 853
          __u = (union __anonunion___u_56 *)((void *)__u + 2);
#line 853
          __u->__uc = __c;
#line 853
          goto switch_break;
          case_14: /* CIL Label */ 
#line 853
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 853
          __u = (union __anonunion___u_56 *)((void *)__u + 4);
          case_10: /* CIL Label */ 
#line 853
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 853
          __u = (union __anonunion___u_56 *)((void *)__u + 4);
          case_6: /* CIL Label */ 
#line 853
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 853
          __u = (union __anonunion___u_56 *)((void *)__u + 4);
          case_2: /* CIL Label */ 
#line 853
          __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 853
          goto switch_break;
          case_13: /* CIL Label */ 
#line 853
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 853
          __u = (union __anonunion___u_56 *)((void *)__u + 4);
          case_9: /* CIL Label */ 
#line 853
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 853
          __u = (union __anonunion___u_56 *)((void *)__u + 4);
          case_5: /* CIL Label */ 
#line 853
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 853
          __u = (union __anonunion___u_56 *)((void *)__u + 4);
          case_1: /* CIL Label */ 
#line 853
          __u->__uc = __c;
#line 853
          goto switch_break;
          case_16: /* CIL Label */ 
#line 853
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 853
          __u = (union __anonunion___u_56 *)((void *)__u + 4);
          case_12: /* CIL Label */ 
#line 853
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 853
          __u = (union __anonunion___u_56 *)((void *)__u + 4);
          case_8: /* CIL Label */ 
#line 853
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 853
          __u = (union __anonunion___u_56 *)((void *)__u + 4);
          case_4: /* CIL Label */ 
#line 853
          __u->__ui = (unsigned int )((int )__c * 16843009);
          case_0: /* CIL Label */ 
#line 853
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 853
        __s = (void *)lim_states;
        {
#line 853
        __builtin_memset(__s, '\000', (int )(sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1)));
        }
        }
      }
      {
      {
#line 855
      match_ctx_clear_flag(mctx);
      }
      {
#line 856
      sift_ctx_init(& sctx, sifted_states, lim_states, halt_node, match_last, 0);
      }
      {
#line 858
      ret = sift_states_backward(preg, mctx, & sctx);
      }
      {
#line 859
      free((void *)sctx.limits.elems);
      }
      {
#line 860
      tmp___3 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
      }
      }
#line 860
      if (tmp___3) {
#line 861
        goto free_return;
      }
#line 862
      if ((unsigned long )*(sifted_states + 0) != (unsigned long )((void *)0)) {
#line 863
        goto while_break;
      } else
#line 862
      if ((unsigned long )*(lim_states + 0) != (unsigned long )((void *)0)) {
#line 863
        goto while_break;
      }
      {
      {
#line 864
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 866
        match_last --;
#line 867
        if (match_last < 0) {
#line 869
          ret = (reg_errcode_t )1;
#line 870
          goto free_return;
        }
#line 864
        if (! (! (*(mctx->state_log + match_last))->halt)) {
#line 864
          goto while_break___0;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      {
#line 873
      halt_node = check_halt_state_context(preg, (re_dfastate_t const   *)*(mctx->state_log + match_last),
                                           (re_match_context_t const   *)mctx, match_last);
      }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 877
    ret = merge_state_array(dfa, sifted_states, lim_states, match_last + 1);
    }
    {
#line 879
    free((void *)lim_states);
    }
#line 880
    lim_states = (re_dfastate_t **)((void *)0);
    {
#line 881
    tmp___4 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
    }
    }
#line 881
    if (tmp___4) {
#line 882
      goto free_return;
    }
  } else {
    {
    {
#line 886
    sift_ctx_init(& sctx, sifted_states, lim_states, halt_node, match_last, 0);
    }
    {
#line 888
    ret = sift_states_backward(preg, mctx, & sctx);
    }
    {
#line 889
    free((void *)sctx.limits.elems);
    }
    {
#line 890
    tmp___5 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
    }
    }
#line 890
    if (tmp___5) {
#line 891
      goto free_return;
    }
  }
  {
  {
#line 893
  free((void *)mctx->state_log);
  }
#line 894
  mctx->state_log = sifted_states;
#line 895
  sifted_states = (re_dfastate_t **)((void *)0);
#line 896
  mctx->last_node = halt_node;
#line 897
  mctx->match_last = match_last;
#line 898
  ret = (reg_errcode_t )0;
  }
  free_return: 
  {
  {
#line 900
  free((void *)sifted_states);
  }
  {
#line 901
  free((void *)lim_states);
  }
  }
#line 902
  return (ret);
}
}
#line 909 "regexec.c"
static re_dfastate_t *acquire_init_state_context(reg_errcode_t *err , regex_t const   *preg ,
                                                 re_match_context_t const   *mctx ,
                                                 int idx ) 
{ 
  re_dfa_t *dfa ;
  unsigned int context ;
  re_dfastate_t *tmp ;

  {
#line 916
  dfa = (re_dfa_t *)preg->buffer;
#line 918
  *err = (reg_errcode_t )0;
#line 919
  if ((dfa->init_state)->has_constraint) {
    {
    {
#line 922
    context = re_string_context_at((re_string_t const   *)mctx->input, idx - 1, (int )mctx->eflags,
                                   (int )preg->newline_anchor);
    }
    }
#line 924
    if (context & 1U) {
#line 925
      return (dfa->init_state_word);
    } else
#line 926
    if (context == 0U) {
#line 927
      return (dfa->init_state);
    } else
#line 928
    if (context & (unsigned int )((1 << 1) << 1)) {
#line 928
      if (context & (unsigned int )(1 << 1)) {
#line 929
        return (dfa->init_state_begbuf);
      } else {
#line 928
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 930
    if (context & (unsigned int )(1 << 1)) {
#line 931
      return (dfa->init_state_nl);
    } else
#line 932
    if (context & (unsigned int )((1 << 1) << 1)) {
      {
      {
#line 935
      tmp = re_acquire_state_context(err, dfa, (re_node_set const   *)(dfa->init_state)->entrance_nodes,
                                     context);
      }
      }
#line 935
      return (tmp);
    } else {
#line 941
      return (dfa->init_state);
    }
  } else {
#line 944
    return (dfa->init_state);
  }
}
}
#line 955 "regexec.c"
static int check_matching(regex_t const   *preg , re_match_context_t *mctx , int fl_search ,
                          int fl_longest_match ) 
{ 
  re_dfa_t *dfa ;
  reg_errcode_t err ;
  int match ;
  int match_last ;
  int cur_str_idx ;
  re_dfastate_t *cur_state ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int max ;
  int tmp___8 ;

  {
  {
#line 961
  dfa = (re_dfa_t *)preg->buffer;
#line 963
  match = 0;
#line 964
  match_last = -1;
#line 965
  cur_str_idx = (mctx->input)->cur_idx;
  {
#line 968
  cur_state = acquire_init_state_context(& err, preg, (re_match_context_t const   *)mctx,
                                         cur_str_idx);
  }
  {
#line 970
  tmp = __builtin_expect((long )((unsigned long )cur_state == (unsigned long )((void *)0)),
                         0L);
  }
  }
#line 970
  if (tmp) {
#line 971
    return (-2);
  }
#line 972
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
#line 973
    *(mctx->state_log + cur_str_idx) = cur_state;
  }
#line 977
  if (dfa->nbackref) {
    {
    {
#line 979
    err = check_subexp_matching_top(dfa, mctx, & cur_state->nodes, 0);
    }
    {
#line 980
    tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    }
#line 980
    if (tmp___0) {
#line 981
      return ((int )err);
    }
  }
#line 984
  if (cur_state->has_backref) {
    {
    {
#line 986
    err = transit_state_bkref(preg, & cur_state->nodes, mctx);
    }
    {
#line 987
    tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    }
#line 987
    if (tmp___1) {
#line 988
      return ((int )err);
    }
  }
#line 992
  if (cur_state->halt) {
#line 994
    if (! cur_state->has_constraint) {
#line 994
      goto _L;
    } else {
      {
      {
#line 994
      tmp___2 = check_halt_state_context(preg, (re_dfastate_t const   *)cur_state,
                                         (re_match_context_t const   *)mctx, cur_str_idx);
      }
      }
#line 994
      if (tmp___2) {
        _L: /* CIL Label */ 
#line 997
        if (! fl_longest_match) {
#line 998
          return (cur_str_idx);
        } else {
#line 1001
          match_last = cur_str_idx;
#line 1002
          match = 1;
        }
      }
    }
  }
  {
  {
#line 1007
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1007
    if (! (! ((mctx->input)->stop <= (mctx->input)->cur_idx))) {
#line 1007
      goto while_break;
    }
#line 1009
    if (fl_search) {
#line 1009
      if (! match) {
#line 1009
        tmp___3 = 1;
      } else {
#line 1009
        tmp___3 = 0;
      }
    } else {
#line 1009
      tmp___3 = 0;
    }
    {
    {
#line 1009
    cur_state = transit_state(& err, preg, mctx, cur_state, tmp___3);
    }
    }
#line 1011
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
      {
#line 1013
      cur_str_idx = (mctx->input)->cur_idx;
      {
#line 1014
      tmp___4 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 1014
      if (tmp___4) {
#line 1015
        return (-2);
      }
#line 1016
      if (fl_search) {
#line 1016
        if (! match) {
          {
          {
#line 1021
          tmp___5 = __ctype_get_mb_cur_max();
          }
          }
#line 1021
          if (tmp___5 == 1U) {
            {
            {
#line 1024
            cur_state = acquire_init_state_context(& err, preg, (re_match_context_t const   *)mctx,
                                                   cur_str_idx);
            }
            }
          } else
#line 1021
          if (cur_str_idx == (mctx->input)->len) {
            {
            {
#line 1024
            cur_state = acquire_init_state_context(& err, preg, (re_match_context_t const   *)mctx,
                                                   cur_str_idx);
            }
            }
          } else
#line 1021
          if (*((mctx->input)->wcs + cur_str_idx) != 4294967295U) {
            {
            {
#line 1024
            cur_state = acquire_init_state_context(& err, preg, (re_match_context_t const   *)mctx,
                                                   cur_str_idx);
            }
            }
          }
#line 1026
          if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 1026
            if ((unsigned int )err != 0U) {
#line 1026
              tmp___6 = 1;
            } else {
#line 1026
              tmp___6 = 0;
            }
          } else {
#line 1026
            tmp___6 = 0;
          }
          {
          {
#line 1026
          tmp___7 = __builtin_expect((long )tmp___6, 0L);
          }
          }
#line 1026
          if (tmp___7) {
#line 1027
            return (-2);
          }
#line 1028
          if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
#line 1029
            *(mctx->state_log + cur_str_idx) = cur_state;
          }
        } else {
#line 1016
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1031
      if (! fl_longest_match) {
#line 1031
        if (match) {
#line 1032
          goto while_break;
        } else {
#line 1031
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1035
      if ((unsigned long )mctx->state_log == (unsigned long )((void *)0)) {
#line 1036
        goto while_break;
      } else {
#line 1039
        max = mctx->state_log_top;
        {
        {
#line 1040
        while (1) {
          while_continue___2: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 1040
          if (! (cur_str_idx <= max)) {
#line 1040
            goto while_break___0;
          }
#line 1041
          if ((unsigned long )*(mctx->state_log + cur_str_idx) != (unsigned long )((void *)0)) {
#line 1042
            goto while_break___0;
          }
#line 1040
          cur_str_idx ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1043
        if (cur_str_idx > max) {
#line 1044
          goto while_break;
        }
      }
    }
#line 1049
    if ((unsigned long )cur_state != (unsigned long )((void *)0)) {
#line 1049
      if (cur_state->halt) {
#line 1053
        if (! cur_state->has_constraint) {
#line 1053
          goto _L___2;
        } else {
          {
          {
#line 1053
          tmp___8 = check_halt_state_context(preg, (re_dfastate_t const   *)cur_state,
                                             (re_match_context_t const   *)mctx, (mctx->input)->cur_idx);
          }
          }
#line 1053
          if (tmp___8) {
            _L___2: /* CIL Label */ 
#line 1058
            match_last = (mctx->input)->cur_idx;
#line 1059
            match = 1;
#line 1060
            if (! fl_longest_match) {
#line 1061
              goto while_break;
            }
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1065
  return (match_last);
}
}
#line 1070 "regexec.c"
static int check_halt_node_context(re_dfa_t const   *dfa , int node , unsigned int context ) 
{ 
  re_token_type_t type ;
  unsigned int constraint ;

  {
#line 1075
  type = (dfa->nodes + node)->type;
#line 1076
  constraint = (dfa->nodes + node)->constraint;
#line 1077
  if ((unsigned int )type != 27U) {
#line 1078
    return (0);
  }
#line 1079
  if (! constraint) {
#line 1080
    return (1);
  }
#line 1081
  if (constraint & 4U) {
#line 1081
    if (! (context & 1U)) {
#line 1082
      return (0);
    } else {
#line 1081
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1081
  if (constraint & 8U) {
#line 1081
    if (context & 1U) {
#line 1082
      return (0);
    } else {
#line 1081
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1081
  if (constraint & 32U) {
#line 1081
    if (! (context & (unsigned int )(1 << 1))) {
#line 1082
      return (0);
    } else {
#line 1081
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1081
  if (constraint & 128U) {
#line 1081
    if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 1082
      return (0);
    }
  }
#line 1083
  return (1);
}
}
#line 1090 "regexec.c"
static int check_halt_state_context(regex_t const   *preg , re_dfastate_t const   *state ,
                                    re_match_context_t const   *mctx , int idx ) 
{ 
  re_dfa_t *dfa ;
  int i ;
  unsigned int context ;
  int tmp ;

  {
  {
#line 1097
  dfa = (re_dfa_t *)preg->buffer;
  {
#line 1103
  context = re_string_context_at((re_string_t const   *)mctx->input, idx, (int )mctx->eflags,
                                 (int )preg->newline_anchor);
  }
#line 1105
  i = 0;
  }
  {
  {
#line 1105
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1105
    if (! (i < (int )state->nodes.nelem)) {
#line 1105
      goto while_break;
    }
    {
    {
#line 1106
    tmp = check_halt_node_context((re_dfa_t const   *)dfa, *(state->nodes.elems + i),
                                  context);
    }
    }
#line 1106
    if (tmp) {
#line 1107
      return (*(state->nodes.elems + i));
    }
#line 1105
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1108
  return (0);
}
}
#line 1116 "regexec.c"
static int proceed_next_node(regex_t const   *preg , int nregs , regmatch_t *regs___0 ,
                             re_match_context_t const   *mctx , int *pidx , int node ,
                             re_node_set *eps_via_nodes , struct re_fail_stack_t *fs ) 
{ 
  re_dfa_t *dfa ;
  int i ;
  int err ;
  int dest_node ;
  re_node_set *cur_nodes ;
  int ndest ;
  int dest_nodes[2] ;
  long tmp ;
  int candidate ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int naccepted ;
  re_token_type_t type ;
  int subexp_idx ;
  char *buf ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp31 ;

  {
#line 1125
  dfa = (re_dfa_t *)preg->buffer;
#line 1127
  dest_node = -1;
#line 1128
  if ((unsigned int )(dfa->nodes + node)->type == 28U) {
#line 1128
    goto _L___0;
  } else
#line 1128
  if ((unsigned int )(dfa->nodes + node)->type == 29U) {
#line 1128
    goto _L___0;
  } else
#line 1128
  if ((unsigned int )(dfa->nodes + node)->type == 30U) {
#line 1128
    goto _L___0;
  } else
#line 1128
  if ((unsigned int )(dfa->nodes + node)->type == 31U) {
#line 1128
    goto _L___0;
  } else
#line 1128
  if ((unsigned int )(dfa->nodes + node)->type == 33U) {
#line 1128
    goto _L___0;
  } else
#line 1128
  if ((unsigned int )(dfa->nodes + node)->type == 23U) {
#line 1128
    goto _L___0;
  } else
#line 1128
  if ((unsigned int )(dfa->nodes + node)->type == 24U) {
    _L___0: /* CIL Label */ 
    {
#line 1130
    cur_nodes = & (*(mctx->state_log + *pidx))->nodes;
    {
#line 1132
    err = re_node_set_insert(eps_via_nodes, node);
    }
    {
#line 1133
    tmp = __builtin_expect((long )(err < 0), 0L);
    }
    }
#line 1133
    if (tmp) {
#line 1134
      return (-1);
    }
#line 1136
    ndest = 0;
#line 1136
    i = 0;
    {
    {
#line 1136
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1136
      if (! (i < (dfa->edests + node)->nelem)) {
#line 1136
        goto while_break;
      }
      {
#line 1138
      candidate = *((dfa->edests + node)->elems + i);
      {
#line 1139
      tmp___0 = re_node_set_contains((re_node_set const   *)cur_nodes, candidate);
      }
      }
#line 1139
      if (! tmp___0) {
#line 1140
        goto __Cont;
      }
#line 1141
      if (ndest == 0) {
#line 1141
        dest_nodes[0] = candidate;
      } else {
#line 1141
        dest_nodes[0] = dest_nodes[0];
      }
#line 1142
      if (ndest == 1) {
#line 1142
        dest_nodes[1] = candidate;
      } else {
#line 1142
        dest_nodes[1] = dest_nodes[1];
      }
#line 1143
      ndest ++;
      __Cont: /* CIL Label */ 
#line 1136
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1145
    if (ndest <= 1) {
#line 1146
      if (ndest == 0) {
#line 1146
        tmp___2 = -1;
      } else {
#line 1146
        if (ndest == 1) {
#line 1146
          tmp___1 = dest_nodes[0];
        } else {
#line 1146
          tmp___1 = 0;
        }
#line 1146
        tmp___2 = tmp___1;
      }
#line 1146
      return (tmp___2);
    }
    {
    {
#line 1148
    tmp___3 = re_node_set_contains((re_node_set const   *)eps_via_nodes, dest_nodes[0]);
    }
    }
#line 1148
    if (tmp___3) {
#line 1149
      return (dest_nodes[1]);
    }
#line 1150
    if ((unsigned long )fs != (unsigned long )((void *)0)) {
      {
      {
#line 1151
      push_fail_stack(fs, *pidx, dest_nodes, nregs, regs___0, eps_via_nodes);
      }
      }
    }
#line 1152
    return (dest_nodes[0]);
  } else {
#line 1156
    naccepted = 0;
#line 1157
    type = (dfa->nodes + node)->type;
#line 1160
    if ((unsigned int )type == 22U) {
      {
      {
#line 1161
      naccepted = check_node_accept_bytes(preg, node, (re_string_t const   *)mctx->input,
                                          *pidx);
      }
      }
    } else
#line 1160
    if ((unsigned int )type == 25U) {
      {
      {
#line 1161
      naccepted = check_node_accept_bytes(preg, node, (re_string_t const   *)mctx->input,
                                          *pidx);
      }
      }
    } else
#line 1164
    if ((unsigned int )type == 32U) {
#line 1166
      subexp_idx = (dfa->nodes + node)->opr.idx;
#line 1167
      naccepted = (regs___0 + subexp_idx)->rm_eo - (regs___0 + subexp_idx)->rm_so;
#line 1168
      if ((unsigned long )fs != (unsigned long )((void *)0)) {
#line 1170
        if ((regs___0 + subexp_idx)->rm_so == -1) {
#line 1171
          return (-1);
        } else
#line 1170
        if ((regs___0 + subexp_idx)->rm_eo == -1) {
#line 1171
          return (-1);
        } else
#line 1172
        if (naccepted) {
          {
#line 1174
          buf = (char *)(mctx->input)->mbs;
          {
#line 1175
          tmp___4 = memcmp((void const   *)(buf + (regs___0 + subexp_idx)->rm_so),
                           (void const   *)(buf + *pidx), (size_t )naccepted);
          }
          }
#line 1175
          if (tmp___4 != 0) {
#line 1177
            return (-1);
          }
        }
      }
#line 1181
      if (naccepted == 0) {
        {
        {
#line 1183
        err = re_node_set_insert(eps_via_nodes, node);
        }
        {
#line 1184
        tmp___5 = __builtin_expect((long )(err < 0), 0L);
        }
        }
#line 1184
        if (tmp___5) {
#line 1185
          return (-2);
        }
        {
#line 1186
        dest_node = *((dfa->edests + node)->elems + 0);
        {
#line 1187
        tmp___6 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                       dest_node);
        }
        }
#line 1187
        if (tmp___6) {
#line 1189
          return (dest_node);
        }
      }
    }
#line 1193
    if (naccepted != 0) {
#line 1193
      goto _L;
    } else {
      {
      {
#line 1193
      tmp___8 = check_node_accept(preg, (re_token_t const   *)(dfa->nodes + node),
                                  mctx, *pidx);
      }
      }
#line 1193
      if (tmp___8) {
        _L: /* CIL Label */ 
#line 1196
        dest_node = *(dfa->nexts + node);
#line 1197
        if (naccepted == 0) {
#line 1197
          (*pidx) ++;
        } else {
#line 1197
          *pidx += naccepted;
        }
#line 1198
        if (fs) {
#line 1198
          if (*pidx > (int )mctx->match_last) {
#line 1201
            return (-1);
          } else
#line 1198
          if ((unsigned long )*(mctx->state_log + *pidx) == (unsigned long )((void *)0)) {
#line 1201
            return (-1);
          } else {
            {
            {
#line 1198
            tmp___7 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                           dest_node);
            }
            }
#line 1198
            if (! tmp___7) {
#line 1201
              return (-1);
            }
          }
        }
#line 1202
        eps_via_nodes->nelem = 0;
#line 1203
        return (dest_node);
      }
    }
  }
#line 1206
  return (-1);
}
}
#line 1209 "regexec.c"
static reg_errcode_t push_fail_stack(struct re_fail_stack_t *fs , int str_idx , int *dests ,
                                     int nregs , regmatch_t *regs___0 , re_node_set *eps_via_nodes ) 
{ 
  reg_errcode_t err ;
  int num ;
  int tmp ;
  struct re_fail_stack_ent_t *new_array ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1217
  tmp = fs->num;
#line 1217
  (fs->num) ++;
#line 1217
  num = tmp;
#line 1218
  if (fs->num == fs->alloc) {
    {
#line 1221
    fs->alloc *= 2;
    {
#line 1222
    tmp___0 = realloc((void *)fs->stack, (size_t )(sizeof(struct re_fail_stack_ent_t ) * (unsigned long )fs->alloc));
    }
#line 1222
    new_array = (struct re_fail_stack_ent_t *)tmp___0;
    }
#line 1224
    if ((unsigned long )new_array == (unsigned long )((void *)0)) {
#line 1225
      return ((reg_errcode_t )12);
    }
#line 1226
    fs->stack = new_array;
  }
  {
#line 1228
  (fs->stack + num)->idx = str_idx;
#line 1229
  (fs->stack + num)->node = *(dests + 1);
  {
#line 1230
  tmp___1 = malloc((size_t )((unsigned long )nregs * sizeof(regmatch_t )));
  }
#line 1230
  (fs->stack + num)->regs = (regmatch_t *)tmp___1;
  {
#line 1231
  memcpy((void */* __restrict  */)(fs->stack + num)->regs, (void const   */* __restrict  */)regs___0,
         (size_t )(sizeof(regmatch_t ) * (unsigned long )nregs));
  }
  {
#line 1232
  err = re_node_set_init_copy(& (fs->stack + num)->eps_via_nodes, (re_node_set const   *)eps_via_nodes);
  }
  }
#line 1233
  return (err);
}
}
#line 1236 "regexec.c"
static int pop_fail_stack(struct re_fail_stack_t *fs , int *pidx , int nregs , regmatch_t *regs___0 ,
                          re_node_set *eps_via_nodes ) 
{ 
  int num ;
  long tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1243
  (fs->num) --;
#line 1243
  num = fs->num;
  {
#line 1244
  tmp = __builtin_expect((long )(! (! (num >= 0))), 1L);
  }
  }
#line 1244
  if (! tmp) {
    {
    {
#line 1244
    __assert_fail("num >= 0", "regexec.c", 1244U, "pop_fail_stack");
    }
    }
  }
  {
#line 1245
  *pidx = (fs->stack + num)->idx;
  {
#line 1246
  memcpy((void */* __restrict  */)regs___0, (void const   */* __restrict  */)(fs->stack + num)->regs,
         (size_t )(sizeof(regmatch_t ) * (unsigned long )nregs));
  }
  {
#line 1247
  free((void *)eps_via_nodes->elems);
  }
  {
#line 1248
  free((void *)(fs->stack + num)->regs);
  }
#line 1249
  *eps_via_nodes = (fs->stack + num)->eps_via_nodes;
  }
#line 1250
  return ((fs->stack + num)->node);
}
}
#line 1258 "regexec.c"
static reg_errcode_t set_regs(regex_t const   *preg , re_match_context_t const   *mctx ,
                              size_t nmatch , regmatch_t *pmatch , int fl_backtrack ) 
{ 
  re_dfa_t *dfa ;
  int idx ;
  int cur_node ;
  int real_nmatch ;
  re_node_set eps_via_nodes ;
  struct re_fail_stack_t *fs ;
  struct re_fail_stack_t fs_body ;
  void *tmp ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_57 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  int reg_idx ;
  reg_errcode_t tmp___0 ;
  long tmp___1 ;
  reg_errcode_t tmp___2 ;

  {
#line 1266
  dfa = (re_dfa_t *)preg->buffer;
#line 1270
  fs_body.num = 0;
#line 1270
  fs_body.alloc = 2;
#line 1270
  fs_body.stack = (struct re_fail_stack_ent_t *)((void *)0);
#line 1275
  if (fl_backtrack) {
    {
#line 1277
    fs = & fs_body;
    {
#line 1278
    tmp = malloc((size_t )((unsigned long )fs->alloc * sizeof(struct re_fail_stack_ent_t )));
    }
#line 1278
    fs->stack = (struct re_fail_stack_ent_t *)tmp;
    }
  } else {
#line 1281
    fs = (struct re_fail_stack_t *)((void *)0);
  }
#line 1282
  cur_node = dfa->init_node;
#line 1283
  if (nmatch <= (size_t )preg->re_nsub) {
#line 1283
    real_nmatch = (int )nmatch;
  } else {
#line 1283
    real_nmatch = (int )(preg->re_nsub + 1U);
  }
#line 1284
  if (sizeof(re_node_set ) <= 16UL) {
#line 1284
    if (sizeof(re_node_set ) == 1UL) {
#line 1284
      __s___1 = (void *)(& eps_via_nodes);
#line 1284
      *((__uint8_t *)__s___1) = (__uint8_t )'\000';
    } else {
#line 1284
      __s___0 = (void *)(& eps_via_nodes);
#line 1284
      __u = (union __anonunion___u_57 *)__s___0;
#line 1284
      __c = (__uint8_t )'\000';
      {
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 15U) {
#line 1284
        goto case_15;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 11U) {
#line 1284
        goto case_11;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 7U) {
#line 1284
        goto case_7;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 3U) {
#line 1284
        goto case_3;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 14U) {
#line 1284
        goto case_14;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 10U) {
#line 1284
        goto case_10;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 6U) {
#line 1284
        goto case_6;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 2U) {
#line 1284
        goto case_2;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 13U) {
#line 1284
        goto case_13;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 9U) {
#line 1284
        goto case_9;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 5U) {
#line 1284
        goto case_5;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 1U) {
#line 1284
        goto case_1;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 16U) {
#line 1284
        goto case_16;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 12U) {
#line 1284
        goto case_12;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 8U) {
#line 1284
        goto case_8;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 4U) {
#line 1284
        goto case_4;
      }
#line 1284
      if ((unsigned int )sizeof(re_node_set ) == 0U) {
#line 1284
        goto case_0;
      }
#line 1284
      goto switch_break;
      case_15: /* CIL Label */ 
#line 1284
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1284
      __u = (union __anonunion___u_57 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 1284
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1284
      __u = (union __anonunion___u_57 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 1284
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1284
      __u = (union __anonunion___u_57 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 1284
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1284
      __u = (union __anonunion___u_57 *)((void *)__u + 2);
#line 1284
      __u->__uc = __c;
#line 1284
      goto switch_break;
      case_14: /* CIL Label */ 
#line 1284
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1284
      __u = (union __anonunion___u_57 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 1284
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1284
      __u = (union __anonunion___u_57 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 1284
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1284
      __u = (union __anonunion___u_57 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 1284
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1284
      goto switch_break;
      case_13: /* CIL Label */ 
#line 1284
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1284
      __u = (union __anonunion___u_57 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 1284
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1284
      __u = (union __anonunion___u_57 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 1284
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1284
      __u = (union __anonunion___u_57 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 1284
      __u->__uc = __c;
#line 1284
      goto switch_break;
      case_16: /* CIL Label */ 
#line 1284
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1284
      __u = (union __anonunion___u_57 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 1284
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1284
      __u = (union __anonunion___u_57 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 1284
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1284
      __u = (union __anonunion___u_57 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 1284
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 1284
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1284
    __s = (void *)(& eps_via_nodes);
    {
#line 1284
    __builtin_memset(__s, '\000', (int )sizeof(re_node_set ));
    }
    }
  }
#line 1285
  idx = (pmatch + 0)->rm_so;
  {
  {
#line 1285
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1285
    if (! (idx <= (pmatch + 0)->rm_eo)) {
#line 1285
      goto while_break;
    }
    {
    {
#line 1287
    update_regs(dfa, pmatch, cur_node, idx, real_nmatch);
    }
    }
#line 1288
    if (idx == (pmatch + 0)->rm_eo) {
#line 1288
      if (cur_node == (int )mctx->last_node) {
#line 1291
        if (fs) {
#line 1293
          reg_idx = 0;
          {
          {
#line 1293
          while (1) {
            while_continue___2: /* CIL Label */ ;
            while_continue___0: /* CIL Label */ ;
#line 1293
            if (! ((size_t )reg_idx < nmatch)) {
#line 1293
              goto while_break___0;
            }
#line 1294
            if ((pmatch + reg_idx)->rm_so > -1) {
#line 1294
              if ((pmatch + reg_idx)->rm_eo == -1) {
#line 1295
                goto while_break___0;
              }
            }
#line 1293
            reg_idx ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1296
          if ((size_t )reg_idx == nmatch) {
            {
            {
#line 1298
            free((void *)eps_via_nodes.elems);
            }
            {
#line 1299
            tmp___0 = free_fail_stack_return(fs);
            }
            }
#line 1299
            return (tmp___0);
          }
          {
          {
#line 1301
          cur_node = pop_fail_stack(fs, & idx, (int )nmatch, pmatch, & eps_via_nodes);
          }
          }
        } else {
          {
          {
#line 1306
          free((void *)eps_via_nodes.elems);
          }
          }
#line 1307
          return ((reg_errcode_t )0);
        }
      }
    }
    {
    {
#line 1312
    cur_node = proceed_next_node(preg, (int )nmatch, pmatch, mctx, & idx, cur_node,
                                 & eps_via_nodes, fs);
    }
    {
#line 1315
    tmp___1 = __builtin_expect((long )(cur_node < 0), 0L);
    }
    }
#line 1315
    if (tmp___1) {
#line 1317
      if (cur_node == -2) {
#line 1318
        return ((reg_errcode_t )12);
      }
#line 1319
      if (fs) {
        {
        {
#line 1320
        cur_node = pop_fail_stack(fs, & idx, (int )nmatch, pmatch, & eps_via_nodes);
        }
        }
      } else {
        {
        {
#line 1324
        free((void *)eps_via_nodes.elems);
        }
        }
#line 1325
        return ((reg_errcode_t )1);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1329
  free((void *)eps_via_nodes.elems);
  }
  {
#line 1330
  tmp___2 = free_fail_stack_return(fs);
  }
  }
#line 1330
  return (tmp___2);
}
}
#line 1333 "regexec.c"
static reg_errcode_t free_fail_stack_return(struct re_fail_stack_t *fs ) 
{ 
  int fs_idx ;

  {
#line 1337
  if (fs) {
#line 1340
    fs_idx = 0;
    {
    {
#line 1340
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1340
      if (! (fs_idx < fs->num)) {
#line 1340
        goto while_break;
      }
      {
      {
#line 1342
      free((void *)(fs->stack + fs_idx)->eps_via_nodes.elems);
      }
      {
#line 1343
      free((void *)(fs->stack + fs_idx)->regs);
      }
#line 1340
      fs_idx ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 1345
    free((void *)fs->stack);
    }
    }
  }
#line 1347
  return ((reg_errcode_t )0);
}
}
#line 1350 "regexec.c"
static void update_regs(re_dfa_t *dfa , regmatch_t *pmatch , int cur_node , int cur_idx ,
                        int nmatch ) 
{ 
  int type ;
  int reg_num ;

  {
#line 1356
  type = (int )(dfa->nodes + cur_node)->type;
#line 1358
  if (type != 23) {
#line 1358
    if (type != 24) {
#line 1359
      return;
    }
  }
#line 1360
  reg_num = (dfa->nodes + cur_node)->opr.idx + 1;
#line 1361
  if (reg_num >= nmatch) {
#line 1362
    return;
  }
#line 1363
  if (type == 23) {
#line 1366
    (pmatch + reg_num)->rm_so = cur_idx;
#line 1367
    (pmatch + reg_num)->rm_eo = -1;
  } else
#line 1369
  if (type == 24) {
#line 1371
    (pmatch + reg_num)->rm_eo = cur_idx;
  }
#line 1372
  return;
}
}
#line 1399 "regexec.c"
static reg_errcode_t sift_states_backward(regex_t const   *preg , re_match_context_t *mctx ,
                                          re_sift_context_t *sctx ) 
{ 
  reg_errcode_t err ;
  re_dfa_t *dfa ;
  int null_cnt ;
  int str_idx ;
  re_node_set cur_dest ;
  re_node_set *cur_src ;
  long tmp ;
  long tmp___0 ;
  int i ;
  int ret ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_58 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  int prev_node ;
  int naccepted ;
  re_token_type_t type ;
  int tmp___1 ;
  int tmp___2 ;
  int to_idx ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
  {
#line 1406
  dfa = (re_dfa_t *)preg->buffer;
#line 1407
  null_cnt = 0;
#line 1408
  str_idx = sctx->last_str_idx;
#line 1415
  cur_src = & (*(mctx->state_log + str_idx))->nodes;
  {
#line 1419
  err = re_node_set_init_1(& cur_dest, sctx->last_node);
  }
  {
#line 1420
  tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 1420
  if (tmp) {
#line 1421
    return (err);
  }
  {
  {
#line 1422
  err = update_cur_sifted_state(preg, mctx, sctx, str_idx, & cur_dest);
  }
  {
#line 1423
  tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 1423
  if (tmp___0) {
#line 1424
    goto free_return;
  }
  {
  {
#line 1427
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1427
    if (! (str_idx > 0)) {
#line 1427
      goto while_break;
    }
#line 1431
    if ((unsigned long )*(sctx->sifted_states + str_idx) == (unsigned long )((void *)0)) {
#line 1431
      null_cnt ++;
    } else {
#line 1431
      null_cnt = 0;
    }
#line 1432
    if (null_cnt > mctx->max_mb_elem_len) {
#line 1434
      if (0) {
#line 1434
        if (sizeof(re_dfastate_t *) * (unsigned long )str_idx == 1UL) {
#line 1434
          __s___1 = (void *)sctx->sifted_states;
#line 1434
          *((__uint8_t *)__s___1) = (__uint8_t )'\000';
        } else {
#line 1434
          __s___0 = (void *)sctx->sifted_states;
#line 1434
          __u = (union __anonunion___u_58 *)__s___0;
#line 1434
          __c = (__uint8_t )'\000';
          {
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 15U) {
#line 1434
            goto case_15;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 11U) {
#line 1434
            goto case_11;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 7U) {
#line 1434
            goto case_7;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 3U) {
#line 1434
            goto case_3;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 14U) {
#line 1434
            goto case_14;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 10U) {
#line 1434
            goto case_10;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 6U) {
#line 1434
            goto case_6;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 2U) {
#line 1434
            goto case_2;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 13U) {
#line 1434
            goto case_13;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 9U) {
#line 1434
            goto case_9;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 5U) {
#line 1434
            goto case_5;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 1U) {
#line 1434
            goto case_1;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 16U) {
#line 1434
            goto case_16;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 12U) {
#line 1434
            goto case_12;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 8U) {
#line 1434
            goto case_8;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 4U) {
#line 1434
            goto case_4;
          }
#line 1434
          if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx) == 0U) {
#line 1434
            goto case_0;
          }
#line 1434
          goto switch_break;
          case_15: /* CIL Label */ 
#line 1434
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1434
          __u = (union __anonunion___u_58 *)((void *)__u + 4);
          case_11: /* CIL Label */ 
#line 1434
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1434
          __u = (union __anonunion___u_58 *)((void *)__u + 4);
          case_7: /* CIL Label */ 
#line 1434
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1434
          __u = (union __anonunion___u_58 *)((void *)__u + 4);
          case_3: /* CIL Label */ 
#line 1434
          __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1434
          __u = (union __anonunion___u_58 *)((void *)__u + 2);
#line 1434
          __u->__uc = __c;
#line 1434
          goto switch_break;
          case_14: /* CIL Label */ 
#line 1434
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1434
          __u = (union __anonunion___u_58 *)((void *)__u + 4);
          case_10: /* CIL Label */ 
#line 1434
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1434
          __u = (union __anonunion___u_58 *)((void *)__u + 4);
          case_6: /* CIL Label */ 
#line 1434
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1434
          __u = (union __anonunion___u_58 *)((void *)__u + 4);
          case_2: /* CIL Label */ 
#line 1434
          __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1434
          goto switch_break;
          case_13: /* CIL Label */ 
#line 1434
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1434
          __u = (union __anonunion___u_58 *)((void *)__u + 4);
          case_9: /* CIL Label */ 
#line 1434
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1434
          __u = (union __anonunion___u_58 *)((void *)__u + 4);
          case_5: /* CIL Label */ 
#line 1434
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1434
          __u = (union __anonunion___u_58 *)((void *)__u + 4);
          case_1: /* CIL Label */ 
#line 1434
          __u->__uc = __c;
#line 1434
          goto switch_break;
          case_16: /* CIL Label */ 
#line 1434
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1434
          __u = (union __anonunion___u_58 *)((void *)__u + 4);
          case_12: /* CIL Label */ 
#line 1434
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1434
          __u = (union __anonunion___u_58 *)((void *)__u + 4);
          case_8: /* CIL Label */ 
#line 1434
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1434
          __u = (union __anonunion___u_58 *)((void *)__u + 4);
          case_4: /* CIL Label */ 
#line 1434
          __u->__ui = (unsigned int )((int )__c * 16843009);
          case_0: /* CIL Label */ 
#line 1434
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 1434
        __s = (void *)sctx->sifted_states;
        {
#line 1434
        __builtin_memset(__s, '\000', (int )(sizeof(re_dfastate_t *) * (unsigned long )str_idx));
        }
        }
      }
      {
      {
#line 1436
      free((void *)cur_dest.elems);
      }
      }
#line 1437
      return ((reg_errcode_t )0);
    }
#line 1439
    cur_dest.nelem = 0;
#line 1440
    str_idx --;
#line 1441
    if ((unsigned long )*(mctx->state_log + str_idx) == (unsigned long )((void *)0)) {
#line 1441
      cur_src = & empty_set;
    } else {
#line 1441
      cur_src = & (*(mctx->state_log + str_idx))->nodes;
    }
#line 1450
    i = 0;
    {
    {
#line 1450
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1450
      if (! (i < cur_src->nelem)) {
#line 1450
        goto while_break___0;
      }
#line 1452
      prev_node = *(cur_src->elems + i);
#line 1453
      naccepted = 0;
#line 1454
      type = (dfa->nodes + prev_node)->type;
#line 1456
      if ((unsigned int )type == 28U) {
#line 1457
        goto __Cont;
      } else
#line 1456
      if ((unsigned int )type == 29U) {
#line 1457
        goto __Cont;
      } else
#line 1456
      if ((unsigned int )type == 30U) {
#line 1457
        goto __Cont;
      } else
#line 1456
      if ((unsigned int )type == 31U) {
#line 1457
        goto __Cont;
      } else
#line 1456
      if ((unsigned int )type == 33U) {
#line 1457
        goto __Cont;
      } else
#line 1456
      if ((unsigned int )type == 23U) {
#line 1457
        goto __Cont;
      } else
#line 1456
      if ((unsigned int )type == 24U) {
#line 1457
        goto __Cont;
      }
#line 1460
      if ((unsigned int )type == 22U) {
        {
        {
#line 1461
        naccepted = sift_states_iter_mb(preg, (re_match_context_t const   *)mctx,
                                        sctx, prev_node, str_idx, sctx->last_str_idx);
        }
        }
      } else
#line 1460
      if ((unsigned int )type == 25U) {
        {
        {
#line 1461
        naccepted = sift_states_iter_mb(preg, (re_match_context_t const   *)mctx,
                                        sctx, prev_node, str_idx, sctx->last_str_idx);
        }
        }
      }
#line 1468
      if (! naccepted) {
        {
        {
#line 1468
        tmp___1 = check_node_accept(preg, (re_token_t const   *)(dfa->nodes + prev_node),
                                    (re_match_context_t const   *)mctx, str_idx);
        }
        }
#line 1468
        if (tmp___1) {
#line 1468
          if ((unsigned long )*(sctx->sifted_states + (str_idx + 1)) != (unsigned long )((void *)0)) {
            {
            {
#line 1468
            tmp___2 = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + (str_idx + 1)))->nodes),
                                           *(dfa->nexts + prev_node));
            }
            }
#line 1468
            if (tmp___2) {
#line 1473
              naccepted = 1;
            }
          }
        }
      }
#line 1475
      if (naccepted == 0) {
#line 1476
        goto __Cont;
      }
#line 1478
      if (sctx->limits.nelem) {
        {
#line 1480
        to_idx = str_idx + naccepted;
        {
#line 1481
        tmp___3 = check_dst_limits(dfa, & sctx->limits, mctx, *(dfa->nexts + prev_node),
                                   to_idx, prev_node, str_idx);
        }
        }
#line 1481
        if (tmp___3) {
#line 1484
          goto __Cont;
        }
      }
      {
      {
#line 1486
      ret = re_node_set_insert(& cur_dest, prev_node);
      }
      {
#line 1487
      tmp___4 = __builtin_expect((long )(ret == -1), 0L);
      }
      }
#line 1487
      if (tmp___4) {
#line 1489
        err = (reg_errcode_t )12;
#line 1490
        goto free_return;
      }
      __Cont: /* CIL Label */ 
#line 1450
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 1498
    err = update_cur_sifted_state(preg, mctx, sctx, str_idx, & cur_dest);
    }
    {
#line 1499
    tmp___5 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    }
#line 1499
    if (tmp___5) {
#line 1500
      goto free_return;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1502
  err = (reg_errcode_t )0;
  free_return: 
  {
  {
#line 1504
  free((void *)cur_dest.elems);
  }
  }
#line 1505
  return (err);
}
}
#line 1510 "regexec.c"
static reg_errcode_t clean_state_log_if_need(re_match_context_t *mctx , int next_state_log_idx ) 
{ 
  int top ;
  reg_errcode_t err ;
  long tmp ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_59 *__u ;
  __uint8_t __c ;
  void *__s___1 ;

  {
#line 1515
  top = mctx->state_log_top;
#line 1517
  if (next_state_log_idx >= (mctx->input)->bufs_len) {
#line 1517
    goto _L;
  } else
#line 1517
  if (next_state_log_idx >= (mctx->input)->valid_len) {
#line 1517
    if ((mctx->input)->valid_len < (mctx->input)->len) {
      _L: /* CIL Label */ 
      {
      {
#line 1522
      err = extend_buffers(mctx);
      }
      {
#line 1523
      tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 1523
      if (tmp) {
#line 1524
        return (err);
      }
    }
  }
#line 1527
  if (top < next_state_log_idx) {
#line 1529
    if (0) {
#line 1529
      if (sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top) == 1UL) {
#line 1529
        __s___1 = (void *)((mctx->state_log + top) + 1);
#line 1529
        *((__uint8_t *)__s___1) = (__uint8_t )'\000';
      } else {
#line 1529
        __s___0 = (void *)((mctx->state_log + top) + 1);
#line 1529
        __u = (union __anonunion___u_59 *)__s___0;
#line 1529
        __c = (__uint8_t )'\000';
        {
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 15U) {
#line 1529
          goto case_15;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 11U) {
#line 1529
          goto case_11;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 7U) {
#line 1529
          goto case_7;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 3U) {
#line 1529
          goto case_3;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 14U) {
#line 1529
          goto case_14;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 10U) {
#line 1529
          goto case_10;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 6U) {
#line 1529
          goto case_6;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 2U) {
#line 1529
          goto case_2;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 13U) {
#line 1529
          goto case_13;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 9U) {
#line 1529
          goto case_9;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 5U) {
#line 1529
          goto case_5;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 1U) {
#line 1529
          goto case_1;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 16U) {
#line 1529
          goto case_16;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 12U) {
#line 1529
          goto case_12;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 8U) {
#line 1529
          goto case_8;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 4U) {
#line 1529
          goto case_4;
        }
#line 1529
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)) == 0U) {
#line 1529
          goto case_0;
        }
#line 1529
        goto switch_break;
        case_15: /* CIL Label */ 
#line 1529
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1529
        __u = (union __anonunion___u_59 *)((void *)__u + 4);
        case_11: /* CIL Label */ 
#line 1529
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1529
        __u = (union __anonunion___u_59 *)((void *)__u + 4);
        case_7: /* CIL Label */ 
#line 1529
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1529
        __u = (union __anonunion___u_59 *)((void *)__u + 4);
        case_3: /* CIL Label */ 
#line 1529
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1529
        __u = (union __anonunion___u_59 *)((void *)__u + 2);
#line 1529
        __u->__uc = __c;
#line 1529
        goto switch_break;
        case_14: /* CIL Label */ 
#line 1529
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1529
        __u = (union __anonunion___u_59 *)((void *)__u + 4);
        case_10: /* CIL Label */ 
#line 1529
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1529
        __u = (union __anonunion___u_59 *)((void *)__u + 4);
        case_6: /* CIL Label */ 
#line 1529
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1529
        __u = (union __anonunion___u_59 *)((void *)__u + 4);
        case_2: /* CIL Label */ 
#line 1529
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1529
        goto switch_break;
        case_13: /* CIL Label */ 
#line 1529
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1529
        __u = (union __anonunion___u_59 *)((void *)__u + 4);
        case_9: /* CIL Label */ 
#line 1529
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1529
        __u = (union __anonunion___u_59 *)((void *)__u + 4);
        case_5: /* CIL Label */ 
#line 1529
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1529
        __u = (union __anonunion___u_59 *)((void *)__u + 4);
        case_1: /* CIL Label */ 
#line 1529
        __u->__uc = __c;
#line 1529
        goto switch_break;
        case_16: /* CIL Label */ 
#line 1529
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1529
        __u = (union __anonunion___u_59 *)((void *)__u + 4);
        case_12: /* CIL Label */ 
#line 1529
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1529
        __u = (union __anonunion___u_59 *)((void *)__u + 4);
        case_8: /* CIL Label */ 
#line 1529
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1529
        __u = (union __anonunion___u_59 *)((void *)__u + 4);
        case_4: /* CIL Label */ 
#line 1529
        __u->__ui = (unsigned int )((int )__c * 16843009);
        case_0: /* CIL Label */ 
#line 1529
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 1529
      __s = (void *)((mctx->state_log + top) + 1);
      {
#line 1529
      __builtin_memset(__s, '\000', (int )(sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top)));
      }
      }
    }
#line 1531
    mctx->state_log_top = next_state_log_idx;
  }
#line 1533
  return ((reg_errcode_t )0);
}
}
#line 1536 "regexec.c"
static reg_errcode_t merge_state_array(re_dfa_t *dfa , re_dfastate_t **dst , re_dfastate_t **src ,
                                       int num ) 
{ 
  int st_idx ;
  reg_errcode_t err ;
  re_node_set merged_set ;
  long tmp ;
  long tmp___0 ;

  {
#line 1545
  st_idx = 0;
  {
  {
#line 1545
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1545
    if (! (st_idx < num)) {
#line 1545
      goto while_break;
    }
#line 1547
    if ((unsigned long )*(dst + st_idx) == (unsigned long )((void *)0)) {
#line 1548
      *(dst + st_idx) = *(src + st_idx);
    } else
#line 1549
    if ((unsigned long )*(src + st_idx) != (unsigned long )((void *)0)) {
      {
      {
#line 1552
      err = re_node_set_init_union(& merged_set, (re_node_set const   *)(& (*(dst + st_idx))->nodes),
                                   (re_node_set const   *)(& (*(src + st_idx))->nodes));
      }
      {
#line 1554
      tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 1554
      if (tmp) {
#line 1555
        return (err);
      }
      {
      {
#line 1556
      *(dst + st_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& merged_set));
      }
      {
#line 1557
      free((void *)merged_set.elems);
      }
      {
#line 1558
      tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 1558
      if (tmp___0) {
#line 1559
        return (err);
      }
    }
#line 1545
    st_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1562
  return ((reg_errcode_t )0);
}
}
#line 1565 "regexec.c"
static reg_errcode_t update_cur_sifted_state(regex_t const   *preg , re_match_context_t *mctx ,
                                             re_sift_context_t *sctx , int str_idx ,
                                             re_node_set *dest_nodes ) 
{ 
  reg_errcode_t err ;
  re_dfa_t *dfa ;
  re_node_set const   *candidates ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1574
  dfa = (re_dfa_t *)preg->buffer;
#line 1576
  if ((unsigned long )*(mctx->state_log + str_idx) == (unsigned long )((void *)0)) {
#line 1576
    candidates = (re_node_set const   *)(& empty_set);
  } else {
#line 1576
    candidates = (re_node_set const   *)(& (*(mctx->state_log + str_idx))->nodes);
  }
#line 1581
  if (dest_nodes->nelem) {
    {
    {
#line 1583
    err = add_epsilon_src_nodes(dfa, dest_nodes, candidates);
    }
    {
#line 1584
    tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    }
#line 1584
    if (tmp) {
#line 1585
      return (err);
    }
  }
#line 1589
  if (dest_nodes->nelem) {
#line 1589
    if (sctx->limits.nelem) {
      {
      {
#line 1591
      err = check_subexp_limits(dfa, dest_nodes, candidates, & sctx->limits, mctx->bkref_ents,
                                str_idx);
      }
      {
#line 1593
      tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 1593
      if (tmp___0) {
#line 1594
        return (err);
      }
    }
  }
  {
  {
#line 1598
  *(sctx->sifted_states + str_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)dest_nodes);
  }
  }
#line 1599
  if ((unsigned long )*(sctx->sifted_states + str_idx) == (unsigned long )((void *)0)) {
#line 1599
    if ((unsigned int )err != 0U) {
#line 1599
      tmp___1 = 1;
    } else {
#line 1599
      tmp___1 = 0;
    }
  } else {
#line 1599
    tmp___1 = 0;
  }
  {
  {
#line 1599
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  }
#line 1599
  if (tmp___2) {
#line 1600
    return (err);
  }
#line 1602
  if ((unsigned long )*(mctx->state_log + str_idx) != (unsigned long )((void *)0)) {
#line 1602
    if ((*(mctx->state_log + str_idx))->has_backref) {
      {
      {
#line 1605
      err = sift_states_bkref(preg, mctx, sctx, str_idx, dest_nodes);
      }
      {
#line 1606
      tmp___3 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 1606
      if (tmp___3) {
#line 1607
        return (err);
      }
    }
  }
#line 1609
  return ((reg_errcode_t )0);
}
}
#line 1612 "regexec.c"
static reg_errcode_t add_epsilon_src_nodes(re_dfa_t *dfa , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) 
{ 
  reg_errcode_t err ;
  int src_idx ;
  re_node_set src_copy ;
  long tmp ;
  long tmp___0 ;

  {
  {
  {
#line 1622
  err = re_node_set_init_copy(& src_copy, (re_node_set const   *)dest_nodes);
  }
  {
#line 1623
  tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 1623
  if (tmp) {
#line 1624
    return (err);
  }
#line 1625
  src_idx = 0;
  {
  {
#line 1625
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1625
    if (! (src_idx < src_copy.nelem)) {
#line 1625
      goto while_break;
    }
    {
    {
#line 1627
    err = re_node_set_add_intersect(dest_nodes, candidates, (re_node_set const   *)(dfa->inveclosures + *(src_copy.elems + src_idx)));
    }
    {
#line 1630
    tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    }
#line 1630
    if (tmp___0) {
      {
      {
#line 1632
      free((void *)src_copy.elems);
      }
      }
#line 1633
      return (err);
    }
#line 1625
    src_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1636
  free((void *)src_copy.elems);
  }
  }
#line 1637
  return ((reg_errcode_t )0);
}
}
#line 1640 "regexec.c"
static reg_errcode_t sub_epsilon_src_nodes(re_dfa_t *dfa , int node , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) 
{ 
  int ecl_idx ;
  reg_errcode_t err ;
  re_node_set *inv_eclosure ;
  re_node_set except_nodes ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_60 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  int cur_node ;
  int edst1 ;
  int edst2 ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int cur_node___0 ;
  int idx ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1649
  inv_eclosure = dfa->inveclosures + node;
#line 1651
  if (sizeof(re_node_set ) <= 16UL) {
#line 1651
    if (sizeof(re_node_set ) == 1UL) {
#line 1651
      __s___1 = (void *)(& except_nodes);
#line 1651
      *((__uint8_t *)__s___1) = (__uint8_t )'\000';
    } else {
#line 1651
      __s___0 = (void *)(& except_nodes);
#line 1651
      __u = (union __anonunion___u_60 *)__s___0;
#line 1651
      __c = (__uint8_t )'\000';
      {
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 15U) {
#line 1651
        goto case_15;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 11U) {
#line 1651
        goto case_11;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 7U) {
#line 1651
        goto case_7;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 3U) {
#line 1651
        goto case_3;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 14U) {
#line 1651
        goto case_14;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 10U) {
#line 1651
        goto case_10;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 6U) {
#line 1651
        goto case_6;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 2U) {
#line 1651
        goto case_2;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 13U) {
#line 1651
        goto case_13;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 9U) {
#line 1651
        goto case_9;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 5U) {
#line 1651
        goto case_5;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 1U) {
#line 1651
        goto case_1;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 16U) {
#line 1651
        goto case_16;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 12U) {
#line 1651
        goto case_12;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 8U) {
#line 1651
        goto case_8;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 4U) {
#line 1651
        goto case_4;
      }
#line 1651
      if ((unsigned int )sizeof(re_node_set ) == 0U) {
#line 1651
        goto case_0;
      }
#line 1651
      goto switch_break;
      case_15: /* CIL Label */ 
#line 1651
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1651
      __u = (union __anonunion___u_60 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 1651
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1651
      __u = (union __anonunion___u_60 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 1651
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1651
      __u = (union __anonunion___u_60 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 1651
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1651
      __u = (union __anonunion___u_60 *)((void *)__u + 2);
#line 1651
      __u->__uc = __c;
#line 1651
      goto switch_break;
      case_14: /* CIL Label */ 
#line 1651
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1651
      __u = (union __anonunion___u_60 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 1651
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1651
      __u = (union __anonunion___u_60 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 1651
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1651
      __u = (union __anonunion___u_60 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 1651
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1651
      goto switch_break;
      case_13: /* CIL Label */ 
#line 1651
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1651
      __u = (union __anonunion___u_60 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 1651
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1651
      __u = (union __anonunion___u_60 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 1651
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1651
      __u = (union __anonunion___u_60 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 1651
      __u->__uc = __c;
#line 1651
      goto switch_break;
      case_16: /* CIL Label */ 
#line 1651
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1651
      __u = (union __anonunion___u_60 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 1651
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1651
      __u = (union __anonunion___u_60 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 1651
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1651
      __u = (union __anonunion___u_60 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 1651
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 1651
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1651
    __s = (void *)(& except_nodes);
    {
#line 1651
    __builtin_memset(__s, '\000', (int )sizeof(re_node_set ));
    }
    }
  }
#line 1652
  ecl_idx = 0;
  {
  {
#line 1652
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1652
    if (! (ecl_idx < inv_eclosure->nelem)) {
#line 1652
      goto while_break;
    }
#line 1654
    cur_node = *(inv_eclosure->elems + ecl_idx);
#line 1655
    if (cur_node == node) {
#line 1656
      goto __Cont;
    }
#line 1657
    if ((unsigned int )(dfa->nodes + cur_node)->type == 28U) {
#line 1657
      goto _L___1;
    } else
#line 1657
    if ((unsigned int )(dfa->nodes + cur_node)->type == 29U) {
#line 1657
      goto _L___1;
    } else
#line 1657
    if ((unsigned int )(dfa->nodes + cur_node)->type == 30U) {
#line 1657
      goto _L___1;
    } else
#line 1657
    if ((unsigned int )(dfa->nodes + cur_node)->type == 31U) {
#line 1657
      goto _L___1;
    } else
#line 1657
    if ((unsigned int )(dfa->nodes + cur_node)->type == 33U) {
#line 1657
      goto _L___1;
    } else
#line 1657
    if ((unsigned int )(dfa->nodes + cur_node)->type == 23U) {
#line 1657
      goto _L___1;
    } else
#line 1657
    if ((unsigned int )(dfa->nodes + cur_node)->type == 24U) {
      _L___1: /* CIL Label */ 
#line 1659
      edst1 = *((dfa->edests + cur_node)->elems + 0);
#line 1660
      if ((dfa->edests + cur_node)->nelem > 1) {
#line 1660
        tmp = *((dfa->edests + cur_node)->elems + 1);
      } else {
#line 1660
        tmp = -1;
      }
      {
#line 1660
      edst2 = tmp;
      {
#line 1662
      tmp___1 = re_node_set_contains((re_node_set const   *)inv_eclosure, edst1);
      }
      }
#line 1662
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 1662
        if (edst2 > 0) {
          {
          {
#line 1662
          tmp___3 = re_node_set_contains((re_node_set const   *)inv_eclosure, edst2);
          }
          }
#line 1662
          if (! tmp___3) {
            {
            {
#line 1662
            tmp___4 = re_node_set_contains((re_node_set const   *)dest_nodes, edst2);
            }
            }
#line 1662
            if (tmp___4) {
              _L: /* CIL Label */ 
              {
              {
#line 1668
              err = re_node_set_add_intersect(& except_nodes, candidates, (re_node_set const   *)(dfa->inveclosures + cur_node));
              }
              {
#line 1670
              tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
              }
              }
#line 1670
              if (tmp___0) {
                {
                {
#line 1672
                free((void *)except_nodes.elems);
                }
                }
#line 1673
                return (err);
              }
            }
          }
        }
      } else {
        {
        {
#line 1662
        tmp___2 = re_node_set_contains((re_node_set const   *)dest_nodes, edst1);
        }
        }
#line 1662
        if (tmp___2) {
#line 1662
          goto _L;
        } else {
#line 1662
          goto _L___0;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1652
    ecl_idx ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1678
  ecl_idx = 0;
  {
  {
#line 1678
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1678
    if (! (ecl_idx < inv_eclosure->nelem)) {
#line 1678
      goto while_break___0;
    }
    {
#line 1680
    cur_node___0 = *(inv_eclosure->elems + ecl_idx);
    {
#line 1681
    tmp___6 = re_node_set_contains((re_node_set const   *)(& except_nodes), cur_node___0);
    }
    }
#line 1681
    if (! tmp___6) {
      {
      {
#line 1683
      tmp___5 = re_node_set_contains((re_node_set const   *)dest_nodes, cur_node___0);
      }
#line 1683
      idx = tmp___5 - 1;
      {
#line 1684
      re_node_set_remove_at(dest_nodes, idx);
      }
      }
    }
#line 1678
    ecl_idx ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 1687
  free((void *)except_nodes.elems);
  }
  }
#line 1688
  return ((reg_errcode_t )0);
}
}
#line 1691 "regexec.c"
static int check_dst_limits(re_dfa_t *dfa , re_node_set *limits , re_match_context_t *mctx ,
                            int dst_node , int dst_idx , int src_node , int src_idx ) 
{ 
  int lim_idx ;
  int src_pos ;
  int dst_pos ;
  int subexp_idx ;
  struct re_backref_cache_entry *ent ;

  {
#line 1700
  lim_idx = 0;
  {
  {
#line 1700
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1700
    if (! (lim_idx < limits->nelem)) {
#line 1700
      goto while_break;
    }
    {
#line 1704
    ent = mctx->bkref_ents + *(limits->elems + lim_idx);
#line 1705
    subexp_idx = (dfa->nodes + ent->node)->opr.idx - 1;
    {
#line 1707
    dst_pos = check_dst_limits_calc_pos(dfa, mctx, *(limits->elems + lim_idx), dfa->eclosures + dst_node,
                                        subexp_idx, dst_node, dst_idx);
    }
    {
#line 1710
    src_pos = check_dst_limits_calc_pos(dfa, mctx, *(limits->elems + lim_idx), dfa->eclosures + src_node,
                                        subexp_idx, src_node, src_idx);
    }
    }
#line 1718
    if (! (src_pos == dst_pos)) {
#line 1721
      return (1);
    }
#line 1700
    lim_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1723
  return (0);
}
}
#line 1726 "regexec.c"
static int check_dst_limits_calc_pos(re_dfa_t *dfa , re_match_context_t *mctx , int limit ,
                                     re_node_set *eclosures , int subexp_idx , int from_node ,
                                     int str_idx ) 
{ 
  struct re_backref_cache_entry *lim ;
  int node_idx ;
  int node ;
  int bi ;
  int tmp ;
  struct re_backref_cache_entry *ent ;
  int dst ;
  int cpos ;

  {
#line 1734
  lim = mctx->bkref_ents + limit;
#line 1738
  if (str_idx < lim->subexp_from) {
#line 1739
    return (-1);
  }
#line 1741
  if (lim->subexp_to < str_idx) {
#line 1742
    return (1);
  }
#line 1745
  if (str_idx != lim->subexp_from) {
#line 1745
    if (str_idx != lim->subexp_to) {
#line 1746
      return (0);
    }
  }
#line 1750
  node_idx = 0;
  {
  {
#line 1750
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1750
    if (! (node_idx < eclosures->nelem)) {
#line 1750
      goto while_break;
    }
#line 1752
    node = *(eclosures->elems + node_idx);
    {
#line 1755
    if ((unsigned int )(dfa->nodes + node)->type == 32U) {
#line 1755
      goto case_32;
    }
#line 1800
    if ((unsigned int )(dfa->nodes + node)->type == 23U) {
#line 1800
      goto case_23;
    }
#line 1805
    if ((unsigned int )(dfa->nodes + node)->type == 24U) {
#line 1805
      goto case_24;
    }
#line 1810
    goto switch_default;
    case_32: /* CIL Label */ 
    {
    {
#line 1757
    tmp = search_cur_bkref_entry(mctx, str_idx);
    }
#line 1757
    bi = tmp;
    }
    {
    {
#line 1758
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1758
      if (! (bi < mctx->nbkref_ents)) {
#line 1758
        goto while_break___0;
      }
#line 1760
      ent = mctx->bkref_ents + bi;
#line 1765
      if (ent->str_idx > str_idx) {
#line 1766
        goto while_break___0;
      }
#line 1768
      if (ent->node != node) {
#line 1769
        goto __Cont;
      } else
#line 1768
      if (ent->subexp_from != ent->subexp_to) {
#line 1769
        goto __Cont;
      }
#line 1777
      dst = *((dfa->edests + node)->elems + 0);
#line 1778
      if (dst == from_node) {
#line 1780
        if (str_idx == lim->subexp_from) {
#line 1781
          return (-1);
        } else {
#line 1783
          return (0);
        }
      }
      {
      {
#line 1786
      cpos = check_dst_limits_calc_pos(dfa, mctx, limit, dfa->eclosures + dst, subexp_idx,
                                       dst, str_idx);
      }
      }
#line 1791
      if (cpos == -1) {
#line 1791
        if (str_idx == lim->subexp_from) {
#line 1792
          return (-1);
        }
      }
#line 1794
      if (cpos == 0) {
#line 1795
        return (0);
      }
      __Cont: /* CIL Label */ 
#line 1758
      bi ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1797
    goto switch_break;
    case_23: /* CIL Label */ 
#line 1801
    if (str_idx == lim->subexp_from) {
#line 1801
      if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 1802
        return (-1);
      }
    }
#line 1803
    goto switch_break;
    case_24: /* CIL Label */ 
#line 1806
    if (str_idx == lim->subexp_to) {
#line 1806
      if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 1807
        return (0);
      }
    }
#line 1808
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1811
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1750
    node_idx ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1815
  if (str_idx == lim->subexp_to) {
#line 1816
    return (1);
  } else {
#line 1818
    return (0);
  }
}
}
#line 1824 "regexec.c"
static reg_errcode_t check_subexp_limits(re_dfa_t *dfa , re_node_set *dest_nodes ,
                                         re_node_set const   *candidates , re_node_set *limits ,
                                         struct re_backref_cache_entry *bkref_ents ,
                                         int str_idx ) 
{ 
  reg_errcode_t err ;
  int node_idx ;
  int lim_idx ;
  int subexp_idx ;
  struct re_backref_cache_entry *ent ;
  int ops_node ;
  int cls_node ;
  int node ;
  re_token_type_t type ;
  long tmp ;
  int node___0 ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int node___1 ;
  re_token_type_t type___0 ;
  long tmp___3 ;

  {
#line 1836
  lim_idx = 0;
  {
  {
#line 1836
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1836
    if (! (lim_idx < limits->nelem)) {
#line 1836
      goto while_break;
    }
#line 1840
    ent = bkref_ents + *(limits->elems + lim_idx);
#line 1842
    if (str_idx <= ent->subexp_from) {
#line 1843
      goto __Cont;
    } else
#line 1842
    if (ent->str_idx < str_idx) {
#line 1843
      goto __Cont;
    }
#line 1845
    subexp_idx = (dfa->nodes + ent->node)->opr.idx - 1;
#line 1846
    if (ent->subexp_to == str_idx) {
#line 1848
      ops_node = -1;
#line 1849
      cls_node = -1;
#line 1850
      node_idx = 0;
      {
      {
#line 1850
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 1850
        if (! (node_idx < dest_nodes->nelem)) {
#line 1850
          goto while_break___0;
        }
#line 1852
        node = *(dest_nodes->elems + node_idx);
#line 1853
        type = (dfa->nodes + node)->type;
#line 1854
        if ((unsigned int )type == 23U) {
#line 1854
          if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 1856
            ops_node = node;
          } else {
#line 1854
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1857
        if ((unsigned int )type == 24U) {
#line 1857
          if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 1859
            cls_node = node;
          }
        }
#line 1850
        node_idx ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1864
      if (ops_node >= 0) {
        {
        {
#line 1866
        err = sub_epsilon_src_nodes(dfa, ops_node, dest_nodes, candidates);
        }
        {
#line 1868
        tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        }
#line 1868
        if (tmp) {
#line 1869
          return (err);
        }
      }
#line 1872
      node_idx = 0;
      {
      {
#line 1872
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 1872
        if (! (node_idx < dest_nodes->nelem)) {
#line 1872
          goto while_break___1;
        }
        {
#line 1874
        node___0 = *(dest_nodes->elems + node_idx);
        {
#line 1875
        tmp___1 = re_node_set_contains((re_node_set const   *)(dfa->inveclosures + node___0),
                                       cls_node);
        }
        }
#line 1875
        if (! tmp___1) {
          {
          {
#line 1875
          tmp___2 = re_node_set_contains((re_node_set const   *)(dfa->eclosures + node___0),
                                         cls_node);
          }
          }
#line 1875
          if (! tmp___2) {
            {
            {
#line 1880
            err = sub_epsilon_src_nodes(dfa, node___0, dest_nodes, candidates);
            }
            {
#line 1882
            tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
            }
            }
#line 1882
            if (tmp___0) {
#line 1883
              return (err);
            }
#line 1884
            node_idx --;
          }
        }
#line 1872
        node_idx ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 1890
      node_idx = 0;
      {
      {
#line 1890
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 1890
        if (! (node_idx < dest_nodes->nelem)) {
#line 1890
          goto while_break___2;
        }
#line 1892
        node___1 = *(dest_nodes->elems + node_idx);
#line 1893
        type___0 = (dfa->nodes + node___1)->type;
#line 1894
        if ((unsigned int )type___0 == 24U) {
#line 1894
          goto _L___2;
        } else
#line 1894
        if ((unsigned int )type___0 == 23U) {
          _L___2: /* CIL Label */ 
#line 1896
          if (subexp_idx != (dfa->nodes + node___1)->opr.idx) {
#line 1897
            goto __Cont___0;
          }
#line 1898
          if ((unsigned int )type___0 == 24U) {
#line 1898
            if (ent->subexp_to != str_idx) {
#line 1898
              goto _L___0;
            } else {
#line 1898
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 1898
          if ((unsigned int )type___0 == 23U) {
            _L___0: /* CIL Label */ 
            {
            {
#line 1903
            err = sub_epsilon_src_nodes(dfa, node___1, dest_nodes, candidates);
            }
            {
#line 1905
            tmp___3 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
            }
            }
#line 1905
            if (tmp___3) {
#line 1906
              return (err);
            }
          }
        }
        __Cont___0: /* CIL Label */ 
#line 1890
        node_idx ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1836
    lim_idx ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1912
  return ((reg_errcode_t )0);
}
}
#line 1915 "regexec.c"
static reg_errcode_t sift_states_bkref(regex_t const   *preg , re_match_context_t *mctx ,
                                       re_sift_context_t *sctx , int str_idx , re_node_set *dest_nodes ) 
{ 
  reg_errcode_t err ;
  re_dfa_t *dfa ;
  int node_idx ;
  int node ;
  re_sift_context_t local_sctx ;
  re_node_set const   *candidates ;
  int cur_bkref_idx ;
  re_token_type_t type ;
  int enabled_idx ;
  int tmp ;
  int disabled_idx ;
  int subexp_len ;
  int to_idx ;
  int dst_node ;
  struct re_backref_cache_entry *entry ;
  int tmp___0 ;
  int tmp___1 ;
  re_dfastate_t *cur_state ;
  struct re_backref_cache_entry *entry2 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  struct re_backref_cache_entry *entry___0 ;

  {
#line 1924
  dfa = (re_dfa_t *)preg->buffer;
#line 1928
  if ((unsigned long )*(mctx->state_log + str_idx) == (unsigned long )((void *)0)) {
#line 1928
    candidates = (re_node_set const   *)(& empty_set);
  } else {
#line 1928
    candidates = (re_node_set const   *)(& (*(mctx->state_log + str_idx))->nodes);
  }
#line 1930
  local_sctx.sifted_states = (re_dfastate_t **)((void *)0);
#line 1932
  node_idx = 0;
  {
  {
#line 1932
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1932
    if (! (node_idx < (int )candidates->nelem)) {
#line 1932
      goto while_break;
    }
#line 1934
    cur_bkref_idx = (mctx->input)->cur_idx;
#line 1936
    node = *(candidates->elems + node_idx);
#line 1937
    type = (dfa->nodes + node)->type;
#line 1938
    if (node == sctx->cur_bkref) {
#line 1938
      if (str_idx == cur_bkref_idx) {
#line 1939
        goto __Cont;
      }
    }
#line 1941
    if (node == sctx->last_node) {
#line 1941
      if (str_idx == sctx->last_str_idx) {
#line 1942
        goto __Cont;
      }
    }
#line 1943
    if ((unsigned int )type == 32U) {
      {
      {
#line 1945
      tmp = search_cur_bkref_entry(mctx, str_idx);
      }
#line 1945
      enabled_idx = tmp;
      }
      {
      {
#line 1946
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 1946
        if (! (enabled_idx < mctx->nbkref_ents)) {
#line 1946
          goto while_break___0;
        }
#line 1950
        entry = mctx->bkref_ents + enabled_idx;
#line 1951
        if (entry->str_idx > str_idx) {
#line 1952
          goto while_break___0;
        }
#line 1953
        if (entry->node != node) {
#line 1954
          goto __Cont___0;
        }
#line 1955
        subexp_len = entry->subexp_to - entry->subexp_from;
#line 1956
        to_idx = str_idx + subexp_len;
#line 1957
        if (subexp_len) {
#line 1957
          dst_node = *(dfa->nexts + node);
        } else {
#line 1957
          dst_node = *((dfa->edests + node)->elems + 0);
        }
#line 1960
        if (to_idx > sctx->last_str_idx) {
#line 1966
          goto __Cont___0;
        } else
#line 1960
        if ((unsigned long )*(sctx->sifted_states + to_idx) == (unsigned long )((void *)0)) {
#line 1966
          goto __Cont___0;
        } else
#line 1960
        if ((unsigned long )*(sctx->sifted_states + to_idx) != (unsigned long )((void *)0)) {
          {
          {
#line 1960
          tmp___0 = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + to_idx))->nodes),
                                         dst_node);
          }
          }
#line 1960
          if (tmp___0) {
            {
            {
#line 1960
            tmp___1 = check_dst_limits(dfa, & sctx->limits, mctx, node, str_idx, dst_node,
                                       to_idx);
            }
            }
#line 1960
            if (tmp___1) {
#line 1966
              goto __Cont___0;
            }
          } else {
#line 1966
            goto __Cont___0;
          }
        } else {
#line 1966
          goto __Cont___0;
        }
#line 1969
        entry->flag = 0;
#line 1970
        disabled_idx = enabled_idx + 1;
        {
        {
#line 1970
        while (1) {
          while_continue___5: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 1970
          if (! (disabled_idx < mctx->nbkref_ents)) {
#line 1970
            goto while_break___1;
          }
#line 1974
          entry2 = mctx->bkref_ents + disabled_idx;
#line 1975
          if (entry2->str_idx > str_idx) {
#line 1976
            goto while_break___1;
          }
#line 1977
          if (entry2->node == node) {
#line 1977
            entry2->flag = 1;
          } else {
#line 1977
            entry2->flag = entry2->flag;
          }
#line 1970
          disabled_idx ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1980
        if ((unsigned long )local_sctx.sifted_states == (unsigned long )((void *)0)) {
          {
#line 1982
          local_sctx = *sctx;
          {
#line 1983
          err = re_node_set_init_copy(& local_sctx.limits, (re_node_set const   *)(& sctx->limits));
          }
          {
#line 1985
          tmp___2 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
          }
          }
#line 1985
          if (tmp___2) {
#line 1986
            goto free_return;
          }
        }
        {
#line 1988
        local_sctx.last_node = node;
#line 1989
        local_sctx.last_str_idx = str_idx;
        {
#line 1990
        tmp___3 = re_node_set_insert(& local_sctx.limits, enabled_idx);
        }
#line 1990
        err = (reg_errcode_t )tmp___3;
        {
#line 1991
        tmp___4 = __builtin_expect((long )((unsigned int )err < 0U), 0L);
        }
        }
#line 1991
        if (tmp___4) {
#line 1993
          err = (reg_errcode_t )12;
#line 1994
          goto free_return;
        }
        {
#line 1996
        cur_state = *(local_sctx.sifted_states + str_idx);
        {
#line 1997
        err = sift_states_backward(preg, mctx, & local_sctx);
        }
        {
#line 1998
        tmp___5 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        }
#line 1998
        if (tmp___5) {
#line 1999
          goto free_return;
        }
#line 2000
        if ((unsigned long )sctx->limited_states != (unsigned long )((void *)0)) {
          {
          {
#line 2002
          err = merge_state_array(dfa, sctx->limited_states, local_sctx.sifted_states,
                                  str_idx + 1);
          }
          {
#line 2005
          tmp___6 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
          }
          }
#line 2005
          if (tmp___6) {
#line 2006
            goto free_return;
          }
        }
        {
#line 2008
        *(local_sctx.sifted_states + str_idx) = cur_state;
        {
#line 2009
        tmp___7 = re_node_set_contains((re_node_set const   *)(& local_sctx.limits),
                                       enabled_idx);
        }
        {
#line 2009
        re_node_set_remove_at(& local_sctx.limits, tmp___7 - 1);
        }
#line 2012
        (mctx->bkref_ents + enabled_idx)->flag = 1;
        }
        __Cont___0: /* CIL Label */ 
#line 1946
        enabled_idx ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      {
#line 2015
      enabled_idx = search_cur_bkref_entry(mctx, str_idx);
      }
      }
      {
      {
#line 2016
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 2016
        if (! (enabled_idx < mctx->nbkref_ents)) {
#line 2016
          goto while_break___2;
        }
#line 2019
        entry___0 = mctx->bkref_ents + enabled_idx;
#line 2020
        if (entry___0->str_idx > str_idx) {
#line 2021
          goto while_break___2;
        }
#line 2022
        if (entry___0->node == node) {
#line 2023
          entry___0->flag = 0;
        }
#line 2016
        enabled_idx ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1932
    node_idx ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2027
  err = (reg_errcode_t )0;
  free_return: 
#line 2029
  if ((unsigned long )local_sctx.sifted_states != (unsigned long )((void *)0)) {
    {
    {
#line 2031
    free((void *)local_sctx.limits.elems);
    }
    }
  }
#line 2034
  return (err);
}
}
#line 2039 "regexec.c"
static int sift_states_iter_mb(regex_t const   *preg , re_match_context_t const   *mctx ,
                               re_sift_context_t *sctx , int node_idx , int str_idx ,
                               int max_str_idx ) 
{ 
  re_dfa_t *dfa ;
  int naccepted ;
  int tmp ;

  {
  {
#line 2046
  dfa = (re_dfa_t *)preg->buffer;
  {
#line 2049
  naccepted = check_node_accept_bytes(preg, node_idx, (re_string_t const   *)mctx->input,
                                      str_idx);
  }
  }
#line 2050
  if (naccepted > 0) {
#line 2050
    if (str_idx + naccepted <= max_str_idx) {
#line 2050
      if ((unsigned long )*(sctx->sifted_states + (str_idx + naccepted)) != (unsigned long )((void *)0)) {
        {
        {
#line 2050
        tmp = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + (str_idx + naccepted)))->nodes),
                                   *(dfa->nexts + node_idx));
        }
        }
#line 2050
        if (! tmp) {
#line 2056
          naccepted = 0;
        }
      } else {
#line 2056
        naccepted = 0;
      }
    }
  }
#line 2059
  return (naccepted);
}
}
#line 2071 "regexec.c"
static re_dfastate_t *transit_state(reg_errcode_t *err , regex_t const   *preg , re_match_context_t *mctx ,
                                    re_dfastate_t *state , int fl_search ) 
{ 
  re_dfa_t *dfa ;
  re_dfastate_t **trtable ;
  re_dfastate_t *next_state ;
  unsigned char ch ;
  int cur_idx ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  re_dfastate_t *pstate ;
  unsigned int context ;
  re_node_set next_nodes ;
  re_node_set *log_nodes ;
  re_node_set *table_nodes ;
  long tmp___4 ;
  re_dfastate_t *tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
#line 2079
  dfa = (re_dfa_t *)preg->buffer;
#line 2084
  if ((mctx->input)->cur_idx + 1 >= (mctx->input)->bufs_len) {
#line 2084
    goto _L;
  } else
#line 2084
  if ((mctx->input)->cur_idx + 1 >= (mctx->input)->valid_len) {
#line 2084
    if ((mctx->input)->valid_len < (mctx->input)->len) {
      _L: /* CIL Label */ 
      {
      {
#line 2088
      *err = extend_buffers(mctx);
      }
      {
#line 2089
      tmp = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
      }
      }
#line 2089
      if (tmp) {
#line 2090
        return ((re_dfastate_t *)((void *)0));
      }
    }
  }
#line 2093
  *err = (reg_errcode_t )0;
#line 2094
  if ((unsigned long )state == (unsigned long )((void *)0)) {
#line 2096
    next_state = state;
#line 2097
    ((mctx->input)->cur_idx) ++;
  } else {
#line 2103
    if (state->accept_mb) {
      {
      {
#line 2105
      *err = transit_state_mb(preg, state, mctx);
      }
      {
#line 2106
      tmp___0 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
      }
      }
#line 2106
      if (tmp___0) {
#line 2107
        return ((re_dfastate_t *)((void *)0));
      }
    }
#line 2115
    tmp___1 = (mctx->input)->cur_idx;
#line 2115
    ((mctx->input)->cur_idx) ++;
#line 2115
    ch = *((mctx->input)->mbs + tmp___1);
#line 2116
    if (fl_search) {
#line 2116
      trtable = state->trtable_search;
    } else {
#line 2116
      trtable = state->trtable;
    }
#line 2117
    if ((unsigned long )trtable == (unsigned long )((void *)0)) {
      {
      {
#line 2119
      trtable = build_trtable(preg, (re_dfastate_t const   *)state, fl_search);
      }
      }
#line 2120
      if (fl_search) {
#line 2121
        state->trtable_search = trtable;
      } else {
#line 2123
        state->trtable = trtable;
      }
    }
#line 2125
    next_state = *(trtable + ch);
  }
#line 2136
  cur_idx = (mctx->input)->cur_idx;
#line 2138
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
#line 2140
    if (cur_idx > mctx->state_log_top) {
#line 2142
      *(mctx->state_log + cur_idx) = next_state;
#line 2143
      mctx->state_log_top = cur_idx;
    } else
#line 2145
    if ((unsigned long )*(mctx->state_log + cur_idx) == (unsigned long )((re_dfastate_t *)0)) {
#line 2147
      *(mctx->state_log + cur_idx) = next_state;
    } else {
#line 2153
      table_nodes = (re_node_set *)((void *)0);
#line 2158
      pstate = *(mctx->state_log + cur_idx);
#line 2159
      log_nodes = pstate->entrance_nodes;
#line 2160
      if ((unsigned long )next_state != (unsigned long )((void *)0)) {
        {
#line 2162
        table_nodes = next_state->entrance_nodes;
        {
#line 2163
        *err = re_node_set_init_union(& next_nodes, (re_node_set const   *)table_nodes,
                                      (re_node_set const   *)log_nodes);
        }
        {
#line 2165
        tmp___4 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
        }
        }
#line 2165
        if (tmp___4) {
#line 2166
          return ((re_dfastate_t *)((void *)0));
        }
      } else {
#line 2169
        next_nodes = *log_nodes;
      }
      {
      {
#line 2173
      context = re_string_context_at((re_string_t const   *)mctx->input, (mctx->input)->cur_idx - 1,
                                     mctx->eflags, (int )preg->newline_anchor);
      }
      {
#line 2176
      tmp___5 = re_acquire_state_context(err, dfa, (re_node_set const   *)(& next_nodes),
                                         context);
      }
#line 2176
      *(mctx->state_log + cur_idx) = tmp___5;
#line 2176
      next_state = tmp___5;
      }
#line 2181
      if ((unsigned long )table_nodes != (unsigned long )((void *)0)) {
        {
        {
#line 2182
        free((void *)next_nodes.elems);
        }
        }
      }
    }
  }
#line 2189
  if (dfa->nbackref) {
#line 2189
    if (next_state) {
      {
      {
#line 2191
      *err = check_subexp_matching_top(dfa, mctx, & next_state->nodes, cur_idx);
      }
      {
#line 2193
      tmp___6 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
      }
      }
#line 2193
      if (tmp___6) {
#line 2194
        return ((re_dfastate_t *)((void *)0));
      }
    }
  }
#line 2198
  if ((unsigned long )next_state != (unsigned long )((void *)0)) {
#line 2198
    if (next_state->has_backref) {
      {
      {
#line 2200
      *err = transit_state_bkref(preg, & next_state->nodes, mctx);
      }
      {
#line 2201
      tmp___7 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
      }
      }
#line 2201
      if (tmp___7) {
#line 2202
        return ((re_dfastate_t *)((void *)0));
      }
#line 2203
      next_state = *(mctx->state_log + cur_idx);
    }
  }
#line 2205
  return (next_state);
}
}
#line 2215 "regexec.c"
static reg_errcode_t check_subexp_matching_top(re_dfa_t *dfa , re_match_context_t *mctx ,
                                               re_node_set *cur_nodes , int str_idx ) 
{ 
  int node_idx ;
  reg_errcode_t err ;
  int node ;
  long tmp ;

  {
#line 2230
  node_idx = 0;
  {
  {
#line 2230
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2230
    if (! (node_idx < cur_nodes->nelem)) {
#line 2230
      goto while_break;
    }
#line 2232
    node = *(cur_nodes->elems + node_idx);
#line 2233
    if ((unsigned int )(dfa->nodes + node)->type == 23U) {
#line 2233
      if ((unsigned long )(dfa->nodes + node)->opr.idx < 8UL * sizeof(dfa->used_bkref_map)) {
#line 2233
        if (dfa->used_bkref_map & (unsigned int )(1 << (dfa->nodes + node)->opr.idx)) {
          {
          {
#line 2237
          err = match_ctx_add_subtop(mctx, node, str_idx);
          }
          {
#line 2238
          tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
          }
          }
#line 2238
          if (tmp) {
#line 2239
            return (err);
          }
        }
      }
    }
#line 2230
    node_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2242
  return ((reg_errcode_t )0);
}
}
#line 2314 "regexec.c"
static reg_errcode_t transit_state_mb(regex_t const   *preg , re_dfastate_t *pstate ,
                                      re_match_context_t *mctx ) 
{ 
  reg_errcode_t err ;
  re_dfa_t *dfa ;
  int i ;
  re_node_set dest_nodes ;
  re_node_set *new_nodes ;
  int cur_node_idx ;
  int naccepted ;
  int dest_idx ;
  unsigned int context ;
  re_dfastate_t *dest_state ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 2321
  dfa = (re_dfa_t *)preg->buffer;
#line 2324
  i = 0;
  {
  {
#line 2324
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2324
    if (! (i < pstate->nodes.nelem)) {
#line 2324
      goto while_break;
    }
#line 2327
    cur_node_idx = *(pstate->nodes.elems + i);
#line 2328
    naccepted = 0;
#line 2332
    if ((dfa->nodes + cur_node_idx)->constraint) {
      {
      {
#line 2334
      context = re_string_context_at((re_string_t const   *)mctx->input, (mctx->input)->cur_idx,
                                     mctx->eflags, (int )preg->newline_anchor);
      }
      }
#line 2337
      if ((dfa->nodes + cur_node_idx)->constraint & 4U) {
#line 2337
        if (! (context & 1U)) {
#line 2339
          goto __Cont;
        } else {
#line 2337
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 2337
      if ((dfa->nodes + cur_node_idx)->constraint & 8U) {
#line 2337
        if (context & 1U) {
#line 2339
          goto __Cont;
        } else {
#line 2337
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2337
      if ((dfa->nodes + cur_node_idx)->constraint & 32U) {
#line 2337
        if (! (context & (unsigned int )(1 << 1))) {
#line 2339
          goto __Cont;
        } else {
#line 2337
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2337
      if ((dfa->nodes + cur_node_idx)->constraint & 128U) {
#line 2337
        if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 2339
          goto __Cont;
        }
      }
    }
#line 2343
    if ((unsigned int )(dfa->nodes + cur_node_idx)->type == 22U) {
      {
      {
#line 2344
      naccepted = check_node_accept_bytes(preg, cur_node_idx, (re_string_t const   *)mctx->input,
                                          (mctx->input)->cur_idx);
      }
      }
    } else
#line 2343
    if ((unsigned int )(dfa->nodes + cur_node_idx)->type == 25U) {
      {
      {
#line 2344
      naccepted = check_node_accept_bytes(preg, cur_node_idx, (re_string_t const   *)mctx->input,
                                          (mctx->input)->cur_idx);
      }
      }
    }
#line 2346
    if (naccepted == 0) {
#line 2347
      goto __Cont;
    }
#line 2350
    dest_idx = (mctx->input)->cur_idx + naccepted;
#line 2351
    if (mctx->max_mb_elem_len < naccepted) {
#line 2351
      mctx->max_mb_elem_len = naccepted;
    } else {
#line 2351
      mctx->max_mb_elem_len = mctx->max_mb_elem_len;
    }
    {
    {
#line 2353
    err = clean_state_log_if_need(mctx, dest_idx);
    }
    {
#line 2354
    tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    }
#line 2354
    if (tmp) {
#line 2355
      return (err);
    }
#line 2361
    new_nodes = dfa->eclosures + *(dfa->nexts + *(pstate->nodes.elems + i));
#line 2363
    dest_state = *(mctx->state_log + dest_idx);
#line 2364
    if ((unsigned long )dest_state == (unsigned long )((void *)0)) {
#line 2365
      dest_nodes = *new_nodes;
    } else {
      {
      {
#line 2368
      err = re_node_set_init_union(& dest_nodes, (re_node_set const   *)dest_state->entrance_nodes,
                                   (re_node_set const   *)new_nodes);
      }
      {
#line 2370
      tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 2370
      if (tmp___0) {
#line 2371
        return (err);
      }
    }
    {
    {
#line 2373
    context = re_string_context_at((re_string_t const   *)mctx->input, dest_idx - 1,
                                   mctx->eflags, (int )preg->newline_anchor);
    }
    {
#line 2375
    *(mctx->state_log + dest_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& dest_nodes),
                                                             context);
    }
    }
#line 2377
    if ((unsigned long )dest_state != (unsigned long )((void *)0)) {
      {
      {
#line 2378
      free((void *)dest_nodes.elems);
      }
      }
    }
#line 2379
    if ((unsigned long )*(mctx->state_log + dest_idx) == (unsigned long )((void *)0)) {
#line 2379
      if ((unsigned int )err != 0U) {
#line 2379
        tmp___1 = 1;
      } else {
#line 2379
        tmp___1 = 0;
      }
    } else {
#line 2379
      tmp___1 = 0;
    }
    {
    {
#line 2379
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    }
#line 2379
    if (tmp___2) {
#line 2380
      return (err);
    }
    __Cont: /* CIL Label */ 
#line 2324
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2382
  return ((reg_errcode_t )0);
}
}
#line 2386 "regexec.c"
static reg_errcode_t transit_state_bkref(regex_t const   *preg , re_node_set *nodes ,
                                         re_match_context_t *mctx ) 
{ 
  reg_errcode_t err ;
  re_dfa_t *dfa ;
  int i ;
  int cur_str_idx ;
  int dest_str_idx ;
  int prev_nelem ;
  int bkc_idx ;
  int node_idx ;
  unsigned int context ;
  re_token_t *node ;
  re_node_set *new_dest_nodes ;
  long tmp ;
  int subexp_len ;
  re_dfastate_t *dest_state ;
  struct re_backref_cache_entry *bkref_ent ;
  int tmp___0 ;
  long tmp___1 ;
  re_node_set dest_nodes ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 2393
  dfa = (re_dfa_t *)preg->buffer;
#line 2395
  cur_str_idx = (mctx->input)->cur_idx;
#line 2397
  i = 0;
  {
  {
#line 2397
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2397
    if (! (i < nodes->nelem)) {
#line 2397
      goto while_break;
    }
#line 2400
    node_idx = *(nodes->elems + i);
#line 2402
    node = dfa->nodes + node_idx;
#line 2406
    if ((unsigned int )node->type != 32U) {
#line 2407
      goto __Cont;
    }
#line 2409
    if (node->constraint) {
      {
      {
#line 2411
      context = re_string_context_at((re_string_t const   *)mctx->input, cur_str_idx,
                                     mctx->eflags, (int )preg->newline_anchor);
      }
      }
#line 2413
      if (node->constraint & 4U) {
#line 2413
        if (! (context & 1U)) {
#line 2414
          goto __Cont;
        } else {
#line 2413
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 2413
      if (node->constraint & 8U) {
#line 2413
        if (context & 1U) {
#line 2414
          goto __Cont;
        } else {
#line 2413
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2413
      if (node->constraint & 32U) {
#line 2413
        if (! (context & (unsigned int )(1 << 1))) {
#line 2414
          goto __Cont;
        } else {
#line 2413
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2413
      if (node->constraint & 128U) {
#line 2413
        if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 2414
          goto __Cont;
        }
      }
    }
    {
#line 2419
    bkc_idx = mctx->nbkref_ents;
    {
#line 2420
    err = get_subexp(preg, mctx, node_idx, cur_str_idx);
    }
    {
#line 2421
    tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    }
#line 2421
    if (tmp) {
#line 2422
      goto free_return;
    }
    {
    {
#line 2429
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 2429
      if (! (bkc_idx < mctx->nbkref_ents)) {
#line 2429
        goto while_break___0;
      }
#line 2434
      bkref_ent = mctx->bkref_ents + bkc_idx;
#line 2435
      if (bkref_ent->node != node_idx) {
#line 2436
        goto __Cont___0;
      } else
#line 2435
      if (bkref_ent->str_idx != cur_str_idx) {
#line 2436
        goto __Cont___0;
      }
#line 2437
      subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;
#line 2438
      if (subexp_len == 0) {
#line 2438
        new_dest_nodes = dfa->eclosures + *((dfa->edests + node_idx)->elems + 0);
      } else {
#line 2438
        new_dest_nodes = dfa->eclosures + *(dfa->nexts + node_idx);
      }
      {
#line 2441
      dest_str_idx = (cur_str_idx + bkref_ent->subexp_to) - bkref_ent->subexp_from;
      {
#line 2443
      context = re_string_context_at((re_string_t const   *)mctx->input, dest_str_idx - 1,
                                     mctx->eflags, (int )preg->newline_anchor);
      }
#line 2445
      dest_state = *(mctx->state_log + dest_str_idx);
      }
#line 2446
      if ((unsigned long )*(mctx->state_log + cur_str_idx) == (unsigned long )((void *)0)) {
#line 2446
        prev_nelem = 0;
      } else {
#line 2446
        prev_nelem = (*(mctx->state_log + cur_str_idx))->nodes.nelem;
      }
#line 2449
      if ((unsigned long )dest_state == (unsigned long )((void *)0)) {
        {
        {
#line 2451
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)new_dest_nodes,
                                                                     context);
        }
        }
#line 2454
        if ((unsigned long )*(mctx->state_log + dest_str_idx) == (unsigned long )((void *)0)) {
#line 2454
          if ((unsigned int )err != 0U) {
#line 2454
            tmp___0 = 1;
          } else {
#line 2454
            tmp___0 = 0;
          }
        } else {
#line 2454
          tmp___0 = 0;
        }
        {
        {
#line 2454
        tmp___1 = __builtin_expect((long )tmp___0, 0L);
        }
        }
#line 2454
        if (tmp___1) {
#line 2456
          goto free_return;
        }
      } else {
        {
        {
#line 2461
        err = re_node_set_init_union(& dest_nodes, (re_node_set const   *)dest_state->entrance_nodes,
                                     (re_node_set const   *)new_dest_nodes);
        }
        {
#line 2464
        tmp___2 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        }
#line 2464
        if (tmp___2) {
          {
          {
#line 2466
          free((void *)dest_nodes.elems);
          }
          }
#line 2467
          goto free_return;
        }
        {
        {
#line 2469
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& dest_nodes),
                                                                     context);
        }
        {
#line 2471
        free((void *)dest_nodes.elems);
        }
        }
#line 2472
        if ((unsigned long )*(mctx->state_log + dest_str_idx) == (unsigned long )((void *)0)) {
#line 2472
          if ((unsigned int )err != 0U) {
#line 2472
            tmp___3 = 1;
          } else {
#line 2472
            tmp___3 = 0;
          }
        } else {
#line 2472
          tmp___3 = 0;
        }
        {
        {
#line 2472
        tmp___4 = __builtin_expect((long )tmp___3, 0L);
        }
        }
#line 2472
        if (tmp___4) {
#line 2474
          goto free_return;
        }
      }
#line 2478
      if (subexp_len == 0) {
#line 2478
        if ((*(mctx->state_log + cur_str_idx))->nodes.nelem > prev_nelem) {
          {
          {
#line 2481
          err = check_subexp_matching_top(dfa, mctx, new_dest_nodes, cur_str_idx);
          }
          {
#line 2483
          tmp___5 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
          }
          }
#line 2483
          if (tmp___5) {
#line 2484
            goto free_return;
          }
          {
          {
#line 2485
          err = transit_state_bkref(preg, new_dest_nodes, mctx);
          }
          {
#line 2486
          tmp___6 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
          }
          }
#line 2486
          if (tmp___6) {
#line 2487
            goto free_return;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 2429
      bkc_idx ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2397
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2491
  err = (reg_errcode_t )0;
  free_return: 
#line 2493
  return (err);
}
}
#line 2502 "regexec.c"
static reg_errcode_t get_subexp(regex_t const   *preg , re_match_context_t *mctx ,
                                int bkref_node , int bkref_str_idx ) 
{ 
  int subexp_num ;
  int sub_top_idx ;
  re_dfa_t *dfa ;
  char *buf ;
  int cache_idx ;
  int tmp ;
  struct re_backref_cache_entry *entry ;
  reg_errcode_t err ;
  re_sub_match_top_t *sub_top ;
  re_sub_match_last_t *sub_last ;
  int sub_last_idx ;
  int sl_str ;
  char *bkref_str ;
  int sl_str_diff ;
  int tmp___0 ;
  long tmp___1 ;
  int cls_node ;
  int sl_str_off ;
  re_node_set *nodes ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  {
#line 2509
  dfa = (re_dfa_t *)preg->buffer;
#line 2510
  buf = (char *)(mctx->input)->mbs;
  {
#line 2512
  tmp = search_cur_bkref_entry(mctx, bkref_str_idx);
  }
#line 2512
  cache_idx = tmp;
  }
  {
  {
#line 2513
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2513
    if (! (cache_idx < mctx->nbkref_ents)) {
#line 2513
      goto while_break;
    }
#line 2515
    entry = mctx->bkref_ents + cache_idx;
#line 2516
    if (entry->str_idx > bkref_str_idx) {
#line 2517
      goto while_break;
    }
#line 2518
    if (entry->node == bkref_node) {
#line 2519
      return ((reg_errcode_t )0);
    }
#line 2513
    cache_idx ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2521
  subexp_num = (dfa->nodes + bkref_node)->opr.idx - 1;
#line 2524
  sub_top_idx = 0;
  {
  {
#line 2524
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 2524
    if (! (sub_top_idx < mctx->nsub_tops)) {
#line 2524
      goto while_break___0;
    }
#line 2527
    sub_top = *(mctx->sub_tops + sub_top_idx);
#line 2532
    if ((dfa->nodes + sub_top->node)->opr.idx != subexp_num) {
#line 2533
      goto __Cont;
    }
#line 2535
    sl_str = sub_top->str_idx;
#line 2536
    bkref_str = buf + bkref_str_idx;
#line 2539
    sub_last_idx = 0;
    {
    {
#line 2539
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 2539
      if (! (sub_last_idx < sub_top->nlasts)) {
#line 2539
        goto while_break___1;
      }
#line 2542
      sub_last = *(sub_top->lasts + sub_last_idx);
#line 2543
      sl_str_diff = sub_last->str_idx - sl_str;
#line 2546
      if (sl_str_diff > 0) {
        {
        {
#line 2546
        tmp___0 = memcmp((void const   *)bkref_str, (void const   *)(buf + sl_str),
                         (size_t )sl_str_diff);
        }
        }
#line 2546
        if (tmp___0 != 0) {
#line 2548
          goto while_break___1;
        }
      }
      {
#line 2549
      bkref_str += sl_str_diff;
#line 2550
      sl_str += sl_str_diff;
      {
#line 2551
      err = get_subexp_sub(preg, mctx, sub_top, sub_last, bkref_node, bkref_str_idx);
      }
      }
#line 2553
      if ((unsigned int )err == 1U) {
#line 2554
        goto __Cont___0;
      }
      {
      {
#line 2555
      tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 2555
      if (tmp___1) {
#line 2556
        return (err);
      }
      __Cont___0: /* CIL Label */ 
#line 2539
      sub_last_idx ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2558
    if (sub_last_idx < sub_top->nlasts) {
#line 2559
      goto __Cont;
    }
#line 2560
    if (sub_last_idx > 0) {
#line 2561
      sl_str ++;
    }
    {
    {
#line 2563
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 2563
      if (! (sl_str <= bkref_str_idx)) {
#line 2563
        goto while_break___2;
      }
#line 2567
      sl_str_off = sl_str - sub_top->str_idx;
#line 2570
      if (sl_str_off > 0) {
        {
#line 2570
        tmp___2 = bkref_str;
#line 2570
        bkref_str ++;
        {
#line 2570
        tmp___3 = memcmp((void const   *)tmp___2, (void const   *)((buf + sl_str) - 1),
                         (size_t )1);
        }
        }
#line 2570
        if (tmp___3 != 0) {
#line 2572
          goto while_break___2;
        }
      }
#line 2573
      if ((unsigned long )*(mctx->state_log + sl_str) == (unsigned long )((void *)0)) {
#line 2574
        goto __Cont___1;
      }
      {
#line 2576
      nodes = & (*(mctx->state_log + sl_str))->nodes;
      {
#line 2577
      cls_node = find_subexp_node(dfa, nodes, subexp_num, 0);
      }
      }
#line 2578
      if (cls_node == -1) {
#line 2579
        goto __Cont___1;
      }
#line 2580
      if ((unsigned long )sub_top->path == (unsigned long )((void *)0)) {
        {
        {
#line 2582
        tmp___4 = calloc((size_t )sizeof(state_array_t ), (size_t )((sl_str - sub_top->str_idx) + 1));
        }
#line 2582
        sub_top->path = (state_array_t *)tmp___4;
        }
#line 2584
        if ((unsigned long )sub_top->path == (unsigned long )((void *)0)) {
#line 2585
          return ((reg_errcode_t )12);
        }
      }
      {
      {
#line 2589
      err = check_arrival(preg, mctx, sub_top->path, sub_top->node, sub_top->str_idx,
                          cls_node, sl_str, 0);
      }
      }
#line 2591
      if ((unsigned int )err == 1U) {
#line 2592
        goto __Cont___1;
      }
      {
      {
#line 2593
      tmp___5 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 2593
      if (tmp___5) {
#line 2594
        return (err);
      }
      {
      {
#line 2595
      sub_last = match_ctx_add_sublast(sub_top, cls_node, sl_str);
      }
      {
#line 2596
      tmp___6 = __builtin_expect((long )((unsigned long )sub_last == (unsigned long )((void *)0)),
                                 0L);
      }
      }
#line 2596
      if (tmp___6) {
#line 2597
        return ((reg_errcode_t )12);
      }
      {
      {
#line 2598
      err = get_subexp_sub(preg, mctx, sub_top, sub_last, bkref_node, bkref_str_idx);
      }
      }
#line 2600
      if ((unsigned int )err == 1U) {

      }
      __Cont___1: /* CIL Label */ 
#line 2563
      sl_str ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2524
    sub_top_idx ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2604
  return ((reg_errcode_t )0);
}
}
#line 2613 "regexec.c"
static reg_errcode_t get_subexp_sub(regex_t const   *preg , re_match_context_t *mctx ,
                                    re_sub_match_top_t *sub_top , re_sub_match_last_t *sub_last ,
                                    int bkref_node , int bkref_str ) 
{ 
  reg_errcode_t err ;
  int to_idx ;
  long tmp ;

  {
  {
  {
#line 2624
  err = check_arrival(preg, mctx, & sub_last->path, sub_last->node, sub_last->str_idx,
                      bkref_node, bkref_str, 1);
  }
  }
#line 2626
  if ((unsigned int )err != 0U) {
#line 2627
    return (err);
  }
  {
  {
#line 2628
  err = match_ctx_add_entry(mctx, bkref_node, bkref_str, sub_top->str_idx, sub_last->str_idx);
  }
  {
#line 2630
  tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 2630
  if (tmp) {
#line 2631
    return (err);
  }
  {
#line 2632
  to_idx = (bkref_str + sub_last->str_idx) - sub_top->str_idx;
  {
#line 2633
  clean_state_log_if_need(mctx, to_idx);
  }
  }
#line 2634
  return ((reg_errcode_t )0);
}
}
#line 2645 "regexec.c"
static int find_subexp_node(re_dfa_t *dfa , re_node_set *nodes , int subexp_idx ,
                            int fl_open ) 
{ 
  int cls_idx ;
  int cls_node ;
  re_token_t *node ;

  {
#line 2652
  cls_idx = 0;
  {
  {
#line 2652
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2652
    if (! (cls_idx < nodes->nelem)) {
#line 2652
      goto while_break;
    }
#line 2654
    cls_node = *(nodes->elems + cls_idx);
#line 2655
    node = dfa->nodes + cls_node;
#line 2656
    if (fl_open) {
#line 2656
      if ((unsigned int )node->type == 23U) {
#line 2656
        goto _L;
      } else {
#line 2656
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2656
    if (! fl_open) {
#line 2656
      if ((unsigned int )node->type == 24U) {
        _L: /* CIL Label */ 
#line 2656
        if (node->opr.idx == subexp_idx) {
#line 2659
          return (cls_node);
        }
      }
    }
#line 2652
    cls_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2661
  return (-1);
}
}
#line 2669 "regexec.c"
static reg_errcode_t check_arrival(regex_t const   *preg , re_match_context_t *mctx ,
                                   state_array_t *path , int top_node , int top_str ,
                                   int last_node , int last_str , int fl_open ) 
{ 
  re_dfa_t *dfa ;
  reg_errcode_t err ;
  int subexp_num ;
  int backup_cur_idx ;
  int str_idx ;
  int null_cnt ;
  re_dfastate_t *cur_state ;
  re_node_set *cur_nodes ;
  re_node_set next_nodes ;
  re_dfastate_t **backup_state_log ;
  unsigned int context ;
  re_dfastate_t **new_array ;
  int old_alloc ;
  void *tmp ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_61 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  void *__s___2 ;
  void *__s___3 ;
  union __anonunion___u_62 *__u___0 ;
  __uint8_t __c___0 ;
  void *__s___4 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 2677
  dfa = (re_dfa_t *)preg->buffer;
#line 2680
  cur_state = (re_dfastate_t *)((void *)0);
#line 2685
  subexp_num = (dfa->nodes + top_node)->opr.idx;
#line 2687
  if (path->alloc < (last_str + mctx->max_mb_elem_len) + 1) {
    {
#line 2690
    old_alloc = path->alloc;
#line 2691
    path->alloc += (last_str + mctx->max_mb_elem_len) + 1;
    {
#line 2692
    tmp = realloc((void *)path->array, (size_t )((unsigned long )path->alloc * sizeof(re_dfastate_t *)));
    }
#line 2692
    new_array = (re_dfastate_t **)tmp;
    }
#line 2693
    if ((unsigned long )new_array == (unsigned long )((void *)0)) {
#line 2694
      return ((reg_errcode_t )12);
    }
#line 2695
    path->array = new_array;
#line 2696
    if (0) {
#line 2696
      if (sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc) == 1UL) {
#line 2696
        __s___1 = (void *)(new_array + old_alloc);
#line 2696
        *((__uint8_t *)__s___1) = (__uint8_t )'\000';
      } else {
#line 2696
        __s___0 = (void *)(new_array + old_alloc);
#line 2696
        __u = (union __anonunion___u_61 *)__s___0;
#line 2696
        __c = (__uint8_t )'\000';
        {
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 15U) {
#line 2696
          goto case_15;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 11U) {
#line 2696
          goto case_11;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 7U) {
#line 2696
          goto case_7;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 3U) {
#line 2696
          goto case_3;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 14U) {
#line 2696
          goto case_14;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 10U) {
#line 2696
          goto case_10;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 6U) {
#line 2696
          goto case_6;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 2U) {
#line 2696
          goto case_2;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 13U) {
#line 2696
          goto case_13;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 9U) {
#line 2696
          goto case_9;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 5U) {
#line 2696
          goto case_5;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 1U) {
#line 2696
          goto case_1;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 16U) {
#line 2696
          goto case_16;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 12U) {
#line 2696
          goto case_12;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 8U) {
#line 2696
          goto case_8;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 4U) {
#line 2696
          goto case_4;
        }
#line 2696
        if ((unsigned int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)) == 0U) {
#line 2696
          goto case_0;
        }
#line 2696
        goto switch_break;
        case_15: /* CIL Label */ 
#line 2696
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2696
        __u = (union __anonunion___u_61 *)((void *)__u + 4);
        case_11: /* CIL Label */ 
#line 2696
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2696
        __u = (union __anonunion___u_61 *)((void *)__u + 4);
        case_7: /* CIL Label */ 
#line 2696
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2696
        __u = (union __anonunion___u_61 *)((void *)__u + 4);
        case_3: /* CIL Label */ 
#line 2696
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 2696
        __u = (union __anonunion___u_61 *)((void *)__u + 2);
#line 2696
        __u->__uc = __c;
#line 2696
        goto switch_break;
        case_14: /* CIL Label */ 
#line 2696
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2696
        __u = (union __anonunion___u_61 *)((void *)__u + 4);
        case_10: /* CIL Label */ 
#line 2696
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2696
        __u = (union __anonunion___u_61 *)((void *)__u + 4);
        case_6: /* CIL Label */ 
#line 2696
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2696
        __u = (union __anonunion___u_61 *)((void *)__u + 4);
        case_2: /* CIL Label */ 
#line 2696
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 2696
        goto switch_break;
        case_13: /* CIL Label */ 
#line 2696
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2696
        __u = (union __anonunion___u_61 *)((void *)__u + 4);
        case_9: /* CIL Label */ 
#line 2696
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2696
        __u = (union __anonunion___u_61 *)((void *)__u + 4);
        case_5: /* CIL Label */ 
#line 2696
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2696
        __u = (union __anonunion___u_61 *)((void *)__u + 4);
        case_1: /* CIL Label */ 
#line 2696
        __u->__uc = __c;
#line 2696
        goto switch_break;
        case_16: /* CIL Label */ 
#line 2696
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2696
        __u = (union __anonunion___u_61 *)((void *)__u + 4);
        case_12: /* CIL Label */ 
#line 2696
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2696
        __u = (union __anonunion___u_61 *)((void *)__u + 4);
        case_8: /* CIL Label */ 
#line 2696
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2696
        __u = (union __anonunion___u_61 *)((void *)__u + 4);
        case_4: /* CIL Label */ 
#line 2696
        __u->__ui = (unsigned int )((int )__c * 16843009);
        case_0: /* CIL Label */ 
#line 2696
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 2696
      __s = (void *)(new_array + old_alloc);
      {
#line 2696
      __builtin_memset(__s, '\000', (int )(sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc)));
      }
      }
    }
  }
#line 2700
  if (path->next_idx == 0) {
#line 2700
    str_idx = top_str;
  } else {
#line 2700
    str_idx = path->next_idx;
  }
  {
#line 2703
  backup_state_log = mctx->state_log;
#line 2704
  backup_cur_idx = (mctx->input)->cur_idx;
#line 2705
  mctx->state_log = path->array;
#line 2706
  (mctx->input)->cur_idx = str_idx;
  {
#line 2709
  context = re_string_context_at((re_string_t const   *)mctx->input, str_idx - 1,
                                 mctx->eflags, (int )preg->newline_anchor);
  }
  }
#line 2711
  if (str_idx == top_str) {
    {
    {
#line 2713
    err = re_node_set_init_1(& next_nodes, top_node);
    }
    {
#line 2714
    tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    }
#line 2714
    if (tmp___0) {
#line 2715
      return (err);
    }
    {
    {
#line 2716
    err = check_arrival_expand_ecl(dfa, & next_nodes, subexp_num, fl_open);
    }
    {
#line 2717
    tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    }
#line 2717
    if (tmp___1) {
      {
      {
#line 2719
      free((void *)next_nodes.elems);
      }
      }
#line 2720
      return (err);
    }
  } else {
#line 2725
    cur_state = *(mctx->state_log + str_idx);
#line 2726
    if (cur_state) {
#line 2726
      if (cur_state->has_backref) {
        {
        {
#line 2728
        err = re_node_set_init_copy(& next_nodes, (re_node_set const   *)(& cur_state->nodes));
        }
        {
#line 2729
        tmp___2 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        }
#line 2729
        if (tmp___2) {
#line 2730
          return (err);
        }
      } else {
#line 2726
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2733
    if (sizeof(re_node_set ) <= 16UL) {
#line 2733
      if (sizeof(re_node_set ) == 1UL) {
#line 2733
        __s___4 = (void *)(& next_nodes);
#line 2733
        *((__uint8_t *)__s___4) = (__uint8_t )'\000';
      } else {
#line 2733
        __s___3 = (void *)(& next_nodes);
#line 2733
        __u___0 = (union __anonunion___u_62 *)__s___3;
#line 2733
        __c___0 = (__uint8_t )'\000';
        {
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 15U) {
#line 2733
          goto case_15___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 11U) {
#line 2733
          goto case_11___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 7U) {
#line 2733
          goto case_7___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 3U) {
#line 2733
          goto case_3___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 14U) {
#line 2733
          goto case_14___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 10U) {
#line 2733
          goto case_10___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 6U) {
#line 2733
          goto case_6___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 2U) {
#line 2733
          goto case_2___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 13U) {
#line 2733
          goto case_13___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 9U) {
#line 2733
          goto case_9___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 5U) {
#line 2733
          goto case_5___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 1U) {
#line 2733
          goto case_1___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 16U) {
#line 2733
          goto case_16___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 12U) {
#line 2733
          goto case_12___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 8U) {
#line 2733
          goto case_8___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 4U) {
#line 2733
          goto case_4___0;
        }
#line 2733
        if ((unsigned int )sizeof(re_node_set ) == 0U) {
#line 2733
          goto case_0___0;
        }
#line 2733
        goto switch_break___0;
        case_15___0: /* CIL Label */ 
#line 2733
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 2733
        __u___0 = (union __anonunion___u_62 *)((void *)__u___0 + 4);
        case_11___0: /* CIL Label */ 
#line 2733
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 2733
        __u___0 = (union __anonunion___u_62 *)((void *)__u___0 + 4);
        case_7___0: /* CIL Label */ 
#line 2733
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 2733
        __u___0 = (union __anonunion___u_62 *)((void *)__u___0 + 4);
        case_3___0: /* CIL Label */ 
#line 2733
        __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 2733
        __u___0 = (union __anonunion___u_62 *)((void *)__u___0 + 2);
#line 2733
        __u___0->__uc = __c___0;
#line 2733
        goto switch_break___0;
        case_14___0: /* CIL Label */ 
#line 2733
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 2733
        __u___0 = (union __anonunion___u_62 *)((void *)__u___0 + 4);
        case_10___0: /* CIL Label */ 
#line 2733
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 2733
        __u___0 = (union __anonunion___u_62 *)((void *)__u___0 + 4);
        case_6___0: /* CIL Label */ 
#line 2733
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 2733
        __u___0 = (union __anonunion___u_62 *)((void *)__u___0 + 4);
        case_2___0: /* CIL Label */ 
#line 2733
        __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 2733
        goto switch_break___0;
        case_13___0: /* CIL Label */ 
#line 2733
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 2733
        __u___0 = (union __anonunion___u_62 *)((void *)__u___0 + 4);
        case_9___0: /* CIL Label */ 
#line 2733
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 2733
        __u___0 = (union __anonunion___u_62 *)((void *)__u___0 + 4);
        case_5___0: /* CIL Label */ 
#line 2733
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 2733
        __u___0 = (union __anonunion___u_62 *)((void *)__u___0 + 4);
        case_1___0: /* CIL Label */ 
#line 2733
        __u___0->__uc = __c___0;
#line 2733
        goto switch_break___0;
        case_16___0: /* CIL Label */ 
#line 2733
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 2733
        __u___0 = (union __anonunion___u_62 *)((void *)__u___0 + 4);
        case_12___0: /* CIL Label */ 
#line 2733
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 2733
        __u___0 = (union __anonunion___u_62 *)((void *)__u___0 + 4);
        case_8___0: /* CIL Label */ 
#line 2733
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 2733
        __u___0 = (union __anonunion___u_62 *)((void *)__u___0 + 4);
        case_4___0: /* CIL Label */ 
#line 2733
        __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
        case_0___0: /* CIL Label */ 
#line 2733
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 2733
      __s___2 = (void *)(& next_nodes);
      {
#line 2733
      __builtin_memset(__s___2, '\000', (int )sizeof(re_node_set ));
      }
      }
    }
  }
#line 2735
  if (str_idx == top_str) {
#line 2735
    goto _L___0;
  } else
#line 2735
  if (cur_state) {
#line 2735
    if (cur_state->has_backref) {
      _L___0: /* CIL Label */ 
#line 2737
      if (next_nodes.nelem) {
        {
        {
#line 2739
        err = expand_bkref_cache(preg, mctx, & next_nodes, str_idx, last_str, subexp_num,
                                 fl_open);
        }
        {
#line 2741
        tmp___3 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        }
#line 2741
        if (tmp___3) {
          {
          {
#line 2743
          free((void *)next_nodes.elems);
          }
          }
#line 2744
          return (err);
        }
      }
      {
      {
#line 2747
      cur_state = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& next_nodes),
                                           context);
      }
      }
#line 2748
      if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 2748
        if ((unsigned int )err != 0U) {
#line 2748
          tmp___4 = 1;
        } else {
#line 2748
          tmp___4 = 0;
        }
      } else {
#line 2748
        tmp___4 = 0;
      }
      {
      {
#line 2748
      tmp___5 = __builtin_expect((long )tmp___4, 0L);
      }
      }
#line 2748
      if (tmp___5) {
        {
        {
#line 2750
        free((void *)next_nodes.elems);
        }
        }
#line 2751
        return (err);
      }
#line 2753
      *(mctx->state_log + str_idx) = cur_state;
    }
  }
#line 2756
  null_cnt = 0;
  {
  {
#line 2756
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2756
    if (str_idx < last_str) {
#line 2756
      if (! (null_cnt <= mctx->max_mb_elem_len)) {
#line 2756
        goto while_break;
      }
    } else {
#line 2756
      goto while_break;
    }
#line 2758
    next_nodes.nelem = 0;
#line 2759
    if (*(mctx->state_log + (str_idx + 1))) {
      {
      {
#line 2761
      err = re_node_set_merge(& next_nodes, (re_node_set const   *)(& (*(mctx->state_log + (str_idx + 1)))->nodes));
      }
      {
#line 2763
      tmp___6 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 2763
      if (tmp___6) {
        {
        {
#line 2765
        free((void *)next_nodes.elems);
        }
        }
#line 2766
        return (err);
      }
    }
#line 2769
    if (cur_state) {
      {
      {
#line 2771
      err = check_arrival_add_next_nodes(preg, dfa, mctx, str_idx, & cur_state->nodes,
                                         & next_nodes);
      }
      {
#line 2773
      tmp___7 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 2773
      if (tmp___7) {
        {
        {
#line 2775
        free((void *)next_nodes.elems);
        }
        }
#line 2776
        return (err);
      }
    }
#line 2779
    str_idx ++;
#line 2780
    if (next_nodes.nelem) {
      {
      {
#line 2782
      err = check_arrival_expand_ecl(dfa, & next_nodes, subexp_num, fl_open);
      }
      {
#line 2784
      tmp___8 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 2784
      if (tmp___8) {
        {
        {
#line 2786
        free((void *)next_nodes.elems);
        }
        }
#line 2787
        return (err);
      }
      {
      {
#line 2789
      err = expand_bkref_cache(preg, mctx, & next_nodes, str_idx, last_str, subexp_num,
                               fl_open);
      }
      {
#line 2791
      tmp___9 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 2791
      if (tmp___9) {
        {
        {
#line 2793
        free((void *)next_nodes.elems);
        }
        }
#line 2794
        return (err);
      }
    }
    {
    {
#line 2797
    context = re_string_context_at((re_string_t const   *)mctx->input, str_idx - 1,
                                   mctx->eflags, (int )preg->newline_anchor);
    }
    {
#line 2799
    cur_state = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& next_nodes),
                                         context);
    }
    }
#line 2800
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 2800
      if ((unsigned int )err != 0U) {
#line 2800
        tmp___10 = 1;
      } else {
#line 2800
        tmp___10 = 0;
      }
    } else {
#line 2800
      tmp___10 = 0;
    }
    {
    {
#line 2800
    tmp___11 = __builtin_expect((long )tmp___10, 0L);
    }
    }
#line 2800
    if (tmp___11) {
      {
      {
#line 2802
      free((void *)next_nodes.elems);
      }
      }
#line 2803
      return (err);
    }
#line 2805
    *(mctx->state_log + str_idx) = cur_state;
#line 2806
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 2806
      null_cnt ++;
    } else {
#line 2806
      null_cnt = 0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 2808
  free((void *)next_nodes.elems);
  }
  }
#line 2809
  if ((unsigned long )*(mctx->state_log + last_str) == (unsigned long )((void *)0)) {
#line 2809
    cur_nodes = (re_node_set *)((void *)0);
  } else {
#line 2809
    cur_nodes = & (*(mctx->state_log + last_str))->nodes;
  }
#line 2811
  path->next_idx = str_idx;
#line 2814
  mctx->state_log = backup_state_log;
#line 2815
  (mctx->input)->cur_idx = backup_cur_idx;
#line 2817
  if ((unsigned long )cur_nodes == (unsigned long )((void *)0)) {
#line 2818
    return ((reg_errcode_t )1);
  }
  {
  {
#line 2820
  tmp___15 = re_node_set_contains((re_node_set const   *)cur_nodes, last_node);
  }
  }
#line 2820
  if (tmp___15) {
#line 2820
    tmp___14 = 0;
  } else {
    {
    {
#line 2820
    tmp___16 = re_node_set_contains((re_node_set const   *)cur_nodes, last_node);
    }
    }
#line 2820
    if (tmp___16) {
#line 2820
      tmp___14 = 0;
    } else {
#line 2820
      tmp___14 = 1;
    }
  }
#line 2820
  return ((reg_errcode_t )tmp___14);
}
}
#line 2833 "regexec.c"
static reg_errcode_t check_arrival_add_next_nodes(regex_t const   *preg , re_dfa_t *dfa ,
                                                  re_match_context_t *mctx , int str_idx ,
                                                  re_node_set *cur_nodes , re_node_set *next_nodes ) 
{ 
  int cur_idx ;
  reg_errcode_t err ;
  re_node_set union_set ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_63 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  int naccepted ;
  int cur_node ;
  re_token_type_t type ;
  re_dfastate_t *dest_state ;
  int next_node ;
  int next_idx ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;

  {
#line 2844
  if (sizeof(re_node_set ) <= 16UL) {
#line 2844
    if (sizeof(re_node_set ) == 1UL) {
#line 2844
      __s___1 = (void *)(& union_set);
#line 2844
      *((__uint8_t *)__s___1) = (__uint8_t )'\000';
    } else {
#line 2844
      __s___0 = (void *)(& union_set);
#line 2844
      __u = (union __anonunion___u_63 *)__s___0;
#line 2844
      __c = (__uint8_t )'\000';
      {
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 15U) {
#line 2844
        goto case_15;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 11U) {
#line 2844
        goto case_11;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 7U) {
#line 2844
        goto case_7;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 3U) {
#line 2844
        goto case_3;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 14U) {
#line 2844
        goto case_14;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 10U) {
#line 2844
        goto case_10;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 6U) {
#line 2844
        goto case_6;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 2U) {
#line 2844
        goto case_2;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 13U) {
#line 2844
        goto case_13;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 9U) {
#line 2844
        goto case_9;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 5U) {
#line 2844
        goto case_5;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 1U) {
#line 2844
        goto case_1;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 16U) {
#line 2844
        goto case_16;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 12U) {
#line 2844
        goto case_12;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 8U) {
#line 2844
        goto case_8;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 4U) {
#line 2844
        goto case_4;
      }
#line 2844
      if ((unsigned int )sizeof(re_node_set ) == 0U) {
#line 2844
        goto case_0;
      }
#line 2844
      goto switch_break;
      case_15: /* CIL Label */ 
#line 2844
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2844
      __u = (union __anonunion___u_63 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 2844
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2844
      __u = (union __anonunion___u_63 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 2844
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2844
      __u = (union __anonunion___u_63 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 2844
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 2844
      __u = (union __anonunion___u_63 *)((void *)__u + 2);
#line 2844
      __u->__uc = __c;
#line 2844
      goto switch_break;
      case_14: /* CIL Label */ 
#line 2844
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2844
      __u = (union __anonunion___u_63 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 2844
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2844
      __u = (union __anonunion___u_63 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 2844
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2844
      __u = (union __anonunion___u_63 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 2844
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 2844
      goto switch_break;
      case_13: /* CIL Label */ 
#line 2844
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2844
      __u = (union __anonunion___u_63 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 2844
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2844
      __u = (union __anonunion___u_63 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 2844
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2844
      __u = (union __anonunion___u_63 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 2844
      __u->__uc = __c;
#line 2844
      goto switch_break;
      case_16: /* CIL Label */ 
#line 2844
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2844
      __u = (union __anonunion___u_63 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 2844
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2844
      __u = (union __anonunion___u_63 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 2844
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2844
      __u = (union __anonunion___u_63 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 2844
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 2844
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 2844
    __s = (void *)(& union_set);
    {
#line 2844
    __builtin_memset(__s, '\000', (int )sizeof(re_node_set ));
    }
    }
  }
#line 2845
  cur_idx = 0;
  {
  {
#line 2845
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2845
    if (! (cur_idx < cur_nodes->nelem)) {
#line 2845
      goto while_break;
    }
#line 2847
    naccepted = 0;
#line 2848
    cur_node = *(cur_nodes->elems + cur_idx);
#line 2849
    type = (dfa->nodes + cur_node)->type;
#line 2850
    if ((unsigned int )type == 28U) {
#line 2851
      goto __Cont;
    } else
#line 2850
    if ((unsigned int )type == 29U) {
#line 2851
      goto __Cont;
    } else
#line 2850
    if ((unsigned int )type == 30U) {
#line 2851
      goto __Cont;
    } else
#line 2850
    if ((unsigned int )type == 31U) {
#line 2851
      goto __Cont;
    } else
#line 2850
    if ((unsigned int )type == 33U) {
#line 2851
      goto __Cont;
    } else
#line 2850
    if ((unsigned int )type == 23U) {
#line 2851
      goto __Cont;
    } else
#line 2850
    if ((unsigned int )type == 24U) {
#line 2851
      goto __Cont;
    }
#line 2854
    if ((unsigned int )type == 22U) {
#line 2854
      goto _L;
    } else
#line 2854
    if ((unsigned int )type == 25U) {
      _L: /* CIL Label */ 
      {
      {
#line 2856
      naccepted = check_node_accept_bytes(preg, cur_node, (re_string_t const   *)mctx->input,
                                          str_idx);
      }
      }
#line 2858
      if (naccepted > 1) {
#line 2861
        next_node = *(dfa->nexts + cur_node);
#line 2862
        next_idx = str_idx + naccepted;
#line 2863
        dest_state = *(mctx->state_log + next_idx);
#line 2864
        union_set.nelem = 0;
#line 2865
        if (dest_state) {
          {
          {
#line 2867
          err = re_node_set_merge(& union_set, (re_node_set const   *)(& dest_state->nodes));
          }
          {
#line 2868
          tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
          }
          }
#line 2868
          if (tmp) {
            {
            {
#line 2870
            free((void *)union_set.elems);
            }
            }
#line 2871
            return (err);
          }
          {
          {
#line 2873
          tmp___0 = re_node_set_insert(& union_set, next_node);
          }
#line 2873
          err = (reg_errcode_t )tmp___0;
          {
#line 2874
          tmp___1 = __builtin_expect((long )((unsigned int )err < 0U), 0L);
          }
          }
#line 2874
          if (tmp___1) {
            {
            {
#line 2876
            free((void *)union_set.elems);
            }
            }
#line 2877
            return ((reg_errcode_t )12);
          }
        } else {
          {
          {
#line 2882
          tmp___2 = re_node_set_insert(& union_set, next_node);
          }
#line 2882
          err = (reg_errcode_t )tmp___2;
          {
#line 2883
          tmp___3 = __builtin_expect((long )((unsigned int )err < 0U), 0L);
          }
          }
#line 2883
          if (tmp___3) {
            {
            {
#line 2885
            free((void *)union_set.elems);
            }
            }
#line 2886
            return ((reg_errcode_t )12);
          }
        }
        {
        {
#line 2889
        *(mctx->state_log + next_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& union_set));
        }
        }
#line 2891
        if ((unsigned long )*(mctx->state_log + next_idx) == (unsigned long )((void *)0)) {
#line 2891
          if ((unsigned int )err != 0U) {
#line 2891
            tmp___4 = 1;
          } else {
#line 2891
            tmp___4 = 0;
          }
        } else {
#line 2891
          tmp___4 = 0;
        }
        {
        {
#line 2891
        tmp___5 = __builtin_expect((long )tmp___4, 0L);
        }
        }
#line 2891
        if (tmp___5) {
          {
          {
#line 2894
          free((void *)union_set.elems);
          }
          }
#line 2895
          return (err);
        }
      }
    }
#line 2900
    if (naccepted) {
#line 2900
      goto _L___0;
    } else {
      {
      {
#line 2900
      tmp___8 = check_node_accept(preg, (re_token_t const   *)(dfa->nodes + cur_node),
                                  (re_match_context_t const   *)mctx, str_idx);
      }
      }
#line 2900
      if (tmp___8) {
        _L___0: /* CIL Label */ 
        {
        {
#line 2904
        tmp___6 = re_node_set_insert(next_nodes, *(dfa->nexts + cur_node));
        }
#line 2904
        err = (reg_errcode_t )tmp___6;
        {
#line 2905
        tmp___7 = __builtin_expect((long )((unsigned int )err < 0U), 0L);
        }
        }
#line 2905
        if (tmp___7) {
          {
          {
#line 2907
          free((void *)union_set.elems);
          }
          }
#line 2908
          return ((reg_errcode_t )12);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 2845
    cur_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 2912
  free((void *)union_set.elems);
  }
  }
#line 2913
  return ((reg_errcode_t )0);
}
}
#line 2922 "regexec.c"
static reg_errcode_t check_arrival_expand_ecl(re_dfa_t *dfa , re_node_set *cur_nodes ,
                                              int ex_subexp , int fl_open ) 
{ 
  reg_errcode_t err ;
  int idx ;
  int outside_node ;
  re_node_set new_nodes ;
  long tmp ;
  int cur_node ;
  re_node_set *eclosure ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
  {
#line 2934
  err = re_node_set_alloc(& new_nodes, cur_nodes->nelem);
  }
  {
#line 2935
  tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 2935
  if (tmp) {
#line 2936
    return (err);
  }
#line 2940
  idx = 0;
  {
  {
#line 2940
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2940
    if (! (idx < cur_nodes->nelem)) {
#line 2940
      goto while_break;
    }
    {
#line 2942
    cur_node = *(cur_nodes->elems + idx);
#line 2943
    eclosure = dfa->eclosures + cur_node;
    {
#line 2944
    outside_node = find_subexp_node(dfa, eclosure, ex_subexp, fl_open);
    }
    }
#line 2945
    if (outside_node == -1) {
      {
      {
#line 2948
      err = re_node_set_merge(& new_nodes, (re_node_set const   *)eclosure);
      }
      {
#line 2949
      tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 2949
      if (tmp___0) {
        {
        {
#line 2951
        free((void *)new_nodes.elems);
        }
        }
#line 2952
        return (err);
      }
    } else {
      {
      {
#line 2958
      err = check_arrival_expand_ecl_sub(dfa, & new_nodes, cur_node, ex_subexp, fl_open);
      }
      {
#line 2960
      tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 2960
      if (tmp___1) {
        {
        {
#line 2962
        free((void *)new_nodes.elems);
        }
        }
#line 2963
        return (err);
      }
    }
#line 2940
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 2967
  free((void *)cur_nodes->elems);
  }
#line 2968
  *cur_nodes = new_nodes;
  }
#line 2969
  return ((reg_errcode_t )0);
}
}
#line 2976 "regexec.c"
static reg_errcode_t check_arrival_expand_ecl_sub(re_dfa_t *dfa , re_node_set *dst_nodes ,
                                                  int target , int ex_subexp , int fl_open ) 
{ 
  int cur_node ;
  int type ;
  int err ;
  long tmp ;
  long tmp___0 ;
  reg_errcode_t tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 2983
  cur_node = target;
  {
  {
#line 2983
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 2983
    tmp___3 = re_node_set_contains((re_node_set const   *)dst_nodes, cur_node);
    }
    }
#line 2983
    if (tmp___3) {
#line 2983
      goto while_break;
    }
#line 2986
    type = (int )(dfa->nodes + cur_node)->type;
#line 2988
    if (type == 23) {
#line 2988
      if (fl_open) {
#line 2988
        goto _L;
      } else {
#line 2988
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2988
    if (type == 24) {
#line 2988
      if (! fl_open) {
        _L: /* CIL Label */ 
#line 2988
        if ((dfa->nodes + cur_node)->opr.idx == ex_subexp) {
#line 2992
          if (! fl_open) {
            {
            {
#line 2994
            err = re_node_set_insert(dst_nodes, cur_node);
            }
            {
#line 2995
            tmp = __builtin_expect((long )(err == -1), 0L);
            }
            }
#line 2995
            if (tmp) {
#line 2996
              return ((reg_errcode_t )12);
            }
          }
#line 2998
          goto while_break;
        }
      }
    }
    {
    {
#line 3000
    err = re_node_set_insert(dst_nodes, cur_node);
    }
    {
#line 3001
    tmp___0 = __builtin_expect((long )(err == -1), 0L);
    }
    }
#line 3001
    if (tmp___0) {
#line 3002
      return ((reg_errcode_t )12);
    }
#line 3003
    if ((dfa->edests + cur_node)->nelem == 0) {
#line 3004
      goto while_break;
    }
#line 3005
    if ((dfa->edests + cur_node)->nelem == 2) {
      {
      {
#line 3007
      tmp___1 = check_arrival_expand_ecl_sub(dfa, dst_nodes, *((dfa->edests + cur_node)->elems + 1),
                                             ex_subexp, fl_open);
      }
#line 3007
      err = (int )tmp___1;
      {
#line 3010
      tmp___2 = __builtin_expect((long )(err != 0), 0L);
      }
      }
#line 3010
      if (tmp___2) {
#line 3011
        return ((reg_errcode_t )err);
      }
    }
#line 3013
    cur_node = *((dfa->edests + cur_node)->elems + 0);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3015
  return ((reg_errcode_t )0);
}
}
#line 3023 "regexec.c"
static reg_errcode_t expand_bkref_cache(regex_t const   *preg , re_match_context_t *mctx ,
                                        re_node_set *cur_nodes , int cur_str , int last_str ,
                                        int subexp_num , int fl_open ) 
{ 
  reg_errcode_t err ;
  re_dfa_t *dfa ;
  int cache_idx ;
  int cache_idx_start ;
  int to_idx ;
  int next_node ;
  struct re_backref_cache_entry *ent ;
  int tmp ;
  re_node_set new_dests ;
  reg_errcode_t err2 ;
  reg_errcode_t err3 ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  re_node_set union_set ;
  int ret ;
  int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;

  {
  {
#line 3032
  dfa = (re_dfa_t *)preg->buffer;
  {
#line 3036
  cache_idx_start = search_cur_bkref_entry(mctx, cur_str);
  }
#line 3037
  cache_idx = cache_idx_start;
  }
  {
  {
#line 3037
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3037
    if (! (cache_idx < mctx->nbkref_ents)) {
#line 3037
      goto while_break;
    }
#line 3040
    ent = mctx->bkref_ents + cache_idx;
#line 3041
    if (ent->str_idx > cur_str) {
#line 3042
      goto while_break;
    }
    {
    {
#line 3044
    tmp = re_node_set_contains((re_node_set const   *)cur_nodes, ent->node);
    }
    }
#line 3044
    if (! tmp) {
#line 3045
      goto __Cont;
    }
#line 3047
    to_idx = (cur_str + ent->subexp_to) - ent->subexp_from;
#line 3050
    if (to_idx == cur_str) {
      {
#line 3056
      next_node = *((dfa->edests + ent->node)->elems + 0);
      {
#line 3057
      tmp___0 = re_node_set_contains((re_node_set const   *)cur_nodes, next_node);
      }
      }
#line 3057
      if (tmp___0) {
#line 3058
        goto __Cont;
      }
      {
      {
#line 3059
      err = re_node_set_init_1(& new_dests, next_node);
      }
      {
#line 3060
      err2 = check_arrival_expand_ecl(dfa, & new_dests, subexp_num, fl_open);
      }
      {
#line 3062
      err3 = re_node_set_merge(cur_nodes, (re_node_set const   *)(& new_dests));
      }
      {
#line 3063
      free((void *)new_dests.elems);
      }
      }
#line 3064
      if ((unsigned int )err != 0U) {
#line 3064
        tmp___2 = 1;
      } else
#line 3064
      if ((unsigned int )err2 != 0U) {
#line 3064
        tmp___2 = 1;
      } else
#line 3064
      if ((unsigned int )err3 != 0U) {
#line 3064
        tmp___2 = 1;
      } else {
#line 3064
        tmp___2 = 0;
      }
      {
      {
#line 3064
      tmp___3 = __builtin_expect((long )tmp___2, 0L);
      }
      }
#line 3064
      if (tmp___3) {
#line 3067
        if ((unsigned int )err != 0U) {
#line 3067
          err = err;
        } else {
#line 3067
          if ((unsigned int )err2 != 0U) {
#line 3067
            tmp___1 = (unsigned int )err2;
          } else {
#line 3067
            tmp___1 = (unsigned int )err3;
          }
#line 3067
          err = (reg_errcode_t )tmp___1;
        }
#line 3069
        return (err);
      }
#line 3072
      cache_idx = cache_idx_start - 1;
#line 3073
      goto __Cont;
    } else {
#line 3078
      next_node = *(dfa->nexts + ent->node);
#line 3079
      if (*(mctx->state_log + to_idx)) {
        {
        {
#line 3082
        tmp___4 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes),
                                       next_node);
        }
        }
#line 3082
        if (tmp___4) {
#line 3084
          goto __Cont;
        }
        {
        {
#line 3085
        err = re_node_set_init_copy(& union_set, (re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes));
        }
        {
#line 3087
        ret = re_node_set_insert(& union_set, next_node);
        }
        }
#line 3088
        if ((unsigned int )err != 0U) {
#line 3088
          tmp___5 = 1;
        } else
#line 3088
        if (ret < 0) {
#line 3088
          tmp___5 = 1;
        } else {
#line 3088
          tmp___5 = 0;
        }
        {
        {
#line 3088
        tmp___6 = __builtin_expect((long )tmp___5, 0L);
        }
        }
#line 3088
        if (tmp___6) {
          {
          {
#line 3090
          free((void *)union_set.elems);
          }
          }
#line 3091
          if ((unsigned int )err != 0U) {
#line 3091
            err = err;
          } else {
#line 3091
            err = (reg_errcode_t )12;
          }
#line 3092
          return (err);
        }
      } else {
        {
        {
#line 3097
        err = re_node_set_init_1(& union_set, next_node);
        }
        {
#line 3098
        tmp___7 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        }
#line 3098
        if (tmp___7) {
#line 3099
          return (err);
        }
      }
      {
      {
#line 3101
      *(mctx->state_log + to_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& union_set));
      }
      {
#line 3102
      free((void *)union_set.elems);
      }
      }
#line 3103
      if ((unsigned long )*(mctx->state_log + to_idx) == (unsigned long )((void *)0)) {
#line 3103
        if ((unsigned int )err != 0U) {
#line 3103
          tmp___8 = 1;
        } else {
#line 3103
          tmp___8 = 0;
        }
      } else {
#line 3103
        tmp___8 = 0;
      }
      {
      {
#line 3103
      tmp___9 = __builtin_expect((long )tmp___8, 0L);
      }
      }
#line 3103
      if (tmp___9) {
#line 3105
        return (err);
      }
    }
    __Cont: /* CIL Label */ 
#line 3037
    cache_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3108
  return ((reg_errcode_t )0);
}
}
#line 3114 "regexec.c"
static re_dfastate_t **build_trtable(regex_t const   *preg , re_dfastate_t const   *state ,
                                     int fl_search ) 
{ 
  reg_errcode_t err ;
  re_dfa_t *dfa ;
  int i ;
  int j ;
  int k ;
  int ch ;
  int dests_node_malloced ;
  int dest_states_malloced ;
  int ndests ;
  re_dfastate_t **trtable ;
  re_dfastate_t **dest_states ;
  re_dfastate_t **dest_states_word ;
  re_dfastate_t **dest_states_nl ;
  re_node_set follows ;
  re_node_set *dests_node ;
  bitset *dests_ch ;
  bitset acceptable ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_64 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  int next_node ;
  long tmp___7 ;
  int not_initial ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  unsigned short const   **tmp___15 ;

  {
  {
#line 3121
  dfa = (re_dfa_t *)preg->buffer;
#line 3123
  dests_node_malloced = 0;
#line 3123
  dest_states_malloced = 0;
#line 3126
  dest_states = (re_dfastate_t **)((void *)0);
  {
#line 3142
  tmp = malloc((size_t )((sizeof(re_node_set ) + sizeof(bitset )) * 256UL));
  }
#line 3142
  dests_node = (re_node_set *)tmp;
  {
#line 3144
  tmp___0 = __builtin_expect((long )((unsigned long )dests_node == (unsigned long )((void *)0)),
                             0L);
  }
  }
#line 3144
  if (tmp___0) {
#line 3145
    return ((re_dfastate_t **)((void *)0));
  }
  {
#line 3146
  dests_node_malloced = 1;
#line 3148
  dests_ch = (bitset *)(dests_node + 256);
  {
#line 3151
  tmp___1 = calloc((size_t )sizeof(re_dfastate_t *), (size_t )256);
  }
#line 3151
  trtable = (re_dfastate_t **)tmp___1;
  {
#line 3152
  tmp___2 = __builtin_expect((long )((unsigned long )trtable == (unsigned long )((void *)0)),
                             0L);
  }
  }
#line 3152
  if (tmp___2) {
#line 3154
    if (dests_node_malloced) {
      {
      {
#line 3155
      free((void *)dests_node);
      }
      }
    }
#line 3156
    return ((re_dfastate_t **)((void *)0));
  }
  {
  {
#line 3161
  ndests = group_nodes_into_DFAstates(preg, state, dests_node, dests_ch);
  }
  {
#line 3162
  tmp___3 = __builtin_expect((long )(ndests <= 0), 0L);
  }
  }
#line 3162
  if (tmp___3) {
#line 3164
    if (dests_node_malloced) {
      {
      {
#line 3165
      free((void *)dests_node);
      }
      }
    }
#line 3167
    if (ndests == 0) {
#line 3168
      return (trtable);
    }
    {
    {
#line 3169
    free((void *)trtable);
    }
    }
#line 3170
    return ((re_dfastate_t **)((void *)0));
  }
  {
  {
#line 3173
  err = re_node_set_alloc(& follows, ndests + 1);
  }
  {
#line 3174
  tmp___4 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  }
#line 3174
  if (tmp___4) {
#line 3175
    goto out_free;
  }
  {
  {
#line 3185
  tmp___5 = malloc((size_t )((unsigned long )(ndests * 3) * sizeof(re_dfastate_t *)));
  }
#line 3185
  dest_states = (re_dfastate_t **)tmp___5;
  {
#line 3187
  tmp___6 = __builtin_expect((long )((unsigned long )dest_states == (unsigned long )((void *)0)),
                             0L);
  }
  }
#line 3187
  if (tmp___6) {
    out_free: 
#line 3190
    if (dest_states_malloced) {
      {
      {
#line 3191
      free((void *)dest_states);
      }
      }
    }
    {
    {
#line 3192
    free((void *)follows.elems);
    }
#line 3193
    i = 0;
    }
    {
    {
#line 3193
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 3193
      if (! (i < ndests)) {
#line 3193
        goto while_break;
      }
      {
      {
#line 3194
      free((void *)(dests_node + i)->elems);
      }
#line 3193
      i ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 3195
    free((void *)trtable);
    }
    }
#line 3196
    if (dests_node_malloced) {
      {
      {
#line 3197
      free((void *)dests_node);
      }
      }
    }
#line 3198
    return ((re_dfastate_t **)((void *)0));
  }
#line 3200
  dest_states_malloced = 1;
#line 3202
  dest_states_word = dest_states + ndests;
#line 3203
  dest_states_nl = dest_states_word + ndests;
#line 3204
  if (sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)) <= 16UL) {
#line 3204
    if (sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)) == 1UL) {
#line 3204
      __s___1 = (void *)(acceptable);
#line 3204
      *((__uint8_t *)__s___1) = (__uint8_t )0;
    } else {
#line 3204
      __s___0 = (void *)(acceptable);
#line 3204
      __u = (union __anonunion___u_64 *)__s___0;
#line 3204
      __c = (__uint8_t )0;
      {
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 15U) {
#line 3204
        goto case_15;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 11U) {
#line 3204
        goto case_11;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 7U) {
#line 3204
        goto case_7;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 3U) {
#line 3204
        goto case_3;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 14U) {
#line 3204
        goto case_14;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 10U) {
#line 3204
        goto case_10;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 6U) {
#line 3204
        goto case_6;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 2U) {
#line 3204
        goto case_2;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 13U) {
#line 3204
        goto case_13;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 9U) {
#line 3204
        goto case_9;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 5U) {
#line 3204
        goto case_5;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 1U) {
#line 3204
        goto case_1;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 16U) {
#line 3204
        goto case_16;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 12U) {
#line 3204
        goto case_12;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 8U) {
#line 3204
        goto case_8;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 4U) {
#line 3204
        goto case_4;
      }
#line 3204
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 0U) {
#line 3204
        goto case_0;
      }
#line 3204
      goto switch_break;
      case_15: /* CIL Label */ 
#line 3204
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3204
      __u = (union __anonunion___u_64 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 3204
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3204
      __u = (union __anonunion___u_64 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 3204
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3204
      __u = (union __anonunion___u_64 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 3204
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 3204
      __u = (union __anonunion___u_64 *)((void *)__u + 2);
#line 3204
      __u->__uc = __c;
#line 3204
      goto switch_break;
      case_14: /* CIL Label */ 
#line 3204
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3204
      __u = (union __anonunion___u_64 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 3204
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3204
      __u = (union __anonunion___u_64 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 3204
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3204
      __u = (union __anonunion___u_64 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 3204
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 3204
      goto switch_break;
      case_13: /* CIL Label */ 
#line 3204
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3204
      __u = (union __anonunion___u_64 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 3204
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3204
      __u = (union __anonunion___u_64 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 3204
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3204
      __u = (union __anonunion___u_64 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 3204
      __u->__uc = __c;
#line 3204
      goto switch_break;
      case_16: /* CIL Label */ 
#line 3204
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3204
      __u = (union __anonunion___u_64 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 3204
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3204
      __u = (union __anonunion___u_64 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 3204
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3204
      __u = (union __anonunion___u_64 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 3204
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 3204
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 3204
    __s = (void *)(acceptable);
    {
#line 3204
    __builtin_memset(__s, '\000', (int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))));
    }
    }
  }
#line 3207
  i = 0;
  {
  {
#line 3207
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 3207
    if (! (i < ndests)) {
#line 3207
      goto while_break___0;
    }
#line 3210
    follows.nelem = 0;
#line 3212
    j = 0;
    {
    {
#line 3212
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 3212
      if (! (j < (dests_node + i)->nelem)) {
#line 3212
        goto while_break___1;
      }
#line 3214
      next_node = *(dfa->nexts + *((dests_node + i)->elems + j));
#line 3215
      if (next_node != -1) {
        {
        {
#line 3217
        err = re_node_set_merge(& follows, (re_node_set const   *)(dfa->eclosures + next_node));
        }
        {
#line 3218
        tmp___7 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        }
#line 3218
        if (tmp___7) {
#line 3219
          goto out_free;
        }
      }
#line 3212
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3223
    if (fl_search) {
#line 3226
      not_initial = 0;
#line 3227
      j = 0;
      {
      {
#line 3227
      while (1) {
        while_continue___12: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 3227
        if (! (j < follows.nelem)) {
#line 3227
          goto while_break___2;
        }
#line 3228
        if ((unsigned int )(dfa->nodes + *(follows.elems + j))->type == 26U) {
#line 3230
          not_initial = (int )(dfa->nodes + *(follows.elems + j))->mb_partial;
#line 3231
          goto while_break___2;
        }
#line 3227
        j ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 3233
      if (! not_initial) {
        {
        {
#line 3236
        err = re_node_set_merge(& follows, (re_node_set const   *)(dfa->init_state)->entrance_nodes);
        }
        {
#line 3238
        tmp___8 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        }
#line 3238
        if (tmp___8) {
#line 3239
          goto out_free;
        }
      }
    }
    {
    {
#line 3242
    *(dest_states + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                  0U);
    }
    }
#line 3243
    if ((unsigned long )*(dest_states + i) == (unsigned long )((void *)0)) {
#line 3243
      if ((unsigned int )err != 0U) {
#line 3243
        tmp___9 = 1;
      } else {
#line 3243
        tmp___9 = 0;
      }
    } else {
#line 3243
      tmp___9 = 0;
    }
    {
    {
#line 3243
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
    }
#line 3243
    if (tmp___10) {
#line 3244
      goto out_free;
    }
#line 3247
    if ((*(dest_states + i))->has_constraint) {
      {
      {
#line 3249
      *(dest_states_word + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                         1U);
      }
      }
#line 3251
      if ((unsigned long )*(dest_states_word + i) == (unsigned long )((void *)0)) {
#line 3251
        if ((unsigned int )err != 0U) {
#line 3251
          tmp___11 = 1;
        } else {
#line 3251
          tmp___11 = 0;
        }
      } else {
#line 3251
        tmp___11 = 0;
      }
      {
      {
#line 3251
      tmp___12 = __builtin_expect((long )tmp___11, 0L);
      }
      }
#line 3251
      if (tmp___12) {
#line 3252
        goto out_free;
      }
      {
      {
#line 3253
      *(dest_states_nl + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                       (unsigned int )(1 << 1));
      }
      }
#line 3255
      if ((unsigned long )*(dest_states_nl + i) == (unsigned long )((void *)0)) {
#line 3255
        if ((unsigned int )err != 0U) {
#line 3255
          tmp___13 = 1;
        } else {
#line 3255
          tmp___13 = 0;
        }
      } else {
#line 3255
        tmp___13 = 0;
      }
      {
      {
#line 3255
      tmp___14 = __builtin_expect((long )tmp___13, 0L);
      }
      }
#line 3255
      if (tmp___14) {
#line 3256
        goto out_free;
      }
    } else {
#line 3260
      *(dest_states_word + i) = *(dest_states + i);
#line 3261
      *(dest_states_nl + i) = *(dest_states + i);
    }
    {
    {
#line 3263
    bitset_merge((unsigned int *)(acceptable), (unsigned int */* const  */)(*(dests_ch + i)));
    }
#line 3207
    i ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3268
  i = 0;
#line 3268
  ch = 0;
  {
  {
#line 3268
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 3268
    if (! ((unsigned long )i < ((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) {
#line 3268
      goto while_break___3;
    }
#line 3269
    j = 0;
    {
    {
#line 3269
    while (1) {
      while_continue___14: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 3269
      if (! ((unsigned long )j < sizeof(unsigned int ) * 8UL)) {
#line 3269
        goto while_break___4;
      }
#line 3270
      if ((acceptable[i] >> j) & 1U) {
        {
        {
#line 3273
        tmp___15 = __ctype_b_loc();
        }
        }
#line 3273
        if ((int const   )*(*tmp___15 + ch) & 8) {
#line 3273
          goto _L;
        } else
#line 3273
        if (ch == 95) {
          _L: /* CIL Label */ 
#line 3275
          k = 0;
          {
          {
#line 3275
          while (1) {
            while_continue___15: /* CIL Label */ ;
            while_continue___5: /* CIL Label */ ;
#line 3275
            if (! (k < ndests)) {
#line 3275
              goto while_break___5;
            }
#line 3276
            if (((*(dests_ch + k))[i] >> j) & 1U) {
#line 3279
              *(trtable + ch) = *(dest_states_word + k);
#line 3282
              goto while_break___5;
            }
#line 3275
            k ++;
          }
          while_break___15: /* CIL Label */ ;
          }
          while_break___5: /* CIL Label */ ;
          }
        } else {
#line 3287
          k = 0;
          {
          {
#line 3287
          while (1) {
            while_continue___16: /* CIL Label */ ;
            while_continue___6: /* CIL Label */ ;
#line 3287
            if (! (k < ndests)) {
#line 3287
              goto while_break___6;
            }
#line 3288
            if (((*(dests_ch + k))[i] >> j) & 1U) {
#line 3291
              *(trtable + ch) = *(dest_states + k);
#line 3294
              goto while_break___6;
            }
#line 3287
            k ++;
          }
          while_break___16: /* CIL Label */ ;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
      }
#line 3269
      j ++;
#line 3269
      ch ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3268
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3299
  if (acceptable[10UL / (sizeof(unsigned int ) * 8UL)] & (unsigned int )(1 << 10UL % (sizeof(unsigned int ) * 8UL))) {
#line 3302
    k = 0;
    {
    {
#line 3302
    while (1) {
      while_continue___17: /* CIL Label */ ;
      while_continue___7: /* CIL Label */ ;
#line 3302
      if (! (k < ndests)) {
#line 3302
        goto while_break___7;
      }
#line 3303
      if ((*(dests_ch + k))[10UL / (sizeof(unsigned int ) * 8UL)] & (unsigned int )(1 << 10UL % (sizeof(unsigned int ) * 8UL))) {
#line 3306
        *(trtable + '\n') = *(dest_states_nl + k);
#line 3309
        goto while_break___7;
      }
#line 3302
      k ++;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 3313
  if (dest_states_malloced) {
    {
    {
#line 3314
    free((void *)dest_states);
    }
    }
  }
  {
  {
#line 3316
  free((void *)follows.elems);
  }
#line 3317
  i = 0;
  }
  {
  {
#line 3317
  while (1) {
    while_continue___18: /* CIL Label */ ;
    while_continue___8: /* CIL Label */ ;
#line 3317
    if (! (i < ndests)) {
#line 3317
      goto while_break___8;
    }
    {
    {
#line 3318
    free((void *)(dests_node + i)->elems);
    }
#line 3317
    i ++;
    }
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 3320
  if (dests_node_malloced) {
    {
    {
#line 3321
    free((void *)dests_node);
    }
    }
  }
#line 3323
  return (trtable);
}
}
#line 3331 "regexec.c"
static int group_nodes_into_DFAstates(regex_t const   *preg , re_dfastate_t const   *state ,
                                      re_node_set *dests_node , bitset *dests_ch ) 
{ 
  reg_errcode_t err ;
  re_dfa_t const   *dfa ;
  int i ;
  int j ;
  int k ;
  int ndests ;
  bitset accepts ;
  re_node_set const   *cur_nodes ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_65 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  re_token_t *node ;
  re_token_type_t type ;
  unsigned int constraint ;
  void *__s___3 ;
  union __anonunion___u_66 *__u___0 ;
  __uint8_t __c___0 ;
  void *__s___4 ;
  int accepts_newline ;
  void *__s___5 ;
  void *__s___6 ;
  union __anonunion___u_67 *__u___1 ;
  __uint8_t __c___1 ;
  void *__s___7 ;
  void *__s___8 ;
  void *__s___9 ;
  union __anonunion___u_68 *__u___2 ;
  __uint8_t __c___2 ;
  void *__s___10 ;
  bitset intersec ;
  bitset remains ;
  int has_intersec ;
  int not_subset ;
  int not_consumed ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  void *__s___11 ;
  void *__s___12 ;
  union __anonunion___u_69 *__u___3 ;
  __uint8_t __c___3 ;
  void *__s___13 ;

  {
#line 3339
  dfa = (re_dfa_t const   *)((re_dfa_t *)preg->buffer);
#line 3343
  cur_nodes = & state->nodes;
#line 3344
  if (sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)) <= 16UL) {
#line 3344
    if (sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)) == 1UL) {
#line 3344
      __s___1 = (void *)(accepts);
#line 3344
      *((__uint8_t *)__s___1) = (__uint8_t )0;
    } else {
#line 3344
      __s___0 = (void *)(accepts);
#line 3344
      __u = (union __anonunion___u_65 *)__s___0;
#line 3344
      __c = (__uint8_t )0;
      {
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 15U) {
#line 3344
        goto case_15;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 11U) {
#line 3344
        goto case_11;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 7U) {
#line 3344
        goto case_7;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 3U) {
#line 3344
        goto case_3;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 14U) {
#line 3344
        goto case_14;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 10U) {
#line 3344
        goto case_10;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 6U) {
#line 3344
        goto case_6;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 2U) {
#line 3344
        goto case_2;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 13U) {
#line 3344
        goto case_13;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 9U) {
#line 3344
        goto case_9;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 5U) {
#line 3344
        goto case_5;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 1U) {
#line 3344
        goto case_1;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 16U) {
#line 3344
        goto case_16;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 12U) {
#line 3344
        goto case_12;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 8U) {
#line 3344
        goto case_8;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 4U) {
#line 3344
        goto case_4;
      }
#line 3344
      if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 0U) {
#line 3344
        goto case_0;
      }
#line 3344
      goto switch_break;
      case_15: /* CIL Label */ 
#line 3344
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3344
      __u = (union __anonunion___u_65 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 3344
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3344
      __u = (union __anonunion___u_65 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 3344
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3344
      __u = (union __anonunion___u_65 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 3344
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 3344
      __u = (union __anonunion___u_65 *)((void *)__u + 2);
#line 3344
      __u->__uc = __c;
#line 3344
      goto switch_break;
      case_14: /* CIL Label */ 
#line 3344
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3344
      __u = (union __anonunion___u_65 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 3344
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3344
      __u = (union __anonunion___u_65 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 3344
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3344
      __u = (union __anonunion___u_65 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 3344
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 3344
      goto switch_break;
      case_13: /* CIL Label */ 
#line 3344
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3344
      __u = (union __anonunion___u_65 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 3344
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3344
      __u = (union __anonunion___u_65 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 3344
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3344
      __u = (union __anonunion___u_65 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 3344
      __u->__uc = __c;
#line 3344
      goto switch_break;
      case_16: /* CIL Label */ 
#line 3344
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3344
      __u = (union __anonunion___u_65 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 3344
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3344
      __u = (union __anonunion___u_65 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 3344
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3344
      __u = (union __anonunion___u_65 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 3344
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 3344
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 3344
    __s = (void *)(accepts);
    {
#line 3344
    __builtin_memset(__s, '\000', (int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))));
    }
    }
  }
#line 3345
  ndests = 0;
#line 3348
  i = 0;
  {
  {
#line 3348
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3348
    if (! (i < (int )cur_nodes->nelem)) {
#line 3348
      goto while_break;
    }
#line 3350
    node = dfa->nodes + *(cur_nodes->elems + i);
#line 3351
    type = node->type;
#line 3352
    constraint = node->constraint;
#line 3355
    if ((unsigned int )type == 26U) {
#line 3356
      accepts[(unsigned long )node->opr.c / (sizeof(unsigned int ) * 8UL)] |= (unsigned int )(1 << (unsigned long )node->opr.c % (sizeof(unsigned int ) * 8UL));
    } else
#line 3357
    if ((unsigned int )type == 21U) {
      {
      {
#line 3359
      bitset_merge((unsigned int *)(accepts), (unsigned int */* const  */)node->opr.sbcset);
      }
      }
    } else
#line 3361
    if ((unsigned int )type == 25U) {
#line 3363
      if (sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)) <= 16UL) {
#line 3363
        if (sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)) == 1UL) {
#line 3363
          __s___4 = (void *)(accepts);
#line 3363
          *((__uint8_t *)__s___4) = (__uint8_t )255;
        } else {
#line 3363
          __s___3 = (void *)(accepts);
#line 3363
          __u___0 = (union __anonunion___u_66 *)__s___3;
#line 3363
          __c___0 = (__uint8_t )255;
          {
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 15U) {
#line 3363
            goto case_15___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 11U) {
#line 3363
            goto case_11___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 7U) {
#line 3363
            goto case_7___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 3U) {
#line 3363
            goto case_3___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 14U) {
#line 3363
            goto case_14___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 10U) {
#line 3363
            goto case_10___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 6U) {
#line 3363
            goto case_6___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 2U) {
#line 3363
            goto case_2___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 13U) {
#line 3363
            goto case_13___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 9U) {
#line 3363
            goto case_9___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 5U) {
#line 3363
            goto case_5___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 1U) {
#line 3363
            goto case_1___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 16U) {
#line 3363
            goto case_16___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 12U) {
#line 3363
            goto case_12___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 8U) {
#line 3363
            goto case_8___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 4U) {
#line 3363
            goto case_4___0;
          }
#line 3363
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 0U) {
#line 3363
            goto case_0___0;
          }
#line 3363
          goto switch_break___0;
          case_15___0: /* CIL Label */ 
#line 3363
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 3363
          __u___0 = (union __anonunion___u_66 *)((void *)__u___0 + 4);
          case_11___0: /* CIL Label */ 
#line 3363
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 3363
          __u___0 = (union __anonunion___u_66 *)((void *)__u___0 + 4);
          case_7___0: /* CIL Label */ 
#line 3363
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 3363
          __u___0 = (union __anonunion___u_66 *)((void *)__u___0 + 4);
          case_3___0: /* CIL Label */ 
#line 3363
          __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 3363
          __u___0 = (union __anonunion___u_66 *)((void *)__u___0 + 2);
#line 3363
          __u___0->__uc = __c___0;
#line 3363
          goto switch_break___0;
          case_14___0: /* CIL Label */ 
#line 3363
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 3363
          __u___0 = (union __anonunion___u_66 *)((void *)__u___0 + 4);
          case_10___0: /* CIL Label */ 
#line 3363
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 3363
          __u___0 = (union __anonunion___u_66 *)((void *)__u___0 + 4);
          case_6___0: /* CIL Label */ 
#line 3363
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 3363
          __u___0 = (union __anonunion___u_66 *)((void *)__u___0 + 4);
          case_2___0: /* CIL Label */ 
#line 3363
          __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 3363
          goto switch_break___0;
          case_13___0: /* CIL Label */ 
#line 3363
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 3363
          __u___0 = (union __anonunion___u_66 *)((void *)__u___0 + 4);
          case_9___0: /* CIL Label */ 
#line 3363
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 3363
          __u___0 = (union __anonunion___u_66 *)((void *)__u___0 + 4);
          case_5___0: /* CIL Label */ 
#line 3363
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 3363
          __u___0 = (union __anonunion___u_66 *)((void *)__u___0 + 4);
          case_1___0: /* CIL Label */ 
#line 3363
          __u___0->__uc = __c___0;
#line 3363
          goto switch_break___0;
          case_16___0: /* CIL Label */ 
#line 3363
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 3363
          __u___0 = (union __anonunion___u_66 *)((void *)__u___0 + 4);
          case_12___0: /* CIL Label */ 
#line 3363
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 3363
          __u___0 = (union __anonunion___u_66 *)((void *)__u___0 + 4);
          case_8___0: /* CIL Label */ 
#line 3363
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 3363
          __u___0 = (union __anonunion___u_66 *)((void *)__u___0 + 4);
          case_4___0: /* CIL Label */ 
#line 3363
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
          case_0___0: /* CIL Label */ 
#line 3363
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        }
      } else {
        {
        {
#line 3363
        memset((void *)(accepts), 255, (size_t )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))));
        }
        }
      }
#line 3364
      if (! (preg->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3365
        accepts[10UL / (sizeof(unsigned int ) * 8UL)] &= (unsigned int )(~ (1 << 10UL % (sizeof(unsigned int ) * 8UL)));
      }
#line 3366
      if (preg->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3367
        accepts[0UL / (sizeof(unsigned int ) * 8UL)] &= (unsigned int )(~ (1 << 0UL % (sizeof(unsigned int ) * 8UL)));
      }
    } else {
#line 3370
      goto __Cont;
    }
#line 3374
    if (constraint) {
#line 3376
      if (constraint & 32U) {
#line 3378
        accepts_newline = (int )(accepts[10UL / (sizeof(unsigned int ) * 8UL)] & (unsigned int )(1 << 10UL % (sizeof(unsigned int ) * 8UL)));
#line 3379
        if (sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)) <= 16UL) {
#line 3379
          if (sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)) == 1UL) {
#line 3379
            __s___7 = (void *)(accepts);
#line 3379
            *((__uint8_t *)__s___7) = (__uint8_t )0;
          } else {
#line 3379
            __s___6 = (void *)(accepts);
#line 3379
            __u___1 = (union __anonunion___u_67 *)__s___6;
#line 3379
            __c___1 = (__uint8_t )0;
            {
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 15U) {
#line 3379
              goto case_15___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 11U) {
#line 3379
              goto case_11___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 7U) {
#line 3379
              goto case_7___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 3U) {
#line 3379
              goto case_3___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 14U) {
#line 3379
              goto case_14___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 10U) {
#line 3379
              goto case_10___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 6U) {
#line 3379
              goto case_6___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 2U) {
#line 3379
              goto case_2___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 13U) {
#line 3379
              goto case_13___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 9U) {
#line 3379
              goto case_9___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 5U) {
#line 3379
              goto case_5___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 1U) {
#line 3379
              goto case_1___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 16U) {
#line 3379
              goto case_16___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 12U) {
#line 3379
              goto case_12___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 8U) {
#line 3379
              goto case_8___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 4U) {
#line 3379
              goto case_4___1;
            }
#line 3379
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 0U) {
#line 3379
              goto case_0___1;
            }
#line 3379
            goto switch_break___1;
            case_15___1: /* CIL Label */ 
#line 3379
            __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 3379
            __u___1 = (union __anonunion___u_67 *)((void *)__u___1 + 4);
            case_11___1: /* CIL Label */ 
#line 3379
            __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 3379
            __u___1 = (union __anonunion___u_67 *)((void *)__u___1 + 4);
            case_7___1: /* CIL Label */ 
#line 3379
            __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 3379
            __u___1 = (union __anonunion___u_67 *)((void *)__u___1 + 4);
            case_3___1: /* CIL Label */ 
#line 3379
            __u___1->__usi = (unsigned short )((int )((unsigned short )__c___1) * 257);
#line 3379
            __u___1 = (union __anonunion___u_67 *)((void *)__u___1 + 2);
#line 3379
            __u___1->__uc = __c___1;
#line 3379
            goto switch_break___1;
            case_14___1: /* CIL Label */ 
#line 3379
            __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 3379
            __u___1 = (union __anonunion___u_67 *)((void *)__u___1 + 4);
            case_10___1: /* CIL Label */ 
#line 3379
            __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 3379
            __u___1 = (union __anonunion___u_67 *)((void *)__u___1 + 4);
            case_6___1: /* CIL Label */ 
#line 3379
            __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 3379
            __u___1 = (union __anonunion___u_67 *)((void *)__u___1 + 4);
            case_2___1: /* CIL Label */ 
#line 3379
            __u___1->__usi = (unsigned short )((int )((unsigned short )__c___1) * 257);
#line 3379
            goto switch_break___1;
            case_13___1: /* CIL Label */ 
#line 3379
            __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 3379
            __u___1 = (union __anonunion___u_67 *)((void *)__u___1 + 4);
            case_9___1: /* CIL Label */ 
#line 3379
            __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 3379
            __u___1 = (union __anonunion___u_67 *)((void *)__u___1 + 4);
            case_5___1: /* CIL Label */ 
#line 3379
            __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 3379
            __u___1 = (union __anonunion___u_67 *)((void *)__u___1 + 4);
            case_1___1: /* CIL Label */ 
#line 3379
            __u___1->__uc = __c___1;
#line 3379
            goto switch_break___1;
            case_16___1: /* CIL Label */ 
#line 3379
            __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 3379
            __u___1 = (union __anonunion___u_67 *)((void *)__u___1 + 4);
            case_12___1: /* CIL Label */ 
#line 3379
            __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 3379
            __u___1 = (union __anonunion___u_67 *)((void *)__u___1 + 4);
            case_8___1: /* CIL Label */ 
#line 3379
            __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
#line 3379
            __u___1 = (union __anonunion___u_67 *)((void *)__u___1 + 4);
            case_4___1: /* CIL Label */ 
#line 3379
            __u___1->__ui = (unsigned int )((int )__c___1 * 16843009);
            case_0___1: /* CIL Label */ 
#line 3379
            goto switch_break___1;
            switch_break___1: /* CIL Label */ ;
            }
          }
        } else {
          {
#line 3379
          __s___5 = (void *)(accepts);
          {
#line 3379
          __builtin_memset(__s___5, '\000', (int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))));
          }
          }
        }
#line 3380
        if (accepts_newline) {
#line 3381
          accepts[10UL / (sizeof(unsigned int ) * 8UL)] |= (unsigned int )(1 << 10UL % (sizeof(unsigned int ) * 8UL));
        } else {
#line 3383
          goto __Cont;
        }
      }
#line 3385
      if (constraint & 128U) {
#line 3387
        if (sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)) <= 16UL) {
#line 3387
          if (sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)) == 1UL) {
#line 3387
            __s___10 = (void *)(accepts);
#line 3387
            *((__uint8_t *)__s___10) = (__uint8_t )0;
          } else {
#line 3387
            __s___9 = (void *)(accepts);
#line 3387
            __u___2 = (union __anonunion___u_68 *)__s___9;
#line 3387
            __c___2 = (__uint8_t )0;
            {
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 15U) {
#line 3387
              goto case_15___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 11U) {
#line 3387
              goto case_11___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 7U) {
#line 3387
              goto case_7___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 3U) {
#line 3387
              goto case_3___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 14U) {
#line 3387
              goto case_14___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 10U) {
#line 3387
              goto case_10___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 6U) {
#line 3387
              goto case_6___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 2U) {
#line 3387
              goto case_2___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 13U) {
#line 3387
              goto case_13___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 9U) {
#line 3387
              goto case_9___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 5U) {
#line 3387
              goto case_5___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 1U) {
#line 3387
              goto case_1___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 16U) {
#line 3387
              goto case_16___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 12U) {
#line 3387
              goto case_12___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 8U) {
#line 3387
              goto case_8___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 4U) {
#line 3387
              goto case_4___2;
            }
#line 3387
            if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 0U) {
#line 3387
              goto case_0___2;
            }
#line 3387
            goto switch_break___2;
            case_15___2: /* CIL Label */ 
#line 3387
            __u___2->__ui = (unsigned int )((int )__c___2 * 16843009);
#line 3387
            __u___2 = (union __anonunion___u_68 *)((void *)__u___2 + 4);
            case_11___2: /* CIL Label */ 
#line 3387
            __u___2->__ui = (unsigned int )((int )__c___2 * 16843009);
#line 3387
            __u___2 = (union __anonunion___u_68 *)((void *)__u___2 + 4);
            case_7___2: /* CIL Label */ 
#line 3387
            __u___2->__ui = (unsigned int )((int )__c___2 * 16843009);
#line 3387
            __u___2 = (union __anonunion___u_68 *)((void *)__u___2 + 4);
            case_3___2: /* CIL Label */ 
#line 3387
            __u___2->__usi = (unsigned short )((int )((unsigned short )__c___2) * 257);
#line 3387
            __u___2 = (union __anonunion___u_68 *)((void *)__u___2 + 2);
#line 3387
            __u___2->__uc = __c___2;
#line 3387
            goto switch_break___2;
            case_14___2: /* CIL Label */ 
#line 3387
            __u___2->__ui = (unsigned int )((int )__c___2 * 16843009);
#line 3387
            __u___2 = (union __anonunion___u_68 *)((void *)__u___2 + 4);
            case_10___2: /* CIL Label */ 
#line 3387
            __u___2->__ui = (unsigned int )((int )__c___2 * 16843009);
#line 3387
            __u___2 = (union __anonunion___u_68 *)((void *)__u___2 + 4);
            case_6___2: /* CIL Label */ 
#line 3387
            __u___2->__ui = (unsigned int )((int )__c___2 * 16843009);
#line 3387
            __u___2 = (union __anonunion___u_68 *)((void *)__u___2 + 4);
            case_2___2: /* CIL Label */ 
#line 3387
            __u___2->__usi = (unsigned short )((int )((unsigned short )__c___2) * 257);
#line 3387
            goto switch_break___2;
            case_13___2: /* CIL Label */ 
#line 3387
            __u___2->__ui = (unsigned int )((int )__c___2 * 16843009);
#line 3387
            __u___2 = (union __anonunion___u_68 *)((void *)__u___2 + 4);
            case_9___2: /* CIL Label */ 
#line 3387
            __u___2->__ui = (unsigned int )((int )__c___2 * 16843009);
#line 3387
            __u___2 = (union __anonunion___u_68 *)((void *)__u___2 + 4);
            case_5___2: /* CIL Label */ 
#line 3387
            __u___2->__ui = (unsigned int )((int )__c___2 * 16843009);
#line 3387
            __u___2 = (union __anonunion___u_68 *)((void *)__u___2 + 4);
            case_1___2: /* CIL Label */ 
#line 3387
            __u___2->__uc = __c___2;
#line 3387
            goto switch_break___2;
            case_16___2: /* CIL Label */ 
#line 3387
            __u___2->__ui = (unsigned int )((int )__c___2 * 16843009);
#line 3387
            __u___2 = (union __anonunion___u_68 *)((void *)__u___2 + 4);
            case_12___2: /* CIL Label */ 
#line 3387
            __u___2->__ui = (unsigned int )((int )__c___2 * 16843009);
#line 3387
            __u___2 = (union __anonunion___u_68 *)((void *)__u___2 + 4);
            case_8___2: /* CIL Label */ 
#line 3387
            __u___2->__ui = (unsigned int )((int )__c___2 * 16843009);
#line 3387
            __u___2 = (union __anonunion___u_68 *)((void *)__u___2 + 4);
            case_4___2: /* CIL Label */ 
#line 3387
            __u___2->__ui = (unsigned int )((int )__c___2 * 16843009);
            case_0___2: /* CIL Label */ 
#line 3387
            goto switch_break___2;
            switch_break___2: /* CIL Label */ ;
            }
          }
        } else {
          {
#line 3387
          __s___8 = (void *)(accepts);
          {
#line 3387
          __builtin_memset(__s___8, '\000', (int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))));
          }
          }
        }
#line 3388
        goto __Cont;
      }
#line 3390
      if (constraint & 4U) {
#line 3391
        j = 0;
        {
        {
#line 3391
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 3391
          if (! ((unsigned long )j < ((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) {
#line 3391
            goto while_break___0;
          }
#line 3392
          accepts[j] &= *(dfa->word_char + j);
#line 3391
          j ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 3393
      if (constraint & 8U) {
#line 3394
        j = 0;
        {
        {
#line 3394
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 3394
          if (! ((unsigned long )j < ((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) {
#line 3394
            goto while_break___1;
          }
#line 3395
          accepts[j] &= ~ *(dfa->word_char + j);
#line 3394
          j ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 3400
    j = 0;
    {
    {
#line 3400
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 3400
      if (! (j < ndests)) {
#line 3400
        goto while_break___2;
      }
#line 3408
      if ((unsigned int )type == 26U) {
#line 3408
        if (! ((*(dests_ch + j))[(unsigned long )node->opr.c / (sizeof(unsigned int ) * 8UL)] & (unsigned int )(1 << (unsigned long )node->opr.c % (sizeof(unsigned int ) * 8UL)))) {
#line 3409
          goto __Cont___0;
        }
      }
#line 3412
      has_intersec = 0;
#line 3413
      k = 0;
      {
      {
#line 3413
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 3413
        if (! ((unsigned long )k < ((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) {
#line 3413
          goto while_break___3;
        }
#line 3414
        tmp = accepts[k] & (*(dests_ch + j))[k];
#line 3414
        intersec[k] = tmp;
#line 3414
        has_intersec = (int )((unsigned int )has_intersec | tmp);
#line 3413
        k ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3416
      if (! has_intersec) {
#line 3417
        goto __Cont___0;
      }
#line 3420
      not_consumed = 0;
#line 3420
      not_subset = not_consumed;
#line 3421
      k = 0;
      {
      {
#line 3421
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 3421
        if (! ((unsigned long )k < ((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) {
#line 3421
          goto while_break___4;
        }
#line 3423
        tmp___0 = ~ accepts[k] & (*(dests_ch + j))[k];
#line 3423
        remains[k] = tmp___0;
#line 3423
        not_subset = (int )((unsigned int )not_subset | tmp___0);
#line 3424
        tmp___1 = accepts[k] & ~ (*(dests_ch + j))[k];
#line 3424
        accepts[k] = tmp___1;
#line 3424
        not_consumed = (int )((unsigned int )not_consumed | tmp___1);
#line 3421
        k ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 3429
      if (not_subset) {
        {
        {
#line 3431
        memcpy((void */* __restrict  */)(*(dests_ch + ndests)), (void const   */* __restrict  */)(remains),
               (size_t )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))));
        }
        {
#line 3432
        memcpy((void */* __restrict  */)(*(dests_ch + j)), (void const   */* __restrict  */)(intersec),
               (size_t )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))));
        }
        {
#line 3433
        err = re_node_set_init_copy(dests_node + ndests, (re_node_set const   *)(dests_node + j));
        }
        {
#line 3434
        tmp___2 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        }
#line 3434
        if (tmp___2) {
#line 3435
          goto error_return;
        }
#line 3436
        ndests ++;
      }
      {
      {
#line 3440
      tmp___3 = re_node_set_insert(dests_node + j, *(cur_nodes->elems + i));
      }
#line 3440
      err = (reg_errcode_t )tmp___3;
      {
#line 3441
      tmp___4 = __builtin_expect((long )((unsigned int )err < 0U), 0L);
      }
      }
#line 3441
      if (tmp___4) {
#line 3442
        goto error_return;
      }
#line 3445
      if (! not_consumed) {
#line 3446
        goto while_break___2;
      }
      __Cont___0: /* CIL Label */ 
#line 3400
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3449
    if (j == ndests) {
      {
      {
#line 3451
      memcpy((void */* __restrict  */)(*(dests_ch + ndests)), (void const   */* __restrict  */)(accepts),
             (size_t )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))));
      }
      {
#line 3452
      err = re_node_set_init_1(dests_node + ndests, *(cur_nodes->elems + i));
      }
      {
#line 3453
      tmp___5 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      }
#line 3453
      if (tmp___5) {
#line 3454
        goto error_return;
      }
#line 3455
      ndests ++;
#line 3456
      if (sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)) <= 16UL) {
#line 3456
        if (sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)) == 1UL) {
#line 3456
          __s___13 = (void *)(accepts);
#line 3456
          *((__uint8_t *)__s___13) = (__uint8_t )0;
        } else {
#line 3456
          __s___12 = (void *)(accepts);
#line 3456
          __u___3 = (union __anonunion___u_69 *)__s___12;
#line 3456
          __c___3 = (__uint8_t )0;
          {
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 15U) {
#line 3456
            goto case_15___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 11U) {
#line 3456
            goto case_11___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 7U) {
#line 3456
            goto case_7___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 3U) {
#line 3456
            goto case_3___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 14U) {
#line 3456
            goto case_14___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 10U) {
#line 3456
            goto case_10___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 6U) {
#line 3456
            goto case_6___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 2U) {
#line 3456
            goto case_2___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 13U) {
#line 3456
            goto case_13___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 9U) {
#line 3456
            goto case_9___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 5U) {
#line 3456
            goto case_5___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 1U) {
#line 3456
            goto case_1___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 16U) {
#line 3456
            goto case_16___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 12U) {
#line 3456
            goto case_12___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 8U) {
#line 3456
            goto case_8___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 4U) {
#line 3456
            goto case_4___3;
          }
#line 3456
          if ((unsigned int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))) == 0U) {
#line 3456
            goto case_0___3;
          }
#line 3456
          goto switch_break___3;
          case_15___3: /* CIL Label */ 
#line 3456
          __u___3->__ui = (unsigned int )((int )__c___3 * 16843009);
#line 3456
          __u___3 = (union __anonunion___u_69 *)((void *)__u___3 + 4);
          case_11___3: /* CIL Label */ 
#line 3456
          __u___3->__ui = (unsigned int )((int )__c___3 * 16843009);
#line 3456
          __u___3 = (union __anonunion___u_69 *)((void *)__u___3 + 4);
          case_7___3: /* CIL Label */ 
#line 3456
          __u___3->__ui = (unsigned int )((int )__c___3 * 16843009);
#line 3456
          __u___3 = (union __anonunion___u_69 *)((void *)__u___3 + 4);
          case_3___3: /* CIL Label */ 
#line 3456
          __u___3->__usi = (unsigned short )((int )((unsigned short )__c___3) * 257);
#line 3456
          __u___3 = (union __anonunion___u_69 *)((void *)__u___3 + 2);
#line 3456
          __u___3->__uc = __c___3;
#line 3456
          goto switch_break___3;
          case_14___3: /* CIL Label */ 
#line 3456
          __u___3->__ui = (unsigned int )((int )__c___3 * 16843009);
#line 3456
          __u___3 = (union __anonunion___u_69 *)((void *)__u___3 + 4);
          case_10___3: /* CIL Label */ 
#line 3456
          __u___3->__ui = (unsigned int )((int )__c___3 * 16843009);
#line 3456
          __u___3 = (union __anonunion___u_69 *)((void *)__u___3 + 4);
          case_6___3: /* CIL Label */ 
#line 3456
          __u___3->__ui = (unsigned int )((int )__c___3 * 16843009);
#line 3456
          __u___3 = (union __anonunion___u_69 *)((void *)__u___3 + 4);
          case_2___3: /* CIL Label */ 
#line 3456
          __u___3->__usi = (unsigned short )((int )((unsigned short )__c___3) * 257);
#line 3456
          goto switch_break___3;
          case_13___3: /* CIL Label */ 
#line 3456
          __u___3->__ui = (unsigned int )((int )__c___3 * 16843009);
#line 3456
          __u___3 = (union __anonunion___u_69 *)((void *)__u___3 + 4);
          case_9___3: /* CIL Label */ 
#line 3456
          __u___3->__ui = (unsigned int )((int )__c___3 * 16843009);
#line 3456
          __u___3 = (union __anonunion___u_69 *)((void *)__u___3 + 4);
          case_5___3: /* CIL Label */ 
#line 3456
          __u___3->__ui = (unsigned int )((int )__c___3 * 16843009);
#line 3456
          __u___3 = (union __anonunion___u_69 *)((void *)__u___3 + 4);
          case_1___3: /* CIL Label */ 
#line 3456
          __u___3->__uc = __c___3;
#line 3456
          goto switch_break___3;
          case_16___3: /* CIL Label */ 
#line 3456
          __u___3->__ui = (unsigned int )((int )__c___3 * 16843009);
#line 3456
          __u___3 = (union __anonunion___u_69 *)((void *)__u___3 + 4);
          case_12___3: /* CIL Label */ 
#line 3456
          __u___3->__ui = (unsigned int )((int )__c___3 * 16843009);
#line 3456
          __u___3 = (union __anonunion___u_69 *)((void *)__u___3 + 4);
          case_8___3: /* CIL Label */ 
#line 3456
          __u___3->__ui = (unsigned int )((int )__c___3 * 16843009);
#line 3456
          __u___3 = (union __anonunion___u_69 *)((void *)__u___3 + 4);
          case_4___3: /* CIL Label */ 
#line 3456
          __u___3->__ui = (unsigned int )((int )__c___3 * 16843009);
          case_0___3: /* CIL Label */ 
#line 3456
          goto switch_break___3;
          switch_break___3: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 3456
        __s___11 = (void *)(accepts);
        {
#line 3456
        __builtin_memset(__s___11, '\000', (int )(sizeof(unsigned int ) * (((256UL + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL))));
        }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 3348
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3459
  return (ndests);
  error_return: 
#line 3461
  j = 0;
  {
  {
#line 3461
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 3461
    if (! (j < ndests)) {
#line 3461
      goto while_break___5;
    }
    {
    {
#line 3462
    free((void *)(dests_node + j)->elems);
    }
#line 3461
    j ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 3463
  return (-1);
}
}
#line 3475 "regexec.c"
static int check_node_accept_bytes(regex_t const   *preg , int node_idx , re_string_t const   *input ,
                                   int str_idx ) 
{ 
  re_dfa_t const   *dfa ;
  re_token_t const   *node ;
  int elem_len ;
  int tmp ;
  int char_len ;
  int tmp___0 ;
  int i ;
  re_charset_t const   *cset ;
  int match_len ;
  wchar_t wc ;
  wint_t tmp___1 ;
  wint_t tmp___2 ;
  wctype_t wt ;
  int tmp___3 ;
  wchar_t cmp_buf[6] ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp23 ;

  {
  {
#line 3481
  dfa = (re_dfa_t const   *)((re_dfa_t *)preg->buffer);
#line 3482
  node = (re_token_t const   *)(dfa->nodes + node_idx);
  {
#line 3483
  tmp = re_string_elem_size_at(input, str_idx);
  }
#line 3483
  elem_len = tmp;
  {
#line 3484
  tmp___0 = re_string_char_size_at(input, str_idx);
  }
#line 3484
  char_len = tmp___0;
  }
#line 3490
  if (elem_len <= 1) {
#line 3490
    if (char_len <= 1) {
#line 3491
      return (0);
    }
  }
#line 3492
  if ((unsigned int const   )node->type == 25U) {
#line 3495
    if (! (preg->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3495
      if ((int )*(input->mbs + str_idx) == 10) {
#line 3499
        return (0);
      } else {
#line 3495
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3495
    if (preg->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3495
      if ((int )*(input->mbs + str_idx) == 0) {
#line 3499
        return (0);
      }
    }
#line 3500
    return (char_len);
  } else
#line 3502
  if ((unsigned int const   )node->type == 22U) {
#line 3504
    cset = (re_charset_t const   *)node->opr.mbcset;
#line 3509
    match_len = 0;
#line 3510
    if (cset->nranges) {
      {
      {
#line 3510
      tmp___1 = re_string_wchar_at(input, str_idx);
      }
#line 3510
      tmp___2 = tmp___1;
      }
    } else
#line 3510
    if (cset->nchar_classes) {
      {
      {
#line 3510
      tmp___1 = re_string_wchar_at(input, str_idx);
      }
#line 3510
      tmp___2 = tmp___1;
      }
    } else
#line 3510
    if (cset->nmbchars) {
      {
      {
#line 3510
      tmp___1 = re_string_wchar_at(input, str_idx);
      }
#line 3510
      tmp___2 = tmp___1;
      }
    } else {
#line 3510
      tmp___2 = (wint_t )0;
    }
#line 3510
    wc = (wchar_t )tmp___2;
#line 3514
    i = 0;
    {
    {
#line 3514
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 3514
      if (! (i < (int )cset->nmbchars)) {
#line 3514
        goto while_break;
      }
#line 3515
      if (wc == *(cset->mbchars + i)) {
#line 3517
        match_len = char_len;
#line 3518
        goto check_node_accept_bytes_match;
      }
#line 3514
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 3521
    i = 0;
    {
    {
#line 3521
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 3521
      if (! (i < (int )cset->nchar_classes)) {
#line 3521
        goto while_break___0;
      }
      {
#line 3523
      wt = *(cset->char_classes + i);
      {
#line 3524
      tmp___3 = iswctype((wint_t )wc, wt);
      }
      }
#line 3524
      if (tmp___3) {
#line 3526
        match_len = char_len;
#line 3527
        goto check_node_accept_bytes_match;
      }
#line 3521
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3623
    cmp_buf[0] = (wchar_t )0;
#line 3623
    cmp_buf[1] = (wchar_t )0;
#line 3623
    cmp_buf[2] = wc;
#line 3623
    cmp_buf[3] = (wchar_t )0;
#line 3623
    cmp_buf[4] = (wchar_t )0;
#line 3623
    cmp_buf[5] = (wchar_t )0;
#line 3628
    i = 0;
    {
    {
#line 3628
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 3628
      if (! (i < (int )cset->nranges)) {
#line 3628
        goto while_break___1;
      }
      {
#line 3630
      cmp_buf[0] = *(cset->range_starts + i);
#line 3631
      cmp_buf[4] = *(cset->range_ends + i);
      {
#line 3632
      tmp___4 = wcscoll((wchar_t const   *)(cmp_buf), (wchar_t const   *)(cmp_buf + 2));
      }
      }
#line 3632
      if (tmp___4 <= 0) {
        {
        {
#line 3632
        tmp___5 = wcscoll((wchar_t const   *)(cmp_buf + 2), (wchar_t const   *)(cmp_buf + 4));
        }
        }
#line 3632
        if (tmp___5 <= 0) {
#line 3635
          match_len = char_len;
#line 3636
          goto check_node_accept_bytes_match;
        }
      }
#line 3628
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    check_node_accept_bytes_match: 
#line 3641
    if (! cset->non_match) {
#line 3642
      return (match_len);
    } else
#line 3645
    if (match_len > 0) {
#line 3646
      return (0);
    } else {
#line 3648
      if (elem_len > char_len) {
#line 3648
        tmp___6 = elem_len;
      } else {
#line 3648
        tmp___6 = char_len;
      }
#line 3648
      return (tmp___6);
    }
  }
#line 3651
  return (0);
}
}
#line 3716 "regexec.c"
static int check_node_accept(regex_t const   *preg , re_token_t const   *node , re_match_context_t const   *mctx ,
                             int idx ) 
{ 
  unsigned char ch ;
  unsigned int context ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 3724
  if (node->constraint) {
    {
    {
#line 3728
    tmp = re_string_context_at((re_string_t const   *)mctx->input, idx, (int )mctx->eflags,
                               (int )preg->newline_anchor);
    }
#line 3728
    context = tmp;
    }
#line 3731
    if (node->constraint & 4U) {
#line 3731
      if (! (context & 1U)) {
#line 3732
        return (0);
      } else {
#line 3731
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 3731
    if (node->constraint & 8U) {
#line 3731
      if (context & 1U) {
#line 3732
        return (0);
      } else {
#line 3731
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 3731
    if (node->constraint & 32U) {
#line 3731
      if (! (context & (unsigned int )(1 << 1))) {
#line 3732
        return (0);
      } else {
#line 3731
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3731
    if (node->constraint & 128U) {
#line 3731
      if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 3732
        return (0);
      }
    }
  }
#line 3734
  ch = *((mctx->input)->mbs + idx);
#line 3735
  if ((unsigned int const   )node->type == 26U) {
#line 3736
    return ((int const   )node->opr.c == (int const   )ch);
  } else
#line 3737
  if ((unsigned int const   )node->type == 21U) {
#line 3738
    return ((int )(*(node->opr.sbcset + (unsigned long )ch / (sizeof(unsigned int ) * 8UL)) & (unsigned int )(1 << (unsigned long )ch % (sizeof(unsigned int ) * 8UL))));
  } else
#line 3739
  if ((unsigned int const   )node->type == 25U) {
#line 3740
    if ((int )ch == 10) {
#line 3740
      if (! (preg->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3740
        tmp___0 = 0;
      } else {
#line 3740
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 3740
    if ((int )ch == 0) {
#line 3740
      if (preg->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3740
        tmp___0 = 0;
      } else {
#line 3740
        tmp___0 = 1;
      }
    } else {
#line 3740
      tmp___0 = 1;
    }
#line 3740
    return (tmp___0);
  } else {
#line 3743
    return (0);
  }
}
}
#line 3748 "regexec.c"
static reg_errcode_t extend_buffers(re_match_context_t *mctx ) 
{ 
  reg_errcode_t ret ;
  re_string_t *pstr ;
  long tmp ;
  re_dfastate_t **new_array ;
  void *tmp___0 ;
  long tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 3753
  pstr = mctx->input;
  {
#line 3756
  ret = re_string_realloc_buffers(pstr, pstr->bufs_len * 2);
  }
  {
#line 3757
  tmp = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
  }
  }
#line 3757
  if (tmp) {
#line 3758
    return (ret);
  }
#line 3760
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
    {
    {
#line 3764
    tmp___0 = realloc((void *)mctx->state_log, (size_t )((unsigned long )(pstr->bufs_len * 2) * sizeof(re_dfastate_t *)));
    }
#line 3764
    new_array = (re_dfastate_t **)tmp___0;
    {
#line 3766
    tmp___1 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 3766
    if (tmp___1) {
#line 3767
      return ((reg_errcode_t )12);
    }
#line 3768
    mctx->state_log = new_array;
  }
#line 3772
  if (pstr->icase) {
    {
    {
#line 3775
    tmp___2 = __ctype_get_mb_cur_max();
    }
    }
#line 3775
    if (tmp___2 > 1U) {
      {
      {
#line 3776
      build_wcs_upper_buffer(pstr);
      }
      }
    } else {
      {
      {
#line 3779
      build_upper_buffer(pstr);
      }
      }
    }
  } else {
    {
    {
#line 3784
    tmp___3 = __ctype_get_mb_cur_max();
    }
    }
#line 3784
    if (tmp___3 > 1U) {
      {
      {
#line 3785
      build_wcs_buffer(pstr);
      }
      }
    } else
#line 3789
    if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
      {
      {
#line 3790
      re_string_translate_buffer(pstr);
      }
      }
    } else {
#line 3792
      pstr->valid_len = pstr->bufs_len;
    }
  }
#line 3795
  return ((reg_errcode_t )0);
}
}
#line 3803 "regexec.c"
static reg_errcode_t match_ctx_init(re_match_context_t *mctx , int eflags , re_string_t *input ,
                                    int n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 3809
  mctx->eflags = eflags;
#line 3810
  mctx->input = input;
#line 3811
  mctx->match_last = -1;
#line 3812
  if (n > 0) {
    {
    {
#line 3814
    tmp = malloc((size_t )((unsigned long )n * sizeof(struct re_backref_cache_entry )));
    }
#line 3814
    mctx->bkref_ents = (struct re_backref_cache_entry *)tmp;
    {
#line 3815
    tmp___0 = malloc((size_t )((unsigned long )n * sizeof(re_sub_match_top_t *)));
    }
#line 3815
    mctx->sub_tops = (re_sub_match_top_t **)tmp___0;
    }
#line 3816
    if ((unsigned long )mctx->bkref_ents == (unsigned long )((void *)0)) {
#line 3816
      tmp___1 = 1;
    } else
#line 3816
    if ((unsigned long )mctx->sub_tops == (unsigned long )((void *)0)) {
#line 3816
      tmp___1 = 1;
    } else {
#line 3816
      tmp___1 = 0;
    }
    {
    {
#line 3816
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    }
#line 3816
    if (tmp___2) {
#line 3817
      return ((reg_errcode_t )12);
    }
  } else {
#line 3820
    mctx->bkref_ents = (struct re_backref_cache_entry *)((void *)0);
  }
#line 3821
  mctx->nbkref_ents = 0;
#line 3822
  mctx->abkref_ents = n;
#line 3823
  mctx->max_mb_elem_len = 1;
#line 3824
  mctx->nsub_tops = 0;
#line 3825
  mctx->asub_tops = n;
#line 3826
  return ((reg_errcode_t )0);
}
}
#line 3833 "regexec.c"
static void match_ctx_clean(re_match_context_t *mctx ) 
{ 


  {
  {
  {
#line 3837
  match_ctx_free_subtops(mctx);
  }
#line 3838
  mctx->nsub_tops = 0;
#line 3839
  mctx->nbkref_ents = 0;
  }
#line 3840
  return;
}
}
#line 3844 "regexec.c"
static void match_ctx_free(re_match_context_t *mctx ) 
{ 


  {
  {
  {
#line 3848
  match_ctx_free_subtops(mctx);
  }
  {
#line 3849
  free((void *)mctx->sub_tops);
  }
  {
#line 3850
  free((void *)mctx->bkref_ents);
  }
  }
#line 3851
  return;
}
}
#line 3855 "regexec.c"
static void match_ctx_free_subtops(re_match_context_t *mctx ) 
{ 
  int st_idx ;
  int sl_idx ;
  re_sub_match_top_t *top ;
  re_sub_match_last_t *last ;

  {
#line 3860
  st_idx = 0;
  {
  {
#line 3860
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3860
    if (! (st_idx < mctx->nsub_tops)) {
#line 3860
      goto while_break;
    }
#line 3863
    top = *(mctx->sub_tops + st_idx);
#line 3864
    sl_idx = 0;
    {
    {
#line 3864
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 3864
      if (! (sl_idx < top->nlasts)) {
#line 3864
        goto while_break___0;
      }
      {
#line 3866
      last = *(top->lasts + sl_idx);
      {
#line 3867
      free((void *)last->path.array);
      }
      {
#line 3868
      free((void *)last);
      }
#line 3864
      sl_idx ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 3870
    free((void *)top->lasts);
    }
    }
#line 3871
    if (top->path) {
      {
      {
#line 3873
      free((void *)(top->path)->array);
      }
      {
#line 3874
      free((void *)top->path);
      }
      }
    }
    {
    {
#line 3876
    free((void *)top);
    }
#line 3860
    st_idx ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3878
  return;
}
}
#line 3885 "regexec.c"
static reg_errcode_t match_ctx_add_entry(re_match_context_t *mctx , int node , int str_idx ,
                                         int from , int to ) 
{ 
  struct re_backref_cache_entry *new_entry ;
  void *tmp ;
  long tmp___0 ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_70 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  int tmp___1 ;

  {
#line 3890
  if (mctx->nbkref_ents >= mctx->abkref_ents) {
    {
    {
#line 3893
    tmp = realloc((void *)mctx->bkref_ents, (size_t )((unsigned long )(mctx->abkref_ents * 2) * sizeof(struct re_backref_cache_entry )));
    }
#line 3893
    new_entry = (struct re_backref_cache_entry *)tmp;
    {
#line 3895
    tmp___0 = __builtin_expect((long )((unsigned long )new_entry == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 3895
    if (tmp___0) {
      {
      {
#line 3897
      free((void *)mctx->bkref_ents);
      }
      }
#line 3898
      return ((reg_errcode_t )12);
    }
#line 3900
    mctx->bkref_ents = new_entry;
#line 3901
    if (0) {
#line 3901
      if (sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents == 1UL) {
#line 3901
        __s___1 = (void *)(mctx->bkref_ents + mctx->nbkref_ents);
#line 3901
        *((__uint8_t *)__s___1) = (__uint8_t )'\000';
      } else {
#line 3901
        __s___0 = (void *)(mctx->bkref_ents + mctx->nbkref_ents);
#line 3901
        __u = (union __anonunion___u_70 *)__s___0;
#line 3901
        __c = (__uint8_t )'\000';
        {
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 15U) {
#line 3901
          goto case_15;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 11U) {
#line 3901
          goto case_11;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 7U) {
#line 3901
          goto case_7;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 3U) {
#line 3901
          goto case_3;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 14U) {
#line 3901
          goto case_14;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 10U) {
#line 3901
          goto case_10;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 6U) {
#line 3901
          goto case_6;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 2U) {
#line 3901
          goto case_2;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 13U) {
#line 3901
          goto case_13;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 9U) {
#line 3901
          goto case_9;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 5U) {
#line 3901
          goto case_5;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 1U) {
#line 3901
          goto case_1;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 16U) {
#line 3901
          goto case_16;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 12U) {
#line 3901
          goto case_12;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 8U) {
#line 3901
          goto case_8;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 4U) {
#line 3901
          goto case_4;
        }
#line 3901
        if ((unsigned int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents) == 0U) {
#line 3901
          goto case_0;
        }
#line 3901
        goto switch_break;
        case_15: /* CIL Label */ 
#line 3901
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3901
        __u = (union __anonunion___u_70 *)((void *)__u + 4);
        case_11: /* CIL Label */ 
#line 3901
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3901
        __u = (union __anonunion___u_70 *)((void *)__u + 4);
        case_7: /* CIL Label */ 
#line 3901
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3901
        __u = (union __anonunion___u_70 *)((void *)__u + 4);
        case_3: /* CIL Label */ 
#line 3901
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 3901
        __u = (union __anonunion___u_70 *)((void *)__u + 2);
#line 3901
        __u->__uc = __c;
#line 3901
        goto switch_break;
        case_14: /* CIL Label */ 
#line 3901
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3901
        __u = (union __anonunion___u_70 *)((void *)__u + 4);
        case_10: /* CIL Label */ 
#line 3901
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3901
        __u = (union __anonunion___u_70 *)((void *)__u + 4);
        case_6: /* CIL Label */ 
#line 3901
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3901
        __u = (union __anonunion___u_70 *)((void *)__u + 4);
        case_2: /* CIL Label */ 
#line 3901
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 3901
        goto switch_break;
        case_13: /* CIL Label */ 
#line 3901
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3901
        __u = (union __anonunion___u_70 *)((void *)__u + 4);
        case_9: /* CIL Label */ 
#line 3901
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3901
        __u = (union __anonunion___u_70 *)((void *)__u + 4);
        case_5: /* CIL Label */ 
#line 3901
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3901
        __u = (union __anonunion___u_70 *)((void *)__u + 4);
        case_1: /* CIL Label */ 
#line 3901
        __u->__uc = __c;
#line 3901
        goto switch_break;
        case_16: /* CIL Label */ 
#line 3901
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3901
        __u = (union __anonunion___u_70 *)((void *)__u + 4);
        case_12: /* CIL Label */ 
#line 3901
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3901
        __u = (union __anonunion___u_70 *)((void *)__u + 4);
        case_8: /* CIL Label */ 
#line 3901
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 3901
        __u = (union __anonunion___u_70 *)((void *)__u + 4);
        case_4: /* CIL Label */ 
#line 3901
        __u->__ui = (unsigned int )((int )__c * 16843009);
        case_0: /* CIL Label */ 
#line 3901
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 3901
      __s = (void *)(mctx->bkref_ents + mctx->nbkref_ents);
      {
#line 3901
      __builtin_memset(__s, '\000', (int )(sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents));
      }
      }
    }
#line 3903
    mctx->abkref_ents *= 2;
  }
#line 3905
  (mctx->bkref_ents + mctx->nbkref_ents)->node = node;
#line 3906
  (mctx->bkref_ents + mctx->nbkref_ents)->str_idx = str_idx;
#line 3907
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_from = from;
#line 3908
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_to = to;
#line 3909
  tmp___1 = mctx->nbkref_ents;
#line 3909
  (mctx->nbkref_ents) ++;
#line 3909
  (mctx->bkref_ents + tmp___1)->flag = 0;
#line 3910
  if (mctx->max_mb_elem_len < to - from) {
#line 3911
    mctx->max_mb_elem_len = to - from;
  }
#line 3912
  return ((reg_errcode_t )0);
}
}
#line 3918 "regexec.c"
static int search_cur_bkref_entry(re_match_context_t *mctx , int str_idx ) 
{ 
  int left ;
  int right ;
  int mid ;

  {
#line 3924
  right = mctx->nbkref_ents;
#line 3925
  left = 0;
  {
  {
#line 3925
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3925
    if (! (left < right)) {
#line 3925
      goto while_break;
    }
#line 3927
    mid = (left + right) / 2;
#line 3928
    if ((mctx->bkref_ents + mid)->str_idx < str_idx) {
#line 3929
      left = mid + 1;
    } else {
#line 3931
      right = mid;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3933
  return (left);
}
}
#line 3936 "regexec.c"
static void match_ctx_clear_flag(re_match_context_t *mctx ) 
{ 
  int i ;

  {
#line 3941
  i = 0;
  {
  {
#line 3941
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3941
    if (! (i < mctx->nbkref_ents)) {
#line 3941
      goto while_break;
    }
#line 3943
    (mctx->bkref_ents + i)->flag = 0;
#line 3941
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3945
  return;
}
}
#line 3950 "regexec.c"
static reg_errcode_t match_ctx_add_subtop(re_match_context_t *mctx , int node , int str_idx ) 
{ 
  re_sub_match_top_t **new_array ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3959
  if (mctx->nsub_tops == mctx->asub_tops) {
    {
#line 3962
    mctx->asub_tops *= 2;
    {
#line 3963
    tmp = realloc((void *)mctx->sub_tops, (size_t )((unsigned long )mctx->asub_tops * sizeof(re_sub_match_top_t *)));
    }
#line 3963
    new_array = (re_sub_match_top_t **)tmp;
    {
#line 3965
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 3965
    if (tmp___0) {
#line 3966
      return ((reg_errcode_t )12);
    }
#line 3967
    mctx->sub_tops = new_array;
  }
  {
  {
#line 3969
  tmp___1 = calloc((size_t )1, (size_t )sizeof(re_sub_match_top_t ));
  }
#line 3969
  *(mctx->sub_tops + mctx->nsub_tops) = (re_sub_match_top_t *)tmp___1;
  }
#line 3970
  if ((unsigned long )*(mctx->sub_tops + mctx->nsub_tops) == (unsigned long )((void *)0)) {
#line 3971
    return ((reg_errcode_t )12);
  }
#line 3972
  (*(mctx->sub_tops + mctx->nsub_tops))->node = node;
#line 3973
  tmp___2 = mctx->nsub_tops;
#line 3973
  (mctx->nsub_tops) ++;
#line 3973
  (*(mctx->sub_tops + tmp___2))->str_idx = str_idx;
#line 3974
  return ((reg_errcode_t )0);
}
}
#line 3980 "regexec.c"
static re_sub_match_last_t *match_ctx_add_sublast(re_sub_match_top_t *subtop , int node ,
                                                  int str_idx ) 
{ 
  re_sub_match_last_t *new_entry ;
  re_sub_match_last_t **new_array ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;

  {
#line 3986
  if (subtop->nlasts == subtop->alasts) {
    {
#line 3989
    subtop->alasts = 2 * subtop->alasts + 1;
    {
#line 3990
    tmp = realloc((void *)subtop->lasts, (size_t )((unsigned long )subtop->alasts * sizeof(re_sub_match_last_t *)));
    }
#line 3990
    new_array = (re_sub_match_last_t **)tmp;
    {
#line 3992
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
    }
#line 3992
    if (tmp___0) {
#line 3993
      return ((re_sub_match_last_t *)((void *)0));
    }
#line 3994
    subtop->lasts = new_array;
  }
  {
  {
#line 3996
  tmp___1 = calloc((size_t )1, (size_t )sizeof(re_sub_match_last_t ));
  }
#line 3996
  new_entry = (re_sub_match_last_t *)tmp___1;
  {
#line 3997
  tmp___2 = __builtin_expect((long )((unsigned long )new_entry == (unsigned long )((void *)0)),
                             0L);
  }
  }
#line 3997
  if (tmp___2) {
#line 3998
    return ((re_sub_match_last_t *)((void *)0));
  }
#line 3999
  *(subtop->lasts + subtop->nlasts) = new_entry;
#line 4000
  new_entry->node = node;
#line 4001
  new_entry->str_idx = str_idx;
#line 4002
  (subtop->nlasts) ++;
#line 4003
  return (new_entry);
}
}
#line 4006 "regexec.c"
static void sift_ctx_init(re_sift_context_t *sctx , re_dfastate_t **sifted_sts , re_dfastate_t **limited_sts ,
                          int last_node , int last_str_idx , int check_subexp ) 
{ 
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_71 *__u ;
  __uint8_t __c ;
  void *__s___1 ;

  {
#line 4013
  sctx->sifted_states = sifted_sts;
#line 4014
  sctx->limited_states = limited_sts;
#line 4015
  sctx->last_node = last_node;
#line 4016
  sctx->last_str_idx = last_str_idx;
#line 4017
  sctx->check_subexp = check_subexp;
#line 4018
  sctx->cur_bkref = -1;
#line 4019
  sctx->cls_subexp_idx = -1;
#line 4020
  if (sizeof(re_node_set ) <= 16UL) {
#line 4020
    if (sizeof(re_node_set ) == 1UL) {
#line 4020
      __s___1 = (void *)(& sctx->limits);
#line 4020
      *((__uint8_t *)__s___1) = (__uint8_t )'\000';
    } else {
#line 4020
      __s___0 = (void *)(& sctx->limits);
#line 4020
      __u = (union __anonunion___u_71 *)__s___0;
#line 4020
      __c = (__uint8_t )'\000';
      {
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 15U) {
#line 4020
        goto case_15;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 11U) {
#line 4020
        goto case_11;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 7U) {
#line 4020
        goto case_7;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 3U) {
#line 4020
        goto case_3;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 14U) {
#line 4020
        goto case_14;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 10U) {
#line 4020
        goto case_10;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 6U) {
#line 4020
        goto case_6;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 2U) {
#line 4020
        goto case_2;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 13U) {
#line 4020
        goto case_13;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 9U) {
#line 4020
        goto case_9;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 5U) {
#line 4020
        goto case_5;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 1U) {
#line 4020
        goto case_1;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 16U) {
#line 4020
        goto case_16;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 12U) {
#line 4020
        goto case_12;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 8U) {
#line 4020
        goto case_8;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 4U) {
#line 4020
        goto case_4;
      }
#line 4020
      if ((unsigned int )sizeof(re_node_set ) == 0U) {
#line 4020
        goto case_0;
      }
#line 4020
      goto switch_break;
      case_15: /* CIL Label */ 
#line 4020
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 4020
      __u = (union __anonunion___u_71 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 4020
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 4020
      __u = (union __anonunion___u_71 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 4020
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 4020
      __u = (union __anonunion___u_71 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 4020
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 4020
      __u = (union __anonunion___u_71 *)((void *)__u + 2);
#line 4020
      __u->__uc = __c;
#line 4020
      goto switch_break;
      case_14: /* CIL Label */ 
#line 4020
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 4020
      __u = (union __anonunion___u_71 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 4020
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 4020
      __u = (union __anonunion___u_71 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 4020
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 4020
      __u = (union __anonunion___u_71 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 4020
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 4020
      goto switch_break;
      case_13: /* CIL Label */ 
#line 4020
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 4020
      __u = (union __anonunion___u_71 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 4020
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 4020
      __u = (union __anonunion___u_71 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 4020
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 4020
      __u = (union __anonunion___u_71 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 4020
      __u->__uc = __c;
#line 4020
      goto switch_break;
      case_16: /* CIL Label */ 
#line 4020
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 4020
      __u = (union __anonunion___u_71 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 4020
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 4020
      __u = (union __anonunion___u_71 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 4020
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 4020
      __u = (union __anonunion___u_71 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 4020
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 4020
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 4020
    __s = (void *)(& sctx->limits);
    {
#line 4020
    __builtin_memset(__s, '\000', (int )sizeof(re_node_set ));
    }
    }
  }
#line 4021
  return;
}
}
#line 138 "fmt.c"
void fmt(char *line___0 , char *line_end , int max_length , FILE *output_file___0 ) ;
#line 139
static flagT get_paragraph(void) ;
#line 140
static int get_line(int c ) ;
#line 141
static int get_space(int c ) ;
#line 142
static int copy_rest(int c ) ;
#line 143
static flagT same_para(int c ) ;
#line 144
static void flush_paragraph(void) ;
#line 145
static void fmt_paragraph(void) ;
#line 146
static void check_punctuation(WORD *w ) ;
#line 147
static COST base_cost(WORD *this ) ;
#line 148
static COST line_cost(WORD *next , int len ) ;
#line 149
static void put_paragraph(WORD *finish ) ;
#line 150
static void put_line(WORD *w , int indent ) ;
#line 151
static void put_word(WORD *w ) ;
#line 152
static void put_space(int space ) ;
#line 159 "fmt.c"
static int max_width  ;
#line 162 "fmt.c"
static char *parabuf  ;
#line 165 "fmt.c"
static char *end_of_parabuf  ;
#line 168 "fmt.c"
static FILE *outfile  ;
#line 173 "fmt.c"
static int best_width  ;
#line 178 "fmt.c"
static int in_column  ;
#line 181 "fmt.c"
static int out_column  ;
#line 185 "fmt.c"
static WORD words[1000]  ;
#line 190 "fmt.c"
static WORD *word_limit  ;
#line 193 "fmt.c"
static int first_indent  ;
#line 196 "fmt.c"
static int other_indent  ;
#line 199 "fmt.c"
static int next_char  ;
#line 204 "fmt.c"
static int last_line_length  ;
#line 208 "fmt.c"
void fmt(char *line___0 , char *line_end , int max_length , FILE *output_file___0 ) 
{ 
  char *tmp ;
  flagT tmp___0 ;

  {
#line 211
  parabuf = line___0;
#line 212
  end_of_parabuf = line_end;
#line 213
  outfile = output_file___0;
#line 215
  max_width = max_length;
#line 216
  best_width = (max_width * 187) / 200;
#line 218
  in_column = 0;
#line 219
  other_indent = 0;
#line 220
  if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
#line 220
    next_char = -1;
  } else {
#line 220
    tmp = parabuf;
#line 220
    parabuf ++;
#line 220
    next_char = (int )*tmp;
  }
  {
  {
#line 221
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 221
    tmp___0 = get_paragraph();
    }
    }
#line 221
    if (! tmp___0) {
#line 221
      goto while_break;
    }
    {
    {
#line 223
    fmt_paragraph();
    }
    {
#line 224
    put_paragraph(word_limit);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 235 "fmt.c"
static flagT get_paragraph(void) 
{ 
  register int c ;
  char *tmp ;
  flagT tmp___0 ;
  flagT tmp___1 ;

  {
#line 240
  last_line_length = 0;
#line 241
  c = next_char;
  {
  {
#line 245
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 245
    if (! (c == 10)) {
#line 245
      if (! (c == -1)) {
#line 245
        goto while_break;
      }
    }
    {
    {
#line 247
    c = copy_rest(c);
    }
    }
#line 248
    if (c == -1) {
#line 250
      next_char = -1;
#line 251
      return ((flagT )0);
    }
    {
    {
#line 253
    _IO_putc('\n', outfile);
    }
    }
#line 254
    if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
#line 254
      c = -1;
    } else {
#line 254
      tmp = parabuf;
#line 254
      parabuf ++;
#line 254
      c = (int )*tmp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  first_indent = in_column;
#line 260
  word_limit = words;
  {
#line 261
  c = get_line(c);
  }
#line 265
  other_indent = in_column;
  }
  {
  {
#line 266
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 266
    tmp___0 = same_para(c);
    }
    }
#line 266
    if (tmp___0) {
#line 266
      if (! (in_column == other_indent)) {
#line 266
        goto while_break___0;
      }
    } else {
#line 266
      goto while_break___0;
    }
    {
    {
#line 267
    c = get_line(c);
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 269
  tmp___1 = (flagT )1;
#line 269
  (word_limit - 1)->final = tmp___1;
#line 269
  (word_limit - 1)->period = tmp___1;
#line 270
  next_char = c;
#line 271
  return ((flagT )1);
}
}
#line 277 "fmt.c"
static int copy_rest(int c ) 
{ 
  char *tmp ;

  {
#line 280
  out_column = 0;
  {
  {
#line 281
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 281
    if (c != 10) {
#line 281
      if (! (c != -1)) {
#line 281
        goto while_break;
      }
    } else {
#line 281
      goto while_break;
    }
    {
    {
#line 283
    _IO_putc(c, outfile);
    }
    }
#line 284
    if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
#line 284
      c = -1;
    } else {
#line 284
      tmp = parabuf;
#line 284
      parabuf ++;
#line 284
      c = (int )*tmp;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  return (c);
}
}
#line 293 "fmt.c"
static flagT same_para(int c ) 
{ 
  int tmp ;

  {
#line 296
  if (c != 10) {
#line 296
    if (c != -1) {
#line 296
      tmp = 1;
    } else {
#line 296
      tmp = 0;
    }
  } else {
#line 296
    tmp = 0;
  }
#line 296
  return ((flagT )tmp);
}
}
#line 307 "fmt.c"
static int get_line(int c ) 
{ 
  int start ;
  register WORD *end_of_word ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 313
  end_of_word = & words[998];
  {
  {
#line 315
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 320
    word_limit->text = (char const   *)(parabuf - 1);
    {
    {
#line 321
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 322
      if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
#line 322
        c = -1;
      } else {
#line 322
        tmp = parabuf;
#line 322
        parabuf ++;
#line 322
        c = (int )*tmp;
      }
#line 321
      if (c != -1) {
        {
        {
#line 321
        tmp___0 = __ctype_b_loc();
        }
        }
#line 321
        if ((int const   )*(*tmp___0 + c) & 8192) {
#line 321
          goto while_break___0;
        }
      } else {
#line 321
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 324
    word_limit->length = (short )((parabuf - (char *)word_limit->text) - (long )(c != -1));
#line 325
    in_column += (int )word_limit->length;
    {
#line 327
    check_punctuation(word_limit);
    }
#line 331
    start = in_column;
    {
#line 332
    c = get_space(c);
    }
#line 333
    word_limit->space = (short )(in_column - start);
    }
#line 334
    if (c == -1) {
#line 334
      tmp___1 = 1;
    } else
#line 334
    if (word_limit->period) {
#line 334
      if (c == 10) {
#line 334
        tmp___1 = 1;
      } else
#line 334
      if ((int )word_limit->space > 1) {
#line 334
        tmp___1 = 1;
      } else {
#line 334
        tmp___1 = 0;
      }
    } else {
#line 334
      tmp___1 = 0;
    }
#line 334
    word_limit->final = (flagT )tmp___1;
#line 337
    if (c == 10) {
#line 337
      goto _L;
    } else
#line 337
    if (c == -1) {
      _L: /* CIL Label */ 
#line 338
      if (word_limit->final) {
#line 338
        word_limit->space = (short)2;
      } else {
#line 338
        word_limit->space = (short)1;
      }
    }
#line 339
    if ((unsigned long )word_limit == (unsigned long )end_of_word) {
      {
      {
#line 340
      flush_paragraph();
      }
      }
    }
#line 341
    word_limit ++;
#line 342
    if (c == -1) {
#line 344
      in_column = first_indent;
#line 345
      return (-1);
    }
#line 315
    if (! (c != 10)) {
#line 315
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  in_column = 0;
#line 351
  if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
#line 351
    c = -1;
  } else {
#line 351
    tmp___2 = parabuf;
#line 351
    parabuf ++;
#line 351
    c = (int )*tmp___2;
  }
  {
  {
#line 352
  tmp___3 = get_space(c);
  }
  }
#line 352
  return (tmp___3);
}
}
#line 358 "fmt.c"
static int get_space(int c ) 
{ 
  char *tmp ;

  {
  {
  {
#line 361
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 363
    if (c == 32) {
#line 364
      in_column ++;
    } else
#line 365
    if (c == 9) {
#line 366
      in_column = (in_column / 8 + 1) * 8;
    } else {
#line 368
      return (c);
    }
#line 369
    if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
#line 369
      c = -1;
    } else {
#line 369
      tmp = parabuf;
#line 369
      parabuf ++;
#line 369
      c = (int )*tmp;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 375 "fmt.c"
static void check_punctuation(WORD *w ) 
{ 
  register char const   *start ;
  register char const   *finish ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___3 ;
  char *tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 380
  start = w->text;
#line 381
  finish = start + ((int )w->length - 1);
  {
#line 382
  tmp___0 = strchr("([`\'\"", (int )*start);
  }
#line 382
  w->paren = (flagT )((unsigned long )tmp___0 != (unsigned long )((void *)0));
  {
#line 383
  tmp___1 = __ctype_b_loc();
  }
#line 383
  w->punct = (flagT )(((int const   )*(*tmp___1 + (int )*finish) & 4) != (int const   )0);
  }
  {
  {
#line 384
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 384
    tmp___3 = strchr(")]\'\"", (int )*finish);
    }
    }
#line 384
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 384
      if (! ((unsigned long )finish > (unsigned long )start)) {
#line 384
        goto while_break;
      }
    } else {
#line 384
      goto while_break;
    }
#line 385
    finish --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 386
  tmp___5 = strchr(".?!", (int )*finish);
  }
#line 386
  w->period = (flagT )((unsigned long )tmp___5 != (unsigned long )((void *)0));
  }
#line 387
  return;
}
}
#line 392 "fmt.c"
static void flush_paragraph(void) 
{ 
  WORD *split_point ;
  register WORD *w ;
  COST best_break ;

  {
  {
  {
#line 404
  fmt_paragraph();
  }
#line 408
  split_point = word_limit;
#line 409
  best_break = (COST )(~ (1UL << (8UL * sizeof(COST ) - 1UL)));
#line 410
  w = words[0].next_break;
  }
  {
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 410
    if (! ((unsigned long )w != (unsigned long )word_limit)) {
#line 410
      goto while_break;
    }
#line 412
    if (w->best_cost - (w->next_break)->best_cost < best_break) {
#line 414
      split_point = w;
#line 415
      best_break = w->best_cost - (w->next_break)->best_cost;
    }
#line 417
    if ((unsigned long )best_break <= ~ (1UL << (8UL * sizeof(COST ) - 1UL)) - 9UL) {
#line 418
      best_break += 9L;
    }
#line 410
    w = w->next_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 420
  put_paragraph(split_point);
  }
  {
#line 425
  memmove((void *)((char *)(words)), (void const   *)((char *)split_point), (size_t )((unsigned long )((word_limit - split_point) + 1L) * sizeof(WORD )));
  }
#line 427
  word_limit -= split_point - words;
  }
#line 428
  return;
}
}
#line 434 "fmt.c"
static void fmt_paragraph(void) 
{ 
  register WORD *start ;
  register WORD *w ;
  register int len ;
  register COST wcost ;
  register COST best ;
  int saved_length ;
  COST tmp ;
  COST tmp___0 ;

  {
#line 442
  word_limit->best_cost = (COST )0;
#line 443
  saved_length = (int )word_limit->length;
#line 444
  word_limit->length = (short )max_width;
#line 446
  start = word_limit - 1;
  {
  {
#line 446
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 446
    if (! ((unsigned long )start >= (unsigned long )(words))) {
#line 446
      goto while_break;
    }
#line 448
    best = (COST )(~ (1UL << (8UL * sizeof(COST ) - 1UL)));
#line 449
    if ((unsigned long )start == (unsigned long )(words)) {
#line 449
      len = first_indent;
    } else {
#line 449
      len = other_indent;
    }
#line 453
    w = start;
#line 454
    len += (int )w->length;
    {
    {
#line 455
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
#line 457
      w ++;
      {
#line 461
      tmp = line_cost(w, len);
      }
#line 461
      wcost = tmp + w->best_cost;
      }
#line 462
      if ((unsigned long )start == (unsigned long )(words)) {
#line 462
        if (last_line_length > 0) {
#line 463
          wcost += ((COST )((len - last_line_length) * 10) * (COST )((len - last_line_length) * 10)) / 2L;
        }
      }
#line 464
      if (wcost < best) {
#line 466
        best = wcost;
#line 467
        start->next_break = w;
#line 468
        start->line_length = (short )len;
      }
#line 470
      len += (int )(w - 1)->space + (int )w->length;
#line 455
      if (! (len < max_width)) {
#line 455
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 473
    tmp___0 = base_cost(start);
    }
#line 473
    start->best_cost = best + tmp___0;
#line 446
    start --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 476
  word_limit->length = (short )saved_length;
#line 477
  return;
}
}
#line 482 "fmt.c"
static COST base_cost(WORD *this ) 
{ 
  register COST cost ;

  {
#line 487
  cost = 4900L;
#line 489
  if ((unsigned long )this > (unsigned long )(words)) {
#line 491
    if ((this - 1)->period) {
#line 493
      if ((this - 1)->final) {
#line 494
        cost -= 2500L;
      } else {
#line 496
        cost += 360000L;
      }
    } else
#line 498
    if ((this - 1)->punct) {
#line 499
      cost -= 1600L;
    } else
#line 500
    if ((unsigned long )this > (unsigned long )(words + 1)) {
#line 500
      if ((this - 2)->final) {
#line 501
        cost += 40000L / (COST )((int )(this - 1)->length + 2);
      }
    }
  }
#line 504
  if (this->paren) {
#line 505
    cost -= 1600L;
  } else
#line 506
  if (this->final) {
#line 507
    cost += 22500L / (COST )((int )this->length + 2);
  }
#line 509
  return (cost);
}
}
#line 515 "fmt.c"
static COST line_cost(WORD *next , int len ) 
{ 
  register int n ;
  register COST cost ;

  {
#line 521
  if ((unsigned long )next == (unsigned long )word_limit) {
#line 522
    return ((COST )0);
  }
#line 523
  n = best_width - len;
#line 524
  cost = (COST )(n * 10) * (COST )(n * 10);
#line 525
  if ((unsigned long )next->next_break != (unsigned long )word_limit) {
#line 527
    n = len - (int )next->line_length;
#line 528
    cost += ((COST )(n * 10) * (COST )(n * 10)) / 2L;
  }
#line 530
  return (cost);
}
}
#line 536 "fmt.c"
static void put_paragraph(WORD *finish ) 
{ 
  register WORD *w ;

  {
  {
  {
#line 541
  put_line(words, first_indent);
  }
#line 542
  w = words[0].next_break;
  }
  {
  {
#line 542
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 542
    if (! ((unsigned long )w != (unsigned long )finish)) {
#line 542
      goto while_break;
    }
    {
    {
#line 543
    put_line(w, other_indent);
    }
#line 542
    w = w->next_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 549 "fmt.c"
static void put_line(WORD *w , int indent ) 
{ 
  register WORD *endline ;

  {
  {
#line 553
  out_column = 0;
  {
#line 554
  put_space(indent);
  }
#line 556
  endline = w->next_break - 1;
  }
  {
  {
#line 557
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 557
    if (! ((unsigned long )w != (unsigned long )endline)) {
#line 557
      goto while_break;
    }
    {
    {
#line 559
    put_word(w);
    }
    {
#line 560
    put_space((int )w->space);
    }
#line 557
    w ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 562
  put_word(w);
  }
#line 563
  last_line_length = out_column;
  {
#line 564
  _IO_putc('\n', outfile);
  }
  }
#line 565
  return;
}
}
#line 569 "fmt.c"
static void put_word(WORD *w ) 
{ 
  register char const   *s ;
  register int n ;
  char const   *tmp ;

  {
#line 575
  s = w->text;
#line 576
  n = (int )w->length;
  {
  {
#line 576
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 576
    if (! (n != 0)) {
#line 576
      goto while_break;
    }
    {
#line 577
    tmp = s;
#line 577
    s ++;
    {
#line 577
    _IO_putc((int )*tmp, outfile);
    }
#line 576
    n --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 578
  out_column += (int )w->length;
#line 579
  return;
}
}
#line 583 "fmt.c"
static void put_space(int space ) 
{ 
  int tmp ;

  {
#line 586
  out_column += space;
  {
  {
#line 587
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 587
    tmp = space;
#line 587
    space --;
#line 587
    if (! tmp) {
#line 587
      goto while_break;
    }
    {
    {
#line 588
    _IO_putc(' ', outfile);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 589
  return;
}
}
#line 145 "sed.h"
void bad_prog(char const   *why ) ;
#line 146
size_t normalize_text(char *buf , size_t len ) ;
#line 153
regex_t *compile_regex(struct buffer *b___0 , int flags , int needed_sub ) ;
#line 154
int match_regex(regex_t *regex , char *buf , size_t buflen , size_t buf_start_offset ,
                struct re_registers *regarray , int regsize ) ;
#line 167
int extended_regexp_flags ;
#line 179
flagT POSIXLY_CORRECT ;
#line 43 "regex.c"
static char const   errors[72]  = 
#line 43 "regex.c"
  {      (char const   )'N',      (char const   )'o',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'o',      (char const   )'u',      (char const   )'s',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'\000',      (char const   )'C', 
        (char const   )'a',      (char const   )'n',      (char const   )'n',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'s',      (char const   )'p', 
        (char const   )'e',      (char const   )'c',      (char const   )'i',      (char const   )'f', 
        (char const   )'y',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'d',      (char const   )'i',      (char const   )'f',      (char const   )'i', 
        (char const   )'e',      (char const   )'r',      (char const   )'s',      (char const   )' ', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'e', 
        (char const   )'m',      (char const   )'p',      (char const   )'t',      (char const   )'y', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'\000'};
#line 53 "regex.c"
regex_t *compile_regex(struct buffer *b___0 , int flags , int needed_sub ) 
{ 
  regex_t *new_regex ;
  char *last_re ;
  size_t last_re_len ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char const   *error ;
  int syntax ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  char buf[200] ;
  char *tmp___6 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 61
  last_re = (char *)((void *)0);
  {
#line 67
  tmp___0 = size_buffer(b___0);
  }
  }
#line 67
  if (tmp___0 == 0U) {
#line 67
    if (! POSIXLY_CORRECT) {
#line 69
      if (flags > 0) {
        {
        {
#line 70
        tmp = dcgettext((char const   *)((void *)0), errors + sizeof("No previous regular expression"),
                        5);
        }
        {
#line 70
        bad_prog((char const   *)tmp);
        }
        }
      }
#line 71
      return ((regex_t *)((void *)0));
    }
  }
  {
  {
#line 74
  last_re_len = size_buffer(b___0);
  }
  {
#line 75
  tmp___1 = get_buffer(b___0);
  }
  {
#line 75
  tmp___2 = ck_memdup((void const   *)tmp___1, last_re_len);
  }
#line 75
  last_re = (char *)tmp___2;
  {
#line 77
  tmp___3 = ck_malloc((size_t )sizeof(regex_t ));
  }
#line 77
  new_regex = (regex_t *)tmp___3;
  }
#line 97
  if (extended_regexp_flags & 1) {
#line 97
    tmp___4 = ((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
#line 97
    tmp___4 = ((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1);
  }
#line 97
  syntax = (int )tmp___4;
#line 102
  if (flags & (1 << 1)) {
#line 102
    tmp___5 = (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  } else {
#line 102
    tmp___5 = 0UL;
  }
#line 102
  syntax = (int )((unsigned long )syntax | tmp___5);
#line 104
  syntax = (int )((unsigned long )syntax | ((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 105
  syntax = (int )((unsigned long )syntax & ~ (((1UL << 1) << 1) << 1));
#line 106
  syntax = (int )((unsigned long )syntax & ~ (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 109
  if (flags & ((1 << 1) << 1)) {
#line 111
    syntax = (int )((unsigned long )syntax & ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1));
#line 112
    syntax = (int )((unsigned long )syntax | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
  {
  {
#line 116
  last_re_len = normalize_text(last_re, last_re_len);
  }
  {
#line 117
  re_set_syntax((reg_syntax_t )syntax);
  }
  {
#line 118
  error = re_compile_pattern((char const   *)last_re, last_re_len, new_regex);
  }
#line 119
  new_regex->newline_anchor = (unsigned int )((flags & ((1 << 1) << 1)) != 0);
#line 121
  new_regex->translate = (char *)((void *)0);
  }
#line 134
  if (error) {
    {
    {
#line 135
    bad_prog(error);
    }
    }
  }
  {
  {
#line 139
  ck_free((void *)last_re);
  }
  }
#line 142
  if (new_regex->re_nsub < (size_t )needed_sub) {
#line 142
    if (! POSIXLY_CORRECT) {
      {
      {
#line 145
      tmp___6 = dcgettext((char const   *)((void *)0), "Invalid reference \\%d on `s\' command\'s RHS",
                          5);
      }
      {
#line 145
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___6,
              needed_sub);
      }
      {
#line 147
      bad_prog((char const   *)(buf));
      }
      }
    }
  }
#line 150
  return (new_regex);
}
}
#line 201 "regex.c"
static regex_t *regex_last  ;
#line 191 "regex.c"
int match_regex(regex_t *regex , char *buf , size_t buflen , size_t buf_start_offset ,
                struct re_registers *regarray , int regsize ) 
{ 
  int ret ;
  char *tmp ;
  struct re_registers *tmp___0 ;

  {
#line 213
  if (! regex) {
#line 215
    regex = regex_last;
#line 216
    if (! regex_last) {
      {
      {
#line 217
      tmp = dcgettext((char const   *)((void *)0), errors, 5);
      }
      {
#line 217
      bad_prog((char const   *)tmp);
      }
      }
    }
  } else {
#line 220
    regex_last = regex;
  }
#line 232
  if (regsize) {
#line 232
    tmp___0 = regarray;
  } else {
#line 232
    tmp___0 = (struct re_registers *)((void *)0);
  }
  {
  {
#line 232
  ret = re_search(regex, (char const   *)buf, (int )buflen, (int )buf_start_offset,
                  (int )(buflen - buf_start_offset), tmp___0);
  }
  }
#line 236
  return (ret > -1);
}
}
#line 154 "/usr/include/stdio.h"
extern int rename(char const   *__old , char const   *__new ) ;
#line 273
extern FILE *fdopen(int __fd , char const   *__modes ) ;
#line 596
extern int ungetc(int __c , FILE *__stream ) ;
#line 722
extern int feof(FILE *__stream ) ;
#line 752
extern int fileno(FILE *__stream ) ;
#line 767
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 773
extern int pclose(FILE *__stream ) ;
#line 305 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 65 "/usr/include/string.h"
extern void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__)) ;
#line 85
extern char *strncpy(char * __restrict  __dest , char const   * __restrict  __src ,
                     size_t __n ) ;
#line 99
extern int strncmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 164
extern char *strrchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
#line 379 "/usr/include/wchar.h"
__inline extern float wcstof(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ) ;
#line 381
__inline extern long double wcstold(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ) ;
#line 418
__inline extern long long wcstoq(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                                 int __base ) ;
#line 425
__inline extern unsigned long long wcstouq(wchar_t const   * __restrict  __nptr ,
                                           wchar_t ** __restrict  __endptr , int __base ) ;
#line 486
extern float __wcstof_internal(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                               int __group ) ;
#line 489
extern long double __wcstold_internal(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                                      int __group ) ;
#line 507
extern long long __wcstoll_internal(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                                    int __base , int __group ) ;
#line 514
extern unsigned long long __wcstoull_internal(wchar_t const   * __restrict  __nptr ,
                                              wchar_t ** __restrict  __endptr , int __base ,
                                              int __group ) ;
#line 542 "/usr/include/wchar.h"
__inline extern float wcstof(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ) 
{ 
  float tmp ;

  {
  {
  {
#line 544
  tmp = __wcstof_internal(__nptr, __endptr, 0);
  }
  }
#line 544
  return (tmp);
}
}
#line 545 "/usr/include/wchar.h"
__inline extern long double wcstold(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ) 
{ 
  long double tmp ;

  {
  {
  {
#line 547
  tmp = __wcstold_internal(__nptr, __endptr, 0);
  }
  }
#line 547
  return (tmp);
}
}
#line 551 "/usr/include/wchar.h"
__inline extern long long wcstoq(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                                 int __base ) 
{ 
  long long tmp ;

  {
  {
  {
#line 554
  tmp = __wcstoll_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 554
  return (tmp);
}
}
#line 556 "/usr/include/wchar.h"
__inline extern unsigned long long wcstouq(wchar_t const   * __restrict  __nptr ,
                                           wchar_t ** __restrict  __endptr , int __base ) 
{ 
  unsigned long long tmp ;

  {
  {
  {
#line 560
  tmp = __wcstoull_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 560
  return (tmp);
}
}
#line 677 "/usr/include/stdlib.h"
extern int mkstemp(char *__template )  __asm__("mkstemp64")  ;
#line 215 "/usr/include/sys/stat.h"
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("stat64")  ;
#line 219
__inline extern int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64")  ;
#line 226
__inline extern int stat64(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
#line 228
__inline extern int fstat64(int __fd , struct stat64 *__statbuf ) ;
#line 239
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("lstat64")  ;
#line 248
__inline extern int lstat64(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
#line 266
extern int fchmod(int __fd , __mode_t __mode ) ;
#line 287
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 326
extern int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __asm__("__fxstat64")  ;
#line 329
extern int __xstat(int __ver , char const   *__filename , struct stat *__stat_buf )  __asm__("__xstat64")  ;
#line 331
extern int __lxstat(int __ver , char const   *__filename , struct stat *__stat_buf )  __asm__("__lxstat64")  ;
#line 343
extern int __fxstat64(int __ver , int __fildes , struct stat64 *__stat_buf ) ;
#line 345
extern int __xstat64(int __ver , char const   *__filename , struct stat64 *__stat_buf ) ;
#line 347
extern int __lxstat64(int __ver , char const   *__filename , struct stat64 *__stat_buf ) ;
#line 350
extern int __xmknod(int __ver , char const   *__path , __mode_t __mode , __dev_t *__dev ) ;
#line 356
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("stat64")  ;
#line 356 "/usr/include/sys/stat.h"
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
  {
#line 359
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
  }
#line 359
  return (tmp);
}
}
#line 363
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("lstat64")  ;
#line 363 "/usr/include/sys/stat.h"
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
  {
#line 366
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
  }
#line 366
  return (tmp);
}
}
#line 370
__inline extern int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64")  ;
#line 370 "/usr/include/sys/stat.h"
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
  {
#line 372
  tmp = __fxstat(3, __fd, __statbuf);
  }
  }
#line 372
  return (tmp);
}
}
#line 376 "/usr/include/sys/stat.h"
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
  {
#line 379
  tmp = __xmknod(1, __path, __mode, & __dev);
  }
  }
#line 379
  return (tmp);
}
}
#line 386 "/usr/include/sys/stat.h"
__inline extern int stat64(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
  {
#line 389
  tmp = __xstat64(3, (char const   *)__path, (struct stat64 *)__statbuf);
  }
  }
#line 389
  return (tmp);
}
}
#line 393 "/usr/include/sys/stat.h"
__inline extern int lstat64(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
  {
#line 396
  tmp = __lxstat64(3, (char const   *)__path, (struct stat64 *)__statbuf);
  }
  }
#line 396
  return (tmp);
}
}
#line 400 "/usr/include/sys/stat.h"
__inline extern int fstat64(int __fd , struct stat64 *__statbuf ) 
{ 
  int tmp ;

  {
  {
  {
#line 402
  tmp = __fxstat64(3, __fd, __statbuf);
  }
  }
#line 402
  return (tmp);
}
}
#line 150 "sed.h"
void rewind_read_files(void) ;
#line 161
int process_files(struct vector *the_program___0 , char **argv ) ;
#line 170
flagT unbuffered_output ;
#line 173
flagT no_default_output ;
#line 176
flagT separate_files ;
#line 182
countT lcmd_out_line_len ;
#line 185
char *in_place_extension ;
#line 128 "execute.c"
static flagT replaced  =    (flagT )0;
#line 131 "execute.c"
static FILE *output_file  ;
#line 134 "execute.c"
static struct line line  ;
#line 137 "execute.c"
static struct line s_accum  ;
#line 140 "execute.c"
static struct line hold  ;
#line 144 "execute.c"
static struct line buffer  ;
#line 146 "execute.c"
static struct append_queue *append_head  =    (struct append_queue *)((void *)0);
#line 147 "execute.c"
static struct append_queue *append_tail  =    (struct append_queue *)((void *)0);
#line 180
static void resize_line(struct line *lb , size_t len ) ;
#line 181 "execute.c"
static void resize_line(struct line *lb , size_t len ) 
{ 
  int inactive ;
  void *tmp ;

  {
#line 187
  inactive = (int )(lb->active - lb->text);
#line 191
  if ((size_t )inactive > lb->alloc * 2U) {
    {
    {
#line 193
    memmove((void *)lb->text, (void const   *)lb->active, lb->length);
    }
#line 194
    lb->alloc = (size_t )((long )lb->alloc + (lb->active - lb->text));
#line 195
    lb->active = lb->text;
#line 196
    inactive = 0;
    }
#line 198
    if (lb->alloc > len) {
#line 199
      return;
    }
  }
#line 202
  lb->alloc *= 2U;
#line 203
  if (lb->alloc < len) {
#line 204
    lb->alloc = len;
  }
#line 205
  if (lb->alloc < 50U) {
#line 206
    lb->alloc = (size_t )50;
  }
  {
  {
#line 208
  tmp = ck_realloc((void *)lb->text, (size_t )((unsigned long )((size_t )inactive + lb->alloc) * sizeof(char )));
  }
#line 208
  lb->text = (char *)tmp;
#line 209
  lb->active = lb->text + inactive;
  }
#line 210
  return;
}
}
#line 213
static void str_append(struct line *to , char const   *string , size_t length ) ;
#line 214 "execute.c"
static void str_append(struct line *to , char const   *string , size_t length ) 
{ 
  size_t new_length ;

  {
#line 220
  new_length = to->length + length;
#line 222
  if (to->alloc < new_length) {
    {
    {
#line 223
    resize_line(to, new_length);
    }
    }
  }
  {
  {
#line 224
  memcpy((void */* __restrict  */)(to->active + to->length), (void const   */* __restrict  */)string,
         length);
  }
#line 225
  to->length = new_length;
  }
#line 226
  return;
}
}
#line 228
static void str_append_modified(struct line *to , char const   *string , size_t length ,
                                enum replacement_types type ) ;
#line 230 "execute.c"
static void str_append_modified(struct line *to , char const   *string , size_t length ,
                                enum replacement_types type ) 
{ 
  size_t old_length ;
  char *start ;
  char *end ;
  int __res ;
  __int32_t const   **tmp___0 ;
  int __res___0 ;
  __int32_t const   **tmp___2 ;
  int __res___1 ;
  __int32_t const   **tmp___4 ;
  int __res___2 ;
  __int32_t const   **tmp___6 ;

  {
#line 237
  old_length = to->length;
#line 240
  if (length == 0U) {
#line 241
    return;
  }
  {
  {
#line 243
  str_append(to, string, length);
  }
#line 244
  start = to->active + old_length;
#line 245
  end = start + length;
  }
#line 248
  if ((unsigned int )type & 4U) {
#line 250
    if (sizeof(*start) > 1UL) {
      {
      {
#line 250
      __res = toupper((int )*start);
      }
      }
    } else {
      {
      {
#line 250
      tmp___0 = __ctype_toupper_loc();
      }
#line 250
      __res = (int )*(*tmp___0 + (int )*start);
      }
    }
#line 250
    *start = (char )__res;
#line 251
    start ++;
#line 252
    type = (enum replacement_types )((unsigned int )type & 4294967291U);
  } else
#line 254
  if ((unsigned int )type & 8U) {
#line 256
    if (sizeof(*start) > 1UL) {
      {
      {
#line 256
      __res___0 = tolower((int )*start);
      }
      }
    } else {
      {
      {
#line 256
      tmp___2 = __ctype_tolower_loc();
      }
#line 256
      __res___0 = (int )*(*tmp___2 + (int )*start);
      }
    }
#line 256
    *start = (char )__res___0;
#line 257
    start ++;
#line 258
    type = (enum replacement_types )((unsigned int )type & 4294967287U);
  }
#line 261
  if ((unsigned int )type == 0U) {
#line 262
    return;
  }
#line 265
  if ((unsigned int )type == 1U) {
    {
    {
#line 266
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 266
      if (! ((unsigned long )start != (unsigned long )end)) {
#line 266
        goto while_break;
      }
#line 267
      if (sizeof(*start) > 1UL) {
        {
        {
#line 267
        __res___1 = toupper((int )*start);
        }
        }
      } else {
        {
        {
#line 267
        tmp___4 = __ctype_toupper_loc();
        }
#line 267
        __res___1 = (int )*(*tmp___4 + (int )*start);
        }
      }
#line 267
      *start = (char )__res___1;
#line 266
      start ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 269
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 269
      if (! ((unsigned long )start != (unsigned long )end)) {
#line 269
        goto while_break___0;
      }
#line 270
      if (sizeof(*start) > 1UL) {
        {
        {
#line 270
        __res___2 = tolower((int )*start);
        }
        }
      } else {
        {
        {
#line 270
        tmp___6 = __ctype_tolower_loc();
        }
#line 270
        __res___2 = (int )*(*tmp___6 + (int )*start);
        }
      }
#line 270
      *start = (char )__res___2;
#line 269
      start ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 271
  return;
}
}
#line 274
static void line_init(struct line *buf , size_t initial_size ) ;
#line 275 "execute.c"
static void line_init(struct line *buf , size_t initial_size ) 
{ 
  void *tmp ;

  {
  {
  {
#line 280
  tmp = ck_malloc((size_t )((unsigned long )initial_size * sizeof(char )));
  }
#line 280
  buf->text = (char *)tmp;
#line 281
  buf->active = buf->text;
#line 282
  buf->alloc = initial_size;
#line 283
  buf->length = (size_t )0;
#line 284
  buf->chomped = (flagT )1;
  }
#line 285
  return;
}
}
#line 289
static void line_copy(struct line *from , struct line *to ) ;
#line 290 "execute.c"
static void line_copy(struct line *from , struct line *to ) 
{ 
  void *tmp ;

  {
#line 296
  to->alloc = (size_t )((long )to->alloc + (to->active - to->text));
#line 298
  if (to->alloc < from->length) {
#line 300
    to->alloc *= 2U;
#line 301
    if (to->alloc < from->length) {
#line 302
      to->alloc = from->length;
    }
#line 303
    if (to->alloc < 50U) {
#line 304
      to->alloc = (size_t )50;
    }
    {
    {
#line 307
    ck_free((void *)to->text);
    }
    {
#line 308
    tmp = ck_malloc((size_t )((unsigned long )to->alloc * sizeof(char )));
    }
#line 308
    to->text = (char *)tmp;
    }
  }
  {
#line 311
  to->active = to->text;
#line 312
  to->length = from->length;
#line 313
  to->chomped = from->chomped;
  {
#line 314
  memcpy((void */* __restrict  */)to->active, (void const   */* __restrict  */)from->active,
         from->length);
  }
  }
#line 315
  return;
}
}
#line 318
static void line_append(struct line *from , struct line *to ) ;
#line 319 "execute.c"
static void line_append(struct line *from , struct line *to ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 324
  str_append(to, "\n", (size_t )1);
  }
  {
#line 325
  str_append(to, (char const   *)from->active, from->length);
  }
#line 326
  to->chomped = from->chomped;
  }
#line 327
  return;
}
}
#line 330
static void line_exchange(struct line *a , struct line *b___0 ) ;
#line 331 "execute.c"
static void line_exchange(struct line *a , struct line *b___0 ) 
{ 
  struct line t ;

  {
  {
  {
#line 338
  memcpy((void */* __restrict  */)(& t), (void const   */* __restrict  */)a, (size_t )sizeof(struct line ));
  }
  {
#line 339
  memcpy((void */* __restrict  */)a, (void const   */* __restrict  */)b___0, (size_t )sizeof(struct line ));
  }
  {
#line 340
  memcpy((void */* __restrict  */)b___0, (void const   */* __restrict  */)(& t), (size_t )sizeof(struct line ));
  }
  }
#line 341
  return;
}
}
#line 345
static flagT read_always_fail(struct input *input  __attribute__((__unused__)) ) ;
#line 346 "execute.c"
static flagT read_always_fail(struct input *input  __attribute__((__unused__)) ) 
{ 


  {
#line 350
  return ((flagT )0);
}
}
#line 353
static flagT read_file_line(struct input *input ) ;
#line 358 "execute.c"
static char *b  ;
#line 359 "execute.c"
static size_t blen  ;
#line 354 "execute.c"
static flagT read_file_line(struct input *input ) 
{ 
  long result ;
  __ssize_t tmp ;

  {
  {
  {
#line 361
  tmp = getline((char **/* __restrict  */)(& b), (size_t */* __restrict  */)(& blen),
                (FILE */* __restrict  */)input->fp);
  }
#line 361
  result = (long )tmp;
  }
#line 364
  if (result > 0L) {
#line 364
    if ((int )*(b + (result - 1L)) == 10) {
#line 365
      result --;
    } else {
#line 364
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 369
    if (! *(input->file_list)) {
#line 369
      if (! POSIXLY_CORRECT) {
#line 370
        line.chomped = (flagT )0;
      }
    }
#line 372
    if (result <= 0L) {
#line 373
      return ((flagT )0);
    }
  }
  {
  {
#line 376
  str_append(& line, (char const   *)b, (size_t )result);
  }
  }
#line 377
  return ((flagT )1);
}
}
#line 381
static void output_line(char const   *text , size_t length , flagT nl , FILE *fp ) ;
#line 382 "execute.c"
static void output_line(char const   *text , size_t length , flagT nl , FILE *fp ) 
{ 
  char *__cil_tmp5 ;

  {
#line 389
  if (length) {
    {
    {
#line 390
    ck_fwrite((void const   *)text, (size_t )1, length, fp);
    }
    }
  }
#line 391
  if (nl) {
    {
    {
#line 392
    ck_fwrite((void const   *)"\n", (size_t )1, (size_t )1, fp);
    }
    }
  }
#line 393
  if ((unsigned long )fp != (unsigned long )stdout) {
    {
    {
#line 394
    ck_fflush(fp);
    }
    }
  } else
#line 393
  if (unbuffered_output) {
    {
    {
#line 394
    ck_fflush(fp);
    }
    }
  }
#line 395
  return;
}
}
#line 397
static struct append_queue *next_append_slot(void) ;
#line 398 "execute.c"
static struct append_queue *next_append_slot(void) 
{ 
  struct append_queue *n ;
  void *tmp ;

  {
  {
  {
#line 401
  tmp = ck_malloc((size_t )sizeof(struct append_queue ));
  }
#line 401
  n = (struct append_queue *)tmp;
#line 403
  n->fname = (char const   *)((void *)0);
#line 404
  n->text = (char *)((void *)0);
#line 405
  n->textlen = (size_t )0;
#line 406
  n->next = (struct append_queue *)((void *)0);
#line 407
  n->free = (flagT )0;
  }
#line 409
  if (append_tail) {
#line 410
    append_tail->next = n;
  } else {
#line 412
    append_head = n;
  }
#line 413
  append_tail = n;
#line 413
  return (append_tail);
}
}
#line 416
static void release_append_queue(void) ;
#line 417 "execute.c"
static void release_append_queue(void) 
{ 
  struct append_queue *p ;
  struct append_queue *q ;

  {
#line 422
  p = append_head;
  {
  {
#line 422
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 422
    if (! p) {
#line 422
      goto while_break;
    }
#line 424
    if (p->free) {
      {
      {
#line 425
      ck_free((void *)p->text);
      }
      }
    }
    {
#line 427
    q = p->next;
    {
#line 428
    ck_free((void *)p);
    }
#line 422
    p = q;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  append_tail = (struct append_queue *)((void *)0);
#line 430
  append_head = append_tail;
#line 431
  return;
}
}
#line 433
static void dump_append_queue(void) ;
#line 434 "execute.c"
static void dump_append_queue(void) 
{ 
  struct append_queue *p ;
  char buf[8192] ;
  size_t cnt ;
  FILE *fp ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 439
  p = append_head;
  {
  {
#line 439
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 439
    if (! p) {
#line 439
      goto while_break;
    }
#line 441
    if (p->text) {
      {
      {
#line 442
      output_line((char const   *)p->text, p->textlen, (flagT )0, output_file);
      }
      }
    }
#line 443
    if (p->fname) {
      {
      {
#line 453
      fp = ck_fopen(p->fname, "r", (flagT )0);
      }
      }
#line 454
      if (fp) {
        {
        {
#line 456
        while (1) {
          while_continue___2: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
          {
          {
#line 456
          cnt = ck_fread((void *)(buf), (size_t )1, (size_t )sizeof(buf), fp);
          }
          }
#line 456
          if (! (cnt > 0U)) {
#line 456
            goto while_break___0;
          }
          {
          {
#line 457
          ck_fwrite((void const   *)(buf), (size_t )1, cnt, output_file);
          }
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        {
#line 458
        ck_fclose(fp);
        }
        }
      }
    }
#line 439
    p = p->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 462
  release_append_queue();
  }
  }
#line 463
  return;
}
}
#line 467
static char *get_backup_file_name(char const   *name ) ;
#line 468 "execute.c"
static char *get_backup_file_name(char const   *name ) 
{ 
  char *old_asterisk ;
  char *asterisk ;
  char *backup ;
  char *p ;
  int name_length ;
  size_t tmp ;
  int backup_length ;
  size_t tmp___0 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___5 ;

  {
  {
  {
#line 473
  tmp = strlen(name);
  }
#line 473
  name_length = (int )tmp;
  {
#line 473
  tmp___0 = strlen((char const   *)in_place_extension);
  }
#line 473
  backup_length = (int )tmp___0;
#line 476
  asterisk = in_place_extension - 1;
#line 476
  old_asterisk = asterisk + 1;
  }
  {
  {
#line 476
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 476
    tmp___2 = strchr((char const   *)old_asterisk, '*');
    }
#line 476
    asterisk = tmp___2;
    }
#line 476
    if (! asterisk) {
#line 476
      goto while_break;
    }
#line 479
    backup_length += name_length - 1;
#line 476
    old_asterisk = asterisk + 1;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 481
  tmp___3 = xmalloc((size_t )(backup_length + 1));
  }
#line 481
  backup = (char *)tmp___3;
#line 481
  p = backup;
#line 484
  asterisk = in_place_extension - 1;
#line 484
  old_asterisk = asterisk + 1;
  }
  {
  {
#line 484
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 484
    tmp___5 = strchr((char const   *)old_asterisk, '*');
    }
#line 484
    asterisk = tmp___5;
    }
#line 484
    if (! asterisk) {
#line 484
      goto while_break___0;
    }
    {
    {
#line 488
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)old_asterisk,
           (size_t )(asterisk - old_asterisk));
    }
#line 489
    p += asterisk - old_asterisk;
    {
#line 490
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)name);
    }
#line 491
    p += name_length;
#line 484
    old_asterisk = asterisk + 1;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 495
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)old_asterisk);
  }
  }
#line 496
  return (backup);
}
}
#line 500
static void open_next_file(char const   *name , struct input *input ) ;
#line 501 "execute.c"
static void open_next_file(char const   *name , struct input *input ) 
{ 
  char const   *ptr ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  FILE *tmp___2 ;
  int output_fd ;
  char *tmpdir ;
  char *tmp___3 ;
  char *p ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  struct stat st ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 506
  buffer.length = (size_t )0;
#line 508
  if ((int const   )*(name + 0) == 45) {
#line 508
    if ((int const   )*(name + 1) == 0) {
      {
      {
#line 510
      clearerr(stdin);
      }
#line 511
      input->fp = stdin;
      }
    } else {
#line 508
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
    {
#line 513
    tmp___2 = ck_fopen(name, "r", (flagT )0);
    }
#line 513
    input->fp = tmp___2;
    }
#line 513
    if (! tmp___2) {
      {
      {
#line 515
      tmp = __errno_location();
      }
      {
#line 515
      tmp___0 = strerror(*tmp);
      }
#line 515
      ptr = (char const   *)tmp___0;
      {
#line 516
      tmp___1 = dcgettext((char const   *)((void *)0), "%s: can\'t read %s: %s\n",
                          5);
      }
      {
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              myname, name, ptr);
      }
#line 517
      input->read_fn = & read_always_fail;
#line 518
      (input->bad_count) ++;
      }
#line 519
      return;
    }
  }
#line 522
  input->read_fn = & read_file_line;
#line 524
  if (in_place_extension) {
    {
    {
#line 527
    tmp___3 = ck_strdup(name);
    }
#line 527
    tmpdir = tmp___3;
    {
#line 530
    p = strrchr((char const   *)tmpdir, '/');
    }
    }
#line 530
    if (p) {
#line 531
      *(p + 1) = (char)0;
    } else {
      {
      {
#line 533
      strcpy((char */* __restrict  */)tmpdir, (char const   */* __restrict  */)".");
      }
      }
    }
    {
#line 535
    input->in_file_name = name;
    {
#line 536
    input->out_file_name = temp_file_template((char const   *)tmpdir, (char *)"sed");
    }
    {
#line 537
    output_fd = mkstemp(input->out_file_name);
    }
    {
#line 538
    free((void *)tmpdir);
    }
    }
#line 540
    if (output_fd == -1) {
      {
      {
#line 541
      tmp___4 = __errno_location();
      }
      {
#line 541
      tmp___5 = strerror(*tmp___4);
      }
      {
#line 541
      tmp___6 = dcgettext((char const   *)((void *)0), "Couldn\'t open temporary file %s: %s",
                          5);
      }
      {
#line 541
      panic((char const   *)tmp___6, input->out_file_name, tmp___5);
      }
      }
    }
    {
    {
#line 546
    tmp___7 = fileno(input->fp);
    }
    {
#line 546
    fstat(tmp___7, & st);
    }
    {
#line 547
    fchmod(output_fd, st.st_mode);
    }
    {
#line 551
    output_file = fdopen(output_fd, "w");
    }
    }
#line 552
    if (! output_file) {
      {
      {
#line 553
      tmp___8 = __errno_location();
      }
      {
#line 553
      tmp___9 = strerror(*tmp___8);
      }
      {
#line 553
      tmp___10 = dcgettext((char const   *)((void *)0), "Couldn\'t open temporary file %s: %s",
                           5);
      }
      {
#line 553
      panic((char const   *)tmp___10, input->out_file_name, tmp___9);
      }
      }
    }
  } else {
#line 556
    output_file = stdout;
  }
#line 557
  return;
}
}
#line 561
static void closedown(struct input *input ) ;
#line 562 "execute.c"
static void closedown(struct input *input ) 
{ 
  int fd ;
  int tmp ;
  char *backup_file_name ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 566
  input->read_fn = & read_always_fail;
#line 567
  if (! input->fp) {
#line 568
    return;
  }
#line 569
  if ((unsigned long )input->fp != (unsigned long )stdin) {
    {
    {
#line 570
    ck_fclose(input->fp);
    }
    }
  }
#line 572
  if (in_place_extension) {
#line 572
    if ((unsigned long )output_file != (unsigned long )((void *)0)) {
      {
      {
#line 574
      tmp = fileno(output_file);
      }
#line 574
      fd = tmp;
      }
#line 575
      if (0) {
        {
        {
#line 575
        __s1_len = strlen((char const   *)in_place_extension);
        }
        {
#line 575
        __s2_len = strlen("*");
        }
        }
#line 575
        if (! ((size_t )((void const   *)(in_place_extension + 1)) - (size_t )((void const   *)in_place_extension) == 1U)) {
#line 575
          goto _L___0;
        } else
#line 575
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 575
          if (! ((size_t )((void const   *)("*" + 1)) - (size_t )((void const   *)"*") == 1U)) {
#line 575
            tmp___6 = 1;
          } else
#line 575
          if (__s2_len >= 4U) {
#line 575
            tmp___6 = 1;
          } else {
#line 575
            tmp___6 = 0;
          }
        } else {
#line 575
          tmp___6 = 0;
        }
#line 575
        if (tmp___6) {
#line 575
          if (__s1_len < __s2_len) {
#line 575
            tmp___2 = __s1_len;
          } else {
#line 575
            tmp___2 = __s2_len;
          }
          {
          {
#line 575
          tmp___3 = memcmp((void const   *)((char const   *)in_place_extension), (void const   *)"*",
                           tmp___2 + 1U);
          }
#line 575
          tmp___5 = tmp___3;
          }
        } else {
          {
          {
#line 575
          tmp___4 = strcmp((char const   *)in_place_extension, "*");
          }
#line 575
          tmp___5 = tmp___4;
          }
        }
      } else {
        {
        {
#line 575
        tmp___4 = strcmp((char const   *)in_place_extension, "*");
        }
#line 575
        tmp___5 = tmp___4;
        }
      }
#line 575
      if (tmp___5 != 0) {
        {
        {
#line 577
        tmp___0 = get_backup_file_name(input->in_file_name);
        }
#line 577
        backup_file_name = tmp___0;
        {
#line 578
        rename(input->in_file_name, (char const   *)backup_file_name);
        }
        {
#line 579
        free((void *)backup_file_name);
        }
        }
      }
      {
      {
#line 582
      ck_fclose(output_file);
      }
      {
#line 583
      close(fd);
      }
      {
#line 584
      rename((char const   *)input->out_file_name, input->in_file_name);
      }
      {
#line 585
      free((void *)input->out_file_name);
      }
      }
    }
  }
#line 588
  input->fp = (FILE *)((void *)0);
#line 590
  if (separate_files) {
    {
    {
#line 591
    rewind_read_files();
    }
    }
  }
#line 592
  return;
}
}
#line 595
static void reset_addresses(struct vector *vec ) ;
#line 596 "execute.c"
static void reset_addresses(struct vector *vec ) 
{ 
  struct sed_cmd *cur_cmd ;
  int n ;
  int tmp ;

  {
#line 603
  cur_cmd = vec->v;
#line 603
  n = (int )vec->v_length;
  {
  {
#line 603
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 603
    tmp = n;
#line 603
    n --;
#line 603
    if (! tmp) {
#line 603
      goto while_break;
    }
#line 604
    cur_cmd->a1_matched = (char)0;
#line 603
    cur_cmd ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 605
  return;
}
}
#line 609
static flagT read_pattern_space(struct input *input , struct vector *the_program___0 ,
                                flagT append ) ;
#line 610 "execute.c"
static flagT read_pattern_space(struct input *input , struct vector *the_program___0 ,
                                flagT append ) 
{ 
  char **tmp ;
  flagT tmp___0 ;

  {
#line 616
  if (append_head) {
    {
    {
#line 617
    dump_append_queue();
    }
    }
  }
#line 618
  replaced = (flagT )0;
#line 619
  if (! append) {
#line 620
    line.length = (size_t )0;
  }
#line 621
  line.chomped = (flagT )1;
  {
  {
#line 623
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 623
    tmp___0 = (*(input->read_fn))(input);
    }
    }
#line 623
    if (tmp___0) {
#line 623
      goto while_break;
    }
    {
    {
#line 625
    closedown(input);
    }
    }
#line 627
    if (! *(input->file_list)) {
#line 629
      line.chomped = (flagT )0;
#line 630
      return ((flagT )0);
    }
#line 633
    if (separate_files) {
      {
#line 635
      input->line_number = (countT )0;
      {
#line 636
      reset_addresses(the_program___0);
      }
      }
    }
    {
#line 639
    tmp = input->file_list;
#line 639
    (input->file_list) ++;
    {
#line 639
    open_next_file((char const   *)*tmp, input);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 642
  (input->line_number) ++;
#line 643
  return ((flagT )1);
}
}
#line 647
static flagT last_file_with_data_p(struct input *input ) ;
#line 648 "execute.c"
static flagT last_file_with_data_p(struct input *input ) 
{ 
  int ch ;
  char **tmp ;

  {
  {
  {
#line 652
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 656
    closedown(input);
    }
    }
#line 657
    if (! *(input->file_list)) {
#line 658
      return ((flagT )1);
    }
    {
#line 659
    tmp = input->file_list;
#line 659
    (input->file_list) ++;
    {
#line 659
    open_next_file((char const   *)*tmp, input);
    }
    }
#line 660
    if (input->fp) {
      {
      {
#line 662
      ch = _IO_getc(input->fp);
      }
      }
#line 662
      if (ch != -1) {
        {
        {
#line 664
        ungetc(ch, input->fp);
        }
        }
#line 665
        return ((flagT )0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 672
static flagT test_eof(struct input *input ) ;
#line 673 "execute.c"
static flagT test_eof(struct input *input ) 
{ 
  int ch ;
  flagT tmp ;
  int tmp___0 ;
  flagT tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  flagT tmp___4 ;
  int tmp___5 ;

  {
#line 679
  if (buffer.length) {
#line 680
    return ((flagT )0);
  }
#line 681
  if (! input->fp) {
#line 682
    if (separate_files) {
#line 682
      tmp___0 = 1;
    } else {
      {
      {
#line 682
      tmp = last_file_with_data_p(input);
      }
      }
#line 682
      if (tmp) {
#line 682
        tmp___0 = 1;
      } else {
#line 682
        tmp___0 = 0;
      }
    }
#line 682
    return ((flagT )tmp___0);
  }
  {
  {
#line 683
  tmp___3 = feof(input->fp);
  }
  }
#line 683
  if (tmp___3) {
#line 684
    if (separate_files) {
#line 684
      tmp___2 = 1;
    } else {
      {
      {
#line 684
      tmp___1 = last_file_with_data_p(input);
      }
      }
#line 684
      if (tmp___1) {
#line 684
        tmp___2 = 1;
      } else {
#line 684
        tmp___2 = 0;
      }
    }
#line 684
    return ((flagT )tmp___2);
  }
  {
  {
#line 685
  ch = _IO_getc(input->fp);
  }
  }
#line 685
  if (ch == -1) {
#line 686
    if (separate_files) {
#line 686
      tmp___5 = 1;
    } else {
      {
      {
#line 686
      tmp___4 = last_file_with_data_p(input);
      }
      }
#line 686
      if (tmp___4) {
#line 686
        tmp___5 = 1;
      } else {
#line 686
        tmp___5 = 0;
      }
    }
#line 686
    return ((flagT )tmp___5);
  }
  {
  {
#line 687
  ungetc(ch, input->fp);
  }
  }
#line 688
  return ((flagT )0);
}
}
#line 693
static flagT match_an_address_p(struct addr *addr , struct input *input ) ;
#line 694 "execute.c"
static flagT match_an_address_p(struct addr *addr , struct input *input ) 
{ 
  int tmp ;
  flagT tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
#line 701
  if ((unsigned int )addr->addr_type == 0U) {
#line 701
    goto case_0;
  }
#line 704
  if ((unsigned int )addr->addr_type == 1U) {
#line 704
    goto case_1;
  }
#line 707
  if ((unsigned int )addr->addr_type == 2U) {
#line 707
    goto case_2;
  }
#line 710
  if ((unsigned int )addr->addr_type == 3U) {
#line 710
    goto case_3;
  }
#line 722
  if ((unsigned int )addr->addr_type == 6U) {
#line 722
    goto case_6;
  }
#line 722
  if ((unsigned int )addr->addr_type == 5U) {
#line 722
    goto case_6;
  }
#line 722
  if ((unsigned int )addr->addr_type == 4U) {
#line 722
    goto case_6;
  }
#line 728
  if ((unsigned int )addr->addr_type == 7U) {
#line 728
    goto case_7;
  }
#line 731
  goto switch_default;
  case_0: /* CIL Label */ 
#line 702
  return ((flagT )1);
  case_1: /* CIL Label */ 
  {
  {
#line 705
  tmp = match_regex(addr->addr_regex, line.active, line.length, (size_t )0, (struct re_registers *)((void *)0),
                    0);
  }
  }
#line 705
  return ((flagT )tmp);
  case_2: /* CIL Label */ 
#line 708
  return ((flagT )(addr->addr_number == input->line_number));
  case_3: /* CIL Label */ 
#line 711
  if (addr->addr_number < addr->addr_step) {
#line 712
    return ((flagT )(addr->addr_number == input->line_number % addr->addr_step));
  }
#line 714
  if (input->line_number < addr->addr_number) {
#line 715
    return ((flagT )0);
  }
#line 717
  addr->addr_number %= addr->addr_step;
#line 718
  return ((flagT )(addr->addr_number == 0UL));
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 726
  return ((flagT )(addr->addr_number <= input->line_number));
  case_7: /* CIL Label */ 
  {
  {
#line 729
  tmp___0 = test_eof(input);
  }
  }
#line 729
  return (tmp___0);
  switch_default: /* CIL Label */ 
  {
  {
#line 732
  tmp___1 = dcgettext((char const   *)((void *)0), "INTERNAL ERROR: bad address type",
                      5);
  }
  {
#line 732
  panic((char const   *)tmp___1);
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 735
  return ((flagT )0);
}
}
#line 739
static flagT match_address_p(struct sed_cmd *cmd , struct input *input ) ;
#line 740 "execute.c"
static flagT match_address_p(struct sed_cmd *cmd , struct input *input ) 
{ 
  flagT addr_matched ;
  flagT tmp ;
  flagT tmp___0 ;
  flagT tmp___1 ;

  {
#line 745
  addr_matched = (flagT )cmd->a1_matched;
#line 747
  if (addr_matched) {
    {
    {
#line 749
    tmp = match_an_address_p(cmd->a2, input);
    }
    }
#line 749
    if (tmp) {
#line 750
      cmd->a1_matched = (char)0;
    }
  } else
#line 752
  if (! cmd->a1) {
#line 752
    goto _L;
  } else {
    {
    {
#line 752
    tmp___1 = match_an_address_p(cmd->a1, input);
    }
    }
#line 752
    if (tmp___1) {
      _L: /* CIL Label */ 
#line 754
      addr_matched = (flagT )1;
#line 755
      if (cmd->a2) {
#line 757
        cmd->a1_matched = (char)1;
        {
#line 760
        if ((unsigned int )(cmd->a2)->addr_type == 1U) {
#line 760
          goto case_1;
        }
#line 762
        if ((unsigned int )(cmd->a2)->addr_type == 5U) {
#line 762
          goto case_5;
        }
#line 765
        if ((unsigned int )(cmd->a2)->addr_type == 6U) {
#line 765
          goto case_6;
        }
#line 769
        goto switch_default;
        case_1: /* CIL Label */ 
#line 761
        goto switch_break;
        case_5: /* CIL Label */ 
#line 763
        (cmd->a2)->addr_number = input->line_number + (cmd->a2)->addr_step;
#line 764
        goto switch_break;
        case_6: /* CIL Label */ 
#line 766
        (cmd->a2)->addr_number = (input->line_number + (cmd->a2)->addr_step) - input->line_number % (cmd->a2)->addr_step;
#line 768
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
        {
#line 770
        tmp___0 = match_an_address_p(cmd->a2, input);
        }
        }
#line 770
        if (tmp___0) {
#line 771
          cmd->a1_matched = (char)0;
        }
#line 772
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 776
  if (cmd->addr_bang) {
#line 777
    return ((flagT )(! addr_matched));
  }
#line 778
  return (addr_matched);
}
}
#line 782
static void do_list(int line_len ) ;
#line 783 "execute.c"
static void do_list(int line_len ) 
{ 
  unsigned char *p ;
  countT len ;
  countT width ;
  char obuf[180] ;
  char *o ;
  size_t olen ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  countT tmp___11 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 787
  p = (unsigned char *)line.active;
#line 788
  len = (countT )line.length;
#line 789
  width = (countT )0;
  {
  {
#line 794
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 794
    tmp___11 = len;
#line 794
    len --;
#line 794
    if (! tmp___11) {
#line 794
      goto while_break;
    }
#line 795
    o = obuf;
#line 801
    if (((int )*p & -128) == 0) {
      {
      {
#line 801
      tmp___10 = __ctype_b_loc();
      }
      }
#line 801
      if ((int const   )*(*tmp___10 + (int )*p) & 16384) {
#line 805
        tmp = o;
#line 805
        o ++;
#line 805
        *tmp = (char )*p;
#line 806
        if ((int )*p == 92) {
#line 807
          tmp___0 = o;
#line 807
          o ++;
#line 807
          *tmp___0 = (char )'\\';
        }
      } else {
#line 801
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 809
      tmp___1 = o;
#line 809
      o ++;
#line 809
      *tmp___1 = (char )'\\';
      {
#line 812
      if ((int )*p == 7) {
#line 812
        goto case_7;
      }
#line 816
      if ((int )*p == 8) {
#line 816
        goto case_8;
      }
#line 817
      if ((int )*p == 12) {
#line 817
        goto case_12;
      }
#line 818
      if ((int )*p == 10) {
#line 818
        goto case_10;
      }
#line 819
      if ((int )*p == 13) {
#line 819
        goto case_13;
      }
#line 820
      if ((int )*p == 9) {
#line 820
        goto case_9;
      }
#line 821
      if ((int )*p == 11) {
#line 821
        goto case_11;
      }
#line 822
      goto switch_default;
      case_7: /* CIL Label */ 
#line 812
      tmp___2 = o;
#line 812
      o ++;
#line 812
      *tmp___2 = (char )'a';
#line 812
      goto switch_break;
      case_8: /* CIL Label */ 
#line 816
      tmp___3 = o;
#line 816
      o ++;
#line 816
      *tmp___3 = (char )'b';
#line 816
      goto switch_break;
      case_12: /* CIL Label */ 
#line 817
      tmp___4 = o;
#line 817
      o ++;
#line 817
      *tmp___4 = (char )'f';
#line 817
      goto switch_break;
      case_10: /* CIL Label */ 
#line 818
      tmp___5 = o;
#line 818
      o ++;
#line 818
      *tmp___5 = (char )'n';
#line 818
      goto switch_break;
      case_13: /* CIL Label */ 
#line 819
      tmp___6 = o;
#line 819
      o ++;
#line 819
      *tmp___6 = (char )'r';
#line 819
      goto switch_break;
      case_9: /* CIL Label */ 
#line 820
      tmp___7 = o;
#line 820
      o ++;
#line 820
      *tmp___7 = (char )'t';
#line 820
      goto switch_break;
      case_11: /* CIL Label */ 
#line 821
      tmp___8 = o;
#line 821
      o ++;
#line 821
      *tmp___8 = (char )'v';
#line 821
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 823
      sprintf((char */* __restrict  */)o, (char const   */* __restrict  */)"%03o",
              (int )*p);
      }
      {
#line 824
      tmp___9 = strlen((char const   *)o);
      }
#line 824
      o += tmp___9;
      }
#line 825
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 828
    olen = (size_t )(o - obuf);
#line 829
    if (width + (countT )olen >= (countT )line_len) {
#line 829
      if (line_len > 0) {
        {
        {
#line 830
        ck_fwrite((void const   *)"\\\n", (size_t )1, (size_t )2, output_file);
        }
#line 831
        width = (countT )0;
        }
      }
    }
    {
    {
#line 833
    ck_fwrite((void const   *)(obuf), (size_t )1, olen, output_file);
    }
#line 834
    width += (countT )olen;
#line 794
    p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 836
  ck_fwrite((void const   *)"$\n", (size_t )1, (size_t )2, output_file);
  }
  }
#line 837
  return;
}
}
#line 839
static enum replacement_types append_replacement(struct line *buf , struct replacement *p ,
                                                 struct re_registers *regs___0 , enum replacement_types repl_mod ) ;
#line 842 "execute.c"
static enum replacement_types append_replacement(struct line *buf , struct replacement *p ,
                                                 struct re_registers *regs___0 , enum replacement_types repl_mod ) 
{ 
  int i ;
  enum replacement_types curr_type ;

  {
  {
  {
#line 849
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 849
    if (! p) {
#line 849
      goto while_break;
    }
#line 851
    i = p->subst_id;
#line 857
    if ((unsigned int )p->repl_type & 12U) {
#line 857
      curr_type = p->repl_type;
    } else {
#line 857
      curr_type = (enum replacement_types )((unsigned int )p->repl_type | (unsigned int )repl_mod);
    }
#line 861
    repl_mod = (enum replacement_types )0;
#line 862
    if (p->prefix_length) {
      {
      {
#line 864
      str_append_modified(buf, (char const   *)p->prefix, p->prefix_length, curr_type);
      }
#line 866
      curr_type = (enum replacement_types )((unsigned int )curr_type & 4294967283U);
      }
    }
#line 869
    if (0 <= i) {
#line 870
      if (*(regs___0->end + i) == *(regs___0->start + i)) {
#line 870
        if ((unsigned int )p->repl_type & 12U) {
#line 874
          repl_mod = (enum replacement_types )((unsigned int )curr_type & 12U);
        } else {
          {
          {
#line 877
          str_append_modified(buf, (char const   *)(line.active + *(regs___0->start + i)),
                              (size_t )(*(regs___0->end + i) - *(regs___0->start + i)),
                              curr_type);
          }
          }
        }
      } else {
        {
        {
#line 877
        str_append_modified(buf, (char const   *)(line.active + *(regs___0->start + i)),
                            (size_t )(*(regs___0->end + i) - *(regs___0->start + i)),
                            curr_type);
        }
        }
      }
    }
#line 849
    p = p->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (repl_mod);
}
}
#line 885
static void do_subst(struct subst *sub ) ;
#line 896 "execute.c"
static struct re_registers regs  ;
#line 886 "execute.c"
static void do_subst(struct subst *sub ) 
{ 
  size_t start ;
  size_t last_end ;
  countT count ;
  flagT again ;
  int tmp ;
  enum replacement_types repl_mod ;
  size_t offset ;
  size_t matched ;
  int tmp___0 ;
  FILE *pipe___0 ;
  char buf[4096] ;
  int n ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 890
  start = (size_t )0;
#line 891
  last_end = (size_t )0;
#line 892
  count = (countT )0;
#line 893
  again = (flagT )1;
#line 898
  if (s_accum.alloc == 0U) {
    {
    {
#line 899
    line_init(& s_accum, (size_t )50);
    }
    }
  }
  {
#line 900
  s_accum.length = (size_t )0;
  {
#line 904
  tmp = match_regex(sub->regx, line.active, line.length, start, & regs, 10);
  }
  }
#line 904
  if (! tmp) {
#line 906
    return;
  }
#line 908
  if (! sub->replacement) {
#line 908
    if (sub->numb <= 1UL) {
#line 909
      if (*(regs.start + 0) == 0) {
#line 909
        if (! sub->global) {
#line 912
          replaced = (flagT )1;
#line 914
          line.active += *(regs.end + 0);
#line 915
          line.length -= (size_t )*(regs.end + 0);
#line 916
          line.alloc -= (size_t )*(regs.end + 0);
#line 917
          goto post_subst;
        } else {
#line 909
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 919
      if ((size_t )*(regs.end + 0) == line.length) {
#line 922
        replaced = (flagT )1;
#line 924
        line.length = (size_t )*(regs.start + 0);
#line 925
        goto post_subst;
      }
    }
  }
  {
  {
#line 928
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 930
    repl_mod = (enum replacement_types )0;
#line 932
    offset = (size_t )*(regs.start + 0);
#line 933
    matched = (size_t )(*(regs.end + 0) - *(regs.start + 0));
#line 936
    if (start < offset) {
      {
      {
#line 937
      str_append(& s_accum, (char const   *)(line.active + start), offset - start);
      }
      }
    }
#line 948
    if (matched > 0U) {
#line 948
      goto _L___1;
    } else
#line 948
    if (count == 0UL) {
#line 948
      goto _L___1;
    } else
#line 948
    if (offset > last_end) {
      _L___1: /* CIL Label */ 
#line 948
      last_end = (size_t )*(regs.end + 0);
#line 948
      count ++;
#line 948
      if (count >= sub->numb) {
        {
#line 952
        replaced = (flagT )1;
        {
#line 955
        repl_mod = append_replacement(& s_accum, sub->replacement, & regs, repl_mod);
        }
#line 956
        again = (flagT )sub->global;
        }
      } else {
#line 948
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 963
      if (matched == 0U) {
#line 965
        if (start < line.length) {
#line 966
          matched = (size_t )1;
        } else {
#line 968
          goto while_break;
        }
      }
      {
      {
#line 971
      str_append(& s_accum, (char const   *)(line.active + offset), matched);
      }
      }
    }
#line 975
    start = offset + matched;
#line 928
    if (again) {
#line 928
      if (start <= line.length) {
        {
        {
#line 928
        tmp___0 = match_regex(sub->regx, line.active, line.length, start, & regs,
                              10);
        }
        }
#line 928
        if (! tmp___0) {
#line 928
          goto while_break;
        }
      } else {
#line 928
        goto while_break;
      }
    } else {
#line 928
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 983
  if (start < line.length) {
    {
    {
#line 984
    str_append(& s_accum, (char const   *)(line.active + start), line.length - start);
    }
    }
  }
  {
#line 985
  s_accum.chomped = line.chomped;
  {
#line 989
  line_exchange(& line, & s_accum);
  }
  }
#line 992
  if (count < sub->numb) {
#line 993
    return;
  }
  post_subst: 
#line 996
  if (sub->print & 1U) {
    {
    {
#line 997
    output_line((char const   *)line.active, line.length, line.chomped, output_file);
    }
    }
  }
#line 999
  if (sub->eval) {
    {
#line 1003
    s_accum.length = (size_t )0;
    {
#line 1005
    str_append(& line, "", (size_t )1);
    }
    {
#line 1006
    pipe___0 = popen((char const   *)line.active, "r");
    }
    }
#line 1008
    if ((unsigned long )pipe___0 != (unsigned long )((void *)0)) {
      {
      {
#line 1010
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
        {
        {
#line 1010
        tmp___2 = feof(pipe___0);
        }
        }
#line 1010
        if (tmp___2) {
#line 1010
          goto while_break___0;
        }
        {
        {
#line 1013
        tmp___1 = fread((void */* __restrict  */)(buf), (size_t )sizeof(char ), (size_t )4096,
                        (FILE */* __restrict  */)pipe___0);
        }
#line 1013
        n = (int )tmp___1;
        }
#line 1014
        if (n > 0) {
          {
          {
#line 1015
          str_append(& s_accum, (char const   *)(buf), (size_t )n);
          }
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      {
#line 1018
      pclose(pipe___0);
      }
      {
#line 1020
      line_exchange(& line, & s_accum);
      }
      }
#line 1021
      if (line.length) {
#line 1021
        if ((int )*(line.active + (line.length - 1U)) == 10) {
#line 1023
          (line.length) --;
        }
      }
    } else {
      {
      {
#line 1026
      tmp___3 = dcgettext((char const   *)((void *)0), "error in subprocess", 5);
      }
      {
#line 1026
      panic((char const   *)tmp___3);
      }
      }
    }
  }
#line 1032
  if (sub->print & 2U) {
    {
    {
#line 1033
    output_line((char const   *)line.active, line.length, line.chomped, output_file);
    }
    }
  }
#line 1034
  if (sub->fp) {
    {
    {
#line 1035
    output_line((char const   *)line.active, line.length, line.chomped, sub->fp);
    }
    }
  }
#line 1036
  return;
}
}
#line 1093
static int execute_program(struct vector *vec , struct input *input ) ;
#line 1094 "execute.c"
static int execute_program(struct vector *vec , struct input *input ) 
{ 
  struct sed_cmd *cur_cmd ;
  struct sed_cmd *end_cmd ;
  struct append_queue *aq ;
  struct append_queue *tmp ;
  char *p ;
  void *tmp___0 ;
  FILE *pipe___0 ;
  int cmd_length ;
  char buf[4096] ;
  int n ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  countT tmp___4 ;
  countT tmp___5 ;
  flagT tmp___6 ;
  flagT tmp___7 ;
  flagT tmp___8 ;
  flagT tmp___9 ;
  char *p___0 ;
  void *tmp___10 ;
  unsigned int tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  struct append_queue *aq___0 ;
  struct append_queue *tmp___14 ;
  struct append_queue *aq___1 ;
  size_t buflen ;
  char *text ;
  int result ;
  int tmp___15 ;
  char *p___1 ;
  void *tmp___16 ;
  unsigned int tmp___17 ;
  long tmp___18 ;
  int idx ;
  int prev_idx ;
  char **trans ;
  mbstate_t cur_stat ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_36 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  int mbclen ;
  int i ;
  size_t tmp___19 ;
  flagT move_remain_buffer ;
  int trans_len ;
  size_t tmp___20 ;
  int new_len ;
  int move_len ;
  int move_offset ;
  char *move_from ;
  char *move_to ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  unsigned char *p___2 ;
  unsigned char *e ;
  size_t tmp___34 ;
  char *tmp___35 ;
  flagT tmp___36 ;
  void *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;

  {
#line 1102
  cur_cmd = vec->v;
#line 1103
  end_cmd = vec->v + vec->v_length;
  {
  {
#line 1104
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1104
    if (! ((unsigned long )cur_cmd < (unsigned long )end_cmd)) {
#line 1104
      goto while_break;
    }
    {
    {
#line 1106
    tmp___36 = match_address_p(cur_cmd, input);
    }
    }
#line 1106
    if (tmp___36) {
      {
#line 1110
      if ((int )cur_cmd->cmd == 97) {
#line 1110
        goto case_97;
      }
#line 1119
      if ((int )cur_cmd->cmd == 98) {
#line 1119
        goto case_98;
      }
#line 1119
      if ((int )cur_cmd->cmd == 123) {
#line 1119
        goto case_98;
      }
#line 1124
      if ((int )cur_cmd->cmd == 58) {
#line 1124
        goto case_58;
      }
#line 1124
      if ((int )cur_cmd->cmd == 125) {
#line 1124
        goto case_58;
      }
#line 1128
      if ((int )cur_cmd->cmd == 99) {
#line 1128
        goto case_99;
      }
#line 1135
      if ((int )cur_cmd->cmd == 100) {
#line 1135
        goto case_100;
      }
#line 1138
      if ((int )cur_cmd->cmd == 68) {
#line 1138
        goto case_68;
      }
#line 1157
      if ((int )cur_cmd->cmd == 101) {
#line 1157
        goto case_101;
      }
#line 1211
      if ((int )cur_cmd->cmd == 103) {
#line 1211
        goto case_103;
      }
#line 1215
      if ((int )cur_cmd->cmd == 71) {
#line 1215
        goto case_71;
      }
#line 1219
      if ((int )cur_cmd->cmd == 104) {
#line 1219
        goto case_104;
      }
#line 1223
      if ((int )cur_cmd->cmd == 72) {
#line 1223
        goto case_72;
      }
#line 1227
      if ((int )cur_cmd->cmd == 105) {
#line 1227
        goto case_105;
      }
#line 1232
      if ((int )cur_cmd->cmd == 108) {
#line 1232
        goto case_108;
      }
#line 1238
      if ((int )cur_cmd->cmd == 76) {
#line 1238
        goto case_76;
      }
#line 1246
      if ((int )cur_cmd->cmd == 110) {
#line 1246
        goto case_110;
      }
#line 1253
      if ((int )cur_cmd->cmd == 78) {
#line 1253
        goto case_78;
      }
#line 1259
      if ((int )cur_cmd->cmd == 112) {
#line 1259
        goto case_112;
      }
#line 1263
      if ((int )cur_cmd->cmd == 80) {
#line 1263
        goto case_80;
      }
#line 1271
      if ((int )cur_cmd->cmd == 113) {
#line 1271
        goto case_113;
      }
#line 1275
      if ((int )cur_cmd->cmd == 81) {
#line 1275
        goto case_81;
      }
#line 1278
      if ((int )cur_cmd->cmd == 114) {
#line 1278
        goto case_114;
      }
#line 1286
      if ((int )cur_cmd->cmd == 82) {
#line 1286
        goto case_82;
      }
#line 1306
      if ((int )cur_cmd->cmd == 115) {
#line 1306
        goto case_115;
      }
#line 1310
      if ((int )cur_cmd->cmd == 116) {
#line 1310
        goto case_116;
      }
#line 1319
      if ((int )cur_cmd->cmd == 84) {
#line 1319
        goto case_84;
      }
#line 1329
      if ((int )cur_cmd->cmd == 119) {
#line 1329
        goto case_119;
      }
#line 1335
      if ((int )cur_cmd->cmd == 87) {
#line 1335
        goto case_87;
      }
#line 1344
      if ((int )cur_cmd->cmd == 120) {
#line 1344
        goto case_120;
      }
#line 1348
      if ((int )cur_cmd->cmd == 121) {
#line 1348
        goto case_121;
      }
#line 1429
      if ((int )cur_cmd->cmd == 61) {
#line 1429
        goto case_61;
      }
#line 1434
      goto switch_default;
      case_97: /* CIL Label */ 
      {
      {
#line 1112
      tmp = next_append_slot();
      }
#line 1112
      aq = tmp;
#line 1113
      aq->text = cur_cmd->x.cmd_txt.text;
#line 1114
      aq->textlen = cur_cmd->x.cmd_txt.text_length;
      }
#line 1116
      goto switch_break;
      case_98: /* CIL Label */ 
      case_123: /* CIL Label */ 
#line 1120
      cur_cmd = vec->v + cur_cmd->x.jump_index;
#line 1121
      goto while_continue;
      case_58: /* CIL Label */ 
      case_125: /* CIL Label */ 
#line 1126
      goto switch_break;
      case_99: /* CIL Label */ 
#line 1129
      if (! cur_cmd->a1_matched) {
        {
        {
#line 1130
        output_line((char const   *)cur_cmd->x.cmd_txt.text, cur_cmd->x.cmd_txt.text_length,
                    (flagT )0, output_file);
        }
        }
      }
      case_100: /* CIL Label */ 
#line 1136
      return (-1);
      case_68: /* CIL Label */ 
      {
      {
#line 1140
      tmp___0 = memchr((void const   *)line.active, '\n', line.length);
      }
#line 1140
      p = (char *)tmp___0;
      }
#line 1141
      if (! p) {
#line 1143
        line.length = (size_t )0;
#line 1144
        line.chomped = (flagT )0;
#line 1145
        return (-1);
      }
#line 1147
      p ++;
#line 1148
      line.alloc = (size_t )((long )line.alloc - (p - line.active));
#line 1149
      line.length = (size_t )((long )line.length - (p - line.active));
#line 1150
      line.active += p - line.active;
#line 1153
      cur_cmd = vec->v;
#line 1154
      goto while_continue;
      case_101: /* CIL Label */ 
#line 1160
      cmd_length = (int )cur_cmd->x.cmd_txt.text_length;
#line 1161
      if (s_accum.alloc == 0U) {
        {
        {
#line 1162
        line_init(& s_accum, (size_t )50);
        }
        }
      }
#line 1163
      s_accum.length = (size_t )0;
#line 1165
      if (! cmd_length) {
        {
        {
#line 1167
        str_append(& line, "", (size_t )1);
        }
        {
#line 1168
        pipe___0 = popen((char const   *)line.active, "r");
        }
        }
      } else {
        {
#line 1172
        *(cur_cmd->x.cmd_txt.text + (cmd_length - 1)) = (char)0;
        {
#line 1173
        pipe___0 = popen((char const   *)cur_cmd->x.cmd_txt.text, "r");
        }
        }
      }
#line 1176
      if ((unsigned long )pipe___0 != (unsigned long )((void *)0)) {
        {
        {
#line 1178
        while (1) {
          while_continue___5: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
          {
          {
#line 1178
          tmp___2 = feof(pipe___0);
          }
          }
#line 1178
          if (tmp___2) {
#line 1178
            goto while_break___0;
          }
          {
          {
#line 1181
          tmp___1 = fread((void */* __restrict  */)(buf), (size_t )sizeof(char ),
                          (size_t )4096, (FILE */* __restrict  */)pipe___0);
          }
#line 1181
          n = (int )tmp___1;
          }
#line 1182
          if (n > 0) {
#line 1183
            if (! cmd_length) {
              {
              {
#line 1184
              str_append(& s_accum, (char const   *)(buf), (size_t )n);
              }
              }
            } else {
              {
              {
#line 1186
              output_line((char const   *)(buf), (size_t )n, (flagT )0, output_file);
              }
              }
            }
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        {
#line 1189
        pclose(pipe___0);
        }
        }
#line 1190
        if (! cmd_length) {
#line 1193
          if (s_accum.length) {
#line 1193
            if ((int )*(s_accum.active + (s_accum.length - 1U)) == 10) {
#line 1195
              (s_accum.length) --;
            }
          }
          {
          {
#line 1200
          line_exchange(& line, & s_accum);
          }
          }
        }
      } else {
        {
        {
#line 1204
        tmp___3 = dcgettext((char const   *)((void *)0), "error in subprocess", 5);
        }
        {
#line 1204
        panic((char const   *)tmp___3);
        }
        }
      }
#line 1208
      goto switch_break;
      case_103: /* CIL Label */ 
      {
      {
#line 1212
      line_copy(& hold, & line);
      }
      }
#line 1213
      goto switch_break;
      case_71: /* CIL Label */ 
      {
      {
#line 1216
      line_append(& hold, & line);
      }
      }
#line 1217
      goto switch_break;
      case_104: /* CIL Label */ 
      {
      {
#line 1220
      line_copy(& line, & hold);
      }
      }
#line 1221
      goto switch_break;
      case_72: /* CIL Label */ 
      {
      {
#line 1224
      line_append(& line, & hold);
      }
      }
#line 1225
      goto switch_break;
      case_105: /* CIL Label */ 
      {
      {
#line 1228
      output_line((char const   *)cur_cmd->x.cmd_txt.text, cur_cmd->x.cmd_txt.text_length,
                  (flagT )0, output_file);
      }
      }
#line 1230
      goto switch_break;
      case_108: /* CIL Label */ 
#line 1233
      if (cur_cmd->x.int_arg == -1) {
#line 1233
        tmp___4 = lcmd_out_line_len;
      } else {
#line 1233
        tmp___4 = (countT )cur_cmd->x.int_arg;
      }
      {
      {
#line 1233
      do_list((int )tmp___4);
      }
      }
#line 1236
      goto switch_break;
      case_76: /* CIL Label */ 
#line 1239
      if (cur_cmd->x.int_arg == -1) {
#line 1239
        tmp___5 = lcmd_out_line_len;
      } else {
#line 1239
        tmp___5 = (countT )cur_cmd->x.int_arg;
      }
      {
      {
#line 1239
      fmt(line.active, line.active + line.length, (int )tmp___5, output_file);
      }
      }
#line 1244
      goto switch_break;
      case_110: /* CIL Label */ 
#line 1247
      if (! no_default_output) {
        {
        {
#line 1248
        output_line((char const   *)line.active, line.length, line.chomped, output_file);
        }
        }
      }
      {
      {
#line 1249
      tmp___6 = test_eof(input);
      }
      }
#line 1249
      if (tmp___6) {
#line 1250
        return (-1);
      } else {
        {
        {
#line 1249
        tmp___7 = read_pattern_space(input, vec, (flagT )0);
        }
        }
#line 1249
        if (! tmp___7) {
#line 1250
          return (-1);
        }
      }
#line 1251
      goto switch_break;
      case_78: /* CIL Label */ 
      {
      {
#line 1254
      str_append(& line, "\n", (size_t )1);
      }
      {
#line 1255
      tmp___8 = test_eof(input);
      }
      }
#line 1255
      if (tmp___8) {
#line 1256
        return (-1);
      } else {
        {
        {
#line 1255
        tmp___9 = read_pattern_space(input, vec, (flagT )1);
        }
        }
#line 1255
        if (! tmp___9) {
#line 1256
          return (-1);
        }
      }
#line 1257
      goto switch_break;
      case_112: /* CIL Label */ 
      {
      {
#line 1260
      output_line((char const   *)line.active, line.length, line.chomped, output_file);
      }
      }
#line 1261
      goto switch_break;
      case_80: /* CIL Label */ 
      {
      {
#line 1265
      tmp___10 = memchr((void const   *)line.active, '\n', line.length);
      }
#line 1265
      p___0 = (char *)tmp___10;
      }
#line 1266
      if (p___0) {
#line 1266
        tmp___11 = 1U;
      } else {
#line 1266
        tmp___11 = (unsigned int )line.chomped;
      }
#line 1266
      if (p___0) {
#line 1266
        tmp___12 = p___0 - line.active;
      } else {
#line 1266
        tmp___12 = (long )line.length;
      }
      {
      {
#line 1266
      output_line((char const   *)line.active, (size_t )tmp___12, (flagT )tmp___11,
                  output_file);
      }
      }
#line 1269
      goto switch_break;
      case_113: /* CIL Label */ 
#line 1272
      if (! no_default_output) {
        {
        {
#line 1273
        output_line((char const   *)line.active, line.length, line.chomped, output_file);
        }
        }
      }
      case_81: /* CIL Label */ 
#line 1276
      if (cur_cmd->x.int_arg == -1) {
#line 1276
        tmp___13 = 0;
      } else {
#line 1276
        tmp___13 = cur_cmd->x.int_arg;
      }
#line 1276
      return (tmp___13);
      case_114: /* CIL Label */ 
#line 1279
      if (cur_cmd->x.fname) {
        {
        {
#line 1281
        tmp___14 = next_append_slot();
        }
#line 1281
        aq___0 = tmp___14;
#line 1282
        aq___0->fname = (char const   *)cur_cmd->x.fname;
        }
      }
#line 1284
      goto switch_break;
      case_82: /* CIL Label */ 
#line 1287
      if (cur_cmd->x.fp) {
        {
        {
#line 1287
        tmp___15 = feof(cur_cmd->x.fp);
        }
        }
#line 1287
        if (! tmp___15) {
          {
#line 1291
          text = (char *)((void *)0);
          {
#line 1294
          result = getline((char **/* __restrict  */)(& text), (size_t */* __restrict  */)(& buflen),
                           (FILE */* __restrict  */)cur_cmd->x.fp);
          }
          }
#line 1296
          if (result != -1) {
            {
            {
#line 1298
            aq___1 = next_append_slot();
            }
#line 1299
            aq___1->free = (flagT )1;
#line 1300
            aq___1->text = text;
#line 1301
            aq___1->textlen = (size_t )result;
            }
          }
        }
      }
#line 1304
      goto switch_break;
      case_115: /* CIL Label */ 
      {
      {
#line 1307
      do_subst(cur_cmd->x.cmd_subst);
      }
      }
#line 1308
      goto switch_break;
      case_116: /* CIL Label */ 
#line 1311
      if (replaced) {
#line 1313
        replaced = (flagT )0;
#line 1314
        cur_cmd = vec->v + cur_cmd->x.jump_index;
#line 1315
        goto while_continue;
      }
#line 1317
      goto switch_break;
      case_84: /* CIL Label */ 
#line 1320
      if (! replaced) {
#line 1322
        cur_cmd = vec->v + cur_cmd->x.jump_index;
#line 1323
        goto while_continue;
      } else {
#line 1326
        replaced = (flagT )0;
      }
#line 1327
      goto switch_break;
      case_119: /* CIL Label */ 
#line 1330
      if (cur_cmd->x.fp) {
        {
        {
#line 1331
        output_line((char const   *)line.active, line.length, line.chomped, cur_cmd->x.fp);
        }
        }
      }
#line 1333
      goto switch_break;
      case_87: /* CIL Label */ 
#line 1336
      if (cur_cmd->x.fp) {
        {
        {
#line 1338
        tmp___16 = memchr((void const   *)line.active, '\n', line.length);
        }
#line 1338
        p___1 = (char *)tmp___16;
        }
#line 1339
        if (p___1) {
#line 1339
          tmp___17 = 1U;
        } else {
#line 1339
          tmp___17 = (unsigned int )line.chomped;
        }
#line 1339
        if (p___1) {
#line 1339
          tmp___18 = p___1 - line.active;
        } else {
#line 1339
          tmp___18 = (long )line.length;
        }
        {
        {
#line 1339
        output_line((char const   *)line.active, (size_t )tmp___18, (flagT )tmp___17,
                    cur_cmd->x.fp);
        }
        }
      }
#line 1342
      goto switch_break;
      case_120: /* CIL Label */ 
      {
      {
#line 1345
      line_exchange(& line, & hold);
      }
      }
#line 1346
      goto switch_break;
      case_121: /* CIL Label */ 
      {
      {
#line 1351
      tmp___34 = __ctype_get_mb_cur_max();
      }
      }
#line 1351
      if (tmp___34 > 1U) {
#line 1356
        if (sizeof(mbstate_t ) <= 16UL) {
#line 1356
          if (sizeof(mbstate_t ) == 1UL) {
#line 1356
            __s___1 = (void *)(& cur_stat);
#line 1356
            *((__uint8_t *)__s___1) = (__uint8_t )0;
          } else {
#line 1356
            __s___0 = (void *)(& cur_stat);
#line 1356
            __u = (union __anonunion___u_36 *)__s___0;
#line 1356
            __c = (__uint8_t )0;
            {
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 15U) {
#line 1356
              goto case_15;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 11U) {
#line 1356
              goto case_11;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 7U) {
#line 1356
              goto case_7;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 3U) {
#line 1356
              goto case_3;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 14U) {
#line 1356
              goto case_14;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 10U) {
#line 1356
              goto case_10;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 6U) {
#line 1356
              goto case_6;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 2U) {
#line 1356
              goto case_2;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 13U) {
#line 1356
              goto case_13;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 9U) {
#line 1356
              goto case_9;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 5U) {
#line 1356
              goto case_5;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 1U) {
#line 1356
              goto case_1;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 16U) {
#line 1356
              goto case_16;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 12U) {
#line 1356
              goto case_12;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 8U) {
#line 1356
              goto case_8;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 4U) {
#line 1356
              goto case_4;
            }
#line 1356
            if ((unsigned int )sizeof(mbstate_t ) == 0U) {
#line 1356
              goto case_0;
            }
#line 1356
            goto switch_break___0;
            case_15: /* CIL Label */ 
#line 1356
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1356
            __u = (union __anonunion___u_36 *)((void *)__u + 4);
            case_11: /* CIL Label */ 
#line 1356
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1356
            __u = (union __anonunion___u_36 *)((void *)__u + 4);
            case_7: /* CIL Label */ 
#line 1356
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1356
            __u = (union __anonunion___u_36 *)((void *)__u + 4);
            case_3: /* CIL Label */ 
#line 1356
            __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1356
            __u = (union __anonunion___u_36 *)((void *)__u + 2);
#line 1356
            __u->__uc = __c;
#line 1356
            goto switch_break___0;
            case_14: /* CIL Label */ 
#line 1356
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1356
            __u = (union __anonunion___u_36 *)((void *)__u + 4);
            case_10: /* CIL Label */ 
#line 1356
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1356
            __u = (union __anonunion___u_36 *)((void *)__u + 4);
            case_6: /* CIL Label */ 
#line 1356
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1356
            __u = (union __anonunion___u_36 *)((void *)__u + 4);
            case_2: /* CIL Label */ 
#line 1356
            __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1356
            goto switch_break___0;
            case_13: /* CIL Label */ 
#line 1356
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1356
            __u = (union __anonunion___u_36 *)((void *)__u + 4);
            case_9: /* CIL Label */ 
#line 1356
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1356
            __u = (union __anonunion___u_36 *)((void *)__u + 4);
            case_5: /* CIL Label */ 
#line 1356
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1356
            __u = (union __anonunion___u_36 *)((void *)__u + 4);
            case_1: /* CIL Label */ 
#line 1356
            __u->__uc = __c;
#line 1356
            goto switch_break___0;
            case_16: /* CIL Label */ 
#line 1356
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1356
            __u = (union __anonunion___u_36 *)((void *)__u + 4);
            case_12: /* CIL Label */ 
#line 1356
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1356
            __u = (union __anonunion___u_36 *)((void *)__u + 4);
            case_8: /* CIL Label */ 
#line 1356
            __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1356
            __u = (union __anonunion___u_36 *)((void *)__u + 4);
            case_4: /* CIL Label */ 
#line 1356
            __u->__ui = (unsigned int )((int )__c * 16843009);
            case_0: /* CIL Label */ 
#line 1356
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
          }
        } else {
          {
#line 1356
          __s = (void *)(& cur_stat);
          {
#line 1356
          __builtin_memset(__s, '\000', (int )sizeof(mbstate_t ));
          }
          }
        }
#line 1357
        idx = 0;
        {
        {
#line 1357
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 1357
          if (! ((size_t )idx < line.length)) {
#line 1357
            goto while_break___1;
          }
          {
          {
#line 1360
          tmp___19 = mbrlen((char const   */* __restrict  */)(line.active + idx),
                            line.length - (size_t )idx, (mbstate_t */* __restrict  */)(& cur_stat));
          }
#line 1360
          mbclen = (int )tmp___19;
          }
#line 1365
          if ((size_t )mbclen == 4294967295U) {
#line 1367
            mbclen = 1;
          } else
#line 1365
          if ((size_t )mbclen == 4294967294U) {
#line 1367
            mbclen = 1;
          } else
#line 1365
          if (mbclen == 0) {
#line 1367
            mbclen = 1;
          }
#line 1369
          trans = cur_cmd->x.translatemb;
#line 1371
          i = 0;
          {
          {
#line 1371
          while (1) {
            while_continue___7: /* CIL Label */ ;
            while_continue___2: /* CIL Label */ ;
#line 1371
            if (! ((unsigned long )*(trans + 2 * i) != (unsigned long )((void *)0))) {
#line 1371
              goto while_break___2;
            }
#line 1373
            if (0) {
#line 1373
              if (0) {
                {
                {
#line 1373
                __s1_len = strlen((char const   *)(line.active + idx));
                }
                {
#line 1373
                __s2_len = strlen((char const   *)*(trans + 2 * i));
                }
                }
#line 1373
                if (! ((size_t )((void const   *)((line.active + idx) + 1)) - (size_t )((void const   *)(line.active + idx)) == 1U)) {
#line 1373
                  goto _L___0;
                } else
#line 1373
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 1373
                  if (! ((size_t )((void const   *)(*(trans + 2 * i) + 1)) - (size_t )((void const   *)*(trans + 2 * i)) == 1U)) {
#line 1373
                    tmp___29 = 1;
                  } else
#line 1373
                  if (__s2_len >= 4U) {
#line 1373
                    tmp___29 = 1;
                  } else {
#line 1373
                    tmp___29 = 0;
                  }
                } else {
#line 1373
                  tmp___29 = 0;
                }
#line 1373
                if (tmp___29) {
#line 1373
                  if (__s1_len < __s2_len) {
#line 1373
                    tmp___25 = __s1_len;
                  } else {
#line 1373
                    tmp___25 = __s2_len;
                  }
                  {
                  {
#line 1373
                  tmp___26 = memcmp((void const   *)((char const   *)(line.active + idx)),
                                    (void const   *)((char const   *)*(trans + 2 * i)),
                                    tmp___25 + 1U);
                  }
#line 1373
                  tmp___28 = tmp___26;
                  }
                } else {
                  {
                  {
#line 1373
                  tmp___27 = strcmp((char const   *)(line.active + idx), (char const   *)*(trans + 2 * i));
                  }
#line 1373
                  tmp___28 = tmp___27;
                  }
                }
              } else {
                {
                {
#line 1373
                tmp___27 = strcmp((char const   *)(line.active + idx), (char const   *)*(trans + 2 * i));
                }
#line 1373
                tmp___28 = tmp___27;
                }
              }
#line 1373
              tmp___31 = tmp___28;
            } else {
              {
              {
#line 1373
              tmp___30 = strncmp((char const   *)(line.active + idx), (char const   *)*(trans + 2 * i),
                                 (size_t )mbclen);
              }
#line 1373
              tmp___31 = tmp___30;
              }
            }
#line 1373
            if (tmp___31 == 0) {
              {
#line 1376
              move_remain_buffer = (flagT )0;
              {
#line 1377
              tmp___20 = strlen((char const   *)*(trans + (2 * i + 1)));
              }
#line 1377
              trans_len = (int )tmp___20;
              }
#line 1379
              if (mbclen < trans_len) {
#line 1382
                new_len = (int )(((line.length + 1U) + (size_t )trans_len) - (size_t )mbclen);
#line 1384
                if (line.alloc < (size_t )new_len) {
                  {
                  {
#line 1387
                  resize_line(& line, (size_t )new_len);
                  }
                  }
                }
#line 1389
                move_remain_buffer = (flagT )1;
              } else
#line 1391
              if (mbclen > trans_len) {
#line 1394
                move_remain_buffer = (flagT )1;
              }
#line 1396
              prev_idx = idx;
#line 1397
              if (move_remain_buffer) {
                {
#line 1402
                move_from = (line.active + idx) + mbclen;
#line 1403
                move_to = (line.active + idx) + trans_len;
#line 1404
                move_len = (int )(((line.length + 1U) - (size_t )idx) - (size_t )mbclen);
#line 1405
                move_offset = trans_len - mbclen;
                {
#line 1406
                memmove((void *)move_to, (void const   *)move_from, (size_t )move_len);
                }
#line 1407
                line.length += (size_t )move_offset;
#line 1408
                idx += move_offset;
                }
              }
              {
              {
#line 1410
              strncpy((char */* __restrict  */)(line.active + prev_idx), (char const   */* __restrict  */)*(trans + (2 * i + 1)),
                      (size_t )trans_len);
              }
              }
#line 1412
              goto while_break___2;
            }
#line 1371
            i ++;
          }
          while_break___7: /* CIL Label */ ;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1415
          idx += mbclen;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 1422
        p___2 = (unsigned char *)line.active;
#line 1423
        e = p___2 + line.length;
        {
        {
#line 1423
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 1423
          if (! ((unsigned long )p___2 < (unsigned long )e)) {
#line 1423
            goto while_break___3;
          }
#line 1424
          *p___2 = *(cur_cmd->x.translate + *p___2);
#line 1423
          p___2 ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1427
      goto switch_break;
      case_61: /* CIL Label */ 
      {
      {
#line 1430
      fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%lu\n",
              input->line_number);
      }
      }
#line 1432
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 1435
      tmp___35 = dcgettext((char const   *)((void *)0), "INTERNAL ERROR: Bad cmd %c",
                           5);
      }
      {
#line 1435
      panic((char const   *)tmp___35, (int )cur_cmd->cmd);
      }
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 1485
    cur_cmd ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1488
  if (! no_default_output) {
    {
    {
#line 1489
    output_line((char const   *)line.active, line.length, line.chomped, output_file);
    }
    }
  }
#line 1490
  return (-1);
}
}
#line 1501 "execute.c"
static char dash[2]  = {      (char )'-',      (char )'\000'};
#line 1502 "execute.c"
static char *stdin_argv[2]  = {      dash,      (char *)((void *)0)};
#line 1496 "execute.c"
int process_files(struct vector *the_program___0 , char **argv ) 
{ 
  struct input input ;
  int status ;
  flagT tmp ;

  {
  {
  {
#line 1506
  line_init(& line, (size_t )50);
  }
  {
#line 1507
  line_init(& hold, (size_t )0);
  }
  {
#line 1508
  line_init(& buffer, (size_t )0);
  }
#line 1513
  input.file_list = stdin_argv;
  }
#line 1514
  if (argv) {
#line 1514
    if (*argv) {
#line 1515
      input.file_list = argv;
    }
  }
#line 1516
  input.bad_count = (countT )0;
#line 1517
  input.line_number = (countT )0;
#line 1518
  input.read_fn = & read_always_fail;
#line 1519
  input.fp = (FILE *)((void *)0);
#line 1521
  status = 0;
  {
  {
#line 1522
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1522
    tmp = read_pattern_space(& input, the_program___0, (flagT )0);
    }
    }
#line 1522
    if (! tmp) {
#line 1522
      goto while_break;
    }
    {
    {
#line 1524
    status = execute_program(the_program___0, & input);
    }
    }
#line 1525
    if (status == -1) {
#line 1526
      status = 0;
    } else {
#line 1528
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1530
  closedown(& input);
  }
  }
#line 1545
  if (input.bad_count) {
#line 1546
    status = 2;
  }
#line 1548
  return (status);
}
}
#line 18 "../lib/strverscmp.h"
extern int strverscmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 648 "/usr/include/stdio.h"
extern long ftell(FILE *__stream ) ;
#line 653
extern void rewind(FILE *__stream ) ;
#line 203 "../lib/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 205
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 147 "sed.h"
struct vector *compile_string(struct vector *cur_program , char *str , size_t len ) ;
#line 148
struct vector *compile_file(struct vector *cur_program , char const   *cmdfile ) ;
#line 149
void check_final_program(struct vector *program ) ;
#line 151
void finish_program(struct vector *program ) ;
#line 113 "compile.c"
FILE *my_stdin  ;
#line 113 "compile.c"
FILE *my_stdout  ;
#line 113 "compile.c"
FILE *my_stderr  ;
#line 114 "compile.c"
struct special_files special_files[4]  = {      {(char *)"/dev/stdin", & my_stdin}, 
        {(char *)"/dev/stdout", & my_stdout}, 
        {(char *)"/dev/stderr", & my_stderr}, 
        {(char *)((void *)0), (FILE **)((void *)0)}};
#line 133 "compile.c"
static struct prog_info prog  ;
#line 134 "compile.c"
static struct error_info cur_input  ;
#line 138 "compile.c"
static struct sed_label *jumps  =    (struct sed_label *)((void *)0);
#line 139 "compile.c"
static struct sed_label *labels  =    (struct sed_label *)((void *)0);
#line 143 "compile.c"
static flagT first_script  =    (flagT )1;
#line 146 "compile.c"
static struct buffer *pending_text  =    (struct buffer *)((void *)0);
#line 147 "compile.c"
static struct text_buf *old_text_buf  =    (struct text_buf *)((void *)0);
#line 151 "compile.c"
static struct sed_label *blocks  =    (struct sed_label *)((void *)0);
#line 154 "compile.c"
static struct obstack obs  ;
#line 157 "compile.c"
static char const   errors___0[630]  = 
#line 157
  {      (char const   )'M',      (char const   )'u',      (char const   )'l',      (char const   )'t', 
        (char const   )'i',      (char const   )'p',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'`',      (char const   )'!',      (char const   )'\'', 
        (char const   )'s',      (char const   )'\000',      (char const   )'U',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'`',      (char const   )',',      (char const   )'\'', 
        (char const   )'\000',      (char const   )'C',      (char const   )'a',      (char const   )'n', 
        (char const   )'n',      (char const   )'o',      (char const   )'t',      (char const   )' ', 
        (char const   )'u',      (char const   )'s',      (char const   )'e',      (char const   )' ', 
        (char const   )'+',      (char const   )'N',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'~',      (char const   )'N', 
        (char const   )' ',      (char const   )'a',      (char const   )'s',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'r',      (char const   )'s', 
        (char const   )'t',      (char const   )' ',      (char const   )'a',      (char const   )'d', 
        (char const   )'d',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'s',      (char const   )'\000',      (char const   )'U',      (char const   )'n', 
        (char const   )'m',      (char const   )'a',      (char const   )'t',      (char const   )'c', 
        (char const   )'h',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'`',      (char const   )'{',      (char const   )'\'',      (char const   )'\000', 
        (char const   )'U',      (char const   )'n',      (char const   )'e',      (char const   )'x', 
        (char const   )'p',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'`', 
        (char const   )'}',      (char const   )'\'',      (char const   )'\000',      (char const   )'E', 
        (char const   )'x',      (char const   )'t',      (char const   )'r',      (char const   )'a', 
        (char const   )' ',      (char const   )'c',      (char const   )'h',      (char const   )'a', 
        (char const   )'r',      (char const   )'a',      (char const   )'c',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'s',      (char const   )' ', 
        (char const   )'a',      (char const   )'f',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'E',      (char const   )'x', 
        (char const   )'p',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'\\', 
        (char const   )' ',      (char const   )'a',      (char const   )'f',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'`', 
        (char const   )'a',      (char const   )'\'',      (char const   )',',      (char const   )' ', 
        (char const   )'`',      (char const   )'c',      (char const   )'\'',      (char const   )' ', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'`', 
        (char const   )'i',      (char const   )'\'',      (char const   )'\000',      (char const   )'`', 
        (char const   )'}',      (char const   )'\'',      (char const   )' ',      (char const   )'d', 
        (char const   )'o',      (char const   )'e',      (char const   )'s',      (char const   )'n', 
        (char const   )'\'',      (char const   )'t',      (char const   )' ',      (char const   )'w', 
        (char const   )'a',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'n',      (char const   )'y',      (char const   )' ', 
        (char const   )'a',      (char const   )'d',      (char const   )'d',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'e', 
        (char const   )'s',      (char const   )'\000',      (char const   )':',      (char const   )' ', 
        (char const   )'d',      (char const   )'o',      (char const   )'e',      (char const   )'s', 
        (char const   )'n',      (char const   )'\'',      (char const   )'t',      (char const   )' ', 
        (char const   )'w',      (char const   )'a',      (char const   )'n',      (char const   )'t', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'y', 
        (char const   )' ',      (char const   )'a',      (char const   )'d',      (char const   )'d', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'e',      (char const   )'s',      (char const   )'\000',      (char const   )'C', 
        (char const   )'o',      (char const   )'m',      (char const   )'m',      (char const   )'e', 
        (char const   )'n',      (char const   )'t',      (char const   )'s',      (char const   )' ', 
        (char const   )'d',      (char const   )'o',      (char const   )'n',      (char const   )'\'', 
        (char const   )'t',      (char const   )' ',      (char const   )'a',      (char const   )'c', 
        (char const   )'c',      (char const   )'e',      (char const   )'p',      (char const   )'t', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'y', 
        (char const   )' ',      (char const   )'a',      (char const   )'d',      (char const   )'d', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'e',      (char const   )'s',      (char const   )'\000',      (char const   )'M', 
        (char const   )'i',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'n',      (char const   )'g',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'m',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )'\000',      (char const   )'C', 
        (char const   )'o',      (char const   )'m',      (char const   )'m',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'o', 
        (char const   )'n',      (char const   )'l',      (char const   )'y',      (char const   )' ', 
        (char const   )'u',      (char const   )'s',      (char const   )'e',      (char const   )'s', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )'e', 
        (char const   )' ',      (char const   )'a',      (char const   )'d',      (char const   )'d', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'\000',      (char const   )'U',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'m',      (char const   )'i', 
        (char const   )'n',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )'a',      (char const   )'d', 
        (char const   )'d',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'s',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'g',      (char const   )'e',      (char const   )'x',      (char const   )'\000', 
        (char const   )'U',      (char const   )'n',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )'m',      (char const   )'i',      (char const   )'n', 
        (char const   )'a',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'`',      (char const   )'s',      (char const   )'\'', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'\000',      (char const   )'U',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'m',      (char const   )'i', 
        (char const   )'n',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )'`',      (char const   )'y', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'U',      (char const   )'n', 
        (char const   )'k',      (char const   )'n',      (char const   )'o',      (char const   )'w', 
        (char const   )'n',      (char const   )' ',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'`',      (char const   )'s',      (char const   )'\'',      (char const   )'\000', 
        (char const   )'m',      (char const   )'u',      (char const   )'l',      (char const   )'t', 
        (char const   )'i',      (char const   )'p',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'`',      (char const   )'p',      (char const   )'\'', 
        (char const   )' ',      (char const   )'o',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'s', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'`',      (char const   )'s',      (char const   )'\'',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'m', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'\000', 
        (char const   )'m',      (char const   )'u',      (char const   )'l',      (char const   )'t', 
        (char const   )'i',      (char const   )'p',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'`',      (char const   )'g',      (char const   )'\'', 
        (char const   )' ',      (char const   )'o',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'s', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'`',      (char const   )'s',      (char const   )'\'',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'m', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'\000', 
        (char const   )'m',      (char const   )'u',      (char const   )'l',      (char const   )'t', 
        (char const   )'i',      (char const   )'p',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'n',      (char const   )'u',      (char const   )'m', 
        (char const   )'b',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'s',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )' ',      (char const   )'`', 
        (char const   )'s',      (char const   )'\'',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'m',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )'\000',      (char const   )'n', 
        (char const   )'u',      (char const   )'m',      (char const   )'b',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'`',      (char const   )'s',      (char const   )'\'',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'m', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )' ', 
        (char const   )'m',      (char const   )'a',      (char const   )'y',      (char const   )' ', 
        (char const   )'n',      (char const   )'o',      (char const   )'t',      (char const   )' ', 
        (char const   )'b',      (char const   )'e',      (char const   )' ',      (char const   )'z', 
        (char const   )'e',      (char const   )'r',      (char const   )'o',      (char const   )'\000', 
        (char const   )'s',      (char const   )'t',      (char const   )'r',      (char const   )'i', 
        (char const   )'n',      (char const   )'g',      (char const   )'s',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'y',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'f',      (char const   )'f',      (char const   )'e',      (char const   )'r', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'l',      (char const   )'e',      (char const   )'n',      (char const   )'g', 
        (char const   )'t',      (char const   )'h',      (char const   )'s',      (char const   )'\000', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'n',      (char const   )'e',      (char const   )'w', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'d',      (char const   )'\000'};
#line 205 "compile.c"
static struct fp_list *file_read  =    (struct fp_list *)((void *)0);
#line 206 "compile.c"
static struct fp_list *file_write  =    (struct fp_list *)((void *)0);
#line 212
static int inchar(void) ;
#line 213 "compile.c"
static int inchar(void) 
{ 
  int ch ;
  unsigned char const   *tmp ;
  int tmp___0 ;

  {
#line 216
  ch = -1;
#line 218
  if (prog.cur) {
#line 220
    if ((unsigned long )prog.cur < (unsigned long )prog.end) {
#line 221
      tmp = prog.cur;
#line 221
      (prog.cur) ++;
#line 221
      ch = (int )*tmp;
    }
  } else
#line 223
  if (prog.file) {
    {
    {
#line 225
    tmp___0 = feof(prog.file);
    }
    }
#line 225
    if (! tmp___0) {
      {
      {
#line 226
      ch = _IO_getc(prog.file);
      }
      }
    }
  }
#line 228
  if (ch == 10) {
#line 229
    (cur_input.line) ++;
  }
#line 230
  return (ch);
}
}
#line 234
static void savchar(int ch ) ;
#line 235 "compile.c"
static void savchar(int ch ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 239
  if (ch == -1) {
#line 240
    return;
  }
#line 241
  if (ch == 10) {
#line 241
    if (cur_input.line > 0UL) {
#line 242
      (cur_input.line) --;
    }
  }
#line 243
  if (prog.cur) {
#line 245
    if ((unsigned long )prog.cur <= (unsigned long )prog.base) {
      {
      {
#line 246
      tmp = dcgettext((char const   *)((void *)0), "Called savchar() with unexpected pushback (%x)",
                      5);
      }
      {
#line 246
      panic((char const   *)tmp, (int )((unsigned char )ch));
      }
      }
    } else {
#line 245
      (prog.cur) --;
#line 245
      if ((int const   )*(prog.cur) != (int const   )ch) {
        {
        {
#line 246
        tmp = dcgettext((char const   *)((void *)0), "Called savchar() with unexpected pushback (%x)",
                        5);
        }
        {
#line 246
        panic((char const   *)tmp, (int )((unsigned char )ch));
        }
        }
      }
    }
  } else {
    {
    {
#line 250
    ungetc(ch, prog.file);
    }
    }
  }
#line 251
  return;
}
}
#line 254
static int in_nonblank(void) ;
#line 255 "compile.c"
static int in_nonblank(void) 
{ 
  int ch ;
  unsigned short const   **tmp ;

  {
  {
  {
#line 259
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 260
    ch = inchar();
    }
    {
#line 259
    tmp = __ctype_b_loc();
    }
    }
#line 259
    if (! ((int const   )*(*tmp + ch) & 1)) {
#line 259
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (ch);
}
}
#line 266
static countT in_integer(int ch ) ;
#line 267 "compile.c"
static countT in_integer(int ch ) 
{ 
  countT num ;
  unsigned short const   **tmp ;

  {
#line 271
  num = (countT )0;
  {
  {
#line 273
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 273
    tmp = __ctype_b_loc();
    }
    }
#line 273
    if (! ((int const   )*(*tmp + ch) & 2048)) {
#line 273
      goto while_break;
    }
    {
#line 275
    num = (num * 10UL + (countT )ch) - 48UL;
    {
#line 276
    ch = inchar();
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 278
  savchar(ch);
  }
  }
#line 279
  return (num);
}
}
#line 282
static int add_then_next(struct buffer *b___0 , int ch ) ;
#line 283 "compile.c"
static int add_then_next(struct buffer *b___0 , int ch ) 
{ 
  int tmp ;

  {
  {
  {
#line 288
  add1_buffer(b___0, ch);
  }
  {
#line 289
  tmp = inchar();
  }
  }
#line 289
  return (tmp);
}
}
#line 292
static char *convert_number(char *result , char *buf , char const   *bufend , int base ,
                            int maxdigits , int default_char ) ;
#line 293 "compile.c"
static char *convert_number(char *result , char *buf , char const   *bufend , int base ,
                            int maxdigits , int default_char ) 
{ 
  int n ;
  char *p ;
  int d ;
  int tmp ;

  {
#line 302
  n = 0;
#line 305
  p = buf;
  {
  {
#line 305
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 305
    if ((unsigned long )p < (unsigned long )bufend) {
#line 305
      tmp = maxdigits;
#line 305
      maxdigits --;
#line 305
      if (! (tmp > 0)) {
#line 305
        goto while_break;
      }
    } else {
#line 305
      goto while_break;
    }
#line 307
    d = -1;
    {
#line 310
    if ((int )*p == 48) {
#line 310
      goto case_48;
    }
#line 311
    if ((int )*p == 49) {
#line 311
      goto case_49;
    }
#line 312
    if ((int )*p == 50) {
#line 312
      goto case_50;
    }
#line 313
    if ((int )*p == 51) {
#line 313
      goto case_51;
    }
#line 314
    if ((int )*p == 52) {
#line 314
      goto case_52;
    }
#line 315
    if ((int )*p == 53) {
#line 315
      goto case_53;
    }
#line 316
    if ((int )*p == 54) {
#line 316
      goto case_54;
    }
#line 317
    if ((int )*p == 55) {
#line 317
      goto case_55;
    }
#line 318
    if ((int )*p == 56) {
#line 318
      goto case_56;
    }
#line 319
    if ((int )*p == 57) {
#line 319
      goto case_57;
    }
#line 320
    if ((int )*p == 97) {
#line 320
      goto case_97;
    }
#line 320
    if ((int )*p == 65) {
#line 320
      goto case_97;
    }
#line 321
    if ((int )*p == 98) {
#line 321
      goto case_98;
    }
#line 321
    if ((int )*p == 66) {
#line 321
      goto case_98;
    }
#line 322
    if ((int )*p == 99) {
#line 322
      goto case_99;
    }
#line 322
    if ((int )*p == 67) {
#line 322
      goto case_99;
    }
#line 323
    if ((int )*p == 100) {
#line 323
      goto case_100;
    }
#line 323
    if ((int )*p == 68) {
#line 323
      goto case_100;
    }
#line 324
    if ((int )*p == 101) {
#line 324
      goto case_101;
    }
#line 324
    if ((int )*p == 69) {
#line 324
      goto case_101;
    }
#line 325
    if ((int )*p == 102) {
#line 325
      goto case_102;
    }
#line 325
    if ((int )*p == 70) {
#line 325
      goto case_102;
    }
#line 308
    goto switch_break;
    case_48: /* CIL Label */ 
#line 310
    d = 0;
#line 310
    goto switch_break;
    case_49: /* CIL Label */ 
#line 311
    d = 1;
#line 311
    goto switch_break;
    case_50: /* CIL Label */ 
#line 312
    d = 2;
#line 312
    goto switch_break;
    case_51: /* CIL Label */ 
#line 313
    d = 3;
#line 313
    goto switch_break;
    case_52: /* CIL Label */ 
#line 314
    d = 4;
#line 314
    goto switch_break;
    case_53: /* CIL Label */ 
#line 315
    d = 5;
#line 315
    goto switch_break;
    case_54: /* CIL Label */ 
#line 316
    d = 6;
#line 316
    goto switch_break;
    case_55: /* CIL Label */ 
#line 317
    d = 7;
#line 317
    goto switch_break;
    case_56: /* CIL Label */ 
#line 318
    d = 8;
#line 318
    goto switch_break;
    case_57: /* CIL Label */ 
#line 319
    d = 9;
#line 319
    goto switch_break;
    case_97: /* CIL Label */ 
    case_65: /* CIL Label */ 
#line 320
    d = 10;
#line 320
    goto switch_break;
    case_98: /* CIL Label */ 
    case_66: /* CIL Label */ 
#line 321
    d = 11;
#line 321
    goto switch_break;
    case_99: /* CIL Label */ 
    case_67: /* CIL Label */ 
#line 322
    d = 12;
#line 322
    goto switch_break;
    case_100: /* CIL Label */ 
    case_68: /* CIL Label */ 
#line 323
    d = 13;
#line 323
    goto switch_break;
    case_101: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 324
    d = 14;
#line 324
    goto switch_break;
    case_102: /* CIL Label */ 
    case_70: /* CIL Label */ 
#line 325
    d = 15;
#line 325
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 327
    if (d < 0) {
#line 328
      goto while_break;
    } else
#line 327
    if (base <= d) {
#line 328
      goto while_break;
    }
#line 329
    n = n * base + d;
#line 305
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  if ((unsigned long )p == (unsigned long )buf) {
#line 332
    *result = (char )default_char;
  } else {
#line 334
    *result = (char )n;
  }
#line 335
  return (p);
}
}
#line 340
static struct buffer *read_filename(void) ;
#line 341 "compile.c"
static struct buffer *read_filename(void) 
{ 
  struct buffer *b___0 ;
  int ch ;

  {
  {
  {
#line 347
  b___0 = init_buffer();
  }
  {
#line 348
  ch = in_nonblank();
  }
  }
  {
  {
#line 349
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 349
    if (ch != -1) {
#line 349
      if (! (ch != 10)) {
#line 349
        goto while_break;
      }
    } else {
#line 349
      goto while_break;
    }
    {
    {
#line 359
    add1_buffer(b___0, ch);
    }
    {
#line 360
    ch = inchar();
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 362
  add1_buffer(b___0, '\000');
  }
  }
#line 363
  return (b___0);
}
}
#line 366
static FILE *get_openfile(struct fp_list **file_ptrs , char *mode , flagT fail ) ;
#line 367 "compile.c"
static FILE *get_openfile(struct fp_list **file_ptrs , char *mode , flagT fail ) 
{ 
  struct buffer *b___0 ;
  char *file_name ;
  struct fp_list *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  FILE *fp ;
  struct special_files *special ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *value ;

  {
  {
  {
#line 378
  b___0 = read_filename();
  }
  {
#line 379
  file_name = get_buffer(b___0);
  }
#line 380
  p = *file_ptrs;
  }
  {
  {
#line 380
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 380
    if (! p) {
#line 380
      goto while_break;
    }
#line 381
    if (0) {
      {
      {
#line 381
      __s1_len = strlen((char const   *)p->name);
      }
      {
#line 381
      __s2_len = strlen((char const   *)file_name);
      }
      }
#line 381
      if (! ((size_t )((void const   *)(p->name + 1)) - (size_t )((void const   *)p->name) == 1U)) {
#line 381
        goto _L___0;
      } else
#line 381
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 381
        if (! ((size_t )((void const   *)(file_name + 1)) - (size_t )((void const   *)file_name) == 1U)) {
#line 381
          tmp___4 = 1;
        } else
#line 381
        if (__s2_len >= 4U) {
#line 381
          tmp___4 = 1;
        } else {
#line 381
          tmp___4 = 0;
        }
      } else {
#line 381
        tmp___4 = 0;
      }
#line 381
      if (tmp___4) {
#line 381
        if (__s1_len < __s2_len) {
#line 381
          tmp___0 = __s1_len;
        } else {
#line 381
          tmp___0 = __s2_len;
        }
        {
        {
#line 381
        tmp___1 = memcmp((void const   *)((char const   *)p->name), (void const   *)((char const   *)file_name),
                         tmp___0 + 1U);
        }
#line 381
        tmp___3 = tmp___1;
        }
      } else {
        {
        {
#line 381
        tmp___2 = strcmp((char const   *)p->name, (char const   *)file_name);
        }
#line 381
        tmp___3 = tmp___2;
        }
      }
    } else {
      {
      {
#line 381
      tmp___2 = strcmp((char const   *)p->name, (char const   *)file_name);
      }
#line 381
      tmp___3 = tmp___2;
      }
    }
#line 381
    if (tmp___3 == 0) {
#line 382
      goto while_break;
    }
#line 380
    p = p->link;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  if (! p) {
#line 386
    fp = (FILE *)((void *)0);
#line 387
    if (! POSIXLY_CORRECT) {
#line 390
      special = special_files;
#line 394
      my_stdin = stdin;
#line 394
      my_stdout = stdout;
#line 394
      my_stderr = stderr;
#line 395
      special = special_files;
      {
      {
#line 395
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 395
        if (! special->name) {
#line 395
          goto while_break___0;
        }
#line 396
        if (0) {
          {
          {
#line 396
          __s1_len___0 = strlen((char const   *)special->name);
          }
          {
#line 396
          __s2_len___0 = strlen((char const   *)file_name);
          }
          }
#line 396
          if (! ((size_t )((void const   *)(special->name + 1)) - (size_t )((void const   *)special->name) == 1U)) {
#line 396
            goto _L___2;
          } else
#line 396
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 396
            if (! ((size_t )((void const   *)(file_name + 1)) - (size_t )((void const   *)file_name) == 1U)) {
#line 396
              tmp___10 = 1;
            } else
#line 396
            if (__s2_len___0 >= 4U) {
#line 396
              tmp___10 = 1;
            } else {
#line 396
              tmp___10 = 0;
            }
          } else {
#line 396
            tmp___10 = 0;
          }
#line 396
          if (tmp___10) {
#line 396
            if (__s1_len___0 < __s2_len___0) {
#line 396
              tmp___6 = __s1_len___0;
            } else {
#line 396
              tmp___6 = __s2_len___0;
            }
            {
            {
#line 396
            tmp___7 = memcmp((void const   *)((char const   *)special->name), (void const   *)((char const   *)file_name),
                             tmp___6 + 1U);
            }
#line 396
            tmp___9 = tmp___7;
            }
          } else {
            {
            {
#line 396
            tmp___8 = strcmp((char const   *)special->name, (char const   *)file_name);
            }
#line 396
            tmp___9 = tmp___8;
            }
          }
        } else {
          {
          {
#line 396
          tmp___8 = strcmp((char const   *)special->name, (char const   *)file_name);
          }
#line 396
          tmp___9 = tmp___8;
          }
        }
#line 396
        if (tmp___9 == 0) {
#line 398
          fp = *(special->pfp);
#line 399
          goto while_break___0;
        }
#line 395
        special ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 403
    __h = & obs;
#line 403
    __o = __h;
#line 403
    __len = (int )sizeof(struct fp_list );
#line 403
    if (__o->chunk_limit - __o->next_free < (long )__len) {
      {
      {
#line 403
      _obstack_newchunk(__o, __len);
      }
      }
    }
#line 403
    __o->next_free += __len;
#line 403
    __o1 = __h;
#line 403
    value = (void *)__o1->object_base;
#line 403
    if ((unsigned long )__o1->next_free == (unsigned long )value) {
#line 403
      __o1->maybe_empty_object = 1U;
    }
#line 403
    __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 403
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 403
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 403
    __o1->object_base = __o1->next_free;
#line 403
    p = (struct fp_list *)value;
    {
#line 404
    p->name = ck_strdup((char const   *)file_name);
    }
#line 405
    p->special = (unsigned long )fp != (unsigned long )((void *)0);
    }
#line 406
    if (! fp) {
      {
      {
#line 407
      fp = ck_fopen((char const   *)p->name, (char const   *)mode, fail);
      }
      }
    }
#line 408
    p->fp = fp;
#line 409
    p->link = *file_ptrs;
#line 410
    *file_ptrs = p;
  }
  {
  {
#line 412
  free_buffer(b___0);
  }
  }
#line 413
  return (p->fp);
}
}
#line 417
static struct sed_cmd *next_cmd_entry(struct vector **vectorp ) ;
#line 418 "compile.c"
static struct sed_cmd *next_cmd_entry(struct vector **vectorp ) 
{ 
  struct sed_cmd *cmd ;
  struct vector *v ;
  void *tmp ;

  {
#line 425
  v = *vectorp;
#line 426
  if (v->v_length == v->v_allocated) {
    {
#line 428
    v->v_allocated += 40U;
    {
#line 429
    tmp = ck_realloc((void *)v->v, (size_t )((unsigned long )v->v_allocated * sizeof(struct sed_cmd )));
    }
#line 429
    v->v = (struct sed_cmd *)tmp;
    }
  }
#line 432
  cmd = v->v + v->v_length;
#line 433
  cmd->a1 = (struct addr *)((void *)0);
#line 434
  cmd->a2 = (struct addr *)((void *)0);
#line 435
  cmd->a1_matched = (char)0;
#line 436
  cmd->addr_bang = (char)0;
#line 437
  cmd->cmd = (char )'\000';
#line 439
  *vectorp = v;
#line 440
  return (cmd);
}
}
#line 443
static int snarf_char_class(struct buffer *b___0 ) ;
#line 444 "compile.c"
static int snarf_char_class(struct buffer *b___0 ) 
{ 
  int ch ;
  int prev ;
  int delim ;

  {
  {
  {
#line 450
  ch = inchar();
  }
  }
#line 451
  if (ch == 94) {
    {
    {
#line 452
    ch = add_then_next(b___0, ch);
    }
    }
  }
#line 453
  if (ch == 93) {
    {
    {
#line 454
    ch = add_then_next(b___0, ch);
    }
    }
  }
  {
  {
#line 455
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 455
    if (ch != -1) {
#line 455
      if (ch != 10) {
#line 455
        if (! (ch != 93)) {
#line 455
          goto while_break;
        }
      } else {
#line 455
        goto while_break;
      }
    } else {
#line 455
      goto while_break;
    }
#line 457
    if (ch == 91) {
      {
      {
#line 460
      ch = add_then_next(b___0, ch);
      }
#line 460
      delim = ch;
      }
#line 462
      if (delim != 46) {
#line 462
        if (delim != 58) {
#line 462
          if (delim != 61) {
#line 463
            goto while_continue;
          }
        }
      }
      {
      {
#line 464
      ch = add_then_next(b___0, ch);
      }
#line 464
      prev = ch;
      }
      {
      {
#line 464
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 464
        if (ch == 93) {
#line 464
          if (prev == delim) {
#line 464
            goto while_break___0;
          }
        }
#line 467
        if (ch == -1) {
#line 468
          return (ch);
        } else
#line 467
        if (ch == 10) {
#line 468
          return (ch);
        }
        {
#line 469
        prev = ch;
        {
#line 464
        ch = add_then_next(b___0, ch);
        }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 473
    if (ch == 92) {
      {
      {
#line 475
      ch = inchar();
      }
      }
#line 476
      if (ch == -1) {
#line 477
        goto while_break;
      }
#line 478
      if (ch != 110) {
#line 478
        if (ch != 10) {
          {
          {
#line 480
          add1_buffer(b___0, '\\');
          }
          }
#line 481
          goto while_continue;
        }
      }
#line 483
      ch = '\n';
    }
    {
    {
#line 486
    ch = add_then_next(b___0, ch);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 489
  return (ch);
}
}
#line 492
static struct buffer *match_slash(int slash , flagT regex , flagT keep_backwhack ) ;
#line 493 "compile.c"
static struct buffer *match_slash(int slash , flagT regex , flagT keep_backwhack ) 
{ 
  struct buffer *b___0 ;
  int ch ;

  {
  {
  {
#line 502
  b___0 = init_buffer();
  }
  }
  {
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 503
    ch = inchar();
    }
    }
#line 503
    if (ch != -1) {
#line 503
      if (ch != 10) {
#line 503
        if (! (ch != slash)) {
#line 503
          goto while_break;
        }
      } else {
#line 503
        goto while_break;
      }
    } else {
#line 503
      goto while_break;
    }
#line 505
    if (ch == 92) {
      {
      {
#line 507
      ch = inchar();
      }
      }
#line 508
      if (ch == -1) {
#line 509
        goto while_break;
      } else
#line 511
      if (ch == 110) {
#line 511
        if (regex) {
#line 512
          ch = '\n';
        } else {
#line 511
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 514
      if (ch != 10) {
#line 514
        if (ch != slash) {
          {
          {
#line 515
          add1_buffer(b___0, '\\');
          }
          }
        } else
#line 514
        if (keep_backwhack) {
          {
          {
#line 515
          add1_buffer(b___0, '\\');
          }
          }
        }
      }
    } else
#line 517
    if (ch == 91) {
#line 517
      if (regex) {
        {
        {
#line 519
        add1_buffer(b___0, ch);
        }
        {
#line 520
        ch = snarf_char_class(b___0);
        }
        }
#line 521
        if (ch != 93) {
#line 522
          goto while_break;
        }
      }
    }
    {
    {
#line 524
    add1_buffer(b___0, ch);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  if (ch == slash) {
#line 527
    return (b___0);
  }
#line 529
  if (ch == 10) {
    {
    {
#line 530
    savchar(ch);
    }
    }
  }
  {
  {
#line 531
  free_buffer(b___0);
  }
  }
#line 532
  return ((struct buffer *)((void *)0));
}
}
#line 535
static flagT mark_subst_opts(struct subst *cmd ) ;
#line 536 "compile.c"
static flagT mark_subst_opts(struct subst *cmd ) 
{ 
  int flags ;
  int ch ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;

  {
#line 540
  flags = 0;
#line 543
  cmd->global = 0U;
#line 544
  cmd->print = 0U;
#line 545
  cmd->eval = 0U;
#line 546
  cmd->numb = (countT )0;
#line 547
  cmd->fp = (FILE *)((void *)0);
  {
  {
#line 549
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 550
    ch = in_nonblank();
    }
    }
    {
#line 553
    if (ch == 73) {
#line 553
      goto case_73;
    }
#line 553
    if (ch == 105) {
#line 553
      goto case_73;
    }
#line 572
    if (ch == 77) {
#line 572
      goto case_77;
    }
#line 572
    if (ch == 109) {
#line 572
      goto case_77;
    }
#line 576
    if (ch == 101) {
#line 576
      goto case_101;
    }
#line 580
    if (ch == 112) {
#line 580
      goto case_112;
    }
#line 586
    if (ch == 103) {
#line 586
      goto case_103;
    }
#line 592
    if (ch == 119) {
#line 592
      goto case_119;
    }
#line 597
    if (ch == 57) {
#line 597
      goto case_57;
    }
#line 597
    if (ch == 56) {
#line 597
      goto case_57;
    }
#line 597
    if (ch == 55) {
#line 597
      goto case_57;
    }
#line 597
    if (ch == 54) {
#line 597
      goto case_57;
    }
#line 597
    if (ch == 53) {
#line 597
      goto case_57;
    }
#line 597
    if (ch == 52) {
#line 597
      goto case_57;
    }
#line 597
    if (ch == 51) {
#line 597
      goto case_57;
    }
#line 597
    if (ch == 50) {
#line 597
      goto case_57;
    }
#line 597
    if (ch == 49) {
#line 597
      goto case_57;
    }
#line 597
    if (ch == 48) {
#line 597
      goto case_57;
    }
#line 606
    if (ch == 35) {
#line 606
      goto case_35;
    }
#line 606
    if (ch == 125) {
#line 606
      goto case_35;
    }
#line 611
    if (ch == 59) {
#line 611
      goto case_59;
    }
#line 611
    if (ch == 10) {
#line 611
      goto case_59;
    }
#line 611
    if (ch == -1) {
#line 611
      goto case_59;
    }
#line 614
    if (ch == 13) {
#line 614
      goto case_13;
    }
#line 619
    goto switch_default;
    case_73: /* CIL Label */ 
    case_105: /* CIL Label */ 
#line 554
    flags |= 1 << 1;
#line 555
    goto switch_break;
    case_77: /* CIL Label */ 
    case_109: /* CIL Label */ 
#line 573
    flags |= (1 << 1) << 1;
#line 574
    goto switch_break;
    case_101: /* CIL Label */ 
#line 577
    cmd->eval = 1U;
#line 578
    goto switch_break;
    case_112: /* CIL Label */ 
#line 581
    if (cmd->print) {
      {
      {
#line 582
      tmp = dcgettext((char const   *)((void *)0), (((((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex")) + sizeof("Unterminated `s\' command")) + sizeof("Unterminated `y\' command")) + sizeof("Unknown option to `s\'"),
                      5);
      }
      {
#line 582
      bad_prog((char const   *)tmp);
      }
      }
    }
#line 583
    cmd->print |= (unsigned int )(1 << cmd->eval);
#line 584
    goto switch_break;
    case_103: /* CIL Label */ 
#line 587
    if (cmd->global) {
      {
      {
#line 588
      tmp___0 = dcgettext((char const   *)((void *)0), ((((((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex")) + sizeof("Unterminated `s\' command")) + sizeof("Unterminated `y\' command")) + sizeof("Unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command"),
                          5);
      }
      {
#line 588
      bad_prog((char const   *)tmp___0);
      }
      }
    }
#line 589
    cmd->global = 1U;
#line 590
    goto switch_break;
    case_119: /* CIL Label */ 
    {
    {
#line 593
    cmd->fp = get_openfile(& file_write, (char *)"w", (flagT )1);
    }
    }
#line 594
    return ((flagT )flags);
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 598
    if (cmd->numb) {
      {
      {
#line 599
      tmp___1 = dcgettext((char const   *)((void *)0), (((((((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex")) + sizeof("Unterminated `s\' command")) + sizeof("Unterminated `y\' command")) + sizeof("Unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command"),
                          5);
      }
      {
#line 599
      bad_prog((char const   *)tmp___1);
      }
      }
    }
    {
    {
#line 600
    cmd->numb = in_integer(ch);
    }
    }
#line 601
    if (! cmd->numb) {
      {
      {
#line 602
      tmp___2 = dcgettext((char const   *)((void *)0), ((((((((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex")) + sizeof("Unterminated `s\' command")) + sizeof("Unterminated `y\' command")) + sizeof("Unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command"),
                          5);
      }
      {
#line 602
      bad_prog((char const   *)tmp___2);
      }
      }
    }
#line 603
    goto switch_break;
    case_35: /* CIL Label */ 
    case_125: /* CIL Label */ 
    {
    {
#line 607
    savchar(ch);
    }
    }
    case_59: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
#line 612
    return ((flagT )flags);
    case_13: /* CIL Label */ 
    {
    {
#line 615
    tmp___3 = inchar();
    }
    }
#line 615
    if (tmp___3 == 10) {
#line 616
      return ((flagT )flags);
    }
    switch_default: /* CIL Label */ 
    {
    {
#line 620
    tmp___4 = dcgettext((char const   *)((void *)0), ((((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex")) + sizeof("Unterminated `s\' command")) + sizeof("Unterminated `y\' command"),
                        5);
    }
    {
#line 620
    bad_prog((char const   *)tmp___4);
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 627
static char *read_label(void) ;
#line 628 "compile.c"
static char *read_label(void) 
{ 
  struct buffer *b___0 ;
  int ch ;
  char *ret ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
  {
  {
#line 635
  b___0 = init_buffer();
  }
  {
#line 636
  ch = in_nonblank();
  }
  }
  {
  {
#line 638
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 638
    if (ch != -1) {
#line 638
      if (ch != 10) {
        {
        {
#line 638
        tmp = __ctype_b_loc();
        }
        }
#line 638
        if ((int const   )*(*tmp + ch) & 1) {
#line 638
          goto while_break;
        } else
#line 638
        if (ch != 59) {
#line 638
          if (ch != 125) {
#line 638
            if (! (ch != 35)) {
#line 638
              goto while_break;
            }
          } else {
#line 638
            goto while_break;
          }
        } else {
#line 638
          goto while_break;
        }
      } else {
#line 638
        goto while_break;
      }
    } else {
#line 638
      goto while_break;
    }
    {
    {
#line 641
    add1_buffer(b___0, ch);
    }
    {
#line 642
    ch = inchar();
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 644
  savchar(ch);
  }
  {
#line 645
  add1_buffer(b___0, '\000');
  }
  {
#line 646
  tmp___0 = get_buffer(b___0);
  }
  {
#line 646
  ret = ck_strdup((char const   *)tmp___0);
  }
  {
#line 647
  free_buffer(b___0);
  }
  }
#line 648
  return (ret);
}
}
#line 655
static struct sed_label *setup_label(struct sed_label *list , countT idx , char *name ,
                                     struct error_info  const  *err_info ) ;
#line 657 "compile.c"
static struct sed_label *setup_label(struct sed_label *list , countT idx , char *name ,
                                     struct error_info  const  *err_info ) 
{ 
  struct sed_label *ret ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *value ;

  {
#line 664
  __h = & obs;
#line 664
  __o = __h;
#line 664
  __len = (int )sizeof(struct sed_label );
#line 664
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
    {
#line 664
    _obstack_newchunk(__o, __len);
    }
    }
  }
#line 664
  __o->next_free += __len;
#line 664
  __o1 = __h;
#line 664
  value = (void *)__o1->object_base;
#line 664
  if ((unsigned long )__o1->next_free == (unsigned long )value) {
#line 664
    __o1->maybe_empty_object = 1U;
  }
#line 664
  __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 664
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 664
    __o1->next_free = __o1->chunk_limit;
  }
#line 664
  __o1->object_base = __o1->next_free;
#line 664
  ret = (struct sed_label *)value;
#line 665
  ret->v_index = idx;
#line 666
  ret->name = name;
#line 667
  if (err_info) {
    {
    {
#line 668
    memcpy((void */* __restrict  */)(& ret->err_info), (void const   */* __restrict  */)err_info,
           (size_t )sizeof(ret->err_info));
    }
    }
  }
#line 669
  ret->next = list;
#line 670
  return (ret);
}
}
#line 673
static struct sed_label *release_label(struct sed_label *list_head ) ;
#line 674 "compile.c"
static struct sed_label *release_label(struct sed_label *list_head ) 
{ 
  struct sed_label *ret ;

  {
#line 680
  if (! list_head) {
#line 681
    return ((struct sed_label *)((void *)0));
  }
  {
#line 682
  ret = list_head->next;
  {
#line 684
  ck_free((void *)list_head->name);
  }
  }
#line 690
  return (ret);
}
}
#line 693
static struct replacement *new_replacement(char *text , size_t length , enum replacement_types type ) ;
#line 695 "compile.c"
static struct replacement *new_replacement(char *text , size_t length , enum replacement_types type ) 
{ 
  struct replacement *r ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *value ;

  {
#line 701
  __h = & obs;
#line 701
  __o = __h;
#line 701
  __len = (int )sizeof(struct replacement );
#line 701
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
    {
#line 701
    _obstack_newchunk(__o, __len);
    }
    }
  }
#line 701
  __o->next_free += __len;
#line 701
  __o1 = __h;
#line 701
  value = (void *)__o1->object_base;
#line 701
  if ((unsigned long )__o1->next_free == (unsigned long )value) {
#line 701
    __o1->maybe_empty_object = 1U;
  }
#line 701
  __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 701
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 701
    __o1->next_free = __o1->chunk_limit;
  }
#line 701
  __o1->object_base = __o1->next_free;
#line 701
  r = (struct replacement *)value;
#line 703
  r->prefix = text;
#line 704
  r->prefix_length = length;
#line 705
  r->subst_id = -1;
#line 706
  r->repl_type = type;
#line 709
  return (r);
}
}
#line 712
static void setup_replacement(struct subst *sub , char const   *text , size_t length ) ;
#line 713 "compile.c"
static void setup_replacement(struct subst *sub , char const   *text , size_t length ) 
{ 
  char *base ;
  char *p ;
  char *text_end ;
  enum replacement_types repl_type ;
  enum replacement_types save_type ;
  struct replacement root ;
  struct replacement *tail ;
  void *tmp ;
  struct replacement *tmp___0 ;
  struct replacement *tmp___1 ;
  struct replacement *tmp___2 ;

  {
  {
#line 722
  repl_type = (enum replacement_types )0;
#line 722
  save_type = (enum replacement_types )0;
#line 726
  sub->max_id = 0U;
  {
#line 727
  tmp = ck_memdup((void const   *)text, (size_t )((unsigned long )length * sizeof(char )));
  }
#line 727
  base = (char *)tmp;
  {
#line 728
  length = normalize_text(base, length);
  }
#line 730
  text_end = base + length;
#line 731
  tail = & root;
#line 733
  p = base;
  }
  {
  {
#line 733
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 733
    if (! ((unsigned long )p < (unsigned long )text_end)) {
#line 733
      goto while_break;
    }
#line 735
    if ((int )*p == 92) {
      {
      {
#line 738
      tmp___0 = new_replacement(base, (size_t )(p - base), repl_type);
      }
#line 738
      tail->next = tmp___0;
#line 738
      tail = tmp___0;
#line 741
      repl_type = save_type;
#line 744
      p ++;
      }
#line 745
      if ((unsigned long )p < (unsigned long )text_end) {
        {
#line 749
        if ((int )*p == 57) {
#line 749
          goto case_57;
        }
#line 749
        if ((int )*p == 56) {
#line 749
          goto case_57;
        }
#line 749
        if ((int )*p == 55) {
#line 749
          goto case_57;
        }
#line 749
        if ((int )*p == 54) {
#line 749
          goto case_57;
        }
#line 749
        if ((int )*p == 53) {
#line 749
          goto case_57;
        }
#line 749
        if ((int )*p == 52) {
#line 749
          goto case_57;
        }
#line 749
        if ((int )*p == 51) {
#line 749
          goto case_57;
        }
#line 749
        if ((int )*p == 50) {
#line 749
          goto case_57;
        }
#line 749
        if ((int )*p == 49) {
#line 749
          goto case_57;
        }
#line 749
        if ((int )*p == 48) {
#line 749
          goto case_57;
        }
#line 755
        if ((int )*p == 76) {
#line 755
          goto case_76;
        }
#line 760
        if ((int )*p == 85) {
#line 760
          goto case_85;
        }
#line 765
        if ((int )*p == 69) {
#line 765
          goto case_69;
        }
#line 770
        if ((int )*p == 108) {
#line 770
          goto case_108;
        }
#line 775
        if ((int )*p == 117) {
#line 775
          goto case_117;
        }
#line 780
        goto switch_default;
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
#line 750
        tail->subst_id = (int )*p - 48;
#line 751
        if (sub->max_id < (unsigned int )tail->subst_id) {
#line 752
          sub->max_id = (unsigned int )tail->subst_id;
        }
#line 753
        goto switch_break;
        case_76: /* CIL Label */ 
#line 756
        repl_type = (enum replacement_types )2;
#line 757
        save_type = (enum replacement_types )2;
#line 758
        goto switch_break;
        case_85: /* CIL Label */ 
#line 761
        repl_type = (enum replacement_types )1;
#line 762
        save_type = (enum replacement_types )1;
#line 763
        goto switch_break;
        case_69: /* CIL Label */ 
#line 766
        repl_type = (enum replacement_types )0;
#line 767
        save_type = (enum replacement_types )0;
#line 768
        goto switch_break;
        case_108: /* CIL Label */ 
#line 771
        save_type = repl_type;
#line 772
        repl_type = (enum replacement_types )((unsigned int )repl_type | 8U);
#line 773
        goto switch_break;
        case_117: /* CIL Label */ 
#line 776
        save_type = repl_type;
#line 777
        repl_type = (enum replacement_types )((unsigned int )repl_type | 4U);
#line 778
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 781
        *(p + -1) = *p;
#line 782
        (tail->prefix_length) ++;
        switch_break: /* CIL Label */ ;
        }
      }
#line 785
      base = p + 1;
    } else
#line 787
    if ((int )*p == 38) {
      {
      {
#line 790
      tmp___1 = new_replacement(base, (size_t )(p - base), repl_type);
      }
#line 790
      tail->next = tmp___1;
#line 790
      tail = tmp___1;
#line 793
      repl_type = save_type;
#line 794
      tail->subst_id = 0;
#line 795
      base = p + 1;
      }
    }
#line 733
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 799
  if ((unsigned long )base < (unsigned long )text_end) {
    {
    {
#line 800
    tmp___2 = new_replacement(base, (size_t )(text_end - base), repl_type);
    }
#line 800
    tail->next = tmp___2;
#line 800
    tail = tmp___2;
    }
  }
#line 803
  tail->next = (struct replacement *)((void *)0);
#line 804
  sub->replacement = root.next;
#line 805
  return;
}
}
#line 807
static void read_text(struct text_buf *buf , int leadin_ch ) ;
#line 808 "compile.c"
static void read_text(struct text_buf *buf , int leadin_ch ) 
{ 
  int ch ;
  char *tmp ;
  void *tmp___0 ;

  {
#line 816
  if (buf) {
#line 818
    if (pending_text) {
      {
      {
#line 819
      free_buffer(pending_text);
      }
      }
    }
    {
    {
#line 820
    pending_text = init_buffer();
    }
#line 821
    buf->text = (char *)((void *)0);
#line 822
    buf->text_length = (size_t )0;
#line 823
    old_text_buf = buf;
    }
  }
#line 827
  if (leadin_ch == -1) {
#line 828
    return;
  }
#line 830
  if (leadin_ch != 10) {
    {
    {
#line 831
    add1_buffer(pending_text, leadin_ch);
    }
    }
  }
  {
  {
#line 832
  ch = inchar();
  }
  }
  {
  {
#line 843
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 843
    if (ch != -1) {
#line 843
      if (! (ch != 10)) {
#line 843
        goto while_break;
      }
    } else {
#line 843
      goto while_break;
    }
#line 845
    if (ch == 92) {
      {
      {
#line 846
      ch = inchar();
      }
      }
    }
#line 847
    if (ch == -1) {
      {
      {
#line 849
      add1_buffer(pending_text, '\n');
      }
      }
#line 850
      return;
    }
    {
    {
#line 852
    add1_buffer(pending_text, ch);
    }
    {
#line 858
    ch = inchar();
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 860
  add1_buffer(pending_text, '\n');
  }
  }
#line 862
  if (! buf) {
#line 863
    buf = old_text_buf;
  }
  {
  {
#line 864
  buf->text_length = size_buffer(pending_text);
  }
  {
#line 865
  tmp = get_buffer(pending_text);
  }
  {
#line 865
  tmp___0 = ck_memdup((void const   *)tmp, (size_t )((unsigned long )buf->text_length * sizeof(char )));
  }
#line 865
  buf->text = (char *)tmp___0;
  {
#line 866
  free_buffer(pending_text);
  }
#line 867
  pending_text = (struct buffer *)((void *)0);
  }
#line 868
  return;
}
}
#line 875
static flagT compile_address(struct addr *addr , int ch ) ;
#line 876 "compile.c"
static flagT compile_address(struct addr *addr , int ch ) 
{ 
  int flags ;
  struct buffer *b___0 ;
  char *tmp ;
  countT step ;
  int tmp___0 ;
  countT tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 881
  addr->addr_type = (enum addr_types )0;
#line 882
  addr->addr_step = (countT )0;
#line 883
  addr->addr_number = ~ ((countT )0);
#line 884
  addr->addr_regex = (regex_t *)((void *)0);
#line 886
  if (ch == 47) {
#line 886
    goto _L___0;
  } else
#line 886
  if (ch == 92) {
    _L___0: /* CIL Label */ 
#line 888
    flags = 0;
#line 890
    addr->addr_type = (enum addr_types )1;
#line 891
    if (ch == 92) {
      {
      {
#line 892
      ch = inchar();
      }
      }
    }
    {
    {
#line 893
    b___0 = match_slash(ch, (flagT )1, (flagT )1);
    }
    }
#line 893
    if (! b___0) {
      {
      {
#line 894
      tmp = dcgettext((char const   *)((void *)0), (((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address"),
                      5);
      }
      {
#line 894
      bad_prog((char const   *)tmp);
      }
      }
    }
    {
    {
#line 896
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 898
      ch = in_nonblank();
      }
      }
      {
#line 901
      if (ch == 73) {
#line 901
        goto case_73;
      }
#line 917
      if (ch == 77) {
#line 917
        goto case_77;
      }
#line 921
      goto switch_default;
      case_73: /* CIL Label */ 
#line 902
      flags |= 1 << 1;
#line 903
      goto switch_break;
      case_77: /* CIL Label */ 
#line 918
      flags |= (1 << 1) << 1;
#line 919
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 922
      savchar(ch);
      }
      {
#line 923
      addr->addr_regex = compile_regex(b___0, flags, 0);
      }
      {
#line 924
      free_buffer(b___0);
      }
      }
#line 925
      return ((flagT )1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 929
    tmp___3 = __ctype_b_loc();
    }
    }
#line 929
    if ((int const   )*(*tmp___3 + ch) & 2048) {
      {
      {
#line 931
      addr->addr_number = in_integer(ch);
      }
#line 932
      addr->addr_type = (enum addr_types )2;
      {
#line 933
      ch = in_nonblank();
      }
      }
#line 934
      if (ch != 126) {
        {
        {
#line 936
        savchar(ch);
        }
        }
      } else {
        {
        {
#line 940
        tmp___0 = in_nonblank();
        }
        {
#line 940
        tmp___1 = in_integer(tmp___0);
        }
#line 940
        step = tmp___1;
        }
#line 941
        if (step > 0UL) {
#line 943
          addr->addr_step = step;
#line 944
          addr->addr_type = (enum addr_types )3;
        }
      }
    } else
#line 948
    if (ch == 43) {
#line 948
      goto _L;
    } else
#line 948
    if (ch == 126) {
      _L: /* CIL Label */ 
      {
      {
#line 950
      tmp___2 = in_nonblank();
      }
      {
#line 950
      addr->addr_step = in_integer(tmp___2);
      }
      }
#line 951
      if (! (addr->addr_step == 0UL)) {
#line 953
        if (ch == 43) {
#line 954
          addr->addr_type = (enum addr_types )5;
        } else {
#line 956
          addr->addr_type = (enum addr_types )6;
        }
      }
    } else
#line 958
    if (ch == 36) {
#line 960
      addr->addr_type = (enum addr_types )7;
    } else {
#line 963
      return ((flagT )0);
    }
  }
#line 965
  return ((flagT )1);
}
}
#line 970
static struct vector *compile_program(struct vector *vector ) ;
#line 971 "compile.c"
static struct vector *compile_program(struct vector *vector ) 
{ 
  struct sed_cmd *cur_cmd ;
  struct buffer *b___0 ;
  int ch ;
  void *tmp ;
  struct addr a ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  flagT tmp___5 ;
  void *tmp___6 ;
  flagT tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  long tmp___10 ;
  char *version ;
  char *tmp___11 ;
  char *compared_version ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  countT tmp___24 ;
  unsigned short const   **tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  struct buffer *b2 ;
  int flags ;
  int slash ;
  char *tmp___31 ;
  char *tmp___32 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *value ;
  size_t tmp___33 ;
  char *tmp___34 ;
  flagT tmp___35 ;
  unsigned char *ustring ;
  size_t len ;
  int slash___0 ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o1___0 ;
  void *value___0 ;
  size_t tmp___36 ;
  char *tmp___37 ;
  int i ;
  int j ;
  int idx ;
  int src_char_num ;
  int len___0 ;
  size_t tmp___38 ;
  size_t *src_lens ;
  void *tmp___39 ;
  char *src_buf ;
  char *dest_buf ;
  char **trans_pairs ;
  size_t mbclen ;
  mbstate_t cur_stat ;
  struct buffer *b2___0 ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_33 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  int tmp___40 ;
  void *__s___2 ;
  void *__s___3 ;
  union __anonunion___u_34 *__u___0 ;
  __uint8_t __c___0 ;
  void *__s___4 ;
  char *tmp___41 ;
  size_t tmp___42 ;
  void *tmp___43 ;
  char *tmp___44 ;
  void *tmp___45 ;
  void *tmp___47 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  unsigned char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  int tmp___55 ;
  size_t tmp___56 ;
  char *tmp___57 ;
  char const   *msg ;
  char *tmp___58 ;
  char *unknown_cmd ;
  size_t tmp___59 ;
  void *tmp___60 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;
  char *__cil_tmp250 ;
  char *__cil_tmp251 ;
  char *__cil_tmp252 ;
  char *__cil_tmp253 ;
  char *__cil_tmp254 ;
  char *__cil_tmp255 ;
  char *__cil_tmp256 ;
  char *__cil_tmp257 ;
  char *__cil_tmp258 ;
  char *__cil_tmp259 ;
  char *__cil_tmp260 ;
  char *__cil_tmp261 ;
  char *__cil_tmp262 ;
  char *__cil_tmp263 ;
  char *__cil_tmp264 ;
  char *__cil_tmp265 ;
  char *__cil_tmp266 ;
  char *__cil_tmp267 ;
  char *__cil_tmp268 ;
  char *__cil_tmp269 ;
  char *__cil_tmp270 ;
  char *__cil_tmp271 ;
  char *__cil_tmp272 ;
  char *__cil_tmp273 ;
  char *__cil_tmp274 ;
  char *__cil_tmp275 ;
  char *__cil_tmp276 ;
  char *__cil_tmp277 ;
  char *__cil_tmp278 ;
  char *__cil_tmp279 ;
  char *__cil_tmp280 ;
  char *__cil_tmp281 ;
  char *__cil_tmp282 ;
  char *__cil_tmp283 ;
  char *__cil_tmp284 ;
  char *__cil_tmp285 ;
  char *__cil_tmp286 ;
  char *__cil_tmp287 ;
  char *__cil_tmp288 ;
  char *__cil_tmp289 ;
  char *__cil_tmp290 ;
  char *__cil_tmp291 ;
  char *__cil_tmp292 ;
  char *__cil_tmp293 ;
  char *__cil_tmp294 ;
  char *__cil_tmp295 ;
  char *__cil_tmp296 ;
  char *__cil_tmp297 ;
  char *__cil_tmp298 ;
  char *__cil_tmp299 ;
  char *__cil_tmp300 ;
  char *__cil_tmp301 ;
  char *__cil_tmp302 ;
  char *__cil_tmp303 ;
  char *__cil_tmp304 ;
  char *__cil_tmp305 ;
  char *__cil_tmp306 ;
  char *__cil_tmp307 ;
  char *__cil_tmp308 ;
  char *__cil_tmp309 ;
  char *__cil_tmp310 ;
  char *__cil_tmp311 ;
  char *__cil_tmp312 ;
  char *__cil_tmp313 ;
  char *__cil_tmp314 ;
  char *__cil_tmp315 ;
  char *__cil_tmp316 ;
  char *__cil_tmp317 ;
  char *__cil_tmp318 ;
  char *__cil_tmp319 ;
  char *__cil_tmp320 ;
  char *__cil_tmp321 ;
  char *__cil_tmp322 ;
  char *__cil_tmp323 ;
  char *__cil_tmp324 ;
  char *__cil_tmp325 ;
  char *__cil_tmp326 ;
  char *__cil_tmp327 ;
  char *__cil_tmp328 ;
  char *__cil_tmp329 ;
  char *__cil_tmp330 ;
  char *__cil_tmp331 ;
  char *__cil_tmp332 ;
  char *__cil_tmp333 ;
  char *__cil_tmp334 ;
  char *__cil_tmp335 ;
  char *__cil_tmp336 ;
  char *__cil_tmp337 ;
  char *__cil_tmp338 ;
  char *__cil_tmp339 ;
  char *__cil_tmp340 ;
  char *__cil_tmp341 ;
  char *__cil_tmp342 ;
  char *__cil_tmp343 ;
  char *__cil_tmp344 ;
  char *__cil_tmp345 ;
  char *__cil_tmp346 ;
  char *__cil_tmp347 ;
  char *__cil_tmp348 ;
  char *__cil_tmp349 ;
  char *__cil_tmp350 ;
  char *__cil_tmp351 ;
  char *__cil_tmp352 ;
  char *__cil_tmp353 ;
  char *__cil_tmp354 ;
  char *__cil_tmp355 ;
  char *__cil_tmp356 ;
  char *__cil_tmp357 ;
  char *__cil_tmp358 ;
  char *__cil_tmp359 ;
  char *__cil_tmp360 ;
  char *__cil_tmp361 ;
  char *__cil_tmp362 ;
  char *__cil_tmp363 ;
  char *__cil_tmp364 ;
  char *__cil_tmp365 ;
  char *__cil_tmp366 ;
  char *__cil_tmp367 ;
  char *__cil_tmp368 ;
  char *__cil_tmp369 ;
  char *__cil_tmp370 ;
  char *__cil_tmp371 ;
  char *__cil_tmp372 ;
  char *__cil_tmp373 ;
  char *__cil_tmp374 ;
  char *__cil_tmp375 ;
  char *__cil_tmp376 ;
  char *__cil_tmp377 ;
  char *__cil_tmp378 ;
  char *__cil_tmp379 ;
  char *__cil_tmp380 ;
  char *__cil_tmp381 ;
  char *__cil_tmp382 ;
  char *__cil_tmp383 ;
  char *__cil_tmp384 ;
  char *__cil_tmp385 ;
  char *__cil_tmp386 ;
  char *__cil_tmp387 ;
  char *__cil_tmp388 ;
  char *__cil_tmp389 ;
  char *__cil_tmp390 ;
  char *__cil_tmp391 ;
  char *__cil_tmp392 ;
  char *__cil_tmp393 ;
  char *__cil_tmp394 ;
  char *__cil_tmp395 ;
  char *__cil_tmp396 ;
  char *__cil_tmp397 ;
  char *__cil_tmp398 ;
  char *__cil_tmp399 ;
  char *__cil_tmp400 ;
  char *__cil_tmp401 ;
  char *__cil_tmp402 ;
  char *__cil_tmp403 ;
  char *__cil_tmp404 ;
  char *__cil_tmp405 ;
  char *__cil_tmp406 ;
  char *__cil_tmp407 ;
  char *__cil_tmp408 ;
  char *__cil_tmp409 ;
  char *__cil_tmp410 ;
  char *__cil_tmp411 ;
  char *__cil_tmp412 ;
  char *__cil_tmp413 ;
  char *__cil_tmp414 ;
  char *__cil_tmp415 ;
  char *__cil_tmp416 ;
  char *__cil_tmp417 ;
  char *__cil_tmp418 ;
  char *__cil_tmp419 ;
  char *__cil_tmp420 ;
  char *__cil_tmp421 ;
  char *__cil_tmp422 ;

  {
#line 979
  if (! vector) {
    {
    {
#line 981
    tmp = ck_malloc((size_t )sizeof(struct vector ));
    }
#line 981
    vector = (struct vector *)tmp;
#line 982
    vector->v = (struct sed_cmd *)((void *)0);
#line 983
    vector->v_allocated = (size_t )0;
#line 984
    vector->v_length = (size_t )0;
    {
#line 986
    _obstack_begin(& obs, 0, 0, (void *(*)(long  ))(& ck_malloc), & ck_free);
    }
    }
  }
#line 988
  if (pending_text) {
    {
    {
#line 989
    read_text((struct text_buf *)((void *)0), '\n');
    }
    }
  }
  {
  {
#line 991
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 995
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 995
      ch = inchar();
      }
      }
#line 995
      if (! (ch == 59)) {
        {
        {
#line 995
        tmp___0 = __ctype_b_loc();
        }
        }
#line 995
        if (! ((int const   )*(*tmp___0 + ch) & 8192)) {
#line 995
          goto while_break___0;
        }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 997
    if (ch == -1) {
#line 998
      goto while_break;
    }
    {
    {
#line 1000
    cur_cmd = next_cmd_entry(& vector);
    }
    {
#line 1001
    tmp___7 = compile_address(& a, ch);
    }
    }
#line 1001
    if (tmp___7) {
#line 1003
      if ((unsigned int )a.addr_type == 5U) {
        {
        {
#line 1005
        tmp___1 = dcgettext((char const   *)((void *)0), (errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'"),
                            5);
        }
        {
#line 1005
        bad_prog((char const   *)tmp___1);
        }
        }
      } else
#line 1003
      if ((unsigned int )a.addr_type == 6U) {
        {
        {
#line 1005
        tmp___1 = dcgettext((char const   *)((void *)0), (errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'"),
                            5);
        }
        {
#line 1005
        bad_prog((char const   *)tmp___1);
        }
        }
      }
      {
      {
#line 1007
      tmp___2 = ck_memdup((void const   *)(& a), (size_t )sizeof(struct addr ));
      }
#line 1007
      cur_cmd->a1 = (struct addr *)tmp___2;
      {
#line 1008
      ch = in_nonblank();
      }
      }
#line 1009
      if (ch == 44) {
        {
        {
#line 1011
        tmp___4 = in_nonblank();
        }
        {
#line 1011
        tmp___5 = compile_address(& a, tmp___4);
        }
        }
#line 1011
        if (! tmp___5) {
          {
          {
#line 1012
          tmp___3 = dcgettext((char const   *)((void *)0), errors___0 + sizeof("Multiple `!\'s"),
                              5);
          }
          {
#line 1012
          bad_prog((char const   *)tmp___3);
          }
          }
        }
#line 1013
        if ((unsigned int )a.addr_type == 2U) {
#line 1014
          a.addr_type = (enum addr_types )4;
        }
        {
        {
#line 1015
        tmp___6 = ck_memdup((void const   *)(& a), (size_t )sizeof(struct addr ));
        }
#line 1015
        cur_cmd->a2 = (struct addr *)tmp___6;
        {
#line 1016
        ch = in_nonblank();
        }
        }
#line 1017
        if ((unsigned int )(cur_cmd->a1)->addr_type == 2U) {
#line 1017
          goto _L;
        } else
#line 1017
        if ((unsigned int )(cur_cmd->a1)->addr_type == 3U) {
          _L: /* CIL Label */ 
#line 1017
          if ((cur_cmd->a1)->addr_number == 0UL) {
#line 1020
            cur_cmd->a1_matched = (char)1;
          }
        }
      }
    }
#line 1023
    if (ch == 33) {
      {
#line 1025
      cur_cmd->addr_bang = (char)1;
      {
#line 1026
      ch = in_nonblank();
      }
      }
#line 1027
      if (ch == 33) {
        {
        {
#line 1028
        tmp___8 = dcgettext((char const   *)((void *)0), errors___0, 5);
        }
        {
#line 1028
        bad_prog((char const   *)tmp___8);
        }
        }
      }
    }
#line 1031
    cur_cmd->cmd = (char )ch;
    {
#line 1034
    if (ch == 35) {
#line 1034
      goto case_35;
    }
#line 1046
    if (ch == 118) {
#line 1046
      goto case_118;
    }
#line 1063
    if (ch == 123) {
#line 1063
      goto case_123;
    }
#line 1068
    if (ch == 125) {
#line 1068
      goto case_125;
    }
#line 1083
    if (ch == 101) {
#line 1083
      goto case_101;
    }
#line 1094
    if (ch == 105) {
#line 1094
      goto case_105;
    }
#line 1094
    if (ch == 97) {
#line 1094
      goto case_105;
    }
#line 1099
    if (ch == 99) {
#line 1099
      goto case_99;
    }
#line 1117
    if (ch == 58) {
#line 1117
      goto case_58;
    }
#line 1125
    if (ch == 84) {
#line 1125
      goto case_84;
    }
#line 1125
    if (ch == 116) {
#line 1125
      goto case_84;
    }
#line 1125
    if (ch == 98) {
#line 1125
      goto case_84;
    }
#line 1130
    if (ch == 81) {
#line 1130
      goto case_81;
    }
#line 1130
    if (ch == 113) {
#line 1130
      goto case_81;
    }
#line 1136
    if (ch == 76) {
#line 1136
      goto case_76;
    }
#line 1136
    if (ch == 108) {
#line 1136
      goto case_76;
    }
#line 1156
    if (ch == 61) {
#line 1156
      goto case_61;
    }
#line 1170
    if (ch == 120) {
#line 1170
      goto case_120;
    }
#line 1170
    if (ch == 80) {
#line 1170
      goto case_120;
    }
#line 1170
    if (ch == 112) {
#line 1170
      goto case_120;
    }
#line 1170
    if (ch == 78) {
#line 1170
      goto case_120;
    }
#line 1170
    if (ch == 110) {
#line 1170
      goto case_120;
    }
#line 1170
    if (ch == 72) {
#line 1170
      goto case_120;
    }
#line 1170
    if (ch == 104) {
#line 1170
      goto case_120;
    }
#line 1170
    if (ch == 71) {
#line 1170
      goto case_120;
    }
#line 1170
    if (ch == 103) {
#line 1170
      goto case_120;
    }
#line 1170
    if (ch == 68) {
#line 1170
      goto case_120;
    }
#line 1170
    if (ch == 100) {
#line 1170
      goto case_120;
    }
#line 1178
    if (ch == 114) {
#line 1178
      goto case_114;
    }
#line 1186
    if (ch == 82) {
#line 1186
      goto case_82;
    }
#line 1191
    if (ch == 87) {
#line 1191
      goto case_87;
    }
#line 1191
    if (ch == 119) {
#line 1191
      goto case_87;
    }
#line 1195
    if (ch == 115) {
#line 1195
      goto case_115;
    }
#line 1219
    if (ch == 121) {
#line 1219
      goto case_121;
    }
#line 1336
    if (ch == -1) {
#line 1336
      goto case_neg_1;
    }
#line 1339
    goto switch_default;
    case_35: /* CIL Label */ 
#line 1035
    if (cur_cmd->a1) {
      {
      {
#line 1036
      tmp___9 = dcgettext((char const   *)((void *)0), ((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses"),
                          5);
      }
      {
#line 1036
      bad_prog((char const   *)tmp___9);
      }
      }
    }
    {
    {
#line 1037
    ch = inchar();
    }
    }
#line 1038
    if (ch == 110) {
#line 1038
      if (first_script) {
#line 1038
        if (cur_input.line < 2UL) {
#line 1039
          if (prog.base) {
#line 1039
            if ((unsigned long )prog.cur == (unsigned long )(prog.base + 2)) {
#line 1041
              no_default_output = (flagT )1;
            } else {
#line 1039
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 1039
          if (prog.file) {
#line 1039
            if (! prog.base) {
              {
              {
#line 1039
              tmp___10 = ftell(prog.file);
              }
              }
#line 1039
              if (2L == tmp___10) {
#line 1041
                no_default_output = (flagT )1;
              }
            }
          }
        }
      }
    }
    {
    {
#line 1042
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 1042
      if (ch != -1) {
#line 1042
        if (! (ch != 10)) {
#line 1042
          goto while_break___1;
        }
      } else {
#line 1042
        goto while_break___1;
      }
      {
      {
#line 1043
      ch = inchar();
      }
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1044
    goto __Cont;
    case_118: /* CIL Label */ 
    {
    {
#line 1052
    tmp___11 = read_label();
    }
#line 1052
    version = tmp___11;
    }
#line 1054
    if ((int )*version == 0) {
#line 1054
      compared_version = (char *)"4.0";
    } else {
#line 1054
      compared_version = version;
    }
    {
    {
#line 1055
    tmp___13 = strverscmp((char const   *)compared_version, "4.0");
    }
    }
#line 1055
    if (tmp___13 > 0) {
      {
      {
#line 1056
      tmp___12 = dcgettext((char const   *)((void *)0), ((((((((((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex")) + sizeof("Unterminated `s\' command")) + sizeof("Unterminated `y\' command")) + sizeof("Unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for y command are different lengths"),
                           5);
      }
      {
#line 1056
      bad_prog((char const   *)tmp___12);
      }
      }
    }
    {
    {
#line 1058
    free((void *)version);
    }
#line 1059
    POSIXLY_CORRECT = (flagT )0;
    }
#line 1061
    goto __Cont;
    case_123: /* CIL Label */ 
    {
    {
#line 1064
    blocks = setup_label(blocks, (countT )vector->v_length, (char *)((void *)0), (struct error_info  const  *)(& cur_input));
    }
#line 1065
    cur_cmd->addr_bang = (char )(! cur_cmd->addr_bang);
    }
#line 1066
    goto switch_break;
    case_125: /* CIL Label */ 
#line 1069
    if (! blocks) {
      {
      {
#line 1070
      tmp___14 = dcgettext((char const   *)((void *)0), (((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'"),
                           5);
      }
      {
#line 1070
      bad_prog((char const   *)tmp___14);
      }
      }
    }
#line 1071
    if (cur_cmd->a1) {
      {
      {
#line 1072
      tmp___15 = dcgettext((char const   *)((void *)0), ((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'"),
                           5);
      }
      {
#line 1072
      bad_prog((char const   *)tmp___15);
      }
      }
    }
    {
    {
#line 1073
    ch = in_nonblank();
    }
    }
#line 1074
    if (ch == 125) {
      {
      {
#line 1075
      savchar(ch);
      }
      }
    } else
#line 1074
    if (ch == 35) {
      {
      {
#line 1075
      savchar(ch);
      }
      }
    } else
#line 1076
    if (ch != -1) {
#line 1076
      if (ch != 10) {
#line 1076
        if (ch != 59) {
          {
          {
#line 1077
          tmp___16 = dcgettext((char const   *)((void *)0), ((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'"),
                               5);
          }
          {
#line 1077
          bad_prog((char const   *)tmp___16);
          }
          }
        }
      }
    }
    {
#line 1079
    (vector->v + blocks->v_index)->x.jump_index = (countT )vector->v_length;
    {
#line 1080
    blocks = release_label(blocks);
    }
    }
#line 1081
    goto switch_break;
    case_101: /* CIL Label */ 
    {
    {
#line 1084
    ch = in_nonblank();
    }
    }
#line 1085
    if (ch == -1) {
#line 1087
      cur_cmd->x.cmd_txt.text_length = (size_t )0;
#line 1088
      goto switch_break;
    } else
#line 1085
    if (ch == 10) {
#line 1087
      cur_cmd->x.cmd_txt.text_length = (size_t )0;
#line 1088
      goto switch_break;
    } else {
#line 1091
      goto read_text_to_slash;
    }
    case_105: /* CIL Label */ 
    case_97: /* CIL Label */ 
#line 1095
    if (POSIXLY_CORRECT) {
#line 1095
      if (cur_cmd->a2) {
        {
        {
#line 1096
        tmp___17 = dcgettext((char const   *)((void *)0), ((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command"),
                             5);
        }
        {
#line 1096
        bad_prog((char const   *)tmp___17);
        }
        }
      }
    }
    case_99: /* CIL Label */ 
    {
    {
#line 1100
    ch = in_nonblank();
    }
    }
    read_text_to_slash: 
#line 1103
    if (ch == -1) {
      {
      {
#line 1104
      tmp___18 = dcgettext((char const   *)((void *)0), (((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command"),
                           5);
      }
      {
#line 1104
      bad_prog((char const   *)tmp___18);
      }
      }
    }
#line 1106
    if (ch == 92) {
      {
      {
#line 1107
      ch = inchar();
      }
      }
    } else {
      {
      {
#line 1110
      savchar(ch);
      }
#line 1111
      ch = '\n';
      }
    }
    {
    {
#line 1114
    read_text(& cur_cmd->x.cmd_txt, ch);
    }
    }
#line 1115
    goto switch_break;
    case_58: /* CIL Label */ 
#line 1118
    if (cur_cmd->a1) {
      {
      {
#line 1119
      tmp___19 = dcgettext((char const   *)((void *)0), (((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses"),
                           5);
      }
      {
#line 1119
      bad_prog((char const   *)tmp___19);
      }
      }
    }
    {
    {
#line 1120
    tmp___20 = read_label();
    }
    {
#line 1120
    labels = setup_label(labels, (countT )vector->v_length, tmp___20, (struct error_info  const  *)((void *)0));
    }
    }
#line 1121
    goto switch_break;
    case_84: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_98: /* CIL Label */ 
    {
    {
#line 1126
    tmp___21 = read_label();
    }
    {
#line 1126
    jumps = setup_label(jumps, (countT )vector->v_length, tmp___21, (struct error_info  const  *)((void *)0));
    }
    }
#line 1127
    goto switch_break;
    case_81: /* CIL Label */ 
    case_113: /* CIL Label */ 
#line 1131
    if (cur_cmd->a2) {
      {
      {
#line 1132
      tmp___22 = dcgettext((char const   *)((void *)0), ((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command"),
                           5);
      }
      {
#line 1132
      bad_prog((char const   *)tmp___22);
      }
      }
    }
    case_76: /* CIL Label */ 
    case_108: /* CIL Label */ 
#line 1137
    if (POSIXLY_CORRECT) {
#line 1137
      if (cur_cmd->a2) {
        {
        {
#line 1138
        tmp___23 = dcgettext((char const   *)((void *)0), ((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command"),
                             5);
        }
        {
#line 1138
        bad_prog((char const   *)tmp___23);
        }
        }
      }
    }
    {
    {
#line 1140
    ch = in_nonblank();
    }
    {
#line 1141
    tmp___25 = __ctype_b_loc();
    }
    }
#line 1141
    if ((int const   )*(*tmp___25 + ch) & 2048) {
      {
      {
#line 1143
      tmp___24 = in_integer(ch);
      }
#line 1143
      cur_cmd->x.int_arg = (int )tmp___24;
      {
#line 1144
      ch = in_nonblank();
      }
      }
    } else {
#line 1147
      cur_cmd->x.int_arg = -1;
    }
#line 1149
    if (ch == 125) {
      {
      {
#line 1150
      savchar(ch);
      }
      }
    } else
#line 1149
    if (ch == 35) {
      {
      {
#line 1150
      savchar(ch);
      }
      }
    } else
#line 1151
    if (ch != -1) {
#line 1151
      if (ch != 10) {
#line 1151
        if (ch != 59) {
          {
          {
#line 1152
          tmp___26 = dcgettext((char const   *)((void *)0), ((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'"),
                               5);
          }
          {
#line 1152
          bad_prog((char const   *)tmp___26);
          }
          }
        }
      }
    }
#line 1154
    goto switch_break;
    case_61: /* CIL Label */ 
#line 1157
    if (POSIXLY_CORRECT) {
#line 1157
      if (cur_cmd->a2) {
        {
        {
#line 1158
        tmp___27 = dcgettext((char const   *)((void *)0), ((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command"),
                             5);
        }
        {
#line 1158
        bad_prog((char const   *)tmp___27);
        }
        }
      }
    }
    case_120: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_100: /* CIL Label */ 
    {
    {
#line 1171
    ch = in_nonblank();
    }
    }
#line 1172
    if (ch == 125) {
      {
      {
#line 1173
      savchar(ch);
      }
      }
    } else
#line 1172
    if (ch == 35) {
      {
      {
#line 1173
      savchar(ch);
      }
      }
    } else
#line 1174
    if (ch != -1) {
#line 1174
      if (ch != 10) {
#line 1174
        if (ch != 59) {
          {
          {
#line 1175
          tmp___28 = dcgettext((char const   *)((void *)0), ((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'"),
                               5);
          }
          {
#line 1175
          bad_prog((char const   *)tmp___28);
          }
          }
        }
      }
    }
#line 1176
    goto switch_break;
    case_114: /* CIL Label */ 
#line 1179
    if (POSIXLY_CORRECT) {
#line 1179
      if (cur_cmd->a2) {
        {
        {
#line 1180
        tmp___29 = dcgettext((char const   *)((void *)0), ((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command"),
                             5);
        }
        {
#line 1180
        bad_prog((char const   *)tmp___29);
        }
        }
      }
    }
    {
    {
#line 1181
    b___0 = read_filename();
    }
    {
#line 1182
    tmp___30 = get_buffer(b___0);
    }
    {
#line 1182
    cur_cmd->x.fname = ck_strdup((char const   *)tmp___30);
    }
    {
#line 1183
    free_buffer(b___0);
    }
    }
#line 1184
    goto switch_break;
    case_82: /* CIL Label */ 
    {
    {
#line 1187
    cur_cmd->x.fp = get_openfile(& file_read, (char *)"r", (flagT )0);
    }
    }
#line 1188
    goto switch_break;
    case_87: /* CIL Label */ 
    case_119: /* CIL Label */ 
    {
    {
#line 1192
    cur_cmd->x.fp = get_openfile(& file_write, (char *)"w", (flagT )1);
    }
    }
#line 1193
    goto switch_break;
    case_115: /* CIL Label */ 
    {
    {
#line 1201
    slash = inchar();
    }
    {
#line 1202
    b___0 = match_slash(slash, (flagT )1, (flagT )1);
    }
    }
#line 1202
    if (! b___0) {
      {
      {
#line 1203
      tmp___31 = dcgettext((char const   *)((void *)0), ((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex"),
                           5);
      }
      {
#line 1203
      bad_prog((char const   *)tmp___31);
      }
      }
    }
    {
    {
#line 1204
    b2 = match_slash(slash, (flagT )0, (flagT )1);
    }
    }
#line 1204
    if (! b2) {
      {
      {
#line 1205
      tmp___32 = dcgettext((char const   *)((void *)0), ((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex"),
                           5);
      }
      {
#line 1205
      bad_prog((char const   *)tmp___32);
      }
      }
    }
#line 1207
    __h = & obs;
#line 1207
    __o = __h;
#line 1207
    __len = (int )sizeof(struct subst );
#line 1207
    if (__o->chunk_limit - __o->next_free < (long )__len) {
      {
      {
#line 1207
      _obstack_newchunk(__o, __len);
      }
      }
    }
#line 1207
    __o->next_free += __len;
#line 1207
    __o1 = __h;
#line 1207
    value = (void *)__o1->object_base;
#line 1207
    if ((unsigned long )__o1->next_free == (unsigned long )value) {
#line 1207
      __o1->maybe_empty_object = 1U;
    }
#line 1207
    __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 1207
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 1207
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 1207
    __o1->object_base = __o1->next_free;
#line 1207
    cur_cmd->x.cmd_subst = (struct subst *)value;
    {
#line 1208
    tmp___33 = size_buffer(b2);
    }
    {
#line 1208
    tmp___34 = get_buffer(b2);
    }
    {
#line 1208
    setup_replacement(cur_cmd->x.cmd_subst, (char const   *)tmp___34, tmp___33);
    }
    {
#line 1210
    free_buffer(b2);
    }
    {
#line 1212
    tmp___35 = mark_subst_opts(cur_cmd->x.cmd_subst);
    }
#line 1212
    flags = (int )tmp___35;
    {
#line 1213
    (cur_cmd->x.cmd_subst)->regx = compile_regex(b___0, flags, (int )(cur_cmd->x.cmd_subst)->max_id);
    }
    {
#line 1215
    free_buffer(b___0);
    }
    }
#line 1217
    goto switch_break;
    case_121: /* CIL Label */ 
    {
    {
#line 1226
    tmp___36 = __ctype_get_mb_cur_max();
    }
    }
#line 1226
    if (tmp___36 == 1U) {
#line 1229
      __h___0 = & obs;
#line 1229
      __o___0 = __h___0;
#line 1229
      __len___0 = (int )(256UL * sizeof(unsigned char ));
#line 1229
      if (__o___0->chunk_limit - __o___0->next_free < (long )__len___0) {
        {
        {
#line 1229
        _obstack_newchunk(__o___0, __len___0);
        }
        }
      }
#line 1229
      __o___0->next_free += __len___0;
#line 1229
      __o1___0 = __h___0;
#line 1229
      value___0 = (void *)__o1___0->object_base;
#line 1229
      if ((unsigned long )__o1___0->next_free == (unsigned long )value___0) {
#line 1229
        __o1___0->maybe_empty_object = 1U;
      }
#line 1229
      __o1___0->next_free = (char *)0 + (((__o1___0->next_free - (char *)0) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 1229
      if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 1229
        __o1___0->next_free = __o1___0->chunk_limit;
      }
#line 1229
      __o1___0->object_base = __o1___0->next_free;
#line 1229
      ustring = (unsigned char *)value___0;
#line 1230
      len = (size_t )0;
      {
      {
#line 1230
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 1230
        if (! (len < 256U)) {
#line 1230
          goto while_break___2;
        }
#line 1231
        *(ustring + len) = (unsigned char )len;
#line 1230
        len ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1232
      cur_cmd->x.translate = ustring;
    }
    {
    {
#line 1235
    slash___0 = inchar();
    }
    {
#line 1236
    b___0 = match_slash(slash___0, (flagT )0, (flagT )0);
    }
    }
#line 1236
    if (! b___0) {
      {
      {
#line 1237
      tmp___37 = dcgettext((char const   *)((void *)0), (((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex")) + sizeof("Unterminated `s\' command"),
                           5);
      }
      {
#line 1237
      bad_prog((char const   *)tmp___37);
      }
      }
    }
    {
    {
#line 1240
    tmp___56 = __ctype_get_mb_cur_max();
    }
    }
#line 1240
    if (tmp___56 > 1U) {
      {
      {
#line 1242
      tmp___38 = size_buffer(b___0);
      }
#line 1242
      len___0 = (int )tmp___38;
      {
#line 1243
      tmp___39 = ck_malloc((size_t )((unsigned long )len___0 * sizeof(size_t )));
      }
#line 1243
      src_lens = (size_t *)tmp___39;
      }
#line 1250
      if (sizeof(mbstate_t ) <= 16UL) {
#line 1250
        if (sizeof(mbstate_t ) == 1UL) {
#line 1250
          __s___1 = (void *)(& cur_stat);
#line 1250
          *((__uint8_t *)__s___1) = (__uint8_t )0;
        } else {
#line 1250
          __s___0 = (void *)(& cur_stat);
#line 1250
          __u = (union __anonunion___u_33 *)__s___0;
#line 1250
          __c = (__uint8_t )0;
          {
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 15U) {
#line 1250
            goto case_15;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 11U) {
#line 1250
            goto case_11;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 7U) {
#line 1250
            goto case_7;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 3U) {
#line 1250
            goto case_3;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 14U) {
#line 1250
            goto case_14;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 10U) {
#line 1250
            goto case_10;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 6U) {
#line 1250
            goto case_6;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 2U) {
#line 1250
            goto case_2;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 13U) {
#line 1250
            goto case_13;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 9U) {
#line 1250
            goto case_9;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 5U) {
#line 1250
            goto case_5;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 1U) {
#line 1250
            goto case_1;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 16U) {
#line 1250
            goto case_16;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 12U) {
#line 1250
            goto case_12;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 8U) {
#line 1250
            goto case_8;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 4U) {
#line 1250
            goto case_4;
          }
#line 1250
          if ((unsigned int )sizeof(mbstate_t ) == 0U) {
#line 1250
            goto case_0;
          }
#line 1250
          goto switch_break___0;
          case_15: /* CIL Label */ 
#line 1250
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1250
          __u = (union __anonunion___u_33 *)((void *)__u + 4);
          case_11: /* CIL Label */ 
#line 1250
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1250
          __u = (union __anonunion___u_33 *)((void *)__u + 4);
          case_7: /* CIL Label */ 
#line 1250
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1250
          __u = (union __anonunion___u_33 *)((void *)__u + 4);
          case_3: /* CIL Label */ 
#line 1250
          __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1250
          __u = (union __anonunion___u_33 *)((void *)__u + 2);
#line 1250
          __u->__uc = __c;
#line 1250
          goto switch_break___0;
          case_14: /* CIL Label */ 
#line 1250
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1250
          __u = (union __anonunion___u_33 *)((void *)__u + 4);
          case_10: /* CIL Label */ 
#line 1250
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1250
          __u = (union __anonunion___u_33 *)((void *)__u + 4);
          case_6: /* CIL Label */ 
#line 1250
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1250
          __u = (union __anonunion___u_33 *)((void *)__u + 4);
          case_2: /* CIL Label */ 
#line 1250
          __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1250
          goto switch_break___0;
          case_13: /* CIL Label */ 
#line 1250
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1250
          __u = (union __anonunion___u_33 *)((void *)__u + 4);
          case_9: /* CIL Label */ 
#line 1250
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1250
          __u = (union __anonunion___u_33 *)((void *)__u + 4);
          case_5: /* CIL Label */ 
#line 1250
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1250
          __u = (union __anonunion___u_33 *)((void *)__u + 4);
          case_1: /* CIL Label */ 
#line 1250
          __u->__uc = __c;
#line 1250
          goto switch_break___0;
          case_16: /* CIL Label */ 
#line 1250
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1250
          __u = (union __anonunion___u_33 *)((void *)__u + 4);
          case_12: /* CIL Label */ 
#line 1250
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1250
          __u = (union __anonunion___u_33 *)((void *)__u + 4);
          case_8: /* CIL Label */ 
#line 1250
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1250
          __u = (union __anonunion___u_33 *)((void *)__u + 4);
          case_4: /* CIL Label */ 
#line 1250
          __u->__ui = (unsigned int )((int )__c * 16843009);
          case_0: /* CIL Label */ 
#line 1250
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 1250
        __s = (void *)(& cur_stat);
        {
#line 1250
        __builtin_memset(__s, '\000', (int )sizeof(mbstate_t ));
        }
        }
      }
      {
      {
#line 1251
      src_buf = get_buffer(b___0);
      }
#line 1252
      i = 0;
#line 1252
      j = 0;
      }
      {
      {
#line 1252
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 1252
        if (! (i < len___0)) {
#line 1252
          goto while_break___3;
        }
        {
        {
#line 1254
        mbclen = mbrlen((char const   */* __restrict  */)(src_buf + i), (size_t )(len___0 - i),
                        (mbstate_t */* __restrict  */)(& cur_stat));
        }
        }
#line 1257
        if (mbclen == 4294967295U) {
#line 1259
          mbclen = (size_t )1;
        } else
#line 1257
        if (mbclen == 4294967294U) {
#line 1259
          mbclen = (size_t )1;
        } else
#line 1257
        if (mbclen == 0U) {
#line 1259
          mbclen = (size_t )1;
        }
#line 1260
        tmp___40 = j;
#line 1260
        j ++;
#line 1260
        *(src_lens + tmp___40) = mbclen;
#line 1261
        i = (int )((size_t )i + mbclen);
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1263
      src_char_num = j;
#line 1265
      if (sizeof(mbstate_t ) <= 16UL) {
#line 1265
        if (sizeof(mbstate_t ) == 1UL) {
#line 1265
          __s___4 = (void *)(& cur_stat);
#line 1265
          *((__uint8_t *)__s___4) = (__uint8_t )0;
        } else {
#line 1265
          __s___3 = (void *)(& cur_stat);
#line 1265
          __u___0 = (union __anonunion___u_34 *)__s___3;
#line 1265
          __c___0 = (__uint8_t )0;
          {
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 15U) {
#line 1265
            goto case_15___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 11U) {
#line 1265
            goto case_11___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 7U) {
#line 1265
            goto case_7___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 3U) {
#line 1265
            goto case_3___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 14U) {
#line 1265
            goto case_14___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 10U) {
#line 1265
            goto case_10___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 6U) {
#line 1265
            goto case_6___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 2U) {
#line 1265
            goto case_2___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 13U) {
#line 1265
            goto case_13___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 9U) {
#line 1265
            goto case_9___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 5U) {
#line 1265
            goto case_5___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 1U) {
#line 1265
            goto case_1___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 16U) {
#line 1265
            goto case_16___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 12U) {
#line 1265
            goto case_12___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 8U) {
#line 1265
            goto case_8___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 4U) {
#line 1265
            goto case_4___0;
          }
#line 1265
          if ((unsigned int )sizeof(mbstate_t ) == 0U) {
#line 1265
            goto case_0___0;
          }
#line 1265
          goto switch_break___1;
          case_15___0: /* CIL Label */ 
#line 1265
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1265
          __u___0 = (union __anonunion___u_34 *)((void *)__u___0 + 4);
          case_11___0: /* CIL Label */ 
#line 1265
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1265
          __u___0 = (union __anonunion___u_34 *)((void *)__u___0 + 4);
          case_7___0: /* CIL Label */ 
#line 1265
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1265
          __u___0 = (union __anonunion___u_34 *)((void *)__u___0 + 4);
          case_3___0: /* CIL Label */ 
#line 1265
          __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 1265
          __u___0 = (union __anonunion___u_34 *)((void *)__u___0 + 2);
#line 1265
          __u___0->__uc = __c___0;
#line 1265
          goto switch_break___1;
          case_14___0: /* CIL Label */ 
#line 1265
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1265
          __u___0 = (union __anonunion___u_34 *)((void *)__u___0 + 4);
          case_10___0: /* CIL Label */ 
#line 1265
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1265
          __u___0 = (union __anonunion___u_34 *)((void *)__u___0 + 4);
          case_6___0: /* CIL Label */ 
#line 1265
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1265
          __u___0 = (union __anonunion___u_34 *)((void *)__u___0 + 4);
          case_2___0: /* CIL Label */ 
#line 1265
          __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 1265
          goto switch_break___1;
          case_13___0: /* CIL Label */ 
#line 1265
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1265
          __u___0 = (union __anonunion___u_34 *)((void *)__u___0 + 4);
          case_9___0: /* CIL Label */ 
#line 1265
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1265
          __u___0 = (union __anonunion___u_34 *)((void *)__u___0 + 4);
          case_5___0: /* CIL Label */ 
#line 1265
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1265
          __u___0 = (union __anonunion___u_34 *)((void *)__u___0 + 4);
          case_1___0: /* CIL Label */ 
#line 1265
          __u___0->__uc = __c___0;
#line 1265
          goto switch_break___1;
          case_16___0: /* CIL Label */ 
#line 1265
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1265
          __u___0 = (union __anonunion___u_34 *)((void *)__u___0 + 4);
          case_12___0: /* CIL Label */ 
#line 1265
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1265
          __u___0 = (union __anonunion___u_34 *)((void *)__u___0 + 4);
          case_8___0: /* CIL Label */ 
#line 1265
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 1265
          __u___0 = (union __anonunion___u_34 *)((void *)__u___0 + 4);
          case_4___0: /* CIL Label */ 
#line 1265
          __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
          case_0___0: /* CIL Label */ 
#line 1265
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 1265
        __s___2 = (void *)(& cur_stat);
        {
#line 1265
        __builtin_memset(__s___2, '\000', (int )sizeof(mbstate_t ));
        }
        }
      }
      {
      {
#line 1266
      b2___0 = match_slash(slash___0, (flagT )0, (flagT )0);
      }
      }
#line 1266
      if (! b2___0) {
        {
        {
#line 1267
        tmp___41 = dcgettext((char const   *)((void *)0), (((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex")) + sizeof("Unterminated `s\' command"),
                             5);
        }
        {
#line 1267
        bad_prog((char const   *)tmp___41);
        }
        }
      }
      {
      {
#line 1268
      dest_buf = get_buffer(b2___0);
      }
#line 1269
      idx = 0;
      {
#line 1270
      tmp___42 = size_buffer(b2___0);
      }
#line 1270
      len___0 = (int )tmp___42;
      {
#line 1276
      tmp___43 = ck_malloc((size_t )((unsigned long )(2 * src_char_num + 1) * sizeof(char *)));
      }
#line 1276
      trans_pairs = (char **)tmp___43;
#line 1277
      cur_cmd->x.translatemb = trans_pairs;
#line 1278
      i = 0;
      }
      {
      {
#line 1278
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 1278
        if (! (i < src_char_num)) {
#line 1278
          goto while_break___4;
        }
#line 1280
        if (idx >= len___0) {
          {
          {
#line 1281
          tmp___44 = dcgettext((char const   *)((void *)0), (((((((((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex")) + sizeof("Unterminated `s\' command")) + sizeof("Unterminated `y\' command")) + sizeof("Unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"),
                               5);
          }
          {
#line 1281
          bad_prog((char const   *)tmp___44);
          }
          }
        }
        {
        {
#line 1284
        tmp___45 = ck_malloc((size_t )((unsigned long )(*(src_lens + i) + 1U) * sizeof(char )));
        }
#line 1284
        *(trans_pairs + 2 * i) = (char *)tmp___45;
        {
#line 1285
        strncpy((char */* __restrict  */)*(trans_pairs + 2 * i), (char const   */* __restrict  */)src_buf,
                *(src_lens + i));
        }
#line 1286
        *(*(trans_pairs + 2 * i) + *(src_lens + i)) = (char )'\000';
#line 1287
        src_buf += *(src_lens + i);
        {
#line 1290
        mbclen = mbrlen((char const   */* __restrict  */)(dest_buf + idx), (size_t )(len___0 - idx),
                        (mbstate_t */* __restrict  */)(& cur_stat));
        }
        }
#line 1293
        if (mbclen == 4294967295U) {
#line 1295
          mbclen = (size_t )1;
        } else
#line 1293
        if (mbclen == 4294967294U) {
#line 1295
          mbclen = (size_t )1;
        } else
#line 1293
        if (mbclen == 0U) {
#line 1295
          mbclen = (size_t )1;
        }
        {
        {
#line 1298
        tmp___47 = ck_malloc((size_t )((unsigned long )(mbclen + 1U) * sizeof(char )));
        }
#line 1298
        *(trans_pairs + (2 * i + 1)) = (char *)tmp___47;
        {
#line 1299
        strncpy((char */* __restrict  */)*(trans_pairs + (2 * i + 1)), (char const   */* __restrict  */)(dest_buf + idx),
                mbclen);
        }
#line 1300
        *(*(trans_pairs + (2 * i + 1)) + mbclen) = (char )'\000';
#line 1301
        idx = (int )((size_t )idx + mbclen);
#line 1278
        i ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1303
      *(trans_pairs + 2 * i) = (char *)((void *)0);
#line 1304
      if (idx != len___0) {
        {
        {
#line 1305
        tmp___49 = dcgettext((char const   *)((void *)0), (((((((((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex")) + sizeof("Unterminated `s\' command")) + sizeof("Unterminated `y\' command")) + sizeof("Unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"),
                             5);
        }
        {
#line 1305
        bad_prog((char const   *)tmp___49);
        }
        }
      }
      {
      {
#line 1306
      free_buffer(b___0);
      }
      {
#line 1307
      free_buffer(b2___0);
      }
      }
    } else {
      {
      {
#line 1312
      tmp___50 = get_buffer(b___0);
      }
#line 1312
      ustring = (unsigned char *)tmp___50;
      {
#line 1313
      len = size_buffer(b___0);
      }
      }
      {
      {
#line 1313
      while (1) {
        while_continue___12: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
#line 1313
        if (! len) {
#line 1313
          goto while_break___5;
        }
        {
        {
#line 1315
        ch = inchar();
        }
        }
#line 1316
        if (ch == slash___0) {
          {
          {
#line 1317
          tmp___51 = dcgettext((char const   *)((void *)0), (((((((((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex")) + sizeof("Unterminated `s\' command")) + sizeof("Unterminated `y\' command")) + sizeof("Unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"),
                               5);
          }
          {
#line 1317
          bad_prog((char const   *)tmp___51);
          }
          }
        }
#line 1318
        if (ch == 10) {
          {
          {
#line 1319
          bad_prog((((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex")) + sizeof("Unterminated `s\' command"));
          }
          }
        }
#line 1320
        if (ch == 92) {
          {
          {
#line 1321
          ch = inchar();
          }
          }
        }
#line 1322
        if (ch == -1) {
          {
          {
#line 1323
          bad_prog((((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex")) + sizeof("Unterminated `s\' command"));
          }
          }
        }
#line 1324
        tmp___52 = ustring;
#line 1324
        ustring ++;
#line 1324
        *(cur_cmd->x.translate + *tmp___52) = (unsigned char )ch;
#line 1313
        len --;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
      {
#line 1326
      free_buffer(b___0);
      }
      {
#line 1328
      tmp___55 = inchar();
      }
      }
#line 1328
      if (tmp___55 != slash___0) {
        {
        {
#line 1329
        tmp___53 = dcgettext((char const   *)((void *)0), (((((((((((((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses")) + sizeof("Missing command")) + sizeof("Command only uses one address")) + sizeof("Unterminated address regex")) + sizeof("Unterminated `s\' command")) + sizeof("Unterminated `y\' command")) + sizeof("Unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"),
                             5);
        }
        {
#line 1329
        bad_prog((char const   *)tmp___53);
        }
        }
      } else {
        {
        {
#line 1330
        ch = in_nonblank();
        }
        }
#line 1330
        if (ch != -1) {
#line 1330
          if (ch != 10) {
#line 1330
            if (ch != 59) {
              {
              {
#line 1331
              tmp___54 = dcgettext((char const   *)((void *)0), ((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'"),
                                   5);
              }
              {
#line 1331
              bad_prog((char const   *)tmp___54);
              }
              }
            }
          }
        }
      }
    }
#line 1334
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
    {
#line 1337
    tmp___57 = dcgettext((char const   *)((void *)0), (((((((((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address")) + sizeof("Unmatched `{\'")) + sizeof("Unexpected `}\'")) + sizeof("Extra characters after command")) + sizeof("Expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("Comments don\'t accept any addresses"),
                         5);
    }
    {
#line 1337
    bad_prog((char const   *)tmp___57);
    }
    }
    switch_default: /* CIL Label */ 
    {
    {
#line 1341
    tmp___58 = dcgettext((char const   *)((void *)0), "Unknown command:", 5);
    }
#line 1341
    msg = (char const   *)tmp___58;
    {
#line 1342
    tmp___59 = strlen(msg);
    }
    {
#line 1342
    tmp___60 = xmalloc(tmp___59 + 5U);
    }
#line 1342
    unknown_cmd = (char *)tmp___60;
    {
#line 1343
    sprintf((char */* __restrict  */)unknown_cmd, (char const   */* __restrict  */)"%s `%c\'",
            msg, ch);
    }
    {
#line 1344
    bad_prog((char const   *)unknown_cmd);
    }
    }
    switch_break: /* CIL Label */ ;
    }
#line 1350
    (vector->v_length) ++;
    __Cont: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1352
  return (vector);
}
}
#line 1357 "compile.c"
void bad_prog(char const   *why ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1361
  if (cur_input.name) {
    {
    {
#line 1362
    tmp = dcgettext((char const   *)((void *)0), "%s: file %s line %lu: %s\n", 5);
    }
    {
#line 1362
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            myname, cur_input.name, cur_input.line, why);
    }
    }
  } else {
    {
    {
#line 1365
    tmp___0 = dcgettext((char const   *)((void *)0), "%s: -e expression #%lu, char %lu: %s\n",
                        5);
    }
    {
#line 1365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            myname, cur_input.string_expr_count, (unsigned long )(prog.cur - prog.base),
            why);
    }
    }
  }
  {
  {
#line 1370
  exit(1);
  }
  }
}
}
#line 1375 "compile.c"
size_t normalize_text(char *buf , size_t len ) 
{ 
  char const   *bufend ;
  char *p ;
  char *q ;
  int c ;
  char *tmp ;
  char *tmp___0 ;
  int __res ;
  __int32_t const   **tmp___2 ;

  {
#line 1380
  bufend = (char const   *)(buf + len);
#line 1381
  p = buf;
#line 1382
  q = buf;
#line 1386
  if (POSIXLY_CORRECT) {
#line 1386
    if (! extended_regexp_flags) {
#line 1387
      return (len);
    }
  }
  {
  {
#line 1389
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1389
    if (! ((unsigned long )p < (unsigned long )bufend)) {
#line 1389
      goto while_break;
    }
#line 1393
    tmp = p;
#line 1393
    p ++;
#line 1393
    *q = *tmp;
#line 1394
    if ((int )*q == 92) {
#line 1394
      if ((unsigned long )p < (unsigned long )bufend) {
#line 1395
        tmp___0 = p;
#line 1395
        p ++;
#line 1395
        c = (int )*tmp___0;
        {
#line 1398
        if (c == 97) {
#line 1398
          goto case_97;
        }
#line 1403
        if (c == 102) {
#line 1403
          goto case_102;
        }
#line 1405
        if (c == 110) {
#line 1405
          goto case_110;
        }
#line 1405
        if (c == 10) {
#line 1405
          goto case_110;
        }
#line 1406
        if (c == 114) {
#line 1406
          goto case_114;
        }
#line 1407
        if (c == 116) {
#line 1407
          goto case_116;
        }
#line 1408
        if (c == 118) {
#line 1408
          goto case_118;
        }
#line 1410
        if (c == 100) {
#line 1410
          goto case_100;
        }
#line 1414
        if (c == 120) {
#line 1414
          goto case_120;
        }
#line 1443
        if (c == 111) {
#line 1443
          goto case_111;
        }
#line 1448
        if (c == 99) {
#line 1448
          goto case_99;
        }
#line 1457
        goto switch_default;
        case_97: /* CIL Label */ 
#line 1398
        *q = (char )'\a';
#line 1398
        goto switch_break;
        case_102: /* CIL Label */ 
#line 1403
        *q = (char )'\f';
#line 1403
        goto switch_break;
        case_110: /* CIL Label */ 
        case_10: /* CIL Label */ 
#line 1405
        *q = (char )'\n';
#line 1405
        goto switch_break;
        case_114: /* CIL Label */ 
#line 1406
        *q = (char )'\r';
#line 1406
        goto switch_break;
        case_116: /* CIL Label */ 
#line 1407
        *q = (char )'\t';
#line 1407
        goto switch_break;
        case_118: /* CIL Label */ 
#line 1408
        *q = (char )'\v';
#line 1408
        goto switch_break;
        case_100: /* CIL Label */ 
        {
        {
#line 1411
        p = convert_number(q, p, bufend, 10, 3, 'd');
        }
        }
#line 1412
        goto switch_break;
        case_120: /* CIL Label */ 
        {
        {
#line 1415
        p = convert_number(q, p, bufend, 16, 2, 'x');
        }
        }
#line 1416
        goto switch_break;
        case_111: /* CIL Label */ 
        {
        {
#line 1444
        p = convert_number(q, p, bufend, 8, 3, 'o');
        }
        }
#line 1445
        goto switch_break;
        case_99: /* CIL Label */ 
#line 1449
        if ((unsigned long )p < (unsigned long )bufend) {
#line 1451
          if (sizeof(*p) > 1UL) {
            {
            {
#line 1451
            __res = toupper((int )*p);
            }
            }
          } else {
            {
            {
#line 1451
            tmp___2 = __ctype_toupper_loc();
            }
#line 1451
            __res = (int )*(*tmp___2 + (int )*p);
            }
          }
#line 1451
          *q = (char )(__res ^ 64);
#line 1452
          p ++;
#line 1453
          goto switch_break;
        }
        switch_default: /* CIL Label */ 
#line 1459
        q ++;
#line 1459
        *q = *(p + -1);
#line 1460
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 1462
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1464
  return ((size_t )(q - buf));
}
}
#line 1476 "compile.c"
static countT string_expr_count  =    (countT )0;
#line 1470 "compile.c"
struct vector *compile_string(struct vector *cur_program , char *str , size_t len ) 
{ 
  struct vector *ret ;

  {
  {
#line 1479
  prog.file = (FILE *)((void *)0);
#line 1480
  prog.base = (unsigned char const   *)((unsigned char *)str);
#line 1481
  prog.cur = prog.base;
#line 1482
  prog.end = prog.cur + len;
#line 1484
  cur_input.line = (countT )0;
#line 1485
  cur_input.name = (char const   *)((void *)0);
#line 1486
  string_expr_count ++;
#line 1486
  cur_input.string_expr_count = string_expr_count;
  {
#line 1488
  ret = compile_program(cur_program);
  }
#line 1489
  prog.base = (unsigned char const   *)((void *)0);
#line 1490
  prog.cur = (unsigned char const   *)((void *)0);
#line 1491
  prog.end = (unsigned char const   *)((void *)0);
#line 1493
  first_script = (flagT )0;
  }
#line 1494
  return (ret);
}
}
#line 1500 "compile.c"
struct vector *compile_file(struct vector *cur_program , char const   *cmdfile ) 
{ 
  struct vector *ret ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1508
  prog.file = stdin;
#line 1509
  if ((int const   )*(cmdfile + 0) != 45) {
    {
    {
#line 1510
    prog.file = ck_fopen(cmdfile, "rt", (flagT )1);
    }
    }
  } else
#line 1509
  if ((int const   )*(cmdfile + 1) != 0) {
    {
    {
#line 1510
    prog.file = ck_fopen(cmdfile, "rt", (flagT )1);
    }
    }
  }
  {
#line 1512
  cur_input.line = (countT )1;
#line 1513
  cur_input.name = cmdfile;
#line 1514
  cur_input.string_expr_count = (countT )0;
  {
#line 1516
  ret = compile_program(cur_program);
  }
  }
#line 1517
  if ((unsigned long )prog.file != (unsigned long )stdin) {
    {
    {
#line 1518
    ck_fclose(prog.file);
    }
    }
  }
#line 1519
  prog.file = (FILE *)((void *)0);
#line 1521
  first_script = (flagT )0;
#line 1522
  return (ret);
}
}
#line 1528 "compile.c"
void check_final_program(struct vector *program ) 
{ 
  struct sed_label *go ;
  struct sed_label *lbl ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  struct fp_list *p ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 1536
  if (blocks) {
    {
    {
#line 1539
    memcpy((void */* __restrict  */)(& cur_input), (void const   */* __restrict  */)(& blocks->err_info),
           (size_t )sizeof(cur_input));
    }
    {
#line 1540
    tmp = dcgettext((char const   *)((void *)0), ((errors___0 + sizeof("Multiple `!\'s")) + sizeof("Unexpected `,\'")) + sizeof("Cannot use +N or ~N as first address"),
                    5);
    }
    {
#line 1540
    bad_prog((char const   *)tmp);
    }
    }
  }
#line 1544
  if (pending_text) {
    {
    {
#line 1546
    old_text_buf->text_length = size_buffer(pending_text);
    }
    {
#line 1547
    tmp___0 = get_buffer(pending_text);
    }
    {
#line 1547
    tmp___1 = ck_memdup((void const   *)tmp___0, (size_t )((unsigned long )old_text_buf->text_length * sizeof(char )));
    }
#line 1547
    old_text_buf->text = (char *)tmp___1;
    {
#line 1549
    free_buffer(pending_text);
    }
#line 1550
    pending_text = (struct buffer *)((void *)0);
    }
  }
#line 1553
  go = jumps;
  {
  {
#line 1553
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1553
    if (! go) {
#line 1553
      goto while_break;
    }
#line 1555
    lbl = labels;
    {
    {
#line 1555
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1555
      if (! lbl) {
#line 1555
        goto while_break___0;
      }
#line 1556
      if (0) {
        {
        {
#line 1556
        __s1_len = strlen((char const   *)lbl->name);
        }
        {
#line 1556
        __s2_len = strlen((char const   *)go->name);
        }
        }
#line 1556
        if (! ((size_t )((void const   *)(lbl->name + 1)) - (size_t )((void const   *)lbl->name) == 1U)) {
#line 1556
          goto _L___0;
        } else
#line 1556
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1556
          if (! ((size_t )((void const   *)(go->name + 1)) - (size_t )((void const   *)go->name) == 1U)) {
#line 1556
            tmp___7 = 1;
          } else
#line 1556
          if (__s2_len >= 4U) {
#line 1556
            tmp___7 = 1;
          } else {
#line 1556
            tmp___7 = 0;
          }
        } else {
#line 1556
          tmp___7 = 0;
        }
#line 1556
        if (tmp___7) {
#line 1556
          if (__s1_len < __s2_len) {
#line 1556
            tmp___3 = __s1_len;
          } else {
#line 1556
            tmp___3 = __s2_len;
          }
          {
          {
#line 1556
          tmp___4 = memcmp((void const   *)((char const   *)lbl->name), (void const   *)((char const   *)go->name),
                           tmp___3 + 1U);
          }
#line 1556
          tmp___6 = tmp___4;
          }
        } else {
          {
          {
#line 1556
          tmp___5 = strcmp((char const   *)lbl->name, (char const   *)go->name);
          }
#line 1556
          tmp___6 = tmp___5;
          }
        }
      } else {
        {
        {
#line 1556
        tmp___5 = strcmp((char const   *)lbl->name, (char const   *)go->name);
        }
#line 1556
        tmp___6 = tmp___5;
        }
      }
#line 1556
      if (tmp___6 == 0) {
#line 1557
        goto while_break___0;
      }
#line 1555
      lbl = lbl->next;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1558
    if (lbl) {
#line 1560
      (program->v + go->v_index)->x.jump_index = lbl->v_index;
    } else {
#line 1564
      if (*(go->name)) {
        {
        {
#line 1565
        tmp___8 = dcgettext((char const   *)((void *)0), "Can\'t find label for jump to `%s\'",
                            5);
        }
        {
#line 1565
        panic((char const   *)tmp___8, go->name);
        }
        }
      }
#line 1566
      (program->v + go->v_index)->x.jump_index = (countT )program->v_length;
    }
    {
    {
#line 1553
    go = release_label(go);
    }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1569
  jumps = (struct sed_label *)((void *)0);
#line 1571
  lbl = labels;
  {
  {
#line 1571
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 1571
    if (! lbl) {
#line 1571
      goto while_break___1;
    }
    {
    {
#line 1571
    lbl = release_label(lbl);
    }
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1573
  labels = (struct sed_label *)((void *)0);
#line 1579
  p = file_read;
  {
  {
#line 1579
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 1579
    if (! p) {
#line 1579
      goto while_break___2;
    }
#line 1580
    if (p->name) {
      {
      {
#line 1582
      ck_free((void *)p->name);
      }
#line 1583
      p->name = (char *)((void *)0);
      }
    }
#line 1579
    p = p->link;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1586
  p = file_write;
  {
  {
#line 1586
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 1586
    if (! p) {
#line 1586
      goto while_break___3;
    }
#line 1587
    if (p->name) {
      {
      {
#line 1589
      ck_free((void *)p->name);
      }
#line 1590
      p->name = (char *)((void *)0);
      }
    }
#line 1586
    p = p->link;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1593
  return;
}
}
#line 1596 "compile.c"
void rewind_read_files(void) 
{ 
  struct fp_list *p ;

  {
#line 1601
  p = file_read;
  {
  {
#line 1601
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1601
    if (! p) {
#line 1601
      goto while_break;
    }
#line 1602
    if (p->fp) {
#line 1602
      if (! p->special) {
        {
        {
#line 1603
        rewind(p->fp);
        }
        }
      }
    }
#line 1601
    p = p->link;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1604
  return;
}
}
#line 1607 "compile.c"
void finish_program(struct vector *program ) 
{ 
  struct fp_list *p ;
  struct fp_list *q ;

  {
#line 1615
  p = file_read;
  {
  {
#line 1615
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1615
    if (! p) {
#line 1615
      goto while_break;
    }
#line 1617
    if (p->fp) {
#line 1617
      if (! p->special) {
        {
        {
#line 1618
        ck_fclose(p->fp);
        }
        }
      }
    }
#line 1619
    q = p->link;
#line 1615
    p = q;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1626
  p = file_write;
  {
  {
#line 1626
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1626
    if (! p) {
#line 1626
      goto while_break___0;
    }
#line 1628
    if (p->fp) {
#line 1628
      if (! p->special) {
        {
        {
#line 1629
        ck_fclose(p->fp);
        }
        }
      }
    }
#line 1630
    q = p->link;
#line 1626
    p = q;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1636
  file_write = (struct fp_list *)((void *)0);
#line 1636
  file_read = file_write;
#line 1642
  return;
}
}
#line 125 "/usr/include/locale.h"
extern char *setlocale(int __category , char const   *__locale ) ;
#line 35 "../lib/getopt.h"
extern char *optarg ;
#line 49
extern int optind ;
#line 110
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 81 "/usr/include/libintl.h"
extern char *textdomain(char const   *__domainname ) ;
#line 85
extern char *bindtextdomain(char const   *__domainname , char const   *__dirname ) ;
#line 163 "sed.h"
int main(int argc , char **argv ) ;
#line 179 "sed.h"
flagT POSIXLY_CORRECT  ;
#line 66 "sed.c"
int extended_regexp_flags  =    0;
#line 69 "sed.c"
flagT unbuffered_output  =    (flagT )0;
#line 72 "sed.c"
flagT no_default_output  =    (flagT )0;
#line 75 "sed.c"
flagT separate_files  =    (flagT )0;
#line 78 "sed.c"
char *in_place_extension  =    (char *)((void *)0);
#line 84 "sed.c"
countT lcmd_out_line_len  =    (countT )70;
#line 87 "sed.c"
static struct vector *the_program  =    (struct vector *)((void *)0);
#line 89
static void usage(int status ) ;
#line 90 "sed.c"
static void usage(int status ) 
{ 
  FILE *out ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 94
  if (status) {
#line 94
    tmp = stderr;
  } else {
#line 94
    tmp = stdout;
  }
  {
#line 94
  out = tmp;
  {
#line 102
  tmp___0 = dcgettext((char const   *)((void *)0), "Usage: %s [OPTION]... {script-only-if-no-other-script} [input-file]...\n\n  -n, --quiet, --silent\n                 suppress automatic printing of pattern space\n  -e script, --expression=script\n                 add the script to the commands to be executed\n  -f script-file, --file=script-file\n                 add the contents of script-file to the commands to be executed\n  -i[suffix], --in-place[=suffix]\n                 edit files in place (makes backup if extension supplied)\n  -l N, --line-length=N\n                 specify the desired line-wrap length for the `l\' command\n  -r, --regexp-extended\n                 use extended regular expressions in the script.\n%s  -s, --separate\n                 consider files as separate rather than as a single continuous\n                 long stream.\n  -u, --unbuffered\n                 load minimal amounts of data from the input files and flush\n                 the output buffers more often\n      --help     display this help and exit\n  -V, --version  output version information and exit\n\nIf no -e, --expression, -f, or --file option is given, then the first\nnon-option argument is taken as the sed script to interpret.  All\nremaining arguments are names of input files; if no input files are\nspecified, then the standard input is read.\n\n",
                      5);
  }
  {
#line 102
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___0,
          myname, "");
  }
  {
#line 131
  tmp___1 = dcgettext((char const   *)((void *)0), "E-mail bug reports to: %s .\nBe sure to include the word ``%s\'\' somewhere in the ``Subject:\'\' field.\n",
                      5);
  }
  {
#line 131
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___1,
          "bonzini@gnu.org", "sed");
  }
  {
#line 135
  ck_fclose((FILE *)((void *)0));
  }
  {
#line 136
  exit(status);
  }
  }
}
}
#line 150 "sed.c"
static struct option longopts[12]  = 
#line 150
  {      {"regexp-extended", 0, (int *)((void *)0), 'r'}, 
        {"expression", 1, (int *)((void *)0), 'e'}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"in-place", 2, (int *)((void *)0), 'i'}, 
        {"line-length", 1, (int *)((void *)0), 'l'}, 
        {"quiet", 0, (int *)((void *)0), 'n'}, 
        {"silent", 0, (int *)((void *)0), 'n'}, 
        {"separate", 0, (int *)((void *)0), 's'}, 
        {"unbuffered", 0, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 139 "sed.c"
int main(int argc , char **argv ) 
{ 
  int opt ;
  int return_code ;
  char *tmp ;
  char const   *p ;
  char *tmp___0 ;
  countT t ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *arg ;
  int tmp___9 ;
  size_t tmp___10 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
  {
#line 176
  setlocale(6, "");
  }
  {
#line 180
  bindtextdomain("sed", "/usr/local/share/locale");
  }
  {
#line 181
  textdomain("sed");
  }
  {
#line 184
  tmp = getenv("POSIXLY_CORRECT");
  }
#line 184
  POSIXLY_CORRECT = (flagT )((unsigned long )tmp != (unsigned long )((void *)0));
  {
#line 191
  tmp___0 = getenv("COLS");
  }
#line 191
  p = (char const   *)tmp___0;
  }
#line 192
  if (p) {
    {
    {
#line 194
    tmp___1 = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)((void *)0),
                      0);
    }
#line 194
    t = tmp___1;
    }
#line 195
    if (1UL < t) {
#line 196
      lcmd_out_line_len = t - 1UL;
    }
  }
#line 200
  myname = (char const   *)*argv;
  {
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 201
    opt = getopt_long(argc, (char * const  *)argv, "shnruVe:f:l:i::", (struct option  const  *)(longopts),
                      (int *)((void *)0));
    }
    }
#line 201
    if (! (opt != -1)) {
#line 201
      goto while_break;
    }
    {
#line 205
    if (opt == 110) {
#line 205
      goto case_110;
    }
#line 208
    if (opt == 101) {
#line 208
      goto case_101;
    }
#line 211
    if (opt == 102) {
#line 211
      goto case_102;
    }
#line 215
    if (opt == 105) {
#line 215
      goto case_105;
    }
#line 229
    if (opt == 108) {
#line 229
      goto case_108;
    }
#line 232
    if (opt == 114) {
#line 232
      goto case_114;
    }
#line 246
    if (opt == 115) {
#line 246
      goto case_115;
    }
#line 250
    if (opt == 117) {
#line 250
      goto case_117;
    }
#line 254
    if (opt == 86) {
#line 254
      goto case_86;
    }
#line 268
    if (opt == 104) {
#line 268
      goto case_104;
    }
#line 270
    goto switch_default;
    case_110: /* CIL Label */ 
#line 206
    no_default_output = (flagT )1;
#line 207
    goto switch_break;
    case_101: /* CIL Label */ 
    {
    {
#line 209
    tmp___2 = strlen((char const   *)optarg);
    }
    {
#line 209
    the_program = compile_string(the_program, optarg, tmp___2);
    }
    }
#line 210
    goto switch_break;
    case_102: /* CIL Label */ 
    {
    {
#line 212
    the_program = compile_file(the_program, (char const   *)optarg);
    }
    }
#line 213
    goto switch_break;
    case_105: /* CIL Label */ 
#line 216
    separate_files = (flagT )1;
#line 217
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
#line 218
      in_place_extension = (char *)"*";
    } else {
      {
      {
#line 219
      tmp___6 = strchr((char const   *)optarg, '*');
      }
      }
#line 219
      if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
        {
        {
#line 221
        tmp___3 = strlen((char const   *)optarg);
        }
        {
#line 221
        tmp___4 = xmalloc(tmp___3 + 2U);
        }
#line 221
        in_place_extension = (char *)tmp___4;
#line 222
        *(in_place_extension + 0) = (char )'*';
        {
#line 223
        strcpy((char */* __restrict  */)(in_place_extension + 1), (char const   */* __restrict  */)optarg);
        }
        }
      } else {
        {
        {
#line 226
        in_place_extension = ck_strdup((char const   *)optarg);
        }
        }
      }
    }
#line 227
    goto switch_break;
    case_108: /* CIL Label */ 
    {
    {
#line 230
    lcmd_out_line_len = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                                0);
    }
    }
#line 231
    goto switch_break;
    case_114: /* CIL Label */ 
#line 233
    if (extended_regexp_flags) {
      {
      {
#line 234
      usage(4);
      }
      }
    }
#line 235
    extended_regexp_flags = 1;
#line 236
    goto switch_break;
    case_115: /* CIL Label */ 
#line 247
    separate_files = (flagT )1;
#line 248
    goto switch_break;
    case_117: /* CIL Label */ 
#line 251
    unbuffered_output = (flagT )1;
#line 252
    goto switch_break;
    case_86: /* CIL Label */ 
    {
    {
#line 259
    tmp___7 = dcgettext((char const   *)((void *)0), "GNU sed version %s\n", 5);
    }
    {
#line 259
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)tmp___7,
            "4.0.8");
    }
    {
#line 261
    tmp___8 = dcgettext((char const   *)((void *)0), "%s\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE,\nto the extent permitted by law.\n",
                        5);
    }
    {
#line 261
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)tmp___8,
            "Copyright (C) 2003 Free Software Foundation, Inc.");
    }
    {
#line 266
    ck_fclose((FILE *)((void *)0));
    }
    {
#line 267
    exit(0);
    }
    }
    case_104: /* CIL Label */ 
    {
    {
#line 269
    usage(0);
    }
    }
    switch_default: /* CIL Label */ 
    {
    {
#line 271
    usage(4);
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  if (! the_program) {
#line 277
    if (optind < argc) {
      {
#line 279
      tmp___9 = optind;
#line 279
      optind ++;
#line 279
      arg = *(argv + tmp___9);
      {
#line 280
      tmp___10 = strlen((char const   *)arg);
      }
      {
#line 280
      the_program = compile_string(the_program, arg, tmp___10);
      }
      }
    } else {
      {
      {
#line 283
      usage(4);
      }
      }
    }
  }
  {
  {
#line 285
  check_final_program(the_program);
  }
  {
#line 287
  return_code = process_files(the_program, argv + optind);
  }
  {
#line 289
  finish_program(the_program);
  }
  {
#line 290
  ck_fclose((FILE *)((void *)0));
  }
  }
#line 292
  return (return_code);
}
}
