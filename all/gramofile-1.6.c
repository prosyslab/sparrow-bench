/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 19 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
struct __anonstruct_sample_t_2 {
   short left ;
   short right ;
};
#line 19 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
typedef struct __anonstruct_sample_t_2 sample_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 63 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/fmtheaders.h"
struct wavhead {
   u_long main_chunk ;
   u_long length ;
   u_long chunk_type ;
   u_long sub_chunk ;
   u_long sc_len ;
   u_short format ;
   u_short modus ;
   u_long sample_fq ;
   u_long byte_p_sec ;
   u_short byte_p_spl ;
   u_short bit_p_spl ;
   u_long data_chunk ;
   u_long data_length ;
};
#line 63 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/fmtheaders.h"
typedef struct wavhead wavhead;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 358 "/usr/include/curses.h"
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 14 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/scrollmenu.h"
struct __anonstruct_scrollmenu_t_1 {
   char **items ;
   int number ;
   int y ;
   int x ;
   int h ;
   int w ;
   int selected ;
   int firstonscreen ;
   int last_of_1st_part ;
   int hasfocus ;
};
#line 14 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/scrollmenu.h"
typedef struct __anonstruct_scrollmenu_t_1 scrollmenu_t;
#line 17 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/stringinput.h"
struct __anonstruct_stringinput_t_2 {
   char *string ;
   int y ;
   int x ;
   int w ;
   int maxlen ;
   int cursorpos ;
   int firstcharonscreen ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/stringinput.h"
typedef struct __anonstruct_stringinput_t_2 stringinput_t;
#line 14 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/buttons.h"
struct __anonstruct_button_t_3 {
   char *text ;
   int y ;
   int x ;
   int selected ;
};
#line 14 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/buttons.h"
typedef struct __anonstruct_button_t_3 button_t;
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.h"
struct __anonstruct_beginendsample_t_17 {
   long begin ;
   long end ;
};
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.h"
typedef struct __anonstruct_beginendsample_t_17 beginendsample_t;
#line 26 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
struct __anonstruct_longsample_t_3 {
   long left ;
   long right ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
typedef struct __anonstruct_longsample_t_3 longsample_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
struct __anonstruct_doublesample_t_4 {
   double left ;
   double right ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
typedef struct __anonstruct_doublesample_t_4 doublesample_t;
#line 43 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
struct __anonstruct_buffer_t_5 {
   sample_t *array ;
   long currpos ;
   long arraylength ;
   long pre_length ;
   long post_length ;
   int *indextable ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
typedef struct __anonstruct_buffer_t_5 buffer_t;
#line 60 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
struct __anonstruct_param_t_6 {
   buffer_t buffer ;
   buffer_t buffer2 ;
   buffer_t buffer3 ;
   buffer_t buffer4 ;
   int filterno ;
   long postlength1 ;
   long prelength1 ;
   long postlength2 ;
   long prelength2 ;
   long postlength3 ;
   long prelength3 ;
   long postlength4 ;
   long prelength4 ;
   short *sslist1 ;
   short *sslist2 ;
   int int1 ;
   long long1 ;
   long long2 ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
typedef struct __anonstruct_param_t_6 param_t;
#line 79 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
typedef param_t *parampointer_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 151 "/usr/include/curses.h"
typedef unsigned long mmask_t;
#line 1597 "/usr/include/curses.h"
struct __anonstruct_MEVENT_30 {
   short id ;
   int x ;
   int y ;
   int z ;
   mmask_t bstate ;
};
#line 1597 "/usr/include/curses.h"
typedef struct __anonstruct_MEVENT_30 MEVENT;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_10 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_11 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_10 __wait_terminated ;
   struct __anonstruct___wait_stopped_11 __wait_stopped ;
};
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 104 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
#line 14 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/fmtheaders.h"
struct vochead {
   u_char Magic[20] ;
   u_short BlockOffset ;
   u_short Version ;
   u_short IDCode ;
};
#line 14 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/fmtheaders.h"
typedef struct vochead vochead;
#line 21 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/fmtheaders.h"
struct blockTC {
   u_char BlockID ;
   u_char BlockLen[3] ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/fmtheaders.h"
typedef struct blockTC blockTC;
#line 26 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/fmtheaders.h"
struct blockT1 {
   u_char TimeConstant ;
   u_char PackMethod ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/fmtheaders.h"
typedef struct blockT1 blockT1;
#line 31 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/fmtheaders.h"
struct blockT8 {
   u_short TimeConstant ;
   u_char PackMethod ;
   u_char VoiceMode ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/fmtheaders.h"
typedef struct blockT8 blockT8;
#line 37 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/fmtheaders.h"
struct blockT9 {
   u_int SamplesPerSec ;
   u_char BitsPerSample ;
   u_char Channels ;
   u_short Format ;
   u_char reserved[4] ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/fmtheaders.h"
typedef struct blockT9 blockT9;
#line 44 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/bplay.c"
enum sndf_t {
    F_UNKNOWN = 0,
    F_WAV = 1,
    F_VOC = 2,
    F_RAW = 3
} ;
#line 44 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/bplay.c"
typedef enum sndf_t sndf_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 177 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 122 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/ipc.h"
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   unsigned short mode ;
   unsigned short __pad1 ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   __syscall_ulong_t __glibc_reserved1 ;
   __syscall_ulong_t __glibc_reserved2 ;
};
#line 38 "/usr/include/x86_64-linux-gnu/bits/sem.h"
struct semid_ds {
   struct ipc_perm sem_perm ;
   __time_t sem_otime ;
   __syscall_ulong_t __glibc_reserved1 ;
   __time_t sem_ctime ;
   __syscall_ulong_t __glibc_reserved2 ;
   __syscall_ulong_t sem_nsems ;
   __syscall_ulong_t __glibc_reserved3 ;
   __syscall_ulong_t __glibc_reserved4 ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/sem.h"
struct seminfo {
   int semmap ;
   int semmni ;
   int semmns ;
   int semmnu ;
   int semmsl ;
   int semopm ;
   int semume ;
   int semusz ;
   int semvmx ;
   int semaem ;
};
#line 41 "/usr/include/x86_64-linux-gnu/sys/sem.h"
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/shm.h"
typedef __syscall_ulong_t shmatt_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/shm.h"
struct shmid_ds {
   struct ipc_perm shm_perm ;
   size_t shm_segsz ;
   __time_t shm_atime ;
   __time_t shm_dtime ;
   __time_t shm_ctime ;
   __pid_t shm_cpid ;
   __pid_t shm_lpid ;
   shmatt_t shm_nattch ;
   __syscall_ulong_t __glibc_reserved4 ;
   __syscall_ulong_t __glibc_reserved5 ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
union semun {
   int val ;
   struct semid_ds *buf ;
   unsigned short *array ;
   struct seminfo *__buf ;
};
#line 67 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
struct blockinf_t {
   int count ;
   int last ;
   int setit ;
   int speed ;
   int bits ;
   int stereo ;
};
#line 67 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
typedef struct blockinf_t blockinf_t;
#line 16 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/tracksplit.h"
void tracksplit_main(char *startdir ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/tracksplit_filenm.h"
int tracksplit_select_file(char *startdir , char *selectedfile ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/tracksplit_parammenu.h"
int tracksplit_parammenu(int *make_use_rms , int *make_graphs , long *blocklen , int *global_silence_factor ,
                         int *local_silence_threshold , int *min_silence_blocks ,
                         int *min_track_blocks , int *extra_blocks_start , int *extra_blocks_end ) ;
#line 141 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
void qsort2double(double *a , long n ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_wav.h"
int openwavsource(char *filename ) ;
#line 23
void closewavsource(void) ;
#line 28
sample_t readsamplesource(void) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/secshms.h"
void fsec2hmsf(double seconds , char *outstring ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/errorwindow.h"
void error_window_display(char *text , char *buttontext ) ;
#line 21
void error_window(char *text ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/clrscr.h"
void clearscreen(char *headertext ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 156 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 181
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 674 "/usr/include/curses.h"
extern int mvprintw(int  , int  , char const   *  , ...) ;
#line 710
extern int nodelay(WINDOW * , _Bool  ) ;
#line 731
extern int reset_prog_mode(void) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 31 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/tracksplit.c"
int tracksplit_get_options(char *startdir , char *filename , int *make_use_rms , int *make_graphs ,
                           long *blocklen , int *global_silence_factor , int *local_silence_threshold ,
                           int *min_silence_blocks , int *min_track_blocks , int *extra_blocks_start ,
                           int *extra_blocks_end ) 
{ 
  int currscreen ;
  int options_ready ;
  int returnval ;
  int tmp ;
  int tmp___0 ;

  {
#line 41
  currscreen = 0;
#line 42
  options_ready = 0;
#line 43
  returnval = 0;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 48
    if (currscreen == 0) {
#line 48
      goto case_0;
    }
#line 65
    if (currscreen == 1) {
#line 65
      goto case_1;
    }
#line 46
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 49
    tmp = tracksplit_select_file(startdir, filename);
    }
    {
#line 54
    if (tmp == 0) {
#line 54
      goto case_0___0;
    }
#line 58
    if (tmp == 2) {
#line 58
      goto case_2;
    }
#line 49
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 55
    options_ready = 1;
#line 56
    returnval = 0;
#line 57
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 59
    currscreen = 1;
#line 60
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 63
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 66
    tmp___0 = tracksplit_parammenu(make_use_rms, make_graphs, blocklen, global_silence_factor,
                                   local_silence_threshold, min_silence_blocks, min_track_blocks,
                                   extra_blocks_start, extra_blocks_end);
    }
    {
#line 76
    if (tmp___0 == 0) {
#line 76
      goto case_0___1;
    }
#line 80
    if (tmp___0 == 1) {
#line 80
      goto case_1___0;
    }
#line 83
    if (tmp___0 == 2) {
#line 83
      goto case_2___0;
    }
#line 66
    goto switch_break___1;
    case_0___1: /* CIL Label */ 
#line 77
    options_ready = 1;
#line 78
    returnval = 0;
#line 79
    goto switch_break___1;
    case_1___0: /* CIL Label */ 
#line 81
    currscreen = 0;
#line 82
    goto switch_break___1;
    case_2___0: /* CIL Label */ 
#line 84
    returnval = 1;
#line 85
    options_ready = 1;
#line 86
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 89
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 45
    if (! (! options_ready)) {
#line 45
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return (returnval);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/tracksplit.c"
void tracksplit_merge(short *typearray , long *startarray , long *endarray , long *num_of_parts ) 
{ 
  long l ;
  long l2 ;

  {
#line 102
  l2 = 0L;
#line 104
  l = 1L;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (l < *num_of_parts)) {
#line 104
      goto while_break;
    }
#line 105
    if ((int )*(typearray + l) == (int )*(typearray + l2)) {
#line 107
      *(endarray + l2) = *(endarray + l);
    } else {
#line 111
      l2 ++;
#line 112
      *(typearray + l2) = *(typearray + l);
#line 113
      *(startarray + l2) = *(startarray + l);
#line 114
      *(endarray + l2) = *(endarray + l);
    }
#line 104
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  *num_of_parts = l2 + 1L;
#line 118
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/tracksplit.c"
void tracksplit_findtracks(double *medarray , long total_blocks , double global_silence_threshold ,
                           int local_silence_threshold , int min_silence_blocks ,
                           int min_track_blocks , int extra_blocks_start , int extra_blocks_end ,
                           long *trackstarts , long *trackends , int *detected_tracks ) 
{ 
  double *above_threshold ;
  double *above_th_rms ;
  short *part_type ;
  long *part_start ;
  long *part_end ;
  long num_parts ;
  short type_now ;
  short type_left ;
  short type_right ;
  double local_mean ;
  register long l ;
  register long l2 ;
  double tempdouble ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 163
  tmp = malloc((unsigned long )total_blocks * sizeof(double ));
#line 163
  above_threshold = (double *)tmp;
#line 164
  tmp___0 = malloc((unsigned long )total_blocks * sizeof(double ));
#line 164
  above_th_rms = (double *)tmp___0;
#line 165
  tmp___1 = malloc((unsigned long )total_blocks * sizeof(short ));
#line 165
  part_type = (short *)tmp___1;
#line 166
  tmp___2 = malloc((unsigned long )total_blocks * sizeof(long ));
#line 166
  part_start = (long *)tmp___2;
#line 167
  tmp___3 = malloc((unsigned long )total_blocks * sizeof(long ));
#line 167
  part_end = (long *)tmp___3;
#line 170
  l = 0L;
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (l < total_blocks)) {
#line 170
      goto while_break;
    }
#line 172
    if (*(medarray + l) > global_silence_threshold) {
#line 173
      *(above_threshold + l) = (double )1000;
    } else {
#line 175
      *(above_threshold + l) = (double )0;
    }
#line 177
    *(above_th_rms + l) = (double )0;
#line 170
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  l = 0L;
  {
#line 181
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 181
    if (! (l < total_blocks)) {
#line 181
      goto while_break___0;
    }
#line 183
    tempdouble = (double )0;
#line 184
    l2 = l - 5L;
    {
#line 184
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 184
      if (! (l2 <= l + 5L)) {
#line 184
        goto while_break___1;
      }
#line 185
      if (l2 >= 0L) {
#line 185
        if (l2 < total_blocks) {
#line 186
          tempdouble += *(above_threshold + l2) * *(above_threshold + l2);
        }
      }
#line 184
      l2 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 188
    *(above_th_rms + l) = sqrt(tempdouble / (double )11);
#line 181
    l ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 193
  *(part_type + 0) = (short)4;
#line 194
  *(part_start + 0) = -2L;
#line 195
  *(part_end + 0) = -2L;
#line 197
  type_now = (short)2;
#line 198
  num_parts = 1L;
#line 199
  l2 = -1L;
#line 201
  l = 0L;
  {
#line 201
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 201
    if (! (l < total_blocks)) {
#line 201
      goto while_break___2;
    }
#line 203
    if ((int )type_now == 2) {
#line 203
      if (*(above_th_rms + l) > (double )500) {
#line 206
        *(part_type + num_parts) = type_now;
#line 207
        *(part_start + num_parts) = l2;
#line 208
        *(part_end + num_parts) = l - 1L;
#line 209
        l2 = l;
#line 210
        type_now = (short)1;
#line 211
        num_parts ++;
      }
    }
#line 214
    if ((int )type_now == 1) {
#line 214
      if (*(above_th_rms + l) <= (double )500) {
#line 217
        *(part_type + num_parts) = type_now;
#line 218
        *(part_start + num_parts) = l2;
#line 219
        *(part_end + num_parts) = l - 1L;
#line 220
        l2 = l;
#line 221
        type_now = (short)2;
#line 222
        num_parts ++;
      }
    }
#line 201
    l ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 227
  *(part_type + num_parts) = type_now;
#line 228
  *(part_start + num_parts) = l2;
#line 229
  *(part_end + num_parts) = l - 1L;
#line 230
  l2 = l;
#line 231
  num_parts ++;
#line 234
  *(part_type + num_parts) = (short)4;
#line 235
  *(part_start + num_parts) = l2;
#line 236
  *(part_end + num_parts) = l2;
#line 237
  num_parts ++;
#line 241
  l = 0L;
  {
#line 241
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 241
    if (! (l < num_parts)) {
#line 241
      goto while_break___3;
    }
#line 243
    if ((int )*(part_type + l) == 2) {
#line 243
      if ((*(part_end + l) - *(part_start + l)) + 1L >= (long )min_silence_blocks) {
#line 245
        *(part_type + l) = (short)4;
      }
    }
#line 247
    if ((int )*(part_type + l) == 1) {
#line 247
      if ((*(part_end + l) - *(part_start + l)) + 1L >= (long )min_track_blocks) {
#line 249
        *(part_type + l) = (short)3;
      }
    }
#line 241
    l ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 268
  if ((int )*(part_type + 1) == 2) {
#line 269
    *(part_type + 1) = (short)4;
  }
#line 274
  if ((int )*(part_type + (num_parts - 2L)) == 2) {
#line 275
    *(part_type + (num_parts - 2L)) = (short)4;
  }
#line 294
  l = 1L;
  {
#line 294
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 294
    if (! (l < num_parts - 1L)) {
#line 294
      goto while_break___4;
    }
#line 296
    if ((int )*(part_type + l) == 1) {
#line 296
      if ((int )*(part_type + (l - 1L)) == 2) {
#line 296
        if ((int )*(part_type + (l + 1L)) == 2) {
#line 296
          if (*(part_end + l) - *(part_start + l) < 10L) {
#line 300
            *(part_type + l) = (short)2;
          }
        }
      }
    }
#line 294
    l ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 303
  tracksplit_merge(part_type, part_start, part_end, & num_parts);
#line 308
  l = 0L;
  }
  {
#line 308
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 308
    if (! (l < num_parts)) {
#line 308
      goto while_break___5;
    }
#line 310
    if ((int )*(part_type + l) == 2) {
#line 310
      if ((*(part_end + l) - *(part_start + l)) + 1L >= (long )min_silence_blocks) {
#line 312
        *(part_type + l) = (short)4;
      }
    }
#line 308
    l ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 327
  l = 0L;
  {
#line 327
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 327
    if (! (l < num_parts)) {
#line 327
      goto while_break___6;
    }
#line 328
    if ((int )*(part_type + l) == 2) {
#line 328
      goto _L;
    } else
#line 328
    if ((int )*(part_type + l) == 1) {
      _L: /* CIL Label */ 
#line 331
      l2 = l;
#line 332
      type_left = (short)0;
      {
#line 333
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 333
        if (l2 >= 0L) {
#line 333
          if (! ((int )type_left == 0)) {
#line 333
            goto while_break___7;
          }
        } else {
#line 333
          goto while_break___7;
        }
#line 335
        if ((int )*(part_type + l2) == 4) {
#line 337
          type_left = *(part_type + l2);
        } else
#line 335
        if ((int )*(part_type + l2) == 3) {
#line 337
          type_left = *(part_type + l2);
        }
#line 338
        l2 --;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 340
      if ((int )type_left == 0) {
#line 341
        type_left = (short)4;
      }
#line 344
      l2 = l;
#line 345
      type_right = (short)0;
      {
#line 346
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 346
        if (l2 < num_parts) {
#line 346
          if (! ((int )type_right == 0)) {
#line 346
            goto while_break___8;
          }
        } else {
#line 346
          goto while_break___8;
        }
#line 348
        if ((int )*(part_type + l2) == 4) {
#line 350
          type_right = *(part_type + l2);
        } else
#line 348
        if ((int )*(part_type + l2) == 3) {
#line 350
          type_right = *(part_type + l2);
        }
#line 351
        l2 ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 353
      if ((int )type_right == 0) {
#line 354
        type_right = (short)4;
      }
#line 357
      if ((int )type_left == 4) {
#line 357
        if ((int )type_right == 4) {
#line 358
          *(part_type + l) = (short)4;
        } else {
#line 360
          *(part_type + l) = (short)3;
        }
      } else {
#line 360
        *(part_type + l) = (short)3;
      }
    }
#line 327
    l ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 363
  tracksplit_merge(part_type, part_start, part_end, & num_parts);
  }
#line 367
  if (*(part_end + 0) >= 0L) {
#line 368
    *(part_start + 0) = 0L;
  } else {
#line 371
    l = 0L;
    {
#line 371
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 371
      if (! (l < num_parts - 1L)) {
#line 371
        goto while_break___9;
      }
#line 373
      *(part_type + l) = *(part_type + (l + 1L));
#line 374
      *(part_start + l) = *(part_start + (l + 1L));
#line 375
      *(part_end + l) = *(part_end + (l + 1L));
#line 371
      l ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 377
    num_parts --;
  }
#line 380
  if (*(part_start + (num_parts - 1L)) <= total_blocks - 1L) {
#line 381
    *(part_end + (num_parts - 1L)) = total_blocks - 1L;
  } else {
#line 383
    num_parts --;
  }
#line 393
  l = 0L;
  {
#line 393
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 393
    if (! (l < num_parts)) {
#line 393
      goto while_break___10;
    }
#line 394
    if ((int )*(part_type + l) == 4) {
#line 394
      if ((*(part_end + l) - *(part_start + l)) + 1L >= 10L) {
#line 398
        local_mean = (double )0;
#line 399
        l2 = *(part_start + l) + 3L;
        {
#line 399
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 399
          if (! (l2 <= *(part_end + l) - 3L)) {
#line 399
            goto while_break___11;
          }
#line 400
          local_mean += *(medarray + l2);
#line 399
          l2 ++;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 401
        local_mean /= (double )(((*(part_end + l) - *(part_start + l)) + 1L) - 6L);
        {
#line 403
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 403
          if (*(medarray + *(part_start + l)) > local_mean * ((double )1 + (double )local_silence_threshold / 100.)) {
#line 403
            if (! (*(part_start + l) < *(part_end + l))) {
#line 403
              goto while_break___12;
            }
          } else {
#line 403
            goto while_break___12;
          }
#line 406
          (*(part_start + l)) ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        {
#line 408
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 408
          if (*(medarray + *(part_end + l)) > local_mean * ((double )1 + (double )local_silence_threshold / 100.)) {
#line 408
            if (! (*(part_end + l) > *(part_start + l))) {
#line 408
              goto while_break___13;
            }
          } else {
#line 408
            goto while_break___13;
          }
#line 411
          (*(part_end + l)) --;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 415
        if ((*(part_end + l) - *(part_start + l)) + 1L >= (long )((extra_blocks_end + extra_blocks_start) + 1)) {
#line 418
          *(part_start + l) += (long )extra_blocks_end;
#line 419
          *(part_end + l) -= (long )extra_blocks_start;
        }
#line 424
        if ((*(part_end + l) - *(part_start + l)) + 1L < (long )min_silence_blocks) {
#line 424
          if (l > 0L) {
#line 424
            if (l < num_parts - 1L) {
#line 426
              *(part_type + l) = (short)3;
            }
          }
        }
#line 429
        if (l > 0L) {
#line 430
          *(part_end + (l - 1L)) = *(part_start + l) - 1L;
        }
#line 431
        if (l < num_parts - 1L) {
#line 432
          *(part_start + (l + 1L)) = *(part_end + l) + 1L;
        }
      }
    }
#line 393
    l ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 436
  tracksplit_merge(part_type, part_start, part_end, & num_parts);
#line 447
  *detected_tracks = 0;
#line 448
  l = 0L;
  }
  {
#line 448
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 448
    if (l < num_parts) {
#line 448
      if (! (*detected_tracks < 99)) {
#line 448
        goto while_break___14;
      }
    } else {
#line 448
      goto while_break___14;
    }
#line 449
    if ((int )*(part_type + l) == 3) {
#line 451
      *(trackstarts + *detected_tracks) = *(part_start + l);
#line 452
      *(trackends + *detected_tracks) = *(part_end + l);
#line 453
      (*detected_tracks) ++;
    }
#line 448
    l ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 478
  free((void *)above_threshold);
#line 479
  free((void *)above_th_rms);
#line 480
  free((void *)part_type);
#line 481
  free((void *)part_start);
#line 482
  free((void *)part_end);
  }
#line 483
  return;
}
}
#line 486 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/tracksplit.c"
void tracksplit_main(char *startdir ) 
{ 
  char filename[250] ;
  int make_use_rms ;
  int make_graphs ;
  long blocklen ;
  int global_silence_factor ;
  int local_silence_threshold ;
  int min_silence_blocks ;
  int min_track_blocks ;
  int extra_blocks_start ;
  int extra_blocks_end ;
  sample_t sample ;
  double *rmsarray ;
  double *medarray ;
  double *sortarray ;
  long total_samples ;
  long total_samples_read ;
  struct stat buf ;
  register long l ;
  long samples_read ;
  long current_block ;
  long total_blocks ;
  double sum_left ;
  double sum_right ;
  int i ;
  FILE *tempfile ;
  FILE *tempfile2 ;
  long trackstarts[100] ;
  long trackends[100] ;
  int detected_tracks ;
  char tempstring[250] ;
  double global_silence_threshold ;
  double min_poss_threshold ;
  double max_poss_threshold ;
  int compute_rms_now ;
  long templong ;
  int in_ch ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;

  {
  {
#line 492
  make_use_rms = 1;
#line 493
  make_graphs = 0;
#line 494
  blocklen = 4410L;
#line 495
  global_silence_factor = 150;
#line 496
  local_silence_threshold = 5;
#line 497
  min_silence_blocks = 20;
#line 498
  min_track_blocks = 50;
#line 499
  extra_blocks_start = 3;
#line 500
  extra_blocks_end = 6;
#line 504
  rmsarray = (double *)((void *)0);
#line 533
  filename[0] = (char )'\000';
#line 535
  tmp = tracksplit_get_options(startdir, filename, & make_use_rms, & make_graphs,
                               & blocklen, & global_silence_factor, & local_silence_threshold,
                               & min_silence_blocks, & min_track_blocks, & extra_blocks_start,
                               & extra_blocks_end);
  }
#line 535
  if (! tmp) {
#line 541
    return;
  }
  {
#line 543
  clearscreen((char *)"Track Location");
#line 544
  wmove(stdscr, 0, 79);
#line 545
  wrefresh(stdscr);
#line 547
  compute_rms_now = 0;
  }
#line 549
  if (! make_use_rms) {
#line 550
    compute_rms_now = 1;
  }
#line 552
  if (! compute_rms_now) {
    {
#line 554
    strcpy((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)(filename));
#line 555
    strcat((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)".rms");
#line 556
    tempfile = fopen((char const   */* __restrict  */)(tempstring), (char const   */* __restrict  */)"r");
    }
#line 557
    if ((unsigned long )tempfile == (unsigned long )((void *)0)) {
#line 558
      compute_rms_now = 1;
    }
  }
#line 561
  if (! compute_rms_now) {
    {
#line 563
    fgets((char */* __restrict  */)(tempstring), 100, (FILE */* __restrict  */)tempfile);
#line 564
    tmp___0 = strncasecmp((char const   *)(tempstring), "GramoFile Binary RMS Data",
                          (size_t )25);
    }
#line 564
    if (tmp___0) {
      {
#line 566
      fclose(tempfile);
#line 567
      compute_rms_now = 1;
      }
    }
  }
#line 571
  if (! compute_rms_now) {
    {
#line 573
    tmp___1 = fread((void */* __restrict  */)(& templong), sizeof(long ), (size_t )1,
                    (FILE */* __restrict  */)tempfile);
    }
#line 573
    if (tmp___1 < 1UL) {
      {
#line 575
      fclose(tempfile);
#line 576
      compute_rms_now = 1;
      }
    }
  }
#line 580
  if (! compute_rms_now) {
#line 582
    if (templong != blocklen) {
      {
#line 584
      fclose(tempfile);
#line 585
      compute_rms_now = 1;
      }
    }
  }
#line 589
  if (! compute_rms_now) {
    {
#line 591
    tmp___2 = fread((void */* __restrict  */)(& templong), sizeof(long ), (size_t )1,
                    (FILE */* __restrict  */)tempfile);
    }
#line 591
    if (tmp___2 < 1UL) {
      {
#line 593
      fclose(tempfile);
#line 594
      compute_rms_now = 1;
      }
    }
  }
#line 598
  if (! compute_rms_now) {
#line 600
    if (templong < 1L) {
      {
#line 602
      fclose(tempfile);
#line 603
      compute_rms_now = 1;
      }
    } else {
      {
#line 608
      total_blocks = templong;
#line 610
      tmp___3 = malloc((unsigned long )total_blocks * sizeof(double ));
#line 610
      rmsarray = (double *)tmp___3;
#line 612
      fread((void */* __restrict  */)rmsarray, sizeof(double ), (size_t )total_blocks,
            (FILE */* __restrict  */)tempfile);
#line 613
      fclose(tempfile);
      }
    }
  }
#line 617
  if (compute_rms_now) {
    {
#line 619
    tmp___4 = stat((char const   */* __restrict  */)(filename), (struct stat */* __restrict  */)(& buf));
    }
#line 619
    if (tmp___4) {
      {
#line 621
      error_window((char *)"Sound file could not be opened.");
      }
#line 622
      return;
    }
    {
#line 625
    total_samples = (long )(((unsigned long )buf.st_size - sizeof(wavhead )) / 4UL);
#line 627
    total_blocks = total_samples / blocklen + 1L;
#line 629
    tmp___5 = openwavsource(filename);
    }
#line 629
    if (! tmp___5) {
      {
#line 631
      error_window((char *)"Sound file could not be opened.");
      }
#line 632
      return;
    }
    {
#line 635
    error_window_display((char *)"Computing signal power (RMS)...", (char *)" Cancel ");
#line 637
    nodelay(stdscr, (_Bool)1);
#line 639
    tmp___6 = malloc((unsigned long )total_blocks * sizeof(double ));
#line 639
    rmsarray = (double *)tmp___6;
#line 641
    total_samples_read = 0L;
#line 642
    current_block = 0L;
    }
    {
#line 644
    while (1) {
      while_continue: /* CIL Label */ ;
#line 644
      if (! (total_samples_read < total_samples)) {
#line 644
        goto while_break;
      }
#line 646
      if (! (current_block % 5L)) {
        {
#line 648
        mvprintw(11, 21, "Done : %3d %%", (int )(((double )current_block * 100.) / (double )total_blocks));
#line 651
        wmove(stdscr, 0, 79);
        }
      }
#line 654
      samples_read = 0L;
#line 655
      sum_left = (double )0;
#line 656
      sum_right = (double )0;
#line 657
      l = 0L;
      {
#line 657
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 657
        if (! (l < blocklen)) {
#line 657
          goto while_break___0;
        }
#line 658
        if (total_samples_read < total_samples) {
          {
#line 660
          sample = readsamplesource();
#line 661
          sum_left += (double )((long )sample.left * (long )sample.left);
#line 662
          sum_right += (double )((long )sample.right * (long )sample.right);
#line 664
          samples_read ++;
#line 665
          total_samples_read ++;
          }
        }
#line 657
        l ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 668
      tmp___7 = fabs(sum_left / (double )samples_read);
#line 668
      sum_left = sqrt(tmp___7);
#line 669
      tmp___8 = fabs(sum_right / (double )samples_read);
#line 669
      sum_right = sqrt(tmp___8);
      }
#line 671
      if (sum_right > sum_left) {
#line 672
        sum_left = sum_right;
      }
#line 676
      if (sum_left < (double )0) {
#line 677
        sum_left = (double )0;
      }
#line 678
      if (sum_left > (double )32767) {
#line 679
        sum_left = (double )32767;
      }
      {
#line 681
      *(rmsarray + current_block) = sum_left;
#line 683
      current_block ++;
#line 685
      in_ch = wgetch(stdscr);
      }
#line 686
      if (in_ch == 27) {
        {
#line 688
        reset_prog_mode();
#line 689
        nodelay(stdscr, (_Bool)0);
#line 690
        closewavsource();
        }
#line 691
        return;
      } else
#line 686
      if (in_ch == 13) {
        {
#line 688
        reset_prog_mode();
#line 689
        nodelay(stdscr, (_Bool)0);
#line 690
        closewavsource();
        }
#line 691
        return;
      } else
#line 686
      if (in_ch == 343) {
        {
#line 688
        reset_prog_mode();
#line 689
        nodelay(stdscr, (_Bool)0);
#line 690
        closewavsource();
        }
#line 691
        return;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 695
    closewavsource();
#line 697
    reset_prog_mode();
#line 698
    nodelay(stdscr, (_Bool)0);
    }
#line 700
    if (make_use_rms) {
      {
#line 702
      strcpy((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)(filename));
#line 703
      strcat((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)".rms");
#line 704
      tempfile = fopen((char const   */* __restrict  */)(tempstring), (char const   */* __restrict  */)"w");
#line 705
      fprintf((FILE */* __restrict  */)tempfile, (char const   */* __restrict  */)"GramoFile Binary RMS Data\n");
#line 706
      fwrite((void const   */* __restrict  */)(& blocklen), sizeof(long ), (size_t )1,
             (FILE */* __restrict  */)tempfile);
#line 707
      fwrite((void const   */* __restrict  */)(& total_blocks), sizeof(long ), (size_t )1,
             (FILE */* __restrict  */)tempfile);
#line 708
      fwrite((void const   */* __restrict  */)rmsarray, sizeof(double ), (size_t )total_blocks,
             (FILE */* __restrict  */)tempfile);
#line 709
      fclose(tempfile);
      }
    }
  }
  {
#line 717
  tmp___9 = malloc((unsigned long )total_blocks * sizeof(double ));
#line 717
  medarray = (double *)tmp___9;
#line 718
  tmp___10 = malloc((unsigned long )total_blocks * sizeof(double ));
#line 718
  sortarray = (double *)tmp___10;
#line 720
  *(medarray + 0) = *(rmsarray + 0);
#line 721
  *(medarray + (total_blocks - 1L)) = *(rmsarray + (total_blocks - 1L));
#line 724
  l = 1L;
  }
  {
#line 724
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 724
    if (! (l < total_blocks - 1L)) {
#line 724
      goto while_break___1;
    }
#line 725
    if (*(rmsarray + (l - 1L)) < *(rmsarray + l)) {
#line 728
      if (*(rmsarray + l) < *(rmsarray + (l + 1L))) {
#line 730
        *(medarray + l) = *(rmsarray + l);
      } else
#line 734
      if (*(rmsarray + (l - 1L)) < *(rmsarray + (l + 1L))) {
#line 736
        *(medarray + l) = *(rmsarray + (l + 1L));
      } else {
#line 739
        *(medarray + l) = *(rmsarray + (l - 1L));
      }
    } else
#line 745
    if (*(rmsarray + l) < *(rmsarray + (l + 1L))) {
#line 748
      if (*(rmsarray + (l - 1L)) < *(rmsarray + (l + 1L))) {
#line 750
        *(medarray + l) = *(rmsarray + (l - 1L));
      } else {
#line 753
        *(medarray + l) = *(rmsarray + (l + 1L));
      }
    } else {
#line 757
      *(medarray + l) = *(rmsarray + l);
    }
#line 724
    l ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 770
  l = 0L;
  {
#line 770
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 770
    if (! (l < total_blocks)) {
#line 770
      goto while_break___2;
    }
#line 771
    *(sortarray + l) = *(medarray + l);
#line 770
    l ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 773
  qsort2double(sortarray, total_blocks);
#line 776
  min_poss_threshold = *(sortarray + 10);
#line 777
  max_poss_threshold = *(sortarray + total_blocks / 2L);
#line 810
  global_silence_threshold = (max_poss_threshold - min_poss_threshold) * ((double )global_silence_factor / 1000.) + min_poss_threshold;
#line 817
  tracksplit_findtracks(medarray, total_blocks, global_silence_threshold, local_silence_threshold,
                        min_silence_blocks, min_track_blocks, extra_blocks_start,
                        extra_blocks_end, trackstarts, trackends, & detected_tracks);
#line 834
  strcpy((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)(filename));
#line 835
  strcat((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)".tracks");
#line 836
  tempfile = fopen((char const   */* __restrict  */)(tempstring), (char const   */* __restrict  */)"w");
  }
#line 837
  if ((unsigned long )tempfile == (unsigned long )((void *)0)) {
    {
#line 839
    error_window((char *)"The .tracks file could not be written.");
    }
#line 840
    return;
  }
  {
#line 842
  fprintf((FILE */* __restrict  */)tempfile, (char const   */* __restrict  */)"# GramoFile Tracks File\n#\n# This file contains information on track starts/ends. It is automatically\n# generated and will be overwritten completely by subsequent track-\n# splitting actions on the same audio file.\n\n# Blank lines and lines starting with `#\' are ignored.\n\n[Tracks]\n# These values are not used (yet), but are included for reference /\n# regeneration purposes.\n");
#line 855
  fprintf((FILE */* __restrict  */)tempfile, (char const   */* __restrict  */)"Blocklen=%ld\n",
          blocklen);
#line 856
  fprintf((FILE */* __restrict  */)tempfile, (char const   */* __restrict  */)"Global_silence_factor=%d\n",
          global_silence_factor);
#line 858
  fprintf((FILE */* __restrict  */)tempfile, (char const   */* __restrict  */)"Local_silence_factor=%d\n",
          local_silence_threshold);
#line 860
  fprintf((FILE */* __restrict  */)tempfile, (char const   */* __restrict  */)"Min_silence_blocks=%d\n",
          min_silence_blocks);
#line 861
  fprintf((FILE */* __restrict  */)tempfile, (char const   */* __restrict  */)"Min_track_blocks=%d\n",
          min_track_blocks);
#line 862
  fprintf((FILE */* __restrict  */)tempfile, (char const   */* __restrict  */)"Extra_blocks_start=%d\n",
          extra_blocks_start);
#line 863
  fprintf((FILE */* __restrict  */)tempfile, (char const   */* __restrict  */)"Extra_blocks_end=%d\n",
          extra_blocks_end);
#line 864
  fprintf((FILE */* __restrict  */)tempfile, (char const   */* __restrict  */)"\n# Below are start/end times of tracks. These are used to create separate\n# soundfiles during signal processing. You may modify the computed values\n# if you disagree... The block-numbers are those used in the .med file.\n\n");
#line 872
  fprintf((FILE */* __restrict  */)tempfile, (char const   */* __restrict  */)"Number_of_tracks=%d\n",
          detected_tracks);
#line 874
  l = 0L;
  }
  {
#line 874
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 874
    if (! (l < (long )detected_tracks)) {
#line 874
      goto while_break___3;
    }
    {
#line 876
    fsec2hmsf(((double )((trackends[l] - trackstarts[l]) + 1L) * (double )blocklen) / 44100.,
              tempstring);
#line 879
    fprintf((FILE */* __restrict  */)tempfile, (char const   */* __restrict  */)"\n# Track %ld - blocks %ld to %ld - length: %s\n",
            l + 1L, trackstarts[l], trackends[l], tempstring);
#line 882
    fsec2hmsf(((double )trackstarts[l] * (double )blocklen) / 44100., tempstring);
#line 884
    fprintf((FILE */* __restrict  */)tempfile, (char const   */* __restrict  */)"Track%02ldstart=%s\n",
            l + 1L, tempstring);
#line 885
    fsec2hmsf(((double )(trackends[l] + 1L) * (double )blocklen) / 44100., tempstring);
#line 887
    fprintf((FILE */* __restrict  */)tempfile, (char const   */* __restrict  */)"Track%02ldend=%s\n",
            l + 1L, tempstring);
#line 874
    l ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 890
  fprintf((FILE */* __restrict  */)tempfile, (char const   */* __restrict  */)"\n");
#line 891
  fclose(tempfile);
  }
#line 894
  if (make_graphs) {
    {
#line 896
    strcpy((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)(filename));
#line 897
    strcat((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)".med");
#line 898
    tempfile2 = fopen((char const   */* __restrict  */)(tempstring), (char const   */* __restrict  */)"w");
#line 899
    fprintf((FILE */* __restrict  */)tempfile2, (char const   */* __restrict  */)"Med(RMS(signal))\n");
#line 900
    fprintf((FILE */* __restrict  */)tempfile2, (char const   */* __restrict  */)"Threshold: %f\n\n",
            global_silence_threshold);
#line 901
    l = 0L;
    }
    {
#line 901
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 901
      if (! (l < total_blocks)) {
#line 901
        goto while_break___4;
      }
      {
#line 903
      fprintf((FILE */* __restrict  */)tempfile2, (char const   */* __restrict  */)"%5ld:%8.2f ",
              l, *(medarray + l));
#line 904
      i = 0;
      }
      {
#line 904
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 904
        tmp___11 = fabs(*(medarray + l) / (double )80);
        }
#line 904
        if (! ((double )i < tmp___11)) {
#line 904
          goto while_break___5;
        }
        {
#line 905
        fprintf((FILE */* __restrict  */)tempfile2, (char const   */* __restrict  */)"=");
#line 904
        i ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 906
      fprintf((FILE */* __restrict  */)tempfile2, (char const   */* __restrict  */)"\n");
#line 901
      l ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 908
    fclose(tempfile2);
#line 910
    strcpy((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)(filename));
#line 911
    strcat((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)".sor");
#line 912
    tempfile2 = fopen((char const   */* __restrict  */)(tempstring), (char const   */* __restrict  */)"w");
#line 913
    fprintf((FILE */* __restrict  */)tempfile2, (char const   */* __restrict  */)"Sort(Med(RMS(signal)))\n");
#line 914
    fprintf((FILE */* __restrict  */)tempfile2, (char const   */* __restrict  */)"Threshold: %f\n\n",
            global_silence_threshold);
#line 915
    l = 0L;
    }
    {
#line 915
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 915
      if (! (l < total_blocks)) {
#line 915
        goto while_break___6;
      }
      {
#line 917
      fprintf((FILE */* __restrict  */)tempfile2, (char const   */* __restrict  */)"%5ld:%8.2f ",
              l, *(sortarray + l));
#line 918
      i = 0;
      }
      {
#line 918
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 918
        tmp___12 = fabs(*(sortarray + l) / (double )80);
        }
#line 918
        if (! ((double )i < tmp___12)) {
#line 918
          goto while_break___7;
        }
        {
#line 919
        fprintf((FILE */* __restrict  */)tempfile2, (char const   */* __restrict  */)"=");
#line 918
        i ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 920
      fprintf((FILE */* __restrict  */)tempfile2, (char const   */* __restrict  */)"\n");
#line 915
      l ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 922
    fclose(tempfile2);
    }
  }
  {
#line 927
  sprintf((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)"%d tracks have been detected. More information is in the `.tracks\' file.",
          detected_tracks);
#line 929
  error_window(tempstring);
#line 932
  free((void *)rmsarray);
#line 933
  free((void *)medarray);
#line 934
  free((void *)sortarray);
  }
#line 935
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/playwav.h"
int playwav_select_file(char *startdir , char *selectedfile , int *usebeginendtime___0 ,
                        double *begintime___0 , double *endtime___0 ) ;
#line 21
void playwav_main(char *startdir ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/scrollmenu.h"
void scrollmenu_display(scrollmenu_t *menu ) ;
#line 32
int scrollmenu_stdkeys(int key , scrollmenu_t *menu ) ;
#line 37
void scrollmenu_delete_menu(scrollmenu_t *menu ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/stringinput.h"
void stringinput_display(stringinput_t *data ) ;
#line 31
void stringinput_stdkeys(int key , stringinput_t *data ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/buttons.h"
void button_display(button_t *button ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/boxes.h"
void mybox(int y , int x , int h , int w ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/dirfilemenu.h"
void dirfilemenu(char *basedir , scrollmenu_t *menu ) ;
#line 19
int dirfilemenu_process_select(scrollmenu_t *menu , char *dirfile ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/checkfile.h"
int checkfile(char *filename ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/helpline.h"
void helpline(char *helptext ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/clrscr.h"
void header(char *headertext ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/secshms.h"
int hmsf2fsec(char *instring , double *seconds ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.h"
int load_track_times(char *filename , beginendsample_t *tracktimes , int *number_of_tracks ) ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 717
extern int system(char const   *__command ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 598 "/usr/include/curses.h"
extern int def_prog_mode(void) ;
#line 801
extern int wclear(WINDOW * ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/playwav.c"
void playwav_playit(char *filename , int usebeginendtime___0 , double begintime___0 ,
                    double endtime___0 ) 
{ 
  char shellcmd[500] ;
  int tmp ;

  {
  {
#line 42
  tmp = checkfile(filename);
  }
  {
#line 44
  if (tmp == 1) {
#line 44
    goto case_1;
  }
#line 64
  if (tmp == 2) {
#line 64
    goto case_2;
  }
#line 70
  if (tmp == 4) {
#line 70
    goto case_4;
  }
#line 70
  if (tmp == 3) {
#line 70
    goto case_4;
  }
#line 74
  goto switch_default;
  case_1: /* CIL Label */ 
#line 46
  if (usebeginendtime___0) {
    {
#line 47
    sprintf((char */* __restrict  */)(shellcmd), (char const   */* __restrict  */)"bplay_gramo -S -s 44100 -b 16 -J %ld -T %ld %s",
            (long )(begintime___0 * (double )44100), (long )((endtime___0 - begintime___0) * (double )44100),
            filename);
    }
  } else {
    {
#line 51
    sprintf((char */* __restrict  */)(shellcmd), (char const   */* __restrict  */)"bplay_gramo -S -s 44100 -b 16 %s",
            filename);
    }
  }
  {
#line 55
  def_prog_mode();
#line 57
  system((char const   *)(shellcmd));
#line 59
  reset_prog_mode();
#line 60
  wclear(stdscr);
  }
#line 62
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 65
  error_window((char *)"The specified name is of a directory. A file name must be specified.");
  }
#line 67
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 71
  error_window((char *)"The specified file does not exist.");
  }
#line 72
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 75
  error_window((char *)"Fell out of switch, playwav #2");
  }
#line 76
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/playwav.c"
void playwav_track(char *filename , int track , int action ) 
{ 
  beginendsample_t tracktimes[100] ;
  int number_of_tracks ;
  double begintime___0 ;
  double endtime___0 ;
  char helpstring[200] ;
  int tmp ;

  {
  {
#line 100
  tmp = load_track_times(filename, tracktimes, & number_of_tracks);
  }
#line 100
  if (! tmp) {
#line 101
    return;
  }
#line 103
  if (track > number_of_tracks) {
    {
#line 105
    sprintf((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)"There are only %d tracks.",
            number_of_tracks);
#line 106
    error_window(helpstring);
    }
#line 107
    return;
  } else
#line 103
  if (track < 1) {
    {
#line 105
    sprintf((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)"There are only %d tracks.",
            number_of_tracks);
#line 106
    error_window(helpstring);
    }
#line 107
    return;
  }
  {
#line 112
  if (action == 1) {
#line 112
    goto case_1;
  }
#line 118
  if (action == 2) {
#line 118
    goto case_2;
  }
#line 123
  if (action == 3) {
#line 123
    goto case_3;
  }
#line 128
  if (action == 4) {
#line 128
    goto case_4;
  }
#line 133
  if (action == 5) {
#line 133
    goto case_5;
  }
#line 138
  goto switch_default;
  case_1: /* CIL Label */ 
#line 113
  begintime___0 = (double )tracktimes[track].begin;
#line 114
  endtime___0 = (double )tracktimes[track].end;
#line 116
  goto switch_break;
  case_2: /* CIL Label */ 
#line 119
  begintime___0 = (double )tracktimes[track].begin;
#line 120
  endtime___0 = (double )(tracktimes[track].begin + 220500L);
#line 121
  goto switch_break;
  case_3: /* CIL Label */ 
#line 124
  begintime___0 = (double )(tracktimes[track].end - 176400L);
#line 125
  endtime___0 = (double )tracktimes[track].end;
#line 126
  goto switch_break;
  case_4: /* CIL Label */ 
#line 129
  begintime___0 = (double )(tracktimes[track].begin - 132300L);
#line 130
  endtime___0 = (double )tracktimes[track].begin;
#line 131
  goto switch_break;
  case_5: /* CIL Label */ 
#line 134
  begintime___0 = (double )tracktimes[track].end;
#line 135
  endtime___0 = (double )(tracktimes[track].end + 132300L);
#line 136
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 139
  error_window((char *)"Fell out of switch, playwav #3");
  }
#line 140
  return;
  switch_break: /* CIL Label */ ;
  }
#line 143
  if (begintime___0 < (double )0) {
#line 144
    begintime___0 = (double )0;
  }
#line 145
  if (endtime___0 < (double )0) {
#line 146
    endtime___0 = (double )0;
  }
#line 147
  if (begintime___0 >= endtime___0) {
#line 148
    return;
  }
  {
#line 151
  playwav_playit(filename, 1, begintime___0 / (double )44100, endtime___0 / (double )44100);
  }
#line 152
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/playwav.c"
int playwav_select_file(char *startdir , char *selectedfile , int *usebeginendtime___0 ,
                        double *begintime___0 , double *endtime___0 ) 
{ 
  scrollmenu_t dirfilelist ;
  stringinput_t string ;
  button_t ok_button ;
  button_t cancel_button ;
  int dont_stop ;
  int returnval ;
  int focus ;
  int in_ch ;
  int i ;
  char helpstring[500] ;
  char *charpointer ;
  struct stat filestats ;
  int oldselected ;
  double tempdouble ;
  long templong ;
  char tempstring[250] ;
  stringinput_t trackstring ;
  stringinput_t begintimestring ;
  stringinput_t endtimestring ;
  button_t beginend_check ;
  struct stat buf ;
  char *helplines[8] ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  size_t tmp___31 ;
  int tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___36 ;
  int tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;

  {
  {
#line 164
  dont_stop = 1;
#line 165
  returnval = 0;
#line 173
  tempdouble = (double )0;
#line 180
  helplines[0] = (char *)" Select name of sound file to be played.                        TAB: Next field";
#line 180
  helplines[1] = (char *)" Enter: Play track    B/E: Beginning/End    F/A: beFore/After    +/-: Prev/Next";
#line 180
  helplines[2] = (char *)" Play only a part of the sound file.                            TAB: Next field";
#line 180
  helplines[3] = (char *)" Enter begin time of part to be played.                         TAB: Next field";
#line 180
  helplines[4] = (char *)" Enter end time of part to be played.                           TAB: Next field";
#line 180
  helplines[5] = (char *)" Enter name of sound file to be played.                         TAB: Next field";
#line 180
  helplines[6] = (char *)" Back to main menu.                                             TAB: Next field";
#line 180
  helplines[7] = (char *)" Play the specified (part of the) sound file.                   TAB: Next field";
#line 191
  dirfilelist.y = 3;
#line 192
  dirfilelist.x = 5;
#line 193
  dirfilelist.h = 12;
#line 194
  dirfilelist.w = 32;
#line 195
  dirfilelist.firstonscreen = 0;
#line 196
  dirfilemenu(startdir, & dirfilelist);
#line 197
  dirfilelist.selected = dirfilelist.last_of_1st_part + 1;
#line 199
  string.maxlen = 500;
#line 200
  tmp = malloc((unsigned long )string.maxlen * sizeof(char ));
#line 200
  string.string = (char *)tmp;
  }
#line 201
  if ((int )*(selectedfile + 0) == 0) {
    {
#line 202
    strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)startdir);
    }
  } else {
    {
#line 204
    strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)selectedfile);
    }
  }
  {
#line 205
  string.y = 17;
#line 206
  string.x = 5;
#line 207
  string.w = 70;
#line 208
  tmp___0 = strlen((char const   *)string.string);
#line 208
  string.cursorpos = (int )tmp___0;
#line 209
  tmp___1 = strlen((char const   *)string.string);
#line 209
  string.firstcharonscreen = (int )((tmp___1 - (size_t )string.w) + 2UL);
  }
#line 210
  if (string.firstcharonscreen < 0) {
#line 211
    string.firstcharonscreen = 0;
  }
  {
#line 213
  ok_button.text = (char *)" Play ";
#line 214
  ok_button.y = 20;
#line 215
  ok_button.x = 69;
#line 216
  ok_button.selected = 0;
#line 218
  cancel_button.text = (char *)" Cancel ";
#line 219
  cancel_button.y = 20;
#line 220
  cancel_button.x = 5;
#line 221
  cancel_button.selected = 0;
#line 223
  trackstring.maxlen = 500;
#line 224
  tmp___2 = malloc((unsigned long )trackstring.maxlen * sizeof(char ));
#line 224
  trackstring.string = (char *)tmp___2;
#line 226
  strcpy((char */* __restrict  */)trackstring.string, (char const   */* __restrict  */)"1");
#line 227
  trackstring.y = 11;
#line 228
  trackstring.x = 54;
#line 229
  trackstring.w = 10;
#line 230
  tmp___3 = strlen((char const   *)trackstring.string);
#line 230
  trackstring.cursorpos = (int )tmp___3;
#line 231
  trackstring.firstcharonscreen = 0;
#line 233
  begintimestring.maxlen = 500;
#line 234
  tmp___4 = malloc((unsigned long )begintimestring.maxlen * sizeof(char ));
#line 234
  begintimestring.string = (char *)tmp___4;
#line 236
  fsec2hmsf(*begintime___0, begintimestring.string);
#line 237
  begintimestring.y = 14;
#line 238
  begintimestring.x = 59;
#line 239
  begintimestring.w = 18;
#line 240
  tmp___5 = strlen((char const   *)begintimestring.string);
#line 240
  begintimestring.cursorpos = (int )tmp___5;
#line 241
  begintimestring.firstcharonscreen = 0;
#line 243
  endtimestring.maxlen = 500;
#line 244
  tmp___6 = malloc((unsigned long )endtimestring.maxlen * sizeof(char ));
#line 244
  endtimestring.string = (char *)tmp___6;
#line 246
  fsec2hmsf(*endtime___0, endtimestring.string);
#line 247
  endtimestring.y = 15;
#line 248
  endtimestring.x = 59;
#line 249
  endtimestring.w = 18;
#line 250
  tmp___7 = strlen((char const   *)endtimestring.string);
#line 250
  endtimestring.cursorpos = (int )tmp___7;
#line 251
  endtimestring.firstcharonscreen = 0;
#line 253
  beginend_check.text = (char *)"";
#line 254
  beginend_check.y = 13;
#line 255
  beginend_check.x = 42;
#line 256
  beginend_check.selected = 0;
#line 258
  clearscreen((char *)"Play a sound file");
  }
#line 260
  if ((int )*(selectedfile + 0) == 0) {
#line 261
    focus = 0;
  } else {
#line 263
    focus = 5;
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (*usebeginendtime___0) {
#line 268
      beginend_check.text = (char *)"[X] Use begin and end times";
    } else {
#line 270
      beginend_check.text = (char *)"[ ] Use begin and end times";
    }
#line 272
    if (focus == 2) {
#line 273
      beginend_check.selected = 1;
    } else {
#line 275
      beginend_check.selected = 0;
    }
#line 277
    if (focus == 6) {
#line 278
      cancel_button.selected = 1;
    } else {
#line 280
      cancel_button.selected = 0;
    }
#line 282
    if (focus == 7) {
#line 283
      ok_button.selected = 1;
    } else {
#line 285
      ok_button.selected = 0;
    }
    {
#line 287
    dirfilelist.hasfocus = focus == 0;
#line 289
    scrollmenu_display(& dirfilelist);
#line 290
    mybox(dirfilelist.y - 1, dirfilelist.x - 1, dirfilelist.h + 2, dirfilelist.w + 2);
#line 292
    mvprintw(dirfilelist.y - 1, dirfilelist.x + 1, "Files and directories:");
#line 295
    button_display(& beginend_check);
#line 297
    stringinput_display(& trackstring);
#line 298
    mvprintw(trackstring.y, trackstring.x - 7, "Track:");
#line 301
    stringinput_display(& begintimestring);
#line 302
    mvprintw(begintimestring.y, begintimestring.x - 12, "Begin time:");
#line 305
    stringinput_display(& endtimestring);
#line 306
    mvprintw(endtimestring.y, endtimestring.x - 12, "End time  :");
#line 309
    stringinput_display(& string);
#line 310
    mybox(string.y - 1, string.x - 1, 3, string.w + 2);
#line 311
    mvprintw(string.y - 1, string.x + 1, "File name:");
#line 313
    button_display(& cancel_button);
#line 314
    tmp___8 = strlen((char const   *)cancel_button.text);
#line 314
    mybox(cancel_button.y - 1, cancel_button.x - 1, 3, (int )(tmp___8 + 2UL));
#line 316
    button_display(& ok_button);
#line 317
    tmp___9 = strlen((char const   *)ok_button.text);
#line 317
    mybox(ok_button.y - 1, ok_button.x - 1, 3, (int )(tmp___9 + 2UL));
#line 320
    header((char *)"Play a sound file");
#line 321
    helpline(helplines[focus]);
    }
#line 324
    if (focus == 1) {
      {
#line 325
      stringinput_display(& trackstring);
      }
    } else
#line 326
    if (focus == 3) {
      {
#line 327
      stringinput_display(& begintimestring);
      }
    } else
#line 328
    if (focus == 4) {
      {
#line 329
      stringinput_display(& endtimestring);
      }
    } else
#line 330
    if (focus == 5) {
      {
#line 331
      stringinput_display(& string);
      }
    } else {
      {
#line 333
      wmove(stdscr, 0, 79);
      }
    }
    {
#line 335
    wrefresh(stdscr);
#line 337
    in_ch = wgetch(stdscr);
    }
    {
#line 341
    if (focus == 0) {
#line 341
      goto case_0;
    }
#line 412
    if (focus == 1) {
#line 412
      goto case_1;
    }
#line 474
    if (focus == 2) {
#line 474
      goto case_2;
    }
#line 496
    if (focus == 3) {
#line 496
      goto case_3;
    }
#line 529
    if (focus == 4) {
#line 529
      goto case_4;
    }
#line 563
    if (focus == 5) {
#line 563
      goto case_5;
    }
#line 626
    if (focus == 6) {
#line 626
      goto case_6;
    }
#line 646
    if (focus == 7) {
#line 646
      goto case_7;
    }
#line 339
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 342
    tmp___14 = scrollmenu_stdkeys(in_ch, & dirfilelist);
    }
#line 342
    if (tmp___14 >= 0) {
      {
#line 344
      oldselected = dirfilelist.selected;
#line 345
      i = dirfilemenu_process_select(& dirfilelist, helpstring);
      }
#line 347
      if (i == 0) {
        {
#line 349
        strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)(helpstring));
#line 350
        focus = 7;
#line 351
        tmp___10 = strlen((char const   *)string.string);
#line 351
        string.cursorpos = (int )tmp___10;
#line 352
        string.firstcharonscreen = 0;
#line 354
        tmp___13 = stat((char const   */* __restrict  */)(helpstring), (struct stat */* __restrict  */)(& buf));
        }
#line 354
        if (! tmp___13) {
#line 356
          *begintime___0 = (double )0;
#line 357
          if ((unsigned long )buf.st_size < sizeof(wavhead )) {
#line 358
            *endtime___0 = (double )0;
          } else {
#line 360
            *endtime___0 = (double )((unsigned long )buf.st_size - sizeof(wavhead )) / ((double )4 * 44100.);
          }
          {
#line 363
          fsec2hmsf(*begintime___0, begintimestring.string);
#line 364
          tmp___11 = strlen((char const   *)begintimestring.string);
#line 364
          begintimestring.cursorpos = (int )tmp___11;
#line 366
          begintimestring.firstcharonscreen = 0;
#line 368
          fsec2hmsf(*endtime___0, endtimestring.string);
#line 369
          tmp___12 = strlen((char const   *)endtimestring.string);
#line 369
          endtimestring.cursorpos = (int )tmp___12;
#line 370
          endtimestring.firstcharonscreen = 0;
          }
        }
      } else {
        {
#line 376
        scrollmenu_delete_menu(& dirfilelist);
#line 377
        dirfilemenu(helpstring, & dirfilelist);
        }
#line 378
        if (dirfilelist.number == 0) {
          {
#line 380
          error_window((char *)"No permission to read this directory.");
#line 382
          scrollmenu_delete_menu(& dirfilelist);
#line 383
          dirfilemenu(startdir, & dirfilelist);
#line 384
          dirfilelist.selected = oldselected;
          }
        } else {
          {
#line 388
          strcpy((char */* __restrict  */)startdir, (char const   */* __restrict  */)(helpstring));
#line 389
          dirfilelist.firstonscreen = 0;
#line 391
          charpointer = strrchr((char const   *)string.string, '/');
          }
#line 392
          if ((unsigned long )charpointer != (unsigned long )((void *)0)) {
            {
#line 393
            strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)(charpointer + 1));
            }
          } else {
            {
#line 395
            strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)string.string);
            }
          }
          {
#line 396
          strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)(helpstring));
          }
        }
      }
    } else {
      {
#line 403
      if (in_ch == 260) {
#line 403
        goto case_260;
      }
#line 406
      if (in_ch == 261) {
#line 406
        goto case_261;
      }
#line 401
      goto switch_break___0;
      case_260: /* CIL Label */ 
#line 404
      focus --;
#line 405
      goto switch_break___0;
      case_261: /* CIL Label */ 
#line 407
      focus ++;
#line 408
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 410
    goto switch_break;
    case_1: /* CIL Label */ 
#line 414
    if (in_ch >= 48) {
#line 414
      if (in_ch <= 57) {
        {
#line 415
        stringinput_stdkeys(in_ch, & trackstring);
        }
      } else {
#line 414
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 414
    if (in_ch > 127) {
      {
#line 415
      stringinput_stdkeys(in_ch, & trackstring);
      }
    }
    {
#line 417
    templong = atol((char const   *)trackstring.string);
    }
    {
#line 422
    if (in_ch == 13) {
#line 422
      goto case_13;
    }
#line 422
    if (in_ch == 343) {
#line 422
      goto case_13;
    }
#line 427
    if (in_ch == 66) {
#line 427
      goto case_66;
    }
#line 427
    if (in_ch == 98) {
#line 427
      goto case_66;
    }
#line 432
    if (in_ch == 69) {
#line 432
      goto case_69;
    }
#line 432
    if (in_ch == 101) {
#line 432
      goto case_69;
    }
#line 437
    if (in_ch == 70) {
#line 437
      goto case_70;
    }
#line 437
    if (in_ch == 102) {
#line 437
      goto case_70;
    }
#line 442
    if (in_ch == 65) {
#line 442
      goto case_65;
    }
#line 442
    if (in_ch == 97) {
#line 442
      goto case_65;
    }
#line 447
    if (in_ch == 61) {
#line 447
      goto case_61;
    }
#line 447
    if (in_ch == 43) {
#line 447
      goto case_61;
    }
#line 456
    if (in_ch == 95) {
#line 456
      goto case_95;
    }
#line 456
    if (in_ch == 45) {
#line 456
      goto case_95;
    }
#line 464
    if (in_ch == 259) {
#line 464
      goto case_259;
    }
#line 467
    if (in_ch == 258) {
#line 467
      goto case_258;
    }
#line 419
    goto switch_break___1;
    case_13: /* CIL Label */ 
    case_343: /* CIL Label */ 
    {
#line 423
    playwav_track(string.string, (int )templong, 1);
    }
#line 424
    goto switch_break___1;
    case_66: /* CIL Label */ 
    case_98: /* CIL Label */ 
    {
#line 428
    playwav_track(string.string, (int )templong, 2);
    }
#line 429
    goto switch_break___1;
    case_69: /* CIL Label */ 
    case_101: /* CIL Label */ 
    {
#line 433
    playwav_track(string.string, (int )templong, 3);
    }
#line 434
    goto switch_break___1;
    case_70: /* CIL Label */ 
    case_102: /* CIL Label */ 
    {
#line 438
    playwav_track(string.string, (int )templong, 4);
    }
#line 439
    goto switch_break___1;
    case_65: /* CIL Label */ 
    case_97: /* CIL Label */ 
    {
#line 443
    playwav_track(string.string, (int )templong, 5);
    }
#line 444
    goto switch_break___1;
    case_61: /* CIL Label */ 
    case_43: /* CIL Label */ 
#line 448
    if (templong < 99L) {
#line 449
      templong ++;
    }
    {
#line 450
    sprintf((char */* __restrict  */)trackstring.string, (char const   */* __restrict  */)"%ld",
            templong);
#line 451
    tmp___15 = strlen((char const   *)trackstring.string);
#line 451
    trackstring.cursorpos = (int )tmp___15;
#line 452
    trackstring.firstcharonscreen = 0;
    }
#line 453
    goto switch_break___1;
    case_95: /* CIL Label */ 
    case_45: /* CIL Label */ 
#line 457
    if (templong > 1L) {
#line 458
      templong --;
    }
    {
#line 459
    sprintf((char */* __restrict  */)trackstring.string, (char const   */* __restrict  */)"%ld",
            templong);
#line 460
    tmp___16 = strlen((char const   *)trackstring.string);
#line 460
    trackstring.cursorpos = (int )tmp___16;
#line 461
    trackstring.firstcharonscreen = 0;
    }
#line 462
    goto switch_break___1;
    case_259: /* CIL Label */ 
#line 465
    focus --;
#line 466
    goto switch_break___1;
    case_258: /* CIL Label */ 
#line 468
    focus ++;
#line 469
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 472
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 481
    if (in_ch == 88) {
#line 481
      goto case_88;
    }
#line 481
    if (in_ch == 120) {
#line 481
      goto case_88;
    }
#line 481
    if (in_ch == 32) {
#line 481
      goto case_88;
    }
#line 481
    if (in_ch == 13) {
#line 481
      goto case_88;
    }
#line 481
    if (in_ch == 343) {
#line 481
      goto case_88;
    }
#line 486
    if (in_ch == 259) {
#line 486
      goto case_259___0;
    }
#line 486
    if (in_ch == 260) {
#line 486
      goto case_259___0;
    }
#line 490
    if (in_ch == 258) {
#line 490
      goto case_258___0;
    }
#line 490
    if (in_ch == 261) {
#line 490
      goto case_258___0;
    }
#line 475
    goto switch_break___2;
    case_88: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_13___0: /* CIL Label */ 
    case_343___0: /* CIL Label */ 
#line 482
    *usebeginendtime___0 = 1 - *usebeginendtime___0;
#line 483
    goto switch_break___2;
    case_259___0: /* CIL Label */ 
    case_260___0: /* CIL Label */ 
#line 487
    focus --;
#line 488
    goto switch_break___2;
    case_258___0: /* CIL Label */ 
    case_261___0: /* CIL Label */ 
#line 491
    focus ++;
#line 492
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 494
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 497
    stringinput_stdkeys(in_ch, & begintimestring);
    }
    {
#line 501
    if (in_ch == 13) {
#line 501
      goto case_13___1;
    }
#line 501
    if (in_ch == 343) {
#line 501
      goto case_13___1;
    }
#line 520
    if (in_ch == 259) {
#line 520
      goto case_259___1;
    }
#line 523
    if (in_ch == 258) {
#line 523
      goto case_258___1;
    }
#line 498
    goto switch_break___3;
    case_13___1: /* CIL Label */ 
    case_343___1: /* CIL Label */ 
    {
#line 502
    strcpy((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)begintimestring.string);
#line 503
    tmp___19 = hmsf2fsec(tempstring, & tempdouble);
    }
#line 503
    if (tmp___19) {
      {
#line 512
      *begintime___0 = tempdouble;
#line 513
      fsec2hmsf(tempdouble, begintimestring.string);
#line 514
      tmp___18 = strlen((char const   *)begintimestring.string);
#line 514
      begintimestring.cursorpos = (int )tmp___18;
#line 516
      focus ++;
      }
    } else {
      {
#line 505
      error_window((char *)"Enter the time in the format hours:minutes:seconds.fractions, for example 0:04:26.740");
#line 507
      tmp___17 = strlen((char const   *)begintimestring.string);
#line 507
      begintimestring.cursorpos = (int )tmp___17;
      }
    }
#line 518
    goto switch_break___3;
    case_259___1: /* CIL Label */ 
#line 521
    focus --;
#line 522
    goto switch_break___3;
    case_258___1: /* CIL Label */ 
#line 524
    focus ++;
#line 525
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 527
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 530
    stringinput_stdkeys(in_ch, & endtimestring);
    }
    {
#line 534
    if (in_ch == 13) {
#line 534
      goto case_13___2;
    }
#line 534
    if (in_ch == 343) {
#line 534
      goto case_13___2;
    }
#line 553
    if (in_ch == 259) {
#line 553
      goto case_259___2;
    }
#line 556
    if (in_ch == 258) {
#line 556
      goto case_258___2;
    }
#line 531
    goto switch_break___4;
    case_13___2: /* CIL Label */ 
    case_343___2: /* CIL Label */ 
    {
#line 535
    strcpy((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)endtimestring.string);
#line 536
    tmp___22 = hmsf2fsec(tempstring, & tempdouble);
    }
#line 536
    if (tmp___22) {
      {
#line 545
      *endtime___0 = tempdouble;
#line 546
      fsec2hmsf(tempdouble, endtimestring.string);
#line 547
      tmp___21 = strlen((char const   *)endtimestring.string);
#line 547
      endtimestring.cursorpos = (int )tmp___21;
#line 549
      focus = 5;
      }
    } else {
      {
#line 538
      error_window((char *)"Enter the time in the format hours:minutes:seconds.fractions, for example 0:04:26.740");
#line 540
      tmp___20 = strlen((char const   *)endtimestring.string);
#line 540
      endtimestring.cursorpos = (int )tmp___20;
      }
    }
#line 551
    goto switch_break___4;
    case_259___2: /* CIL Label */ 
#line 554
    focus --;
#line 555
    goto switch_break___4;
    case_258___2: /* CIL Label */ 
#line 557
    focus ++;
#line 558
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 560
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 564
    stringinput_stdkeys(in_ch, & string);
    }
#line 565
    if (in_ch == 343) {
#line 565
      goto _L___1;
    } else
#line 565
    if (in_ch == 13) {
      _L___1: /* CIL Label */ 
      {
#line 567
      strcpy((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)string.string);
      }
      {
#line 570
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 570
        tmp___24 = strlen((char const   *)(helpstring));
        }
#line 570
        if (tmp___24 > 0UL) {
          {
#line 570
          tmp___25 = strlen((char const   *)(helpstring));
          }
#line 570
          if (! ((int )helpstring[tmp___25 - 1UL] == 47)) {
#line 570
            goto while_break___0;
          }
        } else {
#line 570
          goto while_break___0;
        }
        {
#line 572
        tmp___23 = strlen((char const   *)(helpstring));
#line 572
        helpstring[tmp___23 - 1UL] = (char )'\000';
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 574
      strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)"/");
#line 576
      tmp___30 = stat((char const   */* __restrict  */)(helpstring), (struct stat */* __restrict  */)(& filestats));
      }
#line 576
      if (tmp___30) {
        _L___0: /* CIL Label */ 
        {
#line 592
        focus = 7;
#line 594
        tmp___29 = stat((char const   */* __restrict  */)string.string, (struct stat */* __restrict  */)(& buf));
        }
#line 594
        if (! tmp___29) {
#line 596
          *begintime___0 = (double )0;
#line 597
          if ((unsigned long )buf.st_size < sizeof(wavhead )) {
#line 598
            *endtime___0 = (double )0;
          } else {
#line 600
            *endtime___0 = (double )((unsigned long )buf.st_size - sizeof(wavhead )) / ((double )4 * 44100.);
          }
          {
#line 603
          fsec2hmsf(*begintime___0, begintimestring.string);
#line 604
          tmp___27 = strlen((char const   *)begintimestring.string);
#line 604
          begintimestring.cursorpos = (int )tmp___27;
#line 606
          begintimestring.firstcharonscreen = 0;
#line 608
          fsec2hmsf(*endtime___0, endtimestring.string);
#line 609
          tmp___28 = strlen((char const   *)endtimestring.string);
#line 609
          endtimestring.cursorpos = (int )tmp___28;
#line 610
          endtimestring.firstcharonscreen = 0;
          }
        }
      } else
#line 576
      if ((filestats.st_mode & 61440U) == 16384U) {
        {
#line 579
        strcpy((char */* __restrict  */)startdir, (char const   */* __restrict  */)(helpstring));
#line 580
        scrollmenu_delete_menu(& dirfilelist);
#line 581
        dirfilemenu(startdir, & dirfilelist);
#line 582
        dirfilelist.firstonscreen = 0;
#line 583
        dirfilelist.selected = dirfilelist.last_of_1st_part + 1;
#line 585
        strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)startdir);
#line 586
        tmp___26 = strlen((char const   *)string.string);
#line 586
        string.cursorpos = (int )tmp___26;
#line 587
        focus = 0;
        }
      } else {
#line 576
        goto _L___0;
      }
    } else {
      {
#line 617
      if (in_ch == 259) {
#line 617
        goto case_259___3;
      }
#line 620
      if (in_ch == 258) {
#line 620
        goto case_258___3;
      }
#line 615
      goto switch_break___5;
      case_259___3: /* CIL Label */ 
#line 618
      focus --;
#line 619
      goto switch_break___5;
      case_258___3: /* CIL Label */ 
#line 621
      focus ++;
#line 622
      goto switch_break___5;
      switch_break___5: /* CIL Label */ ;
      }
    }
#line 624
    goto switch_break;
    case_6: /* CIL Label */ 
#line 627
    if (in_ch == 343) {
#line 629
      returnval = 0;
#line 630
      dont_stop = 0;
    } else
#line 627
    if (in_ch == 13) {
#line 629
      returnval = 0;
#line 630
      dont_stop = 0;
    } else {
      {
#line 636
      if (in_ch == 259) {
#line 636
        goto case_259___4;
      }
#line 636
      if (in_ch == 260) {
#line 636
        goto case_259___4;
      }
#line 640
      if (in_ch == 258) {
#line 640
        goto case_258___4;
      }
#line 640
      if (in_ch == 261) {
#line 640
        goto case_258___4;
      }
#line 633
      goto switch_break___6;
      case_259___4: /* CIL Label */ 
      case_260___1: /* CIL Label */ 
#line 637
      focus --;
#line 638
      goto switch_break___6;
      case_258___4: /* CIL Label */ 
      case_261___1: /* CIL Label */ 
#line 641
      focus ++;
#line 642
      goto switch_break___6;
      switch_break___6: /* CIL Label */ ;
      }
    }
#line 644
    goto switch_break;
    case_7: /* CIL Label */ 
#line 647
    if (in_ch == 343) {
#line 647
      goto _L___2;
    } else
#line 647
    if (in_ch == 13) {
      _L___2: /* CIL Label */ 
      {
#line 649
      strcpy((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)begintimestring.string);
#line 650
      tmp___32 = hmsf2fsec(tempstring, & tempdouble);
      }
#line 650
      if (! tmp___32) {
        {
#line 652
        error_window((char *)"Enter the begin time in the format hours:minutes:seconds.fractions, for example 0:04:26.740");
#line 654
        tmp___31 = strlen((char const   *)begintimestring.string);
#line 654
        begintimestring.cursorpos = (int )tmp___31;
#line 656
        focus = 3;
        }
#line 657
        goto switch_break;
      }
      {
#line 660
      *begintime___0 = tempdouble;
#line 662
      strcpy((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)endtimestring.string);
#line 663
      tmp___34 = hmsf2fsec(tempstring, & tempdouble);
      }
#line 663
      if (! tmp___34) {
        {
#line 665
        error_window((char *)"Enter the end time in the format hours:minutes:seconds.fractions, for example 0:04:26.740");
#line 667
        tmp___33 = strlen((char const   *)endtimestring.string);
#line 667
        endtimestring.cursorpos = (int )tmp___33;
#line 669
        focus = 4;
        }
#line 670
        goto switch_break;
      }
#line 673
      *endtime___0 = tempdouble;
#line 675
      if (*begintime___0 > *endtime___0) {
        {
#line 677
        error_window((char *)"The begin time is larger than the end time.");
#line 678
        fsec2hmsf(*begintime___0, begintimestring.string);
#line 679
        tmp___35 = strlen((char const   *)begintimestring.string);
#line 679
        begintimestring.cursorpos = (int )tmp___35;
#line 681
        fsec2hmsf(*endtime___0, endtimestring.string);
#line 682
        tmp___36 = strlen((char const   *)endtimestring.string);
#line 682
        endtimestring.cursorpos = (int )tmp___36;
#line 684
        focus = 3;
        }
#line 685
        goto switch_break;
      }
      {
#line 688
      tmp___37 = checkfile(string.string);
      }
      {
#line 690
      if (tmp___37 == 1) {
#line 690
        goto case_1___0;
      }
#line 699
      if (tmp___37 == 2) {
#line 699
        goto case_2___0;
      }
#line 707
      if (tmp___37 == 4) {
#line 707
        goto case_4___0;
      }
#line 707
      if (tmp___37 == 3) {
#line 707
        goto case_4___0;
      }
#line 713
      goto switch_default;
      case_1___0: /* CIL Label */ 
      {
#line 695
      playwav_playit(string.string, *usebeginendtime___0, *begintime___0, *endtime___0);
      }
#line 697
      goto switch_break___7;
      case_2___0: /* CIL Label */ 
      {
#line 700
      error_window((char *)"The specified name is of a directory. A file name must be specified.");
#line 702
      tmp___38 = strlen((char const   *)string.string);
#line 702
      string.cursorpos = (int )tmp___38;
#line 703
      focus = 5;
      }
#line 704
      goto switch_break___7;
      case_4___0: /* CIL Label */ 
      case_3___0: /* CIL Label */ 
      {
#line 708
      error_window((char *)"The specified file does not exist.");
#line 709
      tmp___39 = strlen((char const   *)string.string);
#line 709
      string.cursorpos = (int )tmp___39;
#line 710
      focus = 5;
      }
#line 711
      goto switch_break___7;
      switch_default: /* CIL Label */ 
      {
#line 714
      error_window((char *)"Fell out of switch, playwav #1");
      }
#line 715
      goto switch_break___7;
      switch_break___7: /* CIL Label */ ;
      }
    } else {
      {
#line 723
      if (in_ch == 259) {
#line 723
        goto case_259___5;
      }
#line 723
      if (in_ch == 260) {
#line 723
        goto case_259___5;
      }
#line 727
      if (in_ch == 258) {
#line 727
        goto case_258___5;
      }
#line 727
      if (in_ch == 261) {
#line 727
        goto case_258___5;
      }
#line 720
      goto switch_break___8;
      case_259___5: /* CIL Label */ 
      case_260___2: /* CIL Label */ 
#line 724
      focus --;
#line 725
      goto switch_break___8;
      case_258___5: /* CIL Label */ 
      case_261___2: /* CIL Label */ 
#line 728
      focus ++;
#line 729
      goto switch_break___8;
      switch_break___8: /* CIL Label */ ;
      }
    }
#line 731
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 734
    if (in_ch == 9) {
#line 735
      focus ++;
    }
#line 737
    if (in_ch == 27) {
#line 738
      dont_stop = 0;
    }
#line 740
    if (focus > 7) {
#line 741
      focus = 0;
    }
#line 742
    if (focus < 0) {
#line 743
      focus = 7;
    }
#line 265
    if (! dont_stop) {
#line 265
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 747
  scrollmenu_delete_menu(& dirfilelist);
#line 748
  free((void *)string.string);
  }
#line 750
  return (returnval);
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/playwav.c"
void playwav_main(char *startdir ) 
{ 
  char filename[250] ;
  int usebeginendtime___0 ;
  double begintime___0 ;
  double endtime___0 ;
  int tmp ;

  {
#line 758
  usebeginendtime___0 = 0;
#line 759
  begintime___0 = (double )0;
#line 759
  endtime___0 = (double )0;
#line 761
  filename[0] = (char )'\000';
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 765
    tmp = playwav_select_file(startdir, filename, & usebeginendtime___0, & begintime___0,
                              & endtime___0);
    }
#line 765
    if (! tmp) {
#line 767
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 108 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
buffer_t init_buffer(long post_length , long pre_length ) ;
#line 110
void delete_buffer(buffer_t *buffer ) ;
#line 126
void advance_current_pos(buffer_t *buffer , int filterno ) ;
#line 128
void advance_current_pos_custom(buffer_t *buffer , sample_t (*fillfunc)(long offset ,
                                                                        long offset_zero ,
                                                                        parampointer_t parampointer ) ,
                                long offset_zero , parampointer_t parampointer ) ;
#line 147
short median(short *a , int n ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf.h"
void cond_median_param_defaults(parampointer_t parampointer ) ;
#line 20
void cond_median_param_screen(parampointer_t parampointer ) ;
#line 22
void init_cond_median_filter(int filterno , parampointer_t parampointer ) ;
#line 24
void delete_cond_median_filter(parampointer_t parampointer ) ;
#line 26
sample_t cond_median_filter(parampointer_t parampointer ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/yesnowindow.h"
int yesno_window(char *text , char *yestext , char *notext , int preselected ) ;
#line 776 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) labs)(long __x )  __attribute__((__const__)) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf.c"
void cond_median_param_defaults(parampointer_t parampointer ) 
{ 


  {
#line 63
  parampointer->postlength1 = 10L;
#line 64
  parampointer->prelength1 = 10L;
#line 65
  parampointer->postlength2 = 4L;
#line 66
  parampointer->prelength2 = 4L;
#line 67
  parampointer->postlength3 = 5L;
#line 68
  parampointer->prelength3 = 5L;
#line 69
  parampointer->int1 = 5;
#line 70
  parampointer->long1 = 2500L;
#line 73
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf.c"
void cond_median_param_screen(parampointer_t parampointer ) 
{ 
  stringinput_t medlengthstr ;
  stringinput_t rmslengthstr ;
  stringinput_t rmflengthstr ;
  stringinput_t decimatestr ;
  stringinput_t thresholdstr ;
  button_t ok_button ;
  button_t cancel_button ;
  button_t defaults_button ;
  int dont_stop ;
  int focus ;
  int in_ch ;
  int i ;
  long helplong ;
  char *helplines[8] ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 81
  dont_stop = 1;
#line 82
  focus = 0;
#line 87
  helplines[0] = (char *)" ^: no neat interpolation.              v: broad ticks not filtered out.       ";
#line 87
  helplines[1] = (char *)" ^: less ticks detected.                v: not all of tick interpolated.       ";
#line 87
  helplines[2] = (char *)" ^: bad following of dynamics.          v: less ticks detected.                ";
#line 87
  helplines[3] = (char *)" ^: bad following of dynamics.          v: less ticks detected.                ";
#line 87
  helplines[4] = (char *)" ^: only strong ticks detected.         v: music-ticks also filtered out.      ";
#line 87
  helplines[5] = (char *)" Discard changes.                                                              ";
#line 87
  helplines[6] = (char *)" Reset default values.                                                         ";
#line 87
  helplines[7] = (char *)" Accept changes.                                                               ";
#line 98
  medlengthstr.maxlen = 500;
#line 99
  tmp = malloc((unsigned long )medlengthstr.maxlen * sizeof(char ));
#line 99
  medlengthstr.string = (char *)tmp;
#line 101
  sprintf((char */* __restrict  */)medlengthstr.string, (char const   */* __restrict  */)"%ld",
          (parampointer->prelength1 + parampointer->postlength1) + 1L);
#line 103
  medlengthstr.y = 6;
#line 104
  medlengthstr.x = 57;
#line 105
  medlengthstr.w = 19;
#line 106
  medlengthstr.cursorpos = (int )strlen(medlengthstr.string);
#line 107
  medlengthstr.firstcharonscreen = 0;
#line 109
  rmslengthstr.maxlen = 500;
#line 110
  tmp___0 = malloc((unsigned long )rmslengthstr.maxlen * sizeof(char ));
#line 110
  rmslengthstr.string = (char *)tmp___0;
#line 112
  sprintf((char */* __restrict  */)rmslengthstr.string, (char const   */* __restrict  */)"%ld",
          (parampointer->prelength2 + parampointer->postlength2) + 1L);
#line 114
  rmslengthstr.y = 8;
#line 115
  rmslengthstr.x = 57;
#line 116
  rmslengthstr.w = 19;
#line 117
  rmslengthstr.cursorpos = (int )strlen(rmslengthstr.string);
#line 118
  rmslengthstr.firstcharonscreen = 0;
#line 120
  rmflengthstr.maxlen = 500;
#line 121
  tmp___1 = malloc((unsigned long )rmflengthstr.maxlen * sizeof(char ));
#line 121
  rmflengthstr.string = (char *)tmp___1;
#line 123
  sprintf((char */* __restrict  */)rmflengthstr.string, (char const   */* __restrict  */)"%ld",
          (parampointer->prelength3 + parampointer->postlength3) + 1L);
#line 125
  rmflengthstr.y = 10;
#line 126
  rmflengthstr.x = 57;
#line 127
  rmflengthstr.w = 19;
#line 128
  rmflengthstr.cursorpos = (int )strlen(rmflengthstr.string);
#line 129
  rmflengthstr.firstcharonscreen = 0;
#line 131
  decimatestr.maxlen = 500;
#line 132
  tmp___2 = malloc((unsigned long )decimatestr.maxlen * sizeof(char ));
#line 132
  decimatestr.string = (char *)tmp___2;
#line 134
  sprintf((char */* __restrict  */)decimatestr.string, (char const   */* __restrict  */)"%d",
          parampointer->int1);
#line 135
  decimatestr.y = 12;
#line 136
  decimatestr.x = 57;
#line 137
  decimatestr.w = 19;
#line 138
  decimatestr.cursorpos = (int )strlen(decimatestr.string);
#line 139
  decimatestr.firstcharonscreen = 0;
#line 141
  thresholdstr.maxlen = 500;
#line 142
  tmp___3 = malloc((unsigned long )thresholdstr.maxlen * sizeof(char ));
#line 142
  thresholdstr.string = (char *)tmp___3;
#line 144
  sprintf((char */* __restrict  */)thresholdstr.string, (char const   */* __restrict  */)"%ld",
          parampointer->long1);
#line 145
  thresholdstr.y = 14;
#line 146
  thresholdstr.x = 57;
#line 147
  thresholdstr.w = 19;
#line 148
  thresholdstr.cursorpos = (int )strlen(thresholdstr.string);
#line 149
  thresholdstr.firstcharonscreen = 0;
#line 151
  ok_button.text = (char *)" OK ";
#line 152
  ok_button.y = 20;
#line 153
  ok_button.x = 71;
#line 154
  ok_button.selected = 0;
#line 156
  cancel_button.text = (char *)" Cancel ";
#line 157
  cancel_button.y = 20;
#line 158
  cancel_button.x = 5;
#line 159
  cancel_button.selected = 0;
#line 161
  defaults_button.text = (char *)" Defaults ";
#line 162
  defaults_button.y = 20;
#line 163
  defaults_button.x = 36;
#line 164
  defaults_button.selected = 0;
#line 166
  clearscreen((char *)"Conditional Median Filter - Parameters");
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 170
    header((char *)"Conditional Median Filter - Parameters");
    }
#line 172
    if (focus == 5) {
#line 173
      cancel_button.selected = 1;
    } else {
#line 175
      cancel_button.selected = 0;
    }
#line 177
    if (focus == 6) {
#line 178
      defaults_button.selected = 1;
    } else {
#line 180
      defaults_button.selected = 0;
    }
#line 182
    if (focus == 7) {
#line 183
      ok_button.selected = 1;
    } else {
#line 185
      ok_button.selected = 0;
    }
    {
#line 187
    mvprintw(3, 2, "See the Signproc.txt file for the meaning of the parameters.");
#line 190
    stringinput_display(& medlengthstr);
#line 191
    mvprintw(medlengthstr.y, 2, "Number of samples for median to interpolate ticks:");
#line 194
    stringinput_display(& rmslengthstr);
#line 195
    mvprintw(rmslengthstr.y, 2, "Length of the RMS operation (samples):");
#line 198
    stringinput_display(& rmflengthstr);
#line 199
    mvprintw(rmflengthstr.y, 2, "Length of the recursive median operation (samples):");
#line 202
    stringinput_display(& decimatestr);
#line 203
    mvprintw(decimatestr.y, 2, "Decimation factor for the recursive median:");
#line 206
    stringinput_display(& thresholdstr);
#line 207
    mvprintw(thresholdstr.y, 2, "Threshold for tick detection (thousandths):");
#line 210
    button_display(& cancel_button);
#line 211
    tmp___4 = (int )strlen(cancel_button.text);
#line 211
    mybox(cancel_button.y - 1, cancel_button.x - 1, 3, tmp___4 + 2);
#line 213
    button_display(& defaults_button);
#line 214
    tmp___5 = (int )strlen(defaults_button.text);
#line 214
    mybox(defaults_button.y - 1, defaults_button.x - 1, 3, tmp___5 + 2);
#line 216
    button_display(& ok_button);
#line 217
    tmp___6 = (int )strlen(ok_button.text);
#line 217
    mybox(ok_button.y - 1, ok_button.x - 1, 3, tmp___6 + 2);
#line 220
    helpline(helplines[focus]);
    }
    {
#line 224
    if (focus == 0) {
#line 224
      goto case_0;
    }
#line 227
    if (focus == 1) {
#line 227
      goto case_1;
    }
#line 230
    if (focus == 2) {
#line 230
      goto case_2;
    }
#line 233
    if (focus == 3) {
#line 233
      goto case_3;
    }
#line 236
    if (focus == 4) {
#line 236
      goto case_4;
    }
#line 239
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 225
    stringinput_display(& medlengthstr);
    }
#line 226
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 228
    stringinput_display(& rmslengthstr);
    }
#line 229
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 231
    stringinput_display(& rmflengthstr);
    }
#line 232
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 234
    stringinput_display(& decimatestr);
    }
#line 235
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 237
    stringinput_display(& thresholdstr);
    }
#line 238
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 240
    wmove(stdscr, 0, 79);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 243
    wrefresh(stdscr);
#line 245
    in_ch = wgetch(stdscr);
    }
    {
#line 249
    if (focus == 0) {
#line 249
      goto case_0___0;
    }
#line 272
    if (focus == 1) {
#line 272
      goto case_1___0;
    }
#line 295
    if (focus == 2) {
#line 295
      goto case_2___0;
    }
#line 318
    if (focus == 3) {
#line 318
      goto case_3___0;
    }
#line 341
    if (focus == 4) {
#line 341
      goto case_4___0;
    }
#line 364
    if (focus == 5) {
#line 364
      goto case_5;
    }
#line 383
    if (focus == 6) {
#line 383
      goto case_6;
    }
#line 407
    if (focus == 7) {
#line 407
      goto case_7;
    }
#line 247
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 250
    stringinput_stdkeys(in_ch, & medlengthstr);
    }
    {
#line 254
    if (in_ch == 13) {
#line 254
      goto case_13;
    }
#line 254
    if (in_ch == 343) {
#line 254
      goto case_13;
    }
#line 263
    if (in_ch == 259) {
#line 263
      goto case_259;
    }
#line 266
    if (in_ch == 258) {
#line 266
      goto case_258;
    }
#line 251
    goto switch_break___1;
    case_13: /* CIL Label */ 
    case_343: /* CIL Label */ 
    {
#line 255
    i = sscanf((char const   */* __restrict  */)medlengthstr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 256
    if (i < 1) {
      {
#line 257
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else
#line 256
    if (helplong < 1L) {
      {
#line 257
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else
#line 256
    if (helplong % 2L == 0L) {
      {
#line 257
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else {
#line 260
      focus ++;
    }
#line 261
    goto switch_break___1;
    case_259: /* CIL Label */ 
#line 264
    focus --;
#line 265
    goto switch_break___1;
    case_258: /* CIL Label */ 
#line 267
    focus ++;
#line 268
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 270
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 273
    stringinput_stdkeys(in_ch, & rmslengthstr);
    }
    {
#line 277
    if (in_ch == 13) {
#line 277
      goto case_13___0;
    }
#line 277
    if (in_ch == 343) {
#line 277
      goto case_13___0;
    }
#line 286
    if (in_ch == 259) {
#line 286
      goto case_259___0;
    }
#line 289
    if (in_ch == 258) {
#line 289
      goto case_258___0;
    }
#line 274
    goto switch_break___2;
    case_13___0: /* CIL Label */ 
    case_343___0: /* CIL Label */ 
    {
#line 278
    i = sscanf((char const   */* __restrict  */)rmslengthstr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 279
    if (i < 1) {
      {
#line 280
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else
#line 279
    if (helplong < 1L) {
      {
#line 280
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else
#line 279
    if (helplong % 2L == 0L) {
      {
#line 280
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else {
#line 283
      focus ++;
    }
#line 284
    goto switch_break___2;
    case_259___0: /* CIL Label */ 
#line 287
    focus --;
#line 288
    goto switch_break___2;
    case_258___0: /* CIL Label */ 
#line 290
    focus ++;
#line 291
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 293
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 296
    stringinput_stdkeys(in_ch, & rmflengthstr);
    }
    {
#line 300
    if (in_ch == 13) {
#line 300
      goto case_13___1;
    }
#line 300
    if (in_ch == 343) {
#line 300
      goto case_13___1;
    }
#line 309
    if (in_ch == 259) {
#line 309
      goto case_259___1;
    }
#line 312
    if (in_ch == 258) {
#line 312
      goto case_258___1;
    }
#line 297
    goto switch_break___3;
    case_13___1: /* CIL Label */ 
    case_343___1: /* CIL Label */ 
    {
#line 301
    i = sscanf((char const   */* __restrict  */)rmflengthstr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 302
    if (i < 1) {
      {
#line 303
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else
#line 302
    if (helplong < 1L) {
      {
#line 303
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else
#line 302
    if (helplong % 2L == 0L) {
      {
#line 303
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else {
#line 306
      focus ++;
    }
#line 307
    goto switch_break___3;
    case_259___1: /* CIL Label */ 
#line 310
    focus --;
#line 311
    goto switch_break___3;
    case_258___1: /* CIL Label */ 
#line 313
    focus ++;
#line 314
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 316
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 319
    stringinput_stdkeys(in_ch, & decimatestr);
    }
    {
#line 323
    if (in_ch == 13) {
#line 323
      goto case_13___2;
    }
#line 323
    if (in_ch == 343) {
#line 323
      goto case_13___2;
    }
#line 332
    if (in_ch == 259) {
#line 332
      goto case_259___2;
    }
#line 335
    if (in_ch == 258) {
#line 335
      goto case_258___2;
    }
#line 320
    goto switch_break___4;
    case_13___2: /* CIL Label */ 
    case_343___2: /* CIL Label */ 
    {
#line 324
    i = sscanf((char const   */* __restrict  */)decimatestr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 325
    if (i < 1) {
      {
#line 326
      error_window((char *)"A whole number, greater than 0, must be specified.");
      }
    } else
#line 325
    if (helplong < 1L) {
      {
#line 326
      error_window((char *)"A whole number, greater than 0, must be specified.");
      }
    } else {
#line 329
      focus ++;
    }
#line 330
    goto switch_break___4;
    case_259___2: /* CIL Label */ 
#line 333
    focus --;
#line 334
    goto switch_break___4;
    case_258___2: /* CIL Label */ 
#line 336
    focus ++;
#line 337
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 339
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 342
    stringinput_stdkeys(in_ch, & thresholdstr);
    }
    {
#line 346
    if (in_ch == 13) {
#line 346
      goto case_13___3;
    }
#line 346
    if (in_ch == 343) {
#line 346
      goto case_13___3;
    }
#line 355
    if (in_ch == 259) {
#line 355
      goto case_259___3;
    }
#line 358
    if (in_ch == 258) {
#line 358
      goto case_258___3;
    }
#line 343
    goto switch_break___5;
    case_13___3: /* CIL Label */ 
    case_343___3: /* CIL Label */ 
    {
#line 347
    i = sscanf((char const   */* __restrict  */)thresholdstr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 348
    if (i < 1) {
      {
#line 349
      error_window((char *)"A whole number, greater than 1000, must be specified.");
      }
    } else
#line 348
    if (helplong < 1000L) {
      {
#line 349
      error_window((char *)"A whole number, greater than 1000, must be specified.");
      }
    } else {
#line 352
      focus = 7;
    }
#line 353
    goto switch_break___5;
    case_259___3: /* CIL Label */ 
#line 356
    focus --;
#line 357
    goto switch_break___5;
    case_258___3: /* CIL Label */ 
#line 359
    focus ++;
#line 360
    goto switch_break___5;
    switch_break___5: /* CIL Label */ ;
    }
#line 362
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
#line 368
    if (in_ch == 13) {
#line 368
      goto case_13___4;
    }
#line 368
    if (in_ch == 343) {
#line 368
      goto case_13___4;
    }
#line 373
    if (in_ch == 259) {
#line 373
      goto case_259___4;
    }
#line 373
    if (in_ch == 260) {
#line 373
      goto case_259___4;
    }
#line 377
    if (in_ch == 258) {
#line 377
      goto case_258___4;
    }
#line 377
    if (in_ch == 261) {
#line 377
      goto case_258___4;
    }
#line 365
    goto switch_break___6;
    case_13___4: /* CIL Label */ 
    case_343___4: /* CIL Label */ 
#line 369
    dont_stop = 0;
#line 370
    goto switch_break___6;
    case_259___4: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 374
    focus --;
#line 375
    goto switch_break___6;
    case_258___4: /* CIL Label */ 
    case_261: /* CIL Label */ 
#line 378
    focus ++;
#line 379
    goto switch_break___6;
    switch_break___6: /* CIL Label */ ;
    }
#line 381
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 387
    if (in_ch == 13) {
#line 387
      goto case_13___5;
    }
#line 387
    if (in_ch == 343) {
#line 387
      goto case_13___5;
    }
#line 397
    if (in_ch == 259) {
#line 397
      goto case_259___5;
    }
#line 397
    if (in_ch == 260) {
#line 397
      goto case_259___5;
    }
#line 401
    if (in_ch == 258) {
#line 401
      goto case_258___5;
    }
#line 401
    if (in_ch == 261) {
#line 401
      goto case_258___5;
    }
#line 384
    goto switch_break___7;
    case_13___5: /* CIL Label */ 
    case_343___5: /* CIL Label */ 
    {
#line 388
    tmp___7 = yesno_window((char *)"Restore default parameters?", (char *)" Yes ",
                           (char *)" No ", 0);
    }
#line 388
    if (tmp___7) {
      {
#line 391
      cond_median_param_defaults(parampointer);
#line 392
      dont_stop = 0;
      }
    }
#line 394
    goto switch_break___7;
    case_259___5: /* CIL Label */ 
    case_260___0: /* CIL Label */ 
#line 398
    focus --;
#line 399
    goto switch_break___7;
    case_258___5: /* CIL Label */ 
    case_261___0: /* CIL Label */ 
#line 402
    focus ++;
#line 403
    goto switch_break___7;
    switch_break___7: /* CIL Label */ ;
    }
#line 405
    goto switch_break___0;
    case_7: /* CIL Label */ 
    {
#line 411
    if (in_ch == 13) {
#line 411
      goto case_13___6;
    }
#line 411
    if (in_ch == 343) {
#line 411
      goto case_13___6;
    }
#line 485
    if (in_ch == 259) {
#line 485
      goto case_259___6;
    }
#line 485
    if (in_ch == 260) {
#line 485
      goto case_259___6;
    }
#line 489
    if (in_ch == 258) {
#line 489
      goto case_258___6;
    }
#line 489
    if (in_ch == 261) {
#line 489
      goto case_258___6;
    }
#line 408
    goto switch_break___8;
    case_13___6: /* CIL Label */ 
    case_343___6: /* CIL Label */ 
    {
#line 413
    i = sscanf((char const   */* __restrict  */)medlengthstr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 414
    if (i < 1) {
      {
#line 416
      error_window((char *)"A whole, odd number, greater than 0, must be specified as median length.");
#line 418
      medlengthstr.cursorpos = (int )strlen(medlengthstr.string);
#line 420
      focus = 0;
      }
#line 421
      goto switch_break___8;
    } else
#line 414
    if (helplong < 1L) {
      {
#line 416
      error_window((char *)"A whole, odd number, greater than 0, must be specified as median length.");
#line 418
      medlengthstr.cursorpos = (int )strlen(medlengthstr.string);
#line 420
      focus = 0;
      }
#line 421
      goto switch_break___8;
    } else
#line 414
    if (helplong % 2L == 0L) {
      {
#line 416
      error_window((char *)"A whole, odd number, greater than 0, must be specified as median length.");
#line 418
      medlengthstr.cursorpos = (int )strlen(medlengthstr.string);
#line 420
      focus = 0;
      }
#line 421
      goto switch_break___8;
    }
    {
#line 424
    parampointer->prelength1 = (helplong - 1L) / 2L;
#line 425
    parampointer->postlength1 = (helplong - 1L) / 2L;
#line 427
    i = sscanf((char const   */* __restrict  */)rmslengthstr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 428
    if (i < 1) {
      {
#line 430
      error_window((char *)"A whole, odd number, greater than 0, must be specified as RMS length.");
#line 432
      rmslengthstr.cursorpos = (int )strlen(rmslengthstr.string);
#line 434
      focus = 1;
      }
#line 435
      goto switch_break___8;
    } else
#line 428
    if (helplong < 1L) {
      {
#line 430
      error_window((char *)"A whole, odd number, greater than 0, must be specified as RMS length.");
#line 432
      rmslengthstr.cursorpos = (int )strlen(rmslengthstr.string);
#line 434
      focus = 1;
      }
#line 435
      goto switch_break___8;
    } else
#line 428
    if (helplong % 2L == 0L) {
      {
#line 430
      error_window((char *)"A whole, odd number, greater than 0, must be specified as RMS length.");
#line 432
      rmslengthstr.cursorpos = (int )strlen(rmslengthstr.string);
#line 434
      focus = 1;
      }
#line 435
      goto switch_break___8;
    }
    {
#line 438
    parampointer->prelength2 = (helplong - 1L) / 2L;
#line 439
    parampointer->postlength2 = (helplong - 1L) / 2L;
#line 441
    i = sscanf((char const   */* __restrict  */)rmflengthstr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 442
    if (i < 1) {
      {
#line 444
      error_window((char *)"A whole, odd number, greater than 0, must be specified as length of the recursive median.");
#line 446
      rmflengthstr.cursorpos = (int )strlen(rmflengthstr.string);
#line 448
      focus = 2;
      }
#line 449
      goto switch_break___8;
    } else
#line 442
    if (helplong < 1L) {
      {
#line 444
      error_window((char *)"A whole, odd number, greater than 0, must be specified as length of the recursive median.");
#line 446
      rmflengthstr.cursorpos = (int )strlen(rmflengthstr.string);
#line 448
      focus = 2;
      }
#line 449
      goto switch_break___8;
    } else
#line 442
    if (helplong % 2L == 0L) {
      {
#line 444
      error_window((char *)"A whole, odd number, greater than 0, must be specified as length of the recursive median.");
#line 446
      rmflengthstr.cursorpos = (int )strlen(rmflengthstr.string);
#line 448
      focus = 2;
      }
#line 449
      goto switch_break___8;
    }
    {
#line 452
    parampointer->prelength3 = (helplong - 1L) / 2L;
#line 453
    parampointer->postlength3 = (helplong - 1L) / 2L;
#line 455
    i = sscanf((char const   */* __restrict  */)decimatestr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 456
    if (i < 1) {
      {
#line 458
      error_window((char *)"A whole number, greater than 0, must be specified as decimation factor.");
#line 460
      decimatestr.cursorpos = (int )strlen(decimatestr.string);
#line 462
      focus = 3;
      }
#line 463
      goto switch_break___8;
    } else
#line 456
    if (helplong < 1L) {
      {
#line 458
      error_window((char *)"A whole number, greater than 0, must be specified as decimation factor.");
#line 460
      decimatestr.cursorpos = (int )strlen(decimatestr.string);
#line 462
      focus = 3;
      }
#line 463
      goto switch_break___8;
    }
    {
#line 466
    parampointer->int1 = (int )helplong;
#line 468
    i = sscanf((char const   */* __restrict  */)thresholdstr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 469
    if (i < 1) {
      {
#line 471
      error_window((char *)"A whole number, greater than 1000, must be specified as threshold.");
#line 473
      thresholdstr.cursorpos = (int )strlen(thresholdstr.string);
#line 475
      focus = 4;
      }
#line 476
      goto switch_break___8;
    } else
#line 469
    if (helplong < 1000L) {
      {
#line 471
      error_window((char *)"A whole number, greater than 1000, must be specified as threshold.");
#line 473
      thresholdstr.cursorpos = (int )strlen(thresholdstr.string);
#line 475
      focus = 4;
      }
#line 476
      goto switch_break___8;
    }
#line 479
    parampointer->long1 = helplong;
#line 481
    dont_stop = 0;
#line 482
    goto switch_break___8;
    case_259___6: /* CIL Label */ 
    case_260___1: /* CIL Label */ 
#line 486
    focus --;
#line 487
    goto switch_break___8;
    case_258___6: /* CIL Label */ 
    case_261___1: /* CIL Label */ 
#line 490
    focus ++;
#line 491
    goto switch_break___8;
    switch_break___8: /* CIL Label */ ;
    }
#line 493
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 496
    if (in_ch == 9) {
#line 497
      focus ++;
    }
#line 499
    if (in_ch == 27) {
#line 500
      dont_stop = 0;
    }
#line 502
    if (focus > 7) {
#line 503
      focus = 0;
    }
#line 504
    if (focus < 0) {
#line 505
      focus = 7;
    }
#line 168
    if (! dont_stop) {
#line 168
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 509
  free((void *)medlengthstr.string);
#line 510
  free((void *)rmslengthstr.string);
#line 511
  free((void *)rmflengthstr.string);
#line 512
  free((void *)decimatestr.string);
#line 513
  free((void *)thresholdstr.string);
  }
#line 514
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf.c"
void init_cond_median_filter(int filterno , parampointer_t parampointer ) 
{ 
  long total_post ;
  long total_pre ;

  {
#line 522
  total_post = parampointer->postlength1;
#line 523
  if (parampointer->postlength2 > total_post) {
#line 524
    total_post = parampointer->postlength2;
  }
#line 526
  total_pre = parampointer->prelength1;
#line 527
  if ((parampointer->prelength2 + parampointer->prelength3 * (long )parampointer->int1) + 1L > total_pre) {
#line 529
    total_pre = (parampointer->prelength2 + parampointer->prelength3 * (long )parampointer->int1) + 1L;
  }
  {
#line 532
  parampointer->buffer = init_buffer(total_post, total_pre);
#line 533
  parampointer->buffer2 = init_buffer(parampointer->postlength2, parampointer->prelength2);
#line 535
  parampointer->buffer3 = init_buffer(parampointer->postlength3, parampointer->prelength3 * (long )parampointer->int1);
#line 538
  parampointer->filterno = filterno;
  }
#line 539
  return;
}
}
#line 542 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf.c"
void delete_cond_median_filter(parampointer_t parampointer ) 
{ 


  {
  {
#line 545
  delete_buffer(& parampointer->buffer);
#line 546
  delete_buffer(& parampointer->buffer2);
#line 547
  delete_buffer(& parampointer->buffer3);
  }
#line 548
  return;
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf.c"
sample_t cond_median_highpass(long offset , long offset_zero , parampointer_t parampointer ) 
{ 
  sample_t sample ;
  longsample_t sum ;

  {
#line 558
  offset += offset_zero;
#line 560
  sum.left = 0L;
#line 561
  sum.right = 0L;
#line 565
  sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + ((parampointer->buffer.currpos + offset) - 1L)));
#line 566
  sum.left += (long )sample.left;
#line 567
  sum.right += (long )sample.right;
#line 568
  sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + (parampointer->buffer.currpos + offset)));
#line 569
  sum.left -= 2L * (long )sample.left;
#line 570
  sum.right -= 2L * (long )sample.right;
#line 571
  sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + ((parampointer->buffer.currpos + offset) + 1L)));
#line 572
  sum.left += (long )sample.left;
#line 573
  sum.right += (long )sample.right;
#line 575
  sum.left /= 4L;
#line 576
  sum.right /= 4L;
#line 597
  sample.left = (short )sum.left;
#line 598
  sample.right = (short )sum.right;
#line 600
  return (sample);
}
}
#line 603 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf.c"
sample_t (*cond_median_highpass_pointer)(long offset , long offset_zero , parampointer_t parampointer )  =    & cond_median_highpass;
#line 605 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf.c"
sample_t cond_median_rms(long offset , long offset_zero , parampointer_t parampointer ) 
{ 
  sample_t sample ;
  doublesample_t doublesample ;
  doublesample_t sum ;
  long i ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 614
  advance_current_pos_custom(& parampointer->buffer2, cond_median_highpass_pointer,
                             offset + offset_zero, parampointer);
#line 619
  sum.left = (double )0;
#line 620
  sum.right = (double )0;
#line 622
  i = - parampointer->postlength2;
  }
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;
#line 622
    if (! (i <= parampointer->prelength2)) {
#line 622
      goto while_break;
    }
#line 625
    sample = *(parampointer->buffer2.array + *(parampointer->buffer2.indextable + (parampointer->buffer2.currpos + i)));
#line 626
    doublesample.left = (double )sample.left;
#line 627
    doublesample.right = (double )sample.right;
#line 628
    sum.left += doublesample.left * doublesample.left;
#line 629
    sum.right += doublesample.right * doublesample.right;
#line 622
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 632
  sum.left /= (double )((parampointer->postlength2 + parampointer->prelength2) + 1L);
#line 634
  sum.right /= (double )((parampointer->postlength2 + parampointer->prelength2) + 1L);
#line 637
  tmp = sqrt(sum.left + (double )1);
#line 637
  sample.left = (short )tmp;
#line 638
  tmp___0 = sqrt(sum.right + (double )1);
#line 638
  sample.right = (short )tmp___0;
  }
#line 640
  return (sample);
}
}
#line 643 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf.c"
sample_t (*cond_median_rms_pointer)(long offset , long offset_zero , parampointer_t parampointer )  =    & cond_median_rms;
#line 645 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf.c"
sample_t cond_median_filter(parampointer_t parampointer ) 
{ 
  sample_t sample ;
  sample_t w_t ;
  sample_t b_t ;
  sample_t returnval ;
  short *list1 ;
  unsigned long __lengthoflist1 ;
  void *tmp ;
  short *list2 ;
  unsigned long __lengthoflist2 ;
  void *tmp___0 ;
  short *list3 ;
  unsigned long __lengthoflist3 ;
  void *tmp___1 ;
  long i ;
  long j ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 652
  __lengthoflist1 = (unsigned long )((parampointer->postlength3 + parampointer->prelength3 * (long )parampointer->int1) + 1L);
#line 652
  tmp = __builtin_alloca(sizeof(*list1) * __lengthoflist1);
#line 652
  list1 = (short *)tmp;
#line 654
  __lengthoflist2 = (unsigned long )((parampointer->postlength3 + parampointer->prelength3 * (long )parampointer->int1) + 1L);
#line 654
  tmp___0 = __builtin_alloca(sizeof(*list2) * __lengthoflist2);
#line 654
  list2 = (short *)tmp___0;
#line 656
  __lengthoflist3 = (unsigned long )((parampointer->postlength1 + parampointer->prelength1) + 1L);
#line 656
  tmp___1 = __builtin_alloca(sizeof(*list3) * __lengthoflist3);
#line 656
  list3 = (short *)tmp___1;
#line 659
  advance_current_pos(& parampointer->buffer, parampointer->filterno);
#line 661
  advance_current_pos_custom(& parampointer->buffer3, cond_median_rms_pointer, 0L,
                             parampointer);
#line 666
  w_t = *(parampointer->buffer3.array + *(parampointer->buffer3.indextable + parampointer->buffer3.currpos));
#line 670
  i = 0L;
  }
  {
#line 670
  while (1) {
    while_continue: /* CIL Label */ ;
#line 670
    if (! (i < parampointer->postlength3)) {
#line 670
      goto while_break;
    }
#line 672
    sample = *(parampointer->buffer3.array + *(parampointer->buffer3.indextable + ((parampointer->buffer3.currpos + i) - parampointer->postlength3)));
#line 674
    *(list1 + i) = sample.left;
#line 675
    *(list2 + i) = sample.right;
#line 670
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  j = i;
  {
#line 680
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 680
    if (! (i <= parampointer->postlength3 + parampointer->prelength3 * (long )parampointer->int1)) {
#line 680
      goto while_break___0;
    }
#line 684
    sample = *(parampointer->buffer3.array + *(parampointer->buffer3.indextable + ((parampointer->buffer3.currpos + i) - parampointer->postlength3)));
#line 686
    *(list1 + j) = sample.left;
#line 687
    *(list2 + j) = sample.right;
#line 688
    j ++;
#line 680
    i += (long )parampointer->int1;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 691
  b_t.left = median(list1, (int )j);
#line 692
  b_t.right = median(list2, (int )j);
#line 694
  *(parampointer->buffer3.array + *(parampointer->buffer3.indextable + parampointer->buffer3.currpos)) = b_t;
#line 710
  returnval = *(parampointer->buffer.array + *(parampointer->buffer.indextable + parampointer->buffer.currpos));
#line 714
  tmp___2 = labs((long )((int )w_t.left - (int )b_t.left));
  }
#line 714
  if ((tmp___2 * 1000L) / (long )b_t.left > parampointer->long1) {
#line 719
    i = 0L;
    {
#line 719
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 719
      if (! (i <= parampointer->postlength1 + parampointer->prelength1)) {
#line 719
        goto while_break___1;
      }
#line 721
      *(list3 + i) = (parampointer->buffer.array + *(parampointer->buffer.indextable + ((parampointer->buffer.currpos + i) - parampointer->postlength1)))->left;
#line 719
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 724
    returnval.left = median(list3, (int )((parampointer->postlength1 + parampointer->prelength1) + 1L));
    }
  }
  {
#line 728
  tmp___3 = labs((long )((int )w_t.right - (int )b_t.right));
  }
#line 728
  if ((tmp___3 * 1000L) / (long )b_t.right > parampointer->long1) {
#line 733
    i = 0L;
    {
#line 733
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 733
      if (! (i <= parampointer->postlength1 + parampointer->prelength1)) {
#line 733
        goto while_break___2;
      }
#line 735
      *(list3 + i) = (parampointer->buffer.array + *(parampointer->buffer.indextable + ((parampointer->buffer.currpos + i) - parampointer->postlength1)))->right;
#line 733
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 738
    returnval.right = median(list3, (int )((parampointer->postlength1 + parampointer->prelength1) + 1L));
    }
  }
#line 744
  return (returnval);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/mainmenu.h"
void mainmenu(char *startdir ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/splashscr.h"
void splashscreen(void) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 511 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 711
extern int noecho(void) ;
#line 712
extern int nonl(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/gramofile.c"
void init_curses(void) 
{ 


  {
  {
#line 25
  initscr();
#line 26
  keypad(stdscr, (_Bool)1);
#line 27
  nonl();
#line 28
  cbreak();
#line 29
  noecho();
#line 33
  wrefresh(stdscr);
  }
#line 35
  return;
}
}
#line 42
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/gramofile.c"
static void finishmenu(int sig ) 
{ 


  {
  {
#line 41
  endwin();
#line 42
  exit(0);
  }
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/gramofile.c"
void main(void) 
{ 
  char startdir[250] ;
  char *helpcharptr ;

  {
  {
#line 51
  signal(2, & finishmenu);
#line 53
  init_curses();
#line 55
  splashscreen();
#line 57
  helpcharptr = getcwd(startdir, (size_t )250);
  }
#line 58
  if ((unsigned long )helpcharptr == (unsigned long )((void *)0)) {
    {
#line 59
    strcpy((char */* __restrict  */)(startdir), (char const   */* __restrict  */)"/");
    }
  } else {
    {
#line 61
    strcat((char */* __restrict  */)(startdir), (char const   */* __restrict  */)"/");
    }
  }
  {
#line 63
  mainmenu(startdir);
#line 65
  finishmenu(0);
  }
#line 66
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_exper.h"
void experiment_param_defaults(parampointer_t parampointer ) ;
#line 18
void experiment_param_screen(parampointer_t parampointer ) ;
#line 20
void init_experiment_filter(int filterno , parampointer_t parampointer ) ;
#line 22
void delete_experiment_filter(parampointer_t parampointer ) ;
#line 24
sample_t experiment_filter(parampointer_t parampointer ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_exper.c"
void experiment_param_defaults(parampointer_t parampointer ) 
{ 


  {
#line 24
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_exper.c"
void experiment_param_screen(parampointer_t parampointer ) 
{ 


  {
  {
#line 29
  error_window((char *)"This is a filter with which you can experiment. The source code is in signpr_exper.c");
  }
#line 31
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_exper.c"
void init_experiment_filter(int filterno , parampointer_t parampointer ) 
{ 


  {
  {
#line 36
  parampointer->buffer = init_buffer(100L, 100L);
#line 38
  parampointer->filterno = filterno;
  }
#line 39
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_exper.c"
void delete_experiment_filter(parampointer_t parampointer ) 
{ 


  {
  {
#line 44
  delete_buffer(& parampointer->buffer);
  }
#line 45
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_exper.c"
sample_t experiment_filter(parampointer_t parampointer ) 
{ 
  sample_t sample ;
  longsample_t longsample ;

  {
  {
#line 55
  advance_current_pos(& parampointer->buffer, parampointer->filterno);
#line 63
  longsample.left = 0L;
#line 64
  longsample.right = 0L;
#line 67
  sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + (parampointer->buffer.currpos + -2L)));
#line 68
  longsample.left += (long )sample.left;
#line 69
  longsample.right += (long )sample.right;
#line 71
  sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + (parampointer->buffer.currpos + -1L)));
#line 72
  longsample.left += (long )(5 * (int )sample.left);
#line 73
  longsample.right += (long )(5 * (int )sample.right);
#line 75
  sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + parampointer->buffer.currpos));
#line 76
  longsample.left += (long )(13 * (int )sample.left);
#line 77
  longsample.right += (long )(13 * (int )sample.right);
#line 79
  sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + (parampointer->buffer.currpos + 1L)));
#line 80
  longsample.left += (long )(5 * (int )sample.left);
#line 81
  longsample.right += (long )(5 * (int )sample.right);
#line 83
  sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + (parampointer->buffer.currpos + 2L)));
#line 84
  longsample.left += (long )sample.left;
#line 85
  longsample.right += (long )sample.right;
#line 88
  sample.left = (short )(longsample.left / 25L);
#line 89
  sample.right = (short )(longsample.right / 25L);
  }
#line 92
  return (sample);
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/textwindow.h"
void display_textwin(char *text , int y , int x , int h , int w ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/yesnowindow.c"
int yesno_window(char *text , char *yestext , char *notext , int preselected ) 
{ 
  button_t yes_button ;
  button_t no_button ;
  int i ;
  int focus ;
  int tmp ;

  {
  {
#line 30
  yes_button.text = yestext;
#line 31
  yes_button.y = 13;
#line 32
  tmp = (int )strlen(yes_button.text);
#line 32
  yes_button.x = 59 - tmp;
#line 34
  yes_button.selected = 0;
#line 36
  no_button.text = notext;
#line 37
  no_button.y = 13;
#line 38
  no_button.x = 21;
#line 39
  no_button.selected = 0;
#line 41
  mybox(8, 19, 7, 42);
#line 43
  display_textwin((char *)"", 9, 20, 5, 40);
#line 45
  display_textwin(text, 9, 21, 5, 38);
#line 48
  focus = preselected;
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    yes_button.selected = 0;
#line 53
    no_button.selected = 0;
#line 54
    if (focus == 0) {
#line 55
      no_button.selected = 1;
    }
#line 56
    if (focus == 1) {
#line 57
      yes_button.selected = 1;
    }
    {
#line 59
    button_display(& yes_button);
#line 60
    button_display(& no_button);
#line 62
    wmove(stdscr, 0, 79);
#line 63
    wrefresh(stdscr);
    }
    {
#line 65
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 66
      i = wgetch(stdscr);
      }
#line 65
      if (i != 13) {
#line 65
        if (i != 343) {
#line 65
          if (i != 27) {
#line 65
            if (i != 260) {
#line 65
              if (i != 261) {
#line 65
                if (! (i != 9)) {
#line 65
                  goto while_break___0;
                }
              } else {
#line 65
                goto while_break___0;
              }
            } else {
#line 65
              goto while_break___0;
            }
          } else {
#line 65
            goto while_break___0;
          }
        } else {
#line 65
          goto while_break___0;
        }
      } else {
#line 65
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 72
    if (i == 260) {
#line 72
      goto case_260;
    }
#line 76
    if (i == 261) {
#line 76
      goto case_261;
    }
#line 80
    if (i == 9) {
#line 80
      goto case_9;
    }
#line 70
    goto switch_break;
    case_260: /* CIL Label */ 
#line 73
    focus = 0;
#line 74
    goto switch_break;
    case_261: /* CIL Label */ 
#line 77
    focus = 1;
#line 78
    goto switch_break;
    case_9: /* CIL Label */ 
#line 81
    focus = 1 - focus;
#line 82
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 50
    if (i != 13) {
#line 50
      if (i != 343) {
#line 50
        if (! (i != 27)) {
#line 50
          goto while_break;
        }
      } else {
#line 50
        goto while_break;
      }
    } else {
#line 50
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  wclear(stdscr);
#line 89
  wrefresh(stdscr);
  }
#line 91
  if (i == 27) {
#line 92
    return (0);
  } else {
#line 94
    return (focus);
  }
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/checkfile.h"
void strip_trailing_slashes(char *path ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/checkfile.c"
void strip_trailing_slashes(char *path ) 
{ 
  int last ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 29
  tmp = strlen((char const   *)path);
#line 29
  last = (int )(tmp - 1UL);
  }
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (last > 0) {
#line 30
      if (! ((int )*(path + last) == 47)) {
#line 30
        goto while_break;
      }
    } else {
#line 30
      goto while_break;
    }
#line 31
    tmp___0 = last;
#line 31
    last --;
#line 31
    *(path + tmp___0) = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 32
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/checkfile.c"
int checkfile(char *filename ) 
{ 
  struct stat buf ;
  int i ;
  char myfilename[250] ;
  char *slash ;
  int tmp ;

  {
  {
#line 43
  strip_trailing_slashes(filename);
#line 45
  i = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& buf));
  }
#line 47
  if (! i) {
#line 49
    if ((buf.st_mode & 61440U) == 16384U) {
      {
#line 51
      tmp = strcmp((char const   *)filename, "/");
      }
#line 51
      if (tmp) {
        {
#line 52
        strcat((char */* __restrict  */)filename, (char const   */* __restrict  */)"/");
        }
      }
#line 53
      return (2);
    } else {
#line 56
      return (1);
    }
  } else {
    {
#line 61
    strcpy((char */* __restrict  */)(myfilename), (char const   */* __restrict  */)filename);
#line 65
    slash = strrchr((char const   *)(myfilename), '/');
    }
#line 66
    if ((unsigned long )slash == (unsigned long )((void *)0)) {
      {
#line 67
      strcpy((char */* __restrict  */)(myfilename), (char const   */* __restrict  */)".");
      }
    } else {
      {
#line 71
      while (1) {
        while_continue: /* CIL Label */ ;
#line 71
        if ((unsigned long )slash > (unsigned long )(myfilename)) {
#line 71
          if (! ((int )*slash == 47)) {
#line 71
            goto while_break;
          }
        } else {
#line 71
          goto while_break;
        }
#line 72
        slash --;
      }
      while_break: /* CIL Label */ ;
      }
#line 73
      *(slash + 1) = (char)0;
    }
    {
#line 78
    i = stat((char const   */* __restrict  */)(myfilename), (struct stat */* __restrict  */)(& buf));
    }
#line 79
    if (! i) {
#line 81
      if ((buf.st_mode & 61440U) == 16384U) {
#line 82
        return (3);
      }
#line 84
      return (4);
    } else {
#line 87
      return (4);
    }
  }
}
}
#line 785 "/usr/include/curses.h"
extern int waddch(WINDOW * , chtype const    ) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 794
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 795
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/scrollmenu.c"
void scrollmenu_display(scrollmenu_t *menu ) 
{ 
  int i ;
  int j ;
  int x1 ;
  int y1 ;
  int tmp ;

  {
#line 24
  if (menu->selected >= menu->number) {
#line 25
    menu->selected = menu->number - 1;
  }
#line 27
  if (menu->selected < 0) {
#line 28
    menu->selected = 0;
  }
#line 29
  if (menu->selected < menu->firstonscreen) {
#line 30
    menu->firstonscreen = menu->selected;
  }
#line 31
  if (menu->selected >= menu->firstonscreen + menu->h) {
#line 32
    menu->firstonscreen = (menu->selected - menu->h) + 1;
  }
#line 34
  i = 0;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (i < menu->h)) {
#line 34
      goto while_break;
    }
#line 36
    if (menu->firstonscreen + i == menu->selected) {
#line 36
      if (menu->hasfocus) {
        {
#line 37
        wattr_on(stdscr, 1UL << 16, (void *)0);
        }
      }
    }
#line 39
    if (menu->firstonscreen + i < menu->number) {
      {
#line 40
      tmp = wmove(stdscr, menu->y + i, menu->x);
      }
#line 40
      if (! (tmp == -1)) {
        {
#line 40
        waddnstr(stdscr, (char const   *)*(menu->items + (menu->firstonscreen + i)),
                 menu->w);
        }
      }
    } else {
      {
#line 45
      wmove(stdscr, menu->y + i, menu->x);
      }
    }
#line 47
    if (stdscr) {
#line 47
      y1 = (int )stdscr->_cury;
    } else {
#line 47
      y1 = -1;
    }
#line 47
    if (stdscr) {
#line 47
      x1 = (int )stdscr->_curx;
    } else {
#line 47
      x1 = -1;
    }
#line 49
    j = x1;
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 49
      if (! (j < menu->x + menu->w)) {
#line 49
        goto while_break___0;
      }
      {
#line 50
      waddch(stdscr, (chtype const   )' ');
#line 49
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 52
    if (menu->firstonscreen + i == menu->selected) {
#line 52
      if (menu->hasfocus) {
        {
#line 53
        wattr_off(stdscr, 1UL << 16, (void *)0);
        }
      }
    }
#line 34
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  wmove(stdscr, (menu->y + menu->selected) - menu->firstonscreen, menu->x);
  }
#line 57
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/scrollmenu.c"
int scrollmenu_stdkeys(int key , scrollmenu_t *menu ) 
{ 
  int returnval ;

  {
#line 66
  returnval = -1;
  {
#line 72
  if (key == 259) {
#line 72
    goto case_259;
  }
#line 72
  if (key == 75) {
#line 72
    goto case_259;
  }
#line 72
  if (key == 107) {
#line 72
    goto case_259;
  }
#line 78
  if (key == 258) {
#line 78
    goto case_258;
  }
#line 78
  if (key == 74) {
#line 78
    goto case_258;
  }
#line 78
  if (key == 106) {
#line 78
    goto case_258;
  }
#line 82
  if (key == 338) {
#line 82
    goto case_338;
  }
#line 91
  if (key == 339) {
#line 91
    goto case_339;
  }
#line 99
  if (key == 343) {
#line 99
    goto case_343;
  }
#line 99
  if (key == 13) {
#line 99
    goto case_343;
  }
#line 68
  goto switch_break;
  case_259: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_107: /* CIL Label */ 
#line 73
  (menu->selected) --;
#line 74
  goto switch_break;
  case_258: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_106: /* CIL Label */ 
#line 79
  (menu->selected) ++;
#line 80
  goto switch_break;
  case_338: /* CIL Label */ 
#line 83
  if (menu->selected < (menu->firstonscreen + menu->h) - 1) {
#line 85
    menu->selected = (menu->firstonscreen + menu->h) - 1;
  } else {
#line 88
    menu->selected += menu->h - 1;
  }
#line 89
  goto switch_break;
  case_339: /* CIL Label */ 
#line 92
  if (menu->selected > menu->firstonscreen) {
#line 93
    menu->selected = menu->firstonscreen;
  } else {
#line 95
    menu->selected -= menu->h - 1;
  }
#line 96
  goto switch_break;
  case_343: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 100
  returnval = menu->selected;
#line 101
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 104
  if (menu->selected < 0) {
#line 105
    menu->selected = 0;
  }
#line 106
  if (menu->selected >= menu->number) {
#line 107
    menu->selected = menu->number - 1;
  }
#line 109
  return (returnval);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/scrollmenu.c"
void scrollmenu_delete_menu(scrollmenu_t *menu ) 
{ 
  int i ;

  {
#line 117
  if ((unsigned long )menu->items != (unsigned long )((void *)0)) {
#line 119
    i = 0;
    {
#line 119
    while (1) {
      while_continue: /* CIL Label */ ;
#line 119
      if (! (i < menu->number)) {
#line 119
        goto while_break;
      }
      {
#line 120
      free((void *)*(menu->items + i));
#line 119
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 122
    free((void *)menu->items);
#line 123
    menu->items = (char **)((void *)0);
    }
  }
#line 125
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_infilenm.h"
int signproc_select_infile(char *startdir , char *selectedfile ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_infilenm.c"
int signproc_select_infile(char *startdir , char *selectedfile ) 
{ 
  scrollmenu_t dirfilelist ;
  stringinput_t string ;
  button_t next_button ;
  button_t cancel_button ;
  int dont_stop ;
  int returnval ;
  int focus ;
  int in_ch ;
  int i ;
  char helpstring[500] ;
  char *charpointer ;
  struct stat filestats ;
  int oldselected ;
  char *helplines[4] ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;

  {
  {
#line 40
  dont_stop = 1;
#line 41
  returnval = 0;
#line 42
  focus = 1;
#line 50
  helplines[0] = (char *)" Select name of sound file to be processed.                     TAB: Next field";
#line 50
  helplines[1] = (char *)" Enter name of sound file to be processed.                      TAB: Next field";
#line 50
  helplines[2] = (char *)" Back to main menu.                                             TAB: Next field";
#line 50
  helplines[3] = (char *)" To Signal Processing - Filter Selection.                       TAB: Next field";
#line 57
  dirfilelist.y = 3;
#line 58
  dirfilelist.x = 5;
#line 59
  dirfilelist.h = 12;
#line 60
  dirfilelist.w = 32;
#line 61
  dirfilelist.firstonscreen = 0;
#line 62
  dirfilemenu(startdir, & dirfilelist);
#line 63
  dirfilelist.selected = dirfilelist.last_of_1st_part + 1;
#line 65
  string.maxlen = 500;
#line 66
  tmp = malloc((unsigned long )string.maxlen * sizeof(char ));
#line 66
  string.string = (char *)tmp;
  }
#line 67
  if ((int )*(selectedfile + 0) == 0) {
    {
#line 68
    strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)startdir);
    }
  } else {
    {
#line 70
    strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)selectedfile);
    }
  }
  {
#line 71
  string.y = 17;
#line 72
  string.x = 5;
#line 73
  string.w = 70;
#line 74
  tmp___0 = strlen((char const   *)string.string);
#line 74
  string.cursorpos = (int )tmp___0;
#line 75
  tmp___1 = strlen((char const   *)string.string);
#line 75
  string.firstcharonscreen = (int )((tmp___1 - (size_t )string.w) + 2UL);
  }
#line 76
  if (string.firstcharonscreen < 0) {
#line 77
    string.firstcharonscreen = 0;
  }
  {
#line 79
  next_button.text = (char *)" Next screen > ";
#line 80
  next_button.y = 20;
#line 81
  next_button.x = 60;
#line 82
  next_button.selected = 0;
#line 84
  cancel_button.text = (char *)" Cancel ";
#line 85
  cancel_button.y = 20;
#line 86
  cancel_button.x = 36;
#line 87
  cancel_button.selected = 0;
#line 89
  clearscreen((char *)"Signal Processing - Source File");
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (focus == 2) {
#line 94
      cancel_button.selected = 1;
    } else {
#line 96
      cancel_button.selected = 0;
    }
#line 98
    if (focus == 3) {
#line 99
      next_button.selected = 1;
    } else {
#line 101
      next_button.selected = 0;
    }
    {
#line 103
    dirfilelist.hasfocus = focus == 0;
#line 105
    scrollmenu_display(& dirfilelist);
#line 106
    mybox(dirfilelist.y - 1, dirfilelist.x - 1, dirfilelist.h + 2, dirfilelist.w + 2);
#line 108
    mvprintw(dirfilelist.y - 1, dirfilelist.x + 1, "Files and directories:");
#line 111
    stringinput_display(& string);
#line 112
    mybox(string.y - 1, string.x - 1, 3, string.w + 2);
#line 113
    mvprintw(string.y - 1, string.x + 1, "Source file name:");
#line 115
    button_display(& cancel_button);
#line 116
    tmp___2 = strlen((char const   *)cancel_button.text);
#line 116
    mybox(cancel_button.y - 1, cancel_button.x - 1, 3, (int )(tmp___2 + 2UL));
#line 118
    button_display(& next_button);
#line 119
    tmp___3 = strlen((char const   *)next_button.text);
#line 119
    mybox(next_button.y - 1, next_button.x - 1, 3, (int )(tmp___3 + 2UL));
#line 122
    helpline(helplines[focus]);
    }
#line 124
    if (focus == 1) {
      {
#line 125
      stringinput_display(& string);
      }
    } else {
      {
#line 127
      wmove(stdscr, 0, 79);
      }
    }
    {
#line 129
    wrefresh(stdscr);
#line 131
    in_ch = wgetch(stdscr);
    }
    {
#line 135
    if (focus == 0) {
#line 135
      goto case_0;
    }
#line 188
    if (focus == 1) {
#line 188
      goto case_1;
    }
#line 229
    if (focus == 2) {
#line 229
      goto case_2;
    }
#line 249
    if (focus == 3) {
#line 249
      goto case_3;
    }
#line 133
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 136
    tmp___5 = scrollmenu_stdkeys(in_ch, & dirfilelist);
    }
#line 136
    if (tmp___5 >= 0) {
      {
#line 138
      oldselected = dirfilelist.selected;
#line 139
      i = dirfilemenu_process_select(& dirfilelist, helpstring);
      }
#line 141
      if (i == 0) {
        {
#line 143
        strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)(helpstring));
#line 144
        focus = 1;
#line 145
        tmp___4 = strlen((char const   *)string.string);
#line 145
        string.cursorpos = (int )tmp___4;
#line 146
        string.firstcharonscreen = 0;
        }
      } else {
        {
#line 151
        scrollmenu_delete_menu(& dirfilelist);
#line 152
        dirfilemenu(helpstring, & dirfilelist);
        }
#line 153
        if (dirfilelist.number == 0) {
          {
#line 155
          error_window((char *)"No permission to read this directory.");
#line 157
          header((char *)"Signal Processing - Source File");
#line 158
          scrollmenu_delete_menu(& dirfilelist);
#line 159
          dirfilemenu(startdir, & dirfilelist);
#line 160
          dirfilelist.selected = oldselected;
          }
        } else {
          {
#line 164
          strcpy((char */* __restrict  */)startdir, (char const   */* __restrict  */)(helpstring));
#line 165
          dirfilelist.firstonscreen = 0;
#line 167
          charpointer = strrchr((char const   *)string.string, '/');
          }
#line 168
          if ((unsigned long )charpointer != (unsigned long )((void *)0)) {
            {
#line 169
            strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)(charpointer + 1));
            }
          } else {
            {
#line 171
            strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)string.string);
            }
          }
          {
#line 172
          strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)(helpstring));
          }
        }
      }
    } else {
      {
#line 179
      if (in_ch == 260) {
#line 179
        goto case_260;
      }
#line 182
      if (in_ch == 261) {
#line 182
        goto case_261;
      }
#line 177
      goto switch_break___0;
      case_260: /* CIL Label */ 
#line 180
      focus --;
#line 181
      goto switch_break___0;
      case_261: /* CIL Label */ 
#line 183
      focus ++;
#line 184
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 186
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 189
    stringinput_stdkeys(in_ch, & string);
    }
#line 190
    if (in_ch == 343) {
#line 190
      goto _L;
    } else
#line 190
    if (in_ch == 13) {
      _L: /* CIL Label */ 
      {
#line 192
      strcpy((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)string.string);
      }
      {
#line 195
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 195
        tmp___7 = strlen((char const   *)(helpstring));
        }
#line 195
        if (tmp___7 > 0UL) {
          {
#line 195
          tmp___8 = strlen((char const   *)(helpstring));
          }
#line 195
          if (! ((int )helpstring[tmp___8 - 1UL] == 47)) {
#line 195
            goto while_break___0;
          }
        } else {
#line 195
          goto while_break___0;
        }
        {
#line 197
        tmp___6 = strlen((char const   *)(helpstring));
#line 197
        helpstring[tmp___6 - 1UL] = (char )'\000';
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 199
      strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)"/");
#line 201
      tmp___10 = stat((char const   */* __restrict  */)(helpstring), (struct stat */* __restrict  */)(& filestats));
      }
#line 201
      if (tmp___10) {
#line 215
        focus = 3;
      } else
#line 201
      if ((filestats.st_mode & 61440U) == 16384U) {
        {
#line 204
        strcpy((char */* __restrict  */)startdir, (char const   */* __restrict  */)(helpstring));
#line 205
        scrollmenu_delete_menu(& dirfilelist);
#line 206
        dirfilemenu(startdir, & dirfilelist);
#line 207
        dirfilelist.firstonscreen = 0;
#line 208
        dirfilelist.selected = dirfilelist.last_of_1st_part + 1;
#line 210
        strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)startdir);
#line 211
        tmp___9 = strlen((char const   *)string.string);
#line 211
        string.cursorpos = (int )tmp___9;
#line 212
        focus = 0;
        }
      } else {
#line 215
        focus = 3;
      }
    } else {
      {
#line 220
      if (in_ch == 259) {
#line 220
        goto case_259;
      }
#line 223
      if (in_ch == 258) {
#line 223
        goto case_258;
      }
#line 218
      goto switch_break___1;
      case_259: /* CIL Label */ 
#line 221
      focus --;
#line 222
      goto switch_break___1;
      case_258: /* CIL Label */ 
#line 224
      focus ++;
#line 225
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
#line 227
    goto switch_break;
    case_2: /* CIL Label */ 
#line 230
    if (in_ch == 343) {
#line 232
      returnval = 0;
#line 233
      dont_stop = 0;
    } else
#line 230
    if (in_ch == 13) {
#line 232
      returnval = 0;
#line 233
      dont_stop = 0;
    } else {
      {
#line 239
      if (in_ch == 259) {
#line 239
        goto case_259___0;
      }
#line 239
      if (in_ch == 260) {
#line 239
        goto case_259___0;
      }
#line 243
      if (in_ch == 258) {
#line 243
        goto case_258___0;
      }
#line 243
      if (in_ch == 261) {
#line 243
        goto case_258___0;
      }
#line 236
      goto switch_break___2;
      case_259___0: /* CIL Label */ 
      case_260___0: /* CIL Label */ 
#line 240
      focus --;
#line 241
      goto switch_break___2;
      case_258___0: /* CIL Label */ 
      case_261___0: /* CIL Label */ 
#line 244
      focus ++;
#line 245
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    }
#line 247
    goto switch_break;
    case_3: /* CIL Label */ 
#line 250
    if (in_ch == 343) {
#line 250
      goto _L___0;
    } else
#line 250
    if (in_ch == 13) {
      _L___0: /* CIL Label */ 
      {
#line 251
      tmp___11 = checkfile(string.string);
      }
      {
#line 253
      if (tmp___11 == 1) {
#line 253
        goto case_1___0;
      }
#line 259
      if (tmp___11 == 2) {
#line 259
        goto case_2___0;
      }
#line 268
      if (tmp___11 == 4) {
#line 268
        goto case_4;
      }
#line 268
      if (tmp___11 == 3) {
#line 268
        goto case_4;
      }
#line 275
      goto switch_default;
      case_1___0: /* CIL Label */ 
      {
#line 254
      strcpy((char */* __restrict  */)selectedfile, (char const   */* __restrict  */)string.string);
#line 255
      returnval = 2;
#line 256
      dont_stop = 0;
      }
#line 257
      goto switch_break___3;
      case_2___0: /* CIL Label */ 
      {
#line 260
      error_window((char *)"The specified name is of a directory. A file name must be specified.");
#line 262
      header((char *)"Signal Processing - Source File");
#line 263
      tmp___12 = strlen((char const   *)string.string);
#line 263
      string.cursorpos = (int )tmp___12;
#line 264
      focus = 1;
      }
#line 265
      goto switch_break___3;
      case_4: /* CIL Label */ 
      case_3___0: /* CIL Label */ 
      {
#line 269
      error_window((char *)"The specified file does not exist.");
#line 270
      header((char *)"Signal Processing - Source File");
#line 271
      tmp___13 = strlen((char const   *)string.string);
#line 271
      string.cursorpos = (int )tmp___13;
#line 272
      focus = 1;
      }
#line 273
      goto switch_break___3;
      switch_default: /* CIL Label */ 
      {
#line 276
      error_window((char *)"Fell out of switch, signpr_infilenm #1");
#line 277
      header((char *)"Signal Processing - Source File");
      }
#line 278
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 284
      if (in_ch == 259) {
#line 284
        goto case_259___1;
      }
#line 284
      if (in_ch == 260) {
#line 284
        goto case_259___1;
      }
#line 288
      if (in_ch == 258) {
#line 288
        goto case_258___1;
      }
#line 288
      if (in_ch == 261) {
#line 288
        goto case_258___1;
      }
#line 281
      goto switch_break___4;
      case_259___1: /* CIL Label */ 
      case_260___1: /* CIL Label */ 
#line 285
      focus --;
#line 286
      goto switch_break___4;
      case_258___1: /* CIL Label */ 
      case_261___1: /* CIL Label */ 
#line 289
      focus ++;
#line 290
      goto switch_break___4;
      switch_break___4: /* CIL Label */ ;
      }
    }
#line 292
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 295
    if (in_ch == 9) {
#line 296
      focus ++;
    }
#line 298
    if (in_ch == 27) {
#line 299
      dont_stop = 0;
    }
#line 301
    if (focus > 3) {
#line 302
      focus = 0;
    }
#line 303
    if (focus < 0) {
#line 304
      focus = 3;
    }
#line 91
    if (! dont_stop) {
#line 91
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  scrollmenu_delete_menu(& dirfilelist);
#line 309
  free((void *)string.string);
  }
#line 311
  return (returnval);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
parampointer_t parampointerarray[50]  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
int filter_type[50]  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.h"
int number_of_filters  ;
#line 95
void write_sample_to_screen(sample_t data ) ;
#line 97
sample_t read_from_keyboard(void) ;
#line 136
void qsort2(short *a , int n ) ;
#line 152
void add_to_filterlist(scrollmenu_t *filtlist___0 , int *filtnumbers___0 , char **helptexts___0 ,
                       int filternumber , char *filtername , char *helptext ) ;
#line 156
void make_filterlist(scrollmenu_t *filtlist___0 , int *filtnumbers___0 , char **helptexts___0 ) ;
#line 162
sample_t get_sample_from_filter(int filterno ) ;
#line 167
void init_filters(void) ;
#line 169
void delete_filters(void) ;
#line 174
void param_defaults(parampointer_t parampointer , int filtertype ) ;
#line 179
void param_screen(parampointer_t parampointer , int filtertype ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_median.h"
void simple_median_param_defaults(parampointer_t parampointer ) ;
#line 20
void simple_median_param_screen(parampointer_t parampointer ) ;
#line 22
void init_simple_median_filter(int filterno , parampointer_t parampointer ) ;
#line 24
void delete_simple_median_filter(parampointer_t parampointer ) ;
#line 26
sample_t simple_median_filter(parampointer_t parampointer ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf2.h"
void cond_median2_param_defaults(parampointer_t parampointer ) ;
#line 20
void cond_median2_param_screen(parampointer_t parampointer ) ;
#line 22
void init_cond_median2_filter(int filterno , parampointer_t parampointer ) ;
#line 24
void delete_cond_median2_filter(parampointer_t parampointer ) ;
#line 26
sample_t cond_median2_filter(parampointer_t parampointer ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_mean.h"
void simple_mean_param_defaults(parampointer_t parampointer ) ;
#line 20
void simple_mean_param_screen(parampointer_t parampointer ) ;
#line 22
void init_simple_mean_filter(int filterno , parampointer_t parampointer ) ;
#line 24
void delete_simple_mean_filter(parampointer_t parampointer ) ;
#line 26
sample_t simple_mean_filter(parampointer_t parampointer ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_doubmed.h"
void double_median_param_defaults(parampointer_t parampointer ) ;
#line 20
void double_median_param_screen(parampointer_t parampointer ) ;
#line 22
void init_double_median_filter(int filterno , parampointer_t parampointer ) ;
#line 24
void delete_double_median_filter(parampointer_t parampointer ) ;
#line 26
sample_t double_median_filter(parampointer_t parampointer ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_rms.h"
void rms_param_defaults(parampointer_t parampointer ) ;
#line 20
void rms_param_screen(parampointer_t parampointer ) ;
#line 22
void init_rms_filter(int filterno , parampointer_t parampointer ) ;
#line 24
void delete_rms_filter(parampointer_t parampointer ) ;
#line 26
sample_t rms_filter(parampointer_t parampointer ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_copy.h"
void copyonly_param_defaults(parampointer_t parampointer ) ;
#line 18
void copyonly_param_screen(parampointer_t parampointer ) ;
#line 20
void init_copyonly_filter(int filterno , parampointer_t parampointer ) ;
#line 22
void delete_copyonly_filter(parampointer_t parampointer ) ;
#line 24
sample_t copyonly_filter(parampointer_t parampointer ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_mono.h"
void monoize_param_defaults(parampointer_t parampointer ) ;
#line 19
void monoize_param_screen(parampointer_t parampointer ) ;
#line 21
void init_monoize_filter(int filterno , parampointer_t parampointer ) ;
#line 23
void delete_monoize_filter(parampointer_t parampointer ) ;
#line 25
sample_t monoize_filter(parampointer_t parampointer ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 431
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
void write_sample_to_screen(sample_t data ) 
{ 


  {
  {
#line 36
  printf((char const   */* __restrict  */)"Output, left & right: %d %d\n", (int )data.left,
         (int )data.right);
  }
#line 37
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
sample_t read_from_keyboard(void) 
{ 
  sample_t inputsample ;
  int left ;
  int right ;

  {
  {
#line 46
  printf((char const   */* __restrict  */)"Please enter left & right sample: ");
#line 48
  scanf((char const   */* __restrict  */)"%d %d", & left, & right);
#line 50
  inputsample.left = (short )left;
#line 51
  inputsample.right = (short )right;
  }
#line 53
  return (inputsample);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
buffer_t init_buffer(long post_length , long pre_length ) 
{ 
  buffer_t newbuffer ;
  long bufferlength ;
  void *tmp ;
  int i ;
  int tablesize ;
  void *tmp___0 ;

  {
  {
#line 71
  bufferlength = (pre_length + post_length) + 1L;
#line 73
  tmp = malloc((unsigned long )bufferlength * sizeof(sample_t ));
#line 73
  newbuffer.array = (sample_t *)tmp;
#line 75
  newbuffer.currpos = -1L;
#line 76
  newbuffer.arraylength = bufferlength;
#line 77
  newbuffer.pre_length = pre_length;
#line 78
  newbuffer.post_length = post_length;
#line 83
  tablesize = (int )(bufferlength * 3L);
#line 84
  tmp___0 = malloc((unsigned long )tablesize * sizeof(int ));
#line 84
  newbuffer.indextable = (int *)tmp___0;
#line 86
  newbuffer.indextable += bufferlength;
#line 87
  i = (int )(- bufferlength);
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! ((long )i < 2L * bufferlength)) {
#line 87
      goto while_break;
    }
#line 89
    *(newbuffer.indextable + i) = (int )(((long )i + bufferlength) % bufferlength);
#line 87
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return (newbuffer);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
void delete_buffer(buffer_t *buffer ) 
{ 


  {
  {
#line 101
  free((void *)(buffer->indextable - buffer->arraylength));
#line 103
  buffer->arraylength = 0L;
#line 104
  buffer->pre_length = 0L;
#line 105
  buffer->post_length = 0L;
#line 106
  free((void *)buffer->array);
  }
#line 107
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
void advance_current_pos(buffer_t *buffer , int filterno ) 
{ 
  long i ;

  {
#line 162
  if (buffer->currpos < 0L) {
#line 164
    i = 0L;
    {
#line 164
    while (1) {
      while_continue: /* CIL Label */ ;
#line 164
      if (! (i <= buffer->post_length)) {
#line 164
        goto while_break;
      }
#line 167
      (buffer->array + i)->left = (short)0;
#line 168
      (buffer->array + i)->right = (short)0;
#line 164
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 171
    buffer->currpos = buffer->post_length;
#line 173
    i = 0L;
    {
#line 173
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 173
      if (! (i <= buffer->pre_length)) {
#line 173
        goto while_break___0;
      }
      {
#line 175
      *(buffer->array + (buffer->currpos + i)) = get_sample_from_filter(filterno - 1);
#line 173
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 182
    (buffer->currpos) ++;
#line 184
    if (buffer->currpos >= buffer->arraylength) {
#line 185
      buffer->currpos -= buffer->arraylength;
    }
#line 187
    i = buffer->currpos + buffer->pre_length;
#line 189
    if (i >= buffer->arraylength) {
#line 190
      i -= buffer->arraylength;
    }
    {
#line 192
    *(buffer->array + i) = get_sample_from_filter(filterno - 1);
    }
  }
#line 194
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
void advance_current_pos_custom(buffer_t *buffer , sample_t (*fillfunc)(long offset ,
                                                                        long offset_zero ,
                                                                        parampointer_t parampointer ) ,
                                long offset_zero , parampointer_t parampointer ) 
{ 
  long i ;

  {
#line 202
  if (buffer->currpos < 0L) {
#line 204
    i = 0L;
    {
#line 204
    while (1) {
      while_continue: /* CIL Label */ ;
#line 204
      if (! (i <= buffer->post_length)) {
#line 204
        goto while_break;
      }
#line 207
      (buffer->array + i)->left = (short)0;
#line 208
      (buffer->array + i)->right = (short)0;
#line 204
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 211
    buffer->currpos = buffer->post_length;
#line 213
    i = 0L;
    {
#line 213
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 213
      if (! (i <= buffer->pre_length)) {
#line 213
        goto while_break___0;
      }
      {
#line 215
      *(buffer->array + (buffer->currpos + i)) = (*fillfunc)(i, offset_zero, parampointer);
#line 213
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 222
    (buffer->currpos) ++;
#line 224
    if (buffer->currpos >= buffer->arraylength) {
#line 225
      buffer->currpos -= buffer->arraylength;
    }
#line 227
    i = buffer->currpos + buffer->pre_length;
#line 229
    if (i >= buffer->arraylength) {
#line 230
      i -= buffer->arraylength;
    }
    {
#line 232
    *(buffer->array + i) = (*fillfunc)(buffer->pre_length, offset_zero, parampointer);
    }
  }
#line 235
  return;
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
void qsort2(short *a , int n ) 
{ 
  int i ;
  int j ;
  short x ;
  short w ;

  {
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    i = 0;
#line 253
    j = n - 1;
#line 254
    x = *(a + j / 2);
    {
#line 255
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 257
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 257
        if (! ((int )*(a + i) < (int )x)) {
#line 257
          goto while_break___1;
        }
#line 258
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 259
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 259
        if (! ((int )*(a + j) > (int )x)) {
#line 259
          goto while_break___2;
        }
#line 260
        j --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 261
      if (i > j) {
#line 262
        goto while_break___0;
      }
#line 263
      w = *(a + i);
#line 264
      *(a + i) = *(a + j);
#line 265
      *(a + j) = w;
#line 255
      i ++;
#line 255
      j --;
#line 255
      if (! (i <= j)) {
#line 255
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 268
    if (j + 1 < n - i) {
#line 270
      if (j > 0) {
        {
#line 271
        qsort2(a, j + 1);
        }
      }
#line 272
      a += i;
#line 273
      n -= i;
    } else {
#line 277
      if (i < n - 1) {
        {
#line 278
        qsort2(a + i, n - i);
        }
      }
#line 279
      n = j + 1;
    }
#line 250
    if (! (n > 1)) {
#line 250
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  return;
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
void qsort2double(double *a , long n ) 
{ 
  long i ;
  long j ;
  double x ;
  double w ;

  {
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    i = 0L;
#line 297
    j = n - 1L;
#line 298
    x = *(a + j / 2L);
    {
#line 299
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 301
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 301
        if (! (*(a + i) < x)) {
#line 301
          goto while_break___1;
        }
#line 302
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 303
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 303
        if (! (*(a + j) > x)) {
#line 303
          goto while_break___2;
        }
#line 304
        j --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 305
      if (i > j) {
#line 306
        goto while_break___0;
      }
#line 307
      w = *(a + i);
#line 308
      *(a + i) = *(a + j);
#line 309
      *(a + j) = w;
#line 299
      i ++;
#line 299
      j --;
#line 299
      if (! (i <= j)) {
#line 299
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 312
    if (j + 1L < n - i) {
#line 314
      if (j > 0L) {
        {
#line 315
        qsort2double(a, j + 1L);
        }
      }
#line 316
      a += i;
#line 317
      n -= i;
    } else {
#line 321
      if (i < n - 1L) {
        {
#line 322
        qsort2double(a + i, n - i);
        }
      }
#line 323
      n = j + 1L;
    }
#line 294
    if (! (n > 1L)) {
#line 294
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  return;
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
short median(short *a , int n ) 
{ 
  int i ;
  int j ;
  int k ;
  short x ;
  short w ;
  short t1 ;
  short t2 ;
  int low ;
  int mid ;
  int high ;

  {
#line 354
  low = 0;
#line 355
  mid = n / 2;
#line 356
  high = n - 1;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! (high - low > 5)) {
#line 358
      goto while_break;
    }
#line 360
    i = low;
#line 361
    j = high;
#line 362
    t1 = *(a + i);
#line 363
    t2 = *(a + j);
#line 364
    if ((int )t1 > (int )t2) {
#line 366
      x = t1;
#line 367
      t1 = t2;
#line 368
      t2 = x;
    }
#line 370
    x = *(a + (low + high) / 2);
#line 371
    if ((int )x < (int )t1) {
#line 373
      x = t1;
    } else
#line 375
    if ((int )x > (int )t2) {
#line 377
      x = t2;
    }
    {
#line 379
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 381
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 381
        if (! ((int )*(a + i) < (int )x)) {
#line 381
          goto while_break___1;
        }
#line 382
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 383
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 383
        if (! ((int )*(a + j) > (int )x)) {
#line 383
          goto while_break___2;
        }
#line 384
        j --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 385
      if (i > j) {
#line 386
        goto while_break___0;
      }
#line 387
      w = *(a + i);
#line 388
      *(a + i) = *(a + j);
#line 389
      *(a + j) = w;
#line 379
      i ++;
#line 379
      j --;
#line 379
      if (! (i <= j)) {
#line 379
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 392
    if (i <= mid) {
#line 394
      low = i;
    } else {
#line 398
      high = j;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  i = low;
  {
#line 401
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 401
    if (! (i <= mid)) {
#line 401
      goto while_break___3;
    }
#line 403
    k = i;
#line 404
    w = *(a + i);
#line 405
    j = i + 1;
    {
#line 405
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 405
      if (! (j <= high)) {
#line 405
        goto while_break___4;
      }
#line 407
      if ((int )*(a + j) < (int )w) {
#line 409
        k = j;
#line 410
        w = *(a + j);
      }
#line 405
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 413
    if (k != i) {
#line 415
      *(a + k) = *(a + i);
#line 416
      *(a + i) = w;
    }
#line 401
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 419
  return (*(a + mid));
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
void add_to_filterlist(scrollmenu_t *filtlist___0 , int *filtnumbers___0 , char **helptexts___0 ,
                       int filternumber , char *filtername , char *helptext ) 
{ 


  {
#line 442
  *(filtlist___0->items + filtlist___0->number) = filtername;
#line 443
  *(filtnumbers___0 + filtlist___0->number) = filternumber;
#line 444
  *(helptexts___0 + filtlist___0->number) = helptext;
#line 446
  (filtlist___0->number) ++;
#line 447
  return;
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
void make_filterlist(scrollmenu_t *filtlist___0 , int *filtnumbers___0 , char **helptexts___0 ) 
{ 


  {
  {
#line 453
  filtlist___0->number = 0;
#line 455
  add_to_filterlist(filtlist___0, filtnumbers___0, helptexts___0, 7, (char *)"Copy Only",
                    (char *)"Do nothing - just copy the signal unchanged.");
#line 462
  add_to_filterlist(filtlist___0, filtnumbers___0, helptexts___0, 8, (char *)"Convert to mono",
                    (char *)"Average left & right signals.");
#line 469
  add_to_filterlist(filtlist___0, filtnumbers___0, helptexts___0, 1, (char *)"Simple Median Filter",
                    (char *)"Interpolate short ticks.");
#line 476
  add_to_filterlist(filtlist___0, filtnumbers___0, helptexts___0, 4, (char *)"Double Median Filter",
                    (char *)"Interpolate short ticks and correct interpolations.");
#line 483
  add_to_filterlist(filtlist___0, filtnumbers___0, helptexts___0, 2, (char *)"Simple Mean Filter",
                    (char *)"\'Smooth\' the signal by taking the mean of samples.");
#line 490
  add_to_filterlist(filtlist___0, filtnumbers___0, helptexts___0, 6, (char *)"RMS Filter",
                    (char *)"Compute the `running\' Root-Mean-Square of the signal.");
#line 497
  add_to_filterlist(filtlist___0, filtnumbers___0, helptexts___0, 3, (char *)"Conditional Median Filter",
                    (char *)"Remove ticks while not changing rest of signal.");
#line 504
  add_to_filterlist(filtlist___0, filtnumbers___0, helptexts___0, 5, (char *)"Conditional Median Filter II",
                    (char *)"Remove ticks while not changing rest of signal - Better.");
#line 511
  add_to_filterlist(filtlist___0, filtnumbers___0, helptexts___0, 9, (char *)"Experimenting Filter",
                    (char *)"The filter YOU are experimenting with (in signpr_exper.c)");
  }
#line 518
  return;
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
sample_t get_sample_from_filter(int filterno ) 
{ 
  sample_t tmp ;
  sample_t tmp___0 ;
  sample_t tmp___1 ;
  sample_t tmp___2 ;
  sample_t tmp___3 ;
  sample_t tmp___4 ;
  sample_t tmp___5 ;
  sample_t tmp___6 ;
  sample_t tmp___7 ;
  sample_t tmp___8 ;

  {
#line 525
  if (filterno == -1) {
    {
#line 526
    tmp = readsamplesource();
    }
#line 526
    return (tmp);
  } else {
    {
#line 530
    if (filter_type[filterno] == 1) {
#line 530
      goto case_1;
    }
#line 534
    if (filter_type[filterno] == 2) {
#line 534
      goto case_2;
    }
#line 538
    if (filter_type[filterno] == 3) {
#line 538
      goto case_3;
    }
#line 542
    if (filter_type[filterno] == 4) {
#line 542
      goto case_4;
    }
#line 546
    if (filter_type[filterno] == 5) {
#line 546
      goto case_5;
    }
#line 550
    if (filter_type[filterno] == 6) {
#line 550
      goto case_6;
    }
#line 554
    if (filter_type[filterno] == 7) {
#line 554
      goto case_7;
    }
#line 558
    if (filter_type[filterno] == 8) {
#line 558
      goto case_8;
    }
#line 562
    if (filter_type[filterno] == 9) {
#line 562
      goto case_9;
    }
#line 566
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 531
    tmp___0 = simple_median_filter(parampointerarray[filterno]);
    }
#line 531
    return (tmp___0);
#line 532
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 535
    tmp___1 = simple_mean_filter(parampointerarray[filterno]);
    }
#line 535
    return (tmp___1);
#line 536
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 539
    tmp___2 = cond_median_filter(parampointerarray[filterno]);
    }
#line 539
    return (tmp___2);
#line 540
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 543
    tmp___3 = double_median_filter(parampointerarray[filterno]);
    }
#line 543
    return (tmp___3);
#line 544
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 547
    tmp___4 = cond_median2_filter(parampointerarray[filterno]);
    }
#line 547
    return (tmp___4);
#line 548
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 551
    tmp___5 = rms_filter(parampointerarray[filterno]);
    }
#line 551
    return (tmp___5);
#line 552
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 555
    tmp___6 = copyonly_filter(parampointerarray[filterno]);
    }
#line 555
    return (tmp___6);
#line 556
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 559
    tmp___7 = monoize_filter(parampointerarray[filterno]);
    }
#line 559
    return (tmp___7);
#line 560
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 563
    tmp___8 = experiment_filter(parampointerarray[filterno]);
    }
#line 563
    return (tmp___8);
#line 564
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 567
    printf((char const   */* __restrict  */)"Error (get_sample_from_filter): wrong filter");
#line 568
    exit(2);
    }
#line 569
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 571
  return;
}
}
#line 575 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
void init_filters(void) 
{ 
  int i ;

  {
#line 580
  i = 0;
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! (i < number_of_filters)) {
#line 580
      goto while_break;
    }
    {
#line 583
    if (filter_type[i] == 0) {
#line 583
      goto case_0;
    }
#line 586
    if (filter_type[i] == 1) {
#line 586
      goto case_1;
    }
#line 590
    if (filter_type[i] == 2) {
#line 590
      goto case_2;
    }
#line 594
    if (filter_type[i] == 3) {
#line 594
      goto case_3;
    }
#line 598
    if (filter_type[i] == 4) {
#line 598
      goto case_4;
    }
#line 602
    if (filter_type[i] == 5) {
#line 602
      goto case_5;
    }
#line 606
    if (filter_type[i] == 6) {
#line 606
      goto case_6;
    }
#line 610
    if (filter_type[i] == 7) {
#line 610
      goto case_7;
    }
#line 614
    if (filter_type[i] == 8) {
#line 614
      goto case_8;
    }
#line 618
    if (filter_type[i] == 9) {
#line 618
      goto case_9;
    }
#line 622
    goto switch_default;
    case_0: /* CIL Label */ 
#line 584
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 587
    init_simple_median_filter(i, parampointerarray[i]);
    }
#line 588
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 591
    init_simple_mean_filter(i, parampointerarray[i]);
    }
#line 592
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 595
    init_cond_median_filter(i, parampointerarray[i]);
    }
#line 596
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 599
    init_double_median_filter(i, parampointerarray[i]);
    }
#line 600
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 603
    init_cond_median2_filter(i, parampointerarray[i]);
    }
#line 604
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 607
    init_rms_filter(i, parampointerarray[i]);
    }
#line 608
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 611
    init_copyonly_filter(i, parampointerarray[i]);
    }
#line 612
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 615
    init_monoize_filter(i, parampointerarray[i]);
    }
#line 616
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 619
    init_experiment_filter(i, parampointerarray[i]);
    }
#line 620
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 623
    printf((char const   */* __restrict  */)"Error (init_filters): wrong filter");
#line 624
    exit(2);
    }
#line 625
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 580
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 627
  return;
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
void delete_filters(void) 
{ 
  int i ;

  {
#line 636
  i = 0;
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (! (i < number_of_filters)) {
#line 636
      goto while_break;
    }
    {
#line 639
    if (filter_type[i] == 0) {
#line 639
      goto case_0;
    }
#line 642
    if (filter_type[i] == 1) {
#line 642
      goto case_1;
    }
#line 646
    if (filter_type[i] == 2) {
#line 646
      goto case_2;
    }
#line 650
    if (filter_type[i] == 3) {
#line 650
      goto case_3;
    }
#line 654
    if (filter_type[i] == 4) {
#line 654
      goto case_4;
    }
#line 658
    if (filter_type[i] == 5) {
#line 658
      goto case_5;
    }
#line 662
    if (filter_type[i] == 6) {
#line 662
      goto case_6;
    }
#line 666
    if (filter_type[i] == 7) {
#line 666
      goto case_7;
    }
#line 670
    if (filter_type[i] == 8) {
#line 670
      goto case_8;
    }
#line 674
    if (filter_type[i] == 9) {
#line 674
      goto case_9;
    }
#line 678
    goto switch_default;
    case_0: /* CIL Label */ 
#line 640
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 643
    delete_simple_median_filter(parampointerarray[i]);
    }
#line 644
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 647
    delete_simple_mean_filter(parampointerarray[i]);
    }
#line 648
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 651
    delete_cond_median_filter(parampointerarray[i]);
    }
#line 652
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 655
    delete_double_median_filter(parampointerarray[i]);
    }
#line 656
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 659
    delete_cond_median2_filter(parampointerarray[i]);
    }
#line 660
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 663
    delete_rms_filter(parampointerarray[i]);
    }
#line 664
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 667
    delete_copyonly_filter(parampointerarray[i]);
    }
#line 668
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 671
    delete_monoize_filter(parampointerarray[i]);
    }
#line 672
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 675
    delete_experiment_filter(parampointerarray[i]);
    }
#line 676
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 679
    printf((char const   */* __restrict  */)"Error (delete_filters): wrong filter");
#line 680
    exit(2);
    }
#line 681
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 636
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 683
  return;
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
void param_defaults(parampointer_t parampointer , int filtertype ) 
{ 


  {
  {
#line 692
  if (filtertype == 0) {
#line 692
    goto case_0;
  }
#line 695
  if (filtertype == 1) {
#line 695
    goto case_1;
  }
#line 699
  if (filtertype == 2) {
#line 699
    goto case_2;
  }
#line 703
  if (filtertype == 3) {
#line 703
    goto case_3;
  }
#line 707
  if (filtertype == 4) {
#line 707
    goto case_4;
  }
#line 711
  if (filtertype == 5) {
#line 711
    goto case_5;
  }
#line 715
  if (filtertype == 6) {
#line 715
    goto case_6;
  }
#line 719
  if (filtertype == 7) {
#line 719
    goto case_7;
  }
#line 723
  if (filtertype == 8) {
#line 723
    goto case_8;
  }
#line 727
  if (filtertype == 9) {
#line 727
    goto case_9;
  }
#line 731
  goto switch_default;
  case_0: /* CIL Label */ 
#line 693
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 696
  simple_median_param_defaults(parampointer);
  }
#line 697
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 700
  simple_mean_param_defaults(parampointer);
  }
#line 701
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 704
  cond_median_param_defaults(parampointer);
  }
#line 705
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 708
  double_median_param_defaults(parampointer);
  }
#line 709
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 712
  cond_median2_param_defaults(parampointer);
  }
#line 713
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 716
  rms_param_defaults(parampointer);
  }
#line 717
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 720
  copyonly_param_defaults(parampointer);
  }
#line 721
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 724
  monoize_param_defaults(parampointer);
  }
#line 725
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 728
  experiment_param_defaults(parampointer);
  }
#line 729
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 732
  printf((char const   */* __restrict  */)"Error (praram_defaults): wrong filter");
#line 733
  exit(2);
  }
#line 734
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 736
  return;
}
}
#line 740 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_general.c"
void param_screen(parampointer_t parampointer , int filtertype ) 
{ 


  {
  {
#line 745
  if (filtertype == 0) {
#line 745
    goto case_0;
  }
#line 748
  if (filtertype == 1) {
#line 748
    goto case_1;
  }
#line 752
  if (filtertype == 2) {
#line 752
    goto case_2;
  }
#line 756
  if (filtertype == 3) {
#line 756
    goto case_3;
  }
#line 760
  if (filtertype == 4) {
#line 760
    goto case_4;
  }
#line 764
  if (filtertype == 5) {
#line 764
    goto case_5;
  }
#line 768
  if (filtertype == 6) {
#line 768
    goto case_6;
  }
#line 772
  if (filtertype == 7) {
#line 772
    goto case_7;
  }
#line 776
  if (filtertype == 8) {
#line 776
    goto case_8;
  }
#line 780
  if (filtertype == 9) {
#line 780
    goto case_9;
  }
#line 784
  goto switch_default;
  case_0: /* CIL Label */ 
#line 746
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 749
  simple_median_param_screen(parampointer);
  }
#line 750
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 753
  simple_mean_param_screen(parampointer);
  }
#line 754
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 757
  cond_median_param_screen(parampointer);
  }
#line 758
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 761
  double_median_param_screen(parampointer);
  }
#line 762
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 765
  cond_median2_param_screen(parampointer);
  }
#line 766
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 769
  rms_param_screen(parampointer);
  }
#line 770
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 773
  copyonly_param_screen(parampointer);
  }
#line 774
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 777
  monoize_param_screen(parampointer);
  }
#line 778
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 781
  experiment_param_screen(parampointer);
  }
#line 782
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 785
  printf((char const   */* __restrict  */)"Error (praram_screen): wrong filter");
#line 786
  exit(2);
  }
#line 787
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 790
  wclear(stdscr);
#line 791
  wrefresh(stdscr);
  }
#line 792
  return;
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/errorwindow.c"
void error_window_display(char *text , char *buttontext ) 
{ 
  button_t ok_button ;
  int tmp ;

  {
  {
#line 26
  ok_button.text = buttontext;
#line 27
  ok_button.y = 13;
#line 28
  tmp = (int )strlen(ok_button.text);
#line 28
  ok_button.x = 59 - tmp;
#line 30
  ok_button.selected = 1;
#line 32
  mybox(8, 19, 7, 42);
#line 34
  display_textwin((char *)"", 9, 20, 5, 40);
#line 36
  display_textwin(text, 9, 21, 5, 38);
#line 38
  button_display(& ok_button);
#line 39
  wmove(stdscr, 0, 79);
#line 40
  wrefresh(stdscr);
  }
#line 41
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/errorwindow.c"
void error_window(char *text ) 
{ 
  int i ;

  {
  {
#line 49
  error_window_display(text, (char *)" OK ");
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 52
    i = wgetch(stdscr);
    }
#line 51
    if (i != 13) {
#line 51
      if (i != 343) {
#line 51
        if (! (i != 27)) {
#line 51
          goto while_break;
        }
      } else {
#line 51
        goto while_break;
      }
    } else {
#line 51
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  wclear(stdscr);
#line 56
  wrefresh(stdscr);
  }
#line 57
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.h"
int signproc_get_options(char *startdir , char *infilename , char *outfilename , scrollmenu_t *filtlist___0 ,
                         int *filtnumbers___0 , char **helptexts___0 , scrollmenu_t *selectedfilts___0 ,
                         int *usetracktimes___0 , int *usebeginendtime___0 , double *begintime___0 ,
                         double *endtime___0 ) ;
#line 34
void signproc_main(char *startdir ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_filtmenu.h"
int signproc_select_filters(scrollmenu_t *filtlist___0 , int *filtnumbers___0 , char **helptexts___0 ,
                            scrollmenu_t *selectedfilts___0 , int *usetracktimes___0 ,
                            int *usebeginendtime___0 , double *begintime___0 , double *endtime___0 ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_outfilenm.h"
int signproc_select_outfile(char *startdir , char *selectedfile ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_wav.h"
int seeksamplesource(long samplenumber ) ;
#line 34
int openwavdest(char *filename , long bcount ) ;
#line 37
void closewavdest(void) ;
#line 39
void writesampledest(sample_t sample ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 749 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
int signproc_get_options(char *startdir , char *infilename , char *outfilename , scrollmenu_t *filtlist___0 ,
                         int *filtnumbers___0 , char **helptexts___0 , scrollmenu_t *selectedfilts___0 ,
                         int *usetracktimes___0 , int *usebeginendtime___0 , double *begintime___0 ,
                         double *endtime___0 ) 
{ 
  int currscreen ;
  int options_ready ;
  int returnval ;
  char oldinfilename[250] ;
  struct stat buf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 38
  currscreen = 0;
#line 39
  options_ready = 0;
#line 40
  returnval = 0;
#line 44
  oldinfilename[0] = (char )'\000';
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 49
    if (currscreen == 0) {
#line 49
      goto case_0;
    }
#line 66
    if (currscreen == 1) {
#line 66
      goto case_1;
    }
#line 102
    if (currscreen == 2) {
#line 102
      goto case_2___1;
    }
#line 47
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 50
    tmp = signproc_select_infile(startdir, infilename);
    }
    {
#line 55
    if (tmp == 0) {
#line 55
      goto case_0___0;
    }
#line 59
    if (tmp == 2) {
#line 59
      goto case_2;
    }
#line 50
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 56
    options_ready = 1;
#line 57
    returnval = 0;
#line 58
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 60
    currscreen = 1;
#line 61
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 64
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 67
    tmp___0 = strcmp((char const   *)infilename, (char const   *)(oldinfilename));
    }
#line 67
    if (tmp___0) {
      {
#line 69
      strcpy((char */* __restrict  */)(oldinfilename), (char const   */* __restrict  */)infilename);
#line 70
      stat((char const   */* __restrict  */)infilename, (struct stat */* __restrict  */)(& buf));
      }
#line 71
      if ((unsigned long )buf.st_size < sizeof(wavhead )) {
#line 72
        *endtime___0 = (double )0;
      } else {
#line 74
        *endtime___0 = (double )((unsigned long )buf.st_size - sizeof(wavhead )) / ((double )4 * 44100.);
      }
#line 76
      *begintime___0 = (double )0;
    }
    {
#line 81
    tmp___1 = signproc_select_filters(filtlist___0, filtnumbers___0, helptexts___0,
                                      selectedfilts___0, usetracktimes___0, usebeginendtime___0,
                                      begintime___0, endtime___0);
    }
    {
#line 88
    if (tmp___1 == 0) {
#line 88
      goto case_0___1;
    }
#line 92
    if (tmp___1 == 1) {
#line 92
      goto case_1___0;
    }
#line 95
    if (tmp___1 == 2) {
#line 95
      goto case_2___0;
    }
#line 81
    goto switch_break___1;
    case_0___1: /* CIL Label */ 
#line 89
    options_ready = 1;
#line 90
    returnval = 0;
#line 91
    goto switch_break___1;
    case_1___0: /* CIL Label */ 
#line 93
    currscreen = 0;
#line 94
    goto switch_break___1;
    case_2___0: /* CIL Label */ 
#line 96
    currscreen = 2;
#line 97
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 100
    goto switch_break;
    case_2___1: /* CIL Label */ 
    {
#line 103
    tmp___2 = signproc_select_outfile(startdir, outfilename);
    }
    {
#line 108
    if (tmp___2 == 0) {
#line 108
      goto case_0___2;
    }
#line 112
    if (tmp___2 == 1) {
#line 112
      goto case_1___1;
    }
#line 115
    if (tmp___2 == 2) {
#line 115
      goto case_2___2;
    }
#line 103
    goto switch_break___2;
    case_0___2: /* CIL Label */ 
#line 109
    options_ready = 1;
#line 110
    returnval = 0;
#line 111
    goto switch_break___2;
    case_1___1: /* CIL Label */ 
#line 113
    currscreen = 1;
#line 114
    goto switch_break___2;
    case_2___2: /* CIL Label */ 
#line 116
    returnval = 1;
#line 117
    options_ready = 1;
#line 118
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 121
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 46
    if (! (! options_ready)) {
#line 46
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return (returnval);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
long totalsize_samples  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
long current_total_sample  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
long tracksize_samples  ;
#line 131 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
long current_sample  ;
#line 138 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
int load_track_times(char *filename , beginendsample_t *tracktimes , int *number_of_tracks ) 
{ 
  char tempstring[250] ;
  char tempstring2[250] ;
  FILE *tracksfile ;
  long tracks_pos ;
  int i ;
  double seconds ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;

  {
  {
#line 150
  strcpy((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)filename);
#line 151
  strcat((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)".tracks");
#line 153
  tracksfile = fopen((char const   */* __restrict  */)(tempstring), (char const   */* __restrict  */)"r");
  }
#line 155
  if ((unsigned long )tracksfile == (unsigned long )((void *)0)) {
#line 156
    return (0);
  }
#line 158
  tempstring[0] = (char )'\000';
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    tmp = feof(tracksfile);
    }
#line 159
    if (tmp) {
#line 159
      goto while_break;
    } else {
      {
#line 159
      tmp___0 = strlen("[Tracks]");
#line 159
      tmp___1 = strncasecmp((char const   *)(tempstring), "[Tracks]", tmp___0);
      }
#line 159
      if (! tmp___1) {
#line 159
        goto while_break;
      }
    }
    {
#line 161
    fgets((char */* __restrict  */)(tempstring), 250, (FILE */* __restrict  */)tracksfile);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 163
  tmp___2 = feof(tracksfile);
  }
#line 163
  if (tmp___2) {
    {
#line 168
    fclose(tracksfile);
    }
#line 169
    return (0);
  }
  {
#line 172
  tracks_pos = ftell(tracksfile);
#line 174
  tempstring[0] = (char )'\000';
  }
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 175
    tmp___3 = feof(tracksfile);
    }
#line 175
    if (tmp___3) {
#line 175
      goto while_break___0;
    } else {
      {
#line 175
      tmp___4 = strlen("Number_of_tracks=");
#line 175
      tmp___5 = strncasecmp((char const   *)(tempstring), "Number_of_tracks=", tmp___4);
      }
#line 175
      if (! tmp___5) {
#line 175
        goto while_break___0;
      }
    }
    {
#line 177
    fgets((char */* __restrict  */)(tempstring), 250, (FILE */* __restrict  */)tracksfile);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 179
  tmp___6 = strlen("Number_of_tracks=");
#line 179
  tmp___7 = strncasecmp((char const   *)(tempstring), "Number_of_tracks=", tmp___6);
  }
#line 179
  if (tmp___7) {
    {
#line 185
    fclose(tracksfile);
    }
#line 186
    return (0);
  }
  {
#line 189
  tmp___8 = strlen("Number_of_tracks=");
#line 189
  *number_of_tracks = atoi((char const   *)(tempstring + tmp___8));
  }
#line 191
  if (*number_of_tracks < 1) {
    {
#line 196
    fclose(tracksfile);
    }
#line 197
    return (0);
  } else
#line 191
  if (*number_of_tracks > 99) {
    {
#line 196
    fclose(tracksfile);
    }
#line 197
    return (0);
  }
#line 200
  i = 1;
  {
#line 200
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 200
    if (! (i <= *number_of_tracks)) {
#line 200
      goto while_break___1;
    }
    {
#line 202
    sprintf((char */* __restrict  */)(tempstring2), (char const   */* __restrict  */)"Track%02dstart=",
            i);
#line 203
    fseek(tracksfile, tracks_pos, 0);
#line 205
    tempstring[0] = (char )'\000';
    }
    {
#line 206
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 206
      tmp___9 = feof(tracksfile);
      }
#line 206
      if (tmp___9) {
#line 206
        goto while_break___2;
      } else {
        {
#line 206
        tmp___10 = strlen((char const   *)(tempstring2));
#line 206
        tmp___11 = strncasecmp((char const   *)(tempstring), (char const   *)(tempstring2),
                               tmp___10);
        }
#line 206
        if (! tmp___11) {
#line 206
          goto while_break___2;
        }
      }
      {
#line 208
      fgets((char */* __restrict  */)(tempstring), 250, (FILE */* __restrict  */)tracksfile);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 210
    tmp___12 = strlen((char const   *)(tempstring2));
#line 210
    tmp___13 = strncasecmp((char const   *)(tempstring), (char const   *)(tempstring2),
                           tmp___12);
    }
#line 210
    if (tmp___13) {
      {
#line 215
      fclose(tracksfile);
      }
#line 216
      return (0);
    }
    {
#line 219
    tmp___14 = strlen((char const   *)(tempstring));
#line 219
    tempstring[tmp___14 - 1UL] = (char )'\000';
#line 220
    tmp___15 = strlen((char const   *)(tempstring2));
#line 220
    tmp___16 = hmsf2fsec(tempstring + tmp___15, & seconds);
    }
#line 220
    if (! tmp___16) {
      {
#line 225
      fclose(tracksfile);
      }
#line 226
      return (0);
    }
    {
#line 229
    (tracktimes + i)->begin = (long )((double )44100 * seconds);
#line 231
    sprintf((char */* __restrict  */)(tempstring2), (char const   */* __restrict  */)"Track%02dend=",
            i);
#line 232
    fseek(tracksfile, tracks_pos, 0);
#line 234
    tempstring[0] = (char )'\000';
    }
    {
#line 235
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 235
      tmp___17 = feof(tracksfile);
      }
#line 235
      if (tmp___17) {
#line 235
        goto while_break___3;
      } else {
        {
#line 235
        tmp___18 = strlen((char const   *)(tempstring2));
#line 235
        tmp___19 = strncasecmp((char const   *)(tempstring), (char const   *)(tempstring2),
                               tmp___18);
        }
#line 235
        if (! tmp___19) {
#line 235
          goto while_break___3;
        }
      }
      {
#line 237
      fgets((char */* __restrict  */)(tempstring), 250, (FILE */* __restrict  */)tracksfile);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 239
    tmp___20 = strlen((char const   *)(tempstring2));
#line 239
    tmp___21 = strncasecmp((char const   *)(tempstring), (char const   *)(tempstring2),
                           tmp___20);
    }
#line 239
    if (tmp___21) {
      {
#line 244
      fclose(tracksfile);
      }
#line 245
      return (0);
    }
    {
#line 248
    tmp___22 = strlen((char const   *)(tempstring));
#line 248
    tempstring[tmp___22 - 1UL] = (char )'\000';
#line 249
    tmp___23 = strlen((char const   *)(tempstring2));
#line 249
    tmp___24 = hmsf2fsec(tempstring + tmp___23, & seconds);
    }
#line 249
    if (! tmp___24) {
      {
#line 254
      fclose(tracksfile);
      }
#line 255
      return (0);
    }
#line 258
    (tracktimes + i)->end = (long )((double )44100 * seconds);
#line 200
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 261
  fclose(tracksfile);
  }
#line 262
  return (1);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
static int first_entry  =    1;
#line 278 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
static scrollmenu_t filtlist  ;
#line 279 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
static char *filtlist_items[60]  ;
#line 280 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
static int filtnumbers[60]  ;
#line 281 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
static char *helptexts[60]  ;
#line 282 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
static scrollmenu_t selectedfilts  ;
#line 283 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
static char *selectedfilts_items[50]  ;
#line 284 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
static int usebeginendtime  =    0;
#line 284 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
static int usetracktimes  =    1;
#line 285 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
static double begintime  =    (double )0;
#line 285 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
static double endtime  =    (double )0;
#line 266 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_main.c"
void signproc_main(char *startdir ) 
{ 
  char infilename[250] ;
  char outfilename[250] ;
  char baseoutfilename[250] ;
  char outfileextension[250] ;
  struct stat buf ;
  int i ;
  char *charptr ;
  int in_ch ;
  beginendsample_t tracktimes[100] ;
  int number_of_tracks ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  sample_t tmp___6 ;

  {
#line 295
  if (first_entry) {
    {
#line 297
    filtlist.items = filtlist_items;
#line 298
    make_filterlist(& filtlist, filtnumbers, helptexts);
#line 300
    selectedfilts.items = selectedfilts_items;
#line 301
    number_of_filters = 0;
#line 302
    selectedfilts.number = 0;
#line 308
    *(selectedfilts.items + number_of_filters) = *(filtlist.items + 7);
#line 309
    filter_type[number_of_filters] = filtnumbers[7];
#line 310
    tmp = malloc(sizeof(param_t ));
#line 310
    parampointerarray[number_of_filters] = (parampointer_t )tmp;
#line 312
    param_defaults(parampointerarray[number_of_filters], filtnumbers[7]);
#line 313
    number_of_filters ++;
#line 314
    selectedfilts.number = number_of_filters;
#line 315
    selectedfilts.selected = number_of_filters - 1;
#line 318
    first_entry = 0;
    }
  }
  {
#line 321
  infilename[0] = (char )'\000';
#line 322
  outfilename[0] = (char )'\000';
#line 324
  tmp___0 = signproc_get_options(startdir, infilename, outfilename, & filtlist, filtnumbers,
                                 helptexts, & selectedfilts, & usetracktimes, & usebeginendtime,
                                 & begintime, & endtime);
  }
#line 324
  if (! tmp___0) {
#line 327
    return;
  }
  {
#line 329
  strcpy((char */* __restrict  */)(baseoutfilename), (char const   */* __restrict  */)(outfilename));
#line 330
  strcpy((char */* __restrict  */)(outfileextension), (char const   */* __restrict  */)".wav");
#line 335
  charptr = strrchr((char const   *)(outfilename), '.');
  }
#line 335
  if ((unsigned long )charptr != (unsigned long )((void *)0)) {
    {
#line 335
    tmp___1 = strchr((char const   *)charptr, '/');
    }
#line 335
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 339
      baseoutfilename[charptr - outfilename] = (char )'\000';
#line 340
      strcpy((char */* __restrict  */)(outfileextension), (char const   */* __restrict  */)charptr);
      }
    }
  }
#line 343
  if (usebeginendtime) {
#line 345
    number_of_tracks = 1;
#line 346
    tracktimes[1].begin = (long )(begintime * (double )44100);
#line 347
    tracktimes[1].end = (long )(endtime * (double )44100);
  } else
#line 349
  if (usetracktimes) {
    {
#line 351
    tmp___2 = load_track_times(infilename, tracktimes, & number_of_tracks);
    }
#line 351
    if (! tmp___2) {
      {
#line 353
      error_window((char *)"No (correct) track information is available for the specified source file.");
      }
#line 355
      return;
    }
  } else {
    {
#line 361
    number_of_tracks = 1;
#line 362
    stat((char const   */* __restrict  */)(infilename), (struct stat */* __restrict  */)(& buf));
#line 363
    tracktimes[1].begin = 0L;
#line 364
    tracktimes[1].end = (long )(((unsigned long )buf.st_size - sizeof(wavhead )) / 4UL);
    }
  }
#line 367
  totalsize_samples = 0L;
#line 368
  current_total_sample = 0L;
#line 369
  i = 1;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! (i <= number_of_tracks)) {
#line 369
      goto while_break;
    }
#line 370
    totalsize_samples += tracktimes[i].end - tracktimes[i].begin;
#line 369
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 372
  tmp___3 = openwavsource(infilename);
  }
#line 372
  if (! tmp___3) {
#line 373
    return;
  }
  {
#line 375
  def_prog_mode();
#line 377
  i = 1;
  }
  {
#line 377
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 377
    if (! (i <= number_of_tracks)) {
#line 377
      goto while_break___0;
    }
    {
#line 379
    clearscreen((char *)"Signal Processing");
#line 380
    error_window_display((char *)"", (char *)" Cancel ");
#line 381
    mvprintw(9, 21, "Track:   %2d of %d.", i, number_of_tracks);
#line 383
    nodelay(stdscr, (_Bool)1);
#line 386
    tracksize_samples = (tracktimes[i].end - tracktimes[i].begin) + 1L;
#line 389
    tmp___4 = seeksamplesource(tracktimes[i].begin);
    }
#line 389
    if (! tmp___4) {
      {
#line 391
      reset_prog_mode();
#line 392
      nodelay(stdscr, (_Bool)0);
#line 393
      error_window((char *)"The start position of the track could not be found. This track will be skipped.");
      }
#line 395
      goto while_break___0;
    }
#line 398
    if (number_of_tracks > 1) {
      {
#line 399
      sprintf((char */* __restrict  */)(outfilename), (char const   */* __restrict  */)"%s%02d%s",
              baseoutfilename, i, outfileextension);
      }
    }
    {
#line 403
    tmp___5 = openwavdest(outfilename, tracksize_samples * 4L);
    }
#line 403
    if (! tmp___5) {
      {
#line 405
      reset_prog_mode();
#line 406
      nodelay(stdscr, (_Bool)0);
#line 407
      error_window((char *)"The destination file could not be opened. This track will be skipped.");
      }
#line 409
      goto while_break___0;
    }
    {
#line 412
    init_filters();
#line 415
    current_sample = 0L;
    }
    {
#line 415
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 415
      if (! (current_sample < tracksize_samples)) {
#line 415
        goto while_break___1;
      }
#line 419
      if (! (current_sample % 4000L)) {
        {
#line 422
        mvprintw(10, 21, "Done:  %3ld%%  track", (long )((100. * (double )current_sample) / (double )tracksize_samples));
#line 425
        mvprintw(11, 21, "       %3ld%%  total", (long )((100. * (double )current_total_sample) / (double )totalsize_samples));
#line 428
        wmove(stdscr, 0, 79);
#line 429
        wrefresh(stdscr);
#line 431
        in_ch = wgetch(stdscr);
        }
#line 432
        if (in_ch == 27) {
#line 432
          goto _L;
        } else
#line 432
        if (in_ch == 13) {
#line 432
          goto _L;
        } else
#line 432
        if (in_ch == 343) {
          _L: /* CIL Label */ 
          {
#line 434
          reset_prog_mode();
#line 435
          nodelay(stdscr, (_Bool)0);
#line 436
          closewavdest();
#line 437
          closewavsource();
#line 438
          delete_filters();
          }
#line 439
          return;
        }
      }
      {
#line 443
      tmp___6 = get_sample_from_filter(number_of_filters - 1);
#line 443
      writesampledest(tmp___6);
#line 445
      current_total_sample ++;
#line 415
      current_sample ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 448
    closewavdest();
#line 449
    delete_filters();
#line 377
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 452
  closewavsource();
#line 454
  reset_prog_mode();
#line 455
  nodelay(stdscr, (_Bool)0);
  }
#line 456
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_mean.c"
void simple_mean_param_defaults(parampointer_t parampointer ) 
{ 


  {
#line 30
  parampointer->postlength1 = 1L;
#line 31
  parampointer->prelength1 = 1L;
#line 32
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_mean.c"
void simple_mean_param_screen(parampointer_t parampointer ) 
{ 
  stringinput_t meanlengthstr ;
  button_t ok_button ;
  button_t cancel_button ;
  int dont_stop ;
  int returnval ;
  int focus ;
  int in_ch ;
  int i ;
  long helplong ;
  char *helplines[3] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 39
  dont_stop = 1;
#line 40
  returnval = 0;
#line 41
  focus = 0;
#line 46
  helplines[0] = (char *)" ^: more distortion.                    v: less effective.                     ";
#line 46
  helplines[1] = (char *)" Discard changes.                                                              ";
#line 46
  helplines[2] = (char *)" Accept changes.                                                               ";
#line 52
  meanlengthstr.maxlen = 500;
#line 53
  tmp = malloc((unsigned long )meanlengthstr.maxlen * sizeof(char ));
#line 53
  meanlengthstr.string = (char *)tmp;
#line 55
  sprintf((char */* __restrict  */)meanlengthstr.string, (char const   */* __restrict  */)"%ld",
          (parampointer->prelength1 + parampointer->postlength1) + 1L);
#line 57
  meanlengthstr.y = 6;
#line 58
  meanlengthstr.x = 38;
#line 59
  meanlengthstr.w = 15;
#line 60
  meanlengthstr.cursorpos = (int )strlen(meanlengthstr.string);
#line 61
  meanlengthstr.firstcharonscreen = 0;
#line 63
  ok_button.text = (char *)" OK ";
#line 64
  ok_button.y = 20;
#line 65
  ok_button.x = 71;
#line 66
  ok_button.selected = 0;
#line 68
  cancel_button.text = (char *)" Cancel ";
#line 69
  cancel_button.y = 20;
#line 70
  cancel_button.x = 5;
#line 71
  cancel_button.selected = 0;
#line 73
  clearscreen((char *)"Simple Mean Filter - Parameters");
  }
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 77
    header((char *)"Simple Mean Filter - Parameters");
    }
#line 79
    if (focus == 1) {
#line 80
      cancel_button.selected = 1;
    } else {
#line 82
      cancel_button.selected = 0;
    }
#line 84
    if (focus == 2) {
#line 85
      ok_button.selected = 1;
    } else {
#line 87
      ok_button.selected = 0;
    }
    {
#line 89
    mvprintw(3, 2, "See the Signproc.txt file for the meaning of the parameters.");
#line 92
    stringinput_display(& meanlengthstr);
#line 93
    mvprintw(meanlengthstr.y, 2, "Number of samples to take mean of:");
#line 96
    button_display(& cancel_button);
#line 97
    tmp___0 = (int )strlen(cancel_button.text);
#line 97
    mybox(cancel_button.y - 1, cancel_button.x - 1, 3, tmp___0 + 2);
#line 99
    button_display(& ok_button);
#line 100
    tmp___1 = (int )strlen(ok_button.text);
#line 100
    mybox(ok_button.y - 1, ok_button.x - 1, 3, tmp___1 + 2);
#line 103
    helpline(helplines[focus]);
    }
#line 105
    if (focus == 0) {
      {
#line 106
      stringinput_display(& meanlengthstr);
      }
    } else {
      {
#line 108
      wmove(stdscr, 0, 79);
      }
    }
    {
#line 110
    wrefresh(stdscr);
#line 112
    in_ch = wgetch(stdscr);
    }
    {
#line 116
    if (focus == 0) {
#line 116
      goto case_0;
    }
#line 139
    if (focus == 1) {
#line 139
      goto case_1;
    }
#line 159
    if (focus == 2) {
#line 159
      goto case_2;
    }
#line 114
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 117
    stringinput_stdkeys(in_ch, & meanlengthstr);
    }
#line 118
    if (in_ch == 343) {
#line 118
      goto _L;
    } else
#line 118
    if (in_ch == 13) {
      _L: /* CIL Label */ 
      {
#line 120
      i = sscanf((char const   */* __restrict  */)meanlengthstr.string, (char const   */* __restrict  */)"%li",
                 & helplong);
      }
#line 121
      if (i < 1) {
        {
#line 122
        error_window((char *)"A whole, odd number, greater than 0, must be specified.");
        }
      } else
#line 121
      if (helplong < 1L) {
        {
#line 122
        error_window((char *)"A whole, odd number, greater than 0, must be specified.");
        }
      } else
#line 121
      if (helplong % 2L == 0L) {
        {
#line 122
        error_window((char *)"A whole, odd number, greater than 0, must be specified.");
        }
      } else {
#line 125
        focus = 2;
      }
    } else {
      {
#line 130
      if (in_ch == 259) {
#line 130
        goto case_259;
      }
#line 133
      if (in_ch == 258) {
#line 133
        goto case_258;
      }
#line 128
      goto switch_break___0;
      case_259: /* CIL Label */ 
#line 131
      focus --;
#line 132
      goto switch_break___0;
      case_258: /* CIL Label */ 
#line 134
      focus ++;
#line 135
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 137
    goto switch_break;
    case_1: /* CIL Label */ 
#line 140
    if (in_ch == 343) {
#line 142
      returnval = 0;
#line 143
      dont_stop = 0;
    } else
#line 140
    if (in_ch == 13) {
#line 142
      returnval = 0;
#line 143
      dont_stop = 0;
    } else {
      {
#line 149
      if (in_ch == 259) {
#line 149
        goto case_259___0;
      }
#line 149
      if (in_ch == 260) {
#line 149
        goto case_259___0;
      }
#line 153
      if (in_ch == 258) {
#line 153
        goto case_258___0;
      }
#line 153
      if (in_ch == 261) {
#line 153
        goto case_258___0;
      }
#line 146
      goto switch_break___1;
      case_259___0: /* CIL Label */ 
      case_260: /* CIL Label */ 
#line 150
      focus --;
#line 151
      goto switch_break___1;
      case_258___0: /* CIL Label */ 
      case_261: /* CIL Label */ 
#line 154
      focus ++;
#line 155
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
#line 157
    goto switch_break;
    case_2: /* CIL Label */ 
#line 160
    if (in_ch == 343) {
#line 160
      goto _L___0;
    } else
#line 160
    if (in_ch == 13) {
      _L___0: /* CIL Label */ 
      {
#line 162
      i = sscanf((char const   */* __restrict  */)meanlengthstr.string, (char const   */* __restrict  */)"%li",
                 & helplong);
      }
#line 163
      if (i < 1) {
        {
#line 165
        error_window((char *)"A whole, odd number, greater than 0, must be specified as mean length.");
#line 167
        meanlengthstr.cursorpos = (int )strlen(meanlengthstr.string);
#line 169
        focus = 0;
        }
      } else
#line 163
      if (helplong < 1L) {
        {
#line 165
        error_window((char *)"A whole, odd number, greater than 0, must be specified as mean length.");
#line 167
        meanlengthstr.cursorpos = (int )strlen(meanlengthstr.string);
#line 169
        focus = 0;
        }
      } else
#line 163
      if (helplong % 2L == 0L) {
        {
#line 165
        error_window((char *)"A whole, odd number, greater than 0, must be specified as mean length.");
#line 167
        meanlengthstr.cursorpos = (int )strlen(meanlengthstr.string);
#line 169
        focus = 0;
        }
      } else {
#line 173
        parampointer->prelength1 = (helplong - 1L) / 2L;
#line 174
        parampointer->postlength1 = (helplong - 1L) / 2L;
#line 175
        dont_stop = 0;
      }
    } else {
      {
#line 182
      if (in_ch == 259) {
#line 182
        goto case_259___1;
      }
#line 182
      if (in_ch == 260) {
#line 182
        goto case_259___1;
      }
#line 186
      if (in_ch == 258) {
#line 186
        goto case_258___1;
      }
#line 186
      if (in_ch == 261) {
#line 186
        goto case_258___1;
      }
#line 179
      goto switch_break___2;
      case_259___1: /* CIL Label */ 
      case_260___0: /* CIL Label */ 
#line 183
      focus --;
#line 184
      goto switch_break___2;
      case_258___1: /* CIL Label */ 
      case_261___0: /* CIL Label */ 
#line 187
      focus ++;
#line 188
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    }
#line 190
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 193
    if (in_ch == 9) {
#line 194
      focus ++;
    }
#line 196
    if (in_ch == 27) {
#line 197
      dont_stop = 0;
    }
#line 199
    if (focus > 2) {
#line 200
      focus -= 3;
    }
#line 201
    if (focus < 0) {
#line 202
      focus += 3;
    }
#line 75
    if (! dont_stop) {
#line 75
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  free((void *)meanlengthstr.string);
  }
#line 207
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_mean.c"
void init_simple_mean_filter(int filterno , parampointer_t parampointer ) 
{ 


  {
  {
#line 212
  parampointer->buffer = init_buffer(parampointer->postlength1, parampointer->prelength1);
#line 215
  parampointer->filterno = filterno;
  }
#line 216
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_mean.c"
void delete_simple_mean_filter(parampointer_t parampointer ) 
{ 


  {
  {
#line 221
  delete_buffer(& parampointer->buffer);
  }
#line 222
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_mean.c"
sample_t simple_mean_filter(parampointer_t parampointer ) 
{ 
  longsample_t sum ;
  sample_t sample ;
  long i ;

  {
  {
#line 232
  advance_current_pos(& parampointer->buffer, parampointer->filterno);
#line 234
  sum.left = 0L;
#line 235
  sum.right = 0L;
#line 237
  i = 0L;
  }
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! (i <= parampointer->postlength1 + parampointer->prelength1)) {
#line 237
      goto while_break;
    }
#line 240
    sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + ((parampointer->buffer.currpos + i) - parampointer->postlength1)));
#line 242
    sum.left += (long )sample.left;
#line 243
    sum.right += (long )sample.right;
#line 237
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  sample.left = (short )(sum.left / ((parampointer->postlength1 + parampointer->prelength1) + 1L));
#line 248
  sample.right = (short )(sum.right / ((parampointer->postlength1 + parampointer->prelength1) + 1L));
#line 251
  return (sample);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_rms.c"
void rms_param_defaults(parampointer_t parampointer ) 
{ 


  {
#line 31
  parampointer->postlength1 = 1L;
#line 32
  parampointer->prelength1 = 1L;
#line 33
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_rms.c"
void rms_param_screen(parampointer_t parampointer ) 
{ 
  stringinput_t rmslengthstr ;
  button_t ok_button ;
  button_t cancel_button ;
  int dont_stop ;
  int returnval ;
  int focus ;
  int in_ch ;
  int i ;
  long helplong ;
  char *helplines[3] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 40
  dont_stop = 1;
#line 41
  returnval = 0;
#line 42
  focus = 0;
#line 47
  helplines[0] = (char *)"                                                                               ";
#line 47
  helplines[1] = (char *)" Discard changes.                                                              ";
#line 47
  helplines[2] = (char *)" Accept changes.                                                               ";
#line 53
  rmslengthstr.maxlen = 500;
#line 54
  tmp = malloc((unsigned long )rmslengthstr.maxlen * sizeof(char ));
#line 54
  rmslengthstr.string = (char *)tmp;
#line 56
  sprintf((char */* __restrict  */)rmslengthstr.string, (char const   */* __restrict  */)"%ld",
          (parampointer->prelength1 + parampointer->postlength1) + 1L);
#line 58
  rmslengthstr.y = 6;
#line 59
  rmslengthstr.x = 40;
#line 60
  rmslengthstr.w = 15;
#line 61
  rmslengthstr.cursorpos = (int )strlen(rmslengthstr.string);
#line 62
  rmslengthstr.firstcharonscreen = 0;
#line 64
  ok_button.text = (char *)" OK ";
#line 65
  ok_button.y = 20;
#line 66
  ok_button.x = 71;
#line 67
  ok_button.selected = 0;
#line 69
  cancel_button.text = (char *)" Cancel ";
#line 70
  cancel_button.y = 20;
#line 71
  cancel_button.x = 5;
#line 72
  cancel_button.selected = 0;
#line 74
  clearscreen((char *)"RMS Filter - Parameters");
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    header((char *)"RMS Filter - Parameters");
    }
#line 80
    if (focus == 1) {
#line 81
      cancel_button.selected = 1;
    } else {
#line 83
      cancel_button.selected = 0;
    }
#line 85
    if (focus == 2) {
#line 86
      ok_button.selected = 1;
    } else {
#line 88
      ok_button.selected = 0;
    }
    {
#line 93
    stringinput_display(& rmslengthstr);
#line 94
    mvprintw(rmslengthstr.y, 2, "Number of samples to compute RMS of:");
#line 97
    button_display(& cancel_button);
#line 98
    tmp___0 = (int )strlen(cancel_button.text);
#line 98
    mybox(cancel_button.y - 1, cancel_button.x - 1, 3, tmp___0 + 2);
#line 100
    button_display(& ok_button);
#line 101
    tmp___1 = (int )strlen(ok_button.text);
#line 101
    mybox(ok_button.y - 1, ok_button.x - 1, 3, tmp___1 + 2);
#line 104
    helpline(helplines[focus]);
    }
#line 106
    if (focus == 0) {
      {
#line 107
      stringinput_display(& rmslengthstr);
      }
    } else {
      {
#line 109
      wmove(stdscr, 0, 79);
      }
    }
    {
#line 111
    wrefresh(stdscr);
#line 113
    in_ch = wgetch(stdscr);
    }
    {
#line 117
    if (focus == 0) {
#line 117
      goto case_0;
    }
#line 140
    if (focus == 1) {
#line 140
      goto case_1;
    }
#line 160
    if (focus == 2) {
#line 160
      goto case_2;
    }
#line 115
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 118
    stringinput_stdkeys(in_ch, & rmslengthstr);
    }
#line 119
    if (in_ch == 343) {
#line 119
      goto _L;
    } else
#line 119
    if (in_ch == 13) {
      _L: /* CIL Label */ 
      {
#line 121
      i = sscanf((char const   */* __restrict  */)rmslengthstr.string, (char const   */* __restrict  */)"%li",
                 & helplong);
      }
#line 122
      if (i < 1) {
        {
#line 123
        error_window((char *)"A whole, odd number, greater than 0, must be specified.");
        }
      } else
#line 122
      if (helplong < 1L) {
        {
#line 123
        error_window((char *)"A whole, odd number, greater than 0, must be specified.");
        }
      } else
#line 122
      if (helplong % 2L == 0L) {
        {
#line 123
        error_window((char *)"A whole, odd number, greater than 0, must be specified.");
        }
      } else {
#line 126
        focus = 2;
      }
    } else {
      {
#line 131
      if (in_ch == 259) {
#line 131
        goto case_259;
      }
#line 134
      if (in_ch == 258) {
#line 134
        goto case_258;
      }
#line 129
      goto switch_break___0;
      case_259: /* CIL Label */ 
#line 132
      focus --;
#line 133
      goto switch_break___0;
      case_258: /* CIL Label */ 
#line 135
      focus ++;
#line 136
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 138
    goto switch_break;
    case_1: /* CIL Label */ 
#line 141
    if (in_ch == 343) {
#line 143
      returnval = 0;
#line 144
      dont_stop = 0;
    } else
#line 141
    if (in_ch == 13) {
#line 143
      returnval = 0;
#line 144
      dont_stop = 0;
    } else {
      {
#line 150
      if (in_ch == 259) {
#line 150
        goto case_259___0;
      }
#line 150
      if (in_ch == 260) {
#line 150
        goto case_259___0;
      }
#line 154
      if (in_ch == 258) {
#line 154
        goto case_258___0;
      }
#line 154
      if (in_ch == 261) {
#line 154
        goto case_258___0;
      }
#line 147
      goto switch_break___1;
      case_259___0: /* CIL Label */ 
      case_260: /* CIL Label */ 
#line 151
      focus --;
#line 152
      goto switch_break___1;
      case_258___0: /* CIL Label */ 
      case_261: /* CIL Label */ 
#line 155
      focus ++;
#line 156
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
#line 158
    goto switch_break;
    case_2: /* CIL Label */ 
#line 161
    if (in_ch == 343) {
#line 161
      goto _L___0;
    } else
#line 161
    if (in_ch == 13) {
      _L___0: /* CIL Label */ 
      {
#line 163
      i = sscanf((char const   */* __restrict  */)rmslengthstr.string, (char const   */* __restrict  */)"%li",
                 & helplong);
      }
#line 164
      if (i < 1) {
        {
#line 166
        error_window((char *)"A whole, odd number, greater than 0, must be specified as RMS length.");
#line 168
        rmslengthstr.cursorpos = (int )strlen(rmslengthstr.string);
#line 170
        focus = 0;
        }
      } else
#line 164
      if (helplong < 1L) {
        {
#line 166
        error_window((char *)"A whole, odd number, greater than 0, must be specified as RMS length.");
#line 168
        rmslengthstr.cursorpos = (int )strlen(rmslengthstr.string);
#line 170
        focus = 0;
        }
      } else
#line 164
      if (helplong % 2L == 0L) {
        {
#line 166
        error_window((char *)"A whole, odd number, greater than 0, must be specified as RMS length.");
#line 168
        rmslengthstr.cursorpos = (int )strlen(rmslengthstr.string);
#line 170
        focus = 0;
        }
      } else {
#line 174
        parampointer->prelength1 = (helplong - 1L) / 2L;
#line 175
        parampointer->postlength1 = (helplong - 1L) / 2L;
#line 176
        dont_stop = 0;
      }
    } else {
      {
#line 183
      if (in_ch == 259) {
#line 183
        goto case_259___1;
      }
#line 183
      if (in_ch == 260) {
#line 183
        goto case_259___1;
      }
#line 187
      if (in_ch == 258) {
#line 187
        goto case_258___1;
      }
#line 187
      if (in_ch == 261) {
#line 187
        goto case_258___1;
      }
#line 180
      goto switch_break___2;
      case_259___1: /* CIL Label */ 
      case_260___0: /* CIL Label */ 
#line 184
      focus --;
#line 185
      goto switch_break___2;
      case_258___1: /* CIL Label */ 
      case_261___0: /* CIL Label */ 
#line 188
      focus ++;
#line 189
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    }
#line 191
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 194
    if (in_ch == 9) {
#line 195
      focus ++;
    }
#line 197
    if (in_ch == 27) {
#line 198
      dont_stop = 0;
    }
#line 200
    if (focus > 2) {
#line 201
      focus -= 3;
    }
#line 202
    if (focus < 0) {
#line 203
      focus += 3;
    }
#line 76
    if (! dont_stop) {
#line 76
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 207
  free((void *)rmslengthstr.string);
  }
#line 208
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_rms.c"
void init_rms_filter(int filterno , parampointer_t parampointer ) 
{ 


  {
  {
#line 213
  parampointer->buffer = init_buffer(parampointer->postlength1, parampointer->prelength1);
#line 216
  parampointer->filterno = filterno;
  }
#line 217
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_rms.c"
void delete_rms_filter(parampointer_t parampointer ) 
{ 


  {
  {
#line 222
  delete_buffer(& parampointer->buffer);
  }
#line 223
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_rms.c"
sample_t rms_filter(parampointer_t parampointer ) 
{ 
  doublesample_t sum ;
  sample_t sample ;
  long i ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 233
  advance_current_pos(& parampointer->buffer, parampointer->filterno);
#line 235
  sum.left = (double )0;
#line 236
  sum.right = (double )0;
#line 238
  i = 0L;
  }
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (i <= parampointer->postlength1 + parampointer->prelength1)) {
#line 238
      goto while_break;
    }
#line 241
    sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + ((parampointer->buffer.currpos + i) - parampointer->postlength1)));
#line 243
    sum.left += (double )((int )sample.left * (int )sample.left);
#line 244
    sum.right += (double )((int )sample.right * (int )sample.right);
#line 238
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 247
  tmp = sqrt(sum.left / (double )((parampointer->postlength1 + parampointer->prelength1) + 1L));
#line 247
  sample.left = (short )tmp;
#line 249
  tmp___0 = sqrt(sum.right / (double )((parampointer->postlength1 + parampointer->prelength1) + 1L));
#line 249
  sample.right = (short )tmp___0;
  }
#line 252
  return (sample);
}
}
#line 115 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) modf)(double __x ,
                                                                              double *__iptr ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/secshms.c"
void secs2hms(long seconds , char *outstring ) 
{ 


  {
  {
#line 18
  sprintf((char */* __restrict  */)outstring, (char const   */* __restrict  */)"%ld:%02ld:%02ld",
          seconds / 3600L, (seconds / 60L) % 60L, seconds % 60L);
  }
#line 21
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/secshms.c"
void fsec2hmsf(double seconds , char *outstring ) 
{ 
  double intpart ;
  double floatpart ;
  long i ;
  char helpstring[250] ;

  {
  {
#line 26
  intpart = (double )0;
#line 31
  floatpart = modf(seconds, & intpart);
#line 32
  i = (long )intpart;
#line 33
  secs2hms(i, outstring);
#line 35
  sprintf((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)"%.3f",
          floatpart);
#line 36
  strcat((char */* __restrict  */)outstring, (char const   */* __restrict  */)(helpstring + 1));
  }
#line 37
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/secshms.c"
int hmsf2fsec(char *instring , double *seconds ) 
{ 
  char *charptr ;
  int i ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 44
  i = 0;
#line 46
  tmp = strlen((char const   *)instring);
  }
#line 46
  if (! tmp) {
#line 47
    return (0);
  }
  {
#line 49
  *seconds = (double )0;
#line 53
  charptr = strrchr((char const   *)instring, ':');
  }
#line 54
  if ((unsigned long )charptr == (unsigned long )((void *)0)) {
#line 55
    charptr = instring;
  } else {
#line 58
    *charptr = (char )'\000';
#line 59
    charptr ++;
  }
  {
#line 62
  tmp___0 = sscanf((char const   */* __restrict  */)charptr, (char const   */* __restrict  */)"%lf",
                   seconds);
  }
#line 62
  if (! tmp___0) {
#line 63
    return (0);
  }
#line 65
  if ((unsigned long )charptr == (unsigned long )instring) {
#line 66
    return (1);
  }
  {
#line 70
  charptr = strrchr((char const   *)instring, ':');
  }
#line 71
  if ((unsigned long )charptr == (unsigned long )((void *)0)) {
#line 72
    charptr = instring;
  } else {
#line 75
    *charptr = (char )'\000';
#line 76
    charptr ++;
  }
  {
#line 79
  tmp___1 = sscanf((char const   */* __restrict  */)charptr, (char const   */* __restrict  */)"%d",
                   & i);
  }
#line 79
  if (! tmp___1) {
#line 80
    return (0);
  }
#line 81
  *seconds += (double )(i * 60);
#line 83
  if ((unsigned long )charptr == (unsigned long )instring) {
#line 84
    return (1);
  }
  {
#line 88
  charptr = strrchr((char const   *)instring, ':');
  }
#line 89
  if ((unsigned long )charptr == (unsigned long )((void *)0)) {
#line 90
    charptr = instring;
  } else {
#line 93
    *charptr = (char )'\000';
#line 94
    charptr ++;
  }
  {
#line 97
  tmp___2 = sscanf((char const   */* __restrict  */)charptr, (char const   */* __restrict  */)"%d",
                   & i);
  }
#line 97
  if (! tmp___2) {
#line 98
    return (0);
  }
#line 99
  *seconds += (double )(i * 3600);
#line 101
  if ((unsigned long )charptr == (unsigned long )instring) {
#line 102
    return (1);
  }
#line 104
  return (0);
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_copy.c"
void copyonly_param_defaults(parampointer_t parampointer ) 
{ 


  {
#line 18
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_copy.c"
void copyonly_param_screen(parampointer_t parampointer ) 
{ 


  {
  {
#line 23
  error_window((char *)"This `filter\' does not have adjustable parameters. It just copies the signal unchanged.");
  }
#line 25
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_copy.c"
void init_copyonly_filter(int filterno , parampointer_t parampointer ) 
{ 


  {
  {
#line 30
  parampointer->buffer = init_buffer(0L, 0L);
#line 32
  parampointer->filterno = filterno;
  }
#line 33
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_copy.c"
void delete_copyonly_filter(parampointer_t parampointer ) 
{ 


  {
  {
#line 38
  delete_buffer(& parampointer->buffer);
  }
#line 39
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_copy.c"
sample_t copyonly_filter(parampointer_t parampointer ) 
{ 


  {
  {
#line 45
  advance_current_pos(& parampointer->buffer, parampointer->filterno);
  }
#line 47
  return (*(parampointer->buffer.array + *(parampointer->buffer.indextable + parampointer->buffer.currpos)));
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_filtmenu.c"
int signproc_select_filters(scrollmenu_t *filtlist___0 , int *filtnumbers___0 , char **helptexts___0 ,
                            scrollmenu_t *selectedfilts___0 , int *usetracktimes___0 ,
                            int *usebeginendtime___0 , double *begintime___0 , double *endtime___0 ) 
{ 
  button_t next_button ;
  button_t cancel_button ;
  button_t prev_button ;
  button_t beginend_check ;
  button_t tracktimes_check ;
  stringinput_t begintimestring ;
  stringinput_t endtimestring ;
  int dont_stop ;
  int returnval ;
  int focus ;
  int in_ch ;
  int i ;
  double tempdouble ;
  char tempstring[250] ;
  char *emptyhelpline ;
  int maxhelplength ;
  char helphelpline[100] ;
  char *helplines[9] ;
  char *helpcharptr ;
  int helpint ;
  parampointer_t helpparampointer ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;

  {
  {
#line 40
  dont_stop = 1;
#line 41
  returnval = 0;
#line 42
  focus = 0;
#line 45
  tempdouble = (double )0;
#line 48
  emptyhelpline = (char *)"                                                                TAB: Next field";
#line 51
  maxhelplength = 62;
#line 54
  helplines[0] = (char *)" Enter: Add selected filter.                                    TAB: Next field";
#line 54
  helplines[1] = (char *)" Enter: Parameters   U/D: Move   R/Del: Delete                  TAB: Next field";
#line 54
  helplines[2] = (char *)" Use the .tracks file to split tracks.                          TAB: Next field";
#line 54
  helplines[3] = (char *)" Process only the specified part of the sound.                  TAB: Next field";
#line 54
  helplines[4] = (char *)" Enter begin time of part to be processed.                      TAB: Next field";
#line 54
  helplines[5] = (char *)" Enter end time of part to be processed.                        TAB: Next field";
#line 54
  helplines[6] = (char *)" To Signal Processing - Source File.                            TAB: Next field";
#line 54
  helplines[7] = (char *)" Back to main menu.                                             TAB: Next field";
#line 54
  helplines[8] = (char *)" To Signal Processing - Destination File.                       TAB: Next field";
#line 71
  filtlist___0->y = 3;
#line 72
  filtlist___0->x = 5;
#line 73
  filtlist___0->h = 12;
#line 74
  filtlist___0->w = 32;
#line 75
  filtlist___0->firstonscreen = 0;
#line 76
  filtlist___0->selected = 0;
#line 78
  selectedfilts___0->y = 3;
#line 79
  selectedfilts___0->x = 43;
#line 80
  selectedfilts___0->h = 12;
#line 81
  selectedfilts___0->w = 32;
#line 82
  selectedfilts___0->firstonscreen = 0;
#line 83
  selectedfilts___0->selected = 0;
#line 86
  begintimestring.maxlen = 500;
#line 87
  tmp = malloc((unsigned long )begintimestring.maxlen * sizeof(char ));
#line 87
  begintimestring.string = (char *)tmp;
#line 89
  fsec2hmsf(*begintime___0, begintimestring.string);
#line 90
  begintimestring.y = 17;
#line 91
  begintimestring.x = 59;
#line 92
  begintimestring.w = 18;
#line 93
  tmp___0 = strlen((char const   *)begintimestring.string);
#line 93
  begintimestring.cursorpos = (int )tmp___0;
#line 94
  begintimestring.firstcharonscreen = 0;
#line 96
  endtimestring.maxlen = 500;
#line 97
  tmp___1 = malloc((unsigned long )endtimestring.maxlen * sizeof(char ));
#line 97
  endtimestring.string = (char *)tmp___1;
#line 99
  fsec2hmsf(*endtime___0, endtimestring.string);
#line 100
  endtimestring.y = 18;
#line 101
  endtimestring.x = 59;
#line 102
  endtimestring.w = 18;
#line 103
  tmp___2 = strlen((char const   *)endtimestring.string);
#line 103
  endtimestring.cursorpos = (int )tmp___2;
#line 104
  endtimestring.firstcharonscreen = 0;
#line 106
  prev_button.text = (char *)" < Previous screen ";
#line 107
  prev_button.y = 20;
#line 108
  prev_button.x = 5;
#line 109
  prev_button.selected = 0;
#line 111
  next_button.text = (char *)" Next screen > ";
#line 112
  next_button.y = 20;
#line 113
  next_button.x = 60;
#line 114
  next_button.selected = 0;
#line 116
  cancel_button.text = (char *)" Cancel ";
#line 117
  cancel_button.y = 20;
#line 118
  cancel_button.x = 36;
#line 119
  cancel_button.selected = 0;
#line 121
  tracktimes_check.text = (char *)"";
#line 122
  tracktimes_check.y = 16;
#line 123
  tracktimes_check.x = 4;
#line 124
  tracktimes_check.selected = 0;
#line 126
  beginend_check.text = (char *)"";
#line 127
  beginend_check.y = 16;
#line 128
  beginend_check.x = 42;
#line 129
  beginend_check.selected = 0;
#line 131
  clearscreen((char *)"Signal Processing - Filter Selection");
  }
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 135
    header((char *)"Signal Processing - Filter Selection");
    }
#line 137
    if (*usetracktimes___0) {
#line 138
      tracktimes_check.text = (char *)"[X] Split tracks";
    } else {
#line 140
      tracktimes_check.text = (char *)"[ ] Split tracks";
    }
#line 142
    if (*usebeginendtime___0) {
#line 143
      beginend_check.text = (char *)"[X] Use begin and end times";
    } else {
#line 145
      beginend_check.text = (char *)"[ ] Use begin and end times";
    }
#line 147
    if (focus == 2) {
#line 148
      tracktimes_check.selected = 1;
    } else {
#line 150
      tracktimes_check.selected = 0;
    }
#line 152
    if (focus == 3) {
#line 153
      beginend_check.selected = 1;
    } else {
#line 155
      beginend_check.selected = 0;
    }
#line 157
    if (focus == 6) {
#line 158
      prev_button.selected = 1;
    } else {
#line 160
      prev_button.selected = 0;
    }
#line 162
    if (focus == 7) {
#line 163
      cancel_button.selected = 1;
    } else {
#line 165
      cancel_button.selected = 0;
    }
#line 167
    if (focus == 8) {
#line 168
      next_button.selected = 1;
    } else {
#line 170
      next_button.selected = 0;
    }
    {
#line 172
    filtlist___0->hasfocus = focus == 0;
#line 173
    selectedfilts___0->hasfocus = focus == 1;
#line 175
    scrollmenu_display(filtlist___0);
#line 176
    mybox(filtlist___0->y - 1, filtlist___0->x - 1, filtlist___0->h + 2, filtlist___0->w + 2);
#line 178
    mvprintw(filtlist___0->y - 1, filtlist___0->x + 1, "Available filters:");
#line 181
    scrollmenu_display(selectedfilts___0);
#line 182
    mybox(selectedfilts___0->y - 1, selectedfilts___0->x - 1, selectedfilts___0->h + 2,
          selectedfilts___0->w + 2);
#line 184
    mvprintw(selectedfilts___0->y - 1, selectedfilts___0->x + 1, "Selected filters:");
#line 187
    stringinput_display(& begintimestring);
#line 188
    mvprintw(begintimestring.y, begintimestring.x - 12, "Begin time:");
#line 191
    stringinput_display(& endtimestring);
#line 192
    mvprintw(endtimestring.y, endtimestring.x - 12, "End time  :");
#line 195
    button_display(& prev_button);
#line 196
    tmp___3 = strlen((char const   *)prev_button.text);
#line 196
    mybox(prev_button.y - 1, prev_button.x - 1, 3, (int )(tmp___3 + 2UL));
#line 198
    button_display(& cancel_button);
#line 199
    tmp___4 = strlen((char const   *)cancel_button.text);
#line 199
    mybox(cancel_button.y - 1, cancel_button.x - 1, 3, (int )(tmp___4 + 2UL));
#line 201
    button_display(& next_button);
#line 202
    tmp___5 = strlen((char const   *)next_button.text);
#line 202
    mybox(next_button.y - 1, next_button.x - 1, 3, (int )(tmp___5 + 2UL));
#line 205
    button_display(& tracktimes_check);
#line 206
    button_display(& beginend_check);
    }
#line 208
    if (focus == 0) {
      {
#line 210
      strcpy((char */* __restrict  */)(helphelpline), (char const   */* __restrict  */)emptyhelpline);
#line 212
      i = 0;
      }
      {
#line 213
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 213
        tmp___6 = strlen((char const   *)*(helptexts___0 + filtlist___0->selected));
        }
#line 213
        if ((size_t )i < tmp___6) {
#line 213
          if (! (i < maxhelplength)) {
#line 213
            goto while_break___0;
          }
        } else {
#line 213
          goto while_break___0;
        }
#line 216
        helphelpline[i + 1] = *(*(helptexts___0 + filtlist___0->selected) + i);
#line 217
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 220
      helpline(helphelpline);
      }
    } else {
      {
#line 223
      helpline(helplines[focus]);
      }
    }
#line 225
    if (focus == 4) {
      {
#line 226
      stringinput_display(& begintimestring);
      }
    } else
#line 227
    if (focus == 5) {
      {
#line 228
      stringinput_display(& endtimestring);
      }
    } else {
      {
#line 230
      wmove(stdscr, 0, 79);
      }
    }
    {
#line 232
    wrefresh(stdscr);
#line 234
    in_ch = wgetch(stdscr);
    }
    {
#line 238
    if (focus == 0) {
#line 238
      goto case_0;
    }
#line 273
    if (focus == 1) {
#line 273
      goto case_1;
    }
#line 375
    if (focus == 2) {
#line 375
      goto case_2;
    }
#line 399
    if (focus == 3) {
#line 399
      goto case_3;
    }
#line 423
    if (focus == 4) {
#line 423
      goto case_4;
    }
#line 456
    if (focus == 5) {
#line 456
      goto case_5;
    }
#line 490
    if (focus == 6) {
#line 490
      goto case_6;
    }
#line 510
    if (focus == 7) {
#line 510
      goto case_7;
    }
#line 530
    if (focus == 8) {
#line 530
      goto case_8;
    }
#line 236
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 239
    tmp___8 = scrollmenu_stdkeys(in_ch, filtlist___0);
    }
#line 239
    if (tmp___8 >= 0) {
#line 241
      if (selectedfilts___0->number < 50) {
        {
#line 243
        *(selectedfilts___0->items + number_of_filters) = *(filtlist___0->items + filtlist___0->selected);
#line 245
        filter_type[number_of_filters] = *(filtnumbers___0 + filtlist___0->selected);
#line 247
        tmp___7 = malloc(sizeof(param_t ));
#line 247
        parampointerarray[number_of_filters] = (parampointer_t )tmp___7;
#line 250
        param_defaults(parampointerarray[number_of_filters], *(filtnumbers___0 + filtlist___0->selected));
#line 253
        number_of_filters ++;
#line 254
        selectedfilts___0->number = number_of_filters;
#line 255
        selectedfilts___0->selected = number_of_filters - 1;
        }
      } else {
        {
#line 258
        error_window((char *)"The maximum number of filters has been reached. No more filters can be added.");
        }
      }
    } else {
      {
#line 264
      if (in_ch == 260) {
#line 264
        goto case_260;
      }
#line 267
      if (in_ch == 261) {
#line 267
        goto case_261;
      }
#line 262
      goto switch_break___0;
      case_260: /* CIL Label */ 
#line 265
      focus --;
#line 266
      goto switch_break___0;
      case_261: /* CIL Label */ 
#line 268
      focus ++;
#line 269
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 271
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 274
    tmp___9 = scrollmenu_stdkeys(in_ch, selectedfilts___0);
    }
#line 274
    if (tmp___9 >= 0) {
      {
#line 278
      param_screen(parampointerarray[selectedfilts___0->selected], filter_type[selectedfilts___0->selected]);
      }
    } else {
      {
#line 286
      if (in_ch == 85) {
#line 286
        goto case_85;
      }
#line 286
      if (in_ch == 117) {
#line 286
        goto case_85;
      }
#line 314
      if (in_ch == 68) {
#line 314
        goto case_68;
      }
#line 314
      if (in_ch == 100) {
#line 314
        goto case_68;
      }
#line 345
      if (in_ch == 82) {
#line 345
        goto case_82;
      }
#line 345
      if (in_ch == 114) {
#line 345
        goto case_82;
      }
#line 345
      if (in_ch == 127) {
#line 345
        goto case_82;
      }
#line 345
      if (in_ch == 263) {
#line 345
        goto case_82;
      }
#line 366
      if (in_ch == 260) {
#line 366
        goto case_260___0;
      }
#line 369
      if (in_ch == 261) {
#line 369
        goto case_261___0;
      }
#line 283
      goto switch_break___1;
      case_85: /* CIL Label */ 
      case_117: /* CIL Label */ 
#line 287
      if (selectedfilts___0->selected > 0) {
#line 289
        helpcharptr = *(selectedfilts___0->items + (selectedfilts___0->selected - 1));
#line 291
        *(selectedfilts___0->items + (selectedfilts___0->selected - 1)) = *(selectedfilts___0->items + selectedfilts___0->selected);
#line 293
        *(selectedfilts___0->items + selectedfilts___0->selected) = helpcharptr;
#line 296
        helpint = filter_type[selectedfilts___0->selected - 1];
#line 297
        filter_type[selectedfilts___0->selected - 1] = filter_type[selectedfilts___0->selected];
#line 299
        filter_type[selectedfilts___0->selected] = helpint;
#line 302
        helpparampointer = parampointerarray[selectedfilts___0->selected - 1];
#line 304
        parampointerarray[selectedfilts___0->selected - 1] = parampointerarray[selectedfilts___0->selected];
#line 306
        parampointerarray[selectedfilts___0->selected] = helpparampointer;
#line 309
        (selectedfilts___0->selected) --;
      }
#line 311
      goto switch_break___1;
      case_68: /* CIL Label */ 
      case_100: /* CIL Label */ 
#line 315
      if (selectedfilts___0->selected < number_of_filters - 1) {
#line 318
        helpcharptr = *(selectedfilts___0->items + (selectedfilts___0->selected + 1));
#line 320
        *(selectedfilts___0->items + (selectedfilts___0->selected + 1)) = *(selectedfilts___0->items + selectedfilts___0->selected);
#line 322
        *(selectedfilts___0->items + selectedfilts___0->selected) = helpcharptr;
#line 325
        helpint = filter_type[selectedfilts___0->selected + 1];
#line 326
        filter_type[selectedfilts___0->selected + 1] = filter_type[selectedfilts___0->selected];
#line 328
        filter_type[selectedfilts___0->selected] = helpint;
#line 331
        helpparampointer = parampointerarray[selectedfilts___0->selected + 1];
#line 333
        parampointerarray[selectedfilts___0->selected + 1] = parampointerarray[selectedfilts___0->selected];
#line 335
        parampointerarray[selectedfilts___0->selected] = helpparampointer;
#line 338
        (selectedfilts___0->selected) ++;
      }
#line 340
      goto switch_break___1;
      case_82: /* CIL Label */ 
      case_114: /* CIL Label */ 
      case_127: /* CIL Label */ 
      case_263: /* CIL Label */ 
#line 346
      if (number_of_filters > 0) {
        {
#line 348
        free((void *)parampointerarray[selectedfilts___0->selected]);
#line 350
        i = selectedfilts___0->selected;
        }
        {
#line 350
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 350
          if (! (i < number_of_filters - 1)) {
#line 350
            goto while_break___1;
          }
#line 353
          *(selectedfilts___0->items + i) = *(selectedfilts___0->items + (i + 1));
#line 356
          filter_type[i] = filter_type[i + 1];
#line 358
          parampointerarray[i] = parampointerarray[i + 1];
#line 350
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 361
        number_of_filters --;
#line 362
        selectedfilts___0->number = number_of_filters;
      }
#line 364
      goto switch_break___1;
      case_260___0: /* CIL Label */ 
#line 367
      focus --;
#line 368
      goto switch_break___1;
      case_261___0: /* CIL Label */ 
#line 370
      focus ++;
#line 371
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
#line 373
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 382
    if (in_ch == 88) {
#line 382
      goto case_88;
    }
#line 382
    if (in_ch == 120) {
#line 382
      goto case_88;
    }
#line 382
    if (in_ch == 32) {
#line 382
      goto case_88;
    }
#line 382
    if (in_ch == 13) {
#line 382
      goto case_88;
    }
#line 382
    if (in_ch == 343) {
#line 382
      goto case_88;
    }
#line 389
    if (in_ch == 259) {
#line 389
      goto case_259;
    }
#line 389
    if (in_ch == 260) {
#line 389
      goto case_259;
    }
#line 393
    if (in_ch == 258) {
#line 393
      goto case_258;
    }
#line 393
    if (in_ch == 261) {
#line 393
      goto case_258;
    }
#line 376
    goto switch_break___2;
    case_88: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_343: /* CIL Label */ 
#line 383
    *usetracktimes___0 = 1 - *usetracktimes___0;
#line 384
    if (*usetracktimes___0) {
#line 385
      *usebeginendtime___0 = 0;
    }
#line 386
    goto switch_break___2;
    case_259: /* CIL Label */ 
    case_260___1: /* CIL Label */ 
#line 390
    focus --;
#line 391
    goto switch_break___2;
    case_258: /* CIL Label */ 
    case_261___1: /* CIL Label */ 
#line 394
    focus ++;
#line 395
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 397
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 406
    if (in_ch == 88) {
#line 406
      goto case_88___0;
    }
#line 406
    if (in_ch == 120) {
#line 406
      goto case_88___0;
    }
#line 406
    if (in_ch == 32) {
#line 406
      goto case_88___0;
    }
#line 406
    if (in_ch == 13) {
#line 406
      goto case_88___0;
    }
#line 406
    if (in_ch == 343) {
#line 406
      goto case_88___0;
    }
#line 413
    if (in_ch == 259) {
#line 413
      goto case_259___0;
    }
#line 413
    if (in_ch == 260) {
#line 413
      goto case_259___0;
    }
#line 417
    if (in_ch == 258) {
#line 417
      goto case_258___0;
    }
#line 417
    if (in_ch == 261) {
#line 417
      goto case_258___0;
    }
#line 400
    goto switch_break___3;
    case_88___0: /* CIL Label */ 
    case_120___0: /* CIL Label */ 
    case_32___0: /* CIL Label */ 
    case_13___0: /* CIL Label */ 
    case_343___0: /* CIL Label */ 
#line 407
    *usebeginendtime___0 = 1 - *usebeginendtime___0;
#line 408
    if (*usebeginendtime___0) {
#line 409
      *usetracktimes___0 = 0;
    }
#line 410
    goto switch_break___3;
    case_259___0: /* CIL Label */ 
    case_260___2: /* CIL Label */ 
#line 414
    focus --;
#line 415
    goto switch_break___3;
    case_258___0: /* CIL Label */ 
    case_261___2: /* CIL Label */ 
#line 418
    focus ++;
#line 419
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 421
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 424
    stringinput_stdkeys(in_ch, & begintimestring);
    }
    {
#line 428
    if (in_ch == 13) {
#line 428
      goto case_13___1;
    }
#line 428
    if (in_ch == 343) {
#line 428
      goto case_13___1;
    }
#line 447
    if (in_ch == 259) {
#line 447
      goto case_259___1;
    }
#line 450
    if (in_ch == 258) {
#line 450
      goto case_258___1;
    }
#line 425
    goto switch_break___4;
    case_13___1: /* CIL Label */ 
    case_343___1: /* CIL Label */ 
    {
#line 429
    strcpy((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)begintimestring.string);
#line 430
    tmp___12 = hmsf2fsec(tempstring, & tempdouble);
    }
#line 430
    if (tmp___12) {
      {
#line 439
      *begintime___0 = tempdouble;
#line 440
      fsec2hmsf(tempdouble, begintimestring.string);
#line 441
      tmp___11 = strlen((char const   *)begintimestring.string);
#line 441
      begintimestring.cursorpos = (int )tmp___11;
#line 443
      focus ++;
      }
    } else {
      {
#line 432
      error_window((char *)"Enter the time in the format hours:minutes:seconds.fractions, for example 0:04:26.740");
#line 434
      tmp___10 = strlen((char const   *)begintimestring.string);
#line 434
      begintimestring.cursorpos = (int )tmp___10;
      }
    }
#line 445
    goto switch_break___4;
    case_259___1: /* CIL Label */ 
#line 448
    focus --;
#line 449
    goto switch_break___4;
    case_258___1: /* CIL Label */ 
#line 451
    focus ++;
#line 452
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 454
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 457
    stringinput_stdkeys(in_ch, & endtimestring);
    }
    {
#line 461
    if (in_ch == 13) {
#line 461
      goto case_13___2;
    }
#line 461
    if (in_ch == 343) {
#line 461
      goto case_13___2;
    }
#line 480
    if (in_ch == 259) {
#line 480
      goto case_259___2;
    }
#line 483
    if (in_ch == 258) {
#line 483
      goto case_258___2;
    }
#line 458
    goto switch_break___5;
    case_13___2: /* CIL Label */ 
    case_343___2: /* CIL Label */ 
    {
#line 462
    strcpy((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)endtimestring.string);
#line 463
    tmp___15 = hmsf2fsec(tempstring, & tempdouble);
    }
#line 463
    if (tmp___15) {
      {
#line 472
      *endtime___0 = tempdouble;
#line 473
      fsec2hmsf(tempdouble, endtimestring.string);
#line 474
      tmp___14 = strlen((char const   *)endtimestring.string);
#line 474
      endtimestring.cursorpos = (int )tmp___14;
#line 476
      focus = 8;
      }
    } else {
      {
#line 465
      error_window((char *)"Enter the time in the format hours:minutes:seconds.fractions, for example 0:04:26.740");
#line 467
      tmp___13 = strlen((char const   *)endtimestring.string);
#line 467
      endtimestring.cursorpos = (int )tmp___13;
      }
    }
#line 478
    goto switch_break___5;
    case_259___2: /* CIL Label */ 
#line 481
    focus --;
#line 482
    goto switch_break___5;
    case_258___2: /* CIL Label */ 
#line 484
    focus ++;
#line 485
    goto switch_break___5;
    switch_break___5: /* CIL Label */ ;
    }
#line 487
    goto switch_break;
    case_6: /* CIL Label */ 
#line 491
    if (in_ch == 343) {
#line 493
      returnval = 1;
#line 494
      dont_stop = 0;
    } else
#line 491
    if (in_ch == 13) {
#line 493
      returnval = 1;
#line 494
      dont_stop = 0;
    } else {
      {
#line 500
      if (in_ch == 259) {
#line 500
        goto case_259___3;
      }
#line 500
      if (in_ch == 260) {
#line 500
        goto case_259___3;
      }
#line 504
      if (in_ch == 258) {
#line 504
        goto case_258___3;
      }
#line 504
      if (in_ch == 261) {
#line 504
        goto case_258___3;
      }
#line 497
      goto switch_break___6;
      case_259___3: /* CIL Label */ 
      case_260___3: /* CIL Label */ 
#line 501
      focus --;
#line 502
      goto switch_break___6;
      case_258___3: /* CIL Label */ 
      case_261___3: /* CIL Label */ 
#line 505
      focus ++;
#line 506
      goto switch_break___6;
      switch_break___6: /* CIL Label */ ;
      }
    }
#line 508
    goto switch_break;
    case_7: /* CIL Label */ 
#line 511
    if (in_ch == 343) {
#line 513
      returnval = 0;
#line 514
      dont_stop = 0;
    } else
#line 511
    if (in_ch == 13) {
#line 513
      returnval = 0;
#line 514
      dont_stop = 0;
    } else {
      {
#line 520
      if (in_ch == 259) {
#line 520
        goto case_259___4;
      }
#line 520
      if (in_ch == 260) {
#line 520
        goto case_259___4;
      }
#line 524
      if (in_ch == 258) {
#line 524
        goto case_258___4;
      }
#line 524
      if (in_ch == 261) {
#line 524
        goto case_258___4;
      }
#line 517
      goto switch_break___7;
      case_259___4: /* CIL Label */ 
      case_260___4: /* CIL Label */ 
#line 521
      focus --;
#line 522
      goto switch_break___7;
      case_258___4: /* CIL Label */ 
      case_261___4: /* CIL Label */ 
#line 525
      focus ++;
#line 526
      goto switch_break___7;
      switch_break___7: /* CIL Label */ ;
      }
    }
#line 528
    goto switch_break;
    case_8: /* CIL Label */ 
#line 531
    if (in_ch == 343) {
#line 531
      goto _L;
    } else
#line 531
    if (in_ch == 13) {
      _L: /* CIL Label */ 
#line 533
      if (number_of_filters < 1) {
        {
#line 535
        error_window((char *)"No filters have been selected.");
#line 536
        focus = 0;
        }
#line 537
        goto switch_break;
      }
      {
#line 540
      strcpy((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)begintimestring.string);
#line 541
      tmp___17 = hmsf2fsec(tempstring, & tempdouble);
      }
#line 541
      if (! tmp___17) {
        {
#line 543
        error_window((char *)"Enter the begin time in the format hours:minutes:seconds.fractions, for example 0:04:26.740");
#line 545
        tmp___16 = strlen((char const   *)begintimestring.string);
#line 545
        begintimestring.cursorpos = (int )tmp___16;
#line 547
        focus = 4;
        }
#line 548
        goto switch_break;
      }
      {
#line 551
      *begintime___0 = tempdouble;
#line 553
      strcpy((char */* __restrict  */)(tempstring), (char const   */* __restrict  */)endtimestring.string);
#line 554
      tmp___19 = hmsf2fsec(tempstring, & tempdouble);
      }
#line 554
      if (! tmp___19) {
        {
#line 556
        error_window((char *)"Enter the end time in the format hours:minutes:seconds.fractions, for example 0:04:26.740");
#line 558
        tmp___18 = strlen((char const   *)endtimestring.string);
#line 558
        endtimestring.cursorpos = (int )tmp___18;
#line 560
        focus = 5;
        }
#line 561
        goto switch_break;
      }
#line 564
      *endtime___0 = tempdouble;
#line 566
      if (*begintime___0 > *endtime___0) {
        {
#line 568
        error_window((char *)"The begin time is larger than the end time.");
#line 569
        fsec2hmsf(*begintime___0, begintimestring.string);
#line 570
        tmp___20 = strlen((char const   *)begintimestring.string);
#line 570
        begintimestring.cursorpos = (int )tmp___20;
#line 572
        fsec2hmsf(*endtime___0, endtimestring.string);
#line 573
        tmp___21 = strlen((char const   *)endtimestring.string);
#line 573
        endtimestring.cursorpos = (int )tmp___21;
#line 575
        focus = 4;
        }
#line 576
        goto switch_break;
      }
#line 579
      returnval = 2;
#line 580
      dont_stop = 0;
    } else {
      {
#line 586
      if (in_ch == 259) {
#line 586
        goto case_259___5;
      }
#line 586
      if (in_ch == 260) {
#line 586
        goto case_259___5;
      }
#line 590
      if (in_ch == 258) {
#line 590
        goto case_258___5;
      }
#line 590
      if (in_ch == 261) {
#line 590
        goto case_258___5;
      }
#line 583
      goto switch_break___8;
      case_259___5: /* CIL Label */ 
      case_260___5: /* CIL Label */ 
#line 587
      focus --;
#line 588
      goto switch_break___8;
      case_258___5: /* CIL Label */ 
      case_261___5: /* CIL Label */ 
#line 591
      focus ++;
#line 592
      goto switch_break___8;
      switch_break___8: /* CIL Label */ ;
      }
    }
#line 594
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 598
    if (in_ch == 9) {
#line 599
      focus ++;
    }
#line 601
    if (in_ch == 27) {
#line 602
      dont_stop = 0;
    }
#line 604
    if (focus > 8) {
#line 605
      focus -= 9;
    }
#line 606
    if (focus < 0) {
#line 607
      focus += 9;
    }
#line 133
    if (! dont_stop) {
#line 133
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 611
  return (returnval);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_doubmed.c"
void double_median_param_defaults(parampointer_t parampointer ) 
{ 


  {
#line 30
  parampointer->postlength1 = 2L;
#line 31
  parampointer->prelength1 = 2L;
#line 32
  parampointer->postlength2 = 2L;
#line 33
  parampointer->prelength2 = 2L;
#line 34
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_doubmed.c"
void double_median_param_screen(parampointer_t parampointer ) 
{ 
  stringinput_t medlength1str ;
  stringinput_t medlength2str ;
  button_t ok_button ;
  button_t cancel_button ;
  int dont_stop ;
  int returnval ;
  int focus ;
  int in_ch ;
  int i ;
  long helplong ;
  char *helplines[4] ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 41
  dont_stop = 1;
#line 42
  returnval = 0;
#line 43
  focus = 0;
#line 48
  helplines[0] = (char *)" ^: more distortion.                    v: less effective against ticks.       ";
#line 48
  helplines[1] = (char *)" ^: less correction of distortion.      v: more (faulty) correction.           ";
#line 48
  helplines[2] = (char *)" Discard changes.                                                              ";
#line 48
  helplines[3] = (char *)" Accept changes.                                                               ";
#line 55
  medlength1str.maxlen = 500;
#line 56
  tmp = malloc((unsigned long )medlength1str.maxlen * sizeof(char ));
#line 56
  medlength1str.string = (char *)tmp;
#line 58
  sprintf((char */* __restrict  */)medlength1str.string, (char const   */* __restrict  */)"%ld",
          (parampointer->prelength1 + parampointer->postlength1) + 1L);
#line 60
  medlength1str.y = 6;
#line 61
  medlength1str.x = 57;
#line 62
  medlength1str.w = 19;
#line 63
  medlength1str.cursorpos = (int )strlen(medlength1str.string);
#line 64
  medlength1str.firstcharonscreen = 0;
#line 66
  medlength2str.maxlen = 500;
#line 67
  tmp___0 = malloc((unsigned long )medlength2str.maxlen * sizeof(char ));
#line 67
  medlength2str.string = (char *)tmp___0;
#line 69
  sprintf((char */* __restrict  */)medlength2str.string, (char const   */* __restrict  */)"%ld",
          (parampointer->prelength2 + parampointer->postlength2) + 1L);
#line 71
  medlength2str.y = 8;
#line 72
  medlength2str.x = 57;
#line 73
  medlength2str.w = 19;
#line 74
  medlength2str.cursorpos = (int )strlen(medlength2str.string);
#line 75
  medlength2str.firstcharonscreen = 0;
#line 77
  ok_button.text = (char *)" OK ";
#line 78
  ok_button.y = 20;
#line 79
  ok_button.x = 71;
#line 80
  ok_button.selected = 0;
#line 82
  cancel_button.text = (char *)" Cancel ";
#line 83
  cancel_button.y = 20;
#line 84
  cancel_button.x = 5;
#line 85
  cancel_button.selected = 0;
#line 87
  clearscreen((char *)"Double Median Filter - Parameters");
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    header((char *)"Double Median Filter - Parameters");
    }
#line 93
    if (focus == 2) {
#line 94
      cancel_button.selected = 1;
    } else {
#line 96
      cancel_button.selected = 0;
    }
#line 98
    if (focus == 3) {
#line 99
      ok_button.selected = 1;
    } else {
#line 101
      ok_button.selected = 0;
    }
    {
#line 103
    mvprintw(3, 2, "See the Signproc.txt file for the meaning of the parameters.");
#line 106
    stringinput_display(& medlength1str);
#line 107
    mvprintw(medlength1str.y, 2, "Number of samples for the first median:");
#line 110
    stringinput_display(& medlength2str);
#line 111
    mvprintw(medlength2str.y, 2, "Number of samples for the second (correction) median:");
#line 114
    button_display(& cancel_button);
#line 115
    tmp___1 = (int )strlen(cancel_button.text);
#line 115
    mybox(cancel_button.y - 1, cancel_button.x - 1, 3, tmp___1 + 2);
#line 117
    button_display(& ok_button);
#line 118
    tmp___2 = (int )strlen(ok_button.text);
#line 118
    mybox(ok_button.y - 1, ok_button.x - 1, 3, tmp___2 + 2);
#line 121
    helpline(helplines[focus]);
    }
    {
#line 125
    if (focus == 0) {
#line 125
      goto case_0;
    }
#line 128
    if (focus == 1) {
#line 128
      goto case_1;
    }
#line 131
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 126
    stringinput_display(& medlength1str);
    }
#line 127
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 129
    stringinput_display(& medlength2str);
    }
#line 130
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 132
    wmove(stdscr, 0, 79);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 135
    wrefresh(stdscr);
#line 137
    in_ch = wgetch(stdscr);
    }
    {
#line 141
    if (focus == 0) {
#line 141
      goto case_0___0;
    }
#line 164
    if (focus == 1) {
#line 164
      goto case_1___0;
    }
#line 187
    if (focus == 2) {
#line 187
      goto case_2;
    }
#line 207
    if (focus == 3) {
#line 207
      goto case_3;
    }
#line 139
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 142
    stringinput_stdkeys(in_ch, & medlength1str);
    }
    {
#line 146
    if (in_ch == 13) {
#line 146
      goto case_13;
    }
#line 146
    if (in_ch == 343) {
#line 146
      goto case_13;
    }
#line 155
    if (in_ch == 259) {
#line 155
      goto case_259;
    }
#line 158
    if (in_ch == 258) {
#line 158
      goto case_258;
    }
#line 143
    goto switch_break___1;
    case_13: /* CIL Label */ 
    case_343: /* CIL Label */ 
    {
#line 147
    i = sscanf((char const   */* __restrict  */)medlength1str.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 148
    if (i < 1) {
      {
#line 149
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else
#line 148
    if (helplong < 1L) {
      {
#line 149
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else
#line 148
    if (helplong % 2L == 0L) {
      {
#line 149
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else {
#line 152
      focus = 1;
    }
#line 153
    goto switch_break___1;
    case_259: /* CIL Label */ 
#line 156
    focus --;
#line 157
    goto switch_break___1;
    case_258: /* CIL Label */ 
#line 159
    focus ++;
#line 160
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 162
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 165
    stringinput_stdkeys(in_ch, & medlength2str);
    }
    {
#line 169
    if (in_ch == 13) {
#line 169
      goto case_13___0;
    }
#line 169
    if (in_ch == 343) {
#line 169
      goto case_13___0;
    }
#line 178
    if (in_ch == 259) {
#line 178
      goto case_259___0;
    }
#line 181
    if (in_ch == 258) {
#line 181
      goto case_258___0;
    }
#line 166
    goto switch_break___2;
    case_13___0: /* CIL Label */ 
    case_343___0: /* CIL Label */ 
    {
#line 170
    i = sscanf((char const   */* __restrict  */)medlength2str.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 171
    if (i < 1) {
      {
#line 172
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else
#line 171
    if (helplong < 1L) {
      {
#line 172
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else
#line 171
    if (helplong % 2L == 0L) {
      {
#line 172
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else {
#line 175
      focus = 3;
    }
#line 176
    goto switch_break___2;
    case_259___0: /* CIL Label */ 
#line 179
    focus --;
#line 180
    goto switch_break___2;
    case_258___0: /* CIL Label */ 
#line 182
    focus ++;
#line 183
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 185
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 191
    if (in_ch == 13) {
#line 191
      goto case_13___1;
    }
#line 191
    if (in_ch == 343) {
#line 191
      goto case_13___1;
    }
#line 197
    if (in_ch == 259) {
#line 197
      goto case_259___1;
    }
#line 197
    if (in_ch == 260) {
#line 197
      goto case_259___1;
    }
#line 201
    if (in_ch == 258) {
#line 201
      goto case_258___1;
    }
#line 201
    if (in_ch == 261) {
#line 201
      goto case_258___1;
    }
#line 188
    goto switch_break___3;
    case_13___1: /* CIL Label */ 
    case_343___1: /* CIL Label */ 
#line 192
    returnval = 0;
#line 193
    dont_stop = 0;
#line 194
    goto switch_break___3;
    case_259___1: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 198
    focus --;
#line 199
    goto switch_break___3;
    case_258___1: /* CIL Label */ 
    case_261: /* CIL Label */ 
#line 202
    focus ++;
#line 203
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 205
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 211
    if (in_ch == 13) {
#line 211
      goto case_13___2;
    }
#line 211
    if (in_ch == 343) {
#line 211
      goto case_13___2;
    }
#line 244
    if (in_ch == 259) {
#line 244
      goto case_259___2;
    }
#line 244
    if (in_ch == 260) {
#line 244
      goto case_259___2;
    }
#line 248
    if (in_ch == 258) {
#line 248
      goto case_258___2;
    }
#line 248
    if (in_ch == 261) {
#line 248
      goto case_258___2;
    }
#line 208
    goto switch_break___4;
    case_13___2: /* CIL Label */ 
    case_343___2: /* CIL Label */ 
    {
#line 212
    i = sscanf((char const   */* __restrict  */)medlength1str.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 213
    if (i < 1) {
      {
#line 215
      error_window((char *)"A whole, odd number, greater than 0, must be specified as first median length.");
#line 217
      medlength1str.cursorpos = (int )strlen(medlength1str.string);
#line 219
      focus = 0;
      }
#line 220
      goto switch_break___4;
    } else
#line 213
    if (helplong < 1L) {
      {
#line 215
      error_window((char *)"A whole, odd number, greater than 0, must be specified as first median length.");
#line 217
      medlength1str.cursorpos = (int )strlen(medlength1str.string);
#line 219
      focus = 0;
      }
#line 220
      goto switch_break___4;
    } else
#line 213
    if (helplong % 2L == 0L) {
      {
#line 215
      error_window((char *)"A whole, odd number, greater than 0, must be specified as first median length.");
#line 217
      medlength1str.cursorpos = (int )strlen(medlength1str.string);
#line 219
      focus = 0;
      }
#line 220
      goto switch_break___4;
    }
    {
#line 223
    parampointer->prelength1 = (helplong - 1L) / 2L;
#line 224
    parampointer->postlength1 = (helplong - 1L) / 2L;
#line 226
    i = sscanf((char const   */* __restrict  */)medlength2str.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 227
    if (i < 1) {
      {
#line 229
      error_window((char *)"A whole, odd number, greater than 0, must be specified as second median length.");
#line 231
      medlength2str.cursorpos = (int )strlen(medlength2str.string);
#line 233
      focus = 1;
      }
#line 234
      goto switch_break___4;
    } else
#line 227
    if (helplong < 1L) {
      {
#line 229
      error_window((char *)"A whole, odd number, greater than 0, must be specified as second median length.");
#line 231
      medlength2str.cursorpos = (int )strlen(medlength2str.string);
#line 233
      focus = 1;
      }
#line 234
      goto switch_break___4;
    } else
#line 227
    if (helplong % 2L == 0L) {
      {
#line 229
      error_window((char *)"A whole, odd number, greater than 0, must be specified as second median length.");
#line 231
      medlength2str.cursorpos = (int )strlen(medlength2str.string);
#line 233
      focus = 1;
      }
#line 234
      goto switch_break___4;
    }
#line 237
    parampointer->prelength2 = (helplong - 1L) / 2L;
#line 238
    parampointer->postlength2 = (helplong - 1L) / 2L;
#line 240
    dont_stop = 0;
#line 241
    goto switch_break___4;
    case_259___2: /* CIL Label */ 
    case_260___0: /* CIL Label */ 
#line 245
    focus --;
#line 246
    goto switch_break___4;
    case_258___2: /* CIL Label */ 
    case_261___0: /* CIL Label */ 
#line 249
    focus ++;
#line 250
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 252
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 255
    if (in_ch == 9) {
#line 256
      focus ++;
    }
#line 258
    if (in_ch == 27) {
#line 259
      dont_stop = 0;
    }
#line 261
    if (focus > 3) {
#line 262
      focus = 0;
    }
#line 263
    if (focus < 0) {
#line 264
      focus = 3;
    }
#line 89
    if (! dont_stop) {
#line 89
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 268
  free((void *)medlength1str.string);
#line 269
  free((void *)medlength2str.string);
  }
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_doubmed.c"
void init_double_median_filter(int filterno , parampointer_t parampointer ) 
{ 
  long total_post ;

  {
#line 277
  total_post = parampointer->postlength2;
#line 278
  if (parampointer->postlength1 > total_post) {
#line 279
    total_post = parampointer->postlength1;
  }
  {
#line 281
  parampointer->buffer = init_buffer(total_post, parampointer->prelength1 + parampointer->prelength2);
#line 284
  parampointer->buffer2 = init_buffer(parampointer->postlength2, parampointer->prelength2);
#line 287
  parampointer->filterno = filterno;
  }
#line 288
  return;
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_doubmed.c"
void delete_double_median_filter(parampointer_t parampointer ) 
{ 


  {
  {
#line 293
  delete_buffer(& parampointer->buffer);
#line 294
  delete_buffer(& parampointer->buffer2);
  }
#line 295
  return;
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_doubmed.c"
sample_t double_median_1(long offset , long offset_zero , parampointer_t parampointer ) 
{ 
  sample_t sample ;
  short *list1 ;
  unsigned long __lengthoflist1 ;
  void *tmp ;
  short *list2 ;
  unsigned long __lengthoflist2 ;
  void *tmp___0 ;
  long i ;

  {
  {
#line 302
  __lengthoflist1 = (unsigned long )((parampointer->postlength1 + parampointer->prelength1) + 1L);
#line 302
  tmp = __builtin_alloca(sizeof(*list1) * __lengthoflist1);
#line 302
  list1 = (short *)tmp;
#line 303
  __lengthoflist2 = (unsigned long )((parampointer->postlength1 + parampointer->prelength1) + 1L);
#line 303
  tmp___0 = __builtin_alloca(sizeof(*list2) * __lengthoflist2);
#line 303
  list2 = (short *)tmp___0;
#line 306
  i = 0L;
  }
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! (i <= parampointer->postlength1 + parampointer->prelength1)) {
#line 306
      goto while_break;
    }
#line 309
    sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + ((((parampointer->buffer.currpos + i) - parampointer->postlength1) + offset) + offset_zero)));
#line 312
    *(list1 + i) = sample.left;
#line 313
    *(list2 + i) = sample.right;
#line 306
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 316
  sample.left = median(list1, (int )((parampointer->postlength1 + parampointer->prelength1) + 1L));
#line 318
  sample.right = median(list2, (int )((parampointer->postlength1 + parampointer->prelength1) + 1L));
  }
#line 320
  return (sample);
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_doubmed.c"
sample_t (*double_median_1_pointer)(long offset , long offset_zero , parampointer_t parampointer )  =    & double_median_1;
#line 325 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_doubmed.c"
sample_t double_median_filter(parampointer_t parampointer ) 
{ 
  sample_t sample ;
  sample_t sample2 ;
  sample_t returnval ;
  short *list1 ;
  unsigned long __lengthoflist1 ;
  void *tmp ;
  short *list2 ;
  unsigned long __lengthoflist2 ;
  void *tmp___0 ;
  long i ;
  long j ;
  short tmp___1 ;
  short tmp___2 ;

  {
  {
#line 331
  __lengthoflist1 = (unsigned long )((parampointer->postlength2 + parampointer->prelength2) + 1L);
#line 331
  tmp = __builtin_alloca(sizeof(*list1) * __lengthoflist1);
#line 331
  list1 = (short *)tmp;
#line 332
  __lengthoflist2 = (unsigned long )((parampointer->postlength2 + parampointer->prelength2) + 1L);
#line 332
  tmp___0 = __builtin_alloca(sizeof(*list2) * __lengthoflist2);
#line 332
  list2 = (short *)tmp___0;
#line 335
  advance_current_pos(& parampointer->buffer, parampointer->filterno);
#line 337
  advance_current_pos_custom(& parampointer->buffer2, double_median_1_pointer, 0L,
                             parampointer);
#line 343
  i = 0L;
  }
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! (i <= parampointer->postlength2 + parampointer->prelength2)) {
#line 343
      goto while_break;
    }
#line 346
    sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + ((parampointer->buffer.currpos + i) - parampointer->postlength2)));
#line 348
    sample2 = *(parampointer->buffer2.array + *(parampointer->buffer2.indextable + ((parampointer->buffer2.currpos + i) - parampointer->postlength2)));
#line 351
    j = (long )((int )sample.left - (int )sample2.left);
#line 352
    j /= 2L;
#line 353
    *(list1 + i) = (short )j;
#line 355
    j = (long )((int )sample.right - (int )sample2.right);
#line 356
    j /= 2L;
#line 357
    *(list2 + i) = (short )j;
#line 343
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  sample2 = *(parampointer->buffer2.array + *(parampointer->buffer2.indextable + parampointer->buffer2.currpos));
#line 362
  tmp___1 = median(list1, (int )((parampointer->postlength2 + parampointer->prelength2) + 1L));
#line 362
  returnval.left = (short )((int )tmp___1 * 2 + (int )sample2.left);
#line 366
  tmp___2 = median(list2, (int )((parampointer->postlength2 + parampointer->prelength2) + 1L));
#line 366
  returnval.right = (short )((int )tmp___2 * 2 + (int )sample2.right);
  }
#line 370
  return (returnval);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_median.c"
void simple_median_param_defaults(parampointer_t parampointer ) 
{ 


  {
#line 30
  parampointer->postlength1 = 1L;
#line 31
  parampointer->prelength1 = 1L;
#line 32
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_median.c"
void simple_median_param_screen(parampointer_t parampointer ) 
{ 
  stringinput_t medlengthstr ;
  button_t ok_button ;
  button_t cancel_button ;
  int dont_stop ;
  int returnval ;
  int focus ;
  int in_ch ;
  int i ;
  long helplong ;
  char *helplines[3] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 39
  dont_stop = 1;
#line 40
  returnval = 0;
#line 41
  focus = 0;
#line 46
  helplines[0] = (char *)" ^: broader ticks removed.              v: less distortion.                    ";
#line 46
  helplines[1] = (char *)" Discard changes.                                                              ";
#line 46
  helplines[2] = (char *)" Accept changes.                                                               ";
#line 52
  medlengthstr.maxlen = 500;
#line 53
  tmp = malloc((unsigned long )medlengthstr.maxlen * sizeof(char ));
#line 53
  medlengthstr.string = (char *)tmp;
#line 55
  sprintf((char */* __restrict  */)medlengthstr.string, (char const   */* __restrict  */)"%ld",
          (parampointer->prelength1 + parampointer->postlength1) + 1L);
#line 57
  medlengthstr.y = 6;
#line 58
  medlengthstr.x = 44;
#line 59
  medlengthstr.w = 19;
#line 60
  medlengthstr.cursorpos = (int )strlen(medlengthstr.string);
#line 61
  tmp___0 = (int )strlen(medlengthstr.string);
#line 61
  medlengthstr.firstcharonscreen = (tmp___0 - medlengthstr.w) + 2;
  }
#line 63
  if (medlengthstr.firstcharonscreen < 0) {
#line 64
    medlengthstr.firstcharonscreen = 0;
  }
  {
#line 66
  ok_button.text = (char *)" OK ";
#line 67
  ok_button.y = 20;
#line 68
  ok_button.x = 71;
#line 69
  ok_button.selected = 0;
#line 71
  cancel_button.text = (char *)" Cancel ";
#line 72
  cancel_button.y = 20;
#line 73
  cancel_button.x = 5;
#line 74
  cancel_button.selected = 0;
#line 76
  clearscreen((char *)"Simple Median filter - Parameters");
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    header((char *)"Simple Median filter - Parameters");
    }
#line 82
    if (focus == 1) {
#line 83
      cancel_button.selected = 1;
    } else {
#line 85
      cancel_button.selected = 0;
    }
#line 87
    if (focus == 2) {
#line 88
      ok_button.selected = 1;
    } else {
#line 90
      ok_button.selected = 0;
    }
    {
#line 92
    mvprintw(3, 2, "See the Signproc.txt file for the meaning of the parameters.");
#line 95
    stringinput_display(& medlengthstr);
#line 96
    mvprintw(medlengthstr.y, 2, "Number of samples to take the median of:");
#line 99
    button_display(& cancel_button);
#line 100
    tmp___1 = (int )strlen(cancel_button.text);
#line 100
    mybox(cancel_button.y - 1, cancel_button.x - 1, 3, tmp___1 + 2);
#line 102
    button_display(& ok_button);
#line 103
    tmp___2 = (int )strlen(ok_button.text);
#line 103
    mybox(ok_button.y - 1, ok_button.x - 1, 3, tmp___2 + 2);
#line 106
    helpline(helplines[focus]);
    }
#line 108
    if (focus == 0) {
      {
#line 109
      stringinput_display(& medlengthstr);
      }
    } else {
      {
#line 111
      wmove(stdscr, 0, 79);
      }
    }
    {
#line 113
    wrefresh(stdscr);
#line 115
    in_ch = wgetch(stdscr);
    }
    {
#line 119
    if (focus == 0) {
#line 119
      goto case_0;
    }
#line 142
    if (focus == 1) {
#line 142
      goto case_1;
    }
#line 162
    if (focus == 2) {
#line 162
      goto case_2;
    }
#line 117
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 120
    stringinput_stdkeys(in_ch, & medlengthstr);
    }
#line 121
    if (in_ch == 343) {
#line 121
      goto _L;
    } else
#line 121
    if (in_ch == 13) {
      _L: /* CIL Label */ 
      {
#line 123
      i = sscanf((char const   */* __restrict  */)medlengthstr.string, (char const   */* __restrict  */)"%li",
                 & helplong);
      }
#line 124
      if (i < 1) {
        {
#line 125
        error_window((char *)"A whole, odd number, greater than 0, must be specified.");
        }
      } else
#line 124
      if (helplong < 1L) {
        {
#line 125
        error_window((char *)"A whole, odd number, greater than 0, must be specified.");
        }
      } else
#line 124
      if (helplong % 2L == 0L) {
        {
#line 125
        error_window((char *)"A whole, odd number, greater than 0, must be specified.");
        }
      } else {
#line 128
        focus = 2;
      }
    } else {
      {
#line 133
      if (in_ch == 259) {
#line 133
        goto case_259;
      }
#line 136
      if (in_ch == 258) {
#line 136
        goto case_258;
      }
#line 131
      goto switch_break___0;
      case_259: /* CIL Label */ 
#line 134
      focus --;
#line 135
      goto switch_break___0;
      case_258: /* CIL Label */ 
#line 137
      focus ++;
#line 138
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 140
    goto switch_break;
    case_1: /* CIL Label */ 
#line 143
    if (in_ch == 343) {
#line 145
      returnval = 0;
#line 146
      dont_stop = 0;
    } else
#line 143
    if (in_ch == 13) {
#line 145
      returnval = 0;
#line 146
      dont_stop = 0;
    } else {
      {
#line 152
      if (in_ch == 259) {
#line 152
        goto case_259___0;
      }
#line 152
      if (in_ch == 260) {
#line 152
        goto case_259___0;
      }
#line 156
      if (in_ch == 258) {
#line 156
        goto case_258___0;
      }
#line 156
      if (in_ch == 261) {
#line 156
        goto case_258___0;
      }
#line 149
      goto switch_break___1;
      case_259___0: /* CIL Label */ 
      case_260: /* CIL Label */ 
#line 153
      focus --;
#line 154
      goto switch_break___1;
      case_258___0: /* CIL Label */ 
      case_261: /* CIL Label */ 
#line 157
      focus ++;
#line 158
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
#line 160
    goto switch_break;
    case_2: /* CIL Label */ 
#line 163
    if (in_ch == 343) {
#line 163
      goto _L___0;
    } else
#line 163
    if (in_ch == 13) {
      _L___0: /* CIL Label */ 
      {
#line 165
      i = sscanf((char const   */* __restrict  */)medlengthstr.string, (char const   */* __restrict  */)"%li",
                 & helplong);
      }
#line 166
      if (i < 1) {
        {
#line 168
        error_window((char *)"A whole, odd number, greater than 0, must be specified as median length.");
#line 170
        medlengthstr.cursorpos = (int )strlen(medlengthstr.string);
#line 172
        focus = 0;
        }
      } else
#line 166
      if (helplong < 1L) {
        {
#line 168
        error_window((char *)"A whole, odd number, greater than 0, must be specified as median length.");
#line 170
        medlengthstr.cursorpos = (int )strlen(medlengthstr.string);
#line 172
        focus = 0;
        }
      } else
#line 166
      if (helplong % 2L == 0L) {
        {
#line 168
        error_window((char *)"A whole, odd number, greater than 0, must be specified as median length.");
#line 170
        medlengthstr.cursorpos = (int )strlen(medlengthstr.string);
#line 172
        focus = 0;
        }
      } else {
#line 176
        parampointer->prelength1 = (helplong - 1L) / 2L;
#line 177
        parampointer->postlength1 = (helplong - 1L) / 2L;
#line 178
        dont_stop = 0;
      }
    } else {
      {
#line 185
      if (in_ch == 259) {
#line 185
        goto case_259___1;
      }
#line 185
      if (in_ch == 260) {
#line 185
        goto case_259___1;
      }
#line 189
      if (in_ch == 258) {
#line 189
        goto case_258___1;
      }
#line 189
      if (in_ch == 261) {
#line 189
        goto case_258___1;
      }
#line 182
      goto switch_break___2;
      case_259___1: /* CIL Label */ 
      case_260___0: /* CIL Label */ 
#line 186
      focus --;
#line 187
      goto switch_break___2;
      case_258___1: /* CIL Label */ 
      case_261___0: /* CIL Label */ 
#line 190
      focus ++;
#line 191
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    }
#line 193
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 196
    if (in_ch == 9) {
#line 197
      focus ++;
    }
#line 199
    if (in_ch == 27) {
#line 200
      dont_stop = 0;
    }
#line 202
    if (focus > 2) {
#line 203
      focus -= 3;
    }
#line 204
    if (focus < 0) {
#line 205
      focus += 3;
    }
#line 78
    if (! dont_stop) {
#line 78
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 209
  free((void *)medlengthstr.string);
  }
#line 210
  return;
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_median.c"
void init_simple_median_filter(int filterno , parampointer_t parampointer ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 215
  parampointer->buffer = init_buffer(parampointer->postlength1, parampointer->prelength1);
#line 218
  parampointer->filterno = filterno;
#line 220
  tmp = malloc((unsigned long )((parampointer->postlength1 + parampointer->prelength1) + 1L) * sizeof(short ));
#line 220
  parampointer->sslist1 = (short *)tmp;
#line 225
  tmp___0 = malloc((unsigned long )((parampointer->postlength1 + parampointer->prelength1) + 1L) * sizeof(short ));
#line 225
  parampointer->sslist2 = (short *)tmp___0;
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_median.c"
void delete_simple_median_filter(parampointer_t parampointer ) 
{ 


  {
  {
#line 234
  delete_buffer(& parampointer->buffer);
#line 235
  free((void *)parampointer->sslist1);
#line 236
  free((void *)parampointer->sslist2);
  }
#line 237
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_median.c"
sample_t simple_median_filter(parampointer_t parampointer ) 
{ 
  sample_t sample ;
  long i ;

  {
  {
#line 246
  advance_current_pos(& parampointer->buffer, parampointer->filterno);
#line 248
  i = 0L;
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! (i <= parampointer->postlength1 + parampointer->prelength1)) {
#line 248
      goto while_break;
    }
#line 251
    sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + ((parampointer->buffer.currpos + i) - parampointer->postlength1)));
#line 253
    *(parampointer->sslist1 + i) = sample.left;
#line 254
    *(parampointer->sslist2 + i) = sample.right;
#line 248
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  sample.left = median(parampointer->sslist1, (int )((parampointer->postlength1 + parampointer->prelength1) + 1L));
#line 260
  sample.right = median(parampointer->sslist2, (int )((parampointer->postlength1 + parampointer->prelength1) + 1L));
  }
#line 264
  return (sample);
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/stringinput.c"
void stringinput_display(stringinput_t *data ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 23
  if (data->cursorpos < 0) {
#line 24
    data->cursorpos = 0;
  }
  {
#line 25
  tmp = (int )strlen(data->string);
  }
#line 25
  if (data->cursorpos > tmp) {
    {
#line 26
    data->cursorpos = (int )strlen(data->string);
    }
  }
#line 28
  if (data->cursorpos < data->firstcharonscreen + 2) {
#line 29
    data->firstcharonscreen = data->cursorpos - 2;
  }
#line 30
  if (data->cursorpos >= data->firstcharonscreen + data->w) {
#line 31
    data->firstcharonscreen = (data->cursorpos - data->w) + 1;
  }
#line 33
  if (data->firstcharonscreen < 0) {
#line 34
    data->firstcharonscreen = 0;
  }
  {
#line 36
  wmove(stdscr, data->y, data->x);
#line 37
  i = data->firstcharonscreen;
  }
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp___0 = (int )strlen(data->string);
    }
#line 38
    if (i < tmp___0) {
#line 38
      if (! (i < data->firstcharonscreen + data->w)) {
#line 38
        goto while_break;
      }
    } else {
#line 38
      goto while_break;
    }
    {
#line 40
    waddch(stdscr, (chtype const   )*(data->string + i));
#line 41
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 44
    if (! (i < data->firstcharonscreen + data->w)) {
#line 44
      goto while_break___0;
    }
    {
#line 46
    waddch(stdscr, (chtype const   )' ');
#line 47
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 50
  wmove(stdscr, data->y, (data->x + data->cursorpos) - data->firstcharonscreen);
  }
#line 51
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/stringinput.c"
void stringinput_stdkeys(int key , stringinput_t *data ) 
{ 
  char helpstring[500] ;
  int tmp ;

  {
  {
#line 60
  if (key == 260) {
#line 60
    goto case_260;
  }
#line 64
  if (key == 261) {
#line 64
    goto case_261;
  }
#line 68
  if (key == 262) {
#line 68
    goto case_262;
  }
#line 72
  if (key == 360) {
#line 72
    goto case_360;
  }
#line 78
  if (key == 127) {
#line 78
    goto case_127;
  }
#line 78
  if (key == 263) {
#line 78
    goto case_127;
  }
#line 58
  goto switch_break;
  case_260: /* CIL Label */ 
#line 61
  (data->cursorpos) --;
#line 62
  goto switch_break;
  case_261: /* CIL Label */ 
#line 65
  (data->cursorpos) ++;
#line 66
  goto switch_break;
  case_262: /* CIL Label */ 
#line 69
  data->cursorpos = 0;
#line 70
  goto switch_break;
  case_360: /* CIL Label */ 
  {
#line 73
  data->cursorpos = (int )strlen(data->string);
  }
#line 74
  goto switch_break;
  case_127: /* CIL Label */ 
  case_263: /* CIL Label */ 
#line 80
  if (data->cursorpos > 0) {
    {
#line 82
    strcpy(helpstring, data->string);
#line 83
    strcpy((helpstring + data->cursorpos) - 1, data->string + data->cursorpos);
#line 85
    strcpy(data->string, helpstring);
#line 86
    (data->cursorpos) --;
    }
  }
#line 88
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 103
  if (key >= 32) {
#line 103
    if (key <= 126) {
      {
#line 105
      strcpy(helpstring, data->string);
#line 106
      strcpy((helpstring + data->cursorpos) + 1, data->string + data->cursorpos);
#line 108
      helpstring[data->cursorpos] = (char )key;
#line 109
      strcpy(data->string, helpstring);
#line 110
      (data->cursorpos) ++;
      }
    }
  }
#line 113
  if (data->cursorpos < 0) {
#line 114
    data->cursorpos = 0;
  }
  {
#line 115
  tmp = (int )strlen(data->string);
  }
#line 115
  if (data->cursorpos > tmp) {
    {
#line 116
    data->cursorpos = (int )strlen(data->string);
    }
  }
#line 117
  return;
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/mainmenu.h"
void displaymenu_onscreen(char **options , char **helptext , int number , int selected ,
                          int y , int x , int distance ) ;
#line 24
int displaymenu(char **options , char **helptext , int number , int preselected ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/reclp_main.h"
void record_from_lp(char *startdir ) ;
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 1606 "/usr/include/curses.h"
extern int getmouse(MEVENT * ) ;
#line 1608
extern mmask_t mousemask(mmask_t  , mmask_t * ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/mainmenu.c"
void displaymenu_onscreen(char **options , char **helptext , int number , int selected ,
                          int y , int x , int distance ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 38
  i = 0;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! (i < number)) {
#line 38
      goto while_break;
    }
    {
#line 40
    mvprintw(y + i * distance, x, "%d.", i + 1);
    }
#line 42
    if (i == selected) {
      {
#line 43
      wattr_on(stdscr, 1UL << 16, (void *)0);
      }
    }
    {
#line 44
    tmp = wmove(stdscr, y + i * distance, x + 3);
    }
#line 44
    if (! (tmp == -1)) {
      {
#line 44
      waddnstr(stdscr, (char const   *)*(options + i), -1);
      }
    }
#line 45
    if (i == selected) {
      {
#line 46
      wattr_off(stdscr, 1UL << 16, (void *)0);
      }
    }
#line 38
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 49
  tmp___0 = wmove(stdscr, 16, 1);
  }
#line 49
  if (! (tmp___0 == -1)) {
    {
#line 49
    waddnstr(stdscr, (char const   *)*(options + selected), -1);
    }
  }
  {
#line 51
  display_textwin(*(helptext + selected), 17, 2, 5, 76);
#line 53
  wmove(stdscr, 0, 79);
#line 55
  wrefresh(stdscr);
  }
#line 56
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/mainmenu.c"
int displaymenu(char **options , char **helptext , int number , int preselected ) 
{ 
  int i ;
  int selected ;
  int exitfunc ;
  int in_ch ;
  MEVENT mouse_event ;
  int tmp ;

  {
#line 66
  exitfunc = 0;
#line 79
  selected = preselected;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 83
    displaymenu_onscreen(options, helptext, number, selected, 3, 5, 2);
#line 88
    in_ch = wgetch(stdscr);
    }
#line 91
    if (in_ch == 409) {
      {
#line 93
      getmouse(& mouse_event);
      }
#line 95
      if (mouse_event.bstate == 4UL) {
#line 95
        goto _L;
      } else
#line 95
      if (mouse_event.bstate == 8UL) {
        _L: /* CIL Label */ 
#line 99
        i = 0;
        {
#line 99
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 99
          if (! (i < number)) {
#line 99
            goto while_break___0;
          }
#line 100
          if (mouse_event.y == 3 + i * 2) {
#line 100
            if (mouse_event.x >= 5) {
              {
#line 100
              tmp = (int )strlen(*(options + i));
              }
#line 100
              if (mouse_event.x < 8 + tmp) {
                {
#line 109
                displaymenu_onscreen(options, helptext, number, i, 3, 5, 2);
#line 115
                usleep((__useconds_t )100000);
#line 116
                selected = i;
#line 117
                exitfunc = 1;
                }
              }
            }
          }
#line 99
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    {
#line 128
    if (in_ch == 259) {
#line 128
      goto case_259;
    }
#line 128
    if (in_ch == 75) {
#line 128
      goto case_259;
    }
#line 128
    if (in_ch == 107) {
#line 128
      goto case_259;
    }
#line 134
    if (in_ch == 258) {
#line 134
      goto case_258;
    }
#line 134
    if (in_ch == 74) {
#line 134
      goto case_258;
    }
#line 134
    if (in_ch == 106) {
#line 134
      goto case_258;
    }
#line 138
    if (in_ch == 9) {
#line 138
      goto case_9;
    }
#line 145
    if (in_ch == 343) {
#line 145
      goto case_343;
    }
#line 145
    if (in_ch == 13) {
#line 145
      goto case_343;
    }
#line 124
    goto switch_break;
    case_259: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
#line 129
    selected --;
#line 130
    goto switch_break;
    case_258: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_106: /* CIL Label */ 
#line 135
    selected ++;
#line 136
    goto switch_break;
    case_9: /* CIL Label */ 
#line 139
    selected ++;
#line 140
    if (selected >= number) {
#line 141
      selected = 0;
    }
#line 142
    goto switch_break;
    case_343: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 146
    exitfunc = 1;
#line 147
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 150
    if (in_ch >= 49) {
#line 150
      if (in_ch <= 57) {
#line 152
        selected = in_ch - 49;
#line 153
        if (selected < number) {
          {
#line 155
          displaymenu_onscreen(options, helptext, number, selected, 3, 5, 2);
#line 160
          usleep((__useconds_t )100000);
#line 161
          exitfunc = 1;
          }
        }
      }
    }
#line 165
    if (selected < 0) {
#line 166
      selected = 0;
    }
#line 167
    if (selected >= number) {
#line 168
      selected = number - 1;
    }
#line 170
    if (in_ch == 27) {
#line 173
      selected = -1;
#line 174
      exitfunc = 1;
    } else
#line 170
    if (in_ch == 113) {
#line 173
      selected = -1;
#line 174
      exitfunc = 1;
    } else
#line 170
    if (in_ch == 81) {
#line 173
      selected = -1;
#line 174
      exitfunc = 1;
    } else
#line 170
    if (in_ch == 48) {
#line 173
      selected = -1;
#line 174
      exitfunc = 1;
    }
#line 81
    if (! (! exitfunc)) {
#line 81
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  mousemask((mmask_t )0, (mmask_t *)((void *)0));
  }
#line 183
  return (selected);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/mainmenu.c"
void mainmenu(char *startdir ) 
{ 
  int selected ;
  char *menu_options[6] ;
  char *menu_helptext[6] ;

  {
#line 189
  selected = 0;
#line 192
  menu_options[0] = (char *)"Record audio to a sound file           ";
#line 192
  menu_options[1] = (char *)"[Copy sound from an audio CD to a file]";
#line 192
  menu_options[2] = (char *)"Locate tracks                          ";
#line 192
  menu_options[3] = (char *)"Process the audio signal               ";
#line 192
  menu_options[4] = (char *)"[Write an audio CD]                    ";
#line 192
  menu_options[5] = (char *)"Play a sound file                      ";
#line 201
  menu_helptext[0] = (char *)"With this option, audio from various sources (like gramophone records) can be recorded (sampled). The digital audio data is stored in a sound file (.wav format) on the harddisk.";
#line 201
  menu_helptext[1] = (char *)"This option is not implemented yet. You can use the `cdda2wav\' or `cdparanoia\' program to copy digital audio from a CD to a sound file (.wav format) on the harddisk.";
#line 201
  menu_helptext[2] = (char *)"The starts and ends of tracks in a large sound file can be detected automatically with this option. The `process signal\' option uses the resulting .tracks file to actually split tracks.";
#line 201
  menu_helptext[3] = (char *)"With this option, the digital audio from a sound file on the harddisk can be processed. For example, ticks may be filtered out. If track separation points are computed (previous option), separate audio files will be generated, each containing one track.";
#line 201
  menu_helptext[4] = (char *)"This option is not implemented yet. You can use the `cdrecord\' or `xcdroast\' program to create CDs from sound files on the harddisk.";
#line 201
  menu_helptext[5] = (char *)"(Parts of) sound files can be played with this option.";
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 230
    clearscreen((char *)"Main Menu");
#line 231
    helpline((char *)" Arrows/TAB: Navigate           Enter: Select option           0/Q/Escape: Exit ");
#line 234
    selected = displaymenu(menu_options, menu_helptext, 6, selected);
    }
    {
#line 239
    if (selected == 0) {
#line 239
      goto case_0;
    }
#line 243
    if (selected == 1) {
#line 243
      goto case_1;
    }
#line 247
    if (selected == 2) {
#line 247
      goto case_2;
    }
#line 251
    if (selected == 3) {
#line 251
      goto case_3;
    }
#line 255
    if (selected == 4) {
#line 255
      goto case_4;
    }
#line 259
    if (selected == 5) {
#line 259
      goto case_5;
    }
#line 237
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 240
    record_from_lp(startdir);
    }
#line 241
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 244
    error_window((char *)"This option has not yet been implemented.");
    }
#line 245
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 248
    tracksplit_main(startdir);
    }
#line 249
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 252
    signproc_main(startdir);
    }
#line 253
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 256
    error_window((char *)"This option has not yet been implemented.");
    }
#line 257
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 260
    playwav_main(startdir);
    }
#line 261
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 228
    if (! (selected != -1)) {
#line 228
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/tracksplit_parammenu.c"
int tracksplit_parammenu(int *make_use_rms , int *make_graphs , long *blocklen , int *global_silence_factor ,
                         int *local_silence_threshold , int *min_silence_blocks ,
                         int *min_track_blocks , int *extra_blocks_start , int *extra_blocks_end ) 
{ 
  button_t next_button ;
  button_t cancel_button ;
  button_t prev_button ;
  button_t make_use_rms_check ;
  button_t make_graphs_check ;
  stringinput_t blocklen_string ;
  stringinput_t global_silence_factor_string ;
  stringinput_t local_silence_threshold_string ;
  stringinput_t min_silence_blocks_string ;
  stringinput_t min_track_blocks_string ;
  stringinput_t extra_blocks_start_string ;
  stringinput_t extra_blocks_end_string ;
  int dont_stop ;
  int returnval ;
  int focus ;
  int in_ch ;
  long templong ;
  char *helplines[12] ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 39
  dont_stop = 1;
#line 40
  returnval = 0;
#line 41
  focus = 11;
#line 45
  helplines[0] = (char *)" Save results or use saved results of lengthy computation.      TAB: Next field";
#line 45
  helplines[1] = (char *)" For manual (double-)checking/adjustment. Needs a few MB\'s.     TAB: Next field";
#line 45
  helplines[2] = (char *)" Number of samples to compute RMS of; 4410 = 0.1 sec.           TAB: Next field";
#line 45
  helplines[3] = (char *)" The relative threshold during the initial search for tracks.   TAB: Next field";
#line 45
  helplines[4] = (char *)" Begin/end of track ...% above local (silence) power level.     TAB: Next field";
#line 45
  helplines[5] = (char *)" Shorter periods of silence not treated as track separation.    TAB: Next field";
#line 45
  helplines[6] = (char *)" Shorter tracks are ignored.                                    TAB: Next field";
#line 45
  helplines[7] = (char *)" Correction for fade-in effects that are hard to detect.        TAB: Next field";
#line 45
  helplines[8] = (char *)" Correction for fade-out effects that are hard to detect.       TAB: Next field";
#line 45
  helplines[9] = (char *)" To Track Splitting - File Name.                                TAB: Next field";
#line 45
  helplines[10] = (char *)" Back to main menu.                                             TAB: Next field";
#line 45
  helplines[11] = (char *)" Start searching for tracks.                                    TAB: Next field";
#line 60
  make_use_rms_check.text = (char *)"";
#line 61
  make_use_rms_check.y = 4;
#line 62
  make_use_rms_check.x = 2;
#line 63
  make_use_rms_check.selected = 0;
#line 65
  make_graphs_check.text = (char *)"";
#line 66
  make_graphs_check.y = 6;
#line 67
  make_graphs_check.x = 2;
#line 68
  make_graphs_check.selected = 0;
#line 70
  blocklen_string.maxlen = 500;
#line 71
  tmp = malloc((unsigned long )blocklen_string.maxlen * sizeof(char ));
#line 71
  blocklen_string.string = (char *)tmp;
#line 73
  sprintf((char */* __restrict  */)blocklen_string.string, (char const   */* __restrict  */)"%ld",
          *blocklen);
#line 74
  blocklen_string.y = 8;
#line 75
  blocklen_string.x = 54;
#line 76
  blocklen_string.w = 12;
#line 77
  blocklen_string.cursorpos = (int )strlen(blocklen_string.string);
#line 79
  blocklen_string.firstcharonscreen = 0;
#line 81
  global_silence_factor_string.maxlen = 500;
#line 82
  tmp___0 = malloc((unsigned long )global_silence_factor_string.maxlen * sizeof(char ));
#line 82
  global_silence_factor_string.string = (char *)tmp___0;
#line 84
  sprintf((char */* __restrict  */)global_silence_factor_string.string, (char const   */* __restrict  */)"%d",
          *global_silence_factor);
#line 86
  global_silence_factor_string.y = 10;
#line 87
  global_silence_factor_string.x = 54;
#line 88
  global_silence_factor_string.w = 12;
#line 89
  global_silence_factor_string.cursorpos = (int )strlen(global_silence_factor_string.string);
#line 91
  global_silence_factor_string.firstcharonscreen = 0;
#line 93
  local_silence_threshold_string.maxlen = 500;
#line 94
  tmp___1 = malloc((unsigned long )local_silence_threshold_string.maxlen * sizeof(char ));
#line 94
  local_silence_threshold_string.string = (char *)tmp___1;
#line 96
  sprintf((char */* __restrict  */)local_silence_threshold_string.string, (char const   */* __restrict  */)"%d",
          *local_silence_threshold);
#line 98
  local_silence_threshold_string.y = 11;
#line 99
  local_silence_threshold_string.x = 54;
#line 100
  local_silence_threshold_string.w = 12;
#line 101
  local_silence_threshold_string.cursorpos = (int )strlen(local_silence_threshold_string.string);
#line 103
  local_silence_threshold_string.firstcharonscreen = 0;
#line 105
  min_silence_blocks_string.maxlen = 500;
#line 106
  tmp___2 = malloc((unsigned long )min_silence_blocks_string.maxlen * sizeof(char ));
#line 106
  min_silence_blocks_string.string = (char *)tmp___2;
#line 108
  sprintf((char */* __restrict  */)min_silence_blocks_string.string, (char const   */* __restrict  */)"%d",
          *min_silence_blocks);
#line 110
  min_silence_blocks_string.y = 13;
#line 111
  min_silence_blocks_string.x = 54;
#line 112
  min_silence_blocks_string.w = 12;
#line 113
  min_silence_blocks_string.cursorpos = (int )strlen(min_silence_blocks_string.string);
#line 115
  min_silence_blocks_string.firstcharonscreen = 0;
#line 117
  min_track_blocks_string.maxlen = 500;
#line 118
  tmp___3 = malloc((unsigned long )min_track_blocks_string.maxlen * sizeof(char ));
#line 118
  min_track_blocks_string.string = (char *)tmp___3;
#line 120
  sprintf((char */* __restrict  */)min_track_blocks_string.string, (char const   */* __restrict  */)"%d",
          *min_track_blocks);
#line 122
  min_track_blocks_string.y = 14;
#line 123
  min_track_blocks_string.x = 54;
#line 124
  min_track_blocks_string.w = 12;
#line 125
  min_track_blocks_string.cursorpos = (int )strlen(min_track_blocks_string.string);
#line 127
  min_track_blocks_string.firstcharonscreen = 0;
#line 129
  extra_blocks_start_string.maxlen = 500;
#line 130
  tmp___4 = malloc((unsigned long )extra_blocks_start_string.maxlen * sizeof(char ));
#line 130
  extra_blocks_start_string.string = (char *)tmp___4;
#line 132
  sprintf((char */* __restrict  */)extra_blocks_start_string.string, (char const   */* __restrict  */)"%d",
          *extra_blocks_start);
#line 134
  extra_blocks_start_string.y = 16;
#line 135
  extra_blocks_start_string.x = 54;
#line 136
  extra_blocks_start_string.w = 12;
#line 137
  extra_blocks_start_string.cursorpos = (int )strlen(extra_blocks_start_string.string);
#line 139
  extra_blocks_start_string.firstcharonscreen = 0;
#line 141
  extra_blocks_end_string.maxlen = 500;
#line 142
  tmp___5 = malloc((unsigned long )extra_blocks_end_string.maxlen * sizeof(char ));
#line 142
  extra_blocks_end_string.string = (char *)tmp___5;
#line 144
  sprintf((char */* __restrict  */)extra_blocks_end_string.string, (char const   */* __restrict  */)"%d",
          *extra_blocks_end);
#line 146
  extra_blocks_end_string.y = 17;
#line 147
  extra_blocks_end_string.x = 54;
#line 148
  extra_blocks_end_string.w = 12;
#line 149
  extra_blocks_end_string.cursorpos = (int )strlen(extra_blocks_end_string.string);
#line 151
  extra_blocks_end_string.firstcharonscreen = 0;
#line 153
  prev_button.text = (char *)" < Previous screen ";
#line 154
  prev_button.y = 20;
#line 155
  prev_button.x = 5;
#line 156
  prev_button.selected = 0;
#line 158
  next_button.text = (char *)" Start computation ";
#line 159
  next_button.y = 20;
#line 160
  next_button.x = 56;
#line 161
  next_button.selected = 0;
#line 163
  cancel_button.text = (char *)" Cancel ";
#line 164
  cancel_button.y = 20;
#line 165
  cancel_button.x = 36;
#line 166
  cancel_button.selected = 0;
#line 168
  clearscreen((char *)"Track Location - Parameters");
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 172
    header((char *)"Track Location - Parameters");
    }
#line 174
    if (*make_use_rms) {
#line 175
      make_use_rms_check.text = (char *)"[X]";
    } else {
#line 177
      make_use_rms_check.text = (char *)"[ ]";
    }
#line 179
    if (*make_graphs) {
#line 180
      make_graphs_check.text = (char *)"[X]";
    } else {
#line 182
      make_graphs_check.text = (char *)"[ ]";
    }
#line 184
    if (focus == 0) {
#line 185
      make_use_rms_check.selected = 1;
    } else {
#line 187
      make_use_rms_check.selected = 0;
    }
#line 189
    if (focus == 1) {
#line 190
      make_graphs_check.selected = 1;
    } else {
#line 192
      make_graphs_check.selected = 0;
    }
#line 194
    if (focus == 9) {
#line 195
      prev_button.selected = 1;
    } else {
#line 197
      prev_button.selected = 0;
    }
#line 199
    if (focus == 10) {
#line 200
      cancel_button.selected = 1;
    } else {
#line 202
      cancel_button.selected = 0;
    }
#line 204
    if (focus == 11) {
#line 205
      next_button.selected = 1;
    } else {
#line 207
      next_button.selected = 0;
    }
    {
#line 209
    stringinput_display(& blocklen_string);
#line 210
    mvprintw(blocklen_string.y, 2, "Length of blocks of signal power data (samples)   :");
#line 213
    stringinput_display(& global_silence_factor_string);
#line 214
    mvprintw(global_silence_factor_string.y, 2, "Global silence factor (0.1 %)                     :");
#line 217
    stringinput_display(& local_silence_threshold_string);
#line 218
    mvprintw(local_silence_threshold_string.y, 2, "Local silence factor (%)                          :");
#line 221
    stringinput_display(& min_silence_blocks_string);
#line 222
    mvprintw(min_silence_blocks_string.y, 2, "Minimal length of inter-track silence (blocks)    :");
#line 225
    stringinput_display(& min_track_blocks_string);
#line 226
    mvprintw(min_track_blocks_string.y, 2, "Minimal length of tracks (blocks)                 :");
#line 229
    stringinput_display(& extra_blocks_start_string);
#line 230
    mvprintw(extra_blocks_start_string.y, 2, "Number of extra blocks at track start             :");
#line 233
    stringinput_display(& extra_blocks_end_string);
#line 234
    mvprintw(extra_blocks_end_string.y, 2, "Number of extra blocks at track end               :");
#line 237
    button_display(& prev_button);
#line 238
    tmp___6 = (int )strlen(prev_button.text);
#line 238
    mybox(prev_button.y - 1, prev_button.x - 1, 3, tmp___6 + 2);
#line 240
    button_display(& cancel_button);
#line 241
    tmp___7 = (int )strlen(cancel_button.text);
#line 241
    mybox(cancel_button.y - 1, cancel_button.x - 1, 3, tmp___7 + 2);
#line 243
    button_display(& next_button);
#line 244
    tmp___8 = (int )strlen(next_button.text);
#line 244
    mybox(next_button.y - 1, next_button.x - 1, 3, tmp___8 + 2);
#line 247
    button_display(& make_use_rms_check);
#line 248
    mvprintw(make_use_rms_check.y, make_use_rms_check.x + 4, "Save/load signal power (RMS) data to/from .rms file");
#line 251
    button_display(& make_graphs_check);
#line 252
    mvprintw(make_graphs_check.y, make_graphs_check.x + 4, "Generate graph files");
#line 255
    helpline(helplines[focus]);
    }
    {
#line 259
    if (focus == 2) {
#line 259
      goto case_2;
    }
#line 262
    if (focus == 3) {
#line 262
      goto case_3;
    }
#line 265
    if (focus == 4) {
#line 265
      goto case_4;
    }
#line 268
    if (focus == 5) {
#line 268
      goto case_5;
    }
#line 271
    if (focus == 6) {
#line 271
      goto case_6;
    }
#line 274
    if (focus == 7) {
#line 274
      goto case_7;
    }
#line 277
    if (focus == 8) {
#line 277
      goto case_8;
    }
#line 280
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 260
    stringinput_display(& blocklen_string);
    }
#line 261
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 263
    stringinput_display(& global_silence_factor_string);
    }
#line 264
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 266
    stringinput_display(& local_silence_threshold_string);
    }
#line 267
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 269
    stringinput_display(& min_silence_blocks_string);
    }
#line 270
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 272
    stringinput_display(& min_track_blocks_string);
    }
#line 273
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 275
    stringinput_display(& extra_blocks_start_string);
    }
#line 276
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 278
    stringinput_display(& extra_blocks_end_string);
    }
#line 279
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 281
    wmove(stdscr, 0, 79);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 284
    wrefresh(stdscr);
#line 286
    in_ch = wgetch(stdscr);
    }
    {
#line 290
    if (focus == 0) {
#line 290
      goto case_0;
    }
#line 312
    if (focus == 1) {
#line 312
      goto case_1;
    }
#line 334
    if (focus == 2) {
#line 334
      goto case_2___0;
    }
#line 368
    if (focus == 3) {
#line 368
      goto case_3___0;
    }
#line 405
    if (focus == 4) {
#line 405
      goto case_4___0;
    }
#line 443
    if (focus == 5) {
#line 443
      goto case_5___0;
    }
#line 481
    if (focus == 6) {
#line 481
      goto case_6___0;
    }
#line 519
    if (focus == 7) {
#line 519
      goto case_7___0;
    }
#line 557
    if (focus == 8) {
#line 557
      goto case_8___0;
    }
#line 595
    if (focus == 9) {
#line 595
      goto case_9;
    }
#line 615
    if (focus == 10) {
#line 615
      goto case_10;
    }
#line 635
    if (focus == 11) {
#line 635
      goto case_11;
    }
#line 288
    goto switch_break___0;
    case_0: /* CIL Label */ 
    {
#line 297
    if (in_ch == 88) {
#line 297
      goto case_88;
    }
#line 297
    if (in_ch == 120) {
#line 297
      goto case_88;
    }
#line 297
    if (in_ch == 32) {
#line 297
      goto case_88;
    }
#line 297
    if (in_ch == 13) {
#line 297
      goto case_88;
    }
#line 297
    if (in_ch == 343) {
#line 297
      goto case_88;
    }
#line 302
    if (in_ch == 259) {
#line 302
      goto case_259;
    }
#line 302
    if (in_ch == 260) {
#line 302
      goto case_259;
    }
#line 306
    if (in_ch == 258) {
#line 306
      goto case_258;
    }
#line 306
    if (in_ch == 261) {
#line 306
      goto case_258;
    }
#line 291
    goto switch_break___1;
    case_88: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_343: /* CIL Label */ 
#line 298
    *make_use_rms = 1 - *make_use_rms;
#line 299
    goto switch_break___1;
    case_259: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 303
    focus --;
#line 304
    goto switch_break___1;
    case_258: /* CIL Label */ 
    case_261: /* CIL Label */ 
#line 307
    focus ++;
#line 308
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 310
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 319
    if (in_ch == 88) {
#line 319
      goto case_88___0;
    }
#line 319
    if (in_ch == 120) {
#line 319
      goto case_88___0;
    }
#line 319
    if (in_ch == 32) {
#line 319
      goto case_88___0;
    }
#line 319
    if (in_ch == 13) {
#line 319
      goto case_88___0;
    }
#line 319
    if (in_ch == 343) {
#line 319
      goto case_88___0;
    }
#line 324
    if (in_ch == 259) {
#line 324
      goto case_259___0;
    }
#line 324
    if (in_ch == 260) {
#line 324
      goto case_259___0;
    }
#line 328
    if (in_ch == 258) {
#line 328
      goto case_258___0;
    }
#line 328
    if (in_ch == 261) {
#line 328
      goto case_258___0;
    }
#line 313
    goto switch_break___2;
    case_88___0: /* CIL Label */ 
    case_120___0: /* CIL Label */ 
    case_32___0: /* CIL Label */ 
    case_13___0: /* CIL Label */ 
    case_343___0: /* CIL Label */ 
#line 320
    *make_graphs = 1 - *make_graphs;
#line 321
    goto switch_break___2;
    case_259___0: /* CIL Label */ 
    case_260___0: /* CIL Label */ 
#line 325
    focus --;
#line 326
    goto switch_break___2;
    case_258___0: /* CIL Label */ 
    case_261___0: /* CIL Label */ 
#line 329
    focus ++;
#line 330
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 332
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 335
    stringinput_stdkeys(in_ch, & blocklen_string);
    }
    {
#line 339
    if (in_ch == 13) {
#line 339
      goto case_13___1;
    }
#line 339
    if (in_ch == 343) {
#line 339
      goto case_13___1;
    }
#line 359
    if (in_ch == 259) {
#line 359
      goto case_259___1;
    }
#line 362
    if (in_ch == 258) {
#line 362
      goto case_258___1;
    }
#line 336
    goto switch_break___3;
    case_13___1: /* CIL Label */ 
    case_343___1: /* CIL Label */ 
    {
#line 340
    templong = atol((char const   *)blocklen_string.string);
    }
#line 341
    if (templong < 1L) {
      {
#line 343
      error_window((char *)"Enter a whole number, greater than 0. Default: 4410.");
#line 345
      blocklen_string.cursorpos = (int )strlen(blocklen_string.string);
      }
    } else {
      {
#line 350
      *blocklen = templong;
#line 351
      sprintf((char */* __restrict  */)blocklen_string.string, (char const   */* __restrict  */)"%ld",
              templong);
#line 353
      blocklen_string.cursorpos = (int )strlen(blocklen_string.string);
#line 355
      focus ++;
      }
    }
#line 357
    goto switch_break___3;
    case_259___1: /* CIL Label */ 
#line 360
    focus --;
#line 361
    goto switch_break___3;
    case_258___1: /* CIL Label */ 
#line 363
    focus ++;
#line 364
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 366
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 369
    stringinput_stdkeys(in_ch, & global_silence_factor_string);
    }
    {
#line 374
    if (in_ch == 13) {
#line 374
      goto case_13___2;
    }
#line 374
    if (in_ch == 343) {
#line 374
      goto case_13___2;
    }
#line 396
    if (in_ch == 259) {
#line 396
      goto case_259___2;
    }
#line 399
    if (in_ch == 258) {
#line 399
      goto case_258___2;
    }
#line 371
    goto switch_break___4;
    case_13___2: /* CIL Label */ 
    case_343___2: /* CIL Label */ 
    {
#line 375
    templong = atol((char const   *)global_silence_factor_string.string);
    }
#line 377
    if (templong < 0L) {
      {
#line 379
      error_window((char *)"Enter a whole, positive number, preferably less than 1000. Default: 150.");
#line 381
      global_silence_factor_string.cursorpos = (int )strlen(global_silence_factor_string.string);
      }
    } else
#line 377
    if (templong > 10000L) {
      {
#line 379
      error_window((char *)"Enter a whole, positive number, preferably less than 1000. Default: 150.");
#line 381
      global_silence_factor_string.cursorpos = (int )strlen(global_silence_factor_string.string);
      }
    } else {
      {
#line 387
      *global_silence_factor = (int )templong;
#line 388
      sprintf((char */* __restrict  */)global_silence_factor_string.string, (char const   */* __restrict  */)"%ld",
              templong);
#line 390
      global_silence_factor_string.cursorpos = (int )strlen(global_silence_factor_string.string);
#line 392
      focus ++;
      }
    }
#line 394
    goto switch_break___4;
    case_259___2: /* CIL Label */ 
#line 397
    focus --;
#line 398
    goto switch_break___4;
    case_258___2: /* CIL Label */ 
#line 400
    focus ++;
#line 401
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 403
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 406
    stringinput_stdkeys(in_ch, & local_silence_threshold_string);
    }
    {
#line 411
    if (in_ch == 13) {
#line 411
      goto case_13___3;
    }
#line 411
    if (in_ch == 343) {
#line 411
      goto case_13___3;
    }
#line 434
    if (in_ch == 259) {
#line 434
      goto case_259___3;
    }
#line 437
    if (in_ch == 258) {
#line 437
      goto case_258___3;
    }
#line 408
    goto switch_break___5;
    case_13___3: /* CIL Label */ 
    case_343___3: /* CIL Label */ 
    {
#line 412
    templong = atol((char const   *)local_silence_threshold_string.string);
    }
#line 414
    if (templong < 0L) {
      {
#line 416
      error_window((char *)"Enter a whole, positive number. Default: 5.");
#line 418
      local_silence_threshold_string.cursorpos = (int )strlen(local_silence_threshold_string.string);
      }
    } else
#line 414
    if (templong > 10000L) {
      {
#line 416
      error_window((char *)"Enter a whole, positive number. Default: 5.");
#line 418
      local_silence_threshold_string.cursorpos = (int )strlen(local_silence_threshold_string.string);
      }
    } else {
      {
#line 424
      *local_silence_threshold = (int )templong;
#line 425
      sprintf((char */* __restrict  */)local_silence_threshold_string.string, (char const   */* __restrict  */)"%ld",
              templong);
#line 427
      local_silence_threshold_string.cursorpos = (int )strlen(local_silence_threshold_string.string);
#line 430
      focus ++;
      }
    }
#line 432
    goto switch_break___5;
    case_259___3: /* CIL Label */ 
#line 435
    focus --;
#line 436
    goto switch_break___5;
    case_258___3: /* CIL Label */ 
#line 438
    focus ++;
#line 439
    goto switch_break___5;
    switch_break___5: /* CIL Label */ ;
    }
#line 441
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
    {
#line 444
    stringinput_stdkeys(in_ch, & min_silence_blocks_string);
    }
    {
#line 449
    if (in_ch == 13) {
#line 449
      goto case_13___4;
    }
#line 449
    if (in_ch == 343) {
#line 449
      goto case_13___4;
    }
#line 472
    if (in_ch == 259) {
#line 472
      goto case_259___4;
    }
#line 475
    if (in_ch == 258) {
#line 475
      goto case_258___4;
    }
#line 446
    goto switch_break___6;
    case_13___4: /* CIL Label */ 
    case_343___4: /* CIL Label */ 
    {
#line 450
    templong = atol((char const   *)min_silence_blocks_string.string);
    }
#line 452
    if (templong < 0L) {
      {
#line 454
      error_window((char *)"Enter a whole, positive number. Default: 20.");
#line 456
      min_silence_blocks_string.cursorpos = (int )strlen(min_silence_blocks_string.string);
      }
    } else
#line 452
    if (templong > 10000L) {
      {
#line 454
      error_window((char *)"Enter a whole, positive number. Default: 20.");
#line 456
      min_silence_blocks_string.cursorpos = (int )strlen(min_silence_blocks_string.string);
      }
    } else {
      {
#line 462
      *min_silence_blocks = (int )templong;
#line 463
      sprintf((char */* __restrict  */)min_silence_blocks_string.string, (char const   */* __restrict  */)"%ld",
              templong);
#line 465
      min_silence_blocks_string.cursorpos = (int )strlen(min_silence_blocks_string.string);
#line 468
      focus ++;
      }
    }
#line 470
    goto switch_break___6;
    case_259___4: /* CIL Label */ 
#line 473
    focus --;
#line 474
    goto switch_break___6;
    case_258___4: /* CIL Label */ 
#line 476
    focus ++;
#line 477
    goto switch_break___6;
    switch_break___6: /* CIL Label */ ;
    }
#line 479
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
    {
#line 482
    stringinput_stdkeys(in_ch, & min_track_blocks_string);
    }
    {
#line 487
    if (in_ch == 13) {
#line 487
      goto case_13___5;
    }
#line 487
    if (in_ch == 343) {
#line 487
      goto case_13___5;
    }
#line 510
    if (in_ch == 259) {
#line 510
      goto case_259___5;
    }
#line 513
    if (in_ch == 258) {
#line 513
      goto case_258___5;
    }
#line 484
    goto switch_break___7;
    case_13___5: /* CIL Label */ 
    case_343___5: /* CIL Label */ 
    {
#line 488
    templong = atol((char const   *)min_track_blocks_string.string);
    }
#line 490
    if (templong < 0L) {
      {
#line 492
      error_window((char *)"Enter a whole, positive number. Default: 50.");
#line 494
      min_track_blocks_string.cursorpos = (int )strlen(min_track_blocks_string.string);
      }
    } else
#line 490
    if (templong > 10000L) {
      {
#line 492
      error_window((char *)"Enter a whole, positive number. Default: 50.");
#line 494
      min_track_blocks_string.cursorpos = (int )strlen(min_track_blocks_string.string);
      }
    } else {
      {
#line 500
      *min_track_blocks = (int )templong;
#line 501
      sprintf((char */* __restrict  */)min_track_blocks_string.string, (char const   */* __restrict  */)"%ld",
              templong);
#line 503
      min_track_blocks_string.cursorpos = (int )strlen(min_track_blocks_string.string);
#line 506
      focus ++;
      }
    }
#line 508
    goto switch_break___7;
    case_259___5: /* CIL Label */ 
#line 511
    focus --;
#line 512
    goto switch_break___7;
    case_258___5: /* CIL Label */ 
#line 514
    focus ++;
#line 515
    goto switch_break___7;
    switch_break___7: /* CIL Label */ ;
    }
#line 517
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
    {
#line 520
    stringinput_stdkeys(in_ch, & extra_blocks_start_string);
    }
    {
#line 525
    if (in_ch == 13) {
#line 525
      goto case_13___6;
    }
#line 525
    if (in_ch == 343) {
#line 525
      goto case_13___6;
    }
#line 548
    if (in_ch == 259) {
#line 548
      goto case_259___6;
    }
#line 551
    if (in_ch == 258) {
#line 551
      goto case_258___6;
    }
#line 522
    goto switch_break___8;
    case_13___6: /* CIL Label */ 
    case_343___6: /* CIL Label */ 
    {
#line 526
    templong = atol((char const   *)extra_blocks_start_string.string);
    }
#line 528
    if (templong < 0L) {
      {
#line 530
      error_window((char *)"Enter a whole, positive number. Default: 3.");
#line 532
      extra_blocks_start_string.cursorpos = (int )strlen(extra_blocks_start_string.string);
      }
    } else
#line 528
    if (templong > 10000L) {
      {
#line 530
      error_window((char *)"Enter a whole, positive number. Default: 3.");
#line 532
      extra_blocks_start_string.cursorpos = (int )strlen(extra_blocks_start_string.string);
      }
    } else {
      {
#line 538
      *extra_blocks_start = (int )templong;
#line 539
      sprintf((char */* __restrict  */)extra_blocks_start_string.string, (char const   */* __restrict  */)"%ld",
              templong);
#line 541
      extra_blocks_start_string.cursorpos = (int )strlen(extra_blocks_start_string.string);
#line 544
      focus ++;
      }
    }
#line 546
    goto switch_break___8;
    case_259___6: /* CIL Label */ 
#line 549
    focus --;
#line 550
    goto switch_break___8;
    case_258___6: /* CIL Label */ 
#line 552
    focus ++;
#line 553
    goto switch_break___8;
    switch_break___8: /* CIL Label */ ;
    }
#line 555
    goto switch_break___0;
    case_8___0: /* CIL Label */ 
    {
#line 558
    stringinput_stdkeys(in_ch, & extra_blocks_end_string);
    }
    {
#line 563
    if (in_ch == 13) {
#line 563
      goto case_13___7;
    }
#line 563
    if (in_ch == 343) {
#line 563
      goto case_13___7;
    }
#line 586
    if (in_ch == 259) {
#line 586
      goto case_259___7;
    }
#line 589
    if (in_ch == 258) {
#line 589
      goto case_258___7;
    }
#line 560
    goto switch_break___9;
    case_13___7: /* CIL Label */ 
    case_343___7: /* CIL Label */ 
    {
#line 564
    templong = atol((char const   *)extra_blocks_end_string.string);
    }
#line 566
    if (templong < 0L) {
      {
#line 568
      error_window((char *)"Enter a whole, positive number. Default: 6.");
#line 570
      extra_blocks_end_string.cursorpos = (int )strlen(extra_blocks_end_string.string);
      }
    } else
#line 566
    if (templong > 10000L) {
      {
#line 568
      error_window((char *)"Enter a whole, positive number. Default: 6.");
#line 570
      extra_blocks_end_string.cursorpos = (int )strlen(extra_blocks_end_string.string);
      }
    } else {
      {
#line 576
      *extra_blocks_end = (int )templong;
#line 577
      sprintf((char */* __restrict  */)extra_blocks_end_string.string, (char const   */* __restrict  */)"%ld",
              templong);
#line 579
      extra_blocks_end_string.cursorpos = (int )strlen(extra_blocks_end_string.string);
#line 582
      focus ++;
      }
    }
#line 584
    goto switch_break___9;
    case_259___7: /* CIL Label */ 
#line 587
    focus --;
#line 588
    goto switch_break___9;
    case_258___7: /* CIL Label */ 
#line 590
    focus ++;
#line 591
    goto switch_break___9;
    switch_break___9: /* CIL Label */ ;
    }
#line 593
    goto switch_break___0;
    case_9: /* CIL Label */ 
#line 596
    if (in_ch == 343) {
#line 598
      returnval = 1;
#line 599
      dont_stop = 0;
    } else
#line 596
    if (in_ch == 13) {
#line 598
      returnval = 1;
#line 599
      dont_stop = 0;
    } else {
      {
#line 605
      if (in_ch == 259) {
#line 605
        goto case_259___8;
      }
#line 605
      if (in_ch == 260) {
#line 605
        goto case_259___8;
      }
#line 609
      if (in_ch == 258) {
#line 609
        goto case_258___8;
      }
#line 609
      if (in_ch == 261) {
#line 609
        goto case_258___8;
      }
#line 602
      goto switch_break___10;
      case_259___8: /* CIL Label */ 
      case_260___1: /* CIL Label */ 
#line 606
      focus --;
#line 607
      goto switch_break___10;
      case_258___8: /* CIL Label */ 
      case_261___1: /* CIL Label */ 
#line 610
      focus ++;
#line 611
      goto switch_break___10;
      switch_break___10: /* CIL Label */ ;
      }
    }
#line 613
    goto switch_break___0;
    case_10: /* CIL Label */ 
#line 616
    if (in_ch == 343) {
#line 618
      returnval = 0;
#line 619
      dont_stop = 0;
    } else
#line 616
    if (in_ch == 13) {
#line 618
      returnval = 0;
#line 619
      dont_stop = 0;
    } else {
      {
#line 625
      if (in_ch == 259) {
#line 625
        goto case_259___9;
      }
#line 625
      if (in_ch == 260) {
#line 625
        goto case_259___9;
      }
#line 629
      if (in_ch == 258) {
#line 629
        goto case_258___9;
      }
#line 629
      if (in_ch == 261) {
#line 629
        goto case_258___9;
      }
#line 622
      goto switch_break___11;
      case_259___9: /* CIL Label */ 
      case_260___2: /* CIL Label */ 
#line 626
      focus --;
#line 627
      goto switch_break___11;
      case_258___9: /* CIL Label */ 
      case_261___2: /* CIL Label */ 
#line 630
      focus ++;
#line 631
      goto switch_break___11;
      switch_break___11: /* CIL Label */ ;
      }
    }
#line 633
    goto switch_break___0;
    case_11: /* CIL Label */ 
#line 636
    if (in_ch == 343) {
#line 636
      goto _L;
    } else
#line 636
    if (in_ch == 13) {
      _L: /* CIL Label */ 
      {
#line 638
      templong = atol((char const   *)blocklen_string.string);
      }
#line 639
      if (templong < 1L) {
        {
#line 641
        error_window((char *)"Enter a whole number, greater than 0, as block length. Default: 4410.");
#line 643
        blocklen_string.cursorpos = (int )strlen(blocklen_string.string);
#line 645
        focus = 2;
        }
#line 646
        goto switch_break___0;
      }
      {
#line 648
      *blocklen = templong;
#line 650
      templong = atol((char const   *)global_silence_factor_string.string);
      }
#line 651
      if (templong < 1L) {
        {
#line 653
        error_window((char *)"Enter a whole, positive number as global silence factor. Default: 150.");
#line 655
        global_silence_factor_string.cursorpos = (int )strlen(global_silence_factor_string.string);
#line 657
        focus = 3;
        }
#line 658
        goto switch_break___0;
      } else
#line 651
      if (templong > 10000L) {
        {
#line 653
        error_window((char *)"Enter a whole, positive number as global silence factor. Default: 150.");
#line 655
        global_silence_factor_string.cursorpos = (int )strlen(global_silence_factor_string.string);
#line 657
        focus = 3;
        }
#line 658
        goto switch_break___0;
      }
      {
#line 660
      *global_silence_factor = (int )templong;
#line 662
      templong = atol((char const   *)local_silence_threshold_string.string);
      }
#line 663
      if (templong < 1L) {
        {
#line 665
        error_window((char *)"Enter a whole, positive number as local silence factor. Default: 5.");
#line 667
        local_silence_threshold_string.cursorpos = (int )strlen(local_silence_threshold_string.string);
#line 669
        focus = 4;
        }
#line 670
        goto switch_break___0;
      } else
#line 663
      if (templong > 10000L) {
        {
#line 665
        error_window((char *)"Enter a whole, positive number as local silence factor. Default: 5.");
#line 667
        local_silence_threshold_string.cursorpos = (int )strlen(local_silence_threshold_string.string);
#line 669
        focus = 4;
        }
#line 670
        goto switch_break___0;
      }
      {
#line 672
      *local_silence_threshold = (int )templong;
#line 674
      templong = atol((char const   *)min_silence_blocks_string.string);
      }
#line 675
      if (templong < 1L) {
        {
#line 677
        error_window((char *)"Enter a whole, positive number as minimal silence duration. Default: 20.");
#line 679
        min_silence_blocks_string.cursorpos = (int )strlen(min_silence_blocks_string.string);
#line 681
        focus = 5;
        }
#line 682
        goto switch_break___0;
      } else
#line 675
      if (templong > 10000L) {
        {
#line 677
        error_window((char *)"Enter a whole, positive number as minimal silence duration. Default: 20.");
#line 679
        min_silence_blocks_string.cursorpos = (int )strlen(min_silence_blocks_string.string);
#line 681
        focus = 5;
        }
#line 682
        goto switch_break___0;
      }
      {
#line 684
      *min_silence_blocks = (int )templong;
#line 686
      templong = atol((char const   *)min_track_blocks_string.string);
      }
#line 687
      if (templong < 1L) {
        {
#line 689
        error_window((char *)"Enter a whole, positive number as minimal track length. Default: 50.");
#line 691
        min_track_blocks_string.cursorpos = (int )strlen(min_track_blocks_string.string);
#line 693
        focus = 6;
        }
#line 694
        goto switch_break___0;
      } else
#line 687
      if (templong > 10000L) {
        {
#line 689
        error_window((char *)"Enter a whole, positive number as minimal track length. Default: 50.");
#line 691
        min_track_blocks_string.cursorpos = (int )strlen(min_track_blocks_string.string);
#line 693
        focus = 6;
        }
#line 694
        goto switch_break___0;
      }
      {
#line 696
      *min_track_blocks = (int )templong;
#line 698
      templong = atol((char const   *)extra_blocks_start_string.string);
      }
#line 699
      if (templong < 1L) {
        {
#line 701
        error_window((char *)"Enter a whole, positive number as block addition. Default: 3.");
#line 703
        extra_blocks_start_string.cursorpos = (int )strlen(extra_blocks_start_string.string);
#line 705
        focus = 7;
        }
#line 706
        goto switch_break___0;
      } else
#line 699
      if (templong > 10000L) {
        {
#line 701
        error_window((char *)"Enter a whole, positive number as block addition. Default: 3.");
#line 703
        extra_blocks_start_string.cursorpos = (int )strlen(extra_blocks_start_string.string);
#line 705
        focus = 7;
        }
#line 706
        goto switch_break___0;
      }
      {
#line 708
      *extra_blocks_start = (int )templong;
#line 710
      templong = atol((char const   *)extra_blocks_end_string.string);
      }
#line 711
      if (templong < 1L) {
        {
#line 713
        error_window((char *)"Enter a whole, positive number as block addition. Default: 6.");
#line 715
        extra_blocks_end_string.cursorpos = (int )strlen(extra_blocks_end_string.string);
#line 717
        focus = 8;
        }
#line 718
        goto switch_break___0;
      } else
#line 711
      if (templong > 10000L) {
        {
#line 713
        error_window((char *)"Enter a whole, positive number as block addition. Default: 6.");
#line 715
        extra_blocks_end_string.cursorpos = (int )strlen(extra_blocks_end_string.string);
#line 717
        focus = 8;
        }
#line 718
        goto switch_break___0;
      }
#line 720
      *extra_blocks_end = (int )templong;
#line 722
      returnval = 2;
#line 723
      dont_stop = 0;
    } else {
      {
#line 729
      if (in_ch == 259) {
#line 729
        goto case_259___10;
      }
#line 729
      if (in_ch == 260) {
#line 729
        goto case_259___10;
      }
#line 733
      if (in_ch == 258) {
#line 733
        goto case_258___10;
      }
#line 733
      if (in_ch == 261) {
#line 733
        goto case_258___10;
      }
#line 726
      goto switch_break___12;
      case_259___10: /* CIL Label */ 
      case_260___3: /* CIL Label */ 
#line 730
      focus --;
#line 731
      goto switch_break___12;
      case_258___10: /* CIL Label */ 
      case_261___3: /* CIL Label */ 
#line 734
      focus ++;
#line 735
      goto switch_break___12;
      switch_break___12: /* CIL Label */ ;
      }
    }
#line 737
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 741
    if (in_ch == 9) {
#line 742
      focus ++;
    }
#line 744
    if (in_ch == 27) {
#line 745
      dont_stop = 0;
    }
#line 747
    if (focus > 11) {
#line 748
      focus = 0;
    }
#line 749
    if (focus < 0) {
#line 750
      focus = 11;
    }
#line 170
    if (! dont_stop) {
#line 170
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 754
  return (returnval);
}
}
#line 267 "/usr/include/curses.h"
extern chtype acs_map[] ;
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/helpline.c"
void helpline(char *helptext ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 23
  wmove(stdscr, 22, 0);
#line 24
  i = 0;
  }
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 24
    if (! (i < 80)) {
#line 24
      goto while_break;
    }
    {
#line 25
    waddch(stdscr, (chtype const   )acs_map[(unsigned char )'s']);
#line 24
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 26
  tmp = wmove(stdscr, 23, 0);
  }
#line 26
  if (! (tmp == -1)) {
    {
#line 26
    waddnstr(stdscr, (char const   *)helptext, -1);
    }
  }
#line 28
  return;
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/buttons.c"
void button_display(button_t *button ) 
{ 
  int y ;
  int x ;
  int tmp ;

  {
#line 22
  if (button->selected) {
    {
#line 23
    wattr_on(stdscr, 1UL << 16, (void *)0);
    }
  }
  {
#line 25
  tmp = wmove(stdscr, button->y, button->x);
  }
#line 25
  if (! (tmp == -1)) {
    {
#line 25
    waddnstr(stdscr, (char const   *)button->text, -1);
    }
  }
#line 27
  if (stdscr) {
#line 27
    y = (int )stdscr->_cury;
  } else {
#line 27
    y = -1;
  }
#line 27
  if (stdscr) {
#line 27
    x = (int )stdscr->_curx;
  } else {
#line 27
    x = -1;
  }
  {
#line 28
  wmove(stdscr, y, x - 1);
  }
#line 30
  if (button->selected) {
    {
#line 31
    wattr_off(stdscr, 1UL << 16, (void *)0);
    }
  }
#line 32
  return;
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/clrscr.c"
void header(char *headertext ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 22
  tmp = wmove(stdscr, 0, 1);
  }
#line 22
  if (! (tmp == -1)) {
    {
#line 22
    waddnstr(stdscr, "GramoFile 1.6", -1);
    }
  }
  {
#line 24
  tmp___0 = (int )strlen(headertext);
#line 24
  tmp___1 = wmove(stdscr, 0, ((80 - tmp___0) + 1) / 2);
  }
#line 24
  if (! (tmp___1 == -1)) {
    {
#line 24
    waddnstr(stdscr, (char const   *)headertext, -1);
    }
  }
  {
#line 27
  wmove(stdscr, 1, 0);
#line 28
  i = 0;
  }
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! (i < 80)) {
#line 28
      goto while_break;
    }
    {
#line 29
    waddch(stdscr, (chtype const   )acs_map[(unsigned char )'o']);
#line 28
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  return;
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/clrscr.c"
void clearscreen(char *headertext ) 
{ 


  {
  {
#line 35
  wclear(stdscr);
#line 36
  wrefresh(stdscr);
#line 38
  header(headertext);
  }
#line 39
  return;
}
}
#line 254 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1,2))) scandir)(char const   * __restrict  __dir ,
                                                        struct dirent *** __restrict  __namelist ,
                                                        int (*__selector)(struct dirent  const  * ) ,
                                                        int (*__cmp)(struct dirent  const  ** ,
                                                                     struct dirent  const  ** ) ) ;
#line 324
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) alphasort)(struct dirent  const  **__e1 ,
                                                                                                  struct dirent  const  **__e2 )  __attribute__((__pure__)) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/dirfilemenu.c"
void dirfilemenu(char *basedir , scrollmenu_t *menu ) 
{ 
  struct dirent **namelist ;
  int n ;
  char mybasedir[250] ;
  char helpstring[250] ;
  char *firstslash ;
  int i ;
  int j ;
  int k ;
  int indent ;
  int isadir ;
  struct stat filestats ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 28
  indent = 0;
#line 32
  n = scandir((char const   */* __restrict  */)basedir, (struct dirent ***/* __restrict  */)(& namelist),
              (int (*)(struct dirent  const  * ))((void *)0), (int (*)(struct dirent  const  ** ,
                                                                       struct dirent  const  ** ))(& alphasort));
  }
#line 34
  if (n < 0) {
#line 35
    menu->number = 0;
  } else {
    {
#line 38
    tmp = malloc((unsigned long )(n + 100) * sizeof(char *));
#line 38
    menu->items = (char **)tmp;
#line 40
    i = 0;
    }
    {
#line 40
    while (1) {
      while_continue: /* CIL Label */ ;
#line 40
      if (! (i < n + 100)) {
#line 40
        goto while_break;
      }
#line 41
      *(menu->items + i) = (char *)((void *)0);
#line 40
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 43
    strcpy((char */* __restrict  */)(mybasedir), (char const   */* __restrict  */)basedir);
#line 44
    i = 0;
    }
    {
#line 46
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 48
      firstslash = strchr((char const   *)(mybasedir), '/');
      }
#line 49
      if ((unsigned long )firstslash != (unsigned long )((void *)0)) {
        {
#line 51
        tmp___0 = malloc((unsigned long )(((firstslash - mybasedir) + 2L) + (long )indent) * sizeof(char ));
#line 51
        *(menu->items + i) = (char *)tmp___0;
#line 54
        k = 0;
        }
        {
#line 54
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 54
          if (! (k < indent)) {
#line 54
            goto while_break___1;
          }
#line 55
          *(*(menu->items + i) + k) = (char )' ';
#line 54
          k ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 57
        strncpy((char */* __restrict  */)(*(menu->items + i) + indent), (char const   */* __restrict  */)(mybasedir),
                (size_t )((firstslash - mybasedir) + 1L));
#line 59
        *(*(menu->items + i) + (((firstslash - mybasedir) + 1L) + (long )indent)) = (char )'\000';
#line 61
        strcpy((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)(firstslash + 1));
#line 62
        strcpy((char */* __restrict  */)(mybasedir), (char const   */* __restrict  */)(helpstring));
#line 64
        i ++;
#line 65
        indent ++;
        }
      }
      {
#line 46
      tmp___1 = strlen((char const   *)(mybasedir));
      }
#line 46
      if (! (tmp___1 > 0UL)) {
#line 46
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 70
    menu->last_of_1st_part = i - 1;
#line 72
    j = 0;
    {
#line 72
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 72
      if (! (j < n)) {
#line 72
        goto while_break___2;
      }
      {
#line 74
      tmp___4 = strcmp((char const   *)((*(namelist + j))->d_name), ".");
      }
#line 74
      if (tmp___4) {
        {
#line 74
        tmp___5 = strcmp((char const   *)((*(namelist + j))->d_name), "..");
        }
#line 74
        if (tmp___5) {
          {
#line 77
          strcpy((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)basedir);
#line 78
          strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)((*(namelist + j))->d_name));
#line 79
          stat((char const   */* __restrict  */)(helpstring), (struct stat */* __restrict  */)(& filestats));
          }
#line 81
          if ((filestats.st_mode & 61440U) == 16384U) {
#line 82
            isadir = 1;
          } else {
#line 84
            isadir = 0;
          }
          {
#line 86
          tmp___2 = strlen((char const   *)((*(namelist + j))->d_name));
#line 86
          tmp___3 = malloc((((tmp___2 + 1UL) + (size_t )indent) + (size_t )isadir) * sizeof(char ));
#line 86
          *(menu->items + i) = (char *)tmp___3;
#line 91
          k = 0;
          }
          {
#line 91
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 91
            if (! (k < indent)) {
#line 91
              goto while_break___3;
            }
#line 92
            *(*(menu->items + i) + k) = (char )' ';
#line 91
            k ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 94
          strcpy((char */* __restrict  */)(*(menu->items + i) + indent), (char const   */* __restrict  */)((*(namelist + j))->d_name));
          }
#line 96
          if (isadir) {
            {
#line 97
            strcat((char */* __restrict  */)*(menu->items + i), (char const   */* __restrict  */)"/");
            }
          }
#line 99
          i ++;
        }
      }
#line 72
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 102
    menu->number = i;
  }
#line 104
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/dirfilemenu.c"
int dirfilemenu_process_select(scrollmenu_t *menu , char *dirfile ) 
{ 
  int i ;
  size_t tmp ;

  {
#line 113
  if (menu->selected <= menu->last_of_1st_part) {
#line 116
    *(dirfile + 0) = (char )'\000';
#line 118
    i = 0;
    {
#line 118
    while (1) {
      while_continue: /* CIL Label */ ;
#line 118
      if (! (i <= menu->selected)) {
#line 118
        goto while_break;
      }
      {
#line 119
      strcat((char */* __restrict  */)dirfile, (char const   */* __restrict  */)(*(menu->items + i) + i));
#line 118
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 121
    (menu->selected) ++;
#line 122
    return (1);
  } else {
#line 128
    *(dirfile + 0) = (char )'\000';
#line 130
    i = 0;
    {
#line 130
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 130
      if (! (i <= menu->last_of_1st_part)) {
#line 130
        goto while_break___0;
      }
      {
#line 131
      strcat((char */* __restrict  */)dirfile, (char const   */* __restrict  */)(*(menu->items + i) + i));
#line 130
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 133
    strcat((char */* __restrict  */)dirfile, (char const   */* __restrict  */)((*(menu->items + menu->selected) + menu->last_of_1st_part) + 1));
#line 136
    tmp = strlen((char const   *)*(menu->items + menu->selected));
    }
#line 136
    if ((int )*(*(menu->items + menu->selected) + (tmp - 1UL)) == 47) {
#line 139
      menu->selected = menu->last_of_1st_part + 2;
#line 140
      return (1);
    } else {
#line 143
      return (0);
    }
  }
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/reclp_filenm.h"
int record_from_lp_get_filename(char *startdir , char *selectedfile ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/reclp_filenm.c"
int record_from_lp_get_filename(char *startdir , char *selectedfile ) 
{ 
  scrollmenu_t dirfilelist ;
  stringinput_t string ;
  button_t ok_button ;
  button_t cancel_button ;
  button_t mixer_button ;
  int dont_stop ;
  int returnval ;
  int focus ;
  int in_ch ;
  int i ;
  char helpstring[500] ;
  char *charpointer ;
  struct stat filestats ;
  int oldselected ;
  char *helplines[5] ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;

  {
  {
#line 41
  dont_stop = 1;
#line 42
  returnval = 0;
#line 43
  focus = 1;
#line 51
  helplines[0] = (char *)" Browse files and directories.                                  TAB: Next field";
#line 51
  helplines[1] = (char *)" Enter name of destination sound file.                          TAB: Next field";
#line 51
  helplines[2] = (char *)" Back to main menu                                              TAB: Next field";
#line 51
  helplines[3] = (char *)" Start `xmixer\' to adjust recording volumes.                    TAB: Next field";
#line 51
  helplines[4] = (char *)" Start recording in the specified sound file.                   TAB: Next field";
#line 59
  dirfilelist.y = 3;
#line 60
  dirfilelist.x = 5;
#line 61
  dirfilelist.h = 12;
#line 62
  dirfilelist.w = 32;
#line 63
  dirfilelist.firstonscreen = 0;
#line 64
  dirfilemenu(startdir, & dirfilelist);
#line 65
  dirfilelist.selected = dirfilelist.last_of_1st_part + 1;
#line 67
  string.maxlen = 500;
#line 68
  tmp = malloc((unsigned long )string.maxlen * sizeof(char ));
#line 68
  string.string = (char *)tmp;
#line 69
  strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)startdir);
#line 70
  string.y = 17;
#line 71
  string.x = 5;
#line 72
  string.w = 70;
#line 73
  strcat((char */* __restrict  */)string.string, (char const   */* __restrict  */)"new.wav");
#line 74
  tmp___0 = strlen((char const   *)string.string);
#line 74
  string.cursorpos = (int )tmp___0;
#line 75
  tmp___1 = strlen((char const   *)string.string);
#line 75
  string.firstcharonscreen = (int )((tmp___1 - (size_t )string.w) + 2UL);
  }
#line 76
  if (string.firstcharonscreen < 0) {
#line 77
    string.firstcharonscreen = 0;
  }
  {
#line 79
  ok_button.text = (char *)" Start recording ";
#line 80
  ok_button.y = 20;
#line 81
  ok_button.x = 58;
#line 82
  ok_button.selected = 0;
#line 84
  cancel_button.text = (char *)" Cancel ";
#line 85
  cancel_button.y = 20;
#line 86
  cancel_button.x = 5;
#line 87
  cancel_button.selected = 0;
#line 89
  mixer_button.text = (char *)" Mixer ";
#line 90
  mixer_button.y = 20;
#line 91
  mixer_button.x = 35;
#line 92
  mixer_button.selected = 0;
#line 94
  clearscreen((char *)"Record audio to a sound file");
  }
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    header((char *)"Record audio to a sound file");
    }
#line 100
    if (focus == 2) {
#line 101
      cancel_button.selected = 1;
    } else {
#line 103
      cancel_button.selected = 0;
    }
#line 105
    if (focus == 3) {
#line 106
      mixer_button.selected = 1;
    } else {
#line 108
      mixer_button.selected = 0;
    }
#line 110
    if (focus == 4) {
#line 111
      ok_button.selected = 1;
    } else {
#line 113
      ok_button.selected = 0;
    }
    {
#line 115
    dirfilelist.hasfocus = focus == 0;
#line 117
    scrollmenu_display(& dirfilelist);
#line 118
    mybox(dirfilelist.y - 1, dirfilelist.x - 1, dirfilelist.h + 2, dirfilelist.w + 2);
#line 120
    mvprintw(dirfilelist.y - 1, dirfilelist.x + 1, "Files and directories:");
#line 123
    stringinput_display(& string);
#line 124
    mybox(string.y - 1, string.x - 1, 3, string.w + 2);
#line 125
    mvprintw(string.y - 1, string.x + 1, "File name:");
#line 127
    button_display(& cancel_button);
#line 128
    tmp___2 = strlen((char const   *)cancel_button.text);
#line 128
    mybox(cancel_button.y - 1, cancel_button.x - 1, 3, (int )(tmp___2 + 2UL));
#line 130
    button_display(& mixer_button);
#line 131
    tmp___3 = strlen((char const   *)mixer_button.text);
#line 131
    mybox(mixer_button.y - 1, mixer_button.x - 1, 3, (int )(tmp___3 + 2UL));
#line 133
    button_display(& ok_button);
#line 134
    tmp___4 = strlen((char const   *)ok_button.text);
#line 134
    mybox(ok_button.y - 1, ok_button.x - 1, 3, (int )(tmp___4 + 2UL));
#line 137
    helpline(helplines[focus]);
    }
#line 139
    if (focus == 1) {
      {
#line 140
      stringinput_display(& string);
      }
    } else {
      {
#line 142
      wmove(stdscr, 0, 79);
      }
    }
    {
#line 144
    wrefresh(stdscr);
#line 146
    in_ch = wgetch(stdscr);
    }
    {
#line 150
    if (focus == 0) {
#line 150
      goto case_0;
    }
#line 203
    if (focus == 1) {
#line 203
      goto case_1;
    }
#line 244
    if (focus == 2) {
#line 244
      goto case_2;
    }
#line 264
    if (focus == 3) {
#line 264
      goto case_3;
    }
#line 286
    if (focus == 4) {
#line 286
      goto case_4;
    }
#line 148
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 151
    tmp___6 = scrollmenu_stdkeys(in_ch, & dirfilelist);
    }
#line 151
    if (tmp___6 >= 0) {
      {
#line 153
      oldselected = dirfilelist.selected;
#line 154
      i = dirfilemenu_process_select(& dirfilelist, helpstring);
      }
#line 156
      if (i == 0) {
        {
#line 158
        strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)(helpstring));
#line 159
        focus = 1;
#line 160
        tmp___5 = strlen((char const   *)string.string);
#line 160
        string.cursorpos = (int )tmp___5;
#line 161
        string.firstcharonscreen = 0;
        }
      } else {
        {
#line 166
        scrollmenu_delete_menu(& dirfilelist);
#line 167
        dirfilemenu(helpstring, & dirfilelist);
        }
#line 168
        if (dirfilelist.number == 0) {
          {
#line 170
          error_window((char *)"No permission to read this directory.");
#line 173
          scrollmenu_delete_menu(& dirfilelist);
#line 174
          dirfilemenu(startdir, & dirfilelist);
#line 175
          dirfilelist.selected = oldselected;
          }
        } else {
          {
#line 179
          strcpy((char */* __restrict  */)startdir, (char const   */* __restrict  */)(helpstring));
#line 180
          dirfilelist.firstonscreen = 0;
#line 182
          charpointer = strrchr((char const   *)string.string, '/');
          }
#line 183
          if ((unsigned long )charpointer != (unsigned long )((void *)0)) {
            {
#line 184
            strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)(charpointer + 1));
            }
          } else {
            {
#line 186
            strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)string.string);
            }
          }
          {
#line 187
          strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)(helpstring));
          }
        }
      }
    } else {
      {
#line 194
      if (in_ch == 260) {
#line 194
        goto case_260;
      }
#line 197
      if (in_ch == 261) {
#line 197
        goto case_261;
      }
#line 192
      goto switch_break___0;
      case_260: /* CIL Label */ 
#line 195
      focus --;
#line 196
      goto switch_break___0;
      case_261: /* CIL Label */ 
#line 198
      focus ++;
#line 199
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 201
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 204
    stringinput_stdkeys(in_ch, & string);
    }
#line 205
    if (in_ch == 343) {
#line 205
      goto _L;
    } else
#line 205
    if (in_ch == 13) {
      _L: /* CIL Label */ 
      {
#line 207
      strcpy((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)string.string);
      }
      {
#line 210
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 210
        tmp___8 = strlen((char const   *)(helpstring));
        }
#line 210
        if (tmp___8 > 0UL) {
          {
#line 210
          tmp___9 = strlen((char const   *)(helpstring));
          }
#line 210
          if (! ((int )helpstring[tmp___9 - 1UL] == 47)) {
#line 210
            goto while_break___0;
          }
        } else {
#line 210
          goto while_break___0;
        }
        {
#line 212
        tmp___7 = strlen((char const   *)(helpstring));
#line 212
        helpstring[tmp___7 - 1UL] = (char )'\000';
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 214
      strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)"/");
#line 216
      tmp___11 = stat((char const   */* __restrict  */)(helpstring), (struct stat */* __restrict  */)(& filestats));
      }
#line 216
      if (tmp___11) {
#line 230
        focus = 4;
      } else
#line 216
      if ((filestats.st_mode & 61440U) == 16384U) {
        {
#line 219
        strcpy((char */* __restrict  */)startdir, (char const   */* __restrict  */)(helpstring));
#line 220
        scrollmenu_delete_menu(& dirfilelist);
#line 221
        dirfilemenu(startdir, & dirfilelist);
#line 222
        dirfilelist.firstonscreen = 0;
#line 223
        dirfilelist.selected = dirfilelist.last_of_1st_part + 1;
#line 225
        strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)startdir);
#line 226
        tmp___10 = strlen((char const   *)string.string);
#line 226
        string.cursorpos = (int )tmp___10;
#line 227
        focus = 0;
        }
      } else {
#line 230
        focus = 4;
      }
    } else {
      {
#line 235
      if (in_ch == 259) {
#line 235
        goto case_259;
      }
#line 238
      if (in_ch == 258) {
#line 238
        goto case_258;
      }
#line 233
      goto switch_break___1;
      case_259: /* CIL Label */ 
#line 236
      focus --;
#line 237
      goto switch_break___1;
      case_258: /* CIL Label */ 
#line 239
      focus ++;
#line 240
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
#line 242
    goto switch_break;
    case_2: /* CIL Label */ 
#line 245
    if (in_ch == 343) {
#line 247
      returnval = 0;
#line 248
      dont_stop = 0;
    } else
#line 245
    if (in_ch == 13) {
#line 247
      returnval = 0;
#line 248
      dont_stop = 0;
    } else {
      {
#line 254
      if (in_ch == 259) {
#line 254
        goto case_259___0;
      }
#line 254
      if (in_ch == 260) {
#line 254
        goto case_259___0;
      }
#line 258
      if (in_ch == 258) {
#line 258
        goto case_258___0;
      }
#line 258
      if (in_ch == 261) {
#line 258
        goto case_258___0;
      }
#line 251
      goto switch_break___2;
      case_259___0: /* CIL Label */ 
      case_260___0: /* CIL Label */ 
#line 255
      focus --;
#line 256
      goto switch_break___2;
      case_258___0: /* CIL Label */ 
      case_261___0: /* CIL Label */ 
#line 259
      focus ++;
#line 260
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    }
#line 262
    goto switch_break;
    case_3: /* CIL Label */ 
#line 265
    if (in_ch == 343) {
      {
#line 267
      system("xmixer &");
#line 269
      error_window((char *)"Make sure that the appropriate channel is selected for recording, and all the others for playback.");
      }
    } else
#line 265
    if (in_ch == 13) {
      {
#line 267
      system("xmixer &");
#line 269
      error_window((char *)"Make sure that the appropriate channel is selected for recording, and all the others for playback.");
      }
    } else {
      {
#line 276
      if (in_ch == 259) {
#line 276
        goto case_259___1;
      }
#line 276
      if (in_ch == 260) {
#line 276
        goto case_259___1;
      }
#line 280
      if (in_ch == 258) {
#line 280
        goto case_258___1;
      }
#line 280
      if (in_ch == 261) {
#line 280
        goto case_258___1;
      }
#line 273
      goto switch_break___3;
      case_259___1: /* CIL Label */ 
      case_260___1: /* CIL Label */ 
#line 277
      focus --;
#line 278
      goto switch_break___3;
      case_258___1: /* CIL Label */ 
      case_261___1: /* CIL Label */ 
#line 281
      focus ++;
#line 282
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
    }
#line 284
    goto switch_break;
    case_4: /* CIL Label */ 
#line 287
    if (in_ch == 343) {
#line 287
      goto _L___0;
    } else
#line 287
    if (in_ch == 13) {
      _L___0: /* CIL Label */ 
      {
#line 288
      tmp___12 = checkfile(string.string);
      }
      {
#line 290
      if (tmp___12 == 1) {
#line 290
        goto case_1___0;
      }
#line 305
      if (tmp___12 == 2) {
#line 305
        goto case_2___0;
      }
#line 312
      if (tmp___12 == 3) {
#line 312
        goto case_3___0;
      }
#line 318
      if (tmp___12 == 4) {
#line 318
        goto case_4___0;
      }
#line 325
      goto switch_default;
      case_1___0: /* CIL Label */ 
      {
#line 291
      tmp___14 = yesno_window((char *)"The specified file already exists. Overwrite it?",
                              (char *)" Yes ", (char *)" No ", 0);
      }
#line 291
      if (tmp___14) {
        {
#line 294
        strcpy((char */* __restrict  */)selectedfile, (char const   */* __restrict  */)string.string);
#line 295
        returnval = 1;
#line 296
        dont_stop = 0;
        }
      } else {
        {
#line 300
        tmp___13 = strlen((char const   *)string.string);
#line 300
        string.cursorpos = (int )tmp___13;
#line 301
        focus = 1;
        }
      }
#line 303
      goto switch_break___4;
      case_2___0: /* CIL Label */ 
      {
#line 306
      error_window((char *)"The specified name is of a directory. A file name must be specified.");
#line 308
      tmp___15 = strlen((char const   *)string.string);
#line 308
      string.cursorpos = (int )tmp___15;
#line 309
      focus = 1;
      }
#line 310
      goto switch_break___4;
      case_3___0: /* CIL Label */ 
      {
#line 313
      strcpy((char */* __restrict  */)selectedfile, (char const   */* __restrict  */)string.string);
#line 314
      returnval = 1;
#line 315
      dont_stop = 0;
      }
#line 316
      goto switch_break___4;
      case_4___0: /* CIL Label */ 
      {
#line 319
      error_window((char *)"The directory of the specified file does not exist.");
#line 321
      tmp___16 = strlen((char const   *)string.string);
#line 321
      string.cursorpos = (int )tmp___16;
#line 322
      focus = 1;
      }
#line 323
      goto switch_break___4;
      switch_default: /* CIL Label */ 
      {
#line 326
      error_window((char *)"Fell out of switch, reclp_filenm #1");
      }
#line 327
      goto switch_break___4;
      switch_break___4: /* CIL Label */ ;
      }
    } else {
      {
#line 333
      if (in_ch == 259) {
#line 333
        goto case_259___2;
      }
#line 333
      if (in_ch == 260) {
#line 333
        goto case_259___2;
      }
#line 337
      if (in_ch == 258) {
#line 337
        goto case_258___2;
      }
#line 337
      if (in_ch == 261) {
#line 337
        goto case_258___2;
      }
#line 330
      goto switch_break___5;
      case_259___2: /* CIL Label */ 
      case_260___2: /* CIL Label */ 
#line 334
      focus --;
#line 335
      goto switch_break___5;
      case_258___2: /* CIL Label */ 
      case_261___2: /* CIL Label */ 
#line 338
      focus ++;
#line 339
      goto switch_break___5;
      switch_break___5: /* CIL Label */ ;
      }
    }
#line 341
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 344
    if (in_ch == 9) {
#line 345
      focus ++;
    }
#line 347
    if (in_ch == 27) {
#line 348
      dont_stop = 0;
    }
#line 350
    if (focus > 4) {
#line 351
      focus = 0;
    }
#line 352
    if (focus < 0) {
#line 353
      focus = 4;
    }
#line 96
    if (! dont_stop) {
#line 96
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 357
  scrollmenu_delete_menu(& dirfilelist);
#line 358
  free((void *)string.string);
  }
#line 360
  return (returnval);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/textwindow.c"
void display_textwin(char *text , int y , int x , int h , int w ) 
{ 
  int current_y ;
  char mytext[800] ;
  char mytext2[800] ;
  char helptext[800] ;
  char *lastspace ;
  int i ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 33
  current_y = y;
#line 34
  strncpy((char */* __restrict  */)(mytext), (char const   */* __restrict  */)text,
          (size_t )800);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    strncpy((char */* __restrict  */)(mytext2), (char const   */* __restrict  */)(mytext),
            (size_t )(w + 1));
#line 39
    mytext2[w + 1] = (char )'\000';
#line 41
    tmp = strlen((char const   *)(mytext2));
    }
#line 41
    if (tmp > (size_t )w) {
      {
#line 43
      lastspace = strrchr((char const   *)(mytext2), ' ');
      }
#line 44
      if ((unsigned long )lastspace != (unsigned long )((void *)0)) {
        {
#line 46
        mytext2[lastspace - mytext2] = (char )'\000';
#line 48
        strcpy((char */* __restrict  */)(helptext), (char const   */* __restrict  */)(mytext + ((lastspace - mytext2) + 1L)));
#line 50
        strcpy((char */* __restrict  */)(mytext), (char const   */* __restrict  */)(helptext));
        }
      } else {
        {
#line 55
        mytext2[w] = (char )'\000';
#line 57
        strcpy((char */* __restrict  */)(helptext), (char const   */* __restrict  */)(mytext + w));
#line 58
        strcpy((char */* __restrict  */)(mytext), (char const   */* __restrict  */)(helptext));
        }
      }
    } else {
#line 62
      mytext[0] = (char )'\000';
    }
    {
#line 64
    tmp___0 = wmove(stdscr, current_y, x);
    }
#line 64
    if (! (tmp___0 == -1)) {
      {
#line 64
      waddnstr(stdscr, (char const   *)(mytext2), -1);
      }
    }
    {
#line 66
    tmp___1 = strlen((char const   *)(mytext2));
#line 66
    i = (int )(tmp___1 + 1UL);
    }
    {
#line 66
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 66
      if (! (i <= w)) {
#line 66
        goto while_break___0;
      }
      {
#line 67
      waddch(stdscr, (chtype const   )' ');
#line 66
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 69
    current_y ++;
#line 36
    if (! (current_y < y + h)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/reclp_main.c"
void record_from_lp(char *startdir ) 
{ 
  char filename[250] ;
  char shellcmd[500] ;
  int tmp ;

  {
  {
#line 28
  tmp = record_from_lp_get_filename(startdir, filename);
  }
#line 28
  if (! tmp) {
#line 29
    return;
  }
  {
#line 31
  def_prog_mode();
#line 33
  sprintf((char */* __restrict  */)(shellcmd), (char const   */* __restrict  */)"brec_gramo -S -s 44100 -b 16 -t 6000 -w %s",
          filename);
#line 35
  system((char const   *)(shellcmd));
#line 37
  reset_prog_mode();
  }
#line 38
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf2.c"
void cond_median2_param_defaults(parampointer_t parampointer ) 
{ 


  {
#line 46
  parampointer->postlength2 = 4L;
#line 47
  parampointer->prelength2 = 4L;
#line 48
  parampointer->postlength3 = 5L;
#line 49
  parampointer->prelength3 = 5L;
#line 50
  parampointer->postlength4 = 100L;
#line 51
  parampointer->prelength4 = 100L;
#line 52
  parampointer->int1 = 12;
#line 57
  parampointer->long1 = 2000L;
#line 58
  parampointer->long2 = 8500L;
#line 66
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf2.c"
void cond_median2_param_screen(parampointer_t parampointer ) 
{ 
  stringinput_t rmslengthstr ;
  stringinput_t rmflengthstr ;
  stringinput_t decimatestr ;
  stringinput_t threshold1str ;
  stringinput_t threshold2str ;
  button_t ok_button ;
  button_t cancel_button ;
  button_t defaults_button ;
  int dont_stop ;
  int focus ;
  int in_ch ;
  int i ;
  long helplong ;
  char *helplines[8] ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 85
  dont_stop = 1;
#line 86
  focus = 0;
#line 91
  helplines[0] = (char *)" ^: less ticks detected.                v: not all of tick interpolated.       ";
#line 91
  helplines[1] = (char *)" ^: bad following of dynamics.          v: less ticks detected.                ";
#line 91
  helplines[2] = (char *)" ^: bad following of dynamics.          v: less ticks detected.                ";
#line 91
  helplines[3] = (char *)" ^: detected tick length too short      v: detected tick length longer.        ";
#line 91
  helplines[4] = (char *)" ^: only strong ticks detected.         v: music-ticks also filtered out.      ";
#line 91
  helplines[5] = (char *)" Discard changes.                                                              ";
#line 91
  helplines[6] = (char *)" Reset default values.                                                         ";
#line 91
  helplines[7] = (char *)" Accept changes.                                                               ";
#line 102
  rmslengthstr.maxlen = 500;
#line 103
  tmp = malloc((unsigned long )rmslengthstr.maxlen * sizeof(char ));
#line 103
  rmslengthstr.string = (char *)tmp;
#line 105
  sprintf((char */* __restrict  */)rmslengthstr.string, (char const   */* __restrict  */)"%ld",
          (parampointer->prelength2 + parampointer->postlength2) + 1L);
#line 107
  rmslengthstr.y = 6;
#line 108
  rmslengthstr.x = 59;
#line 109
  rmslengthstr.w = 19;
#line 110
  rmslengthstr.cursorpos = (int )strlen(rmslengthstr.string);
#line 111
  rmslengthstr.firstcharonscreen = 0;
#line 113
  rmflengthstr.maxlen = 500;
#line 114
  tmp___0 = malloc((unsigned long )rmflengthstr.maxlen * sizeof(char ));
#line 114
  rmflengthstr.string = (char *)tmp___0;
#line 116
  sprintf((char */* __restrict  */)rmflengthstr.string, (char const   */* __restrict  */)"%ld",
          (parampointer->prelength3 + parampointer->postlength3) + 1L);
#line 118
  rmflengthstr.y = 8;
#line 119
  rmflengthstr.x = 59;
#line 120
  rmflengthstr.w = 19;
#line 121
  rmflengthstr.cursorpos = (int )strlen(rmflengthstr.string);
#line 122
  rmflengthstr.firstcharonscreen = 0;
#line 124
  decimatestr.maxlen = 500;
#line 125
  tmp___1 = malloc((unsigned long )decimatestr.maxlen * sizeof(char ));
#line 125
  decimatestr.string = (char *)tmp___1;
#line 127
  sprintf((char */* __restrict  */)decimatestr.string, (char const   */* __restrict  */)"%d",
          parampointer->int1);
#line 128
  decimatestr.y = 10;
#line 129
  decimatestr.x = 59;
#line 130
  decimatestr.w = 19;
#line 131
  decimatestr.cursorpos = (int )strlen(decimatestr.string);
#line 132
  decimatestr.firstcharonscreen = 0;
#line 134
  threshold1str.maxlen = 500;
#line 135
  tmp___2 = malloc((unsigned long )threshold1str.maxlen * sizeof(char ));
#line 135
  threshold1str.string = (char *)tmp___2;
#line 137
  sprintf((char */* __restrict  */)threshold1str.string, (char const   */* __restrict  */)"%ld",
          parampointer->long1);
#line 138
  threshold1str.y = 12;
#line 139
  threshold1str.x = 59;
#line 140
  threshold1str.w = 19;
#line 141
  threshold1str.cursorpos = (int )strlen(threshold1str.string);
#line 142
  threshold1str.firstcharonscreen = 0;
#line 144
  threshold2str.maxlen = 500;
#line 145
  tmp___3 = malloc((unsigned long )threshold2str.maxlen * sizeof(char ));
#line 145
  threshold2str.string = (char *)tmp___3;
#line 147
  sprintf((char */* __restrict  */)threshold2str.string, (char const   */* __restrict  */)"%ld",
          parampointer->long2);
#line 148
  threshold2str.y = 14;
#line 149
  threshold2str.x = 59;
#line 150
  threshold2str.w = 19;
#line 151
  threshold2str.cursorpos = (int )strlen(threshold2str.string);
#line 152
  threshold2str.firstcharonscreen = 0;
#line 154
  ok_button.text = (char *)" OK ";
#line 155
  ok_button.y = 20;
#line 156
  ok_button.x = 71;
#line 157
  ok_button.selected = 0;
#line 159
  cancel_button.text = (char *)" Cancel ";
#line 160
  cancel_button.y = 20;
#line 161
  cancel_button.x = 5;
#line 162
  cancel_button.selected = 0;
#line 164
  defaults_button.text = (char *)" Defaults ";
#line 165
  defaults_button.y = 20;
#line 166
  defaults_button.x = 36;
#line 167
  defaults_button.selected = 0;
#line 169
  clearscreen((char *)"CMF II [FOURTH ORDER] - Parameters");
  }
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 173
    header((char *)"CMF II [FOURTH ORDER] - Parameters");
    }
#line 175
    if (focus == 5) {
#line 176
      cancel_button.selected = 1;
    } else {
#line 178
      cancel_button.selected = 0;
    }
#line 180
    if (focus == 6) {
#line 181
      defaults_button.selected = 1;
    } else {
#line 183
      defaults_button.selected = 0;
    }
#line 185
    if (focus == 7) {
#line 186
      ok_button.selected = 1;
    } else {
#line 188
      ok_button.selected = 0;
    }
    {
#line 190
    mvprintw(3, 2, "See also the Signproc.txt file for the meaning of the parameters.");
#line 193
    stringinput_display(& rmslengthstr);
#line 194
    mvprintw(rmslengthstr.y, 2, "Length of the RMS operation (samples):");
#line 197
    stringinput_display(& rmflengthstr);
#line 198
    mvprintw(rmflengthstr.y, 2, "Length of the recursive median operation (samples):");
#line 201
    stringinput_display(& decimatestr);
#line 202
    mvprintw(decimatestr.y, 2, "Decimation factor for the recursive median:");
#line 205
    stringinput_display(& threshold1str);
#line 206
    mvprintw(threshold1str.y, 2, "Fine threshold for tick start/end (thousandths):");
#line 209
    stringinput_display(& threshold2str);
#line 210
    mvprintw(threshold2str.y, 2, "Threshold for detection of tick presence (thousandths):");
#line 213
    button_display(& cancel_button);
#line 214
    tmp___4 = (int )strlen(cancel_button.text);
#line 214
    mybox(cancel_button.y - 1, cancel_button.x - 1, 3, tmp___4 + 2);
#line 216
    button_display(& defaults_button);
#line 217
    tmp___5 = (int )strlen(defaults_button.text);
#line 217
    mybox(defaults_button.y - 1, defaults_button.x - 1, 3, tmp___5 + 2);
#line 219
    button_display(& ok_button);
#line 220
    tmp___6 = (int )strlen(ok_button.text);
#line 220
    mybox(ok_button.y - 1, ok_button.x - 1, 3, tmp___6 + 2);
#line 223
    helpline(helplines[focus]);
    }
    {
#line 227
    if (focus == 0) {
#line 227
      goto case_0;
    }
#line 230
    if (focus == 1) {
#line 230
      goto case_1;
    }
#line 233
    if (focus == 2) {
#line 233
      goto case_2;
    }
#line 236
    if (focus == 3) {
#line 236
      goto case_3;
    }
#line 239
    if (focus == 4) {
#line 239
      goto case_4;
    }
#line 242
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 228
    stringinput_display(& rmslengthstr);
    }
#line 229
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 231
    stringinput_display(& rmflengthstr);
    }
#line 232
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 234
    stringinput_display(& decimatestr);
    }
#line 235
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 237
    stringinput_display(& threshold1str);
    }
#line 238
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 240
    stringinput_display(& threshold2str);
    }
#line 241
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 243
    wmove(stdscr, 0, 79);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 246
    wrefresh(stdscr);
#line 248
    in_ch = wgetch(stdscr);
    }
    {
#line 252
    if (focus == 0) {
#line 252
      goto case_0___0;
    }
#line 275
    if (focus == 1) {
#line 275
      goto case_1___0;
    }
#line 298
    if (focus == 2) {
#line 298
      goto case_2___0;
    }
#line 321
    if (focus == 3) {
#line 321
      goto case_3___0;
    }
#line 343
    if (focus == 4) {
#line 343
      goto case_4___0;
    }
#line 365
    if (focus == 5) {
#line 365
      goto case_5;
    }
#line 384
    if (focus == 6) {
#line 384
      goto case_6;
    }
#line 408
    if (focus == 7) {
#line 408
      goto case_7;
    }
#line 250
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 253
    stringinput_stdkeys(in_ch, & rmslengthstr);
    }
    {
#line 257
    if (in_ch == 13) {
#line 257
      goto case_13;
    }
#line 257
    if (in_ch == 343) {
#line 257
      goto case_13;
    }
#line 266
    if (in_ch == 259) {
#line 266
      goto case_259;
    }
#line 269
    if (in_ch == 258) {
#line 269
      goto case_258;
    }
#line 254
    goto switch_break___1;
    case_13: /* CIL Label */ 
    case_343: /* CIL Label */ 
    {
#line 258
    i = sscanf((char const   */* __restrict  */)rmslengthstr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 259
    if (i < 1) {
      {
#line 260
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else
#line 259
    if (helplong < 1L) {
      {
#line 260
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else
#line 259
    if (helplong % 2L == 0L) {
      {
#line 260
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else {
#line 263
      focus ++;
    }
#line 264
    goto switch_break___1;
    case_259: /* CIL Label */ 
#line 267
    focus --;
#line 268
    goto switch_break___1;
    case_258: /* CIL Label */ 
#line 270
    focus ++;
#line 271
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 273
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 276
    stringinput_stdkeys(in_ch, & rmflengthstr);
    }
    {
#line 280
    if (in_ch == 13) {
#line 280
      goto case_13___0;
    }
#line 280
    if (in_ch == 343) {
#line 280
      goto case_13___0;
    }
#line 289
    if (in_ch == 259) {
#line 289
      goto case_259___0;
    }
#line 292
    if (in_ch == 258) {
#line 292
      goto case_258___0;
    }
#line 277
    goto switch_break___2;
    case_13___0: /* CIL Label */ 
    case_343___0: /* CIL Label */ 
    {
#line 281
    i = sscanf((char const   */* __restrict  */)rmflengthstr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 282
    if (i < 1) {
      {
#line 283
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else
#line 282
    if (helplong < 1L) {
      {
#line 283
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else
#line 282
    if (helplong % 2L == 0L) {
      {
#line 283
      error_window((char *)"A whole, odd number, greater than 0, must be specified.");
      }
    } else {
#line 286
      focus ++;
    }
#line 287
    goto switch_break___2;
    case_259___0: /* CIL Label */ 
#line 290
    focus --;
#line 291
    goto switch_break___2;
    case_258___0: /* CIL Label */ 
#line 293
    focus ++;
#line 294
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 296
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 299
    stringinput_stdkeys(in_ch, & decimatestr);
    }
    {
#line 303
    if (in_ch == 13) {
#line 303
      goto case_13___1;
    }
#line 303
    if (in_ch == 343) {
#line 303
      goto case_13___1;
    }
#line 312
    if (in_ch == 259) {
#line 312
      goto case_259___1;
    }
#line 315
    if (in_ch == 258) {
#line 315
      goto case_258___1;
    }
#line 300
    goto switch_break___3;
    case_13___1: /* CIL Label */ 
    case_343___1: /* CIL Label */ 
    {
#line 304
    i = sscanf((char const   */* __restrict  */)decimatestr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 305
    if (i < 1) {
      {
#line 306
      error_window((char *)"A whole number, greater than 0, must be specified.");
      }
    } else
#line 305
    if (helplong < 1L) {
      {
#line 306
      error_window((char *)"A whole number, greater than 0, must be specified.");
      }
    } else {
#line 309
      focus ++;
    }
#line 310
    goto switch_break___3;
    case_259___1: /* CIL Label */ 
#line 313
    focus --;
#line 314
    goto switch_break___3;
    case_258___1: /* CIL Label */ 
#line 316
    focus ++;
#line 317
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 319
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 322
    stringinput_stdkeys(in_ch, & threshold1str);
    }
    {
#line 326
    if (in_ch == 13) {
#line 326
      goto case_13___2;
    }
#line 326
    if (in_ch == 343) {
#line 326
      goto case_13___2;
    }
#line 334
    if (in_ch == 259) {
#line 334
      goto case_259___2;
    }
#line 337
    if (in_ch == 258) {
#line 337
      goto case_258___2;
    }
#line 323
    goto switch_break___4;
    case_13___2: /* CIL Label */ 
    case_343___2: /* CIL Label */ 
    {
#line 327
    i = sscanf((char const   */* __restrict  */)threshold1str.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 328
    if (i < 1) {
      {
#line 329
      error_window((char *)"A whole, positive number must be specified.");
      }
    } else
#line 328
    if (helplong < 1L) {
      {
#line 329
      error_window((char *)"A whole, positive number must be specified.");
      }
    } else {
#line 331
      focus ++;
    }
#line 332
    goto switch_break___4;
    case_259___2: /* CIL Label */ 
#line 335
    focus --;
#line 336
    goto switch_break___4;
    case_258___2: /* CIL Label */ 
#line 338
    focus ++;
#line 339
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 341
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 344
    stringinput_stdkeys(in_ch, & threshold2str);
    }
    {
#line 348
    if (in_ch == 13) {
#line 348
      goto case_13___3;
    }
#line 348
    if (in_ch == 343) {
#line 348
      goto case_13___3;
    }
#line 356
    if (in_ch == 259) {
#line 356
      goto case_259___3;
    }
#line 359
    if (in_ch == 258) {
#line 359
      goto case_258___3;
    }
#line 345
    goto switch_break___5;
    case_13___3: /* CIL Label */ 
    case_343___3: /* CIL Label */ 
    {
#line 349
    i = sscanf((char const   */* __restrict  */)threshold2str.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 350
    if (i < 1) {
      {
#line 351
      error_window((char *)"A whole, positive number must be specified.");
      }
    } else
#line 350
    if (helplong < 1L) {
      {
#line 351
      error_window((char *)"A whole, positive number must be specified.");
      }
    } else {
#line 353
      focus = 7;
    }
#line 354
    goto switch_break___5;
    case_259___3: /* CIL Label */ 
#line 357
    focus --;
#line 358
    goto switch_break___5;
    case_258___3: /* CIL Label */ 
#line 360
    focus ++;
#line 361
    goto switch_break___5;
    switch_break___5: /* CIL Label */ ;
    }
#line 363
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
#line 369
    if (in_ch == 13) {
#line 369
      goto case_13___4;
    }
#line 369
    if (in_ch == 343) {
#line 369
      goto case_13___4;
    }
#line 374
    if (in_ch == 259) {
#line 374
      goto case_259___4;
    }
#line 374
    if (in_ch == 260) {
#line 374
      goto case_259___4;
    }
#line 378
    if (in_ch == 258) {
#line 378
      goto case_258___4;
    }
#line 378
    if (in_ch == 261) {
#line 378
      goto case_258___4;
    }
#line 366
    goto switch_break___6;
    case_13___4: /* CIL Label */ 
    case_343___4: /* CIL Label */ 
#line 370
    dont_stop = 0;
#line 371
    goto switch_break___6;
    case_259___4: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 375
    focus --;
#line 376
    goto switch_break___6;
    case_258___4: /* CIL Label */ 
    case_261: /* CIL Label */ 
#line 379
    focus ++;
#line 380
    goto switch_break___6;
    switch_break___6: /* CIL Label */ ;
    }
#line 382
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 388
    if (in_ch == 13) {
#line 388
      goto case_13___5;
    }
#line 388
    if (in_ch == 343) {
#line 388
      goto case_13___5;
    }
#line 398
    if (in_ch == 259) {
#line 398
      goto case_259___5;
    }
#line 398
    if (in_ch == 260) {
#line 398
      goto case_259___5;
    }
#line 402
    if (in_ch == 258) {
#line 402
      goto case_258___5;
    }
#line 402
    if (in_ch == 261) {
#line 402
      goto case_258___5;
    }
#line 385
    goto switch_break___7;
    case_13___5: /* CIL Label */ 
    case_343___5: /* CIL Label */ 
    {
#line 389
    tmp___7 = yesno_window((char *)"Restore default parameters?", (char *)" Yes ",
                           (char *)" No ", 0);
    }
#line 389
    if (tmp___7) {
      {
#line 392
      cond_median2_param_defaults(parampointer);
#line 393
      dont_stop = 0;
      }
    }
#line 395
    goto switch_break___7;
    case_259___5: /* CIL Label */ 
    case_260___0: /* CIL Label */ 
#line 399
    focus --;
#line 400
    goto switch_break___7;
    case_258___5: /* CIL Label */ 
    case_261___0: /* CIL Label */ 
#line 403
    focus ++;
#line 404
    goto switch_break___7;
    switch_break___7: /* CIL Label */ ;
    }
#line 406
    goto switch_break___0;
    case_7: /* CIL Label */ 
    {
#line 412
    if (in_ch == 13) {
#line 412
      goto case_13___6;
    }
#line 412
    if (in_ch == 343) {
#line 412
      goto case_13___6;
    }
#line 485
    if (in_ch == 259) {
#line 485
      goto case_259___6;
    }
#line 485
    if (in_ch == 260) {
#line 485
      goto case_259___6;
    }
#line 489
    if (in_ch == 258) {
#line 489
      goto case_258___6;
    }
#line 489
    if (in_ch == 261) {
#line 489
      goto case_258___6;
    }
#line 409
    goto switch_break___8;
    case_13___6: /* CIL Label */ 
    case_343___6: /* CIL Label */ 
    {
#line 414
    i = sscanf((char const   */* __restrict  */)rmslengthstr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 415
    if (i < 1) {
      {
#line 417
      error_window((char *)"A whole, odd number, greater than 0, must be specified as RMS length.");
#line 419
      rmslengthstr.cursorpos = (int )strlen(rmslengthstr.string);
#line 421
      focus = 0;
      }
#line 422
      goto switch_break___8;
    } else
#line 415
    if (helplong < 1L) {
      {
#line 417
      error_window((char *)"A whole, odd number, greater than 0, must be specified as RMS length.");
#line 419
      rmslengthstr.cursorpos = (int )strlen(rmslengthstr.string);
#line 421
      focus = 0;
      }
#line 422
      goto switch_break___8;
    } else
#line 415
    if (helplong % 2L == 0L) {
      {
#line 417
      error_window((char *)"A whole, odd number, greater than 0, must be specified as RMS length.");
#line 419
      rmslengthstr.cursorpos = (int )strlen(rmslengthstr.string);
#line 421
      focus = 0;
      }
#line 422
      goto switch_break___8;
    }
    {
#line 425
    parampointer->prelength2 = (helplong - 1L) / 2L;
#line 426
    parampointer->postlength2 = (helplong - 1L) / 2L;
#line 428
    i = sscanf((char const   */* __restrict  */)rmflengthstr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 429
    if (i < 1) {
      {
#line 431
      error_window((char *)"A whole, odd number, greater than 0, must be specified as length of the recursive median.");
#line 433
      rmflengthstr.cursorpos = (int )strlen(rmflengthstr.string);
#line 435
      focus = 1;
      }
#line 436
      goto switch_break___8;
    } else
#line 429
    if (helplong < 1L) {
      {
#line 431
      error_window((char *)"A whole, odd number, greater than 0, must be specified as length of the recursive median.");
#line 433
      rmflengthstr.cursorpos = (int )strlen(rmflengthstr.string);
#line 435
      focus = 1;
      }
#line 436
      goto switch_break___8;
    } else
#line 429
    if (helplong % 2L == 0L) {
      {
#line 431
      error_window((char *)"A whole, odd number, greater than 0, must be specified as length of the recursive median.");
#line 433
      rmflengthstr.cursorpos = (int )strlen(rmflengthstr.string);
#line 435
      focus = 1;
      }
#line 436
      goto switch_break___8;
    }
    {
#line 439
    parampointer->prelength3 = (helplong - 1L) / 2L;
#line 440
    parampointer->postlength3 = (helplong - 1L) / 2L;
#line 442
    i = sscanf((char const   */* __restrict  */)decimatestr.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 443
    if (i < 1) {
      {
#line 445
      error_window((char *)"A whole number, greater than 0, must be specified as decimation factor.");
#line 447
      decimatestr.cursorpos = (int )strlen(decimatestr.string);
#line 449
      focus = 2;
      }
#line 450
      goto switch_break___8;
    } else
#line 443
    if (helplong < 1L) {
      {
#line 445
      error_window((char *)"A whole number, greater than 0, must be specified as decimation factor.");
#line 447
      decimatestr.cursorpos = (int )strlen(decimatestr.string);
#line 449
      focus = 2;
      }
#line 450
      goto switch_break___8;
    }
    {
#line 453
    parampointer->int1 = (int )helplong;
#line 455
    i = sscanf((char const   */* __restrict  */)threshold1str.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 456
    if (i < 1) {
      {
#line 458
      error_window((char *)"A whole, positive number must be specified as threshold.");
#line 460
      threshold1str.cursorpos = (int )strlen(threshold1str.string);
#line 462
      focus = 3;
      }
#line 463
      goto switch_break___8;
    } else
#line 456
    if (helplong < 1L) {
      {
#line 458
      error_window((char *)"A whole, positive number must be specified as threshold.");
#line 460
      threshold1str.cursorpos = (int )strlen(threshold1str.string);
#line 462
      focus = 3;
      }
#line 463
      goto switch_break___8;
    }
    {
#line 466
    parampointer->long1 = helplong;
#line 468
    i = sscanf((char const   */* __restrict  */)threshold2str.string, (char const   */* __restrict  */)"%li",
               & helplong);
    }
#line 469
    if (i < 1) {
      {
#line 471
      error_window((char *)"A whole, positive number must be specified as threshold.");
#line 473
      threshold2str.cursorpos = (int )strlen(threshold2str.string);
#line 475
      focus = 4;
      }
#line 476
      goto switch_break___8;
    } else
#line 469
    if (helplong < 1000L) {
      {
#line 471
      error_window((char *)"A whole, positive number must be specified as threshold.");
#line 473
      threshold2str.cursorpos = (int )strlen(threshold2str.string);
#line 475
      focus = 4;
      }
#line 476
      goto switch_break___8;
    }
#line 479
    parampointer->long2 = helplong;
#line 481
    dont_stop = 0;
#line 482
    goto switch_break___8;
    case_259___6: /* CIL Label */ 
    case_260___1: /* CIL Label */ 
#line 486
    focus --;
#line 487
    goto switch_break___8;
    case_258___6: /* CIL Label */ 
    case_261___1: /* CIL Label */ 
#line 490
    focus ++;
#line 491
    goto switch_break___8;
    switch_break___8: /* CIL Label */ ;
    }
#line 493
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 496
    if (in_ch == 9) {
#line 497
      focus ++;
    }
#line 499
    if (in_ch == 27) {
#line 500
      dont_stop = 0;
    }
#line 502
    if (focus > 7) {
#line 503
      focus = 0;
    }
#line 504
    if (focus < 0) {
#line 505
      focus = 7;
    }
#line 171
    if (! dont_stop) {
#line 171
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 509
  free((void *)rmslengthstr.string);
#line 510
  free((void *)rmflengthstr.string);
#line 511
  free((void *)decimatestr.string);
#line 512
  free((void *)threshold1str.string);
#line 513
  free((void *)threshold2str.string);
  }
#line 514
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf2.c"
void init_cond_median2_filter(int filterno , parampointer_t parampointer ) 
{ 
  long total_post ;
  long total_pre ;
  long l ;

  {
#line 523
  total_post = ((parampointer->postlength4 + parampointer->prelength4) + 1L) + 4L;
#line 526
  total_pre = (parampointer->postlength4 + parampointer->prelength4) + 1L;
#line 527
  l = ((parampointer->prelength4 + parampointer->prelength3 * (long )parampointer->int1) + parampointer->prelength2) + 5L;
#line 530
  if (l > total_pre) {
#line 531
    total_pre = l;
  }
  {
#line 533
  parampointer->buffer = init_buffer(total_post, total_pre);
#line 534
  parampointer->buffer2 = init_buffer(parampointer->postlength2, parampointer->prelength2);
#line 536
  parampointer->buffer3 = init_buffer(parampointer->postlength3, parampointer->prelength3 * (long )parampointer->int1);
#line 538
  parampointer->buffer4 = init_buffer(parampointer->postlength4, parampointer->prelength4);
#line 541
  parampointer->filterno = filterno;
  }
#line 542
  return;
}
}
#line 545 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf2.c"
void delete_cond_median2_filter(parampointer_t parampointer ) 
{ 


  {
  {
#line 548
  delete_buffer(& parampointer->buffer);
#line 549
  delete_buffer(& parampointer->buffer2);
#line 550
  delete_buffer(& parampointer->buffer3);
#line 551
  delete_buffer(& parampointer->buffer4);
  }
#line 552
  return;
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf2.c"
sample_t cond_median2_highpass(long offset , long offset_zero , parampointer_t parampointer ) 
{ 
  sample_t sample ;
  longsample_t sum ;

  {
#line 562
  offset += offset_zero;
#line 564
  sum.left = 0L;
#line 565
  sum.right = 0L;
#line 605
  sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + ((parampointer->buffer.currpos + offset) - 2L)));
#line 606
  sum.left += (long )sample.left;
#line 607
  sum.right += (long )sample.right;
#line 608
  sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + ((parampointer->buffer.currpos + offset) - 1L)));
#line 609
  sum.left -= 4L * (long )sample.left;
#line 610
  sum.right -= 4L * (long )sample.right;
#line 611
  sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + (parampointer->buffer.currpos + offset)));
#line 612
  sum.left += 6L * (long )sample.left;
#line 613
  sum.right += 6L * (long )sample.right;
#line 614
  sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + ((parampointer->buffer.currpos + offset) + 1L)));
#line 615
  sum.left -= 4L * (long )sample.left;
#line 616
  sum.right -= 4L * (long )sample.right;
#line 617
  sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + ((parampointer->buffer.currpos + offset) + 2L)));
#line 618
  sum.left += (long )sample.left;
#line 619
  sum.right += (long )sample.right;
#line 621
  sum.left /= 4L;
#line 622
  sum.right /= 4L;
#line 653
  if (sum.left < 32767L) {
#line 654
    sample.left = (short )sum.left;
  } else {
#line 656
    sample.left = (short)32767;
  }
#line 658
  if (sum.right < 32767L) {
#line 659
    sample.right = (short )sum.right;
  } else {
#line 661
    sample.right = (short)32767;
  }
#line 663
  return (sample);
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf2.c"
sample_t (*cond_median2_highpass_pointer)(long offset , long offset_zero , parampointer_t parampointer )  =    & cond_median2_highpass;
#line 668 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf2.c"
sample_t cond_median2_rms(long offset , long offset_zero , parampointer_t parampointer ) 
{ 
  sample_t sample ;
  doublesample_t doublesample ;
  doublesample_t sum ;
  long i ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 677
  advance_current_pos_custom(& parampointer->buffer2, cond_median2_highpass_pointer,
                             offset + offset_zero, parampointer);
#line 682
  sum.left = (double )0;
#line 683
  sum.right = (double )0;
#line 685
  i = - parampointer->postlength2;
  }
  {
#line 685
  while (1) {
    while_continue: /* CIL Label */ ;
#line 685
    if (! (i <= parampointer->prelength2)) {
#line 685
      goto while_break;
    }
#line 688
    sample = *(parampointer->buffer2.array + *(parampointer->buffer2.indextable + (parampointer->buffer2.currpos + i)));
#line 689
    doublesample.left = (double )sample.left;
#line 690
    doublesample.right = (double )sample.right;
#line 691
    sum.left += doublesample.left * doublesample.left;
#line 692
    sum.right += doublesample.right * doublesample.right;
#line 685
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 695
  sum.left /= (double )((parampointer->postlength2 + parampointer->prelength2) + 1L);
#line 697
  sum.right /= (double )((parampointer->postlength2 + parampointer->prelength2) + 1L);
#line 700
  tmp = sqrt(sum.left + (double )1);
#line 700
  sample.left = (short )tmp;
#line 701
  tmp___0 = sqrt(sum.right + (double )1);
#line 701
  sample.right = (short )tmp___0;
  }
#line 703
  return (sample);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf2.c"
sample_t (*cond_median2_rms_pointer)(long offset , long offset_zero , parampointer_t parampointer )  =    & cond_median2_rms;
#line 708 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf2.c"
sample_t cond_median2_gate(long offset , long offset_zero , parampointer_t parampointer ) 
{ 
  sample_t sample ;
  sample_t w_t ;
  sample_t b_t ;
  sample_t returnval ;
  short *list1 ;
  unsigned long __lengthoflist1 ;
  void *tmp ;
  short *list2 ;
  unsigned long __lengthoflist2 ;
  void *tmp___0 ;
  long i ;
  long j ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 718
  __lengthoflist1 = (unsigned long )((parampointer->postlength3 + parampointer->prelength3 * (long )parampointer->int1) + 1L);
#line 718
  tmp = __builtin_alloca(sizeof(*list1) * __lengthoflist1);
#line 718
  list1 = (short *)tmp;
#line 720
  __lengthoflist2 = (unsigned long )((parampointer->postlength3 + parampointer->prelength3 * (long )parampointer->int1) + 1L);
#line 720
  tmp___0 = __builtin_alloca(sizeof(*list2) * __lengthoflist2);
#line 720
  list2 = (short *)tmp___0;
#line 724
  advance_current_pos_custom(& parampointer->buffer3, cond_median2_rms_pointer, offset + offset_zero,
                             parampointer);
#line 729
  w_t = *(parampointer->buffer3.array + *(parampointer->buffer3.indextable + parampointer->buffer3.currpos));
#line 733
  i = 0L;
  }
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
#line 733
    if (! (i < parampointer->postlength3)) {
#line 733
      goto while_break;
    }
#line 735
    sample = *(parampointer->buffer3.array + *(parampointer->buffer3.indextable + ((parampointer->buffer3.currpos + i) - parampointer->postlength3)));
#line 737
    *(list1 + i) = sample.left;
#line 738
    *(list2 + i) = sample.right;
#line 733
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 741
  j = i;
  {
#line 743
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 743
    if (! (i <= parampointer->postlength3 + parampointer->prelength3 * (long )parampointer->int1)) {
#line 743
      goto while_break___0;
    }
#line 747
    sample = *(parampointer->buffer3.array + *(parampointer->buffer3.indextable + ((parampointer->buffer3.currpos + i) - parampointer->postlength3)));
#line 749
    *(list1 + j) = sample.left;
#line 750
    *(list2 + j) = sample.right;
#line 751
    j ++;
#line 743
    i += (long )parampointer->int1;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 754
  b_t.left = median(list1, (int )j);
#line 755
  b_t.right = median(list2, (int )j);
#line 757
  *(parampointer->buffer3.array + *(parampointer->buffer3.indextable + parampointer->buffer3.currpos)) = b_t;
#line 760
  tmp___1 = labs((long )((int )w_t.left - (int )b_t.left));
#line 760
  i = (tmp___1 * 1000L) / (long )b_t.left;
  }
#line 763
  if (i > 32767L) {
#line 764
    i = 32767L;
  }
  {
#line 765
  returnval.left = (short )i;
#line 767
  tmp___2 = labs((long )((int )w_t.right - (int )b_t.right));
#line 767
  i = (tmp___2 * 1000L) / (long )b_t.right;
  }
#line 770
  if (i > 32767L) {
#line 771
    i = 32767L;
  }
#line 772
  returnval.right = (short )i;
#line 774
  return (returnval);
}
}
#line 777 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf2.c"
sample_t (*cond_median2_gate_pointer)(long offset , long offset_zero , parampointer_t parampointer )  =    & cond_median2_gate;
#line 779 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_cmf2.c"
sample_t cond_median2_filter(parampointer_t parampointer ) 
{ 
  sample_t sample ;
  sample_t gate ;
  sample_t returnval ;
  short *list3 ;
  unsigned long __lengthoflist3 ;
  void *tmp ;
  long i ;
  int toleft ;
  int toright ;
  short maxval ;

  {
  {
#line 784
  __lengthoflist3 = (unsigned long )(2L * ((parampointer->postlength4 + parampointer->prelength4) + 1L) + 1L);
#line 784
  tmp = __builtin_alloca(sizeof(*list3) * __lengthoflist3);
#line 784
  list3 = (short *)tmp;
#line 796
  advance_current_pos(& parampointer->buffer, parampointer->filterno);
#line 798
  advance_current_pos_custom(& parampointer->buffer4, cond_median2_gate_pointer, 0L,
                             parampointer);
#line 803
  gate = *(parampointer->buffer4.array + *(parampointer->buffer4.indextable + parampointer->buffer4.currpos));
#line 810
  returnval = *(parampointer->buffer.array + *(parampointer->buffer.indextable + parampointer->buffer.currpos));
  }
#line 813
  if ((long )gate.left > parampointer->long1) {
#line 815
    maxval = gate.left;
#line 817
    toleft = -1;
#line 818
    sample.left = (short)0;
    {
#line 819
    while (1) {
      while_continue: /* CIL Label */ ;
#line 821
      toleft ++;
#line 822
      if ((long )toleft < parampointer->postlength4) {
#line 824
        sample = *(parampointer->buffer4.array + *(parampointer->buffer4.indextable + ((parampointer->buffer4.currpos + (long )(- toleft)) - 1L)));
#line 825
        if ((int )sample.left > (int )maxval) {
#line 828
          maxval = sample.left;
        }
      }
#line 819
      if ((long )toleft < parampointer->postlength4) {
#line 819
        if (! ((long )sample.left > parampointer->long1)) {
#line 819
          goto while_break;
        }
      } else {
#line 819
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 834
    toright = -1;
#line 835
    sample.left = (short)0;
    {
#line 836
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 838
      toright ++;
#line 839
      if ((long )toright < parampointer->prelength4) {
#line 841
        sample = *(parampointer->buffer4.array + *(parampointer->buffer4.indextable + ((parampointer->buffer4.currpos + (long )toright) + 1L)));
#line 842
        if ((int )sample.left > (int )maxval) {
#line 845
          maxval = sample.left;
        }
      }
#line 836
      if ((long )toright < parampointer->prelength4) {
#line 836
        if (! ((long )sample.left > parampointer->long1)) {
#line 836
          goto while_break___0;
        }
      } else {
#line 836
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 855
    if ((long )maxval > parampointer->long2) {
#line 871
      i = 0L;
      {
#line 871
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 871
        if (! (i <= (long )(2 * ((toleft + toright) + 1)))) {
#line 871
          goto while_break___1;
        }
#line 872
        *(list3 + i) = (parampointer->buffer.array + *(parampointer->buffer.indextable + ((parampointer->buffer.currpos + i) - (long )((toleft + toright) + 1))))->left;
#line 871
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 875
      returnval.left = median(list3, 2 * ((toleft + toright) + 1) + 1);
      }
    }
  }
#line 881
  if ((long )gate.right > parampointer->long1) {
#line 883
    maxval = gate.right;
#line 885
    toleft = -1;
#line 886
    sample.right = (short)0;
    {
#line 887
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 889
      toleft ++;
#line 890
      if ((long )toleft < parampointer->postlength4) {
#line 892
        sample = *(parampointer->buffer4.array + *(parampointer->buffer4.indextable + ((parampointer->buffer4.currpos + (long )(- toleft)) - 1L)));
#line 893
        if ((int )sample.right > (int )maxval) {
#line 896
          maxval = sample.right;
        }
      }
#line 887
      if ((long )toleft < parampointer->postlength4) {
#line 887
        if (! ((long )sample.right > parampointer->long1)) {
#line 887
          goto while_break___2;
        }
      } else {
#line 887
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 902
    toright = -1;
#line 903
    sample.right = (short)0;
    {
#line 904
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 906
      toright ++;
#line 907
      if ((long )toright < parampointer->prelength4) {
#line 909
        sample = *(parampointer->buffer4.array + *(parampointer->buffer4.indextable + ((parampointer->buffer4.currpos + (long )toright) + 1L)));
#line 910
        if ((int )sample.right > (int )maxval) {
#line 913
          maxval = sample.right;
        }
      }
#line 904
      if ((long )toright < parampointer->prelength4) {
#line 904
        if (! ((long )sample.right > parampointer->long1)) {
#line 904
          goto while_break___3;
        }
      } else {
#line 904
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 923
    if ((long )maxval > parampointer->long2) {
#line 939
      i = 0L;
      {
#line 939
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 939
        if (! (i <= (long )(2 * ((toleft + toright) + 1)))) {
#line 939
          goto while_break___4;
        }
#line 940
        *(list3 + i) = (parampointer->buffer.array + *(parampointer->buffer.indextable + ((parampointer->buffer.currpos + i) - (long )((toleft + toright) + 1))))->right;
#line 939
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 943
      returnval.right = median(list3, 2 * ((toleft + toright) + 1) + 1);
      }
    }
  }
#line 949
  return (returnval);
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_mono.c"
void monoize_param_defaults(parampointer_t parampointer ) 
{ 


  {
#line 19
  return;
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_mono.c"
void monoize_param_screen(parampointer_t parampointer ) 
{ 


  {
  {
#line 24
  error_window((char *)"This `filter\' does not have adjustable parameters. It just averages the left & right signals.");
  }
#line 26
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_mono.c"
void init_monoize_filter(int filterno , parampointer_t parampointer ) 
{ 


  {
  {
#line 31
  parampointer->buffer = init_buffer(0L, 0L);
#line 33
  parampointer->filterno = filterno;
  }
#line 34
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_mono.c"
void delete_monoize_filter(parampointer_t parampointer ) 
{ 


  {
  {
#line 39
  delete_buffer(& parampointer->buffer);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_mono.c"
sample_t monoize_filter(parampointer_t parampointer ) 
{ 
  sample_t sample ;
  longsample_t sum ;

  {
  {
#line 49
  advance_current_pos(& parampointer->buffer, parampointer->filterno);
#line 51
  sample = *(parampointer->buffer.array + *(parampointer->buffer.indextable + parampointer->buffer.currpos));
#line 52
  sum.left = (long )(((int )sample.left + (int )sample.right) / 2);
#line 53
  sample.left = (short )sum.left;
#line 54
  sample.right = (short )sum.left;
  }
#line 56
  return (sample);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/tracksplit_filenm.c"
int tracksplit_select_file(char *startdir , char *selectedfile ) 
{ 
  scrollmenu_t dirfilelist ;
  stringinput_t string ;
  button_t next_button ;
  button_t cancel_button ;
  int dont_stop ;
  int returnval ;
  int focus ;
  int in_ch ;
  int i ;
  char helpstring[500] ;
  char *charpointer ;
  struct stat filestats ;
  int oldselected ;
  char *helplines[4] ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;

  {
  {
#line 40
  dont_stop = 1;
#line 41
  returnval = 0;
#line 42
  focus = 1;
#line 50
  helplines[0] = (char *)" Select name of sound file for track splitting.                 TAB: Next field";
#line 50
  helplines[1] = (char *)" Enter name of sound file for track splitting.                  TAB: Next field";
#line 50
  helplines[2] = (char *)" Back to main menu.                                             TAB: Next field";
#line 50
  helplines[3] = (char *)" To Track Splitting - Parameters.                               TAB: Next field";
#line 57
  dirfilelist.y = 3;
#line 58
  dirfilelist.x = 5;
#line 59
  dirfilelist.h = 12;
#line 60
  dirfilelist.w = 32;
#line 61
  dirfilelist.firstonscreen = 0;
#line 62
  dirfilemenu(startdir, & dirfilelist);
#line 63
  dirfilelist.selected = dirfilelist.last_of_1st_part + 1;
#line 65
  string.maxlen = 500;
#line 66
  tmp = malloc((unsigned long )string.maxlen * sizeof(char ));
#line 66
  string.string = (char *)tmp;
  }
#line 67
  if ((int )*(selectedfile + 0) == 0) {
    {
#line 68
    strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)startdir);
    }
  } else {
    {
#line 70
    strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)selectedfile);
    }
  }
  {
#line 71
  string.y = 17;
#line 72
  string.x = 5;
#line 73
  string.w = 70;
#line 74
  tmp___0 = strlen((char const   *)string.string);
#line 74
  string.cursorpos = (int )tmp___0;
#line 75
  tmp___1 = strlen((char const   *)string.string);
#line 75
  string.firstcharonscreen = (int )((tmp___1 - (size_t )string.w) + 2UL);
  }
#line 76
  if (string.firstcharonscreen < 0) {
#line 77
    string.firstcharonscreen = 0;
  }
  {
#line 79
  next_button.text = (char *)" Next screen > ";
#line 80
  next_button.y = 20;
#line 81
  next_button.x = 60;
#line 82
  next_button.selected = 0;
#line 84
  cancel_button.text = (char *)" Cancel ";
#line 85
  cancel_button.y = 20;
#line 86
  cancel_button.x = 36;
#line 87
  cancel_button.selected = 0;
#line 89
  clearscreen((char *)"Track Location - File Name");
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    header((char *)"Track Location - File Name");
    }
#line 95
    if (focus == 2) {
#line 96
      cancel_button.selected = 1;
    } else {
#line 98
      cancel_button.selected = 0;
    }
#line 100
    if (focus == 3) {
#line 101
      next_button.selected = 1;
    } else {
#line 103
      next_button.selected = 0;
    }
    {
#line 105
    dirfilelist.hasfocus = focus == 0;
#line 107
    scrollmenu_display(& dirfilelist);
#line 108
    mybox(dirfilelist.y - 1, dirfilelist.x - 1, dirfilelist.h + 2, dirfilelist.w + 2);
#line 110
    mvprintw(dirfilelist.y - 1, dirfilelist.x + 1, "Files and directories:");
#line 113
    stringinput_display(& string);
#line 114
    mybox(string.y - 1, string.x - 1, 3, string.w + 2);
#line 115
    mvprintw(string.y - 1, string.x + 1, "File name:");
#line 117
    button_display(& cancel_button);
#line 118
    tmp___2 = strlen((char const   *)cancel_button.text);
#line 118
    mybox(cancel_button.y - 1, cancel_button.x - 1, 3, (int )(tmp___2 + 2UL));
#line 120
    button_display(& next_button);
#line 121
    tmp___3 = strlen((char const   *)next_button.text);
#line 121
    mybox(next_button.y - 1, next_button.x - 1, 3, (int )(tmp___3 + 2UL));
#line 124
    helpline(helplines[focus]);
    }
#line 126
    if (focus == 1) {
      {
#line 127
      stringinput_display(& string);
      }
    } else {
      {
#line 129
      wmove(stdscr, 0, 79);
      }
    }
    {
#line 131
    wrefresh(stdscr);
#line 133
    in_ch = wgetch(stdscr);
    }
    {
#line 137
    if (focus == 0) {
#line 137
      goto case_0;
    }
#line 189
    if (focus == 1) {
#line 189
      goto case_1;
    }
#line 230
    if (focus == 2) {
#line 230
      goto case_2;
    }
#line 250
    if (focus == 3) {
#line 250
      goto case_3;
    }
#line 135
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 138
    tmp___5 = scrollmenu_stdkeys(in_ch, & dirfilelist);
    }
#line 138
    if (tmp___5 >= 0) {
      {
#line 140
      oldselected = dirfilelist.selected;
#line 141
      i = dirfilemenu_process_select(& dirfilelist, helpstring);
      }
#line 143
      if (i == 0) {
        {
#line 145
        strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)(helpstring));
#line 146
        focus = 1;
#line 147
        tmp___4 = strlen((char const   *)string.string);
#line 147
        string.cursorpos = (int )tmp___4;
#line 148
        string.firstcharonscreen = 0;
        }
      } else {
        {
#line 153
        scrollmenu_delete_menu(& dirfilelist);
#line 154
        dirfilemenu(helpstring, & dirfilelist);
        }
#line 155
        if (dirfilelist.number == 0) {
          {
#line 157
          error_window((char *)"No permission to read this directory.");
#line 159
          scrollmenu_delete_menu(& dirfilelist);
#line 160
          dirfilemenu(startdir, & dirfilelist);
#line 161
          dirfilelist.selected = oldselected;
          }
        } else {
          {
#line 165
          strcpy((char */* __restrict  */)startdir, (char const   */* __restrict  */)(helpstring));
#line 166
          dirfilelist.firstonscreen = 0;
#line 168
          charpointer = strrchr((char const   *)string.string, '/');
          }
#line 169
          if ((unsigned long )charpointer != (unsigned long )((void *)0)) {
            {
#line 170
            strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)(charpointer + 1));
            }
          } else {
            {
#line 172
            strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)string.string);
            }
          }
          {
#line 173
          strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)(helpstring));
          }
        }
      }
    } else {
      {
#line 180
      if (in_ch == 260) {
#line 180
        goto case_260;
      }
#line 183
      if (in_ch == 261) {
#line 183
        goto case_261;
      }
#line 178
      goto switch_break___0;
      case_260: /* CIL Label */ 
#line 181
      focus --;
#line 182
      goto switch_break___0;
      case_261: /* CIL Label */ 
#line 184
      focus ++;
#line 185
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 187
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 190
    stringinput_stdkeys(in_ch, & string);
    }
#line 191
    if (in_ch == 343) {
#line 191
      goto _L;
    } else
#line 191
    if (in_ch == 13) {
      _L: /* CIL Label */ 
      {
#line 193
      strcpy((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)string.string);
      }
      {
#line 196
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 196
        tmp___7 = strlen((char const   *)(helpstring));
        }
#line 196
        if (tmp___7 > 0UL) {
          {
#line 196
          tmp___8 = strlen((char const   *)(helpstring));
          }
#line 196
          if (! ((int )helpstring[tmp___8 - 1UL] == 47)) {
#line 196
            goto while_break___0;
          }
        } else {
#line 196
          goto while_break___0;
        }
        {
#line 198
        tmp___6 = strlen((char const   *)(helpstring));
#line 198
        helpstring[tmp___6 - 1UL] = (char )'\000';
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 200
      strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)"/");
#line 202
      tmp___10 = stat((char const   */* __restrict  */)(helpstring), (struct stat */* __restrict  */)(& filestats));
      }
#line 202
      if (tmp___10) {
#line 216
        focus = 3;
      } else
#line 202
      if ((filestats.st_mode & 61440U) == 16384U) {
        {
#line 205
        strcpy((char */* __restrict  */)startdir, (char const   */* __restrict  */)(helpstring));
#line 206
        scrollmenu_delete_menu(& dirfilelist);
#line 207
        dirfilemenu(startdir, & dirfilelist);
#line 208
        dirfilelist.firstonscreen = 0;
#line 209
        dirfilelist.selected = dirfilelist.last_of_1st_part + 1;
#line 211
        strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)startdir);
#line 212
        tmp___9 = strlen((char const   *)string.string);
#line 212
        string.cursorpos = (int )tmp___9;
#line 213
        focus = 0;
        }
      } else {
#line 216
        focus = 3;
      }
    } else {
      {
#line 221
      if (in_ch == 259) {
#line 221
        goto case_259;
      }
#line 224
      if (in_ch == 258) {
#line 224
        goto case_258;
      }
#line 219
      goto switch_break___1;
      case_259: /* CIL Label */ 
#line 222
      focus --;
#line 223
      goto switch_break___1;
      case_258: /* CIL Label */ 
#line 225
      focus ++;
#line 226
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
#line 228
    goto switch_break;
    case_2: /* CIL Label */ 
#line 231
    if (in_ch == 343) {
#line 233
      returnval = 0;
#line 234
      dont_stop = 0;
    } else
#line 231
    if (in_ch == 13) {
#line 233
      returnval = 0;
#line 234
      dont_stop = 0;
    } else {
      {
#line 240
      if (in_ch == 259) {
#line 240
        goto case_259___0;
      }
#line 240
      if (in_ch == 260) {
#line 240
        goto case_259___0;
      }
#line 244
      if (in_ch == 258) {
#line 244
        goto case_258___0;
      }
#line 244
      if (in_ch == 261) {
#line 244
        goto case_258___0;
      }
#line 237
      goto switch_break___2;
      case_259___0: /* CIL Label */ 
      case_260___0: /* CIL Label */ 
#line 241
      focus --;
#line 242
      goto switch_break___2;
      case_258___0: /* CIL Label */ 
      case_261___0: /* CIL Label */ 
#line 245
      focus ++;
#line 246
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    }
#line 248
    goto switch_break;
    case_3: /* CIL Label */ 
#line 251
    if (in_ch == 343) {
#line 251
      goto _L___0;
    } else
#line 251
    if (in_ch == 13) {
      _L___0: /* CIL Label */ 
      {
#line 252
      tmp___11 = checkfile(string.string);
      }
      {
#line 254
      if (tmp___11 == 1) {
#line 254
        goto case_1___0;
      }
#line 260
      if (tmp___11 == 2) {
#line 260
        goto case_2___0;
      }
#line 268
      if (tmp___11 == 4) {
#line 268
        goto case_4;
      }
#line 268
      if (tmp___11 == 3) {
#line 268
        goto case_4;
      }
#line 274
      goto switch_default;
      case_1___0: /* CIL Label */ 
      {
#line 255
      strcpy((char */* __restrict  */)selectedfile, (char const   */* __restrict  */)string.string);
#line 256
      returnval = 2;
#line 257
      dont_stop = 0;
      }
#line 258
      goto switch_break___3;
      case_2___0: /* CIL Label */ 
      {
#line 261
      error_window((char *)"The specified name is of a directory. A file name must be specified.");
#line 263
      tmp___12 = strlen((char const   *)string.string);
#line 263
      string.cursorpos = (int )tmp___12;
#line 264
      focus = 1;
      }
#line 265
      goto switch_break___3;
      case_4: /* CIL Label */ 
      case_3___0: /* CIL Label */ 
      {
#line 269
      error_window((char *)"The specified file does not exist.");
#line 270
      tmp___13 = strlen((char const   *)string.string);
#line 270
      string.cursorpos = (int )tmp___13;
#line 271
      focus = 1;
      }
#line 272
      goto switch_break___3;
      switch_default: /* CIL Label */ 
      {
#line 275
      error_window((char *)"Fell out of switch, tracksplit_filenm #1");
      }
#line 276
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 282
      if (in_ch == 259) {
#line 282
        goto case_259___1;
      }
#line 282
      if (in_ch == 260) {
#line 282
        goto case_259___1;
      }
#line 286
      if (in_ch == 258) {
#line 286
        goto case_258___1;
      }
#line 286
      if (in_ch == 261) {
#line 286
        goto case_258___1;
      }
#line 279
      goto switch_break___4;
      case_259___1: /* CIL Label */ 
      case_260___1: /* CIL Label */ 
#line 283
      focus --;
#line 284
      goto switch_break___4;
      case_258___1: /* CIL Label */ 
      case_261___1: /* CIL Label */ 
#line 287
      focus ++;
#line 288
      goto switch_break___4;
      switch_break___4: /* CIL Label */ ;
      }
    }
#line 290
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 293
    if (in_ch == 9) {
#line 294
      focus ++;
    }
#line 296
    if (in_ch == 27) {
#line 297
      dont_stop = 0;
    }
#line 299
    if (focus > 3) {
#line 300
      focus = 0;
    }
#line 301
    if (focus < 0) {
#line 302
      focus = 3;
    }
#line 91
    if (! dont_stop) {
#line 91
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 306
  scrollmenu_delete_menu(& dirfilelist);
#line 307
  free((void *)string.string);
  }
#line 309
  return (returnval);
}
}
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 279 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) rint)(double __x ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_l1fit.h"
long mdfunc(double b , short *x , short *y , double *a , int n , short *tmp1 ) ;
#line 8
void l1fit(short *x , short *y , int n , double *a , double *b ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_l1fit.c"
long mdfunc(double b , short *x , short *y , double *a , int n , short *tmp1 ) 
{ 
  int i ;
  long result ;
  double dtmp ;
  double tmp ;
  short tmp___0 ;
  int tmp___1 ;

  {
#line 29
  i = 0;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (i < n)) {
#line 29
      goto while_break;
    }
    {
#line 31
    tmp = rint((double )*(y + i) - b * (double )*(x + i));
#line 31
    *(tmp1 + i) = (short )tmp;
#line 29
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 34
  tmp___0 = median(tmp1, n);
#line 34
  *a = (double )tmp___0;
#line 36
  result = 0L;
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 37
    if (! (i < n)) {
#line 37
      goto while_break___0;
    }
#line 39
    dtmp = (double )*(y + i) - (b * (double )*(x + i) + *a);
#line 40
    if ((int )*(y + i) != 0) {
      {
#line 41
      tmp___1 = abs((int )*(y + i));
#line 41
      dtmp /= (double )tmp___1;
      }
    }
#line 42
    if (dtmp > (double )0) {
#line 44
      result += (long )*(x + i);
    } else
#line 46
    if (dtmp < (double )0) {
#line 48
      result -= (long )*(x + i);
    }
#line 37
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 53
  return (result);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_l1fit.c"
void l1fit(short *x , short *y , int n , double *a , double *b ) 
{ 
  int sx ;
  int sy ;
  int sxx ;
  int sxy ;
  int del ;
  double aa ;
  double bb ;
  double c2 ;
  double sigb ;
  double b1 ;
  double b2 ;
  double delb ;
  long f1 ;
  long f2 ;
  long f ;
  int i ;
  short *tmp1 ;
  short tmp ;
  void *tmp___0 ;
  double tmp___1 ;

  {
#line 71
  sx = 0;
#line 72
  sy = 0;
#line 73
  sxx = 0;
#line 74
  sxy = 0;
#line 76
  i = 0;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i < n)) {
#line 76
      goto while_break;
    }
#line 78
    sx += (int )*(x + i);
#line 79
    sy += (int )*(y + i);
#line 80
    sxx += (int )*(x + i) * (int )*(x + i);
#line 81
    sxy += (int )*(x + i) * (int )*(y + i);
#line 76
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  del = n * sxx - sx * sx;
#line 86
  if (del == 0) {
    {
#line 88
    tmp = median(y, n);
#line 88
    *a = (double )tmp;
#line 89
    *b = 0.;
    }
#line 90
    return;
  }
#line 97
  aa = (double )(sxx * sy - sx * sxy) / (double )del;
#line 98
  bb = (double )(n * sxy - sx * sy) / (double )del;
#line 100
  c2 = 0.;
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 101
    if (! (i < n)) {
#line 101
      goto while_break___0;
    }
#line 102
    c2 += ((double )*(y + i) - (aa + bb * (double )*(x + i))) * ((double )*(y + i) - (aa + bb * (double )*(x + i)));
#line 101
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 103
  sigb = sqrt(c2 / (double )del);
  }
#line 107
  if (c2 == 0.) {
#line 109
    *a = aa;
#line 110
    *b = bb;
#line 111
    return;
  }
  {
#line 114
  tmp___0 = malloc((unsigned long )n * sizeof(short ));
#line 114
  tmp1 = (short *)tmp___0;
#line 116
  b1 = bb;
#line 117
  f1 = mdfunc(b1, x, y, & aa, n, tmp1);
  }
#line 118
  if (f1 >= 0L) {
#line 120
    delb = sigb * 3.;
  } else {
#line 124
    delb = - sigb * 3.;
  }
  {
#line 127
  b2 = b1 + delb;
#line 128
  f2 = mdfunc(b2, x, y, & aa, n, tmp1);
  }
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (f1 * f2 > 0L)) {
#line 130
      goto while_break___1;
    }
    {
#line 132
    b1 = b2;
#line 133
    f1 = f2;
#line 134
    b2 = b1 + delb;
#line 135
    f2 = mdfunc(b2, x, y, & aa, n, tmp1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 138
  sigb *= 0.01;
  {
#line 140
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 140
    tmp___1 = fabs(b1 - b2);
    }
#line 140
    if (! (tmp___1 > sigb)) {
#line 140
      goto while_break___2;
    }
#line 142
    bb = (b1 + b2) / 2.;
#line 143
    if (bb == b1) {
#line 144
      goto while_break___2;
    } else
#line 143
    if (bb == b2) {
#line 144
      goto while_break___2;
    }
    {
#line 145
    f = mdfunc(bb, x, y, & aa, n, tmp1);
    }
#line 146
    if (f * f1 >= 0L) {
#line 148
      f1 = f;
#line 149
      b1 = bb;
    } else {
#line 153
      f2 = f;
#line 154
      b2 = bb;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 158
  free((void *)tmp1);
#line 160
  *a = aa;
#line 161
  *b = bb;
  }
#line 162
  return;
}
}
#line 813 "/usr/include/curses.h"
extern int whline(WINDOW * , chtype  , int  ) ;
#line 840
extern int wvline(WINDOW * , chtype  , int  ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/boxes.c"
void mybox(int y , int x , int h , int w ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 22
  tmp = wmove(stdscr, y, x);
  }
#line 22
  if (! (tmp == -1)) {
    {
#line 22
    waddch(stdscr, (chtype const   )acs_map[(unsigned char )'l']);
    }
  }
  {
#line 23
  tmp___0 = wmove(stdscr, y, (x + w) - 1);
  }
#line 23
  if (! (tmp___0 == -1)) {
    {
#line 23
    waddch(stdscr, (chtype const   )acs_map[(unsigned char )'k']);
    }
  }
  {
#line 24
  tmp___1 = wmove(stdscr, (y + h) - 1, x);
  }
#line 24
  if (! (tmp___1 == -1)) {
    {
#line 24
    waddch(stdscr, (chtype const   )acs_map[(unsigned char )'m']);
    }
  }
  {
#line 25
  tmp___2 = wmove(stdscr, (y + h) - 1, (x + w) - 1);
  }
#line 25
  if (! (tmp___2 == -1)) {
    {
#line 25
    waddch(stdscr, (chtype const   )acs_map[(unsigned char )'j']);
    }
  }
  {
#line 27
  wmove(stdscr, y, x + 1);
#line 28
  whline(stdscr, acs_map[(unsigned char )'q'], w - 2);
#line 29
  wmove(stdscr, y + 1, (x + w) - 1);
#line 30
  wvline(stdscr, acs_map[(unsigned char )'x'], h - 2);
#line 31
  wmove(stdscr, (y + h) - 1, x + 1);
#line 32
  whline(stdscr, acs_map[(unsigned char )'q'], w - 2);
#line 33
  wmove(stdscr, y + 1, x);
#line 34
  wvline(stdscr, acs_map[(unsigned char )'x'], h - 2);
  }
#line 35
  return;
}
}
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/splashscr.c"
void splashscreen(void) 
{ 
  char splashtext[1080] ;

  {
  {
#line 21
  splashtext[0] = (char )'\n';
#line 21
  splashtext[1] = (char )' ';
#line 21
  splashtext[2] = (char )' ';
#line 21
  splashtext[3] = (char )'#';
#line 21
  splashtext[4] = (char )'#';
#line 21
  splashtext[5] = (char )'#';
#line 21
  splashtext[6] = (char )'#';
#line 21
  splashtext[7] = (char )'#';
#line 21
  splashtext[8] = (char )'#';
#line 21
  splashtext[9] = (char )'#';
#line 21
  splashtext[10] = (char )' ';
#line 21
  splashtext[11] = (char )' ';
#line 21
  splashtext[12] = (char )' ';
#line 21
  splashtext[13] = (char )' ';
#line 21
  splashtext[14] = (char )' ';
#line 21
  splashtext[15] = (char )' ';
#line 21
  splashtext[16] = (char )' ';
#line 21
  splashtext[17] = (char )' ';
#line 21
  splashtext[18] = (char )' ';
#line 21
  splashtext[19] = (char )' ';
#line 21
  splashtext[20] = (char )' ';
#line 21
  splashtext[21] = (char )' ';
#line 21
  splashtext[22] = (char )' ';
#line 21
  splashtext[23] = (char )' ';
#line 21
  splashtext[24] = (char )' ';
#line 21
  splashtext[25] = (char )' ';
#line 21
  splashtext[26] = (char )' ';
#line 21
  splashtext[27] = (char )' ';
#line 21
  splashtext[28] = (char )' ';
#line 21
  splashtext[29] = (char )' ';
#line 21
  splashtext[30] = (char )' ';
#line 21
  splashtext[31] = (char )' ';
#line 21
  splashtext[32] = (char )' ';
#line 21
  splashtext[33] = (char )' ';
#line 21
  splashtext[34] = (char )' ';
#line 21
  splashtext[35] = (char )' ';
#line 21
  splashtext[36] = (char )' ';
#line 21
  splashtext[37] = (char )' ';
#line 21
  splashtext[38] = (char )' ';
#line 21
  splashtext[39] = (char )' ';
#line 21
  splashtext[40] = (char )' ';
#line 21
  splashtext[41] = (char )' ';
#line 21
  splashtext[42] = (char )' ';
#line 21
  splashtext[43] = (char )' ';
#line 21
  splashtext[44] = (char )' ';
#line 21
  splashtext[45] = (char )' ';
#line 21
  splashtext[46] = (char )' ';
#line 21
  splashtext[47] = (char )' ';
#line 21
  splashtext[48] = (char )' ';
#line 21
  splashtext[49] = (char )' ';
#line 21
  splashtext[50] = (char )' ';
#line 21
  splashtext[51] = (char )' ';
#line 21
  splashtext[52] = (char )' ';
#line 21
  splashtext[53] = (char )' ';
#line 21
  splashtext[54] = (char )'#';
#line 21
  splashtext[55] = (char )'#';
#line 21
  splashtext[56] = (char )'#';
#line 21
  splashtext[57] = (char )'#';
#line 21
  splashtext[58] = (char )'#';
#line 21
  splashtext[59] = (char )'#';
#line 21
  splashtext[60] = (char )'#';
#line 21
  splashtext[61] = (char )' ';
#line 21
  splashtext[62] = (char )'#';
#line 21
  splashtext[63] = (char )'#';
#line 21
  splashtext[64] = (char )' ';
#line 21
  splashtext[65] = (char )' ';
#line 21
  splashtext[66] = (char )' ';
#line 21
  splashtext[67] = (char )'#';
#line 21
  splashtext[68] = (char )'#';
#line 21
  splashtext[69] = (char )'#';
#line 21
  splashtext[70] = (char )'\n';
#line 21
  splashtext[71] = (char )' ';
#line 21
  splashtext[72] = (char )'#';
#line 21
  splashtext[73] = (char )'#';
#line 21
  splashtext[74] = (char )' ';
#line 21
  splashtext[75] = (char )' ';
#line 21
  splashtext[76] = (char )' ';
#line 21
  splashtext[77] = (char )' ';
#line 21
  splashtext[78] = (char )' ';
#line 21
  splashtext[79] = (char )' ';
#line 21
  splashtext[80] = (char )' ';
#line 21
  splashtext[81] = (char )' ';
#line 21
  splashtext[82] = (char )' ';
#line 21
  splashtext[83] = (char )' ';
#line 21
  splashtext[84] = (char )' ';
#line 21
  splashtext[85] = (char )' ';
#line 21
  splashtext[86] = (char )' ';
#line 21
  splashtext[87] = (char )' ';
#line 21
  splashtext[88] = (char )' ';
#line 21
  splashtext[89] = (char )' ';
#line 21
  splashtext[90] = (char )' ';
#line 21
  splashtext[91] = (char )' ';
#line 21
  splashtext[92] = (char )' ';
#line 21
  splashtext[93] = (char )' ';
#line 21
  splashtext[94] = (char )' ';
#line 21
  splashtext[95] = (char )' ';
#line 21
  splashtext[96] = (char )' ';
#line 21
  splashtext[97] = (char )' ';
#line 21
  splashtext[98] = (char )' ';
#line 21
  splashtext[99] = (char )' ';
#line 21
  splashtext[100] = (char )' ';
#line 21
  splashtext[101] = (char )' ';
#line 21
  splashtext[102] = (char )' ';
#line 21
  splashtext[103] = (char )' ';
#line 21
  splashtext[104] = (char )' ';
#line 21
  splashtext[105] = (char )' ';
#line 21
  splashtext[106] = (char )' ';
#line 21
  splashtext[107] = (char )' ';
#line 21
  splashtext[108] = (char )' ';
#line 21
  splashtext[109] = (char )' ';
#line 21
  splashtext[110] = (char )' ';
#line 21
  splashtext[111] = (char )' ';
#line 21
  splashtext[112] = (char )' ';
#line 21
  splashtext[113] = (char )' ';
#line 21
  splashtext[114] = (char )' ';
#line 21
  splashtext[115] = (char )' ';
#line 21
  splashtext[116] = (char )' ';
#line 21
  splashtext[117] = (char )' ';
#line 21
  splashtext[118] = (char )' ';
#line 21
  splashtext[119] = (char )' ';
#line 21
  splashtext[120] = (char )' ';
#line 21
  splashtext[121] = (char )' ';
#line 21
  splashtext[122] = (char )' ';
#line 21
  splashtext[123] = (char )'#';
#line 21
  splashtext[124] = (char )'#';
#line 21
  splashtext[125] = (char )' ';
#line 21
  splashtext[126] = (char )' ';
#line 21
  splashtext[127] = (char )' ';
#line 21
  splashtext[128] = (char )' ';
#line 21
  splashtext[129] = (char )' ';
#line 21
  splashtext[130] = (char )' ';
#line 21
  splashtext[131] = (char )' ';
#line 21
  splashtext[132] = (char )' ';
#line 21
  splashtext[133] = (char )' ';
#line 21
  splashtext[134] = (char )' ';
#line 21
  splashtext[135] = (char )' ';
#line 21
  splashtext[136] = (char )' ';
#line 21
  splashtext[137] = (char )' ';
#line 21
  splashtext[138] = (char )'#';
#line 21
  splashtext[139] = (char )'#';
#line 21
  splashtext[140] = (char )'\n';
#line 21
  splashtext[141] = (char )' ';
#line 21
  splashtext[142] = (char )'#';
#line 21
  splashtext[143] = (char )'#';
#line 21
  splashtext[144] = (char )' ';
#line 21
  splashtext[145] = (char )' ';
#line 21
  splashtext[146] = (char )' ';
#line 21
  splashtext[147] = (char )' ';
#line 21
  splashtext[148] = (char )' ';
#line 21
  splashtext[149] = (char )' ';
#line 21
  splashtext[150] = (char )' ';
#line 21
  splashtext[151] = (char )' ';
#line 21
  splashtext[152] = (char )'#';
#line 21
  splashtext[153] = (char )'#';
#line 21
  splashtext[154] = (char )' ';
#line 21
  splashtext[155] = (char )'#';
#line 21
  splashtext[156] = (char )'#';
#line 21
  splashtext[157] = (char )'#';
#line 21
  splashtext[158] = (char )'#';
#line 21
  splashtext[159] = (char )' ';
#line 21
  splashtext[160] = (char )' ';
#line 21
  splashtext[161] = (char )' ';
#line 21
  splashtext[162] = (char )'#';
#line 21
  splashtext[163] = (char )'#';
#line 21
  splashtext[164] = (char )'#';
#line 21
  splashtext[165] = (char )'#';
#line 21
  splashtext[166] = (char )'#';
#line 21
  splashtext[167] = (char )' ';
#line 21
  splashtext[168] = (char )' ';
#line 21
  splashtext[169] = (char )' ';
#line 21
  splashtext[170] = (char )'#';
#line 21
  splashtext[171] = (char )'#';
#line 21
  splashtext[172] = (char )' ';
#line 21
  splashtext[173] = (char )'#';
#line 21
  splashtext[174] = (char )'#';
#line 21
  splashtext[175] = (char )'#';
#line 21
  splashtext[176] = (char )' ';
#line 21
  splashtext[177] = (char )'#';
#line 21
  splashtext[178] = (char )'#';
#line 21
  splashtext[179] = (char )'#';
#line 21
  splashtext[180] = (char )' ';
#line 21
  splashtext[181] = (char )' ';
#line 21
  splashtext[182] = (char )' ';
#line 21
  splashtext[183] = (char )' ';
#line 21
  splashtext[184] = (char )'#';
#line 21
  splashtext[185] = (char )'#';
#line 21
  splashtext[186] = (char )'#';
#line 21
  splashtext[187] = (char )'#';
#line 21
  splashtext[188] = (char )'#';
#line 21
  splashtext[189] = (char )' ';
#line 21
  splashtext[190] = (char )' ';
#line 21
  splashtext[191] = (char )' ';
#line 21
  splashtext[192] = (char )' ';
#line 21
  splashtext[193] = (char )'#';
#line 21
  splashtext[194] = (char )'#';
#line 21
  splashtext[195] = (char )' ';
#line 21
  splashtext[196] = (char )' ';
#line 21
  splashtext[197] = (char )' ';
#line 21
  splashtext[198] = (char )' ';
#line 21
  splashtext[199] = (char )' ';
#line 21
  splashtext[200] = (char )' ';
#line 21
  splashtext[201] = (char )'#';
#line 21
  splashtext[202] = (char )'#';
#line 21
  splashtext[203] = (char )'#';
#line 21
  splashtext[204] = (char )' ';
#line 21
  splashtext[205] = (char )' ';
#line 21
  splashtext[206] = (char )' ';
#line 21
  splashtext[207] = (char )' ';
#line 21
  splashtext[208] = (char )'#';
#line 21
  splashtext[209] = (char )'#';
#line 21
  splashtext[210] = (char )' ';
#line 21
  splashtext[211] = (char )' ';
#line 21
  splashtext[212] = (char )' ';
#line 21
  splashtext[213] = (char )' ';
#line 21
  splashtext[214] = (char )'#';
#line 21
  splashtext[215] = (char )'#';
#line 21
  splashtext[216] = (char )'#';
#line 21
  splashtext[217] = (char )'#';
#line 21
  splashtext[218] = (char )'#';
#line 21
  splashtext[219] = (char )'\n';
#line 21
  splashtext[220] = (char )' ';
#line 21
  splashtext[221] = (char )'#';
#line 21
  splashtext[222] = (char )'#';
#line 21
  splashtext[223] = (char )' ';
#line 21
  splashtext[224] = (char )' ';
#line 21
  splashtext[225] = (char )'#';
#line 21
  splashtext[226] = (char )'#';
#line 21
  splashtext[227] = (char )'#';
#line 21
  splashtext[228] = (char )'#';
#line 21
  splashtext[229] = (char )' ';
#line 21
  splashtext[230] = (char )' ';
#line 21
  splashtext[231] = (char )' ';
#line 21
  splashtext[232] = (char )'#';
#line 21
  splashtext[233] = (char )'#';
#line 21
  splashtext[234] = (char )' ';
#line 21
  splashtext[235] = (char )' ';
#line 21
  splashtext[236] = (char )' ';
#line 21
  splashtext[237] = (char )'#';
#line 21
  splashtext[238] = (char )'#';
#line 21
  splashtext[239] = (char )' ';
#line 21
  splashtext[240] = (char )' ';
#line 21
  splashtext[241] = (char )' ';
#line 21
  splashtext[242] = (char )' ';
#line 21
  splashtext[243] = (char )' ';
#line 21
  splashtext[244] = (char )' ';
#line 21
  splashtext[245] = (char )'#';
#line 21
  splashtext[246] = (char )'#';
#line 21
  splashtext[247] = (char )' ';
#line 21
  splashtext[248] = (char )' ';
#line 21
  splashtext[249] = (char )' ';
#line 21
  splashtext[250] = (char )'#';
#line 21
  splashtext[251] = (char )'#';
#line 21
  splashtext[252] = (char )' ';
#line 21
  splashtext[253] = (char )' ';
#line 21
  splashtext[254] = (char )'#';
#line 21
  splashtext[255] = (char )'#';
#line 21
  splashtext[256] = (char )' ';
#line 21
  splashtext[257] = (char )' ';
#line 21
  splashtext[258] = (char )'#';
#line 21
  splashtext[259] = (char )'#';
#line 21
  splashtext[260] = (char )' ';
#line 21
  splashtext[261] = (char )' ';
#line 21
  splashtext[262] = (char )'#';
#line 21
  splashtext[263] = (char )'#';
#line 21
  splashtext[264] = (char )' ';
#line 21
  splashtext[265] = (char )' ';
#line 21
  splashtext[266] = (char )' ';
#line 21
  splashtext[267] = (char )'#';
#line 21
  splashtext[268] = (char )'#';
#line 21
  splashtext[269] = (char )' ';
#line 21
  splashtext[270] = (char )' ';
#line 21
  splashtext[271] = (char )' ';
#line 21
  splashtext[272] = (char )'#';
#line 21
  splashtext[273] = (char )'#';
#line 21
  splashtext[274] = (char )'#';
#line 21
  splashtext[275] = (char )'#';
#line 21
  splashtext[276] = (char )'#';
#line 21
  splashtext[277] = (char )' ';
#line 21
  splashtext[278] = (char )' ';
#line 21
  splashtext[279] = (char )' ';
#line 21
  splashtext[280] = (char )' ';
#line 21
  splashtext[281] = (char )'#';
#line 21
  splashtext[282] = (char )'#';
#line 21
  splashtext[283] = (char )' ';
#line 21
  splashtext[284] = (char )' ';
#line 21
  splashtext[285] = (char )' ';
#line 21
  splashtext[286] = (char )' ';
#line 21
  splashtext[287] = (char )'#';
#line 21
  splashtext[288] = (char )'#';
#line 21
  splashtext[289] = (char )' ';
#line 21
  splashtext[290] = (char )' ';
#line 21
  splashtext[291] = (char )' ';
#line 21
  splashtext[292] = (char )'#';
#line 21
  splashtext[293] = (char )'#';
#line 21
  splashtext[294] = (char )' ';
#line 21
  splashtext[295] = (char )' ';
#line 21
  splashtext[296] = (char )' ';
#line 21
  splashtext[297] = (char )'#';
#line 21
  splashtext[298] = (char )'#';
#line 21
  splashtext[299] = (char )'\n';
#line 21
  splashtext[300] = (char )' ';
#line 21
  splashtext[301] = (char )'#';
#line 21
  splashtext[302] = (char )'#';
#line 21
  splashtext[303] = (char )' ';
#line 21
  splashtext[304] = (char )' ';
#line 21
  splashtext[305] = (char )' ';
#line 21
  splashtext[306] = (char )' ';
#line 21
  splashtext[307] = (char )' ';
#line 21
  splashtext[308] = (char )'#';
#line 21
  splashtext[309] = (char )'#';
#line 21
  splashtext[310] = (char )' ';
#line 21
  splashtext[311] = (char )' ';
#line 21
  splashtext[312] = (char )'#';
#line 21
  splashtext[313] = (char )'#';
#line 21
  splashtext[314] = (char )' ';
#line 21
  splashtext[315] = (char )' ';
#line 21
  splashtext[316] = (char )' ';
#line 21
  splashtext[317] = (char )' ';
#line 21
  splashtext[318] = (char )' ';
#line 21
  splashtext[319] = (char )' ';
#line 21
  splashtext[320] = (char )' ';
#line 21
  splashtext[321] = (char )'#';
#line 21
  splashtext[322] = (char )'#';
#line 21
  splashtext[323] = (char )'#';
#line 21
  splashtext[324] = (char )'#';
#line 21
  splashtext[325] = (char )'#';
#line 21
  splashtext[326] = (char )'#';
#line 21
  splashtext[327] = (char )' ';
#line 21
  splashtext[328] = (char )' ';
#line 21
  splashtext[329] = (char )' ';
#line 21
  splashtext[330] = (char )'#';
#line 21
  splashtext[331] = (char )'#';
#line 21
  splashtext[332] = (char )' ';
#line 21
  splashtext[333] = (char )' ';
#line 21
  splashtext[334] = (char )'#';
#line 21
  splashtext[335] = (char )'#';
#line 21
  splashtext[336] = (char )' ';
#line 21
  splashtext[337] = (char )' ';
#line 21
  splashtext[338] = (char )'#';
#line 21
  splashtext[339] = (char )'#';
#line 21
  splashtext[340] = (char )' ';
#line 21
  splashtext[341] = (char )' ';
#line 21
  splashtext[342] = (char )'#';
#line 21
  splashtext[343] = (char )'#';
#line 21
  splashtext[344] = (char )' ';
#line 21
  splashtext[345] = (char )' ';
#line 21
  splashtext[346] = (char )' ';
#line 21
  splashtext[347] = (char )'#';
#line 21
  splashtext[348] = (char )'#';
#line 21
  splashtext[349] = (char )' ';
#line 21
  splashtext[350] = (char )' ';
#line 21
  splashtext[351] = (char )' ';
#line 21
  splashtext[352] = (char )'#';
#line 21
  splashtext[353] = (char )'#';
#line 21
  splashtext[354] = (char )' ';
#line 21
  splashtext[355] = (char )' ';
#line 21
  splashtext[356] = (char )' ';
#line 21
  splashtext[357] = (char )' ';
#line 21
  splashtext[358] = (char )' ';
#line 21
  splashtext[359] = (char )' ';
#line 21
  splashtext[360] = (char )' ';
#line 21
  splashtext[361] = (char )'#';
#line 21
  splashtext[362] = (char )'#';
#line 21
  splashtext[363] = (char )' ';
#line 21
  splashtext[364] = (char )' ';
#line 21
  splashtext[365] = (char )' ';
#line 21
  splashtext[366] = (char )' ';
#line 21
  splashtext[367] = (char )'#';
#line 21
  splashtext[368] = (char )'#';
#line 21
  splashtext[369] = (char )' ';
#line 21
  splashtext[370] = (char )' ';
#line 21
  splashtext[371] = (char )' ';
#line 21
  splashtext[372] = (char )'#';
#line 21
  splashtext[373] = (char )'#';
#line 21
  splashtext[374] = (char )'#';
#line 21
  splashtext[375] = (char )'#';
#line 21
  splashtext[376] = (char )'#';
#line 21
  splashtext[377] = (char )'#';
#line 21
  splashtext[378] = (char )'\n';
#line 21
  splashtext[379] = (char )' ';
#line 21
  splashtext[380] = (char )'#';
#line 21
  splashtext[381] = (char )'#';
#line 21
  splashtext[382] = (char )' ';
#line 21
  splashtext[383] = (char )' ';
#line 21
  splashtext[384] = (char )' ';
#line 21
  splashtext[385] = (char )' ';
#line 21
  splashtext[386] = (char )' ';
#line 21
  splashtext[387] = (char )'#';
#line 21
  splashtext[388] = (char )'#';
#line 21
  splashtext[389] = (char )' ';
#line 21
  splashtext[390] = (char )' ';
#line 21
  splashtext[391] = (char )'#';
#line 21
  splashtext[392] = (char )'#';
#line 21
  splashtext[393] = (char )' ';
#line 21
  splashtext[394] = (char )' ';
#line 21
  splashtext[395] = (char )' ';
#line 21
  splashtext[396] = (char )' ';
#line 21
  splashtext[397] = (char )' ';
#line 21
  splashtext[398] = (char )' ';
#line 21
  splashtext[399] = (char )'#';
#line 21
  splashtext[400] = (char )'#';
#line 21
  splashtext[401] = (char )' ';
#line 21
  splashtext[402] = (char )' ';
#line 21
  splashtext[403] = (char )' ';
#line 21
  splashtext[404] = (char )'#';
#line 21
  splashtext[405] = (char )'#';
#line 21
  splashtext[406] = (char )' ';
#line 21
  splashtext[407] = (char )' ';
#line 21
  splashtext[408] = (char )' ';
#line 21
  splashtext[409] = (char )'#';
#line 21
  splashtext[410] = (char )'#';
#line 21
  splashtext[411] = (char )' ';
#line 21
  splashtext[412] = (char )' ';
#line 21
  splashtext[413] = (char )'#';
#line 21
  splashtext[414] = (char )'#';
#line 21
  splashtext[415] = (char )' ';
#line 21
  splashtext[416] = (char )' ';
#line 21
  splashtext[417] = (char )'#';
#line 21
  splashtext[418] = (char )'#';
#line 21
  splashtext[419] = (char )' ';
#line 21
  splashtext[420] = (char )' ';
#line 21
  splashtext[421] = (char )'#';
#line 21
  splashtext[422] = (char )'#';
#line 21
  splashtext[423] = (char )' ';
#line 21
  splashtext[424] = (char )' ';
#line 21
  splashtext[425] = (char )' ';
#line 21
  splashtext[426] = (char )'#';
#line 21
  splashtext[427] = (char )'#';
#line 21
  splashtext[428] = (char )' ';
#line 21
  splashtext[429] = (char )' ';
#line 21
  splashtext[430] = (char )' ';
#line 21
  splashtext[431] = (char )'#';
#line 21
  splashtext[432] = (char )'#';
#line 21
  splashtext[433] = (char )' ';
#line 21
  splashtext[434] = (char )' ';
#line 21
  splashtext[435] = (char )' ';
#line 21
  splashtext[436] = (char )' ';
#line 21
  splashtext[437] = (char )' ';
#line 21
  splashtext[438] = (char )' ';
#line 21
  splashtext[439] = (char )' ';
#line 21
  splashtext[440] = (char )'#';
#line 21
  splashtext[441] = (char )'#';
#line 21
  splashtext[442] = (char )' ';
#line 21
  splashtext[443] = (char )' ';
#line 21
  splashtext[444] = (char )' ';
#line 21
  splashtext[445] = (char )' ';
#line 21
  splashtext[446] = (char )'#';
#line 21
  splashtext[447] = (char )'#';
#line 21
  splashtext[448] = (char )' ';
#line 21
  splashtext[449] = (char )' ';
#line 21
  splashtext[450] = (char )' ';
#line 21
  splashtext[451] = (char )'#';
#line 21
  splashtext[452] = (char )'#';
#line 21
  splashtext[453] = (char )'\n';
#line 21
  splashtext[454] = (char )' ';
#line 21
  splashtext[455] = (char )' ';
#line 21
  splashtext[456] = (char )'#';
#line 21
  splashtext[457] = (char )'#';
#line 21
  splashtext[458] = (char )'#';
#line 21
  splashtext[459] = (char )'#';
#line 21
  splashtext[460] = (char )'#';
#line 21
  splashtext[461] = (char )'#';
#line 21
  splashtext[462] = (char )'#';
#line 21
  splashtext[463] = (char )' ';
#line 21
  splashtext[464] = (char )' ';
#line 21
  splashtext[465] = (char )' ';
#line 21
  splashtext[466] = (char )'#';
#line 21
  splashtext[467] = (char )'#';
#line 21
  splashtext[468] = (char )' ';
#line 21
  splashtext[469] = (char )' ';
#line 21
  splashtext[470] = (char )' ';
#line 21
  splashtext[471] = (char )' ';
#line 21
  splashtext[472] = (char )' ';
#line 21
  splashtext[473] = (char )' ';
#line 21
  splashtext[474] = (char )' ';
#line 21
  splashtext[475] = (char )'#';
#line 21
  splashtext[476] = (char )'#';
#line 21
  splashtext[477] = (char )'#';
#line 21
  splashtext[478] = (char )'#';
#line 21
  splashtext[479] = (char )'#';
#line 21
  splashtext[480] = (char )'#';
#line 21
  splashtext[481] = (char )' ';
#line 21
  splashtext[482] = (char )' ';
#line 21
  splashtext[483] = (char )' ';
#line 21
  splashtext[484] = (char )'#';
#line 21
  splashtext[485] = (char )'#';
#line 21
  splashtext[486] = (char )' ';
#line 21
  splashtext[487] = (char )' ';
#line 21
  splashtext[488] = (char )'#';
#line 21
  splashtext[489] = (char )'#';
#line 21
  splashtext[490] = (char )' ';
#line 21
  splashtext[491] = (char )' ';
#line 21
  splashtext[492] = (char )'#';
#line 21
  splashtext[493] = (char )'#';
#line 21
  splashtext[494] = (char )' ';
#line 21
  splashtext[495] = (char )' ';
#line 21
  splashtext[496] = (char )' ';
#line 21
  splashtext[497] = (char )'#';
#line 21
  splashtext[498] = (char )'#';
#line 21
  splashtext[499] = (char )'#';
#line 21
  splashtext[500] = (char )'#';
#line 21
  splashtext[501] = (char )'#';
#line 21
  splashtext[502] = (char )' ';
#line 21
  splashtext[503] = (char )' ';
#line 21
  splashtext[504] = (char )' ';
#line 21
  splashtext[505] = (char )' ';
#line 21
  splashtext[506] = (char )'#';
#line 21
  splashtext[507] = (char )'#';
#line 21
  splashtext[508] = (char )' ';
#line 21
  splashtext[509] = (char )' ';
#line 21
  splashtext[510] = (char )' ';
#line 21
  splashtext[511] = (char )' ';
#line 21
  splashtext[512] = (char )' ';
#line 21
  splashtext[513] = (char )' ';
#line 21
  splashtext[514] = (char )'#';
#line 21
  splashtext[515] = (char )'#';
#line 21
  splashtext[516] = (char )'#';
#line 21
  splashtext[517] = (char )'#';
#line 21
  splashtext[518] = (char )' ';
#line 21
  splashtext[519] = (char )' ';
#line 21
  splashtext[520] = (char )'#';
#line 21
  splashtext[521] = (char )'#';
#line 21
  splashtext[522] = (char )'#';
#line 21
  splashtext[523] = (char )'#';
#line 21
  splashtext[524] = (char )' ';
#line 21
  splashtext[525] = (char )' ';
#line 21
  splashtext[526] = (char )' ';
#line 21
  splashtext[527] = (char )'#';
#line 21
  splashtext[528] = (char )'#';
#line 21
  splashtext[529] = (char )'#';
#line 21
  splashtext[530] = (char )'#';
#line 21
  splashtext[531] = (char )'#';
#line 21
  splashtext[532] = (char )'\n';
#line 21
  splashtext[533] = (char )'\n';
#line 21
  splashtext[534] = (char )' ';
#line 21
  splashtext[535] = (char )' ';
#line 21
  splashtext[536] = (char )' ';
#line 21
  splashtext[537] = (char )' ';
#line 21
  splashtext[538] = (char )' ';
#line 21
  splashtext[539] = (char )' ';
#line 21
  splashtext[540] = (char )' ';
#line 21
  splashtext[541] = (char )' ';
#line 21
  splashtext[542] = (char )' ';
#line 21
  splashtext[543] = (char )' ';
#line 21
  splashtext[544] = (char )' ';
#line 21
  splashtext[545] = (char )' ';
#line 21
  splashtext[546] = (char )' ';
#line 21
  splashtext[547] = (char )' ';
#line 21
  splashtext[548] = (char )' ';
#line 21
  splashtext[549] = (char )' ';
#line 21
  splashtext[550] = (char )' ';
#line 21
  splashtext[551] = (char )' ';
#line 21
  splashtext[552] = (char )' ';
#line 21
  splashtext[553] = (char )' ';
#line 21
  splashtext[554] = (char )' ';
#line 21
  splashtext[555] = (char )' ';
#line 21
  splashtext[556] = (char )' ';
#line 21
  splashtext[557] = (char )' ';
#line 21
  splashtext[558] = (char )' ';
#line 21
  splashtext[559] = (char )' ';
#line 21
  splashtext[560] = (char )' ';
#line 21
  splashtext[561] = (char )' ';
#line 21
  splashtext[562] = (char )' ';
#line 21
  splashtext[563] = (char )' ';
#line 21
  splashtext[564] = (char )' ';
#line 21
  splashtext[565] = (char )' ';
#line 21
  splashtext[566] = (char )' ';
#line 21
  splashtext[567] = (char )' ';
#line 21
  splashtext[568] = (char )' ';
#line 21
  splashtext[569] = (char )' ';
#line 21
  splashtext[570] = (char )' ';
#line 21
  splashtext[571] = (char )' ';
#line 21
  splashtext[572] = (char )' ';
#line 21
  splashtext[573] = (char )' ';
#line 21
  splashtext[574] = (char )' ';
#line 21
  splashtext[575] = (char )' ';
#line 21
  splashtext[576] = (char )' ';
#line 21
  splashtext[577] = (char )' ';
#line 21
  splashtext[578] = (char )' ';
#line 21
  splashtext[579] = (char )' ';
#line 21
  splashtext[580] = (char )' ';
#line 21
  splashtext[581] = (char )' ';
#line 21
  splashtext[582] = (char )' ';
#line 21
  splashtext[583] = (char )' ';
#line 21
  splashtext[584] = (char )' ';
#line 21
  splashtext[585] = (char )' ';
#line 21
  splashtext[586] = (char )' ';
#line 21
  splashtext[587] = (char )' ';
#line 21
  splashtext[588] = (char )' ';
#line 21
  splashtext[589] = (char )' ';
#line 21
  splashtext[590] = (char )' ';
#line 21
  splashtext[591] = (char )' ';
#line 21
  splashtext[592] = (char )' ';
#line 21
  splashtext[593] = (char )' ';
#line 21
  splashtext[594] = (char )' ';
#line 21
  splashtext[595] = (char )' ';
#line 21
  splashtext[596] = (char )' ';
#line 21
  splashtext[597] = (char )' ';
#line 21
  splashtext[598] = (char )' ';
#line 21
  splashtext[599] = (char )' ';
#line 21
  splashtext[600] = (char )' ';
#line 21
  splashtext[601] = (char )'V';
#line 21
  splashtext[602] = (char )'e';
#line 21
  splashtext[603] = (char )'r';
#line 21
  splashtext[604] = (char )'s';
#line 21
  splashtext[605] = (char )'i';
#line 21
  splashtext[606] = (char )'o';
#line 21
  splashtext[607] = (char )'n';
#line 21
  splashtext[608] = (char )' ';
#line 21
  splashtext[609] = (char )'1';
#line 21
  splashtext[610] = (char )'.';
#line 21
  splashtext[611] = (char )'6';
#line 21
  splashtext[612] = (char )'\n';
#line 21
  splashtext[613] = (char )'_';
#line 21
  splashtext[614] = (char )'_';
#line 21
  splashtext[615] = (char )'_';
#line 21
  splashtext[616] = (char )'_';
#line 21
  splashtext[617] = (char )'_';
#line 21
  splashtext[618] = (char )'_';
#line 21
  splashtext[619] = (char )'_';
#line 21
  splashtext[620] = (char )'_';
#line 21
  splashtext[621] = (char )'_';
#line 21
  splashtext[622] = (char )'_';
#line 21
  splashtext[623] = (char )'_';
#line 21
  splashtext[624] = (char )'_';
#line 21
  splashtext[625] = (char )'_';
#line 21
  splashtext[626] = (char )'_';
#line 21
  splashtext[627] = (char )'_';
#line 21
  splashtext[628] = (char )'_';
#line 21
  splashtext[629] = (char )'_';
#line 21
  splashtext[630] = (char )'_';
#line 21
  splashtext[631] = (char )'_';
#line 21
  splashtext[632] = (char )'_';
#line 21
  splashtext[633] = (char )'_';
#line 21
  splashtext[634] = (char )'_';
#line 21
  splashtext[635] = (char )'_';
#line 21
  splashtext[636] = (char )'_';
#line 21
  splashtext[637] = (char )'_';
#line 21
  splashtext[638] = (char )'_';
#line 21
  splashtext[639] = (char )'_';
#line 21
  splashtext[640] = (char )'_';
#line 21
  splashtext[641] = (char )'_';
#line 21
  splashtext[642] = (char )'_';
#line 21
  splashtext[643] = (char )'_';
#line 21
  splashtext[644] = (char )'_';
#line 21
  splashtext[645] = (char )'_';
#line 21
  splashtext[646] = (char )'_';
#line 21
  splashtext[647] = (char )'_';
#line 21
  splashtext[648] = (char )'_';
#line 21
  splashtext[649] = (char )'_';
#line 21
  splashtext[650] = (char )'_';
#line 21
  splashtext[651] = (char )'_';
#line 21
  splashtext[652] = (char )'_';
#line 21
  splashtext[653] = (char )'_';
#line 21
  splashtext[654] = (char )'_';
#line 21
  splashtext[655] = (char )'_';
#line 21
  splashtext[656] = (char )'_';
#line 21
  splashtext[657] = (char )'_';
#line 21
  splashtext[658] = (char )'_';
#line 21
  splashtext[659] = (char )'_';
#line 21
  splashtext[660] = (char )'_';
#line 21
  splashtext[661] = (char )'_';
#line 21
  splashtext[662] = (char )'_';
#line 21
  splashtext[663] = (char )'_';
#line 21
  splashtext[664] = (char )'_';
#line 21
  splashtext[665] = (char )'_';
#line 21
  splashtext[666] = (char )'_';
#line 21
  splashtext[667] = (char )'_';
#line 21
  splashtext[668] = (char )'_';
#line 21
  splashtext[669] = (char )'_';
#line 21
  splashtext[670] = (char )'_';
#line 21
  splashtext[671] = (char )'_';
#line 21
  splashtext[672] = (char )'_';
#line 21
  splashtext[673] = (char )'_';
#line 21
  splashtext[674] = (char )'_';
#line 21
  splashtext[675] = (char )'_';
#line 21
  splashtext[676] = (char )'_';
#line 21
  splashtext[677] = (char )'_';
#line 21
  splashtext[678] = (char )'_';
#line 21
  splashtext[679] = (char )'_';
#line 21
  splashtext[680] = (char )'_';
#line 21
  splashtext[681] = (char )'_';
#line 21
  splashtext[682] = (char )'_';
#line 21
  splashtext[683] = (char )'_';
#line 21
  splashtext[684] = (char )'_';
#line 21
  splashtext[685] = (char )'_';
#line 21
  splashtext[686] = (char )'_';
#line 21
  splashtext[687] = (char )'_';
#line 21
  splashtext[688] = (char )'_';
#line 21
  splashtext[689] = (char )'_';
#line 21
  splashtext[690] = (char )'_';
#line 21
  splashtext[691] = (char )'_';
#line 21
  splashtext[692] = (char )'_';
#line 21
  splashtext[693] = (char )' ';
#line 21
  splashtext[694] = (char )' ';
#line 21
  splashtext[695] = (char )' ';
#line 21
  splashtext[696] = (char )' ';
#line 21
  splashtext[697] = (char )' ';
#line 21
  splashtext[698] = (char )'\n';
#line 21
  splashtext[699] = (char )' ';
#line 21
  splashtext[700] = (char )' ';
#line 21
  splashtext[701] = (char )' ';
#line 21
  splashtext[702] = (char )' ';
#line 21
  splashtext[703] = (char )' ';
#line 21
  splashtext[704] = (char )' ';
#line 21
  splashtext[705] = (char )' ';
#line 21
  splashtext[706] = (char )' ';
#line 21
  splashtext[707] = (char )'R';
#line 21
  splashtext[708] = (char )'e';
#line 21
  splashtext[709] = (char )'c';
#line 21
  splashtext[710] = (char )'o';
#line 21
  splashtext[711] = (char )'r';
#line 21
  splashtext[712] = (char )'d';
#line 21
  splashtext[713] = (char )'i';
#line 21
  splashtext[714] = (char )'n';
#line 21
  splashtext[715] = (char )'g';
#line 21
  splashtext[716] = (char )' ';
#line 21
  splashtext[717] = (char )' ';
#line 21
  splashtext[718] = (char )'-';
#line 21
  splashtext[719] = (char )' ';
#line 21
  splashtext[720] = (char )' ';
#line 21
  splashtext[721] = (char )'P';
#line 21
  splashtext[722] = (char )'l';
#line 21
  splashtext[723] = (char )'a';
#line 21
  splashtext[724] = (char )'y';
#line 21
  splashtext[725] = (char )'b';
#line 21
  splashtext[726] = (char )'a';
#line 21
  splashtext[727] = (char )'c';
#line 21
  splashtext[728] = (char )'k';
#line 21
  splashtext[729] = (char )' ';
#line 21
  splashtext[730] = (char )' ';
#line 21
  splashtext[731] = (char )'-';
#line 21
  splashtext[732] = (char )' ';
#line 21
  splashtext[733] = (char )' ';
#line 21
  splashtext[734] = (char )'T';
#line 21
  splashtext[735] = (char )'r';
#line 21
  splashtext[736] = (char )'a';
#line 21
  splashtext[737] = (char )'c';
#line 21
  splashtext[738] = (char )'k';
#line 21
  splashtext[739] = (char )' ';
#line 21
  splashtext[740] = (char )'S';
#line 21
  splashtext[741] = (char )'p';
#line 21
  splashtext[742] = (char )'l';
#line 21
  splashtext[743] = (char )'i';
#line 21
  splashtext[744] = (char )'t';
#line 21
  splashtext[745] = (char )'t';
#line 21
  splashtext[746] = (char )'i';
#line 21
  splashtext[747] = (char )'n';
#line 21
  splashtext[748] = (char )'g';
#line 21
  splashtext[749] = (char )' ';
#line 21
  splashtext[750] = (char )' ';
#line 21
  splashtext[751] = (char )'-';
#line 21
  splashtext[752] = (char )' ';
#line 21
  splashtext[753] = (char )' ';
#line 21
  splashtext[754] = (char )'S';
#line 21
  splashtext[755] = (char )'i';
#line 21
  splashtext[756] = (char )'g';
#line 21
  splashtext[757] = (char )'n';
#line 21
  splashtext[758] = (char )'a';
#line 21
  splashtext[759] = (char )'l';
#line 21
  splashtext[760] = (char )' ';
#line 21
  splashtext[761] = (char )'P';
#line 21
  splashtext[762] = (char )'r';
#line 21
  splashtext[763] = (char )'o';
#line 21
  splashtext[764] = (char )'c';
#line 21
  splashtext[765] = (char )'e';
#line 21
  splashtext[766] = (char )'s';
#line 21
  splashtext[767] = (char )'s';
#line 21
  splashtext[768] = (char )'i';
#line 21
  splashtext[769] = (char )'n';
#line 21
  splashtext[770] = (char )'g';
#line 21
  splashtext[771] = (char )'\n';
#line 21
  splashtext[772] = (char )'\n';
#line 21
  splashtext[773] = (char )'\n';
#line 21
  splashtext[774] = (char )'\n';
#line 21
  splashtext[775] = (char )' ';
#line 21
  splashtext[776] = (char )' ';
#line 21
  splashtext[777] = (char )' ';
#line 21
  splashtext[778] = (char )'C';
#line 21
  splashtext[779] = (char )'o';
#line 21
  splashtext[780] = (char )'p';
#line 21
  splashtext[781] = (char )'y';
#line 21
  splashtext[782] = (char )'r';
#line 21
  splashtext[783] = (char )'i';
#line 21
  splashtext[784] = (char )'g';
#line 21
  splashtext[785] = (char )'h';
#line 21
  splashtext[786] = (char )'t';
#line 21
  splashtext[787] = (char )' ';
#line 21
  splashtext[788] = (char )'(';
#line 21
  splashtext[789] = (char )'C';
#line 21
  splashtext[790] = (char )')';
#line 21
  splashtext[791] = (char )' ';
#line 21
  splashtext[792] = (char )'1';
#line 21
  splashtext[793] = (char )'9';
#line 21
  splashtext[794] = (char )'9';
#line 21
  splashtext[795] = (char )'8';
#line 21
  splashtext[796] = (char )' ';
#line 21
  splashtext[797] = (char )'J';
#line 21
  splashtext[798] = (char )'.';
#line 21
  splashtext[799] = (char )'A';
#line 21
  splashtext[800] = (char )'.';
#line 21
  splashtext[801] = (char )' ';
#line 21
  splashtext[802] = (char )'B';
#line 21
  splashtext[803] = (char )'e';
#line 21
  splashtext[804] = (char )'z';
#line 21
  splashtext[805] = (char )'e';
#line 21
  splashtext[806] = (char )'m';
#line 21
  splashtext[807] = (char )'e';
#line 21
  splashtext[808] = (char )'r';
#line 21
  splashtext[809] = (char )'\n';
#line 21
  splashtext[810] = (char )'\n';
#line 21
  splashtext[811] = (char )' ';
#line 21
  splashtext[812] = (char )' ';
#line 21
  splashtext[813] = (char )' ';
#line 21
  splashtext[814] = (char )'T';
#line 21
  splashtext[815] = (char )'h';
#line 21
  splashtext[816] = (char )'i';
#line 21
  splashtext[817] = (char )'s';
#line 21
  splashtext[818] = (char )' ';
#line 21
  splashtext[819] = (char )'p';
#line 21
  splashtext[820] = (char )'r';
#line 21
  splashtext[821] = (char )'o';
#line 21
  splashtext[822] = (char )'g';
#line 21
  splashtext[823] = (char )'r';
#line 21
  splashtext[824] = (char )'a';
#line 21
  splashtext[825] = (char )'m';
#line 21
  splashtext[826] = (char )' ';
#line 21
  splashtext[827] = (char )'i';
#line 21
  splashtext[828] = (char )'s';
#line 21
  splashtext[829] = (char )' ';
#line 21
  splashtext[830] = (char )'f';
#line 21
  splashtext[831] = (char )'r';
#line 21
  splashtext[832] = (char )'e';
#line 21
  splashtext[833] = (char )'e';
#line 21
  splashtext[834] = (char )' ';
#line 21
  splashtext[835] = (char )'s';
#line 21
  splashtext[836] = (char )'o';
#line 21
  splashtext[837] = (char )'f';
#line 21
  splashtext[838] = (char )'t';
#line 21
  splashtext[839] = (char )'w';
#line 21
  splashtext[840] = (char )'a';
#line 21
  splashtext[841] = (char )'r';
#line 21
  splashtext[842] = (char )'e';
#line 21
  splashtext[843] = (char )';';
#line 21
  splashtext[844] = (char )' ';
#line 21
  splashtext[845] = (char )'y';
#line 21
  splashtext[846] = (char )'o';
#line 21
  splashtext[847] = (char )'u';
#line 21
  splashtext[848] = (char )' ';
#line 21
  splashtext[849] = (char )'a';
#line 21
  splashtext[850] = (char )'r';
#line 21
  splashtext[851] = (char )'e';
#line 21
  splashtext[852] = (char )' ';
#line 21
  splashtext[853] = (char )'e';
#line 21
  splashtext[854] = (char )'n';
#line 21
  splashtext[855] = (char )'c';
#line 21
  splashtext[856] = (char )'o';
#line 21
  splashtext[857] = (char )'u';
#line 21
  splashtext[858] = (char )'r';
#line 21
  splashtext[859] = (char )'a';
#line 21
  splashtext[860] = (char )'g';
#line 21
  splashtext[861] = (char )'e';
#line 21
  splashtext[862] = (char )'d';
#line 21
  splashtext[863] = (char )' ';
#line 21
  splashtext[864] = (char )'t';
#line 21
  splashtext[865] = (char )'o';
#line 21
  splashtext[866] = (char )' ';
#line 21
  splashtext[867] = (char )'r';
#line 21
  splashtext[868] = (char )'e';
#line 21
  splashtext[869] = (char )'d';
#line 21
  splashtext[870] = (char )'i';
#line 21
  splashtext[871] = (char )'s';
#line 21
  splashtext[872] = (char )'t';
#line 21
  splashtext[873] = (char )'r';
#line 21
  splashtext[874] = (char )'i';
#line 21
  splashtext[875] = (char )'b';
#line 21
  splashtext[876] = (char )'u';
#line 21
  splashtext[877] = (char )'t';
#line 21
  splashtext[878] = (char )'e';
#line 21
  splashtext[879] = (char )' ';
#line 21
  splashtext[880] = (char )'i';
#line 21
  splashtext[881] = (char )'t';
#line 21
  splashtext[882] = (char )' ';
#line 21
  splashtext[883] = (char )'u';
#line 21
  splashtext[884] = (char )'n';
#line 21
  splashtext[885] = (char )'d';
#line 21
  splashtext[886] = (char )'e';
#line 21
  splashtext[887] = (char )'r';
#line 21
  splashtext[888] = (char )'\n';
#line 21
  splashtext[889] = (char )' ';
#line 21
  splashtext[890] = (char )' ';
#line 21
  splashtext[891] = (char )' ';
#line 21
  splashtext[892] = (char )'t';
#line 21
  splashtext[893] = (char )'h';
#line 21
  splashtext[894] = (char )'e';
#line 21
  splashtext[895] = (char )' ';
#line 21
  splashtext[896] = (char )'t';
#line 21
  splashtext[897] = (char )'e';
#line 21
  splashtext[898] = (char )'r';
#line 21
  splashtext[899] = (char )'m';
#line 21
  splashtext[900] = (char )'s';
#line 21
  splashtext[901] = (char )' ';
#line 21
  splashtext[902] = (char )'o';
#line 21
  splashtext[903] = (char )'f';
#line 21
  splashtext[904] = (char )' ';
#line 21
  splashtext[905] = (char )'t';
#line 21
  splashtext[906] = (char )'h';
#line 21
  splashtext[907] = (char )'e';
#line 21
  splashtext[908] = (char )' ';
#line 21
  splashtext[909] = (char )'G';
#line 21
  splashtext[910] = (char )'N';
#line 21
  splashtext[911] = (char )'U';
#line 21
  splashtext[912] = (char )' ';
#line 21
  splashtext[913] = (char )'G';
#line 21
  splashtext[914] = (char )'e';
#line 21
  splashtext[915] = (char )'n';
#line 21
  splashtext[916] = (char )'e';
#line 21
  splashtext[917] = (char )'r';
#line 21
  splashtext[918] = (char )'a';
#line 21
  splashtext[919] = (char )'l';
#line 21
  splashtext[920] = (char )' ';
#line 21
  splashtext[921] = (char )'P';
#line 21
  splashtext[922] = (char )'u';
#line 21
  splashtext[923] = (char )'b';
#line 21
  splashtext[924] = (char )'l';
#line 21
  splashtext[925] = (char )'i';
#line 21
  splashtext[926] = (char )'c';
#line 21
  splashtext[927] = (char )' ';
#line 21
  splashtext[928] = (char )'L';
#line 21
  splashtext[929] = (char )'i';
#line 21
  splashtext[930] = (char )'c';
#line 21
  splashtext[931] = (char )'e';
#line 21
  splashtext[932] = (char )'n';
#line 21
  splashtext[933] = (char )'s';
#line 21
  splashtext[934] = (char )'e';
#line 21
  splashtext[935] = (char )'.';
#line 21
  splashtext[936] = (char )'\n';
#line 21
  splashtext[937] = (char )'\n';
#line 21
  splashtext[938] = (char )' ';
#line 21
  splashtext[939] = (char )' ';
#line 21
  splashtext[940] = (char )' ';
#line 21
  splashtext[941] = (char )'T';
#line 21
  splashtext[942] = (char )'h';
#line 21
  splashtext[943] = (char )'i';
#line 21
  splashtext[944] = (char )'s';
#line 21
  splashtext[945] = (char )' ';
#line 21
  splashtext[946] = (char )'p';
#line 21
  splashtext[947] = (char )'r';
#line 21
  splashtext[948] = (char )'o';
#line 21
  splashtext[949] = (char )'g';
#line 21
  splashtext[950] = (char )'r';
#line 21
  splashtext[951] = (char )'a';
#line 21
  splashtext[952] = (char )'m';
#line 21
  splashtext[953] = (char )' ';
#line 21
  splashtext[954] = (char )'c';
#line 21
  splashtext[955] = (char )'o';
#line 21
  splashtext[956] = (char )'m';
#line 21
  splashtext[957] = (char )'e';
#line 21
  splashtext[958] = (char )'s';
#line 21
  splashtext[959] = (char )' ';
#line 21
  splashtext[960] = (char )'w';
#line 21
  splashtext[961] = (char )'i';
#line 21
  splashtext[962] = (char )'t';
#line 21
  splashtext[963] = (char )'h';
#line 21
  splashtext[964] = (char )' ';
#line 21
  splashtext[965] = (char )'A';
#line 21
  splashtext[966] = (char )'B';
#line 21
  splashtext[967] = (char )'S';
#line 21
  splashtext[968] = (char )'O';
#line 21
  splashtext[969] = (char )'L';
#line 21
  splashtext[970] = (char )'U';
#line 21
  splashtext[971] = (char )'T';
#line 21
  splashtext[972] = (char )'E';
#line 21
  splashtext[973] = (char )'L';
#line 21
  splashtext[974] = (char )'Y';
#line 21
  splashtext[975] = (char )' ';
#line 21
  splashtext[976] = (char )'N';
#line 21
  splashtext[977] = (char )'O';
#line 21
  splashtext[978] = (char )' ';
#line 21
  splashtext[979] = (char )'W';
#line 21
  splashtext[980] = (char )'A';
#line 21
  splashtext[981] = (char )'R';
#line 21
  splashtext[982] = (char )'R';
#line 21
  splashtext[983] = (char )'A';
#line 21
  splashtext[984] = (char )'N';
#line 21
  splashtext[985] = (char )'T';
#line 21
  splashtext[986] = (char )'Y';
#line 21
  splashtext[987] = (char )'.';
#line 21
  splashtext[988] = (char )' ';
#line 21
  splashtext[989] = (char )'S';
#line 21
  splashtext[990] = (char )'e';
#line 21
  splashtext[991] = (char )'e';
#line 21
  splashtext[992] = (char )' ';
#line 21
  splashtext[993] = (char )'t';
#line 21
  splashtext[994] = (char )'h';
#line 21
  splashtext[995] = (char )'e';
#line 21
  splashtext[996] = (char )' ';
#line 21
  splashtext[997] = (char )'G';
#line 21
  splashtext[998] = (char )'N';
#line 21
  splashtext[999] = (char )'U';
#line 21
  splashtext[1000] = (char )' ';
#line 21
  splashtext[1001] = (char )'G';
#line 21
  splashtext[1002] = (char )'e';
#line 21
  splashtext[1003] = (char )'n';
#line 21
  splashtext[1004] = (char )'e';
#line 21
  splashtext[1005] = (char )'r';
#line 21
  splashtext[1006] = (char )'a';
#line 21
  splashtext[1007] = (char )'l';
#line 21
  splashtext[1008] = (char )' ';
#line 21
  splashtext[1009] = (char )'P';
#line 21
  splashtext[1010] = (char )'u';
#line 21
  splashtext[1011] = (char )'b';
#line 21
  splashtext[1012] = (char )'l';
#line 21
  splashtext[1013] = (char )'i';
#line 21
  splashtext[1014] = (char )'c';
#line 21
  splashtext[1015] = (char )'\n';
#line 21
  splashtext[1016] = (char )' ';
#line 21
  splashtext[1017] = (char )' ';
#line 21
  splashtext[1018] = (char )' ';
#line 21
  splashtext[1019] = (char )'L';
#line 21
  splashtext[1020] = (char )'i';
#line 21
  splashtext[1021] = (char )'c';
#line 21
  splashtext[1022] = (char )'e';
#line 21
  splashtext[1023] = (char )'n';
#line 21
  splashtext[1024] = (char )'s';
#line 21
  splashtext[1025] = (char )'e';
#line 21
  splashtext[1026] = (char )' ';
#line 21
  splashtext[1027] = (char )'(';
#line 21
  splashtext[1028] = (char )'e';
#line 21
  splashtext[1029] = (char )'.';
#line 21
  splashtext[1030] = (char )'g';
#line 21
  splashtext[1031] = (char )'.';
#line 21
  splashtext[1032] = (char )' ';
#line 21
  splashtext[1033] = (char )'i';
#line 21
  splashtext[1034] = (char )'n';
#line 21
  splashtext[1035] = (char )' ';
#line 21
  splashtext[1036] = (char )'t';
#line 21
  splashtext[1037] = (char )'h';
#line 21
  splashtext[1038] = (char )'e';
#line 21
  splashtext[1039] = (char )' ';
#line 21
  splashtext[1040] = (char )'f';
#line 21
  splashtext[1041] = (char )'i';
#line 21
  splashtext[1042] = (char )'l';
#line 21
  splashtext[1043] = (char )'e';
#line 21
  splashtext[1044] = (char )' ';
#line 21
  splashtext[1045] = (char )'n';
#line 21
  splashtext[1046] = (char )'a';
#line 21
  splashtext[1047] = (char )'m';
#line 21
  splashtext[1048] = (char )'e';
#line 21
  splashtext[1049] = (char )'d';
#line 21
  splashtext[1050] = (char )' ';
#line 21
  splashtext[1051] = (char )'`';
#line 21
  splashtext[1052] = (char )'C';
#line 21
  splashtext[1053] = (char )'O';
#line 21
  splashtext[1054] = (char )'P';
#line 21
  splashtext[1055] = (char )'Y';
#line 21
  splashtext[1056] = (char )'I';
#line 21
  splashtext[1057] = (char )'N';
#line 21
  splashtext[1058] = (char )'G';
#line 21
  splashtext[1059] = (char )'\'';
#line 21
  splashtext[1060] = (char )')';
#line 21
  splashtext[1061] = (char )' ';
#line 21
  splashtext[1062] = (char )'f';
#line 21
  splashtext[1063] = (char )'o';
#line 21
  splashtext[1064] = (char )'r';
#line 21
  splashtext[1065] = (char )' ';
#line 21
  splashtext[1066] = (char )'m';
#line 21
  splashtext[1067] = (char )'o';
#line 21
  splashtext[1068] = (char )'r';
#line 21
  splashtext[1069] = (char )'e';
#line 21
  splashtext[1070] = (char )' ';
#line 21
  splashtext[1071] = (char )'d';
#line 21
  splashtext[1072] = (char )'e';
#line 21
  splashtext[1073] = (char )'t';
#line 21
  splashtext[1074] = (char )'a';
#line 21
  splashtext[1075] = (char )'i';
#line 21
  splashtext[1076] = (char )'l';
#line 21
  splashtext[1077] = (char )'s';
#line 21
  splashtext[1078] = (char )'.';
#line 21
  splashtext[1079] = (char )'\000';
#line 51
  wclear(stdscr);
#line 52
  wrefresh(stdscr);
#line 54
  usleep((__useconds_t )500000);
#line 56
  waddnstr(stdscr, (char const   *)(splashtext), -1);
#line 57
  wmove(stdscr, 0, 79);
#line 58
  wrefresh(stdscr);
#line 60
  sleep(3U);
  }
#line 61
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_outfilenm.c"
int signproc_select_outfile(char *startdir , char *selectedfile ) 
{ 
  scrollmenu_t dirfilelist ;
  stringinput_t string ;
  button_t next_button ;
  button_t cancel_button ;
  button_t prev_button ;
  int dont_stop ;
  int returnval ;
  int focus ;
  int in_ch ;
  int i ;
  char helpstring[500] ;
  char *charpointer ;
  struct stat filestats ;
  int oldselected ;
  char *helplines[5] ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;

  {
  {
#line 40
  dont_stop = 1;
#line 41
  returnval = 0;
#line 42
  focus = 1;
#line 50
  helplines[0] = (char *)" Browse files and directories.                                  TAB: Next field";
#line 50
  helplines[1] = (char *)" Enter name of destination sound file.                          TAB: Next field";
#line 50
  helplines[2] = (char *)" To Signal Processing - Filter Selection.                       TAB: Next field";
#line 50
  helplines[3] = (char *)" Back to main menu.                                             TAB: Next field";
#line 50
  helplines[4] = (char *)" Start processing the signal.                                   TAB: Next field";
#line 58
  dirfilelist.y = 3;
#line 59
  dirfilelist.x = 5;
#line 60
  dirfilelist.h = 12;
#line 61
  dirfilelist.w = 32;
#line 62
  dirfilelist.firstonscreen = 0;
#line 63
  dirfilemenu(startdir, & dirfilelist);
#line 64
  dirfilelist.selected = dirfilelist.last_of_1st_part + 1;
#line 66
  string.maxlen = 500;
#line 67
  tmp = malloc((unsigned long )string.maxlen * sizeof(char ));
#line 67
  string.string = (char *)tmp;
  }
#line 68
  if ((int )*(selectedfile + 0) == 0) {
    {
#line 70
    strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)startdir);
#line 71
    strcat((char */* __restrict  */)string.string, (char const   */* __restrict  */)"processed.wav");
    }
  } else {
    {
#line 74
    strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)selectedfile);
    }
  }
  {
#line 75
  string.y = 17;
#line 76
  string.x = 5;
#line 77
  string.w = 70;
#line 78
  tmp___0 = strlen((char const   *)string.string);
#line 78
  string.cursorpos = (int )tmp___0;
#line 79
  tmp___1 = strlen((char const   *)string.string);
#line 79
  string.firstcharonscreen = (int )((tmp___1 - (size_t )string.w) + 2UL);
  }
#line 80
  if (string.firstcharonscreen < 0) {
#line 81
    string.firstcharonscreen = 0;
  }
  {
#line 83
  prev_button.text = (char *)" < Previous screen ";
#line 84
  prev_button.y = 20;
#line 85
  prev_button.x = 5;
#line 86
  prev_button.selected = 0;
#line 88
  next_button.text = (char *)" Start ";
#line 89
  next_button.y = 20;
#line 90
  next_button.x = 68;
#line 91
  next_button.selected = 0;
#line 93
  cancel_button.text = (char *)" Cancel ";
#line 94
  cancel_button.y = 20;
#line 95
  cancel_button.x = 36;
#line 96
  cancel_button.selected = 0;
#line 98
  clearscreen((char *)"Signal Processing - Destination File");
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (focus == 2) {
#line 103
      prev_button.selected = 1;
    } else {
#line 105
      prev_button.selected = 0;
    }
#line 107
    if (focus == 3) {
#line 108
      cancel_button.selected = 1;
    } else {
#line 110
      cancel_button.selected = 0;
    }
#line 112
    if (focus == 4) {
#line 113
      next_button.selected = 1;
    } else {
#line 115
      next_button.selected = 0;
    }
    {
#line 117
    dirfilelist.hasfocus = focus == 0;
#line 119
    scrollmenu_display(& dirfilelist);
#line 120
    mybox(dirfilelist.y - 1, dirfilelist.x - 1, dirfilelist.h + 2, dirfilelist.w + 2);
#line 122
    mvprintw(dirfilelist.y - 1, dirfilelist.x + 1, "Files and directories:");
#line 125
    stringinput_display(& string);
#line 126
    mybox(string.y - 1, string.x - 1, 3, string.w + 2);
#line 127
    mvprintw(string.y - 1, string.x + 1, "Destination File Name:");
#line 129
    button_display(& prev_button);
#line 130
    tmp___2 = strlen((char const   *)prev_button.text);
#line 130
    mybox(prev_button.y - 1, prev_button.x - 1, 3, (int )(tmp___2 + 2UL));
#line 132
    button_display(& cancel_button);
#line 133
    tmp___3 = strlen((char const   *)cancel_button.text);
#line 133
    mybox(cancel_button.y - 1, cancel_button.x - 1, 3, (int )(tmp___3 + 2UL));
#line 135
    button_display(& next_button);
#line 136
    tmp___4 = strlen((char const   *)next_button.text);
#line 136
    mybox(next_button.y - 1, next_button.x - 1, 3, (int )(tmp___4 + 2UL));
#line 139
    helpline(helplines[focus]);
    }
#line 141
    if (focus == 1) {
      {
#line 142
      stringinput_display(& string);
      }
    } else {
      {
#line 144
      wmove(stdscr, 0, 79);
      }
    }
    {
#line 146
    wrefresh(stdscr);
#line 148
    in_ch = wgetch(stdscr);
    }
    {
#line 152
    if (focus == 0) {
#line 152
      goto case_0;
    }
#line 205
    if (focus == 1) {
#line 205
      goto case_1;
    }
#line 246
    if (focus == 2) {
#line 246
      goto case_2;
    }
#line 267
    if (focus == 3) {
#line 267
      goto case_3;
    }
#line 287
    if (focus == 4) {
#line 287
      goto case_4;
    }
#line 150
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 153
    tmp___6 = scrollmenu_stdkeys(in_ch, & dirfilelist);
    }
#line 153
    if (tmp___6 >= 0) {
      {
#line 155
      oldselected = dirfilelist.selected;
#line 156
      i = dirfilemenu_process_select(& dirfilelist, helpstring);
      }
#line 158
      if (i == 0) {
        {
#line 160
        strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)(helpstring));
#line 161
        focus = 1;
#line 162
        tmp___5 = strlen((char const   *)string.string);
#line 162
        string.cursorpos = (int )tmp___5;
#line 163
        string.firstcharonscreen = 0;
        }
      } else {
        {
#line 168
        scrollmenu_delete_menu(& dirfilelist);
#line 169
        dirfilemenu(helpstring, & dirfilelist);
        }
#line 170
        if (dirfilelist.number == 0) {
          {
#line 172
          error_window((char *)"No permission to read this directory.");
#line 174
          header((char *)"Signal Processing - Destination File");
#line 175
          scrollmenu_delete_menu(& dirfilelist);
#line 176
          dirfilemenu(startdir, & dirfilelist);
#line 177
          dirfilelist.selected = oldselected;
          }
        } else {
          {
#line 181
          strcpy((char */* __restrict  */)startdir, (char const   */* __restrict  */)(helpstring));
#line 182
          dirfilelist.firstonscreen = 0;
#line 184
          charpointer = strrchr((char const   *)string.string, '/');
          }
#line 185
          if ((unsigned long )charpointer != (unsigned long )((void *)0)) {
            {
#line 186
            strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)(charpointer + 1));
            }
          } else {
            {
#line 188
            strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)string.string);
            }
          }
          {
#line 189
          strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)(helpstring));
          }
        }
      }
    } else {
      {
#line 196
      if (in_ch == 260) {
#line 196
        goto case_260;
      }
#line 199
      if (in_ch == 261) {
#line 199
        goto case_261;
      }
#line 194
      goto switch_break___0;
      case_260: /* CIL Label */ 
#line 197
      focus --;
#line 198
      goto switch_break___0;
      case_261: /* CIL Label */ 
#line 200
      focus ++;
#line 201
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 203
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 206
    stringinput_stdkeys(in_ch, & string);
    }
#line 207
    if (in_ch == 343) {
#line 207
      goto _L;
    } else
#line 207
    if (in_ch == 13) {
      _L: /* CIL Label */ 
      {
#line 209
      strcpy((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)string.string);
      }
      {
#line 212
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 212
        tmp___8 = strlen((char const   *)(helpstring));
        }
#line 212
        if (tmp___8 > 0UL) {
          {
#line 212
          tmp___9 = strlen((char const   *)(helpstring));
          }
#line 212
          if (! ((int )helpstring[tmp___9 - 1UL] == 47)) {
#line 212
            goto while_break___0;
          }
        } else {
#line 212
          goto while_break___0;
        }
        {
#line 214
        tmp___7 = strlen((char const   *)(helpstring));
#line 214
        helpstring[tmp___7 - 1UL] = (char )'\000';
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 216
      strcat((char */* __restrict  */)(helpstring), (char const   */* __restrict  */)"/");
#line 218
      tmp___11 = stat((char const   */* __restrict  */)(helpstring), (struct stat */* __restrict  */)(& filestats));
      }
#line 218
      if (tmp___11) {
#line 232
        focus = 4;
      } else
#line 218
      if ((filestats.st_mode & 61440U) == 16384U) {
        {
#line 221
        strcpy((char */* __restrict  */)startdir, (char const   */* __restrict  */)(helpstring));
#line 222
        scrollmenu_delete_menu(& dirfilelist);
#line 223
        dirfilemenu(startdir, & dirfilelist);
#line 224
        dirfilelist.firstonscreen = 0;
#line 225
        dirfilelist.selected = dirfilelist.last_of_1st_part + 1;
#line 227
        strcpy((char */* __restrict  */)string.string, (char const   */* __restrict  */)startdir);
#line 228
        tmp___10 = strlen((char const   *)string.string);
#line 228
        string.cursorpos = (int )tmp___10;
#line 229
        focus = 0;
        }
      } else {
#line 232
        focus = 4;
      }
    } else {
      {
#line 237
      if (in_ch == 259) {
#line 237
        goto case_259;
      }
#line 240
      if (in_ch == 258) {
#line 240
        goto case_258;
      }
#line 235
      goto switch_break___1;
      case_259: /* CIL Label */ 
#line 238
      focus --;
#line 239
      goto switch_break___1;
      case_258: /* CIL Label */ 
#line 241
      focus ++;
#line 242
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
#line 244
    goto switch_break;
    case_2: /* CIL Label */ 
#line 247
    if (in_ch == 343) {
      {
#line 249
      strcpy((char */* __restrict  */)selectedfile, (char const   */* __restrict  */)string.string);
#line 250
      returnval = 1;
#line 251
      dont_stop = 0;
      }
    } else
#line 247
    if (in_ch == 13) {
      {
#line 249
      strcpy((char */* __restrict  */)selectedfile, (char const   */* __restrict  */)string.string);
#line 250
      returnval = 1;
#line 251
      dont_stop = 0;
      }
    } else {
      {
#line 257
      if (in_ch == 259) {
#line 257
        goto case_259___0;
      }
#line 257
      if (in_ch == 260) {
#line 257
        goto case_259___0;
      }
#line 261
      if (in_ch == 258) {
#line 261
        goto case_258___0;
      }
#line 261
      if (in_ch == 261) {
#line 261
        goto case_258___0;
      }
#line 254
      goto switch_break___2;
      case_259___0: /* CIL Label */ 
      case_260___0: /* CIL Label */ 
#line 258
      focus --;
#line 259
      goto switch_break___2;
      case_258___0: /* CIL Label */ 
      case_261___0: /* CIL Label */ 
#line 262
      focus ++;
#line 263
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    }
#line 265
    goto switch_break;
    case_3: /* CIL Label */ 
#line 268
    if (in_ch == 343) {
#line 270
      returnval = 0;
#line 271
      dont_stop = 0;
    } else
#line 268
    if (in_ch == 13) {
#line 270
      returnval = 0;
#line 271
      dont_stop = 0;
    } else {
      {
#line 277
      if (in_ch == 259) {
#line 277
        goto case_259___1;
      }
#line 277
      if (in_ch == 260) {
#line 277
        goto case_259___1;
      }
#line 281
      if (in_ch == 258) {
#line 281
        goto case_258___1;
      }
#line 281
      if (in_ch == 261) {
#line 281
        goto case_258___1;
      }
#line 274
      goto switch_break___3;
      case_259___1: /* CIL Label */ 
      case_260___1: /* CIL Label */ 
#line 278
      focus --;
#line 279
      goto switch_break___3;
      case_258___1: /* CIL Label */ 
      case_261___1: /* CIL Label */ 
#line 282
      focus ++;
#line 283
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
    }
#line 285
    goto switch_break;
    case_4: /* CIL Label */ 
#line 288
    if (in_ch == 343) {
#line 288
      goto _L___0;
    } else
#line 288
    if (in_ch == 13) {
      _L___0: /* CIL Label */ 
      {
#line 289
      tmp___12 = checkfile(string.string);
      }
      {
#line 291
      if (tmp___12 == 1) {
#line 291
        goto case_1___0;
      }
#line 307
      if (tmp___12 == 2) {
#line 307
        goto case_2___0;
      }
#line 315
      if (tmp___12 == 3) {
#line 315
        goto case_3___0;
      }
#line 321
      if (tmp___12 == 4) {
#line 321
        goto case_4___0;
      }
#line 339
      goto switch_default;
      case_1___0: /* CIL Label */ 
      {
#line 292
      tmp___14 = yesno_window((char *)"The specified file already exists. Overwrite it?",
                              (char *)" Yes ", (char *)" No ", 0);
      }
#line 292
      if (tmp___14) {
        {
#line 295
        strcpy((char */* __restrict  */)selectedfile, (char const   */* __restrict  */)string.string);
#line 296
        returnval = 2;
#line 297
        dont_stop = 0;
        }
      } else {
        {
#line 301
        tmp___13 = strlen((char const   *)string.string);
#line 301
        string.cursorpos = (int )tmp___13;
#line 302
        focus = 1;
#line 303
        header((char *)"Signal Processing - Destination File");
        }
      }
#line 305
      goto switch_break___4;
      case_2___0: /* CIL Label */ 
      {
#line 308
      error_window((char *)"The specified name is of a directory. A file name must be specified.");
#line 310
      header((char *)"Signal Processing - Destination File");
#line 311
      tmp___15 = strlen((char const   *)string.string);
#line 311
      string.cursorpos = (int )tmp___15;
#line 312
      focus = 1;
      }
#line 313
      goto switch_break___4;
      case_3___0: /* CIL Label */ 
      {
#line 316
      strcpy((char */* __restrict  */)selectedfile, (char const   */* __restrict  */)string.string);
#line 317
      returnval = 2;
#line 318
      dont_stop = 0;
      }
#line 319
      goto switch_break___4;
      case_4___0: /* CIL Label */ 
#line 322
      if ((int )*(string.string) == 124) {
        {
#line 325
        strcpy((char */* __restrict  */)selectedfile, (char const   */* __restrict  */)string.string);
#line 326
        returnval = 2;
#line 327
        dont_stop = 0;
        }
      } else {
        {
#line 331
        error_window((char *)"The directory of the specified file does not exist.");
#line 333
        header((char *)"Signal Processing - Destination File");
#line 334
        tmp___16 = strlen((char const   *)string.string);
#line 334
        string.cursorpos = (int )tmp___16;
#line 335
        focus = 1;
        }
      }
#line 337
      goto switch_break___4;
      switch_default: /* CIL Label */ 
      {
#line 340
      error_window((char *)"Fell out of switch, signpr_outfilenm #1");
#line 341
      header((char *)"Signal Processing - Destination File");
      }
#line 342
      goto switch_break___4;
      switch_break___4: /* CIL Label */ ;
      }
    } else {
      {
#line 348
      if (in_ch == 259) {
#line 348
        goto case_259___2;
      }
#line 348
      if (in_ch == 260) {
#line 348
        goto case_259___2;
      }
#line 352
      if (in_ch == 258) {
#line 352
        goto case_258___2;
      }
#line 352
      if (in_ch == 261) {
#line 352
        goto case_258___2;
      }
#line 345
      goto switch_break___5;
      case_259___2: /* CIL Label */ 
      case_260___2: /* CIL Label */ 
#line 349
      focus --;
#line 350
      goto switch_break___5;
      case_258___2: /* CIL Label */ 
      case_261___2: /* CIL Label */ 
#line 353
      focus ++;
#line 354
      goto switch_break___5;
      switch_break___5: /* CIL Label */ ;
      }
    }
#line 356
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 359
    if (in_ch == 9) {
#line 360
      focus ++;
    }
#line 362
    if (in_ch == 27) {
#line 363
      dont_stop = 0;
    }
#line 365
    if (focus > 4) {
#line 366
      focus = 0;
    }
#line 367
    if (focus < 0) {
#line 368
      focus = 4;
    }
#line 100
    if (! dont_stop) {
#line 100
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 372
  scrollmenu_delete_menu(& dirfilelist);
#line 373
  free((void *)string.string);
  }
#line 375
  return (returnval);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 858 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_wav.c"
FILE *sourcefile  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_wav.c"
int openwavsource(char *filename ) 
{ 
  int count ;
  char hd_buf[20] ;
  wavhead wavhd ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 36
  sourcefile = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
  }
#line 36
  if ((unsigned long )sourcefile == (unsigned long )((void *)0)) {
    {
#line 38
    error_window((char *)"The source file could not be opened.");
    }
#line 39
    return (0);
  }
  {
#line 42
  tmp = fread((void */* __restrict  */)(hd_buf), (size_t )1, (size_t )20, (FILE */* __restrict  */)sourcefile);
#line 42
  count = (int )tmp;
  }
#line 43
  if (count < 20) {
    {
#line 45
    fclose(sourcefile);
#line 46
    error_window((char *)"The source file could not be read, or is too short.");
    }
#line 47
    return (0);
  }
  {
#line 50
  tmp___0 = strstr((char const   *)(hd_buf), "RIFF");
  }
#line 50
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 52
    fclose(sourcefile);
#line 53
    error_window((char *)"The source file is not a .wav file, and can not be processed.");
    }
#line 55
    return (0);
  }
  {
#line 58
  memcpy((void */* __restrict  */)((void *)(& wavhd)), (void const   */* __restrict  */)((void *)(hd_buf)),
         (size_t )20);
#line 59
  tmp___1 = fread((void */* __restrict  */)((char *)(& wavhd) + 20), (size_t )1, sizeof(wavhd) - 20UL,
                  (FILE */* __restrict  */)sourcefile);
#line 59
  count = (int )tmp___1;
  }
#line 61
  if ((unsigned long )count < sizeof(wavhd) - 20UL) {
    {
#line 63
    fclose(sourcefile);
#line 64
    error_window((char *)"The source file is too short. Probably it is not a .wav sound file.");
    }
#line 66
    return (0);
  }
#line 76
  if ((int )wavhd.format != 1) {
    {
#line 78
    fclose(sourcefile);
#line 79
    error_window((char *)"The source file is a .wav file with unknown format, and can not be processed.");
    }
#line 81
    return (0);
  }
#line 84
  if (wavhd.sample_fq != 44100UL) {
    {
#line 86
    fclose(sourcefile);
#line 87
    error_window((char *)"The source file is not sampled at 44100 Hz, and can not be processed.");
    }
#line 89
    return (0);
  }
#line 92
  if ((int )wavhd.bit_p_spl != 16) {
    {
#line 94
    fclose(sourcefile);
#line 95
    error_window((char *)"The source file does not have 16 bit samples, and can not be processed.");
    }
#line 97
    return (0);
  }
#line 100
  if ((int )wavhd.modus != 2) {
    {
#line 102
    fclose(sourcefile);
#line 103
    error_window((char *)"The source file is not stereo, and can not be processed.");
    }
#line 105
    return (0);
  }
#line 109
  return (1);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_wav.c"
void closewavsource(void) 
{ 


  {
  {
#line 115
  fclose(sourcefile);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_wav.c"
int seeksamplesource(long samplenumber ) 
{ 
  struct stat buf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 124
  tmp = fileno(sourcefile);
#line 124
  tmp___0 = fstat(tmp, & buf);
  }
#line 124
  if (tmp___0) {
#line 125
    return (0);
  }
#line 127
  if (sizeof(wavhead ) + (unsigned long )(4L * samplenumber) >= (unsigned long )buf.st_size) {
#line 128
    return (0);
  }
  {
#line 130
  tmp___1 = fseek(sourcefile, (long )(sizeof(wavhead ) + (unsigned long )(4L * samplenumber)),
                  0);
  }
#line 130
  if (tmp___1 > -1) {
#line 131
    return (1);
  } else {
#line 133
    return (0);
  }
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_wav.c"
sample_t readsamplesource(void) 
{ 
  sample_t sample ;
  size_t tmp ;

  {
  {
#line 141
  tmp = fread((void */* __restrict  */)(& sample), (size_t )1, (size_t )4, (FILE */* __restrict  */)sourcefile);
  }
#line 141
  if (tmp != 4UL) {
#line 145
    sample.left = (short)0;
#line 146
    sample.right = (short)0;
  }
#line 153
  return (sample);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_wav.c"
FILE *destfile  ;
#line 160 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_wav.c"
int destfileispipe  ;
#line 162 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_wav.c"
int openwavdest(char *filename , long bcount ) 
{ 
  wavhead header___0 ;
  char *riff ;
  char *wave ;
  char *fmt ;
  char *data ;

  {
#line 170
  riff = (char *)"RIFF";
#line 171
  wave = (char *)"WAVE";
#line 172
  fmt = (char *)"fmt ";
#line 173
  data = (char *)"data";
#line 175
  if ((int )*filename == 124) {
    {
#line 177
    destfileispipe = 1;
#line 178
    destfile = popen((char const   *)(filename + 1), "w");
    }
#line 178
    if ((unsigned long )destfile == (unsigned long )((void *)0)) {
#line 179
      return (0);
    }
  } else {
    {
#line 183
    destfileispipe = 0;
#line 184
    destfile = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
    }
#line 184
    if ((unsigned long )destfile == (unsigned long )((void *)0)) {
#line 185
      return (0);
    }
  }
  {
#line 189
  memcpy((void */* __restrict  */)(& header___0.main_chunk), (void const   */* __restrict  */)riff,
         (size_t )4);
#line 190
  header___0.length = (sizeof(wavhead ) - 8UL) + (unsigned long )bcount;
#line 191
  memcpy((void */* __restrict  */)(& header___0.chunk_type), (void const   */* __restrict  */)wave,
         (size_t )4);
#line 193
  memcpy((void */* __restrict  */)(& header___0.sub_chunk), (void const   */* __restrict  */)fmt,
         (size_t )4);
#line 194
  header___0.sc_len = (u_long )16;
#line 195
  header___0.format = (u_short )1;
#line 196
  header___0.modus = (u_short )2;
#line 197
  header___0.sample_fq = (u_long )44100;
#line 198
  header___0.byte_p_sec = (u_long )176400;
#line 199
  header___0.byte_p_spl = (u_short )4;
#line 200
  header___0.bit_p_spl = (u_short )16;
#line 202
  memcpy((void */* __restrict  */)(& header___0.data_chunk), (void const   */* __restrict  */)data,
         (size_t )4);
#line 203
  header___0.data_length = (u_long )bcount;
#line 217
  fwrite((void const   */* __restrict  */)(& header___0), sizeof(header___0), (size_t )1,
         (FILE */* __restrict  */)destfile);
  }
#line 219
  return (1);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_wav.c"
void closewavdest(void) 
{ 


  {
#line 225
  if (destfileispipe) {
    {
#line 226
    pclose(destfile);
    }
  } else {
    {
#line 228
    fclose(destfile);
    }
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/signpr_wav.c"
void writesampledest(sample_t sample ) 
{ 


  {
  {
#line 239
  fwrite((void const   */* __restrict  */)(& sample), (size_t )4, (size_t )1, (FILE */* __restrict  */)destfile);
  }
#line 240
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/endian.h"
u_short SwapTwoBytes(u_short w ) ;
#line 8
u_long SwapFourBytes(u_long dw ) ;
#line 9
sample_t SwapSample(sample_t sample ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/endian.c"
u_short SwapTwoBytes(u_short w ) 
{ 
  register u_short tmp ;

  {
#line 13
  tmp = (u_short )((int )w & 255);
#line 14
  tmp = (u_short )((((int )w & 65280) >> 8) | ((int )tmp << 8));
#line 15
  return (tmp);
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/endian.c"
short SwapTwo(short w ) 
{ 
  register short tmp ;

  {
#line 22
  tmp = (short )((int )w & 255);
#line 23
  tmp = (short )((((int )w & 65280) >> 8) | ((int )tmp << 8));
#line 24
  return (tmp);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/endian.c"
u_long SwapFourBytes(u_long dw ) 
{ 
  register u_long tmp ;

  {
#line 31
  tmp = dw & 255UL;
#line 32
  tmp = ((dw & 65280UL) >> 8) | (tmp << 8);
#line 33
  tmp = ((dw & 16711680UL) >> 16) | (tmp << 8);
#line 34
  tmp = ((dw & 4278190080UL) >> 24) | (tmp << 8);
#line 35
  return (tmp);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/endian.c"
sample_t SwapSample(sample_t sample ) 
{ 


  {
  {
#line 41
  sample.left = SwapTwo(sample.left);
#line 42
  sample.right = SwapTwo(sample.right);
  }
#line 43
  return (sample);
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/sndfunc.c"
int audio  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/sndfunc.c"
int abuf_size  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/sndfunc.c"
int fmt_mask  ;
#line 27
void sync_audio(void) ;
#line 33
void ErrDie(char *err ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/sndfunc.c"
void init_sound(int recorder ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 39
  if (recorder) {
#line 39
    tmp = 0;
  } else {
#line 39
    tmp = 1;
  }
  {
#line 39
  audio = open("/dev/dsp", tmp);
  }
#line 40
  if (audio == -1) {
    {
#line 41
    ErrDie((char *)"/dev/dsp");
    }
  }
  {
#line 47
  abuf_size = 65536;
#line 50
  tmp___0 = ioctl(audio, (unsigned long )(((2U << 30) | (unsigned int )(80 << 8)) | 11U) | (sizeof(int ) << 16),
                  & fmt_mask);
  }
#line 50
  if (tmp___0 < 0) {
    {
#line 50
    ErrDie((char *)"/dev/dsp");
    }
  }
#line 52
  return;
}
}
#line 56
void snd_parm(int speed , int bits , int stereo ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/sndfunc.c"
static int oldspeed  =    -1;
#line 56 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/sndfunc.c"
static int oldbits  =    -1;
#line 56 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/sndfunc.c"
static int oldstereo  =    -1;
#line 54 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/sndfunc.c"
void snd_parm(int speed , int bits , int stereo ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 58
  if (speed != oldspeed) {
#line 58
    goto _L;
  } else
#line 58
  if (bits != oldbits) {
#line 58
    goto _L;
  } else
#line 58
  if (stereo != oldstereo) {
    _L: /* CIL Label */ 
    {
#line 64
    sync_audio();
#line 67
    tmp = ioctl(audio, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 5U) | (sizeof(int ) << 16),
                & bits);
    }
#line 67
    if (tmp < 0) {
      {
#line 68
      ErrDie((char *)"/dev/dsp");
      }
    }
    {
#line 69
    tmp___0 = ioctl(audio, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 3U) | (sizeof(int ) << 16),
                    & stereo);
    }
#line 69
    if (tmp___0 < 0) {
      {
#line 70
      ErrDie((char *)"/dev/dsp");
      }
    }
    {
#line 71
    tmp___1 = ioctl(audio, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 2U) | (sizeof(int ) << 16),
                    & speed);
    }
#line 71
    if (tmp___1 < 0) {
      {
#line 72
      ErrDie((char *)"/dev/dsp");
      }
    }
  }
#line 74
  oldspeed = speed;
#line 74
  oldbits = bits;
#line 74
  oldstereo = stereo;
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/sndfunc.c"
void sync_audio(void) 
{ 
  int tmp ;

  {
  {
#line 79
  tmp = ioctl(audio, (unsigned long )((unsigned int )(80 << 8) | 1U), (void *)0);
  }
#line 79
  if (tmp < 0) {
    {
#line 80
    ErrDie((char *)"/dev/dsp");
    }
  }
#line 81
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 705
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setreuid)(__uid_t __ruid ,
                                                                               __uid_t __euid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 97 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpriority)(__priority_which_t __which ,
                                                                                  id_t __who ,
                                                                                  int __prio ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/bplay.c"
void finish_curses(int sig ) ;
#line 723 "/usr/include/curses.h"
extern int printw(char const   *  , ...) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/bplay.c"
char *progname  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/bplay.c"
int forked  ;
#line 66
void Usage(void) ;
#line 68
void Die(char *err ) ;
#line 70
void getbcount(int speed , int bits , int stereo , long *bcount , long timelim , long samplim ,
               long timejmp , long sampjmp , long *bjump ) ;
#line 72
void playraw(int thefd , char *hd_buf , int speed , int bits , int stereo ) ;
#line 73
void playwav(int thefd , char *hd_buf , int mods , int speed , int bits , int stereo ,
             long timelim , long samplim , long timejmp , long sampjmp ) ;
#line 77
void playvoc(int thefd , char *hd_buf ) ;
#line 85
void init_shm(void) ;
#line 86
void shmrec(int outfd , long totalcount , int terminate ) ;
#line 87
void diskread(int infd , long totalplay , long skipped , char *hd_buf , int terminate ,
              int speed , int bits , int stereo ) ;
#line 89
void volatile   audiowrite(void) ;
#line 90
void initsems(int disks , int snds ) ;
#line 91
void cleanupsems(void) ;
#line 114
extern int ( /* missing proto */  basename)() ;
#line 403 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/bplay.c"
void Usage(void) 
{ 
  int i ;

  {
  {
#line 406
  printw("Usage: %s [-S] [-s Hz] [-b 8|16] [-t secs] [-r|-v|-w] [filename]\n", progname);
#line 409
  printw("\nPress any key...");
#line 410
  wrefresh(stdscr);
#line 411
  i = wgetch(stdscr);
#line 413
  finish_curses(-1);
#line 414
  exit(1);
  }
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/bplay.c"
void ErrDie(char *err ) 
{ 
  char string[500] ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 420
  tmp = __errno_location();
#line 420
  tmp___0 = strerror(*tmp);
#line 420
  sprintf((char */* __restrict  */)(string), (char const   */* __restrict  */)"%s: %s",
          err, tmp___0);
#line 421
  error_window(string);
#line 422
  finish_curses(-1);
#line 423
  exit(-1);
  }
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/bplay.c"
void Die(char *err ) 
{ 
  char string[500] ;

  {
  {
#line 429
  sprintf((char */* __restrict  */)(string), (char const   */* __restrict  */)"%s",
          err);
#line 430
  error_window(string);
#line 431
  finish_curses(-1);
#line 432
  exit(-1);
  }
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/bplay.c"
void getbcount(int speed , int bits , int stereo , long *bcount , long timelim , long samplim ,
               long timejmp , long sampjmp , long *bjump ) 
{ 


  {
#line 438
  if (timelim) {
#line 441
    *bcount = ((long )speed * timelim) * ((long )(bits + 7) / 8L);
#line 443
    if (stereo) {
#line 443
      *bcount <<= 1;
    }
  }
#line 446
  if (samplim) {
#line 448
    *bcount = samplim * ((long )(bits + 7) / 8L);
#line 449
    if (stereo) {
#line 449
      *bcount <<= 1;
    }
  }
#line 451
  if (timejmp) {
#line 453
    *bjump = ((long )speed * timejmp) * ((long )(bits + 7) / 8L);
#line 454
    if (stereo) {
#line 454
      *bjump <<= 1;
    }
  }
#line 456
  if (sampjmp) {
#line 458
    *bjump = sampjmp * ((long )(bits + 7) / 8L);
#line 459
    if (stereo) {
#line 459
      *bjump <<= 1;
    }
  }
#line 461
  return;
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/bplay.c"
void playraw(int thefd , char *hd_buf , int speed , int bits , int stereo ) 
{ 
  char const   *tmp ;

  {
#line 465
  if (stereo) {
#line 465
    tmp = "Stereo";
  } else {
#line 465
    tmp = "Mono";
  }
  {
#line 465
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Playing raw data : %d bit, Speed %d %s ...\n",
          bits, speed, tmp);
#line 467
  diskread(thefd, 0L, 0L, hd_buf, 1, speed, bits, stereo);
  }
#line 468
  return;
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/bplay.c"
void playwav(int thefd , char *hd_buf , int mods , int speed , int bits , int stereo ,
             long timelim , long samplim , long timejmp , long sampjmp ) 
{ 
  wavhead wavhd ;
  int count ;
  long bcount ;
  long bjump ;
  ssize_t tmp ;

  {
  {
#line 475
  bcount = 0L;
#line 475
  bjump = 0L;
#line 477
  memcpy((void */* __restrict  */)((void *)(& wavhd)), (void const   */* __restrict  */)((void *)hd_buf),
         (size_t )20);
#line 478
  tmp = read(thefd, (void *)((char *)(& wavhd) + 20), sizeof(wavhd) - 20UL);
#line 478
  count = (int )tmp;
  }
#line 479
  if ((int )wavhd.format != 1) {
    {
#line 479
    Die((char *)"Input is not a PCM WAV file");
    }
  }
  {
#line 486
  speed = (int )wavhd.sample_fq;
#line 490
  bits = (int )wavhd.bit_p_spl;
#line 494
  stereo = (int )wavhd.modus - 1;
#line 500
  getbcount(speed, bits, stereo, & bcount, timelim, samplim, timejmp, sampjmp, & bjump);
  }
#line 502
  if (bjump) {
    {
#line 502
    lseek(thefd, bjump, 1);
    }
  }
  {
#line 504
  diskread(thefd, bcount, bjump, (char *)((void *)0), 1, speed, bits, stereo);
  }
#line 505
  return;
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/bplay.c"
void playvoc(int thefd , char *hd_buf ) 
{ 
  int count ;
  int speed ;
  int bits ;
  int stereo ;
  int inloop ;
  int loop_times ;
  long bytecount ;
  long loop_pos ;
  vochead vochd ;
  blockTC ccblock ;
  int lastblocktype ;
  int quit ;
  ssize_t tmp ;
  int off ;
  char *junk ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  blockT1 tblock ;
  blockT8 tblock___0 ;
  blockT9 tblock___1 ;
  int rd ;
  int trgt ;
  char junkbuf[8192] ;
  ssize_t tmp___2 ;

  {
  {
#line 510
  speed = 0;
#line 510
  bits = 0;
#line 510
  stereo = 0;
#line 511
  inloop = 0;
#line 512
  loop_pos = 0L;
#line 515
  lastblocktype = -1;
#line 516
  quit = 0;
#line 518
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Playing Creative Labs Voice file ...\n");
#line 519
  memcpy((void */* __restrict  */)((void *)(& vochd)), (void const   */* __restrict  */)((void *)hd_buf),
         (size_t )20);
#line 520
  tmp = read(thefd, (void *)((char *)(& vochd) + 20), sizeof(vochd) - 20UL);
#line 520
  count = (int )tmp;
#line 521
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Format version %d.%d\n",
          (int )vochd.Version >> 8, (int )vochd.Version & 255);
  }
#line 523
  if ((int )vochd.IDCode != ~ ((int )vochd.Version) + 4660) {
    {
#line 524
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Odd - version mismatch - %d != %d\n",
            (int )vochd.IDCode, ~ ((int )vochd.Version) + 4660);
    }
  }
#line 526
  if (sizeof(vochd) < (unsigned long )vochd.BlockOffset) {
    {
#line 528
    off = (int )((unsigned long )vochd.BlockOffset - sizeof(vochd));
#line 530
    tmp___0 = malloc((size_t )off);
#line 530
    junk = (char *)tmp___0;
#line 531
    read(thefd, (void *)junk, (size_t )off);
    }
  }
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! (! quit)) {
#line 533
      goto while_break;
    }
    {
#line 535
    tmp___1 = read(thefd, (void *)((char *)(& ccblock)), sizeof(ccblock));
    }
#line 535
    if (tmp___1 == -1L) {
      {
#line 540
      diskread(thefd, -1L, 0L, (char *)((void *)0), 1, speed, bits, stereo);
#line 541
      quit = 1;
      }
#line 542
      goto while_continue;
    }
    {
#line 549
    if ((int )ccblock.BlockID == 1) {
#line 549
      goto case_1;
    }
#line 565
    if ((int )ccblock.BlockID == 8) {
#line 565
      goto case_8;
    }
#line 577
    if ((int )ccblock.BlockID == 9) {
#line 577
      goto case_9;
    }
#line 591
    if ((int )ccblock.BlockID == 0) {
#line 591
      goto case_0;
    }
#line 598
    if ((int )ccblock.BlockID == 6) {
#line 598
      goto case_6;
    }
#line 613
    if ((int )ccblock.BlockID == 7) {
#line 613
      goto case_7;
    }
#line 631
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 552
    read(thefd, (void *)((char *)(& tblock)), sizeof(tblock));
    }
#line 553
    if ((int )tblock.PackMethod != 0) {
      {
#line 553
      Die((char *)"Non PCM VOC block");
      }
    }
#line 554
    if (lastblocktype != 8) {
#line 556
      speed = 256000000 / (65536 - ((int )tblock.TimeConstant << 8));
#line 557
      bits = 8;
#line 558
      stereo = 0;
    }
    {
#line 560
    bytecount = (long )((((u_long )ccblock.BlockLen[0] | ((u_long )ccblock.BlockLen[1] << 8)) | ((u_long )ccblock.BlockLen[2] << 16)) - 2UL);
#line 561
    diskread(thefd, bytecount, 0L, (char *)((void *)0), 0, speed, bits, stereo);
#line 562
    lastblocktype = 1;
    }
#line 564
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 568
    read(thefd, (void *)((char *)(& tblock___0)), sizeof(tblock___0));
    }
#line 569
    if ((int )tblock___0.PackMethod != 0) {
      {
#line 569
      Die((char *)"Non PCM VOC block");
      }
    }
#line 570
    speed = 256000000 / (65536 - (int )tblock___0.TimeConstant);
#line 571
    bits = 8;
#line 572
    stereo = (int )tblock___0.VoiceMode;
#line 573
    if (stereo) {
#line 573
      speed >>= 1;
    }
#line 574
    lastblocktype = 8;
#line 576
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 580
    read(thefd, (void *)((char *)(& tblock___1)), sizeof(tblock___1));
    }
#line 581
    if ((int )tblock___1.Format != 0) {
#line 581
      if ((int )tblock___1.Format != 4) {
        {
#line 582
        Die((char *)"Non PCM VOC block");
        }
      }
    }
    {
#line 583
    speed = (int )tblock___1.SamplesPerSec;
#line 584
    bits = (int )tblock___1.BitsPerSample;
#line 585
    stereo = (int )tblock___1.Channels - 1;
#line 586
    bytecount = (long )((((u_long )ccblock.BlockLen[0] | ((u_long )ccblock.BlockLen[1] << 8)) | ((u_long )ccblock.BlockLen[2] << 16)) - 12UL);
#line 587
    diskread(thefd, bytecount, 0L, (char *)((void *)0), 0, speed, bits, stereo);
#line 588
    lastblocktype = 9;
    }
#line 590
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 595
    diskread(thefd, -1L, 0L, (char *)((void *)0), 1, speed, bits, stereo);
#line 596
    quit = 1;
    }
#line 597
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 599
    inloop = 1;
#line 600
    read(thefd, (void *)((char *)(& loop_times)), (size_t )2);
#line 601
    loop_times ++;
#line 605
    loop_pos = lseek(thefd, (__off_t )0, 1);
    }
#line 606
    if (loop_pos == -1L) {
      {
#line 608
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Input not seekable - loop will only be played once\n");
#line 609
      loop_times = 1;
      }
    }
#line 611
    lastblocktype = (int )ccblock.BlockID;
#line 612
    goto switch_break;
    case_7: /* CIL Label */ 
#line 614
    if (! inloop) {
      {
#line 616
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Loop end with no loop start - ignoring\n");
      }
#line 617
      goto switch_break;
    }
#line 619
    if (loop_times != 65535) {
#line 619
      loop_times --;
    }
#line 620
    if (loop_times) {
      {
#line 625
      lseek(thefd, loop_pos, 0);
      }
    } else {
#line 628
      inloop = 0;
    }
#line 629
    lastblocktype = (int )ccblock.BlockID;
#line 630
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 633
    rd = 0;
#line 633
    trgt = 8192;
#line 636
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignored\n");
#line 637
    bytecount = (long )(((u_long )ccblock.BlockLen[0] | ((u_long )ccblock.BlockLen[1] << 8)) | ((u_long )ccblock.BlockLen[2] << 16));
    }
    {
#line 638
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 638
      if (! ((long )rd < bytecount)) {
#line 638
        goto while_break___0;
      }
#line 640
      if ((long )(rd + trgt) > bytecount) {
#line 641
        trgt = (int )(bytecount - (long )rd);
      }
      {
#line 642
      tmp___2 = read(thefd, (void *)(junkbuf), (size_t )trgt);
#line 642
      count = (int )tmp___2;
      }
#line 643
      if (count < 0) {
        {
#line 643
        ErrDie((char *)"read");
        }
      }
#line 644
      if (count == 0) {
        {
#line 644
        Die((char *)"premature eof in input");
        }
      }
#line 645
      rd += count;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 647
    lastblocktype = (int )ccblock.BlockID;
#line 649
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 652
  return;
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/bplay.c"
void finish_curses(int sig ) 
{ 


  {
  {
#line 673
  endwin();
#line 674
  exit(0);
  }
}
}
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 972 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) sync)(void) ;
#line 52 "/usr/include/x86_64-linux-gnu/sys/sem.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) semctl)(int __semid ,
                                                                             int __semnum ,
                                                                             int __cmd 
                                                                             , ...) ;
#line 55
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) semget)(key_t __key ,
                                                                             int __nsems ,
                                                                             int __semflg ) ;
#line 58
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) semop)(int __semid ,
                                                                            struct sembuf *__sops ,
                                                                            size_t __nsops ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/shm.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shmctl)(int __shmid ,
                                                                             int __cmd ,
                                                                             struct shmid_ds *__buf ) ;
#line 53
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shmget)(key_t __key ,
                                                                             size_t __size ,
                                                                             int __shmflg ) ;
#line 56
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) shmat)(int __shmid ,
                                                                              void const   *__shmaddr ,
                                                                              int __shmflg ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int shmid  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int shmid2  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int *disksemid  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int *sndsemid  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static char *bigbuff  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static char **buffarr  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int numbuffs  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int numsemblks  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static blockinf_t *buffinf  ;
#line 86
static void sighandler(int i ) ;
#line 99 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
void init_shm(void) 
{ 
  int i ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __uid_t tmp___12 ;
  __uid_t tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
#line 104
  shmid = shmget(0, (size_t )262144, 1920);
  }
#line 106
  if (shmid == -1) {
    {
#line 107
    ErrDie((char *)"shmget");
    }
  }
  {
#line 108
  tmp = shmat(shmid, (void const   *)0, 8192);
#line 108
  bigbuff = (char *)tmp;
  }
#line 109
  if ((unsigned long )bigbuff == (unsigned long )((char *)-1)) {
    {
#line 111
    perror("shmat");
#line 112
    tmp___0 = shmctl(shmid, 0, (struct shmid_ds *)((void *)0));
    }
#line 112
    if (tmp___0) {
      {
#line 113
      perror("shmctl");
      }
    }
    {
#line 114
    exit(-1);
    }
  }
  {
#line 116
  tmp___1 = shmctl(shmid, 0, (struct shmid_ds *)((void *)0));
  }
#line 116
  if (tmp___1) {
    {
#line 117
    ErrDie((char *)"shmctl");
    }
  }
  {
#line 122
  numbuffs = 262144 / abuf_size;
#line 123
  tmp___2 = malloc((unsigned long )numbuffs * sizeof(char *));
#line 123
  buffarr = (char **)tmp___2;
#line 124
  i = 0;
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < numbuffs)) {
#line 124
      goto while_break;
    }
#line 125
    *(buffarr + i) = bigbuff + i * abuf_size;
#line 124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  shmid2 = shmget(0, (unsigned long )numbuffs * sizeof(blockinf_t ), 1920);
  }
#line 132
  if (shmid2 == -1) {
    {
#line 133
    ErrDie((char *)"shmget");
    }
  }
  {
#line 134
  tmp___3 = shmat(shmid2, (void const   *)0, 8192);
#line 134
  buffinf = (blockinf_t *)tmp___3;
  }
#line 135
  if ((unsigned long )buffinf == (unsigned long )((blockinf_t *)((char *)-1))) {
    {
#line 137
    perror("shmat");
#line 138
    tmp___4 = shmctl(shmid2, 0, (struct shmid_ds *)((void *)0));
    }
#line 138
    if (tmp___4) {
      {
#line 139
      perror("shmctl");
      }
    }
    {
#line 140
    exit(-1);
    }
  }
  {
#line 142
  tmp___5 = shmctl(shmid2, 0, (struct shmid_ds *)((void *)0));
  }
#line 142
  if (tmp___5) {
    {
#line 143
    ErrDie((char *)"shmctl");
    }
  }
  {
#line 147
  tmp___6 = getuid();
#line 147
  tmp___7 = geteuid();
#line 147
  tmp___8 = setreuid(tmp___7, tmp___6);
#line 157
  tmp___9 = shmctl(shmid, 11, (struct shmid_ds *)((void *)0));
  }
#line 157
  if (tmp___9) {
#line 157
    tmp___11 = 1;
  } else {
    {
#line 157
    tmp___10 = shmctl(shmid2, 11, (struct shmid_ds *)((void *)0));
    }
#line 157
    if (tmp___10) {
#line 157
      tmp___11 = 1;
    } else {
#line 157
      tmp___11 = 0;
    }
  }
  {
#line 165
  tmp___12 = getuid();
#line 165
  tmp___13 = geteuid();
#line 165
  tmp___14 = setreuid(tmp___13, tmp___12);
#line 177
  numsemblks = numbuffs / 32;
  }
#line 178
  if (numsemblks * 32 < numbuffs) {
#line 179
    numsemblks ++;
  }
  {
#line 181
  tmp___15 = malloc(sizeof(int ) * (unsigned long )numsemblks);
#line 181
  disksemid = (int *)tmp___15;
  }
#line 181
  if ((unsigned long )disksemid == (unsigned long )((void *)0)) {
    {
#line 182
    ErrDie((char *)"malloc");
    }
  }
  {
#line 183
  tmp___16 = malloc(sizeof(int ) * (unsigned long )numsemblks);
#line 183
  sndsemid = (int *)tmp___16;
  }
#line 183
  if ((unsigned long )sndsemid == (unsigned long )((void *)0)) {
    {
#line 184
    ErrDie((char *)"malloc");
    }
  }
#line 186
  i = 0;
  {
#line 186
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 186
    if (! (i < numsemblks)) {
#line 186
      goto while_break___0;
    }
    {
#line 188
    tmp___17 = semget(0, 32, 1920);
#line 188
    *(disksemid + i) = tmp___17;
    }
#line 188
    if (tmp___17 == -1) {
      {
#line 190
      ErrDie((char *)"semget");
      }
    }
    {
#line 191
    tmp___18 = semget(0, 32, 1920);
#line 191
    *(sndsemid + i) = tmp___18;
    }
#line 191
    if (tmp___18 == -1) {
      {
#line 193
      ErrDie((char *)"semget");
      }
    }
#line 186
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 196
  signal(2, & sighandler);
  }
#line 197
  return;
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
void up(int *semblk , int xsemnum ) 
{ 
  struct sembuf sbuf ;
  int tmp ;

  {
  {
#line 205
  sbuf.sem_num = (unsigned short )(xsemnum % 32);
#line 206
  sbuf.sem_op = (short)1;
#line 207
  sbuf.sem_flg = (short)0;
#line 209
  tmp = semop(*(semblk + xsemnum / 32), & sbuf, (size_t )1);
  }
#line 209
  if (tmp == -1) {
    {
#line 210
    perror("semop");
    }
  }
#line 211
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
void down(int *semblk , int xsemnum ) 
{ 
  struct sembuf sbuf ;
  int tmp ;

  {
  {
#line 218
  sbuf.sem_num = (unsigned short )(xsemnum % 32);
#line 219
  sbuf.sem_op = (short)-1;
#line 220
  sbuf.sem_flg = (short)0;
#line 222
  tmp = semop(*(semblk + xsemnum / 32), & sbuf, (size_t )1);
  }
#line 222
  if (tmp == -1) {
    {
#line 223
    perror("semop");
    }
  }
#line 224
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
void shmrec(int outfd , long totalcount , int terminate ) 
{ 
  pid_t pid ;
  int i ;
  button_t ok_button ;
  char timestring[100] ;
  int cbuff___1 ;
  long totalrd ;
  short *ssptr ;
  short leftvalue ;
  short rightvalue ;
  short maxleft ;
  short maxright ;
  long samplesabove50pct ;
  long samplesabove90pct ;
  long samplesabove99pct ;
  long samplestooloud ;
  long count ;
  long numwr ;
  long trgt ;
  char *tmpptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int cbuff___2 ;
  long totalrd___0 ;
  int stoprecording ;
  int in_ch ;
  long trgt___0 ;
  long count___0 ;
  long numrd ;
  char *tmpptr___0 ;

  {
  {
#line 234
  nodelay(stdscr, (_Bool)1);
#line 236
  sync();
#line 238
  pid = fork();
  }
#line 239
  if (pid == 0) {
    {
#line 241
    cbuff___1 = 0;
#line 242
    totalrd = 0L;
#line 247
    samplesabove50pct = 0L;
#line 248
    samplesabove90pct = 0L;
#line 249
    samplesabove99pct = 0L;
#line 250
    samplestooloud = 0L;
#line 254
    signal(2, (void (*)(int  ))0);
    }
    {
#line 257
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 263
      down(disksemid, cbuff___1);
#line 265
      tmpptr = *(buffarr + cbuff___1);
#line 267
      ssptr = (short *)tmpptr;
#line 269
      numwr = 0L;
#line 270
      trgt = (long )(buffinf + cbuff___1)->count;
      }
      {
#line 271
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 271
        if (numwr < trgt) {
          {
#line 271
          count = write(outfd, (void const   *)tmpptr, (size_t )(trgt - numwr));
          }
#line 271
          if (! (count > 0L)) {
#line 271
            goto while_break___0;
          }
        } else {
#line 271
          goto while_break___0;
        }
#line 274
        numwr += count;
#line 275
        tmpptr += count;
#line 276
        totalrd += count;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 280
      maxleft = (short)0;
#line 281
      maxright = (short)0;
#line 282
      trgt = (long )(buffinf + cbuff___1)->count;
#line 284
      numwr = 0L;
      {
#line 284
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 284
        if (! (numwr < trgt)) {
#line 284
          goto while_break___1;
        }
        {
#line 286
        tmp = abs((int )*ssptr);
#line 286
        leftvalue = (short )tmp;
        }
#line 287
        if ((int )leftvalue > (int )maxleft) {
#line 287
          maxleft = leftvalue;
        }
        {
#line 288
        ssptr ++;
#line 290
        tmp___0 = abs((int )*ssptr);
#line 290
        rightvalue = (short )tmp___0;
        }
#line 291
        if ((int )rightvalue > (int )maxright) {
#line 291
          maxright = rightvalue;
        }
#line 292
        ssptr ++;
#line 294
        if ((int )leftvalue > 16383) {
#line 295
          samplesabove50pct ++;
        } else
#line 294
        if ((int )rightvalue > 16383) {
#line 295
          samplesabove50pct ++;
        }
#line 296
        if ((int )leftvalue > 29490) {
#line 297
          samplesabove90pct ++;
        } else
#line 296
        if ((int )rightvalue > 29490) {
#line 297
          samplesabove90pct ++;
        }
#line 298
        if ((int )leftvalue > 32439) {
#line 299
          samplesabove99pct ++;
        } else
#line 298
        if ((int )rightvalue > 32439) {
#line 299
          samplesabove99pct ++;
        }
#line 300
        if ((int )leftvalue > 32764) {
#line 301
          samplestooloud ++;
        } else
#line 300
        if ((int )rightvalue > 32764) {
#line 301
          samplestooloud ++;
        }
#line 284
        numwr += 4L;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 303
      wmove(stdscr, 11, 21);
#line 304
      waddnstr(stdscr, "L: =", -1);
#line 305
      leftvalue = (short )((int )maxleft / 963);
#line 306
      numwr = 0L;
      }
      {
#line 306
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 306
        if (! (numwr < (long )leftvalue)) {
#line 306
          goto while_break___2;
        }
#line 307
        if (numwr >= 32L) {
#line 307
          tmp___1 = '#';
        } else {
#line 307
          tmp___1 = '=';
        }
        {
#line 307
        waddch(stdscr, (chtype const   )tmp___1);
#line 306
        numwr ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 308
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 308
        if (! (numwr < 34L)) {
#line 308
          goto while_break___3;
        }
        {
#line 309
        waddch(stdscr, (chtype const   )' ');
#line 308
        numwr ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 311
      wmove(stdscr, 12, 21);
#line 312
      waddnstr(stdscr, "R: =", -1);
#line 313
      rightvalue = (short )((int )maxright / 963);
#line 314
      numwr = 0L;
      }
      {
#line 314
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 314
        if (! (numwr < (long )rightvalue)) {
#line 314
          goto while_break___4;
        }
#line 315
        if (numwr >= 32L) {
#line 315
          tmp___2 = '#';
        } else {
#line 315
          tmp___2 = '=';
        }
        {
#line 315
        waddch(stdscr, (chtype const   )tmp___2);
#line 314
        numwr ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 316
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 316
        if (! (numwr < 34L)) {
#line 316
          goto while_break___5;
        }
        {
#line 317
        waddch(stdscr, (chtype const   )' ');
#line 316
        numwr ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 319
      wmove(stdscr, 0, 79);
#line 320
      wrefresh(stdscr);
#line 324
      up(sndsemid, cbuff___1);
      }
#line 327
      if ((buffinf + cbuff___1)->last) {
#line 328
        goto while_break;
      }
#line 330
      cbuff___1 ++;
#line 331
      cbuff___1 %= numbuffs;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 334
    close(outfd);
#line 341
    clearscreen((char *)"Record audio to a sound file");
#line 343
    printw("\n\n");
#line 344
    printw("      Recording information:\n\n\n");
#line 345
    fsec2hmsf((double )totalrd / (double )176400, timestring);
#line 346
    printw("    Recorded time    : %s\n", timestring);
#line 347
    printw("    Recorded samples : %11ld\n", totalrd / 4L);
#line 348
    printw("    Recorded bytes   : %11ld  (excl. header)\n", totalrd);
#line 349
    printw("\n");
#line 350
    printw("    Samples above 50%% of max. volume  : %9ld  (%5.1f%%)\n", samplesabove50pct,
           ((double )samplesabove50pct * 100.) / (double )(totalrd / 4L));
#line 352
    printw("    Samples above 90%% of max. volume  : %9ld  (%5.1f%%)\n", samplesabove90pct,
           ((double )samplesabove90pct * 100.) / (double )(totalrd / 4L));
#line 354
    printw("    Samples above 99%% of max. volume  : %9ld  (%5.1f%%)\n", samplesabove99pct,
           ((double )samplesabove99pct * 100.) / (double )(totalrd / 4L));
#line 356
    printw("    Really too loud (clipped) samples : %9ld  (%5.1f%%)\n", samplestooloud,
           ((double )samplestooloud * 100.) / (double )(totalrd / 4L));
#line 372
    ok_button.text = (char *)" OK ";
#line 373
    ok_button.y = 20;
#line 374
    ok_button.x = 71;
#line 375
    ok_button.selected = 1;
#line 377
    button_display(& ok_button);
#line 378
    tmp___3 = strlen((char const   *)ok_button.text);
#line 378
    mybox(ok_button.y - 1, ok_button.x - 1, 3, (int )(tmp___3 + 2UL));
#line 380
    wmove(stdscr, 0, 79);
#line 381
    wrefresh(stdscr);
#line 384
    exit(0);
    }
  } else {
#line 389
    cbuff___2 = 0;
#line 390
    totalrd___0 = 0L;
#line 392
    stoprecording = 0;
    {
#line 395
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 395
      if (totalrd___0 < totalcount) {
#line 395
        if (! (! stoprecording)) {
#line 395
          goto while_break___6;
        }
      } else {
#line 395
        goto while_break___6;
      }
#line 399
      trgt___0 = totalcount - totalrd___0;
#line 400
      if (trgt___0 > (long )abuf_size) {
#line 401
        trgt___0 = (long )abuf_size;
      }
      {
#line 403
      down(sndsemid, cbuff___2);
#line 405
      numrd = 0L;
#line 406
      tmpptr___0 = *(buffarr + cbuff___2);
      }
      {
#line 407
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 407
        if (numrd < trgt___0) {
          {
#line 407
          count___0 = read(audio, (void *)tmpptr___0, (size_t )(trgt___0 - numrd));
          }
#line 407
          if (! (count___0 > 0L)) {
#line 407
            goto while_break___7;
          }
        } else {
#line 407
          goto while_break___7;
        }
#line 410
        numrd += count___0;
#line 411
        tmpptr___0 += count___0;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 414
      (buffinf + cbuff___2)->count = (int )numrd;
#line 416
      up(disksemid, cbuff___2);
#line 418
      totalrd___0 += numrd;
#line 421
      in_ch = wgetch(stdscr);
      }
#line 425
      if (in_ch == 343) {
#line 426
        stoprecording = 1;
      } else
#line 425
      if (in_ch == 13) {
#line 426
        stoprecording = 1;
      } else
#line 425
      if (in_ch == 27) {
#line 426
        stoprecording = 1;
      }
#line 427
      if (totalrd___0 >= totalcount) {
#line 427
        if (terminate) {
#line 428
          (buffinf + cbuff___2)->last = 1;
        } else {
#line 427
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 427
      if (stoprecording) {
#line 428
        (buffinf + cbuff___2)->last = 1;
      }
#line 430
      cbuff___2 ++;
#line 431
      cbuff___2 %= numbuffs;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 434
    close(audio);
#line 437
    i = 0;
    }
    {
#line 437
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 437
      if (! (i < numbuffs)) {
#line 437
        goto while_break___8;
      }
      {
#line 438
      up(disksemid, i);
#line 437
      i ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 440
    wait((union wait *)((void *)0));
#line 443
    cleanupsems();
#line 446
    nodelay(stdscr, (_Bool)1);
    }
    {
#line 449
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 450
      i = wgetch(stdscr);
      }
#line 449
      if (i != 13) {
#line 449
        if (i != 343) {
#line 449
          if (! (i != 27)) {
#line 449
            goto while_break___9;
          }
        } else {
#line 449
          goto while_break___9;
        }
      } else {
#line 449
        goto while_break___9;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
  }
#line 454
  return;
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int triggered  =    0;
#line 466 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int cbuff  =    0;
#line 456 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
void diskread(int infd , long totalplay , long skipped , char *hd_buf , int terminate ,
              int speed , int bits , int stereo ) 
{ 
  int count ;
  int i ;
  int limited ;
  char *tmppt ;
  long numread ;
  long totalread ;
  int first ;
  char tempstring[50] ;
  int in_ch ;
  int trgt ;
  ssize_t tmp ;

  {
#line 460
  limited = 0;
#line 462
  totalread = 0L;
#line 463
  first = 1;
#line 471
  if (totalplay) {
#line 471
    limited = 1;
  }
#line 472
  if (totalplay == -1L) {
#line 474
    totalplay = 0L;
#line 475
    limited = 1;
  }
  {
#line 478
  clearscreen((char *)"Play a sound file");
#line 479
  error_window_display((char *)"Playing...", (char *)" Stop ");
#line 480
  nodelay(stdscr, (_Bool)1);
#line 481
  wrefresh(stdscr);
  }
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 488
    down(disksemid, cbuff);
#line 490
    numread = 0L;
#line 491
    trgt = abuf_size;
    }
#line 492
    if (limited) {
#line 492
      if (totalread + (long )trgt > totalplay) {
#line 493
        trgt = (int )(totalplay - totalread);
      }
    }
#line 494
    tmppt = *(buffarr + cbuff);
#line 495
    if (first) {
#line 495
      if (trgt) {
#line 497
        (buffinf + cbuff)->setit = 1;
#line 498
        (buffinf + cbuff)->speed = speed;
#line 499
        (buffinf + cbuff)->bits = bits;
#line 500
        (buffinf + cbuff)->stereo = stereo;
#line 501
        if (hd_buf) {
          {
#line 503
          memcpy((void */* __restrict  */)tmppt, (void const   */* __restrict  */)hd_buf,
                 (size_t )20);
#line 504
          tmppt += 20;
#line 504
          numread = 20L;
          }
        }
#line 506
        first = 0;
      }
    }
    {
#line 508
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 508
      if (numread < (long )trgt) {
        {
#line 508
        tmp = read(infd, (void *)tmppt, (size_t )((long )trgt - numread));
#line 508
        count = (int )tmp;
        }
#line 508
        if (! (count != 0)) {
#line 508
          goto while_break___0;
        }
      } else {
#line 508
        goto while_break___0;
      }
#line 511
      tmppt += count;
#line 511
      numread += (long )count;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 517
    (buffinf + cbuff)->count = (int )numread;
#line 518
    totalread += numread;
#line 520
    in_ch = wgetch(stdscr);
    }
#line 522
    if (numread < (long )abuf_size) {
#line 524
      goto while_break;
    }
#line 526
    if (in_ch == 27) {
      {
#line 528
      mvprintw(11, 21, "Time:                 ");
#line 530
      wmove(stdscr, 0, 79);
#line 531
      wrefresh(stdscr);
      }
#line 532
      goto while_break;
    } else
#line 526
    if (in_ch == 343) {
      {
#line 528
      mvprintw(11, 21, "Time:                 ");
#line 530
      wmove(stdscr, 0, 79);
#line 531
      wrefresh(stdscr);
      }
#line 532
      goto while_break;
    } else
#line 526
    if (in_ch == 13) {
      {
#line 528
      mvprintw(11, 21, "Time:                 ");
#line 530
      wmove(stdscr, 0, 79);
#line 531
      wrefresh(stdscr);
      }
#line 532
      goto while_break;
    }
#line 535
    if (triggered) {
      {
#line 537
      up(sndsemid, cbuff);
#line 539
      fsec2hmsf(((double )((skipped + totalread) - 262144L) - 65536.) / (double )((speed * (bits / 8)) * (stereo + 1)),
                tempstring);
#line 542
      mvprintw(11, 21, "Time: %s", tempstring);
#line 544
      wmove(stdscr, 0, 79);
#line 545
      wrefresh(stdscr);
      }
    } else
#line 550
    if (cbuff == numbuffs - 1) {
#line 555
      i = 0;
      {
#line 555
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 555
        if (! (i < numbuffs)) {
#line 555
          goto while_break___1;
        }
        {
#line 556
        up(sndsemid, i);
#line 555
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 557
      triggered = 1;
    }
#line 560
    cbuff ++;
#line 561
    cbuff %= numbuffs;
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  if (terminate) {
#line 566
    (buffinf + cbuff)->last = 1;
#line 567
    if (! triggered) {
#line 572
      i = 0;
      {
#line 572
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 572
        if (! (i < cbuff)) {
#line 572
          goto while_break___2;
        }
        {
#line 573
        up(sndsemid, i);
#line 572
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 574
    up(sndsemid, cbuff);
    }
  } else
#line 576
  if (! triggered) {
#line 576
    if (cbuff == numbuffs - 1) {
#line 581
      i = 0;
      {
#line 581
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 581
        if (! (i < numbuffs)) {
#line 581
          goto while_break___3;
        }
        {
#line 582
        up(sndsemid, i);
#line 581
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 583
      triggered = 1;
    } else {
#line 576
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 585
  if (triggered) {
    {
#line 586
    up(sndsemid, cbuff);
    }
  }
#line 587
  cbuff ++;
#line 588
  cbuff %= numbuffs;
#line 589
  return;
}
}
#line 591 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
void volatile   audiowrite(void) 
{ 
  int cbuff___1 ;
  int count ;
  int numwr ;
  int trgt ;
  char *tmpptr ;
  ssize_t tmp ;

  {
  {
#line 593
  cbuff___1 = 0;
#line 597
  signal(2, (void (*)(int  ))0);
  }
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 603
    down(sndsemid, cbuff___1);
    }
#line 605
    if ((buffinf + cbuff___1)->setit) {
      {
#line 607
      snd_parm((buffinf + cbuff___1)->speed, (buffinf + cbuff___1)->bits, (buffinf + cbuff___1)->stereo);
#line 609
      (buffinf + cbuff___1)->setit = 0;
      }
    }
#line 611
    trgt = (buffinf + cbuff___1)->count;
#line 612
    numwr = 0;
#line 613
    tmpptr = *(buffarr + cbuff___1);
    {
#line 614
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 614
      if (numwr < trgt) {
        {
#line 614
        tmp = write(audio, (void const   *)tmpptr, (size_t )(trgt - numwr));
#line 614
        count = (int )tmp;
        }
#line 614
        if (! (count > 0)) {
#line 614
          goto while_break___0;
        }
      } else {
#line 614
        goto while_break___0;
      }
#line 617
      if (count == -1) {
        {
#line 618
        ErrDie((char *)"write");
        }
      }
#line 619
      numwr += count;
#line 620
      tmpptr += count;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 626
    if ((buffinf + cbuff___1)->last) {
      {
#line 628
      up(disksemid, cbuff___1);
      }
#line 629
      goto while_break;
    }
    {
#line 632
    up(disksemid, cbuff___1);
#line 634
    cbuff___1 ++;
#line 635
    cbuff___1 %= numbuffs;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 638
  sync_audio();
#line 639
  close(audio);
#line 640
  exit(0);
  }
}
}
#line 643 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
void initsems(int disks , int snds ) 
{ 
  int i ;
  int j ;
  union semun __constr_expr_0 ;
  int tmp ;
  union semun __constr_expr_1 ;
  int tmp___0 ;

  {
#line 647
  i = 0;
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 647
    if (! (i < numsemblks)) {
#line 647
      goto while_break;
    }
#line 648
    j = 0;
    {
#line 648
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 648
      if (! (j < 32)) {
#line 648
        goto while_break___0;
      }
      {
#line 650
      __constr_expr_0.val = disks;
#line 650
      tmp = semctl(*(disksemid + i), j, 16, __constr_expr_0);
      }
#line 650
      if (tmp == -1) {
        {
#line 651
        ErrDie((char *)"semctl");
        }
      }
      {
#line 652
      __constr_expr_1.val = snds;
#line 652
      tmp___0 = semctl(*(sndsemid + i), j, 16, __constr_expr_1);
      }
#line 652
      if (tmp___0 == -1) {
        {
#line 653
        ErrDie((char *)"semctl");
        }
      }
#line 648
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 647
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 655
  return;
}
}
#line 657 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
void cleanupsems(void) 
{ 
  int i ;
  union semun __constr_expr_2 ;
  union semun __constr_expr_3 ;

  {
#line 661
  i = 0;
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if (! (i < numsemblks)) {
#line 661
      goto while_break;
    }
    {
#line 663
    __constr_expr_2.val = 0;
#line 663
    semctl(*(disksemid + i), 0, 0, __constr_expr_2);
#line 664
    __constr_expr_3.val = 0;
#line 664
    semctl(*(sndsemid + i), 0, 0, __constr_expr_3);
#line 661
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 666
  return;
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static void sighandler(int i ) 
{ 


  {
  {
#line 673
  cleanupsems();
#line 674
  finish_curses(1);
#line 675
  exit(1);
  }
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/sndfunc.c"
static int oldspeed___0  =    -1;
#line 56 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/sndfunc.c"
static int oldbits___0  =    -1;
#line 56 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/sndfunc.c"
static int oldstereo___0  =    -1;
#line 78 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int shmid___0  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int shmid2___0  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int *disksemid___0  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int *sndsemid___0  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static char *bigbuff___0  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static char **buffarr___0  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int numbuffs___0  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int numsemblks___0  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static blockinf_t *buffinf___0  ;
#line 86
static void sighandler___0(int i ) ;
#line 465 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int triggered___0  =    0;
#line 466 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static int cbuff___0  =    0;
#line 668 "/home/june/repo/benchmarks/collector/temp/gramofile-1.6/bplaysrc/shmbuf.c"
static void sighandler___0(int i ) 
{ 


  {
  {
#line 673
  cleanupsems();
#line 674
  finish_curses(1);
#line 675
  exit(1);
  }
}
}
