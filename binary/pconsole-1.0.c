/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 26 "include/commands.h"
struct __anonstruct_Command_1 {
   char *cmd ;
   int (*func)(char ** ) ;
   char *help ;
};
#line 26 "include/commands.h"
typedef struct __anonstruct_Command_1 Command;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 33 "include/Conn.h"
struct Conn_tag;
#line 33 "include/Conn.h"
typedef struct Conn_tag Conn;
#line 35 "include/Conn.h"
struct Conn_tag {
   Conn *prev ;
   Conn *next ;
   int fd ;
   dev_t rdev ;
   char *dev ;
   char *hostname ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 28 "include/List.h"
struct List_tag;
#line 28 "include/List.h"
typedef struct List_tag ListType;
#line 30 "include/List.h"
struct List_tag {
   ListType *prev ;
   ListType *next ;
};
#line 32 "include/commands.h"
int pcommand(char *buf ) ;
#line 34
int cmd_help(char **argv ) ;
#line 35
int cmd_version(char **argv ) ;
#line 36
int cmd_echo(char **argv ) ;
#line 37
int cmd_connect(char **argv ) ;
#line 38
int cmd_exit(char **argv ) ;
#line 39
int cmd_attach(char **argv ) ;
#line 40
int cmd_detach(char **argv ) ;
#line 41
int cmd_list(char **argv ) ;
#line 31 "include/pconsole.h"
int flags ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 51 "include/cstring.h"
void cstrip_line(char *msg ) ;
#line 52
char **cstrsplit(char *line , char token ) ;
#line 29 "include/terminal.h"
void terminal_mode(int mode ) ;
#line 46 "include/Conn.h"
Conn *AllConns ;
#line 48
Conn *new_Conn(void) ;
#line 49
void destroy_Conn(Conn *c ) ;
#line 51
Conn *add_Conn(Conn *c ) ;
#line 52
void remove_Conn(Conn *c ) ;
#line 55
Conn *find_Conn_by_dev(char *name ) ;
#line 56
Conn *find_Conn_by_hostname(char *name ) ;
#line 59
Conn *find_Conn_by_rdev(dev_t rdev ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 770
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ttyname)(int __fd ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 41 "/home/wheatley/newnew/temp/pconsole-1.0/commands.c"
Command commands[11]  = 
#line 41 "/home/wheatley/newnew/temp/pconsole-1.0/commands.c"
  {      {(char *)"help", & cmd_help, (char *)"Give help about the available commands"}, 
        {(char *)"?",
      & cmd_help, (char *)"short-cut for \'help\'"}, 
        {(char *)"version", & cmd_version, (char *)"Display version information"}, 
        {(char *)"echo", & cmd_echo, (char *)"Turn echo on or off"}, 
        {(char *)"attach", & cmd_attach, (char *)"Attach to a tty device"}, 
        {(char *)"detach", & cmd_detach, (char *)"Detach from a tty device"}, 
        {(char *)"list", & cmd_list, (char *)"Show devices currently attached to"}, 
        {(char *)"connect", & cmd_connect, (char *)"Leave command mode"}, 
        {(char *)"quit", & cmd_exit, (char *)"Exit pconsole"}, 
        {(char *)"exit", & cmd_exit, (char *)"Exit pconsole"}, 
        {(char *)((void *)0), (int (*)(char ** ))((void *)0), (char *)((void *)0)}};
#line 59 "/home/wheatley/newnew/temp/pconsole-1.0/commands.c"
int pcommand(char *buf ) 
{ 
  char cmd[4096] ;
  char **arr ;
  char *cmd_str ;
  int i ;
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 63
  strcpy((char */* __restrict  */)(cmd), (char const   */* __restrict  */)buf);
#line 65
  cstrip_line(cmd);
  }
#line 66
  if (! cmd[0]) {
#line 67
    return (0);
  }
  {
#line 69
  arr = cstrsplit(cmd, (char )' ');
  }
#line 69
  if ((unsigned long )arr == (unsigned long )((void *)0)) {
    {
#line 70
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pconsole: out of memory (?)\n");
    }
#line 71
    return (0);
  }
  {
#line 73
  tmp = strlen((char const   *)*(arr + 0));
#line 73
  len = (int )tmp;
#line 75
  i = 0;
  }
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! ((unsigned long )commands[i].cmd != (unsigned long )((void *)0))) {
#line 75
      goto while_break;
    }
#line 76
    cmd_str = commands[i].cmd;
#line 77
    if ((int )*cmd_str == 124) {
#line 78
      cmd_str ++;
    }
    {
#line 80
    tmp___0 = strncmp((char const   *)cmd_str, (char const   *)*(arr + 0), (size_t )len);
    }
#line 80
    if (! tmp___0) {
#line 81
      if ((unsigned long )commands[i].func == (unsigned long )((void *)0)) {
        {
#line 82
        printf((char const   */* __restrict  */)"pconsole: not yet implemented\n");
        }
      } else {
        {
#line 84
        (*(commands[i].func))(arr + 1);
        }
      }
#line 85
      goto while_break;
    }
#line 75
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  if ((unsigned long )commands[i].cmd == (unsigned long )((void *)0)) {
    {
#line 89
    printf((char const   */* __restrict  */)"pconsole: unknown command \'%s\'\n",
           *(arr + 0));
    }
  }
  {
#line 91
  free((void *)arr);
  }
#line 92
  return (0);
}
}
#line 96 "/home/wheatley/newnew/temp/pconsole-1.0/commands.c"
int cmd_help(char **argv ) 
{ 
  int i ;
  int j ;
  int len ;
  char *cmd ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 99
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
#line 99
    goto _L;
  } else
#line 99
  if ((unsigned long )*(argv + 0) == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 100
    i = 0;
    {
#line 100
    while (1) {
      while_continue: /* CIL Label */ ;
#line 100
      if (! ((unsigned long )commands[i].cmd != (unsigned long )((void *)0))) {
#line 100
        goto while_break;
      }
#line 101
      if ((int )*(commands[i].cmd + 0) == 124) {
        {
#line 102
        printf((char const   */* __restrict  */)"\n %-14s %s\n", commands[i].cmd + 1,
               commands[i].help);
        }
      } else {
        {
#line 104
        printf((char const   */* __restrict  */)" %-14s %s\n", commands[i].cmd, commands[i].help);
        }
      }
#line 100
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 109
    j = 0;
    {
#line 109
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 109
      if (! ((unsigned long )*(argv + j) != (unsigned long )((void *)0))) {
#line 109
        goto while_break___0;
      }
      {
#line 116
      tmp = strcmp((char const   *)*(argv + j), "warranty");
      }
#line 116
      if (! tmp) {
        {
#line 117
        printf((char const   */* __restrict  */)"Copyright (C) 2001  Walter de Jong <walter@heiho.net>\n\n");
#line 120
        printf((char const   */* __restrict  */)"This program is free software; you can redistribute it\nand/or modify it under the terms of the GNU General Public\nLicense as published by the Free Software Foundation;\neither version 2 of the License, or (at your option)\nany later version.\n\n");
#line 127
        printf((char const   */* __restrict  */)"This program is distributed in the hope that it will be\nuseful, but WITHOUT ANY WARRANTY; without even the\nimplied warranty of MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE. See the GNU General Public License\nfor more details.\n\n");
#line 134
        printf((char const   */* __restrict  */)"You should have received a copy of the GNU General Public\nLicense along with this program; if not, write to the\nFree Software Foundation, Inc., 59 Temple Place,\nSuite 330, Boston, MA  02111-1307  USA\n");
        }
#line 139
        goto __Cont;
      }
      {
#line 144
      tmp___0 = strlen((char const   *)*(argv + j));
#line 144
      len = (int )tmp___0;
#line 145
      i = 0;
      }
      {
#line 145
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 145
        if (! ((unsigned long )commands[i].cmd != (unsigned long )((void *)0))) {
#line 145
          goto while_break___1;
        }
#line 146
        cmd = commands[i].cmd;
#line 147
        if ((int )*cmd == 124) {
#line 148
          cmd ++;
        }
        {
#line 150
        tmp___1 = strncmp((char const   *)*(argv + j), (char const   *)cmd, (size_t )len);
        }
#line 150
        if (! tmp___1) {
          {
#line 151
          printf((char const   */* __restrict  */)" %-14s %s\n", cmd, commands[i].help);
          }
#line 152
          goto while_break___1;
        }
#line 145
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 155
      if ((unsigned long )commands[i].cmd == (unsigned long )((void *)0)) {
        {
#line 156
        printf((char const   */* __restrict  */)"pconsole: unknown command \'%s\'\n",
               *(argv + j));
        }
      }
      __Cont: /* CIL Label */ 
#line 109
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 159
  return (0);
}
}
#line 162 "/home/wheatley/newnew/temp/pconsole-1.0/commands.c"
int cmd_version(char **argv ) 
{ 


  {
  {
#line 163
  printf((char const   */* __restrict  */)"pconsole 1.0 WJ101\nCopyright (C) 2001  Walter de Jong <walter@heiho.net>\n\nThis is free software with ABSOLUTELY NO WARRANTY.\nFor details type \'help warranty\'.\n\nThe distribution page is at http://www.heiho.net/pconsole/\n");
  }
#line 171
  return (0);
}
}
#line 174 "/home/wheatley/newnew/temp/pconsole-1.0/commands.c"
int cmd_echo(char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 175
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
#line 176
    flags ^= 1;
  } else
#line 175
  if ((unsigned long )*(argv + 0) == (unsigned long )((void *)0)) {
#line 176
    flags ^= 1;
  } else {
    {
#line 178
    tmp___0 = strcmp((char const   *)*(argv + 0), "on");
    }
#line 178
    if (tmp___0) {
      {
#line 181
      tmp = strcmp((char const   *)*(argv + 0), "off");
      }
#line 181
      if (tmp) {
        {
#line 184
        printf((char const   */* __restrict  */)"usage: echo [on|off]\n");
        }
#line 185
        return (1);
      } else {
#line 182
        flags &= -2;
      }
    } else {
#line 179
      flags |= 1;
    }
  }
#line 188
  if (flags & 1) {
#line 188
    tmp___1 = "on";
  } else {
#line 188
    tmp___1 = "off";
  }
  {
#line 188
  printf((char const   */* __restrict  */)"pconsole: echo is now toggled %s\n", tmp___1);
  }
#line 189
  return (0);
}
}
#line 192 "/home/wheatley/newnew/temp/pconsole-1.0/commands.c"
int cmd_exit(char **argv ) 
{ 
  Conn *c ;
  Conn *c_next ;
  char *arr[2] ;

  {
#line 200
  arr[1] = (char *)((void *)0);
#line 201
  c = AllConns;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 201
      goto while_break;
    }
    {
#line 202
    c_next = c->next;
#line 203
    arr[0] = c->dev;
#line 204
    cmd_detach(arr);
#line 201
    c = c_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  terminal_mode(1);
#line 207
  exit(0);
  }
#line 208
  return (-1);
}
}
#line 211 "/home/wheatley/newnew/temp/pconsole-1.0/commands.c"
int cmd_connect(char **argv ) 
{ 


  {
#line 212
  if ((unsigned long )AllConns == (unsigned long )((void *)0)) {
    {
#line 213
    printf((char const   */* __restrict  */)"pconsole: currently not attached to any terminal device\n");
    }
#line 214
    return (0);
  }
#line 216
  flags &= -3;
#line 217
  return (0);
}
}
#line 220 "/home/wheatley/newnew/temp/pconsole-1.0/commands.c"
int cmd_attach(char **argv ) 
{ 
  int i ;
  int len ;
  char *tty ;
  char *devname ;
  char buf[256] ;
  struct stat ttystat ;
  struct stat ttystat2 ;
  Conn *c ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  Conn *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
#line 226
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
    {
#line 227
    printf((char const   */* __restrict  */)"usage: attach [hostname#]<tty device name> [...]\n");
    }
#line 228
    return (1);
  } else
#line 226
  if ((unsigned long )*(argv + 0) == (unsigned long )((void *)0)) {
    {
#line 227
    printf((char const   */* __restrict  */)"usage: attach [hostname#]<tty device name> [...]\n");
    }
#line 228
    return (1);
  }
  {
#line 230
  tmp = fileno(stdin);
#line 230
  tty = ttyname(tmp);
  }
#line 230
  if ((unsigned long )tty == (unsigned long )((void *)0)) {
    {
#line 231
    printf((char const   */* __restrict  */)"pconsole: not on a tty\n");
#line 232
    cmd_exit((char **)((void *)0));
    }
#line 233
    return (-1);
  }
  {
#line 235
  tmp___2 = stat((char const   */* __restrict  */)tty, (struct stat */* __restrict  */)(& ttystat));
  }
#line 235
  if (tmp___2) {
    {
#line 236
    tmp___0 = __errno_location();
#line 236
    tmp___1 = strerror(*tmp___0);
#line 236
    printf((char const   */* __restrict  */)"failed to stat my tty %s: %s\n", tty,
           tmp___1);
#line 237
    cmd_exit((char **)((void *)0));
    }
#line 238
    return (-1);
  }
  {
#line 240
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"\r\n[pconsole attached from tty %s]\r\n",
          tty);
#line 241
  tmp___3 = strlen((char const   *)(buf));
#line 241
  len = (int )tmp___3;
#line 243
  i = 0;
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! ((unsigned long )*(argv + i) != (unsigned long )((void *)0))) {
#line 243
      goto while_break;
    }
    {
#line 244
    printf((char const   */* __restrict  */)"attaching %s : ", *(argv + i));
#line 246
    devname = strchr((char const   *)*(argv + i), '#');
    }
#line 246
    if ((unsigned long )devname != (unsigned long )((void *)0)) {
#line 247
      *devname = (char)0;
#line 248
      devname ++;
#line 249
      if (! *devname) {
        {
#line 250
        printf((char const   */* __restrict  */)"invalid terminal device name \'%s:\'\n",
               *(argv + i));
        }
#line 251
        goto __Cont;
      }
    } else {
#line 254
      devname = *(argv + i);
    }
    {
#line 260
    tmp___6 = stat((char const   */* __restrict  */)devname, (struct stat */* __restrict  */)(& ttystat2));
    }
#line 260
    if (tmp___6) {
      {
#line 261
      tmp___4 = __errno_location();
#line 261
      tmp___5 = strerror(*tmp___4);
#line 261
      printf((char const   */* __restrict  */)"%s\n", tmp___5);
      }
#line 262
      goto __Cont;
    }
#line 264
    if (((ttystat2.st_mode & 61440U) & 8192U) != 8192U) {
      {
#line 265
      printf((char const   */* __restrict  */)"not a character device\n");
      }
#line 266
      goto __Cont;
    }
#line 269
    if (ttystat2.st_rdev == ttystat.st_rdev) {
      {
#line 270
      printf((char const   */* __restrict  */)"cannot create a pconsole loop\n");
      }
#line 271
      goto __Cont;
    }
    {
#line 273
    tmp___7 = find_Conn_by_rdev(ttystat2.st_rdev);
    }
#line 273
    if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
      {
#line 274
      printf((char const   */* __restrict  */)"already attached\n");
      }
#line 275
      goto __Cont;
    }
    {
#line 286
    c = new_Conn();
    }
#line 286
    if ((unsigned long )c == (unsigned long )((void *)0)) {
      {
#line 287
      printf((char const   */* __restrict  */)"out of memory (?)\n");
      }
#line 288
      return (-1);
    }
    {
#line 290
    c->dev = strdup((char const   *)devname);
    }
#line 291
    if ((unsigned long )devname != (unsigned long )*(argv + i)) {
      {
#line 292
      c->hostname = strdup((char const   *)*(argv + i));
      }
    }
    {
#line 294
    c->rdev = ttystat2.st_rdev;
#line 299
    tmp___10 = open((char const   *)devname, 2);
#line 299
    c->fd = tmp___10;
    }
#line 299
    if (tmp___10 == -1) {
      {
#line 300
      tmp___8 = __errno_location();
#line 300
      tmp___9 = strerror(*tmp___8);
#line 300
      printf((char const   */* __restrict  */)"%s\n", tmp___9);
#line 301
      destroy_Conn(c);
      }
#line 302
      goto __Cont;
    }
    {
#line 304
    add_Conn(c);
#line 305
    printf((char const   */* __restrict  */)"Ok\n");
#line 306
    write(c->fd, (void const   *)(buf), (size_t )len);
    }
    __Cont: /* CIL Label */ 
#line 243
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  return (0);
}
}
#line 311 "/home/wheatley/newnew/temp/pconsole-1.0/commands.c"
int cmd_detach(char **argv ) 
{ 
  int i ;
  int len ;
  char *tty ;
  char buf[256] ;
  Conn *c ;
  int tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
#line 316
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
    {
#line 317
    printf((char const   */* __restrict  */)"usage: detach [hostname#]<tty device name> [...]\n");
    }
#line 318
    return (1);
  } else
#line 316
  if ((unsigned long )*(argv + 0) == (unsigned long )((void *)0)) {
    {
#line 317
    printf((char const   */* __restrict  */)"usage: detach [hostname#]<tty device name> [...]\n");
    }
#line 318
    return (1);
  }
  {
#line 320
  tmp = fileno(stdin);
#line 320
  tty = ttyname(tmp);
  }
#line 321
  if ((unsigned long )tty == (unsigned long )((void *)0)) {
#line 321
    tmp___0 = "(unknown)";
  } else {
#line 321
    tmp___0 = (char const   *)tty;
  }
  {
#line 321
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"\r\n[pconsole detached from tty %s]\r\n",
          tmp___0);
#line 322
  tmp___1 = strlen((char const   *)(buf));
#line 322
  len = (int )tmp___1;
#line 324
  i = 0;
  }
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! ((unsigned long )*(argv + i) != (unsigned long )((void *)0))) {
#line 324
      goto while_break;
    }
    {
#line 325
    c = find_Conn_by_dev(*(argv + i));
    }
#line 325
    if ((unsigned long )c == (unsigned long )((void *)0)) {
      {
#line 325
      c = find_Conn_by_hostname(*(argv + i));
      }
#line 325
      if ((unsigned long )c == (unsigned long )((void *)0)) {
        {
#line 327
        printf((char const   */* __restrict  */)"not attached to %s\n", *(argv + i));
        }
#line 328
        goto __Cont;
      }
    }
    {
#line 330
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if ((unsigned long )c->hostname != (unsigned long )((void *)0)) {
        {
#line 332
        printf((char const   */* __restrict  */)"detaching from %s#%s : ", c->hostname,
               c->dev);
        }
      } else {
        {
#line 334
        printf((char const   */* __restrict  */)"detaching from %s : ", c->dev);
        }
      }
#line 336
      if (c->fd > 0) {
        {
#line 337
        write(c->fd, (void const   *)(buf), (size_t )len);
        }
      }
      {
#line 339
      remove_Conn(c);
#line 340
      destroy_Conn(c);
#line 341
      printf((char const   */* __restrict  */)"Ok\n");
#line 330
      c = find_Conn_by_hostname(*(argv + i));
      }
#line 330
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
        {
#line 330
        c = find_Conn_by_dev(*(argv + i));
        }
#line 330
        if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 330
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 324
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  return (0);
}
}
#line 348 "/home/wheatley/newnew/temp/pconsole-1.0/commands.c"
int cmd_list(char **argv ) 
{ 
  Conn *c ;

  {
#line 351
  if ((unsigned long )AllConns == (unsigned long )((void *)0)) {
    {
#line 352
    printf((char const   */* __restrict  */)"pconsole: currently not attached to any terminal device\n");
    }
#line 353
    return (0);
  }
  {
#line 355
  printf((char const   */* __restrict  */)"Currently attached to:\n");
#line 356
  c = AllConns;
  }
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 356
      goto while_break;
    }
#line 358
    if ((unsigned long )c->hostname != (unsigned long )((void *)0)) {
      {
#line 359
      printf((char const   */* __restrict  */)" %-16s %-20s (device no %d, %d)\n",
             c->dev, c->hostname, ((int )c->rdev >> 8) & 255, (int )c->rdev & 255);
      }
    } else {
      {
#line 361
      printf((char const   */* __restrict  */)" %-16s %-20s (device no %d, %d)\n",
             c->dev, " ", ((int )c->rdev >> 8) & 255, (int )c->rdev & 255);
      }
    }
#line 356
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return (0);
}
}
#line 34 "include/List.h"
void *prepend_List(void *v1 , void *v2 ) ;
#line 35
void *add_List(void *v1 , void *v2 ) ;
#line 38
void remove_List(void *v1 , void *v2 ) ;
#line 50 "include/Conn.h"
Conn *prepend_Conn(Conn *c ) ;
#line 54
Conn *find_Conn_by_fd(int fd ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 31 "/home/wheatley/newnew/temp/pconsole-1.0/Conn.c"
Conn *AllConns  =    (Conn *)((void *)0);
#line 33 "/home/wheatley/newnew/temp/pconsole-1.0/Conn.c"
Conn *new_Conn(void) 
{ 
  Conn *c ;
  void *tmp ;

  {
  {
#line 36
  tmp = malloc(sizeof(Conn ));
#line 36
  c = (Conn *)tmp;
  }
#line 36
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 37
    return ((Conn *)((void *)0));
  }
  {
#line 38
  memset((void *)c, 0, sizeof(Conn ));
  }
#line 39
  return (c);
}
}
#line 42 "/home/wheatley/newnew/temp/pconsole-1.0/Conn.c"
void destroy_Conn(Conn *c ) 
{ 


  {
#line 43
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 44
    return;
  }
#line 46
  if (c->fd > 0) {
    {
#line 47
    close(c->fd);
    }
  }
#line 48
  if ((unsigned long )c->dev != (unsigned long )((void *)0)) {
    {
#line 49
    free((void *)c->dev);
    }
  }
#line 50
  if ((unsigned long )c->hostname != (unsigned long )((void *)0)) {
    {
#line 51
    free((void *)c->hostname);
    }
  }
  {
#line 52
  free((void *)c);
  }
#line 53
  return;
}
}
#line 55 "/home/wheatley/newnew/temp/pconsole-1.0/Conn.c"
Conn *prepend_Conn(Conn *c ) 
{ 
  void *tmp ;

  {
  {
#line 55
  tmp = prepend_List((void *)(& AllConns), (void *)c);
  }
#line 55
  return ((Conn *)tmp);
}
}
#line 56 "/home/wheatley/newnew/temp/pconsole-1.0/Conn.c"
Conn *add_Conn(Conn *c ) 
{ 
  void *tmp ;

  {
  {
#line 56
  tmp = add_List((void *)(& AllConns), (void *)c);
  }
#line 56
  return ((Conn *)tmp);
}
}
#line 57 "/home/wheatley/newnew/temp/pconsole-1.0/Conn.c"
void remove_Conn(Conn *c ) 
{ 


  {
  {
#line 57
  remove_List((void *)(& AllConns), (void *)c);
  }
#line 57
  return;
}
}
#line 59 "/home/wheatley/newnew/temp/pconsole-1.0/Conn.c"
Conn *find_Conn_by_fd(int fd ) 
{ 
  Conn *c ;

  {
#line 62
  c = AllConns;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 62
      goto while_break;
    }
#line 63
    if (c->fd == fd) {
#line 64
      return (c);
    }
#line 62
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return ((Conn *)((void *)0));
}
}
#line 68 "/home/wheatley/newnew/temp/pconsole-1.0/Conn.c"
Conn *find_Conn_by_dev(char *name ) 
{ 
  Conn *c ;
  int tmp ;

  {
#line 71
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 72
    return ((Conn *)((void *)0));
  }
#line 74
  c = AllConns;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 74
      goto while_break;
    }
#line 75
    if ((unsigned long )c->dev != (unsigned long )((void *)0)) {
      {
#line 75
      tmp = strcmp((char const   *)c->dev, (char const   *)name);
      }
#line 75
      if (! tmp) {
#line 76
        return (c);
      }
    }
#line 74
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return ((Conn *)((void *)0));
}
}
#line 80 "/home/wheatley/newnew/temp/pconsole-1.0/Conn.c"
Conn *find_Conn_by_hostname(char *name ) 
{ 
  Conn *c ;
  int tmp ;

  {
#line 83
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 84
    return ((Conn *)((void *)0));
  }
#line 86
  c = AllConns;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 86
      goto while_break;
    }
#line 87
    if ((unsigned long )c->hostname != (unsigned long )((void *)0)) {
      {
#line 87
      tmp = strcmp((char const   *)c->hostname, (char const   *)name);
      }
#line 87
      if (! tmp) {
#line 88
        return (c);
      }
    }
#line 86
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return ((Conn *)((void *)0));
}
}
#line 93 "/home/wheatley/newnew/temp/pconsole-1.0/Conn.c"
Conn *find_Conn_by_rdev(dev_t rdev ) 
{ 
  Conn *c ;

  {
#line 96
  c = AllConns;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 96
      goto while_break;
    }
#line 97
    if (c->rdev == rdev) {
#line 98
      return (c);
    }
#line 96
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return ((Conn *)((void *)0));
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 65 "/home/wheatley/newnew/temp/pconsole-1.0/cstring.c"
void cstrip_line(char *msg ) 
{ 
  char *p ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 69
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
#line 70
    return;
  } else
#line 69
  if (! *msg) {
#line 70
    return;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 72
    p = strchr((char const   *)msg, 27);
    }
#line 72
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 72
      goto while_break;
    }
    {
#line 73
    tmp = strlen((char const   *)p);
#line 73
    memmove((void *)p, (void const   *)(p + 1), tmp + 1UL);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 74
    p = strchr((char const   *)msg, '\t');
    }
#line 74
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 74
      goto while_break___0;
    }
#line 75
    *p = (char )' ';
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 77
  tmp___0 = strlen((char const   *)msg);
#line 77
  i = (int )tmp___0;
  }
  {
#line 78
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 78
    if (i) {
#line 78
      if (! ((int )*msg == 32)) {
#line 78
        goto while_break___1;
      }
    } else {
#line 78
      goto while_break___1;
    }
    {
#line 79
    tmp___1 = i;
#line 79
    i --;
#line 79
    memmove((void *)msg, (void const   *)(msg + 1), (size_t )tmp___1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 81
  i --;
  {
#line 82
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 82
    if (i >= 0) {
#line 82
      if (! ((int )*(msg + i) == 32)) {
#line 82
        if (! ((int )*(msg + i) == 13)) {
#line 82
          if (! ((int )*(msg + i) == 10)) {
#line 82
            goto while_break___2;
          }
        }
      }
    } else {
#line 82
      goto while_break___2;
    }
#line 83
    tmp___2 = i;
#line 83
    i --;
#line 83
    *(msg + tmp___2) = (char)0;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 95 "/home/wheatley/newnew/temp/pconsole-1.0/cstring.c"
char **cstrsplit(char *line , char token ) 
{ 
  char **args ;
  char *p ;
  char *startp ;
  int num ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 97
  num = 2;
#line 99
  if (! line) {
#line 100
    return ((char **)((void *)0));
  } else
#line 99
  if (! *line) {
#line 100
    return ((char **)((void *)0));
  }
#line 102
  p = line;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    p = strchr((char const   *)p, (int )token);
    }
#line 103
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 103
      goto while_break;
    }
#line 104
    num ++;
#line 105
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  tmp = malloc((unsigned long )num * sizeof(char *));
#line 107
  args = (char **)tmp;
  }
#line 107
  if ((unsigned long )args == (unsigned long )((void *)0)) {
#line 108
    return ((char **)((void *)0));
  }
#line 110
  p = line;
#line 110
  startp = p;
#line 111
  num = 0;
  {
#line 112
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 112
    p = strchr((char const   *)p, (int )token);
    }
#line 112
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 112
      goto while_break___0;
    }
#line 113
    tmp___0 = num;
#line 113
    num ++;
#line 113
    *(args + tmp___0) = startp;
#line 114
    *p = (char)0;
#line 115
    p ++;
#line 116
    startp = p;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  tmp___1 = num;
#line 118
  num ++;
#line 118
  *(args + tmp___1) = startp;
#line 119
  *(args + num) = (char *)((void *)0);
#line 120
  return (args);
}
}
#line 33 "include/pconsole.h"
void command_mode(void) ;
#line 34
void pconsole(void) ;
#line 35
int main(int argc , char **argv ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 710
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 43 "/home/wheatley/newnew/temp/pconsole-1.0/pconsole.c"
int flags  =    1;
#line 45 "/home/wheatley/newnew/temp/pconsole-1.0/pconsole.c"
void command_mode(void) 
{ 
  char buf[256] ;
  char *p ;

  {
  {
#line 48
  terminal_mode(1);
#line 49
  printf((char const   */* __restrict  */)"\npconsole command mode\n>>> ");
#line 52
  fflush(stdout);
#line 54
  flags |= 2;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 56
    p = fgets((char */* __restrict  */)(buf), 256, (FILE */* __restrict  */)stdin);
    }
#line 56
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 56
      goto while_break;
    }
    {
#line 57
    cstrip_line(buf);
    }
#line 58
    if (buf[0]) {
      {
#line 59
      pcommand(buf);
      }
    }
#line 61
    if (flags & 2) {
#line 62
      if (buf[0]) {
        {
#line 63
        printf((char const   */* __restrict  */)"\n");
        }
      }
      {
#line 64
      printf((char const   */* __restrict  */)">>> ");
#line 65
      fflush(stdout);
      }
    } else {
#line 67
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 70
    if ((unsigned long )AllConns == (unsigned long )((void *)0)) {
      {
#line 71
      printf((char const   */* __restrict  */)"\n\n");
#line 72
      terminal_mode(1);
#line 73
      exit(0);
      }
    } else {
      {
#line 75
      printf((char const   */* __restrict  */)"<Ctrl-D>\n");
      }
    }
  }
  {
#line 77
  flags &= -3;
#line 79
  printf((char const   */* __restrict  */)"\nPress <Ctrl-A> for command mode\n> ");
#line 82
  fflush(stdout);
#line 83
  terminal_mode(0);
  }
#line 84
  return;
}
}
#line 86 "/home/wheatley/newnew/temp/pconsole-1.0/pconsole.c"
void pconsole(void) 
{ 
  int key ;
  int typed ;
  char kar ;
  Conn *c ;
  Conn *c_next ;
  __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  __uid_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 87
  typed = 0;
#line 91
  if ((unsigned long )AllConns == (unsigned long )((void *)0)) {
    {
#line 92
    command_mode();
    }
  } else {
    {
#line 94
    printf((char const   */* __restrict  */)"\nPress <Ctrl-A> for command mode\n> ");
#line 97
    fflush(stdout);
#line 98
    terminal_mode(0);
    }
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 100
    tmp___4 = fileno(stdin);
#line 100
    tmp___5 = read(tmp___4, (void *)(& kar), (size_t )1);
    }
#line 100
    if (! (tmp___5 > 0L)) {
#line 100
      goto while_break;
    }
#line 101
    key = (int )kar & 255;
#line 102
    if (key == 1) {
      {
#line 103
      printf((char const   */* __restrict  */)"<Ctrl-A>\n");
#line 104
      command_mode();
      }
#line 105
      goto while_continue;
    }
#line 107
    if (key == 19) {
      {
#line 108
      printf((char const   */* __restrict  */)"<Ctrl-S> ");
#line 109
      cmd_echo((char **)((void *)0));
#line 111
      printf((char const   */* __restrict  */)"> ");
#line 112
      fflush(stdout);
#line 113
      typed = 0;
      }
#line 114
      goto while_continue;
    }
#line 116
    if (key == 13) {
      {
#line 117
      printf((char const   */* __restrict  */)"\n> ");
#line 118
      fflush(stdout);
#line 119
      typed = 0;
      }
    } else
#line 116
    if (key == 10) {
      {
#line 117
      printf((char const   */* __restrict  */)"\n> ");
#line 118
      fflush(stdout);
#line 119
      typed = 0;
      }
    } else
#line 121
    if (flags & 1) {
#line 122
      if (key == 127) {
#line 122
        goto _L___0;
      } else
#line 122
      if (key == 8) {
        _L___0: /* CIL Label */ 
#line 123
        if (typed) {
          {
#line 124
          printf((char const   */* __restrict  */)"\b \b");
#line 125
          fflush(stdout);
#line 126
          typed --;
          }
        }
      } else {
#line 129
        if (key >= 32) {
#line 129
          if (key <= 126) {
            {
#line 130
            fputc(key, stdout);
#line 131
            typed ++;
            }
          } else {
#line 129
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 134
          if (key == 27) {
#line 134
            goto case_27;
          }
#line 138
          if (key == 9) {
#line 138
            goto case_9;
          }
#line 142
          goto switch_default;
          case_27: /* CIL Label */ 
          {
#line 135
          printf((char const   */* __restrict  */)"<Esc>");
          }
#line 136
          goto switch_break;
          case_9: /* CIL Label */ 
          {
#line 139
          printf((char const   */* __restrict  */)"<Tab>");
          }
#line 140
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 143
          printf((char const   */* __restrict  */)"<Ctrl-%c>", (key - 1) + 65);
          }
          switch_break: /* CIL Label */ ;
          }
          {
#line 145
          printf((char const   */* __restrict  */)"\n> ");
#line 146
          typed = 0;
          }
        }
        {
#line 148
        fflush(stdout);
        }
      }
    }
#line 155
    c = AllConns;
    {
#line 155
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 155
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 155
        goto while_break___0;
      }
#line 156
      c_next = c->next;
#line 158
      if (c->fd > 0) {
        {
#line 159
        seteuid((__uid_t )0);
#line 160
        tmp___3 = ioctl(c->fd, 21522UL, & kar);
        }
#line 160
        if (tmp___3 == -1) {
          {
#line 161
          tmp = getuid();
#line 161
          seteuid(tmp);
#line 162
          tmp___0 = __errno_location();
#line 162
          tmp___1 = strerror(*tmp___0);
#line 162
          printf((char const   */* __restrict  */)"\nioctl() : %s\n", tmp___1);
          }
#line 163
          if ((unsigned long )c->hostname != (unsigned long )((void *)0)) {
            {
#line 164
            printf((char const   */* __restrict  */)"detaching from %s#%s\n", c->hostname,
                   c->dev);
            }
          } else {
            {
#line 166
            printf((char const   */* __restrict  */)"detaching from %s\n", c->dev);
            }
          }
          {
#line 167
          remove_Conn(c);
#line 168
          destroy_Conn(c);
          }
        } else {
          {
#line 170
          tmp___2 = getuid();
#line 170
          seteuid(tmp___2);
          }
        }
      }
#line 155
      c = c_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 173
    if ((unsigned long )AllConns == (unsigned long )((void *)0)) {
      {
#line 174
      command_mode();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return;
}
}
#line 178 "/home/wheatley/newnew/temp/pconsole-1.0/pconsole.c"
void sig_exit(int sig ) 
{ 


  {
  {
#line 179
  cmd_exit((char **)((void *)0));
#line 180
  exit(127 + sig);
  }
}
}
#line 183 "/home/wheatley/newnew/temp/pconsole-1.0/pconsole.c"
int main(int argc , char **argv ) 
{ 
  __uid_t tmp ;
  __uid_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 184
  tmp = geteuid();
  }
#line 184
  if (tmp) {
    {
#line 185
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You must be root to run this program or this program should be setuid root.\n");
    }
#line 186
    return (-1);
  }
  {
#line 188
  tmp___0 = getuid();
#line 188
  tmp___1 = seteuid(tmp___0);
  }
#line 188
  if (tmp___1) {
    {
#line 189
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to drop root privileges\n");
#line 190
    exit(-1);
    }
  }
  {
#line 192
  tmp___2 = fileno(stdin);
#line 192
  tmp___3 = isatty(tmp___2);
  }
#line 192
  if (! tmp___3) {
    {
#line 193
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pconsole: not a tty\n");
    }
#line 194
    return (-1);
  }
  {
#line 196
  printf((char const   */* __restrict  */)"pconsole WJ101\n");
#line 198
  signal(15, & sig_exit);
#line 199
  signal(2, & sig_exit);
  }
#line 201
  if (argc > 1) {
    {
#line 202
    cmd_attach(argv + 1);
    }
  }
  {
#line 204
  pconsole();
#line 205
  cmd_exit((char **)((void *)0));
  }
#line 206
  return (0);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 34 "/home/wheatley/newnew/temp/pconsole-1.0/terminal.c"
static struct termios ori_term  ;
#line 35 "/home/wheatley/newnew/temp/pconsole-1.0/terminal.c"
static int saved  =    0;
#line 33 "/home/wheatley/newnew/temp/pconsole-1.0/terminal.c"
void terminal_mode(int mode ) 
{ 
  struct termios term ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 38
  tmp = fileno(stdin);
#line 38
  tmp___0 = isatty(tmp);
  }
#line 38
  if (! tmp___0) {
    {
#line 39
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pconsole: not on a tty\n");
    }
#line 40
    return;
  }
  {
#line 42
  tmp___1 = fileno(stdin);
#line 42
  tcgetattr(tmp___1, & term);
  }
#line 43
  if (mode == 0) {
#line 44
    if (! saved) {
      {
#line 45
      memcpy((void */* __restrict  */)(& ori_term), (void const   */* __restrict  */)(& term),
             sizeof(struct termios ));
#line 46
      saved = 1;
      }
    }
    {
#line 48
    term.c_iflag |= 1U;
#line 49
    term.c_iflag &= 4294961855U;
#line 50
    term.c_lflag &= 4294934404U;
#line 51
    term.c_cc[6] = (cc_t )1;
#line 52
    term.c_cc[5] = (cc_t )0;
#line 53
    tmp___2 = fileno(stdin);
#line 53
    tcsetattr(tmp___2, 0, (struct termios  const  *)(& term));
    }
  } else
#line 55
  if (saved) {
    {
#line 56
    memcpy((void */* __restrict  */)(& term), (void const   */* __restrict  */)(& ori_term),
           sizeof(struct termios ));
#line 57
    tmp___3 = fileno(stdin);
#line 57
    tcsetattr(tmp___3, 0, (struct termios  const  *)(& term));
    }
  }
#line 60
  return;
}
}
#line 36 "include/List.h"
void listdestroy_List(void *v1 , void *v2 ) ;
#line 37
void *concat_List(void *v1 , void *v2 ) ;
#line 39
int list_Count(void *v ) ;
#line 40
void *rewind_List(void *v ) ;
#line 41
void *unwind_List(void *v ) ;
#line 42
void *sort_List(void *v , int (*sort_func)(void * , void * ) ) ;
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 32 "/home/wheatley/newnew/temp/pconsole-1.0/List.c"
void *prepend_List(void *v1 , void *v2 ) 
{ 
  ListType **root ;
  ListType *l ;

  {
#line 35
  if ((unsigned long )v1 == (unsigned long )((void *)0)) {
#line 36
    return ((void *)0);
  }
#line 38
  root = (ListType **)v1;
#line 39
  l = (ListType *)v2;
#line 41
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 42
    return ((void *)*root);
  }
#line 44
  l->prev = (ListType *)((void *)0);
#line 45
  l->next = *root;
#line 46
  if ((unsigned long )l->next != (unsigned long )((void *)0)) {
#line 47
    (l->next)->prev = l;
  }
#line 48
  *root = l;
#line 49
  return ((void *)l);
}
}
#line 52 "/home/wheatley/newnew/temp/pconsole-1.0/List.c"
void *add_List(void *v1 , void *v2 ) 
{ 
  ListType **root ;
  ListType *l ;
  ListType *tmp ;
  ListType *lp ;

  {
#line 55
  if ((unsigned long )v1 == (unsigned long )((void *)0)) {
#line 56
    return ((void *)0);
  }
#line 58
  root = (ListType **)v1;
#line 59
  l = (ListType *)v2;
#line 61
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 62
    return ((void *)*root);
  }
#line 64
  tmp = (ListType *)((void *)0);
#line 64
  l->next = tmp;
#line 64
  l->prev = tmp;
#line 65
  if ((unsigned long )*root == (unsigned long )((void *)0)) {
#line 66
    *root = l;
  } else {
#line 72
    lp = *root;
    {
#line 72
    while (1) {
      while_continue: /* CIL Label */ ;
#line 72
      if (! ((unsigned long )lp->next != (unsigned long )((void *)0))) {
#line 72
        goto while_break;
      }
#line 72
      lp = lp->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 73
    lp->next = l;
#line 74
    l->prev = lp;
  }
#line 76
  return ((void *)l);
}
}
#line 82 "/home/wheatley/newnew/temp/pconsole-1.0/List.c"
void listdestroy_List(void *v1 , void *v2 ) 
{ 
  ListType *l ;
  ListType *l2 ;
  void (*destroy_func)(ListType * ) ;

  {
#line 86
  if ((unsigned long )v1 == (unsigned long )((void *)0)) {
#line 87
    return;
  } else
#line 86
  if ((unsigned long )v2 == (unsigned long )((void *)0)) {
#line 87
    return;
  }
#line 89
  l = (ListType *)v1;
#line 90
  destroy_func = (void (*)(ListType * ))v2;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! ((unsigned long )l->prev != (unsigned long )((void *)0))) {
#line 92
      goto while_break;
    }
#line 93
    l = l->prev;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 95
      goto while_break___0;
    }
    {
#line 96
    l2 = l->next;
#line 97
    (*destroy_func)(l);
#line 98
    l = l2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 100
  return;
}
}
#line 102 "/home/wheatley/newnew/temp/pconsole-1.0/List.c"
void *concat_List(void *v1 , void *v2 ) 
{ 
  ListType **root ;
  ListType *l ;
  ListType *p ;

  {
#line 105
  if ((unsigned long )v1 == (unsigned long )((void *)0)) {
#line 106
    return ((void *)0);
  }
#line 108
  root = (ListType **)v1;
#line 109
  l = (ListType *)v2;
#line 111
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 112
    return ((void *)*root);
  }
#line 114
  if ((unsigned long )*root == (unsigned long )((void *)0)) {
#line 115
    *root = l;
  } else {
#line 119
    p = *root;
    {
#line 119
    while (1) {
      while_continue: /* CIL Label */ ;
#line 119
      if (! ((unsigned long )p->next != (unsigned long )((void *)0))) {
#line 119
        goto while_break;
      }
#line 119
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 120
    p->next = l;
#line 121
    l->prev = p;
  }
#line 123
  return ((void *)l);
}
}
#line 126 "/home/wheatley/newnew/temp/pconsole-1.0/List.c"
void remove_List(void *v1 , void *v2 ) 
{ 
  ListType **root ;
  ListType *l ;
  ListType *tmp ;

  {
#line 129
  if ((unsigned long )v1 == (unsigned long )((void *)0)) {
#line 130
    return;
  } else
#line 129
  if ((unsigned long )v2 == (unsigned long )((void *)0)) {
#line 130
    return;
  }
#line 132
  root = (ListType **)v1;
#line 133
  l = (ListType *)v2;
#line 135
  if ((unsigned long )*root == (unsigned long )((void *)0)) {
#line 136
    return;
  }
#line 138
  if ((unsigned long )l->prev == (unsigned long )((void *)0)) {
#line 139
    *root = l->next;
  } else {
#line 141
    (l->prev)->next = l->next;
  }
#line 143
  if ((unsigned long )l->next != (unsigned long )((void *)0)) {
#line 144
    (l->next)->prev = l->prev;
  }
#line 145
  tmp = (ListType *)((void *)0);
#line 145
  l->prev = tmp;
#line 145
  l->next = tmp;
#line 146
  return;
}
}
#line 148 "/home/wheatley/newnew/temp/pconsole-1.0/List.c"
int list_Count(void *v ) 
{ 
  ListType *l ;
  int c ;

  {
#line 150
  c = 0;
#line 152
  l = (ListType *)v;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 152
      goto while_break;
    }
#line 153
    c ++;
#line 152
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return (c);
}
}
#line 157 "/home/wheatley/newnew/temp/pconsole-1.0/List.c"
void *rewind_List(void *v ) 
{ 
  ListType *root ;

  {
#line 160
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 161
    return ((void *)0);
  }
#line 163
  root = (ListType *)v;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! ((unsigned long )root->prev != (unsigned long )((void *)0))) {
#line 165
      goto while_break;
    }
#line 166
    root = root->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return ((void *)root);
}
}
#line 170 "/home/wheatley/newnew/temp/pconsole-1.0/List.c"
void *unwind_List(void *v ) 
{ 
  ListType *root ;

  {
#line 173
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 174
    return ((void *)0);
  }
#line 176
  root = (ListType *)v;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! ((unsigned long )root->next != (unsigned long )((void *)0))) {
#line 178
      goto while_break;
    }
#line 179
    root = root->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return ((void *)root);
}
}
#line 186 "/home/wheatley/newnew/temp/pconsole-1.0/List.c"
void *sort_List(void *v , int (*sort_func)(void * , void * ) ) 
{ 
  ListType *root ;
  ListType *p ;
  ListType **arr ;
  int count ;
  int i ;
  void *tmp ;

  {
#line 190
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 191
    return ((void *)0);
  }
#line 193
  root = (ListType *)v;
#line 194
  if ((unsigned long )sort_func == (unsigned long )((void *)0)) {
#line 195
    return ((void *)root);
  }
#line 197
  count = 0;
#line 198
  p = root;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 198
      goto while_break;
    }
#line 199
    count ++;
#line 198
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  if (count <= 1) {
#line 202
    return ((void *)root);
  }
  {
#line 204
  tmp = malloc((unsigned long )count * sizeof(ListType *));
#line 204
  arr = (ListType **)tmp;
  }
#line 204
  if ((unsigned long )arr == (unsigned long )((void *)0)) {
#line 205
    return ((void *)root);
  }
#line 208
  p = root;
#line 209
  i = 0;
  {
#line 209
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 209
    if (! (i < count)) {
#line 209
      goto while_break___0;
    }
#line 210
    *(arr + i) = p;
#line 211
    p = p->next;
#line 209
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 214
  qsort((void *)arr, (size_t )count, sizeof(ListType *), (int (*)(void const   * ,
                                                                  void const   * ))sort_func);
#line 217
  (*(arr + 0))->prev = (ListType *)((void *)0);
#line 218
  (*(arr + 0))->next = *(arr + 1);
#line 220
  i = 1;
  }
  {
#line 220
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 220
    if (! (i < count - 1)) {
#line 220
      goto while_break___1;
    }
#line 221
    (*(arr + i))->prev = *(arr + (i - 1));
#line 222
    (*(arr + i))->next = *(arr + (i + 1));
#line 220
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 224
  (*(arr + i))->prev = *(arr + (i - 1));
#line 225
  (*(arr + i))->next = (ListType *)((void *)0);
#line 228
  root = *(arr + 0);
#line 229
  free((void *)arr);
  }
#line 230
  return ((void *)root);
}
}
