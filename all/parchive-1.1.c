/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 14 "/home/wheatley/newnew/temp/parchive-1.1/types.h"
typedef unsigned short u16;
#line 16 "/home/wheatley/newnew/temp/parchive-1.1/types.h"
typedef long long i64;
#line 51 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
struct cmds {
   char *str ;
   int cmd ;
};
#line 13 "/home/wheatley/newnew/temp/parchive-1.1/types.h"
typedef unsigned char u8;
#line 15 "/home/wheatley/newnew/temp/parchive-1.1/types.h"
typedef unsigned int u32;
#line 17 "/home/wheatley/newnew/temp/parchive-1.1/types.h"
typedef u8 md5[16];
#line 19
struct par_s;
#line 19 "/home/wheatley/newnew/temp/parchive-1.1/types.h"
typedef struct par_s par_t;
#line 21
struct pfile_entr_s;
#line 21 "/home/wheatley/newnew/temp/parchive-1.1/types.h"
typedef struct pfile_entr_s pfile_entr_t;
#line 22
struct pfile_s;
#line 22 "/home/wheatley/newnew/temp/parchive-1.1/types.h"
typedef struct pfile_s pfile_t;
#line 23
struct hfile_s;
#line 23 "/home/wheatley/newnew/temp/parchive-1.1/types.h"
typedef struct hfile_s hfile_t;
#line 24
struct sub_s;
#line 24 "/home/wheatley/newnew/temp/parchive-1.1/types.h"
typedef struct sub_s sub_t;
#line 26
struct file_s;
#line 26 "/home/wheatley/newnew/temp/parchive-1.1/types.h"
typedef struct file_s *file_t;
#line 17 "/home/wheatley/newnew/temp/parchive-1.1/par.h"
struct par_s {
   i64 magic ;
   u32 version ;
   u32 client ;
   md5 control_hash ;
   md5 set_hash ;
   i64 vol_number ;
   i64 num_files ;
   i64 file_list ;
   i64 file_list_size ;
   i64 data ;
   i64 data_size ;
   i64 control_hash_offset ;
   pfile_t *files ;
   pfile_t *volumes ;
   u16 *filename ;
   u16 *comment ;
   file_t f ;
};
#line 38 "/home/wheatley/newnew/temp/parchive-1.1/par.h"
struct pfile_entr_s {
   i64 size ;
   i64 status ;
   i64 file_size ;
   md5 hash ;
   md5 hash_16k ;
   u16 filename[1] ;
};
#line 47 "/home/wheatley/newnew/temp/parchive-1.1/par.h"
struct pfile_s {
   pfile_t *next ;
   i64 status ;
   i64 file_size ;
   md5 hash_16k ;
   md5 hash ;
   i64 vol_number ;
   u16 *filename ;
   file_t f ;
   hfile_t *match ;
   u16 *fnrs ;
};
#line 60 "/home/wheatley/newnew/temp/parchive-1.1/par.h"
struct cmdline {
   int action ;
   int loglevel ;
   int volumes ;
   int pervol : 1 ;
   int plus : 1 ;
   int move : 1 ;
   int fix : 1 ;
   int usecase : 1 ;
   int dupl : 1 ;
   int add : 1 ;
   int pxx : 1 ;
   int ctrl : 1 ;
   int keep : 1 ;
   int smart : 1 ;
   int dash : 1 ;
};
#line 20 "/home/wheatley/newnew/temp/parchive-1.1/fileops.h"
struct hfile_s {
   hfile_t *next ;
   md5 hash_16k ;
   md5 hash ;
   i64 file_size ;
   i64 magic ;
   u16 *filename ;
   char *dir ;
   u8 hashed ;
};
#line 31 "/home/wheatley/newnew/temp/parchive-1.1/fileops.h"
struct file_s {
   file_t next ;
   FILE *f ;
   char *name ;
   i64 off ;
   i64 s_off ;
   int wr ;
};
#line 15 "/home/wheatley/newnew/temp/parchive-1.1/rs.h"
struct xfile_s;
#line 15 "/home/wheatley/newnew/temp/parchive-1.1/rs.h"
typedef struct xfile_s xfile_t;
#line 17 "/home/wheatley/newnew/temp/parchive-1.1/rs.h"
struct xfile_s {
   i64 size ;
   file_t f ;
   u16 filenr ;
   u16 *files ;
};
#line 17 "/home/wheatley/newnew/temp/parchive-1.1/backend.h"
struct sub_s {
   sub_t *next ;
   int off ;
   u16 *fs ;
   int fl ;
   u16 *ts ;
   int tl ;
};
#line 36 "/home/wheatley/newnew/temp/parchive-1.1/md5.h"
struct md5_ctx {
   u32 A ;
   u32 B ;
   u32 C ;
   u32 D ;
   u32 total[2] ;
   u32 buflen ;
   char buffer[128] ;
};
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 538
extern int getchar(void) ;
#line 580
extern int putchar(int __c ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 38 "/home/wheatley/newnew/temp/parchive-1.1/interface.h"
int par_flags(void) ;
#line 43
int par_setflags(int flags ) ;
#line 48
int par_unsetflags(int flags ) ;
#line 53
int par_load(u16 *filename ) ;
#line 58
int par_search(int partial ) ;
#line 63
int par_unload(u16 *entry ) ;
#line 70
u16 **par_parlist(void) ;
#line 77
u16 **par_filelist(void) ;
#line 82
int par_check(u16 *entry ) ;
#line 89
u16 *par_find(u16 *entry ) ;
#line 94
int par_fixname(u16 *entry ) ;
#line 100
i64 par_getstatus(u16 *entry ) ;
#line 105
int par_setstatus(u16 *entry , i64 status ) ;
#line 110
int par_recover(u16 *entry ) ;
#line 115
int par_addfile(u16 *filename ) ;
#line 120
int par_removefile(u16 *entry ) ;
#line 125
int par_addpars(u16 *entry , int number ) ;
#line 130
int par_create(u16 *entry ) ;
#line 136
u16 **par_dirlist(void) ;
#line 143
int par_setsmart(u16 *from , u16 *to ) ;
#line 20 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static u16 **parlist  =    (u16 **)0;
#line 21 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static u16 **filelist  =    (u16 **)0;
#line 22 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static u16 **dirlist  =    (u16 **)0;
#line 51 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static struct cmds cmds[22]  = 
#line 51
  {      {(char *)"FLAGS", 0}, 
        {(char *)"SETFLAGS", 1}, 
        {(char *)"UNSETFLAGS", 2}, 
        {(char *)"LOAD", 3}, 
        {(char *)"SEARCH", 4}, 
        {(char *)"UNLOAD", 5}, 
        {(char *)"PARLIST", 6}, 
        {(char *)"FILELIST", 7}, 
        {(char *)"DIRLIST", 8}, 
        {(char *)"CHECK", 9}, 
        {(char *)"FIND", 10}, 
        {(char *)"FIXNAME", 11}, 
        {(char *)"GETSTATUS", 12}, 
        {(char *)"SETSTATUS", 13}, 
        {(char *)"RECOVER", 14}, 
        {(char *)"ADDFILE", 15}, 
        {(char *)"REMOVEFILE", 16}, 
        {(char *)"ADDPARS", 17}, 
        {(char *)"CREATE", 18}, 
        {(char *)"SETSMART", 19}, 
        {(char *)"HELP", 20}, 
        {(char *)"QUIT", 21}};
#line 81 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static void print_help(void) 
{ 


  {
  {
#line 84
  printf((char const   */* __restrict  */)"FLAGS              : Show the current flags (with numbers).\nSETFLAGS <n>       : Set flag number <n>.\nUNSETFLAGS <n>     : Unset flag number <n>.\nSETSMART [<entry> <name>] : Setup handling of consistently misnamed files.\nLOAD <filename>    : Add a (new) PAR file to the current list.\nSEARCH             : Search for PAR files matching the current filelist.\nUNLOAD <entry>     : Remove a PAR file from the list.\nPARLIST            : Show the current list of PAR files.\nFILELIST           : Show the current list of data files.\nDIRLIST            : Show the currently cached directory entries.\nCHECK <entry>      : Check the MD5sum of a file.\nFIND <entry>       : Find a file by its filename.\nFIXNAME [<entry>]  : Fix faulty filenames [of <entry>].\nGETSTATUS <entry>  : Get the status bits of an entry.\nSETSTATUS <entry> <status> : Set the status bits of an entry.\nRECOVER [<entry>]  : Recover missing files [only <entry>]\nADDFILE <filename> : Add a data file to the current filelist.\nREMOVEFILE <entry> : Remove a data file from the current filelist.\nADDPARS <number>   : Add new PAR files until there are <number>.\nCREATE [<entry>]   : Create PAR files [only <entry>].\nHELP               : Show this help.\nQUIT               : Quit.\n");
  }
#line 108
  return;
}
}
#line 110 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static int cc  =    '\n';
#line 114 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static void sort_cmds(void) 
{ 
  int i ;
  int j ;
  int k ;
  struct cmds tmp ;
  int tmp___0 ;

  {
#line 119
  k = (int )(sizeof(cmds) / sizeof(cmds[0]) - 1UL);
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    j = 0;
#line 121
    i = j;
    {
#line 121
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 121
      if (! (i < k)) {
#line 121
        goto while_break___0;
      }
      {
#line 122
      tmp___0 = strcmp((char const   *)cmds[i].str, (char const   *)cmds[i + 1].str);
      }
#line 122
      if (tmp___0 > 0) {
#line 124
        tmp = cmds[i + 1];
#line 125
        cmds[i + 1] = cmds[i];
#line 126
        cmds[i] = tmp;
#line 127
        j = i;
      }
#line 121
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 130
    k = j;
#line 120
    if (! (k > 0)) {
#line 120
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return;
}
}
#line 134 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static int get_cmd(void) 
{ 
  struct cmds *l ;
  struct cmds *r ;
  int c ;
  int idx ;
  unsigned short const   **tmp ;

  {
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 142
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 142
      if (cc == 10) {
#line 142
        goto while_break___0;
      } else
#line 142
      if (cc == -1) {
#line 142
        goto while_break___0;
      }
      {
#line 143
      cc = getchar();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 145
    if (cc == -1) {
#line 146
      return (21);
    }
    {
#line 148
    putchar('>');
#line 148
    fflush(stdout);
#line 150
    l = cmds;
#line 151
    r = (cmds + sizeof(cmds) / sizeof(cmds[0])) - 1;
#line 152
    idx = 0;
    }
    {
#line 152
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 153
      cc = getchar();
#line 154
      tmp = __ctype_b_loc();
      }
#line 154
      if (! ((int const   )*(*tmp + cc) & 8)) {
#line 155
        goto while_break___1;
      }
      {
#line 156
      c = toupper(cc);
      }
      {
#line 157
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 157
        if (! (c > (int )*(l->str + idx))) {
#line 157
          goto while_break___2;
        }
#line 158
        l ++;
#line 158
        if ((unsigned long )l > (unsigned long )r) {
#line 159
          return (22);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 160
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 160
        if (! (c < (int )*(r->str + idx))) {
#line 160
          goto while_break___3;
        }
#line 161
        r --;
#line 161
        if ((unsigned long )r < (unsigned long )l) {
#line 162
          return (22);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 152
      idx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 141
    if (! (idx == 0)) {
#line 141
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  if ((unsigned long )r > (unsigned long )l) {
#line 166
    return (23);
  }
#line 167
  return (l->cmd);
}
}
#line 170 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static int bufidx  =    0;
#line 175
static u16 *buf_add(u16 c ) ;
#line 175 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static u16 *buf  =    (u16 *)0;
#line 176 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static int bufsz  =    0;
#line 172 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static u16 *buf_add(u16 c ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 178
  if (bufidx >= bufsz) {
    {
#line 179
    bufsz += 256;
#line 180
    tmp = realloc((void *)buf, (unsigned long )bufsz * sizeof(*buf));
#line 180
    buf = (u16 *)tmp;
    }
  }
#line 182
  tmp___0 = bufidx;
#line 182
  bufidx ++;
#line 182
  *(buf + tmp___0) = c;
#line 183
  return (buf);
}
}
#line 186 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static u16 *get_str(void) 
{ 
  u16 *tmp ;
  unsigned short const   **tmp___0 ;
  u16 *tmp___1 ;

  {
#line 189
  bufidx = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 190
    tmp___0 = __ctype_b_loc();
    }
#line 190
    if (! ((int const   )*(*tmp___0 + cc) & 8192)) {
#line 190
      goto while_break;
    }
#line 191
    if (cc == 10) {
      {
#line 192
      tmp = buf_add((u16 )0);
      }
#line 192
      return (tmp);
    } else
#line 191
    if (cc == -1) {
      {
#line 192
      tmp = buf_add((u16 )0);
      }
#line 192
      return (tmp);
    }
    {
#line 193
    cc = getchar();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 196
    buf_add((u16 )cc);
#line 197
    cc = getchar();
    }
#line 195
    if (cc == 10) {
#line 195
      goto while_break___0;
    } else
#line 195
    if (cc == -1) {
#line 195
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 199
  tmp___1 = buf_add((u16 )0);
  }
#line 199
  return (tmp___1);
}
}
#line 202 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static i64 get_number(void) 
{ 
  i64 ret___0 ;
  int base ;
  unsigned short const   **tmp ;
  int c ;

  {
#line 206
  base = 10;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 208
    tmp = __ctype_b_loc();
    }
#line 208
    if (! ((int const   )*(*tmp + cc) & 8192)) {
#line 208
      goto while_break;
    }
#line 209
    if (cc == 10) {
#line 210
      return ((i64 )0);
    } else
#line 209
    if (cc == -1) {
#line 210
      return ((i64 )0);
    }
    {
#line 211
    cc = getchar();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  ret___0 = (i64 )0;
#line 214
  if (cc == 48) {
    {
#line 215
    base = 8;
#line 216
    cc = getchar();
    }
  }
#line 218
  if (cc == 120) {
    {
#line 219
    base = 16;
#line 220
    cc = getchar();
    }
  } else
#line 218
  if (cc == 88) {
    {
#line 219
    base = 16;
#line 220
    cc = getchar();
    }
  } else
#line 218
  if (cc == 36) {
    {
#line 219
    base = 16;
#line 220
    cc = getchar();
    }
  }
  {
#line 222
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 225
    c = toupper(cc);
    }
#line 226
    if (c >= 97) {
#line 226
      c -= 97;
    } else {
#line 227
      c -= 48;
    }
#line 228
    if (c < 0) {
#line 228
      return (ret___0);
    } else
#line 228
    if (c >= base) {
#line 228
      return (ret___0);
    }
    {
#line 229
    ret___0 = ret___0 * (i64 )base + (i64 )c;
#line 230
    cc = getchar();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 234 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static u16 *get_entry(u16 **list ) 
{ 
  i64 num ;
  i64 i ;

  {
  {
#line 239
  i = get_number();
  }
#line 240
  if (! list) {
#line 240
    return ((u16 *)0);
  }
#line 241
  num = (i64 )0;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! *(list + num)) {
#line 241
      goto while_break;
    }
#line 241
    num ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  if (i < 0LL) {
#line 244
    i = (i64 )0;
  } else
#line 243
  if (i > num) {
#line 244
    i = (i64 )0;
  }
#line 245
  if (i == 0LL) {
#line 245
    return ((u16 *)0);
  }
#line 246
  return (*(list + (i - 1LL)));
}
}
#line 252
static void print_errcode(int code ) ;
#line 252 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static char *err_list[10]  = 
#line 252
  {      (char *)"OK",      (char *)"ERROR: File error",      (char *)"ERROR: Does not exist",      (char *)"ERROR: Not found", 
        (char *)"ERROR: Corrupt",      (char *)"ERROR: Failed",      (char *)"ERROR: Already loaded",      (char *)"ERROR: Not Implemented", 
        (char *)"ERROR: Name Clash",      (char *)"ERROR: Invalid Argument"};
#line 249 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static void print_errcode(int code ) 
{ 


  {
  {
#line 264
  printf((char const   */* __restrict  */)"%s\n", err_list[code]);
  }
#line 265
  return;
}
}
#line 270
static void print_flags(int flags ) ;
#line 270 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static char *flag_list[4]  = {      (char *)"MOVE",      (char *)"CASE",      (char *)"CTRL",      (char *)"KEEP"};
#line 267 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static void print_flags(int flags ) 
{ 
  unsigned int i ;

  {
#line 278
  i = 0U;
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! ((unsigned long )i < sizeof(flag_list) / sizeof(flag_list[0]))) {
#line 278
      goto while_break;
    }
#line 280
    if (i > 0U) {
      {
#line 280
      printf((char const   */* __restrict  */)", ");
      }
    }
#line 281
    if (! (flags & (1 << i))) {
      {
#line 281
      printf((char const   */* __restrict  */)"NO");
      }
    }
    {
#line 282
    printf((char const   */* __restrict  */)"%s(%d)", flag_list[i], 1 << i);
#line 278
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  printf((char const   */* __restrict  */)"\n");
  }
#line 285
  return;
}
}
#line 287 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static void print_string(u16 *str ) 
{ 
  u16 *tmp ;

  {
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! *str) {
#line 290
      goto while_break;
    }
    {
#line 291
    tmp = str;
#line 291
    str ++;
#line 291
    putchar((int )*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 292
  putchar('\n');
  }
#line 293
  return;
}
}
#line 295 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static void print_number(i64 num ) 
{ 


  {
  {
#line 298
  printf((char const   */* __restrict  */)"0x%llx\n", num);
  }
#line 299
  return;
}
}
#line 301 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
static void print_list(u16 **list ) 
{ 
  int i ;

  {
#line 306
  i = 1;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! *list) {
#line 306
      goto while_break;
    }
    {
#line 307
    printf((char const   */* __restrict  */)"%3d: ", i);
#line 308
    print_string(*list);
#line 306
    list ++;
#line 306
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  return;
}
}
#line 313 "/home/wheatley/newnew/temp/parchive-1.1/ui_text.c"
void ui_text(void) 
{ 
  u16 *e ;
  int tmp ;
  int tmp___0 ;
  i64 tmp___1 ;
  int tmp___2 ;
  i64 tmp___3 ;
  int tmp___4 ;
  u16 *tmp___5 ;
  int tmp___6 ;
  i64 tmp___7 ;
  int tmp___8 ;
  u16 *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int i ;
  int tmp___12 ;
  u16 *tmp___13 ;
  int i___0 ;
  u16 *tmp___14 ;
  u16 *tmp___15 ;
  int tmp___16 ;
  u16 *tmp___17 ;
  i64 tmp___18 ;
  i64 tmp___19 ;
  int tmp___20 ;
  u16 *tmp___21 ;
  int tmp___22 ;
  u16 *tmp___23 ;
  int tmp___24 ;
  u16 *tmp___25 ;
  int tmp___26 ;
  i64 tmp___27 ;
  int tmp___28 ;
  u16 *tmp___29 ;
  int tmp___30 ;
  u16 *tmp___31 ;
  u16 *tmp___32 ;
  int tmp___33 ;

  {
  {
#line 318
  sort_cmds();
#line 319
  cc = '\n';
  }
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 321
    tmp = get_cmd();
    }
    {
#line 322
    if (tmp == 0) {
#line 322
      goto case_0;
    }
#line 325
    if (tmp == 1) {
#line 325
      goto case_1;
    }
#line 328
    if (tmp == 2) {
#line 328
      goto case_2;
    }
#line 331
    if (tmp == 3) {
#line 331
      goto case_3;
    }
#line 334
    if (tmp == 4) {
#line 334
      goto case_4;
    }
#line 337
    if (tmp == 5) {
#line 337
      goto case_5;
    }
#line 340
    if (tmp == 6) {
#line 340
      goto case_6;
    }
#line 345
    if (tmp == 7) {
#line 345
      goto case_7;
    }
#line 350
    if (tmp == 8) {
#line 350
      goto case_8;
    }
#line 355
    if (tmp == 9) {
#line 355
      goto case_9;
    }
#line 370
    if (tmp == 10) {
#line 370
      goto case_10;
    }
#line 385
    if (tmp == 11) {
#line 385
      goto case_11;
    }
#line 388
    if (tmp == 12) {
#line 388
      goto case_12;
    }
#line 391
    if (tmp == 13) {
#line 391
      goto case_13;
    }
#line 395
    if (tmp == 14) {
#line 395
      goto case_14;
    }
#line 398
    if (tmp == 15) {
#line 398
      goto case_15;
    }
#line 401
    if (tmp == 16) {
#line 401
      goto case_16;
    }
#line 404
    if (tmp == 17) {
#line 404
      goto case_17;
    }
#line 408
    if (tmp == 18) {
#line 408
      goto case_18;
    }
#line 411
    if (tmp == 19) {
#line 411
      goto case_19;
    }
#line 415
    if (tmp == 21) {
#line 415
      goto case_21;
    }
#line 417
    if (tmp == 20) {
#line 417
      goto case_20;
    }
#line 420
    if (tmp == 23) {
#line 420
      goto case_23;
    }
#line 423
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 323
    tmp___0 = par_flags();
#line 323
    print_flags(tmp___0);
    }
#line 324
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 326
    tmp___1 = get_number();
#line 326
    tmp___2 = par_setflags((int )tmp___1);
#line 326
    print_flags(tmp___2);
    }
#line 327
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 329
    tmp___3 = get_number();
#line 329
    tmp___4 = par_unsetflags((int )tmp___3);
#line 329
    print_flags(tmp___4);
    }
#line 330
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 332
    tmp___5 = get_str();
#line 332
    tmp___6 = par_load(tmp___5);
#line 332
    print_errcode(tmp___6);
    }
#line 333
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 335
    tmp___7 = get_number();
#line 335
    tmp___8 = par_search((int )tmp___7);
#line 335
    print_errcode(tmp___8);
    }
#line 336
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 338
    tmp___9 = get_entry(parlist);
#line 338
    tmp___10 = par_unload(tmp___9);
#line 338
    print_errcode(tmp___10);
    }
#line 339
    goto switch_break;
    case_6: /* CIL Label */ 
#line 341
    if (parlist) {
      {
#line 341
      free((void *)parlist);
      }
    }
    {
#line 342
    parlist = par_parlist();
#line 343
    print_list(parlist);
    }
#line 344
    goto switch_break;
    case_7: /* CIL Label */ 
#line 346
    if (filelist) {
      {
#line 346
      free((void *)filelist);
      }
    }
    {
#line 347
    filelist = par_filelist();
#line 348
    print_list(filelist);
    }
#line 349
    goto switch_break;
    case_8: /* CIL Label */ 
#line 351
    if (dirlist) {
      {
#line 351
      free((void *)dirlist);
      }
    }
    {
#line 352
    dirlist = par_dirlist();
#line 353
    print_list(dirlist);
    }
#line 354
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 356
    e = get_entry(filelist);
    }
#line 357
    if (e) {
      {
#line 358
      tmp___11 = par_check(e);
#line 358
      print_errcode(tmp___11);
      }
    } else
#line 359
    if (filelist) {
#line 361
      i = 0;
      {
#line 361
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 361
        if (! *(filelist + i)) {
#line 361
          goto while_break___0;
        }
        {
#line 362
        printf((char const   */* __restrict  */)"CHECK ");
#line 363
        print_string(*(filelist + i));
#line 364
        tmp___12 = par_check(*(filelist + i));
#line 364
        print_errcode(tmp___12);
#line 361
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 367
      printf((char const   */* __restrict  */)"ERROR: No filelist.\n");
      }
    }
#line 369
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 371
    e = get_entry(filelist);
    }
#line 372
    if (e) {
      {
#line 373
      tmp___13 = par_find(e);
#line 373
      print_string(tmp___13);
      }
    } else
#line 374
    if (filelist) {
#line 376
      i___0 = 0;
      {
#line 376
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 376
        if (! *(filelist + i___0)) {
#line 376
          goto while_break___1;
        }
        {
#line 377
        printf((char const   */* __restrict  */)"FIND ");
#line 378
        print_string(*(filelist + i___0));
#line 379
        tmp___14 = par_find(*(filelist + i___0));
#line 379
        print_string(tmp___14);
#line 376
        i___0 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 382
      printf((char const   */* __restrict  */)"ERROR: No filelist.\n");
      }
    }
#line 384
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 386
    tmp___15 = get_entry(filelist);
#line 386
    tmp___16 = par_fixname(tmp___15);
#line 386
    print_errcode(tmp___16);
    }
#line 387
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 389
    tmp___17 = get_entry(filelist);
#line 389
    tmp___18 = par_getstatus(tmp___17);
#line 389
    print_number(tmp___18);
    }
#line 390
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 392
    e = get_entry(filelist);
#line 393
    tmp___19 = get_number();
#line 393
    tmp___20 = par_setstatus(e, tmp___19);
#line 393
    print_errcode(tmp___20);
    }
#line 394
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 396
    tmp___21 = get_entry(filelist);
#line 396
    tmp___22 = par_recover(tmp___21);
#line 396
    print_errcode(tmp___22);
    }
#line 397
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 399
    tmp___23 = get_str();
#line 399
    tmp___24 = par_addfile(tmp___23);
#line 399
    print_errcode(tmp___24);
    }
#line 400
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 402
    tmp___25 = get_entry(filelist);
#line 402
    tmp___26 = par_removefile(tmp___25);
#line 402
    print_errcode(tmp___26);
    }
#line 403
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 405
    e = get_entry(parlist);
#line 406
    tmp___27 = get_number();
#line 406
    tmp___28 = par_addpars(e, (int )tmp___27);
#line 406
    print_errcode(tmp___28);
    }
#line 407
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 409
    tmp___29 = get_entry(parlist);
#line 409
    tmp___30 = par_create(tmp___29);
#line 409
    print_errcode(tmp___30);
    }
#line 410
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 412
    e = get_entry(filelist);
    }
#line 413
    if (e) {
      {
#line 413
      tmp___31 = get_str();
#line 413
      tmp___32 = tmp___31;
      }
    } else {
#line 413
      tmp___32 = (u16 *)0;
    }
    {
#line 413
    tmp___33 = par_setsmart(e, tmp___32);
#line 413
    print_errcode(tmp___33);
    }
#line 414
    goto switch_break;
    case_21: /* CIL Label */ 
#line 416
    return;
    case_20: /* CIL Label */ 
    {
#line 418
    print_help();
    }
#line 419
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 421
    printf((char const   */* __restrict  */)"Ambiguous command.\n");
    }
#line 422
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 424
    printf((char const   */* __restrict  */)"Unknown command.\n");
    }
#line 425
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 60 "/home/wheatley/newnew/temp/parchive-1.1/par.h"
struct cmdline cmd ;
#line 17 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.h"
par_t *create_par_header(u16 *file , i64 vol ) ;
#line 18
par_t *read_par_header(u16 *file , int create , i64 vol , int silent ) ;
#line 19
void free_file_list(pfile_t *list ) ;
#line 20
void free_par(par_t *par ) ;
#line 21
file_t write_par_header(par_t *par ) ;
#line 22
int restore_files(pfile_t *files___0 , pfile_t *volumes___0 , sub_t *sub___0 ) ;
#line 24
void dump_par(par_t *par ) ;
#line 43 "/home/wheatley/newnew/temp/parchive-1.1/fileops.h"
u16 *make_uni_str(char const   *str ) ;
#line 44
char *stuni(u16 const   *str ) ;
#line 46
char *stmd5(u8 * const  hash ) ;
#line 48
u16 *unicode_copy(u16 *str ) ;
#line 50
file_t file_open(u16 const   *path , int wr ) ;
#line 52
int file_close(file_t f ) ;
#line 54
int file_delete(u16 *file ) ;
#line 55
int file_seek(file_t f , i64 off ) ;
#line 58
int file_add_md5(file_t f , i64 md5off , i64 off , i64 len ) ;
#line 60
char *complete_path(char *path ) ;
#line 62
i64 file_read(file_t f , void *buf___3 , i64 n ) ;
#line 63
i64 file_write(file_t f , void *buf___3 , i64 n ) ;
#line 24 "/home/wheatley/newnew/temp/parchive-1.1/rs.h"
int recreate(xfile_t *in , xfile_t *out ) ;
#line 15 "/home/wheatley/newnew/temp/parchive-1.1/readoldpar.h"
int is_old_par(void *data ) ;
#line 16
par_t *read_old_par(file_t f , u16 *file , int silent ) ;
#line 99 "/home/wheatley/newnew/temp/parchive-1.1/md5.h"
void *md5_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 26 "/home/wheatley/newnew/temp/parchive-1.1/backend.h"
char *basename(u16 *path ) ;
#line 29
hfile_t *hfile_add(u16 *filename ) ;
#line 30
void hash_directory(char *dir ) ;
#line 31
int hash_file(hfile_t *file , char type ) ;
#line 32
int find_file(pfile_t *file , int displ ) ;
#line 35
int move_away(u16 *file , u8 const   *ext ) ;
#line 41
int par_control_check(par_t *par ) ;
#line 44
u16 *do_sub(u16 *from , sub_t *sub___0 ) ;
#line 27 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static i64 read_i64(void *data ) 
{ 
  int i ;
  i64 r ;
  u8 *ptr ;

  {
#line 31
  r = (i64 )0;
#line 32
  ptr = (u8 *)data;
#line 34
  i = (int )sizeof(i64 );
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    i --;
#line 34
    if (! (i >= 0)) {
#line 34
      goto while_break;
    }
#line 35
    r <<= 8;
#line 36
    r += (i64 )*(ptr + i);
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return (r);
}
}
#line 41 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static u32 read_u32(void *data ) 
{ 
  int i ;
  u32 r ;
  u8 *ptr ;

  {
#line 45
  r = (u32 )0;
#line 46
  ptr = (u8 *)data;
#line 48
  i = (int )sizeof(u32 );
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    i --;
#line 48
    if (! (i >= 0)) {
#line 48
      goto while_break;
    }
#line 49
    r <<= 8;
#line 50
    r += (u32 )*(ptr + i);
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (r);
}
}
#line 56 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static void read_u16s(u16 *str , void *data , i64 n ) 
{ 
  u8 *ptr ;

  {
#line 59
  ptr = (u8 *)data;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    n --;
#line 60
    if (! (n >= 0LL)) {
#line 60
      goto while_break;
    }
#line 61
    *str = (u16 )((int )*(ptr + 0) + ((int )*(ptr + 1) << 8));
#line 62
    str ++;
#line 63
    ptr += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static void write_i64(i64 v , void *data ) 
{ 
  size_t i ;
  u8 *ptr ;

  {
#line 71
  ptr = (u8 *)data;
#line 73
  i = (size_t )0;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (i < sizeof(i64 ))) {
#line 73
      goto while_break;
    }
#line 74
    *(ptr + i) = (u8 )(v & 255LL);
#line 75
    v >>= 8;
#line 73
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return;
}
}
#line 79 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static void write_u32(u32 v , void *data ) 
{ 
  size_t i ;
  u8 *ptr ;

  {
#line 83
  ptr = (u8 *)data;
#line 85
  i = (size_t )0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < sizeof(u32 ))) {
#line 85
      goto while_break;
    }
#line 86
    *(ptr + i) = (u8 )(v & 255U);
#line 87
    v >>= 8;
#line 85
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static void write_u16s(u16 *str , void *data , i64 n ) 
{ 
  u8 *ptr ;

  {
#line 95
  ptr = (u8 *)data;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    n --;
#line 96
    if (! (n >= 0LL)) {
#line 96
      goto while_break;
    }
#line 97
    *(ptr + 0) = (u8 )((int )*str & 255);
#line 98
    *(ptr + 1) = (u8 )(((int )*str >> 8) & 255);
#line 99
    str ++;
#line 100
    ptr += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return;
}
}
#line 107 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static void par_endian_read(par_t *par ) 
{ 


  {
  {
#line 110
  par->version = read_u32((void *)(& par->version));
#line 111
  par->client = read_u32((void *)(& par->client));
#line 112
  par->vol_number = read_i64((void *)(& par->vol_number));
#line 113
  par->num_files = read_i64((void *)(& par->num_files));
#line 114
  par->file_list = read_i64((void *)(& par->file_list));
#line 115
  par->file_list_size = read_i64((void *)(& par->file_list_size));
#line 116
  par->data = read_i64((void *)(& par->data));
#line 117
  par->data_size = read_i64((void *)(& par->data_size));
  }
#line 118
  return;
}
}
#line 120 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static void par_endian_write(par_t *par , void *data ) 
{ 
  par_t *p ;

  {
  {
#line 123
  p = (par_t *)data;
#line 124
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)par, (size_t )96);
#line 125
  write_u32(par->version, (void *)(& p->version));
#line 126
  write_u32(par->client, (void *)(& p->client));
#line 127
  write_i64(par->vol_number, (void *)(& p->vol_number));
#line 128
  write_i64(par->num_files, (void *)(& p->num_files));
#line 129
  write_i64(par->file_list, (void *)(& p->file_list));
#line 130
  write_i64(par->file_list_size, (void *)(& p->file_list_size));
#line 131
  write_i64(par->data, (void *)(& p->data));
#line 132
  write_i64(par->data_size, (void *)(& p->data_size));
  }
#line 133
  return;
}
}
#line 135 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static u16 uni_empty[1]  = {      (u16 )0};
#line 137 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static i64 uni_sizeof(u16 *str ) 
{ 
  i64 l ;

  {
#line 141
  l = (i64 )0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! *(str + l)) {
#line 141
      goto while_break;
    }
#line 141
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return (2LL * l);
}
}
#line 150 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static u16 *uni_strip(u16 *str ) 
{ 
  u16 *ret___0 ;

  {
#line 155
  ret___0 = str;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! *str) {
#line 155
      goto while_break;
    }
#line 156
    if ((int )*str == 47) {
#line 157
      ret___0 = str + 1;
    }
#line 155
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (ret___0);
}
}
#line 164 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static void dump_file(pfile_t *file ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 167
  tmp = stmd5((u8 */* const  */)(file->hash));
#line 167
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    status: 0x%llx\n    file size: %lld\n    hash: %s\n",
          file->status, file->file_size, tmp);
#line 174
  tmp___0 = stmd5((u8 */* const  */)(file->hash_16k));
#line 174
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    16k hash: %s\n",
          tmp___0);
#line 177
  tmp___1 = stuni((u16 const   *)file->filename);
#line 177
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    filename: %s\n",
          tmp___1);
  }
#line 180
  return;
}
}
#line 182 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
void dump_par(par_t *par ) 
{ 
  pfile_t *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 187
  tmp = stmd5((u8 */* const  */)(par->control_hash));
#line 187
  tmp___0 = stuni((u16 const   *)par->filename);
#line 187
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PAR file dump:\n  filename: %s\n  version: 0x%04x\n  client: 0x%04x\n  control hash: %s\n",
          tmp___0, par->version, par->client, tmp);
#line 196
  tmp___1 = stmd5((u8 */* const  */)(par->set_hash));
#line 196
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  set hash: %s\n",
          tmp___1);
#line 199
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  volume number: %lld\n  number of files: %lld\n  file list: 0x%llx\n  file list size: 0x%llx\n  data: 0x%llx\n  data size: 0x%llx\n",
          par->vol_number, par->num_files, par->file_list, par->file_list_size, par->data,
          par->data_size);
  }
#line 212
  if (! par->vol_number) {
    {
#line 213
    tmp___2 = stuni((u16 const   *)par->comment);
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  comment: %s\n",
            tmp___2);
    }
  }
  {
#line 216
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nFiles:\n\n");
#line 217
  p = par->files;
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! p) {
#line 217
      goto while_break;
    }
    {
#line 218
    dump_file(p);
#line 217
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  return;
}
}
#line 224 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static i64 read_pfile(pfile_t *file , u8 *ptr , u16 *path , i64 pl ) 
{ 
  i64 i ;
  i64 l ;
  pfile_entr_t *pf ;
  void *tmp ;

  {
  {
#line 230
  pf = (pfile_entr_t *)ptr;
#line 232
  i = read_i64((void *)(& pf->size));
#line 233
  file->status = read_i64((void *)(& pf->status));
#line 234
  file->file_size = read_i64((void *)(& pf->file_size));
#line 240
  memmove((void *)(file->hash), (void const   *)(pf->hash), sizeof(md5 ));
#line 241
  memmove((void *)(file->hash_16k), (void const   *)(pf->hash_16k), sizeof(md5 ));
#line 242
  l = (i - 56LL) / 2LL;
#line 243
  tmp = malloc((size_t )((i64 )sizeof(*(file->filename)) * ((pl + l) + 1LL)));
#line 243
  file->filename = (u16 *)tmp;
#line 244
  memcpy((void */* __restrict  */)file->filename, (void const   */* __restrict  */)path,
         (size_t )(pl * (i64 )sizeof(*(file->filename))));
#line 245
  read_u16s(file->filename + pl, (void *)(& pf->filename), l);
#line 246
  *(file->filename + (l + pl)) = (u16 )0;
  }
#line 248
  return (i);
}
}
#line 254 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static pfile_t *read_pfiles(file_t f , i64 size , u16 *path ) 
{ 
  pfile_t *files___0 ;
  pfile_t **fptr ;
  u8 *buf___3 ;
  i64 i ;
  i64 pl ;
  void *tmp ;
  void *tmp___0 ;
  i64 tmp___1 ;

  {
#line 257
  files___0 = (pfile_t *)0;
#line 257
  fptr = & files___0;
#line 261
  i = (i64 )0;
#line 261
  pl = i;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! *(path + i)) {
#line 261
      goto while_break;
    }
#line 262
    if ((int )*(path + i) == 47) {
#line 263
      pl = i + 1LL;
    }
#line 261
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 265
  tmp = malloc((size_t )((i64 )sizeof(*buf___3) * size));
#line 265
  buf___3 = (u8 *)tmp;
#line 266
  size = file_read(f, (void *)buf___3, size);
#line 269
  i = (i64 )0;
  }
  {
#line 271
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 271
    if (! (i < size)) {
#line 271
      goto while_break___0;
    }
    {
#line 272
    tmp___0 = calloc(sizeof(*(*fptr)), (size_t )1);
#line 272
    *fptr = (pfile_t *)tmp___0;
#line 273
    tmp___1 = read_pfile(*fptr, buf___3 + i, path, pl);
#line 273
    i += tmp___1;
#line 274
    fptr = & (*fptr)->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 276
  free((void *)buf___3);
  }
#line 277
  return (files___0);
}
}
#line 283 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
par_t *create_par_header(u16 *file , i64 vol ) 
{ 
  par_t *par ;
  void *tmp ;

  {
  {
#line 288
  tmp = calloc(sizeof(*par), (size_t )1);
#line 288
  par = (par_t *)tmp;
#line 289
  par->magic = *((i64 *)"PAR\000\000\000\000\000");
#line 290
  par->version = (u32 )65536;
#line 291
  par->client = (u32 )33556736;
#line 292
  par->vol_number = vol;
#line 293
  par->filename = unicode_copy(file);
#line 294
  par->comment = uni_empty;
#line 295
  par->control_hash_offset = (i64 )32;
  }
#line 297
  return (par);
}
}
#line 304 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
par_t *read_par_header(u16 *file , int create , i64 vol , int silent ) 
{ 
  par_t par ;
  par_t *r ;
  char *path ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  u16 *p ;
  par_t *tmp___2 ;
  i64 tmp___3 ;
  par_t *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 310
  memset((void *)(& par), 0, sizeof(par));
#line 312
  tmp = stuni((u16 const   *)file);
#line 312
  hash_directory(tmp);
#line 313
  tmp___0 = stuni((u16 const   *)file);
#line 313
  path = complete_path(tmp___0);
#line 315
  par.f = file_open((u16 const   *)file, 0);
#line 317
  tmp___3 = file_read(par.f, (void *)(& par), (i64 )96);
  }
#line 317
  if (tmp___3 < 96LL) {
#line 318
    if (! create) {
#line 318
      goto _L;
    } else {
      {
#line 318
      tmp___1 = __errno_location();
      }
#line 318
      if (*tmp___1 != 2) {
        _L: /* CIL Label */ 
#line 319
        if (! silent) {
          {
#line 320
          perror("Error reading PAR file");
          }
        }
        {
#line 321
        file_close(par.f);
        }
#line 322
        return ((par_t *)0);
      }
    }
#line 324
    if (! vol) {
#line 327
      p = file;
      {
#line 327
      while (1) {
        while_continue: /* CIL Label */ ;
#line 327
        if (! *p) {
#line 327
          goto while_break;
        }
#line 327
        p ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 329
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 329
        p --;
#line 329
        if ((unsigned long )p >= (unsigned long )file) {
#line 329
          if ((int )*p >= 48) {
#line 329
            if (! ((int )*p <= 57)) {
#line 329
              goto while_break___0;
            }
          } else {
#line 329
            goto while_break___0;
          }
        } else {
#line 329
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 331
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 331
        p ++;
#line 331
        if (! *p) {
#line 331
          goto while_break___1;
        }
#line 332
        vol = vol * 10LL + (i64 )((int )*p - 48);
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 334
    tmp___2 = create_par_header(file, vol);
    }
#line 334
    return (tmp___2);
  }
#line 337
  if (! (par.magic == *((i64 *)"PAR\000\000\000\000\000"))) {
    {
#line 338
    tmp___6 = is_old_par((void *)(& par));
    }
#line 338
    if (tmp___6) {
      {
#line 339
      tmp___5 = file_seek(par.f, (i64 )0);
      }
#line 339
      if (tmp___5 >= 0) {
        {
#line 340
        tmp___4 = read_old_par(par.f, file, silent);
        }
#line 340
        return (tmp___4);
      }
    }
#line 341
    if (! silent) {
      {
#line 342
      tmp___7 = basename(file);
#line 342
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Not a PAR file\n",
              tmp___7);
      }
    }
    {
#line 343
    file_close(par.f);
    }
#line 344
    return ((par_t *)0);
  }
  {
#line 346
  par_endian_read(& par);
#line 348
  par.control_hash_offset = (i64 )32;
#line 349
  par.filename = file;
  }
#line 351
  if (! silent) {
    {
#line 351
    tmp___8 = par_control_check(& par);
    }
#line 351
    if (! tmp___8) {
      {
#line 352
      file_close(par.f);
      }
#line 353
      return ((par_t *)0);
    }
  }
  {
#line 356
  file_seek(par.f, par.file_list);
#line 358
  par.filename = make_uni_str((char const   *)path);
#line 361
  par.files = read_pfiles(par.f, par.file_list_size, par.filename);
#line 363
  file_seek(par.f, par.data);
  }
#line 365
  if (par.vol_number == 0LL) {
    {
#line 366
    tmp___9 = calloc(sizeof(*(par.comment)), (size_t )(par.data_size / 2LL + 1LL));
#line 366
    par.comment = (u16 *)tmp___9;
#line 367
    file_read(par.f, (void *)par.comment, par.data_size);
#line 368
    file_close(par.f);
#line 369
    par.f = (file_t )0;
    }
  }
  {
#line 372
  par.volumes = (pfile_t *)0;
#line 374
  tmp___10 = malloc(sizeof(*r));
#line 374
  r = (par_t *)tmp___10;
#line 375
  memcpy((void */* __restrict  */)r, (void const   */* __restrict  */)(& par), sizeof(*r));
  }
#line 376
  if (cmd.loglevel > 1) {
    {
#line 377
    dump_par(r);
    }
  }
#line 378
  return (r);
}
}
#line 381 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
void free_file_list(pfile_t *list ) 
{ 
  pfile_t *next ;

  {
  {
#line 386
  while (1) {
    while_continue: /* CIL Label */ ;
#line 386
    if (! list) {
#line 386
      goto while_break;
    }
#line 387
    if (list->f) {
      {
#line 387
      file_close(list->f);
      }
    }
#line 388
    if (list->fnrs) {
      {
#line 388
      free((void *)list->fnrs);
      }
    }
    {
#line 389
    next = list->next;
#line 390
    free((void *)list);
#line 391
    list = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 395 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
void free_par(par_t *par ) 
{ 


  {
  {
#line 398
  free_file_list(par->files);
#line 399
  free_file_list(par->volumes);
#line 400
  free((void *)par->filename);
  }
#line 401
  if (par->f) {
    {
#line 401
    file_close(par->f);
    }
  }
  {
#line 402
  free((void *)par);
  }
#line 403
  return;
}
}
#line 408 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static i64 write_pfile(pfile_t *file , pfile_entr_t *pf ) 
{ 
  u16 *name ;
  i64 i ;

  {
  {
#line 414
  name = uni_strip(file->filename);
#line 415
  i = uni_sizeof(name);
#line 417
  write_i64(56LL + i, (void *)(& pf->size));
#line 418
  write_i64(file->status, (void *)(& pf->status));
#line 419
  write_i64(file->file_size, (void *)(& pf->file_size));
#line 420
  memcpy((void */* __restrict  */)(pf->hash), (void const   */* __restrict  */)(file->hash),
         sizeof(md5 ) * sizeof(pf->hash[0]));
#line 421
  memcpy((void */* __restrict  */)(pf->hash_16k), (void const   */* __restrict  */)(file->hash_16k),
         sizeof(md5 ) * sizeof(pf->hash_16k[0]));
#line 422
  write_u16s(name, (void *)(& pf->filename), i / 2LL);
  }
#line 423
  return (56LL + i);
}
}
#line 429 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
static i64 write_file_entries(file_t f , pfile_t *files___0 ) 
{ 
  i64 tot ;
  i64 t ;
  i64 m ;
  pfile_t *p ;
  pfile_entr_t *pfe ;
  u16 *tmp ;
  i64 tmp___0 ;
  void *tmp___1 ;

  {
#line 436
  m = (i64 )0;
#line 436
  tot = m;
#line 437
  p = files___0;
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 437
    if (! p) {
#line 437
      goto while_break;
    }
    {
#line 438
    tmp = uni_strip(p->filename);
#line 438
    tmp___0 = uni_sizeof(tmp);
#line 438
    t = 56LL + tmp___0;
#line 439
    tot += t;
    }
#line 440
    if (m < t) {
#line 440
      m = t;
    }
#line 437
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  tmp___1 = malloc((size_t )m);
#line 442
  pfe = (pfile_entr_t *)tmp___1;
  }
#line 443
  if (f) {
#line 444
    p = files___0;
    {
#line 444
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 444
      if (! p) {
#line 444
        goto while_break___0;
      }
      {
#line 445
      t = write_pfile(p, pfe);
#line 446
      file_write(f, (void *)pfe, t);
#line 444
      p = p->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 449
  free((void *)pfe);
  }
#line 450
  return (tot);
}
}
#line 456 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
file_t write_par_header(par_t *par ) 
{ 
  file_t f ;
  par_t data ;
  pfile_t *p ;
  int i ;
  md5 *hashes ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 466
  tmp___0 = move_away(par->filename, (u8 const   *)".old");
  }
#line 466
  if (tmp___0) {
    {
#line 467
    tmp = basename(par->filename);
#line 467
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      WRITE ERROR: %s: ",
            tmp);
#line 469
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File exists\n");
    }
#line 470
    return ((file_t )0);
  }
  {
#line 472
  f = file_open((u16 const   *)par->filename, 1);
  }
#line 473
  if (! f) {
    {
#line 474
    tmp___1 = basename(par->filename);
#line 474
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      WRITE ERROR: %s: ",
            tmp___1);
#line 476
    perror("");
    }
#line 477
    return ((file_t )0);
  }
  {
#line 479
  par->file_list = (i64 )96;
#line 480
  par->file_list_size = write_file_entries((file_t )0, par->files);
#line 481
  par->data = par->file_list + par->file_list_size;
  }
#line 483
  if (par->vol_number == 0LL) {
    {
#line 484
    par->data_size = uni_sizeof(par->comment);
    }
  } else {
#line 486
    i = 0;
#line 486
    p = par->files;
    {
#line 486
    while (1) {
      while_continue: /* CIL Label */ ;
#line 486
      if (! p) {
#line 486
        goto while_break;
      }
#line 487
      if (par->data_size < p->file_size) {
#line 488
        par->data_size = p->file_size;
      }
#line 486
      p = p->next;
#line 486
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 492
  par->num_files = (i64 )0;
#line 493
  i = 0;
#line 493
  p = par->files;
  {
#line 493
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 493
    if (! p) {
#line 493
      goto while_break___0;
    }
#line 494
    (par->num_files) ++;
#line 495
    if (p->status & 1LL) {
#line 496
      i ++;
    }
#line 493
    p = p->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 498
  tmp___2 = malloc(sizeof(*hashes) * (unsigned long )i);
#line 498
  hashes = (md5 *)tmp___2;
#line 499
  i = 0;
#line 499
  p = par->files;
  }
  {
#line 499
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 499
    if (! p) {
#line 499
      goto while_break___1;
    }
#line 500
    if (! (p->status & 1LL)) {
#line 501
      goto __Cont;
    }
    {
#line 502
    memcpy((void */* __restrict  */)(*(hashes + i)), (void const   */* __restrict  */)(p->hash),
           sizeof(md5 ) * sizeof((*(hashes + i))[0]));
#line 503
    i ++;
    }
    __Cont: /* CIL Label */ 
#line 499
    p = p->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 505
  md5_buffer((char const   *)((char *)hashes), (unsigned long )i * sizeof(md5 ), (void *)(par->set_hash));
#line 506
  free((void *)hashes);
  }
#line 508
  if (cmd.loglevel > 1) {
    {
#line 509
    dump_par(par);
    }
  }
  {
#line 511
  par_endian_write(par, (void *)(& data));
#line 513
  file_write(f, (void *)(& data), (i64 )96);
#line 514
  write_file_entries(f, par->files);
  }
#line 516
  if (par->vol_number == 0LL) {
    {
#line 517
    file_write(f, (void *)par->comment, par->data_size);
    }
#line 518
    if (cmd.ctrl) {
      {
#line 519
      tmp___5 = file_add_md5(f, (i64 )16, (i64 )32, par->data + par->data_size);
      }
#line 519
      if (! tmp___5) {
        {
#line 522
        tmp___3 = basename(par->filename);
#line 522
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      ERROR: %s:",
                tmp___3);
#line 524
        perror("");
#line 525
        tmp___4 = basename(par->filename);
#line 525
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - FAILED\n",
                tmp___4);
#line 527
        file_close(f);
#line 528
        f = (file_t )0;
        }
#line 529
        if (! cmd.keep) {
          {
#line 529
          file_delete(par->filename);
          }
        }
      }
    }
#line 532
    if (f) {
      {
#line 532
      file_close(f);
      }
    }
  }
#line 534
  return (f);
}
}
#line 540 "/home/wheatley/newnew/temp/parchive-1.1/rwpar.c"
int restore_files(pfile_t *files___0 , pfile_t *volumes___0 , sub_t *sub___0 ) 
{ 
  int N ;
  int M ;
  int i ;
  xfile_t *in ;
  xfile_t *out ;
  pfile_t *p ;
  pfile_t *v ;
  pfile_t **pp ;
  pfile_t **qq ;
  int fail ;
  i64 size ;
  pfile_t *mis_f ;
  pfile_t *mis_v ;
  u16 *path ;
  pfile_t *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  pfile_t *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  par_t *par ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;

  {
#line 546
  fail = 0;
#line 552
  p = files___0;
#line 553
  size = (i64 )0;
#line 554
  pp = & files___0;
#line 555
  qq = & mis_f;
#line 556
  tmp = (pfile_t *)0;
#line 556
  *qq = tmp;
#line 556
  *pp = tmp;
#line 557
  i = 1;
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if (! p) {
#line 557
      goto while_break;
    }
#line 558
    p->vol_number = (i64 )i;
#line 559
    if (! (p->status & 1LL)) {
#line 560
      goto __Cont;
    }
#line 561
    if (p->file_size > size) {
#line 562
      size = p->file_size;
    }
    {
#line 563
    tmp___2 = find_file(p, 0);
    }
#line 563
    if (tmp___2) {
      {
#line 569
      tmp___1 = malloc(sizeof(*(*pp)));
#line 569
      *pp = (pfile_t *)tmp___1;
#line 570
      memcpy((void */* __restrict  */)*pp, (void const   */* __restrict  */)p, sizeof(*(*pp)));
#line 571
      (*pp)->next = (pfile_t *)0;
#line 572
      pp = & (*pp)->next;
#line 573
      *pp = (pfile_t *)0;
      }
    } else {
      {
#line 564
      tmp___0 = malloc(sizeof(*(*qq)));
#line 564
      *qq = (pfile_t *)tmp___0;
#line 565
      memcpy((void */* __restrict  */)*qq, (void const   */* __restrict  */)p, sizeof(*(*qq)));
#line 566
      qq = & (*qq)->next;
#line 567
      *qq = (pfile_t *)0;
      }
    }
    __Cont: /* CIL Label */ 
#line 557
    p = p->next;
#line 557
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 578
  p = volumes___0;
#line 579
  pp = & volumes___0;
#line 580
  qq = & mis_v;
#line 581
  tmp___3 = (pfile_t *)0;
#line 581
  *qq = tmp___3;
#line 581
  *pp = tmp___3;
  {
#line 582
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 582
    if (! p) {
#line 582
      goto while_break___0;
    }
#line 583
    if (p->vol_number) {
#line 583
      if (! p->f) {
        {
#line 584
        tmp___4 = malloc(sizeof(*(*qq)));
#line 584
        *qq = (pfile_t *)tmp___4;
#line 585
        memcpy((void */* __restrict  */)*qq, (void const   */* __restrict  */)p, sizeof(*(*qq)));
#line 586
        qq = & (*qq)->next;
#line 587
        *qq = (pfile_t *)0;
        }
      } else {
        {
#line 589
        tmp___5 = malloc(sizeof(*(*pp)));
#line 589
        *pp = (pfile_t *)tmp___5;
#line 590
        memcpy((void */* __restrict  */)*pp, (void const   */* __restrict  */)p, sizeof(*(*pp)));
#line 591
        pp = & (*pp)->next;
#line 592
        *pp = (pfile_t *)0;
        }
      }
    } else {
      {
#line 589
      tmp___5 = malloc(sizeof(*(*pp)));
#line 589
      *pp = (pfile_t *)tmp___5;
#line 590
      memcpy((void */* __restrict  */)*pp, (void const   */* __restrict  */)p, sizeof(*(*pp)));
#line 591
      pp = & (*pp)->next;
#line 592
      *pp = (pfile_t *)0;
      }
    }
#line 582
    p = p->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 597
  N = 0;
#line 597
  p = files___0;
  {
#line 597
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 597
    if (! p) {
#line 597
      goto while_break___1;
    }
#line 598
    N ++;
#line 597
    p = p->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 599
  v = volumes___0;
  {
#line 599
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 599
    if (! v) {
#line 599
      goto while_break___2;
    }
#line 600
    N ++;
#line 599
    v = v->next;
#line 599
    N ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 603
  M = 0;
#line 603
  p = mis_f;
  {
#line 603
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 603
    if (! p) {
#line 603
      goto while_break___3;
    }
#line 604
    M ++;
#line 603
    p = p->next;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 605
  v = mis_v;
  {
#line 605
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 605
    if (! v) {
#line 605
      goto while_break___4;
    }
#line 606
    M ++;
#line 605
    v = v->next;
#line 605
    N ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 608
  tmp___6 = malloc(sizeof(*in) * (unsigned long )(N + 1));
#line 608
  in = (xfile_t *)tmp___6;
#line 609
  tmp___7 = malloc(sizeof(*out) * (unsigned long )(M + 1));
#line 609
  out = (xfile_t *)tmp___7;
#line 612
  i = 0;
#line 612
  p = files___0;
  }
  {
#line 612
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 612
    if (! p) {
#line 612
      goto while_break___5;
    }
    {
#line 613
    p->f = file_open((u16 const   *)(p->match)->filename, 0);
    }
#line 614
    if (! p->f) {
      {
#line 615
      tmp___8 = basename((p->match)->filename);
#line 615
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      ERROR: %s:",
              tmp___8);
#line 617
      perror("");
      }
#line 618
      goto __Cont___0;
    }
#line 620
    (in + i)->filenr = (u16 )p->vol_number;
#line 621
    (in + i)->files = (u16 *)0;
#line 622
    (in + i)->size = p->file_size;
#line 623
    (in + i)->f = p->f;
#line 624
    i ++;
    __Cont___0: /* CIL Label */ 
#line 612
    p = p->next;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 627
  v = volumes___0;
  {
#line 627
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 627
    if (! v) {
#line 627
      goto while_break___6;
    }
#line 628
    (in + i)->filenr = (u16 )v->vol_number;
#line 629
    (in + i)->files = v->fnrs;
#line 630
    (in + i)->size = v->file_size;
#line 631
    (in + i)->f = v->f;
#line 632
    i ++;
#line 627
    v = v->next;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 634
  (in + i)->filenr = (u16 )0;
#line 637
  i = 0;
#line 637
  p = mis_f;
  {
#line 637
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 637
    if (! p) {
#line 637
      goto while_break___7;
    }
    {
#line 638
    path = do_sub(p->filename, sub___0);
#line 640
    tmp___11 = move_away(path, (u8 const   *)".bad");
    }
#line 640
    if (tmp___11) {
      {
#line 641
      tmp___9 = basename(path);
#line 641
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      ERROR: %s: ",
              tmp___9);
#line 643
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File exists\n");
#line 644
      tmp___10 = basename(path);
#line 644
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - NOT RESTORED\n",
              tmp___10);
      }
#line 646
      goto __Cont___1;
    }
    {
#line 648
    p->f = file_open((u16 const   *)path, 1);
    }
#line 649
    if (! p->f) {
      {
#line 650
      tmp___12 = basename(path);
#line 650
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      ERROR: %s: ",
              tmp___12);
#line 652
      perror("");
#line 653
      tmp___13 = basename(path);
#line 653
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - NOT RESTORED\n",
              tmp___13);
      }
#line 655
      goto __Cont___1;
    }
#line 657
    (out + i)->size = p->file_size;
#line 658
    (out + i)->filenr = (u16 )p->vol_number;
#line 659
    (out + i)->files = (u16 *)0;
#line 660
    (out + i)->f = p->f;
#line 661
    i ++;
    __Cont___1: /* CIL Label */ 
#line 637
    p = p->next;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 665
  v = mis_v;
  {
#line 665
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 665
    if (! v) {
#line 665
      goto while_break___8;
    }
    {
#line 668
    par = create_par_header(v->filename, v->vol_number);
    }
#line 669
    if (! par) {
      {
#line 670
      tmp___14 = basename((v->match)->filename);
#line 670
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - FAILED\n",
              tmp___14);
      }
#line 672
      goto __Cont___2;
    }
    {
#line 675
    par->files = files___0;
#line 676
    par->data_size = size;
#line 677
    v->f = write_par_header(par);
#line 678
    par->files = (pfile_t *)0;
    }
#line 679
    if (! v->f) {
      {
#line 680
      tmp___15 = basename(par->filename);
#line 680
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - FAILED\n",
              tmp___15);
#line 682
      fail |= 1;
#line 683
      free_par(par);
      }
#line 684
      goto __Cont___2;
    }
    {
#line 686
    v->match = hfile_add(par->filename);
#line 687
    v->filename = (v->match)->filename;
#line 688
    v->file_size = par->data + par->data_size;
#line 689
    (out + i)->size = par->data_size;
#line 690
    (out + i)->filenr = (u16 )v->vol_number;
#line 691
    (out + i)->files = v->fnrs;
#line 692
    (out + i)->f = v->f;
#line 693
    free_par(par);
#line 694
    i ++;
    }
    __Cont___2: /* CIL Label */ 
#line 665
    v = v->next;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 696
  (out + i)->filenr = (u16 )0;
#line 698
  tmp___16 = recreate(in, out);
  }
#line 698
  if (! tmp___16) {
#line 699
    fail |= 1;
  }
  {
#line 701
  free((void *)in);
#line 702
  free((void *)out);
#line 705
  p = mis_f;
  }
  {
#line 705
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 705
    if (! p) {
#line 705
      goto while_break___9;
    }
#line 706
    if (! p->f) {
#line 706
      goto __Cont___3;
    }
    {
#line 707
    file_close(p->f);
#line 708
    p->f = (file_t )0;
#line 709
    path = do_sub(p->filename, sub___0);
#line 710
    p->match = hfile_add(path);
#line 711
    tmp___19 = hash_file(p->match, (char)2);
    }
#line 711
    if (! tmp___19) {
      {
#line 712
      tmp___17 = basename(path);
#line 712
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      ERROR: %s:",
              tmp___17);
#line 714
      perror("");
#line 715
      tmp___18 = basename(path);
#line 715
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - NOT RESTORED\n",
              tmp___18);
#line 717
      fail |= 1;
      }
#line 718
      if (! cmd.keep) {
        {
#line 718
        file_delete(path);
        }
      }
#line 719
      goto __Cont___3;
    }
#line 721
    if ((p->match)->file_size == 0LL) {
#line 721
      if (p->file_size != 0LL) {
        {
#line 722
        tmp___20 = basename(path);
#line 722
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - NOT RESTORED\n",
                tmp___20);
#line 724
        fail |= 1;
        }
#line 725
        if (! cmd.keep) {
          {
#line 725
          file_delete(path);
          }
        }
#line 726
        goto __Cont___3;
      }
    }
    {
#line 728
    tmp___23 = memcmp((void const   *)((p->match)->hash), (void const   *)(p->hash),
                      sizeof(md5 ));
    }
#line 728
    if (tmp___23) {
      {
#line 729
      tmp___21 = basename(path);
#line 729
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      ERROR: %s: Failed md5 check\n",
              tmp___21);
#line 731
      tmp___22 = basename(path);
#line 731
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - NOT RESTORED\n",
              tmp___22);
#line 733
      fail |= 1;
      }
#line 734
      if (! cmd.keep) {
        {
#line 734
        file_delete(path);
        }
      }
#line 735
      goto __Cont___3;
    }
    {
#line 737
    tmp___24 = basename(path);
#line 737
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - RECOVERED\n",
            tmp___24);
    }
    __Cont___3: /* CIL Label */ 
#line 705
    p = p->next;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 742
  v = mis_v;
  {
#line 742
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 742
    if (! v) {
#line 742
      goto while_break___10;
    }
#line 743
    if (! v->f) {
#line 743
      goto __Cont___4;
    }
    {
#line 744
    tmp___26 = file_add_md5(v->f, (i64 )16, (i64 )32, v->file_size);
    }
#line 744
    if (! tmp___26) {
      {
#line 745
      tmp___25 = basename(v->filename);
#line 745
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - FAILED\n",
              tmp___25);
#line 747
      fail |= 1;
#line 748
      file_close(v->f);
#line 749
      v->f = (file_t )0;
      }
#line 750
      if (! cmd.keep) {
        {
#line 750
        file_delete(v->filename);
        }
      }
#line 751
      goto __Cont___4;
    }
    {
#line 753
    tmp___27 = basename(v->filename);
#line 753
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - OK\n",
            tmp___27);
    }
    __Cont___4: /* CIL Label */ 
#line 742
    v = v->next;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 756
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 756
    p = files___0;
#line 756
    if (! p) {
#line 756
      goto while_break___11;
    }
    {
#line 757
    files___0 = p->next;
#line 758
    free((void *)p);
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 760
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 760
    p = volumes___0;
#line 760
    if (! p) {
#line 760
      goto while_break___12;
    }
    {
#line 761
    volumes___0 = p->next;
#line 762
    free((void *)p);
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 764
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 764
    p = mis_f;
#line 764
    if (! p) {
#line 764
      goto while_break___13;
    }
    {
#line 765
    mis_f = p->next;
#line 766
    free((void *)p);
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 768
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 768
    p = mis_v;
#line 768
    if (! p) {
#line 768
      goto while_break___14;
    }
    {
#line 769
    mis_v = p->next;
#line 770
    free((void *)p);
    }
  }
  while_break___14: /* CIL Label */ ;
  }
#line 773
  if (fail) {
    {
#line 774
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nErrors occurred.\n\n");
    }
#line 775
    return (-1);
  }
#line 777
  return (1);
}
}
#line 27 "/home/wheatley/newnew/temp/parchive-1.1/backend.h"
int unicode_cmp(u16 *a , u16 *b ) ;
#line 28
int unicode_gt(u16 *a , u16 *b ) ;
#line 33
hfile_t *find_file_name(u16 *path , int displ ) ;
#line 34
hfile_t *find_volume(u16 *name , i64 vol ) ;
#line 36
int rename_away(u16 *src , u16 *dst ) ;
#line 37
u16 *file_numbers(pfile_t **list , pfile_t **files___0 ) ;
#line 39
void find_par_files(pfile_t **volumes___0 , pfile_t **files___0 , int part ) ;
#line 42
sub_t *make_sub(u16 *from , u16 *to ) ;
#line 43
void free_sub(sub_t *sub___0 ) ;
#line 45
sub_t *find_best_sub(pfile_t *files___0 , int m ) ;
#line 22 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
static pfile_t *volumes  =    (pfile_t *)0;
#line 22 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
static pfile_t *files  =    (pfile_t *)0;
#line 23 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
static sub_t *sub  =    (sub_t *)0;
#line 24
hfile_t *hfile ;
#line 29 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
int par_flags(void) 
{ 
  int ret___0 ;

  {
#line 32
  ret___0 = 0;
#line 34
  if (cmd.move) {
#line 34
    ret___0 |= 1;
  }
#line 35
  if (cmd.usecase) {
#line 35
    ret___0 |= 2;
  }
#line 36
  if (cmd.ctrl) {
#line 36
    ret___0 |= 4;
  }
#line 37
  if (cmd.keep) {
#line 37
    ret___0 |= 8;
  }
#line 39
  return (ret___0);
}
}
#line 45 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
int par_setflags(int flags ) 
{ 
  int tmp ;

  {
#line 48
  if (flags & 1) {
#line 48
    cmd.move = 1;
  }
#line 49
  if (flags & 2) {
#line 49
    cmd.usecase = 1;
  }
#line 50
  if (flags & 4) {
#line 50
    cmd.ctrl = 1;
  }
#line 51
  if (flags & 8) {
#line 51
    cmd.keep = 1;
  }
  {
#line 53
  tmp = par_flags();
  }
#line 53
  return (tmp);
}
}
#line 59 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
int par_unsetflags(int flags ) 
{ 
  int tmp ;

  {
#line 62
  if (flags & 1) {
#line 62
    cmd.move = 0;
  }
#line 63
  if (flags & 2) {
#line 63
    cmd.usecase = 0;
  }
#line 64
  if (flags & 4) {
#line 64
    cmd.ctrl = 0;
  }
#line 65
  if (flags & 8) {
#line 65
    cmd.keep = 0;
  }
  {
#line 67
  tmp = par_flags();
  }
#line 67
  return (tmp);
}
}
#line 73 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
int par_load(u16 *filename ) 
{ 
  pfile_t *p ;
  pfile_t **pp ;
  par_t *par ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 79
  if (! filename) {
#line 79
    return (9);
  }
  {
#line 81
  par = read_par_header(filename, 1, (i64 )0, 0);
  }
#line 82
  if (! par) {
#line 82
    return (1);
  }
#line 83
  p = volumes;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! p) {
#line 83
      goto while_break;
    }
    {
#line 84
    tmp = unicode_cmp(p->filename, par->filename);
    }
#line 84
    if (! tmp) {
      {
#line 85
      free_par(par);
      }
#line 86
      return (6);
    }
#line 83
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  tmp___0 = calloc(sizeof(*p), (size_t )1);
#line 89
  p = (pfile_t *)tmp___0;
#line 90
  p->match = find_file_name(par->filename, 0);
#line 91
  p->vol_number = par->vol_number;
#line 92
  p->file_size = par->data_size;
  }
#line 93
  if (par->files) {
    {
#line 94
    p->fnrs = file_numbers(& files, & par->files);
    }
  }
  {
#line 95
  p->f = par->f;
#line 96
  p->filename = unicode_copy(par->filename);
#line 97
  par->f = (file_t )0;
#line 98
  free_par(par);
#line 101
  pp = & volumes;
  }
  {
#line 101
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 101
    if (! *pp) {
#line 101
      goto while_break___0;
    }
    {
#line 102
    tmp___1 = unicode_gt((*pp)->filename, filename);
    }
#line 102
    if (tmp___1) {
#line 103
      goto while_break___0;
    }
#line 101
    pp = & (*pp)->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 104
  p->next = *pp;
#line 105
  *pp = p;
#line 106
  return (0);
}
}
#line 112 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
int par_search(int partial ) 
{ 


  {
  {
#line 115
  find_par_files(& volumes, & files, partial);
  }
#line 116
  return (0);
}
}
#line 122 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
int par_unload(u16 *entry ) 
{ 
  pfile_t *p ;
  pfile_t **pp ;

  {
#line 127
  pp = & volumes;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! *pp) {
#line 127
      goto while_break;
    }
#line 128
    if ((unsigned long )(*pp)->filename == (unsigned long )entry) {
#line 129
      p = *pp;
#line 130
      *pp = p->next;
#line 131
      if (p->f) {
        {
#line 131
        file_close(p->f);
        }
      }
#line 132
      if (p->fnrs) {
        {
#line 132
        free((void *)p->fnrs);
        }
      }
      {
#line 133
      free((void *)p->filename);
#line 134
      free((void *)p);
      }
#line 135
      return (0);
    }
#line 127
    pp = & (*pp)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return (2);
}
}
#line 145 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
u16 **par_parlist(void) 
{ 
  u16 **ret___0 ;
  pfile_t *p ;
  int n ;
  void *tmp ;

  {
#line 152
  n = 0;
#line 152
  p = volumes;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! p) {
#line 152
      goto while_break;
    }
#line 153
    n ++;
#line 152
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 154
  tmp = calloc(sizeof(*ret___0), (size_t )(n + 1));
#line 154
  ret___0 = (u16 **)tmp;
#line 155
  n = 0;
#line 155
  p = volumes;
  }
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 155
    if (! p) {
#line 155
      goto while_break___0;
    }
#line 156
    *(ret___0 + n) = p->filename;
#line 155
    p = p->next;
#line 155
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 157
  *(ret___0 + n) = (u16 *)0;
#line 158
  return (ret___0);
}
}
#line 165 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
u16 **par_filelist(void) 
{ 
  u16 **ret___0 ;
  pfile_t *p ;
  int n ;
  void *tmp ;

  {
#line 172
  n = 0;
#line 172
  p = files;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! p) {
#line 172
      goto while_break;
    }
#line 173
    n ++;
#line 172
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 174
  tmp = calloc(sizeof(*ret___0), (size_t )(n + 1));
#line 174
  ret___0 = (u16 **)tmp;
#line 175
  n = 0;
#line 175
  p = files;
  }
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 175
    if (! p) {
#line 175
      goto while_break___0;
    }
#line 176
    *(ret___0 + n) = p->filename;
#line 175
    p = p->next;
#line 175
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 177
  *(ret___0 + n) = (u16 *)0;
#line 178
  return (ret___0);
}
}
#line 184 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
int par_check(u16 *entry ) 
{ 
  pfile_t *p ;
  int tmp ;

  {
#line 189
  p = files;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! p) {
#line 189
      goto while_break;
    }
#line 190
    if ((unsigned long )p->filename == (unsigned long )entry) {
      {
#line 191
      tmp = find_file(p, 0);
      }
#line 191
      if (tmp) {
#line 192
        return (0);
      }
#line 193
      return (4);
    }
#line 189
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (2);
}
}
#line 204 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
u16 *par_find(u16 *entry ) 
{ 
  pfile_t *p ;
  int tmp ;

  {
#line 209
  p = files;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! p) {
#line 209
      goto while_break;
    }
#line 210
    if ((unsigned long )p->filename == (unsigned long )entry) {
      {
#line 211
      tmp = find_file(p, 0);
      }
#line 211
      if (! tmp) {
#line 212
        return ((u16 *)0);
      }
#line 213
      return ((p->match)->filename);
    }
#line 209
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  return ((u16 *)0);
}
}
#line 222 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
int par_fixname(u16 *entry ) 
{ 
  int err ;
  pfile_t *p ;
  u16 *path ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 225
  err = 0;
#line 229
  p = files;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! p) {
#line 229
      goto while_break;
    }
#line 230
    if (entry) {
#line 230
      if ((unsigned long )p->filename != (unsigned long )entry) {
#line 231
        goto __Cont;
      }
    }
    {
#line 232
    tmp = find_file(p, 0);
    }
#line 232
    if (! tmp) {
#line 233
      err = 3;
#line 234
      goto __Cont;
    }
    {
#line 236
    path = do_sub(p->filename, sub);
#line 237
    tmp___0 = unicode_cmp(path, (p->match)->filename);
    }
#line 237
    if (! tmp___0) {
#line 238
      goto __Cont;
    }
    {
#line 239
    tmp___1 = rename_away((p->match)->filename, path);
    }
#line 239
    if (tmp___1) {
#line 240
      err = 1;
    }
    __Cont: /* CIL Label */ 
#line 229
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return (err);
}
}
#line 249 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
i64 par_getstatus(u16 *entry ) 
{ 
  pfile_t *p ;

  {
#line 254
  p = files;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! p) {
#line 254
      goto while_break;
    }
#line 255
    if ((unsigned long )p->filename == (unsigned long )entry) {
#line 256
      return (p->status);
    }
#line 254
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  return ((i64 )0);
}
}
#line 263 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
int par_setstatus(u16 *entry , i64 status ) 
{ 
  pfile_t *p ;

  {
#line 268
  p = files;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! p) {
#line 268
      goto while_break;
    }
#line 269
    if ((unsigned long )p->filename == (unsigned long )entry) {
#line 270
      p->status = status;
#line 271
      return (0);
    }
#line 268
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  return (2);
}
}
#line 280 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
int par_recover(u16 *entry ) 
{ 
  int tmp ;

  {
#line 283
  if (entry) {
#line 284
    return (7);
  }
  {
#line 285
  tmp = restore_files(files, volumes, sub);
  }
#line 285
  if (tmp < 0) {
#line 286
    return (5);
  }
#line 287
  return (0);
}
}
#line 293 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
int par_addfile(u16 *filename ) 
{ 
  pfile_t *p ;
  pfile_t **pp ;
  hfile_t *file ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 299
  if (! filename) {
#line 299
    return (9);
  }
  {
#line 301
  file = find_file_name(filename, 0);
  }
#line 302
  if (! file) {
#line 303
    return (3);
  }
  {
#line 304
  tmp = hash_file(file, (char)2);
  }
#line 304
  if (! tmp) {
#line 305
    return (1);
  }
#line 307
  p = files;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! p) {
#line 307
      goto while_break;
    }
    {
#line 308
    tmp___1 = unicode_cmp(p->filename, filename);
    }
#line 308
    if (! tmp___1) {
      {
#line 309
      tmp___0 = memcmp((void const   *)(p->hash), (void const   *)(file->hash), sizeof(md5 ));
      }
#line 309
      if (tmp___0) {
#line 312
        return (8);
      } else {
#line 310
        return (6);
      }
    }
#line 307
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 316
  tmp___2 = calloc(sizeof(*p), (size_t )1);
#line 316
  p = (pfile_t *)tmp___2;
#line 317
  p->filename = file->filename;
#line 318
  p->match = file;
#line 319
  p->file_size = file->file_size;
#line 320
  memcpy((void */* __restrict  */)(p->hash), (void const   */* __restrict  */)(file->hash),
         sizeof(md5 ) * sizeof(p->hash[0]));
#line 321
  memcpy((void */* __restrict  */)(p->hash_16k), (void const   */* __restrict  */)(file->hash_16k),
         sizeof(md5 ) * sizeof(p->hash_16k[0]));
#line 322
  p->status |= 1LL;
#line 325
  pp = & files;
  }
  {
#line 325
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 325
    if (! *pp) {
#line 325
      goto while_break___0;
    }
    {
#line 326
    tmp___3 = unicode_gt((*pp)->filename, p->filename);
    }
#line 326
    if (tmp___3) {
#line 327
      goto while_break___0;
    }
#line 325
    pp = & (*pp)->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  p->next = *pp;
#line 329
  *pp = p;
#line 331
  return (0);
}
}
#line 337 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
int par_removefile(u16 *entry ) 
{ 


  {
#line 340
  return (7);
}
}
#line 346 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
int par_addpars(u16 *entry , int number ) 
{ 
  int i ;
  int err ;
  pfile_t *p ;
  pfile_t **pp ;
  hfile_t *h ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 349
  err = 0;
#line 353
  if (number < 1) {
#line 353
    return (9);
  }
#line 354
  p = volumes;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! p) {
#line 354
      goto while_break;
    }
#line 355
    if ((unsigned long )p->filename == (unsigned long )entry) {
#line 356
      goto while_break;
    }
#line 354
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  if (! p) {
#line 357
    return (9);
  }
#line 358
  i = 1;
  {
#line 358
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 358
    if (! (i <= number)) {
#line 358
      goto while_break___0;
    }
    {
#line 359
    h = find_volume(entry, (i64 )i);
    }
#line 360
    if (! h) {
#line 361
      err = 1;
#line 362
      goto __Cont;
    }
#line 364
    p = volumes;
    {
#line 364
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 364
      if (! p) {
#line 364
        goto while_break___1;
      }
      {
#line 365
      tmp = unicode_cmp(p->filename, h->filename);
      }
#line 365
      if (! tmp) {
#line 366
        goto while_break___1;
      }
#line 364
      p = p->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 367
    if (p) {
#line 367
      goto __Cont;
    }
    {
#line 368
    tmp___0 = calloc(sizeof(*p), (size_t )1);
#line 368
    p = (pfile_t *)tmp___0;
#line 369
    p->match = h;
#line 370
    p->vol_number = (i64 )i;
#line 371
    p->filename = unicode_copy(h->filename);
#line 374
    pp = & volumes;
    }
    {
#line 374
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 374
      if (! *pp) {
#line 374
        goto while_break___2;
      }
      {
#line 375
      tmp___1 = unicode_gt((*pp)->filename, p->filename);
      }
#line 375
      if (tmp___1) {
#line 376
        goto while_break___2;
      }
#line 374
      pp = & (*pp)->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 377
    p->next = *pp;
#line 378
    *pp = p;
    __Cont: /* CIL Label */ 
#line 358
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 380
  return (err);
}
}
#line 386 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
int par_create(u16 *entry ) 
{ 
  pfile_t *p ;
  par_t *par ;
  int tmp ;

  {
#line 391
  if (entry) {
#line 392
    return (7);
  }
#line 393
  p = volumes;
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if (! p) {
#line 393
      goto while_break;
    }
#line 394
    if (p->f) {
      {
#line 395
      file_close(p->f);
#line 396
      p->f = (file_t )0;
      }
    }
#line 398
    if (! p->vol_number) {
      {
#line 400
      par = create_par_header(p->filename, (i64 )0);
#line 401
      par->files = files;
#line 402
      write_par_header(par);
#line 403
      par->files = (pfile_t *)0;
#line 404
      free_par(par);
      }
    }
#line 406
    if (! p->fnrs) {
      {
#line 407
      p->fnrs = file_numbers(& files, & files);
      }
    }
#line 393
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  tmp = restore_files(files, volumes, sub);
  }
#line 409
  if (tmp < 0) {
#line 410
    return (5);
  }
#line 411
  return (0);
}
}
#line 418 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
u16 **par_dirlist(void) 
{ 
  u16 **ret___0 ;
  hfile_t *p ;
  int n ;
  void *tmp ;

  {
#line 425
  n = 0;
#line 425
  p = hfile;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! p) {
#line 425
      goto while_break;
    }
#line 426
    n ++;
#line 425
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 427
  tmp = calloc(sizeof(*ret___0), (size_t )(n + 1));
#line 427
  ret___0 = (u16 **)tmp;
#line 428
  n = 0;
#line 428
  p = hfile;
  }
  {
#line 428
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 428
    if (! p) {
#line 428
      goto while_break___0;
    }
#line 429
    *(ret___0 + n) = p->filename;
#line 428
    p = p->next;
#line 428
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 430
  *(ret___0 + n) = (u16 *)0;
#line 431
  return (ret___0);
}
}
#line 439 "/home/wheatley/newnew/temp/parchive-1.1/interface.c"
int par_setsmart(u16 *from , u16 *to ) 
{ 


  {
#line 442
  if (! from) {
#line 443
    if (! to) {
      {
#line 444
      free_sub(sub);
#line 445
      sub = find_best_sub(files, 2);
      }
#line 446
      return (0);
    } else {
#line 448
      return (7);
    }
  } else
#line 451
  if (! to) {
#line 452
    return (7);
  } else {
    {
#line 454
    free_sub(sub);
#line 455
    sub = make_sub(from, to);
    }
#line 456
    return (0);
  }
}
}
#line 16 "/home/wheatley/newnew/temp/parchive-1.1/makepar.h"
int par_add_file(par_t *par , hfile_t *file ) ;
#line 17
int par_make_pxx(par_t *par ) ;
#line 26 "/home/wheatley/newnew/temp/parchive-1.1/makepar.c"
int par_add_file(par_t *par , hfile_t *file ) 
{ 
  pfile_t *p ;
  pfile_t **pp ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
#line 31
  if (! file) {
#line 32
    return (0);
  }
  {
#line 33
  tmp___0 = hash_file(file, (char)2);
  }
#line 33
  if (! tmp___0) {
    {
#line 34
    tmp = basename(file->filename);
#line 34
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - ERROR\n",
            tmp);
    }
#line 36
    return (0);
  }
#line 39
  p = par->files;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! p) {
#line 39
      goto while_break;
    }
    {
#line 40
    tmp___1 = unicode_cmp(p->filename, file->filename);
    }
    {
#line 41
    if (tmp___1 == 0) {
#line 41
      goto case_0;
    }
#line 50
    if (tmp___1 == 1) {
#line 50
      goto case_1;
    }
#line 40
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 42
    tmp___4 = memcmp((void const   *)(p->hash), (void const   *)(file->hash), sizeof(md5 ));
    }
#line 42
    if (tmp___4) {
      {
#line 46
      tmp___3 = basename(file->filename);
#line 46
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - NAME CLASH\n",
              tmp___3);
      }
    } else {
      {
#line 43
      tmp___2 = basename(file->filename);
#line 43
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - EXISTS\n",
              tmp___2);
      }
    }
#line 49
    return (0);
    case_1: /* CIL Label */ 
    {
#line 51
    tmp___6 = memcmp((void const   *)(p->hash), (void const   *)(file->hash), sizeof(md5 ));
    }
#line 51
    if (! tmp___6) {
      {
#line 52
      tmp___5 = basename(file->filename);
#line 52
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - EXISTS\n",
              tmp___5);
      }
#line 54
      return (0);
    }
#line 56
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 39
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  tmp___7 = calloc(sizeof(*p), (size_t )1);
#line 61
  p = (pfile_t *)tmp___7;
#line 62
  p->filename = file->filename;
#line 63
  p->match = file;
#line 64
  p->file_size = file->file_size;
#line 65
  memcpy((void */* __restrict  */)(p->hash), (void const   */* __restrict  */)(file->hash),
         sizeof(md5 ) * sizeof(p->hash[0]));
#line 66
  memcpy((void */* __restrict  */)(p->hash_16k), (void const   */* __restrict  */)(file->hash_16k),
         sizeof(md5 ) * sizeof(p->hash_16k[0]));
  }
#line 67
  if (cmd.add) {
#line 68
    p->status |= 1LL;
  }
#line 71
  pp = & par->files;
  {
#line 71
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 71
    if (! *pp) {
#line 71
      goto while_break___0;
    }
    {
#line 72
    tmp___8 = unicode_gt((*pp)->filename, p->filename);
    }
#line 72
    if (tmp___8) {
#line 73
      goto while_break___0;
    }
#line 71
    pp = & (*pp)->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 74
  p->next = *pp;
#line 75
  *pp = p;
#line 77
  tmp___9 = basename(file->filename);
#line 77
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - OK\n",
          tmp___9);
  }
#line 79
  return (1);
}
}
#line 85 "/home/wheatley/newnew/temp/parchive-1.1/makepar.c"
int par_make_pxx(par_t *par ) 
{ 
  pfile_t *p ;
  pfile_t *v ;
  int M ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 91
  if (! (par->magic == *((i64 *)"PAR\000\000\000\000\000"))) {
#line 92
    return (0);
  }
#line 93
  if (par->vol_number) {
    {
#line 94
    tmp = calloc(sizeof(*v), (size_t )1);
#line 94
    v = (pfile_t *)tmp;
#line 95
    v->match = find_file_name(par->filename, 0);
    }
#line 96
    if (! v->match) {
      {
#line 97
      v->match = find_volume(par->filename, par->vol_number);
      }
    }
#line 98
    v->vol_number = par->vol_number;
#line 99
    if (v->match) {
#line 100
      v->filename = (v->match)->filename;
    }
#line 101
    par->volumes = v;
  } else {
#line 103
    if (cmd.volumes <= 0) {
#line 104
      return (0);
    }
#line 106
    M = cmd.volumes;
#line 107
    if (cmd.pervol) {
#line 108
      M = 0;
#line 108
      p = par->files;
      {
#line 108
      while (1) {
        while_continue: /* CIL Label */ ;
#line 108
        if (! p) {
#line 108
          goto while_break;
        }
#line 109
        if (p->status & 1LL) {
#line 110
          M ++;
        }
#line 108
        p = p->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 111
      M = (M - 1) / cmd.volumes + 1;
    }
#line 115
    i = 1;
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 115
      if (! (i <= M)) {
#line 115
        goto while_break___0;
      }
      {
#line 116
      tmp___0 = calloc(sizeof(*v), (size_t )1);
#line 116
      v = (pfile_t *)tmp___0;
#line 117
      v->match = find_volume(par->filename, (i64 )i);
#line 118
      v->vol_number = (i64 )i;
      }
#line 119
      if (v->match) {
#line 120
        v->filename = (v->match)->filename;
      }
#line 121
      v->next = par->volumes;
#line 122
      par->volumes = v;
#line 115
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 126
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\nCreating PAR volumes:\n");
#line 127
  p = par->files;
  }
  {
#line 127
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 127
    if (! p) {
#line 127
      goto while_break___1;
    }
#line 128
    if (p->status & 1LL) {
      {
#line 129
      find_file(p, 1);
      }
    }
#line 127
    p = p->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 131
  v = par->volumes;
  {
#line 131
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 131
    if (! v) {
#line 131
      goto while_break___2;
    }
    {
#line 132
    v->fnrs = file_numbers(& par->files, & par->files);
#line 131
    v = v->next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 134
  tmp___1 = restore_files(par->files, par->volumes, (sub_t *)0);
  }
#line 134
  if (tmp___1 < 0) {
#line 135
    return (0);
  }
#line 137
  return (1);
}
}
#line 38 "/home/wheatley/newnew/temp/parchive-1.1/backend.h"
int find_volumes(par_t *par , int tofind ) ;
#line 18 "/home/wheatley/newnew/temp/parchive-1.1/checkpar.h"
int check_par(par_t *par ) ;
#line 26 "/home/wheatley/newnew/temp/parchive-1.1/checkpar.c"
int check_par(par_t *par ) 
{ 
  int m ;
  pfile_t *p ;
  u16 *str ;
  sub_t *sub___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  u16 *tmp___4 ;
  char *tmp___5 ;

  {
#line 32
  sub___0 = (sub_t *)0;
#line 35
  m = 0;
#line 35
  p = par->files;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! p) {
#line 35
      goto while_break;
    }
    {
#line 36
    tmp = find_file(p, 1);
    }
#line 36
    if (! tmp) {
#line 36
      if (p->status & 1LL) {
#line 37
        m ++;
      }
    }
#line 35
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  if (cmd.smart) {
    {
#line 40
    sub___0 = find_best_sub(par->files, 2);
    }
  }
#line 41
  if (cmd.fix) {
#line 42
    p = par->files;
    {
#line 42
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 42
      if (! p) {
#line 42
        goto while_break___0;
      }
      {
#line 43
      tmp___0 = find_file(p, 0);
      }
#line 43
      if (! tmp___0) {
#line 44
        goto __Cont;
      }
      {
#line 45
      str = do_sub(p->filename, sub___0);
#line 46
      tmp___1 = unicode_cmp(str, (p->match)->filename);
      }
#line 46
      if (! tmp___1) {
#line 47
        goto __Cont;
      }
      {
#line 48
      rename_away((p->match)->filename, str);
      }
      __Cont: /* CIL Label */ 
#line 42
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 51
  if (m == 0) {
    {
#line 52
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"All files found\n");
#line 53
    free_sub(sub___0);
    }
#line 54
    return (0);
  }
#line 56
  if (cmd.action != 3) {
    {
#line 56
    tmp___3 = find_volumes(par, m);
    }
#line 56
    if (tmp___3 < m) {
      {
#line 57
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nToo many missing files:\n");
#line 58
      p = par->files;
      }
      {
#line 58
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 58
        if (! p) {
#line 58
          goto while_break___1;
        }
#line 59
        if (! p->match) {
#line 59
          if (p->status & 1LL) {
            {
#line 60
            tmp___2 = basename(p->filename);
#line 60
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s\n",
                    tmp___2);
            }
          }
        }
#line 58
        p = p->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 62
      free_sub(sub___0);
      }
#line 63
      return (-1);
    }
  }
#line 65
  if (cmd.action != 1) {
    {
#line 66
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nRestoring:\n");
#line 67
    m = restore_files(par->files, par->volumes, sub___0);
#line 68
    free_sub(sub___0);
    }
#line 69
    return (m);
  }
  {
#line 71
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nRestorable:\n");
#line 72
  p = par->files;
  }
  {
#line 72
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 72
    if (! p) {
#line 72
      goto while_break___2;
    }
#line 73
    if (! p->match) {
#line 73
      if (p->status & 1LL) {
        {
#line 74
        tmp___4 = do_sub(p->filename, sub___0);
#line 74
        tmp___5 = basename(tmp___4);
#line 74
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - can be restored\n",
                tmp___5);
        }
      }
    }
#line 72
    p = p->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 77
  free_sub(sub___0);
  }
#line 78
  return (1);
}
}
#line 45 "/home/wheatley/newnew/temp/parchive-1.1/fileops.h"
u16 *unist(char const   *str ) ;
#line 60 "/home/wheatley/newnew/temp/parchive-1.1/par.h"
struct cmdline cmd  ;
#line 40 "/home/wheatley/newnew/temp/parchive-1.1/backend.h"
par_t *find_all_par_files(void) ;
#line 28 "/home/wheatley/newnew/temp/parchive-1.1/main.c"
int usage(void) 
{ 


  {
  {
#line 31
  printf((char const   */* __restrict  */)"Usage:\n   parchive c(heck)   [options] <par file>         : Check parity archive\n   parchive r(ecover) [options] <par file>         : Restore missing volumes\n   parchive a(dd)     [options] <par file> [files] : Add files to parity archive\n Advanced:\n   parchive m(ix)     [options] : Try to restore from all parity files at once\n   parchive i(nteractive) [<par files>] : Interactive mode (very bare-bones)\n\nOptions: (Can be turned off with \'+\')\n    -m   : Move existing files out of the way\n    -f   : Fix faulty filenames\n    -p<n>: Number of files per parity volume\n or -n<n>: Number of parity volumes to create\n    -d   : Search for duplicate files\n    -k   : Keep broken files\n    -s   : Be smart if filenames are consistently different.\n    +i   : Do not add following files to parity volumes\n    +c   : Do not create parity volumes\n    +C   : Ignore case in filename comparisons\n    +H   : Do not check control hashes\n    -v,+v: Increase or decrease verbosity\n    -h,-?: Display this help\n    --   : Always treat following arguments as files\n\n");
  }
#line 57
  return (0);
}
}
#line 61 "/home/wheatley/newnew/temp/parchive-1.1/main.c"
static int check_sizes(void) 
{ 
  int fail ;

  {
#line 64
  fail = 0;
#line 65
  if (sizeof(u8 ) != 1UL) {
    {
#line 66
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"u8 isn\'t 8 bits wide.\n");
#line 67
    fail ++;
    }
  }
#line 69
  if (sizeof(u16 ) != 2UL) {
    {
#line 70
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"u16 isn\'t 16 bits wide.\n");
#line 71
    fail ++;
    }
  }
#line 73
  if (sizeof(u32 ) != 4UL) {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"u32 isn\'t 32 bits wide.\n");
#line 75
    fail ++;
    }
  }
#line 77
  if (sizeof(i64 ) != 8UL) {
    {
#line 78
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"u64 isn\'t 64 bits wide.\n");
#line 79
    fail ++;
    }
  }
#line 81
  return (fail);
}
}
#line 90 "/home/wheatley/newnew/temp/parchive-1.1/main.c"
int main(int argc , char **argv ) 
{ 
  par_t *par ;
  int fail ;
  char *p ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  u16 *tmp___5 ;
  int tmp___6 ;
  u16 *tmp___7 ;
  u16 *tmp___8 ;
  hfile_t *tmp___9 ;
  u16 *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  file_t tmp___13 ;

  {
  {
#line 93
  par = (par_t *)0;
#line 94
  fail = 0;
#line 97
  tmp = check_sizes();
  }
#line 97
  if (tmp) {
#line 98
    return (-1);
  }
  {
#line 101
  memset((void *)(& cmd), 0, sizeof(cmd));
#line 102
  cmd.volumes = 10;
#line 103
  cmd.pervol = 1;
#line 104
  cmd.pxx = 1;
#line 105
  cmd.ctrl = 1;
#line 106
  cmd.add = 1;
#line 107
  cmd.usecase = 1;
  }
#line 109
  if (argc == 1) {
    {
#line 109
    tmp___0 = usage();
    }
#line 109
    return (tmp___0);
  }
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (argc > 1)) {
#line 111
      goto while_break;
    }
#line 112
    if ((int )*(*(argv + 1) + 0) == 45) {
#line 112
      goto _L;
    } else
#line 112
    if ((int )*(*(argv + 1) + 0) == 43) {
      _L: /* CIL Label */ 
#line 112
      if (*(*(argv + 1) + 1)) {
#line 112
        if (! cmd.dash) {
#line 114
          p = *(argv + 1);
          {
#line 114
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 114
            if (! *p) {
#line 114
              goto while_break___0;
            }
            {
#line 115
            if ((int )*p == 45) {
#line 115
              goto case_45;
            }
#line 121
            if ((int )*p == 43) {
#line 121
              goto case_43;
            }
#line 124
            if ((int )*p == 109) {
#line 124
              goto case_109;
            }
#line 127
            if ((int )*p == 105) {
#line 127
              goto case_105;
            }
#line 130
            if ((int )*p == 102) {
#line 130
              goto case_102;
            }
#line 133
            if ((int )*p == 99) {
#line 133
              goto case_99;
            }
#line 136
            if ((int )*p == 100) {
#line 136
              goto case_100;
            }
#line 139
            if ((int )*p == 118) {
#line 139
              goto case_118;
            }
#line 146
            if ((int )*p == 110) {
#line 146
              goto case_110;
            }
#line 146
            if ((int )*p == 112) {
#line 146
              goto case_110;
            }
#line 166
            if ((int )*p == 72) {
#line 166
              goto case_72;
            }
#line 169
            if ((int )*p == 67) {
#line 169
              goto case_67;
            }
#line 172
            if ((int )*p == 107) {
#line 172
              goto case_107;
            }
#line 175
            if ((int )*p == 115) {
#line 175
              goto case_115;
            }
#line 179
            if ((int )*p == 104) {
#line 179
              goto case_104;
            }
#line 179
            if ((int )*p == 63) {
#line 179
              goto case_104;
            }
#line 181
            goto switch_default;
            case_45: /* CIL Label */ 
#line 116
            if ((int )*(p + 1) == 45) {
#line 117
              cmd.dash = 1;
            } else {
#line 119
              cmd.plus = 1;
            }
#line 120
            goto switch_break;
            case_43: /* CIL Label */ 
#line 122
            cmd.plus = 0;
#line 123
            goto switch_break;
            case_109: /* CIL Label */ 
#line 125
            cmd.move = cmd.plus;
#line 126
            goto switch_break;
            case_105: /* CIL Label */ 
#line 128
            cmd.add = cmd.plus;
#line 129
            goto switch_break;
            case_102: /* CIL Label */ 
#line 131
            cmd.fix = cmd.plus;
#line 132
            goto switch_break;
            case_99: /* CIL Label */ 
#line 134
            cmd.pxx = cmd.plus;
#line 135
            goto switch_break;
            case_100: /* CIL Label */ 
#line 137
            cmd.dupl = cmd.plus;
#line 138
            goto switch_break;
            case_118: /* CIL Label */ 
#line 140
            if (cmd.plus) {
#line 141
              (cmd.loglevel) ++;
            } else {
#line 143
              (cmd.loglevel) --;
            }
#line 144
            goto switch_break;
            case_110: /* CIL Label */ 
            case_112: /* CIL Label */ 
#line 147
            cmd.pervol = (int )*p == 112;
            {
#line 148
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 148
              tmp___1 = __ctype_b_loc();
#line 148
              p ++;
              }
#line 148
              if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 148
                goto while_break___1;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 150
            if (! *p) {
#line 151
              argv ++;
#line 152
              argc --;
#line 153
              p = *(argv + 1);
            }
            {
#line 155
            tmp___3 = __ctype_b_loc();
            }
#line 155
            if ((int const   )*(*tmp___3 + (int )*p) & 2048) {
#line 158
              cmd.volumes = 0;
              {
#line 159
              while (1) {
                while_continue___2: /* CIL Label */ ;
                {
#line 160
                cmd.volumes *= 10;
#line 161
                cmd.volumes += (int )*p - 48;
#line 159
                tmp___2 = __ctype_b_loc();
#line 159
                p ++;
                }
#line 159
                if (! ((int const   )*(*tmp___2 + (int )*p) & 2048)) {
#line 159
                  goto while_break___2;
                }
              }
              while_break___2: /* CIL Label */ ;
              }
#line 163
              p --;
            } else {
              {
#line 156
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Value expected!\n");
              }
            }
#line 165
            goto switch_break;
            case_72: /* CIL Label */ 
#line 167
            cmd.ctrl = cmd.plus;
#line 168
            goto switch_break;
            case_67: /* CIL Label */ 
#line 170
            cmd.usecase = cmd.plus;
#line 171
            goto switch_break;
            case_107: /* CIL Label */ 
#line 173
            cmd.keep = cmd.plus;
#line 174
            goto switch_break;
            case_115: /* CIL Label */ 
#line 176
            cmd.smart = cmd.plus;
#line 177
            goto switch_break;
            case_104: /* CIL Label */ 
            case_63: /* CIL Label */ 
            {
#line 180
            tmp___4 = usage();
            }
#line 180
            return (tmp___4);
            switch_default: /* CIL Label */ 
            {
#line 182
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown switch: \'%c\'\n",
                    (int )*p);
            }
#line 184
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
#line 114
            p ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 186
          goto __Cont;
        }
      }
    }
#line 188
    if (! cmd.action) {
      {
#line 191
      if ((int )*(*(argv + 1) + 0) == 67) {
#line 191
        goto case_67___0;
      }
#line 191
      if ((int )*(*(argv + 1) + 0) == 99) {
#line 191
        goto case_67___0;
      }
#line 195
      if ((int )*(*(argv + 1) + 0) == 77) {
#line 195
        goto case_77;
      }
#line 195
      if ((int )*(*(argv + 1) + 0) == 109) {
#line 195
        goto case_77;
      }
#line 199
      if ((int )*(*(argv + 1) + 0) == 82) {
#line 199
        goto case_82;
      }
#line 199
      if ((int )*(*(argv + 1) + 0) == 114) {
#line 199
        goto case_82;
      }
#line 203
      if ((int )*(*(argv + 1) + 0) == 65) {
#line 203
        goto case_65;
      }
#line 203
      if ((int )*(*(argv + 1) + 0) == 97) {
#line 203
        goto case_65;
      }
#line 207
      if ((int )*(*(argv + 1) + 0) == 73) {
#line 207
        goto case_73;
      }
#line 207
      if ((int )*(*(argv + 1) + 0) == 105) {
#line 207
        goto case_73;
      }
#line 210
      goto switch_default___0;
      case_67___0: /* CIL Label */ 
      case_99___0: /* CIL Label */ 
#line 192
      cmd.action = 1;
#line 193
      goto switch_break___0;
      case_77: /* CIL Label */ 
      case_109___0: /* CIL Label */ 
#line 196
      cmd.action = 3;
#line 197
      goto switch_break___0;
      case_82: /* CIL Label */ 
      case_114: /* CIL Label */ 
#line 200
      cmd.action = 2;
#line 201
      goto switch_break___0;
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
#line 204
      cmd.action = 11;
#line 205
      goto switch_break___0;
      case_73: /* CIL Label */ 
      case_105___0: /* CIL Label */ 
#line 208
      cmd.action = 20;
#line 209
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 211
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown command: \'%s\'\n",
              *(argv + 1));
      }
#line 213
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 215
      goto __Cont;
    }
    {
#line 222
    if (cmd.action == 2) {
#line 222
      goto case_2;
    }
#line 222
    if (cmd.action == 1) {
#line 222
      goto case_2;
    }
#line 233
    if (cmd.action == 11) {
#line 233
      goto case_11;
    }
#line 239
    if (cmd.action == 12) {
#line 239
      goto case_12;
    }
#line 242
    if (cmd.action == 3) {
#line 242
      goto case_3;
    }
#line 245
    if (cmd.action == 20) {
#line 245
      goto case_20;
    }
#line 218
    goto switch_default___1;
    switch_default___1: /* CIL Label */ 
#line 219
    cmd.action = 1;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 223
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Checking %s\n",
            *(argv + 1));
#line 224
    tmp___5 = unist((char const   *)*(argv + 1));
#line 224
    par = read_par_header(tmp___5, 0, (i64 )0, 0);
    }
#line 225
    if (! par) {
#line 226
      fail = 2;
#line 227
      goto __Cont;
    }
    {
#line 229
    tmp___6 = check_par(par);
    }
#line 229
    if (tmp___6 < 0) {
#line 229
      fail = 1;
    }
    {
#line 230
    free_par(par);
#line 231
    par = (par_t *)0;
    }
#line 232
    goto switch_break___1;
    case_11: /* CIL Label */ 
    {
#line 234
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Adding to %s\n",
            *(argv + 1));
#line 235
    tmp___7 = unist((char const   *)*(argv + 1));
#line 235
    par = read_par_header(tmp___7, 1, (i64 )0, 0);
    }
#line 236
    if (! par) {
#line 236
      return (2);
    }
#line 237
    cmd.action = 12;
#line 238
    goto switch_break___1;
    case_12: /* CIL Label */ 
    {
#line 240
    tmp___8 = unist((char const   *)*(argv + 1));
#line 240
    tmp___9 = find_file_name(tmp___8, 1);
#line 240
    par_add_file(par, tmp___9);
    }
#line 241
    goto switch_break___1;
    case_3: /* CIL Label */ 
    {
#line 243
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown argument: \'%s\'\n",
            *(argv + 1));
    }
#line 244
    goto switch_break___1;
    case_20: /* CIL Label */ 
    {
#line 246
    tmp___10 = unist((char const   *)*(argv + 1));
#line 246
    par_load(tmp___10);
    }
#line 247
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 111
    argc --;
#line 111
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  if (cmd.action == 20) {
    {
#line 251
    ui_text();
    }
#line 252
    return (0);
  }
#line 254
  if (cmd.action == 3) {
    {
#line 255
    par = find_all_par_files();
    }
#line 256
    if (par) {
      {
#line 257
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nChecking:\n");
#line 258
      tmp___11 = check_par(par);
      }
#line 258
      if (tmp___11 < 0) {
#line 259
        fail = 1;
      }
      {
#line 260
      free_par(par);
#line 261
      par = (par_t *)0;
      }
    } else {
#line 263
      fail = 2;
    }
  }
#line 266
  if (par) {
#line 267
    if (cmd.pxx) {
      {
#line 267
      tmp___12 = par_make_pxx(par);
      }
#line 267
      if (! tmp___12) {
#line 268
        fail |= 1;
      }
    }
#line 269
    if (! par->vol_number) {
      {
#line 269
      tmp___13 = write_par_header(par);
      }
#line 269
      if (! tmp___13) {
#line 270
        fail |= 1;
      }
    }
    {
#line 271
    free_par(par);
    }
  }
#line 273
  return (fail);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 55 "/home/wheatley/newnew/temp/parchive-1.1/md5.h"
void md5_init_ctx(struct md5_ctx *ctx ) ;
#line 61
void md5_process_block(void const   *buffer , size_t len , struct md5_ctx *ctx ) ;
#line 68
void md5_process_bytes(void const   *buffer , size_t len , struct md5_ctx *ctx ) ;
#line 78
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
#line 87
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
#line 93
i64 md5_stream(FILE *stream , void *resblock ) ;
#line 38 "/home/wheatley/newnew/temp/parchive-1.1/md5.c"
static unsigned char const   fillbuf[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 43 "/home/wheatley/newnew/temp/parchive-1.1/md5.c"
void md5_init_ctx(struct md5_ctx *ctx ) 
{ 
  u32 tmp ;

  {
#line 47
  ctx->A = (u32 )1732584193;
#line 48
  ctx->B = 4023233417U;
#line 49
  ctx->C = 2562383102U;
#line 50
  ctx->D = (u32 )271733878;
#line 52
  tmp = (u32 )0;
#line 52
  ctx->total[1] = tmp;
#line 52
  ctx->total[0] = tmp;
#line 53
  ctx->buflen = (u32 )0;
#line 54
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/parchive-1.1/md5.c"
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) 
{ 
  u8 *rb ;
  u32 v ;

  {
#line 66
  rb = (u8 *)resbuf;
#line 69
  v = (u32 )ctx->A;
#line 69
  *(rb + 0) = (u8 )(v & 255U);
#line 70
  v >>= 8;
#line 70
  *(rb + 1) = (u8 )(v & 255U);
#line 71
  v >>= 8;
#line 71
  *(rb + 2) = (u8 )(v & 255U);
#line 72
  v >>= 8;
#line 72
  *(rb + 3) = (u8 )(v & 255U);
#line 73
  v = (u32 )ctx->B;
#line 73
  *(rb + 4) = (u8 )(v & 255U);
#line 74
  v >>= 8;
#line 74
  *(rb + 5) = (u8 )(v & 255U);
#line 75
  v >>= 8;
#line 75
  *(rb + 6) = (u8 )(v & 255U);
#line 76
  v >>= 8;
#line 76
  *(rb + 7) = (u8 )(v & 255U);
#line 77
  v = (u32 )ctx->C;
#line 77
  *(rb + 8) = (u8 )(v & 255U);
#line 78
  v >>= 8;
#line 78
  *(rb + 9) = (u8 )(v & 255U);
#line 79
  v >>= 8;
#line 79
  *(rb + 10) = (u8 )(v & 255U);
#line 80
  v >>= 8;
#line 80
  *(rb + 11) = (u8 )(v & 255U);
#line 81
  v = (u32 )ctx->D;
#line 81
  *(rb + 12) = (u8 )(v & 255U);
#line 82
  v >>= 8;
#line 82
  *(rb + 13) = (u8 )(v & 255U);
#line 83
  v >>= 8;
#line 83
  *(rb + 14) = (u8 )(v & 255U);
#line 84
  v >>= 8;
#line 84
  *(rb + 15) = (u8 )(v & 255U);
#line 86
  return (resbuf);
}
}
#line 94 "/home/wheatley/newnew/temp/parchive-1.1/md5.c"
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) 
{ 
  u32 bytes ;
  u32 v ;
  size_t pad ;
  u8 *bp ;
  void *tmp ;

  {
#line 100
  bytes = ctx->buflen;
#line 106
  ctx->total[0] += bytes;
#line 107
  if (ctx->total[0] < bytes) {
#line 108
    (ctx->total[1]) ++;
  }
#line 110
  if (bytes >= 56U) {
#line 110
    pad = (size_t )(120U - bytes);
  } else {
#line 110
    pad = (size_t )(56U - bytes);
  }
  {
#line 111
  memcpy((void */* __restrict  */)(& ctx->buffer[bytes]), (void const   */* __restrict  */)(fillbuf),
         pad);
#line 113
  bp = (u8 *)(& ctx->buffer[(size_t )bytes + pad]);
#line 116
  v = ctx->total[0];
#line 116
  *(bp + 0) = (u8 )((v << 3) & 255U);
#line 117
  v >>= 5;
#line 117
  *(bp + 1) = (u8 )(v & 255U);
#line 118
  v >>= 8;
#line 118
  *(bp + 2) = (u8 )(v & 255U);
#line 119
  v >>= 8;
#line 119
  *(bp + 3) = (u8 )(v & 255U);
#line 120
  v = (v >> 8) | (ctx->total[1] << 3);
#line 120
  *(bp + 4) = (u8 )(v & 255U);
#line 121
  v >>= 8;
#line 121
  *(bp + 5) = (u8 )(v & 255U);
#line 122
  v >>= 8;
#line 122
  *(bp + 6) = (u8 )(v & 255U);
#line 123
  v >>= 8;
#line 123
  *(bp + 7) = (u8 )(v & 255U);
#line 126
  md5_process_block((void const   *)(ctx->buffer), ((size_t )bytes + pad) + 8UL, ctx);
#line 128
  tmp = md5_read_ctx((struct md5_ctx  const  *)ctx, resbuf);
  }
#line 128
  return (tmp);
}
}
#line 134 "/home/wheatley/newnew/temp/parchive-1.1/md5.c"
i64 md5_stream(FILE *stream , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  i64 tot ;
  size_t n ;
  int tmp ;

  {
  {
#line 146
  tot = (i64 )0;
#line 149
  md5_init_ctx(& ctx);
  }
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    sum = (size_t )0;
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 163
      n = fread((void */* __restrict  */)(buffer + sum), (size_t )1, 4096UL - sum,
                (FILE */* __restrict  */)stream);
#line 165
      sum += n;
      }
#line 161
      if (sum < 4096UL) {
#line 161
        if (! (n != 0UL)) {
#line 161
          goto while_break___0;
        }
      } else {
#line 161
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 168
    if (n == 0UL) {
      {
#line 168
      tmp = ferror(stream);
      }
#line 168
      if (tmp) {
#line 169
        return ((i64 )-1);
      }
    }
#line 172
    if (n == 0UL) {
#line 173
      goto while_break;
    }
    {
#line 178
    md5_process_block((void const   *)(buffer), (size_t )4096, & ctx);
#line 179
    tot += 4096LL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  if (sum > 0UL) {
    {
#line 184
    md5_process_bytes((void const   *)(buffer), sum, & ctx);
    }
  }
  {
#line 186
  tot += (i64 )sum;
#line 189
  md5_finish_ctx(& ctx, resblock);
  }
#line 190
  return (tot);
}
}
#line 197 "/home/wheatley/newnew/temp/parchive-1.1/md5.c"
void *md5_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  void *tmp ;

  {
  {
#line 206
  md5_init_ctx(& ctx);
#line 209
  md5_process_bytes((void const   *)buffer, len, & ctx);
#line 212
  tmp = md5_finish_ctx(& ctx, resblock);
  }
#line 212
  return (tmp);
}
}
#line 216 "/home/wheatley/newnew/temp/parchive-1.1/md5.c"
void md5_process_bytes(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;

  {
#line 224
  if (ctx->buflen != 0U) {
#line 226
    left_over = (size_t )ctx->buflen;
#line 227
    if (128UL - left_over > len) {
#line 227
      tmp = len;
    } else {
#line 227
      tmp = 128UL - left_over;
    }
    {
#line 227
    add = tmp;
#line 229
    memcpy((void */* __restrict  */)(& ctx->buffer[left_over]), (void const   */* __restrict  */)buffer,
           add);
#line 230
    ctx->buflen = (u32 )((size_t )ctx->buflen + add);
    }
#line 232
    if (left_over + add > 64UL) {
      {
#line 234
      md5_process_block((void const   *)(ctx->buffer), (left_over + add) & 0xffffffffffffffc0UL,
                        ctx);
#line 236
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)(& ctx->buffer[(left_over + add) & 0xffffffffffffffc0UL]),
             (left_over + add) & 63UL);
#line 238
      ctx->buflen = (u32 )((left_over + add) & 63UL);
      }
    }
#line 241
    buffer = (void const   *)((char const   *)buffer + add);
#line 242
    len -= add;
  }
#line 246
  if (len > 64UL) {
    {
#line 248
    md5_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
#line 249
    buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
#line 250
    len &= 63UL;
    }
  }
#line 254
  if (len > 0UL) {
    {
#line 256
    memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer,
           len);
#line 257
    ctx->buflen = (u32 )len;
    }
  }
#line 259
  return;
}
}
#line 274 "/home/wheatley/newnew/temp/parchive-1.1/md5.c"
void md5_process_block(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ 
  u32 correct_words[16] ;
  u8 const   *words ;
  u8 const   *endp ;
  u32 A ;
  u32 B ;
  u32 C ;
  u32 D ;
  u32 *cwp ;
  u32 A_save ;
  u32 B_save ;
  u32 C_save ;
  u32 D_save ;
  u8 const   *tmp ;
  u8 const   *tmp___0 ;
  u8 const   *tmp___1 ;
  u8 const   *tmp___2 ;
  u32 *tmp___3 ;
  u8 const   *tmp___4 ;
  u8 const   *tmp___5 ;
  u8 const   *tmp___6 ;
  u8 const   *tmp___7 ;
  u32 *tmp___8 ;
  u8 const   *tmp___9 ;
  u8 const   *tmp___10 ;
  u8 const   *tmp___11 ;
  u8 const   *tmp___12 ;
  u32 *tmp___13 ;
  u8 const   *tmp___14 ;
  u8 const   *tmp___15 ;
  u8 const   *tmp___16 ;
  u8 const   *tmp___17 ;
  u32 *tmp___18 ;
  u8 const   *tmp___19 ;
  u8 const   *tmp___20 ;
  u8 const   *tmp___21 ;
  u8 const   *tmp___22 ;
  u32 *tmp___23 ;
  u8 const   *tmp___24 ;
  u8 const   *tmp___25 ;
  u8 const   *tmp___26 ;
  u8 const   *tmp___27 ;
  u32 *tmp___28 ;
  u8 const   *tmp___29 ;
  u8 const   *tmp___30 ;
  u8 const   *tmp___31 ;
  u8 const   *tmp___32 ;
  u32 *tmp___33 ;
  u8 const   *tmp___34 ;
  u8 const   *tmp___35 ;
  u8 const   *tmp___36 ;
  u8 const   *tmp___37 ;
  u32 *tmp___38 ;
  u8 const   *tmp___39 ;
  u8 const   *tmp___40 ;
  u8 const   *tmp___41 ;
  u8 const   *tmp___42 ;
  u32 *tmp___43 ;
  u8 const   *tmp___44 ;
  u8 const   *tmp___45 ;
  u8 const   *tmp___46 ;
  u8 const   *tmp___47 ;
  u32 *tmp___48 ;
  u8 const   *tmp___49 ;
  u8 const   *tmp___50 ;
  u8 const   *tmp___51 ;
  u8 const   *tmp___52 ;
  u32 *tmp___53 ;
  u8 const   *tmp___54 ;
  u8 const   *tmp___55 ;
  u8 const   *tmp___56 ;
  u8 const   *tmp___57 ;
  u32 *tmp___58 ;
  u8 const   *tmp___59 ;
  u8 const   *tmp___60 ;
  u8 const   *tmp___61 ;
  u8 const   *tmp___62 ;
  u32 *tmp___63 ;
  u8 const   *tmp___64 ;
  u8 const   *tmp___65 ;
  u8 const   *tmp___66 ;
  u8 const   *tmp___67 ;
  u32 *tmp___68 ;
  u8 const   *tmp___69 ;
  u8 const   *tmp___70 ;
  u8 const   *tmp___71 ;
  u8 const   *tmp___72 ;
  u32 *tmp___73 ;
  u8 const   *tmp___74 ;
  u8 const   *tmp___75 ;
  u8 const   *tmp___76 ;
  u8 const   *tmp___77 ;
  u32 *tmp___78 ;

  {
#line 281
  words = (u8 const   *)buffer;
#line 282
  endp = words + len;
#line 283
  A = ctx->A;
#line 284
  B = ctx->B;
#line 285
  C = ctx->C;
#line 286
  D = ctx->D;
#line 291
  ctx->total[0] = (u32 )((size_t )ctx->total[0] + len);
#line 292
  if ((size_t )ctx->total[0] < len) {
#line 293
    (ctx->total[1]) ++;
  }
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! ((unsigned long )words < (unsigned long )endp)) {
#line 297
      goto while_break;
    }
#line 299
    cwp = correct_words;
#line 300
    A_save = A;
#line 301
    B_save = B;
#line 302
    C_save = C;
#line 303
    D_save = D;
    {
#line 336
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 336
      tmp = words;
#line 336
      words ++;
#line 336
      *cwp = (u32 )*tmp;
#line 336
      tmp___0 = words;
#line 336
      words ++;
#line 336
      *cwp |= (unsigned int )((int const   )*tmp___0 << 8);
#line 336
      tmp___1 = words;
#line 336
      words ++;
#line 336
      *cwp |= (unsigned int )((int const   )*tmp___1 << 16);
#line 336
      tmp___2 = words;
#line 336
      words ++;
#line 336
      *cwp |= (unsigned int )((int const   )*tmp___2 << 24);
#line 336
      tmp___3 = cwp;
#line 336
      cwp ++;
#line 336
      A += ((D ^ (B & (C ^ D))) + *tmp___3) + 3614090360U;
#line 336
      A = (A << 7) | (A >> 25);
#line 336
      A += B;
#line 336
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 337
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 337
      tmp___4 = words;
#line 337
      words ++;
#line 337
      *cwp = (u32 )*tmp___4;
#line 337
      tmp___5 = words;
#line 337
      words ++;
#line 337
      *cwp |= (unsigned int )((int const   )*tmp___5 << 8);
#line 337
      tmp___6 = words;
#line 337
      words ++;
#line 337
      *cwp |= (unsigned int )((int const   )*tmp___6 << 16);
#line 337
      tmp___7 = words;
#line 337
      words ++;
#line 337
      *cwp |= (unsigned int )((int const   )*tmp___7 << 24);
#line 337
      tmp___8 = cwp;
#line 337
      cwp ++;
#line 337
      D += ((C ^ (A & (B ^ C))) + *tmp___8) + 3905402710U;
#line 337
      D = (D << 12) | (D >> 20);
#line 337
      D += A;
#line 337
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 338
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 338
      tmp___9 = words;
#line 338
      words ++;
#line 338
      *cwp = (u32 )*tmp___9;
#line 338
      tmp___10 = words;
#line 338
      words ++;
#line 338
      *cwp |= (unsigned int )((int const   )*tmp___10 << 8);
#line 338
      tmp___11 = words;
#line 338
      words ++;
#line 338
      *cwp |= (unsigned int )((int const   )*tmp___11 << 16);
#line 338
      tmp___12 = words;
#line 338
      words ++;
#line 338
      *cwp |= (unsigned int )((int const   )*tmp___12 << 24);
#line 338
      tmp___13 = cwp;
#line 338
      cwp ++;
#line 338
      C += ((B ^ (D & (A ^ B))) + *tmp___13) + 606105819U;
#line 338
      C = (C << 17) | (C >> 15);
#line 338
      C += D;
#line 338
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 339
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 339
      tmp___14 = words;
#line 339
      words ++;
#line 339
      *cwp = (u32 )*tmp___14;
#line 339
      tmp___15 = words;
#line 339
      words ++;
#line 339
      *cwp |= (unsigned int )((int const   )*tmp___15 << 8);
#line 339
      tmp___16 = words;
#line 339
      words ++;
#line 339
      *cwp |= (unsigned int )((int const   )*tmp___16 << 16);
#line 339
      tmp___17 = words;
#line 339
      words ++;
#line 339
      *cwp |= (unsigned int )((int const   )*tmp___17 << 24);
#line 339
      tmp___18 = cwp;
#line 339
      cwp ++;
#line 339
      B += ((A ^ (C & (D ^ A))) + *tmp___18) + 3250441966U;
#line 339
      B = (B << 22) | (B >> 10);
#line 339
      B += C;
#line 339
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 340
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 340
      tmp___19 = words;
#line 340
      words ++;
#line 340
      *cwp = (u32 )*tmp___19;
#line 340
      tmp___20 = words;
#line 340
      words ++;
#line 340
      *cwp |= (unsigned int )((int const   )*tmp___20 << 8);
#line 340
      tmp___21 = words;
#line 340
      words ++;
#line 340
      *cwp |= (unsigned int )((int const   )*tmp___21 << 16);
#line 340
      tmp___22 = words;
#line 340
      words ++;
#line 340
      *cwp |= (unsigned int )((int const   )*tmp___22 << 24);
#line 340
      tmp___23 = cwp;
#line 340
      cwp ++;
#line 340
      A += ((D ^ (B & (C ^ D))) + *tmp___23) + 4118548399U;
#line 340
      A = (A << 7) | (A >> 25);
#line 340
      A += B;
#line 340
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 341
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 341
      tmp___24 = words;
#line 341
      words ++;
#line 341
      *cwp = (u32 )*tmp___24;
#line 341
      tmp___25 = words;
#line 341
      words ++;
#line 341
      *cwp |= (unsigned int )((int const   )*tmp___25 << 8);
#line 341
      tmp___26 = words;
#line 341
      words ++;
#line 341
      *cwp |= (unsigned int )((int const   )*tmp___26 << 16);
#line 341
      tmp___27 = words;
#line 341
      words ++;
#line 341
      *cwp |= (unsigned int )((int const   )*tmp___27 << 24);
#line 341
      tmp___28 = cwp;
#line 341
      cwp ++;
#line 341
      D += ((C ^ (A & (B ^ C))) + *tmp___28) + 1200080426U;
#line 341
      D = (D << 12) | (D >> 20);
#line 341
      D += A;
#line 341
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 342
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 342
      tmp___29 = words;
#line 342
      words ++;
#line 342
      *cwp = (u32 )*tmp___29;
#line 342
      tmp___30 = words;
#line 342
      words ++;
#line 342
      *cwp |= (unsigned int )((int const   )*tmp___30 << 8);
#line 342
      tmp___31 = words;
#line 342
      words ++;
#line 342
      *cwp |= (unsigned int )((int const   )*tmp___31 << 16);
#line 342
      tmp___32 = words;
#line 342
      words ++;
#line 342
      *cwp |= (unsigned int )((int const   )*tmp___32 << 24);
#line 342
      tmp___33 = cwp;
#line 342
      cwp ++;
#line 342
      C += ((B ^ (D & (A ^ B))) + *tmp___33) + 2821735955U;
#line 342
      C = (C << 17) | (C >> 15);
#line 342
      C += D;
#line 342
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 343
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 343
      tmp___34 = words;
#line 343
      words ++;
#line 343
      *cwp = (u32 )*tmp___34;
#line 343
      tmp___35 = words;
#line 343
      words ++;
#line 343
      *cwp |= (unsigned int )((int const   )*tmp___35 << 8);
#line 343
      tmp___36 = words;
#line 343
      words ++;
#line 343
      *cwp |= (unsigned int )((int const   )*tmp___36 << 16);
#line 343
      tmp___37 = words;
#line 343
      words ++;
#line 343
      *cwp |= (unsigned int )((int const   )*tmp___37 << 24);
#line 343
      tmp___38 = cwp;
#line 343
      cwp ++;
#line 343
      B += ((A ^ (C & (D ^ A))) + *tmp___38) + 4249261313U;
#line 343
      B = (B << 22) | (B >> 10);
#line 343
      B += C;
#line 343
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 344
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 344
      tmp___39 = words;
#line 344
      words ++;
#line 344
      *cwp = (u32 )*tmp___39;
#line 344
      tmp___40 = words;
#line 344
      words ++;
#line 344
      *cwp |= (unsigned int )((int const   )*tmp___40 << 8);
#line 344
      tmp___41 = words;
#line 344
      words ++;
#line 344
      *cwp |= (unsigned int )((int const   )*tmp___41 << 16);
#line 344
      tmp___42 = words;
#line 344
      words ++;
#line 344
      *cwp |= (unsigned int )((int const   )*tmp___42 << 24);
#line 344
      tmp___43 = cwp;
#line 344
      cwp ++;
#line 344
      A += ((D ^ (B & (C ^ D))) + *tmp___43) + 1770035416U;
#line 344
      A = (A << 7) | (A >> 25);
#line 344
      A += B;
#line 344
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 345
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 345
      tmp___44 = words;
#line 345
      words ++;
#line 345
      *cwp = (u32 )*tmp___44;
#line 345
      tmp___45 = words;
#line 345
      words ++;
#line 345
      *cwp |= (unsigned int )((int const   )*tmp___45 << 8);
#line 345
      tmp___46 = words;
#line 345
      words ++;
#line 345
      *cwp |= (unsigned int )((int const   )*tmp___46 << 16);
#line 345
      tmp___47 = words;
#line 345
      words ++;
#line 345
      *cwp |= (unsigned int )((int const   )*tmp___47 << 24);
#line 345
      tmp___48 = cwp;
#line 345
      cwp ++;
#line 345
      D += ((C ^ (A & (B ^ C))) + *tmp___48) + 2336552879U;
#line 345
      D = (D << 12) | (D >> 20);
#line 345
      D += A;
#line 345
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 346
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 346
      tmp___49 = words;
#line 346
      words ++;
#line 346
      *cwp = (u32 )*tmp___49;
#line 346
      tmp___50 = words;
#line 346
      words ++;
#line 346
      *cwp |= (unsigned int )((int const   )*tmp___50 << 8);
#line 346
      tmp___51 = words;
#line 346
      words ++;
#line 346
      *cwp |= (unsigned int )((int const   )*tmp___51 << 16);
#line 346
      tmp___52 = words;
#line 346
      words ++;
#line 346
      *cwp |= (unsigned int )((int const   )*tmp___52 << 24);
#line 346
      tmp___53 = cwp;
#line 346
      cwp ++;
#line 346
      C += ((B ^ (D & (A ^ B))) + *tmp___53) + 4294925233U;
#line 346
      C = (C << 17) | (C >> 15);
#line 346
      C += D;
#line 346
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 347
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 347
      tmp___54 = words;
#line 347
      words ++;
#line 347
      *cwp = (u32 )*tmp___54;
#line 347
      tmp___55 = words;
#line 347
      words ++;
#line 347
      *cwp |= (unsigned int )((int const   )*tmp___55 << 8);
#line 347
      tmp___56 = words;
#line 347
      words ++;
#line 347
      *cwp |= (unsigned int )((int const   )*tmp___56 << 16);
#line 347
      tmp___57 = words;
#line 347
      words ++;
#line 347
      *cwp |= (unsigned int )((int const   )*tmp___57 << 24);
#line 347
      tmp___58 = cwp;
#line 347
      cwp ++;
#line 347
      B += ((A ^ (C & (D ^ A))) + *tmp___58) + 2304563134U;
#line 347
      B = (B << 22) | (B >> 10);
#line 347
      B += C;
#line 347
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 348
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 348
      tmp___59 = words;
#line 348
      words ++;
#line 348
      *cwp = (u32 )*tmp___59;
#line 348
      tmp___60 = words;
#line 348
      words ++;
#line 348
      *cwp |= (unsigned int )((int const   )*tmp___60 << 8);
#line 348
      tmp___61 = words;
#line 348
      words ++;
#line 348
      *cwp |= (unsigned int )((int const   )*tmp___61 << 16);
#line 348
      tmp___62 = words;
#line 348
      words ++;
#line 348
      *cwp |= (unsigned int )((int const   )*tmp___62 << 24);
#line 348
      tmp___63 = cwp;
#line 348
      cwp ++;
#line 348
      A += ((D ^ (B & (C ^ D))) + *tmp___63) + 1804603682U;
#line 348
      A = (A << 7) | (A >> 25);
#line 348
      A += B;
#line 348
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 349
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 349
      tmp___64 = words;
#line 349
      words ++;
#line 349
      *cwp = (u32 )*tmp___64;
#line 349
      tmp___65 = words;
#line 349
      words ++;
#line 349
      *cwp |= (unsigned int )((int const   )*tmp___65 << 8);
#line 349
      tmp___66 = words;
#line 349
      words ++;
#line 349
      *cwp |= (unsigned int )((int const   )*tmp___66 << 16);
#line 349
      tmp___67 = words;
#line 349
      words ++;
#line 349
      *cwp |= (unsigned int )((int const   )*tmp___67 << 24);
#line 349
      tmp___68 = cwp;
#line 349
      cwp ++;
#line 349
      D += ((C ^ (A & (B ^ C))) + *tmp___68) + 4254626195U;
#line 349
      D = (D << 12) | (D >> 20);
#line 349
      D += A;
#line 349
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 350
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 350
      tmp___69 = words;
#line 350
      words ++;
#line 350
      *cwp = (u32 )*tmp___69;
#line 350
      tmp___70 = words;
#line 350
      words ++;
#line 350
      *cwp |= (unsigned int )((int const   )*tmp___70 << 8);
#line 350
      tmp___71 = words;
#line 350
      words ++;
#line 350
      *cwp |= (unsigned int )((int const   )*tmp___71 << 16);
#line 350
      tmp___72 = words;
#line 350
      words ++;
#line 350
      *cwp |= (unsigned int )((int const   )*tmp___72 << 24);
#line 350
      tmp___73 = cwp;
#line 350
      cwp ++;
#line 350
      C += ((B ^ (D & (A ^ B))) + *tmp___73) + 2792965006U;
#line 350
      C = (C << 17) | (C >> 15);
#line 350
      C += D;
#line 350
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 351
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 351
      tmp___74 = words;
#line 351
      words ++;
#line 351
      *cwp = (u32 )*tmp___74;
#line 351
      tmp___75 = words;
#line 351
      words ++;
#line 351
      *cwp |= (unsigned int )((int const   )*tmp___75 << 8);
#line 351
      tmp___76 = words;
#line 351
      words ++;
#line 351
      *cwp |= (unsigned int )((int const   )*tmp___76 << 16);
#line 351
      tmp___77 = words;
#line 351
      words ++;
#line 351
      *cwp |= (unsigned int )((int const   )*tmp___77 << 24);
#line 351
      tmp___78 = cwp;
#line 351
      cwp ++;
#line 351
      B += ((A ^ (C & (D ^ A))) + *tmp___78) + 1236535329U;
#line 351
      B = (B << 22) | (B >> 10);
#line 351
      B += C;
#line 351
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 367
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 367
      A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
#line 367
      A = (A << 5) | (A >> 27);
#line 367
      A += B;
#line 367
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 368
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 368
      D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
#line 368
      D = (D << 9) | (D >> 23);
#line 368
      D += A;
#line 368
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 369
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 369
      C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
#line 369
      C = (C << 14) | (C >> 18);
#line 369
      C += D;
#line 369
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 370
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 370
      B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
#line 370
      B = (B << 20) | (B >> 12);
#line 370
      B += C;
#line 370
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 371
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 371
      A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
#line 371
      A = (A << 5) | (A >> 27);
#line 371
      A += B;
#line 371
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 372
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 372
      D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
#line 372
      D = (D << 9) | (D >> 23);
#line 372
      D += A;
#line 372
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 373
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 373
      C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
#line 373
      C = (C << 14) | (C >> 18);
#line 373
      C += D;
#line 373
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 374
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 374
      B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
#line 374
      B = (B << 20) | (B >> 12);
#line 374
      B += C;
#line 374
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 375
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 375
      A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
#line 375
      A = (A << 5) | (A >> 27);
#line 375
      A += B;
#line 375
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 376
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 376
      D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
#line 376
      D = (D << 9) | (D >> 23);
#line 376
      D += A;
#line 376
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 377
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 377
      C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
#line 377
      C = (C << 14) | (C >> 18);
#line 377
      C += D;
#line 377
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 378
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 378
      B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
#line 378
      B = (B << 20) | (B >> 12);
#line 378
      B += C;
#line 378
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 379
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 379
      A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
#line 379
      A = (A << 5) | (A >> 27);
#line 379
      A += B;
#line 379
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 380
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 380
      D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
#line 380
      D = (D << 9) | (D >> 23);
#line 380
      D += A;
#line 380
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 381
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 381
      C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
#line 381
      C = (C << 14) | (C >> 18);
#line 381
      C += D;
#line 381
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 382
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 382
      B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
#line 382
      B = (B << 20) | (B >> 12);
#line 382
      B += C;
#line 382
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 385
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 385
      A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
#line 385
      A = (A << 4) | (A >> 28);
#line 385
      A += B;
#line 385
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 386
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 386
      D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
#line 386
      D = (D << 11) | (D >> 21);
#line 386
      D += A;
#line 386
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 387
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 387
      C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
#line 387
      C = (C << 16) | (C >> 16);
#line 387
      C += D;
#line 387
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 388
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 388
      B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
#line 388
      B = (B << 23) | (B >> 9);
#line 388
      B += C;
#line 388
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    {
#line 389
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 389
      A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
#line 389
      A = (A << 4) | (A >> 28);
#line 389
      A += B;
#line 389
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    {
#line 390
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 390
      D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
#line 390
      D = (D << 11) | (D >> 21);
#line 390
      D += A;
#line 390
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 391
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 391
      C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
#line 391
      C = (C << 16) | (C >> 16);
#line 391
      C += D;
#line 391
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 392
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 392
      B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
#line 392
      B = (B << 23) | (B >> 9);
#line 392
      B += C;
#line 392
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 393
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 393
      A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
#line 393
      A = (A << 4) | (A >> 28);
#line 393
      A += B;
#line 393
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    {
#line 394
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 394
      D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
#line 394
      D = (D << 11) | (D >> 21);
#line 394
      D += A;
#line 394
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    {
#line 395
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 395
      C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
#line 395
      C = (C << 16) | (C >> 16);
#line 395
      C += D;
#line 395
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    {
#line 396
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 396
      B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
#line 396
      B = (B << 23) | (B >> 9);
#line 396
      B += C;
#line 396
      goto while_break___43;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 397
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 397
      A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
#line 397
      A = (A << 4) | (A >> 28);
#line 397
      A += B;
#line 397
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 398
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 398
      D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
#line 398
      D = (D << 11) | (D >> 21);
#line 398
      D += A;
#line 398
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
    {
#line 399
    while (1) {
      while_continue___46: /* CIL Label */ ;
#line 399
      C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
#line 399
      C = (C << 16) | (C >> 16);
#line 399
      C += D;
#line 399
      goto while_break___46;
    }
    while_break___46: /* CIL Label */ ;
    }
    {
#line 400
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 400
      B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
#line 400
      B = (B << 23) | (B >> 9);
#line 400
      B += C;
#line 400
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
    {
#line 403
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 403
      A += ((C ^ (B | ~ D)) + correct_words[0]) + 4096336452U;
#line 403
      A = (A << 6) | (A >> 26);
#line 403
      A += B;
#line 403
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 404
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 404
      D += ((B ^ (A | ~ C)) + correct_words[7]) + 1126891415U;
#line 404
      D = (D << 10) | (D >> 22);
#line 404
      D += A;
#line 404
      goto while_break___49;
    }
    while_break___49: /* CIL Label */ ;
    }
    {
#line 405
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 405
      C += ((A ^ (D | ~ B)) + correct_words[14]) + 2878612391U;
#line 405
      C = (C << 15) | (C >> 17);
#line 405
      C += D;
#line 405
      goto while_break___50;
    }
    while_break___50: /* CIL Label */ ;
    }
    {
#line 406
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 406
      B += ((D ^ (C | ~ A)) + correct_words[5]) + 4237533241U;
#line 406
      B = (B << 21) | (B >> 11);
#line 406
      B += C;
#line 406
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 407
    while (1) {
      while_continue___52: /* CIL Label */ ;
#line 407
      A += ((C ^ (B | ~ D)) + correct_words[12]) + 1700485571U;
#line 407
      A = (A << 6) | (A >> 26);
#line 407
      A += B;
#line 407
      goto while_break___52;
    }
    while_break___52: /* CIL Label */ ;
    }
    {
#line 408
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 408
      D += ((B ^ (A | ~ C)) + correct_words[3]) + 2399980690U;
#line 408
      D = (D << 10) | (D >> 22);
#line 408
      D += A;
#line 408
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
    {
#line 409
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 409
      C += ((A ^ (D | ~ B)) + correct_words[10]) + 4293915773U;
#line 409
      C = (C << 15) | (C >> 17);
#line 409
      C += D;
#line 409
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
    {
#line 410
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 410
      B += ((D ^ (C | ~ A)) + correct_words[1]) + 2240044497U;
#line 410
      B = (B << 21) | (B >> 11);
#line 410
      B += C;
#line 410
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
    {
#line 411
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 411
      A += ((C ^ (B | ~ D)) + correct_words[8]) + 1873313359U;
#line 411
      A = (A << 6) | (A >> 26);
#line 411
      A += B;
#line 411
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 412
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 412
      D += ((B ^ (A | ~ C)) + correct_words[15]) + 4264355552U;
#line 412
      D = (D << 10) | (D >> 22);
#line 412
      D += A;
#line 412
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    {
#line 413
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 413
      C += ((A ^ (D | ~ B)) + correct_words[6]) + 2734768916U;
#line 413
      C = (C << 15) | (C >> 17);
#line 413
      C += D;
#line 413
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 414
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 414
      B += ((D ^ (C | ~ A)) + correct_words[13]) + 1309151649U;
#line 414
      B = (B << 21) | (B >> 11);
#line 414
      B += C;
#line 414
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 415
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 415
      A += ((C ^ (B | ~ D)) + correct_words[4]) + 4149444226U;
#line 415
      A = (A << 6) | (A >> 26);
#line 415
      A += B;
#line 415
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 416
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 416
      D += ((B ^ (A | ~ C)) + correct_words[11]) + 3174756917U;
#line 416
      D = (D << 10) | (D >> 22);
#line 416
      D += A;
#line 416
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    {
#line 417
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 417
      C += ((A ^ (D | ~ B)) + correct_words[2]) + 718787259U;
#line 417
      C = (C << 15) | (C >> 17);
#line 417
      C += D;
#line 417
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 418
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 418
      B += ((D ^ (C | ~ A)) + correct_words[9]) + 3951481745U;
#line 418
      B = (B << 21) | (B >> 11);
#line 418
      B += C;
#line 418
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
#line 421
    A += A_save;
#line 422
    B += B_save;
#line 423
    C += C_save;
#line 424
    D += D_save;
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  ctx->A = A;
#line 429
  ctx->B = B;
#line 430
  ctx->C = C;
#line 431
  ctx->D = D;
#line 432
  return;
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 47 "/home/wheatley/newnew/temp/parchive-1.1/fileops.h"
i64 uni_copy(u16 *dst , u16 *src , i64 n ) ;
#line 49
int file_rename(u16 *src , u16 *dst ) ;
#line 53
int file_exists(u16 *file ) ;
#line 56
i64 file_md5(u16 *file , u8 *block ) ;
#line 57
int file_md5_buffer(u16 *file , u8 *block , u8 *buf___3 , i64 size ) ;
#line 59
int file_get_md5(file_t f , i64 off , u8 *block ) ;
#line 61
hfile_t *read_dir(char *dir ) ;
#line 28 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
hfile_t *hfile  =    (hfile_t *)0;
#line 30 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
char *basename(u16 *path ) 
{ 
  u16 *ret___0 ;
  char *tmp ;

  {
#line 35
  ret___0 = path;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! *path) {
#line 35
      goto while_break;
    }
#line 36
    if ((int )*path == 47) {
#line 37
      ret___0 = path + 1;
    }
#line 35
    path ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 38
  tmp = stuni((u16 const   *)ret___0);
  }
#line 38
  return (tmp);
}
}
#line 45 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
int unicode_gt(u16 *a , u16 *b ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! *a) {
#line 48
      if (! *b) {
#line 48
        goto while_break;
      }
    }
    {
#line 49
    tmp = tolower((int )*a);
#line 49
    tmp___0 = tolower((int )*b);
    }
#line 49
    if (tmp > tmp___0) {
#line 49
      return (1);
    }
    {
#line 50
    tmp___1 = tolower((int )*a);
#line 50
    tmp___2 = tolower((int )*b);
    }
#line 50
    if (tmp___1 < tmp___2) {
#line 50
      return (0);
    }
#line 48
    a ++;
#line 48
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (0);
}
}
#line 61 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
int unicode_cmp(u16 *a , u16 *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! ((int )*a == (int )*b)) {
#line 64
      goto while_break;
    }
#line 65
    if (! *a) {
#line 65
      return (0);
    }
#line 64
    a ++;
#line 64
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  if (! cmd.usecase) {
    {
#line 67
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 67
      tmp = tolower((int )*a);
#line 67
      tmp___0 = tolower((int )*b);
      }
#line 67
      if (! (tmp == tmp___0)) {
#line 67
        goto while_break___0;
      }
#line 68
      if (! *a) {
#line 68
        return (1);
      }
#line 67
      a ++;
#line 67
      b ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 69
  return (-1);
}
}
#line 75 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
static int rename_file(u16 *src , u16 *dst ) 
{ 
  hfile_t *p ;
  int n ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 81
  tmp = basename(src);
#line 81
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Rename: %s",
          tmp);
#line 82
  tmp___0 = basename(dst);
#line 82
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -> %s",
          tmp___0);
#line 83
  n = file_rename(src, dst);
  }
#line 84
  if (n) {
    {
#line 85
    perror(" ");
    }
#line 86
    return (n);
  }
  {
#line 88
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 92
  p = hfile;
  }
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! p) {
#line 92
      goto while_break;
    }
    {
#line 93
    tmp___1 = unicode_cmp(p->filename, src);
    }
#line 93
    if (! tmp___1) {
      {
#line 94
      free((void *)p->filename);
#line 95
      p->filename = unicode_copy(dst);
      }
    }
#line 92
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return (0);
}
}
#line 101 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
hfile_t *hfile_add(u16 *filename ) 
{ 
  hfile_t **pp ;
  void *tmp ;

  {
#line 107
  pp = & hfile;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! *pp) {
#line 107
      goto while_break;
    }
#line 107
    pp = & (*pp)->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  tmp = calloc(sizeof(*(*pp)), (size_t )1);
#line 109
  *pp = (hfile_t *)tmp;
#line 110
  (*pp)->filename = unicode_copy(filename);
  }
#line 111
  return (*pp);
}
}
#line 117 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
void hash_directory(char *dir ) 
{ 
  hfile_t *p ;
  hfile_t *q ;
  hfile_t **pp ;
  int tmp ;

  {
  {
#line 123
  p = read_dir(dir);
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! p) {
#line 123
      goto while_break;
    }
#line 124
    pp = & hfile;
    {
#line 124
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 124
      if (! *pp) {
#line 124
        goto while_break___0;
      }
      {
#line 125
      tmp = unicode_cmp(p->filename, (*pp)->filename);
      }
#line 125
      if (! tmp) {
#line 126
        goto while_break___0;
      }
#line 124
      pp = & (*pp)->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    if (*pp) {
      {
#line 128
      q = p;
#line 129
      p = p->next;
#line 130
      free((void *)q);
      }
    } else {
#line 132
      *pp = p;
#line 133
      p = p->next;
#line 134
      (*pp)->next = (hfile_t *)0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  return;
}
}
#line 142 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
int hash_file(hfile_t *file , char type ) 
{ 
  i64 s ;
  u8 buf___3[16384] ;
  int tmp ;

  {
#line 148
  if ((int )type < 1) {
#line 148
    return (1);
  }
#line 149
  if ((int )file->hashed < 1) {
    {
#line 150
    tmp = file_md5_buffer(file->filename, (u8 *)(file->hash_16k), buf___3, (i64 )sizeof(buf___3));
    }
#line 150
    if (! tmp) {
#line 152
      return (0);
    }
    {
#line 153
    file->hashed = (u8 )1;
#line 154
    memcpy((void */* __restrict  */)(& file->magic), (void const   */* __restrict  */)(buf___3),
           sizeof(file->magic));
    }
  }
#line 156
  if ((int )type < 2) {
#line 156
    return (1);
  }
#line 157
  if ((int )file->hashed < 2) {
    {
#line 158
    s = file_md5(file->filename, (u8 *)(file->hash));
    }
#line 159
    if (s >= 0LL) {
#line 160
      file->hashed = (u8 )2;
#line 161
      if (! file->file_size) {
#line 162
        file->file_size = s;
      }
    }
  }
#line 165
  return (1);
}
}
#line 173 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
int move_away(u16 *file , u8 const   *ext ) 
{ 
  u16 *fn ;
  int l ;
  int i ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  u8 const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 179
  tmp = file_exists(file);
  }
#line 179
  if (! tmp) {
#line 180
    return (0);
  }
#line 181
  if (! cmd.move) {
#line 182
    return (-1);
  }
#line 183
  i = 0;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! *(file + i)) {
#line 183
      goto while_break;
    }
#line 183
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  tmp___0 = strlen((char const   *)ext);
#line 185
  l = (int )((size_t )i + tmp___0);
#line 186
  tmp___1 = malloc(sizeof(*fn) * (unsigned long )(l + 1));
#line 186
  fn = (u16 *)tmp___1;
#line 187
  memcpy((void */* __restrict  */)fn, (void const   */* __restrict  */)file, (unsigned long )i * sizeof(*fn));
  }
  {
#line 188
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 188
    if (! (i <= l)) {
#line 188
      goto while_break___0;
    }
#line 189
    tmp___2 = ext;
#line 189
    ext ++;
#line 189
    *(fn + i) = (u16 )*tmp___2;
#line 188
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 191
  i = 0;
  {
#line 192
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 192
    tmp___3 = file_exists(fn);
    }
#line 192
    if (! tmp___3) {
#line 192
      goto while_break___1;
    }
#line 193
    if (i > 99) {
#line 193
      return (-1);
    }
#line 194
    *(fn + (l - 2)) = (u16 )(48 + i / 10);
#line 195
    *(fn + (l - 1)) = (u16 )(48 + i % 10);
#line 196
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 198
  i = rename_file(file, fn);
#line 199
  free((void *)fn);
  }
#line 200
  return (i);
}
}
#line 206 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
int rename_away(u16 *src , u16 *dst ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 209
  tmp___2 = move_away(dst, (u8 const   *)".bad");
  }
#line 209
  if (tmp___2) {
    {
#line 210
    tmp = basename(src);
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Rename: %s",
            tmp);
#line 211
    tmp___0 = basename(dst);
#line 211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -> %s : ",
            tmp___0);
#line 212
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File exists\n");
    }
#line 213
    return (-1);
  } else {
    {
#line 214
    tmp___1 = rename_file(src, dst);
    }
#line 214
    if (tmp___1) {
#line 215
      return (-1);
    } else {
#line 217
      return (0);
    }
  }
}
}
#line 225 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
int find_file(pfile_t *file , int displ ) 
{ 
  hfile_t *p ;
  int cm ;
  int corr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;

  {
#line 229
  corr = 0;
#line 231
  if (file->match) {
#line 231
    return (1);
  }
#line 234
  p = hfile;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! p) {
#line 234
      goto while_break;
    }
    {
#line 235
    cm = unicode_cmp(p->filename, file->filename);
    }
#line 236
    if (cm < 0) {
#line 236
      goto __Cont;
    }
    {
#line 237
    tmp___0 = hash_file(p, (char)2);
    }
#line 237
    if (! tmp___0) {
#line 238
      if (displ) {
        {
#line 239
        tmp = basename(p->filename);
#line 239
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      ERROR: %s",
                tmp);
#line 241
        perror(" ");
        }
      }
#line 243
      corr = 1;
#line 244
      goto __Cont;
    }
    {
#line 246
    tmp___1 = memcmp((void const   *)(p->hash), (void const   *)(file->hash), sizeof(md5 ));
    }
#line 246
    if (! tmp___1) {
#line 247
      if (! cm) {
#line 248
        file->match = p;
      } else
#line 247
      if (! file->match) {
#line 248
        file->match = p;
      }
#line 249
      goto __Cont;
    }
#line 251
    if (displ) {
      {
#line 252
      tmp___2 = basename(p->filename);
#line 252
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      ERROR: %s: Failed md5 sum\n",
              tmp___2);
      }
    }
#line 254
    corr = 1;
    __Cont: /* CIL Label */ 
#line 234
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  if (file->match) {
#line 257
    if (displ) {
      {
#line 258
      tmp___3 = basename(file->filename);
#line 258
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - OK\n",
              tmp___3);
      }
    }
#line 260
    if (! displ) {
#line 261
      return (1);
    } else
#line 260
    if (! cmd.dupl) {
#line 261
      return (1);
    }
  }
#line 265
  p = hfile;
  {
#line 265
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 265
    if (! p) {
#line 265
      goto while_break___0;
    }
#line 266
    if ((unsigned long )file->match == (unsigned long )p) {
#line 267
      goto __Cont___0;
    }
    {
#line 268
    tmp___4 = hash_file(p, (char)1);
    }
#line 268
    if (! tmp___4) {
#line 269
      goto __Cont___0;
    }
    {
#line 270
    tmp___5 = memcmp((void const   *)(p->hash_16k), (void const   *)(file->hash_16k),
                     sizeof(md5 ));
    }
#line 270
    if (tmp___5) {
#line 271
      goto __Cont___0;
    }
    {
#line 272
    tmp___6 = hash_file(p, (char)2);
    }
#line 272
    if (! tmp___6) {
#line 273
      goto __Cont___0;
    }
    {
#line 274
    tmp___7 = memcmp((void const   *)(p->hash), (void const   *)(file->hash), sizeof(md5 ));
    }
#line 274
    if (tmp___7) {
#line 275
      goto __Cont___0;
    }
#line 276
    if (! file->match) {
#line 277
      file->match = p;
#line 278
      if (displ) {
        {
#line 279
        tmp___8 = basename(file->filename);
#line 279
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - FOUND",
                tmp___8);
#line 281
        tmp___9 = basename(p->filename);
#line 281
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s\n",
                tmp___9);
        }
      }
#line 284
      if (! displ) {
#line 285
        return (1);
      } else
#line 284
      if (! cmd.dupl) {
#line 285
        return (1);
      }
    }
    {
#line 287
    tmp___10 = stuni((u16 const   *)(file->match)->filename);
#line 287
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Duplicate: %s",
            tmp___10);
#line 289
    tmp___11 = basename(p->filename);
#line 289
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" == %s\n",
            tmp___11);
    }
    __Cont___0: /* CIL Label */ 
#line 265
    p = p->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 292
  if (! file->match) {
#line 292
    if (displ) {
#line 293
      if (corr) {
#line 293
        tmp___12 = "CORRUPT";
      } else {
#line 293
        tmp___12 = "NOT FOUND";
      }
      {
#line 293
      tmp___13 = basename(file->filename);
#line 293
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - %s\n",
              tmp___13, tmp___12);
      }
    }
  }
#line 296
  return ((unsigned long )file->match != (unsigned long )((hfile_t *)0));
}
}
#line 302 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
hfile_t *find_file_name(u16 *path , int displ ) 
{ 
  hfile_t *p ;
  hfile_t *ret___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 305
  ret___0 = (hfile_t *)0;
#line 307
  tmp = stuni((u16 const   *)path);
#line 307
  hash_directory(tmp);
#line 308
  tmp___0 = stuni((u16 const   *)path);
#line 308
  tmp___1 = complete_path(tmp___0);
#line 308
  path = unist((char const   *)tmp___1);
#line 311
  p = hfile;
  }
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! p) {
#line 311
      goto while_break;
    }
    {
#line 312
    tmp___2 = unicode_cmp(p->filename, path);
    }
    {
#line 313
    if (tmp___2 == 1) {
#line 313
      goto case_1;
    }
#line 315
    if (tmp___2 == 0) {
#line 315
      goto case_0;
    }
#line 312
    goto switch_break;
    case_1: /* CIL Label */ 
#line 314
    if (ret___0) {
#line 314
      goto switch_break;
    }
    case_0: /* CIL Label */ 
#line 316
    ret___0 = p;
    switch_break: /* CIL Label */ ;
    }
#line 311
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  if (! ret___0) {
#line 319
    if (displ) {
      {
#line 320
      tmp___3 = basename(path);
#line 320
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - NOT FOUND\n",
              tmp___3);
      }
    }
  }
#line 321
  return (ret___0);
}
}
#line 329 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
hfile_t *find_volume(u16 *name , i64 vol ) 
{ 
  u16 *filename ;
  i64 i ;
  hfile_t *p ;
  hfile_t *ret___0 ;
  int nd ;
  int v ;
  void *tmp ;
  int tmp___0 ;

  {
#line 334
  ret___0 = (hfile_t *)0;
#line 337
  if (vol < 1LL) {
#line 338
    return ((hfile_t *)0);
  }
#line 339
  nd = 2;
#line 340
  v = 100;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! (vol >= (i64 )v)) {
#line 340
      goto while_break;
    }
#line 341
    nd ++;
#line 340
    v *= 10;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  i = (i64 )0;
  {
#line 342
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 342
    if (! *(name + i)) {
#line 342
      goto while_break___0;
    }
#line 342
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 344
  if ((int )*(name + (i - 1LL)) < 48) {
#line 345
    i -= 2LL;
  } else
#line 344
  if ((int )*(name + (i - 1LL)) > 57) {
#line 345
    i -= 2LL;
  } else {
    {
#line 347
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 347
      if ((int )*(name + (i - 1LL)) >= 48) {
#line 347
        if (! ((int )*(name + (i - 1LL)) <= 57)) {
#line 347
          goto while_break___1;
        }
      } else {
#line 347
        goto while_break___1;
      }
#line 348
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 350
  i += (i64 )nd;
#line 351
  tmp = malloc((size_t )((i64 )sizeof(*filename) * (i + 1LL)));
#line 351
  filename = (u16 *)tmp;
#line 352
  uni_copy(filename, name, i);
#line 353
  *(filename + i) = (u16 )0;
#line 354
  v = (int )vol;
  }
  {
#line 355
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 355
    nd --;
#line 355
    if (! (nd >= 0)) {
#line 355
      goto while_break___2;
    }
#line 356
    i --;
#line 356
    *(filename + i) = (u16 )(48 + v % 10);
#line 357
    v /= 10;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 360
  p = hfile;
  {
#line 360
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 360
    if (! p) {
#line 360
      goto while_break___3;
    }
    {
#line 361
    tmp___0 = unicode_cmp(p->filename, filename);
    }
    {
#line 362
    if (tmp___0 == 1) {
#line 362
      goto case_1;
    }
#line 364
    if (tmp___0 == 0) {
#line 364
      goto case_0;
    }
#line 361
    goto switch_break;
    case_1: /* CIL Label */ 
#line 363
    if (ret___0) {
#line 363
      goto switch_break;
    }
    case_0: /* CIL Label */ 
#line 365
    ret___0 = p;
    switch_break: /* CIL Label */ ;
    }
#line 360
    p = p->next;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 368
  if (! ret___0) {
    {
#line 369
    ret___0 = hfile_add(filename);
    }
  }
  {
#line 370
  free((void *)filename);
  }
#line 371
  return (ret___0);
}
}
#line 379 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
static int files_match(pfile_t *a , pfile_t *b , int part ) 
{ 
  pfile_t *p ;
  int tmp ;
  int tmp___0 ;

  {
#line 382
  if (part) {
    {
#line 386
    while (1) {
      while_continue: /* CIL Label */ ;
#line 386
      if (! a) {
#line 386
        goto while_break;
      }
#line 387
      if (! (a->status & 1LL)) {
#line 387
        goto __Cont;
      }
#line 388
      p = b;
      {
#line 388
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 388
        if (! p) {
#line 388
          goto while_break___0;
        }
#line 389
        if (! (p->status & 1LL)) {
#line 389
          goto __Cont___0;
        }
#line 390
        if (a->file_size != b->file_size) {
#line 390
          goto __Cont___0;
        }
        {
#line 391
        tmp = memcmp((void const   *)(a->hash), (void const   *)(b->hash), sizeof(md5 ));
        }
#line 391
        if (tmp) {
#line 391
          goto __Cont___0;
        }
#line 392
        return (1);
        __Cont___0: /* CIL Label */ 
#line 388
        p = p->next;
      }
      while_break___0: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 386
      a = a->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 395
    return (0);
  }
  {
#line 398
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 398
    if (! a) {
#line 398
      if (! b) {
#line 398
        goto while_break___1;
      }
    }
#line 399
    if (a) {
#line 399
      if (! (a->status & 1LL)) {
#line 400
        a = a->next;
#line 401
        goto while_continue___1;
      }
    }
#line 403
    if (b) {
#line 403
      if (! (b->status & 1LL)) {
#line 404
        b = b->next;
#line 405
        goto while_continue___1;
      }
    }
#line 407
    if (! a) {
#line 407
      return (0);
    } else
#line 407
    if (! b) {
#line 407
      return (0);
    }
#line 408
    if (a->file_size != b->file_size) {
#line 408
      return (0);
    }
    {
#line 409
    tmp___0 = memcmp((void const   *)(a->hash), (void const   *)(b->hash), sizeof(md5 ));
    }
#line 409
    if (tmp___0) {
#line 409
      return (0);
    }
#line 410
    a = a->next;
#line 410
    b = b->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 412
  return (1);
}
}
#line 415 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
u16 *file_numbers(pfile_t **list , pfile_t **files___0 ) 
{ 
  int i ;
  int j ;
  pfile_t *p ;
  pfile_t **qq ;
  u16 *fnrs ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 422
  i = 0;
#line 422
  p = *files___0;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! p) {
#line 422
      goto while_break;
    }
#line 423
    if (p->status & 1LL) {
#line 424
      i ++;
    }
#line 422
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 425
  tmp = malloc(sizeof(*fnrs) * (unsigned long )(i + 1));
#line 425
  fnrs = (u16 *)tmp;
#line 426
  i = 0;
  }
  {
#line 426
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 426
    if (! *files___0) {
#line 426
      goto while_break___0;
    }
#line 428
    j = 1;
#line 428
    qq = list;
    {
#line 428
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 428
      if (! *qq) {
#line 428
        goto while_break___1;
      }
#line 429
      if ((*files___0)->file_size != (*qq)->file_size) {
#line 429
        goto __Cont;
      }
      {
#line 430
      tmp___0 = memcmp((void const   *)((*files___0)->hash), (void const   *)((*qq)->hash),
                       sizeof(md5 ));
      }
#line 430
      if (tmp___0) {
#line 430
        goto __Cont;
      }
#line 431
      goto while_break___1;
      __Cont: /* CIL Label */ 
#line 428
      qq = & (*qq)->next;
#line 428
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 433
    if ((*files___0)->status & 1LL) {
#line 434
      tmp___1 = i;
#line 434
      i ++;
#line 434
      *(fnrs + tmp___1) = (u16 )j;
    }
#line 436
    if (! *qq) {
#line 437
      *qq = *files___0;
#line 438
      *files___0 = (*files___0)->next;
#line 439
      (*qq)->next = (pfile_t *)0;
    } else {
#line 441
      files___0 = & (*files___0)->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 444
  *(fnrs + i) = (u16 )0;
#line 445
  return (fnrs);
}
}
#line 448 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
int par_control_check(par_t *par ) 
{ 
  md5 hash ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 453
  if (! cmd.ctrl) {
#line 453
    return (1);
  }
#line 456
  if (par->version > 131071U) {
    {
#line 457
    tmp = basename(par->filename);
#line 457
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: PAR Version mismatch! (%x.%x)\n",
            tmp, par->version >> 16, (par->version & 65535U) >> 8);
    }
#line 460
    return (0);
  }
  {
#line 464
  tmp___1 = file_get_md5(par->f, par->control_hash_offset, (u8 *)(hash));
  }
#line 464
  if (tmp___1) {
    {
#line 464
    tmp___2 = memcmp((void const   *)(par->control_hash), (void const   *)(hash),
                     sizeof(md5 ));
    }
#line 464
    if (tmp___2) {
      {
#line 467
      tmp___0 = basename(par->filename);
#line 467
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: PAR file corrupt:control hash mismatch!\n",
              tmp___0);
      }
#line 470
      return (0);
    }
  } else {
    {
#line 467
    tmp___0 = basename(par->filename);
#line 467
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: PAR file corrupt:control hash mismatch!\n",
            tmp___0);
    }
#line 470
    return (0);
  }
#line 472
  return (1);
}
}
#line 479 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
int find_volumes(par_t *par , int tofind ) 
{ 
  int m ;
  pfile_t *v ;
  hfile_t *p ;
  par_t *tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 487
  v = (pfile_t *)0;
#line 488
  if (par->vol_number) {
    {
#line 489
    tmp___0 = calloc(sizeof(*v), (size_t )1);
#line 489
    v = (pfile_t *)tmp___0;
#line 490
    v->match = find_file_name(par->filename, 1);
#line 491
    v->vol_number = par->vol_number;
#line 492
    v->file_size = par->data_size;
#line 493
    v->fnrs = file_numbers(& par->files, & par->files);
#line 494
    v->f = par->f;
#line 495
    v->next = par->volumes;
#line 496
    par->volumes = v;
    }
  } else {
    {
#line 498
    file_close(par->f);
    }
  }
#line 500
  par->f = (file_t )0;
#line 501
  m = 0;
#line 501
  v = par->volumes;
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    if (! v) {
#line 501
      goto while_break;
    }
#line 502
    m ++;
#line 501
    v = v->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 503
  if (m >= tofind) {
#line 504
    return (m);
  }
#line 505
  if (m) {
#line 505
    tmp___1 = "additional ";
  } else {
#line 505
    tmp___1 = "";
  }
  {
#line 505
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nLooking for %sPXX volumes:\n",
          tmp___1);
#line 508
  p = hfile;
  }
  {
#line 508
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 508
    if (! p) {
#line 508
      goto while_break___0;
    }
#line 509
    if ((int )p->hashed >= 1) {
#line 509
      if (! (p->magic == *((i64 *)"PAR\000\000\000\000\000"))) {
        {
#line 509
        tmp___2 = is_old_par((void *)(& p->magic));
        }
#line 509
        if (! tmp___2) {
#line 511
          goto __Cont;
        }
      }
    }
    {
#line 512
    tmp = read_par_header(p->filename, 0, (i64 )0, 1);
    }
#line 513
    if (! tmp) {
#line 513
      goto __Cont;
    }
#line 514
    if (tmp->vol_number) {
      {
#line 514
      tmp___7 = files_match(par->files, tmp->files, 0);
      }
#line 514
      if (tmp___7) {
#line 515
        v = par->volumes;
        {
#line 515
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 515
          if (! v) {
#line 515
            goto while_break___1;
          }
#line 516
          if (v->vol_number == tmp->vol_number) {
#line 517
            goto while_break___1;
          }
#line 515
          v = v->next;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 518
        if (v) {
#line 518
          goto __Cont;
        }
        {
#line 519
        tmp___4 = par_control_check(tmp);
        }
#line 519
        if (! tmp___4) {
          {
#line 520
          tmp___3 = basename(p->filename);
#line 520
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - CORRUPT\n",
                  tmp___3);
#line 522
          free_par(tmp);
          }
#line 523
          goto __Cont;
        }
        {
#line 525
        tmp___5 = calloc(sizeof(*v), (size_t )1);
#line 525
        v = (pfile_t *)tmp___5;
#line 526
        v->match = p;
#line 527
        v->vol_number = tmp->vol_number;
#line 528
        v->file_size = tmp->data_size;
#line 529
        v->fnrs = file_numbers(& par->files, & tmp->files);
#line 530
        v->f = tmp->f;
#line 531
        tmp->f = (file_t )0;
#line 532
        v->next = par->volumes;
#line 533
        par->volumes = v;
#line 534
        m ++;
#line 535
        tmp___6 = basename(p->filename);
#line 535
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - OK\n",
                tmp___6);
        }
      }
    }
    {
#line 538
    free_par(tmp);
    }
#line 539
    if (m >= tofind) {
#line 540
      goto while_break___0;
    }
    __Cont: /* CIL Label */ 
#line 508
    p = p->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 542
  return (m);
}
}
#line 548 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
void find_par_files(pfile_t **volumes___0 , pfile_t **files___0 , int part ) 
{ 
  pfile_t *v ;
  pfile_t **vv ;
  hfile_t *p ;
  par_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 555
  p = hfile;
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if (! p) {
#line 555
      goto while_break;
    }
#line 556
    if ((int )p->hashed >= 1) {
#line 556
      if (! (p->magic == *((i64 *)"PAR\000\000\000\000\000"))) {
        {
#line 556
        tmp___0 = is_old_par((void *)(& p->magic));
        }
#line 556
        if (! tmp___0) {
#line 558
          goto __Cont;
        }
      }
    }
#line 559
    v = *volumes___0;
    {
#line 559
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 559
      if (! v) {
#line 559
        goto while_break___0;
      }
      {
#line 560
      tmp___1 = unicode_cmp(v->filename, p->filename);
      }
#line 560
      if (! tmp___1) {
#line 561
        goto while_break___0;
      }
#line 559
      v = v->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 562
    if (v) {
#line 562
      goto __Cont;
    }
    {
#line 563
    tmp = read_par_header(p->filename, 0, (i64 )0, 1);
    }
#line 564
    if (! tmp) {
#line 564
      goto __Cont;
    }
#line 565
    if (tmp->vol_number) {
      {
#line 565
      tmp___5 = files_match(*files___0, tmp->files, part);
      }
#line 565
      if (tmp___5) {
        {
#line 567
        tmp___2 = par_control_check(tmp);
        }
#line 567
        if (! tmp___2) {
          {
#line 568
          free_par(tmp);
          }
#line 569
          goto __Cont;
        }
        {
#line 571
        tmp___3 = calloc(sizeof(*v), (size_t )1);
#line 571
        v = (pfile_t *)tmp___3;
#line 572
        v->match = p;
#line 573
        v->vol_number = tmp->vol_number;
#line 574
        v->file_size = tmp->data_size;
#line 575
        v->fnrs = file_numbers(files___0, & tmp->files);
#line 576
        v->f = tmp->f;
#line 577
        v->filename = unicode_copy(tmp->filename);
#line 578
        tmp->f = (file_t )0;
#line 581
        vv = volumes___0;
        }
        {
#line 581
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 581
          if (! *vv) {
#line 581
            goto while_break___1;
          }
          {
#line 582
          tmp___4 = unicode_gt((*vv)->filename, v->filename);
          }
#line 582
          if (tmp___4) {
#line 583
            goto while_break___1;
          }
#line 581
          vv = & (*vv)->next;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 584
        v->next = *vv;
#line 585
        *vv = v;
      }
    }
    {
#line 587
    free_par(tmp);
    }
    __Cont: /* CIL Label */ 
#line 555
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 589
  return;
}
}
#line 594 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
par_t *find_all_par_files(void) 
{ 
  par_t *par ;
  par_t *tmp ;
  pfile_t *v ;
  hfile_t *p ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 601
  par = create_par_header((u16 *)0, (i64 )0);
#line 603
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Looking for PAR archives:\n");
#line 605
  hash_directory((char *)".");
#line 607
  p = hfile;
  }
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if (! p) {
#line 607
      goto while_break;
    }
#line 608
    if ((int )p->hashed >= 1) {
#line 608
      if (! (p->magic == *((i64 *)"PAR\000\000\000\000\000"))) {
        {
#line 608
        tmp___0 = is_old_par((void *)(& p->magic));
        }
#line 608
        if (! tmp___0) {
#line 610
          goto __Cont;
        }
      }
    }
    {
#line 611
    tmp = read_par_header(p->filename, 0, (i64 )0, 1);
    }
#line 612
    if (! tmp) {
#line 612
      goto __Cont;
    }
#line 613
    if (tmp->vol_number) {
      {
#line 614
      tmp___2 = par_control_check(tmp);
      }
#line 614
      if (! tmp___2) {
        {
#line 615
        tmp___1 = basename(p->filename);
#line 615
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - CORRUPT\n",
                tmp___1);
#line 617
        free_par(tmp);
        }
#line 618
        goto __Cont;
      }
      {
#line 620
      tmp___3 = calloc(sizeof(*v), (size_t )1);
#line 620
      v = (pfile_t *)tmp___3;
#line 621
      v->match = p;
#line 622
      v->vol_number = tmp->vol_number;
#line 623
      v->file_size = tmp->data_size;
#line 624
      v->fnrs = file_numbers(& par->files, & tmp->files);
#line 625
      v->f = tmp->f;
#line 626
      tmp->f = (file_t )0;
#line 627
      v->next = par->volumes;
#line 628
      par->volumes = v;
#line 629
      tmp___4 = basename(p->filename);
#line 629
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-40s - FOUND\n",
              tmp___4);
      }
    }
    {
#line 632
    free_par(tmp);
    }
    __Cont: /* CIL Label */ 
#line 607
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 634
  if (! par->volumes) {
    {
#line 635
    free_par(par);
    }
#line 636
    return ((par_t *)0);
  }
#line 638
  return (par);
}
}
#line 642 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
static sub_t *make_sub_r(u16 *from , int fl , u16 *to , int tl , int off , sub_t *rhs ) 
{ 
  int i ;
  int j ;
  int k ;
  int m ;
  int ml ;
  int mf ;
  int mt ;
  sub_t *ret___0 ;
  void *tmp ;
  sub_t *tmp___0 ;

  {
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if ((int )*from == (int )*to) {
#line 650
      if (fl > 0) {
#line 650
        if (! (tl > 0)) {
#line 650
          goto while_break;
        }
      } else {
#line 650
        goto while_break;
      }
    } else {
#line 650
      goto while_break;
    }
#line 651
    from ++;
#line 652
    to ++;
#line 653
    fl --;
#line 654
    tl --;
#line 655
    off ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 657
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 657
    if ((int )*(from + (fl - 1)) == (int )*(to + (tl - 1))) {
#line 657
      if (fl > 0) {
#line 657
        if (! (tl > 0)) {
#line 657
          goto while_break___0;
        }
      } else {
#line 657
        goto while_break___0;
      }
    } else {
#line 657
      goto while_break___0;
    }
#line 658
    fl --;
#line 659
    tl --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 663
  if (fl == 0) {
#line 663
    if (tl == 0) {
#line 664
      return (rhs);
    }
  }
#line 667
  ml = 0;
#line 667
  mf = 0;
#line 667
  mt = 0;
#line 668
  i = 0;
  {
#line 668
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 668
    if (! (fl - i > ml)) {
#line 668
      goto while_break___1;
    }
#line 669
    j = 0;
    {
#line 669
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 669
      if (! (tl - j > ml)) {
#line 669
        goto while_break___2;
      }
#line 670
      m = fl - i;
#line 671
      if (m > tl - j) {
#line 671
        m = tl - j;
      }
#line 672
      k = 0;
      {
#line 672
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 672
        if (! (k < m)) {
#line 672
          goto while_break___3;
        }
#line 673
        if ((int )*(from + (i + k)) != (int )*(to + (j + k))) {
#line 674
          goto while_break___3;
        }
#line 672
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 675
      if (k > ml) {
#line 676
        ml = k;
#line 677
        mf = i;
#line 678
        mt = j;
      }
#line 669
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 668
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 683
  if (ml == 0) {
    {
#line 684
    tmp = malloc(sizeof(*ret___0));
#line 684
    ret___0 = (sub_t *)tmp;
#line 685
    ret___0->next = rhs;
#line 686
    ret___0->off = off;
#line 687
    ret___0->fs = from;
#line 688
    ret___0->fl = fl;
#line 689
    ret___0->ts = to;
#line 690
    ret___0->tl = tl;
    }
#line 691
    return (ret___0);
  }
  {
#line 694
  ret___0 = make_sub_r((from + mf) + ml, fl - (mf + ml), (to + mt) + ml, tl - (mt + ml),
                       (off + mf) + ml, rhs);
#line 696
  tmp___0 = make_sub_r(from, mf, to, mt, off, ret___0);
  }
#line 696
  return (tmp___0);
}
}
#line 702 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
sub_t *make_sub(u16 *from , u16 *to ) 
{ 
  int fl ;
  int tl ;
  sub_t *tmp ;

  {
#line 707
  fl = 0;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if (! *(from + fl)) {
#line 707
      goto while_break;
    }
#line 707
    fl ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  tl = 0;
  {
#line 708
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 708
    if (! *(to + tl)) {
#line 708
      goto while_break___0;
    }
#line 708
    tl ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 709
  tmp = make_sub_r(from, fl, to, tl, 0, (sub_t *)0);
  }
#line 709
  return (tmp);
}
}
#line 715 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
void free_sub(sub_t *sub___0 ) 
{ 
  sub_t *t ;

  {
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 719
    if (! sub___0) {
#line 719
      goto while_break;
    }
    {
#line 720
    t = sub___0;
#line 721
    sub___0 = sub___0->next;
#line 722
    free((void *)t);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 724
  return;
}
}
#line 732 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
static u16 *ret  =    (u16 *)0;
#line 733 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
static int retl  =    0;
#line 729 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
u16 *do_sub(u16 *from , sub_t *sub___0 ) 
{ 
  int i ;
  int fp ;
  int rp ;
  sub_t *p ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 737
  i = 0;
  {
#line 737
  while (1) {
    while_continue: /* CIL Label */ ;
#line 737
    if (! *(from + i)) {
#line 737
      goto while_break;
    }
#line 737
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 738
  p = sub___0;
  {
#line 738
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 738
    if (! p) {
#line 738
      goto while_break___0;
    }
#line 739
    i += p->tl - p->fl;
#line 738
    p = p->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 741
  if (retl < i + 1) {
    {
#line 742
    retl = i + 1;
#line 743
    tmp = realloc((void *)ret, sizeof(*ret) * (unsigned long )retl);
#line 743
    ret = (u16 *)tmp;
    }
  }
#line 746
  rp = 0;
#line 746
  fp = rp;
#line 747
  p = sub___0;
  {
#line 747
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 747
    if (! p) {
#line 747
      goto while_break___1;
    }
    {
#line 748
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 748
      if (! (fp < p->off)) {
#line 748
        goto while_break___2;
      }
#line 749
      if (! *(from + fp)) {
#line 750
        return (from);
      }
#line 751
      tmp___0 = rp;
#line 751
      rp ++;
#line 751
      tmp___1 = fp;
#line 751
      fp ++;
#line 751
      *(ret + tmp___0) = *(from + tmp___1);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 753
    i = 0;
    {
#line 753
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 753
      if (! (i < p->fl)) {
#line 753
        goto while_break___3;
      }
#line 754
      tmp___2 = fp;
#line 754
      fp ++;
#line 754
      if ((int )*(from + tmp___2) != (int )*(p->fs + i)) {
#line 755
        return (from);
      }
#line 753
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 757
    i = 0;
    {
#line 757
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 757
      if (! (i < p->tl)) {
#line 757
        goto while_break___4;
      }
#line 758
      tmp___3 = rp;
#line 758
      rp ++;
#line 758
      *(ret + tmp___3) = *(p->ts + i);
#line 757
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 747
    p = p->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 760
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 760
    if (! *(from + fp)) {
#line 760
      goto while_break___5;
    }
#line 761
    tmp___4 = rp;
#line 761
    rp ++;
#line 761
    tmp___5 = fp;
#line 761
    fp ++;
#line 761
    *(ret + tmp___4) = *(from + tmp___5);
  }
  while_break___5: /* CIL Label */ ;
  }
#line 762
  *(ret + rp) = (u16 )0;
#line 763
  return (ret);
}
}
#line 770 "/home/wheatley/newnew/temp/parchive-1.1/backend.c"
sub_t *find_best_sub(pfile_t *files___0 , int m ) 
{ 
  sub_t *best ;
  sub_t *cur ;
  pfile_t *p ;
  pfile_t *q ;
  int i ;
  int tmp ;
  int tmp___0 ;
  u16 *tmp___1 ;
  int tmp___2 ;

  {
#line 778
  best = (sub_t *)0;
#line 780
  p = files___0;
  {
#line 780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 780
    if (! p) {
#line 780
      goto while_break;
    }
    {
#line 781
    tmp = find_file(p, 0);
    }
#line 781
    if (! tmp) {
#line 782
      goto __Cont;
    }
    {
#line 783
    cur = make_sub(p->filename, (p->match)->filename);
#line 784
    i = 0;
#line 785
    q = files___0;
    }
    {
#line 785
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 785
      if (! q) {
#line 785
        goto while_break___0;
      }
      {
#line 786
      tmp___0 = find_file(q, 0);
      }
#line 786
      if (! tmp___0) {
#line 787
        goto __Cont___0;
      }
      {
#line 788
      tmp___1 = do_sub(q->filename, cur);
#line 788
      tmp___2 = unicode_cmp(tmp___1, (q->match)->filename);
      }
#line 788
      if (! tmp___2) {
#line 790
        i ++;
      }
      __Cont___0: /* CIL Label */ 
#line 785
      q = q->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 792
    if (i > m) {
      {
#line 793
      free_sub(best);
#line 794
      best = cur;
      }
    } else {
      {
#line 796
      free_sub(cur);
      }
    }
    __Cont: /* CIL Label */ 
#line 780
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 799
  return (best);
}
}
#line 24 "/home/wheatley/newnew/temp/parchive-1.1/rs.c"
u8 gl[256]  ;
#line 24 "/home/wheatley/newnew/temp/parchive-1.1/rs.c"
u8 ge[512]  ;
#line 27 "/home/wheatley/newnew/temp/parchive-1.1/rs.c"
static int gmul(int a , int b ) 
{ 


  {
#line 30
  if (a == 0) {
#line 30
    return (0);
  } else
#line 30
  if (b == 0) {
#line 30
    return (0);
  }
#line 31
  return ((int )ge[(int )gl[a] + (int )gl[b]]);
}
}
#line 35 "/home/wheatley/newnew/temp/parchive-1.1/rs.c"
static int gdiv(int a , int b ) 
{ 


  {
#line 38
  if (a == 0) {
#line 38
    return (0);
  } else
#line 38
  if (b == 0) {
#line 38
    return (0);
  }
#line 39
  return ((int )ge[((int )gl[a] - (int )gl[b]) + 255]);
}
}
#line 43 "/home/wheatley/newnew/temp/parchive-1.1/rs.c"
static int gpow(int a , int b ) 
{ 


  {
#line 46
  if (a == 0) {
#line 46
    return (0);
  }
#line 47
  return ((int )ge[((int )gl[a] * b) % 255]);
}
}
#line 51 "/home/wheatley/newnew/temp/parchive-1.1/rs.c"
void ginit(void) 
{ 
  unsigned int b ;
  unsigned int l ;

  {
#line 56
  b = 1U;
#line 57
  l = 0U;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (l < 255U)) {
#line 57
      goto while_break;
    }
#line 58
    gl[b] = (u8 )l;
#line 59
    ge[l] = (u8 )b;
#line 60
    b += b;
#line 61
    if (b & 256U) {
#line 61
      b ^= 285U;
    }
#line 57
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  l = 255U;
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (! (l < 512U)) {
#line 63
      goto while_break___0;
    }
#line 64
    ge[l] = ge[l - 255U];
#line 63
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 68 "/home/wheatley/newnew/temp/parchive-1.1/rs.c"
static void make_lut(u8 *lut , int m ) 
{ 
  int j ;

  {
#line 72
  j = 256;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    j --;
#line 72
    if (! j) {
#line 72
      goto while_break;
    }
#line 73
    *(lut + j) = ge[(int )gl[m] + (int )gl[j]];
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  *(lut + 0) = (u8 )0;
#line 75
  return;
}
}
#line 81 "/home/wheatley/newnew/temp/parchive-1.1/rs.c"
int recreate(xfile_t *in , xfile_t *out ) 
{ 
  int i ;
  int j ;
  int k ;
  int l ;
  int M ;
  int N ;
  int Q ;
  int R ;
  u8 *mt ;
  u8 *imt ;
  u8 *muls ;
  u8 buf___3[65536] ;
  u8 *work ;
  i64 s ;
  i64 size ;
  i64 perc ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int d ;
  int l___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  i64 tr ;
  i64 r ;
  i64 q ;
  u8 *p ;
  u8 lut[256] ;

  {
  {
#line 90
  ginit();
#line 93
  R = 0;
#line 93
  Q = R;
#line 93
  i = Q;
  }
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (in + i)->filenr) {
#line 93
      goto while_break;
    }
#line 94
    if ((in + i)->files) {
#line 95
      R ++;
#line 97
      k = 0;
      {
#line 97
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 97
        if (! *((in + i)->files + k)) {
#line 97
          goto while_break___0;
        }
#line 98
        if ((int )*((in + i)->files + k) > Q) {
#line 99
          Q = (int )*((in + i)->files + k);
        }
#line 97
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 102
    if ((int )(in + i)->filenr > Q) {
#line 103
      Q = (int )(in + i)->filenr;
    }
#line 93
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  N = i;
#line 109
  M = 0;
#line 109
  j = M;
#line 109
  i = j;
  {
#line 109
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 109
    if (! (out + i)->filenr) {
#line 109
      goto while_break___1;
    }
#line 110
    M ++;
#line 111
    if ((out + i)->files) {
#line 112
      j ++;
#line 114
      k = 0;
      {
#line 114
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 114
        if (! *((out + i)->files + k)) {
#line 114
          goto while_break___2;
        }
#line 115
        if ((int )*((out + i)->files + k) > Q) {
#line 116
          Q = (int )*((out + i)->files + k);
        }
#line 114
        k ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 119
    if ((int )(out + i)->filenr > Q) {
#line 120
      Q = (int )(out + i)->filenr;
    }
#line 109
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 123
  R += j;
#line 124
  Q += j;
#line 126
  tmp = calloc(sizeof(*mt), (size_t )(R * Q));
#line 126
  mt = (u8 *)tmp;
#line 127
  tmp___0 = calloc(sizeof(*imt), (size_t )(R * N));
#line 127
  imt = (u8 *)tmp___0;
#line 130
  j = 0;
#line 130
  i = j;
  }
  {
#line 130
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 130
    if (! (in + i)->filenr) {
#line 130
      goto while_break___3;
    }
#line 131
    if (! (in + i)->files) {
#line 132
      goto __Cont;
    }
#line 133
    k = 0;
    {
#line 133
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 133
      if (! *((in + i)->files + k)) {
#line 133
        goto while_break___4;
      }
      {
#line 134
      tmp___1 = gpow(k + 1, (int )(in + i)->filenr - 1);
#line 134
      *(mt + (j * Q + ((int )*((in + i)->files + k) - 1))) = (u8 )tmp___1;
#line 133
      k ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 135
    *(imt + (j * N + i)) = (u8 )1;
#line 136
    j ++;
    __Cont: /* CIL Label */ 
#line 130
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 140
  i = 0;
#line 140
  l = Q;
  {
#line 140
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 140
    if (! (out + i)->filenr) {
#line 140
      goto while_break___5;
    }
#line 141
    if (! (out + i)->files) {
#line 142
      goto __Cont___0;
    }
#line 143
    k = 0;
    {
#line 143
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 143
      if (! *((out + i)->files + k)) {
#line 143
        goto while_break___6;
      }
      {
#line 144
      tmp___2 = gpow(k + 1, (int )(out + i)->filenr - 1);
#line 144
      *(mt + (j * Q + ((int )*((out + i)->files + k) - 1))) = (u8 )tmp___2;
#line 143
      k ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 145
    l --;
#line 147
    (out + i)->filenr = (u16 )(l + 1);
#line 148
    *(mt + (j * Q + l)) = (u8 )1;
#line 149
    j ++;
    __Cont___0: /* CIL Label */ 
#line 140
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 152
  if (cmd.loglevel > 0) {
    {
#line 153
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Matrix input:\n");
#line 154
    i = 0;
    }
    {
#line 154
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 154
      if (! (i < R)) {
#line 154
        goto while_break___7;
      }
      {
#line 155
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| ");
#line 156
      j = 0;
      }
      {
#line 156
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 156
        if (! (j < Q)) {
#line 156
          goto while_break___8;
        }
        {
#line 157
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
                (int )*(mt + (i * Q + j)));
#line 156
        j ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 158
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| ");
#line 159
      j = 0;
      }
      {
#line 159
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 159
        if (! (j < N)) {
#line 159
          goto while_break___9;
        }
        {
#line 160
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
                (int )*(imt + (i * N + j)));
#line 159
        j ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 161
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"|\n");
#line 154
      i ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 166
  i = 0;
  {
#line 166
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 166
    if (! (in + i)->filenr) {
#line 166
      goto while_break___10;
    }
#line 167
    if ((in + i)->files) {
#line 168
      goto __Cont___1;
    }
#line 169
    k = (int )(in + i)->filenr - 1;
#line 174
    j = 0;
    {
#line 174
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 174
      if (! (j < R)) {
#line 174
        goto while_break___11;
      }
#line 175
      *(imt + (j * N + i)) = (u8 )((int )*(imt + (j * N + i)) ^ (int )*(mt + (j * Q + k)));
#line 176
      *(mt + (j * Q + k)) = (u8 )0;
#line 174
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    __Cont___1: /* CIL Label */ 
#line 166
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 180
  if (cmd.loglevel > 0) {
    {
#line 181
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Matrix after data file elimination:\n");
#line 182
    i = 0;
    }
    {
#line 182
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 182
      if (! (i < R)) {
#line 182
        goto while_break___12;
      }
      {
#line 183
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| ");
#line 184
      j = 0;
      }
      {
#line 184
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 184
        if (! (j < Q)) {
#line 184
          goto while_break___13;
        }
        {
#line 185
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
                (int )*(mt + (i * Q + j)));
#line 184
        j ++;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 186
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| ");
#line 187
      j = 0;
      }
      {
#line 187
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 187
        if (! (j < N)) {
#line 187
          goto while_break___14;
        }
        {
#line 188
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
                (int )*(imt + (i * N + j)));
#line 187
        j ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 189
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"|\n");
#line 182
      i ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
  }
#line 196
  i = 0;
  {
#line 196
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 196
    if (! (i < R)) {
#line 196
      goto while_break___15;
    }
#line 199
    l___0 = 0;
    {
#line 199
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 199
      if (l___0 < Q) {
#line 199
        if (! (! *(mt + (i * Q + l___0)))) {
#line 199
          goto while_break___16;
        }
      } else {
#line 199
        goto while_break___16;
      }
#line 199
      l___0 ++;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 201
    if (l___0 == Q) {
#line 201
      goto __Cont___2;
    }
#line 202
    d = (int )*(mt + (i * Q + l___0));
#line 204
    j = 0;
    {
#line 204
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 204
      if (! (j < Q)) {
#line 204
        goto while_break___17;
      }
      {
#line 205
      tmp___3 = gdiv((int )*(mt + (i * Q + j)), d);
#line 205
      *(mt + (i * Q + j)) = (u8 )tmp___3;
#line 204
      j ++;
      }
    }
    while_break___17: /* CIL Label */ ;
    }
#line 206
    j = 0;
    {
#line 206
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 206
      if (! (j < N)) {
#line 206
        goto while_break___18;
      }
      {
#line 207
      tmp___4 = gdiv((int )*(imt + (i * N + j)), d);
#line 207
      *(imt + (i * N + j)) = (u8 )tmp___4;
#line 206
      j ++;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
#line 209
    k = 0;
    {
#line 209
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 209
      if (! (k < R)) {
#line 209
        goto while_break___19;
      }
#line 210
      if (k == i) {
#line 210
        goto __Cont___3;
      }
#line 211
      d = (int )*(mt + (k * Q + l___0));
#line 212
      j = 0;
      {
#line 212
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 212
        if (! (j < Q)) {
#line 212
          goto while_break___20;
        }
        {
#line 213
        tmp___5 = gmul((int )*(mt + (i * Q + j)), d);
#line 213
        *(mt + (k * Q + j)) = (u8 )((int )*(mt + (k * Q + j)) ^ tmp___5);
#line 212
        j ++;
        }
      }
      while_break___20: /* CIL Label */ ;
      }
#line 214
      j = 0;
      {
#line 214
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 214
        if (! (j < N)) {
#line 214
          goto while_break___21;
        }
        {
#line 215
        tmp___6 = gmul((int )*(imt + (i * N + j)), d);
#line 215
        *(imt + (k * N + j)) = (u8 )((int )*(imt + (k * N + j)) ^ tmp___6);
#line 214
        j ++;
        }
      }
      while_break___21: /* CIL Label */ ;
      }
      __Cont___3: /* CIL Label */ 
#line 209
      k ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    __Cont___2: /* CIL Label */ 
#line 196
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 219
  if (cmd.loglevel > 0) {
    {
#line 220
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Matrix after gaussian elimination:\n");
#line 221
    i = 0;
    }
    {
#line 221
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 221
      if (! (i < R)) {
#line 221
        goto while_break___22;
      }
      {
#line 222
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| ");
#line 223
      j = 0;
      }
      {
#line 223
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 223
        if (! (j < Q)) {
#line 223
          goto while_break___23;
        }
        {
#line 224
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
                (int )*(mt + (i * Q + j)));
#line 223
        j ++;
        }
      }
      while_break___23: /* CIL Label */ ;
      }
      {
#line 225
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| ");
#line 226
      j = 0;
      }
      {
#line 226
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 226
        if (! (j < N)) {
#line 226
          goto while_break___24;
        }
        {
#line 227
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
                (int )*(imt + (i * N + j)));
#line 226
        j ++;
        }
      }
      while_break___24: /* CIL Label */ ;
      }
      {
#line 228
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"|\n");
#line 221
      i ++;
      }
    }
    while_break___22: /* CIL Label */ ;
    }
  }
  {
#line 233
  tmp___7 = calloc(sizeof(*muls), (size_t )(M * N));
#line 233
  muls = (u8 *)tmp___7;
#line 235
  i = 0;
  }
  {
#line 235
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 235
    if (! (out + i)->filenr) {
#line 235
      goto while_break___25;
    }
#line 237
    j = 0;
    {
#line 237
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 237
      if (! (j < R)) {
#line 237
        goto while_break___26;
      }
#line 238
      k = (int )(out + i)->filenr - 1;
#line 239
      if ((int )*(mt + (j * Q + k)) != 1) {
#line 240
        goto __Cont___4;
      }
#line 242
      k = 0;
      {
#line 242
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 242
        if (! (! *(mt + (j * Q + k)))) {
#line 242
          goto while_break___27;
        }
#line 242
        k ++;
      }
      while_break___27: /* CIL Label */ ;
      }
#line 244
      if (k != (int )(out + i)->filenr - 1) {
#line 245
        goto __Cont___4;
      }
#line 246
      k ++;
      {
#line 246
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 246
        if (k < Q) {
#line 246
          if (! (! *(mt + (j * Q + k)))) {
#line 246
            goto while_break___28;
          }
        } else {
#line 246
          goto while_break___28;
        }
#line 246
        k ++;
      }
      while_break___28: /* CIL Label */ ;
      }
#line 248
      if (k != Q) {
#line 249
        goto __Cont___4;
      }
#line 250
      goto while_break___26;
      __Cont___4: /* CIL Label */ 
#line 237
      j ++;
    }
    while_break___26: /* CIL Label */ ;
    }
#line 253
    if (j == R) {
#line 254
      (out + i)->size = (i64 )0;
#line 255
      goto __Cont___5;
    }
#line 257
    k = 0;
    {
#line 257
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 257
      if (! (k < N)) {
#line 257
        goto while_break___29;
      }
#line 258
      *(muls + (i * N + k)) = *(imt + (j * N + k));
#line 257
      k ++;
    }
    while_break___29: /* CIL Label */ ;
    }
    __Cont___5: /* CIL Label */ 
#line 235
    i ++;
  }
  while_break___25: /* CIL Label */ ;
  }
  {
#line 260
  free((void *)mt);
#line 261
  free((void *)imt);
  }
#line 263
  if (cmd.loglevel > 0) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Multipliers:\n");
#line 265
    i = 0;
    }
    {
#line 265
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 265
      if (! (i < M)) {
#line 265
        goto while_break___30;
      }
      {
#line 266
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| ");
#line 267
      j = 0;
      }
      {
#line 267
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 267
        if (! (j < N)) {
#line 267
          goto while_break___31;
        }
        {
#line 268
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
                (int )*(muls + (i * N + j)));
#line 267
        j ++;
        }
      }
      while_break___31: /* CIL Label */ ;
      }
      {
#line 269
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"|\n");
#line 265
      i ++;
      }
    }
    while_break___30: /* CIL Label */ ;
    }
  }
#line 274
  j = 0;
  {
#line 274
  while (1) {
    while_continue___32: /* CIL Label */ ;
#line 274
    if (! (j < N)) {
#line 274
      goto while_break___32;
    }
#line 275
    i = 0;
    {
#line 275
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 275
      if (! (i < M)) {
#line 275
        goto while_break___33;
      }
#line 276
      if (*(muls + (i * N + j))) {
#line 277
        goto while_break___33;
      }
#line 275
      i ++;
    }
    while_break___33: /* CIL Label */ ;
    }
#line 279
    if (i == M) {
#line 280
      (in + j)->size = (i64 )0;
    }
#line 274
    j ++;
  }
  while_break___32: /* CIL Label */ ;
  }
#line 284
  size = (i64 )0;
#line 285
  i = 0;
  {
#line 285
  while (1) {
    while_continue___34: /* CIL Label */ ;
#line 285
    if (! (out + i)->filenr) {
#line 285
      goto while_break___34;
    }
#line 286
    if (size < (out + i)->size) {
#line 287
      size = (out + i)->size;
    }
#line 285
    i ++;
  }
  while_break___34: /* CIL Label */ ;
  }
  {
#line 290
  tmp___8 = malloc(sizeof(*work) * (sizeof(buf___3) * (unsigned long )M));
#line 290
  work = (u8 *)tmp___8;
#line 292
  perc = (i64 )0;
#line 293
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"0%%");
#line 293
  fflush(stderr);
#line 295
  s = (i64 )0;
  }
  {
#line 295
  while (1) {
    while_continue___35: /* CIL Label */ ;
#line 295
    if (! (s < size)) {
#line 295
      goto while_break___35;
    }
    {
#line 300
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 300
      if (! ((s * 50LL) / size > perc)) {
#line 300
        goto while_break___36;
      }
#line 301
      perc ++;
#line 302
      if (perc % 5LL) {
        {
#line 302
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
        }
      } else {
        {
#line 303
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%lld%%",
                (perc / 5LL) * 10LL);
        }
      }
      {
#line 304
      fflush(stderr);
      }
    }
    while_break___36: /* CIL Label */ ;
    }
    {
#line 308
    memset((void *)work, 0, sizeof(buf___3) * (unsigned long )M);
#line 309
    i = 0;
    }
    {
#line 309
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 309
      if (! (in + i)->filenr) {
#line 309
        goto while_break___37;
      }
#line 310
      tr = (i64 )sizeof(buf___3);
#line 311
      if (tr > (in + i)->size - s) {
#line 312
        tr = (in + i)->size - s;
      }
#line 313
      if (tr <= 0LL) {
#line 314
        goto __Cont___6;
      }
      {
#line 315
      r = file_read((in + i)->f, (void *)(buf___3), tr);
      }
#line 316
      if (r < tr) {
        {
#line 317
        perror("READ ERROR");
#line 318
        free((void *)muls);
#line 319
        free((void *)work);
        }
#line 320
        return (0);
      }
#line 322
      j = 0;
      {
#line 322
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 322
        if (! (out + j)->filenr) {
#line 322
          goto while_break___38;
        }
#line 324
        if (s >= (out + j)->size) {
#line 324
          goto __Cont___7;
        }
#line 325
        if (! *(muls + (j * N + i))) {
#line 325
          goto __Cont___7;
        }
        {
#line 327
        make_lut((u8 *)(lut), (int )*(muls + (j * N + i)));
#line 328
        p = work + (unsigned long )j * sizeof(buf___3);
#line 330
        q = r;
        }
        {
#line 330
        while (1) {
          while_continue___39: /* CIL Label */ ;
#line 330
          q --;
#line 330
          if (! (q >= 0LL)) {
#line 330
            goto while_break___39;
          }
#line 331
          *(p + q) = (u8 )((int )*(p + q) ^ (int )lut[buf___3[q]]);
        }
        while_break___39: /* CIL Label */ ;
        }
        __Cont___7: /* CIL Label */ 
#line 322
        j ++;
      }
      while_break___38: /* CIL Label */ ;
      }
      __Cont___6: /* CIL Label */ 
#line 309
      i ++;
    }
    while_break___37: /* CIL Label */ ;
    }
#line 334
    j = 0;
    {
#line 334
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 334
      if (! (out + j)->filenr) {
#line 334
        goto while_break___40;
      }
#line 335
      if (s >= (out + j)->size) {
#line 335
        goto __Cont___8;
      }
#line 336
      tr = (i64 )sizeof(buf___3);
#line 337
      if (tr > (out + j)->size - s) {
#line 338
        tr = (out + j)->size - s;
      }
      {
#line 339
      r = file_write((out + j)->f, (void *)(work + (unsigned long )j * sizeof(buf___3)),
                     tr);
      }
#line 340
      if (r < tr) {
        {
#line 341
        perror("WRITE ERROR");
#line 342
        free((void *)muls);
#line 343
        free((void *)work);
        }
#line 344
        return (0);
      }
      __Cont___8: /* CIL Label */ 
#line 334
      j ++;
    }
    while_break___40: /* CIL Label */ ;
    }
#line 347
    s += (i64 )sizeof(buf___3);
  }
  while_break___35: /* CIL Label */ ;
  }
  {
#line 349
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"100%%\n");
#line 349
  fflush(stderr);
#line 350
  free((void *)muls);
#line 351
  free((void *)work);
  }
#line 352
  return (1);
}
}
#line 25 "/home/wheatley/newnew/temp/parchive-1.1/readoldpar.c"
static i64 read_i64___0(void *data ) 
{ 
  int i ;
  i64 r ;
  u8 *ptr ;

  {
#line 29
  r = (i64 )0;
#line 30
  ptr = (u8 *)data;
#line 32
  i = (int )sizeof(i64 );
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    i --;
#line 32
    if (! (i >= 0)) {
#line 32
      goto while_break;
    }
#line 33
    r <<= 8;
#line 34
    r += (i64 )*(ptr + i);
  }
  while_break: /* CIL Label */ ;
  }
#line 36
  return (r);
}
}
#line 53 "/home/wheatley/newnew/temp/parchive-1.1/readoldpar.c"
static u16 read_u16(void *data ) 
{ 
  int i ;
  u16 r ;
  u8 *ptr ;

  {
#line 57
  r = (u16 )0;
#line 58
  ptr = (u8 *)data;
#line 60
  i = (int )sizeof(u16 );
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    i --;
#line 60
    if (! (i >= 0)) {
#line 60
      goto while_break;
    }
#line 61
    r = (u16 )((int )r << 8);
#line 62
    r = (u16 )((int )r + (int )((u16 )*(ptr + i)));
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return (r);
}
}
#line 68 "/home/wheatley/newnew/temp/parchive-1.1/readoldpar.c"
static void read_u16s___0(u16 *str , void *data , i64 n ) 
{ 
  u8 *ptr ;

  {
#line 71
  ptr = (u8 *)data;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    n --;
#line 72
    if (! (n >= 0LL)) {
#line 72
      goto while_break;
    }
#line 73
    *str = (u16 )((int )*(ptr + 0) + ((int )*(ptr + 1) << 8));
#line 74
    str ++;
#line 75
    ptr += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/parchive-1.1/readoldpar.c"
int is_old_par(void *data ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 83
  tmp = memcmp((void const   *)data, (void const   *)"PAR", (size_t )4);
  }
#line 83
  if (! tmp) {
#line 84
    return (1);
  }
  {
#line 85
  tmp___0 = memcmp((void const   *)data, (void const   *)"PXX", (size_t )4);
  }
#line 85
  if (! tmp___0) {
#line 86
    return (2);
  }
#line 87
  return (0);
}
}
#line 93 "/home/wheatley/newnew/temp/parchive-1.1/readoldpar.c"
static i64 read_old_pfile(pfile_t *file , u8 *ptr , u16 *path , i64 pl ) 
{ 
  i64 i ;
  i64 l ;
  void *tmp ;
  i64 tmp___0 ;

  {
  {
#line 98
  file->status = read_i64___0((void *)(ptr + 8));
#line 99
  file->file_size = read_i64___0((void *)(ptr + 16));
#line 100
  memcpy((void */* __restrict  */)(file->hash), (void const   */* __restrict  */)(ptr + 40),
         sizeof(md5 ) * sizeof(file->hash[0]));
#line 101
  memcpy((void */* __restrict  */)(file->hash_16k), (void const   */* __restrict  */)(ptr + 24),
         sizeof(md5 ) * sizeof(file->hash_16k[0]));
#line 102
  i = (i64 )0;
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! *(ptr + (58LL + i))) {
#line 102
      if (! *(ptr + ((58LL + i) + 1LL))) {
#line 102
        goto while_break;
      }
    }
#line 102
    i += 2LL;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  l = pl + i;
#line 105
  tmp = malloc((size_t )((i64 )sizeof(*(file->filename)) * l));
#line 105
  file->filename = (u16 *)tmp;
#line 106
  memcpy((void */* __restrict  */)file->filename, (void const   */* __restrict  */)path,
         (size_t )(pl * (i64 )sizeof(*(file->filename))));
#line 107
  read_u16s___0(file->filename + pl, (void *)(ptr + 58), i);
#line 109
  tmp___0 = read_i64___0((void *)ptr);
  }
#line 109
  return (tmp___0);
}
}
#line 112 "/home/wheatley/newnew/temp/parchive-1.1/readoldpar.c"
static pfile_t *read_old_pfiles(file_t f , i64 size , u16 *path ) 
{ 
  pfile_t *files___0 ;
  pfile_t **fptr ;
  u8 *buf___3 ;
  i64 i ;
  i64 pl ;
  void *tmp ;
  void *tmp___0 ;
  i64 tmp___1 ;

  {
#line 115
  files___0 = (pfile_t *)0;
#line 115
  fptr = & files___0;
#line 119
  i = (i64 )0;
#line 119
  pl = i;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! *(path + i)) {
#line 119
      goto while_break;
    }
#line 120
    if ((int )*(path + i) == 47) {
#line 121
      pl = i + 1LL;
    }
#line 119
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 123
  tmp = malloc((size_t )((i64 )sizeof(*buf___3) * size));
#line 123
  buf___3 = (u8 *)tmp;
#line 124
  size = file_read(f, (void *)buf___3, size);
#line 127
  i = (i64 )0;
  }
  {
#line 129
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 129
    if (! (i < size)) {
#line 129
      goto while_break___0;
    }
    {
#line 130
    tmp___0 = calloc(sizeof(*(*fptr)), (size_t )1);
#line 130
    *fptr = (pfile_t *)tmp___0;
#line 131
    tmp___1 = read_old_pfile(*fptr, buf___3 + i, path, pl);
#line 131
    i += tmp___1;
#line 132
    fptr = & (*fptr)->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  free((void *)buf___3);
  }
#line 135
  return (files___0);
}
}
#line 139 "/home/wheatley/newnew/temp/parchive-1.1/readoldpar.c"
par_t *read_old_par(file_t f , u16 *file , int silent ) 
{ 
  u8 buf___3[8] ;
  int px ;
  par_t par ;
  par_t *r ;
  char *path ;
  char *tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  i64 tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 147
  memset((void *)(& par), 0, sizeof(par));
#line 149
  tmp = stuni((u16 const   *)file);
#line 149
  path = complete_path(tmp);
#line 151
  file_read(f, (void *)(buf___3), (i64 )4);
#line 152
  px = is_old_par((void *)(buf___3));
  }
#line 153
  if (! px) {
    {
#line 154
    file_close(f);
    }
#line 155
    return ((par_t *)0);
  }
#line 157
  if (px == 1) {
#line 157
    px = 0;
  }
  {
#line 158
  par.magic = *((i64 *)"PAR\000\000\000\000\000");
#line 159
  par.client = (u32 )33555712;
#line 160
  file_read(f, (void *)(buf___3), (i64 )2);
#line 161
  tmp___0 = read_u16((void *)(buf___3));
#line 161
  par.version = (u32 )tmp___0;
#line 162
  file_read(f, (void *)(par.set_hash), (i64 )16);
#line 163
  par.vol_number = (i64 )0;
  }
#line 164
  if (px) {
    {
#line 165
    file_read(f, (void *)(buf___3), (i64 )2);
#line 166
    tmp___1 = read_u16((void *)(buf___3));
#line 166
    par.vol_number = (i64 )tmp___1;
    }
#line 167
    if (par.version != 133U) {
#line 168
      par.vol_number = (i64 )1;
    }
  }
  {
#line 170
  file_read(f, (void *)(buf___3), (i64 )8);
#line 171
  par.file_list = read_i64___0((void *)(buf___3));
#line 172
  file_read(f, (void *)(buf___3), (i64 )8);
#line 173
  par.data = read_i64___0((void *)(buf___3));
  }
#line 174
  if (px) {
    {
#line 175
    file_read(f, (void *)(buf___3), (i64 )8);
#line 176
    par.data_size = read_i64___0((void *)(buf___3));
    }
  }
  {
#line 178
  file_read(f, (void *)(par.control_hash), (i64 )16);
  }
#line 180
  if (px) {
#line 180
    par.control_hash_offset = (i64 )64;
  } else {
#line 180
    par.control_hash_offset = (i64 )54;
  }
#line 181
  par.f = f;
#line 182
  par.filename = file;
#line 184
  if (! silent) {
    {
#line 184
    tmp___2 = par_control_check(& par);
    }
#line 184
    if (! tmp___2) {
      {
#line 185
      file_close(f);
      }
#line 186
      return ((par_t *)0);
    }
  }
  {
#line 189
  tmp___3 = file_seek(f, par.file_list);
  }
#line 189
  if (tmp___3 < 0) {
#line 190
    if (! silent) {
      {
#line 191
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to seek in PAR file");
#line 192
      perror("");
      }
    }
    {
#line 194
    file_close(f);
    }
#line 195
    return ((par_t *)0);
  }
  {
#line 197
  par.filename = make_uni_str((char const   *)path);
#line 198
  file_read(f, (void *)(buf___3), (i64 )8);
#line 199
  tmp___4 = read_i64___0((void *)(buf___3));
#line 199
  par.file_list_size = tmp___4 - 8LL;
#line 200
  par.files = read_old_pfiles(f, par.file_list_size, par.filename);
  }
#line 202
  if (px) {
#line 203
    if (par.data != par.file_list + par.file_list_size) {
      {
#line 204
      file_seek(f, par.data);
      }
    }
#line 205
    par.f = f;
  } else {
    {
#line 207
    par.f = (file_t )0;
#line 208
    file_close(f);
    }
  }
  {
#line 211
  par.volumes = (pfile_t *)0;
#line 213
  tmp___5 = malloc(sizeof(*r));
#line 213
  r = (par_t *)tmp___5;
#line 214
  memcpy((void */* __restrict  */)r, (void const   */* __restrict  */)(& par), sizeof(*r));
  }
#line 215
  return (r);
}
}
#line 178 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 42 "/home/wheatley/newnew/temp/parchive-1.1/fileops.h"
void unistr(char const   *str , u16 *buf___3 ) ;
#line 51
file_t file_open_ascii(char const   *path , int wr ) ;
#line 28 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
void unistr(char const   *str , u16 *buf___3 ) 
{ 
  u16 *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    tmp = buf___3;
#line 31
    buf___3 ++;
#line 31
    *tmp = (u16 )*str;
#line 31
    tmp___0 = str;
#line 31
    str ++;
#line 31
    if (! *tmp___0) {
#line 31
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 32
  return;
}
}
#line 38 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
u16 *make_uni_str(char const   *str ) 
{ 
  u16 *uni ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 43
  tmp = strlen(str);
#line 43
  tmp___0 = malloc(sizeof(*uni) * (tmp + 1UL));
#line 43
  uni = (u16 *)tmp___0;
#line 44
  unistr(str, uni);
  }
#line 45
  return (uni);
}
}
#line 56 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
static char *buf___0  =    (char *)0;
#line 57 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
static i64 bufsize  =    (i64 )0;
#line 52 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
char *stuni(u16 const   *str ) 
{ 
  i64 i ;
  void *tmp ;

  {
#line 60
  i = (i64 )0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! *(str + i)) {
#line 60
      goto while_break;
    }
#line 60
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  if (i + 1LL > bufsize) {
    {
#line 63
    bufsize = i + 1LL;
#line 64
    tmp = realloc((void *)buf___0, (size_t )((i64 )sizeof(*buf___0) * bufsize));
#line 64
    buf___0 = (char *)tmp;
    }
  }
#line 67
  i = (i64 )0;
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 67
    if (! *(str + i)) {
#line 67
      goto while_break___0;
    }
#line 68
    *(buf___0 + i) = (char )*(str + i);
#line 67
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 69
  *(buf___0 + i) = (char)0;
#line 70
  return (buf___0);
}
}
#line 81 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
static u16 *buf___1  =    (u16 *)0;
#line 82 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
static i64 bufsize___0  =    (i64 )0;
#line 77 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
u16 *unist(char const   *str ) 
{ 
  i64 i ;
  void *tmp ;

  {
#line 85
  i = (i64 )0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! *(str + i)) {
#line 85
      goto while_break;
    }
#line 85
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  if (i + 1LL > bufsize___0) {
    {
#line 88
    bufsize___0 = i + 1LL;
#line 89
    tmp = realloc((void *)buf___1, (size_t )((i64 )sizeof(*buf___1) * bufsize___0));
#line 89
    buf___1 = (u16 *)tmp;
    }
  }
#line 92
  i = (i64 )0;
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 92
    if (! *(str + i)) {
#line 92
      goto while_break___0;
    }
#line 93
    *(buf___1 + i) = (u16 )*(str + i);
#line 92
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 94
  *(buf___1 + i) = (u16 )0;
#line 95
  return (buf___1);
}
}
#line 106 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
static char buf___2[33]  ;
#line 102 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
char *stmd5(u8 * const  hash ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 108
  i = 0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (i < 16)) {
#line 108
      goto while_break;
    }
#line 109
    if ((((int )*(hash + i) >> 4) & 15) < 10) {
#line 109
      tmp = '0';
    } else {
#line 109
      tmp = 87;
    }
#line 109
    buf___2[i * 2] = (char )((((int )*(hash + i) >> 4) & 15) + tmp);
#line 110
    if (((int )*(hash + i) & 15) < 10) {
#line 110
      tmp___0 = '0';
    } else {
#line 110
      tmp___0 = 87;
    }
#line 110
    buf___2[i * 2 + 1] = (char )(((int )*(hash + i) & 15) + tmp___0);
#line 108
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  buf___2[i * 2] = (char)0;
#line 113
  return (buf___2);
}
}
#line 116 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
i64 uni_copy(u16 *dst , u16 *src , i64 n ) 
{ 
  i64 i ;

  {
#line 120
  i = (i64 )0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (*(src + i)) {
#line 120
      if (! (i < n - 1LL)) {
#line 120
        goto while_break;
      }
    } else {
#line 120
      goto while_break;
    }
#line 121
    *(dst + i) = *(src + i);
#line 120
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  *(dst + i) = (u16 )0;
#line 123
  return (i);
}
}
#line 126 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
u16 *unicode_copy(u16 *str ) 
{ 
  u16 *ret___0 ;
  u16 *p ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 131
  if (! str) {
    {
#line 132
    tmp = malloc(sizeof(*ret___0));
#line 132
    ret___0 = (u16 *)tmp;
#line 133
    *(ret___0 + 0) = (u16 )0;
    }
#line 134
    return (ret___0);
  }
#line 136
  p = str;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! *p) {
#line 136
      goto while_break;
    }
#line 136
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  tmp___0 = malloc(sizeof(*ret___0) * (unsigned long )((p - str) + 1L));
#line 138
  ret___0 = (u16 *)tmp___0;
#line 139
  memcpy((void */* __restrict  */)ret___0, (void const   */* __restrict  */)str, (unsigned long )((p - str) + 1L) * sizeof(*ret___0));
  }
#line 140
  return (ret___0);
}
}
#line 143 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
int file_rename(u16 *src , u16 *dst ) 
{ 
  int i ;
  char *s ;
  char *d ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 149
  s = stuni((u16 const   *)dst);
#line 150
  tmp = strlen((char const   *)s);
#line 150
  tmp___0 = malloc(sizeof(*d) * (tmp + 1UL));
#line 150
  d = (char *)tmp___0;
#line 151
  strcpy((char */* __restrict  */)d, (char const   */* __restrict  */)s);
#line 152
  s = stuni((u16 const   *)src);
#line 153
  i = rename((char const   *)s, (char const   *)d);
#line 154
  free((void *)d);
  }
#line 155
  return (i);
}
}
#line 158 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
static int do_seek(file_t f ) 
{ 
  int tmp ;

  {
#line 161
  if (f->off == f->s_off) {
#line 161
    return (0);
  }
#line 162
  if (! f->f) {
#line 162
    return (0);
  }
  {
#line 163
  tmp = fseek(f->f, (long )f->s_off, 0);
  }
#line 163
  if (tmp < 0) {
#line 164
    return (-1);
  }
#line 165
  f->off = f->s_off;
#line 166
  return (0);
}
}
#line 169 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
static int do_close(file_t f ) 
{ 
  int i ;

  {
#line 173
  if (! f->f) {
#line 173
    return (0);
  }
  {
#line 174
  i = fclose(f->f);
#line 175
  f->f = (FILE *)0;
  }
#line 176
  return (i);
}
}
#line 182
static int do_open(file_t f ) ;
#line 182 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
static file_t openfiles  =    (file_t )0;
#line 179 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
static int do_open(file_t f ) 
{ 
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (! f->f)) {
#line 184
      goto while_break;
    }
#line 186
    if (f->wr) {
#line 186
      tmp = 194;
    } else {
#line 186
      tmp = 0;
    }
    {
#line 186
    i = open((char const   *)f->name, tmp, 438);
    }
#line 188
    if (i >= 0) {
#line 188
      if (f->wr) {
#line 188
        tmp___0 = "w+b";
      } else {
#line 188
        tmp___0 = "rb";
      }
      {
#line 188
      f->f = fdopen(i, tmp___0);
      }
    }
#line 189
    if (! f->f) {
      {
#line 190
      tmp___1 = __errno_location();
      }
#line 190
      if (*tmp___1 != 24) {
        {
#line 190
        tmp___2 = __errno_location();
        }
#line 190
        if (*tmp___2 != 23) {
#line 191
          return (-1);
        }
      }
#line 192
      if (! openfiles) {
#line 193
        return (-1);
      }
      {
#line 194
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 194
        if (! (! openfiles->f)) {
#line 194
          goto while_break___0;
        }
#line 195
        openfiles = openfiles->next;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 196
      do_close(openfiles);
#line 197
      openfiles = openfiles->next;
      }
    } else {
#line 199
      f->off = (i64 )0;
#line 200
      if (! f->wr) {
#line 201
        f->next = openfiles;
#line 202
        openfiles = f;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  tmp___3 = do_seek(f);
  }
#line 206
  return (tmp___3);
}
}
#line 209 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
file_t file_open_ascii(char const   *path , int wr ) 
{ 
  file_t f ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 214
  tmp = calloc(sizeof(*f), (size_t )1);
#line 214
  f = (file_t )tmp;
#line 215
  tmp___0 = strlen(path);
#line 215
  tmp___1 = malloc(sizeof(*(f->name)) * (tmp___0 + 1UL));
#line 215
  f->name = (char *)tmp___1;
#line 216
  strcpy((char */* __restrict  */)f->name, (char const   */* __restrict  */)path);
#line 217
  f->wr = wr;
  }
#line 218
  return (f);
}
}
#line 221 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
file_t file_open(u16 const   *path , int wr ) 
{ 
  char *tmp ;
  file_t tmp___0 ;

  {
  {
#line 224
  tmp = stuni(path);
#line 224
  tmp___0 = file_open_ascii((char const   *)tmp, wr);
  }
#line 224
  return (tmp___0);
}
}
#line 227 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
int file_close(file_t f ) 
{ 
  int i ;

  {
#line 231
  if (! f) {
#line 231
    return (0);
  }
  {
#line 232
  i = do_close(f);
#line 233
  free((void *)f->name);
#line 234
  free((void *)f);
  }
#line 235
  return (i);
}
}
#line 238 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
int file_exists(u16 *file ) 
{ 
  FILE *f ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 243
  tmp = stuni((u16 const   *)file);
#line 243
  f = fopen((char const   */* __restrict  */)tmp, (char const   */* __restrict  */)"rb");
  }
#line 244
  if (! f) {
    {
#line 244
    tmp___0 = __errno_location();
    }
#line 244
    return (*tmp___0 != 2);
  }
  {
#line 245
  fclose(f);
  }
#line 246
  return (1);
}
}
#line 249 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
int file_delete(u16 *file ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 252
  tmp = stuni((u16 const   *)file);
#line 252
  tmp___0 = remove((char const   *)tmp);
  }
#line 252
  return (tmp___0);
}
}
#line 255 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
int file_seek(file_t f , i64 off ) 
{ 
  int tmp ;

  {
  {
#line 258
  f->s_off = off;
#line 259
  tmp = do_seek(f);
  }
#line 259
  return (tmp);
}
}
#line 263 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
char *complete_path(char *path ) 
{ 


  {
#line 271
  return (path);
}
}
#line 277 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
hfile_t *read_dir(char *dir ) 
{ 
  DIR *d ;
  struct dirent *de ;
  hfile_t *rd ;
  hfile_t **rdptr ;
  u16 *p ;
  int l ;
  int i ;
  char *dr ;
  void *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 282
  rd = (hfile_t *)0;
#line 282
  rdptr = & rd;
#line 287
  dir = complete_path(dir);
#line 289
  l = 0;
#line 290
  i = 0;
  }
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! *(dir + i)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(dir + i) == 47) {
#line 292
      l = i + 1;
    }
#line 290
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 294
  tmp = malloc(sizeof(*dr) * (unsigned long )(l + 1));
#line 294
  dr = (char *)tmp;
#line 295
  memcpy((void */* __restrict  */)dr, (void const   */* __restrict  */)dir, (size_t )l);
#line 296
  *(dr + l) = (char)0;
  }
#line 298
  if (l) {
#line 298
    tmp___0 = (char const   *)dr;
  } else {
#line 298
    tmp___0 = ".";
  }
  {
#line 298
  d = opendir(tmp___0);
  }
#line 299
  if (d) {
    {
#line 300
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 300
      de = readdir(d);
      }
#line 300
      if (! de) {
#line 300
        goto while_break___0;
      }
      {
#line 301
      tmp___1 = calloc(sizeof(*(*rdptr)), (size_t )1);
#line 301
      *rdptr = (hfile_t *)tmp___1;
#line 302
      tmp___2 = strlen((char const   *)(de->d_name));
#line 302
      tmp___3 = malloc(sizeof(*p) * (((size_t )l + tmp___2) + 1UL));
#line 302
      p = (u16 *)tmp___3;
#line 303
      unistr((char const   *)dr, p);
#line 304
      unistr((char const   *)(de->d_name), p + l);
#line 305
      (*rdptr)->filename = p;
#line 306
      rdptr = & (*rdptr)->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 308
    closedir(d);
    }
  }
  {
#line 311
  free((void *)dr);
  }
#line 312
  return (rd);
}
}
#line 315 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
i64 file_read(file_t f , void *buf___3 , i64 n ) 
{ 
  i64 i ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 319
  if (! f) {
#line 319
    return ((i64 )0);
  }
  {
#line 320
  tmp = do_open(f);
  }
#line 320
  if (tmp < 0) {
#line 321
    return ((i64 )0);
  }
  {
#line 322
  tmp___0 = fread((void */* __restrict  */)buf___3, (size_t )1, (size_t )n, (FILE */* __restrict  */)f->f);
#line 322
  i = (i64 )tmp___0;
  }
#line 323
  if (i > 0LL) {
#line 324
    f->off += i;
#line 325
    f->s_off = f->off;
  }
#line 327
  return (i);
}
}
#line 330 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
i64 file_write(file_t f , void *buf___3 , i64 n ) 
{ 
  i64 i ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 334
  if (! f) {
#line 334
    return ((i64 )0);
  }
  {
#line 335
  tmp = do_open(f);
  }
#line 335
  if (tmp < 0) {
#line 336
    return ((i64 )0);
  }
  {
#line 337
  tmp___0 = fwrite((void const   */* __restrict  */)buf___3, (size_t )1, (size_t )n,
                   (FILE */* __restrict  */)f->f);
#line 337
  i = (i64 )tmp___0;
  }
#line 338
  if (i > 0LL) {
#line 339
    f->off += i;
#line 340
    f->s_off = f->off;
  }
#line 342
  return (i);
}
}
#line 346 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
i64 file_md5(u16 *file , u8 *block ) 
{ 
  FILE *f ;
  i64 i ;
  char *tmp ;

  {
  {
#line 352
  tmp = stuni((u16 const   *)file);
#line 352
  f = fopen((char const   */* __restrict  */)tmp, (char const   */* __restrict  */)"rb");
  }
#line 353
  if (! f) {
#line 353
    return ((i64 )0);
  }
  {
#line 354
  i = md5_stream(f, (void *)block);
#line 355
  fclose(f);
  }
#line 356
  return (i);
}
}
#line 359 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
int file_md5_buffer(u16 *file , u8 *block , u8 *buf___3 , i64 size ) 
{ 
  file_t f ;
  i64 s ;
  void *tmp ;

  {
  {
#line 365
  f = file_open((u16 const   *)file, 0);
  }
#line 366
  if (! f) {
#line 366
    return (0);
  }
  {
#line 367
  s = file_read(f, (void *)buf___3, size);
#line 368
  file_close(f);
  }
#line 369
  if (s < 0LL) {
#line 369
    return (0);
  }
  {
#line 370
  tmp = md5_buffer((char const   *)buf___3, (size_t )s, (void *)block);
  }
#line 370
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
#line 377 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
int file_add_md5(file_t f , i64 md5off , i64 off , i64 len ) 
{ 
  md5 hash ;
  i64 i ;
  int tmp ;
  int tmp___0 ;
  i64 tmp___1 ;

  {
#line 383
  if (! f) {
#line 383
    return (0);
  }
  {
#line 384
  f->s_off = off;
#line 385
  tmp = do_open(f);
  }
#line 385
  if (tmp < 0) {
#line 386
    return (0);
  }
  {
#line 387
  i = md5_stream(f->f, (void *)(hash));
  }
#line 388
  if (i < 0LL) {
#line 389
    return (0);
  }
#line 390
  f->off += i;
#line 391
  f->s_off = f->off;
#line 393
  if (f->off != len) {
#line 394
    return (0);
  }
  {
#line 395
  tmp___0 = file_seek(f, md5off);
  }
#line 395
  if (tmp___0 < 0) {
#line 396
    return (0);
  }
  {
#line 397
  tmp___1 = file_write(f, (void *)(hash), (i64 )sizeof(hash));
  }
#line 397
  if (tmp___1 < 0LL) {
#line 398
    return (0);
  }
#line 399
  return (1);
}
}
#line 403 "/home/wheatley/newnew/temp/parchive-1.1/fileops.c"
int file_get_md5(file_t f , i64 off , u8 *block ) 
{ 
  i64 i ;
  i64 tmp ;
  int tmp___0 ;

  {
  {
#line 406
  tmp = f->off;
#line 408
  f->s_off = off;
#line 409
  tmp___0 = do_open(f);
  }
#line 409
  if (tmp___0 < 0) {
#line 410
    return (0);
  }
  {
#line 411
  i = md5_stream(f->f, (void *)block);
#line 412
  f->s_off = tmp;
  }
#line 414
  return (i != 0LL);
}
}
