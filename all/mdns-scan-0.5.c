/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 29 "/home/wheatley/newnew/temp/mdns-scan-0.5/util.h"
typedef uint64_t usec_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.h"
struct dns_packet {
   size_t size ;
   size_t rindex ;
   uint8_t data[9000] ;
};
#line 34 "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c"
struct hash_entry {
   unsigned int hash ;
   char *name ;
   struct hash_entry *next ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 242 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct ip_mreqn {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_address ;
   int imr_ifindex ;
};
#line 127 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_31 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_32 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_31 ifr_ifrn ;
   union __anonunion_ifr_ifru_32 ifr_ifru ;
};
#line 176 "/usr/include/net/if.h"
union __anonunion_ifc_ifcu_33 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
#line 176 "/usr/include/net/if.h"
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_33 ifc_ifcu ;
};
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 31 "/home/wheatley/newnew/temp/mdns-scan-0.5/util.h"
usec_t timeval_diff(struct timeval  const  *a , struct timeval  const  *b ) ;
#line 32
int timeval_cmp(struct timeval  const  *a , struct timeval  const  *b ) ;
#line 33
usec_t timeval_age(struct timeval  const  *tv ) ;
#line 34
void timeval_add(struct timeval *tv , usec_t v ) ;
#line 36
int set_nonblock(int fd ) ;
#line 37
int set_cloexec(int fd ) ;
#line 39
int wait_for_write(int fd , struct timeval *end ) ;
#line 40
int wait_for_read(int fd , struct timeval *end ) ;
#line 42
int domain_cmp(char const   *a , char const   *b ) ;
#line 45
char *ends_with(char const   *a , char const   *b ) ;
#line 37 "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c"
usec_t timeval_diff(struct timeval  const  *a , struct timeval  const  *b ) 
{ 
  usec_t r ;
  struct timeval  const  *c___0 ;
  int tmp ;

  {
#line 39
  if (a) {
#line 39
    if (! b) {
      {
#line 39
      __assert_fail("a && b", "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c", 39U,
                    "timeval_diff");
      }
    }
  } else {
    {
#line 39
    __assert_fail("a && b", "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c", 39U,
                  "timeval_diff");
    }
  }
  {
#line 42
  tmp = timeval_cmp(a, b);
  }
#line 42
  if (tmp < 0) {
#line 44
    c___0 = a;
#line 45
    a = b;
#line 46
    b = c___0;
  }
#line 50
  r = ((usec_t )a->tv_sec - (usec_t )b->tv_sec) * 1000000UL;
#line 53
  if (a->tv_usec > b->tv_usec) {
#line 54
    r += (usec_t )a->tv_usec - (usec_t )b->tv_usec;
  } else
#line 55
  if (a->tv_usec < b->tv_usec) {
#line 56
    r -= (usec_t )b->tv_usec - (usec_t )a->tv_usec;
  }
#line 58
  return (r);
}
}
#line 62 "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c"
int timeval_cmp(struct timeval  const  *a , struct timeval  const  *b ) 
{ 


  {
#line 63
  if (a) {
#line 63
    if (! b) {
      {
#line 63
      __assert_fail("a && b", "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c", 63U,
                    "timeval_cmp");
      }
    }
  } else {
    {
#line 63
    __assert_fail("a && b", "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c", 63U,
                  "timeval_cmp");
    }
  }
#line 65
  if (a->tv_sec < b->tv_sec) {
#line 66
    return (-1);
  }
#line 68
  if (a->tv_sec > b->tv_sec) {
#line 69
    return (1);
  }
#line 71
  if (a->tv_usec < b->tv_usec) {
#line 72
    return (-1);
  }
#line 74
  if (a->tv_usec > b->tv_usec) {
#line 75
    return (1);
  }
#line 77
  return (0);
}
}
#line 81 "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c"
usec_t timeval_age(struct timeval  const  *tv ) 
{ 
  struct timeval now ;
  usec_t tmp ;

  {
#line 83
  if (! tv) {
    {
#line 83
    __assert_fail("tv", "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c", 83U, "timeval_age");
    }
  }
  {
#line 84
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 85
  tmp = timeval_diff((struct timeval  const  *)(& now), tv);
  }
#line 85
  return (tmp);
}
}
#line 89 "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c"
void timeval_add(struct timeval *tv , usec_t v ) 
{ 
  unsigned long secs ;

  {
#line 91
  if (! tv) {
    {
#line 91
    __assert_fail("tv", "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c", 91U, "timeval_add");
    }
  }
#line 93
  secs = v / 1000000UL;
#line 94
  tv->tv_sec = (__time_t )((unsigned long )tv->tv_sec + secs);
#line 95
  v -= secs * 1000000UL;
#line 97
  tv->tv_usec = (__suseconds_t )((usec_t )tv->tv_usec + v);
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (tv->tv_usec >= 1000000L)) {
#line 100
      goto while_break;
    }
#line 101
    (tv->tv_sec) ++;
#line 102
    tv->tv_usec -= 1000000L;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 106 "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c"
int set_cloexec(int fd ) 
{ 
  int n ;
  int tmp ;

  {
#line 108
  if (! (fd >= 0)) {
    {
#line 108
    __assert_fail("fd >= 0", "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c", 108U,
                  "set_cloexec");
    }
  }
  {
#line 110
  n = fcntl(fd, 1);
  }
#line 110
  if (n < 0) {
#line 111
    return (-1);
  }
#line 113
  if (n & 1) {
#line 114
    return (0);
  }
  {
#line 116
  tmp = fcntl(fd, 2, n | 1);
  }
#line 116
  return (tmp);
}
}
#line 119 "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c"
int set_nonblock(int fd ) 
{ 
  int n ;
  int tmp ;

  {
#line 121
  if (! (fd >= 0)) {
    {
#line 121
    __assert_fail("fd >= 0", "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c", 121U,
                  "set_nonblock");
    }
  }
  {
#line 123
  n = fcntl(fd, 3);
  }
#line 123
  if (n < 0) {
#line 124
    return (-1);
  }
#line 126
  if (n & 2048) {
#line 127
    return (0);
  }
  {
#line 129
  tmp = fcntl(fd, 4, n | 2048);
  }
#line 129
  return (tmp);
}
}
#line 132 "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c"
int wait_for_write(int fd , struct timeval *end ) 
{ 
  struct timeval now ;
  struct timeval tv ;
  fd_set fds ;
  int r ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  usec_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  struct timeval *tmp___4 ;

  {
#line 135
  if (end) {
    {
#line 136
    gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
    }
  }
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 143
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 143
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 144
    fds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 146
    if (end) {
      {
#line 147
      tmp = timeval_cmp((struct timeval  const  *)(& now), (struct timeval  const  *)end);
      }
#line 147
      if (tmp >= 0) {
#line 148
        return (1);
      }
      {
#line 150
      tv.tv_usec = (__suseconds_t )0;
#line 150
      tv.tv_sec = tv.tv_usec;
#line 151
      tmp___0 = timeval_diff((struct timeval  const  *)end, (struct timeval  const  *)(& now));
#line 151
      timeval_add(& tv, tmp___0);
      }
    }
#line 154
    if (end) {
#line 154
      tmp___4 = & tv;
    } else {
#line 154
      tmp___4 = (struct timeval *)((void *)0);
    }
    {
#line 154
    r = select(fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fds),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)tmp___4);
    }
#line 154
    if (r < 0) {
      {
#line 155
      tmp___3 = __errno_location();
      }
#line 155
      if (*tmp___3 != 4) {
        {
#line 156
        tmp___1 = __errno_location();
#line 156
        tmp___2 = strerror(*tmp___1);
#line 156
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"select() failed: %s\n",
                tmp___2);
        }
#line 157
        return (-1);
      }
    } else
#line 159
    if (r == 0) {
#line 160
      return (1);
    } else
#line 162
    if ((fds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 163
      return (0);
    }
#line 166
    if (end) {
      {
#line 167
      gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 171 "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c"
int wait_for_read(int fd , struct timeval *end ) 
{ 
  struct timeval now ;
  struct timeval tv ;
  fd_set fds ;
  int r ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  usec_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  struct timeval *tmp___4 ;

  {
#line 174
  if (end) {
    {
#line 175
    gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
    }
  }
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 182
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 182
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 182
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 183
    fds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 185
    if (end) {
      {
#line 186
      tmp = timeval_cmp((struct timeval  const  *)(& now), (struct timeval  const  *)end);
      }
#line 186
      if (tmp >= 0) {
#line 187
        return (1);
      }
      {
#line 189
      tv.tv_usec = (__suseconds_t )0;
#line 189
      tv.tv_sec = tv.tv_usec;
#line 190
      tmp___0 = timeval_diff((struct timeval  const  *)end, (struct timeval  const  *)(& now));
#line 190
      timeval_add(& tv, tmp___0);
      }
    }
#line 193
    if (end) {
#line 193
      tmp___4 = & tv;
    } else {
#line 193
      tmp___4 = (struct timeval *)((void *)0);
    }
    {
#line 193
    r = select(fd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)tmp___4);
    }
#line 193
    if (r < 0) {
      {
#line 194
      tmp___3 = __errno_location();
      }
#line 194
      if (*tmp___3 != 4) {
        {
#line 195
        tmp___1 = __errno_location();
#line 195
        tmp___2 = strerror(*tmp___1);
#line 195
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"select() failed: %s\n",
                tmp___2);
        }
#line 196
        return (-1);
      }
    } else
#line 198
    if (r == 0) {
#line 199
      return (1);
    } else
#line 202
    if ((fds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 203
      return (0);
    }
#line 206
    if (end) {
      {
#line 207
      gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 212 "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c"
int domain_cmp(char const   *a , char const   *b ) 
{ 
  size_t al ;
  size_t bl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 215
  al = strlen(a);
#line 216
  bl = strlen(b);
  }
#line 218
  if (al > 0UL) {
#line 218
    if ((int const   )*(a + (al - 1UL)) == 46) {
#line 219
      al --;
    }
  }
#line 221
  if (bl > 0UL) {
#line 221
    if ((int const   )*(b + (bl - 1UL)) == 46) {
#line 222
      bl --;
    }
  }
#line 224
  if (al != bl) {
#line 225
    if (al > bl) {
#line 225
      tmp___0 = 1;
    } else {
#line 225
      if (al < bl) {
#line 225
        tmp = -1;
      } else {
#line 225
        tmp = 0;
      }
#line 225
      tmp___0 = tmp;
    }
#line 225
    return (tmp___0);
  }
  {
#line 227
  tmp___1 = strncasecmp(a, b, al);
  }
#line 227
  return (tmp___1);
}
}
#line 230 "/home/wheatley/newnew/temp/mdns-scan-0.5/util.c"
char *ends_with(char const   *a , char const   *b ) 
{ 
  size_t k ;
  size_t l ;
  char *c___0 ;
  int tmp ;

  {
  {
#line 233
  k = strlen(a);
#line 234
  l = strlen(b);
  }
#line 236
  if (l > k) {
#line 237
    return ((char *)((void *)0));
  }
  {
#line 239
  c___0 = ((char *)a + k) - l;
#line 241
  tmp = strcmp((char const   *)c___0, b);
  }
#line 241
  if (tmp == 0) {
#line 242
    return (c___0);
  }
#line 244
  return ((char *)((void *)0));
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 33 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.h"
struct dns_packet *dns_packet_new(void) ;
#line 34
void dns_packet_free(struct dns_packet *p ) ;
#line 35
void dns_packet_set_field(struct dns_packet *p , unsigned int index___0 , uint16_t v ) ;
#line 38
uint8_t *dns_packet_append_uint16(struct dns_packet *p , uint16_t v ) ;
#line 39
uint8_t *dns_packet_append_name(struct dns_packet *p , char const   *name ) ;
#line 42
int dns_packet_check_valid_response(struct dns_packet *p ) ;
#line 45
int dns_packet_consume_name(struct dns_packet *p , char *ret_name , size_t l ) ;
#line 46
int dns_packet_consume_uint16(struct dns_packet *p , uint16_t *ret_v ) ;
#line 47
int dns_packet_consume_uint32(struct dns_packet *p , uint32_t *ret_v ) ;
#line 49
int dns_packet_consume_seek(struct dns_packet *p , size_t length ) ;
#line 27 "/home/wheatley/newnew/temp/mdns-scan-0.5/query.h"
int mdns_open_socket(void) ;
#line 29
int mdns_send_dns_packet(int fd , struct dns_packet *p ) ;
#line 30
int mdns_recv_dns_packet(int fd , struct dns_packet **ret_packet , uint8_t *ret_ttl ,
                         struct timeval *end ) ;
#line 40 "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c"
struct hash_entry *hash_table[1023]  ;
#line 42 "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c"
static unsigned int hash_func(char const   *c___0 ) 
{ 
  unsigned int hash ;

  {
#line 43
  hash = 0U;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! *c___0) {
#line 45
      goto while_break;
    }
#line 46
    hash = 31U * hash + (unsigned int )*c___0;
#line 45
    c___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return (hash);
}
}
#line 51 "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c"
static void handle_service(char const   *service ) 
{ 
  struct hash_entry *e ;
  unsigned int h ;
  unsigned int i ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 55
  h = hash_func(service);
#line 55
  i = h % 1023U;
  }
#line 57
  if (hash_table[i]) {
#line 58
    e = hash_table[i];
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! e) {
#line 58
        goto while_break;
      }
#line 59
      if (e->hash == h) {
        {
#line 60
        tmp = strcmp((char const   *)e->name, service);
        }
#line 60
        if (! tmp) {
#line 61
          return;
        }
      }
#line 58
      e = e->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 64
  tmp___0 = malloc(sizeof(struct hash_entry ));
#line 64
  e = (struct hash_entry *)tmp___0;
  }
#line 65
  if (! e) {
    {
#line 65
    __assert_fail("e", "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c", 65U,
                  "handle_service");
    }
  }
  {
#line 66
  e->hash = h;
#line 67
  e->name = strdup(service);
  }
#line 68
  if (! e->name) {
    {
#line 68
    __assert_fail("e->name", "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c",
                  68U, "handle_service");
    }
  }
  {
#line 69
  e->next = hash_table[i];
#line 70
  hash_table[i] = e;
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"+ %s\n",
          service);
  }
#line 73
  return;
}
}
#line 75 "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c"
static void free_hash_table(void) 
{ 
  unsigned int i ;
  struct hash_entry **e ;
  struct hash_entry *n ;

  {
#line 79
  i = 0U;
#line 79
  e = hash_table;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < 1023U)) {
#line 79
      goto while_break;
    }
    {
#line 80
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if (! *e) {
#line 80
        goto while_break___0;
      }
      {
#line 81
      n = (*e)->next;
#line 83
      free((void *)(*e)->name);
#line 84
      free((void *)*e);
#line 85
      *e = n;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 79
    i ++;
#line 79
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return;
}
}
#line 90 "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c"
static int send_query(int fd , char const   *name , uint16_t type ) 
{ 
  int ret ;
  struct dns_packet *p ;
  uint8_t *tmp ;
  int tmp___0 ;

  {
#line 91
  ret = -1;
#line 92
  p = (struct dns_packet *)((void *)0);
#line 94
  if (! (fd >= 0)) {
    {
#line 94
    __assert_fail("fd >= 0", "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c",
                  94U, "send_query");
    }
  }
  {
#line 96
  p = dns_packet_new();
  }
#line 96
  if (! p) {
    {
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to allocate DNS packet.\n");
    }
#line 98
    goto finish;
  }
  {
#line 101
  dns_packet_set_field(p, 1U, (uint16_t )0);
#line 103
  tmp = dns_packet_append_name(p, name);
  }
#line 103
  if (! tmp) {
    {
#line 104
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad host name\n");
    }
#line 105
    goto finish;
  }
  {
#line 108
  dns_packet_append_uint16(p, type);
#line 109
  dns_packet_append_uint16(p, (uint16_t )1);
#line 110
  dns_packet_set_field(p, 2U, (uint16_t )1);
#line 112
  tmp___0 = mdns_send_dns_packet(fd, p);
  }
#line 112
  if (tmp___0 < 0) {
#line 113
    goto finish;
  }
#line 115
  ret = 0;
  finish: 
#line 118
  if (p) {
    {
#line 119
    dns_packet_free(p);
    }
  }
#line 121
  return (ret);
}
}
#line 124 "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c"
static int handle_packet(int fd , struct dns_packet *p ) 
{ 
  char pname[256] ;
  uint16_t type ;
  uint16_t class ;
  uint32_t rr_ttl ;
  uint16_t rdlength ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char service[256] ;
  int tmp___4 ;
  int tmp___5 ;
  char service___0[256] ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 131
    tmp = dns_packet_consume_name(p, pname, sizeof(pname));
    }
#line 131
    if (tmp < 0) {
#line 136
      goto while_break;
    } else {
      {
#line 131
      tmp___0 = dns_packet_consume_uint16(p, & type);
      }
#line 131
      if (tmp___0 < 0) {
#line 136
        goto while_break;
      } else {
        {
#line 131
        tmp___1 = dns_packet_consume_uint16(p, & class);
        }
#line 131
        if (tmp___1 < 0) {
#line 136
          goto while_break;
        } else {
          {
#line 131
          tmp___2 = dns_packet_consume_uint32(p, & rr_ttl);
          }
#line 131
          if (tmp___2 < 0) {
#line 136
            goto while_break;
          } else {
            {
#line 131
            tmp___3 = dns_packet_consume_uint16(p, & rdlength);
            }
#line 131
            if (tmp___3 < 0) {
#line 136
              goto while_break;
            }
          }
        }
      }
    }
#line 140
    class = (uint16_t )((int )class & -32769);
#line 142
    if ((int )type == 12) {
#line 142
      if ((int )class == 1) {
        {
#line 142
        tmp___10 = strcmp((char const   *)(pname), "_services._dns-sd._udp.local");
        }
#line 142
        if (tmp___10 == 0) {
          {
#line 147
          tmp___4 = dns_packet_consume_name(p, service, sizeof(service));
          }
#line 147
          if (tmp___4 < 0) {
#line 148
            goto while_break;
          }
          {
#line 150
          tmp___5 = send_query(fd, (char const   *)(service), (uint16_t )12);
          }
#line 150
          if (tmp___5 < 0) {
#line 151
            return (-1);
          }
        } else {
#line 142
          goto _L___3;
        }
      } else {
#line 142
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 153
    if ((int )type == 12) {
#line 153
      if ((int )class == 1) {
        {
#line 153
        tmp___8 = strstr((char const   *)(pname), "._tcp.");
        }
#line 153
        if (tmp___8) {
#line 153
          goto _L___0;
        } else {
          {
#line 153
          tmp___9 = strstr((char const   *)(pname), "._udp.");
          }
#line 153
          if (tmp___9) {
            _L___0: /* CIL Label */ 
            {
#line 158
            tmp___6 = dns_packet_consume_name(p, service___0, sizeof(service___0));
            }
#line 158
            if (tmp___6 < 0) {
#line 159
              goto while_break;
            }
            {
#line 161
            handle_service((char const   *)(service___0));
            }
          } else {
#line 153
            goto _L___1;
          }
        }
      } else {
#line 153
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 163
      tmp___7 = dns_packet_consume_seek(p, (size_t )rdlength);
      }
#line 163
      if (tmp___7 < 0) {
#line 164
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return (0);
}
}
#line 171
static char rotdash(void) ;
#line 171 "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c"
static char const   *rd  =    "/-\\|\\-";
#line 172 "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c"
static char const   *c  =    (char const   *)((void *)0);
#line 170 "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c"
static char rotdash(void) 
{ 
  char const   *tmp ;

  {
#line 174
  if (! c) {
#line 175
    c = rd;
  } else
#line 174
  if (! *c) {
#line 175
    c = rd;
  }
#line 177
  tmp = c;
#line 177
  c ++;
#line 177
  return ((char )*tmp);
}
}
#line 180 "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c"
static int event_loop(int fd ) 
{ 
  struct timeval tv ;
  char tmp ;
  int tmp___0 ;
  struct dns_packet *p ;
  uint8_t ttl ;
  int r ;
  int tmp___1 ;

  {
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 185
    tmp = rotdash();
#line 185
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Browsing ... %c           \r",
            (int )tmp);
#line 187
    tmp___0 = send_query(fd, "_services._dns-sd._udp.local", (uint16_t )12);
    }
#line 187
    if (tmp___0 < 0) {
#line 188
      return (-1);
    }
    {
#line 190
    gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 191
    timeval_add(& tv, (usec_t )1000000);
    }
    {
#line 193
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 194
      p = (struct dns_packet *)((void *)0);
#line 198
      r = mdns_recv_dns_packet(fd, & p, & ttl, & tv);
      }
#line 198
      if (r < 0) {
#line 199
        return (-1);
      }
#line 201
      if (! p) {
#line 202
        goto while_break___0;
      }
#line 204
      if (! p) {
        {
#line 204
        __assert_fail("p", "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c",
                      204U, "event_loop");
        }
      }
#line 206
      if ((int )ttl == 255) {
        {
#line 206
        tmp___1 = dns_packet_check_valid_response(p);
        }
#line 206
        if (tmp___1 >= 0) {
          {
#line 208
          handle_packet(fd, p);
          }
        }
      }
      {
#line 211
      dns_packet_free(p);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 218 "/home/wheatley/newnew/temp/mdns-scan-0.5/mdns-scan.c"
int main(int argc , char **argv ) 
{ 
  int fd ;
  int ret ;
  int tmp___0 ;

  {
  {
#line 219
  fd = -1;
#line 220
  ret = 1;
#line 222
  memset((void *)(& hash_table), 0, sizeof(hash_table));
#line 224
  fd = mdns_open_socket();
  }
#line 224
  if (fd < 0) {
#line 225
    goto finish;
  }
  {
#line 227
  tmp___0 = event_loop(fd);
  }
#line 227
  if (tmp___0 < 0) {
#line 227
    ret = 1;
  } else {
#line 227
    ret = 0;
  }
  finish: 
#line 231
  if (fd >= 0) {
    {
#line 232
    close(fd);
    }
  }
  {
#line 234
  free_hash_table();
  }
#line 236
  return (ret);
}
}
#line 272 "/usr/include/x86_64-linux-gnu/bits/socket.h"
extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                struct cmsghdr *__cmsg ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 184
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 43 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.h"
int dns_packet_check_valid(struct dns_packet *p ) ;
#line 44 "/home/wheatley/newnew/temp/mdns-scan-0.5/query.c"
static void mdns_mcast_group(struct sockaddr_in *ret_sa ) 
{ 


  {
#line 45
  if (! ret_sa) {
    {
#line 45
    __assert_fail("ret_sa", "/home/wheatley/newnew/temp/mdns-scan-0.5/query.c", 45U,
                  "mdns_mcast_group");
    }
  }
  {
#line 47
  ret_sa->sin_family = (sa_family_t )2;
#line 48
  ret_sa->sin_port = htons((uint16_t )5353);
#line 49
  ret_sa->sin_addr.s_addr = inet_addr("224.0.0.251");
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/mdns-scan-0.5/query.c"
int mdns_open_socket(void) 
{ 
  struct ip_mreqn mreq ;
  struct sockaddr_in sa ;
  int fd ;
  int ttl ;
  int yes ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;

  {
  {
#line 55
  fd = -1;
#line 57
  mdns_mcast_group(& sa);
#line 59
  fd = socket(2, 2, 0);
  }
#line 59
  if (fd < 0) {
    {
#line 60
    tmp = __errno_location();
#line 60
    tmp___0 = strerror(*tmp);
#line 60
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"socket() failed: %s\n",
            tmp___0);
    }
#line 61
    goto fail;
  }
  {
#line 64
  ttl = 255;
#line 65
  tmp___3 = setsockopt(fd, 0, 33, (void const   *)(& ttl), (socklen_t )sizeof(ttl));
  }
#line 65
  if (tmp___3 < 0) {
    {
#line 66
    tmp___1 = __errno_location();
#line 66
    tmp___2 = strerror(*tmp___1);
#line 66
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IP_MULTICAST_TTL failed: %s\n",
            tmp___2);
    }
#line 67
    goto fail;
  }
  {
#line 70
  yes = 1;
#line 71
  tmp___6 = setsockopt(fd, 1, 2, (void const   *)(& yes), (socklen_t )sizeof(yes));
  }
#line 71
  if (tmp___6 < 0) {
    {
#line 72
    tmp___4 = __errno_location();
#line 72
    tmp___5 = strerror(*tmp___4);
#line 72
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SO_REUSEADDR failed: %s\n",
            tmp___5);
    }
#line 73
    goto fail;
  }
  {
#line 76
  tmp___9 = bind(fd, (struct sockaddr  const  *)((struct sockaddr *)(& sa)), (socklen_t )sizeof(sa));
  }
#line 76
  if (tmp___9 < 0) {
    {
#line 77
    tmp___7 = __errno_location();
#line 77
    tmp___8 = strerror(*tmp___7);
#line 77
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bind() failed: %s\n",
            tmp___8);
    }
#line 78
    goto fail;
  }
  {
#line 81
  memset((void *)(& mreq), 0, sizeof(mreq));
#line 82
  mreq.imr_multiaddr = sa.sin_addr;
#line 83
  mreq.imr_address.s_addr = htonl((in_addr_t )0);
#line 84
  mreq.imr_ifindex = 0;
#line 86
  tmp___12 = setsockopt(fd, 0, 35, (void const   *)(& mreq), (socklen_t )sizeof(mreq));
  }
#line 86
  if (tmp___12 < 0) {
    {
#line 87
    tmp___10 = __errno_location();
#line 87
    tmp___11 = strerror(*tmp___10);
#line 87
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IP_ADD_MEMBERSHIP failed: %s\n",
            tmp___11);
    }
#line 88
    goto fail;
  }
  {
#line 91
  tmp___15 = setsockopt(fd, 0, 12, (void const   *)(& yes), (socklen_t )sizeof(yes));
  }
#line 91
  if (tmp___15 < 0) {
    {
#line 92
    tmp___13 = __errno_location();
#line 92
    tmp___14 = strerror(*tmp___13);
#line 92
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"O_RECVTTL failed: %s\n",
            tmp___14);
    }
#line 93
    goto fail;
  }
  {
#line 96
  tmp___18 = setsockopt(fd, 0, 8, (void const   *)(& yes), (socklen_t )sizeof(yes));
  }
#line 96
  if (tmp___18 < 0) {
    {
#line 97
    tmp___16 = __errno_location();
#line 97
    tmp___17 = strerror(*tmp___16);
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IP_PKTINFO failed: %s\n",
            tmp___17);
    }
#line 98
    goto fail;
  }
  {
#line 101
  tmp___21 = set_cloexec(fd);
  }
#line 101
  if (tmp___21 < 0) {
    {
#line 102
    tmp___19 = __errno_location();
#line 102
    tmp___20 = strerror(*tmp___19);
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FD_CLOEXEC failed: %s\n",
            tmp___20);
    }
#line 103
    goto fail;
  }
  {
#line 106
  tmp___24 = set_nonblock(fd);
  }
#line 106
  if (tmp___24 < 0) {
    {
#line 107
    tmp___22 = __errno_location();
#line 107
    tmp___23 = strerror(*tmp___22);
#line 107
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"O_ONONBLOCK failed: %s\n",
            tmp___23);
    }
#line 108
    goto fail;
  }
#line 111
  return (fd);
  fail: 
#line 114
  if (fd >= 0) {
    {
#line 115
    close(fd);
    }
  }
#line 117
  return (-1);
}
}
#line 120 "/home/wheatley/newnew/temp/mdns-scan-0.5/query.c"
int mdns_send_dns_packet(int fd , struct dns_packet *p ) 
{ 
  struct sockaddr_in sa ;
  struct msghdr msg ;
  struct iovec io ;
  struct cmsghdr *cmsg ;
  struct in_pktinfo *pkti ;
  uint8_t cmsg_data[sizeof(struct cmsghdr ) + sizeof(struct in_pktinfo )] ;
  int i ;
  int n ;
  struct ifreq ifreq[32] ;
  struct ifconf ifconf ;
  int n_sent ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct sockaddr_in *sa___0 ;
  u_int32_t s_addr ;
  int tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;

  {
#line 130
  n_sent = 0;
#line 132
  if (fd >= 0) {
#line 132
    if (! p) {
      {
#line 132
      __assert_fail("fd >= 0 && p", "/home/wheatley/newnew/temp/mdns-scan-0.5/query.c",
                    132U, "mdns_send_dns_packet");
      }
    }
  } else {
    {
#line 132
    __assert_fail("fd >= 0 && p", "/home/wheatley/newnew/temp/mdns-scan-0.5/query.c",
                  132U, "mdns_send_dns_packet");
    }
  }
  {
#line 133
  tmp = dns_packet_check_valid(p);
  }
#line 133
  if (! (tmp >= 0)) {
    {
#line 133
    __assert_fail("dns_packet_check_valid(p) >= 0", "/home/wheatley/newnew/temp/mdns-scan-0.5/query.c",
                  133U, "mdns_send_dns_packet");
    }
  }
  {
#line 135
  mdns_mcast_group(& sa);
#line 137
  memset((void *)(& io), 0, sizeof(io));
#line 138
  io.iov_base = (void *)(p->data);
#line 139
  io.iov_len = p->size;
#line 141
  memset((void *)(cmsg_data), 0, sizeof(cmsg_data));
#line 142
  cmsg = (struct cmsghdr *)(cmsg_data);
#line 143
  cmsg->cmsg_len = sizeof(cmsg_data);
#line 144
  cmsg->cmsg_level = 0;
#line 145
  cmsg->cmsg_type = 8;
#line 147
  pkti = (struct in_pktinfo *)(cmsg_data + sizeof(struct cmsghdr ));
#line 148
  pkti->ipi_ifindex = 0;
#line 150
  memset((void *)(& msg), 0, sizeof(msg));
#line 151
  msg.msg_name = (void *)(& sa);
#line 152
  msg.msg_namelen = (socklen_t )sizeof(sa);
#line 153
  msg.msg_iov = & io;
#line 154
  msg.msg_iovlen = (size_t )1;
#line 155
  msg.msg_control = (void *)(cmsg_data);
#line 156
  msg.msg_controllen = sizeof(cmsg_data);
#line 157
  msg.msg_flags = 0;
#line 159
  ifconf.ifc_ifcu.ifcu_req = ifreq;
#line 160
  ifconf.ifc_len = (int )sizeof(ifreq);
#line 162
  tmp___2 = ioctl(fd, 35090UL, & ifconf);
  }
#line 162
  if (tmp___2 < 0) {
    {
#line 163
    tmp___0 = __errno_location();
#line 163
    tmp___1 = strerror(*tmp___0);
#line 163
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SIOCGIFCONF failed: %s\n",
            tmp___1);
    }
#line 164
    return (-1);
  }
#line 167
  i = 0;
#line 167
  n = (int )((unsigned long )ifconf.ifc_len / sizeof(struct ifreq ));
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < n)) {
#line 167
      goto while_break;
    }
    {
#line 172
    sa___0 = (struct sockaddr_in *)(& ifreq[i].ifr_ifru.ifru_addr);
#line 173
    s_addr = htonl(sa___0->sin_addr.s_addr);
    }
#line 174
    if ((int )sa___0->sin_family != 2) {
#line 178
      goto __Cont;
    } else
#line 174
    if (s_addr == 2130706433U) {
#line 178
      goto __Cont;
    } else
#line 174
    if (s_addr == 0U) {
#line 178
      goto __Cont;
    } else
#line 174
    if (s_addr == 4294967295U) {
#line 178
      goto __Cont;
    }
    {
#line 180
    tmp___3 = ioctl(fd, 35091UL, & ifreq[i]);
    }
#line 180
    if (tmp___3 < 0) {
#line 181
      goto __Cont;
    }
#line 187
    if (! ((int )ifreq[i].ifr_ifru.ifru_flags & 4096)) {
#line 190
      goto __Cont;
    } else
#line 187
    if (! ((int )ifreq[i].ifr_ifru.ifru_flags & 1)) {
#line 190
      goto __Cont;
    } else
#line 187
    if (! ((int )ifreq[i].ifr_ifru.ifru_flags & 64)) {
#line 190
      goto __Cont;
    }
    {
#line 192
    tmp___4 = ioctl(fd, 35123UL, & ifreq[i]);
    }
#line 192
    if (tmp___4 < 0) {
#line 193
      goto __Cont;
    }
#line 195
    pkti->ipi_ifindex = ifreq[i].ifr_ifru.ifru_ivalue;
    {
#line 197
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 199
      tmp___5 = sendmsg(fd, (struct msghdr  const  *)(& msg), 4);
      }
#line 199
      if (tmp___5 >= 0L) {
#line 200
        goto while_break___0;
      }
      {
#line 202
      tmp___8 = __errno_location();
      }
#line 202
      if (*tmp___8 != 11) {
        {
#line 203
        tmp___6 = __errno_location();
#line 203
        tmp___7 = strerror(*tmp___6);
#line 203
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendmsg() failed: %s\n",
                tmp___7);
        }
#line 204
        return (-1);
      }
      {
#line 207
      tmp___9 = wait_for_write(fd, (struct timeval *)((void *)0));
      }
#line 207
      if (tmp___9 < 0) {
#line 208
        return (-1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 211
    n_sent ++;
    __Cont: /* CIL Label */ 
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return (n_sent);
}
}
#line 217 "/home/wheatley/newnew/temp/mdns-scan-0.5/query.c"
int mdns_recv_dns_packet(int fd , struct dns_packet **ret_packet , uint8_t *ret_ttl ,
                         struct timeval *end ) 
{ 
  struct dns_packet *p ;
  struct msghdr msg ;
  struct iovec io ;
  int ret ;
  uint8_t aux[64] ;
  ssize_t l ;
  int r ;
  struct cmsghdr *cmsg ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
#line 218
  p = (struct dns_packet *)((void *)0);
#line 221
  ret = -1;
#line 223
  if (! (fd >= 0)) {
    {
#line 223
    __assert_fail("fd >= 0", "/home/wheatley/newnew/temp/mdns-scan-0.5/query.c", 223U,
                  "mdns_recv_dns_packet");
    }
  }
  {
#line 225
  p = dns_packet_new();
#line 227
  io.iov_base = (void *)(p->data);
#line 228
  io.iov_len = sizeof(p->data);
#line 230
  memset((void *)(& msg), 0, sizeof(msg));
#line 231
  msg.msg_name = (void *)0;
#line 232
  msg.msg_namelen = (socklen_t )0;
#line 233
  msg.msg_iov = & io;
#line 234
  msg.msg_iovlen = (size_t )1;
#line 235
  msg.msg_control = (void *)(aux);
#line 236
  msg.msg_controllen = sizeof(aux);
#line 237
  msg.msg_flags = 0;
  }
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 243
    l = recvmsg(fd, & msg, 0);
    }
#line 243
    if (l >= 0L) {
#line 245
      *ret_ttl = (uint8_t )0;
#line 247
      if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 247
        cmsg = (struct cmsghdr *)msg.msg_control;
      } else {
#line 247
        cmsg = (struct cmsghdr *)0;
      }
      {
#line 247
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 247
        if (! ((unsigned long )cmsg != (unsigned long )((void *)0))) {
#line 247
          goto while_break___0;
        }
#line 248
        if (cmsg->cmsg_level == 0) {
#line 248
          if (cmsg->cmsg_type == 2) {
#line 249
            *ret_ttl = cmsg->__cmsg_data[0];
#line 250
            goto while_break___0;
          }
        }
        {
#line 247
        cmsg = __cmsg_nxthdr(& msg, cmsg);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 254
      if ((unsigned long )cmsg == (unsigned long )((void *)0)) {
        {
#line 255
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Didn\'t recieve TTL\n");
        }
#line 256
        goto fail;
      }
#line 259
      p->size = (size_t )l;
#line 261
      *ret_packet = p;
#line 262
      return (0);
    }
    {
#line 265
    tmp___1 = __errno_location();
    }
#line 265
    if (*tmp___1 != 11) {
      {
#line 266
      tmp = __errno_location();
#line 266
      tmp___0 = strerror(*tmp);
#line 266
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"recvfrom() failed: %s\n",
              tmp___0);
      }
#line 267
      goto fail;
    }
    {
#line 270
    r = wait_for_read(fd, end);
    }
#line 270
    if (r < 0) {
#line 271
      goto fail;
    } else
#line 272
    if (r > 0) {
#line 273
      ret = 0;
#line 274
      *ret_packet = (struct dns_packet *)((void *)0);
#line 275
      goto fail;
    }
  }
  while_break: /* CIL Label */ ;
  }
  fail: 
#line 280
  if (p) {
    {
#line 281
    dns_packet_free(p);
    }
  }
#line 283
  return (ret);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 36 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.h"
uint16_t dns_packet_get_field(struct dns_packet *p , unsigned int index___0 ) ;
#line 40
uint8_t *dns_packet_append_name_compressed(struct dns_packet *p , char const   *name ,
                                           uint8_t *prev ) ;
#line 41
uint8_t *dns_packet_extend(struct dns_packet *p , size_t l ) ;
#line 48
int dns_packet_consume_bytes(struct dns_packet *p , void *ret_data , size_t l ) ;
#line 34 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
struct dns_packet *dns_packet_new(void) 
{ 
  struct dns_packet *p ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 36
  tmp = malloc(sizeof(struct dns_packet ));
#line 36
  p = (struct dns_packet *)tmp;
  }
#line 37
  if (! p) {
    {
#line 37
    __assert_fail("p", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c", 37U, "dns_packet_new");
    }
  }
  {
#line 38
  tmp___0 = (size_t )12;
#line 38
  p->rindex = tmp___0;
#line 38
  p->size = tmp___0;
#line 39
  memset((void *)(p->data), 0, p->size);
  }
#line 40
  return (p);
}
}
#line 43 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
void dns_packet_free(struct dns_packet *p ) 
{ 


  {
#line 44
  if (! p) {
    {
#line 44
    __assert_fail("p", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c", 44U, "dns_packet_free");
    }
  }
  {
#line 45
  free((void *)p);
  }
#line 46
  return;
}
}
#line 48 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
void dns_packet_set_field(struct dns_packet *p , unsigned int index___0 , uint16_t v ) 
{ 


  {
#line 49
  if (p) {
#line 49
    if (! (index___0 < 12U)) {
      {
#line 49
      __assert_fail("p && index < 2*6", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c",
                    49U, "dns_packet_set_field");
      }
    }
  } else {
    {
#line 49
    __assert_fail("p && index < 2*6", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c",
                  49U, "dns_packet_set_field");
    }
  }
  {
#line 51
  *((uint16_t *)(p->data) + index___0) = htons(v);
  }
#line 52
  return;
}
}
#line 54 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
uint16_t dns_packet_get_field(struct dns_packet *p , unsigned int index___0 ) 
{ 
  uint16_t tmp ;

  {
#line 55
  if (p) {
#line 55
    if (! (index___0 < 12U)) {
      {
#line 55
      __assert_fail("p && index < 2*6", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c",
                    55U, "dns_packet_get_field");
      }
    }
  } else {
    {
#line 55
    __assert_fail("p && index < 2*6", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c",
                  55U, "dns_packet_get_field");
    }
  }
  {
#line 57
  tmp = ntohs(*((uint16_t *)(p->data) + index___0));
  }
#line 57
  return (tmp);
}
}
#line 60 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
uint8_t *dns_packet_append_name(struct dns_packet *p , char const   *name ) 
{ 
  uint8_t *d ;
  uint8_t *f ;
  size_t n ;
  size_t tmp ;

  {
#line 61
  f = (uint8_t *)((void *)0);
#line 62
  if (! p) {
    {
#line 62
    __assert_fail("p", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c", 62U, "dns_packet_append_name");
    }
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 65
    tmp = strcspn(name, ".");
#line 65
    n = tmp;
    }
#line 66
    if (! n) {
#line 67
      return ((uint8_t *)((void *)0));
    } else
#line 66
    if (n > 63UL) {
#line 67
      return ((uint8_t *)((void *)0));
    }
    {
#line 69
    d = dns_packet_extend(p, n + 1UL);
    }
#line 70
    if (! f) {
#line 71
      f = d;
    }
    {
#line 72
    *(d + 0) = (uint8_t )n;
#line 73
    memcpy((void */* __restrict  */)(d + 1), (void const   */* __restrict  */)name,
           n);
#line 75
    name += n;
    }
#line 78
    if (! *name) {
#line 79
      goto while_break;
    }
#line 81
    name ++;
#line 84
    if (! *name) {
#line 85
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  d = dns_packet_extend(p, (size_t )1);
#line 89
  *(d + 0) = (uint8_t )0;
  }
#line 91
  return (f);
}
}
#line 94 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
uint8_t *dns_packet_append_uint16(struct dns_packet *p , uint16_t v ) 
{ 
  uint8_t *d ;

  {
#line 96
  if (! p) {
    {
#line 96
    __assert_fail("p", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c", 96U, "dns_packet_append_uint16");
    }
  }
  {
#line 97
  d = dns_packet_extend(p, sizeof(uint16_t ));
#line 98
  *((uint16_t *)d) = htons(v);
  }
#line 99
  return (d);
}
}
#line 102 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
uint8_t *dns_packet_extend(struct dns_packet *p , size_t l ) 
{ 
  uint8_t *d ;

  {
#line 104
  if (! p) {
    {
#line 104
    __assert_fail("p", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c", 104U, "dns_packet_extend");
    }
  }
#line 106
  if (! (p->size + l <= sizeof(p->data))) {
    {
#line 106
    __assert_fail("p->size+l <= sizeof(p->data)", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c",
                  106U, "dns_packet_extend");
    }
  }
#line 108
  d = p->data + p->size;
#line 109
  p->size += l;
#line 111
  return (d);
}
}
#line 114 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
uint8_t *dns_packet_append_name_compressed(struct dns_packet *p , char const   *name ,
                                           uint8_t *prev ) 
{ 
  int16_t *d ;
  long k ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;
  uint16_t tmp___2 ;

  {
#line 117
  if (! p) {
    {
#line 117
    __assert_fail("p", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c", 117U, "dns_packet_append_name_compressed");
    }
  }
#line 119
  if (! prev) {
    {
#line 120
    tmp = dns_packet_append_name(p, name);
    }
#line 120
    return (tmp);
  }
#line 122
  k = prev - p->data;
#line 123
  if (k < 0L) {
    {
#line 124
    tmp___0 = dns_packet_append_name(p, name);
    }
#line 124
    return (tmp___0);
  } else
#line 123
  if (k >= 16384L) {
    {
#line 124
    tmp___0 = dns_packet_append_name(p, name);
    }
#line 124
    return (tmp___0);
  } else
#line 123
  if ((size_t )k >= p->size) {
    {
#line 124
    tmp___0 = dns_packet_append_name(p, name);
    }
#line 124
    return (tmp___0);
  }
  {
#line 126
  tmp___1 = dns_packet_extend(p, sizeof(uint16_t ));
#line 126
  d = (int16_t *)tmp___1;
#line 127
  tmp___2 = htons((uint16_t )(49152L | k));
#line 127
  *d = (int16_t )tmp___2;
  }
#line 129
  return (prev);
}
}
#line 132 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
int dns_packet_check_valid(struct dns_packet *p ) 
{ 
  uint16_t flags ;

  {
#line 133
  if (! p) {
    {
#line 133
    __assert_fail("p", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c", 133U, "dns_packet_check_valid");
    }
  }
#line 136
  if (p->size < 12UL) {
#line 137
    return (-1);
  }
  {
#line 139
  flags = dns_packet_get_field(p, 1U);
  }
#line 141
  if ((int )flags & (15 << 11)) {
#line 142
    return (-1);
  } else
#line 141
  if ((int )flags & 15) {
#line 142
    return (-1);
  }
#line 144
  return (0);
}
}
#line 147 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
int dns_packet_check_valid_response(struct dns_packet *p ) 
{ 
  uint16_t flags ;
  int tmp ;
  uint16_t tmp___0 ;

  {
#line 149
  if (! p) {
    {
#line 149
    __assert_fail("p", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c", 149U, "dns_packet_check_valid_response");
    }
  }
  {
#line 151
  tmp = dns_packet_check_valid(p);
  }
#line 151
  if (tmp < 0) {
#line 152
    return (-1);
  }
  {
#line 154
  flags = dns_packet_get_field(p, 1U);
  }
#line 156
  if (! ((int )flags & (1 << 15))) {
#line 157
    return (-1);
  }
  {
#line 159
  tmp___0 = dns_packet_get_field(p, 2U);
  }
#line 159
  if ((int )tmp___0 > 0) {
#line 160
    return (-1);
  }
#line 162
  return (0);
}
}
#line 166 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
static ssize_t consume_labels(struct dns_packet *p , size_t index___0 , char *ret_name ,
                              size_t l ) 
{ 
  ssize_t ret ;
  int compressed ;
  int first_label ;
  uint8_t n ;
  char *tmp ;

  {
#line 167
  ret = (ssize_t )0;
#line 168
  compressed = 0;
#line 169
  first_label = 1;
#line 170
  if (p) {
#line 170
    if (ret_name) {
#line 170
      if (! l) {
        {
#line 170
        __assert_fail("p && ret_name && l", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c",
                      170U, "consume_labels");
        }
      }
    } else {
      {
#line 170
      __assert_fail("p && ret_name && l", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c",
                    170U, "consume_labels");
      }
    }
  } else {
    {
#line 170
    __assert_fail("p && ret_name && l", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c",
                  170U, "consume_labels");
    }
  }
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (index___0 + 1UL > p->size) {
#line 176
      return ((ssize_t )-1);
    }
#line 178
    n = p->data[index___0];
#line 180
    if (! n) {
#line 181
      index___0 ++;
#line 182
      if (! compressed) {
#line 183
        ret ++;
      }
#line 185
      if (l < 1UL) {
#line 186
        return ((ssize_t )-1);
      }
#line 187
      *ret_name = (char)0;
#line 189
      return (ret);
    } else
#line 191
    if ((int )n <= 63) {
#line 193
      index___0 ++;
#line 194
      if (! compressed) {
#line 195
        ret ++;
      }
#line 197
      if (index___0 + (size_t )n > p->size) {
#line 198
        return ((ssize_t )-1);
      }
#line 200
      if ((size_t )n + 1UL > l) {
#line 201
        return ((ssize_t )-1);
      }
#line 203
      if (! first_label) {
#line 204
        tmp = ret_name;
#line 204
        ret_name ++;
#line 204
        *tmp = (char )'.';
#line 205
        l --;
      } else {
#line 207
        first_label = 0;
      }
      {
#line 209
      memcpy((void */* __restrict  */)ret_name, (void const   */* __restrict  */)(p->data + index___0),
             (size_t )n);
#line 210
      index___0 += (size_t )n;
#line 211
      ret_name += (int )n;
#line 212
      l -= (size_t )n;
      }
#line 214
      if (! compressed) {
#line 215
        ret += (ssize_t )n;
      }
    } else
#line 216
    if (((int )n & 192) == 192) {
#line 219
      if (index___0 + 2UL > p->size) {
#line 220
        return ((ssize_t )-1);
      }
#line 222
      index___0 = ((size_t )((int )p->data[index___0] & -193) << 8) | (unsigned long )p->data[index___0 + 1UL];
#line 224
      if (! compressed) {
#line 225
        ret += 2L;
      }
#line 227
      compressed = 1;
    } else {
#line 229
      return ((ssize_t )-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 233 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
int dns_packet_consume_name(struct dns_packet *p , char *ret_name , size_t l ) 
{ 
  ssize_t r ;

  {
  {
#line 236
  r = consume_labels(p, p->rindex, ret_name, l);
  }
#line 236
  if (r < 0L) {
#line 237
    return (-1);
  }
#line 239
  p->rindex += (size_t )r;
#line 240
  return (0);
}
}
#line 243 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
int dns_packet_consume_uint16(struct dns_packet *p , uint16_t *ret_v ) 
{ 


  {
#line 244
  if (p) {
#line 244
    if (! ret_v) {
      {
#line 244
      __assert_fail("p && ret_v", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c",
                    244U, "dns_packet_consume_uint16");
      }
    }
  } else {
    {
#line 244
    __assert_fail("p && ret_v", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c",
                  244U, "dns_packet_consume_uint16");
    }
  }
#line 246
  if (p->rindex + sizeof(uint16_t ) > p->size) {
#line 247
    return (-1);
  }
  {
#line 249
  *ret_v = ntohs(*((uint16_t *)(p->data + p->rindex)));
#line 250
  p->rindex += sizeof(uint16_t );
  }
#line 252
  return (0);
}
}
#line 255 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
int dns_packet_consume_uint32(struct dns_packet *p , uint32_t *ret_v ) 
{ 


  {
#line 256
  if (p) {
#line 256
    if (! ret_v) {
      {
#line 256
      __assert_fail("p && ret_v", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c",
                    256U, "dns_packet_consume_uint32");
      }
    }
  } else {
    {
#line 256
    __assert_fail("p && ret_v", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c",
                  256U, "dns_packet_consume_uint32");
    }
  }
#line 258
  if (p->rindex + sizeof(uint32_t ) > p->size) {
#line 259
    return (-1);
  }
  {
#line 261
  *ret_v = ntohl(*((uint32_t *)(p->data + p->rindex)));
#line 262
  p->rindex += sizeof(uint32_t );
  }
#line 264
  return (0);
}
}
#line 267 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
int dns_packet_consume_bytes(struct dns_packet *p , void *ret_data , size_t l ) 
{ 


  {
#line 268
  if (p) {
#line 268
    if (ret_data) {
#line 268
      if (! (l > 0UL)) {
        {
#line 268
        __assert_fail("p && ret_data && l > 0", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c",
                      268U, "dns_packet_consume_bytes");
        }
      }
    } else {
      {
#line 268
      __assert_fail("p && ret_data && l > 0", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c",
                    268U, "dns_packet_consume_bytes");
      }
    }
  } else {
    {
#line 268
    __assert_fail("p && ret_data && l > 0", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c",
                  268U, "dns_packet_consume_bytes");
    }
  }
#line 270
  if (p->rindex + l > p->size) {
#line 271
    return (-1);
  }
  {
#line 273
  memcpy((void */* __restrict  */)ret_data, (void const   */* __restrict  */)(p->data + p->rindex),
         l);
#line 274
  p->rindex += l;
  }
#line 276
  return (0);
}
}
#line 279 "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c"
int dns_packet_consume_seek(struct dns_packet *p , size_t length ) 
{ 


  {
#line 280
  if (! p) {
    {
#line 280
    __assert_fail("p", "/home/wheatley/newnew/temp/mdns-scan-0.5/dns.c", 280U, "dns_packet_consume_seek");
    }
  }
#line 282
  if (! length) {
#line 283
    return (0);
  }
#line 285
  if (p->rindex + length > p->size) {
#line 286
    return (-1);
  }
#line 288
  p->rindex += length;
#line 289
  return (0);
}
}
