/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 36 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.h"
struct dateStruct {
   int mm ;
   int dd ;
   int yy ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.h"
typedef struct dateStruct date_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 27 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.h"
struct hmonth {
   char const   *name[3] ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.h"
typedef struct hmonth hmonth_t;
#line 32 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.h"
typedef hmonth_t hmonths_t[][15];
#line 1 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/cities.h"
struct city {
   char *name ;
   int latdeg ;
   int latmin ;
   int longdeg ;
   int longmin ;
   int TZ ;
   int DST_scheme ;
};
#line 1 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/cities.h"
typedef struct city city_t;
#line 154 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
struct dst {
   char *name ;
   int DST_scheme ;
};
#line 154 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
typedef struct dst dst_t;
#line 76 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
struct hebrew_year {
   int first_day_of_week ;
   int leap_p ;
};
#line 76 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
typedef struct hebrew_year year_t;
#line 102 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
struct hsnode {
   char *name ;
   unsigned int typeMask ;
   struct hsnode *next ;
};
#line 102 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
typedef struct hsnode *holstorep_t;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 95 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
struct hinode {
   date_t date ;
   char *name[3] ;
   unsigned int typeMask ;
   struct hinode *next ;
};
#line 95 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
typedef struct hinode holinput_t;
#line 95 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
typedef struct hinode *holinputp_t;
#line 102 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
typedef struct hsnode holstore_t;
#line 328 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/holidays.c"
struct variable_holiday_names {
   char *name[3] ;
};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.h"
char const   *ShortDayNames[7] ;
#line 43
long greg2abs(date_t d ) ;
#line 47
int dayOfWeek(date_t d1 ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/myerror.h"
void die(char const   *s1 , char const   *s2 ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
char *formatString ;
#line 16 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/danlib.h"
char *hc_itoa(int i ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/format.h"
char *formatLine(date_t const   gregDate , date_t const   hebDate , char const   *text ,
                 char *output , size_t maxOutputLen ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/format.c"
static void appendTo(char **buf___0 , char **bufEnd , char **bufIter , char const   *appendMe ) 
{ 
  size_t len ;
  size_t tmp ;
  size_t remainingBuf ;
  size_t bufSize ;
  size_t needed ;
  char *buf2 ;
  void *tmp___0 ;
  size_t bufLen ;

  {
  {
#line 41
  tmp = strlen(appendMe);
#line 41
  len = tmp;
#line 42
  remainingBuf = (size_t )(*bufEnd - *bufIter);
  }
#line 43
  if (remainingBuf <= len + 1UL) {
    {
#line 45
    bufSize = (size_t )(*bufEnd - *buf___0);
#line 46
    needed = (bufSize + len) + 5UL;
#line 47
    tmp___0 = calloc(needed, sizeof(char ));
#line 47
    buf2 = (char *)tmp___0;
#line 48
    bufLen = (size_t )(*bufIter - *buf___0);
    }
#line 50
    if (! buf2) {
      {
#line 51
      die("couldn\'t reallocate enough memory for format", "");
      }
    }
    {
#line 53
    memcpy((void */* __restrict  */)buf2, (void const   */* __restrict  */)*buf___0,
           bufLen);
#line 55
    *bufIter = buf2 + (bufIter - buf___0);
#line 56
    *bufEnd = buf2 + (bufEnd - buf___0);
#line 57
    *buf___0 = buf2;
    }
  }
  {
#line 59
  strncpy((char */* __restrict  */)*bufIter, (char const   */* __restrict  */)appendMe,
          len);
#line 60
  *bufIter += len;
  }
#line 61
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/format.c"
char *formatLine(date_t const   gregDate , date_t const   hebDate , char const   *text ,
                 char *output , size_t maxOutputLen ) 
{ 
  size_t formatLen ;
  size_t tmp ;
  int allocLength ;
  char *autoBuf ;
  unsigned long __lengthofautoBuf ;
  void *tmp___0 ;
  char *buf___0 ;
  char *bufEnd ;
  char *bufIter ;
  char *formatEnd ;
  char const   *formatIter ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char numBuf[20] ;
  long tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 72
  tmp = strlen((char const   *)formatString);
#line 72
  formatLen = tmp;
#line 73
  allocLength = (int )(200UL + formatLen * 2UL);
#line 74
  __lengthofautoBuf = (unsigned long )allocLength;
#line 74
  tmp___0 = __builtin_alloca(sizeof(*autoBuf) * __lengthofautoBuf);
#line 74
  autoBuf = (char *)tmp___0;
#line 75
  buf___0 = autoBuf;
#line 76
  bufEnd = buf___0 + allocLength;
#line 77
  bufIter = buf___0;
#line 78
  formatEnd = formatString + formatLen;
  }
#line 81
  if (! buf___0) {
    {
#line 82
    tmp___1 = strlen((char const   *)formatString);
#line 82
    tmp___2 = hc_itoa((int )(tmp___1 * 2UL));
#line 82
    die("unable to allocate %s bytes to format line", (char const   *)tmp___2);
    }
  }
#line 84
  *buf___0 = (char )'\000';
#line 85
  if ((unsigned long )bufEnd > (unsigned long )buf___0) {
#line 86
    *(bufEnd - 1) = (char )'\000';
  }
#line 88
  formatIter = (char const   *)formatString;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if ((unsigned long )formatIter < (unsigned long )formatEnd) {
#line 88
      if (! *formatIter) {
#line 88
        goto while_break;
      }
    } else {
#line 88
      goto while_break;
    }
    {
#line 94
    if ((int const   )*formatIter == 92) {
#line 94
      goto case_92;
    }
#line 123
    if ((int const   )*formatIter == 37) {
#line 123
      goto case_37;
    }
#line 172
    goto switch_default;
    case_92: /* CIL Label */ 
#line 95
    formatIter ++;
#line 96
    if ((unsigned long )formatIter >= (unsigned long )formatEnd) {
#line 97
      goto switch_break;
    } else
#line 96
    if (! *formatIter) {
#line 97
      goto switch_break;
    }
    {
#line 100
    if ((int const   )*formatIter == 110) {
#line 100
      goto case_110;
    }
#line 103
    if ((int const   )*formatIter == 98) {
#line 103
      goto case_98;
    }
#line 106
    if ((int const   )*formatIter == 101) {
#line 106
      goto case_101;
    }
#line 109
    if ((int const   )*formatIter == 102) {
#line 109
      goto case_102;
    }
#line 112
    if ((int const   )*formatIter == 114) {
#line 112
      goto case_114;
    }
#line 115
    if ((int const   )*formatIter == 116) {
#line 115
      goto case_116;
    }
#line 118
    if ((int const   )*formatIter == 92) {
#line 118
      goto case_92___0;
    }
#line 98
    goto switch_break___0;
    case_110: /* CIL Label */ 
    {
#line 101
    appendTo(& buf___0, & bufEnd, & bufIter, "\n");
    }
#line 102
    goto switch_break___0;
    case_98: /* CIL Label */ 
    {
#line 104
    appendTo(& buf___0, & bufEnd, & bufIter, "\b");
    }
#line 105
    goto switch_break___0;
    case_101: /* CIL Label */ 
    {
#line 107
    appendTo(& buf___0, & bufEnd, & bufIter, "\033");
    }
#line 108
    goto switch_break___0;
    case_102: /* CIL Label */ 
    {
#line 110
    appendTo(& buf___0, & bufEnd, & bufIter, "\f");
    }
#line 111
    goto switch_break___0;
    case_114: /* CIL Label */ 
    {
#line 113
    appendTo(& buf___0, & bufEnd, & bufIter, "\r");
    }
#line 114
    goto switch_break___0;
    case_116: /* CIL Label */ 
    {
#line 116
    appendTo(& buf___0, & bufEnd, & bufIter, "\t");
    }
#line 117
    goto switch_break___0;
    case_92___0: /* CIL Label */ 
    {
#line 119
    appendTo(& buf___0, & bufEnd, & bufIter, "\\");
    }
#line 120
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 122
    goto switch_break;
    case_37: /* CIL Label */ 
#line 124
    formatIter ++;
#line 125
    if ((unsigned long )formatIter >= (unsigned long )formatEnd) {
#line 126
      goto switch_break;
    } else
#line 125
    if (! *formatIter) {
#line 126
      goto switch_break;
    }
    {
#line 129
    if ((int const   )*formatIter == 37) {
#line 129
      goto case_37___0;
    }
#line 132
    if ((int const   )*formatIter == 97) {
#line 132
      goto case_97;
    }
#line 135
    if ((int const   )*formatIter == 89) {
#line 135
      goto case_89;
    }
#line 138
    if ((int const   )*formatIter == 109) {
#line 138
      goto case_109;
    }
#line 141
    if ((int const   )*formatIter == 100) {
#line 141
      goto case_100;
    }
#line 145
    if ((int const   )*formatIter == 81) {
#line 145
      goto case_81;
    }
#line 149
    if ((int const   )*formatIter == 113) {
#line 149
      goto case_113;
    }
#line 152
    if ((int const   )*formatIter == 107) {
#line 152
      goto case_107;
    }
#line 155
    if ((int const   )*formatIter == 74) {
#line 155
      goto case_74;
    }
#line 164
    if ((int const   )*formatIter == 116) {
#line 164
      goto case_116___0;
    }
#line 127
    goto switch_break___1;
    case_37___0: /* CIL Label */ 
    {
#line 130
    appendTo(& buf___0, & bufEnd, & bufIter, "%");
    }
#line 131
    goto switch_break___1;
    case_97: /* CIL Label */ 
    {
#line 133
    tmp___3 = dayOfWeek((date_t )gregDate);
#line 133
    appendTo(& buf___0, & bufEnd, & bufIter, ShortDayNames[tmp___3]);
    }
#line 134
    goto switch_break___1;
    case_89: /* CIL Label */ 
    {
#line 136
    tmp___4 = hc_itoa((int )gregDate.yy);
#line 136
    appendTo(& buf___0, & bufEnd, & bufIter, (char const   *)tmp___4);
    }
#line 137
    goto switch_break___1;
    case_109: /* CIL Label */ 
    {
#line 139
    tmp___5 = hc_itoa((int )gregDate.mm);
#line 139
    appendTo(& buf___0, & bufEnd, & bufIter, (char const   *)tmp___5);
    }
#line 140
    goto switch_break___1;
    case_100: /* CIL Label */ 
    {
#line 142
    tmp___6 = hc_itoa((int )gregDate.dd);
#line 142
    appendTo(& buf___0, & bufEnd, & bufIter, (char const   *)tmp___6);
    }
#line 143
    goto switch_break___1;
    case_81: /* CIL Label */ 
    {
#line 146
    tmp___7 = hc_itoa((int )hebDate.yy);
#line 146
    appendTo(& buf___0, & bufEnd, & bufIter, (char const   *)tmp___7);
    }
#line 147
    goto switch_break___1;
    case_113: /* CIL Label */ 
    {
#line 150
    tmp___8 = hc_itoa((int )hebDate.mm);
#line 150
    appendTo(& buf___0, & bufEnd, & bufIter, (char const   *)tmp___8);
    }
#line 151
    goto switch_break___1;
    case_107: /* CIL Label */ 
    {
#line 153
    tmp___9 = hc_itoa((int )hebDate.dd);
#line 153
    appendTo(& buf___0, & bufEnd, & bufIter, (char const   *)tmp___9);
    }
#line 154
    goto switch_break___1;
    case_74: /* CIL Label */ 
    {
#line 158
    tmp___10 = greg2abs((date_t )gregDate);
#line 158
    snprintf((char */* __restrict  */)(numBuf), (size_t )20, (char const   */* __restrict  */)"%ld",
             tmp___10);
#line 159
    numBuf[19] = (char )'\000';
#line 160
    appendTo(& buf___0, & bufEnd, & bufIter, (char const   *)(numBuf));
    }
#line 161
    goto switch_break___1;
    case_116___0: /* CIL Label */ 
    {
#line 165
    appendTo(& buf___0, & bufEnd, & bufIter, text);
    }
#line 166
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 171
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 173
    tmp___11 = bufIter;
#line 173
    bufIter ++;
#line 173
    *tmp___11 = (char )*formatIter;
#line 174
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 88
    formatIter ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  tmp___12 = bufIter;
#line 177
  bufIter ++;
#line 177
  *tmp___12 = (char )'\000';
#line 179
  strncpy((char */* __restrict  */)output, (char const   */* __restrict  */)buf___0,
          maxOutputLen);
#line 181
  *(output + (maxOutputLen - 1UL)) = (char )'\000';
  }
#line 182
  return (output);
}
}
#line 2 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/gnu.c"
char const   *license[269]  = 
#line 2 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/gnu.c"
  {      (char *)"GNU GENERAL PUBLIC LICENSE",      (char *)"**************************",      (char *)"",      (char *)"                         Version 2, June 1991", 
        (char *)"",      (char *)"     Copyright (C) 1989, 1991 Free Software Foundation, Inc.",      (char *)"     675 Mass Ave, Cambridge, MA 02139, USA",      (char *)"     ", 
        (char *)"     Everyone is permitted to copy and distribute verbatim copies",      (char *)"     of this license document, but changing it is not allowed.",      (char *)"",      (char *)"Preamble", 
        (char *)"========",      (char *)"",      (char *)"   The licenses for most software are designed to take away your",      (char *)"freedom to share and change it.  By contrast, the GNU General Public", 
        (char *)"License is intended to guarantee your freedom to share and change free",      (char *)"software--to make sure the software is free for all its users.  This",      (char *)"General Public License applies to most of the Free Software",      (char *)"Foundation\'s software and to any other program whose authors commit to", 
        (char *)"using it.  (Some other Free Software Foundation software is covered by",      (char *)"the GNU Library General Public License instead.)  You can apply it to",      (char *)"your programs, too.",      (char *)"", 
        (char *)"   When we speak of free software, we are referring to freedom, not",      (char *)"price.  Our General Public Licenses are designed to make sure that you",      (char *)"have the freedom to distribute copies of free software (and charge for",      (char *)"this service if you wish), that you receive source code or can get it", 
        (char *)"if you want it, that you can change the software or use pieces of it in",      (char *)"new free programs; and that you know you can do these things.",      (char *)"",      (char *)"   To protect your rights, we need to make restrictions that forbid", 
        (char *)"anyone to deny you these rights or to ask you to surrender the rights.",      (char *)"These restrictions translate to certain responsibilities for you if you",      (char *)"distribute copies of the software, or if you modify it.",      (char *)"", 
        (char *)"   For example, if you distribute copies of such a program, whether",      (char *)"gratis or for a fee, you must give the recipients all the rights that",      (char *)"you have.  You must make sure that they, too, receive or can get the",      (char *)"source code.  And you must show them these terms so they know their", 
        (char *)"rights.",      (char *)"",      (char *)"   We protect your rights with two steps: (1) copyright the software,",      (char *)"and (2) offer you this license which gives you legal permission to copy,", 
        (char *)"distribute and/or modify the software.",      (char *)"",      (char *)"   Also, for each author\'s protection and ours, we want to make certain",      (char *)"that everyone understands that there is no warranty for this free", 
        (char *)"software.  If the software is modified by someone else and passed on, we",      (char *)"want its recipients to know that what they have is not the original, so",      (char *)"that any problems introduced by others will not reflect on the original",      (char *)"authors\' reputations.", 
        (char *)"",      (char *)"   Finally, any free program is threatened constantly by software",      (char *)"patents.  We wish to avoid the danger that redistributors of a free",      (char *)"program will individually obtain patent licenses, in effect making the", 
        (char *)"program proprietary.  To prevent this, we have made it clear that any",      (char *)"patent must be licensed for everyone\'s free use or not licensed at all.",      (char *)"",      (char *)"   The precise terms and conditions for copying, distribution and", 
        (char *)"modification follow.",      (char *)"",      (char *)"    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION",      (char *)"", 
        (char *)"  0. This License applies to any program or other work which contains a",      (char *)"     notice placed by the copyright holder saying it may be distributed",      (char *)"     under the terms of this General Public License.  The \"Program\",",      (char *)"     below, refers to any such program or work, and a \"work based on", 
        (char *)"     the Program\" means either the Program or any derivative work under",      (char *)"     copyright law: that is to say, a work containing the Program or a",      (char *)"     portion of it, either verbatim or with modifications and/or",      (char *)"     translated into another language.  (Hereinafter, translation is", 
        (char *)"     included without limitation in the term \"modification\".)  Each",      (char *)"     licensee is addressed as \"you\".",      (char *)"",      (char *)"     Activities other than copying, distribution and modification are", 
        (char *)"     not covered by this License; they are outside its scope.  The act",      (char *)"     of running the Program is not restricted, and the output from the",      (char *)"     Program is covered only if its contents constitute a work based on",      (char *)"     the Program (independent of having been made by running the", 
        (char *)"     Program).  Whether that is true depends on what the Program does.",      (char *)"",      (char *)"  1. You may copy and distribute verbatim copies of the Program\'s",      (char *)"     source code as you receive it, in any medium, provided that you", 
        (char *)"     conspicuously and appropriately publish on each copy an appropriate",      (char *)"     copyright notice and disclaimer of warranty; keep intact all the",      (char *)"     notices that refer to this License and to the absence of any",      (char *)"     warranty; and give any other recipients of the Program a copy of", 
        (char *)"     this License along with the Program.",      (char *)"",      (char *)"     You may charge a fee for the physical act of transferring a copy,",      (char *)"     and you may at your option offer warranty protection in exchange", 
        (char *)"     for a fee.",      (char *)"",      (char *)"  2. You may modify your copy or copies of the Program or any portion",      (char *)"     of it, thus forming a work based on the Program, and copy and", 
        (char *)"     distribute such modifications or work under the terms of Section 1",      (char *)"     above, provided that you also meet all of these conditions:",      (char *)"",      (char *)"       a. You must cause the modified files to carry prominent notices", 
        (char *)"          stating that you changed the files and the date of any change.",      (char *)"",      (char *)"       b. You must cause any work that you distribute or publish, that",      (char *)"          in whole or in part contains or is derived from the Program", 
        (char *)"          or any part thereof, to be licensed as a whole at no charge",      (char *)"          to all third parties under the terms of this License.",      (char *)"",      (char *)"       c. If the modified program normally reads commands interactively", 
        (char *)"          when run, you must cause it, when started running for such",      (char *)"          interactive use in the most ordinary way, to print or display",      (char *)"          an announcement including an appropriate copyright notice and",      (char *)"          a notice that there is no warranty (or else, saying that you", 
        (char *)"          provide a warranty) and that users may redistribute the",      (char *)"          program under these conditions, and telling the user how to",      (char *)"          view a copy of this License.  (Exception: if the Program",      (char *)"          itself is interactive but does not normally print such an", 
        (char *)"          announcement, your work based on the Program is not required",      (char *)"          to print an announcement.)",      (char *)"",      (char *)"     These requirements apply to the modified work as a whole.  If", 
        (char *)"     identifiable sections of that work are not derived from the",      (char *)"     Program, and can be reasonably considered independent and separate",      (char *)"     works in themselves, then this License, and its terms, do not",      (char *)"     apply to those sections when you distribute them as separate", 
        (char *)"     works.  But when you distribute the same sections as part of a",      (char *)"     whole which is a work based on the Program, the distribution of",      (char *)"     the whole must be on the terms of this License, whose permissions",      (char *)"     for other licensees extend to the entire whole, and thus to each", 
        (char *)"     and every part regardless of who wrote it.",      (char *)"",      (char *)"     Thus, it is not the intent of this section to claim rights or",      (char *)"     contest your rights to work written entirely by you; rather, the", 
        (char *)"     intent is to exercise the right to control the distribution of",      (char *)"     derivative or collective works based on the Program.",      (char *)"",      (char *)"     In addition, mere aggregation of another work not based on the", 
        (char *)"     Program with the Program (or with a work based on the Program) on",      (char *)"     a volume of a storage or distribution medium does not bring the",      (char *)"     other work under the scope of this License.",      (char *)"", 
        (char *)"  3. You may copy and distribute the Program (or a work based on it,",      (char *)"     under Section 2) in object code or executable form under the terms",      (char *)"     of Sections 1 and 2 above provided that you also do one of the",      (char *)"     following:", 
        (char *)"",      (char *)"       a. Accompany it with the complete corresponding machine-readable",      (char *)"          source code, which must be distributed under the terms of",      (char *)"          Sections 1 and 2 above on a medium customarily used for", 
        (char *)"          software interchange; or,",      (char *)"",      (char *)"       b. Accompany it with a written offer, valid for at least three",      (char *)"          years, to give any third party, for a charge no more than your", 
        (char *)"          cost of physically performing source distribution, a complete",      (char *)"          machine-readable copy of the corresponding source code, to be",      (char *)"          distributed under the terms of Sections 1 and 2 above on a",      (char *)"          medium customarily used for software interchange; or,", 
        (char *)"",      (char *)"       c. Accompany it with the information you received as to the offer",      (char *)"          to distribute corresponding source code.  (This alternative is",      (char *)"          allowed only for noncommercial distribution and only if you", 
        (char *)"          received the program in object code or executable form with",      (char *)"          such an offer, in accord with Subsection b above.)",      (char *)"",      (char *)"     The source code for a work means the preferred form of the work for", 
        (char *)"     making modifications to it.  For an executable work, complete",      (char *)"     source code means all the source code for all modules it contains,",      (char *)"     plus any associated interface definition files, plus the scripts",      (char *)"     used to control compilation and installation of the executable.", 
        (char *)"     However, as a special exception, the source code distributed need",      (char *)"     not include anything that is normally distributed (in either",      (char *)"     source or binary form) with the major components (compiler,",      (char *)"     kernel, and so on) of the operating system on which the executable", 
        (char *)"     runs, unless that component itself accompanies the executable.",      (char *)"",      (char *)"     If distribution of executable or object code is made by offering",      (char *)"     access to copy from a designated place, then offering equivalent", 
        (char *)"     access to copy the source code from the same place counts as",      (char *)"     distribution of the source code, even though third parties are not",      (char *)"     compelled to copy the source along with the object code.",      (char *)"", 
        (char *)"  4. You may not copy, modify, sublicense, or distribute the Program",      (char *)"     except as expressly provided under this License.  Any attempt",      (char *)"     otherwise to copy, modify, sublicense or distribute the Program is",      (char *)"     void, and will automatically terminate your rights under this", 
        (char *)"     License.  However, parties who have received copies, or rights,",      (char *)"     from you under this License will not have their licenses",      (char *)"     terminated so long as such parties remain in full compliance.",      (char *)"", 
        (char *)"  5. You are not required to accept this License, since you have not",      (char *)"     signed it.  However, nothing else grants you permission to modify",      (char *)"     or distribute the Program or its derivative works.  These actions",      (char *)"     are prohibited by law if you do not accept this License.", 
        (char *)"     Therefore, by modifying or distributing the Program (or any work",      (char *)"     based on the Program), you indicate your acceptance of this",      (char *)"     License to do so, and all its terms and conditions for copying,",      (char *)"     distributing or modifying the Program or works based on it.", 
        (char *)"",      (char *)"  6. Each time you redistribute the Program (or any work based on the",      (char *)"     Program), the recipient automatically receives a license from the",      (char *)"     original licensor to copy, distribute or modify the Program", 
        (char *)"     subject to these terms and conditions.  You may not impose any",      (char *)"     further restrictions on the recipients\' exercise of the rights",      (char *)"     granted herein.  You are not responsible for enforcing compliance",      (char *)"     by third parties to this License.", 
        (char *)"",      (char *)"  7. If, as a consequence of a court judgment or allegation of patent",      (char *)"     infringement or for any other reason (not limited to patent",      (char *)"     issues), conditions are imposed on you (whether by court order,", 
        (char *)"     agreement or otherwise) that contradict the conditions of this",      (char *)"     License, they do not excuse you from the conditions of this",      (char *)"     License.  If you cannot distribute so as to satisfy simultaneously",      (char *)"     your obligations under this License and any other pertinent", 
        (char *)"     obligations, then as a consequence you may not distribute the",      (char *)"     Program at all.  For example, if a patent license would not permit",      (char *)"     royalty-free redistribution of the Program by all those who",      (char *)"     receive copies directly or indirectly through you, then the only", 
        (char *)"     way you could satisfy both it and this License would be to refrain",      (char *)"     entirely from distribution of the Program.",      (char *)"",      (char *)"     If any portion of this section is held invalid or unenforceable", 
        (char *)"     under any particular circumstance, the balance of the section is",      (char *)"     intended to apply and the section as a whole is intended to apply",      (char *)"     in other circumstances.",      (char *)"", 
        (char *)"     It is not the purpose of this section to induce you to infringe any",      (char *)"     patents or other property right claims or to contest validity of",      (char *)"     any such claims; this section has the sole purpose of protecting",      (char *)"     the integrity of the free software distribution system, which is", 
        (char *)"     implemented by public license practices.  Many people have made",      (char *)"     generous contributions to the wide range of software distributed",      (char *)"     through that system in reliance on consistent application of that",      (char *)"     system; it is up to the author/donor to decide if he or she is", 
        (char *)"     willing to distribute software through any other system and a",      (char *)"     licensee cannot impose that choice.",      (char *)"",      (char *)"     This section is intended to make thoroughly clear what is believed", 
        (char *)"     to be a consequence of the rest of this License.",      (char *)"",      (char *)"  8. If the distribution and/or use of the Program is restricted in",      (char *)"     certain countries either by patents or by copyrighted interfaces,", 
        (char *)"     the original copyright holder who places the Program under this",      (char *)"     License may add an explicit geographical distribution limitation",      (char *)"     excluding those countries, so that distribution is permitted only",      (char *)"     in or among countries not thus excluded.  In such case, this", 
        (char *)"     License incorporates the limitation as if written in the body of",      (char *)"     this License.",      (char *)"",      (char *)"  9. The Free Software Foundation may publish revised and/or new", 
        (char *)"     versions of the General Public License from time to time.  Such",      (char *)"     new versions will be similar in spirit to the present version, but",      (char *)"     may differ in detail to address new problems or concerns.",      (char *)"", 
        (char *)"     Each version is given a distinguishing version number.  If the",      (char *)"     Program specifies a version number of this License which applies",      (char *)"     to it and \"any later version\", you have the option of following",      (char *)"     the terms and conditions either of that version or of any later", 
        (char *)"     version published by the Free Software Foundation.  If the Program",      (char *)"     does not specify a version number of this License, you may choose",      (char *)"     any version ever published by the Free Software Foundation.",      (char *)"", 
        (char *)" 10. If you wish to incorporate parts of the Program into other free",      (char *)"     programs whose distribution conditions are different, write to the",      (char *)"     author to ask for permission.  For software which is copyrighted",      (char *)"     by the Free Software Foundation, write to the Free Software", 
        (char *)"     Foundation; we sometimes make exceptions for this.  Our decision",      (char *)"     will be guided by the two goals of preserving the free status of",      (char *)"     all derivatives of our free software and of promoting the sharing",      (char *)"     and reuse of software generally.", 
        (char *)((void *)0)};
#line 274 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/gnu.c"
char const   *warranty[26]  = 
#line 274
  {      (char *)"                                NO WARRANTY",      (char *)"",      (char *)" 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO",      (char *)"     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE", 
        (char *)"     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT",      (char *)"     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT",      (char *)"     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT",      (char *)"     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND", 
        (char *)"     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE",      (char *)"     QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE",      (char *)"     PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY",      (char *)"     SERVICING, REPAIR OR CORRECTION.", 
        (char *)"",      (char *)" 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN",      (char *)"     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY",      (char *)"     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE", 
        (char *)"     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,",      (char *)"     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR",      (char *)"     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF",      (char *)"     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU", 
        (char *)"     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY",      (char *)"     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN",      (char *)"     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.",      (char *)"", 
        (char *)"                      END OF TERMS AND CONDITIONS",      (char *)((void *)0)};
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/danlib.h"
void initStr(char **s , size_t size ) ;
#line 14
int isAllNums(char const   *s ) ;
#line 15
char const   *numSuffix(int i ) ;
#line 17
int istrncasecmp(size_t n , char const   *s1 , char const   *s2 ) ;
#line 18
int lookup_string(char const   *str , char const   **arr , int size , int len ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/danlib.c"
void initStr(char **s , size_t size ) 
{ 
  char *tmp ;
  void *tmp___0 ;

  {
  {
#line 38
  tmp___0 = malloc((size + 1UL) * sizeof(char ));
#line 38
  tmp = (char *)tmp___0;
#line 38
  *s = tmp;
  }
#line 38
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 39
    die("\n Memory Error: Couldn\'t allocate string", "");
    }
  }
#line 40
  *(*s) = (char )'\000';
#line 41
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/danlib.c"
int istrncasecmp(size_t n , char const   *s1 , char const   *s2 ) 
{ 
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (n > 0UL) {
#line 47
      if (! *s1) {
#line 47
        if (! *s2) {
#line 47
          goto while_break;
        }
      }
    } else {
#line 47
      goto while_break;
    }
    {
#line 51
    tmp___4 = tolower((int )*s1);
#line 51
    tmp___5 = tolower((int )*s2);
    }
#line 51
    if (tmp___4 != tmp___5) {
      {
#line 53
      tmp___2 = tolower((int )*s1);
#line 53
      tmp___3 = tolower((int )*s2);
      }
#line 53
      if (tmp___2 < tmp___3) {
#line 53
        tmp___1 = -1;
      } else {
#line 53
        tmp___1 = 1;
      }
#line 53
      return (tmp___1);
    }
#line 47
    n --;
#line 47
    s1 ++;
#line 47
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return (0);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/danlib.c"
int lookup_string(char const   *str , char const   **arr , int size , int len ) 
{ 
  int i ;
  int tmp ;

  {
#line 67
  i = 0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < size)) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = istrncasecmp((size_t )len, str, *(arr + i));
    }
#line 68
    if (! tmp) {
#line 69
      return (i);
    }
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return (i);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/danlib.c"
int isAllNums(char const   *s ) 
{ 
  size_t n ;
  size_t len ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 79
  n = (size_t )0;
#line 80
  tmp = strlen(s);
#line 80
  len = tmp;
#line 82
  n = (size_t )0;
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (n < len) {
      {
#line 82
      tmp___0 = __ctype_b_loc();
      }
#line 82
      if (! ((int const   )*(*tmp___0 + (int )*(s + n)) & 2048)) {
#line 82
        goto while_break;
      }
    } else {
#line 82
      goto while_break;
    }
#line 82
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (n == len);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/danlib.c"
char const   *numSuffix(int i ) 
{ 


  {
#line 93
  if (i / 10 == 1) {
#line 94
    return ("th");
  }
  {
#line 97
  if (i % 10 == 1) {
#line 97
    goto case_1;
  }
#line 99
  if (i % 10 == 2) {
#line 99
    goto case_2;
  }
#line 101
  if (i % 10 == 3) {
#line 101
    goto case_3;
  }
#line 103
  goto switch_default;
  case_1: /* CIL Label */ 
#line 98
  return ("st");
  case_2: /* CIL Label */ 
#line 100
  return ("nd");
  case_3: /* CIL Label */ 
#line 102
  return ("rd");
  switch_default: /* CIL Label */ 
#line 104
  return ("th");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/danlib.c"
static char ret[7]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/danlib.c"
char *hc_itoa(int i ) 
{ 


  {
  {
#line 111
  sprintf((char */* __restrict  */)(ret), (char const   */* __restrict  */)"%d", i);
  }
#line 112
  return (ret);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.h"
long day_on_or_before(int day_of_week , long date ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int ashkenazis_sw ;
#line 47
int iso8859_8_sw ;
#line 47
int israel_sw ;
#line 7 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.h"
char *sedra(long absDate ) ;
#line 8
void reset_sedra(int hebYr ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.h"
long hebrew2abs(date_t d ) ;
#line 45
int long_cheshvan(int year ) ;
#line 46
int short_kislev(int year ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
char const   *sedrot[53][3]  = 
#line 44 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
  { {        "Bereshit",        "Bereshis",        "\341\370\340\371\351\372"}, 
   {        "Noach",        "Noach",        "\360\347"}, 
   {        "Lech-Lecha",        "Lech-Lecha",        "\354\352\354\352"}, 
   {        "Vayera",        "Vayera",        "\345\351\370\340"}, 
   {        "Chayei Sara",        "Chayei Sara",        "\347\351\351 \371\370\344"}, 
   {        "Toldot",        "Toldos",        "\372\345\354\343\345\372"}, 
   {        "Vayetzei",        "Vayetzei",        "\345\351\366\340"}, 
   {        "Vayishlach",        "Vayishlach",        "\345\351\371\354\347"}, 
   {        "Vayeshev",        "Vayeshev",        "\345\351\371\341"}, 
   {        "Miketz",        "Miketz",        "\356\367\365"}, 
   {        "Vayigash",        "Vayigash",        "\345\351\342\371"}, 
   {        "Vayechi",        "Vayechi",        "\345\351\347\351"}, 
   {        "Shemot",        "Shemos",        "\371\356\345\372"}, 
   {        "Vaera",        "Vaera",        "\345\340\370\340"}, 
   {        "Bo",        "Bo",        "\341\340"}, 
   {        "Beshalach",        "Beshalach",        "\341\371\354\347"}, 
   {        "Yitro",        "Yisro",        "\351\372\370\345"}, 
   {        "Mishpatim",        "Mishpatim",        "\356\371\364\350\351\355"}, 
   {        "Terumah",        "Terumah",        "\372\370\345\356\344"}, 
   {        "Tetzaveh",        "Tetzaveh",        "\372\366\345\344"}, 
   {        "Ki Tisa",        "Ki Sisa",        "\353\351 \372\371\340"}, 
   {        "Vayakhel",        "Vayakhel",        "\345\351\367\344\354"}, 
   {        "Pekudei",        "Pekudei",        "\364\367\345\343\351"}, 
   {        "Vayikra",        "Vayikra",        "\345\351\367\370\340"}, 
   {        "Tzav",        "Tzav",        "\366\345"}, 
   {        "Shmini",        "Shmini",        "\371\356\351\360\351"}, 
   {        "Tazria",        "Sazria",        "\372\346\370\351\362"}, 
   {        "Metzora",        "Metzora",        "\356\366\370\362"}, 
   {        "Achrei Mot",        "Achrei Mos",        "\340\347\370\351 \356\345\372"}, 
   {        "Kedoshim",        "Kedoshim",        "\367\343\371\351\355"}, 
   {        "Emor",        "Emor",        "\340\356\345\370"}, 
   {        "Behar",        "Behar",        "\341\344\370"}, 
   {        "Bechukotai",        "Bechukosai",        "\341\347\367\372\351"}, 
   {        "Bamidbar",        "Bamidbar",        "\341\356\343\341\370"}, 
   {        "Nasso",        "Nasso",        "\360\371\340"}, 
   {        "Beha\'alotcha",        "Beha\'aloscha",        "\341\344\362\354\372\352"}, 
   {        "Sh\'lach",        "Sh\'lach",        "\371\354\347\354\352"}, 
   {        "Korach",        "Korach",        "\367\345\370\347"}, 
   {        "Chukat",        "Chukas",        "\347\367\372"}, 
   {        "Balak",        "Balak",        "\341\354\367"}, 
   {        "Pinchas",        "Pinchas",        "\364\351\360\347\361"}, 
   {        "Matot",        "Matos",        "\356\350\345\372"}, 
   {        "Masei",        "Masei",        "\356\361\362\351"}, 
   {        "Devarim",        "Devarim",        "\343\341\370\351\355"}, 
   {        "Vaetchanan",        "Vaeschanan",        "\345\340\372\347\360\357"}, 
   {        "Eikev",        "Eikev",        "\362\367\341"}, 
   {        "Re\'eh",        "Re\'eh",        "\370\340\344"}, 
   {        "Shoftim",        "Shoftim",        "\371\345\364\350\351\355"}, 
   {        "Ki Teitzei",        "Ki Seitzei",        "\353\351\372\366\340"}, 
   {        "Ki Tavo",        "Ki Savo",        "\353\351\372\341\345\340"}, 
   {        "Nitzavim",        "Nitzavim",        "\360\366\341\351\355"}, 
   {        "Vayeilech",        "Vayeilech",        "\345\351\354\352"}, 
   {        "Ha\'Azinu",        "Ha\'Azinu",        "\344\340\346\351\360\345"}};
#line 116 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int nonleap_monday_incomplete[55]  = 
#line 116
  {      51,      52,      -1,      0, 
        1,      2,      3,      4, 
        5,      6,      7,      8, 
        9,      10,      11,      12, 
        13,      14,      15,      16, 
        17,      18,      19,      20, 
        -21,      23,      24,      -1, 
        25,      -26,      -28,      30, 
        -31,      33,      34,      35, 
        36,      37,      38,      39, 
        40,      -41,      43,      44, 
        45,      46,      47,      48, 
        49,      -50};
#line 123 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int nonleap_monday_complete_diaspora[55]  = 
#line 123
  {      51,      52,      -1,      0, 
        1,      2,      3,      4, 
        5,      6,      7,      8, 
        9,      10,      11,      12, 
        13,      14,      15,      16, 
        17,      18,      19,      20, 
        -21,      23,      24,      -1, 
        25,      -26,      -28,      30, 
        -31,      33,      -1,      34, 
        35,      36,      37,      -38, 
        40,      -41,      43,      44, 
        45,      46,      47,      48, 
        49,      -50};
#line 143 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int nonleap_thursday_regular_diaspora[55]  = 
#line 143
  {      52,      -1,      -1,      0, 
        1,      2,      3,      4, 
        5,      6,      7,      8, 
        9,      10,      11,      12, 
        13,      14,      15,      16, 
        17,      18,      19,      20, 
        -21,      23,      24,      -1, 
        -1,      25,      -26,      -28, 
        30,      -31,      33,      34, 
        35,      36,      37,      38, 
        39,      40,      -41,      43, 
        44,      45,      46,      47, 
        48,      49,      50};
#line 150 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int nonleap_thursday_regular_israel[55]  = 
#line 150
  {      52,      -1,      -1,      0, 
        1,      2,      3,      4, 
        5,      6,      7,      8, 
        9,      10,      11,      12, 
        13,      14,      15,      16, 
        17,      18,      19,      20, 
        -21,      23,      24,      -1, 
        25,      -26,      -28,      30, 
        31,      32,      33,      34, 
        35,      36,      37,      38, 
        39,      40,      -41,      43, 
        44,      45,      46,      47, 
        48,      49,      50};
#line 157 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int nonleap_thursday_complete[55]  = 
#line 157
  {      52,      -1,      -1,      0, 
        1,      2,      3,      4, 
        5,      6,      7,      8, 
        9,      10,      11,      12, 
        13,      14,      15,      16, 
        17,      18,      19,      20, 
        21,      22,      23,      24, 
        -1,      25,      -26,      -28, 
        30,      -31,      33,      34, 
        35,      36,      37,      38, 
        39,      40,      -41,      43, 
        44,      45,      46,      47, 
        48,      49,      50};
#line 163 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int nonleap_saturday_incomplete[55]  = 
#line 163
  {      -1,      52,      -1,      -1, 
        0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      9,      10,      11, 
        12,      13,      14,      15, 
        16,      17,      18,      19, 
        20,      -21,      23,      24, 
        -1,      25,      -26,      -28, 
        30,      -31,      33,      34, 
        35,      36,      37,      38, 
        39,      40,      -41,      43, 
        44,      45,      46,      47, 
        48,      49,      50};
#line 172 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int nonleap_saturday_complete[55]  = 
#line 172
  {      -1,      52,      -1,      -1, 
        0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      9,      10,      11, 
        12,      13,      14,      15, 
        16,      17,      18,      19, 
        20,      -21,      23,      24, 
        -1,      25,      -26,      -28, 
        30,      -31,      33,      34, 
        35,      36,      37,      38, 
        39,      40,      -41,      43, 
        44,      45,      46,      47, 
        48,      49,      -50};
#line 182 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int leap_monday_incomplete_diaspora[55]  = 
#line 182
  {      51,      52,      -1,      0, 
        1,      2,      3,      4, 
        5,      6,      7,      8, 
        9,      10,      11,      12, 
        13,      14,      15,      16, 
        17,      18,      19,      20, 
        21,      22,      23,      24, 
        25,      26,      27,      -1, 
        28,      29,      30,      31, 
        32,      33,      -1,      34, 
        35,      36,      37,      -38, 
        40,      -41,      43,      44, 
        45,      46,      47,      48, 
        49,      -50};
#line 190 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int leap_monday_incomplete_israel[55]  = 
#line 190
  {      51,      52,      -1,      0, 
        1,      2,      3,      4, 
        5,      6,      7,      8, 
        9,      10,      11,      12, 
        13,      14,      15,      16, 
        17,      18,      19,      20, 
        21,      22,      23,      24, 
        25,      26,      27,      -1, 
        28,      29,      30,      31, 
        32,      33,      34,      35, 
        36,      37,      38,      39, 
        40,      -41,      43,      44, 
        45,      46,      47,      48, 
        49,      -50};
#line 198 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int leap_monday_complete_diaspora[55]  = 
#line 198
  {      51,      52,      -1,      0, 
        1,      2,      3,      4, 
        5,      6,      7,      8, 
        9,      10,      11,      12, 
        13,      14,      15,      16, 
        17,      18,      19,      20, 
        21,      22,      23,      24, 
        25,      26,      27,      -1, 
        -1,      28,      29,      30, 
        31,      32,      33,      34, 
        35,      36,      37,      38, 
        39,      40,      -41,      43, 
        44,      45,      46,      47, 
        48,      49,      50};
#line 205 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int leap_monday_complete_israel[55]  = 
#line 205
  {      51,      52,      -1,      0, 
        1,      2,      3,      4, 
        5,      6,      7,      8, 
        9,      10,      11,      12, 
        13,      14,      15,      16, 
        17,      18,      19,      20, 
        21,      22,      23,      24, 
        25,      26,      27,      -1, 
        28,      29,      30,      31, 
        32,      33,      34,      35, 
        36,      37,      38,      39, 
        40,      41,      42,      43, 
        44,      45,      46,      47, 
        48,      49,      50};
#line 220 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int leap_thursday_incomplete[55]  = 
#line 220
  {      52,      -1,      -1,      0, 
        1,      2,      3,      4, 
        5,      6,      7,      8, 
        9,      10,      11,      12, 
        13,      14,      15,      16, 
        17,      18,      19,      20, 
        21,      22,      23,      24, 
        25,      26,      27,      28, 
        -1,      29,      30,      31, 
        32,      33,      34,      35, 
        36,      37,      38,      39, 
        40,      41,      42,      43, 
        44,      45,      46,      47, 
        48,      49,      50};
#line 227 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int leap_thursday_complete[55]  = 
#line 227
  {      52,      -1,      -1,      0, 
        1,      2,      3,      4, 
        5,      6,      7,      8, 
        9,      10,      11,      12, 
        13,      14,      15,      16, 
        17,      18,      19,      20, 
        21,      22,      23,      24, 
        25,      26,      27,      28, 
        -1,      29,      30,      31, 
        32,      33,      34,      35, 
        36,      37,      38,      39, 
        40,      41,      42,      43, 
        44,      45,      46,      47, 
        48,      49,      -50};
#line 234 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int leap_saturday_incomplete[55]  = 
#line 234
  {      -1,      52,      -1,      -1, 
        0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      9,      10,      11, 
        12,      13,      14,      15, 
        16,      17,      18,      19, 
        20,      21,      22,      23, 
        24,      25,      26,      27, 
        -1,      28,      29,      30, 
        31,      32,      33,      34, 
        35,      36,      37,      38, 
        39,      40,      -41,      43, 
        44,      45,      46,      47, 
        48,      49,      -50};
#line 242 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int leap_saturday_complete_diaspora[55]  = 
#line 242
  {      -1,      52,      -1,      -1, 
        0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      9,      10,      11, 
        12,      13,      14,      15, 
        16,      17,      18,      19, 
        20,      21,      22,      23, 
        24,      25,      26,      27, 
        -1,      28,      29,      30, 
        31,      32,      33,      -1, 
        34,      35,      36,      37, 
        -38,      40,      -41,      43, 
        44,      45,      46,      47, 
        48,      49,      -50};
#line 259 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
int *sedra_years_array[2][4][3][2]  = { { { {            nonleap_monday_incomplete,            nonleap_monday_incomplete}, 
       {            (int *)((void *)0),            (int *)((void *)0)}, 
       {            nonleap_monday_complete_diaspora,            nonleap_monday_incomplete}}, 
     { {            (int *)((void *)0),            (int *)((void *)0)}, 
       {            nonleap_monday_complete_diaspora,            nonleap_monday_incomplete}, 
       {            (int *)((void *)0),            (int *)((void *)0)}}, 
     { {            (int *)((void *)0),            (int *)((void *)0)}, 
       {            nonleap_thursday_regular_diaspora,            nonleap_thursday_regular_israel}, 
       {            nonleap_thursday_complete,            nonleap_thursday_complete}}, 
     { {            nonleap_saturday_incomplete,            nonleap_saturday_incomplete}, 
       {            (int *)((void *)0),            (int *)((void *)0)}, 
       {            nonleap_saturday_complete,            nonleap_saturday_complete}}}, 
   { { {            leap_monday_incomplete_diaspora,            leap_monday_incomplete_israel}, 
       {            (int *)((void *)0),            (int *)((void *)0)}, 
       {            leap_monday_complete_diaspora,            leap_monday_complete_israel}}, 
     { {            (int *)((void *)0),            (int *)((void *)0)}, 
       {            leap_monday_complete_diaspora,            leap_monday_complete_israel}, 
       {            (int *)((void *)0),            (int *)((void *)0)}}, 
     { {            leap_thursday_incomplete,            leap_thursday_incomplete}, 
       {            (int *)((void *)0),            (int *)((void *)0)}, 
       {            leap_thursday_complete,            leap_thursday_complete}}, 
     { {            leap_saturday_incomplete,            leap_saturday_incomplete}, 
       {            (int *)((void *)0),            (int *)((void *)0)}, 
       {            leap_saturday_complete_diaspora,            leap_saturday_incomplete}}}};
#line 395 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
static int *theSedraArray  ;
#line 396 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
static long first_saturday  ;
#line 399 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
void reset_sedra(int hebYr ) 
{ 
  date_t tempDt ;
  int long_c ;
  int short_k ;
  int rosh_hashana_day ;
  int type ;
  long rosh_hashana ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 405
  long_c = long_cheshvan(hebYr);
#line 406
  short_k = short_kislev(hebYr);
  }
#line 408
  if (long_c) {
#line 408
    if (! short_k) {
#line 409
      type = 2;
    } else {
#line 408
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 410
  if (! long_c) {
#line 410
    if (short_k) {
#line 411
      type = 0;
    } else {
#line 413
      type = 1;
    }
  } else {
#line 413
    type = 1;
  }
  {
#line 415
  tempDt.dd = 1;
#line 416
  tempDt.mm = 7;
#line 417
  tempDt.yy = hebYr;
#line 418
  rosh_hashana = hebrew2abs(tempDt);
#line 419
  rosh_hashana_day = (int )(rosh_hashana % 7L);
#line 422
  first_saturday = day_on_or_before(6, rosh_hashana + 6L);
  }
#line 424
  if ((1L + (long )hebYr * 7L) % 19L < 7L) {
#line 424
    tmp = 1;
  } else {
#line 424
    tmp = 0;
  }
#line 424
  if (rosh_hashana_day == 1) {
#line 424
    tmp___0 = 0;
  } else {
#line 424
    tmp___0 = rosh_hashana_day / 2;
  }
#line 424
  theSedraArray = sedra_years_array[tmp][tmp___0][type][israel_sw];
#line 424
  if ((unsigned long )((void *)0) == (unsigned long )theSedraArray) {
    {
#line 429
    die("improper sedra year type calculated.", "");
    }
  }
#line 431
  return;
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
static char buf[40]  ;
#line 436 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/sedra.c"
char *sedra(long absDate ) 
{ 
  int index___0 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int i ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 443
  absDate = day_on_or_before(6, absDate + 6L);
#line 445
  index___0 = *(theSedraArray + (absDate - first_saturday) / 7L);
#line 447
  buf[0] = (char )'\000';
  }
#line 449
  if (index___0 >= 0) {
#line 450
    if (iso8859_8_sw) {
#line 450
      if (sedrot[index___0][2]) {
#line 450
        tmp___0 = sedrot[index___0][2];
      } else {
#line 450
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 450
      if (ashkenazis_sw) {
#line 450
        if (sedrot[index___0][1]) {
#line 450
          tmp = sedrot[index___0][1];
        } else {
#line 450
          tmp = sedrot[index___0][0];
        }
      } else {
#line 450
        tmp = sedrot[index___0][0];
      }
#line 450
      tmp___0 = tmp;
    }
    {
#line 450
    strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___0,
            (size_t )40);
    }
  } else
#line 451
  if (-1 == index___0) {
#line 452
    return ((char *)((void *)0));
  } else {
#line 455
    i = - index___0;
#line 456
    if (iso8859_8_sw) {
#line 456
      if (sedrot[i + 1][2]) {
#line 456
        tmp___2 = sedrot[i + 1][2];
      } else {
#line 456
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 456
      if (ashkenazis_sw) {
#line 456
        if (sedrot[i + 1][1]) {
#line 456
          tmp___1 = sedrot[i + 1][1];
        } else {
#line 456
          tmp___1 = sedrot[i + 1][0];
        }
      } else {
#line 456
        tmp___1 = sedrot[i + 1][0];
      }
#line 456
      tmp___2 = tmp___1;
    }
#line 456
    if (iso8859_8_sw) {
#line 456
      if (sedrot[i][2]) {
#line 456
        tmp___4 = sedrot[i][2];
      } else {
#line 456
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 456
      if (ashkenazis_sw) {
#line 456
        if (sedrot[i][1]) {
#line 456
          tmp___3 = sedrot[i][1];
        } else {
#line 456
          tmp___3 = sedrot[i][0];
        }
      } else {
#line 456
        tmp___3 = sedrot[i][0];
      }
#line 456
      tmp___4 = tmp___3;
    }
    {
#line 456
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s-%s",
            tmp___4, tmp___2);
    }
  }
#line 460
  return (buf);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/myerror.h"
void warn(char const   *s1 , char const   *s2 ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/error.c"
char *progname ;
#line 36 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/error.c"
void die(char const   *s1 , char const   *s2 ) 
{ 
  int *tmp ;

  {
  {
#line 38
  tmp = __errno_location();
  }
#line 38
  if (*tmp) {
    {
#line 39
    perror((char const   *)progname);
    }
  } else {
    {
#line 41
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            progname);
    }
  }
  {
#line 42
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)s1, s2);
#line 43
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 44
  exit(1);
  }
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/error.c"
void warn(char const   *s1 , char const   *s2 ) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 50
  tmp = __errno_location();
  }
#line 50
  if (*tmp) {
    {
#line 51
    perror((char const   *)progname);
    }
  } else {
    {
#line 53
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            progname);
    }
  }
  {
#line 54
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)s1, s2);
#line 55
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 56
  tmp___0 = __errno_location();
#line 56
  *tmp___0 = 0;
  }
#line 57
  return;
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.h"
char const   *eMonths[13] ;
#line 32
int MonthLengths[2][13] ;
#line 42
int dayOfYear(date_t d ) ;
#line 44
date_t abs2greg(long theDate ) ;
#line 46
void incDate(date_t *dt , long n ) ;
#line 48
void setDate(date_t *d ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.c"
char const   *eMonths[13]  = 
#line 41 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.c"
  {      "UNUSED",      "January",      "February",      "March", 
        "April",      "May",      "June",      "July", 
        "August",      "September",      "October",      "November", 
        "December"};
#line 48 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.c"
int MonthLengths[2][13]  = { {        0,        31,        28,        31, 
            30,        31,        30,        31, 
            31,        30,        31,        30, 
            31}, 
   {        0,        31,        29,        31, 
            30,        31,        30,        31, 
            31,        30,        31,        30, 
            31}};
#line 54 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.c"
char const   *ShortDayNames[7]  = {      "Sun",      "Mon",      "Tue",      "Wed", 
        "Thu",      "Fri",      "Sat"};
#line 67 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.c"
int dayOfYear(date_t d ) 
{ 
  int dOY ;

  {
#line 69
  dOY = d.dd + 31 * (d.mm - 1);
#line 70
  if (d.mm > 2) {
#line 72
    dOY -= (4 * d.mm + 23) / 10;
#line 73
    if (! (d.yy % 4)) {
#line 73
      if (d.yy % 100) {
#line 74
        dOY ++;
      } else
#line 73
      if (! (d.yy % 400)) {
#line 74
        dOY ++;
      }
    }
  }
#line 76
  return (dOY);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.c"
long greg2abs(date_t d ) 
{ 
  int tmp ;

  {
  {
#line 86
  tmp = dayOfYear(d);
  }
#line 86
  return (((long )tmp + 365L * (long )(d.yy - 1)) + (long )(((d.yy - 1) / 4 - (d.yy - 1) / 100) + (d.yy - 1) / 400));
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.c"
date_t abs2greg(long theDate ) 
{ 
  int day ;
  int year ;
  int month ;
  int mlen ;
  date_t d ;
  long d0 ;
  long n400 ;
  long d1 ;
  long n100 ;
  long d2 ;
  long n4 ;
  long d3 ;
  long n1 ;
  int tmp ;

  {
#line 105
  d0 = theDate - 1L;
#line 106
  n400 = d0 / 146097L;
#line 107
  d1 = d0 % 146097L;
#line 108
  n100 = d1 / 36524L;
#line 109
  d2 = d1 % 36524L;
#line 110
  n4 = d2 / 1461L;
#line 111
  d3 = d2 % 1461L;
#line 112
  n1 = d3 / 365L;
#line 114
  day = (int )(d3 % 365L + 1L);
#line 115
  year = (int )(((400L * n400 + 100L * n100) + 4L * n4) + n1);
#line 117
  if (4L == n100) {
#line 119
    d.mm = 12;
#line 120
    d.dd = 31;
#line 121
    d.yy = year;
#line 122
    return (d);
  } else
#line 117
  if (4L == n1) {
#line 119
    d.mm = 12;
#line 120
    d.dd = 31;
#line 121
    d.yy = year;
#line 122
    return (d);
  } else {
#line 126
    year ++;
#line 127
    month = 1;
    {
#line 128
    while (1) {
      while_continue: /* CIL Label */ ;
#line 128
      if (! (year % 4)) {
#line 128
        if (year % 100) {
#line 128
          tmp = 1;
        } else
#line 128
        if (! (year % 400)) {
#line 128
          tmp = 1;
        } else {
#line 128
          tmp = 0;
        }
      } else {
#line 128
        tmp = 0;
      }
#line 128
      mlen = MonthLengths[tmp][month];
#line 128
      if (! (mlen < day)) {
#line 128
        goto while_break;
      }
#line 130
      day -= mlen;
#line 131
      month ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 133
    d.yy = year;
#line 134
    d.mm = month;
#line 135
    d.dd = day;
#line 136
    return (d);
  }
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.c"
void incDate(date_t *dt , long n ) 
{ 
  long tmp ;

  {
  {
#line 142
  tmp = greg2abs(*dt);
#line 142
  *dt = abs2greg(tmp + n);
  }
#line 143
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.c"
int dayOfWeek(date_t d1 ) 
{ 
  long tmp ;

  {
  {
#line 148
  tmp = greg2abs(d1);
  }
#line 148
  return ((int )(tmp % 7L));
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.c"
void setDate(date_t *d ) 
{ 
  time_t secs ;
  time_t tmp ;
  char *timestr ;
  char *tmp___0 ;

  {
  {
#line 166
  tmp = time((time_t *)((void *)0));
#line 166
  secs = tmp;
#line 167
  tmp___0 = ctime((time_t const   *)(& secs));
#line 167
  timestr = tmp___0;
#line 172
  sscanf((char const   */* __restrict  */)(timestr + 20), (char const   */* __restrict  */)"%d",
         & d->yy);
#line 173
  d->mm = lookup_string((char const   *)(timestr + 4), eMonths, 13, 3);
#line 174
  sscanf((char const   */* __restrict  */)(timestr + 8), (char const   */* __restrict  */)"%d",
         & d->dd);
  }
#line 175
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/greg.c"
long day_on_or_before(int day_of_week , long date ) 
{ 


  {
#line 190
  return (date - (date - (long )day_of_week) % 7L);
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/mygetopt.c"
int Opterr  =    1;
#line 18 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/mygetopt.c"
int Optind  =    1;
#line 19 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/mygetopt.c"
int Optopt  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/mygetopt.c"
char *Optarg  ;
#line 31
int Getopt(int argc , char **argv , char *mopts , int reset ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/mygetopt.c"
static int sp  =    1;
#line 24 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/mygetopt.c"
int Getopt(int argc , char **argv , char *mopts , int reset ) 
{ 
  register char *cp ;
  int tmp ;
  char errbuf[3] ;
  int tmp___0 ;
  char errbuf___0[3] ;
  int tmp___1 ;

  {
#line 34
  if (reset) {
#line 36
    sp = 1;
#line 37
    Opterr = 1;
#line 38
    Optind = 1;
#line 39
    Optopt = 0;
#line 40
    Optarg = (char *)((void *)0);
#line 41
    return (0);
  }
#line 44
  if (sp == 1) {
#line 47
    if (Optind >= argc) {
#line 49
      return (-1);
    } else
#line 47
    if ((int )*(*(argv + Optind) + 0) != 45) {
#line 49
      return (-1);
    } else
#line 47
    if ((int )*(*(argv + Optind) + 1) == 0) {
#line 49
      return (-1);
    } else {
      {
#line 50
      tmp = strcmp((char const   *)*(argv + Optind), "--");
      }
#line 50
      if (tmp == 0) {
#line 52
        Optind ++;
#line 53
        return (-1);
      }
    }
  }
#line 56
  Optopt = (int )*(*(argv + Optind) + sp);
#line 57
  if (Optopt == 58) {
#line 57
    goto _L;
  } else {
    {
#line 57
    cp = strchr((char const   *)mopts, Optopt);
    }
#line 57
    if ((unsigned long )cp == (unsigned long )((char *)0)) {
      _L: /* CIL Label */ 
#line 59
      if (Opterr) {
        {
#line 59
        errbuf[0] = (char )Optopt;
#line 59
        errbuf[1] = (char )'\n';
#line 59
        errbuf[2] = (char )'\000';
#line 59
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                *(argv + 0));
#line 59
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                ": illegal option -- ");
#line 59
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                errbuf);
        }
      }
#line 61
      sp ++;
#line 61
      if ((int )*(*(argv + Optind) + sp) == 0) {
#line 63
        Optind ++;
#line 64
        sp = 1;
      }
#line 66
      return ('?');
    }
  }
#line 69
  cp ++;
#line 69
  if ((int )*cp == 58) {
#line 71
    if ((int )*(*(argv + Optind) + (sp + 1)) != 0) {
#line 73
      tmp___0 = Optind;
#line 73
      Optind ++;
#line 73
      Optarg = *(argv + tmp___0) + (sp + 1);
    } else {
#line 74
      Optind ++;
#line 74
      if (Optind >= argc) {
#line 76
        if (Opterr) {
          {
#line 76
          errbuf___0[0] = (char )Optopt;
#line 76
          errbuf___0[1] = (char )'\n';
#line 76
          errbuf___0[2] = (char )'\000';
#line 76
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                  *(argv + 0));
#line 76
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                  ": option requires an argument -- ");
#line 76
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                  errbuf___0);
          }
        }
#line 77
        sp = 1;
#line 78
        return ('?');
      } else {
#line 82
        tmp___1 = Optind;
#line 82
        Optind ++;
#line 82
        Optarg = *(argv + tmp___1);
      }
    }
#line 83
    sp = 1;
  } else {
#line 88
    sp ++;
#line 88
    if ((int )*(*(argv + Optind) + sp) == 0) {
#line 91
      sp = 1;
#line 92
      Optind ++;
    }
#line 94
    Optarg = (char *)0;
  }
#line 96
  return (Optopt);
}
}
#line 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) acos)(double __x ) ;
#line 58
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan)(double __x ) ;
#line 63
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 67
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) tan)(double __x ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 181
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/rise.h"
int suntime(double *sunrise , double *sunset , int day , int rise_opt , int set_opt ) ;
#line 25
int one_time(int day , double *tval , double lo_hr , int is_rise , double cos_z ,
             double cos_phi , double sin_phi ) ;
#line 26
char *timeadj(char *prefixStr , double tval , int minadj , int *dayadj ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/rise.c"
int latdeg  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/rise.c"
int latmin  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/rise.c"
int longdeg  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/rise.c"
int longmin  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/rise.c"
int TZ  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/rise.c"
int myclock  =    1;
#line 116 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/rise.c"
int suntime(double *sunrise , double *sunset , int day , int rise_opt , int set_opt ) 
{ 
  double lo_hr ;
  double lambda ;
  double phi ;
  double cos_phi ;
  double sin_phi ;
  double cos_z ;
  int retval ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 121
  retval = 0;
  {
#line 125
  if (set_opt == 0) {
#line 125
    goto case_0;
  }
#line 128
  if (set_opt == 1) {
#line 128
    goto case_1;
  }
#line 131
  if (set_opt == 2) {
#line 131
    goto case_2;
  }
#line 134
  if (set_opt == 3) {
#line 134
    goto case_3;
  }
#line 137
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 126
  cos_z = cos((3.14159265358979323846 / 180.0) * ((double )90 + (double )50 / 60.0));
  }
#line 127
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 129
  cos_z = cos((3.14159265358979323846 / 180.0) * ((double )96 + (double )0 / 60.0));
  }
#line 130
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 132
  cos_z = cos((3.14159265358979323846 / 180.0) * ((double )102 + (double )0 / 60.0));
  }
#line 133
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 135
  cos_z = cos((3.14159265358979323846 / 180.0) * ((double )106 + (double )0 / 60.0));
  }
#line 136
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 138
  tmp = hc_itoa(set_opt);
#line 138
  die("bad set_opt argument to suntime: %d", (char const   *)tmp);
#line 140
  cos_z = 0.0 / 0.0;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 145
  lambda = (double )longdeg + (double )longmin / 60.0;
#line 146
  lo_hr = lambda / 15.0;
#line 147
  phi = (double )latdeg + (double )latmin / 60.0;
#line 148
  cos_phi = cos((3.14159265358979323846 / 180.0) * phi);
#line 149
  sin_phi = sin((3.14159265358979323846 / 180.0) * phi);
#line 151
  tmp___0 = one_time(day, sunset, lo_hr, 0, cos_z, cos_phi, sin_phi);
  }
#line 151
  if (! tmp___0) {
#line 152
    retval |= 1;
  }
  {
#line 157
  if (rise_opt == 4) {
#line 157
    goto case_4;
  }
#line 160
  if (rise_opt == 5) {
#line 160
    goto case_5;
  }
#line 163
  if (rise_opt == 6) {
#line 163
    goto case_6;
  }
#line 166
  if (rise_opt == 7) {
#line 166
    goto case_7;
  }
#line 169
  goto switch_default___0;
  case_4: /* CIL Label */ 
  {
#line 158
  cos_z = cos((3.14159265358979323846 / 180.0) * ((double )90 + (double )50 / 60.0));
  }
#line 159
  goto switch_break___0;
  case_5: /* CIL Label */ 
  {
#line 161
  cos_z = cos((3.14159265358979323846 / 180.0) * ((double )106 + (double )6 / 60.0));
  }
#line 162
  goto switch_break___0;
  case_6: /* CIL Label */ 
  {
#line 164
  cos_z = cos((3.14159265358979323846 / 180.0) * ((double )101 + (double )0 / 60.0));
  }
#line 165
  goto switch_break___0;
  case_7: /* CIL Label */ 
  {
#line 167
  cos_z = cos((3.14159265358979323846 / 180.0) * ((double )100 + (double )12 / 60.0));
  }
#line 168
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 170
  tmp___1 = hc_itoa(rise_opt);
#line 170
  die("bad rise_opt to suntime: %d", (char const   *)tmp___1);
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 173
  tmp___2 = one_time(day, sunrise, lo_hr, 1, cos_z, cos_phi, sin_phi);
  }
#line 173
  if (! tmp___2) {
#line 174
    retval |= 2;
  }
#line 176
  return (retval);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/rise.c"
int one_time(int day , double *tval , double lo_hr , int is_rise , double cos_z ,
             double cos_phi , double sin_phi ) 
{ 
  double t ;
  double xm ;
  double xl ;
  double a ;
  double a_hr ;
  double sin_del ;
  double cos_del ;
  double h ;
  double h_hr ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;

  {
#line 191
  t = (double )day;
#line 192
  if (is_rise) {
#line 193
    t += (18.0 + lo_hr) / 24.0;
  } else {
#line 195
    t += (6.0 + lo_hr) / 24.0;
  }
  {
#line 197
  xm = 0.985600 * t - 3.251;
#line 198
  tmp = sin((3.14159265358979323846 / 180.0) * xm);
#line 198
  tmp___0 = sin(((double )2 * (3.14159265358979323846 / 180.0)) * xm);
#line 198
  xl = ((xm + 1.916 * tmp) + 0.020 * tmp___0) + 282.565;
#line 199
  tmp___1 = tan((3.14159265358979323846 / 180.0) * xl);
#line 199
  tmp___2 = atan(0.91746 * tmp___1);
#line 199
  a = (180.0 / 3.14159265358979323846) * tmp___2;
#line 201
  tmp___3 = fabs((a + 360.0) - xl);
  }
#line 201
  if (tmp___3 > 90.0) {
#line 202
    a += 180.0;
  }
#line 203
  if (a > 360.0) {
#line 204
    a -= 360.0;
  }
  {
#line 206
  a_hr = a / 15.0;
#line 207
  tmp___4 = sin((3.14159265358979323846 / 180.0) * xl);
#line 207
  sin_del = 0.39782 * tmp___4;
#line 208
  cos_del = sqrt(1.0 - sin_del * sin_del);
#line 209
  h = (cos_z - sin_del * sin_phi) / (cos_del * cos_phi);
#line 211
  tmp___5 = fabs(h);
  }
#line 211
  if (tmp___5 > 1.0) {
#line 212
    return (0);
  }
  {
#line 214
  tmp___6 = acos(h);
#line 214
  h = (180.0 / 3.14159265358979323846) * tmp___6;
  }
#line 216
  if (is_rise) {
#line 217
    h = 360.0 - h;
  }
#line 218
  h_hr = h / 15.0;
#line 219
  *tval = (((h_hr + a_hr) + (- 0.065710 * t - 6.620)) + lo_hr) + (double )TZ;
#line 221
  return (1);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/rise.c"
char *timeadj(char *prefixStr , double tval , int minadj , int *dayadj ) 
{ 
  char *str ;
  int hour ;
  int min ;
  size_t num ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 235
  tmp = strlen((char const   *)prefixStr);
#line 235
  num = tmp + 9UL;
#line 237
  *dayadj = 0;
#line 238
  tval += (double )minadj / 60.0;
  }
#line 239
  if (tval < 0.0) {
#line 241
    tval += 24.0;
#line 242
    (*dayadj) --;
  }
#line 244
  hour = (int )tval;
#line 245
  min = (int )((tval - (double )hour) * 60.0 + 0.5);
#line 246
  if (min >= 60) {
#line 248
    hour ++;
#line 249
    min -= 60;
  }
#line 251
  if (hour > 24) {
#line 253
    hour -= 24;
#line 254
    (*dayadj) ++;
  }
#line 256
  if (myclock == 1) {
#line 257
    if (hour > 12) {
#line 258
      hour -= 12;
    }
  }
  {
#line 260
  tmp___0 = calloc((size_t )((unsigned int )num), sizeof(char ));
#line 260
  str = (char *)tmp___0;
#line 261
  sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%s%2d:%02d",
          prefixStr, hour, min);
  }
#line 262
  return (str);
}
}
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 695
extern int puts(char const   *__s ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
FILE *inFile ;
#line 45
FILE *yFile ;
#line 47
int DST_scheme ;
#line 47
int candleLighting_sw ;
#line 47
int euroDates_sw ;
#line 47
int hebrewDates_sw ;
#line 47
int inputFile_sw ;
#line 47
int printOmer_sw ;
#line 47
int printHebDates_sw ;
#line 47
int printSomeHebDates_sw ;
#line 47
int sedraAllWeek_sw ;
#line 47
int sedrot_sw ;
#line 47
int noGreg_sw ;
#line 47
int noHolidays_sw ;
#line 47
int suppress_rosh_chodesh_sw ;
#line 47
int tabs_sw ;
#line 47
int weekday_sw ;
#line 47
int yearDigits_sw ;
#line 47
int yahrtzeitFile_sw ;
#line 70
int havdalah_minutes ;
#line 70
int light_offset ;
#line 113
void init_holidays(int hYear ) ;
#line 117
void main_calendar(long todayAbs , long endAbs ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.h"
hmonth_t hMonths[2][15] ;
#line 42
date_t abs2hebrew(long d ) ;
#line 47
int max_days_in_heb_month(int month , int year ) ;
#line 48
int lookup_hebrew_month(char const   *s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/cities.h"
city_t cities[53]  = 
#line 8 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/cities.h"
  {      {(char *)"Ashdod", 31, 48, -34, -38, 2, 2}, 
        {(char *)"Atlanta", 33, 45, 84, 23, -5, 0}, 
        {(char *)"Austin", 30, 16, 97, 45, -6, 0}, 
        {(char *)"Baghdad", 33, 14, -44, -22, 3, 3}, 
        {(char *)"Beer Sheva", 31, 15, -34, -47, 2, 2}, 
        {(char *)"Berlin", 52, 31, -13, -24, 1, 3}, 
        {(char *)"Baltimore", 39, 17, 76, 36, -5, 0}, 
        {(char *)"Bogota", 4, 36, 74, 5, -5, 1}, 
        {(char *)"Boston", 42, 20, 71, 4, -5, 0}, 
        {(char *)"Buenos Aires", -34, -37, 58, 24, -3, 1}, 
        {(char *)"Buffalo", 42, 53, 78, 52, -5, 0}, 
        {(char *)"Chicago", 41, 50, 87, 45, -6, 0}, 
        {(char *)"Cincinnati", 39, 6, 84, 31, -5, 0}, 
        {(char *)"Cleveland", 41, 30, 81, 41, -5, 0}, 
        {(char *)"Dallas", 32, 47, 96, 48, -6, 0}, 
        {(char *)"Denver", 39, 44, 104, 59, -7, 0}, 
        {(char *)"Detroit", 42, 20, 83, 2, -5, 0}, 
        {(char *)"Eilat", 29, 33, -34, -57, 2, 2}, 
        {(char *)"Gibraltar", 36, 0, 5, 0, -10, 0}, 
        {(char *)"Haifa", 32, 49, -34, -59, 2, 2}, 
        {(char *)"Hawaii", 19, 30, 155, 30, -10, 1}, 
        {(char *)"Houston", 29, 46, 95, 22, -6, 0}, 
        {(char *)"Jerusalem", 31, 47, -35, -14, 2, 2}, 
        {(char *)"Johannesburg", -26, -10, -28, -2, 2, 1}, 
        {(char *)"Kiev", 50, 28, -30, -29, 2, 3}, 
        {(char *)"La Paz", -16, -30, 68, 9, -4, 1}, 
        {(char *)"London", 51, 30, 0, 10, 0, 3}, 
        {(char *)"Los Angeles", 34, 4, 118, 15, -8, 0}, 
        {(char *)"Miami", 25, 46, 80, 12, -5, 0}, 
        {(char *)"Melbourne", -37, -52, -145, -8, 10, 4}, 
        {(char *)"Mexico City", 19, 24, 99, 9, -6, 0}, 
        {(char *)"Montreal", 45, 30, 73, 36, -5, 0}, 
        {(char *)"Moscow", 55, 45, -37, -42, 3, 3}, 
        {(char *)"New York", 40, 43, 74, 1, -5, 0}, 
        {(char *)"Omaha", 41, 16, 95, 56, -7, 0}, 
        {(char *)"Ottawa", 45, 42, 75, 71, -5, 0}, 
        {(char *)"Paris", 48, 52, -2, -20, 1, 3}, 
        {(char *)"Petach Tikvah", 32, 5, -34, -53, 2, 2}, 
        {(char *)"Philadelphia", 39, 57, 75, 10, -5, 0}, 
        {(char *)"Phoenix", 33, 27, 112, 4, -7, 1}, 
        {(char *)"Pittsburgh", 40, 26, 80, 0, -5, 0}, 
        {(char *)"Saint Louis", 38, 38, 90, 12, -6, 0}, 
        {(char *)"Saint Petersburg", 59, 53, -30, -15, 3, 3}, 
        {(char *)"San Francisco", 37, 47, 122, 25, -8, 0}, 
        {(char *)"Seattle", 47, 36, 122, 20, -8, 0}, 
        {(char *)"Sydney", -33, -55, -151, -17, 10, 4}, 
        {(char *)"Tel Aviv", 32, 5, -34, -46, 2, 2}, 
        {(char *)"Tiberias", 32, 58, -35, -32, 2, 2}, 
        {(char *)"Toronto", 43, 38, 79, 24, -5, 0}, 
        {(char *)"Vancouver", 49, 16, 123, 7, -8, 0}, 
        {(char *)"White Plains", 41, 2, 73, 45, -5, 0}, 
        {(char *)"Washington DC", 38, 55, 77, 0, -5, 0}, 
        {(char *)0, 0, 0, 0, 0, 0, 0}};
#line 43 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
void handleArgs(int argc , char **argv ) ;
#line 44
int main(int argc , char **argv ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
int ok_to_run  =    1;
#line 52 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
char *progname  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
static int theYear  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
static int theMonth  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
static int theDay  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
static int yearDirty  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
static int rangeType  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
static int zonep  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
static int schemep  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
static int latp  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
static int longp  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
static char *cityName  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
static char *helpArray[94]  = 
#line 55
  {      (char *)"Hebcal Version 3.5 By Danny Sadinoff",      (char *)"usage: hebcal [-8acdDeHhiorsStTwy]",      (char *)"            [-I file]",      (char *)"            [-Y yahrtzeit_file]", 
        (char *)"            [-C city]",      (char *)"            [-L longitude -l latitude]",      (char *)"            [-m havdalah_minutes_past_sundown ]",      (char *)"            [-z timezone]", 
        (char *)"            [-Z daylight_savings_option]",      (char *)"            [-f format_option]",      (char *)"            [[ month [ day ]] year ]",      (char *)"       hebcal help", 
        (char *)"       hebcal info",      (char *)"       hebcal DST",      (char *)"       hebcal cities",      (char *)"       hebcal warranty", 
        (char *)"       hebcal copying",      (char *)"OPTIONS:",      (char *)"   -8 : Use 8-bit Hebrew (ISO-8859-8-Logical).",      (char *)"   -a : Use ashkenazis hebrew.", 
        (char *)"   -c : Print candlelighting times.",      (char *)"   -C city : Set latitude, longitude, timezone and daylight",      (char *)"             savings scheme according to specified city. ",      (char *)"             This option implies the -c option.", 
        (char *)"   -d : print the hebrew date for the entire date range.",      (char *)"   -D : print the hebrew date for dates with some event.",      (char *)"   -e : Ouput \"european\" dates -- DD.MM.YYYY format.",      (char *)"   -h : Suppress default holidays.", 
        (char *)"   -H : Use Hebrew date ranges - only needed when e.g. hebcal -H 5373",      (char *)"   -i : Use Israeli sedra scheme.",      (char *)"   -f FORMAT : change output to FORMAT. see below for format strings",      (char *)"   -I file : Get non-yahrtzeit Hebrew user events from specified file.", 
        (char *)"        The format is : mmm dd string, Where mmm is a Hebrew month name.",      (char *)"   -l xx,yy : Set the latitude for solar calculations to",      (char *)"              xx degrees and yy minutes.  Negative values are south.",      (char *)"   -L xx,yy : Set the longitude for solar calculations to", 
        (char *)"              xx degrees and yy minutes.  *Negative values are EAST*.",      (char *)"        The -l and -L switches must both be used, or not at all.",      (char *)"        These switches override the -C (localize to city) switch.",      (char *)"   -m mins : Set havdalah to occur this many minutes after sundown ", 
        (char *)"   -o : Add days of the omer.",      (char *)"   -r : Tab delineated format.",      (char *)"   -s : Add weekly sedrot on saturday.",      (char *)"   -S : Print sedrah of the week on all calendar days.", 
        (char *)"   -t : Only output for today\'s date.",      (char *)"   -T : Print today\'s pertinent information, no gregorian date.",      (char *)"   -w : Add day of the week.",      (char *)"   -x : Suppress Rosh Chodesh.", 
        (char *)"   -y : Print only last two digits of year.",      (char *)"   -Y file : Get yahrtzeit dates from specified file.",      (char *)"             The format is: mm dd yyyy string",      (char *)"             the first three fields specify a *Gregorian* date.", 
        (char *)"   -z : Use specified timezone, disabling daylight savings time,",      (char *)"        overriding the -C (localize to city) switch.",      (char *)"   -Z scheme : change to daylight savings scheme.  The possible values",      (char *)"        of scheme are currently usa, israel, eu, and none.", 
        (char *)"",      (char *)"hebcal help    -- Print this message.",      (char *)"hebcal info    -- Print version and localization data.",      (char *)"hebcal DST     -- Print a list of available daylight savings schemes.", 
        (char *)"hebcal cities  -- Print a list of available cities.",      (char *)"hebcal warranty -- Tells you how there\'s NO WARRANTY for hebcal.",      (char *)"hebcal copying -- Prints the details of the GNU copyright.",      (char *)"", 
        (char *)"Hebcal prints out hebrew calendars one solar year at a time.",      (char *)"Given one argument, it will print out the calendar for that year.",      (char *)"Given two numeric arguments mm yyyy, it prints out the calendar for ",      (char *)"month mm of year yyyy.", 
        (char *)"",      (char *)"For example, ",      (char *)"   hebcal -ho",      (char *)"will just print out the days of the omer for the current year.", 
        (char *)"Note: Use COMPLETE Years.  You probably aren\'t interested in ",      (char *)"hebcal 93, but rather hebcal 1993.",      (char *)"",      (char *)"", 
        (char *)"Hebcal is copyright (c) 1994-2004 By Danny Sadinoff",      (char *)"Portions Copyright (c) 2002 Michael J. Radwin. All rights reserved.",      (char *)"",      (char *)"This program is free software; you can redistribute it and/or", 
        (char *)"modify it under the terms of the GNU General Public License",      (char *)"as published by the Free Software Foundation; either version 2",      (char *)"of the License, or (at your option) any later version.",      (char *)"Type \"hebcal copying\" for more details.", 
        (char *)"",      (char *)"Hebcal is distributed in the hope that it will be useful,",      (char *)"but WITHOUT ANY WARRANTY; without even the implied warranty of",      (char *)"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  ", 
        (char *)"Type \"hebcal warranty\" for more details.",      (char *)"  ",      (char *)"\"Free\" above means freely distributed.  To donate money to support hebcal,",      (char *)" see the paypal link at http://www.sadinoff.com/hebcal/ ", 
        (char *)"WWW:",      (char *)"            http://sourceforge.net/projects/hebcal"};
#line 161 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
dst_t savings_bank[6]  = {      {(char *)"usa", 0}, 
        {(char *)"none", 1}, 
        {(char *)"israel", 2}, 
        {(char *)"eu", 3}, 
        {(char *)"aunz", 4}, 
        {(char *)"", 0}};
#line 173 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
void print_version_data(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 175
  printf((char const   */* __restrict  */)"hebcal version 3.5\n");
#line 176
  printf((char const   */* __restrict  */)"=====Defaults=====\n");
#line 177
  printf((char const   */* __restrict  */)"City: %s\n", cityName);
  }
#line 178
  if (latdeg < 0) {
#line 178
    tmp = 'S';
  } else {
#line 178
    tmp = 'N';
  }
  {
#line 178
  tmp___0 = abs(latmin);
#line 178
  tmp___1 = abs(latdeg);
#line 178
  printf((char const   */* __restrict  */)"          %dd%d\' %c latitude\n", tmp___1,
         tmp___0, tmp);
  }
#line 180
  if (longdeg > 0) {
#line 180
    tmp___2 = 'W';
  } else {
#line 180
    tmp___2 = 'E';
  }
  {
#line 180
  tmp___3 = abs(longmin);
#line 180
  tmp___4 = abs(longdeg);
#line 180
  printf((char const   */* __restrict  */)"          %dd%d\' %c longitude\n", tmp___4,
         tmp___3, tmp___2);
  }
#line 182
  if (TZ < 0) {
#line 182
    tmp___5 = "";
  } else {
#line 182
    tmp___5 = "+";
  }
  {
#line 182
  printf((char const   */* __restrict  */)"          GMT %s%d:00\n", tmp___5, TZ);
#line 184
  printf((char const   */* __restrict  */)"\nEnvironment variable for default city: %s\n",
         "HEBCAL_CITY");
#line 185
  printf((char const   */* __restrict  */)"\nEnvironment variable for default options: %s\n",
         "HEBCAL_OPTS");
  }
#line 186
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
void print_warranty(void) 
{ 
  int cnum ;

  {
#line 192
  cnum = 0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! warranty[cnum]) {
#line 192
      goto while_break;
    }
    {
#line 196
    puts(warranty[cnum]);
#line 192
    cnum ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
void print_copying(void) 
{ 
  int cnum ;

  {
#line 205
  cnum = 0;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! license[cnum]) {
#line 205
      goto while_break;
    }
    {
#line 209
    puts(license[cnum]);
#line 205
    cnum ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  cnum = 0;
  {
#line 212
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 212
    if (! warranty[cnum]) {
#line 212
      goto while_break___0;
    }
    {
#line 216
    puts(warranty[cnum]);
#line 212
    cnum ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 218
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
void print_city_data(void) 
{ 
  int cnum ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 224
  cnum = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! cities[cnum].name) {
#line 224
      goto while_break;
    }
#line 228
    if (cities[cnum].TZ < 0) {
#line 228
      tmp = "";
    } else {
#line 228
      tmp = "+";
    }
#line 228
    if (cities[cnum].longdeg > 0) {
#line 228
      tmp___0 = 'W';
    } else {
#line 228
      tmp___0 = 'E';
    }
    {
#line 228
    tmp___1 = abs(cities[cnum].longmin);
#line 228
    tmp___2 = abs(cities[cnum].longdeg);
    }
#line 228
    if (cities[cnum].latdeg < 0) {
#line 228
      tmp___3 = 'S';
    } else {
#line 228
      tmp___3 = 'N';
    }
    {
#line 228
    tmp___4 = abs(cities[cnum].latmin);
#line 228
    tmp___5 = abs(cities[cnum].latdeg);
#line 228
    printf((char const   */* __restrict  */)"%s (%dd%d\' %c lat, %dd%d\' %c long, GMT %s%d:00)\n",
           cities[cnum].name, tmp___5, tmp___4, tmp___3, tmp___2, tmp___1, tmp___0,
           tmp, cities[cnum].TZ);
#line 224
    cnum ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return;
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
void print_DST_data(void) 
{ 
  size_t cnum ;

  {
#line 243
  cnum = (size_t )0;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (cnum < sizeof(savings_bank) / sizeof(dst_t ))) {
#line 243
      goto while_break;
    }
    {
#line 247
    puts((char const   *)savings_bank[cnum].name);
#line 243
    cnum ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
void localize_to_city(char const   *cityNameArg ) 
{ 
  size_t len ;
  size_t tmp ;
  char *pc ;
  char *cityStr ;
  city_t *pcity ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 254
  tmp = strlen(cityNameArg);
#line 254
  len = tmp;
#line 258
  tmp___0 = strlen(cityNameArg);
#line 258
  initStr(& cityStr, tmp___0);
#line 259
  strcpy((char */* __restrict  */)cityStr, (char const   */* __restrict  */)cityNameArg);
  }
#line 261
  if ((unsigned long )cityName != (unsigned long )((void *)0)) {
    {
#line 262
    free((void *)cityName);
    }
  }
#line 265
  pc = cityStr;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! ((int )*pc != 0)) {
#line 265
      goto while_break;
    }
    {
#line 266
    tmp___1 = __ctype_b_loc();
    }
#line 266
    if (! ((int const   )*(*tmp___1 + (int )*pc) & 1024)) {
#line 267
      *pc = (char )' ';
    }
#line 265
    pc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  pcity = & cities[0];
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 269
    if (! ((unsigned long )pcity->name != (unsigned long )((void *)0))) {
#line 269
      goto while_break___0;
    }
    {
#line 270
    tmp___3 = istrncasecmp(len, (char const   *)cityStr, (char const   *)pcity->name);
    }
#line 270
    if (0 == tmp___3) {
#line 272
      if (! longp) {
#line 272
        if (! latp) {
#line 274
          latdeg = pcity->latdeg;
#line 275
          latmin = pcity->latmin;
#line 276
          longdeg = pcity->longdeg;
#line 277
          longmin = pcity->longmin;
        }
      }
#line 279
      if (! zonep) {
#line 281
        TZ = pcity->TZ;
#line 282
        DST_scheme = pcity->DST_scheme;
      }
      {
#line 284
      free((void *)cityStr);
#line 285
      tmp___2 = strlen((char const   *)pcity->name);
#line 285
      initStr(& cityName, tmp___2);
#line 286
      strcpy((char */* __restrict  */)cityName, (char const   */* __restrict  */)pcity->name);
      }
#line 287
      return;
    }
#line 269
    pcity ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 290
  warn("unknown city: %s. Use a nearby city or geographic coordinates.", cityNameArg);
#line 291
  warn("run \'hebcal cities\' for a list of cities.", "");
#line 292
  ok_to_run = 0;
  }
#line 293
  return;
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
void set_DST_scheme(char const   *schemeArg ) 
{ 
  size_t len ;
  size_t tmp ;
  dst_t *pdst ;
  int tmp___0 ;

  {
  {
#line 297
  tmp = strlen(schemeArg);
#line 297
  len = tmp;
#line 300
  pdst = savings_bank;
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! ((unsigned long )pdst->name != (unsigned long )((void *)0))) {
#line 300
      goto while_break;
    }
    {
#line 301
    tmp___0 = istrncasecmp(len, schemeArg, (char const   *)pdst->name);
    }
#line 301
    if (0 == tmp___0) {
#line 303
      DST_scheme = pdst->DST_scheme;
#line 304
      return;
    }
#line 300
    pdst ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 307
  die("unknown daylight savings scheme: %s.  \"hebcal DST\" for options.", schemeArg);
  }
#line 308
  return;
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
void set_default_city(void) 
{ 
  char const   *cityName___0 ;
  char *tmp ;

  {
  {
#line 316
  localize_to_city("New_York");
#line 323
  tmp = getenv("HEBCAL_CITY");
#line 323
  cityName___0 = (char const   *)tmp;
  }
#line 323
  if ((unsigned long )((void *)0) != (unsigned long )cityName___0) {
    {
#line 324
    localize_to_city(cityName___0);
    }
  }
#line 325
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
void handleArgs(int argc , char **argv ) 
{ 
  char dummy[10] ;
  date_t greg_today ;
  int option ;
  char *usage ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  date_t tmp___7 ;
  size_t lineNumber ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___23 ;
  int tmp___25 ;
  int tmp___26 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;

  {
  {
#line 335
  usage = (char *)"usage: \n   hebcal [-acdDehHiorsStTwxy]\n          [-I input_file]\n          [-Y yahrtzeit_file]\n          [-C city]\n          [-L longitude -l latitude]\n          [-m havdalah_minutes]\n          [-z timezone]\n          [-Z daylight_savings_scheme]\n          [[month [day]] year]\n   hebcal help\n   hebcal info\n   hebcal DST\n   hebcal cities\n   hebcal warranty\n   hebcal copying\n";
#line 353
  setDate(& greg_today);
#line 355
  Getopt(argc, argv, (char *)"", 1);
  }
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 356
    option = Getopt(argc, argv, (char *)"acC:dDef:hHI:il:L:m:orsStTwxyY:z:Z:8", 0);
    }
#line 356
    if (! (-1 != option)) {
#line 356
      goto while_break;
    }
    {
#line 361
    if ((int )((char )option) == 97) {
#line 361
      goto case_97;
    }
#line 364
    if ((int )((char )option) == 56) {
#line 364
      goto case_56;
    }
#line 367
    if ((int )((char )option) == 99) {
#line 367
      goto case_99;
    }
#line 370
    if ((int )((char )option) == 67) {
#line 370
      goto case_67;
    }
#line 374
    if ((int )((char )option) == 100) {
#line 374
      goto case_100;
    }
#line 377
    if ((int )((char )option) == 68) {
#line 377
      goto case_68;
    }
#line 381
    if ((int )((char )option) == 73) {
#line 381
      goto case_73;
    }
#line 386
    if ((int )((char )option) == 101) {
#line 386
      goto case_101;
    }
#line 389
    if ((int )((char )option) == 102) {
#line 389
      goto case_102;
    }
#line 392
    if ((int )((char )option) == 104) {
#line 392
      goto case_104;
    }
#line 395
    if ((int )((char )option) == 72) {
#line 395
      goto case_72;
    }
#line 398
    if ((int )((char )option) == 105) {
#line 398
      goto case_105;
    }
#line 401
    if ((int )((char )option) == 108) {
#line 401
      goto case_108;
    }
#line 413
    if ((int )((char )option) == 76) {
#line 413
      goto case_76;
    }
#line 425
    if ((int )((char )option) == 109) {
#line 425
      goto case_109;
    }
#line 429
    if ((int )((char )option) == 111) {
#line 429
      goto case_111;
    }
#line 432
    if ((int )((char )option) == 114) {
#line 432
      goto case_114;
    }
#line 435
    if ((int )((char )option) == 115) {
#line 435
      goto case_115;
    }
#line 438
    if ((int )((char )option) == 83) {
#line 438
      goto case_83;
    }
#line 441
    if ((int )((char )option) == 84) {
#line 441
      goto case_84;
    }
#line 444
    if ((int )((char )option) == 116) {
#line 444
      goto case_116;
    }
#line 452
    if ((int )((char )option) == 119) {
#line 452
      goto case_119;
    }
#line 455
    if ((int )((char )option) == 121) {
#line 455
      goto case_121;
    }
#line 458
    if ((int )((char )option) == 89) {
#line 458
      goto case_89;
    }
#line 463
    if ((int )((char )option) == 120) {
#line 463
      goto case_120;
    }
#line 466
    if ((int )((char )option) == 90) {
#line 466
      goto case_90;
    }
#line 473
    if ((int )((char )option) == 122) {
#line 473
      goto case_122;
    }
#line 481
    goto switch_default;
    case_97: /* CIL Label */ 
#line 362
    ashkenazis_sw = 1;
#line 363
    goto switch_break;
    case_56: /* CIL Label */ 
#line 365
    iso8859_8_sw = 1;
#line 366
    goto switch_break;
    case_99: /* CIL Label */ 
#line 368
    candleLighting_sw = 1;
#line 369
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 371
    localize_to_city((char const   *)Optarg);
#line 372
    candleLighting_sw = 1;
    }
#line 373
    goto switch_break;
    case_100: /* CIL Label */ 
#line 375
    printHebDates_sw = 1;
#line 376
    goto switch_break;
    case_68: /* CIL Label */ 
#line 379
    printSomeHebDates_sw = 1;
#line 380
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 382
    inputFile_sw = 1;
#line 383
    inFile = fopen((char const   */* __restrict  */)Optarg, (char const   */* __restrict  */)"r");
    }
#line 383
    if (! inFile) {
      {
#line 384
      die("could not open input file %s.", (char const   *)Optarg);
      }
    }
#line 385
    goto switch_break;
    case_101: /* CIL Label */ 
#line 387
    euroDates_sw = 1;
#line 388
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 390
    formatString = strdup((char const   *)Optarg);
    }
#line 391
    goto switch_break;
    case_104: /* CIL Label */ 
#line 393
    noHolidays_sw = 1;
#line 394
    goto switch_break;
    case_72: /* CIL Label */ 
#line 396
    hebrewDates_sw = 1;
#line 397
    goto switch_break;
    case_105: /* CIL Label */ 
#line 399
    israel_sw = 1;
#line 400
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 402
    latmin = 0;
#line 402
    latdeg = latmin;
#line 403
    latp = 1;
#line 404
    tmp = sscanf((char const   */* __restrict  */)Optarg, (char const   */* __restrict  */)"%d,%d",
                 & latdeg, & latmin);
    }
#line 404
    if (tmp < 2) {
      {
#line 405
      die("unable to read latitude argument: %s", (char const   *)Optarg);
      }
    }
    {
#line 406
    tmp___0 = abs(latdeg);
    }
#line 406
    if (tmp___0 > 90) {
      {
#line 408
      die("latitude argument out of range", "");
      }
    } else
#line 406
    if (latmin > 60) {
      {
#line 408
      die("latitude argument out of range", "");
      }
    } else
#line 406
    if (latmin < 0) {
      {
#line 408
      die("latitude argument out of range", "");
      }
    }
    {
#line 409
    latmin = abs(latmin);
    }
#line 410
    if (latdeg < 0) {
#line 411
      latmin = - latmin;
    }
#line 412
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 414
    longmin = 0;
#line 414
    longdeg = longmin;
#line 415
    longp = 1;
#line 416
    tmp___1 = sscanf((char const   */* __restrict  */)Optarg, (char const   */* __restrict  */)"%d,%d",
                     & longdeg, & longmin);
    }
#line 416
    if (tmp___1 < 2) {
      {
#line 417
      die("unable to read longitude argument: %s", (char const   *)Optarg);
      }
    }
    {
#line 418
    tmp___2 = abs(longdeg);
    }
#line 418
    if (tmp___2 > 180) {
      {
#line 420
      die("longitude argument out of range", "");
      }
    } else
#line 418
    if (longmin > 60) {
      {
#line 420
      die("longitude argument out of range", "");
      }
    } else
#line 418
    if (longmin < 0) {
      {
#line 420
      die("longitude argument out of range", "");
      }
    }
    {
#line 421
    longmin = abs(longmin);
    }
#line 422
    if (longdeg < 0) {
#line 423
      longmin = - longmin;
    }
#line 424
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 426
    tmp___3 = sscanf((char const   */* __restrict  */)Optarg, (char const   */* __restrict  */)"%d",
                     & havdalah_minutes);
    }
#line 426
    if (! (tmp___3 == 1)) {
      {
#line 427
      die("unable to read havdalah_minutes argument: %s", (char const   *)Optarg);
      }
    }
#line 428
    goto switch_break;
    case_111: /* CIL Label */ 
#line 430
    printOmer_sw = 1;
#line 431
    goto switch_break;
    case_114: /* CIL Label */ 
#line 433
    tabs_sw = 1;
#line 434
    goto switch_break;
    case_115: /* CIL Label */ 
#line 436
    sedrot_sw = 1;
#line 437
    goto switch_break;
    case_83: /* CIL Label */ 
#line 439
    sedraAllWeek_sw = 1;
#line 440
    goto switch_break;
    case_84: /* CIL Label */ 
#line 442
    noGreg_sw = 1;
    case_116: /* CIL Label */ 
#line 445
    printHebDates_sw = 1;
#line 446
    rangeType = 3;
#line 447
    theMonth = greg_today.mm;
#line 448
    theDay = greg_today.dd;
#line 449
    yearDirty = 1;
#line 450
    printOmer_sw = 1;
#line 451
    goto switch_break;
    case_119: /* CIL Label */ 
#line 453
    weekday_sw = 1;
#line 454
    goto switch_break;
    case_121: /* CIL Label */ 
#line 456
    yearDigits_sw = 1;
#line 457
    goto switch_break;
    case_89: /* CIL Label */ 
    {
#line 459
    yahrtzeitFile_sw = 1;
#line 460
    yFile = fopen((char const   */* __restrict  */)Optarg, (char const   */* __restrict  */)"r");
    }
#line 460
    if (! yFile) {
      {
#line 461
      die("could not open yahrtzeit input file %s.", (char const   *)Optarg);
      }
    }
#line 462
    goto switch_break;
    case_120: /* CIL Label */ 
#line 464
    suppress_rosh_chodesh_sw = 1;
#line 465
    goto switch_break;
    case_90: /* CIL Label */ 
    {
#line 467
    schemep = 1;
#line 468
    sscanf((char const   */* __restrict  */)Optarg, (char const   */* __restrict  */)"%s",
           dummy);
#line 469
    set_DST_scheme((char const   *)(dummy));
    }
#line 470
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 474
    tmp___4 = sscanf((char const   */* __restrict  */)Optarg, (char const   */* __restrict  */)"%d",
                     & TZ);
    }
#line 474
    if (! (tmp___4 == 1)) {
      {
#line 475
      die("unable to read time zone argument: %s", (char const   *)Optarg);
      }
    }
#line 476
    if (! schemep) {
#line 477
      DST_scheme = 1;
    }
#line 478
    zonep = 1;
#line 479
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 482
    die((char const   *)usage, "");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  if (latp) {
#line 487
    cityName = (char *)"User Defined City";
  }
#line 488
  if (latp ^ longp) {
    {
#line 489
    die("You must enter BOTH the latitude and the longitude", "");
    }
  }
  {
#line 491
  tmp___5 = strcmp((char const   *)cityName, "Jerusalem");
  }
#line 491
  if (! tmp___5) {
#line 492
    light_offset = -40;
  }
  {
#line 496
  if (argc - Optind == 0) {
#line 496
    goto case_0;
  }
#line 503
  if (argc - Optind == 1) {
#line 503
    goto case_1;
  }
#line 550
  if (argc - Optind == 2) {
#line 550
    goto case_2;
  }
#line 578
  if (argc - Optind == 3) {
#line 578
    goto case_3;
  }
#line 627
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 497
  if (hebrewDates_sw) {
    {
#line 498
    tmp___6 = greg2abs(greg_today);
#line 498
    tmp___7 = abs2hebrew(tmp___6);
#line 498
    theYear = tmp___7.yy;
    }
  } else {
#line 500
    theYear = greg_today.yy;
  }
#line 501
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 504
  tmp___14 = isAllNums((char const   *)*(argv + Optind));
  }
#line 504
  if (tmp___14) {
    {
#line 506
    theYear = atoi((char const   *)*(argv + Optind));
#line 507
    yearDirty = 1;
    }
  } else {
    {
#line 509
    tmp___13 = istrncasecmp((size_t )5, (char const   *)*(argv + Optind), "help");
    }
#line 509
    if (0 == tmp___13) {
#line 513
      lineNumber = (size_t )0;
      {
#line 513
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 513
        if (! (lineNumber < sizeof(helpArray) / sizeof(char *))) {
#line 513
          goto while_break___0;
        }
        {
#line 517
        puts((char const   *)helpArray[lineNumber]);
#line 513
        lineNumber ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 519
      exit(0);
      }
    } else {
      {
#line 521
      tmp___12 = istrncasecmp((size_t )3, (char const   *)*(argv + Optind), "info");
      }
#line 521
      if (0 == tmp___12) {
        {
#line 523
        print_version_data();
#line 524
        exit(0);
        }
      } else {
        {
#line 526
        tmp___11 = istrncasecmp((size_t )3, (char const   *)*(argv + Optind), "cities");
        }
#line 526
        if (0 == tmp___11) {
          {
#line 528
          print_city_data();
#line 529
          exit(0);
          }
        } else {
          {
#line 531
          tmp___10 = istrncasecmp((size_t )3, (char const   *)*(argv + Optind), "DST");
          }
#line 531
          if (0 == tmp___10) {
            {
#line 533
            print_DST_data();
#line 534
            exit(0);
            }
          } else {
            {
#line 536
            tmp___9 = istrncasecmp((size_t )3, (char const   *)*(argv + Optind), "copying");
            }
#line 536
            if (0 == tmp___9) {
              {
#line 538
              print_copying();
#line 539
              exit(0);
              }
            } else {
              {
#line 541
              tmp___8 = istrncasecmp((size_t )3, (char const   *)*(argv + Optind),
                                     "warranty");
              }
#line 541
              if (0 == tmp___8) {
                {
#line 543
                print_warranty();
#line 544
                exit(0);
                }
              } else {
                {
#line 547
                die((char const   *)usage, "");
                }
              }
            }
          }
        }
      }
    }
  }
#line 548
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 551
  tmp___15 = isAllNums((char const   *)*(argv + (Optind + 1)));
  }
#line 551
  if (! tmp___15) {
    {
#line 552
    die((char const   *)usage, "");
    }
  }
  {
#line 553
  theYear = atoi((char const   *)*(argv + (Optind + 1)));
#line 555
  theMonth = lookup_hebrew_month((char const   *)*(argv + Optind));
  }
#line 557
  if (theMonth) {
#line 559
    hebrewDates_sw = 1;
#line 560
    if (theMonth == 13) {
#line 560
      if ((1L + (long )theYear * 7L) % 19L < 7L) {
#line 560
        tmp___16 = 1;
      } else {
#line 560
        tmp___16 = 0;
      }
#line 560
      if (! tmp___16) {
#line 561
        theMonth = 12;
      }
    }
  } else {
    {
#line 563
    tmp___17 = isAllNums((char const   *)*(argv + Optind));
    }
#line 563
    if (tmp___17) {
#line 564
      if (hebrewDates_sw) {
        {
#line 565
        die("Don\'t use numbers to specify hebrew months.", "");
        }
      } else {
        {
#line 567
        theMonth = atoi((char const   *)*(argv + Optind));
        }
      }
    } else
#line 568
    if (hebrewDates_sw) {
      {
#line 569
      die("Unknown hebrew month: %s", (char const   *)*(argv + Optind));
      }
    } else {
      {
#line 571
      die((char const   *)usage, "");
      }
    }
  }
#line 573
  Optind ++;
#line 574
  yearDirty = 1;
#line 575
  rangeType = 1;
#line 576
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 579
  tmp___18 = isAllNums((char const   *)*(argv + (Optind + 1)));
  }
#line 579
  if (tmp___18) {
    {
#line 579
    tmp___19 = isAllNums((char const   *)*(argv + (Optind + 2)));
    }
#line 579
    if (! tmp___19) {
      {
#line 581
      die((char const   *)usage, "");
      }
    }
  } else {
    {
#line 581
    die((char const   *)usage, "");
    }
  }
  {
#line 582
  theDay = atoi((char const   *)*(argv + (Optind + 1)));
#line 583
  theYear = atoi((char const   *)*(argv + (Optind + 2)));
#line 585
  theMonth = lookup_hebrew_month((char const   *)*(argv + Optind));
  }
#line 587
  if (theMonth) {
#line 589
    hebrewDates_sw = 1;
#line 590
    if (theMonth == 13) {
#line 590
      if ((1L + (long )theYear * 7L) % 19L < 7L) {
#line 590
        tmp___20 = 1;
      } else {
#line 590
        tmp___20 = 0;
      }
#line 590
      if (! tmp___20) {
#line 591
        theMonth = 12;
      }
    }
  } else {
    {
#line 593
    tmp___21 = isAllNums((char const   *)*(argv + Optind));
    }
#line 593
    if (tmp___21) {
#line 594
      if (hebrewDates_sw) {
        {
#line 595
        die("Don\'t use numbers to specify hebrew months.", "");
        }
      } else {
        {
#line 597
        theMonth = atoi((char const   *)*(argv + Optind));
        }
      }
    } else
#line 598
    if (hebrewDates_sw) {
      {
#line 599
      die("Unknown hebrew month: %s", (char const   *)*(argv + Optind));
      }
    } else {
      {
#line 601
      die("bad month.%s", (char const   *)usage);
      }
    }
  }
#line 603
  if (theDay < 1) {
    {
#line 604
    die("The day of the month must be greater than 0", "");
    }
  }
#line 605
  if (theMonth < 1) {
    {
#line 606
    die("The month must be greater than 0", "");
    }
  }
#line 608
  if (hebrewDates_sw) {
    {
#line 610
    tmp___31 = max_days_in_heb_month(theMonth, theYear);
    }
#line 610
    if (theDay > tmp___31) {
#line 611
      if (iso8859_8_sw) {
#line 611
        if ((1L + (long )theYear * 7L) % 19L < 7L) {
#line 611
          tmp___30 = 1;
        } else {
#line 611
          tmp___30 = 0;
        }
#line 611
        if (hMonths[tmp___30][theMonth].name[2]) {
#line 611
          if ((1L + (long )theYear * 7L) % 19L < 7L) {
#line 611
            tmp___23 = 1;
          } else {
#line 611
            tmp___23 = 0;
          }
#line 611
          tmp___29 = hMonths[tmp___23][theMonth].name[2];
        } else {
#line 611
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 611
        if (ashkenazis_sw) {
#line 611
          if ((1L + (long )theYear * 7L) % 19L < 7L) {
#line 611
            tmp___28 = 1;
          } else {
#line 611
            tmp___28 = 0;
          }
#line 611
          if (hMonths[tmp___28][theMonth].name[1]) {
#line 611
            if ((1L + (long )theYear * 7L) % 19L < 7L) {
#line 611
              tmp___25 = 1;
            } else {
#line 611
              tmp___25 = 0;
            }
#line 611
            tmp___27 = hMonths[tmp___25][theMonth].name[1];
          } else {
#line 611
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 611
          if ((1L + (long )theYear * 7L) % 19L < 7L) {
#line 611
            tmp___26 = 1;
          } else {
#line 611
            tmp___26 = 0;
          }
#line 611
          tmp___27 = hMonths[tmp___26][theMonth].name[0];
        }
#line 611
        tmp___29 = tmp___27;
      }
      {
#line 611
      die("Sorry, there aren\'t that many days in %s (then)", tmp___29);
      }
    }
  } else {
#line 616
    if (theMonth > 12) {
      {
#line 617
      die("The month must be less than 13", "");
      }
    }
#line 618
    if (! (theYear % 4)) {
#line 618
      if (theYear % 100) {
#line 618
        tmp___32 = 1;
      } else
#line 618
      if (! (theYear % 400)) {
#line 618
        tmp___32 = 1;
      } else {
#line 618
        tmp___32 = 0;
      }
    } else {
#line 618
      tmp___32 = 0;
    }
#line 618
    if (theDay > MonthLengths[tmp___32][theMonth]) {
      {
#line 619
      die("Sorry, there aren\'t that many days in %s (then)", eMonths[theMonth]);
      }
    }
  }
#line 624
  rangeType = 2;
#line 625
  yearDirty = 1;
#line 626
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 628
  die((char const   *)usage, "");
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 630
  return;
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
int tokenize(char *str , int *pargc , char **argv ) 
{ 
  char *s ;
  int tmp ;

  {
  {
#line 638
  *(argv + 0) = progname;
#line 639
  s = strtok((char */* __restrict  */)str, (char const   */* __restrict  */)"\t ");
#line 640
  *pargc = 1;
  }
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 643
    tmp = *pargc;
#line 643
    (*pargc) ++;
#line 643
    *(argv + tmp) = strdup((char const   *)s);
#line 641
    s = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\t ");
    }
#line 641
    if (! s) {
#line 641
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 647
  return (*pargc > 1);
}
}
#line 650 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/start.c"
int main(int argc , char **argv ) 
{ 
  date_t tempDate ;
  long startAbs ;
  long endAbs ;
  char *envStr ;
  int envArgc ;
  char *envArgv[40] ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  {
#line 658
  progname = *(argv + 0);
#line 660
  set_default_city();
#line 661
  envStr = getenv("HEBCAL_OPTS");
  }
#line 661
  if (envStr) {
    {
#line 661
    tmp___0 = strcmp((char const   *)envStr, "");
    }
#line 661
    if (tmp___0) {
      {
#line 665
      tokenize(envStr, & envArgc, envArgv);
#line 666
      i = 1;
      }
      {
#line 666
      while (1) {
        while_continue: /* CIL Label */ ;
#line 666
        if (! (i < argc)) {
#line 666
          goto while_break;
        }
#line 667
        tmp = envArgc;
#line 667
        envArgc ++;
#line 667
        envArgv[tmp] = *(argv + i);
#line 666
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 668
      handleArgs(envArgc, envArgv);
      }
    } else {
      {
#line 671
      handleArgs(argc, argv);
      }
    }
  } else {
    {
#line 671
    handleArgs(argc, argv);
    }
  }
#line 673
  tempDate.yy = theYear;
#line 674
  if (hebrewDates_sw) {
#line 674
    tmp___1 = 3761;
  } else {
#line 674
    tmp___1 = 1;
  }
#line 674
  if (theYear < tmp___1) {
    {
#line 675
    die("Sorry, hebcal can only handle dates in the common era.", "");
    }
  }
  {
#line 679
  if (rangeType == 3) {
#line 679
    goto case_3;
  }
#line 686
  if (rangeType == 2) {
#line 686
    goto case_2;
  }
#line 696
  if (rangeType == 1) {
#line 696
    goto case_1;
  }
#line 714
  if (rangeType == 0) {
#line 714
    goto case_0;
  }
#line 737
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 680
  printHebDates_sw = 1;
#line 681
  tempDate.dd = theDay;
#line 682
  tempDate.mm = theMonth;
#line 683
  tempDate.yy = theYear;
#line 684
  endAbs = greg2abs(tempDate);
#line 684
  startAbs = endAbs;
  }
#line 685
  goto switch_break;
  case_2: /* CIL Label */ 
#line 687
  printHebDates_sw = 1;
#line 688
  tempDate.dd = theDay;
#line 689
  tempDate.mm = theMonth;
#line 690
  tempDate.yy = theYear;
#line 691
  if (hebrewDates_sw) {
    {
#line 692
    endAbs = hebrew2abs(tempDate);
#line 692
    startAbs = endAbs;
    }
  } else {
    {
#line 694
    endAbs = greg2abs(tempDate);
#line 694
    startAbs = endAbs;
    }
  }
#line 695
  goto switch_break;
  case_1: /* CIL Label */ 
#line 697
  tempDate.dd = 1;
#line 698
  tempDate.mm = theMonth;
#line 699
  tempDate.yy = theYear;
#line 700
  if (hebrewDates_sw) {
    {
#line 702
    startAbs = hebrew2abs(tempDate);
#line 703
    tempDate.dd = max_days_in_heb_month(tempDate.mm, tempDate.yy);
#line 704
    endAbs = hebrew2abs(tempDate);
    }
  } else {
    {
#line 708
    startAbs = greg2abs(tempDate);
    }
#line 709
    if (! (theYear % 4)) {
#line 709
      if (theYear % 100) {
#line 709
        tmp___2 = 1;
      } else
#line 709
      if (! (theYear % 400)) {
#line 709
        tmp___2 = 1;
      } else {
#line 709
        tmp___2 = 0;
      }
    } else {
#line 709
      tmp___2 = 0;
    }
    {
#line 709
    tempDate.dd = MonthLengths[tmp___2][theMonth];
#line 710
    endAbs = greg2abs(tempDate);
    }
  }
#line 712
  goto switch_break;
  case_0: /* CIL Label */ 
#line 715
  if (hebrewDates_sw) {
    {
#line 717
    tempDate.dd = 1;
#line 718
    tempDate.mm = 7;
#line 719
    tempDate.yy = theYear;
#line 720
    startAbs = hebrew2abs(tempDate);
#line 722
    (tempDate.yy) ++;
#line 723
    tmp___3 = hebrew2abs(tempDate);
#line 723
    endAbs = tmp___3 - 1L;
    }
  } else {
    {
#line 727
    tempDate.dd = 1;
#line 728
    tempDate.mm = 1;
#line 729
    tempDate.yy = theYear;
#line 730
    startAbs = greg2abs(tempDate);
#line 732
    (tempDate.yy) ++;
#line 733
    tmp___4 = greg2abs(tempDate);
#line 733
    endAbs = tmp___4 - 1L;
    }
  }
#line 735
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 738
  die("Oh, NO! internal error #17q!", "");
#line 741
  endAbs = 0L;
#line 741
  startAbs = endAbs;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 744
  tempDate = abs2hebrew(startAbs);
  }
#line 745
  if (ok_to_run) {
    {
#line 747
    init_holidays(tempDate.yy);
#line 748
    main_calendar(startAbs, endAbs);
    }
#line 750
    return (0);
  } else {
#line 753
    return (1);
  }
}
}
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
FILE *inFile  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
FILE *yFile  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int DST_scheme  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int ashkenazis_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int iso8859_8_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int candleLighting_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int euroDates_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int hebrewDates_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int inputFile_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int israel_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int latlong_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int printOmer_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int printHebDates_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int printSomeHebDates_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int sedraAllWeek_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int sedrot_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int noGreg_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int noHolidays_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int suppress_rosh_chodesh_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int tabs_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int weekday_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int yearDigits_sw  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
int yahrtzeitFile_sw  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
char *formatString  ;
#line 108
year_t yearData(int hebyr ) ;
#line 109
date_t nextHebDate(date_t dth ) ;
#line 114
int getHebHolidays(date_t dth , struct hsnode **holiList ) ;
#line 115
void incHebGregDate(date_t *dtHeb , date_t *dtGreg , long *dtAbs , int *wkday , year_t *theYear___0 ) ;
#line 116
void PrintGregDate(date_t dt ) ;
#line 118
void print_candlelighting_times(int mask , int weekday , date_t todayGreg , int DST ) ;
#line 119
void reset_Omer(int hYear ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.c"
int DST_value  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.c"
long beginOmer  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.c"
long endOmer  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.c"
int havdalah_minutes  =    72;
#line 56 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.c"
int light_offset  =    -18;
#line 60 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.c"
year_t yearData(int hebyr ) 
{ 
  date_t tempDate ;
  year_t retYear ;
  long tmp ;

  {
  {
#line 65
  tempDate.yy = hebyr;
#line 66
  tempDate.mm = 7;
#line 67
  tempDate.dd = 1;
#line 69
  tmp = hebrew2abs(tempDate);
#line 69
  retYear.first_day_of_week = (int )(tmp % 7L);
  }
#line 70
  if ((1L + (long )hebyr * 7L) % 19L < 7L) {
#line 70
    retYear.leap_p = 1;
  } else {
#line 70
    retYear.leap_p = 0;
  }
#line 71
  return (retYear);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.c"
date_t nextHebDate(date_t dth ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 78
  (dth.dd) ++;
#line 79
  tmp___2 = max_days_in_heb_month(dth.mm, dth.yy);
  }
#line 79
  if (dth.dd > tmp___2) {
#line 81
    if ((1L + (long )dth.yy * 7L) % 19L < 7L) {
#line 81
      tmp___1 = 1;
    } else {
#line 81
      tmp___1 = 0;
    }
#line 81
    if (tmp___1) {
#line 81
      tmp___0 = 13;
    } else {
#line 81
      tmp___0 = 12;
    }
#line 81
    if (dth.mm == tmp___0) {
#line 83
      dth.mm = 1;
#line 84
      dth.dd = 1;
    } else {
#line 88
      (dth.mm) ++;
#line 89
      dth.dd = 1;
#line 90
      if (dth.mm == 7) {
#line 92
        (dth.yy) ++;
      }
    }
  }
#line 96
  return (dth);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.c"
void incHebGregDate(date_t *dtHeb , date_t *dtGreg , long *dtAbs , int *wkday , year_t *theYear___0 ) 
{ 


  {
  {
#line 110
  incDate(dtGreg, 1L);
#line 111
  *dtHeb = nextHebDate(*dtHeb);
#line 112
  (*dtAbs) ++;
#line 113
  *wkday = (*wkday + 1) % 7;
  }
#line 115
  if (7 == dtHeb->mm) {
#line 115
    if (1 == dtHeb->dd) {
      {
#line 118
      *theYear___0 = yearData(dtHeb->yy);
      }
#line 119
      if (sedraAllWeek_sw) {
        {
#line 120
        reset_sedra(dtHeb->yy);
        }
      } else
#line 119
      if (sedrot_sw) {
        {
#line 120
        reset_sedra(dtHeb->yy);
        }
      }
#line 121
      if (printOmer_sw) {
        {
#line 122
        reset_Omer(dtHeb->yy);
        }
      }
      {
#line 123
      init_holidays(dtHeb->yy);
      }
    }
  }
#line 125
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.c"
void PrintGregDate(date_t dt ) 
{ 
  int tmp ;

  {
#line 131
  if (! noGreg_sw) {
#line 133
    if (euroDates_sw) {
      {
#line 134
      printf((char const   */* __restrict  */)"%d.%d.", dt.dd, dt.mm);
      }
    } else {
      {
#line 136
      printf((char const   */* __restrict  */)"%d/%d/", dt.mm, dt.dd);
      }
    }
#line 138
    if (yearDigits_sw) {
      {
#line 139
      printf((char const   */* __restrict  */)"%d", dt.yy % 100);
      }
    } else {
      {
#line 141
      printf((char const   */* __restrict  */)"%d", dt.yy);
      }
    }
#line 143
    if (tabs_sw) {
      {
#line 144
      putchar('\t');
      }
    } else {
      {
#line 146
      putchar(' ');
      }
    }
  }
#line 149
  if (weekday_sw) {
    {
#line 150
    tmp = dayOfWeek(dt);
#line 150
    printf((char const   */* __restrict  */)"%s, ", ShortDayNames[tmp]);
    }
  }
#line 151
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.c"
void set_DST_bounds(long *beginDST , long *endDST , int gregYr ) 
{ 
  date_t tempDt ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;

  {
#line 159
  tempDt.yy = gregYr;
#line 160
  tempDt.dd = 1;
#line 161
  tempDt.mm = 4;
  {
#line 165
  if (DST_scheme == 0) {
#line 165
    goto case_0;
  }
#line 211
  if (DST_scheme == 3) {
#line 211
    goto case_3;
  }
#line 224
  if (DST_scheme == 4) {
#line 224
    goto case_4;
  }
#line 232
  if (DST_scheme == 2) {
#line 232
    goto case_2;
  }
#line 248
  if (DST_scheme == 1) {
#line 248
    goto case_1;
  }
#line 252
  goto switch_default;
  case_0: /* CIL Label */ 
#line 167
  if (gregYr >= 1966) {
#line 167
    if (gregYr < 1987) {
      {
#line 170
      tempDt.dd = 30;
#line 171
      tempDt.mm = 4;
#line 172
      tmp = greg2abs(tempDt);
#line 172
      *beginDST = day_on_or_before(0, tmp);
#line 175
      tempDt.dd = 1;
#line 176
      tempDt.mm = 11;
#line 177
      tmp___0 = greg2abs(tempDt);
#line 177
      *endDST = day_on_or_before(0, tmp___0 - 1L);
#line 178
      DST_value = 60;
      }
#line 179
      goto switch_break;
    } else {
#line 167
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 181
  if (gregYr >= 1987) {
#line 181
    if (gregYr < 2007) {
      {
#line 184
      tmp___1 = greg2abs(tempDt);
#line 184
      *beginDST = day_on_or_before(0, tmp___1 + 6L);
#line 188
      tempDt.dd = 1;
#line 189
      tempDt.mm = 11;
#line 190
      tmp___2 = greg2abs(tempDt);
#line 190
      *endDST = day_on_or_before(0, tmp___2 - 1L);
#line 192
      DST_value = 60;
      }
#line 193
      goto switch_break;
    } else {
#line 181
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 195
  if (gregYr >= 2007) {
    {
#line 198
    tempDt.dd = 1;
#line 199
    tempDt.mm = 3;
#line 200
    tmp___3 = greg2abs(tempDt);
#line 200
    *beginDST = day_on_or_before(0, tmp___3 + 13L);
#line 204
    tempDt.dd = 1;
#line 205
    tempDt.mm = 11;
#line 206
    tmp___4 = greg2abs(tempDt);
#line 206
    *endDST = day_on_or_before(0, tmp___4 + 6L);
#line 208
    DST_value = 60;
    }
#line 209
    goto switch_break;
  }
  case_3: /* CIL Label */ 
  {
#line 217
  tmp___5 = greg2abs(tempDt);
#line 217
  *beginDST = day_on_or_before(0, tmp___5 - 1L);
#line 218
  tempDt.dd = 1;
#line 219
  tempDt.mm = 11;
#line 221
  tmp___6 = greg2abs(tempDt);
#line 221
  *endDST = day_on_or_before(0, tmp___6 - 1L);
#line 222
  DST_value = 60;
  }
#line 223
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 226
  tmp___7 = greg2abs(tempDt);
#line 226
  *endDST = day_on_or_before(0, tmp___7 - 1L);
#line 227
  tempDt.dd = 1;
#line 228
  tempDt.mm = 11;
#line 229
  tmp___8 = greg2abs(tempDt);
#line 229
  *beginDST = day_on_or_before(0, tmp___8 - 1L);
#line 230
  DST_value = 60;
  }
#line 231
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 235
  tempDt.mm = 1;
#line 236
  tempDt.dd = 28;
#line 237
  tempDt.yy = gregYr + 3760;
#line 238
  tmp___9 = hebrew2abs(tempDt);
#line 238
  *beginDST = day_on_or_before(0, tmp___9);
#line 242
  tempDt.mm = 7;
#line 243
  tempDt.dd = 1;
#line 244
  tempDt.yy = gregYr + 3761;
#line 245
  tmp___10 = hebrew2abs(tempDt);
#line 245
  *endDST = day_on_or_before(0, tmp___10 - 3L);
#line 246
  DST_value = 60;
  }
#line 247
  goto switch_break;
  case_1: /* CIL Label */ 
#line 249
  tmp___11 = 0L;
#line 249
  *beginDST = tmp___11;
#line 249
  *endDST = tmp___11;
#line 250
  DST_value = 0;
#line 251
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 253
  DST_value = 0;
#line 254
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 256
  return;
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.c"
void set_DST(long beginDST , long endDST , long todayAbs , int *DST ) 
{ 


  {
#line 263
  if (beginDST > endDST) {
#line 266
    if (todayAbs >= beginDST) {
#line 268
      *DST = DST_value;
    } else
#line 266
    if (todayAbs < endDST) {
#line 268
      *DST = DST_value;
    } else {
#line 272
      *DST = 0;
    }
  } else
#line 277
  if (beginDST <= todayAbs) {
#line 277
    if (todayAbs < endDST) {
#line 278
      *DST = DST_value;
    } else {
#line 280
      *DST = 0;
    }
  } else {
#line 280
    *DST = 0;
  }
#line 282
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.c"
void print_candlelighting_times(int mask , int weekday , date_t todayGreg , int DST ) 
{ 
  double xsunrise ;
  double xsunset ;
  int day_adj ;
  int status ;
  int tmp ;
  char *time___0 ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  double xsunrise___0 ;
  double xsunset___0 ;
  int day_adj___0 ;
  int status___0 ;
  int tmp___2 ;
  char *time___1 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 290
  if (weekday == 5) {
#line 290
    goto _L;
  } else
#line 290
  if (mask & 2) {
    _L: /* CIL Label */ 
    {
#line 295
    PrintGregDate(todayGreg);
#line 297
    tmp = dayOfYear(todayGreg);
#line 297
    status = suntime(& xsunrise, & xsunset, tmp, 4, 0);
    }
#line 299
    if (status & 1) {
      {
#line 300
      printf((char const   */* __restrict  */)"No sunset today.\n");
      }
    } else {
      {
#line 303
      tmp___0 = timeadj((char *)"", xsunset, light_offset + DST, & day_adj);
#line 303
      time___0 = tmp___0;
      }
#line 304
      if (iso8859_8_sw) {
#line 304
        tmp___1 = "\344\343\354\367\372 \360\370\345\372";
      } else {
#line 304
        tmp___1 = "Candle lighting";
      }
      {
#line 304
      printf((char const   */* __restrict  */)"%s: %s\n", tmp___1, time___0);
#line 309
      free((void *)time___0);
      }
    }
  }
#line 318
  if (weekday == 6) {
#line 318
    goto _L___0;
  } else
#line 318
  if (mask & 4) {
#line 318
    if (weekday != 5) {
      _L___0: /* CIL Label */ 
      {
#line 326
      PrintGregDate(todayGreg);
#line 328
      tmp___2 = dayOfYear(todayGreg);
#line 328
      status___0 = suntime(& xsunrise___0, & xsunset___0, tmp___2, 4, 0);
      }
#line 330
      if (status___0 & 1) {
        {
#line 331
        printf((char const   */* __restrict  */)"No sunset today.\n");
        }
      } else {
        {
#line 334
        tmp___3 = timeadj((char *)"", xsunset___0, havdalah_minutes + DST, & day_adj___0);
#line 334
        time___1 = tmp___3;
        }
#line 338
        if (iso8859_8_sw) {
#line 338
          tmp___4 = "\343\367\345\372";
        } else {
#line 338
          tmp___4 = "min";
        }
#line 338
        if (iso8859_8_sw) {
#line 338
          tmp___5 = "\344\341\343\354\344";
        } else {
#line 338
          tmp___5 = "Havdalah";
        }
        {
#line 338
        printf((char const   */* __restrict  */)"%s (%d %s):%s\n", tmp___5, havdalah_minutes,
               tmp___4, time___1);
#line 344
        free((void *)time___1);
        }
      }
    }
  }
#line 347
  return;
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.c"
void reset_Omer(int hYear ) 
{ 
  date_t d ;

  {
  {
#line 354
  d.dd = 16;
#line 355
  d.mm = 1;
#line 356
  d.yy = hYear;
#line 358
  beginOmer = hebrew2abs(d);
#line 359
  d.dd = 5;
#line 360
  d.mm = 3;
#line 361
  endOmer = hebrew2abs(d);
  }
#line 362
  return;
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.c"
void main_calendar(long todayAbs , long endAbs ) 
{ 
  date_t todayGreg ;
  date_t todayHeb ;
  long beginDST ;
  long endDST ;
  holstorep_t holi_start ;
  holstorep_t holip ;
  year_t theYear___0 ;
  char *omerStr ;
  int omer ;
  int day_of_week ;
  int returnedMask ;
  int DST ;
  int omer_today ;
  int sedra_today ;
  int candle_today ;
  int holidays_today ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *sedraStr ;
  char *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 376
  todayHeb = abs2hebrew(todayAbs);
#line 377
  todayGreg = abs2greg(todayAbs);
#line 379
  theYear___0 = yearData(todayHeb.yy);
#line 380
  set_DST_bounds(& beginDST, & endDST, todayGreg.yy);
#line 381
  set_DST(beginDST, endDST, todayAbs, & DST);
#line 386
  reset_Omer(todayHeb.yy);
  }
#line 387
  if (sedraAllWeek_sw) {
    {
#line 388
    reset_sedra(todayHeb.yy);
    }
  } else
#line 387
  if (sedrot_sw) {
    {
#line 388
    reset_sedra(todayHeb.yy);
    }
  }
#line 389
  day_of_week = (int )(todayAbs % 7L);
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (todayAbs <= endAbs)) {
#line 390
      goto while_break;
    }
    {
#line 393
    returnedMask = getHebHolidays(todayHeb, & holip);
    }
#line 395
    if (sedraAllWeek_sw) {
#line 395
      tmp = 1;
    } else
#line 395
    if (sedrot_sw) {
#line 395
      if (day_of_week == 6) {
#line 395
        tmp = 1;
      } else {
#line 395
        tmp = 0;
      }
    } else {
#line 395
      tmp = 0;
    }
#line 395
    sedra_today = tmp;
#line 396
    if (printOmer_sw) {
#line 396
      if (todayAbs >= beginOmer) {
#line 396
        if (todayAbs <= endOmer) {
#line 396
          tmp___0 = 1;
        } else {
#line 396
          tmp___0 = 0;
        }
      } else {
#line 396
        tmp___0 = 0;
      }
    } else {
#line 396
      tmp___0 = 0;
    }
#line 396
    omer_today = tmp___0;
#line 399
    if (candleLighting_sw) {
#line 399
      if (day_of_week >= 5) {
#line 399
        tmp___1 = 1;
      } else
#line 399
      if (returnedMask & 2) {
#line 399
        tmp___1 = 1;
      } else
#line 399
      if (returnedMask & 4) {
#line 399
        tmp___1 = 1;
      } else {
#line 399
        tmp___1 = 0;
      }
    } else {
#line 399
      tmp___1 = 0;
    }
#line 399
    candle_today = tmp___1;
#line 403
    if (holip) {
#line 403
      if (! noHolidays_sw) {
#line 403
        tmp___2 = 1;
      } else
#line 403
      if (returnedMask & 1) {
#line 403
        tmp___2 = 1;
      } else {
#line 403
        tmp___2 = 0;
      }
    } else {
#line 403
      tmp___2 = 0;
    }
#line 403
    holidays_today = tmp___2;
#line 406
    if (printHebDates_sw) {
#line 406
      goto _L___2;
    } else
#line 406
    if (printSomeHebDates_sw) {
#line 406
      if (holidays_today) {
#line 406
        goto _L___2;
      } else
#line 406
      if (sedra_today) {
#line 406
        goto _L___2;
      } else
#line 406
      if (omer_today) {
#line 406
        goto _L___2;
      } else
#line 406
      if (candle_today) {
        _L___2: /* CIL Label */ 
        {
#line 410
        PrintGregDate(todayGreg);
        }
#line 411
        if (iso8859_8_sw) {
#line 411
          if ((1L + (long )todayHeb.yy * 7L) % 19L < 7L) {
#line 411
            tmp___11 = 1;
          } else {
#line 411
            tmp___11 = 0;
          }
#line 411
          if (hMonths[tmp___11][todayHeb.mm].name[2]) {
#line 411
            if ((1L + (long )todayHeb.yy * 7L) % 19L < 7L) {
#line 411
              tmp___4 = 1;
            } else {
#line 411
              tmp___4 = 0;
            }
#line 411
            tmp___10 = hMonths[tmp___4][todayHeb.mm].name[2];
          } else {
#line 411
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 411
          if (ashkenazis_sw) {
#line 411
            if ((1L + (long )todayHeb.yy * 7L) % 19L < 7L) {
#line 411
              tmp___9 = 1;
            } else {
#line 411
              tmp___9 = 0;
            }
#line 411
            if (hMonths[tmp___9][todayHeb.mm].name[1]) {
#line 411
              if ((1L + (long )todayHeb.yy * 7L) % 19L < 7L) {
#line 411
                tmp___6 = 1;
              } else {
#line 411
                tmp___6 = 0;
              }
#line 411
              tmp___8 = hMonths[tmp___6][todayHeb.mm].name[1];
            } else {
#line 411
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 411
            if ((1L + (long )todayHeb.yy * 7L) % 19L < 7L) {
#line 411
              tmp___7 = 1;
            } else {
#line 411
              tmp___7 = 0;
            }
#line 411
            tmp___8 = hMonths[tmp___7][todayHeb.mm].name[0];
          }
#line 411
          tmp___10 = tmp___8;
        }
#line 411
        if (iso8859_8_sw) {
#line 411
          tmp___12 = "";
        } else {
#line 411
          tmp___12 = " of";
        }
#line 411
        if (iso8859_8_sw) {
#line 411
          tmp___14 = "";
        } else {
          {
#line 411
          tmp___13 = numSuffix(todayHeb.dd);
#line 411
          tmp___14 = tmp___13;
          }
        }
        {
#line 411
        printf((char const   */* __restrict  */)"%d%s%s %s, %d\n", todayHeb.dd, tmp___14,
               tmp___12, tmp___10, todayHeb.yy);
        }
      }
    }
#line 420
    if (sedra_today) {
      {
#line 422
      tmp___15 = sedra(todayAbs);
#line 422
      sedraStr = (char const   *)tmp___15;
      }
#line 423
      if ((unsigned long )((void *)0) != (unsigned long )sedraStr) {
        {
#line 425
        PrintGregDate(todayGreg);
        }
#line 426
        if (iso8859_8_sw) {
#line 426
          tmp___17 = "\364\370\371\372";
        } else {
#line 426
          if (ashkenazis_sw) {
#line 426
            tmp___16 = "Parshas";
          } else {
#line 426
            tmp___16 = "Parashat";
          }
#line 426
          tmp___17 = tmp___16;
        }
        {
#line 426
        printf((char const   */* __restrict  */)"%s %s\n", tmp___17, sedraStr);
        }
      }
    }
#line 434
    holi_start = holip;
    {
#line 435
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 435
      if (! holip) {
#line 435
        goto while_break___0;
      }
#line 437
      if (! noHolidays_sw) {
        {
#line 442
        PrintGregDate(todayGreg);
#line 443
        puts((char const   *)holip->name);
        }
      } else
#line 437
      if (holip->typeMask & 1U) {
        {
#line 442
        PrintGregDate(todayGreg);
#line 443
        puts((char const   *)holip->name);
        }
      }
#line 435
      holip = holip->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 448
    if (omer_today) {
      {
#line 450
      initStr(& omerStr, (size_t )60);
#line 451
      omer = (int )((todayAbs - beginOmer) + 1L);
      }
#line 452
      if (! tabs_sw) {
        {
#line 454
        tmp___18 = hc_itoa(omer);
#line 454
        strncat((char */* __restrict  */)omerStr, (char const   */* __restrict  */)tmp___18,
                (size_t )60);
#line 455
        tmp___19 = numSuffix(omer);
#line 455
        strncat((char */* __restrict  */)omerStr, (char const   */* __restrict  */)tmp___19,
                (size_t )60);
#line 456
        strncat((char */* __restrict  */)omerStr, (char const   */* __restrict  */)" day of the Omer",
                (size_t )60);
        }
      } else {
        {
#line 460
        strncat((char */* __restrict  */)omerStr, (char const   */* __restrict  */)"Omer: ",
                (size_t )60);
#line 461
        tmp___20 = hc_itoa(omer);
#line 461
        strncat((char */* __restrict  */)omerStr, (char const   */* __restrict  */)tmp___20,
                (size_t )60);
        }
      }
      {
#line 463
      PrintGregDate(todayGreg);
#line 464
      printf((char const   */* __restrict  */)"%s\n", omerStr);
#line 465
      free((void *)omerStr);
      }
    }
#line 469
    if (candle_today) {
      {
#line 471
      set_DST(beginDST, endDST, todayAbs, & DST);
#line 472
      print_candlelighting_times(returnedMask, day_of_week, todayGreg, DST);
      }
    }
    {
#line 477
    incHebGregDate(& todayHeb, & todayGreg, & todayAbs, & day_of_week, & theYear___0);
    }
#line 479
    if (1 == todayGreg.dd) {
#line 479
      if (1 == todayGreg.mm) {
        {
#line 482
        set_DST_bounds(& beginDST, & endDST, todayGreg.yy);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 489
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.h"
int days_in_heb_year(int year ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.c"
hmonth_t hMonths[2][15]  = { {        {{"VOID", (char const   *)((void *)0), "VOID"}}, 
            {{"Nisan", (char const   *)((void *)0), "\360\351\361\357"}}, 
            {{"Iyyar", (char const   *)((void *)0), "\340\351\351\370"}}, 
            {{"Sivan", (char const   *)((void *)0), "\361\351\345\357"}}, 
            {{"Tamuz", (char const   *)((void *)0), "\372\356\345\346"}}, 
            {{"Av", (char const   *)((void *)0), "\340\341"}}, 
            {{"Elul", (char const   *)((void *)0), "\340\354\345\354"}}, 
            {{"Tishrei", (char const   *)((void *)0), "\372\371\370\351"}}, 
            {{"Cheshvan", (char const   *)((void *)0), "\347\371\345\357"}}, 
            {{"Kislev", (char const   *)((void *)0), "\353\361\354\345"}}, 
            {{"Tevet", (char const   *)((void *)0), "\350\341\372"}}, 
            {{"Sh\'vat", (char const   *)((void *)0), "\371\341\350"}}, 
            {{"Adar", (char const   *)((void *)0), "\340\343\370"}}, 
            {{"Nisan", (char const   *)((void *)0), "\360\351\361\357"}}}, 
   {        {{"VOID", (char const   *)((void *)0), "VOID"}}, 
            {{"Nisan", (char const   *)((void *)0), "\360\351\361\357"}}, 
            {{"Iyyar", (char const   *)((void *)0), "\340\351\351\370"}}, 
            {{"Sivan", (char const   *)((void *)0), "\361\351\345\357"}}, 
            {{"Tamuz", (char const   *)((void *)0), "\372\356\345\346"}}, 
            {{"Av", (char const   *)((void *)0), "\340\341"}}, 
            {{"Elul", (char const   *)((void *)0), "\340\354\345\354"}}, 
            {{"Tishrei", (char const   *)((void *)0), "\372\371\370\351"}}, 
            {{"Cheshvan", (char const   *)((void *)0), "\347\371\345\357"}}, 
            {{"Kislev", (char const   *)((void *)0), "\353\361\354\345"}}, 
            {{"Tevet", (char const   *)((void *)0), "\350\341\372"}}, 
            {{"Sh\'vat", (char const   *)((void *)0), "\371\341\350"}}, 
            {{"Adar I", (char const   *)((void *)0), "\340\343\370 \340\'"}}, 
            {{"Adar II", (char const   *)((void *)0), "\340\343\370 \341\'"}}, 
            {{"Nisan", (char const   *)((void *)0), "\360\351\361\357"}}}};
#line 71 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.c"
int max_days_in_heb_month(int month , int year ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 73
  if (month == 2) {
#line 81
    return (29);
  } else
#line 73
  if (month == 4) {
#line 81
    return (29);
  } else
#line 73
  if (month == 6) {
#line 81
    return (29);
  } else
#line 73
  if (month == 10) {
#line 81
    return (29);
  } else
#line 73
  if (month == 13) {
#line 81
    return (29);
  } else
#line 73
  if (month == 12) {
#line 73
    if ((1L + (long )year * 7L) % 19L < 7L) {
#line 73
      tmp = 1;
    } else {
#line 73
      tmp = 0;
    }
#line 73
    if (tmp) {
#line 73
      goto _L___0;
    } else {
#line 81
      return (29);
    }
  } else
  _L___0: /* CIL Label */ 
#line 73
  if (month == 8) {
    {
#line 73
    tmp___0 = long_cheshvan(year);
    }
#line 73
    if (tmp___0) {
#line 73
      goto _L;
    } else {
#line 81
      return (29);
    }
  } else
  _L: /* CIL Label */ 
#line 73
  if (month == 9) {
    {
#line 73
    tmp___1 = short_kislev(year);
    }
#line 73
    if (tmp___1) {
#line 81
      return (29);
    } else {
#line 83
      return (30);
    }
  } else {
#line 83
    return (30);
  }
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.c"
int lookup_hebrew_month(char const   *s ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 100
  tmp = s;
#line 100
  s ++;
#line 100
  tmp___0 = tolower((int )*tmp);
  }
  {
#line 102
  if (tmp___0 == 110) {
#line 102
    goto case_110;
  }
#line 106
  if (tmp___0 == 105) {
#line 106
    goto case_105;
  }
#line 108
  if (tmp___0 == 101) {
#line 108
    goto case_101;
  }
#line 110
  if (tmp___0 == 99) {
#line 110
    goto case_99;
  }
#line 112
  if (tmp___0 == 107) {
#line 112
    goto case_107;
  }
#line 114
  if (tmp___0 == 115) {
#line 114
    goto case_115;
  }
#line 124
  if (tmp___0 == 116) {
#line 124
    goto case_116;
  }
#line 136
  if (tmp___0 == 97) {
#line 136
    goto case_97___0;
  }
#line 151
  goto switch_default___2;
  case_110: /* CIL Label */ 
  {
#line 103
  tmp___3 = tolower((int )*s);
  }
#line 103
  if (tmp___3 == 111) {
#line 103
    tmp___2 = 0;
  } else {
#line 103
    tmp___2 = 1;
  }
#line 103
  return (tmp___2);
  case_105: /* CIL Label */ 
#line 107
  return (2);
  case_101: /* CIL Label */ 
#line 109
  return (6);
  case_99: /* CIL Label */ 
#line 111
  return (8);
  case_107: /* CIL Label */ 
#line 113
  return (9);
  case_115: /* CIL Label */ 
  {
#line 115
  tmp___4 = tolower((int )*s);
  }
  {
#line 117
  if (tmp___4 == 105) {
#line 117
    goto case_105___0;
  }
#line 119
  if (tmp___4 == 104) {
#line 119
    goto case_104;
  }
#line 121
  goto switch_default;
  case_105___0: /* CIL Label */ 
#line 118
  return (3);
  case_104: /* CIL Label */ 
#line 120
  return (11);
  switch_default: /* CIL Label */ 
#line 122
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  case_116: /* CIL Label */ 
  {
#line 125
  tmp___5 = tolower((int )*s);
  }
  {
#line 127
  if (tmp___5 == 97) {
#line 127
    goto case_97;
  }
#line 129
  if (tmp___5 == 105) {
#line 129
    goto case_105___1;
  }
#line 131
  if (tmp___5 == 101) {
#line 131
    goto case_101___0;
  }
#line 133
  goto switch_default___0;
  case_97: /* CIL Label */ 
#line 128
  return (4);
  case_105___1: /* CIL Label */ 
#line 130
  return (7);
  case_101___0: /* CIL Label */ 
#line 132
  return (10);
  switch_default___0: /* CIL Label */ 
#line 134
  return (0);
  switch_break___1: /* CIL Label */ ;
  }
  case_97___0: /* CIL Label */ 
  {
#line 137
  tmp___6 = tolower((int )*s);
  }
  {
#line 139
  if (tmp___6 == 118) {
#line 139
    goto case_118;
  }
#line 141
  if (tmp___6 == 100) {
#line 141
    goto case_100;
  }
#line 148
  goto switch_default___1;
  case_118: /* CIL Label */ 
#line 140
  return (5);
  case_100: /* CIL Label */ 
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! *s) {
#line 142
      goto while_break;
    }
#line 144
    if ((int const   )*s == 49) {
#line 145
      return (12);
    }
#line 142
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return (13);
  switch_default___1: /* CIL Label */ 
#line 149
  return (0);
  switch_break___2: /* CIL Label */ ;
  }
  switch_default___2: /* CIL Label */ 
#line 152
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.c"
static int mmap[12]  = 
#line 196
  {      9,      10,      11,      12, 
        1,      2,      3,      4, 
        7,      7,      7,      8};
#line 194 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.c"
date_t abs2hebrew(long d ) 
{ 
  date_t hebdate ;
  date_t gregdate ;
  int day ;
  int month ;
  int year ;
  long tmp ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
#line 205
  if (d >= 10555144L) {
    {
#line 207
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"parameter to abs2hebrew  %ld out of range\n",
            d);
#line 209
    exit(1);
    }
  }
  {
#line 212
  gregdate = abs2greg(d);
#line 213
  hebdate.dd = 1;
#line 214
  hebdate.mm = 7;
#line 215
  year = 3760 + gregdate.yy;
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 217
    hebdate.yy = year + 1;
#line 217
    tmp = hebrew2abs(hebdate);
    }
#line 217
    if (! (d >= tmp)) {
#line 217
      goto while_break;
    }
#line 219
    year ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  if (year >= 4635) {
#line 221
    if (year < 10666) {
#line 224
      month = mmap[gregdate.mm - 1];
    } else {
#line 229
      month = 7;
    }
  } else {
#line 229
    month = 7;
  }
  {
#line 232
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 232
    hebdate.mm = month;
#line 232
    hebdate.dd = max_days_in_heb_month(month, year);
#line 232
    hebdate.yy = year;
#line 232
    tmp___3 = hebrew2abs(hebdate);
    }
#line 232
    if (! (d > tmp___3)) {
#line 232
      goto while_break___0;
    }
#line 236
    if ((1L + (long )year * 7L) % 19L < 7L) {
#line 236
      tmp___2 = 1;
    } else {
#line 236
      tmp___2 = 0;
    }
#line 236
    if (tmp___2) {
#line 236
      tmp___1 = 13;
    } else {
#line 236
      tmp___1 = 12;
    }
#line 236
    month = month % tmp___1 + 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 238
  hebdate.dd = 1;
#line 240
  tmp___4 = hebrew2abs(hebdate);
#line 240
  day = (int )((d - tmp___4) + 1L);
  }
#line 241
  if (day < 0) {
    {
#line 243
    tmp___5 = hebrew2abs(hebdate);
#line 243
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"assertion failure d < hebrew2abs(m,d,y) => %ld < %ld!\n",
            d, tmp___5);
#line 245
    exit(1);
    }
  }
#line 248
  hebdate.dd = day;
#line 250
  return (hebdate);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.c"
static long hebrew_elapsed_days(int year ) 
{ 
  long yearl ;
  long m_elapsed ;
  long p_elapsed ;
  long h_elapsed ;
  long parts ;
  long day ;
  long alt_day ;
  int tmp ;
  int tmp___0 ;

  {
#line 261
  yearl = (long )year;
#line 262
  m_elapsed = (235L * ((yearl - 1L) / 19L) + 12L * ((yearl - 1L) % 19L)) + (((yearl - 1L) % 19L) * 7L + 1L) / 19L;
#line 266
  p_elapsed = 204L + 793L * (m_elapsed % 1080L);
#line 268
  h_elapsed = ((5L + 12L * m_elapsed) + 793L * (m_elapsed / 1080L)) + p_elapsed / 1080L;
#line 272
  parts = p_elapsed % 1080L + 1080L * (h_elapsed % 24L);
#line 274
  day = (1L + 29L * m_elapsed) + h_elapsed / 24L;
#line 276
  if (parts >= 19440L) {
#line 279
    alt_day = day + 1L;
  } else
#line 276
  if (2L == day % 7L) {
#line 276
    if (parts >= 9924L) {
#line 276
      if ((1L + (long )year * 7L) % 19L < 7L) {
#line 276
        tmp = 1;
      } else {
#line 276
        tmp = 0;
      }
#line 276
      if (tmp) {
#line 276
        goto _L___0;
      } else {
#line 279
        alt_day = day + 1L;
      }
    } else {
#line 276
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 276
  if (1L == day % 7L) {
#line 276
    if (parts >= 16789L) {
#line 276
      if ((1L + (long )(year - 1) * 7L) % 19L < 7L) {
#line 276
        tmp___0 = 1;
      } else {
#line 276
        tmp___0 = 0;
      }
#line 276
      if (tmp___0) {
#line 279
        alt_day = day + 1L;
      } else {
#line 281
        alt_day = day;
      }
    } else {
#line 281
      alt_day = day;
    }
  } else {
#line 281
    alt_day = day;
  }
#line 283
  if (alt_day % 7L == 0L) {
#line 286
    return (alt_day + 1L);
  } else
#line 283
  if (alt_day % 7L == 3L) {
#line 286
    return (alt_day + 1L);
  } else
#line 283
  if (alt_day % 7L == 5L) {
#line 286
    return (alt_day + 1L);
  } else {
#line 288
    return (alt_day);
  }
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.c"
long hebrew2abs(date_t d ) 
{ 
  int m ;
  long tempabs ;
  long ret___0 ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;

  {
#line 300
  tempabs = (long )d.dd;
#line 303
  if (d.mm < 7) {
#line 305
    m = 7;
    {
#line 305
    while (1) {
      while_continue: /* CIL Label */ ;
#line 305
      if ((1L + (long )d.yy * 7L) % 19L < 7L) {
#line 305
        tmp___2 = 1;
      } else {
#line 305
        tmp___2 = 0;
      }
#line 305
      if (tmp___2) {
#line 305
        tmp___1 = 13;
      } else {
#line 305
        tmp___1 = 12;
      }
#line 305
      if (! (m <= tmp___1)) {
#line 305
        goto while_break;
      }
      {
#line 306
      tmp = max_days_in_heb_month(m, d.yy);
#line 306
      tempabs += (long )tmp;
#line 305
      m ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 308
    m = 1;
    {
#line 308
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 308
      if (! (m < d.mm)) {
#line 308
        goto while_break___0;
      }
      {
#line 309
      tmp___3 = max_days_in_heb_month(m, d.yy);
#line 309
      tempabs += (long )tmp___3;
#line 308
      m ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 313
    m = 7;
    {
#line 313
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 313
      if (! (m < d.mm)) {
#line 313
        goto while_break___1;
      }
      {
#line 314
      tmp___4 = max_days_in_heb_month(m, d.yy);
#line 314
      tempabs += (long )tmp___4;
#line 313
      m ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 318
  tmp___5 = hebrew_elapsed_days(d.yy);
#line 318
  ret___0 = (tmp___5 - 1373429L) + tempabs;
  }
#line 319
  return (ret___0);
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.c"
int days_in_heb_year(int year ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
  {
#line 325
  tmp = hebrew_elapsed_days(year + 1);
#line 325
  tmp___0 = hebrew_elapsed_days(year);
  }
#line 325
  return ((int )(tmp - tmp___0));
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.c"
int long_cheshvan(int year ) 
{ 
  int tmp ;

  {
  {
#line 331
  tmp = days_in_heb_year(year);
  }
#line 331
  return (tmp % 10 == 5);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/common.c"
int short_kislev(int year ) 
{ 
  int tmp ;

  {
  {
#line 337
  tmp = days_in_heb_year(year);
  }
#line 337
  return (tmp % 10 == 3);
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 111 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/hebcal.h"
struct hsnode *getHolstorep(void) ;
#line 112
int PushHoliday(struct hsnode *hp , struct hsnode **lp ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/holidays.c"
holstorep_t holidays[14][31]  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/holidays.c"
holstorep_t var_holidays[14][31]  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/holidays.c"
holinput_t inp_holidays[41]  = 
#line 47
  {      {{7, 2, 0}, {(char *)"Rosh Hashana II", (char *)((void *)0), (char *)"\370\340\371 \344\371\360\344 \351\345\355 \341\'"},
      4U, (struct hinode *)((void *)0)}, 
        {{7, 9, 0}, {(char *)"Erev Yom Kippur", (char *)((void *)0), (char *)"\362\370\341 \351\345\355 \353\364\345\370"},
      2U, (struct hinode *)((void *)0)}, 
        {{7, 10, 0}, {(char *)"Yom Kippur", (char *)((void *)0), (char *)"\351\345\355 \353\364\345\370"},
      4U, (struct hinode *)((void *)0)}, 
        {{7, 14, 0}, {(char *)"Erev Sukkot", (char *)"Erev Sukkos", (char *)"\362\370\341 \361\345\353\345\372"},
      2U, (struct hinode *)((void *)0)}, 
        {{7, 15, 0}, {(char *)"Sukkot I", (char *)"Sukkos I", (char *)"\361\345\353\345\372 \351\345\355 \340\'"},
      8U, (struct hinode *)((void *)0)}, 
        {{7, 15, 0}, {(char *)"Sukkot I", (char *)"Sukkos I", (char *)"\361\345\353\345\372 \351\345\355 \340\'"},
      20U, (struct hinode *)((void *)0)}, 
        {{7, 16, 0}, {(char *)"Sukkot II", (char *)"Sukkos II", (char *)"\361\345\353\345\372 \351\345\355 \341\'"},
      12U, (struct hinode *)((void *)0)}, 
        {{7, 16, 0}, {(char *)"Sukkot II (CH\'\'M)", (char *)"Sukkos II (CH\'\'M)", (char *)"\361\345\353\345\372 \351\345\355 \341\' (\347\354 \344\356\345\362\343)"},
      16U, (struct hinode *)((void *)0)}, 
        {{7, 17, 0}, {(char *)"Sukkot III (CH\'\'M)", (char *)"Sukkos III (CH\'\'M)",
                   (char *)"\361\345\353\345\372 \351\345\355 \342\' (\347\354 \344\356\345\362\343)"},
      0U, (struct hinode *)((void *)0)}, 
        {{7, 18, 0}, {(char *)"Sukkot IV (CH\'\'M)", (char *)"Sukkos IV (CH\'\'M)", (char *)"\361\345\353\345\372 \351\345\355 \343\' (\347\354 \344\356\345\362\343)"},
      0U, (struct hinode *)((void *)0)}, 
        {{7, 19, 0}, {(char *)"Sukkot V (CH\'\'M)", (char *)"Sukkos V (CH\'\'M)", (char *)"\361\345\353\345\372 \351\345\355 \344\' (\347\354 \344\356\345\362\343)"},
      0U, (struct hinode *)((void *)0)}, 
        {{7, 20, 0}, {(char *)"Sukkot VI (CH\'\'M)", (char *)"Sukkos VI (CH\'\'M)", (char *)"\361\345\353\345\372 \351\345\355 \345\' (\347\354 \344\356\345\362\343)"},
      0U, (struct hinode *)((void *)0)}, 
        {{7, 21, 0}, {(char *)"Sukkot VII (Hoshana Raba)", (char *)"Sukkos VII (Hoshana Raba)",
                   (char *)"\361\345\353\345\372 \351\345\355 \346\' (\344\345\371\360\340 \370\341\344)"},
      2U, (struct hinode *)((void *)0)}, 
        {{7, 22, 0}, {(char *)"Shmini Atzeret", (char *)"Shmini Atzeres", (char *)"\371\356\351\360\351 \362\366\370\372"},
      8U, (struct hinode *)((void *)0)}, 
        {{7, 22, 0}, {(char *)"Shmini Atzeret", (char *)"Shmini Atzeres", (char *)"\371\356\351\360\351 \362\366\370\372"},
      20U, (struct hinode *)((void *)0)}, 
        {{7, 23, 0}, {(char *)"Simchat Torah", (char *)"Simchas Torah", (char *)"\371\356\347\372 \372\345\370\344"},
      12U, (struct hinode *)((void *)0)}, 
        {{9, 24, 0}, {(char *)"Chanukah: 1 Candle", (char *)((void *)0), (char *)"\347\360\345\353\344: \340\' \360\370"},
      0U, (struct hinode *)((void *)0)}, 
        {{9, 25, 0}, {(char *)"Chanukah: 2 Candles", (char *)((void *)0), (char *)"\347\360\345\353\344: \341\' \360\370\345\372"},
      0U, (struct hinode *)((void *)0)}, 
        {{9, 26, 0}, {(char *)"Chanukah: 3 Candles", (char *)((void *)0), (char *)"\347\360\345\353\344: \342\' \360\370\345\372"},
      0U, (struct hinode *)((void *)0)}, 
        {{9, 27, 0}, {(char *)"Chanukah: 4 Candles", (char *)((void *)0), (char *)"\347\360\345\353\344: \343\' \360\370\345\372"},
      0U, (struct hinode *)((void *)0)}, 
        {{9, 28, 0}, {(char *)"Chanukah: 5 Candles", (char *)((void *)0), (char *)"\347\360\345\353\344: \344\' \360\370\345\372"},
      0U, (struct hinode *)((void *)0)}, 
        {{9, 29, 0}, {(char *)"Chanukah: 6 Candles", (char *)((void *)0), (char *)"\347\360\345\353\344: \345\' \360\370\345\372"},
      0U, (struct hinode *)((void *)0)}, 
        {{11, 15, 0}, {(char *)"Tu B\'Shvat", (char *)((void *)0), (char *)"\350\"\345 \341\371\341\350"},
      0U, (struct hinode *)((void *)0)}, 
        {{1, 14, 0}, {(char *)"Erev Pesach", (char *)((void *)0), (char *)"\362\370\341 \364\361\347"},
      2U, (struct hinode *)((void *)0)}, 
        {{1, 15, 0}, {(char *)"Pesach I", (char *)((void *)0), (char *)"\364\361\347 \351\345\355 \340\'"},
      8U, (struct hinode *)((void *)0)}, 
        {{1, 15, 0}, {(char *)"Pesach I", (char *)((void *)0), (char *)"\364\361\347 \351\345\355 \340\'"},
      20U, (struct hinode *)((void *)0)}, 
        {{1, 16, 0}, {(char *)"Pesach II", (char *)((void *)0), (char *)"\364\361\347\351\345\355 \341\'"},
      12U, (struct hinode *)((void *)0)}, 
        {{1, 16, 0}, {(char *)"Pesach II (CH\'\'M)", (char *)((void *)0), (char *)"\364\361\347 \351\345\355 \341\' (\347\354 \344\356\345\362\343)"},
      16U, (struct hinode *)((void *)0)}, 
        {{1, 17, 0}, {(char *)"Pesach III (CH\'\'M)", (char *)((void *)0), (char *)"\364\361\347 \351\345\355 \342\' (\347\354 \344\356\345\362\343)"},
      0U, (struct hinode *)((void *)0)}, 
        {{1, 18, 0}, {(char *)"Pesach IV (CH\'\'M)", (char *)((void *)0), (char *)"\364\361\347 \351\345\355 \343\' (\347\354 \344\356\345\362\343)"},
      0U, (struct hinode *)((void *)0)}, 
        {{1, 19, 0}, {(char *)"Pesach V (CH\'\'M)", (char *)((void *)0), (char *)"\364\361\347 \351\345\355 \344\' (\347\354 \344\356\345\362\343)"},
      0U, (struct hinode *)((void *)0)}, 
        {{1, 20, 0}, {(char *)"Pesach VI (CH\'\'M)", (char *)((void *)0), (char *)"\364\361\347 \351\345\355 \345\' (\347\354 \344\356\345\362\343)"},
      2U, (struct hinode *)((void *)0)}, 
        {{1, 21, 0}, {(char *)"Pesach VII", (char *)((void *)0), (char *)"\364\361\347 \351\345\355 \346\'"},
      8U, (struct hinode *)((void *)0)}, 
        {{1, 21, 0}, {(char *)"Pesach VII", (char *)((void *)0), (char *)"\364\361\347 \351\345\355 \346\'"},
      20U, (struct hinode *)((void *)0)}, 
        {{1, 22, 0}, {(char *)"Pesach VIII", (char *)((void *)0), (char *)"\364\361\347 \351\345\355 \347\'"},
      12U, (struct hinode *)((void *)0)}, 
        {{2, 18, 0}, {(char *)"Lag B\'Omer", (char *)((void *)0), (char *)"\354\"\342 \341\362\345\356\370"},
      0U, (struct hinode *)((void *)0)}, 
        {{3, 5, 0}, {(char *)"Erev Shavuot", (char *)"Erev Shavuos", (char *)"\362\370\341 \371\341\345\362\345\372"},
      2U, (struct hinode *)((void *)0)}, 
        {{3, 6, 0}, {(char *)"Shavuot I", (char *)"Shavuos I", (char *)"\371\341\345\362\345\372 \351\345\355 \340\'"},
      8U, (struct hinode *)((void *)0)}, 
        {{3, 6, 0}, {(char *)"Shavuot I", (char *)"Shavuos I", (char *)"\371\341\345\362\345\372 \351\345\355 \340\'"},
      20U, (struct hinode *)((void *)0)}, 
        {{3, 7, 0}, {(char *)"Shavuot II", (char *)"Shavuos II", (char *)"\371\341\345\362\345\372 \351\345\355 \341\'"},
      12U, (struct hinode *)((void *)0)}, 
        {{6, 29, 0}, {(char *)"Erev Rosh Hashana", (char *)((void *)0), (char *)"\362\370\341 \370\340\371 \344\371\360\344"},
      2U, (struct hinode *)((void *)0)}};
#line 328 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/holidays.c"
struct variable_holiday_names var_hol_names[24]  = 
#line 328
  {      {{(char *)"Asara B\'Tevet", (char *)((void *)0), (char *)"\362\371\370\344 \341\350\341\372"}}, 
        {{(char *)"Chanukah: 7 Candles",
       (char *)((void *)0), (char *)"\347\360\345\353\344: \346\' \360\370\345\372"}}, 
        {{(char *)"Chanukah: 8 Candles",
       (char *)((void *)0), (char *)"\347\360\345\353\344: \347\' \360\370\345\372"}}, 
        {{(char *)"Chanukah: 8th Day",
       (char *)((void *)0), (char *)"\347\360\345\353\344: \351\345\355 \347\'"}}, 
        {{(char *)"Purim",
       (char *)((void *)0), (char *)"\364\345\370\351\355"}}, 
        {{(char *)"Purim Katan", (char *)"Purim Koton", (char *)"\364\345\370\351\355 \367\350\357"}}, 
        {{(char *)"Shabbat HaChodesh",
       (char *)"Shabbos HaChodesh", (char *)"\371\341\372 \344\347\343\371"}}, 
        {{(char *)"Shabbat HaGadol", (char *)"Shabbos HaGadol", (char *)"\371\341\372 \344\342\343\345\354"}}, 
        {{(char *)"Shabbat Hazon",
       (char *)"Shabbos Hazon", (char *)"\371\341\372 \344\346\345\357"}}, 
        {{(char *)"Shabbat Nachamu", (char *)"Shabbos Nachamu", (char *)"\371\341\372 \360\347\356\345"}}, 
        {{(char *)"Shabbat Parah",
       (char *)"Shabbos Parah", (char *)"\371\341\372 \364\370\344"}}, 
        {{(char *)"Shabbat Shekalim", (char *)"Shabbos Shekalim", (char *)"\371\341\372 \371\367\354\351\355"}}, 
        {{(char *)"Shabbat Shuva",
       (char *)"Shabbos Shuvah", (char *)"\371\341\372 \371\345\341\344"}}, 
        {{(char *)"Shabbat Zachor", (char *)"Shabbos Zachor", (char *)"\371\341\372 \346\353\345\370"}}, 
        {{(char *)"Shushan Purim",
       (char *)((void *)0), (char *)"\371\345\371\357 \364\345\370\351\355"}}, 
        {{(char *)"Ta\'anit Bechorot", (char *)"Ta\'anis Bechoros", (char *)"\372\362\360\351\372 \341\353\345\370\345\372"}}, 
        {{(char *)"Ta\'anit Esther",
       (char *)"Ta\'anis Esther", (char *)"\372\362\360\351\372 \340\361\372\370"}}, 
        {{(char *)"Tish\'a B\'Av",
       (char *)((void *)0), (char *)"\372\371\362\344 \341\340\341"}}, 
        {{(char *)"Tzom Gedaliah", (char *)((void *)0), (char *)"\366\345\355 \342\343\354\351\344"}}, 
        {{(char *)"Tzom Tammuz",
       (char *)((void *)0), (char *)"\366\345\355 \372\356\345\346"}}, 
        {{(char *)"Yom HaAtzma\'ut", (char *)((void *)0), (char *)"\351\345\355 \344\362\366\356\340\345\372"}}, 
        {{(char *)"Yom HaShoah",
       (char *)((void *)0), (char *)"\351\345\355 \344\371\345\340\344"}}, 
        {{(char *)"Yom HaZikaron", (char *)((void *)0), (char *)"\351\345\355 \344\346\353\370\345\357"}}, 
        {{(char *)"Yom Yerushalayim",
       (char *)((void *)0), (char *)"\351\345\355 \351\370\345\371\354\351\355"}}};
#line 359 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/holidays.c"
struct hsnode *getHolstorep(void) 
{ 
  holstorep_t tmp ;
  void *tmp___0 ;

  {
  {
#line 362
  tmp___0 = malloc(sizeof(holstore_t ));
#line 362
  tmp = (holstorep_t )tmp___0;
  }
#line 362
  if (! tmp) {
    {
#line 363
    die("Unable to allocate memory for holiday.", "");
    }
  }
#line 364
  tmp->next = (struct hsnode *)((void *)0);
#line 365
  tmp->name = (char *)((void *)0);
#line 366
  tmp->typeMask = 0U;
#line 367
  return (tmp);
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/holidays.c"
int PushHoliday(struct hsnode *hp , struct hsnode **lp ) 
{ 
  holstorep_t temp ;

  {
  {
#line 381
  temp = getHolstorep();
#line 382
  initStr(& temp->name, (size_t )100);
#line 383
  strcpy((char */* __restrict  */)temp->name, (char const   */* __restrict  */)hp->name);
#line 384
  temp->typeMask = hp->typeMask;
  }
#line 386
  if (! *lp) {
#line 387
    *lp = temp;
  } else {
#line 390
    temp->next = *lp;
#line 391
    *lp = temp;
  }
#line 393
  return ((int )temp->typeMask);
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/holidays.c"
static void load_variable_holidays(int hYear ) 
{ 
  date_t tempDt ;
  long roshHashana ;
  long passover ;
  long tishaBav ;
  long tevet10 ;
  holstorep_t tmpholp ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  long tmp___11 ;
  char *tmp___12 ;
  long tmp___13 ;
  char *tmp___14 ;
  long tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  long tmp___21 ;
  char *tmp___22 ;
  long tmp___23 ;
  char *tmp___24 ;
  long tmp___25 ;
  char *tmp___26 ;
  long tmp___27 ;
  char *tmp___28 ;
  long tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  long tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  char *tmp___39 ;
  long tmp___40 ;
  char *tmp___41 ;

  {
  {
#line 404
  tempDt.yy = hYear;
#line 405
  tempDt.mm = 7;
#line 406
  tempDt.dd = 1;
#line 407
  roshHashana = hebrew2abs(tempDt);
#line 409
  tempDt.yy = hYear;
#line 410
  tempDt.mm = 10;
#line 411
  tempDt.dd = 10;
#line 412
  tevet10 = hebrew2abs(tempDt);
#line 414
  tempDt.mm = 1;
#line 415
  tempDt.dd = 15;
#line 416
  passover = hebrew2abs(tempDt);
#line 418
  tempDt.mm = 5;
#line 419
  tempDt.dd = 9;
#line 420
  tishaBav = hebrew2abs(tempDt);
#line 422
  tmpholp = getHolstorep();
  }
#line 423
  if (iso8859_8_sw) {
#line 423
    if (var_hol_names[18].name[2]) {
#line 423
      tmpholp->name = var_hol_names[18].name[2];
    } else {
#line 423
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 423
    if (ashkenazis_sw) {
#line 423
      if (var_hol_names[18].name[1]) {
#line 423
        tmp = var_hol_names[18].name[1];
      } else {
#line 423
        tmp = var_hol_names[18].name[0];
      }
    } else {
#line 423
      tmp = var_hol_names[18].name[0];
    }
#line 423
    tmpholp->name = tmp;
  }
#line 424
  if (roshHashana % 7L == 4L) {
#line 424
    tmp___0 = 4;
  } else {
#line 424
    tmp___0 = 3;
  }
  {
#line 424
  PushHoliday(tmpholp, & var_holidays[7][tmp___0]);
#line 427
  tmpholp = getHolstorep();
  }
#line 428
  if (iso8859_8_sw) {
#line 428
    if (var_hol_names[12].name[2]) {
#line 428
      tmpholp->name = var_hol_names[12].name[2];
    } else {
#line 428
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 428
    if (ashkenazis_sw) {
#line 428
      if (var_hol_names[12].name[1]) {
#line 428
        tmp___1 = var_hol_names[12].name[1];
      } else {
#line 428
        tmp___1 = var_hol_names[12].name[0];
      }
    } else {
#line 428
      tmp___1 = var_hol_names[12].name[0];
    }
#line 428
    tmpholp->name = tmp___1;
  }
  {
#line 429
  tmp___2 = day_on_or_before(6, 7L + roshHashana);
#line 429
  tempDt = abs2hebrew(tmp___2);
#line 430
  PushHoliday(tmpholp, & var_holidays[7][tempDt.dd]);
#line 434
  tmp___9 = short_kislev(hYear);
  }
#line 434
  if (tmp___9) {
    {
#line 436
    tmpholp = getHolstorep();
    }
#line 437
    if (iso8859_8_sw) {
#line 437
      if (var_hol_names[1].name[2]) {
#line 437
        tmpholp->name = var_hol_names[1].name[2];
      } else {
#line 437
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 437
      if (ashkenazis_sw) {
#line 437
        if (var_hol_names[1].name[1]) {
#line 437
          tmp___3 = var_hol_names[1].name[1];
        } else {
#line 437
          tmp___3 = var_hol_names[1].name[0];
        }
      } else {
#line 437
        tmp___3 = var_hol_names[1].name[0];
      }
#line 437
      tmpholp->name = tmp___3;
    }
    {
#line 438
    PushHoliday(tmpholp, & var_holidays[10][1]);
#line 439
    tmpholp = getHolstorep();
    }
#line 440
    if (iso8859_8_sw) {
#line 440
      if (var_hol_names[2].name[2]) {
#line 440
        tmpholp->name = var_hol_names[2].name[2];
      } else {
#line 440
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 440
      if (ashkenazis_sw) {
#line 440
        if (var_hol_names[2].name[1]) {
#line 440
          tmp___4 = var_hol_names[2].name[1];
        } else {
#line 440
          tmp___4 = var_hol_names[2].name[0];
        }
      } else {
#line 440
        tmp___4 = var_hol_names[2].name[0];
      }
#line 440
      tmpholp->name = tmp___4;
    }
    {
#line 441
    PushHoliday(tmpholp, & var_holidays[10][2]);
#line 442
    tmpholp = getHolstorep();
    }
#line 443
    if (iso8859_8_sw) {
#line 443
      if (var_hol_names[3].name[2]) {
#line 443
        tmpholp->name = var_hol_names[3].name[2];
      } else {
#line 443
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 443
      if (ashkenazis_sw) {
#line 443
        if (var_hol_names[3].name[1]) {
#line 443
          tmp___5 = var_hol_names[3].name[1];
        } else {
#line 443
          tmp___5 = var_hol_names[3].name[0];
        }
      } else {
#line 443
        tmp___5 = var_hol_names[3].name[0];
      }
#line 443
      tmpholp->name = tmp___5;
    }
    {
#line 444
    PushHoliday(tmpholp, & var_holidays[10][3]);
    }
  } else {
    {
#line 448
    tmpholp = getHolstorep();
    }
#line 449
    if (iso8859_8_sw) {
#line 449
      if (var_hol_names[1].name[2]) {
#line 449
        tmpholp->name = var_hol_names[1].name[2];
      } else {
#line 449
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
#line 449
      if (ashkenazis_sw) {
#line 449
        if (var_hol_names[1].name[1]) {
#line 449
          tmp___6 = var_hol_names[1].name[1];
        } else {
#line 449
          tmp___6 = var_hol_names[1].name[0];
        }
      } else {
#line 449
        tmp___6 = var_hol_names[1].name[0];
      }
#line 449
      tmpholp->name = tmp___6;
    }
    {
#line 450
    PushHoliday(tmpholp, & var_holidays[9][30]);
#line 451
    tmpholp = getHolstorep();
    }
#line 452
    if (iso8859_8_sw) {
#line 452
      if (var_hol_names[2].name[2]) {
#line 452
        tmpholp->name = var_hol_names[2].name[2];
      } else {
#line 452
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
#line 452
      if (ashkenazis_sw) {
#line 452
        if (var_hol_names[2].name[1]) {
#line 452
          tmp___7 = var_hol_names[2].name[1];
        } else {
#line 452
          tmp___7 = var_hol_names[2].name[0];
        }
      } else {
#line 452
        tmp___7 = var_hol_names[2].name[0];
      }
#line 452
      tmpholp->name = tmp___7;
    }
    {
#line 453
    PushHoliday(tmpholp, & var_holidays[10][1]);
#line 454
    tmpholp = getHolstorep();
    }
#line 455
    if (iso8859_8_sw) {
#line 455
      if (var_hol_names[3].name[2]) {
#line 455
        tmpholp->name = var_hol_names[3].name[2];
      } else {
#line 455
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
#line 455
      if (ashkenazis_sw) {
#line 455
        if (var_hol_names[3].name[1]) {
#line 455
          tmp___8 = var_hol_names[3].name[1];
        } else {
#line 455
          tmp___8 = var_hol_names[3].name[0];
        }
      } else {
#line 455
        tmp___8 = var_hol_names[3].name[0];
      }
#line 455
      tmpholp->name = tmp___8;
    }
    {
#line 456
    PushHoliday(tmpholp, & var_holidays[10][2]);
    }
  }
  {
#line 459
  tmpholp = getHolstorep();
  }
#line 460
  if (iso8859_8_sw) {
#line 460
    if (var_hol_names[11].name[2]) {
#line 460
      tmpholp->name = var_hol_names[11].name[2];
    } else {
#line 460
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
#line 460
    if (ashkenazis_sw) {
#line 460
      if (var_hol_names[11].name[1]) {
#line 460
        tmp___10 = var_hol_names[11].name[1];
      } else {
#line 460
        tmp___10 = var_hol_names[11].name[0];
      }
    } else {
#line 460
      tmp___10 = var_hol_names[11].name[0];
    }
#line 460
    tmpholp->name = tmp___10;
  }
  {
#line 461
  tmp___11 = day_on_or_before(6, passover - 43L);
#line 461
  tempDt = abs2hebrew(tmp___11);
#line 462
  PushHoliday(tmpholp, & var_holidays[tempDt.mm][tempDt.dd]);
#line 464
  tmpholp = getHolstorep();
  }
#line 465
  if (iso8859_8_sw) {
#line 465
    if (var_hol_names[13].name[2]) {
#line 465
      tmpholp->name = var_hol_names[13].name[2];
    } else {
#line 465
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ 
#line 465
    if (ashkenazis_sw) {
#line 465
      if (var_hol_names[13].name[1]) {
#line 465
        tmp___12 = var_hol_names[13].name[1];
      } else {
#line 465
        tmp___12 = var_hol_names[13].name[0];
      }
    } else {
#line 465
      tmp___12 = var_hol_names[13].name[0];
    }
#line 465
    tmpholp->name = tmp___12;
  }
  {
#line 466
  tmp___13 = day_on_or_before(6, passover - 30L);
#line 466
  tempDt = abs2hebrew(tmp___13);
#line 467
  PushHoliday(tmpholp, & var_holidays[tempDt.mm][tempDt.dd]);
#line 469
  tmpholp = getHolstorep();
  }
#line 470
  if (iso8859_8_sw) {
#line 470
    if (var_hol_names[16].name[2]) {
#line 470
      tmpholp->name = var_hol_names[16].name[2];
    } else {
#line 470
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ 
#line 470
    if (ashkenazis_sw) {
#line 470
      if (var_hol_names[16].name[1]) {
#line 470
        tmp___14 = var_hol_names[16].name[1];
      } else {
#line 470
        tmp___14 = var_hol_names[16].name[0];
      }
    } else {
#line 470
      tmp___14 = var_hol_names[16].name[0];
    }
#line 470
    tmpholp->name = tmp___14;
  }
#line 471
  if (passover % 7L == 2L) {
#line 471
    tmp___15 = 33L;
  } else {
#line 471
    tmp___15 = 31L;
  }
  {
#line 471
  tempDt = abs2hebrew(passover - tmp___15);
#line 472
  PushHoliday(tmpholp, & var_holidays[tempDt.mm][tempDt.dd]);
  }
#line 474
  if ((1L + (long )hYear * 7L) % 19L < 7L) {
#line 474
    tmp___19 = 1;
  } else {
#line 474
    tmp___19 = 0;
  }
#line 474
  if (tmp___19) {
    {
#line 476
    tmpholp = getHolstorep();
    }
#line 477
    if (iso8859_8_sw) {
#line 477
      if (var_hol_names[5].name[2]) {
#line 477
        tmpholp->name = var_hol_names[5].name[2];
      } else {
#line 477
        goto _L___10;
      }
    } else {
      _L___10: /* CIL Label */ 
#line 477
      if (ashkenazis_sw) {
#line 477
        if (var_hol_names[5].name[1]) {
#line 477
          tmp___16 = var_hol_names[5].name[1];
        } else {
#line 477
          tmp___16 = var_hol_names[5].name[0];
        }
      } else {
#line 477
        tmp___16 = var_hol_names[5].name[0];
      }
#line 477
      tmpholp->name = tmp___16;
    }
    {
#line 478
    PushHoliday(tmpholp, & var_holidays[12][14]);
#line 480
    tmpholp = getHolstorep();
    }
#line 481
    if (iso8859_8_sw) {
#line 481
      if (var_hol_names[4].name[2]) {
#line 481
        tmpholp->name = var_hol_names[4].name[2];
      } else {
#line 481
        goto _L___11;
      }
    } else {
      _L___11: /* CIL Label */ 
#line 481
      if (ashkenazis_sw) {
#line 481
        if (var_hol_names[4].name[1]) {
#line 481
          tmp___17 = var_hol_names[4].name[1];
        } else {
#line 481
          tmp___17 = var_hol_names[4].name[0];
        }
      } else {
#line 481
        tmp___17 = var_hol_names[4].name[0];
      }
#line 481
      tmpholp->name = tmp___17;
    }
    {
#line 482
    PushHoliday(tmpholp, & var_holidays[13][14]);
    }
  } else {
    {
#line 486
    tmpholp = getHolstorep();
    }
#line 487
    if (iso8859_8_sw) {
#line 487
      if (var_hol_names[4].name[2]) {
#line 487
        tmpholp->name = var_hol_names[4].name[2];
      } else {
#line 487
        goto _L___12;
      }
    } else {
      _L___12: /* CIL Label */ 
#line 487
      if (ashkenazis_sw) {
#line 487
        if (var_hol_names[4].name[1]) {
#line 487
          tmp___18 = var_hol_names[4].name[1];
        } else {
#line 487
          tmp___18 = var_hol_names[4].name[0];
        }
      } else {
#line 487
        tmp___18 = var_hol_names[4].name[0];
      }
#line 487
      tmpholp->name = tmp___18;
    }
    {
#line 488
    PushHoliday(tmpholp, & var_holidays[12][14]);
    }
  }
  {
#line 491
  tmpholp = getHolstorep();
  }
#line 492
  if (iso8859_8_sw) {
#line 492
    if (var_hol_names[14].name[2]) {
#line 492
      tmpholp->name = var_hol_names[14].name[2];
    } else {
#line 492
      goto _L___13;
    }
  } else {
    _L___13: /* CIL Label */ 
#line 492
    if (ashkenazis_sw) {
#line 492
      if (var_hol_names[14].name[1]) {
#line 492
        tmp___20 = var_hol_names[14].name[1];
      } else {
#line 492
        tmp___20 = var_hol_names[14].name[0];
      }
    } else {
#line 492
      tmp___20 = var_hol_names[14].name[0];
    }
#line 492
    tmpholp->name = tmp___20;
  }
#line 493
  if (passover % 7L == 0L) {
#line 493
    tmp___21 = 28L;
  } else {
#line 493
    tmp___21 = 29L;
  }
  {
#line 493
  tempDt = abs2hebrew(passover - tmp___21);
#line 494
  PushHoliday(tmpholp, & var_holidays[tempDt.mm][tempDt.dd]);
#line 496
  tmpholp = getHolstorep();
  }
#line 497
  if (iso8859_8_sw) {
#line 497
    if (var_hol_names[10].name[2]) {
#line 497
      tmpholp->name = var_hol_names[10].name[2];
    } else {
#line 497
      goto _L___14;
    }
  } else {
    _L___14: /* CIL Label */ 
#line 497
    if (ashkenazis_sw) {
#line 497
      if (var_hol_names[10].name[1]) {
#line 497
        tmp___22 = var_hol_names[10].name[1];
      } else {
#line 497
        tmp___22 = var_hol_names[10].name[0];
      }
    } else {
#line 497
      tmp___22 = var_hol_names[10].name[0];
    }
#line 497
    tmpholp->name = tmp___22;
  }
  {
#line 498
  tmp___23 = day_on_or_before(6, passover - 14L);
#line 498
  tempDt = abs2hebrew(tmp___23 - 7L);
#line 499
  PushHoliday(tmpholp, & var_holidays[tempDt.mm][tempDt.dd]);
#line 501
  tmpholp = getHolstorep();
  }
#line 502
  if (iso8859_8_sw) {
#line 502
    if (var_hol_names[6].name[2]) {
#line 502
      tmpholp->name = var_hol_names[6].name[2];
    } else {
#line 502
      goto _L___15;
    }
  } else {
    _L___15: /* CIL Label */ 
#line 502
    if (ashkenazis_sw) {
#line 502
      if (var_hol_names[6].name[1]) {
#line 502
        tmp___24 = var_hol_names[6].name[1];
      } else {
#line 502
        tmp___24 = var_hol_names[6].name[0];
      }
    } else {
#line 502
      tmp___24 = var_hol_names[6].name[0];
    }
#line 502
    tmpholp->name = tmp___24;
  }
  {
#line 503
  tmp___25 = day_on_or_before(6, passover - 14L);
#line 503
  tempDt = abs2hebrew(tmp___25);
#line 504
  PushHoliday(tmpholp, & var_holidays[tempDt.mm][tempDt.dd]);
#line 506
  tmpholp = getHolstorep();
  }
#line 507
  if (iso8859_8_sw) {
#line 507
    if (var_hol_names[15].name[2]) {
#line 507
      tmpholp->name = var_hol_names[15].name[2];
    } else {
#line 507
      goto _L___16;
    }
  } else {
    _L___16: /* CIL Label */ 
#line 507
    if (ashkenazis_sw) {
#line 507
      if (var_hol_names[15].name[1]) {
#line 507
        tmp___26 = var_hol_names[15].name[1];
      } else {
#line 507
        tmp___26 = var_hol_names[15].name[0];
      }
    } else {
#line 507
      tmp___26 = var_hol_names[15].name[0];
    }
#line 507
    tmpholp->name = tmp___26;
  }
#line 508
  if ((passover - 1L) % 7L >= 5L) {
    {
#line 510
    tmp___27 = day_on_or_before(4, passover);
#line 510
    tempDt = abs2hebrew(tmp___27);
#line 511
    PushHoliday(tmpholp, & var_holidays[tempDt.mm][tempDt.dd]);
    }
  } else {
    {
#line 514
    PushHoliday(tmpholp, & var_holidays[1][14]);
    }
  }
  {
#line 517
  tmpholp = getHolstorep();
  }
#line 518
  if (iso8859_8_sw) {
#line 518
    if (var_hol_names[7].name[2]) {
#line 518
      tmpholp->name = var_hol_names[7].name[2];
    } else {
#line 518
      goto _L___17;
    }
  } else {
    _L___17: /* CIL Label */ 
#line 518
    if (ashkenazis_sw) {
#line 518
      if (var_hol_names[7].name[1]) {
#line 518
        tmp___28 = var_hol_names[7].name[1];
      } else {
#line 518
        tmp___28 = var_hol_names[7].name[0];
      }
    } else {
#line 518
      tmp___28 = var_hol_names[7].name[0];
    }
#line 518
    tmpholp->name = tmp___28;
  }
  {
#line 519
  tmp___29 = day_on_or_before(6, passover - 1L);
#line 519
  tempDt = abs2hebrew(tmp___29);
#line 520
  PushHoliday(tmpholp, & var_holidays[tempDt.mm][tempDt.dd]);
  }
#line 522
  if (hYear > 5698) {
    {
#line 524
    tmpholp = getHolstorep();
    }
#line 525
    if (iso8859_8_sw) {
#line 525
      if (var_hol_names[21].name[2]) {
#line 525
        tmpholp->name = var_hol_names[21].name[2];
      } else {
#line 525
        goto _L___18;
      }
    } else {
      _L___18: /* CIL Label */ 
#line 525
      if (ashkenazis_sw) {
#line 525
        if (var_hol_names[21].name[1]) {
#line 525
          tmp___30 = var_hol_names[21].name[1];
        } else {
#line 525
          tmp___30 = var_hol_names[21].name[0];
        }
      } else {
#line 525
        tmp___30 = var_hol_names[21].name[0];
      }
#line 525
      tmpholp->name = tmp___30;
    }
    {
#line 526
    PushHoliday(tmpholp, & var_holidays[1][27]);
#line 528
    tmpholp = getHolstorep();
    }
#line 529
    if (iso8859_8_sw) {
#line 529
      if (var_hol_names[22].name[2]) {
#line 529
        tmpholp->name = var_hol_names[22].name[2];
      } else {
#line 529
        goto _L___19;
      }
    } else {
      _L___19: /* CIL Label */ 
#line 529
      if (ashkenazis_sw) {
#line 529
        if (var_hol_names[22].name[1]) {
#line 529
          tmp___31 = var_hol_names[22].name[1];
        } else {
#line 529
          tmp___31 = var_hol_names[22].name[0];
        }
      } else {
#line 529
        tmp___31 = var_hol_names[22].name[0];
      }
#line 529
      tmpholp->name = tmp___31;
    }
#line 530
    if (passover % 7L == 0L) {
#line 531
      tempDt.dd = 3;
    } else
#line 532
    if (passover % 7L == 6L) {
#line 533
      tempDt.dd = 4;
    } else {
#line 535
      tempDt.dd = 5;
    }
    {
#line 536
    PushHoliday(tmpholp, & var_holidays[2][tempDt.dd - 1]);
    }
  }
#line 539
  if (hYear > 5708) {
    {
#line 541
    tmpholp = getHolstorep();
    }
#line 542
    if (iso8859_8_sw) {
#line 542
      if (var_hol_names[20].name[2]) {
#line 542
        tmpholp->name = var_hol_names[20].name[2];
      } else {
#line 542
        goto _L___20;
      }
    } else {
      _L___20: /* CIL Label */ 
#line 542
      if (ashkenazis_sw) {
#line 542
        if (var_hol_names[20].name[1]) {
#line 542
          tmp___32 = var_hol_names[20].name[1];
        } else {
#line 542
          tmp___32 = var_hol_names[20].name[0];
        }
      } else {
#line 542
        tmp___32 = var_hol_names[20].name[0];
      }
#line 542
      tmpholp->name = tmp___32;
    }
#line 543
    if (passover % 7L == 0L) {
#line 544
      tempDt.dd = 3;
    } else
#line 545
    if (passover % 7L == 6L) {
#line 546
      tempDt.dd = 4;
    } else {
#line 548
      tempDt.dd = 5;
    }
    {
#line 549
    PushHoliday(tmpholp, & var_holidays[2][tempDt.dd]);
    }
  }
#line 552
  if (hYear > 5727) {
    {
#line 554
    tmpholp = getHolstorep();
    }
#line 555
    if (iso8859_8_sw) {
#line 555
      if (var_hol_names[23].name[2]) {
#line 555
        tmpholp->name = var_hol_names[23].name[2];
      } else {
#line 555
        goto _L___21;
      }
    } else {
      _L___21: /* CIL Label */ 
#line 555
      if (ashkenazis_sw) {
#line 555
        if (var_hol_names[23].name[1]) {
#line 555
          tmp___33 = var_hol_names[23].name[1];
        } else {
#line 555
          tmp___33 = var_hol_names[23].name[0];
        }
      } else {
#line 555
        tmp___33 = var_hol_names[23].name[0];
      }
#line 555
      tmpholp->name = tmp___33;
    }
    {
#line 556
    PushHoliday(tmpholp, & var_holidays[2][28]);
    }
  }
  {
#line 559
  tmpholp = getHolstorep();
  }
#line 560
  if (iso8859_8_sw) {
#line 560
    if (var_hol_names[19].name[2]) {
#line 560
      tmpholp->name = var_hol_names[19].name[2];
    } else {
#line 560
      goto _L___22;
    }
  } else {
    _L___22: /* CIL Label */ 
#line 560
    if (ashkenazis_sw) {
#line 560
      if (var_hol_names[19].name[1]) {
#line 560
        tmp___34 = var_hol_names[19].name[1];
      } else {
#line 560
        tmp___34 = var_hol_names[19].name[0];
      }
    } else {
#line 560
      tmp___34 = var_hol_names[19].name[0];
    }
#line 560
    tmpholp->name = tmp___34;
  }
#line 561
  if (tishaBav % 7L == 6L) {
    {
#line 562
    tempDt = abs2hebrew(tishaBav - 20L);
    }
  } else {
    {
#line 564
    tempDt = abs2hebrew(tishaBav - 21L);
    }
  }
  {
#line 565
  PushHoliday(tmpholp, & var_holidays[tempDt.mm][tempDt.dd]);
#line 567
  tmpholp = getHolstorep();
  }
#line 568
  if (iso8859_8_sw) {
#line 568
    if (var_hol_names[8].name[2]) {
#line 568
      tmpholp->name = var_hol_names[8].name[2];
    } else {
#line 568
      goto _L___23;
    }
  } else {
    _L___23: /* CIL Label */ 
#line 568
    if (ashkenazis_sw) {
#line 568
      if (var_hol_names[8].name[1]) {
#line 568
        tmp___35 = var_hol_names[8].name[1];
      } else {
#line 568
        tmp___35 = var_hol_names[8].name[0];
      }
    } else {
#line 568
      tmp___35 = var_hol_names[8].name[0];
    }
#line 568
    tmpholp->name = tmp___35;
  }
  {
#line 569
  tmp___36 = day_on_or_before(6, tishaBav);
#line 569
  tempDt = abs2hebrew(tmp___36);
#line 570
  PushHoliday(tmpholp, & var_holidays[tempDt.mm][tempDt.dd]);
#line 572
  tmpholp = getHolstorep();
  }
#line 573
  if (iso8859_8_sw) {
#line 573
    if (var_hol_names[17].name[2]) {
#line 573
      tmpholp->name = var_hol_names[17].name[2];
    } else {
#line 573
      goto _L___24;
    }
  } else {
    _L___24: /* CIL Label */ 
#line 573
    if (ashkenazis_sw) {
#line 573
      if (var_hol_names[17].name[1]) {
#line 573
        tmp___37 = var_hol_names[17].name[1];
      } else {
#line 573
        tmp___37 = var_hol_names[17].name[0];
      }
    } else {
#line 573
      tmp___37 = var_hol_names[17].name[0];
    }
#line 573
    tmpholp->name = tmp___37;
  }
#line 574
  if (tishaBav % 7L == 6L) {
#line 574
    tmp___38 = 10;
  } else {
#line 574
    tmp___38 = 9;
  }
  {
#line 574
  PushHoliday(tmpholp, & var_holidays[5][tmp___38]);
#line 577
  tmpholp = getHolstorep();
  }
#line 578
  if (iso8859_8_sw) {
#line 578
    if (var_hol_names[9].name[2]) {
#line 578
      tmpholp->name = var_hol_names[9].name[2];
    } else {
#line 578
      goto _L___25;
    }
  } else {
    _L___25: /* CIL Label */ 
#line 578
    if (ashkenazis_sw) {
#line 578
      if (var_hol_names[9].name[1]) {
#line 578
        tmp___39 = var_hol_names[9].name[1];
      } else {
#line 578
        tmp___39 = var_hol_names[9].name[0];
      }
    } else {
#line 578
      tmp___39 = var_hol_names[9].name[0];
    }
#line 578
    tmpholp->name = tmp___39;
  }
  {
#line 579
  tmp___40 = day_on_or_before(6, tishaBav + 7L);
#line 579
  tempDt = abs2hebrew(tmp___40);
#line 580
  PushHoliday(tmpholp, & var_holidays[tempDt.mm][tempDt.dd]);
#line 582
  tmpholp = getHolstorep();
  }
#line 583
  if (iso8859_8_sw) {
#line 583
    if (var_hol_names[0].name[2]) {
#line 583
      tmpholp->name = var_hol_names[0].name[2];
    } else {
#line 583
      goto _L___26;
    }
  } else {
    _L___26: /* CIL Label */ 
#line 583
    if (ashkenazis_sw) {
#line 583
      if (var_hol_names[0].name[1]) {
#line 583
        tmp___41 = var_hol_names[0].name[1];
      } else {
#line 583
        tmp___41 = var_hol_names[0].name[0];
      }
    } else {
#line 583
      tmp___41 = var_hol_names[0].name[0];
    }
#line 583
    tmpholp->name = tmp___41;
  }
#line 584
  if (tevet10 % 7L == 6L) {
    {
#line 585
    PushHoliday(tmpholp, & var_holidays[10][11]);
    }
  } else {
    {
#line 587
    PushHoliday(tmpholp, & var_holidays[10][10]);
    }
  }
#line 589
  return;
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/holidays.c"
void init_user_holidays(int hyear ) 
{ 
  holstorep_t tmpholp ;
  char *s ;
  char *monthStr ;
  char *eventStr ;
  char nextChar ;
  int index___0 ;
  int inMonth ;
  int inDay ;
  int lineNum ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;

  {
  {
#line 604
  lineNum = 1;
#line 606
  initStr(& s, (size_t )100);
#line 607
  initStr(& monthStr, (size_t )100);
#line 608
  rewind(inFile);
#line 609
  tmp = _IO_getc(inFile);
#line 609
  nextChar = (char )tmp;
  }
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 610
    tmp___12 = feof(inFile);
    }
#line 610
    if (tmp___12) {
#line 610
      goto while_break;
    }
    {
#line 613
    ungetc((int )nextChar, inFile);
#line 614
    tmp___2 = fgets((char */* __restrict  */)s, 100, (FILE */* __restrict  */)inFile);
    }
#line 614
    if (! tmp___2) {
      {
#line 616
      tmp___1 = hc_itoa(lineNum);
#line 616
      warn("input file read error. Skipping line %s", (char const   *)tmp___1);
      }
#line 617
      goto __Cont;
    }
#line 619
    if ((int )*(s + 0) == 10) {
#line 620
      goto __Cont;
    }
    {
#line 621
    tmp___4 = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%s %d%n",
                     monthStr, & inDay, & index___0);
    }
#line 621
    if (! tmp___4) {
      {
#line 623
      tmp___3 = hc_itoa(lineNum);
#line 623
      warn("Error in input file.  Skipping line %s", (char const   *)tmp___3);
      }
#line 624
      goto __Cont;
    }
    {
#line 626
    tmp___6 = isAllNums((char const   *)monthStr);
    }
#line 626
    if (tmp___6) {
      {
#line 628
      tmp___5 = hc_itoa(lineNum);
#line 628
      warn("Numeric hebrew month in input file.  Skipping line %s", (char const   *)tmp___5);
      }
#line 630
      goto __Cont;
    }
    {
#line 632
    inMonth = lookup_hebrew_month((char const   *)monthStr);
    }
#line 632
    if (! inMonth) {
      {
#line 634
      tmp___7 = hc_itoa(lineNum);
#line 634
      warn("Unrecognized hebrew month in input file.  Skipping line %s", (char const   *)tmp___7);
      }
#line 636
      goto __Cont;
    }
#line 638
    if (inDay < 1) {
      {
#line 640
      tmp___8 = hc_itoa(lineNum);
#line 640
      warn("Date out of range in input file. Skipping line %s", (char const   *)tmp___8);
      }
#line 642
      goto __Cont;
    } else
#line 638
    if (inDay > 30) {
      {
#line 640
      tmp___8 = hc_itoa(lineNum);
#line 640
      warn("Date out of range in input file. Skipping line %s", (char const   *)tmp___8);
      }
#line 642
      goto __Cont;
    }
#line 645
    if (inMonth == 13) {
#line 645
      if ((1L + (long )hyear * 7L) % 19L < 7L) {
#line 645
        tmp___9 = 1;
      } else {
#line 645
        tmp___9 = 0;
      }
#line 645
      if (! tmp___9) {
#line 646
        inMonth = 12;
      }
    }
    {
#line 648
    eventStr = (s + index___0) + 1;
#line 649
    tmp___11 = strlen((char const   *)eventStr);
    }
#line 649
    if ((int )*(eventStr + (tmp___11 - 1UL)) == 10) {
      {
#line 650
      tmp___10 = strlen((char const   *)eventStr);
#line 650
      *(eventStr + (tmp___10 - 1UL)) = (char )'\000';
      }
    }
    {
#line 653
    tmpholp = getHolstorep();
#line 654
    initStr(& tmpholp->name, (size_t )100);
#line 655
    strcpy((char */* __restrict  */)tmpholp->name, (char const   */* __restrict  */)eventStr);
#line 656
    tmpholp->typeMask = 1U;
#line 657
    PushHoliday(tmpholp, & var_holidays[inMonth][inDay]);
    }
    __Cont: /* CIL Label */ 
    {
#line 610
    lineNum ++;
#line 610
    tmp___0 = _IO_getc(inFile);
#line 610
    nextChar = (char )tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 660
  return;
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/holidays.c"
void init_yahrtzeits(int hyear ) 
{ 
  holstorep_t tmpholp ;
  char *s ;
  char *monthStr ;
  char *eventStr ;
  char nextChar ;
  int index___0 ;
  int inMonth ;
  int inDay ;
  int inYear ;
  int lineNum ;
  date_t hDeath ;
  date_t gDeath ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;

  {
  {
#line 673
  lineNum = 1;
#line 676
  initStr(& s, (size_t )100);
#line 677
  initStr(& monthStr, (size_t )100);
#line 678
  rewind(yFile);
#line 679
  tmp = _IO_getc(yFile);
#line 679
  nextChar = (char )tmp;
  }
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 680
    tmp___18 = feof(yFile);
    }
#line 680
    if (tmp___18) {
#line 680
      goto while_break;
    }
    {
#line 683
    ungetc((int )nextChar, yFile);
#line 684
    tmp___2 = fgets((char */* __restrict  */)s, 100, (FILE */* __restrict  */)yFile);
    }
#line 684
    if (! tmp___2) {
      {
#line 686
      tmp___1 = hc_itoa(lineNum);
#line 686
      warn("yahrtzeit file read error. Skipping line %s", (char const   *)tmp___1);
      }
#line 687
      goto __Cont;
    }
#line 689
    if ((int )*(s + 0) == 10) {
#line 690
      goto __Cont;
    }
    {
#line 691
    tmp___4 = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%s %d %d%n",
                     monthStr, & inDay, & inYear, & index___0);
    }
#line 691
    if (tmp___4 < 3) {
      {
#line 693
      tmp___3 = hc_itoa(lineNum);
#line 693
      warn("Error in yahrtzeit file.  Skipping line %s", (char const   *)tmp___3);
      }
#line 694
      goto __Cont;
    }
    {
#line 696
    tmp___6 = isAllNums((char const   *)monthStr);
    }
#line 696
    if (! tmp___6) {
      {
#line 698
      tmp___5 = hc_itoa(lineNum);
#line 698
      warn("Non-numeric month in yahrtzeit file. Skipping line %s", (char const   *)tmp___5);
      }
#line 700
      goto __Cont;
    }
    {
#line 702
    sscanf((char const   */* __restrict  */)monthStr, (char const   */* __restrict  */)"%d",
           & inMonth);
    }
#line 704
    if (inMonth > 12) {
      {
#line 708
      tmp___7 = hc_itoa(lineNum);
#line 708
      warn("Date out of range in yahrtzeit file. Skipping line %s", (char const   *)tmp___7);
      }
#line 710
      goto __Cont;
    } else
#line 704
    if (inMonth < 1) {
      {
#line 708
      tmp___7 = hc_itoa(lineNum);
#line 708
      warn("Date out of range in yahrtzeit file. Skipping line %s", (char const   *)tmp___7);
      }
#line 710
      goto __Cont;
    } else
#line 704
    if (inDay < 1) {
      {
#line 708
      tmp___7 = hc_itoa(lineNum);
#line 708
      warn("Date out of range in yahrtzeit file. Skipping line %s", (char const   *)tmp___7);
      }
#line 710
      goto __Cont;
    } else {
#line 704
      if (! (inYear % 4)) {
#line 704
        if (inYear % 100) {
#line 704
          tmp___8 = 1;
        } else
#line 704
        if (! (inYear % 400)) {
#line 704
          tmp___8 = 1;
        } else {
#line 704
          tmp___8 = 0;
        }
      } else {
#line 704
        tmp___8 = 0;
      }
#line 704
      if (inDay > MonthLengths[tmp___8][inMonth]) {
        {
#line 708
        tmp___7 = hc_itoa(lineNum);
#line 708
        warn("Date out of range in yahrtzeit file. Skipping line %s", (char const   *)tmp___7);
        }
#line 710
        goto __Cont;
      }
    }
    {
#line 713
    gDeath.dd = inDay;
#line 714
    gDeath.mm = inMonth;
#line 715
    gDeath.yy = inYear;
#line 717
    tmp___9 = greg2abs(gDeath);
#line 717
    hDeath = abs2hebrew(tmp___9);
    }
#line 722
    if (hDeath.mm == 8) {
#line 722
      if (hDeath.dd == 30) {
        {
#line 722
        tmp___16 = long_cheshvan(hDeath.yy + 1);
        }
#line 722
        if (tmp___16) {
#line 722
          goto _L___2;
        } else {
          {
#line 725
          hDeath.dd = 1;
#line 726
          hDeath.mm = 9;
#line 727
          hDeath.yy = hyear;
#line 728
          tmp___10 = hebrew2abs(hDeath);
#line 728
          hDeath = abs2hebrew(tmp___10 - 1L);
          }
        }
      } else {
#line 722
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 732
    if (hDeath.mm == 9) {
#line 732
      if (hDeath.dd == 30) {
        {
#line 732
        tmp___15 = short_kislev(hDeath.yy + 1);
        }
#line 732
        if (tmp___15) {
#line 732
          goto _L___0;
        } else {
          {
#line 735
          hDeath.dd = 1;
#line 736
          hDeath.mm = 10;
#line 737
          hDeath.yy = hyear;
#line 738
          tmp___11 = hebrew2abs(hDeath);
#line 738
          hDeath = abs2hebrew(tmp___11 - 1L);
          }
        }
      } else {
#line 732
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 742
    if (hDeath.mm == 13) {
#line 744
      if ((1L + (long )hyear * 7L) % 19L < 7L) {
#line 744
        tmp___13 = 1;
      } else {
#line 744
        tmp___13 = 0;
      }
#line 744
      if (tmp___13) {
#line 744
        hDeath.mm = 13;
      } else {
#line 744
        hDeath.mm = 12;
      }
    } else
#line 748
    if (hDeath.mm == 12) {
#line 748
      if (hDeath.dd == 30) {
#line 748
        if ((1L + (long )hyear * 7L) % 19L < 7L) {
#line 748
          tmp___14 = 1;
        } else {
#line 748
          tmp___14 = 0;
        }
#line 748
        if (! tmp___14) {
#line 751
          hDeath.dd = 30;
#line 752
          hDeath.mm = 11;
        }
      }
    }
    {
#line 756
    eventStr = (s + index___0) + 1;
#line 758
    tmp___17 = strlen((char const   *)eventStr);
#line 758
    *(eventStr + (tmp___17 - 1UL)) = (char )'\000';
#line 761
    tmpholp = getHolstorep();
#line 762
    initStr(& tmpholp->name, (size_t )100);
#line 763
    strcpy((char */* __restrict  */)tmpholp->name, (char const   */* __restrict  */)eventStr);
#line 764
    tmpholp->typeMask = 1U;
#line 765
    PushHoliday(tmpholp, & var_holidays[hDeath.mm][hDeath.dd]);
    }
    __Cont: /* CIL Label */ 
    {
#line 680
    lineNum ++;
#line 680
    tmp___0 = _IO_getc(yFile);
#line 680
    nextChar = (char )tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 768
  return;
}
}
#line 782 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/holidays.c"
static int first  =    1;
#line 774 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/holidays.c"
void init_holidays(int hYear ) 
{ 
  int d ;
  int m ;
  holstorep_t tmpholp ;
  holstorep_t tmpholp2 ;
  holinputp_t todayinp ;
  char *tmp ;

  {
#line 784
  if (first) {
#line 786
    m = 0;
#line 786
    todayinp = inp_holidays;
    {
#line 786
    while (1) {
      while_continue: /* CIL Label */ ;
#line 786
      if (! ((unsigned long )m < sizeof(inp_holidays) / sizeof(inp_holidays[0]))) {
#line 786
        goto while_break;
      }
#line 790
      if (! (todayinp->typeMask & 24U)) {
#line 790
        goto _L___0;
      } else
#line 790
      if (todayinp->typeMask & 16U) {
#line 790
        if (israel_sw) {
#line 790
          goto _L___0;
        } else {
#line 790
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 790
      if (todayinp->typeMask & 8U) {
#line 790
        if (! israel_sw) {
          _L___0: /* CIL Label */ 
          {
#line 793
          tmpholp = getHolstorep();
#line 794
          tmpholp->typeMask = todayinp->typeMask;
          }
#line 795
          if (iso8859_8_sw) {
#line 795
            if (todayinp->name[2]) {
#line 795
              tmpholp->name = todayinp->name[2];
            } else {
#line 795
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 795
            if (ashkenazis_sw) {
#line 795
              if (todayinp->name[1]) {
#line 795
                tmp = todayinp->name[1];
              } else {
#line 795
                tmp = todayinp->name[0];
              }
            } else {
#line 795
              tmp = todayinp->name[0];
            }
#line 795
            tmpholp->name = tmp;
          }
          {
#line 796
          PushHoliday(tmpholp, & holidays[todayinp->date.mm][todayinp->date.dd]);
          }
        }
      }
#line 786
      m ++;
#line 786
      todayinp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 799
    first = 0;
  } else {
#line 803
    m = 0;
    {
#line 803
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 803
      if (! (m <= 13)) {
#line 803
        goto while_break___0;
      }
#line 805
      d = 0;
      {
#line 805
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 805
        if (! (d <= 30)) {
#line 805
          goto while_break___1;
        }
#line 807
        tmpholp = var_holidays[m][d];
        {
#line 808
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 808
          if (! ((unsigned long )tmpholp != (unsigned long )((void *)0))) {
#line 808
            goto while_break___2;
          }
          {
#line 810
          tmpholp2 = tmpholp;
#line 811
          tmpholp = tmpholp->next;
#line 812
          free((void *)tmpholp2);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 814
        var_holidays[m][d] = (holstorep_t )((void *)0);
#line 805
        d ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 803
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 819
  load_variable_holidays(hYear);
  }
#line 821
  if (inputFile_sw) {
    {
#line 822
    init_user_holidays(hYear);
    }
  }
#line 823
  if (yahrtzeitFile_sw) {
    {
#line 824
    init_yahrtzeits(hYear);
    }
  }
#line 825
  return;
}
}
#line 830 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/holidays.c"
void freeHolidays(holstorep_t *holiList ) 
{ 
  holstorep_t next ;
  holstorep_t cur ;

  {
#line 833
  cur = *holiList;
  {
#line 834
  while (1) {
    while_continue: /* CIL Label */ ;
#line 834
    if (! cur) {
#line 834
      goto while_break;
    }
    {
#line 835
    next = cur->next;
#line 836
    free((void *)cur->name);
#line 837
    free((void *)cur);
#line 838
    cur = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 841
  *holiList = (holstorep_t )((void *)0);
#line 842
  return;
}
}
#line 847 "/home/june/repo/benchmarks/collector/temp/hebcal-3.5/holidays.c"
int getHebHolidays(date_t dth , struct hsnode **holiList ) 
{ 
  int tmpMask ;
  holstorep_t tmpholip ;
  holstorep_t chp ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___16 ;
  int tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  int tmp___21 ;
  char const   *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
#line 852
  tmpMask = 0;
#line 853
  *holiList = (struct hsnode *)((void *)0);
#line 855
  chp = holidays[dth.mm][dth.dd];
  {
#line 855
  while (1) {
    while_continue: /* CIL Label */ ;
#line 855
    if (! chp) {
#line 855
      goto while_break;
    }
    {
#line 859
    tmp = PushHoliday(chp, holiList);
#line 859
    tmpMask |= tmp;
#line 855
    chp = chp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 861
  chp = var_holidays[dth.mm][dth.dd];
  {
#line 861
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 861
    if (! chp) {
#line 861
      goto while_break___0;
    }
    {
#line 865
    tmp___0 = PushHoliday(chp, holiList);
#line 865
    tmpMask |= tmp___0;
#line 861
    chp = chp->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 868
  if (dth.dd == 1) {
#line 871
    if (dth.mm == 7) {
      {
#line 873
      tmpholip = getHolstorep();
#line 874
      initStr(& tmpholip->name, (size_t )22);
      }
#line 875
      if (iso8859_8_sw) {
#line 875
        tmp___1 = "\370\340\371 \344\371\360\344";
      } else {
#line 875
        tmp___1 = "Rosh Hashana";
      }
      {
#line 875
      sprintf((char */* __restrict  */)tmpholip->name, (char const   */* __restrict  */)"%s %d",
              tmp___1, dth.yy);
#line 879
      PushHoliday(tmpholip, & var_holidays[7][1]);
#line 880
      tmp___2 = PushHoliday(tmpholip, holiList);
#line 880
      tmpMask |= tmp___2;
      }
    } else
#line 884
    if (! suppress_rosh_chodesh_sw) {
      {
#line 886
      tmpholip = getHolstorep();
#line 887
      initStr(& tmpholip->name, (size_t )60);
      }
#line 888
      if (iso8859_8_sw) {
#line 888
        tmp___3 = "\370\340\371 \347\343\371 ";
      } else {
#line 888
        tmp___3 = "Rosh Chodesh ";
      }
      {
#line 888
      strcat((char */* __restrict  */)tmpholip->name, (char const   */* __restrict  */)tmp___3);
      }
#line 891
      if (! tabs_sw) {
#line 893
        if (iso8859_8_sw) {
#line 893
          if ((1L + (long )dth.yy * 7L) % 19L < 7L) {
#line 893
            tmp___12 = 1;
          } else {
#line 893
            tmp___12 = 0;
          }
#line 893
          if (hMonths[tmp___12][dth.mm].name[2]) {
#line 893
            if ((1L + (long )dth.yy * 7L) % 19L < 7L) {
#line 893
              tmp___5 = 1;
            } else {
#line 893
              tmp___5 = 0;
            }
#line 893
            tmp___11 = hMonths[tmp___5][dth.mm].name[2];
          } else {
#line 893
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 893
          if (ashkenazis_sw) {
#line 893
            if ((1L + (long )dth.yy * 7L) % 19L < 7L) {
#line 893
              tmp___10 = 1;
            } else {
#line 893
              tmp___10 = 0;
            }
#line 893
            if (hMonths[tmp___10][dth.mm].name[1]) {
#line 893
              if ((1L + (long )dth.yy * 7L) % 19L < 7L) {
#line 893
                tmp___7 = 1;
              } else {
#line 893
                tmp___7 = 0;
              }
#line 893
              tmp___9 = hMonths[tmp___7][dth.mm].name[1];
            } else {
#line 893
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 893
            if ((1L + (long )dth.yy * 7L) % 19L < 7L) {
#line 893
              tmp___8 = 1;
            } else {
#line 893
              tmp___8 = 0;
            }
#line 893
            tmp___9 = hMonths[tmp___8][dth.mm].name[0];
          }
#line 893
          tmp___11 = tmp___9;
        }
        {
#line 893
        strncat((char */* __restrict  */)tmpholip->name, (char const   */* __restrict  */)tmp___11,
                (size_t )60);
        }
      }
      {
#line 901
      tmp___13 = PushHoliday(tmpholip, holiList);
#line 901
      tmpMask |= tmp___13;
      }
    }
  }
#line 907
  if (dth.dd == 30) {
#line 907
    if (! suppress_rosh_chodesh_sw) {
      {
#line 909
      tmpholip = getHolstorep();
#line 910
      initStr(& tmpholip->name, (size_t )60);
      }
#line 911
      if (iso8859_8_sw) {
#line 911
        tmp___14 = "\370\340\371 \347\343\371 ";
      } else {
#line 911
        tmp___14 = "Rosh Chodesh ";
      }
      {
#line 911
      strcat((char */* __restrict  */)tmpholip->name, (char const   */* __restrict  */)tmp___14);
      }
#line 914
      if (! tabs_sw) {
#line 916
        if (iso8859_8_sw) {
#line 916
          if ((1L + (long )dth.yy * 7L) % 19L < 7L) {
#line 916
            tmp___23 = 1;
          } else {
#line 916
            tmp___23 = 0;
          }
#line 916
          if (hMonths[tmp___23][dth.mm + 1].name[2]) {
#line 916
            if ((1L + (long )dth.yy * 7L) % 19L < 7L) {
#line 916
              tmp___16 = 1;
            } else {
#line 916
              tmp___16 = 0;
            }
#line 916
            tmp___22 = hMonths[tmp___16][dth.mm + 1].name[2];
          } else {
#line 916
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
#line 916
          if (ashkenazis_sw) {
#line 916
            if ((1L + (long )dth.yy * 7L) % 19L < 7L) {
#line 916
              tmp___21 = 1;
            } else {
#line 916
              tmp___21 = 0;
            }
#line 916
            if (hMonths[tmp___21][dth.mm + 1].name[1]) {
#line 916
              if ((1L + (long )dth.yy * 7L) % 19L < 7L) {
#line 916
                tmp___18 = 1;
              } else {
#line 916
                tmp___18 = 0;
              }
#line 916
              tmp___20 = hMonths[tmp___18][dth.mm + 1].name[1];
            } else {
#line 916
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 916
            if ((1L + (long )dth.yy * 7L) % 19L < 7L) {
#line 916
              tmp___19 = 1;
            } else {
#line 916
              tmp___19 = 0;
            }
#line 916
            tmp___20 = hMonths[tmp___19][dth.mm + 1].name[0];
          }
#line 916
          tmp___22 = tmp___20;
        }
        {
#line 916
        strncat((char */* __restrict  */)tmpholip->name, (char const   */* __restrict  */)tmp___22,
                (size_t )60);
        }
      }
      {
#line 924
      tmp___24 = PushHoliday(tmpholip, holiList);
#line 924
      tmpMask |= tmp___24;
      }
    }
  }
#line 928
  return (tmpMask);
}
}
