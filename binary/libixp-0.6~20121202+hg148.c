/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 80 "../include/ixp.h"
typedef unsigned int _ixpuint;
#line 255
struct IxpCFid;
#line 255 "../include/ixp.h"
typedef struct IxpCFid IxpCFid;
#line 256
struct IxpClient;
#line 256 "../include/ixp.h"
typedef struct IxpClient IxpClient;
#line 259
struct IxpMsg;
#line 259 "../include/ixp.h"
typedef struct IxpMsg IxpMsg;
#line 260
struct IxpQid;
#line 260 "../include/ixp.h"
typedef struct IxpQid IxpQid;
#line 261
struct IxpRpc;
#line 261 "../include/ixp.h"
typedef struct IxpRpc IxpRpc;
#line 263
struct IxpStat;
#line 263 "../include/ixp.h"
typedef struct IxpStat IxpStat;
#line 266
struct IxpMutex;
#line 266 "../include/ixp.h"
typedef struct IxpMutex IxpMutex;
#line 268
struct IxpRendez;
#line 268 "../include/ixp.h"
typedef struct IxpRendez IxpRendez;
#line 276 "../include/ixp.h"
struct IxpMutex {
   void *aux ;
};
#line 280 "../include/ixp.h"
struct IxpRendez {
   IxpMutex *mutex ;
   void *aux ;
};
#line 293 "../include/ixp.h"
struct IxpMsg {
   char *data ;
   char *pos ;
   char *end ;
   _ixpuint size ;
   _ixpuint mode ;
};
#line 301 "../include/ixp.h"
struct IxpQid {
   uint8_t type ;
   uint32_t version ;
   uint64_t path ;
   uint8_t dir_type ;
};
#line 310 "../include/ixp.h"
struct IxpStat {
   uint16_t type ;
   uint32_t dev ;
   IxpQid qid ;
   uint32_t mode ;
   uint32_t atime ;
   uint32_t mtime ;
   uint64_t length ;
   char *name ;
   char *uid ;
   char *gid ;
   char *muid ;
};
#line 324
struct IxpFHdr;
#line 324 "../include/ixp.h"
typedef struct IxpFHdr IxpFHdr;
#line 325
struct IxpFError;
#line 325 "../include/ixp.h"
typedef struct IxpFError IxpFError;
#line 326
struct IxpFROpen;
#line 327
struct IxpFRAuth;
#line 327 "../include/ixp.h"
typedef struct IxpFRAuth IxpFRAuth;
#line 329 "../include/ixp.h"
typedef struct IxpFROpen IxpFROpen;
#line 330
struct IxpFIO;
#line 331
struct IxpFRStat;
#line 331 "../include/ixp.h"
typedef struct IxpFRStat IxpFRStat;
#line 332
struct IxpFVersion;
#line 333
struct IxpFRWalk;
#line 333 "../include/ixp.h"
typedef struct IxpFRWalk IxpFRWalk;
#line 334
struct IxpFAttach;
#line 336
struct IxpFTCreate;
#line 336 "../include/ixp.h"
typedef struct IxpFTCreate IxpFTCreate;
#line 337
struct IxpFTFlush;
#line 337 "../include/ixp.h"
typedef struct IxpFTFlush IxpFTFlush;
#line 341
struct IxpFTWalk;
#line 341 "../include/ixp.h"
typedef struct IxpFTWalk IxpFTWalk;
#line 343
struct IxpFTWStat;
#line 343 "../include/ixp.h"
typedef struct IxpFTWStat IxpFTWStat;
#line 344 "../include/ixp.h"
typedef struct IxpFAttach IxpFAttach;
#line 345 "../include/ixp.h"
typedef struct IxpFIO IxpFIO;
#line 346 "../include/ixp.h"
typedef struct IxpFVersion IxpFVersion;
#line 348 "../include/ixp.h"
struct IxpFHdr {
   uint8_t type ;
   uint16_t tag ;
   uint32_t fid ;
};
#line 353 "../include/ixp.h"
struct IxpFVersion {
   IxpFHdr hdr ;
   uint32_t msize ;
   char *version ;
};
#line 358 "../include/ixp.h"
struct IxpFTFlush {
   IxpFHdr hdr ;
   uint16_t oldtag ;
};
#line 362 "../include/ixp.h"
struct IxpFError {
   IxpFHdr hdr ;
   char *ename ;
};
#line 366 "../include/ixp.h"
struct IxpFROpen {
   IxpFHdr hdr ;
   IxpQid qid ;
   uint32_t iounit ;
};
#line 371 "../include/ixp.h"
struct IxpFRAuth {
   IxpFHdr hdr ;
   IxpQid aqid ;
};
#line 375 "../include/ixp.h"
struct IxpFAttach {
   IxpFHdr hdr ;
   uint32_t afid ;
   char *uname ;
   char *aname ;
};
#line 381 "../include/ixp.h"
struct IxpFTCreate {
   IxpFHdr hdr ;
   uint32_t perm ;
   char *name ;
   uint8_t mode ;
};
#line 387 "../include/ixp.h"
struct IxpFTWalk {
   IxpFHdr hdr ;
   uint32_t newfid ;
   uint16_t nwname ;
   char *wname[16] ;
};
#line 393 "../include/ixp.h"
struct IxpFRWalk {
   IxpFHdr hdr ;
   uint16_t nwqid ;
   IxpQid wqid[16] ;
};
#line 398 "../include/ixp.h"
struct IxpFIO {
   IxpFHdr hdr ;
   uint64_t offset ;
   uint32_t count ;
   char *data ;
};
#line 404 "../include/ixp.h"
struct IxpFRStat {
   IxpFHdr hdr ;
   uint16_t nstat ;
   uint8_t *stat ;
};
#line 409 "../include/ixp.h"
struct IxpFTWStat {
   IxpFHdr hdr ;
   IxpStat stat ;
};
#line 508
union IxpFcall;
#line 508 "../include/ixp.h"
typedef union IxpFcall IxpFcall;
#line 509 "../include/ixp.h"
union IxpFcall {
   IxpFHdr hdr ;
   IxpFVersion version ;
   IxpFVersion tversion ;
   IxpFVersion rversion ;
   IxpFTFlush tflush ;
   IxpFROpen ropen ;
   IxpFROpen rcreate ;
   IxpFROpen rattach ;
   IxpFError error ;
   IxpFRAuth rauth ;
   IxpFAttach tattach ;
   IxpFAttach tauth ;
   IxpFTCreate tcreate ;
   IxpFTCreate topen ;
   IxpFTWalk twalk ;
   IxpFRWalk rwalk ;
   IxpFTWStat twstat ;
   IxpFRStat rstat ;
   IxpFIO twrite ;
   IxpFIO rwrite ;
   IxpFIO tread ;
   IxpFIO rread ;
   IxpFIO io ;
};
#line 540 "../include/ixp.h"
typedef IxpStat Stat;
#line 566 "../include/ixp.h"
struct IxpRpc {
   IxpClient *mux ;
   IxpRpc *next ;
   IxpRpc *prev ;
   IxpRendez r ;
   _ixpuint tag ;
   IxpFcall *p ;
   int waiting ;
   int async ;
};
#line 577 "../include/ixp.h"
struct IxpClient {
   int fd ;
   _ixpuint msize ;
   _ixpuint lastfid ;
   _ixpuint nwait ;
   _ixpuint mwait ;
   _ixpuint freetag ;
   IxpCFid *freefid ;
   IxpMsg rmsg ;
   IxpMsg wmsg ;
   IxpMutex lk ;
   IxpMutex rlock ;
   IxpMutex wlock ;
   IxpRendez tagrend ;
   IxpRpc **wait ;
   IxpRpc *muxer ;
   IxpRpc sleep ;
   int mintag ;
   int maxtag ;
};
#line 600 "../include/ixp.h"
struct IxpCFid {
   uint32_t fid ;
   IxpQid qid ;
   uint8_t mode ;
   _ixpuint open ;
   _ixpuint iounit ;
   uint32_t offset ;
   IxpClient *client ;
   IxpCFid *next ;
   IxpMutex iolock ;
};
#line 307 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
struct exectab;
#line 307 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
typedef struct exectab exectab;
#line 308 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
struct exectab {
   char *cmd ;
   int (*fn)(int  , char ** ) ;
};
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 276 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime_r)(time_t const   * __restrict  __timer ,
                                                                                char * __restrict  __buf ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 744 "../include/ixp.h"
extern long ixp_read(IxpCFid * , void * , long  ) ;
#line 745
extern int ixp_remove(IxpClient * , char const   * ) ;
#line 746
extern void ixp_unmount(IxpClient * ) ;
#line 748
extern long ixp_write(IxpCFid * , void const   * , long  ) ;
#line 749
extern IxpCFid *ixp_create(IxpClient * , char const   * , _ixpuint perm , uint8_t mode ) ;
#line 751
extern IxpClient *ixp_mount(char const   * ) ;
#line 754
extern IxpCFid *ixp_open(IxpClient * , char const   * , uint8_t  ) ;
#line 755
extern IxpStat *ixp_stat(IxpClient * , char const   * ) ;
#line 767
extern void ixp_pstat(IxpMsg * , IxpStat * ) ;
#line 771
extern char *ixp_errbuf(void) ;
#line 782
extern IxpMsg ixp_message(char * , _ixpuint len , _ixpuint mode ) ;
#line 783
extern void ixp_freestat(IxpStat * ) ;
#line 811
extern void *ixp_emalloc(_ixpuint  ) ;
#line 813
extern void ixp_eprint(char const   *  , ...) ;
#line 814
extern void *ixp_erealloc(void * , _ixpuint  ) ;
#line 15 "../include/ixp_local.h"
char *argv0  ;
#line 35 "../include/ixp_local.h"
__inline static void _used(long a  , ...) 
{ 


  {
#line 35
  return;
}
}
#line 16 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static IxpClient *client  ;
#line 18 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static void usage(void) 
{ 


  {
  {
#line 20
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %1$s [-a <address>] {create | read | ls [-ld] | remove | write | append} <file>\n       %1$s [-a <address>] xwrite <file> <data>\n       %1$s -v\n",
          argv0);
#line 24
  exit(1);
  }
}
}
#line 28 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static void write_data(IxpCFid *fid , char *name ) 
{ 
  void *buf ;
  long len ;
  char *tmp ;
  long tmp___0 ;

  {
  {
#line 33
  buf = ixp_emalloc(fid->iounit);
  }
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 35
    len = read(0, buf, (size_t )fid->iounit);
    }
#line 36
    if (len >= 0L) {
      {
#line 36
      tmp___0 = ixp_write(fid, (void const   *)buf, len);
      }
#line 36
      if (tmp___0 != len) {
        {
#line 37
        tmp = ixp_errbuf();
#line 37
        ixp_eprint("ixpc: fatal: cannot write file \'%s\': %s\n", name, tmp);
        }
      }
    }
#line 34
    if (! (len > 0L)) {
#line 34
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 40
  free(buf);
  }
#line 41
  return;
}
}
#line 43 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static int comp_stat(void const   *s1 , void const   *s2 ) 
{ 
  Stat *st1 ;
  Stat *st2 ;
  int tmp ;

  {
  {
#line 47
  st1 = (Stat *)s1;
#line 48
  st2 = (Stat *)s2;
#line 49
  tmp = strcmp((char const   *)st1->name, (char const   *)st2->name);
  }
#line 49
  return (tmp);
}
}
#line 54
static void setrwx(long m , char *s ) ;
#line 54 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static char *modes[8]  = 
#line 54
  {      (char *)"---",      (char *)"--x",      (char *)"-w-",      (char *)"-wx", 
        (char *)"r--",      (char *)"r-x",      (char *)"rw-",      (char *)"rwx"};
#line 52 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static void setrwx(long m , char *s ) 
{ 


  {
  {
#line 59
  strncpy((char */* __restrict  */)s, (char const   */* __restrict  */)modes[m], (size_t )3);
  }
#line 60
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static char buf[16]  ;
#line 62 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static char *str_of_mode(_ixpuint mode ) 
{ 


  {
#line 66
  buf[0] = (char )'-';
#line 67
  if (mode & 2147483648U) {
#line 68
    buf[0] = (char )'d';
  }
  {
#line 69
  buf[1] = (char )'-';
#line 70
  setrwx((long )((mode >> 6) & 7U), & buf[2]);
#line 71
  setrwx((long )((mode >> 3) & 7U), & buf[5]);
#line 72
  setrwx((long )(mode & 7U), & buf[8]);
#line 73
  buf[11] = (char)0;
  }
#line 74
  return (buf);
}
}
#line 79 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static char buf___0[32]  ;
#line 77 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static char *str_of_time(_ixpuint val ) 
{ 
  size_t tmp ;

  {
  {
#line 81
  ctime_r((time_t const   */* __restrict  */)((time_t *)(& val)), (char */* __restrict  */)(buf___0));
#line 82
  tmp = strlen((char const   *)(buf___0));
#line 82
  buf___0[tmp - 1UL] = (char )'\000';
  }
#line 83
  return (buf___0);
}
}
#line 86 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static void print_stat(Stat *s , int details ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 88
  if (details) {
    {
#line 89
    tmp = str_of_time(s->mtime);
#line 89
    tmp___0 = str_of_mode(s->mode);
#line 89
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s %s %s %5llu %s %s\n",
            tmp___0, s->uid, s->gid, s->length, tmp, s->name);
    }
  } else
#line 92
  if (s->mode & 2147483648U) {
    {
#line 92
    tmp___1 = strcmp((char const   *)s->name, "/");
    }
#line 92
    if (tmp___1) {
      {
#line 93
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s/\n",
              s->name);
      }
    } else {
      {
#line 95
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\n",
              s->name);
      }
    }
  } else {
    {
#line 95
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\n",
            s->name);
    }
  }
#line 97
  return;
}
}
#line 100 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static int xappend(int argc , char **argv ) 
{ 
  IxpCFid *fid ;
  IxpStat *stat ;
  char *file ;
  int _argtmp ;
  int _inargv ;
  char *_argv ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 106
  _argtmp = 0;
#line 106
  _inargv = 0;
#line 106
  _argv = (char *)((void *)0);
#line 106
  if (! argv0) {
#line 106
    argv0 = *argv;
#line 106
    argv ++;
#line 106
    argc --;
  }
  {
#line 106
  _inargv = 1;
#line 106
  _used((long )_inargv);
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (argc) {
#line 106
      if (! ((int )*(*(argv + 0) + 0) == 45)) {
#line 106
        goto while_break;
      }
    } else {
#line 106
      goto while_break;
    }
#line 106
    _argv = *(argv + 0) + 1;
#line 106
    argv ++;
#line 106
    argc --;
#line 106
    if ((int )*(_argv + 0) == 45) {
#line 106
      if ((int )*(_argv + 1) == 0) {
#line 106
        goto while_break;
      }
    }
    {
#line 106
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 106
      if (! *_argv) {
#line 106
        goto while_break___0;
      }
#line 106
      tmp = _argv;
#line 106
      _argv ++;
      {
#line 107
      goto switch_default;
      switch_default: /* CIL Label */ 
      {
#line 108
      usage();
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  _inargv = 0;
#line 109
  _used((long )_argtmp, _argv, _inargv);
  }
#line 111
  if (_inargv) {
#line 111
    if (*_argv) {
      {
#line 111
      tmp___0 = strlen((char const   *)_argv);
#line 111
      _argtmp = (int )tmp___0;
#line 111
      _argv += _argtmp;
#line 111
      file = _argv - _argtmp;
      }
    } else {
#line 111
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 111
    if (argc > 0) {
      {
#line 111
      argc --;
#line 111
      argv ++;
#line 111
      _used((long )argc);
#line 111
      tmp___1 = *(argv - 1);
      }
    } else {
      {
#line 111
      usage();
#line 111
      tmp___1 = (char *)0;
      }
    }
#line 111
    file = tmp___1;
  }
  {
#line 112
  fid = ixp_open(client, (char const   *)file, (uint8_t )1);
  }
#line 113
  if ((unsigned long )fid == (unsigned long )((void *)0)) {
    {
#line 114
    tmp___2 = ixp_errbuf();
#line 114
    ixp_eprint("ixpc: fatal: Can\'t open file \'%s\': %s\n", file, tmp___2);
    }
  }
  {
#line 116
  stat = ixp_stat(client, (char const   *)file);
#line 117
  fid->offset = (uint32_t )stat->length;
#line 118
  ixp_freestat(stat);
#line 119
  free((void *)stat);
#line 120
  write_data(fid, file);
  }
#line 121
  return (0);
}
}
#line 124 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static int xwrite(int argc , char **argv ) 
{ 
  IxpCFid *fid ;
  char *file ;
  int _argtmp ;
  int _inargv ;
  char *_argv ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 129
  _argtmp = 0;
#line 129
  _inargv = 0;
#line 129
  _argv = (char *)((void *)0);
#line 129
  if (! argv0) {
#line 129
    argv0 = *argv;
#line 129
    argv ++;
#line 129
    argc --;
  }
  {
#line 129
  _inargv = 1;
#line 129
  _used((long )_inargv);
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (argc) {
#line 129
      if (! ((int )*(*(argv + 0) + 0) == 45)) {
#line 129
        goto while_break;
      }
    } else {
#line 129
      goto while_break;
    }
#line 129
    _argv = *(argv + 0) + 1;
#line 129
    argv ++;
#line 129
    argc --;
#line 129
    if ((int )*(_argv + 0) == 45) {
#line 129
      if ((int )*(_argv + 1) == 0) {
#line 129
        goto while_break;
      }
    }
    {
#line 129
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! *_argv) {
#line 129
        goto while_break___0;
      }
#line 129
      tmp = _argv;
#line 129
      _argv ++;
      {
#line 130
      goto switch_default;
      switch_default: /* CIL Label */ 
      {
#line 131
      usage();
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 132
  _inargv = 0;
#line 132
  _used((long )_argtmp, _argv, _inargv);
  }
#line 134
  if (_inargv) {
#line 134
    if (*_argv) {
      {
#line 134
      tmp___0 = strlen((char const   *)_argv);
#line 134
      _argtmp = (int )tmp___0;
#line 134
      _argv += _argtmp;
#line 134
      file = _argv - _argtmp;
      }
    } else {
#line 134
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 134
    if (argc > 0) {
      {
#line 134
      argc --;
#line 134
      argv ++;
#line 134
      _used((long )argc);
#line 134
      tmp___1 = *(argv - 1);
      }
    } else {
      {
#line 134
      usage();
#line 134
      tmp___1 = (char *)0;
      }
    }
#line 134
    file = tmp___1;
  }
  {
#line 135
  fid = ixp_open(client, (char const   *)file, (uint8_t )1);
  }
#line 136
  if ((unsigned long )fid == (unsigned long )((void *)0)) {
    {
#line 137
    tmp___2 = ixp_errbuf();
#line 137
    ixp_eprint("ixpc: fatal: Can\'t open file \'%s\': %s\n", file, tmp___2);
    }
  }
  {
#line 139
  write_data(fid, file);
  }
#line 140
  return (0);
}
}
#line 143 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static int xawrite(int argc , char **argv ) 
{ 
  IxpCFid *fid ;
  char *file ;
  char *buf___1 ;
  char *arg ;
  int nbuf ;
  int mbuf ;
  int len ;
  int _argtmp ;
  int _inargv ;
  char *_argv ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  long tmp___10 ;

  {
#line 149
  _argtmp = 0;
#line 149
  _inargv = 0;
#line 149
  _argv = (char *)((void *)0);
#line 149
  if (! argv0) {
#line 149
    argv0 = *argv;
#line 149
    argv ++;
#line 149
    argc --;
  }
  {
#line 149
  _inargv = 1;
#line 149
  _used((long )_inargv);
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (argc) {
#line 149
      if (! ((int )*(*(argv + 0) + 0) == 45)) {
#line 149
        goto while_break;
      }
    } else {
#line 149
      goto while_break;
    }
#line 149
    _argv = *(argv + 0) + 1;
#line 149
    argv ++;
#line 149
    argc --;
#line 149
    if ((int )*(_argv + 0) == 45) {
#line 149
      if ((int )*(_argv + 1) == 0) {
#line 149
        goto while_break;
      }
    }
    {
#line 149
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 149
      if (! *_argv) {
#line 149
        goto while_break___0;
      }
#line 149
      tmp = _argv;
#line 149
      _argv ++;
      {
#line 150
      goto switch_default;
      switch_default: /* CIL Label */ 
      {
#line 151
      usage();
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  _inargv = 0;
#line 152
  _used((long )_argtmp, _argv, _inargv);
  }
#line 154
  if (_inargv) {
#line 154
    if (*_argv) {
      {
#line 154
      tmp___0 = strlen((char const   *)_argv);
#line 154
      _argtmp = (int )tmp___0;
#line 154
      _argv += _argtmp;
#line 154
      file = _argv - _argtmp;
      }
    } else {
#line 154
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 154
    if (argc > 0) {
      {
#line 154
      argc --;
#line 154
      argv ++;
#line 154
      _used((long )argc);
#line 154
      tmp___1 = *(argv - 1);
      }
    } else {
      {
#line 154
      usage();
#line 154
      tmp___1 = (char *)0;
      }
    }
#line 154
    file = tmp___1;
  }
  {
#line 155
  fid = ixp_open(client, (char const   *)file, (uint8_t )1);
  }
#line 156
  if ((unsigned long )fid == (unsigned long )((void *)0)) {
    {
#line 157
    tmp___2 = ixp_errbuf();
#line 157
    ixp_eprint("ixpc: fatal: Can\'t open file \'%s\': %s\n", file, tmp___2);
    }
  }
  {
#line 159
  nbuf = 0;
#line 160
  mbuf = 128;
#line 161
  tmp___3 = ixp_emalloc((_ixpuint )mbuf);
#line 161
  buf___1 = (char *)tmp___3;
  }
  {
#line 162
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 162
    if (! argc) {
#line 162
      goto while_break___1;
    }
#line 163
    if (_inargv) {
#line 163
      if (*_argv) {
        {
#line 163
        tmp___4 = strlen((char const   *)_argv);
#line 163
        _argtmp = (int )tmp___4;
#line 163
        _argv += _argtmp;
#line 163
        arg = _argv - _argtmp;
        }
      } else {
#line 163
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 163
      if (argc > 0) {
        {
#line 163
        argc --;
#line 163
        argv ++;
#line 163
        _used((long )argc);
#line 163
        tmp___5 = *(argv - 1);
        }
      } else {
        {
#line 163
        _used(0L);
#line 163
        tmp___5 = (char *)0;
        }
      }
#line 163
      arg = tmp___5;
    }
    {
#line 164
    tmp___6 = strlen((char const   *)arg);
#line 164
    len = (int )tmp___6;
    }
#line 165
    if (nbuf + len > mbuf) {
      {
#line 166
      mbuf <<= 1;
#line 167
      tmp___7 = ixp_erealloc((void *)buf___1, (_ixpuint )mbuf);
#line 167
      buf___1 = (char *)tmp___7;
      }
    }
    {
#line 169
    memcpy((void */* __restrict  */)(buf___1 + nbuf), (void const   */* __restrict  */)arg,
           (size_t )len);
#line 170
    nbuf += len;
    }
#line 171
    if (argc) {
#line 172
      tmp___8 = nbuf;
#line 172
      nbuf ++;
#line 172
      *(buf___1 + tmp___8) = (char )' ';
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 175
  tmp___10 = ixp_write(fid, (void const   *)buf___1, (long )nbuf);
  }
#line 175
  if (tmp___10 == -1L) {
    {
#line 176
    tmp___9 = ixp_errbuf();
#line 176
    ixp_eprint("ixpc: fatal: cannot write file \'%s\': %s\n", file, tmp___9);
    }
  }
#line 177
  return (0);
}
}
#line 180 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static int xcreate(int argc , char **argv ) 
{ 
  IxpCFid *fid ;
  char *file ;
  int _argtmp ;
  int _inargv ;
  char *_argv ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 185
  _argtmp = 0;
#line 185
  _inargv = 0;
#line 185
  _argv = (char *)((void *)0);
#line 185
  if (! argv0) {
#line 185
    argv0 = *argv;
#line 185
    argv ++;
#line 185
    argc --;
  }
  {
#line 185
  _inargv = 1;
#line 185
  _used((long )_inargv);
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (argc) {
#line 185
      if (! ((int )*(*(argv + 0) + 0) == 45)) {
#line 185
        goto while_break;
      }
    } else {
#line 185
      goto while_break;
    }
#line 185
    _argv = *(argv + 0) + 1;
#line 185
    argv ++;
#line 185
    argc --;
#line 185
    if ((int )*(_argv + 0) == 45) {
#line 185
      if ((int )*(_argv + 1) == 0) {
#line 185
        goto while_break;
      }
    }
    {
#line 185
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 185
      if (! *_argv) {
#line 185
        goto while_break___0;
      }
#line 185
      tmp = _argv;
#line 185
      _argv ++;
      {
#line 186
      goto switch_default;
      switch_default: /* CIL Label */ 
      {
#line 187
      usage();
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  _inargv = 0;
#line 188
  _used((long )_argtmp, _argv, _inargv);
  }
#line 190
  if (_inargv) {
#line 190
    if (*_argv) {
      {
#line 190
      tmp___0 = strlen((char const   *)_argv);
#line 190
      _argtmp = (int )tmp___0;
#line 190
      _argv += _argtmp;
#line 190
      file = _argv - _argtmp;
      }
    } else {
#line 190
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 190
    if (argc > 0) {
      {
#line 190
      argc --;
#line 190
      argv ++;
#line 190
      _used((long )argc);
#line 190
      tmp___1 = *(argv - 1);
      }
    } else {
      {
#line 190
      usage();
#line 190
      tmp___1 = (char *)0;
      }
    }
#line 190
    file = tmp___1;
  }
  {
#line 191
  fid = ixp_create(client, (char const   *)file, (_ixpuint )511, (uint8_t )1);
  }
#line 192
  if ((unsigned long )fid == (unsigned long )((void *)0)) {
    {
#line 193
    tmp___2 = ixp_errbuf();
#line 193
    ixp_eprint("ixpc: fatal: Can\'t create file \'%s\': %s\n", file, tmp___2);
    }
  }
#line 195
  if (((unsigned int )fid->qid.type & 2147483648U) == 0U) {
    {
#line 196
    write_data(fid, file);
    }
  }
#line 198
  return (0);
}
}
#line 201 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static int xremove(int argc , char **argv ) 
{ 
  char *file ;
  int _argtmp ;
  int _inargv ;
  char *_argv ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 205
  _argtmp = 0;
#line 205
  _inargv = 0;
#line 205
  _argv = (char *)((void *)0);
#line 205
  if (! argv0) {
#line 205
    argv0 = *argv;
#line 205
    argv ++;
#line 205
    argc --;
  }
  {
#line 205
  _inargv = 1;
#line 205
  _used((long )_inargv);
  }
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (argc) {
#line 205
      if (! ((int )*(*(argv + 0) + 0) == 45)) {
#line 205
        goto while_break;
      }
    } else {
#line 205
      goto while_break;
    }
#line 205
    _argv = *(argv + 0) + 1;
#line 205
    argv ++;
#line 205
    argc --;
#line 205
    if ((int )*(_argv + 0) == 45) {
#line 205
      if ((int )*(_argv + 1) == 0) {
#line 205
        goto while_break;
      }
    }
    {
#line 205
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 205
      if (! *_argv) {
#line 205
        goto while_break___0;
      }
#line 205
      tmp = _argv;
#line 205
      _argv ++;
      {
#line 206
      goto switch_default;
      switch_default: /* CIL Label */ 
      {
#line 207
      usage();
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  _inargv = 0;
#line 208
  _used((long )_argtmp, _argv, _inargv);
  }
#line 210
  if (_inargv) {
#line 210
    if (*_argv) {
      {
#line 210
      tmp___0 = strlen((char const   *)_argv);
#line 210
      _argtmp = (int )tmp___0;
#line 210
      _argv += _argtmp;
#line 210
      file = _argv - _argtmp;
      }
    } else {
#line 210
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 210
    if (argc > 0) {
      {
#line 210
      argc --;
#line 210
      argv ++;
#line 210
      _used((long )argc);
#line 210
      tmp___1 = *(argv - 1);
      }
    } else {
      {
#line 210
      usage();
#line 210
      tmp___1 = (char *)0;
      }
    }
#line 210
    file = tmp___1;
  }
  {
#line 211
  tmp___3 = ixp_remove(client, (char const   *)file);
  }
#line 211
  if (tmp___3 == 0) {
    {
#line 212
    tmp___2 = ixp_errbuf();
#line 212
    ixp_eprint("ixpc: fatal: Can\'t remove file \'%s\': %s\n", file, tmp___2);
    }
  }
#line 213
  return (0);
}
}
#line 216 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static int xread(int argc , char **argv ) 
{ 
  IxpCFid *fid ;
  char *file ;
  char *buf___1 ;
  int count ;
  int _argtmp ;
  int _inargv ;
  char *_argv ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  char *tmp___5 ;

  {
#line 222
  _argtmp = 0;
#line 222
  _inargv = 0;
#line 222
  _argv = (char *)((void *)0);
#line 222
  if (! argv0) {
#line 222
    argv0 = *argv;
#line 222
    argv ++;
#line 222
    argc --;
  }
  {
#line 222
  _inargv = 1;
#line 222
  _used((long )_inargv);
  }
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (argc) {
#line 222
      if (! ((int )*(*(argv + 0) + 0) == 45)) {
#line 222
        goto while_break;
      }
    } else {
#line 222
      goto while_break;
    }
#line 222
    _argv = *(argv + 0) + 1;
#line 222
    argv ++;
#line 222
    argc --;
#line 222
    if ((int )*(_argv + 0) == 45) {
#line 222
      if ((int )*(_argv + 1) == 0) {
#line 222
        goto while_break;
      }
    }
    {
#line 222
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 222
      if (! *_argv) {
#line 222
        goto while_break___0;
      }
#line 222
      tmp = _argv;
#line 222
      _argv ++;
      {
#line 223
      goto switch_default;
      switch_default: /* CIL Label */ 
      {
#line 224
      usage();
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  _inargv = 0;
#line 225
  _used((long )_argtmp, _argv, _inargv);
  }
#line 227
  if (_inargv) {
#line 227
    if (*_argv) {
      {
#line 227
      tmp___0 = strlen((char const   *)_argv);
#line 227
      _argtmp = (int )tmp___0;
#line 227
      _argv += _argtmp;
#line 227
      file = _argv - _argtmp;
      }
    } else {
#line 227
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 227
    if (argc > 0) {
      {
#line 227
      argc --;
#line 227
      argv ++;
#line 227
      _used((long )argc);
#line 227
      tmp___1 = *(argv - 1);
      }
    } else {
      {
#line 227
      usage();
#line 227
      tmp___1 = (char *)0;
      }
    }
#line 227
    file = tmp___1;
  }
  {
#line 228
  fid = ixp_open(client, (char const   *)file, (uint8_t )0);
  }
#line 229
  if ((unsigned long )fid == (unsigned long )((void *)0)) {
    {
#line 230
    tmp___2 = ixp_errbuf();
#line 230
    ixp_eprint("ixpc: fatal: Can\'t open file \'%s\': %s\n", file, tmp___2);
    }
  }
  {
#line 232
  tmp___3 = ixp_emalloc(fid->iounit);
#line 232
  buf___1 = (char *)tmp___3;
  }
  {
#line 233
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 233
    tmp___4 = ixp_read(fid, (void *)buf___1, (long )fid->iounit);
#line 233
    count = (int )tmp___4;
    }
#line 233
    if (! (count > 0)) {
#line 233
      goto while_break___1;
    }
    {
#line 234
    write(1, (void const   *)buf___1, (size_t )count);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 236
  if (count == -1) {
    {
#line 237
    tmp___5 = ixp_errbuf();
#line 237
    ixp_eprint("ixpc: fatal: cannot read file/directory \'%s\': %s\n", file, tmp___5);
    }
  }
#line 239
  return (0);
}
}
#line 242 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
static int xls(int argc , char **argv ) 
{ 
  IxpMsg m ;
  Stat *stat ;
  IxpCFid *fid ;
  char *file ;
  char *buf___1 ;
  int lflag ;
  int dflag ;
  int count ;
  int nstat ;
  int mstat ;
  int i ;
  int _argtmp ;
  int _inargv ;
  char *_argv ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  char *tmp___9 ;

  {
#line 250
  dflag = 0;
#line 250
  lflag = dflag;
#line 252
  _argtmp = 0;
#line 252
  _inargv = 0;
#line 252
  _argv = (char *)((void *)0);
#line 252
  if (! argv0) {
#line 252
    argv0 = *argv;
#line 252
    argv ++;
#line 252
    argc --;
  }
  {
#line 252
  _inargv = 1;
#line 252
  _used((long )_inargv);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (argc) {
#line 252
      if (! ((int )*(*(argv + 0) + 0) == 45)) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    _argv = *(argv + 0) + 1;
#line 252
    argv ++;
#line 252
    argc --;
#line 252
    if ((int )*(_argv + 0) == 45) {
#line 252
      if ((int )*(_argv + 1) == 0) {
#line 252
        goto while_break;
      }
    }
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 252
      if (! *_argv) {
#line 252
        goto while_break___0;
      }
#line 252
      tmp = _argv;
#line 252
      _argv ++;
      {
#line 253
      if ((int )*tmp == 108) {
#line 253
        goto case_108;
      }
#line 256
      if ((int )*tmp == 100) {
#line 256
        goto case_100;
      }
#line 259
      goto switch_default;
      case_108: /* CIL Label */ 
#line 254
      lflag ++;
#line 255
      goto switch_break;
      case_100: /* CIL Label */ 
#line 257
      dflag ++;
#line 258
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 260
      usage();
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 261
  _inargv = 0;
#line 261
  _used((long )_argtmp, _argv, _inargv);
  }
#line 263
  if (_inargv) {
#line 263
    if (*_argv) {
      {
#line 263
      tmp___0 = strlen((char const   *)_argv);
#line 263
      _argtmp = (int )tmp___0;
#line 263
      _argv += _argtmp;
#line 263
      file = _argv - _argtmp;
      }
    } else {
#line 263
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 263
    if (argc > 0) {
      {
#line 263
      argc --;
#line 263
      argv ++;
#line 263
      _used((long )argc);
#line 263
      tmp___1 = *(argv - 1);
      }
    } else {
      {
#line 263
      usage();
#line 263
      tmp___1 = (char *)0;
      }
    }
#line 263
    file = tmp___1;
  }
  {
#line 265
  stat = ixp_stat(client, (char const   *)file);
  }
#line 266
  if ((unsigned long )stat == (unsigned long )((void *)0)) {
    {
#line 267
    tmp___2 = ixp_errbuf();
#line 267
    ixp_eprint("ixpc: fatal: cannot stat file \'%s\': %s\n", file, tmp___2);
    }
  }
#line 269
  if (dflag) {
    {
#line 270
    print_stat(stat, lflag);
#line 271
    ixp_freestat(stat);
    }
#line 272
    return (0);
  } else
#line 269
  if ((stat->mode & 2147483648U) == 0U) {
    {
#line 270
    print_stat(stat, lflag);
#line 271
    ixp_freestat(stat);
    }
#line 272
    return (0);
  }
  {
#line 274
  ixp_freestat(stat);
#line 276
  fid = ixp_open(client, (char const   *)file, (uint8_t )0);
  }
#line 277
  if ((unsigned long )fid == (unsigned long )((void *)0)) {
    {
#line 278
    tmp___3 = ixp_errbuf();
#line 278
    ixp_eprint("ixpc: fatal: Can\'t open file \'%s\': %s\n", file, tmp___3);
    }
  }
  {
#line 280
  nstat = 0;
#line 281
  mstat = 16;
#line 282
  tmp___4 = ixp_emalloc((_ixpuint )(sizeof(*stat) * (unsigned long )mstat));
#line 282
  stat = (Stat *)tmp___4;
#line 283
  tmp___5 = ixp_emalloc(fid->iounit);
#line 283
  buf___1 = (char *)tmp___5;
  }
  {
#line 284
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 284
    tmp___8 = ixp_read(fid, (void *)buf___1, (long )fid->iounit);
#line 284
    count = (int )tmp___8;
    }
#line 284
    if (! (count > 0)) {
#line 284
      goto while_break___1;
    }
    {
#line 285
    m = ixp_message(buf___1, (_ixpuint )count, (_ixpuint )1);
    }
    {
#line 286
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 286
      if (! ((unsigned long )m.pos < (unsigned long )m.end)) {
#line 286
        goto while_break___2;
      }
#line 287
      if (nstat == mstat) {
        {
#line 288
        mstat <<= 1;
#line 289
        tmp___6 = ixp_erealloc((void *)stat, (_ixpuint )(sizeof(*stat) * (unsigned long )mstat));
#line 289
        stat = (Stat *)tmp___6;
        }
      }
      {
#line 291
      tmp___7 = nstat;
#line 291
      nstat ++;
#line 291
      ixp_pstat(& m, stat + tmp___7);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 295
  qsort((void *)stat, (size_t )nstat, sizeof(*stat), & comp_stat);
#line 296
  i = 0;
  }
  {
#line 296
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 296
    if (! (i < nstat)) {
#line 296
      goto while_break___3;
    }
    {
#line 297
    print_stat(stat + i, lflag);
#line 298
    ixp_freestat(stat + i);
#line 296
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 300
  free((void *)stat);
  }
#line 302
  if (count == -1) {
    {
#line 303
    tmp___9 = ixp_errbuf();
#line 303
    ixp_eprint("ixpc: fatal: cannot read directory \'%s\': %s\n", file, tmp___9);
    }
  }
#line 304
  return (0);
}
}
#line 308 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
struct exectab etab[8]  = 
#line 308
  {      {(char *)"append", & xappend}, 
        {(char *)"write", & xwrite}, 
        {(char *)"xwrite", & xawrite}, 
        {(char *)"read", & xread}, 
        {(char *)"create", & xcreate}, 
        {(char *)"remove", & xremove}, 
        {(char *)"ls", & xls}, 
        {(char *)0, (int (*)(int  , char ** ))0}};
#line 322 "/home/wheatley/newnew/temp/libixp-0.6~20121202+hg148/cmd/ixpc.c"
int main(int argc , char **argv ) 
{ 
  char *cmd ;
  char *address ;
  exectab *tab ;
  int ret ;
  int _argtmp ;
  int _inargv ;
  char *_argv ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 328
  address = getenv("IXP_ADDRESS");
#line 330
  _argtmp = 0;
#line 330
  _inargv = 0;
#line 330
  _argv = (char *)((void *)0);
  }
#line 330
  if (! argv0) {
#line 330
    argv0 = *argv;
#line 330
    argv ++;
#line 330
    argc --;
  }
  {
#line 330
  _inargv = 1;
#line 330
  _used((long )_inargv);
  }
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (argc) {
#line 330
      if (! ((int )*(*(argv + 0) + 0) == 45)) {
#line 330
        goto while_break;
      }
    } else {
#line 330
      goto while_break;
    }
#line 330
    _argv = *(argv + 0) + 1;
#line 330
    argv ++;
#line 330
    argc --;
#line 330
    if ((int )*(_argv + 0) == 45) {
#line 330
      if ((int )*(_argv + 1) == 0) {
#line 330
        goto while_break;
      }
    }
    {
#line 330
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 330
      if (! *_argv) {
#line 330
        goto while_break___0;
      }
#line 330
      tmp = _argv;
#line 330
      _argv ++;
      {
#line 331
      if ((int )*tmp == 118) {
#line 331
        goto case_118;
      }
#line 334
      if ((int )*tmp == 97) {
#line 334
        goto case_97;
      }
#line 337
      goto switch_default;
      case_118: /* CIL Label */ 
      {
#line 332
      printf((char const   */* __restrict  */)"%s-0.5, \302\2512007 Kris Maglione\n",
             argv0);
#line 333
      exit(0);
      }
      case_97: /* CIL Label */ 
#line 335
      if (_inargv) {
#line 335
        if (*_argv) {
          {
#line 335
          tmp___0 = strlen((char const   *)_argv);
#line 335
          _argtmp = (int )tmp___0;
#line 335
          _argv += _argtmp;
#line 335
          address = _argv - _argtmp;
          }
        } else {
#line 335
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 335
        if (argc > 0) {
          {
#line 335
          argc --;
#line 335
          argv ++;
#line 335
          _used((long )argc);
#line 335
          tmp___1 = *(argv - 1);
          }
        } else {
          {
#line 335
          usage();
#line 335
          tmp___1 = (char *)0;
          }
        }
#line 335
        address = tmp___1;
      }
#line 336
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 338
      usage();
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 339
  _inargv = 0;
#line 339
  _used((long )_argtmp, _argv, _inargv);
  }
#line 341
  if (_inargv) {
#line 341
    if (*_argv) {
      {
#line 341
      tmp___2 = strlen((char const   *)_argv);
#line 341
      _argtmp = (int )tmp___2;
#line 341
      _argv += _argtmp;
#line 341
      cmd = _argv - _argtmp;
      }
    } else {
#line 341
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 341
    if (argc > 0) {
      {
#line 341
      argc --;
#line 341
      argv ++;
#line 341
      _used((long )argc);
#line 341
      tmp___3 = *(argv - 1);
      }
    } else {
      {
#line 341
      usage();
#line 341
      tmp___3 = (char *)0;
      }
    }
#line 341
    cmd = tmp___3;
  }
#line 343
  if (! address) {
    {
#line 344
    ixp_eprint("ixpc: fatal: $IXP_ADDRESS not set\n");
    }
  }
  {
#line 346
  client = ixp_mount((char const   *)address);
  }
#line 347
  if ((unsigned long )client == (unsigned long )((void *)0)) {
    {
#line 348
    tmp___4 = ixp_errbuf();
#line 348
    ixp_eprint("ixpc: fatal: %s\n", tmp___4);
    }
  }
#line 350
  tab = etab;
  {
#line 350
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 350
    if (! tab->cmd) {
#line 350
      goto while_break___1;
    }
    {
#line 351
    tmp___5 = strcmp((char const   *)cmd, (char const   *)tab->cmd);
    }
#line 351
    if (tmp___5 == 0) {
#line 351
      goto while_break___1;
    }
#line 350
    tab ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 352
  if ((unsigned long )tab->cmd == (unsigned long )((char *)0)) {
    {
#line 353
    usage();
    }
  }
  {
#line 355
  ret = (*(tab->fn))(argc, argv);
#line 357
  ixp_unmount(client);
  }
#line 358
  return (ret);
}
}
