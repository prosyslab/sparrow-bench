/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 19 "./struct.h"
typedef long idxtype;
#line 30 "./struct.h"
struct KeyValueType {
   idxtype key ;
   idxtype val ;
};
#line 35 "./struct.h"
typedef struct KeyValueType KeyValueType;
#line 77 "./struct.h"
struct edegreedef {
   idxtype pid ;
   idxtype ed ;
};
#line 81 "./struct.h"
typedef struct edegreedef EDegreeType;
#line 87 "./struct.h"
struct vedegreedef {
   idxtype pid ;
   idxtype ed ;
   idxtype ned ;
   idxtype gv ;
};
#line 92 "./struct.h"
typedef struct vedegreedef VEDegreeType;
#line 98 "./struct.h"
struct workspacedef {
   idxtype *core ;
   long maxcore ;
   long ccore ;
   EDegreeType *edegrees ;
   VEDegreeType *vedegrees ;
   long cdegree ;
   idxtype *auxcore ;
   idxtype *pmat ;
};
#line 112 "./struct.h"
typedef struct workspacedef WorkSpaceType;
#line 119 "./struct.h"
struct rinfodef {
   long id ;
   long ed ;
   long ndegrees ;
   EDegreeType *edegrees ;
};
#line 125 "./struct.h"
typedef struct rinfodef RInfoType;
#line 132 "./struct.h"
struct vrinfodef {
   long id ;
   long ed ;
   long nid ;
   long gv ;
   long ndegrees ;
   VEDegreeType *edegrees ;
};
#line 139 "./struct.h"
typedef struct vrinfodef VRInfoType;
#line 146 "./struct.h"
struct nrinfodef {
   idxtype edegrees[2] ;
};
#line 150 "./struct.h"
typedef struct nrinfodef NRInfoType;
#line 156 "./struct.h"
struct graphdef {
   idxtype *gdata ;
   idxtype *rdata ;
   long nvtxs ;
   long nedges ;
   idxtype *xadj ;
   idxtype *vwgt ;
   idxtype *vsize ;
   idxtype *adjncy ;
   idxtype *adjwgt ;
   idxtype *adjwgtsum ;
   idxtype *label ;
   idxtype *cmap ;
   long mincut ;
   long minvol ;
   idxtype *where ;
   idxtype *pwgts ;
   long nbnd ;
   idxtype *bndptr ;
   idxtype *bndind ;
   idxtype *id ;
   idxtype *ed ;
   RInfoType *rinfo ;
   VRInfoType *vrinfo ;
   NRInfoType *nrinfo ;
   long ncon ;
   float *nvwgt ;
   float *npwgts ;
   struct graphdef *coarser ;
   struct graphdef *finer ;
};
#line 201 "./struct.h"
typedef struct graphdef GraphType;
#line 208 "./struct.h"
typedef double timer;
#line 214 "./struct.h"
struct controldef {
   long CoarsenTo ;
   long dbglvl ;
   long CType ;
   long IType ;
   long RType ;
   long maxvwgt ;
   float nmaxvwgt ;
   long optype ;
   long pfactor ;
   long nseps ;
   long oflags ;
   WorkSpaceType wspace ;
   timer TotalTmr ;
   timer InitPartTmr ;
   timer MatchTmr ;
   timer ContractTmr ;
   timer CoarsenTmr ;
   timer UncoarsenTmr ;
   timer SepTmr ;
   timer RefTmr ;
   timer ProjectTmr ;
   timer SplitTmr ;
   timer AuxTmr1 ;
   timer AuxTmr2 ;
   timer AuxTmr3 ;
   timer AuxTmr4 ;
   timer AuxTmr5 ;
   timer AuxTmr6 ;
};
#line 235 "./struct.h"
typedef struct controldef CtrlType;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 41 "./struct.h"
struct ListNodeType {
   long id ;
   struct ListNodeType *prev ;
   struct ListNodeType *next ;
};
#line 46 "./struct.h"
typedef struct ListNodeType ListNodeType;
#line 54 "./struct.h"
struct PQueueType {
   long type ;
   long nnodes ;
   long maxnodes ;
   long mustfree ;
   long pgainspan ;
   long ngainspan ;
   long maxgain ;
   ListNodeType *nodes ;
   ListNodeType **buckets ;
   KeyValueType *heap ;
   idxtype *locator ;
};
#line 71 "./struct.h"
typedef struct PQueueType PQueueType;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 333 "./proto.h"
void __iidxsort(long n , idxtype *base ) ;
#line 334
void __iintsort(long n , long *base ) ;
#line 335
void __ikeysort(long n , KeyValueType *base ) ;
#line 336
void __ikeyvalsort(long n , KeyValueType *base ) ;
#line 23 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/myqsort.c"
static void siqst(idxtype *base , idxtype *max ) ;
#line 24
static void iiqst(long *base , long *max ) ;
#line 25
static void keyiqst(KeyValueType *base , KeyValueType *max ) ;
#line 26
static void keyvaliqst(KeyValueType *base , KeyValueType *max ) ;
#line 32 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/myqsort.c"
void __iidxsort(long n , idxtype *base ) 
{ 
  register idxtype *i ;
  register idxtype *j ;
  register idxtype *lo ;
  register idxtype *hi ;
  register idxtype *min ;
  register idxtype c ;
  idxtype *max ;
  idxtype *tmp ;

  {
#line 42
  if (n <= 1L) {
#line 43
    return;
  }
#line 45
  max = base + n;
#line 47
  if (n >= 1L) {
    {
#line 48
    siqst(base, max);
#line 49
    hi = base + 1;
    }
  } else {
#line 52
    hi = max;
  }
#line 54
  lo = base;
#line 54
  j = lo;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    tmp = lo;
#line 54
    lo ++;
#line 54
    if (! ((unsigned long )tmp < (unsigned long )hi)) {
#line 54
      goto while_break;
    }
#line 55
    if (*j > *lo) {
#line 56
      j = lo;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  if ((unsigned long )j != (unsigned long )base) {
#line 59
    c = *base;
#line 60
    *base = *j;
#line 61
    *j = c;
  }
#line 64
  min = base;
  {
#line 64
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 64
    min ++;
#line 64
    hi = min;
#line 64
    if (! ((unsigned long )hi < (unsigned long )max)) {
#line 64
      goto while_break___0;
    }
    {
#line 65
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 65
      hi --;
#line 65
      if (! (*hi > *min)) {
#line 65
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 66
    hi ++;
#line 66
    if ((unsigned long )hi != (unsigned long )min) {
#line 67
      lo = min + 1;
      {
#line 67
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 67
        lo --;
#line 67
        if (! ((unsigned long )lo >= (unsigned long )min)) {
#line 67
          goto while_break___2;
        }
#line 68
        c = *lo;
#line 69
        j = lo;
#line 69
        i = j;
        {
#line 69
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 69
          j --;
#line 69
          if (! ((unsigned long )j >= (unsigned long )hi)) {
#line 69
            goto while_break___3;
          }
#line 70
          *i = *j;
#line 69
          i = j;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 71
        *i = c;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/myqsort.c"
static void siqst(idxtype *base , idxtype *max ) 
{ 
  register idxtype *i ;
  register idxtype *j ;
  register idxtype *jj ;
  register idxtype *mid ;
  register idxtype c ;
  idxtype *tmp ;
  long lo ;
  long hi ;
  idxtype *tmp___0 ;

  {
#line 89
  lo = max - base;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    mid = base + ((unsigned int )lo >> 1);
#line 92
    if (lo >= 6L) {
#line 93
      if (*base > *mid) {
#line 93
        j = base;
      } else {
#line 93
        j = mid;
      }
#line 94
      tmp = max - 1;
#line 95
      if (*j > *tmp) {
#line 96
        if ((unsigned long )j == (unsigned long )base) {
#line 96
          j = mid;
        } else {
#line 96
          j = base;
        }
#line 97
        if (*j < *tmp) {
#line 98
          j = tmp;
        }
      }
#line 101
      if ((unsigned long )j != (unsigned long )mid) {
#line 102
        c = *mid;
#line 103
        *mid = *j;
#line 104
        *j = c;
      }
    }
#line 109
    i = base;
#line 109
    j = max - 1;
    {
#line 109
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 110
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 110
        if ((unsigned long )i < (unsigned long )mid) {
#line 110
          if (! (*i <= *mid)) {
#line 110
            goto while_break___1;
          }
        } else {
#line 110
          goto while_break___1;
        }
#line 111
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 112
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 112
        if (! ((unsigned long )j > (unsigned long )mid)) {
#line 112
          goto while_break___2;
        }
#line 113
        if (*mid <= *j) {
#line 114
          j --;
#line 115
          goto while_continue___2;
        }
#line 117
        tmp = i + 1;
#line 118
        if ((unsigned long )i == (unsigned long )mid) {
#line 119
          jj = j;
#line 119
          mid = jj;
        } else {
#line 121
          tmp___0 = j;
#line 121
          j --;
#line 121
          jj = tmp___0;
        }
#line 122
        goto swap;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 125
      if ((unsigned long )i == (unsigned long )mid) {
#line 126
        goto while_break___0;
      } else {
#line 128
        jj = mid;
#line 129
        mid = i;
#line 129
        tmp = mid;
#line 130
        j --;
      }
      swap: 
#line 133
      c = *i;
#line 134
      *i = *jj;
#line 135
      *jj = c;
#line 136
      i = tmp;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 139
    j = mid;
#line 139
    i = j + 1;
#line 140
    lo = j - base;
#line 140
    hi = max - i;
#line 140
    if (lo <= hi) {
#line 141
      if (lo >= 1L) {
        {
#line 142
        siqst(base, j);
        }
      }
#line 143
      base = i;
#line 144
      lo = hi;
    } else {
#line 147
      if (hi >= 1L) {
        {
#line 148
        siqst(i, max);
        }
      }
#line 149
      max = j;
    }
#line 90
    if (! (lo >= 1L)) {
#line 90
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return;
}
}
#line 161 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/myqsort.c"
void __iintsort(long n , long *base ) 
{ 
  register long *i ;
  register long *j ;
  register long *lo ;
  register long *hi ;
  register long *min ;
  register long c ;
  long *max ;
  long *tmp ;

  {
#line 171
  if (n <= 1L) {
#line 172
    return;
  }
#line 174
  max = base + n;
#line 176
  if (n >= 1L) {
    {
#line 177
    iiqst(base, max);
#line 178
    hi = base + 1;
    }
  } else {
#line 181
    hi = max;
  }
#line 183
  lo = base;
#line 183
  j = lo;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    tmp = lo;
#line 183
    lo ++;
#line 183
    if (! ((unsigned long )tmp < (unsigned long )hi)) {
#line 183
      goto while_break;
    }
#line 184
    if (*j > *lo) {
#line 185
      j = lo;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  if ((unsigned long )j != (unsigned long )base) {
#line 188
    c = *base;
#line 189
    *base = *j;
#line 190
    *j = c;
  }
#line 193
  min = base;
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 193
    min ++;
#line 193
    hi = min;
#line 193
    if (! ((unsigned long )hi < (unsigned long )max)) {
#line 193
      goto while_break___0;
    }
    {
#line 194
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 194
      hi --;
#line 194
      if (! (*hi > *min)) {
#line 194
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 195
    hi ++;
#line 195
    if ((unsigned long )hi != (unsigned long )min) {
#line 196
      lo = min + 1;
      {
#line 196
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 196
        lo --;
#line 196
        if (! ((unsigned long )lo >= (unsigned long )min)) {
#line 196
          goto while_break___2;
        }
#line 197
        c = *lo;
#line 198
        j = lo;
#line 198
        i = j;
        {
#line 198
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 198
          j --;
#line 198
          if (! ((unsigned long )j >= (unsigned long )hi)) {
#line 198
            goto while_break___3;
          }
#line 199
          *i = *j;
#line 198
          i = j;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 200
        *i = c;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 204
  return;
}
}
#line 207 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/myqsort.c"
static void iiqst(long *base , long *max ) 
{ 
  register long *i ;
  register long *j ;
  register long *jj ;
  register long *mid ;
  register long c ;
  long *tmp ;
  long lo ;
  long hi ;
  long *tmp___0 ;

  {
#line 219
  lo = max - base;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    mid = base + ((unsigned int )lo >> 1);
#line 222
    if (lo >= 6L) {
#line 223
      if (*base > *mid) {
#line 223
        j = base;
      } else {
#line 223
        j = mid;
      }
#line 224
      tmp = max - 1;
#line 225
      if (*j > *tmp) {
#line 226
        if ((unsigned long )j == (unsigned long )base) {
#line 226
          j = mid;
        } else {
#line 226
          j = base;
        }
#line 227
        if (*j < *tmp) {
#line 228
          j = tmp;
        }
      }
#line 231
      if ((unsigned long )j != (unsigned long )mid) {
#line 232
        c = *mid;
#line 233
        *mid = *j;
#line 234
        *j = c;
      }
    }
#line 239
    i = base;
#line 239
    j = max - 1;
    {
#line 239
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 240
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 240
        if ((unsigned long )i < (unsigned long )mid) {
#line 240
          if (! (*i <= *mid)) {
#line 240
            goto while_break___1;
          }
        } else {
#line 240
          goto while_break___1;
        }
#line 241
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 242
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 242
        if (! ((unsigned long )j > (unsigned long )mid)) {
#line 242
          goto while_break___2;
        }
#line 243
        if (*mid <= *j) {
#line 244
          j --;
#line 245
          goto while_continue___2;
        }
#line 247
        tmp = i + 1;
#line 248
        if ((unsigned long )i == (unsigned long )mid) {
#line 249
          jj = j;
#line 249
          mid = jj;
        } else {
#line 251
          tmp___0 = j;
#line 251
          j --;
#line 251
          jj = tmp___0;
        }
#line 252
        goto swap;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 255
      if ((unsigned long )i == (unsigned long )mid) {
#line 256
        goto while_break___0;
      } else {
#line 258
        jj = mid;
#line 259
        mid = i;
#line 259
        tmp = mid;
#line 260
        j --;
      }
      swap: 
#line 263
      c = *i;
#line 264
      *i = *jj;
#line 265
      *jj = c;
#line 266
      i = tmp;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 269
    j = mid;
#line 269
    i = j + 1;
#line 270
    lo = j - base;
#line 270
    hi = max - i;
#line 270
    if (lo <= hi) {
#line 271
      if (lo >= 1L) {
        {
#line 272
        iiqst(base, j);
        }
      }
#line 273
      base = i;
#line 274
      lo = hi;
    } else {
#line 277
      if (hi >= 1L) {
        {
#line 278
        iiqst(i, max);
        }
      }
#line 279
      max = j;
    }
#line 220
    if (! (lo >= 1L)) {
#line 220
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/myqsort.c"
void __ikeysort(long n , KeyValueType *base ) 
{ 
  register KeyValueType *i ;
  register KeyValueType *j ;
  register KeyValueType *lo ;
  register KeyValueType *hi ;
  register KeyValueType *min ;
  register KeyValueType c ;
  KeyValueType *max ;
  KeyValueType *tmp ;
  long i___0 ;

  {
#line 301
  if (n <= 1L) {
#line 302
    return;
  }
#line 304
  max = base + n;
#line 306
  if (n >= 1L) {
    {
#line 307
    keyiqst(base, max);
#line 308
    hi = base + 1;
    }
  } else {
#line 311
    hi = max;
  }
#line 313
  lo = base;
#line 313
  j = lo;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    tmp = lo;
#line 313
    lo ++;
#line 313
    if (! ((unsigned long )tmp < (unsigned long )hi)) {
#line 313
      goto while_break;
    }
#line 314
    if (j->key > lo->key) {
#line 315
      j = lo;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  if ((unsigned long )j != (unsigned long )base) {
#line 318
    c = *base;
#line 319
    *base = *j;
#line 320
    *j = c;
  }
#line 323
  min = base;
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    min ++;
#line 323
    hi = min;
#line 323
    if (! ((unsigned long )hi < (unsigned long )max)) {
#line 323
      goto while_break___0;
    }
    {
#line 324
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 324
      hi --;
#line 324
      if (! (hi->key > min->key)) {
#line 324
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 325
    hi ++;
#line 325
    if ((unsigned long )hi != (unsigned long )min) {
#line 326
      lo = min + 1;
      {
#line 326
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 326
        lo --;
#line 326
        if (! ((unsigned long )lo >= (unsigned long )min)) {
#line 326
          goto while_break___2;
        }
#line 327
        c = *lo;
#line 328
        j = lo;
#line 328
        i = j;
        {
#line 328
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 328
          j --;
#line 328
          if (! ((unsigned long )j >= (unsigned long )hi)) {
#line 328
            goto while_break___3;
          }
#line 329
          *i = *j;
#line 328
          i = j;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 330
        *i = c;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 338
  i___0 = 0L;
  {
#line 338
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 338
    if (! (i___0 < n - 1L)) {
#line 338
      goto while_break___4;
    }
#line 339
    if ((base + i___0)->key > (base + (i___0 + 1L))->key) {
      {
#line 340
      printf((char const   */* __restrict  */)"Something went wrong!\n");
      }
    }
#line 338
    i___0 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 342
  return;
}
}
#line 345 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/myqsort.c"
static void keyiqst(KeyValueType *base , KeyValueType *max ) 
{ 
  register KeyValueType *i ;
  register KeyValueType *j ;
  register KeyValueType *jj ;
  register KeyValueType *mid ;
  register KeyValueType c ;
  KeyValueType *tmp ;
  long lo ;
  long hi ;
  KeyValueType *tmp___0 ;

  {
#line 356
  lo = (max - base) >> 1;
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    mid = base + ((unsigned int )lo >> 1);
#line 359
    if (lo >= 6L) {
#line 360
      if (base->key > mid->key) {
#line 360
        j = base;
      } else {
#line 360
        j = mid;
      }
#line 361
      tmp = max - 1;
#line 362
      if (j->key > tmp->key) {
#line 363
        if ((unsigned long )j == (unsigned long )base) {
#line 363
          j = mid;
        } else {
#line 363
          j = base;
        }
#line 364
        if (j->key < tmp->key) {
#line 365
          j = tmp;
        }
      }
#line 368
      if ((unsigned long )j != (unsigned long )mid) {
#line 369
        c = *mid;
#line 370
        *mid = *j;
#line 371
        *j = c;
      }
    }
#line 376
    i = base;
#line 376
    j = max - 1;
    {
#line 376
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 377
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 377
        if ((unsigned long )i < (unsigned long )mid) {
#line 377
          if (! (i->key <= mid->key)) {
#line 377
            goto while_break___1;
          }
        } else {
#line 377
          goto while_break___1;
        }
#line 378
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 379
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 379
        if (! ((unsigned long )j > (unsigned long )mid)) {
#line 379
          goto while_break___2;
        }
#line 380
        if (mid->key <= j->key) {
#line 381
          j --;
#line 382
          goto while_continue___2;
        }
#line 384
        tmp = i + 1;
#line 385
        if ((unsigned long )i == (unsigned long )mid) {
#line 386
          jj = j;
#line 386
          mid = jj;
        } else {
#line 388
          tmp___0 = j;
#line 388
          j --;
#line 388
          jj = tmp___0;
        }
#line 389
        goto swap;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 392
      if ((unsigned long )i == (unsigned long )mid) {
#line 393
        goto while_break___0;
      } else {
#line 395
        jj = mid;
#line 396
        mid = i;
#line 396
        tmp = mid;
#line 397
        j --;
      }
      swap: 
#line 400
      c = *i;
#line 401
      *i = *jj;
#line 402
      *jj = c;
#line 403
      i = tmp;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 406
    j = mid;
#line 406
    i = j + 1;
#line 407
    lo = (j - base) >> 1;
#line 407
    hi = (max - i) >> 1;
#line 407
    if (lo <= hi) {
#line 408
      if (lo >= 1L) {
        {
#line 409
        keyiqst(base, j);
        }
      }
#line 410
      base = i;
#line 411
      lo = hi;
    } else {
#line 414
      if (hi >= 1L) {
        {
#line 415
        keyiqst(i, max);
        }
      }
#line 416
      max = j;
    }
#line 357
    if (! (lo >= 1L)) {
#line 357
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return;
}
}
#line 427 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/myqsort.c"
void __ikeyvalsort(long n , KeyValueType *base ) 
{ 
  register KeyValueType *i ;
  register KeyValueType *j ;
  register KeyValueType *lo ;
  register KeyValueType *hi ;
  register KeyValueType *min ;
  register KeyValueType c ;
  KeyValueType *max ;
  KeyValueType *tmp ;

  {
#line 437
  if (n <= 1L) {
#line 438
    return;
  }
#line 440
  max = base + n;
#line 442
  if (n >= 1L) {
    {
#line 443
    keyvaliqst(base, max);
#line 444
    hi = base + 1;
    }
  } else {
#line 447
    hi = max;
  }
#line 449
  lo = base;
#line 449
  j = lo;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    tmp = lo;
#line 449
    lo ++;
#line 449
    if (! ((unsigned long )tmp < (unsigned long )hi)) {
#line 449
      goto while_break;
    }
#line 450
    if (j->key > lo->key) {
#line 451
      j = lo;
    } else
#line 450
    if (j->key == lo->key) {
#line 450
      if (j->val > lo->val) {
#line 451
        j = lo;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  if ((unsigned long )j != (unsigned long )base) {
#line 454
    c = *base;
#line 455
    *base = *j;
#line 456
    *j = c;
  }
#line 459
  min = base;
  {
#line 459
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 459
    min ++;
#line 459
    hi = min;
#line 459
    if (! ((unsigned long )hi < (unsigned long )max)) {
#line 459
      goto while_break___0;
    }
    {
#line 460
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 460
      hi --;
#line 460
      if (! (hi->key > min->key)) {
#line 460
        if (hi->key == min->key) {
#line 460
          if (! (hi->val > min->val)) {
#line 460
            goto while_break___1;
          }
        } else {
#line 460
          goto while_break___1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 461
    hi ++;
#line 461
    if ((unsigned long )hi != (unsigned long )min) {
#line 462
      lo = min + 1;
      {
#line 462
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 462
        lo --;
#line 462
        if (! ((unsigned long )lo >= (unsigned long )min)) {
#line 462
          goto while_break___2;
        }
#line 463
        c = *lo;
#line 464
        j = lo;
#line 464
        i = j;
        {
#line 464
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 464
          j --;
#line 464
          if (! ((unsigned long )j >= (unsigned long )hi)) {
#line 464
            goto while_break___3;
          }
#line 465
          *i = *j;
#line 464
          i = j;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 466
        *i = c;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 470
  return;
}
}
#line 473 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/myqsort.c"
static void keyvaliqst(KeyValueType *base , KeyValueType *max ) 
{ 
  register KeyValueType *i ;
  register KeyValueType *j ;
  register KeyValueType *jj ;
  register KeyValueType *mid ;
  register KeyValueType c ;
  KeyValueType *tmp ;
  long lo ;
  long hi ;
  KeyValueType *tmp___0 ;

  {
#line 484
  lo = (max - base) >> 1;
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 486
    mid = base + ((unsigned int )lo >> 1);
#line 487
    if (lo >= 6L) {
#line 488
      if (base->key > mid->key) {
#line 488
        j = base;
      } else
#line 488
      if (base->key == mid->key) {
#line 488
        if (base->val > mid->val) {
#line 488
          j = base;
        } else {
#line 488
          j = mid;
        }
      } else {
#line 488
        j = mid;
      }
#line 489
      tmp = max - 1;
#line 490
      if (j->key > tmp->key) {
#line 490
        goto _L;
      } else
#line 490
      if (j->key == tmp->key) {
#line 490
        if (j->val > tmp->val) {
          _L: /* CIL Label */ 
#line 491
          if ((unsigned long )j == (unsigned long )base) {
#line 491
            j = mid;
          } else {
#line 491
            j = base;
          }
#line 492
          if (j->key < tmp->key) {
#line 493
            j = tmp;
          } else
#line 492
          if (j->key == tmp->key) {
#line 492
            if (j->val < tmp->val) {
#line 493
              j = tmp;
            }
          }
        }
      }
#line 496
      if ((unsigned long )j != (unsigned long )mid) {
#line 497
        c = *mid;
#line 498
        *mid = *j;
#line 499
        *j = c;
      }
    }
#line 504
    i = base;
#line 504
    j = max - 1;
    {
#line 504
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 505
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 505
        if ((unsigned long )i < (unsigned long )mid) {
#line 505
          if (! (i->key < mid->key)) {
#line 505
            if (i->key == mid->key) {
#line 505
              if (! (i->val <= mid->val)) {
#line 505
                goto while_break___1;
              }
            } else {
#line 505
              goto while_break___1;
            }
          }
        } else {
#line 505
          goto while_break___1;
        }
#line 506
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 507
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 507
        if (! ((unsigned long )j > (unsigned long )mid)) {
#line 507
          goto while_break___2;
        }
#line 508
        if (mid->key < j->key) {
#line 509
          j --;
#line 510
          goto while_continue___2;
        } else
#line 508
        if (mid->key == j->key) {
#line 508
          if (mid->val <= j->val) {
#line 509
            j --;
#line 510
            goto while_continue___2;
          }
        }
#line 512
        tmp = i + 1;
#line 513
        if ((unsigned long )i == (unsigned long )mid) {
#line 514
          jj = j;
#line 514
          mid = jj;
        } else {
#line 516
          tmp___0 = j;
#line 516
          j --;
#line 516
          jj = tmp___0;
        }
#line 517
        goto swap;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 520
      if ((unsigned long )i == (unsigned long )mid) {
#line 521
        goto while_break___0;
      } else {
#line 523
        jj = mid;
#line 524
        mid = i;
#line 524
        tmp = mid;
#line 525
        j --;
      }
      swap: 
#line 528
      c = *i;
#line 529
      *i = *jj;
#line 530
      *jj = c;
#line 531
      i = tmp;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 534
    j = mid;
#line 534
    i = j + 1;
#line 535
    lo = (j - base) >> 1;
#line 535
    hi = (max - i) >> 1;
#line 535
    if (lo <= hi) {
#line 536
      if (lo >= 1L) {
        {
#line 537
        keyvaliqst(base, j);
        }
      }
#line 538
      base = i;
#line 539
      lo = hi;
    } else {
#line 542
      if (hi >= 1L) {
        {
#line 543
        keyvaliqst(i, max);
        }
      }
#line 544
      max = j;
    }
#line 485
    if (! (lo >= 1L)) {
#line 485
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  return;
}
}
#line 204 "./proto.h"
void __MocBalance2Way2(CtrlType *ctrl , GraphType *graph , float *tpwgts , float *ubvec ) ;
#line 244
void __MocFM_2WayEdgeRefine2(CtrlType *ctrl , GraphType *graph , float *tpwgts , float *orgubvec ,
                             long npasses ) ;
#line 319
void __MocCompute2WayPartitionParams(CtrlType *ctrl , GraphType *graph ) ;
#line 320
void __MocProject2WayPartition(CtrlType *ctrl , GraphType *graph ) ;
#line 323
void __MocRefine2Way2(CtrlType *ctrl , GraphType *orggraph , GraphType *graph , float *tpwgts ,
                      float *ubvec ) ;
#line 423
double __seconds(void) ;
#line 426
void __errexit(char *f_str  , ...) ;
#line 20 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mrefine2.c"
void __MocRefine2Way2(CtrlType *ctrl , GraphType *orggraph , GraphType *graph , float *tpwgts ,
                      float *ubvec ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 24
  if (ctrl->dbglvl & 1L) {
    {
#line 24
    tmp = __seconds();
#line 24
    ctrl->UncoarsenTmr -= tmp;
    }
  }
  {
#line 27
  __MocCompute2WayPartitionParams(ctrl, graph);
  }
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (ctrl->dbglvl & 1L) {
      {
#line 32
      tmp___0 = __seconds();
#line 32
      ctrl->RefTmr -= tmp___0;
      }
    }
    {
#line 34
    if (ctrl->RType == 1L) {
#line 34
      goto case_1;
    }
#line 38
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 35
    __MocBalance2Way2(ctrl, graph, tpwgts, ubvec);
#line 36
    __MocFM_2WayEdgeRefine2(ctrl, graph, tpwgts, ubvec, 8L);
    }
#line 37
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 39
    __errexit((char *)"Unknown refinement type: %ld\n", ctrl->RType);
    }
    switch_break: /* CIL Label */ ;
    }
#line 41
    if (ctrl->dbglvl & 1L) {
      {
#line 41
      tmp___1 = __seconds();
#line 41
      ctrl->RefTmr += tmp___1;
      }
    }
#line 43
    if ((unsigned long )graph == (unsigned long )orggraph) {
#line 44
      goto while_break;
    }
#line 46
    graph = graph->finer;
#line 47
    if (ctrl->dbglvl & 1L) {
      {
#line 47
      tmp___2 = __seconds();
#line 47
      ctrl->ProjectTmr -= tmp___2;
      }
    }
    {
#line 48
    __MocProject2WayPartition(ctrl, graph);
    }
#line 49
    if (ctrl->dbglvl & 1L) {
      {
#line 49
      tmp___3 = __seconds();
#line 49
      ctrl->ProjectTmr += tmp___3;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  if (ctrl->dbglvl & 1L) {
    {
#line 52
    tmp___4 = __seconds();
#line 52
    ctrl->UncoarsenTmr += tmp___4;
    }
  }
#line 53
  return;
}
}
#line 47 "./proto.h"
void METIS_EstimateMemory(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                          long *optype , long *nbytes ) ;
#line 64
void METIS_PARTGRAPHRECURSIVE(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                              idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                              long *options , long *edgecut , idxtype *part ) ;
#line 65
void metis_partgraphrecursive(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                              idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                              long *options , long *edgecut , idxtype *part ) ;
#line 66
void metis_partgraphrecursive_(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                               idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                               long *options , long *edgecut , idxtype *part ) ;
#line 67
void metis_partgraphrecursive__(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                                idxtype *adjwgt , long *wgtflag , long *numflag ,
                                long *nparts , long *options , long *edgecut , idxtype *part ) ;
#line 68
void METIS_WPARTGRAPHRECURSIVE(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                               idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                               float *tpwgts , long *options , long *edgecut , idxtype *part ) ;
#line 69
void metis_wpartgraphrecursive(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                               idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                               float *tpwgts , long *options , long *edgecut , idxtype *part ) ;
#line 70
void metis_wpartgraphrecursive_(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                                idxtype *adjwgt , long *wgtflag , long *numflag ,
                                long *nparts , float *tpwgts , long *options , long *edgecut ,
                                idxtype *part ) ;
#line 71
void metis_wpartgraphrecursive__(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                                 idxtype *adjwgt , long *wgtflag , long *numflag ,
                                 long *nparts , float *tpwgts , long *options , long *edgecut ,
                                 idxtype *part ) ;
#line 72
void METIS_PARTGRAPHKWAY(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                         idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                         long *options , long *edgecut , idxtype *part ) ;
#line 73
void metis_partgraphkway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                         idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                         long *options , long *edgecut , idxtype *part ) ;
#line 74
void metis_partgraphkway_(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                          long *options , long *edgecut , idxtype *part ) ;
#line 75
void metis_partgraphkway__(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                           idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                           long *options , long *edgecut , idxtype *part ) ;
#line 76
void METIS_WPARTGRAPHKWAY(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                          float *tpwgts , long *options , long *edgecut , idxtype *part ) ;
#line 77
void metis_wpartgraphkway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                          float *tpwgts , long *options , long *edgecut , idxtype *part ) ;
#line 78
void metis_wpartgraphkway_(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                           idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                           float *tpwgts , long *options , long *edgecut , idxtype *part ) ;
#line 79
void metis_wpartgraphkway__(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                            idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                            float *tpwgts , long *options , long *edgecut , idxtype *part ) ;
#line 80
void METIS_EDGEND(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                  long *options , idxtype *perm , idxtype *iperm ) ;
#line 81
void metis_edgend(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                  long *options , idxtype *perm , idxtype *iperm ) ;
#line 82
void metis_edgend_(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                   long *options , idxtype *perm , idxtype *iperm ) ;
#line 83
void metis_edgend__(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                    long *options , idxtype *perm , idxtype *iperm ) ;
#line 84
void METIS_NODEND(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                  long *options , idxtype *perm , idxtype *iperm ) ;
#line 85
void metis_nodend(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                  long *options , idxtype *perm , idxtype *iperm ) ;
#line 86
void metis_nodend_(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                   long *options , idxtype *perm , idxtype *iperm ) ;
#line 87
void metis_nodend__(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                    long *options , idxtype *perm , idxtype *iperm ) ;
#line 88
void METIS_NODEWND(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                   long *numflag , long *options , idxtype *perm , idxtype *iperm ) ;
#line 89
void metis_nodewnd(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                   long *numflag , long *options , idxtype *perm , idxtype *iperm ) ;
#line 90
void metis_nodewnd_(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                    long *numflag , long *options , idxtype *perm , idxtype *iperm ) ;
#line 91
void metis_nodewnd__(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                     long *numflag , long *options , idxtype *perm , idxtype *iperm ) ;
#line 92
void METIS_PARTMESHNODAL(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                         long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) ;
#line 93
void metis_partmeshnodal(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                         long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) ;
#line 94
void metis_partmeshnodal_(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                          long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) ;
#line 95
void metis_partmeshnodal__(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                           long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) ;
#line 96
void METIS_PARTMESHDUAL(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                        long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) ;
#line 97
void metis_partmeshdual(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                        long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) ;
#line 98
void metis_partmeshdual_(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                         long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) ;
#line 99
void metis_partmeshdual__(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                          long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) ;
#line 100
void METIS_MESHTONODAL(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                       idxtype *dxadj , idxtype *dadjncy ) ;
#line 101
void metis_meshtonodal(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                       idxtype *dxadj , idxtype *dadjncy ) ;
#line 102
void metis_meshtonodal_(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                        idxtype *dxadj , idxtype *dadjncy ) ;
#line 103
void metis_meshtonodal__(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                         idxtype *dxadj , idxtype *dadjncy ) ;
#line 104
void METIS_MESHTODUAL(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                      idxtype *dxadj , idxtype *dadjncy ) ;
#line 105
void metis_meshtodual(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                      idxtype *dxadj , idxtype *dadjncy ) ;
#line 106
void metis_meshtodual_(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                       idxtype *dxadj , idxtype *dadjncy ) ;
#line 107
void metis_meshtodual__(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                        idxtype *dxadj , idxtype *dadjncy ) ;
#line 108
void METIS_ESTIMATEMEMORY(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                          long *optype , long *nbytes ) ;
#line 109
void metis_estimatememory(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                          long *optype , long *nbytes ) ;
#line 110
void metis_estimatememory_(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                           long *optype , long *nbytes ) ;
#line 111
void metis_estimatememory__(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                            long *optype , long *nbytes ) ;
#line 112
void METIS_MCPARTGRAPHRECURSIVE(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                                idxtype *vwgt , idxtype *adjwgt , long *wgtflag ,
                                long *numflag , long *nparts , long *options , long *edgecut ,
                                idxtype *part ) ;
#line 113
void metis_mcpartgraphrecursive(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                                idxtype *vwgt , idxtype *adjwgt , long *wgtflag ,
                                long *numflag , long *nparts , long *options , long *edgecut ,
                                idxtype *part ) ;
#line 114
void metis_mcpartgraphrecursive_(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                                 idxtype *vwgt , idxtype *adjwgt , long *wgtflag ,
                                 long *numflag , long *nparts , long *options , long *edgecut ,
                                 idxtype *part ) ;
#line 115
void metis_mcpartgraphrecursive__(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                                  idxtype *vwgt , idxtype *adjwgt , long *wgtflag ,
                                  long *numflag , long *nparts , long *options , long *edgecut ,
                                  idxtype *part ) ;
#line 116
void METIS_MCPARTGRAPHKWAY(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                           idxtype *vwgt , idxtype *adjwgt , long *wgtflag , long *numflag ,
                           long *nparts , float *rubvec , long *options , long *edgecut ,
                           idxtype *part ) ;
#line 117
void metis_mcpartgraphkway(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                           idxtype *vwgt , idxtype *adjwgt , long *wgtflag , long *numflag ,
                           long *nparts , float *rubvec , long *options , long *edgecut ,
                           idxtype *part ) ;
#line 118
void metis_mcpartgraphkway_(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                            idxtype *vwgt , idxtype *adjwgt , long *wgtflag , long *numflag ,
                            long *nparts , float *rubvec , long *options , long *edgecut ,
                            idxtype *part ) ;
#line 119
void metis_mcpartgraphkway__(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                             idxtype *vwgt , idxtype *adjwgt , long *wgtflag , long *numflag ,
                             long *nparts , float *rubvec , long *options , long *edgecut ,
                             idxtype *part ) ;
#line 120
void METIS_PARTGRAPHVKWAY(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                          long *options , long *volume , idxtype *part ) ;
#line 121
void metis_partgraphvkway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                          long *options , long *volume , idxtype *part ) ;
#line 122
void metis_partgraphvkway_(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                           idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                           long *options , long *volume , idxtype *part ) ;
#line 123
void metis_partgraphvkway__(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                            idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                            long *options , long *volume , idxtype *part ) ;
#line 124
void METIS_WPARTGRAPHVKWAY(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                           idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                           float *tpwgts , long *options , long *volume , idxtype *part ) ;
#line 125
void metis_wpartgraphvkway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                           idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                           float *tpwgts , long *options , long *volume , idxtype *part ) ;
#line 126
void metis_wpartgraphvkway_(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                            idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                            float *tpwgts , long *options , long *volume , idxtype *part ) ;
#line 127
void metis_wpartgraphvkway__(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                             idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                             float *tpwgts , long *options , long *volume , idxtype *part ) ;
#line 148
void METIS_PartGraphKway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                         idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                         long *options , long *edgecut , idxtype *part ) ;
#line 149
void METIS_WPartGraphKway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                          float *tpwgts , long *options , long *edgecut , idxtype *part ) ;
#line 153
void METIS_PartGraphVKway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                          long *options , long *volume , idxtype *part ) ;
#line 154
void METIS_WPartGraphVKway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                           idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                           float *tpwgts , long *options , long *volume , idxtype *part ) ;
#line 224
void METIS_MeshToDual(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                      idxtype *dxadj , idxtype *dadjncy ) ;
#line 225
void METIS_MeshToNodal(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                       idxtype *dxadj , idxtype *dadjncy ) ;
#line 233
void METIS_PartMeshNodal(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                         long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) ;
#line 234
void METIS_PartMeshDual(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                        long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) ;
#line 270
void METIS_mCPartGraphKway(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                           idxtype *vwgt , idxtype *adjwgt , long *wgtflag , long *numflag ,
                           long *nparts , float *rubvec , long *options , long *edgecut ,
                           idxtype *part ) ;
#line 307
void METIS_mCPartGraphRecursive(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                                idxtype *vwgt , idxtype *adjwgt , long *wgtflag ,
                                long *numflag , long *nparts , long *options , long *edgecut ,
                                idxtype *part ) ;
#line 339
void METIS_EdgeND(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                  long *options , idxtype *perm , idxtype *iperm ) ;
#line 340
void METIS_NodeND(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                  long *options , idxtype *perm , idxtype *iperm ) ;
#line 341
void METIS_NodeWND(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                   long *numflag , long *options , idxtype *perm , idxtype *iperm ) ;
#line 359
void METIS_PartGraphRecursive(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                              idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                              long *options , long *edgecut , idxtype *part ) ;
#line 360
void METIS_WPartGraphRecursive(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                               idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                               float *tpwgts , long *options , long *edgecut , idxtype *part ) ;
#line 18 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_PARTGRAPHRECURSIVE(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                              idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                              long *options , long *edgecut , idxtype *part ) 
{ 


  {
  {
#line 20
  METIS_PartGraphRecursive(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                           options, edgecut, part);
  }
#line 21
  return;
}
}
#line 22 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_partgraphrecursive(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                              idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                              long *options , long *edgecut , idxtype *part ) 
{ 


  {
  {
#line 24
  METIS_PartGraphRecursive(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                           options, edgecut, part);
  }
#line 25
  return;
}
}
#line 26 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_partgraphrecursive_(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                               idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                               long *options , long *edgecut , idxtype *part ) 
{ 


  {
  {
#line 28
  METIS_PartGraphRecursive(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                           options, edgecut, part);
  }
#line 29
  return;
}
}
#line 30 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_partgraphrecursive__(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                                idxtype *adjwgt , long *wgtflag , long *numflag ,
                                long *nparts , long *options , long *edgecut , idxtype *part ) 
{ 


  {
  {
#line 32
  METIS_PartGraphRecursive(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                           options, edgecut, part);
  }
#line 33
  return;
}
}
#line 36 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_WPARTGRAPHRECURSIVE(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                               idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                               float *tpwgts , long *options , long *edgecut , idxtype *part ) 
{ 


  {
  {
#line 38
  METIS_WPartGraphRecursive(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                            tpwgts, options, edgecut, part);
  }
#line 39
  return;
}
}
#line 40 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_wpartgraphrecursive(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                               idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                               float *tpwgts , long *options , long *edgecut , idxtype *part ) 
{ 


  {
  {
#line 42
  METIS_WPartGraphRecursive(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                            tpwgts, options, edgecut, part);
  }
#line 43
  return;
}
}
#line 44 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_wpartgraphrecursive_(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                                idxtype *adjwgt , long *wgtflag , long *numflag ,
                                long *nparts , float *tpwgts , long *options , long *edgecut ,
                                idxtype *part ) 
{ 


  {
  {
#line 46
  METIS_WPartGraphRecursive(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                            tpwgts, options, edgecut, part);
  }
#line 47
  return;
}
}
#line 48 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_wpartgraphrecursive__(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                                 idxtype *adjwgt , long *wgtflag , long *numflag ,
                                 long *nparts , float *tpwgts , long *options , long *edgecut ,
                                 idxtype *part ) 
{ 


  {
  {
#line 50
  METIS_WPartGraphRecursive(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                            tpwgts, options, edgecut, part);
  }
#line 51
  return;
}
}
#line 55 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_PARTGRAPHKWAY(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                         idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                         long *options , long *edgecut , idxtype *part ) 
{ 


  {
  {
#line 57
  METIS_PartGraphKway(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                      options, edgecut, part);
  }
#line 58
  return;
}
}
#line 59 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_partgraphkway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                         idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                         long *options , long *edgecut , idxtype *part ) 
{ 


  {
  {
#line 61
  METIS_PartGraphKway(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                      options, edgecut, part);
  }
#line 62
  return;
}
}
#line 63 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_partgraphkway_(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                          long *options , long *edgecut , idxtype *part ) 
{ 


  {
  {
#line 65
  METIS_PartGraphKway(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                      options, edgecut, part);
  }
#line 66
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_partgraphkway__(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                           idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                           long *options , long *edgecut , idxtype *part ) 
{ 


  {
  {
#line 69
  METIS_PartGraphKway(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                      options, edgecut, part);
  }
#line 70
  return;
}
}
#line 74 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_WPARTGRAPHKWAY(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                          float *tpwgts , long *options , long *edgecut , idxtype *part ) 
{ 


  {
  {
#line 76
  METIS_WPartGraphKway(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                       tpwgts, options, edgecut, part);
  }
#line 77
  return;
}
}
#line 78 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_wpartgraphkway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                          float *tpwgts , long *options , long *edgecut , idxtype *part ) 
{ 


  {
  {
#line 80
  METIS_WPartGraphKway(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                       tpwgts, options, edgecut, part);
  }
#line 81
  return;
}
}
#line 82 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_wpartgraphkway_(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                           idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                           float *tpwgts , long *options , long *edgecut , idxtype *part ) 
{ 


  {
  {
#line 84
  METIS_WPartGraphKway(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                       tpwgts, options, edgecut, part);
  }
#line 85
  return;
}
}
#line 86 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_wpartgraphkway__(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                            idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                            float *tpwgts , long *options , long *edgecut , idxtype *part ) 
{ 


  {
  {
#line 88
  METIS_WPartGraphKway(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                       tpwgts, options, edgecut, part);
  }
#line 89
  return;
}
}
#line 93 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_EDGEND(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                  long *options , idxtype *perm , idxtype *iperm ) 
{ 


  {
  {
#line 95
  METIS_EdgeND(nvtxs, xadj, adjncy, numflag, options, perm, iperm);
  }
#line 96
  return;
}
}
#line 97 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_edgend(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                  long *options , idxtype *perm , idxtype *iperm ) 
{ 


  {
  {
#line 99
  METIS_EdgeND(nvtxs, xadj, adjncy, numflag, options, perm, iperm);
  }
#line 100
  return;
}
}
#line 101 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_edgend_(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                   long *options , idxtype *perm , idxtype *iperm ) 
{ 


  {
  {
#line 103
  METIS_EdgeND(nvtxs, xadj, adjncy, numflag, options, perm, iperm);
  }
#line 104
  return;
}
}
#line 105 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_edgend__(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                    long *options , idxtype *perm , idxtype *iperm ) 
{ 


  {
  {
#line 107
  METIS_EdgeND(nvtxs, xadj, adjncy, numflag, options, perm, iperm);
  }
#line 108
  return;
}
}
#line 112 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_NODEND(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                  long *options , idxtype *perm , idxtype *iperm ) 
{ 


  {
  {
#line 114
  METIS_NodeND(nvtxs, xadj, adjncy, numflag, options, perm, iperm);
  }
#line 115
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_nodend(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                  long *options , idxtype *perm , idxtype *iperm ) 
{ 


  {
  {
#line 118
  METIS_NodeND(nvtxs, xadj, adjncy, numflag, options, perm, iperm);
  }
#line 119
  return;
}
}
#line 120 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_nodend_(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                   long *options , idxtype *perm , idxtype *iperm ) 
{ 


  {
  {
#line 122
  METIS_NodeND(nvtxs, xadj, adjncy, numflag, options, perm, iperm);
  }
#line 123
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_nodend__(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                    long *options , idxtype *perm , idxtype *iperm ) 
{ 


  {
  {
#line 126
  METIS_NodeND(nvtxs, xadj, adjncy, numflag, options, perm, iperm);
  }
#line 127
  return;
}
}
#line 131 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_NODEWND(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                   long *numflag , long *options , idxtype *perm , idxtype *iperm ) 
{ 


  {
  {
#line 133
  METIS_NodeWND(nvtxs, xadj, adjncy, vwgt, numflag, options, perm, iperm);
  }
#line 134
  return;
}
}
#line 135 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_nodewnd(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                   long *numflag , long *options , idxtype *perm , idxtype *iperm ) 
{ 


  {
  {
#line 137
  METIS_NodeWND(nvtxs, xadj, adjncy, vwgt, numflag, options, perm, iperm);
  }
#line 138
  return;
}
}
#line 139 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_nodewnd_(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                    long *numflag , long *options , idxtype *perm , idxtype *iperm ) 
{ 


  {
  {
#line 141
  METIS_NodeWND(nvtxs, xadj, adjncy, vwgt, numflag, options, perm, iperm);
  }
#line 142
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_nodewnd__(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                     long *numflag , long *options , idxtype *perm , idxtype *iperm ) 
{ 


  {
  {
#line 145
  METIS_NodeWND(nvtxs, xadj, adjncy, vwgt, numflag, options, perm, iperm);
  }
#line 146
  return;
}
}
#line 150 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_PARTMESHNODAL(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                         long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) 
{ 


  {
  {
#line 152
  METIS_PartMeshNodal(ne, nn, elmnts, etype, numflag, nparts, edgecut, epart, npart);
  }
#line 153
  return;
}
}
#line 154 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_partmeshnodal(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                         long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) 
{ 


  {
  {
#line 156
  METIS_PartMeshNodal(ne, nn, elmnts, etype, numflag, nparts, edgecut, epart, npart);
  }
#line 157
  return;
}
}
#line 158 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_partmeshnodal_(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                          long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) 
{ 


  {
  {
#line 160
  METIS_PartMeshNodal(ne, nn, elmnts, etype, numflag, nparts, edgecut, epart, npart);
  }
#line 161
  return;
}
}
#line 162 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_partmeshnodal__(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                           long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) 
{ 


  {
  {
#line 164
  METIS_PartMeshNodal(ne, nn, elmnts, etype, numflag, nparts, edgecut, epart, npart);
  }
#line 165
  return;
}
}
#line 168 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_PARTMESHDUAL(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                        long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) 
{ 


  {
  {
#line 170
  METIS_PartMeshDual(ne, nn, elmnts, etype, numflag, nparts, edgecut, epart, npart);
  }
#line 171
  return;
}
}
#line 172 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_partmeshdual(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                        long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) 
{ 


  {
  {
#line 174
  METIS_PartMeshDual(ne, nn, elmnts, etype, numflag, nparts, edgecut, epart, npart);
  }
#line 175
  return;
}
}
#line 176 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_partmeshdual_(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                         long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) 
{ 


  {
  {
#line 178
  METIS_PartMeshDual(ne, nn, elmnts, etype, numflag, nparts, edgecut, epart, npart);
  }
#line 179
  return;
}
}
#line 180 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_partmeshdual__(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                          long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) 
{ 


  {
  {
#line 182
  METIS_PartMeshDual(ne, nn, elmnts, etype, numflag, nparts, edgecut, epart, npart);
  }
#line 183
  return;
}
}
#line 186 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_MESHTONODAL(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                       idxtype *dxadj , idxtype *dadjncy ) 
{ 


  {
  {
#line 188
  METIS_MeshToNodal(ne, nn, elmnts, etype, numflag, dxadj, dadjncy);
  }
#line 189
  return;
}
}
#line 190 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_meshtonodal(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                       idxtype *dxadj , idxtype *dadjncy ) 
{ 


  {
  {
#line 192
  METIS_MeshToNodal(ne, nn, elmnts, etype, numflag, dxadj, dadjncy);
  }
#line 193
  return;
}
}
#line 194 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_meshtonodal_(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                        idxtype *dxadj , idxtype *dadjncy ) 
{ 


  {
  {
#line 196
  METIS_MeshToNodal(ne, nn, elmnts, etype, numflag, dxadj, dadjncy);
  }
#line 197
  return;
}
}
#line 198 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_meshtonodal__(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                         idxtype *dxadj , idxtype *dadjncy ) 
{ 


  {
  {
#line 200
  METIS_MeshToNodal(ne, nn, elmnts, etype, numflag, dxadj, dadjncy);
  }
#line 201
  return;
}
}
#line 204 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_MESHTODUAL(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                      idxtype *dxadj , idxtype *dadjncy ) 
{ 


  {
  {
#line 206
  METIS_MeshToDual(ne, nn, elmnts, etype, numflag, dxadj, dadjncy);
  }
#line 207
  return;
}
}
#line 208 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_meshtodual(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                      idxtype *dxadj , idxtype *dadjncy ) 
{ 


  {
  {
#line 210
  METIS_MeshToDual(ne, nn, elmnts, etype, numflag, dxadj, dadjncy);
  }
#line 211
  return;
}
}
#line 212 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_meshtodual_(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                       idxtype *dxadj , idxtype *dadjncy ) 
{ 


  {
  {
#line 214
  METIS_MeshToDual(ne, nn, elmnts, etype, numflag, dxadj, dadjncy);
  }
#line 215
  return;
}
}
#line 216 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_meshtodual__(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                        idxtype *dxadj , idxtype *dadjncy ) 
{ 


  {
  {
#line 218
  METIS_MeshToDual(ne, nn, elmnts, etype, numflag, dxadj, dadjncy);
  }
#line 219
  return;
}
}
#line 222 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_ESTIMATEMEMORY(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                          long *optype , long *nbytes ) 
{ 


  {
  {
#line 224
  METIS_EstimateMemory(nvtxs, xadj, adjncy, numflag, optype, nbytes);
  }
#line 225
  return;
}
}
#line 226 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_estimatememory(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                          long *optype , long *nbytes ) 
{ 


  {
  {
#line 228
  METIS_EstimateMemory(nvtxs, xadj, adjncy, numflag, optype, nbytes);
  }
#line 229
  return;
}
}
#line 230 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_estimatememory_(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                           long *optype , long *nbytes ) 
{ 


  {
  {
#line 232
  METIS_EstimateMemory(nvtxs, xadj, adjncy, numflag, optype, nbytes);
  }
#line 233
  return;
}
}
#line 234 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_estimatememory__(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                            long *optype , long *nbytes ) 
{ 


  {
  {
#line 236
  METIS_EstimateMemory(nvtxs, xadj, adjncy, numflag, optype, nbytes);
  }
#line 237
  return;
}
}
#line 241 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_MCPARTGRAPHRECURSIVE(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                                idxtype *vwgt , idxtype *adjwgt , long *wgtflag ,
                                long *numflag , long *nparts , long *options , long *edgecut ,
                                idxtype *part ) 
{ 


  {
  {
#line 243
  METIS_mCPartGraphRecursive(nvtxs, ncon, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag,
                             nparts, options, edgecut, part);
  }
#line 244
  return;
}
}
#line 245 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_mcpartgraphrecursive(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                                idxtype *vwgt , idxtype *adjwgt , long *wgtflag ,
                                long *numflag , long *nparts , long *options , long *edgecut ,
                                idxtype *part ) 
{ 


  {
  {
#line 247
  METIS_mCPartGraphRecursive(nvtxs, ncon, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag,
                             nparts, options, edgecut, part);
  }
#line 248
  return;
}
}
#line 249 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_mcpartgraphrecursive_(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                                 idxtype *vwgt , idxtype *adjwgt , long *wgtflag ,
                                 long *numflag , long *nparts , long *options , long *edgecut ,
                                 idxtype *part ) 
{ 


  {
  {
#line 251
  METIS_mCPartGraphRecursive(nvtxs, ncon, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag,
                             nparts, options, edgecut, part);
  }
#line 252
  return;
}
}
#line 253 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_mcpartgraphrecursive__(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                                  idxtype *vwgt , idxtype *adjwgt , long *wgtflag ,
                                  long *numflag , long *nparts , long *options , long *edgecut ,
                                  idxtype *part ) 
{ 


  {
  {
#line 255
  METIS_mCPartGraphRecursive(nvtxs, ncon, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag,
                             nparts, options, edgecut, part);
  }
#line 256
  return;
}
}
#line 259 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_MCPARTGRAPHKWAY(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                           idxtype *vwgt , idxtype *adjwgt , long *wgtflag , long *numflag ,
                           long *nparts , float *rubvec , long *options , long *edgecut ,
                           idxtype *part ) 
{ 


  {
  {
#line 261
  METIS_mCPartGraphKway(nvtxs, ncon, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag,
                        nparts, rubvec, options, edgecut, part);
  }
#line 262
  return;
}
}
#line 263 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_mcpartgraphkway(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                           idxtype *vwgt , idxtype *adjwgt , long *wgtflag , long *numflag ,
                           long *nparts , float *rubvec , long *options , long *edgecut ,
                           idxtype *part ) 
{ 


  {
  {
#line 265
  METIS_mCPartGraphKway(nvtxs, ncon, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag,
                        nparts, rubvec, options, edgecut, part);
  }
#line 266
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_mcpartgraphkway_(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                            idxtype *vwgt , idxtype *adjwgt , long *wgtflag , long *numflag ,
                            long *nparts , float *rubvec , long *options , long *edgecut ,
                            idxtype *part ) 
{ 


  {
  {
#line 269
  METIS_mCPartGraphKway(nvtxs, ncon, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag,
                        nparts, rubvec, options, edgecut, part);
  }
#line 270
  return;
}
}
#line 271 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_mcpartgraphkway__(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                             idxtype *vwgt , idxtype *adjwgt , long *wgtflag , long *numflag ,
                             long *nparts , float *rubvec , long *options , long *edgecut ,
                             idxtype *part ) 
{ 


  {
  {
#line 273
  METIS_mCPartGraphKway(nvtxs, ncon, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag,
                        nparts, rubvec, options, edgecut, part);
  }
#line 274
  return;
}
}
#line 277 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_PARTGRAPHVKWAY(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                          long *options , long *volume , idxtype *part ) 
{ 


  {
  {
#line 279
  METIS_PartGraphVKway(nvtxs, xadj, adjncy, vwgt, vsize, wgtflag, numflag, nparts,
                       options, volume, part);
  }
#line 280
  return;
}
}
#line 281 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_partgraphvkway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                          long *options , long *volume , idxtype *part ) 
{ 


  {
  {
#line 283
  METIS_PartGraphVKway(nvtxs, xadj, adjncy, vwgt, vsize, wgtflag, numflag, nparts,
                       options, volume, part);
  }
#line 284
  return;
}
}
#line 285 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_partgraphvkway_(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                           idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                           long *options , long *volume , idxtype *part ) 
{ 


  {
  {
#line 287
  METIS_PartGraphVKway(nvtxs, xadj, adjncy, vwgt, vsize, wgtflag, numflag, nparts,
                       options, volume, part);
  }
#line 288
  return;
}
}
#line 289 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_partgraphvkway__(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                            idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                            long *options , long *volume , idxtype *part ) 
{ 


  {
  {
#line 291
  METIS_PartGraphVKway(nvtxs, xadj, adjncy, vwgt, vsize, wgtflag, numflag, nparts,
                       options, volume, part);
  }
#line 292
  return;
}
}
#line 294 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void METIS_WPARTGRAPHVKWAY(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                           idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                           float *tpwgts , long *options , long *volume , idxtype *part ) 
{ 


  {
  {
#line 296
  METIS_WPartGraphVKway(nvtxs, xadj, adjncy, vwgt, vsize, wgtflag, numflag, nparts,
                        tpwgts, options, volume, part);
  }
#line 297
  return;
}
}
#line 298 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_wpartgraphvkway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                           idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                           float *tpwgts , long *options , long *volume , idxtype *part ) 
{ 


  {
  {
#line 300
  METIS_WPartGraphVKway(nvtxs, xadj, adjncy, vwgt, vsize, wgtflag, numflag, nparts,
                        tpwgts, options, volume, part);
  }
#line 301
  return;
}
}
#line 302 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_wpartgraphvkway_(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                            idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                            float *tpwgts , long *options , long *volume , idxtype *part ) 
{ 


  {
  {
#line 304
  METIS_WPartGraphVKway(nvtxs, xadj, adjncy, vwgt, vsize, wgtflag, numflag, nparts,
                        tpwgts, options, volume, part);
  }
#line 305
  return;
}
}
#line 306 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/frename.c"
void metis_wpartgraphvkway__(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                             idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                             float *tpwgts , long *options , long *volume , idxtype *part ) 
{ 


  {
  {
#line 308
  METIS_WPartGraphVKway(nvtxs, xadj, adjncy, vwgt, vsize, wgtflag, numflag, nparts,
                        tpwgts, options, volume, part);
  }
#line 309
  return;
}
}
#line 209 "./proto.h"
GraphType *__MCCoarsen2Way(CtrlType *ctrl , GraphType *graph ) ;
#line 291
void __MCMatch_RM(CtrlType *ctrl , GraphType *graph ) ;
#line 292
void __MCMatch_HEM(CtrlType *ctrl , GraphType *graph ) ;
#line 293
void __MCMatch_SHEM(CtrlType *ctrl , GraphType *graph ) ;
#line 294
void __MCMatch_SHEBM(CtrlType *ctrl , GraphType *graph , long norm ) ;
#line 295
void __MCMatch_SBHEM(CtrlType *ctrl , GraphType *graph , long norm ) ;
#line 446
long __idxsum(long n , idxtype *x ) ;
#line 452
float __ssum_strd(long n , float *x , long incx ) ;
#line 19 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mcoarsen.c"
GraphType *__MCCoarsen2Way(CtrlType *ctrl , GraphType *graph ) 
{ 
  long i ;
  long clevel ;
  GraphType *cgraph ;
  double tmp ;
  long tmp___0 ;
  float tmp___1 ;
  long tmp___2 ;
  float tmp___3 ;
  double tmp___4 ;

  {
#line 24
  if (ctrl->dbglvl & 1L) {
    {
#line 24
    tmp = __seconds();
#line 24
    ctrl->CoarsenTmr -= tmp;
    }
  }
#line 26
  cgraph = graph;
#line 28
  clevel = 0L;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (ctrl->dbglvl & 4L) {
      {
#line 31
      tmp___0 = __idxsum(cgraph->nvtxs, cgraph->adjwgtsum);
#line 31
      printf((char const   */* __restrict  */)"%6ld %7ld %10ld [%ld] [%6.4f", cgraph->nvtxs,
             cgraph->nedges, tmp___0, ctrl->CoarsenTo, (double )ctrl->nmaxvwgt);
#line 33
      i = 0L;
      }
      {
#line 33
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 33
        if (! (i < graph->ncon)) {
#line 33
          goto while_break___0;
        }
        {
#line 34
        tmp___1 = __ssum_strd(cgraph->nvtxs, cgraph->nvwgt + i, cgraph->ncon);
#line 34
        printf((char const   */* __restrict  */)" %5.3f", (double )tmp___1);
#line 33
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 35
      printf((char const   */* __restrict  */)"]\n");
      }
    }
    {
#line 39
    if (ctrl->CType == 1L) {
#line 39
      goto case_1;
    }
#line 42
    if (ctrl->CType == 2L) {
#line 42
      goto case_2;
    }
#line 48
    if (ctrl->CType == 3L) {
#line 48
      goto case_3;
    }
#line 54
    if (ctrl->CType == 4L) {
#line 54
      goto case_4;
    }
#line 57
    if (ctrl->CType == 5L) {
#line 57
      goto case_5;
    }
#line 60
    if (ctrl->CType == 6L) {
#line 60
      goto case_6;
    }
#line 63
    if (ctrl->CType == 7L) {
#line 63
      goto case_7;
    }
#line 66
    if (ctrl->CType == 8L) {
#line 66
      goto case_8;
    }
#line 69
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 40
    __MCMatch_RM(ctrl, cgraph);
    }
#line 41
    goto switch_break;
    case_2: /* CIL Label */ 
#line 43
    if (clevel < 1L) {
      {
#line 44
      __MCMatch_RM(ctrl, cgraph);
      }
    } else {
      {
#line 46
      __MCMatch_HEM(ctrl, cgraph);
      }
    }
#line 47
    goto switch_break;
    case_3: /* CIL Label */ 
#line 49
    if (clevel < 1L) {
      {
#line 50
      __MCMatch_RM(ctrl, cgraph);
      }
    } else {
      {
#line 52
      __MCMatch_SHEM(ctrl, cgraph);
      }
    }
#line 53
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 55
    __MCMatch_SHEM(ctrl, cgraph);
    }
#line 56
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 58
    __MCMatch_SHEBM(ctrl, cgraph, 1L);
    }
#line 59
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 61
    __MCMatch_SHEBM(ctrl, cgraph, -1L);
    }
#line 62
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 64
    __MCMatch_SBHEM(ctrl, cgraph, 1L);
    }
#line 65
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 67
    __MCMatch_SBHEM(ctrl, cgraph, -1L);
    }
#line 68
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 70
    __errexit((char *)"Unknown CType: %ld\n", ctrl->CType);
    }
    switch_break: /* CIL Label */ ;
    }
#line 73
    cgraph = cgraph->coarser;
#line 74
    clevel ++;
#line 29
    if (cgraph->nvtxs > ctrl->CoarsenTo) {
#line 29
      if ((double )cgraph->nvtxs < 0.90 * (double )(cgraph->finer)->nvtxs) {
#line 29
        if (! (cgraph->nedges > cgraph->nvtxs / 2L)) {
#line 29
          goto while_break;
        }
      } else {
#line 29
        goto while_break;
      }
    } else {
#line 29
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  if (ctrl->dbglvl & 4L) {
    {
#line 79
    tmp___2 = __idxsum(cgraph->nvtxs, cgraph->adjwgtsum);
#line 79
    printf((char const   */* __restrict  */)"%6ld %7ld %10ld [%ld] [%6.4f", cgraph->nvtxs,
           cgraph->nedges, tmp___2, ctrl->CoarsenTo, (double )ctrl->nmaxvwgt);
#line 81
    i = 0L;
    }
    {
#line 81
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 81
      if (! (i < graph->ncon)) {
#line 81
        goto while_break___1;
      }
      {
#line 82
      tmp___3 = __ssum_strd(cgraph->nvtxs, cgraph->nvwgt + i, cgraph->ncon);
#line 82
      printf((char const   */* __restrict  */)" %5.3f", (double )tmp___3);
#line 81
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 83
    printf((char const   */* __restrict  */)"]\n");
    }
  }
#line 87
  if (ctrl->dbglvl & 1L) {
    {
#line 87
    tmp___4 = __seconds();
#line 87
    ctrl->CoarsenTmr += tmp___4;
    }
  }
#line 89
  return (cgraph);
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 31 "./proto.h"
GraphType *__Coarsen2Way(CtrlType *ctrl , GraphType *graph ) ;
#line 55
void __Change2CNumbering(long nvtxs , idxtype *xadj , idxtype *adjncy ) ;
#line 56
void __Change2FNumbering(long nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vector ) ;
#line 130
void __SetUpGraph(GraphType *graph , long OpType , long nvtxs , long ncon , idxtype *xadj ,
                  idxtype *adjncy , idxtype *vwgt , idxtype *adjwgt , long wgtflag ) ;
#line 141
void __Init2WayPartition(CtrlType *ctrl , GraphType *graph , long *tpwgts , float ubfactor ) ;
#line 212
void __AllocateWorkSpace(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 213
void __FreeWorkSpace(CtrlType *ctrl , GraphType *graph ) ;
#line 215
idxtype *__idxwspacemalloc(CtrlType *ctrl , long n ) ;
#line 216
void __idxwspacefree(CtrlType *ctrl , long n ) ;
#line 220
void __InitGraph(GraphType *graph ) ;
#line 361
long __MlevelRecursiveBisection(CtrlType *ctrl , GraphType *graph , long nparts ,
                                idxtype *part , float *tpwgts , float ubfactor , long fpart ) ;
#line 362
void __MlevelEdgeBisection(CtrlType *ctrl , GraphType *graph , long *tpwgts , float ubfactor ) ;
#line 363
void __SplitGraphPart(CtrlType *ctrl , GraphType *graph , GraphType *lgraph , GraphType *rgraph ) ;
#line 364
void __SetUpSplitGraph(GraphType *graph , GraphType *sgraph , long snvtxs , long snedges ) ;
#line 381
void __Refine2Way(CtrlType *ctrl , GraphType *orggraph , GraphType *graph , long *tpwgts ,
                  float ubfactor ) ;
#line 421
void __InitTimers(CtrlType *ctrl ) ;
#line 422
void __PrintTimers(CtrlType *ctrl ) ;
#line 429
idxtype *__idxmalloc(long n , char *msg ) ;
#line 430
float *__fmalloc(long n , char *msg ) ;
#line 451
float __ssum(long n , float *x ) ;
#line 453
void __sscale(long n , float alpha , float *x ) ;
#line 461
void __InitRandom(long seed ) ;
#line 22 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pmetis.c"
void METIS_PartGraphRecursive(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                              idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                              long *options , long *edgecut , idxtype *part ) 
{ 
  long i ;
  float *tpwgts ;

  {
  {
#line 29
  tpwgts = __fmalloc(*nparts, (char *)"KMETIS: tpwgts");
#line 30
  i = 0L;
  }
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (i < *nparts)) {
#line 30
      goto while_break;
    }
#line 31
    *(tpwgts + i) = (float )(1.0 / (1.0 * (double )*nparts));
#line 30
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 33
  METIS_WPartGraphRecursive(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                            tpwgts, options, edgecut, part);
#line 36
  free((void *)tpwgts);
  }
#line 37
  return;
}
}
#line 45 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pmetis.c"
void METIS_WPartGraphRecursive(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                               idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                               float *tpwgts , long *options , long *edgecut , idxtype *part ) 
{ 
  long i ;
  GraphType graph ;
  CtrlType ctrl ;
  float *mytpwgts ;
  long tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 54
  if (*numflag == 1L) {
    {
#line 55
    __Change2CNumbering(*nvtxs, xadj, adjncy);
    }
  }
  {
#line 57
  __SetUpGraph(& graph, 1L, *nvtxs, 1L, xadj, adjncy, vwgt, adjwgt, *wgtflag);
  }
#line 59
  if (*(options + 0) == 0L) {
#line 60
    ctrl.CType = 3L;
#line 61
    ctrl.IType = 1L;
#line 62
    ctrl.RType = 1L;
#line 63
    ctrl.dbglvl = 0L;
  } else {
#line 66
    ctrl.CType = *(options + 1);
#line 67
    ctrl.IType = *(options + 2);
#line 68
    ctrl.RType = *(options + 3);
#line 69
    ctrl.dbglvl = *(options + 4);
  }
  {
#line 71
  ctrl.optype = 1L;
#line 72
  ctrl.CoarsenTo = 20L;
#line 73
  tmp = __idxsum(*nvtxs, graph.vwgt);
#line 73
  ctrl.maxvwgt = (long )(1.5 * (double )(tmp / ctrl.CoarsenTo));
#line 75
  mytpwgts = __fmalloc(*nparts, (char *)"PWMETIS: mytpwgts");
#line 76
  i = 0L;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i < *nparts)) {
#line 76
      goto while_break;
    }
#line 77
    *(mytpwgts + i) = *(tpwgts + i);
#line 76
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 79
  __InitRandom(-1L);
#line 81
  __AllocateWorkSpace(& ctrl, & graph, *nparts);
  }
#line 83
  if (ctrl.dbglvl & 1L) {
    {
#line 83
    __InitTimers(& ctrl);
    }
  }
#line 84
  if (ctrl.dbglvl & 1L) {
    {
#line 84
    tmp___0 = __seconds();
#line 84
    ctrl.TotalTmr -= tmp___0;
    }
  }
  {
#line 86
  *edgecut = __MlevelRecursiveBisection(& ctrl, & graph, *nparts, part, mytpwgts,
                                        (float )1.000, 0L);
  }
#line 88
  if (ctrl.dbglvl & 1L) {
    {
#line 88
    tmp___1 = __seconds();
#line 88
    ctrl.TotalTmr += tmp___1;
    }
  }
#line 89
  if (ctrl.dbglvl & 1L) {
    {
#line 89
    __PrintTimers(& ctrl);
    }
  }
  {
#line 91
  __FreeWorkSpace(& ctrl, & graph);
#line 92
  free((void *)mytpwgts);
  }
#line 94
  if (*numflag == 1L) {
    {
#line 95
    __Change2FNumbering(*nvtxs, xadj, adjncy, part);
    }
  }
#line 96
  return;
}
}
#line 138
void __GKfree(void **ptr1  , ...) ;
#line 103 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pmetis.c"
long __MlevelRecursiveBisection(CtrlType *ctrl , GraphType *graph , long nparts ,
                                idxtype *part , float *tpwgts , float ubfactor , long fpart ) 
{ 
  long i ;
  long nvtxs ;
  long cut ;
  long tvwgt ;
  long tpwgts2[2] ;
  idxtype *label ;
  idxtype *where ;
  GraphType lgraph ;
  GraphType rgraph ;
  float wsum ;
  float tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 110
  nvtxs = graph->nvtxs;
#line 111
  if (nvtxs == 0L) {
    {
#line 112
    printf((char const   */* __restrict  */)"\t***Cannot bisect a graph with 0 vertices!\n\t***You are trying to partition a graph into too many parts!\n");
    }
#line 113
    return (0L);
  }
  {
#line 117
  tvwgt = __idxsum(nvtxs, graph->vwgt);
#line 118
  tmp = __ssum(nparts / 2L, tpwgts);
#line 118
  tpwgts2[0] = (long )((float )tvwgt * tmp);
#line 119
  tpwgts2[1] = tvwgt - tpwgts2[0];
#line 121
  __MlevelEdgeBisection(ctrl, graph, tpwgts2, ubfactor);
#line 122
  cut = graph->mincut;
#line 126
  label = graph->label;
#line 127
  where = graph->where;
#line 128
  i = 0L;
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (i < nvtxs)) {
#line 128
      goto while_break;
    }
#line 129
    *(part + *(label + i)) = *(where + i) + fpart;
#line 128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  if (nparts > 2L) {
    {
#line 132
    __SplitGraphPart(ctrl, graph, & lgraph, & rgraph);
    }
  }
  {
#line 138
  __GKfree(& graph->gdata, & graph->rdata, & graph->label, (void **)0);
#line 141
  wsum = __ssum(nparts / 2L, tpwgts);
#line 142
  __sscale(nparts / 2L, (float )(1.0 / (double )wsum), tpwgts);
#line 143
  __sscale(nparts - nparts / 2L, (float )(1.0 / (1.0 - (double )wsum)), tpwgts + nparts / 2L);
  }
#line 151
  if (nparts > 3L) {
    {
#line 152
    tmp___0 = __MlevelRecursiveBisection(ctrl, & lgraph, nparts / 2L, part, tpwgts,
                                         ubfactor, fpart);
#line 152
    cut += tmp___0;
#line 153
    tmp___1 = __MlevelRecursiveBisection(ctrl, & rgraph, nparts - nparts / 2L, part,
                                         tpwgts + nparts / 2L, ubfactor, fpart + nparts / 2L);
#line 153
    cut += tmp___1;
    }
  } else
#line 155
  if (nparts == 3L) {
    {
#line 156
    tmp___2 = __MlevelRecursiveBisection(ctrl, & rgraph, nparts - nparts / 2L, part,
                                         tpwgts + nparts / 2L, ubfactor, fpart + nparts / 2L);
#line 156
    cut += tmp___2;
#line 157
    __GKfree(& lgraph.gdata, & lgraph.label, (void **)0);
    }
  }
#line 160
  return (cut);
}
}
#line 168 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pmetis.c"
void __MlevelEdgeBisection(CtrlType *ctrl , GraphType *graph , long *tpwgts , float ubfactor ) 
{ 
  GraphType *cgraph ;

  {
  {
#line 172
  cgraph = __Coarsen2Way(ctrl, graph);
#line 174
  __Init2WayPartition(ctrl, cgraph, tpwgts, ubfactor);
#line 176
  __Refine2Way(ctrl, graph, cgraph, tpwgts, ubfactor);
  }
#line 182
  return;
}
}
#line 190 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pmetis.c"
void __SplitGraphPart(CtrlType *ctrl , GraphType *graph , GraphType *lgraph , GraphType *rgraph ) 
{ 
  long i ;
  long j ;
  long k ;
  long kk ;
  long l ;
  long istart ;
  long iend ;
  long mypart ;
  long nvtxs ;
  long ncon ;
  long snvtxs[2] ;
  long snedges[2] ;
  long sum ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *adjwgtsum ;
  idxtype *label ;
  idxtype *where ;
  idxtype *bndptr ;
  idxtype *sxadj[2] ;
  idxtype *svwgt[2] ;
  idxtype *sadjncy[2] ;
  idxtype *sadjwgt[2] ;
  idxtype *sadjwgtsum[2] ;
  idxtype *slabel[2] ;
  idxtype *rename___0 ;
  idxtype *auxadjncy ;
  idxtype *auxadjwgt ;
  float *nvwgt ;
  float *snvwgt[2] ;
  float *npwgts ;
  double tmp ;
  long tmp___0 ;
  idxtype tmp___1 ;
  long tmp___2 ;
  double tmp___3 ;

  {
#line 200
  if (ctrl->dbglvl & 1L) {
    {
#line 200
    tmp = __seconds();
#line 200
    ctrl->SplitTmr -= tmp;
    }
  }
  {
#line 202
  nvtxs = graph->nvtxs;
#line 203
  ncon = graph->ncon;
#line 204
  xadj = graph->xadj;
#line 205
  vwgt = graph->vwgt;
#line 206
  nvwgt = graph->nvwgt;
#line 207
  adjncy = graph->adjncy;
#line 208
  adjwgt = graph->adjwgt;
#line 209
  adjwgtsum = graph->adjwgtsum;
#line 210
  label = graph->label;
#line 211
  where = graph->where;
#line 212
  bndptr = graph->bndptr;
#line 213
  npwgts = graph->npwgts;
#line 217
  rename___0 = __idxwspacemalloc(ctrl, nvtxs);
#line 219
  snedges[1] = 0L;
#line 219
  snedges[0] = snedges[1];
#line 219
  snvtxs[1] = snedges[0];
#line 219
  snvtxs[0] = snvtxs[1];
#line 220
  i = 0L;
  }
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (i < nvtxs)) {
#line 220
      goto while_break;
    }
#line 221
    k = *(where + i);
#line 222
    tmp___0 = snvtxs[k];
#line 222
    (snvtxs[k]) ++;
#line 222
    *(rename___0 + i) = tmp___0;
#line 223
    snedges[k] += *(xadj + (i + 1L)) - *(xadj + i);
#line 220
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 226
  __SetUpSplitGraph(graph, lgraph, snvtxs[0], snedges[0]);
#line 227
  sxadj[0] = lgraph->xadj;
#line 228
  svwgt[0] = lgraph->vwgt;
#line 229
  snvwgt[0] = lgraph->nvwgt;
#line 230
  sadjwgtsum[0] = lgraph->adjwgtsum;
#line 231
  sadjncy[0] = lgraph->adjncy;
#line 232
  sadjwgt[0] = lgraph->adjwgt;
#line 233
  slabel[0] = lgraph->label;
#line 235
  __SetUpSplitGraph(graph, rgraph, snvtxs[1], snedges[1]);
#line 236
  sxadj[1] = rgraph->xadj;
#line 237
  svwgt[1] = rgraph->vwgt;
#line 238
  snvwgt[1] = rgraph->nvwgt;
#line 239
  sadjwgtsum[1] = rgraph->adjwgtsum;
#line 240
  sadjncy[1] = rgraph->adjncy;
#line 241
  sadjwgt[1] = rgraph->adjwgt;
#line 242
  slabel[1] = rgraph->label;
#line 244
  snedges[1] = 0L;
#line 244
  snedges[0] = snedges[1];
#line 244
  snvtxs[1] = snedges[0];
#line 244
  snvtxs[0] = snvtxs[1];
#line 245
  tmp___1 = (idxtype )0;
#line 245
  *(sxadj[1] + 0) = tmp___1;
#line 245
  *(sxadj[0] + 0) = tmp___1;
#line 246
  i = 0L;
  }
  {
#line 246
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 246
    if (! (i < nvtxs)) {
#line 246
      goto while_break___0;
    }
#line 247
    mypart = *(where + i);
#line 248
    sum = *(adjwgtsum + i);
#line 250
    istart = *(xadj + i);
#line 251
    iend = *(xadj + (i + 1L));
#line 252
    if (*(bndptr + i) == -1L) {
#line 253
      auxadjncy = (sadjncy[mypart] + snedges[mypart]) - istart;
#line 254
      auxadjwgt = (sadjwgt[mypart] + snedges[mypart]) - istart;
#line 255
      j = istart;
      {
#line 255
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 255
        if (! (j < iend)) {
#line 255
          goto while_break___1;
        }
#line 256
        *(auxadjncy + j) = *(adjncy + j);
#line 257
        *(auxadjwgt + j) = *(adjwgt + j);
#line 255
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 259
      snedges[mypart] += iend - istart;
    } else {
#line 262
      auxadjncy = sadjncy[mypart];
#line 263
      auxadjwgt = sadjwgt[mypart];
#line 264
      l = snedges[mypart];
#line 265
      j = istart;
      {
#line 265
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 265
        if (! (j < iend)) {
#line 265
          goto while_break___2;
        }
#line 266
        k = *(adjncy + j);
#line 267
        if (*(where + k) == mypart) {
#line 268
          *(auxadjncy + l) = k;
#line 269
          tmp___2 = l;
#line 269
          l ++;
#line 269
          *(auxadjwgt + tmp___2) = *(adjwgt + j);
        } else {
#line 272
          sum -= *(adjwgt + j);
        }
#line 265
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 275
      snedges[mypart] = l;
    }
#line 278
    if (ncon == 1L) {
#line 279
      *(svwgt[mypart] + snvtxs[mypart]) = *(vwgt + i);
    } else {
#line 281
      kk = 0L;
      {
#line 281
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 281
        if (! (kk < ncon)) {
#line 281
          goto while_break___3;
        }
#line 282
        *(snvwgt[mypart] + (snvtxs[mypart] * ncon + kk)) = *(nvwgt + (i * ncon + kk)) / *(npwgts + (mypart * ncon + kk));
#line 281
        kk ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 285
    *(sadjwgtsum[mypart] + snvtxs[mypart]) = sum;
#line 286
    *(slabel[mypart] + snvtxs[mypart]) = *(label + i);
#line 287
    (snvtxs[mypart]) ++;
#line 287
    *(sxadj[mypart] + snvtxs[mypart]) = snedges[mypart];
#line 246
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 290
  mypart = 0L;
  {
#line 290
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 290
    if (! (mypart < 2L)) {
#line 290
      goto while_break___4;
    }
#line 291
    iend = *(sxadj[mypart] + snvtxs[mypart]);
#line 292
    auxadjncy = sadjncy[mypart];
#line 293
    i = 0L;
    {
#line 293
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 293
      if (! (i < iend)) {
#line 293
        goto while_break___5;
      }
#line 294
      *(auxadjncy + i) = *(rename___0 + *(auxadjncy + i));
#line 293
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 290
    mypart ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 297
  lgraph->nedges = snedges[0];
#line 298
  rgraph->nedges = snedges[1];
#line 300
  if (ctrl->dbglvl & 1L) {
    {
#line 300
    tmp___3 = __seconds();
#line 300
    ctrl->SplitTmr += tmp___3;
    }
  }
  {
#line 302
  __idxwspacefree(ctrl, nvtxs);
  }
#line 303
  return;
}
}
#line 309 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pmetis.c"
void __SetUpSplitGraph(GraphType *graph , GraphType *sgraph , long snvtxs , long snedges ) 
{ 


  {
  {
#line 311
  __InitGraph(sgraph);
#line 312
  sgraph->nvtxs = snvtxs;
#line 313
  sgraph->nedges = snedges;
#line 314
  sgraph->ncon = graph->ncon;
  }
#line 317
  if (graph->ncon == 1L) {
    {
#line 318
    sgraph->gdata = __idxmalloc((4L * snvtxs + 1L) + 2L * snedges, (char *)"SetUpSplitGraph: gdata");
#line 320
    sgraph->xadj = sgraph->gdata;
#line 321
    sgraph->vwgt = (sgraph->gdata + snvtxs) + 1;
#line 322
    sgraph->adjwgtsum = (sgraph->gdata + 2L * snvtxs) + 1;
#line 323
    sgraph->cmap = (sgraph->gdata + 3L * snvtxs) + 1;
#line 324
    sgraph->adjncy = (sgraph->gdata + 4L * snvtxs) + 1;
#line 325
    sgraph->adjwgt = ((sgraph->gdata + 4L * snvtxs) + 1) + snedges;
    }
  } else {
    {
#line 328
    sgraph->gdata = __idxmalloc((3L * snvtxs + 1L) + 2L * snedges, (char *)"SetUpSplitGraph: gdata");
#line 330
    sgraph->xadj = sgraph->gdata;
#line 331
    sgraph->adjwgtsum = (sgraph->gdata + snvtxs) + 1;
#line 332
    sgraph->cmap = (sgraph->gdata + 2L * snvtxs) + 1;
#line 333
    sgraph->adjncy = (sgraph->gdata + 3L * snvtxs) + 1;
#line 334
    sgraph->adjwgt = ((sgraph->gdata + 3L * snvtxs) + 1) + snedges;
#line 336
    sgraph->nvwgt = __fmalloc(graph->ncon * snvtxs, (char *)"SetUpSplitGraph: nvwgt");
    }
  }
  {
#line 339
  sgraph->label = __idxmalloc(snvtxs, (char *)"SetUpSplitGraph: sgraph->label");
  }
#line 340
  return;
}
}
#line 21 "./proto.h"
void __BucketSortKeysInc(long n , long max , idxtype *keys , idxtype *tperm , idxtype *perm ) ;
#line 24
void __CreateCoarseGraph(CtrlType *ctrl , GraphType *graph , long cnvtxs , idxtype *match ,
                         idxtype *perm ) ;
#line 26
void __CreateCoarseGraph_NVW(CtrlType *ctrl , GraphType *graph , long cnvtxs , idxtype *match ,
                             idxtype *perm ) ;
#line 194
void __Match_RM(CtrlType *ctrl , GraphType *graph ) ;
#line 195
void __Match_RM_NVW(CtrlType *ctrl , GraphType *graph ) ;
#line 196
void __Match_HEM(CtrlType *ctrl , GraphType *graph ) ;
#line 197
void __Match_SHEM(CtrlType *ctrl , GraphType *graph ) ;
#line 437
idxtype *__idxset(long n , idxtype val , idxtype *x ) ;
#line 457
void __RandomPermute(long n , idxtype *p , long flag ) ;
#line 22 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/match.c"
void __Match_RM(CtrlType *ctrl , GraphType *graph ) 
{ 
  long i ;
  long ii ;
  long j ;
  long nvtxs ;
  long cnvtxs ;
  long maxidx ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *match ;
  idxtype *cmap ;
  idxtype *perm ;
  double tmp ;
  idxtype *tmp___0 ;
  idxtype tmp___1 ;
  long tmp___2 ;
  double tmp___3 ;

  {
#line 28
  if (ctrl->dbglvl & 1L) {
    {
#line 28
    tmp = __seconds();
#line 28
    ctrl->MatchTmr -= tmp;
    }
  }
  {
#line 30
  nvtxs = graph->nvtxs;
#line 31
  xadj = graph->xadj;
#line 32
  vwgt = graph->vwgt;
#line 33
  adjncy = graph->adjncy;
#line 34
  adjwgt = graph->adjwgt;
#line 36
  cmap = graph->cmap;
#line 37
  tmp___0 = __idxwspacemalloc(ctrl, nvtxs);
#line 37
  match = __idxset(nvtxs, (idxtype )-1, tmp___0);
#line 39
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 40
  __RandomPermute(nvtxs, perm, 1L);
#line 42
  cnvtxs = 0L;
#line 43
  ii = 0L;
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (ii < nvtxs)) {
#line 43
      goto while_break;
    }
#line 44
    i = *(perm + ii);
#line 46
    if (*(match + i) == -1L) {
#line 47
      maxidx = i;
#line 50
      j = *(xadj + i);
      {
#line 50
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 50
        if (! (j < *(xadj + (i + 1L)))) {
#line 50
          goto while_break___0;
        }
#line 51
        if (*(match + *(adjncy + j)) == -1L) {
#line 51
          if (*(vwgt + i) + *(vwgt + *(adjncy + j)) <= ctrl->maxvwgt) {
#line 52
            maxidx = *(adjncy + j);
#line 53
            goto while_break___0;
          }
        }
#line 50
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 57
      tmp___2 = cnvtxs;
#line 57
      cnvtxs ++;
#line 57
      tmp___1 = tmp___2;
#line 57
      *(cmap + maxidx) = tmp___1;
#line 57
      *(cmap + i) = tmp___1;
#line 58
      *(match + i) = maxidx;
#line 59
      *(match + maxidx) = i;
    }
#line 43
    ii ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  if (ctrl->dbglvl & 1L) {
    {
#line 63
    tmp___3 = __seconds();
#line 63
    ctrl->MatchTmr += tmp___3;
    }
  }
  {
#line 65
  __CreateCoarseGraph(ctrl, graph, cnvtxs, match, perm);
#line 67
  __idxwspacefree(ctrl, nvtxs);
#line 68
  __idxwspacefree(ctrl, nvtxs);
  }
#line 69
  return;
}
}
#line 75 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/match.c"
void __Match_RM_NVW(CtrlType *ctrl , GraphType *graph ) 
{ 
  long i ;
  long ii ;
  long j ;
  long nvtxs ;
  long cnvtxs ;
  long maxidx ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *match ;
  idxtype *cmap ;
  idxtype *perm ;
  double tmp ;
  idxtype *tmp___0 ;
  idxtype tmp___1 ;
  long tmp___2 ;
  double tmp___3 ;

  {
#line 81
  if (ctrl->dbglvl & 1L) {
    {
#line 81
    tmp = __seconds();
#line 81
    ctrl->MatchTmr -= tmp;
    }
  }
  {
#line 83
  nvtxs = graph->nvtxs;
#line 84
  xadj = graph->xadj;
#line 85
  adjncy = graph->adjncy;
#line 87
  cmap = graph->cmap;
#line 88
  tmp___0 = __idxwspacemalloc(ctrl, nvtxs);
#line 88
  match = __idxset(nvtxs, (idxtype )-1, tmp___0);
#line 90
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 91
  __RandomPermute(nvtxs, perm, 1L);
#line 93
  cnvtxs = 0L;
#line 94
  ii = 0L;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (ii < nvtxs)) {
#line 94
      goto while_break;
    }
#line 95
    i = *(perm + ii);
#line 97
    if (*(match + i) == -1L) {
#line 98
      maxidx = i;
#line 101
      j = *(xadj + i);
      {
#line 101
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 101
        if (! (j < *(xadj + (i + 1L)))) {
#line 101
          goto while_break___0;
        }
#line 102
        if (*(match + *(adjncy + j)) == -1L) {
#line 103
          maxidx = *(adjncy + j);
#line 104
          goto while_break___0;
        }
#line 101
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 108
      tmp___2 = cnvtxs;
#line 108
      cnvtxs ++;
#line 108
      tmp___1 = tmp___2;
#line 108
      *(cmap + maxidx) = tmp___1;
#line 108
      *(cmap + i) = tmp___1;
#line 109
      *(match + i) = maxidx;
#line 110
      *(match + maxidx) = i;
    }
#line 94
    ii ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if (ctrl->dbglvl & 1L) {
    {
#line 114
    tmp___3 = __seconds();
#line 114
    ctrl->MatchTmr += tmp___3;
    }
  }
  {
#line 116
  __CreateCoarseGraph_NVW(ctrl, graph, cnvtxs, match, perm);
#line 118
  __idxwspacefree(ctrl, nvtxs);
#line 119
  __idxwspacefree(ctrl, nvtxs);
  }
#line 120
  return;
}
}
#line 127 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/match.c"
void __Match_HEM(CtrlType *ctrl , GraphType *graph ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long nvtxs ;
  long cnvtxs ;
  long maxidx ;
  long maxwgt ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *match ;
  idxtype *cmap ;
  idxtype *perm ;
  double tmp ;
  idxtype *tmp___0 ;
  idxtype tmp___1 ;
  long tmp___2 ;
  double tmp___3 ;

  {
#line 133
  if (ctrl->dbglvl & 1L) {
    {
#line 133
    tmp = __seconds();
#line 133
    ctrl->MatchTmr -= tmp;
    }
  }
  {
#line 135
  nvtxs = graph->nvtxs;
#line 136
  xadj = graph->xadj;
#line 137
  vwgt = graph->vwgt;
#line 138
  adjncy = graph->adjncy;
#line 139
  adjwgt = graph->adjwgt;
#line 141
  cmap = graph->cmap;
#line 142
  tmp___0 = __idxwspacemalloc(ctrl, nvtxs);
#line 142
  match = __idxset(nvtxs, (idxtype )-1, tmp___0);
#line 144
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 145
  __RandomPermute(nvtxs, perm, 1L);
#line 147
  cnvtxs = 0L;
#line 148
  ii = 0L;
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (ii < nvtxs)) {
#line 148
      goto while_break;
    }
#line 149
    i = *(perm + ii);
#line 151
    if (*(match + i) == -1L) {
#line 152
      maxidx = i;
#line 153
      maxwgt = 0L;
#line 156
      j = *(xadj + i);
      {
#line 156
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 156
        if (! (j < *(xadj + (i + 1L)))) {
#line 156
          goto while_break___0;
        }
#line 157
        k = *(adjncy + j);
#line 158
        if (*(match + k) == -1L) {
#line 158
          if (maxwgt < *(adjwgt + j)) {
#line 158
            if (*(vwgt + i) + *(vwgt + k) <= ctrl->maxvwgt) {
#line 159
              maxwgt = *(adjwgt + j);
#line 160
              maxidx = *(adjncy + j);
            }
          }
        }
#line 156
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 164
      tmp___2 = cnvtxs;
#line 164
      cnvtxs ++;
#line 164
      tmp___1 = tmp___2;
#line 164
      *(cmap + maxidx) = tmp___1;
#line 164
      *(cmap + i) = tmp___1;
#line 165
      *(match + i) = maxidx;
#line 166
      *(match + maxidx) = i;
    }
#line 148
    ii ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  if (ctrl->dbglvl & 1L) {
    {
#line 170
    tmp___3 = __seconds();
#line 170
    ctrl->MatchTmr += tmp___3;
    }
  }
  {
#line 172
  __CreateCoarseGraph(ctrl, graph, cnvtxs, match, perm);
#line 174
  __idxwspacefree(ctrl, nvtxs);
#line 175
  __idxwspacefree(ctrl, nvtxs);
  }
#line 176
  return;
}
}
#line 183 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/match.c"
void __Match_SHEM(CtrlType *ctrl , GraphType *graph ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long nvtxs ;
  long cnvtxs ;
  long maxidx ;
  long maxwgt ;
  long avgdegree ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *match ;
  idxtype *cmap ;
  idxtype *degrees ;
  idxtype *perm ;
  idxtype *tperm ;
  double tmp ;
  idxtype *tmp___0 ;
  idxtype tmp___1 ;
  long tmp___2 ;
  idxtype tmp___3 ;
  long tmp___4 ;
  double tmp___5 ;

  {
#line 189
  if (ctrl->dbglvl & 1L) {
    {
#line 189
    tmp = __seconds();
#line 189
    ctrl->MatchTmr -= tmp;
    }
  }
  {
#line 191
  nvtxs = graph->nvtxs;
#line 192
  xadj = graph->xadj;
#line 193
  vwgt = graph->vwgt;
#line 194
  adjncy = graph->adjncy;
#line 195
  adjwgt = graph->adjwgt;
#line 197
  cmap = graph->cmap;
#line 198
  tmp___0 = __idxwspacemalloc(ctrl, nvtxs);
#line 198
  match = __idxset(nvtxs, (idxtype )-1, tmp___0);
#line 200
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 201
  tperm = __idxwspacemalloc(ctrl, nvtxs);
#line 202
  degrees = __idxwspacemalloc(ctrl, nvtxs);
#line 204
  __RandomPermute(nvtxs, tperm, 1L);
#line 205
  avgdegree = (long )(0.7 * (double )(*(xadj + nvtxs) / nvtxs));
#line 206
  i = 0L;
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (i < nvtxs)) {
#line 206
      goto while_break;
    }
#line 207
    if (*(xadj + (i + 1L)) - *(xadj + i) > avgdegree) {
#line 207
      *(degrees + i) = avgdegree;
    } else {
#line 207
      *(degrees + i) = *(xadj + (i + 1L)) - *(xadj + i);
    }
#line 206
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  __BucketSortKeysInc(nvtxs, avgdegree, degrees, tperm, perm);
#line 210
  cnvtxs = 0L;
#line 213
  ii = 0L;
  }
  {
#line 213
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 213
    if (! (ii < nvtxs)) {
#line 213
      goto while_break___0;
    }
#line 214
    i = *(perm + ii);
#line 216
    if (*(match + i) == -1L) {
#line 217
      if (*(xadj + i) < *(xadj + (i + 1L))) {
#line 218
        goto while_break___0;
      }
#line 220
      maxidx = i;
#line 221
      j = nvtxs - 1L;
      {
#line 221
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 221
        if (! (j > ii)) {
#line 221
          goto while_break___1;
        }
#line 222
        k = *(perm + j);
#line 223
        if (*(match + k) == -1L) {
#line 223
          if (*(xadj + k) < *(xadj + (k + 1L))) {
#line 224
            maxidx = k;
#line 225
            goto while_break___1;
          }
        }
#line 221
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 229
      tmp___2 = cnvtxs;
#line 229
      cnvtxs ++;
#line 229
      tmp___1 = tmp___2;
#line 229
      *(cmap + maxidx) = tmp___1;
#line 229
      *(cmap + i) = tmp___1;
#line 230
      *(match + i) = maxidx;
#line 231
      *(match + maxidx) = i;
    }
#line 213
    ii ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 236
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 236
    if (! (ii < nvtxs)) {
#line 236
      goto while_break___2;
    }
#line 237
    i = *(perm + ii);
#line 239
    if (*(match + i) == -1L) {
#line 240
      maxidx = i;
#line 241
      maxwgt = 0L;
#line 244
      j = *(xadj + i);
      {
#line 244
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 244
        if (! (j < *(xadj + (i + 1L)))) {
#line 244
          goto while_break___3;
        }
#line 245
        if (*(match + *(adjncy + j)) == -1L) {
#line 245
          if (maxwgt < *(adjwgt + j)) {
#line 245
            if (*(vwgt + i) + *(vwgt + *(adjncy + j)) <= ctrl->maxvwgt) {
#line 246
              maxwgt = *(adjwgt + j);
#line 247
              maxidx = *(adjncy + j);
            }
          }
        }
#line 244
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 251
      tmp___4 = cnvtxs;
#line 251
      cnvtxs ++;
#line 251
      tmp___3 = tmp___4;
#line 251
      *(cmap + maxidx) = tmp___3;
#line 251
      *(cmap + i) = tmp___3;
#line 252
      *(match + i) = maxidx;
#line 253
      *(match + maxidx) = i;
    }
#line 236
    ii ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 257
  if (ctrl->dbglvl & 1L) {
    {
#line 257
    tmp___5 = __seconds();
#line 257
    ctrl->MatchTmr += tmp___5;
    }
  }
  {
#line 259
  __idxwspacefree(ctrl, nvtxs);
#line 260
  __idxwspacefree(ctrl, nvtxs);
#line 262
  __CreateCoarseGraph(ctrl, graph, cnvtxs, match, perm);
#line 264
  __idxwspacefree(ctrl, nvtxs);
#line 265
  __idxwspacefree(ctrl, nvtxs);
  }
#line 266
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 167 "./proto.h"
long __IsBalanced(idxtype *pwgts , long nparts , float *tpwgts , float ubfactor ) ;
#line 172
void __Random_KWayVolRefine(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ,
                            float ubfactor , long npasses , long ffactor ) ;
#line 173
void __Random_KWayVolRefineMConn(CtrlType *ctrl , GraphType *graph , long nparts ,
                                 float *tpwgts , float ubfactor , long npasses , long ffactor ) ;
#line 174
void __Greedy_KWayVolBalance(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ,
                             float ubfactor , long npasses ) ;
#line 175
void __Greedy_KWayVolBalanceMConn(CtrlType *ctrl , GraphType *graph , long nparts ,
                                  float *tpwgts , float ubfactor , long npasses ) ;
#line 181
void __EliminateVolSubDomainEdges(CtrlType *ctrl , GraphType *graph , long nparts ,
                                  float *tpwgts ) ;
#line 182
void EliminateVolComponents(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ,
                            float ubfactor ) ;
#line 185
void __RefineVolKWay(CtrlType *ctrl , GraphType *orggraph , GraphType *graph , long nparts ,
                     float *tpwgts , float ubfactor ) ;
#line 186
void __AllocateVolKWayPartitionMemory(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 187
void __ComputeVolKWayPartitionParams(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 188
void __ComputeKWayVolGains(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 189
void __ProjectVolKWayPartition(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 190
void __ComputeVolKWayBoundary(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 191
void __ComputeVolKWayBalanceBoundary(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 221
void __FreeGraph(GraphType *graph ) ;
#line 20 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolrefine.c"
void __RefineVolKWay(CtrlType *ctrl , GraphType *orggraph , GraphType *graph , long nparts ,
                     float *tpwgts , float ubfactor ) 
{ 
  long i ;
  long nlevels ;
  GraphType *ptr ;
  double tmp ;
  double tmp___0 ;
  long tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  long tmp___5 ;
  double tmp___6 ;

  {
#line 26
  if (ctrl->dbglvl & 1L) {
    {
#line 26
    tmp = __seconds();
#line 26
    ctrl->UncoarsenTmr -= tmp;
    }
  }
#line 29
  if (ctrl->RType == 3L) {
    {
#line 30
    __ComputeVolKWayPartitionParams(ctrl, graph, nparts);
#line 31
    EliminateVolComponents(ctrl, graph, nparts, tpwgts, (float )1.25);
#line 32
    __EliminateVolSubDomainEdges(ctrl, graph, nparts, tpwgts);
#line 33
    EliminateVolComponents(ctrl, graph, nparts, tpwgts, (float )1.25);
    }
  }
#line 38
  ptr = graph;
#line 38
  nlevels = 0L;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! ((unsigned long )ptr != (unsigned long )orggraph)) {
#line 38
      goto while_break;
    }
#line 38
    ptr = ptr->finer;
#line 38
    nlevels ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 41
  __ComputeVolKWayPartitionParams(ctrl, graph, nparts);
#line 43
  i = 0L;
  }
  {
#line 43
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 46
    if (ctrl->dbglvl & 1L) {
      {
#line 46
      tmp___0 = __seconds();
#line 46
      ctrl->RefTmr -= tmp___0;
      }
    }
#line 48
    if (2L * i >= nlevels) {
      {
#line 48
      tmp___1 = __IsBalanced(graph->pwgts, nparts, tpwgts, (float )(1.04 * (double )ubfactor));
      }
#line 48
      if (! tmp___1) {
        {
#line 49
        __ComputeVolKWayBalanceBoundary(ctrl, graph, nparts);
        }
        {
#line 51
        if (ctrl->RType == 1L) {
#line 51
          goto case_1;
        }
#line 54
        if (ctrl->RType == 3L) {
#line 54
          goto case_3;
        }
#line 50
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 52
        __Greedy_KWayVolBalance(ctrl, graph, nparts, tpwgts, ubfactor, 1L);
        }
#line 53
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 55
        __Greedy_KWayVolBalanceMConn(ctrl, graph, nparts, tpwgts, ubfactor, 1L);
        }
#line 56
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 58
        __ComputeVolKWayBoundary(ctrl, graph, nparts);
        }
      }
    }
    {
#line 62
    if (ctrl->RType == 1L) {
#line 62
      goto case_1___0;
    }
#line 65
    if (ctrl->RType == 3L) {
#line 65
      goto case_3___0;
    }
#line 61
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 63
    __Random_KWayVolRefine(ctrl, graph, nparts, tpwgts, ubfactor, 10L, 0L);
    }
#line 64
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 66
    __Random_KWayVolRefineMConn(ctrl, graph, nparts, tpwgts, ubfactor, 10L, 0L);
    }
#line 67
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 69
    if (ctrl->dbglvl & 1L) {
      {
#line 69
      tmp___2 = __seconds();
#line 69
      ctrl->RefTmr += tmp___2;
      }
    }
#line 71
    if ((unsigned long )graph == (unsigned long )orggraph) {
#line 72
      goto while_break___0;
    }
    {
#line 74
    __GKfree(& graph->gdata, (void **)0);
#line 76
    graph = graph->finer;
    }
#line 78
    if (ctrl->dbglvl & 1L) {
      {
#line 78
      tmp___3 = __seconds();
#line 78
      ctrl->ProjectTmr -= tmp___3;
      }
    }
    {
#line 79
    __ProjectVolKWayPartition(ctrl, graph, nparts);
    }
#line 80
    if (ctrl->dbglvl & 1L) {
      {
#line 80
      tmp___4 = __seconds();
#line 80
      ctrl->ProjectTmr += tmp___4;
      }
    }
#line 43
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 83
  tmp___5 = __IsBalanced(graph->pwgts, nparts, tpwgts, ubfactor);
  }
#line 83
  if (! tmp___5) {
    {
#line 84
    __ComputeVolKWayBalanceBoundary(ctrl, graph, nparts);
    }
    {
#line 86
    if (ctrl->RType == 1L) {
#line 86
      goto case_1___1;
    }
#line 90
    if (ctrl->RType == 3L) {
#line 90
      goto case_3___1;
    }
#line 85
    goto switch_break___1;
    case_1___1: /* CIL Label */ 
    {
#line 87
    __Greedy_KWayVolBalance(ctrl, graph, nparts, tpwgts, ubfactor, 8L);
#line 88
    __Random_KWayVolRefine(ctrl, graph, nparts, tpwgts, ubfactor, 10L, 0L);
    }
#line 89
    goto switch_break___1;
    case_3___1: /* CIL Label */ 
    {
#line 91
    __Greedy_KWayVolBalanceMConn(ctrl, graph, nparts, tpwgts, ubfactor, 8L);
#line 92
    __Random_KWayVolRefineMConn(ctrl, graph, nparts, tpwgts, ubfactor, 10L, 0L);
    }
#line 93
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
  {
#line 97
  EliminateVolComponents(ctrl, graph, nparts, tpwgts, ubfactor);
  }
#line 99
  if (ctrl->dbglvl & 1L) {
    {
#line 99
    tmp___6 = __seconds();
#line 99
    ctrl->UncoarsenTmr += tmp___6;
    }
  }
#line 100
  return;
}
}
#line 107 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolrefine.c"
void __AllocateVolKWayPartitionMemory(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long nvtxs ;
  long pad64 ;

  {
  {
#line 111
  nvtxs = graph->nvtxs;
#line 113
  pad64 = (3L * nvtxs + nparts) % 2L;
#line 115
  graph->rdata = __idxmalloc((long )(((unsigned long )(3L * nvtxs + nparts) + (sizeof(VRInfoType ) / sizeof(idxtype )) * (unsigned long )nvtxs) + (unsigned long )pad64),
                             (char *)"AllocateVolKWayPartitionMemory: rdata");
#line 116
  graph->pwgts = graph->rdata;
#line 117
  graph->where = graph->rdata + nparts;
#line 118
  graph->bndptr = (graph->rdata + nvtxs) + nparts;
#line 119
  graph->bndind = (graph->rdata + 2L * nvtxs) + nparts;
#line 120
  graph->vrinfo = (VRInfoType *)(((graph->rdata + 3L * nvtxs) + nparts) + pad64);
  }
#line 122
  return;
}
}
#line 129 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolrefine.c"
void __ComputeVolKWayPartitionParams(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long i ;
  long j ;
  long k ;
  long nvtxs ;
  long mincut ;
  long me ;
  long other ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *pwgts ;
  idxtype *where ;
  VRInfoType *rinfo ;
  VRInfoType *myrinfo ;
  VEDegreeType *myedegrees ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  VEDegreeType *tmp___2 ;
  long tmp___3 ;

  {
  {
#line 136
  nvtxs = graph->nvtxs;
#line 137
  xadj = graph->xadj;
#line 138
  vwgt = graph->vwgt;
#line 139
  adjncy = graph->adjncy;
#line 140
  adjwgt = graph->adjwgt;
#line 142
  where = graph->where;
#line 143
  pwgts = __idxset(nparts, (idxtype )0, graph->pwgts);
#line 144
  rinfo = graph->vrinfo;
#line 150
  ctrl->wspace.cdegree = 0L;
#line 151
  mincut = 0L;
#line 152
  i = 0L;
  }
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (i < nvtxs)) {
#line 152
      goto while_break;
    }
#line 153
    me = *(where + i);
#line 154
    *(pwgts + me) += *(vwgt + i);
#line 156
    myrinfo = rinfo + i;
#line 157
    tmp___1 = 0L;
#line 157
    myrinfo->ndegrees = tmp___1;
#line 157
    tmp___0 = tmp___1;
#line 157
    myrinfo->nid = tmp___0;
#line 157
    tmp = tmp___0;
#line 157
    myrinfo->ed = tmp;
#line 157
    myrinfo->id = tmp;
#line 158
    myrinfo->edegrees = (VEDegreeType *)((void *)0);
#line 160
    j = *(xadj + i);
    {
#line 160
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 160
      if (! (j < *(xadj + (i + 1L)))) {
#line 160
        goto while_break___0;
      }
#line 161
      if (me == *(where + *(adjncy + j))) {
#line 162
        myrinfo->id += *(adjwgt + j);
#line 163
        (myrinfo->nid) ++;
      }
#line 160
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 166
    myrinfo->ed = *(graph->adjwgtsum + i) - myrinfo->id;
#line 168
    mincut += myrinfo->ed;
#line 171
    if (myrinfo->ed > 0L) {
#line 172
      tmp___2 = ctrl->wspace.vedegrees + ctrl->wspace.cdegree;
#line 172
      myrinfo->edegrees = tmp___2;
#line 172
      myedegrees = tmp___2;
#line 173
      ctrl->wspace.cdegree += *(xadj + (i + 1L)) - *(xadj + i);
#line 175
      j = *(xadj + i);
      {
#line 175
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 175
        if (! (j < *(xadj + (i + 1L)))) {
#line 175
          goto while_break___1;
        }
#line 176
        other = *(where + *(adjncy + j));
#line 177
        if (me != other) {
#line 178
          k = 0L;
          {
#line 178
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 178
            if (! (k < myrinfo->ndegrees)) {
#line 178
              goto while_break___2;
            }
#line 179
            if ((myedegrees + k)->pid == other) {
#line 180
              (myedegrees + k)->ed += *(adjwgt + j);
#line 181
              ((myedegrees + k)->ned) ++;
#line 182
              goto while_break___2;
            }
#line 178
            k ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 185
          if (k == myrinfo->ndegrees) {
#line 186
            (myedegrees + myrinfo->ndegrees)->gv = (idxtype )0;
#line 187
            (myedegrees + myrinfo->ndegrees)->pid = other;
#line 188
            (myedegrees + myrinfo->ndegrees)->ed = *(adjwgt + j);
#line 189
            tmp___3 = myrinfo->ndegrees;
#line 189
            (myrinfo->ndegrees) ++;
#line 189
            (myedegrees + tmp___3)->ned = (idxtype )1;
          }
        }
#line 175
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 152
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 197
  graph->mincut = mincut / 2L;
#line 200
  __ComputeKWayVolGains(ctrl, graph, nparts);
  }
#line 202
  return;
}
}
#line 209 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolrefine.c"
void __ComputeKWayVolGains(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long kk ;
  long nvtxs ;
  long me ;
  long other ;
  long myndegrees ;
  idxtype *xadj ;
  idxtype *vsize ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *bndind ;
  idxtype *bndptr ;
  idxtype *ophtable ;
  VRInfoType *rinfo ;
  VRInfoType *myrinfo ;
  VRInfoType *orinfo ;
  VEDegreeType *myedegrees ;
  VEDegreeType *oedegrees ;
  idxtype *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 216
  nvtxs = graph->nvtxs;
#line 217
  xadj = graph->xadj;
#line 218
  vsize = graph->vsize;
#line 219
  adjncy = graph->adjncy;
#line 220
  adjwgt = graph->adjwgt;
#line 222
  where = graph->where;
#line 223
  bndind = graph->bndind;
#line 224
  bndptr = __idxset(nvtxs, (idxtype )-1, graph->bndptr);
#line 225
  rinfo = graph->vrinfo;
#line 227
  tmp = __idxwspacemalloc(ctrl, nparts);
#line 227
  ophtable = __idxset(nparts, (idxtype )-1, tmp);
#line 232
  tmp___0 = 0L;
#line 232
  graph->nbnd = tmp___0;
#line 232
  graph->minvol = tmp___0;
#line 233
  i = 0L;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (i < nvtxs)) {
#line 233
      goto while_break;
    }
#line 234
    myrinfo = rinfo + i;
#line 235
    myrinfo->gv = - (1L << (8UL * sizeof(idxtype ) - 2UL));
#line 237
    if (myrinfo->ndegrees > 0L) {
#line 238
      me = *(where + i);
#line 239
      myedegrees = myrinfo->edegrees;
#line 240
      myndegrees = myrinfo->ndegrees;
#line 242
      graph->minvol += myndegrees * *(vsize + i);
#line 244
      j = *(xadj + i);
      {
#line 244
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 244
        if (! (j < *(xadj + (i + 1L)))) {
#line 244
          goto while_break___0;
        }
#line 245
        ii = *(adjncy + j);
#line 246
        other = *(where + ii);
#line 247
        orinfo = rinfo + ii;
#line 248
        oedegrees = orinfo->edegrees;
#line 250
        k = 0L;
        {
#line 250
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 250
          if (! (k < orinfo->ndegrees)) {
#line 250
            goto while_break___1;
          }
#line 251
          *(ophtable + (oedegrees + k)->pid) = k;
#line 250
          k ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 252
        *(ophtable + other) = (idxtype )1;
#line 254
        if (me == other) {
#line 256
          k = 0L;
          {
#line 256
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 256
            if (! (k < myndegrees)) {
#line 256
              goto while_break___2;
            }
#line 257
            if (*(ophtable + (myedegrees + k)->pid) == -1L) {
#line 258
              (myedegrees + k)->gv -= *(vsize + ii);
            }
#line 256
            k ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else
#line 264
        if ((oedegrees + *(ophtable + me))->ned == 1L) {
#line 266
          k = 0L;
          {
#line 266
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 266
            if (! (k < myndegrees)) {
#line 266
              goto while_break___3;
            }
#line 267
            if (*(ophtable + (myedegrees + k)->pid) != -1L) {
#line 268
              (myedegrees + k)->gv += *(vsize + ii);
            }
#line 266
            k ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        } else {
#line 273
          k = 0L;
          {
#line 273
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 273
            if (! (k < myndegrees)) {
#line 273
              goto while_break___4;
            }
#line 274
            if (*(ophtable + (myedegrees + k)->pid) == -1L) {
#line 275
              (myedegrees + k)->gv -= *(vsize + ii);
            }
#line 273
            k ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 280
        kk = 0L;
        {
#line 280
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 280
          if (! (kk < orinfo->ndegrees)) {
#line 280
            goto while_break___5;
          }
#line 281
          *(ophtable + (oedegrees + kk)->pid) = (idxtype )-1;
#line 280
          kk ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 282
        *(ophtable + other) = (idxtype )-1;
#line 244
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 286
      k = 0L;
      {
#line 286
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 286
        if (! (k < myndegrees)) {
#line 286
          goto while_break___6;
        }
#line 287
        if ((myedegrees + k)->gv > myrinfo->gv) {
#line 288
          myrinfo->gv = (myedegrees + k)->gv;
        }
#line 286
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 292
    if (myrinfo->ed > 0L) {
#line 292
      if (myrinfo->id == 0L) {
#line 293
        myrinfo->gv += *(vsize + i);
      }
    }
#line 295
    if (myrinfo->gv >= 0L) {
#line 295
      goto _L;
    } else
#line 295
    if (myrinfo->ed - myrinfo->id >= 0L) {
      _L: /* CIL Label */ 
      {
#line 296
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 296
        *(bndind + graph->nbnd) = i;
#line 296
        tmp___1 = graph->nbnd;
#line 296
        (graph->nbnd) ++;
#line 296
        *(bndptr + i) = tmp___1;
#line 296
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 233
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 299
  __idxwspacefree(ctrl, nparts);
  }
#line 301
  return;
}
}
#line 309 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolrefine.c"
void __ProjectVolKWayPartition(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long i ;
  long j ;
  long k ;
  long nvtxs ;
  long me ;
  long other ;
  long istart ;
  long iend ;
  long ndegrees ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *adjwgtsum ;
  idxtype *cmap ;
  idxtype *where ;
  idxtype *cwhere ;
  GraphType *cgraph ;
  VRInfoType *crinfo ;
  VRInfoType *rinfo ;
  VRInfoType *myrinfo ;
  VEDegreeType *myedegrees ;
  idxtype *htable ;
  idxtype *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  VEDegreeType *tmp___3 ;
  long tmp___4 ;

  {
  {
#line 320
  cgraph = graph->coarser;
#line 321
  cwhere = cgraph->where;
#line 322
  crinfo = cgraph->vrinfo;
#line 324
  nvtxs = graph->nvtxs;
#line 325
  cmap = graph->cmap;
#line 326
  xadj = graph->xadj;
#line 327
  adjncy = graph->adjncy;
#line 328
  adjwgt = graph->adjwgt;
#line 329
  adjwgtsum = graph->adjwgtsum;
#line 331
  __AllocateVolKWayPartitionMemory(ctrl, graph, nparts);
#line 332
  where = graph->where;
#line 333
  rinfo = graph->vrinfo;
#line 336
  i = 0L;
  }
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (i < nvtxs)) {
#line 336
      goto while_break;
    }
#line 337
    k = *(cmap + i);
#line 338
    *(where + i) = *(cwhere + k);
#line 339
    *(cmap + i) = (crinfo + k)->ed;
#line 336
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 342
  tmp = __idxwspacemalloc(ctrl, nparts);
#line 342
  htable = __idxset(nparts, (idxtype )-1, tmp);
#line 344
  ctrl->wspace.cdegree = 0L;
#line 345
  i = 0L;
  }
  {
#line 345
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 345
    if (! (i < nvtxs)) {
#line 345
      goto while_break___0;
    }
#line 346
    me = *(where + i);
#line 348
    myrinfo = rinfo + i;
#line 349
    tmp___2 = 0L;
#line 349
    myrinfo->ndegrees = tmp___2;
#line 349
    tmp___1 = tmp___2;
#line 349
    myrinfo->nid = tmp___1;
#line 349
    tmp___0 = tmp___1;
#line 349
    myrinfo->ed = tmp___0;
#line 349
    myrinfo->id = tmp___0;
#line 350
    myrinfo->edegrees = (VEDegreeType *)((void *)0);
#line 352
    myrinfo->id = *(adjwgtsum + i);
#line 353
    myrinfo->nid = *(xadj + (i + 1L)) - *(xadj + i);
#line 355
    if (*(cmap + i) > 0L) {
#line 356
      istart = *(xadj + i);
#line 357
      iend = *(xadj + (i + 1L));
#line 359
      tmp___3 = ctrl->wspace.vedegrees + ctrl->wspace.cdegree;
#line 359
      myrinfo->edegrees = tmp___3;
#line 359
      myedegrees = tmp___3;
#line 360
      ctrl->wspace.cdegree += iend - istart;
#line 362
      ndegrees = 0L;
#line 363
      j = istart;
      {
#line 363
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 363
        if (! (j < iend)) {
#line 363
          goto while_break___1;
        }
#line 364
        other = *(where + *(adjncy + j));
#line 365
        if (me != other) {
#line 366
          myrinfo->ed += *(adjwgt + j);
#line 367
          (myrinfo->nid) --;
#line 368
          k = *(htable + other);
#line 368
          if (k == -1L) {
#line 369
            *(htable + other) = ndegrees;
#line 370
            (myedegrees + ndegrees)->gv = (idxtype )0;
#line 371
            (myedegrees + ndegrees)->pid = other;
#line 372
            (myedegrees + ndegrees)->ed = *(adjwgt + j);
#line 373
            tmp___4 = ndegrees;
#line 373
            ndegrees ++;
#line 373
            (myedegrees + tmp___4)->ned = (idxtype )1;
          } else {
#line 376
            (myedegrees + k)->ed += *(adjwgt + j);
#line 377
            ((myedegrees + k)->ned) ++;
          }
        }
#line 363
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 381
      myrinfo->id -= myrinfo->ed;
#line 384
      if (myrinfo->ed == 0L) {
#line 385
        myrinfo->edegrees = (VEDegreeType *)((void *)0);
#line 386
        ctrl->wspace.cdegree -= iend - istart;
      } else {
#line 389
        myrinfo->ndegrees = ndegrees;
#line 391
        j = 0L;
        {
#line 391
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 391
          if (! (j < ndegrees)) {
#line 391
            goto while_break___2;
          }
#line 392
          *(htable + (myedegrees + j)->pid) = (idxtype )-1;
#line 391
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 345
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 397
  __ComputeKWayVolGains(ctrl, graph, nparts);
#line 399
  memcpy((void */* __restrict  */)((void *)graph->pwgts), (void const   */* __restrict  */)((void *)cgraph->pwgts),
         sizeof(idxtype ) * (unsigned long )nparts);
#line 400
  graph->mincut = cgraph->mincut;
#line 402
  __FreeGraph(graph->coarser);
#line 403
  graph->coarser = (struct graphdef *)((void *)0);
#line 405
  __idxwspacefree(ctrl, nparts);
  }
#line 407
  return;
}
}
#line 414 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolrefine.c"
void __ComputeVolKWayBoundary(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long i ;
  long nvtxs ;
  long nbnd ;
  idxtype *bndind ;
  idxtype *bndptr ;
  long tmp ;

  {
  {
#line 419
  nvtxs = graph->nvtxs;
#line 420
  bndind = graph->bndind;
#line 421
  bndptr = __idxset(nvtxs, (idxtype )-1, graph->bndptr);
#line 427
  nbnd = 0L;
#line 428
  i = 0L;
  }
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! (i < nvtxs)) {
#line 428
      goto while_break;
    }
#line 429
    if ((graph->vrinfo + i)->gv >= 0L) {
#line 429
      goto _L;
    } else
#line 429
    if ((graph->vrinfo + i)->ed - (graph->vrinfo + i)->id >= 0L) {
      _L: /* CIL Label */ 
      {
#line 430
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 430
        *(bndind + nbnd) = i;
#line 430
        tmp = nbnd;
#line 430
        nbnd ++;
#line 430
        *(bndptr + i) = tmp;
#line 430
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 428
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 433
  graph->nbnd = nbnd;
#line 434
  return;
}
}
#line 439 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolrefine.c"
void __ComputeVolKWayBalanceBoundary(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long i ;
  long nvtxs ;
  long nbnd ;
  idxtype *bndind ;
  idxtype *bndptr ;
  long tmp ;

  {
  {
#line 444
  nvtxs = graph->nvtxs;
#line 445
  bndind = graph->bndind;
#line 446
  bndptr = __idxset(nvtxs, (idxtype )-1, graph->bndptr);
#line 452
  nbnd = 0L;
#line 453
  i = 0L;
  }
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    if (! (i < nvtxs)) {
#line 453
      goto while_break;
    }
#line 454
    if ((graph->vrinfo + i)->ed > 0L) {
      {
#line 455
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 455
        *(bndind + nbnd) = i;
#line 455
        tmp = nbnd;
#line 455
        nbnd ++;
#line 455
        *(bndptr + i) = tmp;
#line 455
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 453
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  graph->nbnd = nbnd;
#line 459
  return;
}
}
#line 181 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 217 "./proto.h"
float *__fwspacemalloc(CtrlType *ctrl , long n ) ;
#line 218
void fwspacefree(CtrlType *ctrl , long n ) ;
#line 241
void __Compute2WayHLoadImbalanceVec(long ncon , float *npwgts , float *tpwgts , float *lbvec ) ;
#line 245
void __SelectQueue2(long ncon , float *npwgts , float *tpwgts , long *from , long *cnum ,
                    PQueueType (*queues)[2] , float *maxwgt ) ;
#line 246
long __IsBetter2wayBalance(long ncon , float *newbal , float *oldbal , float *ubvec ) ;
#line 330
long __AreAllBelow(long ncon , float *v1 , float *v2 ) ;
#line 367
void __PQueueInit(CtrlType *ctrl , PQueueType *queue , long maxnodes , long maxgain ) ;
#line 368
void __PQueueReset(PQueueType *queue ) ;
#line 369
void __PQueueFree(CtrlType *ctrl , PQueueType *queue ) ;
#line 370
long PQueueGetSize(PQueueType *queue ) ;
#line 371
long __PQueueInsert(PQueueType *queue , long node , long gain ) ;
#line 372
long __PQueueDelete(PQueueType *queue , long node , long gain ) ;
#line 373
long __PQueueUpdate(PQueueType *queue , long node , long oldgain , long newgain ) ;
#line 375
long __PQueueGetMax(PQueueType *queue ) ;
#line 377
long PQueueGetKey(PQueueType *queue ) ;
#line 442
long __samax(long n , float *x ) ;
#line 456
void __saxpy(long n , float alpha , float *x , long incx , float *y , long incy ) ;
#line 20 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mfm2.c"
void __MocFM_2WayEdgeRefine2(CtrlType *ctrl , GraphType *graph , float *tpwgts , float *orgubvec ,
                             long npasses ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long l ;
  long kwgt ;
  long nvtxs ;
  long ncon ;
  long nbnd ;
  long nswaps ;
  long from ;
  long to ;
  long pass ;
  long limit ;
  long tmp ;
  long cnum ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *id ;
  idxtype *ed ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *moved ;
  idxtype *swaps ;
  idxtype *perm ;
  idxtype *qnum ;
  float *nvwgt ;
  float *npwgts ;
  float origdiff[16] ;
  float origbal[16] ;
  float minbal[16] ;
  PQueueType parts[16][2] ;
  long higain ;
  long oldgain ;
  long mincut ;
  long initcut ;
  long newcut ;
  long mincutorder ;
  float *maxwgt ;
  float *minwgt ;
  float ubvec[16] ;
  float tvec[16] ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  idxtype tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;

  {
  {
#line 31
  nvtxs = graph->nvtxs;
#line 32
  ncon = graph->ncon;
#line 33
  xadj = graph->xadj;
#line 34
  nvwgt = graph->nvwgt;
#line 35
  adjncy = graph->adjncy;
#line 36
  adjwgt = graph->adjwgt;
#line 37
  where = graph->where;
#line 38
  id = graph->id;
#line 39
  ed = graph->ed;
#line 40
  npwgts = graph->npwgts;
#line 41
  bndptr = graph->bndptr;
#line 42
  bndind = graph->bndind;
#line 44
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 45
  swaps = __idxwspacemalloc(ctrl, nvtxs);
#line 46
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 47
  qnum = __idxwspacemalloc(ctrl, nvtxs);
  }
#line 49
  if (0.01 * (double )nvtxs >= (double )15) {
#line 49
    tmp___2 = 0.01 * (double )nvtxs;
  } else {
#line 49
    tmp___2 = (double )15;
  }
#line 49
  if (tmp___2 >= (double )100) {
#line 49
    limit = 100L;
  } else {
#line 49
    if (0.01 * (double )nvtxs >= (double )15) {
#line 49
      tmp___1 = 0.01 * (double )nvtxs;
    } else {
#line 49
      tmp___1 = (double )15;
    }
#line 49
    limit = (long )tmp___1;
  }
  {
#line 51
  __Compute2WayHLoadImbalanceVec(ncon, npwgts, tpwgts, origbal);
#line 52
  i = 0L;
  }
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (i < ncon)) {
#line 52
      goto while_break;
    }
    {
#line 53
    tmp___3 = fabs((double )(*(tpwgts + 0) - *(npwgts + i)));
#line 53
    origdiff[i] = (float )tmp___3;
    }
#line 54
    if (origbal[i] >= *(orgubvec + i)) {
#line 54
      ubvec[i] = origbal[i];
    } else {
#line 54
      ubvec[i] = *(orgubvec + i);
    }
#line 52
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  minwgt = __fwspacemalloc(ctrl, 2L * ncon);
#line 59
  maxwgt = __fwspacemalloc(ctrl, 2L * ncon);
#line 61
  i = 0L;
  }
  {
#line 61
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 61
    if (! (i < 2L)) {
#line 61
      goto while_break___0;
    }
#line 62
    j = 0L;
    {
#line 62
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 62
      if (! (j < ncon)) {
#line 62
        goto while_break___1;
      }
#line 63
      *(maxwgt + (i * ncon + j)) = *(tpwgts + i) * ubvec[j];
#line 64
      *(minwgt + (i * ncon + j)) = (float )((double )*(tpwgts + i) * (1.0 / (double )ubvec[j]));
#line 62
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 61
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 69
  i = 0L;
  {
#line 69
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 69
    if (! (i < ncon)) {
#line 69
      goto while_break___2;
    }
    {
#line 70
    __PQueueInit(ctrl, & parts[i][0], nvtxs, 501L);
#line 71
    __PQueueInit(ctrl, & parts[i][1], nvtxs, 501L);
#line 69
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 73
  i = 0L;
  {
#line 73
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 73
    if (! (i < nvtxs)) {
#line 73
      goto while_break___3;
    }
    {
#line 74
    *(qnum + i) = __samax(ncon, nvwgt + i * ncon);
#line 73
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 77
  if (ctrl->dbglvl & 8L) {
    {
#line 78
    printf((char const   */* __restrict  */)"Parts: [");
#line 79
    l = 0L;
    }
    {
#line 79
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 79
      if (! (l < ncon)) {
#line 79
        goto while_break___4;
      }
      {
#line 80
      printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
             (double )*(npwgts + (ncon + l)));
#line 79
      l ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 81
    printf((char const   */* __restrict  */)"] T[%.3f %.3f], Nv-Nb[%5ld, %5ld]. ICut: %6ld, LB: ",
           (double )*(tpwgts + 0), (double )*(tpwgts + 1), graph->nvtxs, graph->nbnd,
           graph->mincut);
#line 83
    i = 0L;
    }
    {
#line 83
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 83
      if (! (i < ncon)) {
#line 83
        goto while_break___5;
      }
      {
#line 84
      printf((char const   */* __restrict  */)"%.3f ", (double )origbal[i]);
#line 83
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 85
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 88
  __idxset(nvtxs, (idxtype )-1, moved);
#line 89
  pass = 0L;
  }
  {
#line 89
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 89
    if (! (pass < npasses)) {
#line 89
      goto while_break___6;
    }
#line 90
    i = 0L;
    {
#line 90
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 90
      if (! (i < ncon)) {
#line 90
        goto while_break___7;
      }
      {
#line 91
      __PQueueReset(& parts[i][0]);
#line 92
      __PQueueReset(& parts[i][1]);
#line 90
      i ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 95
    mincutorder = -1L;
#line 96
    initcut = graph->mincut;
#line 96
    mincut = initcut;
#line 96
    newcut = mincut;
#line 97
    __Compute2WayHLoadImbalanceVec(ncon, npwgts, tpwgts, minbal);
#line 103
    nbnd = graph->nbnd;
#line 104
    __RandomPermute(nbnd, perm, 1L);
#line 105
    ii = 0L;
    }
    {
#line 105
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 105
      if (! (ii < nbnd)) {
#line 105
        goto while_break___8;
      }
      {
#line 106
      i = *(bndind + *(perm + ii));
#line 109
      __PQueueInsert(& parts[*(qnum + i)][*(where + i)], i, *(ed + i) - *(id + i));
#line 105
      ii ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
#line 112
    nswaps = 0L;
    {
#line 112
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 112
      if (! (nswaps < nvtxs)) {
#line 112
        goto while_break___9;
      }
      {
#line 113
      __SelectQueue2(ncon, npwgts, tpwgts, & from, & cnum, (PQueueType (*)[2])(parts),
                     maxwgt);
#line 114
      to = (from + 1L) % 2L;
      }
#line 116
      if (from == -1L) {
#line 117
        goto while_break___9;
      } else {
        {
#line 116
        higain = __PQueueGetMax(& parts[cnum][from]);
        }
#line 116
        if (higain == -1L) {
#line 117
          goto while_break___9;
        }
      }
      {
#line 120
      newcut -= *(ed + higain) - *(id + higain);
#line 121
      __saxpy(ncon, (float )1.0, nvwgt + higain * ncon, 1L, npwgts + to * ncon, 1L);
#line 122
      __saxpy(ncon, (float )(- 1.0), nvwgt + higain * ncon, 1L, npwgts + from * ncon,
              1L);
#line 124
      __Compute2WayHLoadImbalanceVec(ncon, npwgts, tpwgts, tvec);
      }
#line 125
      if (newcut < mincut) {
        {
#line 125
        tmp___4 = __AreAllBelow(ncon, tvec, ubvec);
        }
#line 125
        if (tmp___4) {
#line 125
          goto _L;
        } else {
#line 125
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 125
      if (newcut == mincut) {
        {
#line 125
        tmp___5 = __IsBetter2wayBalance(ncon, tvec, minbal, ubvec);
        }
#line 125
        if (tmp___5) {
          _L: /* CIL Label */ 
#line 127
          mincut = newcut;
#line 128
          i = 0L;
          {
#line 128
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 128
            if (! (i < ncon)) {
#line 128
              goto while_break___10;
            }
#line 129
            minbal[i] = tvec[i];
#line 128
            i ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 130
          mincutorder = nswaps;
        } else {
#line 125
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 132
      if (nswaps - mincutorder > limit) {
        {
#line 133
        newcut += *(ed + higain) - *(id + higain);
#line 134
        __saxpy(ncon, (float )1.0, nvwgt + higain * ncon, 1L, npwgts + from * ncon,
                1L);
#line 135
        __saxpy(ncon, (float )(- 1.0), nvwgt + higain * ncon, 1L, npwgts + to * ncon,
                1L);
        }
#line 136
        goto while_break___9;
      }
#line 139
      *(where + higain) = to;
#line 140
      *(moved + higain) = nswaps;
#line 141
      *(swaps + nswaps) = higain;
#line 143
      if (ctrl->dbglvl & 32L) {
        {
#line 144
        printf((char const   */* __restrict  */)"Moved %6ld from %ld(%ld). Gain: %5ld, Cut: %5ld, NPwgts: ",
               higain, from, cnum, *(ed + higain) - *(id + higain), newcut);
#line 145
        l = 0L;
        }
        {
#line 145
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 145
          if (! (l < ncon)) {
#line 145
            goto while_break___11;
          }
          {
#line 146
          printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
                 (double )*(npwgts + (ncon + l)));
#line 145
          l ++;
          }
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 148
        printf((char const   */* __restrict  */)", LB: ");
#line 149
        i = 0L;
        }
        {
#line 149
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 149
          if (! (i < ncon)) {
#line 149
            goto while_break___12;
          }
          {
#line 150
          printf((char const   */* __restrict  */)"%.3f ", (double )tvec[i]);
#line 149
          i ++;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
#line 151
        if (mincutorder == nswaps) {
          {
#line 152
          printf((char const   */* __restrict  */)" *\n");
          }
        } else {
          {
#line 154
          printf((char const   */* __restrict  */)"\n");
          }
        }
      }
      {
#line 161
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 161
        tmp = *(id + higain);
#line 161
        *(id + higain) = *(ed + higain);
#line 161
        *(ed + higain) = tmp;
#line 161
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 162
      if (*(ed + higain) == 0L) {
#line 162
        if (*(xadj + higain) < *(xadj + (higain + 1L))) {
          {
#line 163
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 163
            nbnd --;
#line 163
            *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 163
            *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 163
            *(bndptr + higain) = (idxtype )-1;
#line 163
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
      }
#line 165
      j = *(xadj + higain);
      {
#line 165
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 165
        if (! (j < *(xadj + (higain + 1L)))) {
#line 165
          goto while_break___15;
        }
#line 166
        k = *(adjncy + j);
#line 167
        oldgain = *(ed + k) - *(id + k);
#line 169
        if (to == *(where + k)) {
#line 169
          kwgt = *(adjwgt + j);
        } else {
#line 169
          kwgt = - *(adjwgt + j);
        }
        {
#line 170
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 170
          *(id + k) += kwgt;
#line 170
          *(ed + k) -= kwgt;
#line 170
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 173
        if (*(bndptr + k) != -1L) {
#line 174
          if (*(ed + k) == 0L) {
            {
#line 175
            while (1) {
              while_continue___17: /* CIL Label */ ;
#line 175
              nbnd --;
#line 175
              *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 175
              *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 175
              *(bndptr + k) = (idxtype )-1;
#line 175
              goto while_break___17;
            }
            while_break___17: /* CIL Label */ ;
            }
#line 176
            if (*(moved + k) == -1L) {
              {
#line 177
              __PQueueDelete(& parts[*(qnum + k)][*(where + k)], k, oldgain);
              }
            }
          } else
#line 180
          if (*(moved + k) == -1L) {
            {
#line 181
            __PQueueUpdate(& parts[*(qnum + k)][*(where + k)], k, oldgain, *(ed + k) - *(id + k));
            }
          }
        } else
#line 185
        if (*(ed + k) > 0L) {
          {
#line 186
          while (1) {
            while_continue___18: /* CIL Label */ ;
#line 186
            *(bndind + nbnd) = k;
#line 186
            tmp___6 = nbnd;
#line 186
            nbnd ++;
#line 186
            *(bndptr + k) = tmp___6;
#line 186
            goto while_break___18;
          }
          while_break___18: /* CIL Label */ ;
          }
#line 187
          if (*(moved + k) == -1L) {
            {
#line 188
            __PQueueInsert(& parts[*(qnum + k)][*(where + k)], k, *(ed + k) - *(id + k));
            }
          }
        }
#line 165
        j ++;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 112
      nswaps ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 199
    i = 0L;
    {
#line 199
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 199
      if (! (i < nswaps)) {
#line 199
        goto while_break___19;
      }
#line 200
      *(moved + *(swaps + i)) = (idxtype )-1;
#line 199
      i ++;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 201
    nswaps --;
    {
#line 201
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 201
      if (! (nswaps > mincutorder)) {
#line 201
        goto while_break___20;
      }
#line 202
      higain = *(swaps + nswaps);
#line 204
      tmp___7 = (*(where + higain) + 1L) % 2L;
#line 204
      *(where + higain) = tmp___7;
#line 204
      to = tmp___7;
      {
#line 205
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 205
        tmp = *(id + higain);
#line 205
        *(id + higain) = *(ed + higain);
#line 205
        *(ed + higain) = tmp;
#line 205
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 206
      if (*(ed + higain) == 0L) {
#line 206
        if (*(bndptr + higain) != -1L) {
#line 206
          if (*(xadj + higain) < *(xadj + (higain + 1L))) {
            {
#line 207
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 207
              nbnd --;
#line 207
              *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 207
              *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 207
              *(bndptr + higain) = (idxtype )-1;
#line 207
              goto while_break___22;
            }
            while_break___22: /* CIL Label */ ;
            }
          } else {
#line 206
            goto _L___3;
          }
        } else {
#line 206
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 208
      if (*(ed + higain) > 0L) {
#line 208
        if (*(bndptr + higain) == -1L) {
          {
#line 209
          while (1) {
            while_continue___23: /* CIL Label */ ;
#line 209
            *(bndind + nbnd) = higain;
#line 209
            tmp___8 = nbnd;
#line 209
            nbnd ++;
#line 209
            *(bndptr + higain) = tmp___8;
#line 209
            goto while_break___23;
          }
          while_break___23: /* CIL Label */ ;
          }
        }
      }
      {
#line 211
      __saxpy(ncon, (float )1.0, nvwgt + higain * ncon, 1L, npwgts + to * ncon, 1L);
#line 212
      __saxpy(ncon, (float )(- 1.0), nvwgt + higain * ncon, 1L, npwgts + ((to + 1L) % 2L) * ncon,
              1L);
#line 213
      j = *(xadj + higain);
      }
      {
#line 213
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 213
        if (! (j < *(xadj + (higain + 1L)))) {
#line 213
          goto while_break___24;
        }
#line 214
        k = *(adjncy + j);
#line 216
        if (to == *(where + k)) {
#line 216
          kwgt = *(adjwgt + j);
        } else {
#line 216
          kwgt = - *(adjwgt + j);
        }
        {
#line 217
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 217
          *(id + k) += kwgt;
#line 217
          *(ed + k) -= kwgt;
#line 217
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
#line 219
        if (*(bndptr + k) != -1L) {
#line 219
          if (*(ed + k) == 0L) {
            {
#line 220
            while (1) {
              while_continue___26: /* CIL Label */ ;
#line 220
              nbnd --;
#line 220
              *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 220
              *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 220
              *(bndptr + k) = (idxtype )-1;
#line 220
              goto while_break___26;
            }
            while_break___26: /* CIL Label */ ;
            }
          }
        }
#line 221
        if (*(bndptr + k) == -1L) {
#line 221
          if (*(ed + k) > 0L) {
            {
#line 222
            while (1) {
              while_continue___27: /* CIL Label */ ;
#line 222
              *(bndind + nbnd) = k;
#line 222
              tmp___9 = nbnd;
#line 222
              nbnd ++;
#line 222
              *(bndptr + k) = tmp___9;
#line 222
              goto while_break___27;
            }
            while_break___27: /* CIL Label */ ;
            }
          }
        }
#line 213
        j ++;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 201
      nswaps --;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 226
    if (ctrl->dbglvl & 8L) {
      {
#line 227
      printf((char const   */* __restrict  */)"\tMincut: %6ld at %5ld, NBND: %6ld, NPwgts: [",
             mincut, mincutorder, nbnd);
#line 228
      l = 0L;
      }
      {
#line 228
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 228
        if (! (l < ncon)) {
#line 228
          goto while_break___28;
        }
        {
#line 229
        printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
               (double )*(npwgts + (ncon + l)));
#line 228
        l ++;
        }
      }
      while_break___28: /* CIL Label */ ;
      }
      {
#line 230
      printf((char const   */* __restrict  */)"], LB: ");
#line 231
      __Compute2WayHLoadImbalanceVec(ncon, npwgts, tpwgts, tvec);
#line 232
      i = 0L;
      }
      {
#line 232
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 232
        if (! (i < ncon)) {
#line 232
          goto while_break___29;
        }
        {
#line 233
        printf((char const   */* __restrict  */)"%.3f ", (double )tvec[i]);
#line 232
        i ++;
        }
      }
      while_break___29: /* CIL Label */ ;
      }
      {
#line 234
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 237
    graph->mincut = mincut;
#line 238
    graph->nbnd = nbnd;
#line 240
    if (mincutorder == -1L) {
#line 241
      goto while_break___6;
    } else
#line 240
    if (mincut == initcut) {
#line 241
      goto while_break___6;
    }
#line 89
    pass ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 244
  i = 0L;
  {
#line 244
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 244
    if (! (i < ncon)) {
#line 244
      goto while_break___30;
    }
    {
#line 245
    __PQueueFree(ctrl, & parts[i][0]);
#line 246
    __PQueueFree(ctrl, & parts[i][1]);
#line 244
    i ++;
    }
  }
  while_break___30: /* CIL Label */ ;
  }
  {
#line 249
  __idxwspacefree(ctrl, nvtxs);
#line 250
  __idxwspacefree(ctrl, nvtxs);
#line 251
  __idxwspacefree(ctrl, nvtxs);
#line 252
  __idxwspacefree(ctrl, nvtxs);
#line 253
  fwspacefree(ctrl, 2L * ncon);
#line 254
  fwspacefree(ctrl, 2L * ncon);
  }
#line 256
  return;
}
}
#line 263 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mfm2.c"
void __SelectQueue2(long ncon , float *npwgts , float *tpwgts , long *from , long *cnum ,
                    PQueueType (*queues)[2] , float *maxwgt ) 
{ 
  long i ;
  long j ;
  long maxgain ;
  float diff ;
  float max ;
  float maxdiff ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 266
  maxgain = 0L;
#line 267
  maxdiff = (float )0.0;
#line 269
  *from = -1L;
#line 270
  *cnum = -1L;
#line 273
  j = 0L;
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (j < 2L)) {
#line 273
      goto while_break;
    }
#line 274
    i = 0L;
    {
#line 274
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 274
      if (! (i < ncon)) {
#line 274
        goto while_break___0;
      }
#line 275
      diff = *(npwgts + (j * ncon + i)) - *(maxwgt + (j * ncon + i));
#line 276
      if (diff >= maxdiff) {
#line 277
        maxdiff = diff;
#line 278
        *from = j;
#line 279
        *cnum = i;
      }
#line 274
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 273
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  if (*from != -1L) {
    {
#line 284
    tmp___1 = PQueueGetSize(& (*(queues + *cnum))[*from]);
    }
#line 284
    if (tmp___1 == 0L) {
#line 286
      i = 0L;
      {
#line 286
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 286
        if (! (i < ncon)) {
#line 286
          goto while_break___1;
        }
        {
#line 287
        tmp = PQueueGetSize(& (*(queues + i))[*from]);
        }
#line 287
        if (tmp > 0L) {
#line 288
          max = *(npwgts + (*from * ncon + i)) - *(maxwgt + (*from * ncon + i));
#line 289
          *cnum = i;
#line 290
          goto while_break___1;
        }
#line 286
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 294
      i ++;
      {
#line 294
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 294
        if (! (i < ncon)) {
#line 294
          goto while_break___2;
        }
#line 295
        diff = *(npwgts + (*from * ncon + i)) - *(maxwgt + (*from * ncon + i));
#line 296
        if (diff > max) {
          {
#line 296
          tmp___0 = PQueueGetSize(& (*(queues + i))[*from]);
          }
#line 296
          if (tmp___0 > 0L) {
#line 297
            max = diff;
#line 298
            *cnum = i;
          }
        }
#line 294
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 304
  if ((double )maxdiff <= 0.0) {
#line 304
    goto _L;
  } else
#line 304
  if (*from == -1L) {
    _L: /* CIL Label */ 
#line 305
    maxgain = -100000L;
#line 307
    j = 0L;
    {
#line 307
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 307
      if (! (j < 2L)) {
#line 307
        goto while_break___3;
      }
#line 308
      i = 0L;
      {
#line 308
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 308
        if (! (i < ncon)) {
#line 308
          goto while_break___4;
        }
        {
#line 309
        tmp___2 = PQueueGetSize(& (*(queues + i))[j]);
        }
#line 309
        if (tmp___2 > 0L) {
          {
#line 309
          tmp___3 = PQueueGetKey(& (*(queues + i))[j]);
          }
#line 309
          if (tmp___3 > maxgain) {
            {
#line 310
            maxgain = PQueueGetKey(& (*(queues + i))[j]);
#line 311
            *from = j;
#line 312
            *cnum = i;
            }
          }
        }
#line 308
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 307
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 319
  return;
}
}
#line 326 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mfm2.c"
long __IsBetter2wayBalance(long ncon , float *newbal , float *oldbal , float *ubvec ) 
{ 
  long i ;
  float max1 ;
  float max2 ;
  float sum1 ;
  float sum2 ;
  float tmp ;

  {
#line 329
  max1 = (float )0.0;
#line 329
  max2 = (float )0.0;
#line 329
  sum1 = (float )0.0;
#line 329
  sum2 = (float )0.0;
#line 331
  i = 0L;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! (i < ncon)) {
#line 331
      goto while_break;
    }
#line 332
    tmp = (*(newbal + i) - (float )1) / (*(ubvec + i) - (float )1);
#line 333
    if (max1 < tmp) {
#line 333
      max1 = tmp;
    } else {
#line 333
      max1 = max1;
    }
#line 334
    sum1 += tmp;
#line 336
    tmp = (*(oldbal + i) - (float )1) / (*(ubvec + i) - (float )1);
#line 337
    if (max2 < tmp) {
#line 337
      max2 = tmp;
    } else {
#line 337
      max2 = max2;
    }
#line 338
    sum2 += tmp;
#line 331
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  if (max1 < max2) {
#line 342
    return (1L);
  } else
#line 343
  if (max1 > max2) {
#line 344
    return (0L);
  } else {
#line 346
    return ((long )(sum1 <= sum2));
  }
}
}
#line 200 "./proto.h"
void __MocBalance2Way(CtrlType *ctrl , GraphType *graph , float *tpwgts , float lbfactor ) ;
#line 237
void __MocFM_2WayEdgeRefine(CtrlType *ctrl , GraphType *graph , float *tpwgts , long npasses ) ;
#line 317
void __MocRefine2Way(CtrlType *ctrl , GraphType *orggraph , GraphType *graph , float *tpwgts ,
                     float ubfactor ) ;
#line 318
void __MocAllocate2WayPartitionMemory(CtrlType *ctrl , GraphType *graph ) ;
#line 438
float *__sset(long n , float val , float *x ) ;
#line 20 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mrefine.c"
void __MocRefine2Way(CtrlType *ctrl , GraphType *orggraph , GraphType *graph , float *tpwgts ,
                     float ubfactor ) 
{ 
  long i ;
  float tubvec[16] ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 25
  i = 0L;
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! (i < graph->ncon)) {
#line 25
      goto while_break;
    }
#line 26
    tubvec[i] = (float )1.0;
#line 25
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 28
  if (ctrl->dbglvl & 1L) {
    {
#line 28
    tmp = __seconds();
#line 28
    ctrl->UncoarsenTmr -= tmp;
    }
  }
  {
#line 31
  __MocCompute2WayPartitionParams(ctrl, graph);
  }
  {
#line 33
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 36
    if (ctrl->dbglvl & 1L) {
      {
#line 36
      tmp___0 = __seconds();
#line 36
      ctrl->RefTmr -= tmp___0;
      }
    }
    {
#line 38
    if (ctrl->RType == 1L) {
#line 38
      goto case_1;
    }
#line 42
    if (ctrl->RType == 2L) {
#line 42
      goto case_2;
    }
#line 46
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 39
    __MocBalance2Way(ctrl, graph, tpwgts, (float )1.03);
#line 40
    __MocFM_2WayEdgeRefine(ctrl, graph, tpwgts, 8L);
    }
#line 41
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 43
    __MocBalance2Way(ctrl, graph, tpwgts, (float )1.03);
#line 44
    __MocFM_2WayEdgeRefine2(ctrl, graph, tpwgts, tubvec, 8L);
    }
#line 45
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 47
    __errexit((char *)"Unknown refinement type: %ld\n", ctrl->RType);
    }
    switch_break: /* CIL Label */ ;
    }
#line 49
    if (ctrl->dbglvl & 1L) {
      {
#line 49
      tmp___1 = __seconds();
#line 49
      ctrl->RefTmr += tmp___1;
      }
    }
#line 51
    if ((unsigned long )graph == (unsigned long )orggraph) {
#line 52
      goto while_break___0;
    }
#line 54
    graph = graph->finer;
#line 55
    if (ctrl->dbglvl & 1L) {
      {
#line 55
      tmp___2 = __seconds();
#line 55
      ctrl->ProjectTmr -= tmp___2;
      }
    }
    {
#line 56
    __MocProject2WayPartition(ctrl, graph);
    }
#line 57
    if (ctrl->dbglvl & 1L) {
      {
#line 57
      tmp___3 = __seconds();
#line 57
      ctrl->ProjectTmr += tmp___3;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 60
  __MocBalance2Way(ctrl, graph, tpwgts, (float )1.01);
#line 61
  __MocFM_2WayEdgeRefine(ctrl, graph, tpwgts, 8L);
  }
#line 63
  if (ctrl->dbglvl & 1L) {
    {
#line 63
    tmp___4 = __seconds();
#line 63
    ctrl->UncoarsenTmr += tmp___4;
    }
  }
#line 64
  return;
}
}
#line 70 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mrefine.c"
void __MocAllocate2WayPartitionMemory(CtrlType *ctrl , GraphType *graph ) 
{ 
  long nvtxs ;
  long ncon ;

  {
  {
#line 74
  nvtxs = graph->nvtxs;
#line 75
  ncon = graph->ncon;
#line 77
  graph->rdata = __idxmalloc(5L * nvtxs, (char *)"Allocate2WayPartitionMemory: rdata");
#line 78
  graph->where = graph->rdata;
#line 79
  graph->id = graph->rdata + nvtxs;
#line 80
  graph->ed = graph->rdata + 2L * nvtxs;
#line 81
  graph->bndptr = graph->rdata + 3L * nvtxs;
#line 82
  graph->bndind = graph->rdata + 4L * nvtxs;
#line 84
  graph->npwgts = __fmalloc(2L * ncon, (char *)"npwgts");
  }
#line 85
  return;
}
}
#line 91 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mrefine.c"
void __MocCompute2WayPartitionParams(CtrlType *ctrl , GraphType *graph ) 
{ 
  long i ;
  long j ;
  long nvtxs ;
  long ncon ;
  long nbnd ;
  long mincut ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  float *nvwgt ;
  float *npwgts ;
  idxtype *id ;
  idxtype *ed ;
  idxtype *where ;
  idxtype *bndptr ;
  idxtype *bndind ;
  long me ;
  long tmp ;

  {
  {
#line 100
  nvtxs = graph->nvtxs;
#line 101
  ncon = graph->ncon;
#line 102
  xadj = graph->xadj;
#line 103
  nvwgt = graph->nvwgt;
#line 104
  adjncy = graph->adjncy;
#line 105
  adjwgt = graph->adjwgt;
#line 107
  where = graph->where;
#line 108
  npwgts = __sset(2L * ncon, (float )0.0, graph->npwgts);
#line 109
  id = __idxset(nvtxs, (idxtype )0, graph->id);
#line 110
  ed = __idxset(nvtxs, (idxtype )0, graph->ed);
#line 111
  bndptr = __idxset(nvtxs, (idxtype )-1, graph->bndptr);
#line 112
  bndind = graph->bndind;
#line 118
  mincut = 0L;
#line 118
  nbnd = mincut;
#line 119
  i = 0L;
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! (i < nvtxs)) {
#line 119
      goto while_break;
    }
    {
#line 121
    me = *(where + i);
#line 122
    __saxpy(ncon, (float )1.0, nvwgt + i * ncon, 1L, npwgts + me * ncon, 1L);
#line 124
    j = *(xadj + i);
    }
    {
#line 124
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 124
      if (! (j < *(xadj + (i + 1L)))) {
#line 124
        goto while_break___0;
      }
#line 125
      if (me == *(where + *(adjncy + j))) {
#line 126
        *(id + i) += *(adjwgt + j);
      } else {
#line 128
        *(ed + i) += *(adjwgt + j);
      }
#line 124
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 131
    if (*(ed + i) > 0L) {
#line 132
      mincut += *(ed + i);
#line 133
      *(bndptr + i) = nbnd;
#line 134
      tmp = nbnd;
#line 134
      nbnd ++;
#line 134
      *(bndind + tmp) = i;
    } else
#line 131
    if (*(xadj + i) == *(xadj + (i + 1L))) {
#line 132
      mincut += *(ed + i);
#line 133
      *(bndptr + i) = nbnd;
#line 134
      tmp = nbnd;
#line 134
      nbnd ++;
#line 134
      *(bndind + tmp) = i;
    }
#line 119
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  graph->mincut = mincut / 2L;
#line 139
  graph->nbnd = nbnd;
#line 141
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mrefine.c"
void __MocProject2WayPartition(CtrlType *ctrl , GraphType *graph ) 
{ 
  long i ;
  long j ;
  long k ;
  long nvtxs ;
  long nbnd ;
  long me ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *adjwgtsum ;
  idxtype *cmap ;
  idxtype *where ;
  idxtype *id ;
  idxtype *ed ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *cwhere ;
  idxtype *cid ;
  idxtype *ced ;
  idxtype *cbndptr ;
  GraphType *cgraph ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 157
  cgraph = graph->coarser;
#line 158
  cwhere = cgraph->where;
#line 159
  cid = cgraph->id;
#line 160
  ced = cgraph->ed;
#line 161
  cbndptr = cgraph->bndptr;
#line 163
  nvtxs = graph->nvtxs;
#line 164
  cmap = graph->cmap;
#line 165
  xadj = graph->xadj;
#line 166
  adjncy = graph->adjncy;
#line 167
  adjwgt = graph->adjwgt;
#line 168
  adjwgtsum = graph->adjwgtsum;
#line 170
  __MocAllocate2WayPartitionMemory(ctrl, graph);
#line 172
  where = graph->where;
#line 173
  id = __idxset(nvtxs, (idxtype )0, graph->id);
#line 174
  ed = __idxset(nvtxs, (idxtype )0, graph->ed);
#line 175
  bndptr = __idxset(nvtxs, (idxtype )-1, graph->bndptr);
#line 176
  bndind = graph->bndind;
#line 180
  i = 0L;
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (i < nvtxs)) {
#line 180
      goto while_break;
    }
#line 181
    k = *(cmap + i);
#line 182
    *(where + i) = *(cwhere + k);
#line 183
    *(cmap + i) = *(cbndptr + k);
#line 180
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  nbnd = 0L;
#line 186
  i = 0L;
  {
#line 186
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 186
    if (! (i < nvtxs)) {
#line 186
      goto while_break___0;
    }
#line 187
    me = *(where + i);
#line 189
    *(id + i) = *(adjwgtsum + i);
#line 191
    if (*(xadj + i) == *(xadj + (i + 1L))) {
#line 192
      *(bndptr + i) = nbnd;
#line 193
      tmp = nbnd;
#line 193
      nbnd ++;
#line 193
      *(bndind + tmp) = i;
    } else
#line 196
    if (*(cmap + i) != -1L) {
#line 197
      j = *(xadj + i);
      {
#line 197
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 197
        if (! (j < *(xadj + (i + 1L)))) {
#line 197
          goto while_break___1;
        }
#line 198
        if (me != *(where + *(adjncy + j))) {
#line 199
          *(ed + i) += *(adjwgt + j);
        }
#line 197
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 201
      *(id + i) -= *(ed + i);
#line 203
      if (*(ed + i) > 0L) {
#line 204
        *(bndptr + i) = nbnd;
#line 205
        tmp___0 = nbnd;
#line 205
        nbnd ++;
#line 205
        *(bndind + tmp___0) = i;
      } else
#line 203
      if (*(xadj + i) == *(xadj + (i + 1L))) {
#line 204
        *(bndptr + i) = nbnd;
#line 205
        tmp___0 = nbnd;
#line 205
        nbnd ++;
#line 205
        *(bndind + tmp___0) = i;
      }
    }
#line 186
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 211
  graph->mincut = cgraph->mincut;
#line 212
  graph->nbnd = nbnd;
#line 213
  memcpy((void */* __restrict  */)((void *)graph->npwgts), (void const   */* __restrict  */)((void *)cgraph->npwgts),
         sizeof(float ) * (unsigned long )(2L * graph->ncon));
#line 215
  __FreeGraph(graph->coarser);
#line 216
  graph->coarser = (struct graphdef *)((void *)0);
  }
#line 218
  return;
}
}
#line 389 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) drand48)(void) ;
#line 263 "./proto.h"
void __MocInit2WayPartition2(CtrlType *ctrl , GraphType *graph , float *tpwgts , float *ubvec ) ;
#line 264
void __MocGrowBisection2(CtrlType *ctrl , GraphType *graph , float *tpwgts , float *ubvec ) ;
#line 265
void __MocGrowBisectionNew2(CtrlType *ctrl , GraphType *graph , float *tpwgts , float *ubvec ) ;
#line 266
void __MocInit2WayBalance2(CtrlType *ctrl , GraphType *graph , float *tpwgts , float *ubvec ) ;
#line 267
long __SelectQueueOneWay2(long ncon , float *pto , PQueueType (*queues)[2] , float *ubvec ) ;
#line 329
float __ComputeLoadImbalance(long ncon , long nparts , float *npwgts , float *tpwgts ) ;
#line 21 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/minitpart2.c"
void __MocInit2WayPartition2(CtrlType *ctrl , GraphType *graph , float *tpwgts , float *ubvec ) 
{ 
  long dbglvl ;
  double tmp ;
  double tmp___0 ;

  {
#line 25
  dbglvl = ctrl->dbglvl;
#line 26
  if (ctrl->dbglvl & 8L) {
#line 26
    ctrl->dbglvl -= 8L;
  }
#line 27
  if (ctrl->dbglvl & 32L) {
#line 27
    ctrl->dbglvl -= 32L;
  }
#line 29
  if (ctrl->dbglvl & 1L) {
    {
#line 29
    tmp = __seconds();
#line 29
    ctrl->InitPartTmr -= tmp;
    }
  }
  {
#line 33
  if (ctrl->IType == 2L) {
#line 33
    goto case_2;
  }
#line 33
  if (ctrl->IType == 1L) {
#line 33
    goto case_2;
  }
#line 36
  if (ctrl->IType == 3L) {
#line 36
    goto case_3;
  }
#line 39
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 34
  __MocGrowBisection2(ctrl, graph, tpwgts, ubvec);
  }
#line 35
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 37
  __MocGrowBisectionNew2(ctrl, graph, tpwgts, ubvec);
  }
#line 38
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 40
  __errexit((char *)"Unknown initial partition type: %ld\n", ctrl->IType);
  }
  switch_break: /* CIL Label */ ;
  }
#line 43
  if (ctrl->dbglvl & 16L) {
    {
#line 43
    printf((char const   */* __restrict  */)"Initial Cut: %ld\n", graph->mincut);
    }
  }
#line 44
  if (ctrl->dbglvl & 1L) {
    {
#line 44
    tmp___0 = __seconds();
#line 44
    ctrl->InitPartTmr += tmp___0;
    }
  }
#line 45
  ctrl->dbglvl = dbglvl;
#line 47
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/minitpart2.c"
void __MocGrowBisection2(CtrlType *ctrl , GraphType *graph , float *tpwgts , float *ubvec ) 
{ 
  long nvtxs ;
  long bestcut ;
  long nbfs ;
  idxtype *bestwhere ;
  idxtype *where ;
  int tmp ;
  double tmp___0 ;

  {
  {
#line 62
  nvtxs = graph->nvtxs;
#line 64
  __MocAllocate2WayPartitionMemory(ctrl, graph);
#line 65
  where = graph->where;
#line 67
  bestwhere = __idxmalloc(nvtxs, (char *)"BisectGraph: bestwhere");
  }
#line 68
  if (nvtxs <= ctrl->CoarsenTo) {
#line 68
    tmp = 3;
  } else {
#line 68
    tmp = 8;
  }
  {
#line 68
  nbfs = (long )(2 * tmp);
#line 69
  bestcut = __idxsum(graph->nedges, graph->adjwgt);
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (nbfs > 0L)) {
#line 71
      goto while_break;
    }
    {
#line 72
    __idxset(nvtxs, (idxtype )1, where);
#line 73
    tmp___0 = drand48();
#line 73
    *(where + (long )(tmp___0 * (double )nvtxs)) = (idxtype )0;
#line 75
    __MocCompute2WayPartitionParams(ctrl, graph);
#line 77
    __MocBalance2Way2(ctrl, graph, tpwgts, ubvec);
#line 79
    __MocFM_2WayEdgeRefine2(ctrl, graph, tpwgts, ubvec, 4L);
#line 81
    __MocBalance2Way2(ctrl, graph, tpwgts, ubvec);
#line 82
    __MocFM_2WayEdgeRefine2(ctrl, graph, tpwgts, ubvec, 4L);
    }
#line 84
    if (bestcut > graph->mincut) {
      {
#line 85
      bestcut = graph->mincut;
#line 86
      memcpy((void */* __restrict  */)((void *)bestwhere), (void const   */* __restrict  */)((void *)where),
             sizeof(idxtype ) * (unsigned long )nvtxs);
      }
#line 87
      if (bestcut == 0L) {
#line 88
        goto while_break;
      }
    }
#line 71
    nbfs --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  graph->mincut = bestcut;
#line 93
  memcpy((void */* __restrict  */)((void *)where), (void const   */* __restrict  */)((void *)bestwhere),
         sizeof(idxtype ) * (unsigned long )nvtxs);
#line 95
  __GKfree(& bestwhere, (void **)0);
  }
#line 96
  return;
}
}
#line 108 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/minitpart2.c"
void __MocGrowBisectionNew2(CtrlType *ctrl , GraphType *graph , float *tpwgts , float *ubvec ) 
{ 
  long nvtxs ;
  long bestcut ;
  long nbfs ;
  idxtype *bestwhere ;
  idxtype *where ;
  int tmp ;
  double tmp___0 ;

  {
  {
#line 113
  nvtxs = graph->nvtxs;
#line 115
  __MocAllocate2WayPartitionMemory(ctrl, graph);
#line 116
  where = graph->where;
#line 118
  bestwhere = __idxmalloc(nvtxs, (char *)"BisectGraph: bestwhere");
  }
#line 119
  if (nvtxs <= ctrl->CoarsenTo) {
#line 119
    tmp = 3;
  } else {
#line 119
    tmp = 8;
  }
  {
#line 119
  nbfs = (long )(2 * tmp);
#line 120
  bestcut = __idxsum(graph->nedges, graph->adjwgt);
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (nbfs > 0L)) {
#line 122
      goto while_break;
    }
    {
#line 123
    __idxset(nvtxs, (idxtype )1, where);
#line 124
    tmp___0 = drand48();
#line 124
    *(where + (long )(tmp___0 * (double )nvtxs)) = (idxtype )0;
#line 126
    __MocCompute2WayPartitionParams(ctrl, graph);
#line 128
    __MocInit2WayBalance2(ctrl, graph, tpwgts, ubvec);
#line 130
    __MocFM_2WayEdgeRefine2(ctrl, graph, tpwgts, ubvec, 4L);
    }
#line 132
    if (bestcut > graph->mincut) {
      {
#line 133
      bestcut = graph->mincut;
#line 134
      memcpy((void */* __restrict  */)((void *)bestwhere), (void const   */* __restrict  */)((void *)where),
             sizeof(idxtype ) * (unsigned long )nvtxs);
      }
#line 135
      if (bestcut == 0L) {
#line 136
        goto while_break;
      }
    }
#line 122
    nbfs --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  graph->mincut = bestcut;
#line 141
  memcpy((void */* __restrict  */)((void *)where), (void const   */* __restrict  */)((void *)bestwhere),
         sizeof(idxtype ) * (unsigned long )nvtxs);
#line 143
  __GKfree(& bestwhere, (void **)0);
  }
#line 144
  return;
}
}
#line 156 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/minitpart2.c"
void __MocInit2WayBalance2(CtrlType *ctrl , GraphType *graph , float *tpwgts , float *ubvec ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long l ;
  long kwgt ;
  long nvtxs ;
  long nbnd ;
  long ncon ;
  long nswaps ;
  long from ;
  long to ;
  long cnum ;
  long tmp ;
  long imin ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *id ;
  idxtype *ed ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *moved ;
  idxtype *perm ;
  idxtype *qnum ;
  float *nvwgt ;
  float *npwgts ;
  float minwgt ;
  PQueueType parts[16][2] ;
  long higain ;
  long oldgain ;
  long mincut ;
  float tmp___0 ;
  float tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  float tmp___4 ;

  {
  {
#line 165
  nvtxs = graph->nvtxs;
#line 166
  ncon = graph->ncon;
#line 167
  xadj = graph->xadj;
#line 168
  adjncy = graph->adjncy;
#line 169
  nvwgt = graph->nvwgt;
#line 170
  adjwgt = graph->adjwgt;
#line 171
  where = graph->where;
#line 172
  id = graph->id;
#line 173
  ed = graph->ed;
#line 174
  npwgts = graph->npwgts;
#line 175
  bndptr = graph->bndptr;
#line 176
  bndind = graph->bndind;
#line 178
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 179
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 180
  qnum = __idxwspacemalloc(ctrl, nvtxs);
#line 183
  from = 1L;
#line 184
  to = (from + 1L) % 2L;
  }
#line 186
  if (ctrl->dbglvl & 8L) {
    {
#line 187
    printf((char const   */* __restrict  */)"Parts: [");
#line 188
    l = 0L;
    }
    {
#line 188
    while (1) {
      while_continue: /* CIL Label */ ;
#line 188
      if (! (l < ncon)) {
#line 188
        goto while_break;
      }
      {
#line 189
      printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
             (double )*(npwgts + (ncon + l)));
#line 188
      l ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 190
    tmp___0 = __ComputeLoadImbalance(ncon, 2L, npwgts, tpwgts);
#line 190
    printf((char const   */* __restrict  */)"] T[%.3f %.3f], Nv-Nb[%5ld, %5ld]. ICut: %6ld, LB: %.3f [B]\n",
           (double )*(tpwgts + 0), (double )*(tpwgts + 1), graph->nvtxs, graph->nbnd,
           graph->mincut, (double )tmp___0);
    }
  }
#line 193
  i = 0L;
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 193
    if (! (i < ncon)) {
#line 193
      goto while_break___0;
    }
    {
#line 194
    __PQueueInit(ctrl, & parts[i][0], nvtxs, 501L);
#line 195
    __PQueueInit(ctrl, & parts[i][1], nvtxs, 501L);
#line 193
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 198
  __idxset(nvtxs, (idxtype )-1, moved);
#line 205
  i = 0L;
  }
  {
#line 205
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 205
    if (! (i < nvtxs)) {
#line 205
      goto while_break___1;
    }
    {
#line 206
    *(qnum + i) = __samax(ncon, nvwgt + i * ncon);
#line 205
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 209
  __RandomPermute(nvtxs, perm, 1L);
#line 210
  ii = 0L;
  }
  {
#line 210
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 210
    if (! (ii < nvtxs)) {
#line 210
      goto while_break___2;
    }
#line 211
    i = *(perm + ii);
#line 212
    if (*(where + i) == from) {
#line 213
      if (*(ed + i) > 0L) {
        {
#line 214
        __PQueueInsert(& parts[*(qnum + i)][0], i, *(ed + i) - *(id + i));
        }
      } else {
        {
#line 216
        __PQueueInsert(& parts[*(qnum + i)][1], i, *(ed + i) - *(id + i));
        }
      }
    }
#line 210
    ii ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 226
  imin = 0L;
#line 227
  i = 1L;
  {
#line 227
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 227
    if (! (i < ncon)) {
#line 227
      goto while_break___3;
    }
#line 228
    if (*(ubvec + i) < *(ubvec + imin)) {
#line 228
      imin = i;
    } else {
#line 228
      imin = imin;
    }
#line 227
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 229
  minwgt = (float )(.5 / (double )*(ubvec + imin));
#line 231
  mincut = graph->mincut;
#line 232
  nbnd = graph->nbnd;
#line 233
  nswaps = 0L;
  {
#line 233
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 233
    if (! (nswaps < nvtxs)) {
#line 233
      goto while_break___4;
    }
#line 235
    if (*(npwgts + (to * ncon + imin)) > minwgt) {
#line 236
      goto while_break___4;
    }
    {
#line 238
    cnum = __SelectQueueOneWay2(ncon, npwgts + to * ncon, (PQueueType (*)[2])(parts),
                                ubvec);
    }
#line 238
    if (cnum == -1L) {
#line 239
      goto while_break___4;
    }
    {
#line 241
    higain = __PQueueGetMax(& parts[cnum][0]);
    }
#line 241
    if (higain == -1L) {
      {
#line 242
      higain = __PQueueGetMax(& parts[cnum][1]);
      }
    }
    {
#line 244
    mincut -= *(ed + higain) - *(id + higain);
#line 245
    __saxpy(ncon, (float )1.0, nvwgt + higain * ncon, 1L, npwgts + to * ncon, 1L);
#line 246
    __saxpy(ncon, (float )(- 1.0), nvwgt + higain * ncon, 1L, npwgts + from * ncon,
            1L);
#line 248
    *(where + higain) = to;
#line 249
    *(moved + higain) = nswaps;
    }
#line 251
    if (ctrl->dbglvl & 32L) {
      {
#line 252
      printf((char const   */* __restrict  */)"Moved %6ld from %ld(%ld). [%5ld] %5ld, NPwgts: ",
             higain, from, cnum, *(ed + higain) - *(id + higain), mincut);
#line 253
      l = 0L;
      }
      {
#line 253
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 253
        if (! (l < ncon)) {
#line 253
          goto while_break___5;
        }
        {
#line 254
        printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
               (double )*(npwgts + (ncon + l)));
#line 253
        l ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 255
      tmp___1 = __ComputeLoadImbalance(ncon, 2L, npwgts, tpwgts);
#line 255
      printf((char const   */* __restrict  */)", LB: %.3f\n", (double )tmp___1);
      }
#line 256
      if (*(ed + higain) == 0L) {
#line 256
        if (*(id + higain) > 0L) {
          {
#line 257
          printf((char const   */* __restrict  */)"\t Pulled from the interior!\n");
          }
        }
      }
    }
    {
#line 264
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 264
      tmp = *(id + higain);
#line 264
      *(id + higain) = *(ed + higain);
#line 264
      *(ed + higain) = tmp;
#line 264
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 265
    if (*(ed + higain) == 0L) {
#line 265
      if (*(bndptr + higain) != -1L) {
#line 265
        if (*(xadj + higain) < *(xadj + (higain + 1L))) {
          {
#line 266
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 266
            nbnd --;
#line 266
            *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 266
            *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 266
            *(bndptr + higain) = (idxtype )-1;
#line 266
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
      }
    }
#line 267
    if (*(ed + higain) > 0L) {
#line 267
      if (*(bndptr + higain) == -1L) {
        {
#line 268
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 268
          *(bndind + nbnd) = higain;
#line 268
          tmp___2 = nbnd;
#line 268
          nbnd ++;
#line 268
          *(bndptr + higain) = tmp___2;
#line 268
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
    }
#line 270
    j = *(xadj + higain);
    {
#line 270
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 270
      if (! (j < *(xadj + (higain + 1L)))) {
#line 270
        goto while_break___9;
      }
#line 271
      k = *(adjncy + j);
#line 272
      oldgain = *(ed + k) - *(id + k);
#line 274
      if (to == *(where + k)) {
#line 274
        kwgt = *(adjwgt + j);
      } else {
#line 274
        kwgt = - *(adjwgt + j);
      }
      {
#line 275
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 275
        *(id + k) += kwgt;
#line 275
        *(ed + k) -= kwgt;
#line 275
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 278
      if (*(moved + k) == -1L) {
#line 278
        if (*(where + k) == from) {
#line 279
          if (*(ed + k) > 0L) {
#line 279
            if (*(bndptr + k) == -1L) {
              {
#line 280
              __PQueueDelete(& parts[*(qnum + k)][1], k, oldgain);
#line 281
              __PQueueInsert(& parts[*(qnum + k)][0], k, *(ed + k) - *(id + k));
              }
            } else {
#line 279
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 284
            if (*(bndptr + k) == -1L) {
              {
#line 285
              printf((char const   */* __restrict  */)"What you thought was wrong!\n");
              }
            }
            {
#line 286
            __PQueueUpdate(& parts[*(qnum + k)][0], k, oldgain, *(ed + k) - *(id + k));
            }
          }
        }
      }
#line 291
      if (*(ed + k) == 0L) {
#line 291
        if (*(bndptr + k) != -1L) {
          {
#line 292
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 292
            nbnd --;
#line 292
            *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 292
            *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 292
            *(bndptr + k) = (idxtype )-1;
#line 292
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
        } else {
#line 291
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 293
      if (*(ed + k) > 0L) {
#line 293
        if (*(bndptr + k) == -1L) {
          {
#line 294
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 294
            *(bndind + nbnd) = k;
#line 294
            tmp___3 = nbnd;
#line 294
            nbnd ++;
#line 294
            *(bndptr + k) = tmp___3;
#line 294
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
        }
      }
#line 270
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 233
    nswaps ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 301
  if (ctrl->dbglvl & 8L) {
    {
#line 302
    printf((char const   */* __restrict  */)"\tMincut: %6ld, NBND: %6ld, NPwgts: ",
           mincut, nbnd);
#line 303
    l = 0L;
    }
    {
#line 303
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 303
      if (! (l < ncon)) {
#line 303
        goto while_break___13;
      }
      {
#line 304
      printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
             (double )*(npwgts + (ncon + l)));
#line 303
      l ++;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 305
    tmp___4 = __ComputeLoadImbalance(ncon, 2L, npwgts, tpwgts);
#line 305
    printf((char const   */* __restrict  */)", LB: %.3f\n", (double )tmp___4);
    }
  }
#line 308
  graph->mincut = mincut;
#line 309
  graph->nbnd = nbnd;
#line 311
  i = 0L;
  {
#line 311
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 311
    if (! (i < ncon)) {
#line 311
      goto while_break___14;
    }
    {
#line 312
    __PQueueFree(ctrl, & parts[i][0]);
#line 313
    __PQueueFree(ctrl, & parts[i][1]);
#line 311
    i ++;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 319
  __idxwspacefree(ctrl, nvtxs);
#line 320
  __idxwspacefree(ctrl, nvtxs);
#line 321
  __idxwspacefree(ctrl, nvtxs);
  }
#line 322
  return;
}
}
#line 330 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/minitpart2.c"
long __SelectQueueOneWay2(long ncon , float *pto , PQueueType (*queues)[2] , float *ubvec ) 
{ 
  long i ;
  long cnum ;
  long imax ;
  long maxgain ;
  float max ;
  float twgt[16] ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 332
  cnum = -1L;
#line 333
  max = (float )0.0;
#line 336
  i = 0L;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (i < ncon)) {
#line 336
      goto while_break;
    }
#line 337
    if (max < *(pto + i)) {
#line 338
      imax = i;
#line 339
      max = *(pto + i);
    }
#line 336
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  i = 0L;
  {
#line 342
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 342
    if (! (i < ncon)) {
#line 342
      goto while_break___0;
    }
#line 343
    twgt[i] = (max / (*(ubvec + imax) * *(ubvec + i))) / *(pto + i);
#line 342
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 344
  twgt[imax] = (float )0.0;
#line 346
  max = (float )0.0;
#line 347
  i = 0L;
  {
#line 347
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 347
    if (! (i < ncon)) {
#line 347
      goto while_break___1;
    }
#line 348
    if (max < twgt[i]) {
      {
#line 348
      tmp = PQueueGetSize(& (*(queues + i))[0]);
      }
#line 348
      if (tmp > 0L) {
#line 349
        max = twgt[i];
#line 350
        cnum = i;
      } else {
        {
#line 348
        tmp___0 = PQueueGetSize(& (*(queues + i))[1]);
        }
#line 348
        if (tmp___0 > 0L) {
#line 349
          max = twgt[i];
#line 350
          cnum = i;
        }
      }
    }
#line 347
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 353
  if (max > (float )1) {
#line 354
    return (cnum);
  }
#line 357
  maxgain = -10000000L;
#line 358
  i = 0L;
  {
#line 358
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 358
    if (! (i < ncon)) {
#line 358
      goto while_break___2;
    }
    {
#line 359
    tmp___1 = PQueueGetSize(& (*(queues + i))[0]);
    }
#line 359
    if (tmp___1 > 0L) {
      {
#line 359
      tmp___2 = PQueueGetKey(& (*(queues + i))[0]);
      }
#line 359
      if (tmp___2 > maxgain) {
        {
#line 360
        maxgain = PQueueGetKey(& (*(queues + i))[0]);
#line 361
        cnum = i;
        }
      }
    }
#line 358
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 365
  return (cnum);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 25 "./proto.h"
void __CreateCoarseGraphNoMask(CtrlType *ctrl , GraphType *graph , long cnvtxs , idxtype *match ,
                               idxtype *perm ) ;
#line 27
GraphType *__SetUpCoarseGraph(GraphType *graph , long cnvtxs , long dovsize ) ;
#line 28
void __ReAdjustMemory(GraphType *graph , GraphType *cgraph , long dovsize ) ;
#line 219
GraphType *__CreateGraph(void) ;
#line 22 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/ccgraph.c"
void __CreateCoarseGraph(CtrlType *ctrl , GraphType *graph , long cnvtxs , idxtype *match ,
                         idxtype *perm ) 
{ 
  long i ;
  long j ;
  long jj ;
  long k ;
  long kk ;
  long m ;
  long istart ;
  long iend ;
  long nvtxs ;
  long nedges ;
  long ncon ;
  long cnedges ;
  long v ;
  long u ;
  long mask ;
  long dovsize ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *vsize ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *adjwgtsum ;
  idxtype *auxadj ;
  idxtype *cmap ;
  idxtype *htable ;
  idxtype *cxadj ;
  idxtype *cvwgt ;
  idxtype *cvsize ;
  idxtype *cadjncy ;
  idxtype *cadjwgt ;
  idxtype *cadjwgtsum ;
  float *nvwgt ;
  float *cnvwgt ;
  GraphType *cgraph ;
  double tmp ;
  idxtype *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  double tmp___5 ;

  {
#line 31
  if (ctrl->optype == 6L) {
#line 31
    dovsize = 1L;
  } else {
#line 31
    dovsize = 0L;
  }
#line 33
  mask = (long )((1 << 11) - 1);
#line 34
  if (cnvtxs < 8L * mask) {
    {
#line 35
    __CreateCoarseGraphNoMask(ctrl, graph, cnvtxs, match, perm);
    }
#line 36
    return;
  } else
#line 34
  if (graph->nedges / graph->nvtxs > 15L) {
    {
#line 35
    __CreateCoarseGraphNoMask(ctrl, graph, cnvtxs, match, perm);
    }
#line 36
    return;
  }
#line 39
  if (ctrl->dbglvl & 1L) {
    {
#line 39
    tmp = __seconds();
#line 39
    ctrl->ContractTmr -= tmp;
    }
  }
  {
#line 41
  nvtxs = graph->nvtxs;
#line 42
  ncon = graph->ncon;
#line 43
  xadj = graph->xadj;
#line 44
  vwgt = graph->vwgt;
#line 45
  vsize = graph->vsize;
#line 46
  nvwgt = graph->nvwgt;
#line 47
  adjncy = graph->adjncy;
#line 48
  adjwgt = graph->adjwgt;
#line 49
  adjwgtsum = graph->adjwgtsum;
#line 50
  cmap = graph->cmap;
#line 53
  cgraph = __SetUpCoarseGraph(graph, cnvtxs, dovsize);
#line 54
  cxadj = cgraph->xadj;
#line 55
  cvwgt = cgraph->vwgt;
#line 56
  cvsize = cgraph->vsize;
#line 57
  cnvwgt = cgraph->nvwgt;
#line 58
  cadjwgtsum = cgraph->adjwgtsum;
#line 59
  cadjncy = cgraph->adjncy;
#line 60
  cadjwgt = cgraph->adjwgt;
#line 63
  iend = *(xadj + nvtxs);
#line 64
  auxadj = ctrl->wspace.auxcore;
#line 65
  memcpy((void */* __restrict  */)auxadj, (void const   */* __restrict  */)adjncy,
         (unsigned long )iend * sizeof(idxtype ));
#line 66
  i = 0L;
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i < iend)) {
#line 66
      goto while_break;
    }
#line 67
    *(auxadj + i) = *(cmap + *(auxadj + i));
#line 66
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  tmp___0 = __idxwspacemalloc(ctrl, mask + 1L);
#line 69
  htable = __idxset(mask + 1L, (idxtype )-1, tmp___0);
#line 71
  cnedges = 0L;
#line 71
  cnvtxs = cnedges;
#line 71
  *(cxadj + 0) = cnvtxs;
#line 72
  i = 0L;
  }
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 72
    if (! (i < nvtxs)) {
#line 72
      goto while_break___0;
    }
#line 73
    v = *(perm + i);
#line 74
    if (*(cmap + v) != cnvtxs) {
#line 75
      goto __Cont;
    }
#line 77
    u = *(match + v);
#line 78
    if (ncon == 1L) {
#line 79
      *(cvwgt + cnvtxs) = *(vwgt + v);
    } else {
      {
#line 81
      memcpy((void */* __restrict  */)((void *)(cnvwgt + cnvtxs * ncon)), (void const   */* __restrict  */)((void *)(nvwgt + v * ncon)),
             sizeof(float ) * (unsigned long )ncon);
      }
    }
#line 83
    if (dovsize) {
#line 84
      *(cvsize + cnvtxs) = *(vsize + v);
    }
#line 86
    *(cadjwgtsum + cnvtxs) = *(adjwgtsum + v);
#line 87
    nedges = 0L;
#line 89
    istart = *(xadj + v);
#line 90
    iend = *(xadj + (v + 1L));
#line 91
    j = istart;
    {
#line 91
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 91
      if (! (j < iend)) {
#line 91
        goto while_break___1;
      }
#line 92
      k = *(auxadj + j);
#line 93
      kk = k & mask;
#line 94
      m = *(htable + kk);
#line 94
      if (m == -1L) {
#line 95
        *(cadjncy + nedges) = k;
#line 96
        *(cadjwgt + nedges) = *(adjwgt + j);
#line 97
        tmp___1 = nedges;
#line 97
        nedges ++;
#line 97
        *(htable + kk) = tmp___1;
      } else
#line 99
      if (*(cadjncy + m) == k) {
#line 100
        *(cadjwgt + m) += *(adjwgt + j);
      } else {
#line 103
        jj = 0L;
        {
#line 103
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 103
          if (! (jj < nedges)) {
#line 103
            goto while_break___2;
          }
#line 104
          if (*(cadjncy + jj) == k) {
#line 105
            *(cadjwgt + jj) += *(adjwgt + j);
#line 106
            goto while_break___2;
          }
#line 103
          jj ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 109
        if (jj == nedges) {
#line 110
          *(cadjncy + nedges) = k;
#line 111
          tmp___2 = nedges;
#line 111
          nedges ++;
#line 111
          *(cadjwgt + tmp___2) = *(adjwgt + j);
        }
      }
#line 91
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 116
    if (v != u) {
#line 117
      if (ncon == 1L) {
#line 118
        *(cvwgt + cnvtxs) += *(vwgt + u);
      } else {
        {
#line 120
        __saxpy(ncon, (float )1.0, nvwgt + u * ncon, 1L, cnvwgt + cnvtxs * ncon, 1L);
        }
      }
#line 122
      if (dovsize) {
#line 123
        *(cvsize + cnvtxs) += *(vsize + u);
      }
#line 125
      *(cadjwgtsum + cnvtxs) += *(adjwgtsum + u);
#line 127
      istart = *(xadj + u);
#line 128
      iend = *(xadj + (u + 1L));
#line 129
      j = istart;
      {
#line 129
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 129
        if (! (j < iend)) {
#line 129
          goto while_break___3;
        }
#line 130
        k = *(auxadj + j);
#line 131
        kk = k & mask;
#line 132
        m = *(htable + kk);
#line 132
        if (m == -1L) {
#line 133
          *(cadjncy + nedges) = k;
#line 134
          *(cadjwgt + nedges) = *(adjwgt + j);
#line 135
          tmp___3 = nedges;
#line 135
          nedges ++;
#line 135
          *(htable + kk) = tmp___3;
        } else
#line 137
        if (*(cadjncy + m) == k) {
#line 138
          *(cadjwgt + m) += *(adjwgt + j);
        } else {
#line 141
          jj = 0L;
          {
#line 141
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 141
            if (! (jj < nedges)) {
#line 141
              goto while_break___4;
            }
#line 142
            if (*(cadjncy + jj) == k) {
#line 143
              *(cadjwgt + jj) += *(adjwgt + j);
#line 144
              goto while_break___4;
            }
#line 141
            jj ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 147
          if (jj == nedges) {
#line 148
            *(cadjncy + nedges) = k;
#line 149
            tmp___4 = nedges;
#line 149
            nedges ++;
#line 149
            *(cadjwgt + tmp___4) = *(adjwgt + j);
          }
        }
#line 129
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 155
      jj = *(htable + (cnvtxs & mask));
#line 156
      if (jj >= 0L) {
#line 156
        if (*(cadjncy + jj) != cnvtxs) {
#line 157
          jj = 0L;
          {
#line 157
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 157
            if (! (jj < nedges)) {
#line 157
              goto while_break___5;
            }
#line 158
            if (*(cadjncy + jj) == cnvtxs) {
#line 159
              goto while_break___5;
            }
#line 157
            jj ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      }
#line 162
      if (jj >= 0L) {
#line 162
        if (*(cadjncy + jj) == cnvtxs) {
#line 163
          *(cadjwgtsum + cnvtxs) -= *(cadjwgt + jj);
#line 164
          nedges --;
#line 164
          *(cadjncy + jj) = *(cadjncy + nedges);
#line 165
          *(cadjwgt + jj) = *(cadjwgt + nedges);
        }
      }
    }
#line 171
    j = 0L;
    {
#line 171
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 171
      if (! (j < nedges)) {
#line 171
        goto while_break___6;
      }
#line 172
      *(htable + (*(cadjncy + j) & mask)) = (idxtype )-1;
#line 171
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 173
    *(htable + (cnvtxs & mask)) = (idxtype )-1;
#line 175
    cnedges += nedges;
#line 176
    cnvtxs ++;
#line 176
    *(cxadj + cnvtxs) = cnedges;
#line 177
    cadjncy += nedges;
#line 178
    cadjwgt += nedges;
    __Cont: /* CIL Label */ 
#line 72
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 181
  cgraph->nedges = cnedges;
#line 183
  __ReAdjustMemory(graph, cgraph, dovsize);
  }
#line 185
  if (ctrl->dbglvl & 1L) {
    {
#line 185
    tmp___5 = __seconds();
#line 185
    ctrl->ContractTmr += tmp___5;
    }
  }
  {
#line 187
  __idxwspacefree(ctrl, mask + 1L);
  }
#line 189
  return;
}
}
#line 195 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/ccgraph.c"
void __CreateCoarseGraphNoMask(CtrlType *ctrl , GraphType *graph , long cnvtxs , idxtype *match ,
                               idxtype *perm ) 
{ 
  long i ;
  long j ;
  long k ;
  long m ;
  long istart ;
  long iend ;
  long nvtxs ;
  long nedges ;
  long ncon ;
  long cnedges ;
  long v ;
  long u ;
  long dovsize ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *vsize ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *adjwgtsum ;
  idxtype *auxadj ;
  idxtype *cmap ;
  idxtype *htable ;
  idxtype *cxadj ;
  idxtype *cvwgt ;
  idxtype *cvsize ;
  idxtype *cadjncy ;
  idxtype *cadjwgt ;
  idxtype *cadjwgtsum ;
  float *nvwgt ;
  float *cnvwgt ;
  GraphType *cgraph ;
  double tmp ;
  idxtype *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  double tmp___3 ;

  {
#line 204
  if (ctrl->optype == 6L) {
#line 204
    dovsize = 1L;
  } else {
#line 204
    dovsize = 0L;
  }
#line 206
  if (ctrl->dbglvl & 1L) {
    {
#line 206
    tmp = __seconds();
#line 206
    ctrl->ContractTmr -= tmp;
    }
  }
  {
#line 208
  nvtxs = graph->nvtxs;
#line 209
  ncon = graph->ncon;
#line 210
  xadj = graph->xadj;
#line 211
  vwgt = graph->vwgt;
#line 212
  vsize = graph->vsize;
#line 213
  nvwgt = graph->nvwgt;
#line 214
  adjncy = graph->adjncy;
#line 215
  adjwgt = graph->adjwgt;
#line 216
  adjwgtsum = graph->adjwgtsum;
#line 217
  cmap = graph->cmap;
#line 221
  cgraph = __SetUpCoarseGraph(graph, cnvtxs, dovsize);
#line 222
  cxadj = cgraph->xadj;
#line 223
  cvwgt = cgraph->vwgt;
#line 224
  cvsize = cgraph->vsize;
#line 225
  cnvwgt = cgraph->nvwgt;
#line 226
  cadjwgtsum = cgraph->adjwgtsum;
#line 227
  cadjncy = cgraph->adjncy;
#line 228
  cadjwgt = cgraph->adjwgt;
#line 231
  tmp___0 = __idxwspacemalloc(ctrl, cnvtxs);
#line 231
  htable = __idxset(cnvtxs, (idxtype )-1, tmp___0);
#line 233
  iend = *(xadj + nvtxs);
#line 234
  auxadj = ctrl->wspace.auxcore;
#line 235
  memcpy((void */* __restrict  */)auxadj, (void const   */* __restrict  */)adjncy,
         (unsigned long )iend * sizeof(idxtype ));
#line 236
  i = 0L;
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (i < iend)) {
#line 236
      goto while_break;
    }
#line 237
    *(auxadj + i) = *(cmap + *(auxadj + i));
#line 236
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  cnedges = 0L;
#line 239
  cnvtxs = cnedges;
#line 239
  *(cxadj + 0) = cnvtxs;
#line 240
  i = 0L;
  {
#line 240
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 240
    if (! (i < nvtxs)) {
#line 240
      goto while_break___0;
    }
#line 241
    v = *(perm + i);
#line 242
    if (*(cmap + v) != cnvtxs) {
#line 243
      goto __Cont;
    }
#line 245
    u = *(match + v);
#line 246
    if (ncon == 1L) {
#line 247
      *(cvwgt + cnvtxs) = *(vwgt + v);
    } else {
      {
#line 249
      memcpy((void */* __restrict  */)((void *)(cnvwgt + cnvtxs * ncon)), (void const   */* __restrict  */)((void *)(nvwgt + v * ncon)),
             sizeof(float ) * (unsigned long )ncon);
      }
    }
#line 251
    if (dovsize) {
#line 252
      *(cvsize + cnvtxs) = *(vsize + v);
    }
#line 254
    *(cadjwgtsum + cnvtxs) = *(adjwgtsum + v);
#line 255
    nedges = 0L;
#line 257
    istart = *(xadj + v);
#line 258
    iend = *(xadj + (v + 1L));
#line 259
    j = istart;
    {
#line 259
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 259
      if (! (j < iend)) {
#line 259
        goto while_break___1;
      }
#line 260
      k = *(auxadj + j);
#line 261
      m = *(htable + k);
#line 261
      if (m == -1L) {
#line 262
        *(cadjncy + nedges) = k;
#line 263
        *(cadjwgt + nedges) = *(adjwgt + j);
#line 264
        tmp___1 = nedges;
#line 264
        nedges ++;
#line 264
        *(htable + k) = tmp___1;
      } else {
#line 267
        *(cadjwgt + m) += *(adjwgt + j);
      }
#line 259
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 271
    if (v != u) {
#line 272
      if (ncon == 1L) {
#line 273
        *(cvwgt + cnvtxs) += *(vwgt + u);
      } else {
        {
#line 275
        __saxpy(ncon, (float )1.0, nvwgt + u * ncon, 1L, cnvwgt + cnvtxs * ncon, 1L);
        }
      }
#line 277
      if (dovsize) {
#line 278
        *(cvsize + cnvtxs) += *(vsize + u);
      }
#line 280
      *(cadjwgtsum + cnvtxs) += *(adjwgtsum + u);
#line 282
      istart = *(xadj + u);
#line 283
      iend = *(xadj + (u + 1L));
#line 284
      j = istart;
      {
#line 284
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 284
        if (! (j < iend)) {
#line 284
          goto while_break___2;
        }
#line 285
        k = *(auxadj + j);
#line 286
        m = *(htable + k);
#line 286
        if (m == -1L) {
#line 287
          *(cadjncy + nedges) = k;
#line 288
          *(cadjwgt + nedges) = *(adjwgt + j);
#line 289
          tmp___2 = nedges;
#line 289
          nedges ++;
#line 289
          *(htable + k) = tmp___2;
        } else {
#line 292
          *(cadjwgt + m) += *(adjwgt + j);
        }
#line 284
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 297
      j = *(htable + cnvtxs);
#line 297
      if (j != -1L) {
#line 299
        *(cadjwgtsum + cnvtxs) -= *(cadjwgt + j);
#line 300
        nedges --;
#line 300
        *(cadjncy + j) = *(cadjncy + nedges);
#line 301
        *(cadjwgt + j) = *(cadjwgt + nedges);
#line 302
        *(htable + cnvtxs) = (idxtype )-1;
      }
    }
#line 308
    j = 0L;
    {
#line 308
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 308
      if (! (j < nedges)) {
#line 308
        goto while_break___3;
      }
#line 309
      *(htable + *(cadjncy + j)) = (idxtype )-1;
#line 308
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 311
    cnedges += nedges;
#line 312
    cnvtxs ++;
#line 312
    *(cxadj + cnvtxs) = cnedges;
#line 313
    cadjncy += nedges;
#line 314
    cadjwgt += nedges;
    __Cont: /* CIL Label */ 
#line 240
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  cgraph->nedges = cnedges;
#line 319
  __ReAdjustMemory(graph, cgraph, dovsize);
  }
#line 321
  if (ctrl->dbglvl & 1L) {
    {
#line 321
    tmp___3 = __seconds();
#line 321
    ctrl->ContractTmr += tmp___3;
    }
  }
  {
#line 323
  __idxwspacefree(ctrl, cnvtxs);
  }
#line 324
  return;
}
}
#line 330 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/ccgraph.c"
void __CreateCoarseGraph_NVW(CtrlType *ctrl , GraphType *graph , long cnvtxs , idxtype *match ,
                             idxtype *perm ) 
{ 
  long i ;
  long j ;
  long jj ;
  long k ;
  long kk ;
  long m ;
  long istart ;
  long iend ;
  long nvtxs ;
  long nedges ;
  long ncon ;
  long cnedges ;
  long v ;
  long u ;
  long mask ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgtsum ;
  idxtype *auxadj ;
  idxtype *cmap ;
  idxtype *htable ;
  idxtype *cxadj ;
  idxtype *cvwgt ;
  idxtype *cadjncy ;
  idxtype *cadjwgt ;
  idxtype *cadjwgtsum ;
  float *nvwgt ;
  float *cnvwgt ;
  GraphType *cgraph ;
  double tmp ;
  idxtype *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  double tmp___5 ;

  {
#line 340
  if (ctrl->dbglvl & 1L) {
    {
#line 340
    tmp = __seconds();
#line 340
    ctrl->ContractTmr -= tmp;
    }
  }
  {
#line 342
  nvtxs = graph->nvtxs;
#line 343
  ncon = graph->ncon;
#line 344
  xadj = graph->xadj;
#line 345
  nvwgt = graph->nvwgt;
#line 346
  adjncy = graph->adjncy;
#line 347
  adjwgtsum = graph->adjwgtsum;
#line 348
  cmap = graph->cmap;
#line 351
  cgraph = __SetUpCoarseGraph(graph, cnvtxs, 0L);
#line 352
  cxadj = cgraph->xadj;
#line 353
  cvwgt = cgraph->vwgt;
#line 354
  cnvwgt = cgraph->nvwgt;
#line 355
  cadjwgtsum = cgraph->adjwgtsum;
#line 356
  cadjncy = cgraph->adjncy;
#line 357
  cadjwgt = cgraph->adjwgt;
#line 360
  iend = *(xadj + nvtxs);
#line 361
  auxadj = ctrl->wspace.auxcore;
#line 362
  memcpy((void */* __restrict  */)auxadj, (void const   */* __restrict  */)adjncy,
         (unsigned long )iend * sizeof(idxtype ));
#line 363
  i = 0L;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! (i < iend)) {
#line 363
      goto while_break;
    }
#line 364
    *(auxadj + i) = *(cmap + *(auxadj + i));
#line 363
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  mask = (long )((1 << 11) - 1);
#line 367
  tmp___0 = __idxwspacemalloc(ctrl, mask + 1L);
#line 367
  htable = __idxset(mask + 1L, (idxtype )-1, tmp___0);
#line 369
  cnedges = 0L;
#line 369
  cnvtxs = cnedges;
#line 369
  *(cxadj + 0) = cnvtxs;
#line 370
  i = 0L;
  }
  {
#line 370
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 370
    if (! (i < nvtxs)) {
#line 370
      goto while_break___0;
    }
#line 371
    v = *(perm + i);
#line 372
    if (*(cmap + v) != cnvtxs) {
#line 373
      goto __Cont;
    }
#line 375
    u = *(match + v);
#line 376
    *(cvwgt + cnvtxs) = (idxtype )1;
#line 377
    *(cadjwgtsum + cnvtxs) = *(adjwgtsum + v);
#line 378
    nedges = 0L;
#line 380
    istart = *(xadj + v);
#line 381
    iend = *(xadj + (v + 1L));
#line 382
    j = istart;
    {
#line 382
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 382
      if (! (j < iend)) {
#line 382
        goto while_break___1;
      }
#line 383
      k = *(auxadj + j);
#line 384
      kk = k & mask;
#line 385
      m = *(htable + kk);
#line 385
      if (m == -1L) {
#line 386
        *(cadjncy + nedges) = k;
#line 387
        *(cadjwgt + nedges) = (idxtype )1;
#line 388
        tmp___1 = nedges;
#line 388
        nedges ++;
#line 388
        *(htable + kk) = tmp___1;
      } else
#line 390
      if (*(cadjncy + m) == k) {
#line 391
        (*(cadjwgt + m)) ++;
      } else {
#line 394
        jj = 0L;
        {
#line 394
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 394
          if (! (jj < nedges)) {
#line 394
            goto while_break___2;
          }
#line 395
          if (*(cadjncy + jj) == k) {
#line 396
            (*(cadjwgt + jj)) ++;
#line 397
            goto while_break___2;
          }
#line 394
          jj ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 400
        if (jj == nedges) {
#line 401
          *(cadjncy + nedges) = k;
#line 402
          tmp___2 = nedges;
#line 402
          nedges ++;
#line 402
          *(cadjwgt + tmp___2) = (idxtype )1;
        }
      }
#line 382
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 407
    if (v != u) {
#line 408
      (*(cvwgt + cnvtxs)) ++;
#line 409
      *(cadjwgtsum + cnvtxs) += *(adjwgtsum + u);
#line 411
      istart = *(xadj + u);
#line 412
      iend = *(xadj + (u + 1L));
#line 413
      j = istart;
      {
#line 413
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 413
        if (! (j < iend)) {
#line 413
          goto while_break___3;
        }
#line 414
        k = *(auxadj + j);
#line 415
        kk = k & mask;
#line 416
        m = *(htable + kk);
#line 416
        if (m == -1L) {
#line 417
          *(cadjncy + nedges) = k;
#line 418
          *(cadjwgt + nedges) = (idxtype )1;
#line 419
          tmp___3 = nedges;
#line 419
          nedges ++;
#line 419
          *(htable + kk) = tmp___3;
        } else
#line 421
        if (*(cadjncy + m) == k) {
#line 422
          (*(cadjwgt + m)) ++;
        } else {
#line 425
          jj = 0L;
          {
#line 425
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 425
            if (! (jj < nedges)) {
#line 425
              goto while_break___4;
            }
#line 426
            if (*(cadjncy + jj) == k) {
#line 427
              (*(cadjwgt + jj)) ++;
#line 428
              goto while_break___4;
            }
#line 425
            jj ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 431
          if (jj == nedges) {
#line 432
            *(cadjncy + nedges) = k;
#line 433
            tmp___4 = nedges;
#line 433
            nedges ++;
#line 433
            *(cadjwgt + tmp___4) = (idxtype )1;
          }
        }
#line 413
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 439
      jj = *(htable + (cnvtxs & mask));
#line 440
      if (jj >= 0L) {
#line 440
        if (*(cadjncy + jj) != cnvtxs) {
#line 441
          jj = 0L;
          {
#line 441
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 441
            if (! (jj < nedges)) {
#line 441
              goto while_break___5;
            }
#line 442
            if (*(cadjncy + jj) == cnvtxs) {
#line 443
              goto while_break___5;
            }
#line 441
            jj ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      }
#line 446
      if (jj >= 0L) {
#line 446
        if (*(cadjncy + jj) == cnvtxs) {
#line 447
          *(cadjwgtsum + cnvtxs) -= *(cadjwgt + jj);
#line 448
          nedges --;
#line 448
          *(cadjncy + jj) = *(cadjncy + nedges);
#line 449
          *(cadjwgt + jj) = *(cadjwgt + nedges);
        }
      }
    }
#line 455
    j = 0L;
    {
#line 455
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 455
      if (! (j < nedges)) {
#line 455
        goto while_break___6;
      }
#line 456
      *(htable + (*(cadjncy + j) & mask)) = (idxtype )-1;
#line 455
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 457
    *(htable + (cnvtxs & mask)) = (idxtype )-1;
#line 459
    cnedges += nedges;
#line 460
    cnvtxs ++;
#line 460
    *(cxadj + cnvtxs) = cnedges;
#line 461
    cadjncy += nedges;
#line 462
    cadjwgt += nedges;
    __Cont: /* CIL Label */ 
#line 370
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 465
  cgraph->nedges = cnedges;
#line 467
  __ReAdjustMemory(graph, cgraph, 0L);
  }
#line 469
  if (ctrl->dbglvl & 1L) {
    {
#line 469
    tmp___5 = __seconds();
#line 469
    ctrl->ContractTmr += tmp___5;
    }
  }
  {
#line 471
  __idxwspacefree(ctrl, mask + 1L);
  }
#line 473
  return;
}
}
#line 479 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/ccgraph.c"
GraphType *__SetUpCoarseGraph(GraphType *graph , long cnvtxs , long dovsize ) 
{ 
  GraphType *cgraph ;

  {
  {
#line 483
  cgraph = __CreateGraph();
#line 484
  cgraph->nvtxs = cnvtxs;
#line 485
  cgraph->ncon = graph->ncon;
#line 487
  cgraph->finer = graph;
#line 488
  graph->coarser = cgraph;
  }
#line 492
  if (graph->ncon == 1L) {
#line 493
    if (dovsize) {
      {
#line 494
      cgraph->gdata = __idxmalloc((5L * cnvtxs + 1L) + 2L * graph->nedges, (char *)"SetUpCoarseGraph: gdata");
#line 495
      cgraph->xadj = cgraph->gdata;
#line 496
      cgraph->vwgt = (cgraph->gdata + cnvtxs) + 1;
#line 497
      cgraph->vsize = (cgraph->gdata + 2L * cnvtxs) + 1;
#line 498
      cgraph->adjwgtsum = (cgraph->gdata + 3L * cnvtxs) + 1;
#line 499
      cgraph->cmap = (cgraph->gdata + 4L * cnvtxs) + 1;
#line 500
      cgraph->adjncy = (cgraph->gdata + 5L * cnvtxs) + 1;
#line 501
      cgraph->adjwgt = ((cgraph->gdata + 5L * cnvtxs) + 1) + graph->nedges;
      }
    } else {
      {
#line 504
      cgraph->gdata = __idxmalloc((4L * cnvtxs + 1L) + 2L * graph->nedges, (char *)"SetUpCoarseGraph: gdata");
#line 505
      cgraph->xadj = cgraph->gdata;
#line 506
      cgraph->vwgt = (cgraph->gdata + cnvtxs) + 1;
#line 507
      cgraph->adjwgtsum = (cgraph->gdata + 2L * cnvtxs) + 1;
#line 508
      cgraph->cmap = (cgraph->gdata + 3L * cnvtxs) + 1;
#line 509
      cgraph->adjncy = (cgraph->gdata + 4L * cnvtxs) + 1;
#line 510
      cgraph->adjwgt = ((cgraph->gdata + 4L * cnvtxs) + 1) + graph->nedges;
      }
    }
  } else {
#line 514
    if (dovsize) {
      {
#line 515
      cgraph->gdata = __idxmalloc((4L * cnvtxs + 1L) + 2L * graph->nedges, (char *)"SetUpCoarseGraph: gdata");
#line 516
      cgraph->xadj = cgraph->gdata;
#line 517
      cgraph->vsize = (cgraph->gdata + cnvtxs) + 1;
#line 518
      cgraph->adjwgtsum = (cgraph->gdata + 2L * cnvtxs) + 1;
#line 519
      cgraph->cmap = (cgraph->gdata + 3L * cnvtxs) + 1;
#line 520
      cgraph->adjncy = (cgraph->gdata + 4L * cnvtxs) + 1;
#line 521
      cgraph->adjwgt = ((cgraph->gdata + 4L * cnvtxs) + 1) + graph->nedges;
      }
    } else {
      {
#line 524
      cgraph->gdata = __idxmalloc((3L * cnvtxs + 1L) + 2L * graph->nedges, (char *)"SetUpCoarseGraph: gdata");
#line 525
      cgraph->xadj = cgraph->gdata;
#line 526
      cgraph->adjwgtsum = (cgraph->gdata + cnvtxs) + 1;
#line 527
      cgraph->cmap = (cgraph->gdata + 2L * cnvtxs) + 1;
#line 528
      cgraph->adjncy = (cgraph->gdata + 3L * cnvtxs) + 1;
#line 529
      cgraph->adjwgt = ((cgraph->gdata + 3L * cnvtxs) + 1) + graph->nedges;
      }
    }
    {
#line 532
    cgraph->nvwgt = __fmalloc(graph->ncon * cnvtxs, (char *)"SetUpCoarseGraph: nvwgt");
    }
  }
#line 535
  return (cgraph);
}
}
#line 543 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/ccgraph.c"
void __ReAdjustMemory(GraphType *graph , GraphType *cgraph , long dovsize ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 546
  if (cgraph->nedges > 100000L) {
#line 546
    if ((double )graph->nedges < 0.7 * (double )graph->nedges) {
      {
#line 547
      memcpy((void */* __restrict  */)((void *)(cgraph->adjncy + cgraph->nedges)),
             (void const   */* __restrict  */)((void *)cgraph->adjwgt), sizeof(idxtype ) * (unsigned long )cgraph->nedges);
      }
#line 549
      if (graph->ncon == 1L) {
#line 550
        if (dovsize) {
          {
#line 551
          tmp = realloc((void *)cgraph->gdata, (unsigned long )((5L * cgraph->nvtxs + 1L) + 2L * cgraph->nedges) * sizeof(idxtype ));
#line 551
          cgraph->gdata = (idxtype *)tmp;
#line 554
          cgraph->xadj = cgraph->gdata;
#line 555
          cgraph->vwgt = (cgraph->gdata + cgraph->nvtxs) + 1;
#line 556
          cgraph->vsize = (cgraph->gdata + 2L * cgraph->nvtxs) + 1;
#line 557
          cgraph->adjwgtsum = (cgraph->gdata + 3L * cgraph->nvtxs) + 1;
#line 558
          cgraph->cmap = (cgraph->gdata + 4L * cgraph->nvtxs) + 1;
#line 559
          cgraph->adjncy = (cgraph->gdata + 5L * cgraph->nvtxs) + 1;
#line 560
          cgraph->adjwgt = ((cgraph->gdata + 5L * cgraph->nvtxs) + 1) + cgraph->nedges;
          }
        } else {
          {
#line 563
          tmp___0 = realloc((void *)cgraph->gdata, (unsigned long )((4L * cgraph->nvtxs + 1L) + 2L * cgraph->nedges) * sizeof(idxtype ));
#line 563
          cgraph->gdata = (idxtype *)tmp___0;
#line 566
          cgraph->xadj = cgraph->gdata;
#line 567
          cgraph->vwgt = (cgraph->gdata + cgraph->nvtxs) + 1;
#line 568
          cgraph->adjwgtsum = (cgraph->gdata + 2L * cgraph->nvtxs) + 1;
#line 569
          cgraph->cmap = (cgraph->gdata + 3L * cgraph->nvtxs) + 1;
#line 570
          cgraph->adjncy = (cgraph->gdata + 4L * cgraph->nvtxs) + 1;
#line 571
          cgraph->adjwgt = ((cgraph->gdata + 4L * cgraph->nvtxs) + 1) + cgraph->nedges;
          }
        }
      } else
#line 575
      if (dovsize) {
        {
#line 576
        tmp___1 = realloc((void *)cgraph->gdata, (unsigned long )((4L * cgraph->nvtxs + 1L) + 2L * cgraph->nedges) * sizeof(idxtype ));
#line 576
        cgraph->gdata = (idxtype *)tmp___1;
#line 579
        cgraph->xadj = cgraph->gdata;
#line 580
        cgraph->vsize = (cgraph->gdata + cgraph->nvtxs) + 1;
#line 581
        cgraph->adjwgtsum = (cgraph->gdata + 2L * cgraph->nvtxs) + 1;
#line 582
        cgraph->cmap = (cgraph->gdata + 3L * cgraph->nvtxs) + 1;
#line 583
        cgraph->adjncy = (cgraph->gdata + 4L * cgraph->nvtxs) + 1;
#line 584
        cgraph->adjwgt = ((cgraph->gdata + 4L * cgraph->nvtxs) + 1) + cgraph->nedges;
        }
      } else {
        {
#line 587
        tmp___2 = realloc((void *)cgraph->gdata, (unsigned long )((3L * cgraph->nvtxs + 1L) + 2L * cgraph->nedges) * sizeof(idxtype ));
#line 587
        cgraph->gdata = (idxtype *)tmp___2;
#line 590
        cgraph->xadj = cgraph->gdata;
#line 591
        cgraph->adjwgtsum = (cgraph->gdata + cgraph->nvtxs) + 1;
#line 592
        cgraph->cmap = (cgraph->gdata + 2L * cgraph->nvtxs) + 1;
#line 593
        cgraph->adjncy = (cgraph->gdata + 3L * cgraph->nvtxs) + 1;
#line 594
        cgraph->adjwgt = ((cgraph->gdata + 3L * cgraph->nvtxs) + 1) + cgraph->nedges;
        }
      }
    }
  }
#line 599
  return;
}
}
#line 59 "./proto.h"
void __ChangeMesh2CNumbering(long n , idxtype *mesh ) ;
#line 61
void __ChangeMesh2FNumbering2(long n , idxtype *mesh , long ne , long nn , idxtype *epart ,
                              idxtype *npart ) ;
#line 432
idxtype *__idxsmalloc(long n , idxtype ival , char *msg ) ;
#line 439
long __iamax(long n , long *x ) ;
#line 22 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/meshpart.c"
void METIS_PartMeshNodal(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                         long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) 
{ 
  long i ;
  long j ;
  long k ;
  long me ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *pwgts ;
  long options[10] ;
  long pnumflag ;
  long wgtflag ;
  long nnbrs ;
  long nbrind[200] ;
  long nbrwgt[200] ;
  long maxpwgt ;
  long esize ;
  long esizes[5] ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 27
  pnumflag = 0L;
#line 27
  wgtflag = 0L;
#line 29
  esizes[0] = -1L;
#line 29
  esizes[1] = 3L;
#line 29
  esizes[2] = 4L;
#line 29
  esizes[3] = 8L;
#line 29
  esizes[4] = 4L;
#line 31
  esize = esizes[*etype];
#line 33
  if (*numflag == 1L) {
    {
#line 34
    __ChangeMesh2CNumbering(*ne * esize, elmnts);
    }
  }
  {
#line 36
  xadj = __idxmalloc(*nn + 1L, (char *)"METIS_MESHPARTNODAL: xadj");
#line 37
  adjncy = __idxmalloc(20L * *nn, (char *)"METIS_MESHPARTNODAL: adjncy");
#line 39
  METIS_MeshToNodal(ne, nn, elmnts, etype, & pnumflag, xadj, adjncy);
#line 41
  tmp = realloc((void *)adjncy, (unsigned long )*(xadj + *nn) * sizeof(idxtype ));
#line 41
  adjncy = (idxtype *)tmp;
#line 43
  options[0] = 0L;
#line 44
  METIS_PartGraphKway(nn, xadj, adjncy, (idxtype *)((void *)0), (idxtype *)((void *)0),
                      & wgtflag, & pnumflag, nparts, options, edgecut, npart);
#line 47
  __idxset(*ne, (idxtype )-1, epart);
#line 48
  pwgts = __idxsmalloc(*nparts, (idxtype )0, (char *)"METIS_MESHPARTNODAL: pwgts");
#line 49
  i = 0L;
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (i < *ne)) {
#line 49
      goto while_break;
    }
#line 50
    me = *(npart + *(elmnts + i * esize));
#line 51
    j = 1L;
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 51
      if (! (j < esize)) {
#line 51
        goto while_break___0;
      }
#line 52
      if (*(npart + *(elmnts + (i * esize + j))) != me) {
#line 53
        goto while_break___0;
      }
#line 51
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 55
    if (j == esize) {
#line 56
      *(epart + i) = me;
#line 57
      (*(pwgts + me)) ++;
    }
#line 49
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  maxpwgt = (long )((1.03 * (double )*ne) / (double )*nparts);
#line 62
  i = 0L;
  {
#line 62
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 62
    if (! (i < *ne)) {
#line 62
      goto while_break___1;
    }
#line 63
    if (*(epart + i) == -1L) {
#line 64
      nnbrs = 0L;
#line 65
      j = 0L;
      {
#line 65
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 65
        if (! (j < esize)) {
#line 65
          goto while_break___2;
        }
#line 66
        me = *(npart + *(elmnts + (i * esize + j)));
#line 67
        k = 0L;
        {
#line 67
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 67
          if (! (k < nnbrs)) {
#line 67
            goto while_break___3;
          }
#line 68
          if (nbrind[k] == me) {
#line 69
            (nbrwgt[k]) ++;
#line 70
            goto while_break___3;
          }
#line 67
          k ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 73
        if (k == nnbrs) {
#line 74
          nbrind[nnbrs] = me;
#line 75
          tmp___0 = nnbrs;
#line 75
          nnbrs ++;
#line 75
          nbrwgt[tmp___0] = 1L;
        }
#line 65
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 79
      j = __iamax(nnbrs, nbrwgt);
      }
#line 80
      if (*(pwgts + nbrind[j]) < maxpwgt) {
#line 81
        *(epart + i) = nbrind[j];
      } else {
#line 85
        j = 0L;
        {
#line 85
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 85
          if (! (j < nnbrs)) {
#line 85
            goto while_break___4;
          }
#line 86
          if (*(pwgts + nbrind[j]) < maxpwgt) {
#line 87
            *(epart + i) = nbrind[j];
#line 88
            goto while_break___4;
          }
#line 85
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 91
        if (j == nnbrs) {
          {
#line 92
          tmp___1 = __iamax(nnbrs, nbrwgt);
#line 92
          *(epart + i) = nbrind[tmp___1];
          }
        }
      }
#line 94
      (*(pwgts + *(epart + i))) ++;
    }
#line 62
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 98
  if (*numflag == 1L) {
    {
#line 99
    __ChangeMesh2FNumbering2(*ne * esize, elmnts, *ne, *nn, epart, npart);
    }
  }
  {
#line 101
  __GKfree(& xadj, & adjncy, & pwgts, (void **)0);
  }
#line 103
  return;
}
}
#line 110 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/meshpart.c"
void METIS_PartMeshDual(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                        long *nparts , long *edgecut , idxtype *epart , idxtype *npart ) 
{ 
  long i ;
  long j ;
  long k ;
  long me ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *pwgts ;
  idxtype *nptr ;
  idxtype *nind ;
  long options[10] ;
  long pnumflag ;
  long wgtflag ;
  long nnbrs ;
  long nbrind[200] ;
  long nbrwgt[200] ;
  long maxpwgt ;
  long esize ;
  long esizes[5] ;
  idxtype tmp ;
  long tmp___0 ;

  {
#line 115
  pnumflag = 0L;
#line 115
  wgtflag = 0L;
#line 117
  esizes[0] = -1L;
#line 117
  esizes[1] = 3L;
#line 117
  esizes[2] = 4L;
#line 117
  esizes[3] = 8L;
#line 117
  esizes[4] = 4L;
#line 119
  esize = esizes[*etype];
#line 121
  if (*numflag == 1L) {
    {
#line 122
    __ChangeMesh2CNumbering(*ne * esize, elmnts);
    }
  }
  {
#line 124
  xadj = __idxmalloc(*ne + 1L, (char *)"METIS_MESHPARTNODAL: xadj");
#line 125
  adjncy = __idxmalloc(esize * *ne, (char *)"METIS_MESHPARTNODAL: adjncy");
#line 127
  METIS_MeshToDual(ne, nn, elmnts, etype, & pnumflag, xadj, adjncy);
#line 129
  options[0] = 0L;
#line 130
  METIS_PartGraphKway(ne, xadj, adjncy, (idxtype *)((void *)0), (idxtype *)((void *)0),
                      & wgtflag, & pnumflag, nparts, options, edgecut, epart);
#line 133
  nptr = __idxsmalloc(*nn + 1L, (idxtype )0, (char *)"METIS_MESHPARTDUAL: nptr");
#line 134
  j = esize * *ne;
#line 134
  i = 0L;
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (i < j)) {
#line 134
      goto while_break;
    }
#line 135
    (*(nptr + *(elmnts + i))) ++;
#line 134
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 136
    i = 1L;
    {
#line 136
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 136
      if (! (i < *nn)) {
#line 136
        goto while_break___1;
      }
#line 136
      *(nptr + i) += *(nptr + (i - 1L));
#line 136
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 136
    i = *nn;
    {
#line 136
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 136
      if (! (i > 0L)) {
#line 136
        goto while_break___2;
      }
#line 136
      *(nptr + i) = *(nptr + (i - 1L));
#line 136
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 136
    *(nptr + 0) = (idxtype )0;
#line 136
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 138
  nind = __idxmalloc(*(nptr + *nn), (char *)"METIS_MESHPARTDUAL: nind");
#line 139
  i = 0L;
#line 139
  k = i;
  }
  {
#line 139
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 139
    if (! (i < *ne)) {
#line 139
      goto while_break___3;
    }
#line 140
    j = 0L;
    {
#line 140
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 140
      if (! (j < esize)) {
#line 140
        goto while_break___4;
      }
#line 141
      tmp = *(nptr + *(elmnts + k));
#line 141
      (*(nptr + *(elmnts + k))) ++;
#line 141
      *(nind + tmp) = i;
#line 140
      j ++;
#line 140
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 139
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 143
  i = *nn;
  {
#line 143
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 143
    if (! (i > 0L)) {
#line 143
      goto while_break___5;
    }
#line 144
    *(nptr + i) = *(nptr + (i - 1L));
#line 143
    i --;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 145
  *(nptr + 0) = (idxtype )0;
#line 149
  __idxset(*nn, (idxtype )-1, npart);
#line 150
  pwgts = __idxsmalloc(*nparts, (idxtype )0, (char *)"METIS_MESHPARTDUAL: pwgts");
#line 151
  i = 0L;
  }
  {
#line 151
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 151
    if (! (i < *nn)) {
#line 151
      goto while_break___6;
    }
#line 152
    me = *(epart + *(nind + *(nptr + i)));
#line 153
    j = *(nptr + i) + 1L;
    {
#line 153
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 153
      if (! (j < *(nptr + (i + 1L)))) {
#line 153
        goto while_break___7;
      }
#line 154
      if (*(epart + *(nind + j)) != me) {
#line 155
        goto while_break___7;
      }
#line 153
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 157
    if (j == *(nptr + (i + 1L))) {
#line 158
      *(npart + i) = me;
#line 159
      (*(pwgts + me)) ++;
    }
#line 151
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 163
  maxpwgt = (long )((1.03 * (double )*nn) / (double )*nparts);
#line 164
  i = 0L;
  {
#line 164
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 164
    if (! (i < *nn)) {
#line 164
      goto while_break___8;
    }
#line 165
    if (*(npart + i) == -1L) {
#line 166
      nnbrs = 0L;
#line 167
      j = *(nptr + i);
      {
#line 167
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 167
        if (! (j < *(nptr + (i + 1L)))) {
#line 167
          goto while_break___9;
        }
#line 168
        me = *(epart + *(nind + j));
#line 169
        k = 0L;
        {
#line 169
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 169
          if (! (k < nnbrs)) {
#line 169
            goto while_break___10;
          }
#line 170
          if (nbrind[k] == me) {
#line 171
            (nbrwgt[k]) ++;
#line 172
            goto while_break___10;
          }
#line 169
          k ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 175
        if (k == nnbrs) {
#line 176
          nbrind[nnbrs] = me;
#line 177
          tmp___0 = nnbrs;
#line 177
          nnbrs ++;
#line 177
          nbrwgt[tmp___0] = 1L;
        }
#line 167
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 181
      j = __iamax(nnbrs, nbrwgt);
      }
#line 182
      if (*(pwgts + nbrind[j]) < maxpwgt) {
#line 183
        *(npart + i) = nbrind[j];
      } else {
#line 187
        *(npart + i) = nbrind[0];
#line 188
        j = 0L;
        {
#line 188
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 188
          if (! (j < nnbrs)) {
#line 188
            goto while_break___11;
          }
#line 189
          if (*(pwgts + nbrind[j]) < maxpwgt) {
#line 190
            *(npart + i) = nbrind[j];
#line 191
            goto while_break___11;
          }
#line 188
          j ++;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
#line 195
      (*(pwgts + *(npart + i))) ++;
    }
#line 164
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 199
  if (*numflag == 1L) {
    {
#line 200
    __ChangeMesh2FNumbering2(*ne * esize, elmnts, *ne, *nn, epart, npart);
    }
  }
  {
#line 202
  __GKfree(& xadj, & adjncy, & pwgts, & nptr, & nind, (void **)0);
  }
#line 204
  return;
}
}
#line 249 "./proto.h"
void __MinCover(idxtype *xadj , idxtype *adjncy , long asize , long bsize , idxtype *cover ,
                long *csize ) ;
#line 387
void __ConstructSeparator(CtrlType *ctrl , GraphType *graph , float ubfactor ) ;
#line 388
void __ConstructMinCoverSeparator0(CtrlType *ctrl , GraphType *graph , float ubfactor ) ;
#line 389
void __ConstructMinCoverSeparator(CtrlType *ctrl , GraphType *graph , float ubfactor ) ;
#line 392
void __FM_2WayNodeRefine(CtrlType *ctrl , GraphType *graph , float ubfactor , long npasses ) ;
#line 394
void __FM_2WayNodeRefine_OneSided(CtrlType *ctrl , GraphType *graph , float ubfactor ,
                                  long npasses ) ;
#line 400
void __Allocate2WayNodePartitionMemory(CtrlType *ctrl , GraphType *graph ) ;
#line 401
void __Compute2WayNodePartitionParams(CtrlType *ctrl , GraphType *graph ) ;
#line 21 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/separator.c"
void __ConstructSeparator(CtrlType *ctrl , GraphType *graph , float ubfactor ) 
{ 
  long i ;
  long j ;
  long nvtxs ;
  long nbnd ;
  idxtype *xadj ;
  idxtype *where ;
  idxtype *bndind ;
  idxtype *tmp ;
  void *tmp___0 ;

  {
  {
#line 26
  nvtxs = graph->nvtxs;
#line 27
  xadj = graph->xadj;
#line 28
  nbnd = graph->nbnd;
#line 29
  bndind = graph->bndind;
#line 31
  tmp = __idxwspacemalloc(ctrl, nvtxs);
#line 31
  tmp___0 = memcpy((void */* __restrict  */)((void *)tmp), (void const   */* __restrict  */)((void *)graph->where),
                   sizeof(idxtype ) * (unsigned long )nvtxs);
#line 31
  where = (idxtype *)tmp___0;
#line 34
  i = 0L;
  }
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (i < nbnd)) {
#line 34
      goto while_break;
    }
#line 35
    j = *(bndind + i);
#line 36
    if (*(xadj + (j + 1L)) - *(xadj + j) > 0L) {
#line 37
      *(where + j) = (idxtype )2;
    }
#line 34
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 40
  __GKfree(& graph->rdata, (void **)0);
#line 41
  __Allocate2WayNodePartitionMemory(ctrl, graph);
#line 42
  memcpy((void */* __restrict  */)((void *)graph->where), (void const   */* __restrict  */)((void *)where),
         sizeof(idxtype ) * (unsigned long )nvtxs);
#line 43
  __idxwspacefree(ctrl, nvtxs);
#line 47
  __Compute2WayNodePartitionParams(ctrl, graph);
#line 51
  __FM_2WayNodeRefine(ctrl, graph, ubfactor, 8L);
  }
#line 54
  return;
}
}
#line 63 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/separator.c"
void __ConstructMinCoverSeparator0(CtrlType *ctrl , GraphType *graph , float ubfactor ) 
{ 
  long i ;
  long ii ;
  long j ;
  long jj ;
  long k ;
  long l ;
  long nvtxs ;
  long nbnd ;
  long bnvtxs[3] ;
  long bnedges[2] ;
  long csize ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *bxadj ;
  idxtype *badjncy ;
  idxtype *where ;
  idxtype *bndind ;
  idxtype *bndptr ;
  idxtype *vmap ;
  idxtype *ivmap ;
  idxtype *cover ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 70
  nvtxs = graph->nvtxs;
#line 71
  xadj = graph->xadj;
#line 72
  adjncy = graph->adjncy;
#line 74
  nbnd = graph->nbnd;
#line 75
  bndind = graph->bndind;
#line 76
  bndptr = graph->bndptr;
#line 77
  where = graph->where;
#line 79
  vmap = __idxwspacemalloc(ctrl, nvtxs);
#line 80
  ivmap = __idxwspacemalloc(ctrl, nbnd);
#line 81
  cover = __idxwspacemalloc(ctrl, nbnd);
  }
#line 83
  if (nbnd > 0L) {
#line 85
    bnedges[1] = 0L;
#line 85
    bnedges[0] = bnedges[1];
#line 85
    bnvtxs[1] = bnedges[0];
#line 85
    bnvtxs[0] = bnvtxs[1];
#line 86
    i = 0L;
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;
#line 86
      if (! (i < nbnd)) {
#line 86
        goto while_break;
      }
#line 87
      j = *(bndind + i);
#line 88
      k = *(where + j);
#line 89
      if (*(xadj + (j + 1L)) - *(xadj + j) > 0L) {
#line 90
        (bnvtxs[k]) ++;
#line 91
        bnedges[k] += *(xadj + (j + 1L)) - *(xadj + j);
      }
#line 86
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 95
    bnvtxs[2] = bnvtxs[0] + bnvtxs[1];
#line 96
    bnvtxs[1] = bnvtxs[0];
#line 97
    bnvtxs[0] = 0L;
#line 99
    bxadj = __idxmalloc(bnvtxs[2] + 1L, (char *)"ConstructMinCoverSeparator: bxadj");
#line 100
    badjncy = __idxmalloc((bnedges[0] + bnedges[1]) + 1L, (char *)"ConstructMinCoverSeparator: badjncy");
#line 104
    i = 0L;
    }
    {
#line 104
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 104
      if (! (i < nbnd)) {
#line 104
        goto while_break___0;
      }
#line 105
      j = *(bndind + i);
#line 106
      k = *(where + j);
#line 107
      if (*(xadj + (j + 1L)) - *(xadj + j) > 0L) {
#line 108
        *(vmap + j) = bnvtxs[k];
#line 109
        tmp = bnvtxs[k];
#line 109
        (bnvtxs[k]) ++;
#line 109
        *(ivmap + tmp) = j;
      }
#line 104
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 114
    bnvtxs[1] = bnvtxs[0];
#line 115
    bnvtxs[0] = 0L;
#line 116
    l = 0L;
#line 116
    *(bxadj + 0) = l;
#line 117
    k = 0L;
    {
#line 117
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 117
      if (! (k < 2L)) {
#line 117
        goto while_break___1;
      }
#line 118
      ii = 0L;
      {
#line 118
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 118
        if (! (ii < nbnd)) {
#line 118
          goto while_break___2;
        }
#line 119
        i = *(bndind + ii);
#line 120
        if (*(where + i) == k) {
#line 120
          if (*(xadj + i) < *(xadj + (i + 1L))) {
#line 121
            j = *(xadj + i);
            {
#line 121
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 121
              if (! (j < *(xadj + (i + 1L)))) {
#line 121
                goto while_break___3;
              }
#line 122
              jj = *(adjncy + j);
#line 123
              if (*(where + jj) != k) {
#line 126
                tmp___0 = l;
#line 126
                l ++;
#line 126
                *(badjncy + tmp___0) = *(vmap + jj);
              }
#line 121
              j ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 129
            (bnvtxs[k]) ++;
#line 129
            *(bxadj + bnvtxs[k]) = l;
          }
        }
#line 118
        ii ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 117
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 136
    __MinCover(bxadj, badjncy, bnvtxs[0], bnvtxs[1], cover, & csize);
    }
#line 138
    if (ctrl->dbglvl & 128L) {
      {
#line 138
      printf((char const   */* __restrict  */)"Nvtxs: %6ld, [%5ld %5ld], Cut: %6ld, SS: [%6ld %6ld], Cover: %6ld\n",
             nvtxs, *(graph->pwgts + 0), *(graph->pwgts + 1), graph->mincut, bnvtxs[0],
             bnvtxs[1] - bnvtxs[0], csize);
      }
    }
#line 141
    i = 0L;
    {
#line 141
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 141
      if (! (i < csize)) {
#line 141
        goto while_break___4;
      }
#line 142
      j = *(ivmap + *(cover + i));
#line 143
      *(where + j) = (idxtype )2;
#line 141
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 146
    __GKfree(& bxadj, & badjncy, (void **)0);
#line 148
    i = 0L;
    }
    {
#line 148
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 148
      if (! (i < nbnd)) {
#line 148
        goto while_break___5;
      }
#line 149
      *(bndptr + *(bndind + i)) = (idxtype )-1;
#line 148
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 150
    i = 0L;
#line 150
    nbnd = i;
    {
#line 150
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 150
      if (! (i < nvtxs)) {
#line 150
        goto while_break___6;
      }
#line 151
      if (*(where + i) == 2L) {
#line 152
        *(bndind + nbnd) = i;
#line 153
        tmp___1 = nbnd;
#line 153
        nbnd ++;
#line 153
        *(bndptr + i) = tmp___1;
      }
#line 150
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  } else
#line 158
  if (ctrl->dbglvl & 128L) {
    {
#line 158
    printf((char const   */* __restrict  */)"Nvtxs: %6ld, [%5ld %5ld], Cut: %6ld, SS: [%6d %6d], Cover: %6d\n",
           nvtxs, *(graph->pwgts + 0), *(graph->pwgts + 1), graph->mincut, 0, 0, 0);
    }
  }
  {
#line 162
  __idxwspacefree(ctrl, nvtxs);
#line 163
  __idxwspacefree(ctrl, graph->nbnd);
#line 164
  __idxwspacefree(ctrl, graph->nbnd);
#line 165
  graph->nbnd = nbnd;
  }
#line 169
  return;
}
}
#line 178 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/separator.c"
void __ConstructMinCoverSeparator(CtrlType *ctrl , GraphType *graph , float ubfactor ) 
{ 
  long i ;
  long ii ;
  long j ;
  long jj ;
  long k ;
  long l ;
  long nvtxs ;
  long nbnd ;
  long bnvtxs[3] ;
  long bnedges[2] ;
  long csize ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *bxadj ;
  idxtype *badjncy ;
  idxtype *where ;
  idxtype *bndind ;
  idxtype *bndptr ;
  idxtype *vmap ;
  idxtype *ivmap ;
  idxtype *cover ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 185
  nvtxs = graph->nvtxs;
#line 186
  xadj = graph->xadj;
#line 187
  adjncy = graph->adjncy;
#line 189
  nbnd = graph->nbnd;
#line 190
  bndind = graph->bndind;
#line 191
  bndptr = graph->bndptr;
#line 192
  where = graph->where;
#line 194
  vmap = __idxwspacemalloc(ctrl, nvtxs);
#line 195
  ivmap = __idxwspacemalloc(ctrl, nbnd);
#line 196
  cover = __idxwspacemalloc(ctrl, nbnd);
  }
#line 198
  if (nbnd > 0L) {
#line 200
    bnedges[1] = 0L;
#line 200
    bnedges[0] = bnedges[1];
#line 200
    bnvtxs[1] = bnedges[0];
#line 200
    bnvtxs[0] = bnvtxs[1];
#line 201
    i = 0L;
    {
#line 201
    while (1) {
      while_continue: /* CIL Label */ ;
#line 201
      if (! (i < nbnd)) {
#line 201
        goto while_break;
      }
#line 202
      j = *(bndind + i);
#line 203
      k = *(where + j);
#line 204
      if (*(xadj + (j + 1L)) - *(xadj + j) > 0L) {
#line 205
        (bnvtxs[k]) ++;
#line 206
        bnedges[k] += *(xadj + (j + 1L)) - *(xadj + j);
      }
#line 201
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 210
    bnvtxs[2] = bnvtxs[0] + bnvtxs[1];
#line 211
    bnvtxs[1] = bnvtxs[0];
#line 212
    bnvtxs[0] = 0L;
#line 214
    bxadj = __idxmalloc(bnvtxs[2] + 1L, (char *)"ConstructMinCoverSeparator: bxadj");
#line 215
    badjncy = __idxmalloc((bnedges[0] + bnedges[1]) + 1L, (char *)"ConstructMinCoverSeparator: badjncy");
#line 219
    i = 0L;
    }
    {
#line 219
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 219
      if (! (i < nbnd)) {
#line 219
        goto while_break___0;
      }
#line 220
      j = *(bndind + i);
#line 221
      k = *(where + j);
#line 222
      if (*(xadj + (j + 1L)) - *(xadj + j) > 0L) {
#line 223
        *(vmap + j) = bnvtxs[k];
#line 224
        tmp = bnvtxs[k];
#line 224
        (bnvtxs[k]) ++;
#line 224
        *(ivmap + tmp) = j;
      }
#line 219
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 229
    bnvtxs[1] = bnvtxs[0];
#line 230
    bnvtxs[0] = 0L;
#line 231
    l = 0L;
#line 231
    *(bxadj + 0) = l;
#line 232
    k = 0L;
    {
#line 232
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 232
      if (! (k < 2L)) {
#line 232
        goto while_break___1;
      }
#line 233
      ii = 0L;
      {
#line 233
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 233
        if (! (ii < nbnd)) {
#line 233
          goto while_break___2;
        }
#line 234
        i = *(bndind + ii);
#line 235
        if (*(where + i) == k) {
#line 235
          if (*(xadj + i) < *(xadj + (i + 1L))) {
#line 236
            j = *(xadj + i);
            {
#line 236
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 236
              if (! (j < *(xadj + (i + 1L)))) {
#line 236
                goto while_break___3;
              }
#line 237
              jj = *(adjncy + j);
#line 238
              if (*(where + jj) != k) {
#line 241
                tmp___0 = l;
#line 241
                l ++;
#line 241
                *(badjncy + tmp___0) = *(vmap + jj);
              }
#line 236
              j ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 244
            (bnvtxs[k]) ++;
#line 244
            *(bxadj + bnvtxs[k]) = l;
          }
        }
#line 233
        ii ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 232
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 251
    __MinCover(bxadj, badjncy, bnvtxs[0], bnvtxs[1], cover, & csize);
    }
#line 253
    if (ctrl->dbglvl & 128L) {
      {
#line 253
      printf((char const   */* __restrict  */)"Nvtxs: %6ld, [%5ld %5ld], Cut: %6ld, SS: [%6ld %6ld], Cover: %6ld\n",
             nvtxs, *(graph->pwgts + 0), *(graph->pwgts + 1), graph->mincut, bnvtxs[0],
             bnvtxs[1] - bnvtxs[0], csize);
      }
    }
#line 256
    i = 0L;
    {
#line 256
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 256
      if (! (i < csize)) {
#line 256
        goto while_break___4;
      }
#line 257
      j = *(ivmap + *(cover + i));
#line 258
      *(where + j) = (idxtype )2;
#line 256
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 261
    __GKfree(& bxadj, & badjncy, (void **)0);
    }
  } else
#line 264
  if (ctrl->dbglvl & 128L) {
    {
#line 264
    printf((char const   */* __restrict  */)"Nvtxs: %6ld, [%5ld %5ld], Cut: %6ld, SS: [%6d %6d], Cover: %6d\n",
           nvtxs, *(graph->pwgts + 0), *(graph->pwgts + 1), graph->mincut, 0, 0, 0);
    }
  }
  {
#line 269
  memcpy((void */* __restrict  */)((void *)vmap), (void const   */* __restrict  */)((void *)graph->where),
         sizeof(idxtype ) * (unsigned long )nvtxs);
#line 270
  __GKfree(& graph->rdata, (void **)0);
#line 272
  __Allocate2WayNodePartitionMemory(ctrl, graph);
#line 273
  memcpy((void */* __restrict  */)((void *)graph->where), (void const   */* __restrict  */)((void *)vmap),
         sizeof(idxtype ) * (unsigned long )nvtxs);
#line 274
  __idxwspacefree(ctrl, nvtxs + 2L * graph->nbnd);
#line 276
  __Compute2WayNodePartitionParams(ctrl, graph);
#line 280
  __FM_2WayNodeRefine_OneSided(ctrl, graph, ubfactor, 6L);
  }
#line 283
  return;
}
}
#line 158 "./proto.h"
void __Random_KWayEdgeRefine(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ,
                             float ubfactor , long npasses , long ffactor ) ;
#line 159
void __Greedy_KWayEdgeRefine(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ,
                             float ubfactor , long npasses ) ;
#line 160
void __Greedy_KWayEdgeBalance(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ,
                              float ubfactor , long npasses ) ;
#line 178
long __ComputeVolume(GraphType *graph , idxtype *where ) ;
#line 440
long __idxamax(long n , idxtype *x ) ;
#line 444
long __idxamin(long n , idxtype *x ) ;
#line 19 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayfm.c"
void __Random_KWayEdgeRefine(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ,
                             float ubfactor , long npasses , long ffactor ) 
{ 
  long i ;
  long ii ;
  long iii ;
  long j ;
  long k ;
  long pass ;
  long nvtxs ;
  long nmoves ;
  long nbnd ;
  long tvwgt ;
  long myndegrees ;
  long from ;
  long me ;
  long to ;
  long oldcut ;
  long vwgt ;
  long gain ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *perm ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *minwgt ;
  idxtype *maxwgt ;
  idxtype *itpwgts ;
  EDegreeType *myedegrees ;
  RInfoType *myrinfo ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
  {
#line 28
  nvtxs = graph->nvtxs;
#line 29
  xadj = graph->xadj;
#line 30
  adjncy = graph->adjncy;
#line 31
  adjwgt = graph->adjwgt;
#line 33
  bndptr = graph->bndptr;
#line 34
  bndind = graph->bndind;
#line 36
  where = graph->where;
#line 37
  pwgts = graph->pwgts;
#line 40
  minwgt = __idxwspacemalloc(ctrl, nparts);
#line 41
  maxwgt = __idxwspacemalloc(ctrl, nparts);
#line 42
  itpwgts = __idxwspacemalloc(ctrl, nparts);
#line 43
  tvwgt = __idxsum(nparts, pwgts);
#line 46
  i = 0L;
  }
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i < nparts)) {
#line 46
      goto while_break;
    }
#line 47
    *(itpwgts + i) = (idxtype )(*(tpwgts + i) * (float )tvwgt);
#line 48
    *(maxwgt + i) = (idxtype )((*(tpwgts + i) * (float )tvwgt) * ubfactor);
#line 49
    *(minwgt + i) = (idxtype )((double )(*(tpwgts + i) * (float )tvwgt) * (1.0 / (double )ubfactor));
#line 46
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 52
  perm = __idxwspacemalloc(ctrl, nvtxs);
  }
#line 54
  if (ctrl->dbglvl & 8L) {
    {
#line 54
    tmp = __idxamax(nparts, pwgts);
#line 54
    tmp___0 = __idxamax(nparts, pwgts);
#line 54
    tmp___1 = __idxamin(nparts, pwgts);
#line 54
    printf((char const   */* __restrict  */)"Partitions: [%6ld %6ld]-[%6ld %6ld], Balance: %5.3f, Nv-Nb[%6ld %6ld]. Cut: %6ld\n",
           *(pwgts + tmp___1), *(pwgts + tmp___0), *(minwgt + 0), *(maxwgt + 0), ((1.0 * (double )nparts) * (double )*(pwgts + tmp)) / (double )tvwgt,
           graph->nvtxs, graph->nbnd, graph->mincut);
    }
  }
#line 60
  pass = 0L;
  {
#line 60
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 60
    if (! (pass < npasses)) {
#line 60
      goto while_break___0;
    }
    {
#line 63
    oldcut = graph->mincut;
#line 64
    nbnd = graph->nbnd;
#line 66
    __RandomPermute(nbnd, perm, 1L);
#line 67
    iii = 0L;
#line 67
    nmoves = iii;
    }
    {
#line 67
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 67
      if (! (iii < graph->nbnd)) {
#line 67
        goto while_break___1;
      }
#line 68
      ii = *(perm + iii);
#line 69
      if (ii >= nbnd) {
#line 70
        goto __Cont;
      }
#line 71
      i = *(bndind + ii);
#line 73
      myrinfo = graph->rinfo + i;
#line 75
      if (myrinfo->ed >= myrinfo->id) {
#line 76
        from = *(where + i);
#line 77
        vwgt = *(graph->vwgt + i);
#line 79
        if (myrinfo->id > 0L) {
#line 79
          if (*(pwgts + from) - vwgt < *(minwgt + from)) {
#line 80
            goto __Cont;
          }
        }
#line 82
        myedegrees = myrinfo->edegrees;
#line 83
        myndegrees = myrinfo->ndegrees;
#line 85
        j = myrinfo->id;
#line 86
        k = 0L;
        {
#line 86
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 86
          if (! (k < myndegrees)) {
#line 86
            goto while_break___2;
          }
#line 87
          to = (myedegrees + k)->pid;
#line 88
          gain = (myedegrees + k)->ed - j;
#line 89
          if (*(pwgts + to) + vwgt <= *(maxwgt + to) + ffactor * gain) {
#line 89
            if (gain >= 0L) {
#line 90
              goto while_break___2;
            }
          }
#line 86
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 92
        if (k == myndegrees) {
#line 93
          goto __Cont;
        }
#line 95
        j = k + 1L;
        {
#line 95
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 95
          if (! (j < myndegrees)) {
#line 95
            goto while_break___3;
          }
#line 96
          to = (myedegrees + j)->pid;
#line 97
          if ((myedegrees + j)->ed > (myedegrees + k)->ed) {
#line 97
            if (*(pwgts + to) + vwgt <= *(maxwgt + to)) {
#line 100
              k = j;
            } else {
#line 97
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 97
          if ((myedegrees + j)->ed == (myedegrees + k)->ed) {
#line 97
            if (*(itpwgts + (myedegrees + k)->pid) * *(pwgts + to) < *(itpwgts + to) * *(pwgts + (myedegrees + k)->pid)) {
#line 100
              k = j;
            }
          }
#line 95
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 103
        to = (myedegrees + k)->pid;
#line 105
        j = 0L;
#line 106
        if ((myedegrees + k)->ed - myrinfo->id > 0L) {
#line 107
          j = 1L;
        } else
#line 108
        if ((myedegrees + k)->ed - myrinfo->id == 0L) {
#line 109
          if ((iii & 7L) == 0L) {
#line 110
            j = 1L;
          } else
#line 109
          if (*(pwgts + from) >= *(maxwgt + from)) {
#line 110
            j = 1L;
          } else
#line 109
          if (*(itpwgts + from) * (*(pwgts + to) + vwgt) < *(itpwgts + to) * *(pwgts + from)) {
#line 110
            j = 1L;
          }
        }
#line 112
        if (j == 0L) {
#line 113
          goto __Cont;
        }
#line 118
        graph->mincut -= (myedegrees + k)->ed - myrinfo->id;
#line 120
        if (ctrl->dbglvl & 32L) {
          {
#line 120
          printf((char const   */* __restrict  */)"\t\tMoving %6ld to %3ld. Gain: %4ld. Cut: %6ld\n",
                 i, to, (myedegrees + k)->ed - myrinfo->id, graph->mincut);
          }
        }
#line 123
        *(where + i) = to;
        {
#line 124
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 124
          *(pwgts + to) += vwgt;
#line 124
          *(pwgts + from) -= vwgt;
#line 124
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 125
        myrinfo->ed += myrinfo->id - (myedegrees + k)->ed;
        {
#line 126
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 126
          j = myrinfo->id;
#line 126
          myrinfo->id = (myedegrees + k)->ed;
#line 126
          (myedegrees + k)->ed = j;
#line 126
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 127
        if ((myedegrees + k)->ed == 0L) {
#line 128
          (myrinfo->ndegrees) --;
#line 128
          *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
        } else {
#line 130
          (myedegrees + k)->pid = from;
        }
#line 132
        if (myrinfo->ed - myrinfo->id < 0L) {
          {
#line 133
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 133
            nbnd --;
#line 133
            *(bndind + *(bndptr + i)) = *(bndind + nbnd);
#line 133
            *(bndptr + *(bndind + nbnd)) = *(bndptr + i);
#line 133
            *(bndptr + i) = (idxtype )-1;
#line 133
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
#line 136
        j = *(xadj + i);
        {
#line 136
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 136
          if (! (j < *(xadj + (i + 1L)))) {
#line 136
            goto while_break___7;
          }
#line 137
          ii = *(adjncy + j);
#line 138
          me = *(where + ii);
#line 140
          myrinfo = graph->rinfo + ii;
#line 141
          if ((unsigned long )myrinfo->edegrees == (unsigned long )((void *)0)) {
#line 142
            myrinfo->edegrees = ctrl->wspace.edegrees + ctrl->wspace.cdegree;
#line 143
            ctrl->wspace.cdegree += *(xadj + (ii + 1L)) - *(xadj + ii);
          }
#line 145
          myedegrees = myrinfo->edegrees;
#line 149
          if (me == from) {
            {
#line 150
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 150
              myrinfo->ed += *(adjwgt + j);
#line 150
              myrinfo->id -= *(adjwgt + j);
#line 150
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 152
            if (myrinfo->ed - myrinfo->id >= 0L) {
#line 152
              if (*(bndptr + ii) == -1L) {
                {
#line 153
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 153
                  *(bndind + nbnd) = ii;
#line 153
                  tmp___2 = nbnd;
#line 153
                  nbnd ++;
#line 153
                  *(bndptr + ii) = tmp___2;
#line 153
                  goto while_break___9;
                }
                while_break___9: /* CIL Label */ ;
                }
              }
            }
          } else
#line 155
          if (me == to) {
            {
#line 156
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 156
              myrinfo->id += *(adjwgt + j);
#line 156
              myrinfo->ed -= *(adjwgt + j);
#line 156
              goto while_break___10;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 158
            if (myrinfo->ed - myrinfo->id < 0L) {
#line 158
              if (*(bndptr + ii) != -1L) {
                {
#line 159
                while (1) {
                  while_continue___11: /* CIL Label */ ;
#line 159
                  nbnd --;
#line 159
                  *(bndind + *(bndptr + ii)) = *(bndind + nbnd);
#line 159
                  *(bndptr + *(bndind + nbnd)) = *(bndptr + ii);
#line 159
                  *(bndptr + ii) = (idxtype )-1;
#line 159
                  goto while_break___11;
                }
                while_break___11: /* CIL Label */ ;
                }
              }
            }
          }
#line 163
          if (me != from) {
#line 164
            k = 0L;
            {
#line 164
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 164
              if (! (k < myrinfo->ndegrees)) {
#line 164
                goto while_break___12;
              }
#line 165
              if ((myedegrees + k)->pid == from) {
#line 166
                if ((myedegrees + k)->ed == *(adjwgt + j)) {
#line 167
                  (myrinfo->ndegrees) --;
#line 167
                  *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
                } else {
#line 169
                  (myedegrees + k)->ed -= *(adjwgt + j);
                }
#line 170
                goto while_break___12;
              }
#line 164
              k ++;
            }
            while_break___12: /* CIL Label */ ;
            }
          }
#line 176
          if (me != to) {
#line 177
            k = 0L;
            {
#line 177
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 177
              if (! (k < myrinfo->ndegrees)) {
#line 177
                goto while_break___13;
              }
#line 178
              if ((myedegrees + k)->pid == to) {
#line 179
                (myedegrees + k)->ed += *(adjwgt + j);
#line 180
                goto while_break___13;
              }
#line 177
              k ++;
            }
            while_break___13: /* CIL Label */ ;
            }
#line 183
            if (k == myrinfo->ndegrees) {
#line 184
              (myedegrees + myrinfo->ndegrees)->pid = to;
#line 185
              tmp___3 = myrinfo->ndegrees;
#line 185
              (myrinfo->ndegrees) ++;
#line 185
              (myedegrees + tmp___3)->ed = *(adjwgt + j);
            }
          }
#line 136
          j ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 193
        nmoves ++;
      }
      __Cont: /* CIL Label */ 
#line 67
      iii ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 197
    graph->nbnd = nbnd;
#line 199
    if (ctrl->dbglvl & 8L) {
      {
#line 199
      tmp___4 = __ComputeVolume(graph, where);
#line 199
      tmp___5 = __idxamax(nparts, pwgts);
#line 199
      tmp___6 = __idxamax(nparts, pwgts);
#line 199
      tmp___7 = __idxamin(nparts, pwgts);
#line 199
      printf((char const   */* __restrict  */)"\t[%6ld %6ld], Balance: %5.3f, Nb: %6ld. Nmoves: %5ld, Cut: %6ld, Vol: %6ld\n",
             *(pwgts + tmp___7), *(pwgts + tmp___6), ((1.0 * (double )nparts) * (double )*(pwgts + tmp___5)) / (double )tvwgt,
             graph->nbnd, nmoves, graph->mincut, tmp___4);
      }
    }
#line 204
    if (graph->mincut == oldcut) {
#line 205
      goto while_break___0;
    }
#line 60
    pass ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 208
  __idxwspacefree(ctrl, nparts);
#line 209
  __idxwspacefree(ctrl, nparts);
#line 210
  __idxwspacefree(ctrl, nparts);
#line 211
  __idxwspacefree(ctrl, nvtxs);
  }
#line 212
  return;
}
}
#line 222 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayfm.c"
void __Greedy_KWayEdgeRefine(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ,
                             float ubfactor , long npasses ) 
{ 
  long i ;
  long ii ;
  long iii ;
  long j ;
  long k ;
  long pass ;
  long nvtxs ;
  long nbnd ;
  long tvwgt ;
  long myndegrees ;
  long oldgain ;
  long gain ;
  long from ;
  long me ;
  long to ;
  long oldcut ;
  long vwgt ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *perm ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *minwgt ;
  idxtype *maxwgt ;
  idxtype *moved ;
  idxtype *itpwgts ;
  EDegreeType *myedegrees ;
  RInfoType *myrinfo ;
  PQueueType queue ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
  {
#line 232
  nvtxs = graph->nvtxs;
#line 233
  xadj = graph->xadj;
#line 234
  adjncy = graph->adjncy;
#line 235
  adjwgt = graph->adjwgt;
#line 237
  bndind = graph->bndind;
#line 238
  bndptr = graph->bndptr;
#line 240
  where = graph->where;
#line 241
  pwgts = graph->pwgts;
#line 244
  minwgt = __idxwspacemalloc(ctrl, nparts);
#line 245
  maxwgt = __idxwspacemalloc(ctrl, nparts);
#line 246
  itpwgts = __idxwspacemalloc(ctrl, nparts);
#line 247
  tvwgt = __idxsum(nparts, pwgts);
#line 250
  i = 0L;
  }
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < nparts)) {
#line 250
      goto while_break;
    }
#line 251
    *(itpwgts + i) = (idxtype )(*(tpwgts + i) * (float )tvwgt);
#line 252
    *(maxwgt + i) = (idxtype )((*(tpwgts + i) * (float )tvwgt) * ubfactor);
#line 253
    *(minwgt + i) = (idxtype )((double )(*(tpwgts + i) * (float )tvwgt) * (1.0 / (double )ubfactor));
#line 250
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 256
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 257
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 259
  tmp = __idxamax(nvtxs, graph->adjwgtsum);
#line 259
  __PQueueInit(ctrl, & queue, nvtxs, *(graph->adjwgtsum + tmp));
  }
#line 261
  if (ctrl->dbglvl & 8L) {
    {
#line 261
    tmp___0 = __idxamax(nparts, pwgts);
#line 261
    tmp___1 = __idxamax(nparts, pwgts);
#line 261
    tmp___2 = __idxamin(nparts, pwgts);
#line 261
    printf((char const   */* __restrict  */)"Partitions: [%6ld %6ld]-[%6ld %6ld], Balance: %5.3f, Nv-Nb[%6ld %6ld]. Cut: %6ld\n",
           *(pwgts + tmp___2), *(pwgts + tmp___1), *(minwgt + 0), *(maxwgt + 0), ((1.0 * (double )nparts) * (double )*(pwgts + tmp___0)) / (double )tvwgt,
           graph->nvtxs, graph->nbnd, graph->mincut);
    }
  }
#line 267
  pass = 0L;
  {
#line 267
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 267
    if (! (pass < npasses)) {
#line 267
      goto while_break___0;
    }
    {
#line 270
    __PQueueReset(& queue);
#line 271
    __idxset(nvtxs, (idxtype )-1, moved);
#line 273
    oldcut = graph->mincut;
#line 274
    nbnd = graph->nbnd;
#line 276
    __RandomPermute(nbnd, perm, 1L);
#line 277
    ii = 0L;
    }
    {
#line 277
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 277
      if (! (ii < nbnd)) {
#line 277
        goto while_break___1;
      }
      {
#line 278
      i = *(bndind + *(perm + ii));
#line 279
      __PQueueInsert(& queue, i, (graph->rinfo + i)->ed - (graph->rinfo + i)->id);
#line 280
      *(moved + i) = (idxtype )2;
#line 277
      ii ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 283
    iii = 0L;
    {
#line 283
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 284
      i = __PQueueGetMax(& queue);
      }
#line 284
      if (i == -1L) {
#line 285
        goto while_break___2;
      }
#line 286
      *(moved + i) = (idxtype )1;
#line 288
      myrinfo = graph->rinfo + i;
#line 289
      from = *(where + i);
#line 290
      vwgt = *(graph->vwgt + i);
#line 292
      if (*(pwgts + from) - vwgt < *(minwgt + from)) {
#line 293
        goto __Cont;
      }
#line 295
      myedegrees = myrinfo->edegrees;
#line 296
      myndegrees = myrinfo->ndegrees;
#line 298
      j = myrinfo->id;
#line 299
      k = 0L;
      {
#line 299
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 299
        if (! (k < myndegrees)) {
#line 299
          goto while_break___3;
        }
#line 300
        to = (myedegrees + k)->pid;
#line 301
        gain = (myedegrees + k)->ed - j;
#line 302
        if (*(pwgts + to) + vwgt <= *(maxwgt + to) + gain) {
#line 302
          if (gain >= 0L) {
#line 303
            goto while_break___3;
          }
        }
#line 299
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 305
      if (k == myndegrees) {
#line 306
        goto __Cont;
      }
#line 308
      j = k + 1L;
      {
#line 308
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 308
        if (! (j < myndegrees)) {
#line 308
          goto while_break___4;
        }
#line 309
        to = (myedegrees + j)->pid;
#line 310
        if ((myedegrees + j)->ed > (myedegrees + k)->ed) {
#line 310
          if (*(pwgts + to) + vwgt <= *(maxwgt + to)) {
#line 313
            k = j;
          } else {
#line 310
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 310
        if ((myedegrees + j)->ed == (myedegrees + k)->ed) {
#line 310
          if (*(itpwgts + (myedegrees + k)->pid) * *(pwgts + to) < *(itpwgts + to) * *(pwgts + (myedegrees + k)->pid)) {
#line 313
            k = j;
          }
        }
#line 308
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 316
      to = (myedegrees + k)->pid;
#line 318
      j = 0L;
#line 319
      if ((myedegrees + k)->ed - myrinfo->id > 0L) {
#line 320
        j = 1L;
      } else
#line 321
      if ((myedegrees + k)->ed - myrinfo->id == 0L) {
#line 322
        if ((iii & 7L) == 0L) {
#line 323
          j = 1L;
        } else
#line 322
        if (*(pwgts + from) >= *(maxwgt + from)) {
#line 323
          j = 1L;
        } else
#line 322
        if (*(itpwgts + from) * (*(pwgts + to) + vwgt) < *(itpwgts + to) * *(pwgts + from)) {
#line 323
          j = 1L;
        }
      }
#line 325
      if (j == 0L) {
#line 326
        goto __Cont;
      }
#line 331
      graph->mincut -= (myedegrees + k)->ed - myrinfo->id;
#line 333
      if (ctrl->dbglvl & 32L) {
        {
#line 333
        printf((char const   */* __restrict  */)"\t\tMoving %6ld to %3ld. Gain: %4ld. Cut: %6ld\n",
               i, to, (myedegrees + k)->ed - myrinfo->id, graph->mincut);
        }
      }
#line 336
      *(where + i) = to;
      {
#line 337
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 337
        *(pwgts + to) += vwgt;
#line 337
        *(pwgts + from) -= vwgt;
#line 337
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 338
      myrinfo->ed += myrinfo->id - (myedegrees + k)->ed;
      {
#line 339
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 339
        j = myrinfo->id;
#line 339
        myrinfo->id = (myedegrees + k)->ed;
#line 339
        (myedegrees + k)->ed = j;
#line 339
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 340
      if ((myedegrees + k)->ed == 0L) {
#line 341
        (myrinfo->ndegrees) --;
#line 341
        *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
      } else {
#line 343
        (myedegrees + k)->pid = from;
      }
#line 345
      if (myrinfo->ed < myrinfo->id) {
        {
#line 346
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 346
          nbnd --;
#line 346
          *(bndind + *(bndptr + i)) = *(bndind + nbnd);
#line 346
          *(bndptr + *(bndind + nbnd)) = *(bndptr + i);
#line 346
          *(bndptr + i) = (idxtype )-1;
#line 346
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 349
      j = *(xadj + i);
      {
#line 349
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 349
        if (! (j < *(xadj + (i + 1L)))) {
#line 349
          goto while_break___8;
        }
#line 350
        ii = *(adjncy + j);
#line 351
        me = *(where + ii);
#line 353
        myrinfo = graph->rinfo + ii;
#line 354
        if ((unsigned long )myrinfo->edegrees == (unsigned long )((void *)0)) {
#line 355
          myrinfo->edegrees = ctrl->wspace.edegrees + ctrl->wspace.cdegree;
#line 356
          ctrl->wspace.cdegree += *(xadj + (ii + 1L)) - *(xadj + ii);
        }
#line 358
        myedegrees = myrinfo->edegrees;
#line 362
        oldgain = myrinfo->ed - myrinfo->id;
#line 364
        if (me == from) {
          {
#line 365
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 365
            myrinfo->ed += *(adjwgt + j);
#line 365
            myrinfo->id -= *(adjwgt + j);
#line 365
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 367
          if (myrinfo->ed - myrinfo->id >= 0L) {
#line 367
            if (*(bndptr + ii) == -1L) {
              {
#line 368
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 368
                *(bndind + nbnd) = ii;
#line 368
                tmp___3 = nbnd;
#line 368
                nbnd ++;
#line 368
                *(bndptr + ii) = tmp___3;
#line 368
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
          }
        } else
#line 370
        if (me == to) {
          {
#line 371
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 371
            myrinfo->id += *(adjwgt + j);
#line 371
            myrinfo->ed -= *(adjwgt + j);
#line 371
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 373
          if (myrinfo->ed - myrinfo->id < 0L) {
#line 373
            if (*(bndptr + ii) != -1L) {
              {
#line 374
              while (1) {
                while_continue___12: /* CIL Label */ ;
#line 374
                nbnd --;
#line 374
                *(bndind + *(bndptr + ii)) = *(bndind + nbnd);
#line 374
                *(bndptr + *(bndind + nbnd)) = *(bndptr + ii);
#line 374
                *(bndptr + ii) = (idxtype )-1;
#line 374
                goto while_break___12;
              }
              while_break___12: /* CIL Label */ ;
              }
            }
          }
        }
#line 378
        if (me != from) {
#line 379
          k = 0L;
          {
#line 379
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 379
            if (! (k < myrinfo->ndegrees)) {
#line 379
              goto while_break___13;
            }
#line 380
            if ((myedegrees + k)->pid == from) {
#line 381
              if ((myedegrees + k)->ed == *(adjwgt + j)) {
#line 382
                (myrinfo->ndegrees) --;
#line 382
                *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
              } else {
#line 384
                (myedegrees + k)->ed -= *(adjwgt + j);
              }
#line 385
              goto while_break___13;
            }
#line 379
            k ++;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
#line 391
        if (me != to) {
#line 392
          k = 0L;
          {
#line 392
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 392
            if (! (k < myrinfo->ndegrees)) {
#line 392
              goto while_break___14;
            }
#line 393
            if ((myedegrees + k)->pid == to) {
#line 394
              (myedegrees + k)->ed += *(adjwgt + j);
#line 395
              goto while_break___14;
            }
#line 392
            k ++;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 398
          if (k == myrinfo->ndegrees) {
#line 399
            (myedegrees + myrinfo->ndegrees)->pid = to;
#line 400
            tmp___4 = myrinfo->ndegrees;
#line 400
            (myrinfo->ndegrees) ++;
#line 400
            (myedegrees + tmp___4)->ed = *(adjwgt + j);
          }
        }
#line 405
        if (me == to) {
#line 405
          goto _L___0;
        } else
#line 405
        if (me == from) {
          _L___0: /* CIL Label */ 
#line 406
          gain = myrinfo->ed - myrinfo->id;
#line 407
          if (*(moved + ii) == 2L) {
#line 408
            if (gain >= 0L) {
              {
#line 409
              __PQueueUpdate(& queue, ii, oldgain, gain);
              }
            } else {
              {
#line 411
              __PQueueDelete(& queue, ii, oldgain);
#line 412
              *(moved + ii) = (idxtype )-1;
              }
            }
          } else
#line 415
          if (*(moved + ii) == -1L) {
#line 415
            if (gain >= 0L) {
              {
#line 416
              __PQueueInsert(& queue, ii, gain);
#line 417
              *(moved + ii) = (idxtype )2;
              }
            }
          }
        }
#line 349
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 283
      iii ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 427
    graph->nbnd = nbnd;
#line 429
    if (ctrl->dbglvl & 8L) {
      {
#line 429
      tmp___5 = __idxamax(nparts, pwgts);
#line 429
      tmp___6 = __idxamax(nparts, pwgts);
#line 429
      tmp___7 = __idxamin(nparts, pwgts);
#line 429
      printf((char const   */* __restrict  */)"\t[%6ld %6ld], Balance: %5.3f, Nb: %6ld. Cut: %6ld\n",
             *(pwgts + tmp___7), *(pwgts + tmp___6), ((1.0 * (double )nparts) * (double )*(pwgts + tmp___5)) / (double )tvwgt,
             graph->nbnd, graph->mincut);
      }
    }
#line 434
    if (graph->mincut == oldcut) {
#line 435
      goto while_break___0;
    }
#line 267
    pass ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 438
  __PQueueFree(ctrl, & queue);
#line 440
  __idxwspacefree(ctrl, nparts);
#line 441
  __idxwspacefree(ctrl, nparts);
#line 442
  __idxwspacefree(ctrl, nparts);
#line 443
  __idxwspacefree(ctrl, nvtxs);
#line 444
  __idxwspacefree(ctrl, nvtxs);
  }
#line 446
  return;
}
}
#line 452 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayfm.c"
void __Greedy_KWayEdgeBalance(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ,
                              float ubfactor , long npasses ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long pass ;
  long nvtxs ;
  long nbnd ;
  long tvwgt ;
  long myndegrees ;
  long oldgain ;
  long gain ;
  long nmoves ;
  long from ;
  long me ;
  long to ;
  long oldcut ;
  long vwgt ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *perm ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *minwgt ;
  idxtype *maxwgt ;
  idxtype *moved ;
  idxtype *itpwgts ;
  EDegreeType *myedegrees ;
  RInfoType *myrinfo ;
  PQueueType queue ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
  {
#line 462
  nvtxs = graph->nvtxs;
#line 463
  xadj = graph->xadj;
#line 464
  adjncy = graph->adjncy;
#line 465
  adjwgt = graph->adjwgt;
#line 467
  bndind = graph->bndind;
#line 468
  bndptr = graph->bndptr;
#line 470
  where = graph->where;
#line 471
  pwgts = graph->pwgts;
#line 474
  minwgt = __idxwspacemalloc(ctrl, nparts);
#line 475
  maxwgt = __idxwspacemalloc(ctrl, nparts);
#line 476
  itpwgts = __idxwspacemalloc(ctrl, nparts);
#line 477
  tvwgt = __idxsum(nparts, pwgts);
#line 480
  i = 0L;
  }
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! (i < nparts)) {
#line 480
      goto while_break;
    }
#line 481
    *(itpwgts + i) = (idxtype )(*(tpwgts + i) * (float )tvwgt);
#line 482
    *(maxwgt + i) = (idxtype )((*(tpwgts + i) * (float )tvwgt) * ubfactor);
#line 483
    *(minwgt + i) = (idxtype )((double )(*(tpwgts + i) * (float )tvwgt) * (1.0 / (double )ubfactor));
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 486
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 487
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 489
  tmp = __idxamax(nvtxs, graph->adjwgtsum);
#line 489
  __PQueueInit(ctrl, & queue, nvtxs, *(graph->adjwgtsum + tmp));
  }
#line 491
  if (ctrl->dbglvl & 8L) {
    {
#line 491
    tmp___0 = __idxamax(nparts, pwgts);
#line 491
    tmp___1 = __idxamax(nparts, pwgts);
#line 491
    tmp___2 = __idxamin(nparts, pwgts);
#line 491
    printf((char const   */* __restrict  */)"Partitions: [%6ld %6ld]-[%6ld %6ld], Balance: %5.3f, Nv-Nb[%6ld %6ld]. Cut: %6ld [B]\n",
           *(pwgts + tmp___2), *(pwgts + tmp___1), *(minwgt + 0), *(maxwgt + 0), ((1.0 * (double )nparts) * (double )*(pwgts + tmp___0)) / (double )tvwgt,
           graph->nvtxs, graph->nbnd, graph->mincut);
    }
  }
#line 497
  pass = 0L;
  {
#line 497
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 497
    if (! (pass < npasses)) {
#line 497
      goto while_break___0;
    }
#line 501
    i = 0L;
    {
#line 501
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 501
      if (! (i < nparts)) {
#line 501
        goto while_break___1;
      }
#line 502
      if (*(pwgts + i) > *(maxwgt + i)) {
#line 503
        goto while_break___1;
      }
#line 501
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 505
    if (i == nparts) {
#line 506
      goto while_break___0;
    }
    {
#line 508
    __PQueueReset(& queue);
#line 509
    __idxset(nvtxs, (idxtype )-1, moved);
#line 511
    oldcut = graph->mincut;
#line 512
    nbnd = graph->nbnd;
#line 514
    __RandomPermute(nbnd, perm, 1L);
#line 515
    ii = 0L;
    }
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      if (! (ii < nbnd)) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      i = *(bndind + *(perm + ii));
#line 517
      __PQueueInsert(& queue, i, (graph->rinfo + i)->ed - (graph->rinfo + i)->id);
#line 518
      *(moved + i) = (idxtype )2;
#line 515
      ii ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 521
    nmoves = 0L;
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 523
      i = __PQueueGetMax(& queue);
      }
#line 523
      if (i == -1L) {
#line 524
        goto while_break___3;
      }
#line 525
      *(moved + i) = (idxtype )1;
#line 527
      myrinfo = graph->rinfo + i;
#line 528
      from = *(where + i);
#line 529
      vwgt = *(graph->vwgt + i);
#line 531
      if (*(pwgts + from) - vwgt < *(minwgt + from)) {
#line 532
        goto __Cont;
      }
#line 534
      myedegrees = myrinfo->edegrees;
#line 535
      myndegrees = myrinfo->ndegrees;
#line 537
      k = 0L;
      {
#line 537
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 537
        if (! (k < myndegrees)) {
#line 537
          goto while_break___4;
        }
#line 538
        to = (myedegrees + k)->pid;
#line 539
        if (*(pwgts + to) + vwgt <= *(maxwgt + to)) {
#line 540
          goto while_break___4;
        } else
#line 539
        if (*(itpwgts + from) * (*(pwgts + to) + vwgt) <= *(itpwgts + to) * *(pwgts + from)) {
#line 540
          goto while_break___4;
        }
#line 537
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 542
      if (k == myndegrees) {
#line 543
        goto __Cont;
      }
#line 545
      j = k + 1L;
      {
#line 545
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 545
        if (! (j < myndegrees)) {
#line 545
          goto while_break___5;
        }
#line 546
        to = (myedegrees + j)->pid;
#line 547
        if (*(itpwgts + (myedegrees + k)->pid) * *(pwgts + to) < *(itpwgts + to) * *(pwgts + (myedegrees + k)->pid)) {
#line 548
          k = j;
        }
#line 545
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 551
      to = (myedegrees + k)->pid;
#line 553
      if (*(pwgts + from) < *(maxwgt + from)) {
#line 553
        if (*(pwgts + to) > *(minwgt + to)) {
#line 553
          if ((myedegrees + k)->ed - myrinfo->id < 0L) {
#line 554
            goto __Cont;
          }
        }
      }
#line 559
      graph->mincut -= (myedegrees + k)->ed - myrinfo->id;
#line 561
      if (ctrl->dbglvl & 32L) {
        {
#line 561
        printf((char const   */* __restrict  */)"\t\tMoving %6ld to %3ld. Gain: %4ld. Cut: %6ld\n",
               i, to, (myedegrees + k)->ed - myrinfo->id, graph->mincut);
        }
      }
#line 564
      *(where + i) = to;
      {
#line 565
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 565
        *(pwgts + to) += vwgt;
#line 565
        *(pwgts + from) -= vwgt;
#line 565
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 566
      myrinfo->ed += myrinfo->id - (myedegrees + k)->ed;
      {
#line 567
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 567
        j = myrinfo->id;
#line 567
        myrinfo->id = (myedegrees + k)->ed;
#line 567
        (myedegrees + k)->ed = j;
#line 567
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 568
      if ((myedegrees + k)->ed == 0L) {
#line 569
        (myrinfo->ndegrees) --;
#line 569
        *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
      } else {
#line 571
        (myedegrees + k)->pid = from;
      }
#line 573
      if (myrinfo->ed == 0L) {
        {
#line 574
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 574
          nbnd --;
#line 574
          *(bndind + *(bndptr + i)) = *(bndind + nbnd);
#line 574
          *(bndptr + *(bndind + nbnd)) = *(bndptr + i);
#line 574
          *(bndptr + i) = (idxtype )-1;
#line 574
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 577
      j = *(xadj + i);
      {
#line 577
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 577
        if (! (j < *(xadj + (i + 1L)))) {
#line 577
          goto while_break___9;
        }
#line 578
        ii = *(adjncy + j);
#line 579
        me = *(where + ii);
#line 581
        myrinfo = graph->rinfo + ii;
#line 582
        if ((unsigned long )myrinfo->edegrees == (unsigned long )((void *)0)) {
#line 583
          myrinfo->edegrees = ctrl->wspace.edegrees + ctrl->wspace.cdegree;
#line 584
          ctrl->wspace.cdegree += *(xadj + (ii + 1L)) - *(xadj + ii);
        }
#line 586
        myedegrees = myrinfo->edegrees;
#line 590
        oldgain = myrinfo->ed - myrinfo->id;
#line 592
        if (me == from) {
          {
#line 593
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 593
            myrinfo->ed += *(adjwgt + j);
#line 593
            myrinfo->id -= *(adjwgt + j);
#line 593
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 595
          if (myrinfo->ed > 0L) {
#line 595
            if (*(bndptr + ii) == -1L) {
              {
#line 596
              while (1) {
                while_continue___11: /* CIL Label */ ;
#line 596
                *(bndind + nbnd) = ii;
#line 596
                tmp___3 = nbnd;
#line 596
                nbnd ++;
#line 596
                *(bndptr + ii) = tmp___3;
#line 596
                goto while_break___11;
              }
              while_break___11: /* CIL Label */ ;
              }
            }
          }
        } else
#line 598
        if (me == to) {
          {
#line 599
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 599
            myrinfo->id += *(adjwgt + j);
#line 599
            myrinfo->ed -= *(adjwgt + j);
#line 599
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 601
          if (myrinfo->ed == 0L) {
#line 601
            if (*(bndptr + ii) != -1L) {
              {
#line 602
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 602
                nbnd --;
#line 602
                *(bndind + *(bndptr + ii)) = *(bndind + nbnd);
#line 602
                *(bndptr + *(bndind + nbnd)) = *(bndptr + ii);
#line 602
                *(bndptr + ii) = (idxtype )-1;
#line 602
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
            }
          }
        }
#line 606
        if (me != from) {
#line 607
          k = 0L;
          {
#line 607
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 607
            if (! (k < myrinfo->ndegrees)) {
#line 607
              goto while_break___14;
            }
#line 608
            if ((myedegrees + k)->pid == from) {
#line 609
              if ((myedegrees + k)->ed == *(adjwgt + j)) {
#line 610
                (myrinfo->ndegrees) --;
#line 610
                *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
              } else {
#line 612
                (myedegrees + k)->ed -= *(adjwgt + j);
              }
#line 613
              goto while_break___14;
            }
#line 607
            k ++;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
#line 619
        if (me != to) {
#line 620
          k = 0L;
          {
#line 620
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 620
            if (! (k < myrinfo->ndegrees)) {
#line 620
              goto while_break___15;
            }
#line 621
            if ((myedegrees + k)->pid == to) {
#line 622
              (myedegrees + k)->ed += *(adjwgt + j);
#line 623
              goto while_break___15;
            }
#line 620
            k ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 626
          if (k == myrinfo->ndegrees) {
#line 627
            (myedegrees + myrinfo->ndegrees)->pid = to;
#line 628
            tmp___4 = myrinfo->ndegrees;
#line 628
            (myrinfo->ndegrees) ++;
#line 628
            (myedegrees + tmp___4)->ed = *(adjwgt + j);
          }
        }
#line 633
        if (me == to) {
#line 633
          goto _L;
        } else
#line 633
        if (me == from) {
          _L: /* CIL Label */ 
#line 634
          gain = myrinfo->ed - myrinfo->id;
#line 635
          if (*(moved + ii) == 2L) {
#line 636
            if (myrinfo->ed > 0L) {
              {
#line 637
              __PQueueUpdate(& queue, ii, oldgain, gain);
              }
            } else {
              {
#line 639
              __PQueueDelete(& queue, ii, oldgain);
#line 640
              *(moved + ii) = (idxtype )-1;
              }
            }
          } else
#line 643
          if (*(moved + ii) == -1L) {
#line 643
            if (myrinfo->ed > 0L) {
              {
#line 644
              __PQueueInsert(& queue, ii, gain);
#line 645
              *(moved + ii) = (idxtype )2;
              }
            }
          }
        }
#line 577
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 652
      nmoves ++;
      __Cont: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 655
    graph->nbnd = nbnd;
#line 657
    if (ctrl->dbglvl & 8L) {
      {
#line 657
      tmp___5 = __idxamax(nparts, pwgts);
#line 657
      tmp___6 = __idxamax(nparts, pwgts);
#line 657
      tmp___7 = __idxamin(nparts, pwgts);
#line 657
      printf((char const   */* __restrict  */)"\t[%6ld %6ld], Balance: %5.3f, Nb: %6ld. Nmoves: %5ld, Cut: %6ld\n",
             *(pwgts + tmp___7), *(pwgts + tmp___6), ((1.0 * (double )nparts) * (double )*(pwgts + tmp___5)) / (double )tvwgt,
             graph->nbnd, nmoves, graph->mincut);
      }
    }
#line 497
    pass ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 663
  __PQueueFree(ctrl, & queue);
#line 665
  __idxwspacefree(ctrl, nparts);
#line 666
  __idxwspacefree(ctrl, nparts);
#line 667
  __idxwspacefree(ctrl, nparts);
#line 668
  __idxwspacefree(ctrl, nvtxs);
#line 669
  __idxwspacefree(ctrl, nvtxs);
  }
#line 671
  return;
}
}
#line 16 "./proto.h"
void __Balance2Way(CtrlType *ctrl , GraphType *graph , long *tpwgts , float ubfactor ) ;
#line 52
void __FM_2WayEdgeRefine(CtrlType *ctrl , GraphType *graph , long *tpwgts , long npasses ) ;
#line 142
void __InitSeparator(CtrlType *ctrl , GraphType *graph , float ubfactor ) ;
#line 143
void __GrowBisection(CtrlType *ctrl , GraphType *graph , long *tpwgts , float ubfactor ) ;
#line 144
void __GrowBisectionNode(CtrlType *ctrl , GraphType *graph , float ubfactor ) ;
#line 145
void __RandomBisection(CtrlType *ctrl , GraphType *graph , long *tpwgts , float ubfactor ) ;
#line 382
void __Allocate2WayPartitionMemory(CtrlType *ctrl , GraphType *graph ) ;
#line 383
void __Compute2WayPartitionParams(CtrlType *ctrl , GraphType *graph ) ;
#line 21 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/initpart.c"
void __Init2WayPartition(CtrlType *ctrl , GraphType *graph , long *tpwgts , float ubfactor ) 
{ 
  long dbglvl ;
  double tmp ;
  double tmp___0 ;

  {
#line 25
  dbglvl = ctrl->dbglvl;
#line 26
  if (ctrl->dbglvl & 8L) {
#line 26
    ctrl->dbglvl -= 8L;
  }
#line 27
  if (ctrl->dbglvl & 32L) {
#line 27
    ctrl->dbglvl -= 32L;
  }
#line 29
  if (ctrl->dbglvl & 1L) {
    {
#line 29
    tmp = __seconds();
#line 29
    ctrl->InitPartTmr -= tmp;
    }
  }
  {
#line 32
  if (ctrl->IType == 1L) {
#line 32
    goto case_1;
  }
#line 35
  if (ctrl->IType == 3L) {
#line 35
    goto case_3;
  }
#line 38
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 33
  __GrowBisection(ctrl, graph, tpwgts, ubfactor);
  }
#line 34
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 36
  __RandomBisection(ctrl, graph, tpwgts, ubfactor);
  }
#line 37
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 39
  __errexit((char *)"Unknown initial partition type: %ld\n", ctrl->IType);
  }
  switch_break: /* CIL Label */ ;
  }
#line 42
  if (ctrl->dbglvl & 16L) {
    {
#line 42
    printf((char const   */* __restrict  */)"Initial Cut: %ld\n", graph->mincut);
    }
  }
#line 43
  if (ctrl->dbglvl & 1L) {
    {
#line 43
    tmp___0 = __seconds();
#line 43
    ctrl->InitPartTmr += tmp___0;
    }
  }
#line 44
  ctrl->dbglvl = dbglvl;
#line 50
  return;
}
}
#line 55 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/initpart.c"
void __InitSeparator(CtrlType *ctrl , GraphType *graph , float ubfactor ) 
{ 
  long dbglvl ;
  double tmp ;
  double tmp___0 ;

  {
#line 59
  dbglvl = ctrl->dbglvl;
#line 60
  if (ctrl->dbglvl & 8L) {
#line 60
    ctrl->dbglvl -= 8L;
  }
#line 61
  if (ctrl->dbglvl & 32L) {
#line 61
    ctrl->dbglvl -= 32L;
  }
#line 63
  if (ctrl->dbglvl & 1L) {
    {
#line 63
    tmp = __seconds();
#line 63
    ctrl->InitPartTmr -= tmp;
    }
  }
  {
#line 65
  __GrowBisectionNode(ctrl, graph, ubfactor);
#line 66
  __Compute2WayNodePartitionParams(ctrl, graph);
  }
#line 68
  if (ctrl->dbglvl & 16L) {
    {
#line 68
    printf((char const   */* __restrict  */)"Initial Sep: %ld\n", graph->mincut);
    }
  }
#line 69
  if (ctrl->dbglvl & 1L) {
    {
#line 69
    tmp___0 = __seconds();
#line 69
    ctrl->InitPartTmr += tmp___0;
    }
  }
#line 71
  ctrl->dbglvl = dbglvl;
#line 73
  return;
}
}
#line 82 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/initpart.c"
void __GrowBisection(CtrlType *ctrl , GraphType *graph , long *tpwgts , float ubfactor ) 
{ 
  long i ;
  long j ;
  long k ;
  long nvtxs ;
  long drain ;
  long nleft ;
  long first ;
  long last ;
  long pwgts[2] ;
  long minpwgt[2] ;
  long maxpwgt[2] ;
  long bestcut ;
  long nbfs ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *queue ;
  idxtype *touched ;
  idxtype *bestwhere ;
  long tmp ;
  double tmp___0 ;
  double tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  double tmp___4 ;

  {
  {
#line 89
  nvtxs = graph->nvtxs;
#line 90
  xadj = graph->xadj;
#line 91
  vwgt = graph->vwgt;
#line 92
  adjncy = graph->adjncy;
#line 93
  adjwgt = graph->adjwgt;
#line 95
  __Allocate2WayPartitionMemory(ctrl, graph);
#line 96
  where = graph->where;
#line 98
  bestwhere = __idxmalloc(nvtxs, (char *)"BisectGraph: bestwhere");
#line 99
  queue = __idxmalloc(nvtxs, (char *)"BisectGraph: queue");
#line 100
  touched = __idxmalloc(nvtxs, (char *)"BisectGraph: touched");
#line 104
  maxpwgt[0] = (long )(ubfactor * (float )*(tpwgts + 0));
#line 105
  maxpwgt[1] = (long )(ubfactor * (float )*(tpwgts + 1));
#line 106
  minpwgt[0] = (long )((1.0 / (double )ubfactor) * (double )*(tpwgts + 0));
#line 107
  minpwgt[1] = (long )((1.0 / (double )ubfactor) * (double )*(tpwgts + 1));
  }
#line 109
  if (nvtxs <= ctrl->CoarsenTo) {
#line 109
    nbfs = 3L;
  } else {
#line 109
    nbfs = 8L;
  }
  {
#line 110
  tmp = __idxsum(nvtxs, graph->adjwgtsum);
#line 110
  bestcut = tmp + 1L;
  }
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (nbfs > 0L)) {
#line 111
      goto while_break;
    }
    {
#line 112
    __idxset(nvtxs, (idxtype )0, touched);
#line 114
    pwgts[1] = *(tpwgts + 0) + *(tpwgts + 1);
#line 115
    pwgts[0] = 0L;
#line 117
    __idxset(nvtxs, (idxtype )1, where);
#line 119
    tmp___0 = drand48();
#line 119
    *(queue + 0) = (long )(tmp___0 * (double )nvtxs);
#line 120
    *(touched + *(queue + 0)) = (idxtype )1;
#line 121
    first = 0L;
#line 121
    last = 1L;
#line 122
    nleft = nvtxs - 1L;
#line 123
    drain = 0L;
    }
    {
#line 126
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 127
      if (first == last) {
#line 128
        if (nleft == 0L) {
#line 129
          goto while_break___0;
        } else
#line 128
        if (drain) {
#line 129
          goto while_break___0;
        }
        {
#line 131
        tmp___1 = drand48();
#line 131
        k = (long )(tmp___1 * (double )nleft);
#line 132
        i = 0L;
        }
        {
#line 132
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 132
          if (! (i < nvtxs)) {
#line 132
            goto while_break___1;
          }
#line 133
          if (*(touched + i) == 0L) {
#line 134
            if (k == 0L) {
#line 135
              goto while_break___1;
            } else {
#line 137
              k --;
            }
          }
#line 132
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 141
        *(queue + 0) = i;
#line 142
        *(touched + i) = (idxtype )1;
#line 143
        first = 0L;
#line 143
        last = 1L;
#line 144
        nleft --;
      }
#line 147
      tmp___2 = first;
#line 147
      first ++;
#line 147
      i = *(queue + tmp___2);
#line 148
      if (pwgts[0] > 0L) {
#line 148
        if (pwgts[1] - *(vwgt + i) < minpwgt[1]) {
#line 149
          drain = 1L;
#line 150
          goto __Cont;
        }
      }
#line 153
      *(where + i) = (idxtype )0;
      {
#line 154
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 154
        pwgts[0] += *(vwgt + i);
#line 154
        pwgts[1] -= *(vwgt + i);
#line 154
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 155
      if (pwgts[1] <= maxpwgt[1]) {
#line 156
        goto while_break___0;
      }
#line 158
      drain = 0L;
#line 159
      j = *(xadj + i);
      {
#line 159
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 159
        if (! (j < *(xadj + (i + 1L)))) {
#line 159
          goto while_break___3;
        }
#line 160
        k = *(adjncy + j);
#line 161
        if (*(touched + k) == 0L) {
#line 162
          tmp___3 = last;
#line 162
          last ++;
#line 162
          *(queue + tmp___3) = k;
#line 163
          *(touched + k) = (idxtype )1;
#line 164
          nleft --;
        }
#line 159
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 170
    if (pwgts[1] == 0L) {
      {
#line 171
      tmp___4 = drand48();
#line 171
      i = (long )(tmp___4 * (double )nvtxs);
#line 172
      *(where + i) = (idxtype )1;
      }
      {
#line 173
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 173
        pwgts[1] += *(vwgt + i);
#line 173
        pwgts[0] -= *(vwgt + i);
#line 173
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 179
    __Compute2WayPartitionParams(ctrl, graph);
#line 182
    __Balance2Way(ctrl, graph, tpwgts, ubfactor);
#line 185
    __FM_2WayEdgeRefine(ctrl, graph, tpwgts, 4L);
    }
#line 188
    if (bestcut > graph->mincut) {
      {
#line 189
      bestcut = graph->mincut;
#line 190
      memcpy((void */* __restrict  */)((void *)bestwhere), (void const   */* __restrict  */)((void *)where),
             sizeof(idxtype ) * (unsigned long )nvtxs);
      }
#line 191
      if (bestcut == 0L) {
#line 192
        goto while_break;
      }
    }
#line 111
    nbfs --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  graph->mincut = bestcut;
#line 197
  memcpy((void */* __restrict  */)((void *)where), (void const   */* __restrict  */)((void *)bestwhere),
         sizeof(idxtype ) * (unsigned long )nvtxs);
#line 199
  __GKfree(& bestwhere, & queue, & touched, (void **)0);
  }
#line 200
  return;
}
}
#line 210 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/initpart.c"
void __GrowBisectionNode(CtrlType *ctrl , GraphType *graph , float ubfactor ) 
{ 
  long i ;
  long j ;
  long k ;
  long nvtxs ;
  long drain ;
  long nleft ;
  long first ;
  long last ;
  long pwgts[2] ;
  long tpwgts[2] ;
  long minpwgt[2] ;
  long maxpwgt[2] ;
  long bestcut ;
  long nbfs ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *bndind ;
  idxtype *queue ;
  idxtype *touched ;
  idxtype *bestwhere ;
  double tmp ;
  double tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 216
  nvtxs = graph->nvtxs;
#line 217
  xadj = graph->xadj;
#line 218
  vwgt = graph->vwgt;
#line 219
  adjncy = graph->adjncy;
#line 220
  adjwgt = graph->adjwgt;
#line 222
  bestwhere = __idxmalloc(nvtxs, (char *)"BisectGraph: bestwhere");
#line 223
  queue = __idxmalloc(nvtxs, (char *)"BisectGraph: queue");
#line 224
  touched = __idxmalloc(nvtxs, (char *)"BisectGraph: touched");
#line 226
  tpwgts[0] = __idxsum(nvtxs, vwgt);
#line 227
  tpwgts[1] = tpwgts[0] / 2L;
#line 228
  tpwgts[0] -= tpwgts[1];
#line 230
  maxpwgt[0] = (long )(ubfactor * (float )tpwgts[0]);
#line 231
  maxpwgt[1] = (long )(ubfactor * (float )tpwgts[1]);
#line 232
  minpwgt[0] = (long )((1.0 / (double )ubfactor) * (double )tpwgts[0]);
#line 233
  minpwgt[1] = (long )((1.0 / (double )ubfactor) * (double )tpwgts[1]);
#line 236
  graph->rdata = __idxmalloc(5L * nvtxs + 3L, (char *)"GrowBisectionNode: graph->rdata");
#line 237
  graph->pwgts = graph->rdata;
#line 238
  graph->where = graph->rdata + 3;
#line 239
  graph->bndptr = (graph->rdata + nvtxs) + 3;
#line 240
  graph->bndind = (graph->rdata + 2L * nvtxs) + 3;
#line 241
  graph->nrinfo = (NRInfoType *)((graph->rdata + 3L * nvtxs) + 3);
#line 242
  graph->id = (graph->rdata + 3L * nvtxs) + 3;
#line 243
  graph->ed = (graph->rdata + 4L * nvtxs) + 3;
#line 245
  where = graph->where;
#line 246
  bndind = graph->bndind;
  }
#line 248
  if (nvtxs <= ctrl->CoarsenTo) {
#line 248
    nbfs = 3L;
  } else {
#line 248
    nbfs = 8L;
  }
#line 249
  bestcut = tpwgts[0] + tpwgts[1];
#line 250
  nbfs ++;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (nbfs > 0L)) {
#line 250
      goto while_break;
    }
    {
#line 251
    __idxset(nvtxs, (idxtype )0, touched);
#line 253
    pwgts[1] = tpwgts[0] + tpwgts[1];
#line 254
    pwgts[0] = 0L;
#line 256
    __idxset(nvtxs, (idxtype )1, where);
#line 258
    tmp = drand48();
#line 258
    *(queue + 0) = (long )(tmp * (double )nvtxs);
#line 259
    *(touched + *(queue + 0)) = (idxtype )1;
#line 260
    first = 0L;
#line 260
    last = 1L;
#line 261
    nleft = nvtxs - 1L;
#line 262
    drain = 0L;
    }
#line 265
    if (nbfs >= 1L) {
      {
#line 266
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 267
        if (first == last) {
#line 268
          if (nleft == 0L) {
#line 269
            goto while_break___0;
          } else
#line 268
          if (drain) {
#line 269
            goto while_break___0;
          }
          {
#line 271
          tmp___0 = drand48();
#line 271
          k = (long )(tmp___0 * (double )nleft);
#line 272
          i = 0L;
          }
          {
#line 272
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 272
            if (! (i < nvtxs)) {
#line 272
              goto while_break___1;
            }
#line 273
            if (*(touched + i) == 0L) {
#line 274
              if (k == 0L) {
#line 275
                goto while_break___1;
              } else {
#line 277
                k --;
              }
            }
#line 272
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 281
          *(queue + 0) = i;
#line 282
          *(touched + i) = (idxtype )1;
#line 283
          first = 0L;
#line 283
          last = 1L;
#line 284
          nleft --;
        }
#line 287
        tmp___1 = first;
#line 287
        first ++;
#line 287
        i = *(queue + tmp___1);
#line 288
        if (pwgts[1] - *(vwgt + i) < minpwgt[1]) {
#line 289
          drain = 1L;
#line 290
          goto __Cont;
        }
#line 293
        *(where + i) = (idxtype )0;
        {
#line 294
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 294
          pwgts[0] += *(vwgt + i);
#line 294
          pwgts[1] -= *(vwgt + i);
#line 294
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 295
        if (pwgts[1] <= maxpwgt[1]) {
#line 296
          goto while_break___0;
        }
#line 298
        drain = 0L;
#line 299
        j = *(xadj + i);
        {
#line 299
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 299
          if (! (j < *(xadj + (i + 1L)))) {
#line 299
            goto while_break___3;
          }
#line 300
          k = *(adjncy + j);
#line 301
          if (*(touched + k) == 0L) {
#line 302
            tmp___2 = last;
#line 302
            last ++;
#line 302
            *(queue + tmp___2) = k;
#line 303
            *(touched + k) = (idxtype )1;
#line 304
            nleft --;
          }
#line 299
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        __Cont: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 313
    __Compute2WayPartitionParams(ctrl, graph);
#line 314
    __Balance2Way(ctrl, graph, tpwgts, ubfactor);
#line 315
    __FM_2WayEdgeRefine(ctrl, graph, tpwgts, 4L);
#line 318
    i = 0L;
    }
    {
#line 318
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 318
      if (! (i < graph->nbnd)) {
#line 318
        goto while_break___4;
      }
#line 319
      *(where + *(bndind + i)) = (idxtype )2;
#line 318
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 321
    __Compute2WayNodePartitionParams(ctrl, graph);
#line 322
    __FM_2WayNodeRefine(ctrl, graph, ubfactor, 6L);
    }
#line 326
    if (bestcut > graph->mincut) {
      {
#line 327
      bestcut = graph->mincut;
#line 328
      memcpy((void */* __restrict  */)((void *)bestwhere), (void const   */* __restrict  */)((void *)where),
             sizeof(idxtype ) * (unsigned long )nvtxs);
      }
    }
#line 250
    nbfs --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 332
  graph->mincut = bestcut;
#line 333
  memcpy((void */* __restrict  */)((void *)where), (void const   */* __restrict  */)((void *)bestwhere),
         sizeof(idxtype ) * (unsigned long )nvtxs);
#line 335
  __Compute2WayNodePartitionParams(ctrl, graph);
#line 337
  __GKfree(& bestwhere, & queue, & touched, (void **)0);
  }
#line 338
  return;
}
}
#line 346 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/initpart.c"
void __RandomBisection(CtrlType *ctrl , GraphType *graph , long *tpwgts , float ubfactor ) 
{ 
  long i ;
  long ii ;
  long nvtxs ;
  long pwgts[2] ;
  long minpwgt[2] ;
  long maxpwgt[2] ;
  long bestcut ;
  long nbfs ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *perm ;
  idxtype *bestwhere ;
  long tmp ;

  {
  {
#line 352
  nvtxs = graph->nvtxs;
#line 353
  xadj = graph->xadj;
#line 354
  vwgt = graph->vwgt;
#line 355
  adjncy = graph->adjncy;
#line 356
  adjwgt = graph->adjwgt;
#line 358
  __Allocate2WayPartitionMemory(ctrl, graph);
#line 359
  where = graph->where;
#line 361
  bestwhere = __idxmalloc(nvtxs, (char *)"BisectGraph: bestwhere");
#line 362
  perm = __idxmalloc(nvtxs, (char *)"BisectGraph: queue");
#line 366
  maxpwgt[0] = (long )(ubfactor * (float )*(tpwgts + 0));
#line 367
  maxpwgt[1] = (long )(ubfactor * (float )*(tpwgts + 1));
#line 368
  minpwgt[0] = (long )((1.0 / (double )ubfactor) * (double )*(tpwgts + 0));
#line 369
  minpwgt[1] = (long )((1.0 / (double )ubfactor) * (double )*(tpwgts + 1));
  }
#line 371
  if (nvtxs <= ctrl->CoarsenTo) {
#line 371
    nbfs = 3L;
  } else {
#line 371
    nbfs = 8L;
  }
  {
#line 372
  tmp = __idxsum(nvtxs, graph->adjwgtsum);
#line 372
  bestcut = tmp + 1L;
  }
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! (nbfs > 0L)) {
#line 373
      goto while_break;
    }
    {
#line 374
    __RandomPermute(nvtxs, perm, 1L);
#line 376
    __idxset(nvtxs, (idxtype )1, where);
#line 377
    pwgts[1] = *(tpwgts + 0) + *(tpwgts + 1);
#line 378
    pwgts[0] = 0L;
    }
#line 381
    if (nbfs != 1L) {
#line 382
      ii = 0L;
      {
#line 382
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 382
        if (! (ii < nvtxs)) {
#line 382
          goto while_break___0;
        }
#line 383
        i = *(perm + ii);
#line 384
        if (pwgts[0] + *(vwgt + i) < maxpwgt[0]) {
#line 385
          *(where + i) = (idxtype )0;
#line 386
          pwgts[0] += *(vwgt + i);
#line 387
          pwgts[1] -= *(vwgt + i);
#line 388
          if (pwgts[0] > minpwgt[0]) {
#line 389
            goto while_break___0;
          }
        }
#line 382
        ii ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 397
    __Compute2WayPartitionParams(ctrl, graph);
#line 400
    __Balance2Way(ctrl, graph, tpwgts, ubfactor);
#line 403
    __FM_2WayEdgeRefine(ctrl, graph, tpwgts, 4L);
    }
#line 406
    if (bestcut > graph->mincut) {
      {
#line 407
      bestcut = graph->mincut;
#line 408
      memcpy((void */* __restrict  */)((void *)bestwhere), (void const   */* __restrict  */)((void *)where),
             sizeof(idxtype ) * (unsigned long )nvtxs);
      }
#line 409
      if (bestcut == 0L) {
#line 410
        goto while_break;
      }
    }
#line 373
    nbfs --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 414
  graph->mincut = bestcut;
#line 415
  memcpy((void */* __restrict  */)((void *)where), (void const   */* __restrict  */)((void *)bestwhere),
         sizeof(idxtype ) * (unsigned long )nvtxs);
#line 417
  __GKfree(& bestwhere, & perm, (void **)0);
  }
#line 418
  return;
}
}
#line 132 "./proto.h"
void __SetUpGraph2(GraphType *graph , long nvtxs , long ncon , idxtype *xadj , idxtype *adjncy ,
                   float *nvwgt , idxtype *adjwgt ) ;
#line 256
void __MocInit2WayPartition(CtrlType *ctrl , GraphType *graph , float *tpwgts , float ubfactor ) ;
#line 308
void METIS_mCHPartGraphRecursive(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                                 idxtype *vwgt , idxtype *adjwgt , long *wgtflag ,
                                 long *numflag , long *nparts , float *ubvec , long *options ,
                                 long *edgecut , idxtype *part ) ;
#line 309
void METIS_mCPartGraphRecursiveInternal(long *nvtxs , long *ncon , idxtype *xadj ,
                                        idxtype *adjncy , float *nvwgt , idxtype *adjwgt ,
                                        long *nparts , long *options , long *edgecut ,
                                        idxtype *part ) ;
#line 310
void METIS_mCHPartGraphRecursiveInternal(long *nvtxs , long *ncon , idxtype *xadj ,
                                         idxtype *adjncy , float *nvwgt , idxtype *adjwgt ,
                                         long *nparts , float *ubvec , long *options ,
                                         long *edgecut , idxtype *part ) ;
#line 311
long __MCMlevelRecursiveBisection(CtrlType *ctrl , GraphType *graph , long nparts ,
                                  idxtype *part , float ubfactor , long fpart ) ;
#line 312
long __MCHMlevelRecursiveBisection(CtrlType *ctrl , GraphType *graph , long nparts ,
                                   idxtype *part , float *ubvec , long fpart ) ;
#line 313
void __MCMlevelEdgeBisection(CtrlType *ctrl , GraphType *graph , float *tpwgts , float ubfactor ) ;
#line 314
void __MCHMlevelEdgeBisection(CtrlType *ctrl , GraphType *graph , float *tpwgts ,
                              float *ubvec ) ;
#line 24 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mpmetis.c"
void METIS_mCPartGraphRecursive(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                                idxtype *vwgt , idxtype *adjwgt , long *wgtflag ,
                                long *numflag , long *nparts , long *options , long *edgecut ,
                                idxtype *part ) 
{ 
  GraphType graph ;
  CtrlType ctrl ;
  double tmp ;
  double tmp___0 ;

  {
#line 32
  if (*numflag == 1L) {
    {
#line 33
    __Change2CNumbering(*nvtxs, xadj, adjncy);
    }
  }
  {
#line 35
  __SetUpGraph(& graph, 1L, *nvtxs, *ncon, xadj, adjncy, vwgt, adjwgt, *wgtflag);
  }
#line 37
  if (*(options + 0) == 0L) {
#line 38
    ctrl.CType = 5L;
#line 39
    ctrl.IType = 2L;
#line 40
    ctrl.RType = 1L;
#line 41
    ctrl.dbglvl = 0L;
  } else {
#line 44
    ctrl.CType = *(options + 1);
#line 45
    ctrl.IType = *(options + 2);
#line 46
    ctrl.RType = *(options + 3);
#line 47
    ctrl.dbglvl = *(options + 4);
  }
  {
#line 49
  ctrl.optype = 1L;
#line 50
  ctrl.CoarsenTo = 100L;
#line 52
  ctrl.nmaxvwgt = (float )(1.5 / (1.0 * (double )ctrl.CoarsenTo));
#line 54
  __InitRandom(-1L);
#line 56
  __AllocateWorkSpace(& ctrl, & graph, *nparts);
  }
#line 58
  if (ctrl.dbglvl & 1L) {
    {
#line 58
    __InitTimers(& ctrl);
    }
  }
#line 59
  if (ctrl.dbglvl & 1L) {
    {
#line 59
    tmp = __seconds();
#line 59
    ctrl.TotalTmr -= tmp;
    }
  }
  {
#line 61
  *edgecut = __MCMlevelRecursiveBisection(& ctrl, & graph, *nparts, part, (float )1.000,
                                          0L);
  }
#line 63
  if (ctrl.dbglvl & 1L) {
    {
#line 63
    tmp___0 = __seconds();
#line 63
    ctrl.TotalTmr += tmp___0;
    }
  }
#line 64
  if (ctrl.dbglvl & 1L) {
    {
#line 64
    __PrintTimers(& ctrl);
    }
  }
  {
#line 66
  __FreeWorkSpace(& ctrl, & graph);
  }
#line 68
  if (*numflag == 1L) {
    {
#line 69
    __Change2FNumbering(*nvtxs, xadj, adjncy, part);
    }
  }
#line 70
  return;
}
}
#line 78 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mpmetis.c"
void METIS_mCHPartGraphRecursive(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                                 idxtype *vwgt , idxtype *adjwgt , long *wgtflag ,
                                 long *numflag , long *nparts , float *ubvec , long *options ,
                                 long *edgecut , idxtype *part ) 
{ 
  GraphType graph ;
  CtrlType ctrl ;
  float *myubvec ;
  double tmp ;
  double tmp___0 ;

  {
#line 87
  if (*numflag == 1L) {
    {
#line 88
    __Change2CNumbering(*nvtxs, xadj, adjncy);
    }
  }
  {
#line 90
  __SetUpGraph(& graph, 1L, *nvtxs, *ncon, xadj, adjncy, vwgt, adjwgt, *wgtflag);
  }
#line 92
  if (*(options + 0) == 0L) {
#line 93
    ctrl.CType = 3L;
#line 94
    ctrl.IType = 1L;
#line 95
    ctrl.RType = 1L;
#line 96
    ctrl.dbglvl = 0L;
  } else {
#line 99
    ctrl.CType = *(options + 1);
#line 100
    ctrl.IType = *(options + 2);
#line 101
    ctrl.RType = *(options + 3);
#line 102
    ctrl.dbglvl = *(options + 4);
  }
  {
#line 104
  ctrl.optype = 1L;
#line 105
  ctrl.CoarsenTo = 100L;
#line 107
  ctrl.nmaxvwgt = (float )(1.5 / (1.0 * (double )ctrl.CoarsenTo));
#line 109
  myubvec = __fmalloc(*ncon, (char *)"PWMETIS: mytpwgts");
#line 110
  memcpy((void */* __restrict  */)((void *)myubvec), (void const   */* __restrict  */)((void *)ubvec),
         sizeof(float ) * (unsigned long )*ncon);
#line 112
  __InitRandom(-1L);
#line 114
  __AllocateWorkSpace(& ctrl, & graph, *nparts);
  }
#line 116
  if (ctrl.dbglvl & 1L) {
    {
#line 116
    __InitTimers(& ctrl);
    }
  }
#line 117
  if (ctrl.dbglvl & 1L) {
    {
#line 117
    tmp = __seconds();
#line 117
    ctrl.TotalTmr -= tmp;
    }
  }
  {
#line 119
  *edgecut = __MCHMlevelRecursiveBisection(& ctrl, & graph, *nparts, part, myubvec,
                                           0L);
  }
#line 121
  if (ctrl.dbglvl & 1L) {
    {
#line 121
    tmp___0 = __seconds();
#line 121
    ctrl.TotalTmr += tmp___0;
    }
  }
#line 122
  if (ctrl.dbglvl & 1L) {
    {
#line 122
    __PrintTimers(& ctrl);
    }
  }
  {
#line 124
  __FreeWorkSpace(& ctrl, & graph);
#line 125
  __GKfree(& myubvec, (void **)0);
  }
#line 127
  if (*numflag == 1L) {
    {
#line 128
    __Change2FNumbering(*nvtxs, xadj, adjncy, part);
    }
  }
#line 129
  return;
}
}
#line 137 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mpmetis.c"
void METIS_mCPartGraphRecursiveInternal(long *nvtxs , long *ncon , idxtype *xadj ,
                                        idxtype *adjncy , float *nvwgt , idxtype *adjwgt ,
                                        long *nparts , long *options , long *edgecut ,
                                        idxtype *part ) 
{ 
  GraphType graph ;
  CtrlType ctrl ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 144
  __SetUpGraph2(& graph, *nvtxs, *ncon, xadj, adjncy, nvwgt, adjwgt);
  }
#line 146
  if (*(options + 0) == 0L) {
#line 147
    ctrl.CType = 3L;
#line 148
    ctrl.IType = 1L;
#line 149
    ctrl.RType = 1L;
#line 150
    ctrl.dbglvl = 0L;
  } else {
#line 153
    ctrl.CType = *(options + 1);
#line 154
    ctrl.IType = *(options + 2);
#line 155
    ctrl.RType = *(options + 3);
#line 156
    ctrl.dbglvl = *(options + 4);
  }
  {
#line 158
  ctrl.optype = 1L;
#line 159
  ctrl.CoarsenTo = 100L;
#line 161
  ctrl.nmaxvwgt = (float )(1.5 / (1.0 * (double )ctrl.CoarsenTo));
#line 163
  __InitRandom(-1L);
#line 165
  __AllocateWorkSpace(& ctrl, & graph, *nparts);
  }
#line 167
  if (ctrl.dbglvl & 1L) {
    {
#line 167
    __InitTimers(& ctrl);
    }
  }
#line 168
  if (ctrl.dbglvl & 1L) {
    {
#line 168
    tmp = __seconds();
#line 168
    ctrl.TotalTmr -= tmp;
    }
  }
  {
#line 170
  *edgecut = __MCMlevelRecursiveBisection(& ctrl, & graph, *nparts, part, (float )1.000,
                                          0L);
  }
#line 172
  if (ctrl.dbglvl & 1L) {
    {
#line 172
    tmp___0 = __seconds();
#line 172
    ctrl.TotalTmr += tmp___0;
    }
  }
#line 173
  if (ctrl.dbglvl & 1L) {
    {
#line 173
    __PrintTimers(& ctrl);
    }
  }
  {
#line 175
  __FreeWorkSpace(& ctrl, & graph);
  }
#line 177
  return;
}
}
#line 184 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mpmetis.c"
void METIS_mCHPartGraphRecursiveInternal(long *nvtxs , long *ncon , idxtype *xadj ,
                                         idxtype *adjncy , float *nvwgt , idxtype *adjwgt ,
                                         long *nparts , float *ubvec , long *options ,
                                         long *edgecut , idxtype *part ) 
{ 
  GraphType graph ;
  CtrlType ctrl ;
  float *myubvec ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 193
  __SetUpGraph2(& graph, *nvtxs, *ncon, xadj, adjncy, nvwgt, adjwgt);
  }
#line 195
  if (*(options + 0) == 0L) {
#line 196
    ctrl.CType = 3L;
#line 197
    ctrl.IType = 1L;
#line 198
    ctrl.RType = 1L;
#line 199
    ctrl.dbglvl = 0L;
  } else {
#line 202
    ctrl.CType = *(options + 1);
#line 203
    ctrl.IType = *(options + 2);
#line 204
    ctrl.RType = *(options + 3);
#line 205
    ctrl.dbglvl = *(options + 4);
  }
  {
#line 207
  ctrl.optype = 1L;
#line 208
  ctrl.CoarsenTo = 100L;
#line 210
  ctrl.nmaxvwgt = (float )(1.5 / (1.0 * (double )ctrl.CoarsenTo));
#line 212
  myubvec = __fmalloc(*ncon, (char *)"PWMETIS: mytpwgts");
#line 213
  memcpy((void */* __restrict  */)((void *)myubvec), (void const   */* __restrict  */)((void *)ubvec),
         sizeof(float ) * (unsigned long )*ncon);
#line 215
  __InitRandom(-1L);
#line 217
  __AllocateWorkSpace(& ctrl, & graph, *nparts);
  }
#line 219
  if (ctrl.dbglvl & 1L) {
    {
#line 219
    __InitTimers(& ctrl);
    }
  }
#line 220
  if (ctrl.dbglvl & 1L) {
    {
#line 220
    tmp = __seconds();
#line 220
    ctrl.TotalTmr -= tmp;
    }
  }
  {
#line 222
  *edgecut = __MCHMlevelRecursiveBisection(& ctrl, & graph, *nparts, part, myubvec,
                                           0L);
  }
#line 224
  if (ctrl.dbglvl & 1L) {
    {
#line 224
    tmp___0 = __seconds();
#line 224
    ctrl.TotalTmr += tmp___0;
    }
  }
#line 225
  if (ctrl.dbglvl & 1L) {
    {
#line 225
    __PrintTimers(& ctrl);
    }
  }
  {
#line 227
  __FreeWorkSpace(& ctrl, & graph);
#line 228
  __GKfree(& myubvec, (void **)0);
  }
#line 230
  return;
}
}
#line 238 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mpmetis.c"
long __MCMlevelRecursiveBisection(CtrlType *ctrl , GraphType *graph , long nparts ,
                                  idxtype *part , float ubfactor , long fpart ) 
{ 
  long i ;
  long nvtxs ;
  long cut ;
  idxtype *label ;
  idxtype *where ;
  GraphType lgraph ;
  GraphType rgraph ;
  float tpwgts[2] ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 246
  nvtxs = graph->nvtxs;
#line 247
  if (nvtxs == 0L) {
    {
#line 248
    printf((char const   */* __restrict  */)"\t***Cannot bisect a graph with 0 vertices!\n\t***You are trying to partition a graph into too many parts!\n");
    }
#line 249
    return (0L);
  }
  {
#line 253
  tpwgts[0] = (float )((1.0 * (double )(nparts >> 1)) / (1.0 * (double )nparts));
#line 254
  tpwgts[1] = (float )(1.0 - (double )tpwgts[0]);
#line 256
  __MCMlevelEdgeBisection(ctrl, graph, tpwgts, ubfactor);
#line 257
  cut = graph->mincut;
#line 259
  label = graph->label;
#line 260
  where = graph->where;
#line 261
  i = 0L;
  }
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! (i < nvtxs)) {
#line 261
      goto while_break;
    }
#line 262
    *(part + *(label + i)) = *(where + i) + fpart;
#line 261
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  if (nparts > 2L) {
    {
#line 265
    __SplitGraphPart(ctrl, graph, & lgraph, & rgraph);
    }
  }
  {
#line 268
  __GKfree(& graph->gdata, & graph->nvwgt, & graph->rdata, & graph->npwgts, & graph->label,
           (void **)0);
  }
#line 272
  if (nparts > 3L) {
    {
#line 273
    tmp = __MCMlevelRecursiveBisection(ctrl, & lgraph, nparts / 2L, part, ubfactor,
                                       fpart);
#line 273
    cut += tmp;
#line 274
    tmp___0 = __MCMlevelRecursiveBisection(ctrl, & rgraph, nparts - nparts / 2L, part,
                                           ubfactor, fpart + nparts / 2L);
#line 274
    cut += tmp___0;
    }
  } else
#line 276
  if (nparts == 3L) {
    {
#line 277
    tmp___1 = __MCMlevelRecursiveBisection(ctrl, & rgraph, nparts - nparts / 2L, part,
                                           ubfactor, fpart + nparts / 2L);
#line 277
    cut += tmp___1;
#line 278
    __GKfree(& lgraph.gdata, & lgraph.nvwgt, & lgraph.label, (void **)0);
    }
  }
#line 281
  return (cut);
}
}
#line 290 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mpmetis.c"
long __MCHMlevelRecursiveBisection(CtrlType *ctrl , GraphType *graph , long nparts ,
                                   idxtype *part , float *ubvec , long fpart ) 
{ 
  long i ;
  long nvtxs ;
  long ncon ;
  long cut ;
  idxtype *label ;
  idxtype *where ;
  GraphType lgraph ;
  GraphType rgraph ;
  float tpwgts[2] ;
  float *npwgts ;
  float *lubvec ;
  float *rubvec ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 298
  rubvec = (float *)((void *)0);
#line 298
  lubvec = rubvec;
#line 300
  nvtxs = graph->nvtxs;
#line 301
  ncon = graph->ncon;
#line 302
  if (nvtxs == 0L) {
    {
#line 303
    printf((char const   */* __restrict  */)"\t***Cannot bisect a graph with 0 vertices!\n\t***You are trying to partition a graph into too many parts!\n");
    }
#line 304
    return (0L);
  }
#line 308
  tpwgts[0] = (float )((1.0 * (double )(nparts >> 1)) / (1.0 * (double )nparts));
#line 309
  tpwgts[1] = (float )(1.0 - (double )tpwgts[0]);
#line 312
  if (nparts == 2L) {
    {
#line 313
    __MCHMlevelEdgeBisection(ctrl, graph, tpwgts, ubvec);
    }
  } else {
    {
#line 315
    __MCMlevelEdgeBisection(ctrl, graph, tpwgts, (float )1.000);
    }
  }
#line 316
  cut = graph->mincut;
#line 318
  label = graph->label;
#line 319
  where = graph->where;
#line 320
  i = 0L;
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! (i < nvtxs)) {
#line 320
      goto while_break;
    }
#line 321
    *(part + *(label + i)) = *(where + i) + fpart;
#line 320
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  if (nparts > 2L) {
    {
#line 325
    npwgts = graph->npwgts;
#line 326
    lubvec = __fmalloc(ncon, (char *)"MCHMlevelRecursiveBisection");
#line 327
    rubvec = __fmalloc(ncon, (char *)"MCHMlevelRecursiveBisection");
#line 329
    i = 0L;
    }
    {
#line 329
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 329
      if (! (i < ncon)) {
#line 329
        goto while_break___0;
      }
#line 330
      *(lubvec + i) = (*(ubvec + i) * tpwgts[0]) / *(npwgts + i);
#line 331
      if ((double )*(lubvec + i) >= 1.01) {
#line 331
        *(lubvec + i) = *(lubvec + i);
      } else {
#line 331
        *(lubvec + i) = (float )1.01;
      }
#line 333
      *(rubvec + i) = (*(ubvec + i) * tpwgts[1]) / *(npwgts + (ncon + i));
#line 334
      if ((double )*(rubvec + i) >= 1.01) {
#line 334
        *(rubvec + i) = *(rubvec + i);
      } else {
#line 334
        *(rubvec + i) = (float )1.01;
      }
#line 329
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 337
    __SplitGraphPart(ctrl, graph, & lgraph, & rgraph);
    }
  }
  {
#line 341
  __GKfree(& graph->gdata, & graph->nvwgt, & graph->rdata, & graph->npwgts, & graph->label,
           (void **)0);
  }
#line 345
  if (nparts > 3L) {
    {
#line 346
    tmp = __MCHMlevelRecursiveBisection(ctrl, & lgraph, nparts / 2L, part, lubvec,
                                        fpart);
#line 346
    cut += tmp;
#line 347
    tmp___0 = __MCHMlevelRecursiveBisection(ctrl, & rgraph, nparts - nparts / 2L,
                                            part, rubvec, fpart + nparts / 2L);
#line 347
    cut += tmp___0;
    }
  } else
#line 349
  if (nparts == 3L) {
    {
#line 350
    tmp___1 = __MCHMlevelRecursiveBisection(ctrl, & rgraph, nparts - nparts / 2L,
                                            part, rubvec, fpart + nparts / 2L);
#line 350
    cut += tmp___1;
#line 351
    __GKfree(& lgraph.gdata, & lgraph.nvwgt, & lgraph.label, (void **)0);
    }
  }
  {
#line 354
  __GKfree(& lubvec, & rubvec, (void **)0);
  }
#line 356
  return (cut);
}
}
#line 366 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mpmetis.c"
void __MCMlevelEdgeBisection(CtrlType *ctrl , GraphType *graph , float *tpwgts , float ubfactor ) 
{ 
  GraphType *cgraph ;

  {
  {
#line 370
  cgraph = __MCCoarsen2Way(ctrl, graph);
#line 372
  __MocInit2WayPartition(ctrl, cgraph, tpwgts, ubfactor);
#line 374
  __MocRefine2Way(ctrl, graph, cgraph, tpwgts, ubfactor);
  }
#line 376
  return;
}
}
#line 383 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mpmetis.c"
void __MCHMlevelEdgeBisection(CtrlType *ctrl , GraphType *graph , float *tpwgts ,
                              float *ubvec ) 
{ 
  GraphType *cgraph ;

  {
  {
#line 394
  cgraph = __MCCoarsen2Way(ctrl, graph);
#line 396
  __MocInit2WayPartition2(ctrl, cgraph, tpwgts, ubvec);
#line 398
  __MocRefine2Way2(ctrl, graph, cgraph, tpwgts, ubvec);
  }
#line 400
  return;
}
}
#line 201 "./proto.h"
void __MocGeneral2WayBalance(CtrlType *ctrl , GraphType *graph , float *tpwgts , float lbfactor ) ;
#line 238
void __SelectQueue(long ncon , float *npwgts , float *tpwgts , long *from , long *cnum ,
                   PQueueType (*queues)[2] ) ;
#line 239
long __BetterBalance(long ncon , float *npwgts , float *tpwgts , float *diff ) ;
#line 240
float __Compute2WayHLoadImbalance(long ncon , float *npwgts , float *tpwgts ) ;
#line 443
long __samax2(long n , float *x ) ;
#line 22 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mbalance.c"
void __MocBalance2Way(CtrlType *ctrl , GraphType *graph , float *tpwgts , float lbfactor ) 
{ 
  float tmp ;

  {
  {
#line 25
  tmp = __Compute2WayHLoadImbalance(graph->ncon, graph->npwgts, tpwgts);
  }
#line 25
  if (tmp < lbfactor) {
#line 26
    return;
  }
  {
#line 28
  __MocGeneral2WayBalance(ctrl, graph, tpwgts, lbfactor);
  }
#line 30
  return;
}
}
#line 36 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mbalance.c"
void __MocGeneral2WayBalance(CtrlType *ctrl , GraphType *graph , float *tpwgts , float lbfactor ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long l ;
  long kwgt ;
  long nvtxs ;
  long ncon ;
  long nbnd ;
  long nswaps ;
  long from ;
  long to ;
  long limit ;
  long tmp ;
  long cnum ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *id ;
  idxtype *ed ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *moved ;
  idxtype *swaps ;
  idxtype *perm ;
  idxtype *qnum ;
  float *nvwgt ;
  float *npwgts ;
  float mindiff[16] ;
  float origbal ;
  float minbal ;
  float newbal ;
  PQueueType parts[16][2] ;
  long higain ;
  long oldgain ;
  long mincut ;
  long newcut ;
  long mincutorder ;
  long qsizes[16][2] ;
  double tmp___1 ;
  double tmp___2 ;
  long tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  idxtype tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  float tmp___12 ;

  {
  {
#line 46
  nvtxs = graph->nvtxs;
#line 47
  ncon = graph->ncon;
#line 48
  xadj = graph->xadj;
#line 49
  nvwgt = graph->nvwgt;
#line 50
  adjncy = graph->adjncy;
#line 51
  adjwgt = graph->adjwgt;
#line 52
  where = graph->where;
#line 53
  id = graph->id;
#line 54
  ed = graph->ed;
#line 55
  npwgts = graph->npwgts;
#line 56
  bndptr = graph->bndptr;
#line 57
  bndind = graph->bndind;
#line 59
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 60
  swaps = __idxwspacemalloc(ctrl, nvtxs);
#line 61
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 62
  qnum = __idxwspacemalloc(ctrl, nvtxs);
  }
#line 64
  if (0.01 * (double )nvtxs >= (double )15) {
#line 64
    tmp___2 = 0.01 * (double )nvtxs;
  } else {
#line 64
    tmp___2 = (double )15;
  }
#line 64
  if (tmp___2 >= (double )100) {
#line 64
    limit = 100L;
  } else {
#line 64
    if (0.01 * (double )nvtxs >= (double )15) {
#line 64
      tmp___1 = 0.01 * (double )nvtxs;
    } else {
#line 64
      tmp___1 = (double )15;
    }
#line 64
    limit = (long )tmp___1;
  }
#line 67
  i = 0L;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < ncon)) {
#line 67
      goto while_break;
    }
    {
#line 68
    __PQueueInit(ctrl, & parts[i][0], nvtxs, 501L);
#line 69
    __PQueueInit(ctrl, & parts[i][1], nvtxs, 501L);
#line 70
    tmp___3 = 0L;
#line 70
    qsizes[i][1] = tmp___3;
#line 70
    qsizes[i][0] = tmp___3;
#line 67
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  i = 0L;
  {
#line 73
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 73
    if (! (i < nvtxs)) {
#line 73
      goto while_break___0;
    }
    {
#line 74
    *(qnum + i) = __samax(ncon, nvwgt + i * ncon);
#line 75
    (qsizes[*(qnum + i)][*(where + i)]) ++;
#line 73
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 85
  from = 0L;
  {
#line 85
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 85
    if (! (from < 2L)) {
#line 85
      goto while_break___1;
    }
#line 86
    j = 0L;
    {
#line 86
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 86
      if (! (j < ncon)) {
#line 86
        goto while_break___2;
      }
#line 87
      if (qsizes[j][from] == 0L) {
#line 88
        i = 0L;
        {
#line 88
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 88
          if (! (i < nvtxs)) {
#line 88
            goto while_break___3;
          }
#line 89
          if (*(where + i) != from) {
#line 90
            goto __Cont;
          }
          {
#line 92
          k = __samax2(ncon, nvwgt + i * ncon);
          }
#line 93
          if (k == j) {
#line 93
            if (qsizes[*(qnum + i)][from] > qsizes[j][from]) {
#line 93
              if ((double )*(nvwgt + (i * ncon + *(qnum + i))) < 1.3 * (double )*(nvwgt + (i * ncon + j))) {
#line 94
                (qsizes[*(qnum + i)][from]) --;
#line 95
                (qsizes[j][from]) ++;
#line 96
                *(qnum + i) = j;
              }
            }
          }
          __Cont: /* CIL Label */ 
#line 88
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 86
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 85
    from ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 112
  i = 0L;
  {
#line 112
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 112
    if (! (i < ncon)) {
#line 112
      goto while_break___4;
    }
    {
#line 113
    tmp___4 = fabs((double )(*(tpwgts + 0) - *(npwgts + i)));
#line 113
    mindiff[i] = (float )tmp___4;
#line 112
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 114
  origbal = __Compute2WayHLoadImbalance(ncon, npwgts, tpwgts);
#line 114
  minbal = origbal;
#line 115
  mincut = graph->mincut;
#line 115
  newcut = mincut;
#line 116
  mincutorder = -1L;
  }
#line 118
  if (ctrl->dbglvl & 8L) {
    {
#line 119
    printf((char const   */* __restrict  */)"Parts: [");
#line 120
    l = 0L;
    }
    {
#line 120
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 120
      if (! (l < ncon)) {
#line 120
        goto while_break___5;
      }
      {
#line 121
      printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
             (double )*(npwgts + (ncon + l)));
#line 120
      l ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 122
    printf((char const   */* __restrict  */)"] T[%.3f %.3f], Nv-Nb[%5ld, %5ld]. ICut: %6ld, LB: %.3f [B]\n",
           (double )*(tpwgts + 0), (double )*(tpwgts + 1), graph->nvtxs, graph->nbnd,
           graph->mincut, (double )origbal);
    }
  }
  {
#line 125
  __idxset(nvtxs, (idxtype )-1, moved);
#line 131
  nbnd = graph->nbnd;
#line 132
  __RandomPermute(nvtxs, perm, 1L);
#line 133
  ii = 0L;
  }
  {
#line 133
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 133
    if (! (ii < nvtxs)) {
#line 133
      goto while_break___6;
    }
    {
#line 134
    i = *(perm + ii);
#line 135
    __PQueueInsert(& parts[*(qnum + i)][*(where + i)], i, *(ed + i) - *(id + i));
#line 133
    ii ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 138
  nswaps = 0L;
  {
#line 138
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 138
    if (! (nswaps < nvtxs)) {
#line 138
      goto while_break___7;
    }
#line 139
    if (minbal < lbfactor) {
#line 140
      goto while_break___7;
    }
    {
#line 142
    __SelectQueue(ncon, npwgts, tpwgts, & from, & cnum, (PQueueType (*)[2])(parts));
#line 143
    to = (from + 1L) % 2L;
    }
#line 145
    if (from == -1L) {
#line 146
      goto while_break___7;
    } else {
      {
#line 145
      higain = __PQueueGetMax(& parts[cnum][from]);
      }
#line 145
      if (higain == -1L) {
#line 146
        goto while_break___7;
      }
    }
    {
#line 148
    __saxpy(ncon, (float )1.0, nvwgt + higain * ncon, 1L, npwgts + to * ncon, 1L);
#line 149
    __saxpy(ncon, (float )(- 1.0), nvwgt + higain * ncon, 1L, npwgts + from * ncon,
            1L);
#line 150
    newcut -= *(ed + higain) - *(id + higain);
#line 151
    newbal = __Compute2WayHLoadImbalance(ncon, npwgts, tpwgts);
    }
#line 153
    if (newbal < minbal) {
#line 153
      goto _L___1;
    } else
#line 153
    if (newbal == minbal) {
#line 153
      if (newcut < mincut) {
#line 153
        goto _L___1;
      } else
#line 153
      if (newcut == mincut) {
        {
#line 153
        tmp___6 = __BetterBalance(ncon, npwgts, tpwgts, mindiff);
        }
#line 153
        if (tmp___6) {
          _L___1: /* CIL Label */ 
#line 155
          mincut = newcut;
#line 156
          minbal = newbal;
#line 157
          mincutorder = nswaps;
#line 158
          i = 0L;
          {
#line 158
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 158
            if (! (i < ncon)) {
#line 158
              goto while_break___8;
            }
            {
#line 159
            tmp___5 = fabs((double )(*(tpwgts + 0) - *(npwgts + i)));
#line 159
            mindiff[i] = (float )tmp___5;
#line 158
            i ++;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
        } else {
#line 153
          goto _L___0;
        }
      } else {
#line 153
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 161
    if (nswaps - mincutorder > limit) {
      {
#line 162
      newcut += *(ed + higain) - *(id + higain);
#line 163
      __saxpy(ncon, (float )1.0, nvwgt + higain * ncon, 1L, npwgts + from * ncon,
              1L);
#line 164
      __saxpy(ncon, (float )(- 1.0), nvwgt + higain * ncon, 1L, npwgts + to * ncon,
              1L);
      }
#line 165
      goto while_break___7;
    }
#line 168
    *(where + higain) = to;
#line 169
    *(moved + higain) = nswaps;
#line 170
    *(swaps + nswaps) = higain;
#line 172
    if (ctrl->dbglvl & 32L) {
      {
#line 173
      printf((char const   */* __restrict  */)"Moved %6ld from %ld(%ld). Gain: %5ld, Cut: %5ld, NPwgts: ",
             higain, from, cnum, *(ed + higain) - *(id + higain), newcut);
#line 174
      l = 0L;
      }
      {
#line 174
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 174
        if (! (l < ncon)) {
#line 174
          goto while_break___9;
        }
        {
#line 175
        printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
               (double )*(npwgts + (ncon + l)));
#line 174
        l ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 176
      printf((char const   */* __restrict  */)", %.3f LB: %.3f\n", (double )minbal,
             (double )newbal);
      }
    }
    {
#line 183
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 183
      tmp = *(id + higain);
#line 183
      *(id + higain) = *(ed + higain);
#line 183
      *(ed + higain) = tmp;
#line 183
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 184
    if (*(ed + higain) == 0L) {
#line 184
      if (*(bndptr + higain) != -1L) {
#line 184
        if (*(xadj + higain) < *(xadj + (higain + 1L))) {
          {
#line 185
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 185
            nbnd --;
#line 185
            *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 185
            *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 185
            *(bndptr + higain) = (idxtype )-1;
#line 185
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
        }
      }
    }
#line 186
    if (*(ed + higain) > 0L) {
#line 186
      if (*(bndptr + higain) == -1L) {
        {
#line 187
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 187
          *(bndind + nbnd) = higain;
#line 187
          tmp___7 = nbnd;
#line 187
          nbnd ++;
#line 187
          *(bndptr + higain) = tmp___7;
#line 187
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
    }
#line 189
    j = *(xadj + higain);
    {
#line 189
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 189
      if (! (j < *(xadj + (higain + 1L)))) {
#line 189
        goto while_break___13;
      }
#line 190
      k = *(adjncy + j);
#line 191
      oldgain = *(ed + k) - *(id + k);
#line 193
      if (to == *(where + k)) {
#line 193
        kwgt = *(adjwgt + j);
      } else {
#line 193
        kwgt = - *(adjwgt + j);
      }
      {
#line 194
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 194
        *(id + k) += kwgt;
#line 194
        *(ed + k) -= kwgt;
#line 194
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 197
      if (*(moved + k) == -1L) {
        {
#line 198
        __PQueueUpdate(& parts[*(qnum + k)][*(where + k)], k, oldgain, *(ed + k) - *(id + k));
        }
      }
#line 201
      if (*(ed + k) == 0L) {
#line 201
        if (*(bndptr + k) != -1L) {
          {
#line 202
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 202
            nbnd --;
#line 202
            *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 202
            *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 202
            *(bndptr + k) = (idxtype )-1;
#line 202
            goto while_break___15;
          }
          while_break___15: /* CIL Label */ ;
          }
        } else {
#line 201
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 203
      if (*(ed + k) > 0L) {
#line 203
        if (*(bndptr + k) == -1L) {
          {
#line 204
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 204
            *(bndind + nbnd) = k;
#line 204
            tmp___8 = nbnd;
#line 204
            nbnd ++;
#line 204
            *(bndptr + k) = tmp___8;
#line 204
            goto while_break___16;
          }
          while_break___16: /* CIL Label */ ;
          }
        }
      }
#line 189
      j ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 138
    nswaps ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 213
  nswaps --;
  {
#line 213
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 213
    if (! (nswaps > mincutorder)) {
#line 213
      goto while_break___17;
    }
#line 214
    higain = *(swaps + nswaps);
#line 216
    tmp___9 = (*(where + higain) + 1L) % 2L;
#line 216
    *(where + higain) = tmp___9;
#line 216
    to = tmp___9;
    {
#line 217
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 217
      tmp = *(id + higain);
#line 217
      *(id + higain) = *(ed + higain);
#line 217
      *(ed + higain) = tmp;
#line 217
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 218
    if (*(ed + higain) == 0L) {
#line 218
      if (*(bndptr + higain) != -1L) {
#line 218
        if (*(xadj + higain) < *(xadj + (higain + 1L))) {
          {
#line 219
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 219
            nbnd --;
#line 219
            *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 219
            *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 219
            *(bndptr + higain) = (idxtype )-1;
#line 219
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
        } else {
#line 218
          goto _L___4;
        }
      } else {
#line 218
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 220
    if (*(ed + higain) > 0L) {
#line 220
      if (*(bndptr + higain) == -1L) {
        {
#line 221
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 221
          *(bndind + nbnd) = higain;
#line 221
          tmp___10 = nbnd;
#line 221
          nbnd ++;
#line 221
          *(bndptr + higain) = tmp___10;
#line 221
          goto while_break___20;
        }
        while_break___20: /* CIL Label */ ;
        }
      }
    }
    {
#line 223
    __saxpy(ncon, (float )1.0, nvwgt + higain * ncon, 1L, npwgts + to * ncon, 1L);
#line 224
    __saxpy(ncon, (float )(- 1.0), nvwgt + higain * ncon, 1L, npwgts + ((to + 1L) % 2L) * ncon,
            1L);
#line 225
    j = *(xadj + higain);
    }
    {
#line 225
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 225
      if (! (j < *(xadj + (higain + 1L)))) {
#line 225
        goto while_break___21;
      }
#line 226
      k = *(adjncy + j);
#line 228
      if (to == *(where + k)) {
#line 228
        kwgt = *(adjwgt + j);
      } else {
#line 228
        kwgt = - *(adjwgt + j);
      }
      {
#line 229
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 229
        *(id + k) += kwgt;
#line 229
        *(ed + k) -= kwgt;
#line 229
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 231
      if (*(bndptr + k) != -1L) {
#line 231
        if (*(ed + k) == 0L) {
          {
#line 232
          while (1) {
            while_continue___23: /* CIL Label */ ;
#line 232
            nbnd --;
#line 232
            *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 232
            *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 232
            *(bndptr + k) = (idxtype )-1;
#line 232
            goto while_break___23;
          }
          while_break___23: /* CIL Label */ ;
          }
        }
      }
#line 233
      if (*(bndptr + k) == -1L) {
#line 233
        if (*(ed + k) > 0L) {
          {
#line 234
          while (1) {
            while_continue___24: /* CIL Label */ ;
#line 234
            *(bndind + nbnd) = k;
#line 234
            tmp___11 = nbnd;
#line 234
            nbnd ++;
#line 234
            *(bndptr + k) = tmp___11;
#line 234
            goto while_break___24;
          }
          while_break___24: /* CIL Label */ ;
          }
        }
      }
#line 225
      j ++;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 213
    nswaps --;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 238
  if (ctrl->dbglvl & 8L) {
    {
#line 239
    printf((char const   */* __restrict  */)"\tMincut: %6ld at %5ld, NBND: %6ld, NPwgts: [",
           mincut, mincutorder, nbnd);
#line 240
    l = 0L;
    }
    {
#line 240
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 240
      if (! (l < ncon)) {
#line 240
        goto while_break___25;
      }
      {
#line 241
      printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
             (double )*(npwgts + (ncon + l)));
#line 240
      l ++;
      }
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 242
    tmp___12 = __Compute2WayHLoadImbalance(ncon, npwgts, tpwgts);
#line 242
    printf((char const   */* __restrict  */)"], LB: %.3f\n", (double )tmp___12);
    }
  }
#line 245
  graph->mincut = mincut;
#line 246
  graph->nbnd = nbnd;
#line 249
  i = 0L;
  {
#line 249
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 249
    if (! (i < ncon)) {
#line 249
      goto while_break___26;
    }
    {
#line 250
    __PQueueFree(ctrl, & parts[i][0]);
#line 251
    __PQueueFree(ctrl, & parts[i][1]);
#line 249
    i ++;
    }
  }
  while_break___26: /* CIL Label */ ;
  }
  {
#line 254
  __idxwspacefree(ctrl, nvtxs);
#line 255
  __idxwspacefree(ctrl, nvtxs);
#line 256
  __idxwspacefree(ctrl, nvtxs);
#line 257
  __idxwspacefree(ctrl, nvtxs);
  }
#line 259
  return;
}
}
#line 38 "./proto.h"
long __ComputeCut(GraphType *graph , idxtype *where ) ;
#line 39
long __CheckBnd(GraphType *graph ) ;
#line 40
long __CheckBnd2(GraphType *graph ) ;
#line 41
long __CheckNodeBnd(GraphType *graph , long onbnd ) ;
#line 42
long __CheckRInfo(RInfoType *rinfo ) ;
#line 43
long __CheckNodePartitionParams(GraphType *graph ) ;
#line 44
long __IsSeparable(GraphType *graph ) ;
#line 20 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/debug.c"
long __ComputeCut(GraphType *graph , idxtype *where ) 
{ 
  long i ;
  long j ;
  long cut ;

  {
#line 24
  if ((unsigned long )graph->adjwgt == (unsigned long )((void *)0)) {
#line 25
    cut = 0L;
#line 25
    i = 0L;
    {
#line 25
    while (1) {
      while_continue: /* CIL Label */ ;
#line 25
      if (! (i < graph->nvtxs)) {
#line 25
        goto while_break;
      }
#line 26
      j = *(graph->xadj + i);
      {
#line 26
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 26
        if (! (j < *(graph->xadj + (i + 1L)))) {
#line 26
          goto while_break___0;
        }
#line 27
        if (*(where + i) != *(where + *(graph->adjncy + j))) {
#line 28
          cut ++;
        }
#line 26
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 25
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 32
    cut = 0L;
#line 32
    i = 0L;
    {
#line 32
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 32
      if (! (i < graph->nvtxs)) {
#line 32
        goto while_break___1;
      }
#line 33
      j = *(graph->xadj + i);
      {
#line 33
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 33
        if (! (j < *(graph->xadj + (i + 1L)))) {
#line 33
          goto while_break___2;
        }
#line 34
        if (*(where + i) != *(where + *(graph->adjncy + j))) {
#line 35
          cut += *(graph->adjwgt + j);
        }
#line 33
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 32
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 39
  return (cut / 2L);
}
}
#line 46 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/debug.c"
long __CheckBnd(GraphType *graph ) 
{ 
  long i ;
  long j ;
  long nvtxs ;
  long nbnd ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *where ;
  idxtype *bndptr ;
  idxtype *bndind ;

  {
#line 51
  nvtxs = graph->nvtxs;
#line 52
  xadj = graph->xadj;
#line 53
  adjncy = graph->adjncy;
#line 54
  where = graph->where;
#line 55
  bndptr = graph->bndptr;
#line 56
  bndind = graph->bndind;
#line 58
  nbnd = 0L;
#line 58
  i = 0L;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i < nvtxs)) {
#line 58
      goto while_break;
    }
#line 59
    if (*(xadj + (i + 1L)) - *(xadj + i) == 0L) {
#line 60
      nbnd ++;
    }
#line 62
    j = *(xadj + i);
    {
#line 62
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 62
      if (! (j < *(xadj + (i + 1L)))) {
#line 62
        goto while_break___0;
      }
#line 63
      if (*(where + i) != *(where + *(adjncy + j))) {
#line 64
        nbnd ++;
#line 67
        goto while_break___0;
      }
#line 62
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 58
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return (1L);
}
}
#line 82 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/debug.c"
long __CheckBnd2(GraphType *graph ) 
{ 
  long i ;
  long j ;
  long nvtxs ;
  long nbnd ;
  long id ;
  long ed ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *where ;
  idxtype *bndptr ;
  idxtype *bndind ;

  {
#line 87
  nvtxs = graph->nvtxs;
#line 88
  xadj = graph->xadj;
#line 89
  adjncy = graph->adjncy;
#line 90
  where = graph->where;
#line 91
  bndptr = graph->bndptr;
#line 92
  bndind = graph->bndind;
#line 94
  nbnd = 0L;
#line 94
  i = 0L;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (i < nvtxs)) {
#line 94
      goto while_break;
    }
#line 95
    ed = 0L;
#line 95
    id = ed;
#line 96
    j = *(xadj + i);
    {
#line 96
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 96
      if (! (j < *(xadj + (i + 1L)))) {
#line 96
        goto while_break___0;
      }
#line 97
      if (*(where + i) != *(where + *(adjncy + j))) {
#line 98
        ed += *(graph->adjwgt + j);
      } else {
#line 100
        id += *(graph->adjwgt + j);
      }
#line 96
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 102
    if (ed - id >= 0L) {
#line 102
      if (*(xadj + i) < *(xadj + (i + 1L))) {
#line 103
        nbnd ++;
      }
    }
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return (1L);
}
}
#line 117 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/debug.c"
long __CheckNodeBnd(GraphType *graph , long onbnd ) 
{ 
  long i ;
  long nvtxs ;
  long nbnd ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *where ;
  idxtype *bndptr ;
  idxtype *bndind ;

  {
#line 122
  nvtxs = graph->nvtxs;
#line 123
  xadj = graph->xadj;
#line 124
  adjncy = graph->adjncy;
#line 125
  where = graph->where;
#line 126
  bndptr = graph->bndptr;
#line 127
  bndind = graph->bndind;
#line 129
  nbnd = 0L;
#line 129
  i = 0L;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (i < nvtxs)) {
#line 129
      goto while_break;
    }
#line 130
    if (*(where + i) == 2L) {
#line 131
      nbnd ++;
    }
#line 129
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  i = 0L;
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 136
    if (! (i < nvtxs)) {
#line 136
      goto while_break___0;
    }
#line 136
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 145
  return (1L);
}
}
#line 153 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/debug.c"
long __CheckRInfo(RInfoType *rinfo ) 
{ 
  long i ;
  long j ;

  {
#line 157
  i = 0L;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i < rinfo->ndegrees)) {
#line 157
      goto while_break;
    }
#line 158
    j = i + 1L;
    {
#line 158
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 158
      if (! (j < rinfo->ndegrees)) {
#line 158
        goto while_break___0;
      }
#line 158
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 157
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return (1L);
}
}
#line 170 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/debug.c"
long __CheckNodePartitionParams(GraphType *graph ) 
{ 
  long i ;
  long j ;
  long nvtxs ;
  long me ;
  long other ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *vwgt ;
  idxtype *where ;
  idxtype edegrees[2] ;
  idxtype pwgts[3] ;

  {
#line 176
  nvtxs = graph->nvtxs;
#line 177
  xadj = graph->xadj;
#line 178
  vwgt = graph->vwgt;
#line 179
  adjncy = graph->adjncy;
#line 180
  adjwgt = graph->adjwgt;
#line 182
  where = graph->where;
#line 187
  pwgts[2] = (idxtype )0;
#line 187
  pwgts[1] = pwgts[2];
#line 187
  pwgts[0] = pwgts[1];
#line 188
  i = 0L;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (i < nvtxs)) {
#line 188
      goto while_break;
    }
#line 189
    me = *(where + i);
#line 190
    pwgts[me] += *(vwgt + i);
#line 192
    if (me == 2L) {
#line 193
      edegrees[1] = (idxtype )0;
#line 193
      edegrees[0] = edegrees[1];
#line 195
      j = *(xadj + i);
      {
#line 195
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 195
        if (! (j < *(xadj + (i + 1L)))) {
#line 195
          goto while_break___0;
        }
#line 196
        other = *(where + *(adjncy + j));
#line 197
        if (other != 2L) {
#line 198
          edegrees[other] += *(vwgt + *(adjncy + j));
        }
#line 195
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 200
      if (edegrees[0] != (graph->nrinfo + i)->edegrees[0]) {
        {
#line 201
        printf((char const   */* __restrict  */)"Something wrong with edegrees: %ld %ld %ld %ld %ld\n",
               i, edegrees[0], edegrees[1], (graph->nrinfo + i)->edegrees[0], (graph->nrinfo + i)->edegrees[1]);
        }
#line 202
        return (0L);
      } else
#line 200
      if (edegrees[1] != (graph->nrinfo + i)->edegrees[1]) {
        {
#line 201
        printf((char const   */* __restrict  */)"Something wrong with edegrees: %ld %ld %ld %ld %ld\n",
               i, edegrees[0], edegrees[1], (graph->nrinfo + i)->edegrees[0], (graph->nrinfo + i)->edegrees[1]);
        }
#line 202
        return (0L);
      }
    }
#line 188
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  if (pwgts[0] != *(graph->pwgts + 0)) {
    {
#line 208
    printf((char const   */* __restrict  */)"Something wrong with part-weights: %ld %ld %ld %ld %ld %ld\n",
           pwgts[0], pwgts[1], pwgts[2], *(graph->pwgts + 0), *(graph->pwgts + 1),
           *(graph->pwgts + 2));
    }
  } else
#line 207
  if (pwgts[1] != *(graph->pwgts + 1)) {
    {
#line 208
    printf((char const   */* __restrict  */)"Something wrong with part-weights: %ld %ld %ld %ld %ld %ld\n",
           pwgts[0], pwgts[1], pwgts[2], *(graph->pwgts + 0), *(graph->pwgts + 1),
           *(graph->pwgts + 2));
    }
  } else
#line 207
  if (pwgts[2] != *(graph->pwgts + 2)) {
    {
#line 208
    printf((char const   */* __restrict  */)"Something wrong with part-weights: %ld %ld %ld %ld %ld %ld\n",
           pwgts[0], pwgts[1], pwgts[2], *(graph->pwgts + 0), *(graph->pwgts + 1),
           *(graph->pwgts + 2));
    }
  }
#line 210
  return (1L);
}
}
#line 217 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/debug.c"
long __IsSeparable(GraphType *graph ) 
{ 
  long i ;
  long j ;
  long nvtxs ;
  long other ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *where ;

  {
#line 222
  nvtxs = graph->nvtxs;
#line 223
  xadj = graph->xadj;
#line 224
  adjncy = graph->adjncy;
#line 225
  where = graph->where;
#line 227
  i = 0L;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (i < nvtxs)) {
#line 227
      goto while_break;
    }
#line 228
    if (*(where + i) == 2L) {
#line 229
      goto __Cont;
    }
#line 230
    other = (*(where + i) + 1L) % 2L;
#line 231
    j = *(xadj + i);
    {
#line 231
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 231
      if (! (j < *(xadj + (i + 1L)))) {
#line 231
        goto while_break___0;
      }
#line 231
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return (1L);
}
}
#line 34 "./proto.h"
void __CompressGraph(CtrlType *ctrl , GraphType *graph , long nvtxs , idxtype *xadj ,
                     idxtype *adjncy , idxtype *cptr , idxtype *cind ) ;
#line 150
long __MlevelKWayPartitioning(CtrlType *ctrl , GraphType *graph , long nparts , idxtype *part ,
                              float *tpwgts , float ubfactor ) ;
#line 344
void __MlevelNodeBisectionMultiple(CtrlType *ctrl , GraphType *graph , long *tpwgts ,
                                   float ubfactor ) ;
#line 346
void __SplitGraphOrder(CtrlType *ctrl , GraphType *graph , GraphType *lgraph , GraphType *rgraph ) ;
#line 347
void __MMDOrder(CtrlType *ctrl , GraphType *graph , idxtype *order , long lastvtx ) ;
#line 351
void METIS_PartGraphKway2(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                          long *options , long *edgecut , idxtype *part ) ;
#line 352
void METIS_WPartGraphKway2(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                           idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                           float *tpwgts , long *options , long *edgecut , idxtype *part ) ;
#line 353
void METIS_NodeNDP(long nvtxs , idxtype *xadj , idxtype *adjncy , long npes , long *options ,
                   idxtype *perm , idxtype *iperm , idxtype *sizes ) ;
#line 354
void __MlevelNestedDissectionP(CtrlType *ctrl , GraphType *graph , idxtype *order ,
                               long lastvtx , long npes , long cpos , idxtype *sizes ) ;
#line 355
void METIS_NodeComputeSeparator(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                                idxtype *adjwgt , long *options , long *sepsize ,
                                idxtype *part ) ;
#line 356
void METIS_EdgeComputeSeparator(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                                idxtype *adjwgt , long *options , long *sepsize ,
                                idxtype *part ) ;
#line 22 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/parmetis.c"
void METIS_PartGraphKway2(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                          long *options , long *edgecut , idxtype *part ) 
{ 
  long i ;
  float *tpwgts ;

  {
  {
#line 29
  tpwgts = __fmalloc(*nparts, (char *)"KMETIS: tpwgts");
#line 30
  i = 0L;
  }
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (i < *nparts)) {
#line 30
      goto while_break;
    }
#line 31
    *(tpwgts + i) = (float )(1.0 / (1.0 * (double )*nparts));
#line 30
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 33
  METIS_WPartGraphKway2(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                        tpwgts, options, edgecut, part);
#line 36
  free((void *)tpwgts);
  }
#line 37
  return;
}
}
#line 44 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/parmetis.c"
void METIS_WPartGraphKway2(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                           idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                           float *tpwgts , long *options , long *edgecut , idxtype *part ) 
{ 
  GraphType graph ;
  CtrlType ctrl ;
  long tmp ;
  long tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 52
  if (*numflag == 1L) {
    {
#line 53
    __Change2CNumbering(*nvtxs, xadj, adjncy);
    }
  }
  {
#line 55
  __SetUpGraph(& graph, 2L, *nvtxs, 1L, xadj, adjncy, vwgt, adjwgt, *wgtflag);
  }
#line 57
  if (*(options + 0) == 0L) {
#line 58
    ctrl.CType = 3L;
#line 59
    ctrl.IType = 1L;
#line 60
    ctrl.RType = 3L;
#line 61
    ctrl.dbglvl = 0L;
  } else {
#line 64
    ctrl.CType = *(options + 1);
#line 65
    ctrl.IType = *(options + 2);
#line 66
    ctrl.RType = *(options + 3);
#line 67
    ctrl.dbglvl = *(options + 4);
  }
#line 69
  ctrl.optype = 2L;
#line 70
  ctrl.CoarsenTo = 20L * *nparts;
#line 71
  if (graph.vwgt) {
    {
#line 71
    tmp = __idxsum(*nvtxs, graph.vwgt);
#line 71
    tmp___0 = tmp;
    }
  } else {
#line 71
    tmp___0 = *nvtxs;
  }
  {
#line 71
  ctrl.maxvwgt = (long )(1.5 * (double )(tmp___0 / ctrl.CoarsenTo));
#line 73
  __InitRandom(*(options + 7));
#line 75
  __AllocateWorkSpace(& ctrl, & graph, *nparts);
  }
#line 77
  if (ctrl.dbglvl & 1L) {
    {
#line 77
    __InitTimers(& ctrl);
    }
  }
#line 78
  if (ctrl.dbglvl & 1L) {
    {
#line 78
    tmp___1 = __seconds();
#line 78
    ctrl.TotalTmr -= tmp___1;
    }
  }
  {
#line 80
  *edgecut = __MlevelKWayPartitioning(& ctrl, & graph, *nparts, part, tpwgts, (float )1.03);
  }
#line 82
  if (ctrl.dbglvl & 1L) {
    {
#line 82
    tmp___2 = __seconds();
#line 82
    ctrl.TotalTmr += tmp___2;
    }
  }
#line 83
  if (ctrl.dbglvl & 1L) {
    {
#line 83
    __PrintTimers(& ctrl);
    }
  }
  {
#line 85
  __FreeWorkSpace(& ctrl, & graph);
  }
#line 87
  if (*numflag == 1L) {
    {
#line 88
    __Change2FNumbering(*nvtxs, xadj, adjncy, part);
    }
  }
#line 89
  return;
}
}
#line 95 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/parmetis.c"
void METIS_NodeNDP(long nvtxs , idxtype *xadj , idxtype *adjncy , long npes , long *options ,
                   idxtype *perm , idxtype *iperm , idxtype *sizes ) 
{ 
  long i ;
  long ii ;
  long j ;
  long l ;
  GraphType graph ;
  CtrlType ctrl ;
  idxtype *cptr ;
  idxtype *cind ;
  double tmp ;
  long tmp___0 ;
  long tmp___1 ;
  double tmp___2 ;

  {
#line 103
  if (*(options + 0) == 0L) {
#line 104
    ctrl.CType = 3L;
#line 105
    ctrl.IType = 1L;
#line 106
    ctrl.RType = 2L;
#line 107
    ctrl.dbglvl = 0L;
#line 108
    ctrl.oflags = 1L;
#line 109
    ctrl.pfactor = -1L;
#line 110
    ctrl.nseps = 1L;
  } else {
#line 113
    ctrl.CType = *(options + 1);
#line 114
    ctrl.IType = *(options + 2);
#line 115
    ctrl.RType = *(options + 3);
#line 116
    ctrl.dbglvl = *(options + 4);
#line 117
    ctrl.oflags = *(options + 5);
#line 118
    ctrl.pfactor = *(options + 6);
#line 119
    ctrl.nseps = *(options + 7);
  }
#line 121
  if (ctrl.nseps < 1L) {
#line 122
    ctrl.nseps = 1L;
  }
#line 124
  ctrl.optype = 4L;
#line 125
  ctrl.CoarsenTo = 100L;
#line 127
  if (ctrl.dbglvl & 1L) {
    {
#line 127
    __InitTimers(& ctrl);
    }
  }
#line 128
  if (ctrl.dbglvl & 1L) {
    {
#line 128
    tmp = __seconds();
#line 128
    ctrl.TotalTmr -= tmp;
    }
  }
  {
#line 130
  __InitRandom(-1L);
  }
#line 132
  if (ctrl.oflags & 1L) {
    {
#line 136
    cptr = __idxmalloc(nvtxs + 1L, (char *)"ONMETIS: cptr");
#line 137
    cind = __idxmalloc(nvtxs, (char *)"ONMETIS: cind");
#line 139
    __CompressGraph(& ctrl, & graph, nvtxs, xadj, adjncy, cptr, cind);
    }
#line 141
    if ((double )graph.nvtxs >= 0.85 * (double )nvtxs) {
      {
#line 142
      (ctrl.oflags) --;
#line 143
      __GKfree(& cptr, & cind, (void **)0);
      }
    } else
#line 145
    if (2L * graph.nvtxs < nvtxs) {
#line 145
      if (ctrl.nseps == 1L) {
#line 146
        ctrl.nseps = 2L;
      }
    }
  } else {
    {
#line 149
    __SetUpGraph(& graph, 4L, nvtxs, 1L, xadj, adjncy, (idxtype *)((void *)0), (idxtype *)((void *)0),
                 0L);
    }
  }
  {
#line 156
  tmp___0 = __idxsum(graph.nvtxs, graph.vwgt);
#line 156
  ctrl.maxvwgt = (long )(1.5 * (double )(tmp___0 / ctrl.CoarsenTo));
#line 157
  __AllocateWorkSpace(& ctrl, & graph, 2L);
#line 159
  __idxset(2L * npes - 1L, (idxtype )0, sizes);
#line 160
  __MlevelNestedDissectionP(& ctrl, & graph, iperm, graph.nvtxs, npes, 0L, sizes);
#line 162
  __FreeWorkSpace(& ctrl, & graph);
  }
#line 164
  if (ctrl.oflags & 1L) {
#line 165
    if ((double )graph.nvtxs < 0.85 * (double )nvtxs) {
#line 167
      i = 0L;
      {
#line 167
      while (1) {
        while_continue: /* CIL Label */ ;
#line 167
        if (! (i < graph.nvtxs)) {
#line 167
          goto while_break;
        }
#line 168
        *(perm + *(iperm + i)) = i;
#line 167
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 169
      ii = 0L;
#line 169
      l = ii;
      {
#line 169
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 169
        if (! (ii < graph.nvtxs)) {
#line 169
          goto while_break___0;
        }
#line 170
        i = *(perm + ii);
#line 171
        j = *(cptr + i);
        {
#line 171
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 171
          if (! (j < *(cptr + (i + 1L)))) {
#line 171
            goto while_break___1;
          }
#line 172
          tmp___1 = l;
#line 172
          l ++;
#line 172
          *(iperm + *(cind + j)) = tmp___1;
#line 171
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 169
        ii ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 176
    __GKfree(& cptr, & cind, (void **)0);
    }
  }
#line 180
  i = 0L;
  {
#line 180
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 180
    if (! (i < nvtxs)) {
#line 180
      goto while_break___2;
    }
#line 181
    *(perm + *(iperm + i)) = i;
#line 180
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 183
  if (ctrl.dbglvl & 1L) {
    {
#line 183
    tmp___2 = __seconds();
#line 183
    ctrl.TotalTmr += tmp___2;
    }
  }
#line 184
  if (ctrl.dbglvl & 1L) {
    {
#line 184
    __PrintTimers(& ctrl);
    }
  }
#line 186
  return;
}
}
#line 193 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/parmetis.c"
void __MlevelNestedDissectionP(CtrlType *ctrl , GraphType *graph , idxtype *order ,
                               long lastvtx , long npes , long cpos , idxtype *sizes ) 
{ 
  long i ;
  long nvtxs ;
  long nbnd ;
  long tvwgt ;
  long tpwgts2[2] ;
  idxtype *label ;
  idxtype *bndind ;
  GraphType lgraph ;
  GraphType rgraph ;
  float ubfactor ;

  {
#line 201
  nvtxs = graph->nvtxs;
#line 203
  if (nvtxs == 0L) {
    {
#line 204
    __GKfree(& graph->gdata, & graph->rdata, & graph->label, (void **)0);
    }
#line 205
    return;
  }
  {
#line 209
  tvwgt = __idxsum(nvtxs, graph->vwgt);
#line 210
  tpwgts2[0] = tvwgt / 2L;
#line 211
  tpwgts2[1] = tvwgt - tpwgts2[0];
  }
#line 213
  if (cpos >= npes - 1L) {
#line 214
    ubfactor = (float )1.10;
  } else {
#line 216
    ubfactor = (float )1.05;
  }
  {
#line 219
  __MlevelNodeBisectionMultiple(ctrl, graph, tpwgts2, ubfactor);
  }
#line 221
  if (ctrl->dbglvl & 128L) {
    {
#line 221
    printf((char const   */* __restrict  */)"Nvtxs: %6ld, [%6ld %6ld %6ld]\n", graph->nvtxs,
           *(graph->pwgts + 0), *(graph->pwgts + 1), *(graph->pwgts + 2));
    }
  }
#line 223
  if (cpos < npes - 1L) {
#line 224
    *(sizes + ((2L * npes - 2L) - cpos)) = *(graph->pwgts + 2);
#line 225
    *(sizes + ((2L * npes - 2L) - (2L * cpos + 1L))) = *(graph->pwgts + 1);
#line 226
    *(sizes + ((2L * npes - 2L) - (2L * cpos + 2L))) = *(graph->pwgts + 0);
  }
#line 230
  nbnd = graph->nbnd;
#line 231
  bndind = graph->bndind;
#line 232
  label = graph->label;
#line 233
  i = 0L;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (i < nbnd)) {
#line 233
      goto while_break;
    }
#line 234
    lastvtx --;
#line 234
    *(order + *(label + *(bndind + i))) = lastvtx;
#line 233
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 236
  __SplitGraphOrder(ctrl, graph, & lgraph, & rgraph);
#line 239
  __GKfree(& graph->gdata, & graph->rdata, & graph->label, (void **)0);
  }
#line 241
  if (rgraph.nvtxs > 200L) {
    {
#line 242
    __MlevelNestedDissectionP(ctrl, & rgraph, order, lastvtx, npes, 2L * cpos + 1L,
                              sizes);
    }
  } else
#line 241
  if (2L * cpos + 1L < npes - 1L) {
    {
#line 242
    __MlevelNestedDissectionP(ctrl, & rgraph, order, lastvtx, npes, 2L * cpos + 1L,
                              sizes);
    }
  } else {
    {
#line 244
    __MMDOrder(ctrl, & rgraph, order, lastvtx);
#line 245
    __GKfree(& rgraph.gdata, & rgraph.rdata, & rgraph.label, (void **)0);
    }
  }
#line 247
  if (lgraph.nvtxs > 200L) {
    {
#line 248
    __MlevelNestedDissectionP(ctrl, & lgraph, order, lastvtx - rgraph.nvtxs, npes,
                              2L * cpos + 2L, sizes);
    }
  } else
#line 247
  if (2L * cpos + 2L < npes - 1L) {
    {
#line 248
    __MlevelNestedDissectionP(ctrl, & lgraph, order, lastvtx - rgraph.nvtxs, npes,
                              2L * cpos + 2L, sizes);
    }
  } else {
    {
#line 250
    __MMDOrder(ctrl, & lgraph, order, lastvtx - rgraph.nvtxs);
#line 251
    __GKfree(& lgraph.gdata, & lgraph.rdata, & lgraph.label, (void **)0);
    }
  }
#line 253
  return;
}
}
#line 262 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/parmetis.c"
void METIS_NodeComputeSeparator(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                                idxtype *adjwgt , long *options , long *sepsize ,
                                idxtype *part ) 
{ 
  long tvwgt ;
  long tpwgts[2] ;
  GraphType graph ;
  CtrlType ctrl ;

  {
  {
#line 269
  __SetUpGraph(& graph, 4L, *nvtxs, 1L, xadj, adjncy, vwgt, adjwgt, 3L);
#line 270
  tvwgt = __idxsum(*nvtxs, graph.vwgt);
  }
#line 272
  if (*(options + 0) == 0L) {
#line 273
    ctrl.CType = 3L;
#line 274
    ctrl.IType = 1L;
#line 275
    ctrl.RType = 2L;
#line 276
    ctrl.dbglvl = 0L;
  } else {
#line 279
    ctrl.CType = *(options + 1);
#line 280
    ctrl.IType = *(options + 2);
#line 281
    ctrl.RType = *(options + 3);
#line 282
    ctrl.dbglvl = *(options + 4);
  }
#line 285
  ctrl.oflags = 0L;
#line 286
  ctrl.pfactor = 0L;
#line 287
  ctrl.nseps = 1L;
#line 288
  ctrl.optype = 4L;
#line 289
  if (100L >= *nvtxs - 1L) {
#line 289
    ctrl.CoarsenTo = *nvtxs - 1L;
  } else {
#line 289
    ctrl.CoarsenTo = 100L;
  }
  {
#line 290
  ctrl.maxvwgt = (long )((1.5 * (double )tvwgt) / (double )ctrl.CoarsenTo);
#line 292
  __InitRandom(*(options + 7));
#line 294
  __AllocateWorkSpace(& ctrl, & graph, 2L);
#line 299
  tpwgts[0] = tvwgt / 2L;
#line 300
  tpwgts[1] = tvwgt - tpwgts[0];
#line 302
  __MlevelNodeBisectionMultiple(& ctrl, & graph, tpwgts, (float )1.05);
#line 304
  *sepsize = *(graph.pwgts + 2);
#line 305
  memcpy((void */* __restrict  */)((void *)part), (void const   */* __restrict  */)((void *)graph.where),
         sizeof(idxtype ) * (unsigned long )*nvtxs);
#line 307
  __GKfree(& graph.gdata, & graph.rdata, & graph.label, (void **)0);
#line 310
  __FreeWorkSpace(& ctrl, & graph);
  }
#line 312
  return;
}
}
#line 320 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/parmetis.c"
void METIS_EdgeComputeSeparator(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                                idxtype *adjwgt , long *options , long *sepsize ,
                                idxtype *part ) 
{ 
  long tvwgt ;
  long tpwgts[2] ;
  GraphType graph ;
  CtrlType ctrl ;

  {
  {
#line 327
  __SetUpGraph(& graph, 4L, *nvtxs, 1L, xadj, adjncy, vwgt, adjwgt, 3L);
#line 328
  tvwgt = __idxsum(*nvtxs, graph.vwgt);
  }
#line 330
  if (*(options + 0) == 0L) {
#line 331
    ctrl.CType = 3L;
#line 332
    ctrl.IType = 1L;
#line 333
    ctrl.RType = 2L;
#line 334
    ctrl.dbglvl = 0L;
  } else {
#line 337
    ctrl.CType = *(options + 1);
#line 338
    ctrl.IType = *(options + 2);
#line 339
    ctrl.RType = *(options + 3);
#line 340
    ctrl.dbglvl = *(options + 4);
  }
#line 343
  ctrl.oflags = 0L;
#line 344
  ctrl.pfactor = 0L;
#line 345
  ctrl.nseps = 1L;
#line 346
  ctrl.optype = 3L;
#line 347
  if (100L >= *nvtxs - 1L) {
#line 347
    ctrl.CoarsenTo = *nvtxs - 1L;
  } else {
#line 347
    ctrl.CoarsenTo = 100L;
  }
  {
#line 348
  ctrl.maxvwgt = (long )((1.5 * (double )tvwgt) / (double )ctrl.CoarsenTo);
#line 350
  __InitRandom(*(options + 7));
#line 352
  __AllocateWorkSpace(& ctrl, & graph, 2L);
#line 357
  tpwgts[0] = tvwgt / 2L;
#line 358
  tpwgts[1] = tvwgt - tpwgts[0];
#line 360
  __MlevelEdgeBisection(& ctrl, & graph, tpwgts, (float )1.05);
#line 361
  __ConstructMinCoverSeparator(& ctrl, & graph, (float )1.05);
#line 363
  *sepsize = *(graph.pwgts + 2);
#line 364
  memcpy((void */* __restrict  */)((void *)part), (void const   */* __restrict  */)((void *)graph.where),
         sizeof(idxtype ) * (unsigned long )*nvtxs);
#line 366
  __GKfree(& graph.gdata, & graph.rdata, & graph.label, (void **)0);
#line 369
  __FreeWorkSpace(& ctrl, & graph);
  }
#line 371
  return;
}
}
#line 205 "./proto.h"
void __MocGeneral2WayBalance2(CtrlType *ctrl , GraphType *graph , float *tpwgts ,
                              float *ubvec ) ;
#line 206
void __SelectQueue3(long ncon , float *npwgts , float *tpwgts , long *from , long *cnum ,
                    PQueueType (*queues)[2] , float *maxwgt ) ;
#line 22 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mbalance2.c"
void __MocBalance2Way2(CtrlType *ctrl , GraphType *graph , float *tpwgts , float *ubvec ) 
{ 
  float tvec[16] ;
  long tmp ;

  {
  {
#line 27
  __Compute2WayHLoadImbalanceVec(graph->ncon, graph->npwgts, tpwgts, tvec);
#line 28
  tmp = __AreAllBelow(graph->ncon, tvec, ubvec);
  }
#line 28
  if (! tmp) {
    {
#line 29
    __MocGeneral2WayBalance2(ctrl, graph, tpwgts, ubvec);
    }
  }
#line 30
  return;
}
}
#line 37 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mbalance2.c"
void __MocGeneral2WayBalance2(CtrlType *ctrl , GraphType *graph , float *tpwgts ,
                              float *ubvec ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long l ;
  long kwgt ;
  long nvtxs ;
  long ncon ;
  long nbnd ;
  long nswaps ;
  long from ;
  long to ;
  long limit ;
  long tmp ;
  long cnum ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *id ;
  idxtype *ed ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *moved ;
  idxtype *swaps ;
  idxtype *perm ;
  idxtype *qnum ;
  float *nvwgt ;
  float *npwgts ;
  float origbal[16] ;
  float minbal[16] ;
  float newbal[16] ;
  PQueueType parts[16][2] ;
  long higain ;
  long oldgain ;
  long mincut ;
  long newcut ;
  long mincutorder ;
  float *maxwgt ;
  float *minwgt ;
  float tvec[16] ;
  double tmp___1 ;
  double tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  idxtype tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  {
#line 48
  nvtxs = graph->nvtxs;
#line 49
  ncon = graph->ncon;
#line 50
  xadj = graph->xadj;
#line 51
  nvwgt = graph->nvwgt;
#line 52
  adjncy = graph->adjncy;
#line 53
  adjwgt = graph->adjwgt;
#line 54
  where = graph->where;
#line 55
  id = graph->id;
#line 56
  ed = graph->ed;
#line 57
  npwgts = graph->npwgts;
#line 58
  bndptr = graph->bndptr;
#line 59
  bndind = graph->bndind;
#line 61
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 62
  swaps = __idxwspacemalloc(ctrl, nvtxs);
#line 63
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 64
  qnum = __idxwspacemalloc(ctrl, nvtxs);
  }
#line 66
  if (0.01 * (double )nvtxs >= (double )15) {
#line 66
    tmp___2 = 0.01 * (double )nvtxs;
  } else {
#line 66
    tmp___2 = (double )15;
  }
#line 66
  if (tmp___2 >= (double )100) {
#line 66
    limit = 100L;
  } else {
#line 66
    if (0.01 * (double )nvtxs >= (double )15) {
#line 66
      tmp___1 = 0.01 * (double )nvtxs;
    } else {
#line 66
      tmp___1 = (double )15;
    }
#line 66
    limit = (long )tmp___1;
  }
  {
#line 69
  minwgt = __fwspacemalloc(ctrl, 2L * ncon);
#line 70
  maxwgt = __fwspacemalloc(ctrl, 2L * ncon);
#line 72
  i = 0L;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! (i < 2L)) {
#line 72
      goto while_break;
    }
#line 73
    j = 0L;
    {
#line 73
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 73
      if (! (j < ncon)) {
#line 73
        goto while_break___0;
      }
#line 74
      *(maxwgt + (i * ncon + j)) = *(tpwgts + i) * *(ubvec + j);
#line 75
      *(minwgt + (i * ncon + j)) = (float )((double )*(tpwgts + i) * (1.0 / (double )*(ubvec + j)));
#line 73
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 72
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  i = 0L;
  {
#line 81
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 81
    if (! (i < ncon)) {
#line 81
      goto while_break___1;
    }
    {
#line 82
    __PQueueInit(ctrl, & parts[i][0], nvtxs, 501L);
#line 83
    __PQueueInit(ctrl, & parts[i][1], nvtxs, 501L);
#line 81
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 85
  i = 0L;
  {
#line 85
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 85
    if (! (i < nvtxs)) {
#line 85
      goto while_break___2;
    }
    {
#line 86
    *(qnum + i) = __samax(ncon, nvwgt + i * ncon);
#line 85
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 88
  __Compute2WayHLoadImbalanceVec(ncon, npwgts, tpwgts, origbal);
#line 89
  i = 0L;
  }
  {
#line 89
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 89
    if (! (i < ncon)) {
#line 89
      goto while_break___3;
    }
#line 90
    minbal[i] = origbal[i];
#line 89
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 92
  mincut = graph->mincut;
#line 92
  newcut = mincut;
#line 93
  mincutorder = -1L;
#line 95
  if (ctrl->dbglvl & 8L) {
    {
#line 96
    printf((char const   */* __restrict  */)"Parts: [");
#line 97
    l = 0L;
    }
    {
#line 97
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 97
      if (! (l < ncon)) {
#line 97
        goto while_break___4;
      }
      {
#line 98
      printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
             (double )*(npwgts + (ncon + l)));
#line 97
      l ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 99
    printf((char const   */* __restrict  */)"] T[%.3f %.3f], Nv-Nb[%5ld, %5ld]. ICut: %6ld, LB: ",
           (double )*(tpwgts + 0), (double )*(tpwgts + 1), graph->nvtxs, graph->nbnd,
           graph->mincut);
#line 101
    i = 0L;
    }
    {
#line 101
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 101
      if (! (i < ncon)) {
#line 101
        goto while_break___5;
      }
      {
#line 102
      printf((char const   */* __restrict  */)"%.3f ", (double )origbal[i]);
#line 101
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 103
    printf((char const   */* __restrict  */)"[B]\n");
    }
  }
  {
#line 106
  __idxset(nvtxs, (idxtype )-1, moved);
#line 112
  nbnd = graph->nbnd;
#line 113
  __RandomPermute(nvtxs, perm, 1L);
#line 114
  ii = 0L;
  }
  {
#line 114
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 114
    if (! (ii < nvtxs)) {
#line 114
      goto while_break___6;
    }
    {
#line 115
    i = *(perm + ii);
#line 116
    __PQueueInsert(& parts[*(qnum + i)][*(where + i)], i, *(ed + i) - *(id + i));
#line 114
    ii ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 120
  nswaps = 0L;
  {
#line 120
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 120
    if (! (nswaps < nvtxs)) {
#line 120
      goto while_break___7;
    }
    {
#line 121
    tmp___3 = __AreAllBelow(ncon, minbal, ubvec);
    }
#line 121
    if (tmp___3) {
#line 122
      goto while_break___7;
    }
    {
#line 124
    __SelectQueue3(ncon, npwgts, tpwgts, & from, & cnum, (PQueueType (*)[2])(parts),
                   maxwgt);
#line 125
    to = (from + 1L) % 2L;
    }
#line 127
    if (from == -1L) {
#line 128
      goto while_break___7;
    } else {
      {
#line 127
      higain = __PQueueGetMax(& parts[cnum][from]);
      }
#line 127
      if (higain == -1L) {
#line 128
        goto while_break___7;
      }
    }
    {
#line 130
    __saxpy(ncon, (float )1.0, nvwgt + higain * ncon, 1L, npwgts + to * ncon, 1L);
#line 131
    __saxpy(ncon, (float )(- 1.0), nvwgt + higain * ncon, 1L, npwgts + from * ncon,
            1L);
#line 132
    newcut -= *(ed + higain) - *(id + higain);
#line 133
    __Compute2WayHLoadImbalanceVec(ncon, npwgts, tpwgts, newbal);
#line 135
    tmp___4 = __IsBetter2wayBalance(ncon, newbal, minbal, ubvec);
    }
#line 135
    if (tmp___4) {
#line 135
      goto _L;
    } else {
      {
#line 135
      tmp___5 = __IsBetter2wayBalance(ncon, newbal, origbal, ubvec);
      }
#line 135
      if (tmp___5) {
#line 135
        if (newcut < mincut) {
          _L: /* CIL Label */ 
#line 137
          mincut = newcut;
#line 138
          i = 0L;
          {
#line 138
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 138
            if (! (i < ncon)) {
#line 138
              goto while_break___8;
            }
#line 139
            minbal[i] = newbal[i];
#line 138
            i ++;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 140
          mincutorder = nswaps;
        } else {
#line 135
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 142
      if (nswaps - mincutorder > limit) {
        {
#line 143
        newcut += *(ed + higain) - *(id + higain);
#line 144
        __saxpy(ncon, (float )1.0, nvwgt + higain * ncon, 1L, npwgts + from * ncon,
                1L);
#line 145
        __saxpy(ncon, (float )(- 1.0), nvwgt + higain * ncon, 1L, npwgts + to * ncon,
                1L);
        }
#line 146
        goto while_break___7;
      }
    }
#line 149
    *(where + higain) = to;
#line 150
    *(moved + higain) = nswaps;
#line 151
    *(swaps + nswaps) = higain;
#line 153
    if (ctrl->dbglvl & 32L) {
      {
#line 154
      printf((char const   */* __restrict  */)"Moved %6ld from %ld(%ld). Gain: %5ld, Cut: %5ld, NPwgts: ",
             higain, from, cnum, *(ed + higain) - *(id + higain), newcut);
#line 155
      i = 0L;
      }
      {
#line 155
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 155
        if (! (i < ncon)) {
#line 155
          goto while_break___9;
        }
        {
#line 156
        printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + i),
               (double )*(npwgts + (ncon + i)));
#line 155
        i ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 158
      __Compute2WayHLoadImbalanceVec(ncon, npwgts, tpwgts, tvec);
#line 159
      printf((char const   */* __restrict  */)", LB: ");
#line 160
      i = 0L;
      }
      {
#line 160
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 160
        if (! (i < ncon)) {
#line 160
          goto while_break___10;
        }
        {
#line 161
        printf((char const   */* __restrict  */)"%.3f ", (double )tvec[i]);
#line 160
        i ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 162
      if (mincutorder == nswaps) {
        {
#line 163
        printf((char const   */* __restrict  */)" *\n");
        }
      } else {
        {
#line 165
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
    {
#line 172
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 172
      tmp = *(id + higain);
#line 172
      *(id + higain) = *(ed + higain);
#line 172
      *(ed + higain) = tmp;
#line 172
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 173
    if (*(ed + higain) == 0L) {
#line 173
      if (*(bndptr + higain) != -1L) {
#line 173
        if (*(xadj + higain) < *(xadj + (higain + 1L))) {
          {
#line 174
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 174
            nbnd --;
#line 174
            *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 174
            *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 174
            *(bndptr + higain) = (idxtype )-1;
#line 174
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
        }
      }
    }
#line 175
    if (*(ed + higain) > 0L) {
#line 175
      if (*(bndptr + higain) == -1L) {
        {
#line 176
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 176
          *(bndind + nbnd) = higain;
#line 176
          tmp___6 = nbnd;
#line 176
          nbnd ++;
#line 176
          *(bndptr + higain) = tmp___6;
#line 176
          goto while_break___13;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
    }
#line 178
    j = *(xadj + higain);
    {
#line 178
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 178
      if (! (j < *(xadj + (higain + 1L)))) {
#line 178
        goto while_break___14;
      }
#line 179
      k = *(adjncy + j);
#line 180
      oldgain = *(ed + k) - *(id + k);
#line 182
      if (to == *(where + k)) {
#line 182
        kwgt = *(adjwgt + j);
      } else {
#line 182
        kwgt = - *(adjwgt + j);
      }
      {
#line 183
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 183
        *(id + k) += kwgt;
#line 183
        *(ed + k) -= kwgt;
#line 183
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 186
      if (*(moved + k) == -1L) {
        {
#line 187
        __PQueueUpdate(& parts[*(qnum + k)][*(where + k)], k, oldgain, *(ed + k) - *(id + k));
        }
      }
#line 190
      if (*(ed + k) == 0L) {
#line 190
        if (*(bndptr + k) != -1L) {
          {
#line 191
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 191
            nbnd --;
#line 191
            *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 191
            *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 191
            *(bndptr + k) = (idxtype )-1;
#line 191
            goto while_break___16;
          }
          while_break___16: /* CIL Label */ ;
          }
        } else {
#line 190
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 192
      if (*(ed + k) > 0L) {
#line 192
        if (*(bndptr + k) == -1L) {
          {
#line 193
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 193
            *(bndind + nbnd) = k;
#line 193
            tmp___7 = nbnd;
#line 193
            nbnd ++;
#line 193
            *(bndptr + k) = tmp___7;
#line 193
            goto while_break___17;
          }
          while_break___17: /* CIL Label */ ;
          }
        }
      }
#line 178
      j ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 120
    nswaps ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 203
  i = 0L;
  {
#line 203
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 203
    if (! (i < nswaps)) {
#line 203
      goto while_break___18;
    }
#line 204
    *(moved + *(swaps + i)) = (idxtype )-1;
#line 203
    i ++;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 205
  nswaps --;
  {
#line 205
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 205
    if (! (nswaps > mincutorder)) {
#line 205
      goto while_break___19;
    }
#line 206
    higain = *(swaps + nswaps);
#line 208
    tmp___8 = (*(where + higain) + 1L) % 2L;
#line 208
    *(where + higain) = tmp___8;
#line 208
    to = tmp___8;
    {
#line 209
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 209
      tmp = *(id + higain);
#line 209
      *(id + higain) = *(ed + higain);
#line 209
      *(ed + higain) = tmp;
#line 209
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 210
    if (*(ed + higain) == 0L) {
#line 210
      if (*(bndptr + higain) != -1L) {
#line 210
        if (*(xadj + higain) < *(xadj + (higain + 1L))) {
          {
#line 211
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 211
            nbnd --;
#line 211
            *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 211
            *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 211
            *(bndptr + higain) = (idxtype )-1;
#line 211
            goto while_break___21;
          }
          while_break___21: /* CIL Label */ ;
          }
        } else {
#line 210
          goto _L___3;
        }
      } else {
#line 210
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 212
    if (*(ed + higain) > 0L) {
#line 212
      if (*(bndptr + higain) == -1L) {
        {
#line 213
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 213
          *(bndind + nbnd) = higain;
#line 213
          tmp___9 = nbnd;
#line 213
          nbnd ++;
#line 213
          *(bndptr + higain) = tmp___9;
#line 213
          goto while_break___22;
        }
        while_break___22: /* CIL Label */ ;
        }
      }
    }
    {
#line 215
    __saxpy(ncon, (float )1.0, nvwgt + higain * ncon, 1L, npwgts + to * ncon, 1L);
#line 216
    __saxpy(ncon, (float )(- 1.0), nvwgt + higain * ncon, 1L, npwgts + ((to + 1L) % 2L) * ncon,
            1L);
#line 217
    j = *(xadj + higain);
    }
    {
#line 217
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 217
      if (! (j < *(xadj + (higain + 1L)))) {
#line 217
        goto while_break___23;
      }
#line 218
      k = *(adjncy + j);
#line 220
      if (to == *(where + k)) {
#line 220
        kwgt = *(adjwgt + j);
      } else {
#line 220
        kwgt = - *(adjwgt + j);
      }
      {
#line 221
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 221
        *(id + k) += kwgt;
#line 221
        *(ed + k) -= kwgt;
#line 221
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 223
      if (*(bndptr + k) != -1L) {
#line 223
        if (*(ed + k) == 0L) {
          {
#line 224
          while (1) {
            while_continue___25: /* CIL Label */ ;
#line 224
            nbnd --;
#line 224
            *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 224
            *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 224
            *(bndptr + k) = (idxtype )-1;
#line 224
            goto while_break___25;
          }
          while_break___25: /* CIL Label */ ;
          }
        }
      }
#line 225
      if (*(bndptr + k) == -1L) {
#line 225
        if (*(ed + k) > 0L) {
          {
#line 226
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 226
            *(bndind + nbnd) = k;
#line 226
            tmp___10 = nbnd;
#line 226
            nbnd ++;
#line 226
            *(bndptr + k) = tmp___10;
#line 226
            goto while_break___26;
          }
          while_break___26: /* CIL Label */ ;
          }
        }
      }
#line 217
      j ++;
    }
    while_break___23: /* CIL Label */ ;
    }
#line 205
    nswaps --;
  }
  while_break___19: /* CIL Label */ ;
  }
#line 230
  if (ctrl->dbglvl & 8L) {
    {
#line 231
    printf((char const   */* __restrict  */)"\tMincut: %6ld at %5ld, NBND: %6ld, NPwgts: [",
           mincut, mincutorder, nbnd);
#line 232
    i = 0L;
    }
    {
#line 232
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 232
      if (! (i < ncon)) {
#line 232
        goto while_break___27;
      }
      {
#line 233
      printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + i),
             (double )*(npwgts + (ncon + i)));
#line 232
      i ++;
      }
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 234
    printf((char const   */* __restrict  */)"], LB: ");
#line 235
    __Compute2WayHLoadImbalanceVec(ncon, npwgts, tpwgts, tvec);
#line 236
    i = 0L;
    }
    {
#line 236
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 236
      if (! (i < ncon)) {
#line 236
        goto while_break___28;
      }
      {
#line 237
      printf((char const   */* __restrict  */)"%.3f ", (double )tvec[i]);
#line 236
      i ++;
      }
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 238
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 241
  graph->mincut = mincut;
#line 242
  graph->nbnd = nbnd;
#line 245
  i = 0L;
  {
#line 245
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 245
    if (! (i < ncon)) {
#line 245
      goto while_break___29;
    }
    {
#line 246
    __PQueueFree(ctrl, & parts[i][0]);
#line 247
    __PQueueFree(ctrl, & parts[i][1]);
#line 245
    i ++;
    }
  }
  while_break___29: /* CIL Label */ ;
  }
  {
#line 250
  __idxwspacefree(ctrl, nvtxs);
#line 251
  __idxwspacefree(ctrl, nvtxs);
#line 252
  __idxwspacefree(ctrl, nvtxs);
#line 253
  __idxwspacefree(ctrl, nvtxs);
#line 254
  fwspacefree(ctrl, 2L * ncon);
#line 255
  fwspacefree(ctrl, 2L * ncon);
  }
#line 257
  return;
}
}
#line 266 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mbalance2.c"
void __SelectQueue3(long ncon , float *npwgts , float *tpwgts , long *from , long *cnum ,
                    PQueueType (*queues)[2] , float *maxwgt ) 
{ 
  long i ;
  long j ;
  long maxgain ;
  float maxdiff ;
  float diff ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 269
  maxgain = 0L;
#line 270
  maxdiff = (float )0.0;
#line 272
  *from = -1L;
#line 273
  *cnum = -1L;
#line 276
  j = 0L;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! (j < 2L)) {
#line 276
      goto while_break;
    }
#line 277
    i = 0L;
    {
#line 277
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 277
      if (! (i < ncon)) {
#line 277
        goto while_break___0;
      }
#line 278
      diff = *(npwgts + (j * ncon + i)) - *(maxwgt + (j * ncon + i));
#line 279
      if (diff >= maxdiff) {
#line 280
        maxdiff = diff;
#line 281
        *from = j;
#line 282
        *cnum = i;
      }
#line 277
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 276
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  if (*from != -1L) {
    {
#line 295
    tmp___1 = PQueueGetSize(& (*(queues + *cnum))[*from]);
    }
#line 295
    if (tmp___1 == 0L) {
#line 296
      i = 0L;
      {
#line 296
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 296
        if (! (i < ncon)) {
#line 296
          goto while_break___1;
        }
        {
#line 297
        tmp = PQueueGetSize(& (*(queues + i))[*from]);
        }
#line 297
        if (tmp > 0L) {
#line 298
          maxdiff = *(npwgts + (*from * ncon + i)) - *(maxwgt + (*from * ncon + i));
#line 299
          *cnum = i;
#line 300
          goto while_break___1;
        }
#line 296
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 304
      i ++;
      {
#line 304
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 304
        if (! (i < ncon)) {
#line 304
          goto while_break___2;
        }
#line 305
        diff = *(npwgts + (*from * ncon + i)) - *(maxwgt + (*from * ncon + i));
#line 306
        if (diff > maxdiff) {
          {
#line 306
          tmp___0 = PQueueGetSize(& (*(queues + i))[*from]);
          }
#line 306
          if (tmp___0 > 0L) {
#line 307
            maxdiff = diff;
#line 308
            *cnum = i;
          }
        }
#line 304
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 314
  if (*from == -1L) {
#line 315
    maxgain = -100000L;
#line 316
    j = 0L;
    {
#line 316
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 316
      if (! (j < 2L)) {
#line 316
        goto while_break___3;
      }
#line 317
      i = 0L;
      {
#line 317
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 317
        if (! (i < ncon)) {
#line 317
          goto while_break___4;
        }
        {
#line 318
        tmp___2 = PQueueGetSize(& (*(queues + i))[j]);
        }
#line 318
        if (tmp___2 > 0L) {
          {
#line 318
          tmp___3 = PQueueGetKey(& (*(queues + i))[j]);
          }
#line 318
          if (tmp___3 > maxgain) {
            {
#line 319
            maxgain = PQueueGetKey(& (*(queues + i))[0]);
#line 320
            *from = j;
#line 321
            *cnum = i;
            }
          }
        }
#line 317
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 316
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 328
  return;
}
}
#line 131 "./proto.h"
void __SetUpGraphKway(GraphType *graph , long nvtxs , idxtype *xadj , idxtype *adjncy ) ;
#line 133
void __VolSetUpGraph(GraphType *graph , long OpType , long nvtxs , long ncon , idxtype *xadj ,
                     idxtype *adjncy , idxtype *vwgt , idxtype *vsize , long wgtflag ) ;
#line 134
void __RandomizeGraph(GraphType *graph ) ;
#line 135
long __IsConnectedSubdomain(CtrlType *ctrl , GraphType *graph , long pid , long report ) ;
#line 136
long __IsConnected(CtrlType *ctrl , GraphType *graph , long report ) ;
#line 137
long __IsConnected2(GraphType *graph , long report ) ;
#line 138
long __FindComponents(CtrlType *ctrl , GraphType *graph , idxtype *cptr , idxtype *cind ) ;
#line 447
long __idxsum_strd(long n , idxtype *x , long incx ) ;
#line 21 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/graph.c"
void __SetUpGraph(GraphType *graph , long OpType , long nvtxs , long ncon , idxtype *xadj ,
                  idxtype *adjncy , idxtype *vwgt , idxtype *adjwgt , long wgtflag ) 
{ 
  long i ;
  long j ;
  long sum ;
  long gsize ;
  float *nvwgt ;
  idxtype tvwgt[16] ;
  idxtype *tmp ;
  idxtype *tmp___0 ;
  float *tmp___1 ;
  idxtype *tmp___2 ;

  {
#line 28
  if (OpType == 2L) {
#line 28
    if (ncon == 1L) {
#line 28
      if ((wgtflag & 2L) == 0L) {
#line 28
        if ((wgtflag & 1L) == 0L) {
          {
#line 29
          __SetUpGraphKway(graph, nvtxs, xadj, adjncy);
          }
#line 30
          return;
        }
      }
    }
  }
  {
#line 33
  __InitGraph(graph);
#line 35
  graph->nvtxs = nvtxs;
#line 36
  graph->nedges = *(xadj + nvtxs);
#line 37
  graph->ncon = ncon;
#line 38
  graph->xadj = xadj;
#line 39
  graph->adjncy = adjncy;
  }
#line 41
  if (ncon == 1L) {
#line 42
    gsize = 0L;
#line 43
    if ((wgtflag & 2L) == 0L) {
#line 44
      gsize += nvtxs;
    }
#line 45
    if ((wgtflag & 1L) == 0L) {
#line 46
      gsize += graph->nedges;
    }
    {
#line 48
    gsize += 2L * nvtxs;
#line 50
    graph->gdata = __idxmalloc(gsize, (char *)"SetUpGraph: gdata");
#line 53
    gsize = 0L;
    }
#line 54
    if ((wgtflag & 2L) == 0L) {
      {
#line 55
      tmp = __idxset(nvtxs, (idxtype )1, graph->gdata);
#line 55
      graph->vwgt = tmp;
#line 55
      vwgt = tmp;
#line 56
      gsize += nvtxs;
      }
    } else {
#line 59
      graph->vwgt = vwgt;
    }
#line 61
    if ((wgtflag & 1L) == 0L) {
      {
#line 62
      tmp___0 = __idxset(graph->nedges, (idxtype )1, graph->gdata + gsize);
#line 62
      graph->adjwgt = tmp___0;
#line 62
      adjwgt = tmp___0;
#line 63
      gsize += graph->nedges;
      }
    } else {
#line 66
      graph->adjwgt = adjwgt;
    }
#line 70
    graph->adjwgtsum = graph->gdata + gsize;
#line 71
    gsize += nvtxs;
#line 73
    i = 0L;
    {
#line 73
    while (1) {
      while_continue: /* CIL Label */ ;
#line 73
      if (! (i < nvtxs)) {
#line 73
        goto while_break;
      }
#line 74
      sum = 0L;
#line 75
      j = *(xadj + i);
      {
#line 75
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 75
        if (! (j < *(xadj + (i + 1L)))) {
#line 75
          goto while_break___0;
        }
#line 76
        sum += *(adjwgt + j);
#line 75
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 77
      *(graph->adjwgtsum + i) = sum;
#line 73
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 80
    graph->cmap = graph->gdata + gsize;
#line 81
    gsize += nvtxs;
  } else {
#line 85
    gsize = 0L;
#line 86
    if ((wgtflag & 1L) == 0L) {
#line 87
      gsize += graph->nedges;
    }
    {
#line 89
    gsize += 2L * nvtxs;
#line 91
    graph->gdata = __idxmalloc(gsize, (char *)"SetUpGraph: gdata");
#line 92
    gsize = 0L;
#line 94
    i = 0L;
    }
    {
#line 94
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 94
      if (! (i < ncon)) {
#line 94
        goto while_break___1;
      }
      {
#line 95
      tvwgt[i] = __idxsum_strd(nvtxs, vwgt + i, ncon);
#line 94
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 97
    tmp___1 = __fmalloc(ncon * nvtxs, (char *)"SetUpGraph: nvwgt");
#line 97
    graph->nvwgt = tmp___1;
#line 97
    nvwgt = tmp___1;
#line 99
    i = 0L;
    }
    {
#line 99
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 99
      if (! (i < nvtxs)) {
#line 99
        goto while_break___2;
      }
#line 100
      j = 0L;
      {
#line 100
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 100
        if (! (j < ncon)) {
#line 100
          goto while_break___3;
        }
#line 101
        *(nvwgt + (i * ncon + j)) = (float )((1.0 * (double )*(vwgt + (i * ncon + j))) / (1.0 * (double )tvwgt[j]));
#line 100
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 99
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 106
    if ((wgtflag & 1L) == 0L) {
      {
#line 107
      tmp___2 = __idxset(graph->nedges, (idxtype )1, graph->gdata + gsize);
#line 107
      graph->adjwgt = tmp___2;
#line 107
      adjwgt = tmp___2;
#line 108
      gsize += graph->nedges;
      }
    } else {
#line 111
      graph->adjwgt = adjwgt;
    }
#line 114
    graph->adjwgtsum = graph->gdata + gsize;
#line 115
    gsize += nvtxs;
#line 117
    i = 0L;
    {
#line 117
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 117
      if (! (i < nvtxs)) {
#line 117
        goto while_break___4;
      }
#line 118
      sum = 0L;
#line 119
      j = *(xadj + i);
      {
#line 119
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 119
        if (! (j < *(xadj + (i + 1L)))) {
#line 119
          goto while_break___5;
        }
#line 120
        sum += *(adjwgt + j);
#line 119
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 121
      *(graph->adjwgtsum + i) = sum;
#line 117
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 124
    graph->cmap = graph->gdata + gsize;
#line 125
    gsize += nvtxs;
  }
#line 129
  if (OpType != 2L) {
#line 129
    if (OpType != 6L) {
      {
#line 130
      graph->label = __idxmalloc(nvtxs, (char *)"SetUpGraph: label");
#line 132
      i = 0L;
      }
      {
#line 132
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 132
        if (! (i < nvtxs)) {
#line 132
          goto while_break___6;
        }
#line 133
        *(graph->label + i) = i;
#line 132
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
  }
#line 136
  return;
}
}
#line 142 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/graph.c"
void __SetUpGraphKway(GraphType *graph , long nvtxs , idxtype *xadj , idxtype *adjncy ) 
{ 
  long i ;

  {
  {
#line 146
  __InitGraph(graph);
#line 148
  graph->nvtxs = nvtxs;
#line 149
  graph->nedges = *(xadj + nvtxs);
#line 150
  graph->ncon = 1L;
#line 151
  graph->xadj = xadj;
#line 152
  graph->vwgt = (idxtype *)((void *)0);
#line 153
  graph->adjncy = adjncy;
#line 154
  graph->adjwgt = (idxtype *)((void *)0);
#line 156
  graph->gdata = __idxmalloc(2L * nvtxs, (char *)"SetUpGraph: gdata");
#line 157
  graph->adjwgtsum = graph->gdata;
#line 158
  graph->cmap = graph->gdata + nvtxs;
#line 161
  i = 0L;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < nvtxs)) {
#line 161
      goto while_break;
    }
#line 162
    *(graph->adjwgtsum + i) = *(xadj + (i + 1L)) - *(xadj + i);
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 171 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/graph.c"
void __SetUpGraph2(GraphType *graph , long nvtxs , long ncon , idxtype *xadj , idxtype *adjncy ,
                   float *nvwgt , idxtype *adjwgt ) 
{ 
  long i ;
  long j ;
  long sum ;

  {
  {
#line 176
  __InitGraph(graph);
#line 178
  graph->nvtxs = nvtxs;
#line 179
  graph->nedges = *(xadj + nvtxs);
#line 180
  graph->ncon = ncon;
#line 181
  graph->xadj = xadj;
#line 182
  graph->adjncy = adjncy;
#line 183
  graph->adjwgt = adjwgt;
#line 185
  graph->nvwgt = __fmalloc(nvtxs * ncon, (char *)"SetUpGraph2: graph->nvwgt");
#line 186
  memcpy((void */* __restrict  */)((void *)graph->nvwgt), (void const   */* __restrict  */)((void *)nvwgt),
         sizeof(float ) * (unsigned long )(nvtxs * ncon));
#line 188
  graph->gdata = __idxmalloc(2L * nvtxs, (char *)"SetUpGraph: gdata");
#line 191
  graph->adjwgtsum = graph->gdata;
#line 192
  i = 0L;
  }
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (i < nvtxs)) {
#line 192
      goto while_break;
    }
#line 193
    sum = 0L;
#line 194
    j = *(xadj + i);
    {
#line 194
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 194
      if (! (j < *(xadj + (i + 1L)))) {
#line 194
        goto while_break___0;
      }
#line 195
      sum += *(adjwgt + j);
#line 194
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 196
    *(graph->adjwgtsum + i) = sum;
#line 192
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 199
  graph->cmap = graph->gdata + nvtxs;
#line 201
  graph->label = __idxmalloc(nvtxs, (char *)"SetUpGraph: label");
#line 202
  i = 0L;
  }
  {
#line 202
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 202
    if (! (i < nvtxs)) {
#line 202
      goto while_break___1;
    }
#line 203
    *(graph->label + i) = i;
#line 202
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 211 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/graph.c"
void __VolSetUpGraph(GraphType *graph , long OpType , long nvtxs , long ncon , idxtype *xadj ,
                     idxtype *adjncy , idxtype *vwgt , idxtype *vsize , long wgtflag ) 
{ 
  long i ;
  long j ;
  long sum ;
  long gsize ;
  idxtype *adjwgt ;
  float *nvwgt ;
  idxtype tvwgt[16] ;
  idxtype *tmp ;
  idxtype *tmp___0 ;
  idxtype *tmp___1 ;
  float *tmp___2 ;
  idxtype *tmp___3 ;
  idxtype *tmp___4 ;

  {
  {
#line 219
  __InitGraph(graph);
#line 221
  graph->nvtxs = nvtxs;
#line 222
  graph->nedges = *(xadj + nvtxs);
#line 223
  graph->ncon = ncon;
#line 224
  graph->xadj = xadj;
#line 225
  graph->adjncy = adjncy;
  }
#line 227
  if (ncon == 1L) {
#line 228
    gsize = graph->nedges;
#line 229
    if ((wgtflag & 2L) == 0L) {
#line 230
      gsize += nvtxs;
    }
#line 231
    if ((wgtflag & 1L) == 0L) {
#line 232
      gsize += nvtxs;
    }
    {
#line 234
    gsize += 2L * nvtxs;
#line 236
    graph->gdata = __idxmalloc(gsize, (char *)"SetUpGraph: gdata");
#line 239
    gsize = 0L;
    }
#line 240
    if ((wgtflag & 2L) == 0L) {
      {
#line 241
      tmp = __idxset(nvtxs, (idxtype )1, graph->gdata);
#line 241
      graph->vwgt = tmp;
#line 241
      vwgt = tmp;
#line 242
      gsize += nvtxs;
      }
    } else {
#line 245
      graph->vwgt = vwgt;
    }
#line 247
    if ((wgtflag & 1L) == 0L) {
      {
#line 248
      tmp___0 = __idxset(nvtxs, (idxtype )1, graph->gdata);
#line 248
      graph->vsize = tmp___0;
#line 248
      vsize = tmp___0;
#line 249
      gsize += nvtxs;
      }
    } else {
#line 252
      graph->vsize = vsize;
    }
#line 255
    tmp___1 = graph->gdata + gsize;
#line 255
    graph->adjwgt = tmp___1;
#line 255
    adjwgt = tmp___1;
#line 256
    gsize += graph->nedges;
#line 258
    i = 0L;
    {
#line 258
    while (1) {
      while_continue: /* CIL Label */ ;
#line 258
      if (! (i < nvtxs)) {
#line 258
        goto while_break;
      }
#line 259
      j = *(xadj + i);
      {
#line 259
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 259
        if (! (j < *(xadj + (i + 1L)))) {
#line 259
          goto while_break___0;
        }
#line 260
        *(adjwgt + j) = (1L + *(vsize + i)) + *(vsize + *(adjncy + j));
#line 259
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 258
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 265
    graph->adjwgtsum = graph->gdata + gsize;
#line 266
    gsize += nvtxs;
#line 268
    i = 0L;
    {
#line 268
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 268
      if (! (i < nvtxs)) {
#line 268
        goto while_break___1;
      }
#line 269
      sum = 0L;
#line 270
      j = *(xadj + i);
      {
#line 270
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 270
        if (! (j < *(xadj + (i + 1L)))) {
#line 270
          goto while_break___2;
        }
#line 271
        sum += *(adjwgt + j);
#line 270
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 272
      *(graph->adjwgtsum + i) = sum;
#line 268
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 275
    graph->cmap = graph->gdata + gsize;
#line 276
    gsize += nvtxs;
  } else {
#line 280
    gsize = graph->nedges;
#line 281
    if ((wgtflag & 1L) == 0L) {
#line 282
      gsize += nvtxs;
    }
    {
#line 284
    gsize += 2L * nvtxs;
#line 286
    graph->gdata = __idxmalloc(gsize, (char *)"SetUpGraph: gdata");
#line 287
    gsize = 0L;
    }
#line 290
    if ((wgtflag & 2L) == 0L) {
      {
#line 291
      vwgt = __idxsmalloc(nvtxs, (idxtype )1, (char *)"SetUpGraph: vwgt");
      }
    }
#line 293
    i = 0L;
    {
#line 293
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 293
      if (! (i < ncon)) {
#line 293
        goto while_break___3;
      }
      {
#line 294
      tvwgt[i] = __idxsum_strd(nvtxs, vwgt + i, ncon);
#line 293
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 296
    tmp___2 = __fmalloc(ncon * nvtxs, (char *)"SetUpGraph: nvwgt");
#line 296
    graph->nvwgt = tmp___2;
#line 296
    nvwgt = tmp___2;
#line 298
    i = 0L;
    }
    {
#line 298
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 298
      if (! (i < nvtxs)) {
#line 298
        goto while_break___4;
      }
#line 299
      j = 0L;
      {
#line 299
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 299
        if (! (j < ncon)) {
#line 299
          goto while_break___5;
        }
#line 300
        *(nvwgt + (i * ncon + j)) = (float )((1.0 * (double )*(vwgt + (i * ncon + j))) / (1.0 * (double )tvwgt[j]));
#line 299
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 298
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 302
    if ((wgtflag & 2L) == 0L) {
      {
#line 303
      free((void *)vwgt);
      }
    }
#line 307
    if ((wgtflag & 1L) == 0L) {
      {
#line 308
      tmp___3 = __idxset(nvtxs, (idxtype )1, graph->gdata);
#line 308
      graph->vsize = tmp___3;
#line 308
      vsize = tmp___3;
#line 309
      gsize += nvtxs;
      }
    } else {
#line 312
      graph->vsize = vsize;
    }
#line 315
    tmp___4 = graph->gdata + gsize;
#line 315
    graph->adjwgt = tmp___4;
#line 315
    adjwgt = tmp___4;
#line 316
    gsize += graph->nedges;
#line 318
    i = 0L;
    {
#line 318
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 318
      if (! (i < nvtxs)) {
#line 318
        goto while_break___6;
      }
#line 319
      j = *(xadj + i);
      {
#line 319
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 319
        if (! (j < *(xadj + (i + 1L)))) {
#line 319
          goto while_break___7;
        }
#line 320
        *(adjwgt + j) = (1L + *(vsize + i)) + *(vsize + *(adjncy + j));
#line 319
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 318
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 324
    graph->adjwgtsum = graph->gdata + gsize;
#line 325
    gsize += nvtxs;
#line 327
    i = 0L;
    {
#line 327
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 327
      if (! (i < nvtxs)) {
#line 327
        goto while_break___8;
      }
#line 328
      sum = 0L;
#line 329
      j = *(xadj + i);
      {
#line 329
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 329
        if (! (j < *(xadj + (i + 1L)))) {
#line 329
          goto while_break___9;
        }
#line 330
        sum += *(adjwgt + j);
#line 329
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 331
      *(graph->adjwgtsum + i) = sum;
#line 327
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 334
    graph->cmap = graph->gdata + gsize;
#line 335
    gsize += nvtxs;
  }
#line 339
  if (OpType != 6L) {
    {
#line 340
    graph->label = __idxmalloc(nvtxs, (char *)"SetUpGraph: label");
#line 342
    i = 0L;
    }
    {
#line 342
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 342
      if (! (i < nvtxs)) {
#line 342
        goto while_break___10;
      }
#line 343
      *(graph->label + i) = i;
#line 342
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
#line 346
  return;
}
}
#line 352 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/graph.c"
void __RandomizeGraph(GraphType *graph ) 
{ 
  long i ;
  long j ;
  long k ;
  long l ;
  long tmp ;
  long nvtxs ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  double tmp___0 ;

  {
#line 357
  nvtxs = graph->nvtxs;
#line 358
  xadj = graph->xadj;
#line 359
  adjncy = graph->adjncy;
#line 360
  adjwgt = graph->adjwgt;
#line 362
  i = 0L;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! (i < nvtxs)) {
#line 362
      goto while_break;
    }
#line 363
    l = *(xadj + (i + 1L)) - *(xadj + i);
#line 364
    j = *(xadj + i);
    {
#line 364
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 364
      if (! (j < *(xadj + (i + 1L)))) {
#line 364
        goto while_break___0;
      }
      {
#line 365
      tmp___0 = drand48();
#line 365
      k = *(xadj + i) + (long )(tmp___0 * (double )l);
      }
      {
#line 366
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 366
        tmp = *(adjncy + j);
#line 366
        *(adjncy + j) = *(adjncy + k);
#line 366
        *(adjncy + k) = tmp;
#line 366
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 367
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 367
        tmp = *(adjwgt + j);
#line 367
        *(adjwgt + j) = *(adjwgt + k);
#line 367
        *(adjwgt + k) = tmp;
#line 367
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 364
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 362
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  return;
}
}
#line 376 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/graph.c"
long __IsConnectedSubdomain(CtrlType *ctrl , GraphType *graph , long pid , long report ) 
{ 
  long i ;
  long j ;
  long k ;
  long nvtxs ;
  long first ;
  long last ;
  long nleft ;
  long ncmps ;
  long wgt ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *where ;
  idxtype *touched ;
  idxtype *queue ;
  idxtype *cptr ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 382
  nvtxs = graph->nvtxs;
#line 383
  xadj = graph->xadj;
#line 384
  adjncy = graph->adjncy;
#line 385
  where = graph->where;
#line 387
  touched = __idxsmalloc(nvtxs, (idxtype )0, (char *)"IsConnected: touched");
#line 388
  queue = __idxmalloc(nvtxs, (char *)"IsConnected: queue");
#line 389
  cptr = __idxmalloc(nvtxs, (char *)"IsConnected: cptr");
#line 391
  nleft = 0L;
#line 392
  i = 0L;
  }
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! (i < nvtxs)) {
#line 392
      goto while_break;
    }
#line 393
    if (*(where + i) == pid) {
#line 394
      nleft ++;
    }
#line 392
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  i = 0L;
  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (! (i < nvtxs)) {
#line 397
      goto while_break___0;
    }
#line 398
    if (*(where + i) == pid) {
#line 399
      goto while_break___0;
    }
#line 397
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 402
  *(touched + i) = (idxtype )1;
#line 403
  *(queue + 0) = i;
#line 404
  first = 0L;
#line 404
  last = 1L;
#line 406
  *(cptr + 0) = (idxtype )0;
#line 407
  ncmps = 0L;
  {
#line 408
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 408
    if (! (first != nleft)) {
#line 408
      goto while_break___1;
    }
#line 409
    if (first == last) {
#line 410
      ncmps ++;
#line 410
      *(cptr + ncmps) = first;
#line 411
      i = 0L;
      {
#line 411
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 411
        if (! (i < nvtxs)) {
#line 411
          goto while_break___2;
        }
#line 412
        if (*(where + i) == pid) {
#line 412
          if (! *(touched + i)) {
#line 413
            goto while_break___2;
          }
        }
#line 411
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 415
      tmp = last;
#line 415
      last ++;
#line 415
      *(queue + tmp) = i;
#line 416
      *(touched + i) = (idxtype )1;
    }
#line 419
    tmp___0 = first;
#line 419
    first ++;
#line 419
    i = *(queue + tmp___0);
#line 420
    j = *(xadj + i);
    {
#line 420
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 420
      if (! (j < *(xadj + (i + 1L)))) {
#line 420
        goto while_break___3;
      }
#line 421
      k = *(adjncy + j);
#line 422
      if (*(where + k) == pid) {
#line 422
        if (! *(touched + k)) {
#line 423
          tmp___1 = last;
#line 423
          last ++;
#line 423
          *(queue + tmp___1) = k;
#line 424
          *(touched + k) = (idxtype )1;
        }
      }
#line 420
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 428
  ncmps ++;
#line 428
  *(cptr + ncmps) = first;
#line 430
  if (ncmps > 1L) {
#line 430
    if (report) {
      {
#line 431
      printf((char const   */* __restrict  */)"The graph has %ld connected components in partition %ld:\t",
             ncmps, pid);
#line 432
      i = 0L;
      }
      {
#line 432
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 432
        if (! (i < ncmps)) {
#line 432
          goto while_break___4;
        }
#line 433
        wgt = 0L;
#line 434
        j = *(cptr + i);
        {
#line 434
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 434
          if (! (j < *(cptr + (i + 1L)))) {
#line 434
            goto while_break___5;
          }
#line 435
          wgt += *(graph->vwgt + *(queue + j));
#line 434
          j ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 436
        printf((char const   */* __restrict  */)"[%5ld %5ld] ", *(cptr + (i + 1L)) - *(cptr + i),
               wgt);
#line 432
        i ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 442
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
  {
#line 445
  __GKfree(& touched, & queue, & cptr, (void **)0);
  }
#line 447
  if (ncmps == 1L) {
#line 447
    tmp___2 = 1;
  } else {
#line 447
    tmp___2 = 0;
  }
#line 447
  return ((long )tmp___2);
}
}
#line 454 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/graph.c"
long __IsConnected(CtrlType *ctrl , GraphType *graph , long report ) 
{ 
  long i ;
  long j ;
  long k ;
  long nvtxs ;
  long first ;
  long last ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *touched ;
  idxtype *queue ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 459
  nvtxs = graph->nvtxs;
#line 460
  xadj = graph->xadj;
#line 461
  adjncy = graph->adjncy;
#line 463
  touched = __idxsmalloc(nvtxs, (idxtype )0, (char *)"IsConnected: touched");
#line 464
  queue = __idxmalloc(nvtxs, (char *)"IsConnected: queue");
#line 466
  *(touched + 0) = (idxtype )1;
#line 467
  *(queue + 0) = (idxtype )0;
#line 468
  first = 0L;
#line 468
  last = 1L;
  }
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (! (first < last)) {
#line 470
      goto while_break;
    }
#line 471
    tmp = first;
#line 471
    first ++;
#line 471
    i = *(queue + tmp);
#line 472
    j = *(xadj + i);
    {
#line 472
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 472
      if (! (j < *(xadj + (i + 1L)))) {
#line 472
        goto while_break___0;
      }
#line 473
      k = *(adjncy + j);
#line 474
      if (! *(touched + k)) {
#line 475
        tmp___0 = last;
#line 475
        last ++;
#line 475
        *(queue + tmp___0) = k;
#line 476
        *(touched + k) = (idxtype )1;
      }
#line 472
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 481
  if (first != nvtxs) {
#line 481
    if (report) {
      {
#line 482
      printf((char const   */* __restrict  */)"The graph is not connected. It has %ld disconnected vertices!\n",
             nvtxs - first);
      }
    }
  }
#line 484
  if (first == nvtxs) {
#line 484
    tmp___1 = 1;
  } else {
#line 484
    tmp___1 = 0;
  }
#line 484
  return ((long )tmp___1);
}
}
#line 491 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/graph.c"
long __IsConnected2(GraphType *graph , long report ) 
{ 
  long i ;
  long j ;
  long k ;
  long nvtxs ;
  long first ;
  long last ;
  long nleft ;
  long ncmps ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *where ;
  idxtype *touched ;
  idxtype *queue ;
  idxtype *cptr ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 497
  nvtxs = graph->nvtxs;
#line 498
  xadj = graph->xadj;
#line 499
  adjncy = graph->adjncy;
#line 500
  where = graph->where;
#line 502
  touched = __idxsmalloc(nvtxs, (idxtype )0, (char *)"IsConnected: touched");
#line 503
  queue = __idxmalloc(nvtxs, (char *)"IsConnected: queue");
#line 504
  cptr = __idxmalloc(nvtxs, (char *)"IsConnected: cptr");
#line 506
  nleft = nvtxs;
#line 507
  *(touched + 0) = (idxtype )1;
#line 508
  *(queue + 0) = (idxtype )0;
#line 509
  first = 0L;
#line 509
  last = 1L;
#line 511
  *(cptr + 0) = (idxtype )0;
#line 512
  ncmps = 0L;
  }
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 513
    if (! (first != nleft)) {
#line 513
      goto while_break;
    }
#line 514
    if (first == last) {
#line 515
      ncmps ++;
#line 515
      *(cptr + ncmps) = first;
#line 516
      i = 0L;
      {
#line 516
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 516
        if (! (i < nvtxs)) {
#line 516
          goto while_break___0;
        }
#line 517
        if (! *(touched + i)) {
#line 518
          goto while_break___0;
        }
#line 516
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 520
      tmp = last;
#line 520
      last ++;
#line 520
      *(queue + tmp) = i;
#line 521
      *(touched + i) = (idxtype )1;
    }
#line 524
    tmp___0 = first;
#line 524
    first ++;
#line 524
    i = *(queue + tmp___0);
#line 525
    j = *(xadj + i);
    {
#line 525
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 525
      if (! (j < *(xadj + (i + 1L)))) {
#line 525
        goto while_break___1;
      }
#line 526
      k = *(adjncy + j);
#line 527
      if (! *(touched + k)) {
#line 528
        tmp___1 = last;
#line 528
        last ++;
#line 528
        *(queue + tmp___1) = k;
#line 529
        *(touched + k) = (idxtype )1;
      }
#line 525
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  ncmps ++;
#line 533
  *(cptr + ncmps) = first;
#line 535
  if (ncmps > 1L) {
#line 535
    if (report) {
      {
#line 536
      printf((char const   */* __restrict  */)"%ld connected components:\t", ncmps);
#line 537
      i = 0L;
      }
      {
#line 537
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 537
        if (! (i < ncmps)) {
#line 537
          goto while_break___2;
        }
#line 538
        if (*(cptr + (i + 1L)) - *(cptr + i) > 200L) {
          {
#line 539
          printf((char const   */* __restrict  */)"[%5ld] ", *(cptr + (i + 1L)) - *(cptr + i));
          }
        }
#line 537
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 541
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
  {
#line 544
  __GKfree(& touched, & queue, & cptr, (void **)0);
  }
#line 546
  if (ncmps == 1L) {
#line 546
    tmp___2 = 1;
  } else {
#line 546
    tmp___2 = 0;
  }
#line 546
  return ((long )tmp___2);
}
}
#line 554 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/graph.c"
long __FindComponents(CtrlType *ctrl , GraphType *graph , idxtype *cptr , idxtype *cind ) 
{ 
  long i ;
  long j ;
  long k ;
  long nvtxs ;
  long first ;
  long last ;
  long nleft ;
  long ncmps ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *where ;
  idxtype *touched ;
  idxtype *queue ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 559
  nvtxs = graph->nvtxs;
#line 560
  xadj = graph->xadj;
#line 561
  adjncy = graph->adjncy;
#line 562
  where = graph->where;
#line 564
  touched = __idxsmalloc(nvtxs, (idxtype )0, (char *)"IsConnected: queue");
#line 566
  i = 0L;
  }
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (i < graph->nbnd)) {
#line 566
      goto while_break;
    }
#line 567
    *(touched + *(graph->bndind + i)) = (idxtype )1;
#line 566
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 569
  queue = cind;
#line 571
  nleft = 0L;
#line 572
  i = 0L;
  {
#line 572
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 572
    if (! (i < nvtxs)) {
#line 572
      goto while_break___0;
    }
#line 573
    if (*(where + i) != 2L) {
#line 574
      nleft ++;
    }
#line 572
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 577
  i = 0L;
  {
#line 577
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 577
    if (! (i < nvtxs)) {
#line 577
      goto while_break___1;
    }
#line 578
    if (*(where + i) != 2L) {
#line 579
      goto while_break___1;
    }
#line 577
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 582
  *(touched + i) = (idxtype )1;
#line 583
  *(queue + 0) = i;
#line 584
  first = 0L;
#line 584
  last = 1L;
#line 586
  *(cptr + 0) = (idxtype )0;
#line 587
  ncmps = 0L;
  {
#line 588
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 588
    if (! (first != nleft)) {
#line 588
      goto while_break___2;
    }
#line 589
    if (first == last) {
#line 590
      ncmps ++;
#line 590
      *(cptr + ncmps) = first;
#line 591
      i = 0L;
      {
#line 591
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 591
        if (! (i < nvtxs)) {
#line 591
          goto while_break___3;
        }
#line 592
        if (! *(touched + i)) {
#line 593
          goto while_break___3;
        }
#line 591
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 595
      tmp = last;
#line 595
      last ++;
#line 595
      *(queue + tmp) = i;
#line 596
      *(touched + i) = (idxtype )1;
    }
#line 599
    tmp___0 = first;
#line 599
    first ++;
#line 599
    i = *(queue + tmp___0);
#line 600
    j = *(xadj + i);
    {
#line 600
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 600
      if (! (j < *(xadj + (i + 1L)))) {
#line 600
        goto while_break___4;
      }
#line 601
      k = *(adjncy + j);
#line 602
      if (! *(touched + k)) {
#line 603
        tmp___1 = last;
#line 603
        last ++;
#line 603
        *(queue + tmp___1) = k;
#line 604
        *(touched + k) = (idxtype )1;
      }
#line 600
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 608
  ncmps ++;
#line 608
  *(cptr + ncmps) = first;
#line 610
  free((void *)touched);
  }
#line 612
  return (ncmps);
}
}
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 17 "./proto.h"
void __Bnd2WayBalance(CtrlType *ctrl , GraphType *graph , long *tpwgts ) ;
#line 18
void __General2WayBalance(CtrlType *ctrl , GraphType *graph , long *tpwgts ) ;
#line 21 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/balance.c"
void __Balance2Way(CtrlType *ctrl , GraphType *graph , long *tpwgts , float ubfactor ) 
{ 
  long mindiff ;
  int tmp ;

  {
  {
#line 27
  tmp = abs((int )(*(tpwgts + 0) - *(graph->pwgts + 0)));
#line 27
  mindiff = (long )tmp;
  }
#line 28
  if (mindiff < (3L * (*(graph->pwgts + 0) + *(graph->pwgts + 1))) / graph->nvtxs) {
#line 29
    return;
  }
#line 30
  if (*(graph->pwgts + 0) > *(tpwgts + 0)) {
#line 30
    if (*(graph->pwgts + 0) < (long )(ubfactor * (float )*(tpwgts + 0))) {
#line 31
      return;
    }
  }
#line 32
  if (*(graph->pwgts + 1) > *(tpwgts + 1)) {
#line 32
    if (*(graph->pwgts + 1) < (long )(ubfactor * (float )*(tpwgts + 1))) {
#line 33
      return;
    }
  }
#line 35
  if (graph->nbnd > 0L) {
    {
#line 36
    __Bnd2WayBalance(ctrl, graph, tpwgts);
    }
  } else {
    {
#line 38
    __General2WayBalance(ctrl, graph, tpwgts);
    }
  }
#line 40
  return;
}
}
#line 48 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/balance.c"
void __Bnd2WayBalance(CtrlType *ctrl , GraphType *graph , long *tpwgts ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long kwgt ;
  long nvtxs ;
  long nbnd ;
  long nswaps ;
  long from ;
  long to ;
  long tmp ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *id ;
  idxtype *ed ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *pwgts ;
  idxtype *moved ;
  idxtype *perm ;
  PQueueType parts ;
  long higain ;
  long oldgain ;
  long mincut ;
  long mindiff ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 56
  nvtxs = graph->nvtxs;
#line 57
  xadj = graph->xadj;
#line 58
  vwgt = graph->vwgt;
#line 59
  adjncy = graph->adjncy;
#line 60
  adjwgt = graph->adjwgt;
#line 61
  where = graph->where;
#line 62
  id = graph->id;
#line 63
  ed = graph->ed;
#line 64
  pwgts = graph->pwgts;
#line 65
  bndptr = graph->bndptr;
#line 66
  bndind = graph->bndind;
#line 68
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 69
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 72
  tmp___0 = abs((int )(*(tpwgts + 0) - *(pwgts + 0)));
#line 72
  mindiff = (long )tmp___0;
  }
#line 73
  if (*(pwgts + 0) < *(tpwgts + 0)) {
#line 73
    from = 1L;
  } else {
#line 73
    from = 0L;
  }
#line 74
  to = (from + 1L) % 2L;
#line 76
  if (ctrl->dbglvl & 8L) {
    {
#line 76
    printf((char const   */* __restrict  */)"Partitions: [%6ld %6ld] T[%6ld %6ld], Nv-Nb[%6ld %6ld]. ICut: %6ld [B]\n",
           *(pwgts + 0), *(pwgts + 1), *(tpwgts + 0), *(tpwgts + 1), graph->nvtxs,
           graph->nbnd, graph->mincut);
    }
  }
  {
#line 80
  tmp___1 = __idxamax(nvtxs, graph->adjwgtsum);
#line 80
  tmp = *(graph->adjwgtsum + tmp___1);
#line 81
  __PQueueInit(ctrl, & parts, nvtxs, tmp);
#line 83
  __idxset(nvtxs, (idxtype )-1, moved);
#line 89
  nbnd = graph->nbnd;
#line 90
  __RandomPermute(nbnd, perm, 1L);
#line 91
  ii = 0L;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (ii < nbnd)) {
#line 91
      goto while_break;
    }
#line 92
    i = *(perm + ii);
#line 95
    if (*(where + *(bndind + i)) == from) {
#line 95
      if (*(vwgt + *(bndind + i)) <= mindiff) {
        {
#line 96
        __PQueueInsert(& parts, *(bndind + i), *(ed + *(bndind + i)) - *(id + *(bndind + i)));
        }
      }
    }
#line 91
    ii ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  mincut = graph->mincut;
#line 100
  nswaps = 0L;
  {
#line 100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 100
    if (! (nswaps < nvtxs)) {
#line 100
      goto while_break___0;
    }
    {
#line 101
    higain = __PQueueGetMax(& parts);
    }
#line 101
    if (higain == -1L) {
#line 102
      goto while_break___0;
    }
#line 105
    if (*(pwgts + to) + *(vwgt + higain) > *(tpwgts + to)) {
#line 106
      goto while_break___0;
    }
#line 108
    mincut -= *(ed + higain) - *(id + higain);
    {
#line 109
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 109
      *(pwgts + to) += *(vwgt + higain);
#line 109
      *(pwgts + from) -= *(vwgt + higain);
#line 109
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 111
    *(where + higain) = to;
#line 112
    *(moved + higain) = nswaps;
#line 114
    if (ctrl->dbglvl & 32L) {
      {
#line 114
      printf((char const   */* __restrict  */)"Moved %6ld from %ld. [%3ld %3ld] %5ld [%4ld %4ld]\n",
             higain, from, *(ed + higain) - *(id + higain), *(vwgt + higain), mincut,
             *(pwgts + 0), *(pwgts + 1));
      }
    }
    {
#line 120
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 120
      tmp = *(id + higain);
#line 120
      *(id + higain) = *(ed + higain);
#line 120
      *(ed + higain) = tmp;
#line 120
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 121
    if (*(ed + higain) == 0L) {
#line 121
      if (*(xadj + higain) < *(xadj + (higain + 1L))) {
        {
#line 122
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 122
          nbnd --;
#line 122
          *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 122
          *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 122
          *(bndptr + higain) = (idxtype )-1;
#line 122
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 124
    j = *(xadj + higain);
    {
#line 124
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 124
      if (! (j < *(xadj + (higain + 1L)))) {
#line 124
        goto while_break___4;
      }
#line 125
      k = *(adjncy + j);
#line 126
      oldgain = *(ed + k) - *(id + k);
#line 128
      if (to == *(where + k)) {
#line 128
        kwgt = *(adjwgt + j);
      } else {
#line 128
        kwgt = - *(adjwgt + j);
      }
      {
#line 129
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 129
        *(id + k) += kwgt;
#line 129
        *(ed + k) -= kwgt;
#line 129
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 132
      if (*(bndptr + k) != -1L) {
#line 133
        if (*(ed + k) == 0L) {
          {
#line 134
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 134
            nbnd --;
#line 134
            *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 134
            *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 134
            *(bndptr + k) = (idxtype )-1;
#line 134
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 135
          if (*(moved + k) == -1L) {
#line 135
            if (*(where + k) == from) {
#line 135
              if (*(vwgt + k) <= mindiff) {
                {
#line 136
                __PQueueDelete(& parts, k, oldgain);
                }
              }
            }
          }
        } else
#line 139
        if (*(moved + k) == -1L) {
#line 139
          if (*(where + k) == from) {
#line 139
            if (*(vwgt + k) <= mindiff) {
              {
#line 140
              __PQueueUpdate(& parts, k, oldgain, *(ed + k) - *(id + k));
              }
            }
          }
        }
      } else
#line 144
      if (*(ed + k) > 0L) {
        {
#line 145
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 145
          *(bndind + nbnd) = k;
#line 145
          tmp___2 = nbnd;
#line 145
          nbnd ++;
#line 145
          *(bndptr + k) = tmp___2;
#line 145
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 146
        if (*(moved + k) == -1L) {
#line 146
          if (*(where + k) == from) {
#line 146
            if (*(vwgt + k) <= mindiff) {
              {
#line 147
              __PQueueInsert(& parts, k, *(ed + k) - *(id + k));
              }
            }
          }
        }
      }
#line 124
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 100
    nswaps ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 153
  if (ctrl->dbglvl & 8L) {
    {
#line 153
    printf((char const   */* __restrict  */)"\tMinimum cut: %6ld, PWGTS: [%6ld %6ld], NBND: %6ld\n",
           mincut, *(pwgts + 0), *(pwgts + 1), nbnd);
    }
  }
  {
#line 156
  graph->mincut = mincut;
#line 157
  graph->nbnd = nbnd;
#line 159
  __PQueueFree(ctrl, & parts);
#line 161
  __idxwspacefree(ctrl, nvtxs);
#line 162
  __idxwspacefree(ctrl, nvtxs);
  }
#line 163
  return;
}
}
#line 174 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/balance.c"
void __General2WayBalance(CtrlType *ctrl , GraphType *graph , long *tpwgts ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long kwgt ;
  long nvtxs ;
  long nbnd ;
  long nswaps ;
  long from ;
  long to ;
  long tmp ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *id ;
  idxtype *ed ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *pwgts ;
  idxtype *moved ;
  idxtype *perm ;
  PQueueType parts ;
  long higain ;
  long oldgain ;
  long mincut ;
  long mindiff ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 182
  nvtxs = graph->nvtxs;
#line 183
  xadj = graph->xadj;
#line 184
  vwgt = graph->vwgt;
#line 185
  adjncy = graph->adjncy;
#line 186
  adjwgt = graph->adjwgt;
#line 187
  where = graph->where;
#line 188
  id = graph->id;
#line 189
  ed = graph->ed;
#line 190
  pwgts = graph->pwgts;
#line 191
  bndptr = graph->bndptr;
#line 192
  bndind = graph->bndind;
#line 194
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 195
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 198
  tmp___0 = abs((int )(*(tpwgts + 0) - *(pwgts + 0)));
#line 198
  mindiff = (long )tmp___0;
  }
#line 199
  if (*(pwgts + 0) < *(tpwgts + 0)) {
#line 199
    from = 1L;
  } else {
#line 199
    from = 0L;
  }
#line 200
  to = (from + 1L) % 2L;
#line 202
  if (ctrl->dbglvl & 8L) {
    {
#line 202
    printf((char const   */* __restrict  */)"Partitions: [%6ld %6ld] T[%6ld %6ld], Nv-Nb[%6ld %6ld]. ICut: %6ld [B]\n",
           *(pwgts + 0), *(pwgts + 1), *(tpwgts + 0), *(tpwgts + 1), graph->nvtxs,
           graph->nbnd, graph->mincut);
    }
  }
  {
#line 206
  tmp___1 = __idxamax(nvtxs, graph->adjwgtsum);
#line 206
  tmp = *(graph->adjwgtsum + tmp___1);
#line 207
  __PQueueInit(ctrl, & parts, nvtxs, tmp);
#line 209
  __idxset(nvtxs, (idxtype )-1, moved);
#line 215
  __RandomPermute(nvtxs, perm, 1L);
#line 216
  ii = 0L;
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (ii < nvtxs)) {
#line 216
      goto while_break;
    }
#line 217
    i = *(perm + ii);
#line 218
    if (*(where + i) == from) {
#line 218
      if (*(vwgt + i) <= mindiff) {
        {
#line 219
        __PQueueInsert(& parts, i, *(ed + i) - *(id + i));
        }
      }
    }
#line 216
    ii ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  mincut = graph->mincut;
#line 223
  nbnd = graph->nbnd;
#line 224
  nswaps = 0L;
  {
#line 224
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 224
    if (! (nswaps < nvtxs)) {
#line 224
      goto while_break___0;
    }
    {
#line 225
    higain = __PQueueGetMax(& parts);
    }
#line 225
    if (higain == -1L) {
#line 226
      goto while_break___0;
    }
#line 228
    if (*(pwgts + to) + *(vwgt + higain) > *(tpwgts + to)) {
#line 229
      goto while_break___0;
    }
#line 231
    mincut -= *(ed + higain) - *(id + higain);
    {
#line 232
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 232
      *(pwgts + to) += *(vwgt + higain);
#line 232
      *(pwgts + from) -= *(vwgt + higain);
#line 232
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 234
    *(where + higain) = to;
#line 235
    *(moved + higain) = nswaps;
#line 237
    if (ctrl->dbglvl & 32L) {
      {
#line 237
      printf((char const   */* __restrict  */)"Moved %6ld from %ld. [%3ld %3ld] %5ld [%4ld %4ld]\n",
             higain, from, *(ed + higain) - *(id + higain), *(vwgt + higain), mincut,
             *(pwgts + 0), *(pwgts + 1));
      }
    }
    {
#line 243
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 243
      tmp = *(id + higain);
#line 243
      *(id + higain) = *(ed + higain);
#line 243
      *(ed + higain) = tmp;
#line 243
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 244
    if (*(ed + higain) == 0L) {
#line 244
      if (*(bndptr + higain) != -1L) {
#line 244
        if (*(xadj + higain) < *(xadj + (higain + 1L))) {
          {
#line 245
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 245
            nbnd --;
#line 245
            *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 245
            *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 245
            *(bndptr + higain) = (idxtype )-1;
#line 245
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      }
    }
#line 246
    if (*(ed + higain) > 0L) {
#line 246
      if (*(bndptr + higain) == -1L) {
        {
#line 247
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 247
          *(bndind + nbnd) = higain;
#line 247
          tmp___2 = nbnd;
#line 247
          nbnd ++;
#line 247
          *(bndptr + higain) = tmp___2;
#line 247
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 249
    j = *(xadj + higain);
    {
#line 249
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 249
      if (! (j < *(xadj + (higain + 1L)))) {
#line 249
        goto while_break___5;
      }
#line 250
      k = *(adjncy + j);
#line 251
      oldgain = *(ed + k) - *(id + k);
#line 253
      if (to == *(where + k)) {
#line 253
        kwgt = *(adjwgt + j);
      } else {
#line 253
        kwgt = - *(adjwgt + j);
      }
      {
#line 254
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 254
        *(id + k) += kwgt;
#line 254
        *(ed + k) -= kwgt;
#line 254
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 257
      if (*(moved + k) == -1L) {
#line 257
        if (*(where + k) == from) {
#line 257
          if (*(vwgt + k) <= mindiff) {
            {
#line 258
            __PQueueUpdate(& parts, k, oldgain, *(ed + k) - *(id + k));
            }
          }
        }
      }
#line 261
      if (*(ed + k) == 0L) {
#line 261
        if (*(bndptr + k) != -1L) {
          {
#line 262
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 262
            nbnd --;
#line 262
            *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 262
            *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 262
            *(bndptr + k) = (idxtype )-1;
#line 262
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
        } else {
#line 261
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 263
      if (*(ed + k) > 0L) {
#line 263
        if (*(bndptr + k) == -1L) {
          {
#line 264
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 264
            *(bndind + nbnd) = k;
#line 264
            tmp___3 = nbnd;
#line 264
            nbnd ++;
#line 264
            *(bndptr + k) = tmp___3;
#line 264
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
      }
#line 249
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 224
    nswaps ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  if (ctrl->dbglvl & 8L) {
    {
#line 268
    printf((char const   */* __restrict  */)"\tMinimum cut: %6ld, PWGTS: [%6ld %6ld], NBND: %6ld\n",
           mincut, *(pwgts + 0), *(pwgts + 1), nbnd);
    }
  }
  {
#line 271
  graph->mincut = mincut;
#line 272
  graph->nbnd = nbnd;
#line 274
  __PQueueFree(ctrl, & parts);
#line 276
  __idxwspacefree(ctrl, nvtxs);
#line 277
  __idxwspacefree(ctrl, nvtxs);
  }
#line 278
  return;
}
}
#line 300 "./proto.h"
void __genmmd(long neqns , idxtype *xadj , idxtype *adjncy , idxtype *invp , idxtype *perm ,
              long delta , idxtype *head , idxtype *qsize , idxtype *list , idxtype *marker ,
              long maxint , long *ncsub ) ;
#line 301
void __mmdelm(long mdeg_node , idxtype *xadj , idxtype *adjncy , idxtype *head , idxtype *forward ,
              idxtype *backward , idxtype *qsize , idxtype *list , idxtype *marker ,
              long maxint , long tag ) ;
#line 302
long __mmdint(long neqns , idxtype *xadj , idxtype *adjncy , idxtype *head , idxtype *forward ,
              idxtype *backward , idxtype *qsize , idxtype *list , idxtype *marker ) ;
#line 303
void __mmdnum(long neqns , idxtype *perm , idxtype *invp , idxtype *qsize ) ;
#line 304
void __mmdupd(long ehead , long neqns , idxtype *xadj , idxtype *adjncy , long delta ,
              long *mdeg , idxtype *head , idxtype *forward , idxtype *backward ,
              idxtype *qsize , idxtype *list , idxtype *marker , long maxint , long *tag ) ;
#line 53 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mmd.c"
void __genmmd(long neqns , idxtype *xadj , idxtype *adjncy , idxtype *invp , idxtype *perm ,
              long delta , idxtype *head , idxtype *qsize , idxtype *list , idxtype *marker ,
              long maxint , long *ncsub ) 
{ 
  long ehead ;
  long i ;
  long mdeg ;
  long mdlmt ;
  long mdeg_node ;
  long nextmd ;
  long num ;
  long tag ;

  {
#line 59
  if (neqns <= 0L) {
#line 60
    return;
  }
  {
#line 63
  xadj --;
#line 63
  adjncy --;
#line 63
  invp --;
#line 63
  perm --;
#line 63
  head --;
#line 63
  qsize --;
#line 63
  list --;
#line 63
  marker --;
#line 66
  *ncsub = 0L;
#line 67
  __mmdint(neqns, xadj, adjncy, head, invp, perm, qsize, list, marker);
#line 70
  num = 1L;
#line 73
  nextmd = *(head + 1);
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (nextmd > 0L)) {
#line 74
      goto while_break;
    }
#line 75
    mdeg_node = nextmd;
#line 76
    nextmd = *(invp + mdeg_node);
#line 77
    *(marker + mdeg_node) = maxint;
#line 78
    *(invp + mdeg_node) = - num;
#line 79
    num ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  if (num > neqns) {
#line 85
    goto n1000;
  }
#line 86
  tag = 1L;
#line 87
  *(head + 1) = (idxtype )0;
#line 88
  mdeg = 2L;
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 92
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 92
      if (! (*(head + mdeg) <= 0L)) {
#line 92
        goto while_break___1;
      }
#line 93
      mdeg ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 97
    mdlmt = mdeg + delta;
#line 98
    ehead = 0L;
    n500: 
#line 101
    mdeg_node = *(head + mdeg);
    {
#line 102
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 102
      if (! (mdeg_node <= 0L)) {
#line 102
        goto while_break___2;
      }
#line 103
      mdeg ++;
#line 105
      if (mdeg > mdlmt) {
#line 106
        goto n900;
      }
#line 107
      mdeg_node = *(head + mdeg);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 111
    nextmd = *(invp + mdeg_node);
#line 112
    *(head + mdeg) = nextmd;
#line 113
    if (nextmd > 0L) {
#line 114
      *(perm + nextmd) = - mdeg;
    }
#line 115
    *(invp + mdeg_node) = - num;
#line 116
    *ncsub += (mdeg + *(qsize + mdeg_node)) - 2L;
#line 117
    if (num + *(qsize + mdeg_node) > neqns) {
#line 118
      goto n1000;
    }
#line 122
    tag ++;
#line 123
    if (tag >= maxint) {
#line 124
      tag = 1L;
#line 125
      i = 1L;
      {
#line 125
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 125
        if (! (i <= neqns)) {
#line 125
          goto while_break___3;
        }
#line 126
        if (*(marker + i) < maxint) {
#line 127
          *(marker + i) = (idxtype )0;
        }
#line 125
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 130
    __mmdelm(mdeg_node, xadj, adjncy, head, invp, perm, qsize, list, marker, maxint,
             tag);
#line 132
    num += *(qsize + mdeg_node);
#line 133
    *(list + mdeg_node) = ehead;
#line 134
    ehead = mdeg_node;
    }
#line 135
    if (delta >= 0L) {
#line 136
      goto n500;
    }
    n900: 
#line 141
    if (num > neqns) {
#line 142
      goto n1000;
    }
    {
#line 143
    __mmdupd(ehead, neqns, xadj, adjncy, delta, & mdeg, head, invp, perm, qsize, list,
             marker, maxint, & tag);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  n1000: 
  {
#line 147
  __mmdnum(neqns, perm, invp, qsize);
#line 150
  xadj ++;
#line 150
  adjncy ++;
#line 150
  invp ++;
#line 150
  perm ++;
#line 150
  head ++;
#line 150
  qsize ++;
#line 150
  list ++;
#line 150
  marker ++;
  }
#line 151
  return;
}
}
#line 171 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mmd.c"
void __mmdelm(long mdeg_node , idxtype *xadj , idxtype *adjncy , idxtype *head , idxtype *forward ,
              idxtype *backward , idxtype *qsize , idxtype *list , idxtype *marker ,
              long maxint , long tag ) 
{ 
  long element ;
  long i ;
  long istop ;
  long istart ;
  long j ;
  long jstop ;
  long jstart ;
  long link ;
  long nabor ;
  long node ;
  long npv ;
  long nqnbrs ;
  long nxnode ;
  long pvnode ;
  long rlmt ;
  long rloc ;
  long rnode ;
  long xqnbr ;

  {
#line 181
  *(marker + mdeg_node) = tag;
#line 182
  istart = *(xadj + mdeg_node);
#line 183
  istop = *(xadj + (mdeg_node + 1L)) - 1L;
#line 188
  element = 0L;
#line 189
  rloc = istart;
#line 190
  rlmt = istop;
#line 191
  i = istart;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (i <= istop)) {
#line 191
      goto while_break;
    }
#line 192
    nabor = *(adjncy + i);
#line 193
    if (nabor == 0L) {
#line 193
      goto while_break;
    }
#line 194
    if (*(marker + nabor) < tag) {
#line 195
      *(marker + nabor) = tag;
#line 196
      if (*(forward + nabor) < 0L) {
#line 197
        *(list + nabor) = element;
#line 198
        element = nabor;
      } else {
#line 200
        *(adjncy + rloc) = nabor;
#line 201
        rloc ++;
      }
    }
#line 191
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 207
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 207
    if (! (element > 0L)) {
#line 207
      goto while_break___0;
    }
#line 208
    *(adjncy + rlmt) = - element;
#line 209
    link = element;
    n400: 
#line 212
    jstart = *(xadj + link);
#line 213
    jstop = *(xadj + (link + 1L)) - 1L;
#line 214
    j = jstart;
    {
#line 214
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 214
      if (! (j <= jstop)) {
#line 214
        goto while_break___1;
      }
#line 215
      node = *(adjncy + j);
#line 216
      link = - node;
#line 217
      if (node < 0L) {
#line 217
        goto n400;
      }
#line 218
      if (node == 0L) {
#line 218
        goto while_break___1;
      }
#line 219
      if (*(marker + node) < tag) {
#line 219
        if (*(forward + node) >= 0L) {
#line 220
          *(marker + node) = tag;
          {
#line 222
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 222
            if (! (rloc >= rlmt)) {
#line 222
              goto while_break___2;
            }
#line 223
            link = - *(adjncy + rlmt);
#line 224
            rloc = *(xadj + link);
#line 225
            rlmt = *(xadj + (link + 1L)) - 1L;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 227
          *(adjncy + rloc) = node;
#line 228
          rloc ++;
        }
      }
#line 214
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 231
    element = *(list + element);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 233
  if (rloc <= rlmt) {
#line 233
    *(adjncy + rloc) = (idxtype )0;
  }
#line 235
  link = mdeg_node;
  n1100: 
#line 238
  istart = *(xadj + link);
#line 239
  istop = *(xadj + (link + 1L)) - 1L;
#line 240
  i = istart;
  {
#line 240
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 240
    if (! (i <= istop)) {
#line 240
      goto while_break___3;
    }
#line 241
    rnode = *(adjncy + i);
#line 242
    link = - rnode;
#line 243
    if (rnode < 0L) {
#line 243
      goto n1100;
    }
#line 244
    if (rnode == 0L) {
#line 244
      return;
    }
#line 247
    pvnode = *(backward + rnode);
#line 248
    if (pvnode != 0L) {
#line 248
      if (pvnode != - maxint) {
#line 250
        nxnode = *(forward + rnode);
#line 251
        if (nxnode > 0L) {
#line 251
          *(backward + nxnode) = pvnode;
        }
#line 252
        if (pvnode > 0L) {
#line 252
          *(forward + pvnode) = nxnode;
        }
#line 253
        npv = - pvnode;
#line 254
        if (pvnode < 0L) {
#line 254
          *(head + npv) = nxnode;
        }
      }
    }
#line 258
    jstart = *(xadj + rnode);
#line 259
    jstop = *(xadj + (rnode + 1L)) - 1L;
#line 260
    xqnbr = jstart;
#line 261
    j = jstart;
    {
#line 261
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 261
      if (! (j <= jstop)) {
#line 261
        goto while_break___4;
      }
#line 262
      nabor = *(adjncy + j);
#line 263
      if (nabor == 0L) {
#line 263
        goto while_break___4;
      }
#line 264
      if (*(marker + nabor) < tag) {
#line 265
        *(adjncy + xqnbr) = nabor;
#line 266
        xqnbr ++;
      }
#line 261
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 271
    nqnbrs = xqnbr - jstart;
#line 272
    if (nqnbrs <= 0L) {
#line 274
      *(qsize + mdeg_node) += *(qsize + rnode);
#line 275
      *(qsize + rnode) = (idxtype )0;
#line 276
      *(marker + rnode) = maxint;
#line 277
      *(forward + rnode) = - mdeg_node;
#line 278
      *(backward + rnode) = - maxint;
    } else {
#line 282
      *(forward + rnode) = nqnbrs + 1L;
#line 283
      *(backward + rnode) = (idxtype )0;
#line 284
      *(adjncy + xqnbr) = mdeg_node;
#line 285
      xqnbr ++;
#line 286
      if (xqnbr <= jstop) {
#line 286
        *(adjncy + xqnbr) = (idxtype )0;
      }
    }
#line 240
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 289
  return;
}
}
#line 305 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mmd.c"
long __mmdint(long neqns , idxtype *xadj , idxtype *adjncy , idxtype *head , idxtype *forward ,
              idxtype *backward , idxtype *qsize , idxtype *list , idxtype *marker ) 
{ 
  long fnode ;
  long ndeg ;
  long node ;

  {
#line 310
  node = 1L;
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if (! (node <= neqns)) {
#line 310
      goto while_break;
    }
#line 311
    *(head + node) = (idxtype )0;
#line 312
    *(qsize + node) = (idxtype )1;
#line 313
    *(marker + node) = (idxtype )0;
#line 314
    *(list + node) = (idxtype )0;
#line 310
    node ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  node = 1L;
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 318
    if (! (node <= neqns)) {
#line 318
      goto while_break___0;
    }
#line 319
    ndeg = *(xadj + (node + 1L)) - *(xadj + node);
#line 320
    if (ndeg == 0L) {
#line 321
      ndeg = 1L;
    }
#line 322
    fnode = *(head + ndeg);
#line 323
    *(forward + node) = fnode;
#line 324
    *(head + ndeg) = node;
#line 325
    if (fnode > 0L) {
#line 325
      *(backward + fnode) = node;
    }
#line 326
    *(backward + node) = - ndeg;
#line 318
    node ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  return (0L);
}
}
#line 348 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mmd.c"
void __mmdnum(long neqns , idxtype *perm , idxtype *invp , idxtype *qsize ) 
{ 
  long father ;
  long nextf ;
  long node ;
  long nqsize ;
  long num ;
  long root ;

  {
#line 352
  node = 1L;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (node <= neqns)) {
#line 352
      goto while_break;
    }
#line 353
    nqsize = *(qsize + node);
#line 354
    if (nqsize <= 0L) {
#line 354
      *(perm + node) = *(invp + node);
    }
#line 355
    if (nqsize > 0L) {
#line 355
      *(perm + node) = - *(invp + node);
    }
#line 352
    node ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  node = 1L;
  {
#line 359
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 359
    if (! (node <= neqns)) {
#line 359
      goto while_break___0;
    }
#line 360
    if (*(perm + node) <= 0L) {
#line 364
      father = node;
      {
#line 365
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 365
        if (! (*(perm + father) <= 0L)) {
#line 365
          goto while_break___1;
        }
#line 366
        father = - *(perm + father);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 369
      root = father;
#line 370
      num = *(perm + root) + 1L;
#line 371
      *(invp + node) = - num;
#line 372
      *(perm + root) = num;
#line 375
      father = node;
#line 376
      nextf = - *(perm + father);
      {
#line 377
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 377
        if (! (nextf > 0L)) {
#line 377
          goto while_break___2;
        }
#line 378
        *(perm + father) = - root;
#line 379
        father = nextf;
#line 380
        nextf = - *(perm + father);
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 359
    node ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 386
  node = 1L;
  {
#line 386
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 386
    if (! (node <= neqns)) {
#line 386
      goto while_break___3;
    }
#line 387
    num = - *(invp + node);
#line 388
    *(invp + node) = num;
#line 389
    *(perm + num) = node;
#line 386
    node ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 391
  return;
}
}
#line 412 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mmd.c"
void __mmdupd(long ehead , long neqns , idxtype *xadj , idxtype *adjncy , long delta ,
              long *mdeg , idxtype *head , idxtype *forward , idxtype *backward ,
              idxtype *qsize , idxtype *list , idxtype *marker , long maxint , long *tag ) 
{ 
  long deg ;
  long deg0 ;
  long element ;
  long enode ;
  long fnode ;
  long i ;
  long iq2 ;
  long istop ;
  long istart ;
  long j ;
  long jstop ;
  long jstart ;
  long link ;
  long mdeg0 ;
  long mtag ;
  long nabor ;
  long node ;
  long q2head ;
  long qxhead ;

  {
#line 420
  mdeg0 = *mdeg + delta;
#line 421
  element = ehead;
  n100: 
#line 424
  if (element <= 0L) {
#line 424
    return;
  }
#line 428
  mtag = *tag + mdeg0;
#line 429
  if (mtag >= maxint) {
#line 430
    *tag = 1L;
#line 431
    i = 1L;
    {
#line 431
    while (1) {
      while_continue: /* CIL Label */ ;
#line 431
      if (! (i <= neqns)) {
#line 431
        goto while_break;
      }
#line 432
      if (*(marker + i) < maxint) {
#line 432
        *(marker + i) = (idxtype )0;
      }
#line 431
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 433
    mtag = *tag + mdeg0;
  }
#line 440
  q2head = 0L;
#line 441
  qxhead = 0L;
#line 442
  deg0 = 0L;
#line 443
  link = element;
  n400: 
#line 446
  istart = *(xadj + link);
#line 447
  istop = *(xadj + (link + 1L)) - 1L;
#line 448
  i = istart;
  {
#line 448
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 448
    if (! (i <= istop)) {
#line 448
      goto while_break___0;
    }
#line 449
    enode = *(adjncy + i);
#line 450
    link = - enode;
#line 451
    if (enode < 0L) {
#line 451
      goto n400;
    }
#line 452
    if (enode == 0L) {
#line 452
      goto while_break___0;
    }
#line 453
    if (*(qsize + enode) != 0L) {
#line 454
      deg0 += *(qsize + enode);
#line 455
      *(marker + enode) = mtag;
#line 458
      if (*(backward + enode) == 0L) {
#line 460
        if (*(forward + enode) != 2L) {
#line 461
          *(list + enode) = qxhead;
#line 462
          qxhead = enode;
        } else {
#line 464
          *(list + enode) = q2head;
#line 465
          q2head = enode;
        }
      }
    }
#line 448
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 472
  enode = q2head;
#line 473
  iq2 = 1L;
  n900: 
#line 476
  if (enode <= 0L) {
#line 476
    goto n1500;
  }
#line 477
  if (*(backward + enode) != 0L) {
#line 477
    goto n2200;
  }
#line 478
  (*tag) ++;
#line 479
  deg = deg0;
#line 482
  istart = *(xadj + enode);
#line 483
  nabor = *(adjncy + istart);
#line 484
  if (nabor == element) {
#line 484
    nabor = *(adjncy + (istart + 1L));
  }
#line 485
  link = nabor;
#line 486
  if (*(forward + nabor) >= 0L) {
#line 488
    deg += *(qsize + nabor);
#line 489
    goto n2100;
  }
  n1000: 
#line 495
  istart = *(xadj + link);
#line 496
  istop = *(xadj + (link + 1L)) - 1L;
#line 497
  i = istart;
  {
#line 497
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 497
    if (! (i <= istop)) {
#line 497
      goto while_break___1;
    }
#line 498
    node = *(adjncy + i);
#line 499
    link = - node;
#line 500
    if (node != enode) {
#line 501
      if (node < 0L) {
#line 501
        goto n1000;
      }
#line 502
      if (node == 0L) {
#line 502
        goto n2100;
      }
#line 503
      if (*(qsize + node) != 0L) {
#line 504
        if (*(marker + node) < *tag) {
#line 506
          *(marker + node) = *tag;
#line 507
          deg += *(qsize + node);
        } else
#line 509
        if (*(backward + node) == 0L) {
#line 510
          if (*(forward + node) == 2L) {
#line 513
            *(qsize + enode) += *(qsize + node);
#line 514
            *(qsize + node) = (idxtype )0;
#line 515
            *(marker + node) = maxint;
#line 516
            *(forward + node) = - enode;
#line 517
            *(backward + node) = - maxint;
          } else
#line 520
          if (*(backward + node) == 0L) {
#line 520
            *(backward + node) = - maxint;
          }
        }
      }
    }
#line 497
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 527
  goto n2100;
  n1500: 
#line 531
  enode = qxhead;
#line 532
  iq2 = 0L;
  n1600: 
#line 534
  if (enode <= 0L) {
#line 534
    goto n2300;
  }
#line 535
  if (*(backward + enode) != 0L) {
#line 535
    goto n2200;
  }
#line 536
  (*tag) ++;
#line 537
  deg = deg0;
#line 540
  istart = *(xadj + enode);
#line 541
  istop = *(xadj + (enode + 1L)) - 1L;
#line 542
  i = istart;
  {
#line 542
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 542
    if (! (i <= istop)) {
#line 542
      goto while_break___2;
    }
#line 543
    nabor = *(adjncy + i);
#line 544
    if (nabor == 0L) {
#line 544
      goto while_break___2;
    }
#line 545
    if (*(marker + nabor) < *tag) {
#line 546
      *(marker + nabor) = *tag;
#line 547
      link = nabor;
#line 548
      if (*(forward + nabor) >= 0L) {
#line 550
        deg += *(qsize + nabor);
      } else {
        n1700: 
#line 555
        jstart = *(xadj + link);
#line 556
        jstop = *(xadj + (link + 1L)) - 1L;
#line 557
        j = jstart;
        {
#line 557
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 557
          if (! (j <= jstop)) {
#line 557
            goto while_break___3;
          }
#line 558
          node = *(adjncy + j);
#line 559
          link = - node;
#line 560
          if (node < 0L) {
#line 560
            goto n1700;
          }
#line 561
          if (node == 0L) {
#line 561
            goto while_break___3;
          }
#line 562
          if (*(marker + node) < *tag) {
#line 563
            *(marker + node) = *tag;
#line 564
            deg += *(qsize + node);
          }
#line 557
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 542
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  n2100: 
#line 574
  deg = (deg - *(qsize + enode)) + 1L;
#line 575
  fnode = *(head + deg);
#line 576
  *(forward + enode) = fnode;
#line 577
  *(backward + enode) = - deg;
#line 578
  if (fnode > 0L) {
#line 578
    *(backward + fnode) = enode;
  }
#line 579
  *(head + deg) = enode;
#line 580
  if (deg < *mdeg) {
#line 580
    *mdeg = deg;
  }
  n2200: 
#line 584
  enode = *(list + enode);
#line 585
  if (iq2 == 1L) {
#line 585
    goto n900;
  }
#line 586
  goto n1600;
  n2300: 
#line 590
  *tag = mtag;
#line 591
  element = *(list + element);
#line 592
  goto n100;
}
}
#line 271 "./proto.h"
long __MCMlevelKWayPartitioning(CtrlType *ctrl , GraphType *graph , long nparts ,
                                idxtype *part , float *rubvec ) ;
#line 284
void __MocRefineKWayHorizontal(CtrlType *ctrl , GraphType *orggraph , GraphType *graph ,
                               long nparts , float *ubvec ) ;
#line 285
void __MocAllocateKWayPartitionMemory(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 405
void __ComputePartitionInfo(GraphType *graph , long nparts , idxtype *where ) ;
#line 462
long __ilog2(long a ) ;
#line 23 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mkmetis.c"
void METIS_mCPartGraphKway(long *nvtxs , long *ncon , idxtype *xadj , idxtype *adjncy ,
                           idxtype *vwgt , idxtype *adjwgt , long *wgtflag , long *numflag ,
                           long *nparts , float *rubvec , long *options , long *edgecut ,
                           idxtype *part ) 
{ 
  GraphType graph ;
  CtrlType ctrl ;
  long tmp___0 ;
  long tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
#line 32
  if (*numflag == 1L) {
    {
#line 33
    __Change2CNumbering(*nvtxs, xadj, adjncy);
    }
  }
  {
#line 35
  __SetUpGraph(& graph, 2L, *nvtxs, *ncon, xadj, adjncy, vwgt, adjwgt, *wgtflag);
  }
#line 37
  if (*(options + 0) == 0L) {
#line 38
    ctrl.CType = 5L;
#line 39
    ctrl.IType = 2L;
#line 40
    ctrl.RType = 1L;
#line 41
    ctrl.dbglvl = 0L;
  } else {
#line 44
    ctrl.CType = *(options + 1);
#line 45
    ctrl.IType = *(options + 2);
#line 46
    ctrl.RType = *(options + 3);
#line 47
    ctrl.dbglvl = *(options + 4);
  }
  {
#line 49
  ctrl.optype = 2L;
#line 50
  tmp___1 = __ilog2(*nparts);
  }
#line 50
  if (*nvtxs / (20L * tmp___1) >= 30L * *nparts) {
    {
#line 50
    tmp___0 = __ilog2(*nparts);
#line 50
    ctrl.CoarsenTo = *nvtxs / (20L * tmp___0);
    }
  } else {
#line 50
    ctrl.CoarsenTo = 30L * *nparts;
  }
  {
#line 52
  ctrl.nmaxvwgt = (float )(1.5 / (1.0 * (double )ctrl.CoarsenTo));
#line 54
  __InitRandom(-1L);
#line 56
  __AllocateWorkSpace(& ctrl, & graph, *nparts);
  }
#line 58
  if (ctrl.dbglvl & 1L) {
    {
#line 58
    __InitTimers(& ctrl);
    }
  }
#line 59
  if (ctrl.dbglvl & 1L) {
    {
#line 59
    tmp___2 = __seconds();
#line 59
    ctrl.TotalTmr -= tmp___2;
    }
  }
  {
#line 61
  *edgecut = __MCMlevelKWayPartitioning(& ctrl, & graph, *nparts, part, rubvec);
  }
#line 63
  if (ctrl.dbglvl & 1L) {
    {
#line 63
    tmp___3 = __seconds();
#line 63
    ctrl.TotalTmr += tmp___3;
    }
  }
#line 64
  if (ctrl.dbglvl & 1L) {
    {
#line 64
    __PrintTimers(& ctrl);
    }
  }
  {
#line 66
  __FreeWorkSpace(& ctrl, & graph);
  }
#line 68
  if (*numflag == 1L) {
    {
#line 69
    __Change2FNumbering(*nvtxs, xadj, adjncy, part);
    }
  }
#line 70
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mkmetis.c"
long __MCMlevelKWayPartitioning(CtrlType *ctrl , GraphType *graph , long nparts ,
                                idxtype *part , float *rubvec ) 
{ 
  long i ;
  GraphType *cgraph ;
  long options[10] ;
  long edgecut ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 83
  cgraph = __MCCoarsen2Way(ctrl, graph);
  }
#line 85
  if (ctrl->dbglvl & 1L) {
    {
#line 85
    tmp = __seconds();
#line 85
    ctrl->InitPartTmr -= tmp;
    }
  }
  {
#line 86
  __MocAllocateKWayPartitionMemory(ctrl, cgraph, nparts);
#line 88
  options[0] = 1L;
#line 89
  options[1] = 8L;
#line 90
  options[2] = 2L;
#line 91
  options[3] = 1L;
#line 92
  options[4] = 0L;
#line 95
  i = 0L;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < graph->ncon)) {
#line 95
      goto while_break;
    }
#line 96
    if ((double )*(rubvec + i) > 1.2) {
#line 97
      goto while_break;
    }
#line 95
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  if (i == graph->ncon) {
    {
#line 100
    METIS_mCPartGraphRecursiveInternal(& cgraph->nvtxs, & cgraph->ncon, cgraph->xadj,
                                       cgraph->adjncy, cgraph->nvwgt, cgraph->adjwgt,
                                       & nparts, options, & edgecut, cgraph->where);
    }
  } else {
    {
#line 104
    METIS_mCHPartGraphRecursiveInternal(& cgraph->nvtxs, & cgraph->ncon, cgraph->xadj,
                                        cgraph->adjncy, cgraph->nvwgt, cgraph->adjwgt,
                                        & nparts, rubvec, options, & edgecut, cgraph->where);
    }
  }
#line 109
  if (ctrl->dbglvl & 1L) {
    {
#line 109
    tmp___0 = __seconds();
#line 109
    ctrl->InitPartTmr += tmp___0;
    }
  }
#line 110
  if (ctrl->dbglvl & 16L) {
    {
#line 110
    printf((char const   */* __restrict  */)"Initial %ld-way partitioning cut: %ld\n",
           nparts, edgecut);
    }
  }
#line 112
  if (ctrl->dbglvl & 64L) {
    {
#line 112
    __ComputePartitionInfo(cgraph, nparts, cgraph->where);
    }
  }
  {
#line 114
  __MocRefineKWayHorizontal(ctrl, graph, cgraph, nparts, rubvec);
#line 116
  memcpy((void */* __restrict  */)((void *)part), (void const   */* __restrict  */)((void *)graph->where),
         sizeof(idxtype ) * (unsigned long )graph->nvtxs);
#line 118
  __GKfree(& graph->nvwgt, & graph->npwgts, & graph->gdata, & graph->rdata, (void **)0);
  }
#line 120
  return (graph->mincut);
}
}
#line 454 "./proto.h"
float __snorm2(long n , float *v ) ;
#line 20 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mfm.c"
void __MocFM_2WayEdgeRefine(CtrlType *ctrl , GraphType *graph , float *tpwgts , long npasses ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long l ;
  long kwgt ;
  long nvtxs ;
  long ncon ;
  long nbnd ;
  long nswaps ;
  long from ;
  long to ;
  long pass ;
  long limit ;
  long tmp ;
  long cnum ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *id ;
  idxtype *ed ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *moved ;
  idxtype *swaps ;
  idxtype *perm ;
  idxtype *qnum ;
  float *nvwgt ;
  float *npwgts ;
  float mindiff[16] ;
  float origbal ;
  float minbal ;
  float newbal ;
  PQueueType parts[16][2] ;
  long higain ;
  long oldgain ;
  long mincut ;
  long initcut ;
  long newcut ;
  long mincutorder ;
  float rtpwgts[2] ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  idxtype tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  float tmp___10 ;

  {
  {
#line 30
  nvtxs = graph->nvtxs;
#line 31
  ncon = graph->ncon;
#line 32
  xadj = graph->xadj;
#line 33
  nvwgt = graph->nvwgt;
#line 34
  adjncy = graph->adjncy;
#line 35
  adjwgt = graph->adjwgt;
#line 36
  where = graph->where;
#line 37
  id = graph->id;
#line 38
  ed = graph->ed;
#line 39
  npwgts = graph->npwgts;
#line 40
  bndptr = graph->bndptr;
#line 41
  bndind = graph->bndind;
#line 43
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 44
  swaps = __idxwspacemalloc(ctrl, nvtxs);
#line 45
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 46
  qnum = __idxwspacemalloc(ctrl, nvtxs);
  }
#line 48
  if (0.01 * (double )nvtxs >= (double )25) {
#line 48
    tmp___2 = 0.01 * (double )nvtxs;
  } else {
#line 48
    tmp___2 = (double )25;
  }
#line 48
  if (tmp___2 >= (double )150) {
#line 48
    limit = 150L;
  } else {
#line 48
    if (0.01 * (double )nvtxs >= (double )25) {
#line 48
      tmp___1 = 0.01 * (double )nvtxs;
    } else {
#line 48
      tmp___1 = (double )25;
    }
#line 48
    limit = (long )tmp___1;
  }
#line 51
  i = 0L;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (i < ncon)) {
#line 51
      goto while_break;
    }
    {
#line 52
    __PQueueInit(ctrl, & parts[i][0], nvtxs, 501L);
#line 53
    __PQueueInit(ctrl, & parts[i][1], nvtxs, 501L);
#line 51
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  i = 0L;
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if (! (i < nvtxs)) {
#line 55
      goto while_break___0;
    }
    {
#line 56
    *(qnum + i) = __samax(ncon, nvwgt + i * ncon);
#line 55
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 58
  origbal = __Compute2WayHLoadImbalance(ncon, npwgts, tpwgts);
#line 60
  rtpwgts[0] = origbal * *(tpwgts + 0);
#line 61
  rtpwgts[1] = origbal * *(tpwgts + 1);
  }
#line 64
  if (ctrl->dbglvl & 8L) {
    {
#line 65
    printf((char const   */* __restrict  */)"Parts: [");
#line 66
    l = 0L;
    }
    {
#line 66
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 66
      if (! (l < ncon)) {
#line 66
        goto while_break___1;
      }
      {
#line 67
      printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
             (double )*(npwgts + (ncon + l)));
#line 66
      l ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 68
    printf((char const   */* __restrict  */)"] T[%.3f %.3f], Nv-Nb[%5ld, %5ld]. ICut: %6ld, LB: %.3f\n",
           (double )*(tpwgts + 0), (double )*(tpwgts + 1), graph->nvtxs, graph->nbnd,
           graph->mincut, (double )origbal);
    }
  }
  {
#line 71
  __idxset(nvtxs, (idxtype )-1, moved);
#line 72
  pass = 0L;
  }
  {
#line 72
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 72
    if (! (pass < npasses)) {
#line 72
      goto while_break___2;
    }
#line 73
    i = 0L;
    {
#line 73
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 73
      if (! (i < ncon)) {
#line 73
        goto while_break___3;
      }
      {
#line 74
      __PQueueReset(& parts[i][0]);
#line 75
      __PQueueReset(& parts[i][1]);
#line 73
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 78
    mincutorder = -1L;
#line 79
    initcut = graph->mincut;
#line 79
    mincut = initcut;
#line 79
    newcut = mincut;
#line 80
    i = 0L;
    {
#line 80
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 80
      if (! (i < ncon)) {
#line 80
        goto while_break___4;
      }
      {
#line 81
      tmp___3 = fabs((double )(*(tpwgts + 0) - *(npwgts + i)));
#line 81
      mindiff[i] = (float )tmp___3;
#line 80
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 82
    minbal = __Compute2WayHLoadImbalance(ncon, npwgts, tpwgts);
#line 88
    nbnd = graph->nbnd;
#line 89
    __RandomPermute(nbnd, perm, 1L);
#line 90
    ii = 0L;
    }
    {
#line 90
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 90
      if (! (ii < nbnd)) {
#line 90
        goto while_break___5;
      }
      {
#line 91
      i = *(bndind + *(perm + ii));
#line 94
      __PQueueInsert(& parts[*(qnum + i)][*(where + i)], i, *(ed + i) - *(id + i));
#line 90
      ii ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 97
    nswaps = 0L;
    {
#line 97
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 97
      if (! (nswaps < nvtxs)) {
#line 97
        goto while_break___6;
      }
      {
#line 98
      __SelectQueue(ncon, npwgts, rtpwgts, & from, & cnum, (PQueueType (*)[2])(parts));
#line 99
      to = (from + 1L) % 2L;
      }
#line 101
      if (from == -1L) {
#line 102
        goto while_break___6;
      } else {
        {
#line 101
        higain = __PQueueGetMax(& parts[cnum][from]);
        }
#line 101
        if (higain == -1L) {
#line 102
          goto while_break___6;
        }
      }
      {
#line 105
      __saxpy(ncon, (float )1.0, nvwgt + higain * ncon, 1L, npwgts + to * ncon, 1L);
#line 106
      __saxpy(ncon, (float )(- 1.0), nvwgt + higain * ncon, 1L, npwgts + from * ncon,
              1L);
#line 108
      newcut -= *(ed + higain) - *(id + higain);
#line 109
      newbal = __Compute2WayHLoadImbalance(ncon, npwgts, tpwgts);
      }
#line 111
      if (newcut < mincut) {
#line 111
        if ((double )(newbal - origbal) <= .00001) {
#line 111
          goto _L___1;
        } else {
#line 111
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 111
      if (newcut == mincut) {
#line 111
        if (newbal < minbal) {
#line 111
          goto _L___1;
        } else
#line 111
        if (newbal == minbal) {
          {
#line 111
          tmp___5 = __BetterBalance(ncon, npwgts, tpwgts, mindiff);
          }
#line 111
          if (tmp___5) {
            _L___1: /* CIL Label */ 
#line 114
            mincut = newcut;
#line 115
            minbal = newbal;
#line 116
            mincutorder = nswaps;
#line 117
            i = 0L;
            {
#line 117
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 117
              if (! (i < ncon)) {
#line 117
                goto while_break___7;
              }
              {
#line 118
              tmp___4 = fabs((double )(*(tpwgts + 0) - *(npwgts + i)));
#line 118
              mindiff[i] = (float )tmp___4;
#line 117
              i ++;
              }
            }
            while_break___7: /* CIL Label */ ;
            }
          } else {
#line 111
            goto _L___0;
          }
        } else {
#line 111
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 120
      if (nswaps - mincutorder > limit) {
        {
#line 121
        newcut += *(ed + higain) - *(id + higain);
#line 122
        __saxpy(ncon, (float )1.0, nvwgt + higain * ncon, 1L, npwgts + from * ncon,
                1L);
#line 123
        __saxpy(ncon, (float )(- 1.0), nvwgt + higain * ncon, 1L, npwgts + to * ncon,
                1L);
        }
#line 124
        goto while_break___6;
      }
#line 127
      *(where + higain) = to;
#line 128
      *(moved + higain) = nswaps;
#line 129
      *(swaps + nswaps) = higain;
#line 131
      if (ctrl->dbglvl & 32L) {
        {
#line 132
        printf((char const   */* __restrict  */)"Moved %6ld from %ld(%ld). Gain: %5ld, Cut: %5ld, NPwgts: ",
               higain, from, cnum, *(ed + higain) - *(id + higain), newcut);
#line 133
        l = 0L;
        }
        {
#line 133
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 133
          if (! (l < ncon)) {
#line 133
            goto while_break___8;
          }
          {
#line 134
          printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
                 (double )*(npwgts + (ncon + l)));
#line 133
          l ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 135
        printf((char const   */* __restrict  */)", %.3f LB: %.3f\n", (double )minbal,
               (double )newbal);
        }
      }
      {
#line 142
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 142
        tmp = *(id + higain);
#line 142
        *(id + higain) = *(ed + higain);
#line 142
        *(ed + higain) = tmp;
#line 142
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 143
      if (*(ed + higain) == 0L) {
#line 143
        if (*(xadj + higain) < *(xadj + (higain + 1L))) {
          {
#line 144
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 144
            nbnd --;
#line 144
            *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 144
            *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 144
            *(bndptr + higain) = (idxtype )-1;
#line 144
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
        }
      }
#line 146
      j = *(xadj + higain);
      {
#line 146
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 146
        if (! (j < *(xadj + (higain + 1L)))) {
#line 146
          goto while_break___11;
        }
#line 147
        k = *(adjncy + j);
#line 148
        oldgain = *(ed + k) - *(id + k);
#line 150
        if (to == *(where + k)) {
#line 150
          kwgt = *(adjwgt + j);
        } else {
#line 150
          kwgt = - *(adjwgt + j);
        }
        {
#line 151
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 151
          *(id + k) += kwgt;
#line 151
          *(ed + k) -= kwgt;
#line 151
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 154
        if (*(bndptr + k) != -1L) {
#line 155
          if (*(ed + k) == 0L) {
            {
#line 156
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 156
              nbnd --;
#line 156
              *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 156
              *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 156
              *(bndptr + k) = (idxtype )-1;
#line 156
              goto while_break___13;
            }
            while_break___13: /* CIL Label */ ;
            }
#line 157
            if (*(moved + k) == -1L) {
              {
#line 158
              __PQueueDelete(& parts[*(qnum + k)][*(where + k)], k, oldgain);
              }
            }
          } else
#line 161
          if (*(moved + k) == -1L) {
            {
#line 162
            __PQueueUpdate(& parts[*(qnum + k)][*(where + k)], k, oldgain, *(ed + k) - *(id + k));
            }
          }
        } else
#line 166
        if (*(ed + k) > 0L) {
          {
#line 167
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 167
            *(bndind + nbnd) = k;
#line 167
            tmp___6 = nbnd;
#line 167
            nbnd ++;
#line 167
            *(bndptr + k) = tmp___6;
#line 167
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 168
          if (*(moved + k) == -1L) {
            {
#line 169
            __PQueueInsert(& parts[*(qnum + k)][*(where + k)], k, *(ed + k) - *(id + k));
            }
          }
        }
#line 146
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 97
      nswaps ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 180
    i = 0L;
    {
#line 180
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 180
      if (! (i < nswaps)) {
#line 180
        goto while_break___15;
      }
#line 181
      *(moved + *(swaps + i)) = (idxtype )-1;
#line 180
      i ++;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 182
    nswaps --;
    {
#line 182
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 182
      if (! (nswaps > mincutorder)) {
#line 182
        goto while_break___16;
      }
#line 183
      higain = *(swaps + nswaps);
#line 185
      tmp___7 = (*(where + higain) + 1L) % 2L;
#line 185
      *(where + higain) = tmp___7;
#line 185
      to = tmp___7;
      {
#line 186
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 186
        tmp = *(id + higain);
#line 186
        *(id + higain) = *(ed + higain);
#line 186
        *(ed + higain) = tmp;
#line 186
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 187
      if (*(ed + higain) == 0L) {
#line 187
        if (*(bndptr + higain) != -1L) {
#line 187
          if (*(xadj + higain) < *(xadj + (higain + 1L))) {
            {
#line 188
            while (1) {
              while_continue___18: /* CIL Label */ ;
#line 188
              nbnd --;
#line 188
              *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 188
              *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 188
              *(bndptr + higain) = (idxtype )-1;
#line 188
              goto while_break___18;
            }
            while_break___18: /* CIL Label */ ;
            }
          } else {
#line 187
            goto _L___4;
          }
        } else {
#line 187
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 189
      if (*(ed + higain) > 0L) {
#line 189
        if (*(bndptr + higain) == -1L) {
          {
#line 190
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 190
            *(bndind + nbnd) = higain;
#line 190
            tmp___8 = nbnd;
#line 190
            nbnd ++;
#line 190
            *(bndptr + higain) = tmp___8;
#line 190
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
        }
      }
      {
#line 192
      __saxpy(ncon, (float )1.0, nvwgt + higain * ncon, 1L, npwgts + to * ncon, 1L);
#line 193
      __saxpy(ncon, (float )(- 1.0), nvwgt + higain * ncon, 1L, npwgts + ((to + 1L) % 2L) * ncon,
              1L);
#line 194
      j = *(xadj + higain);
      }
      {
#line 194
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 194
        if (! (j < *(xadj + (higain + 1L)))) {
#line 194
          goto while_break___20;
        }
#line 195
        k = *(adjncy + j);
#line 197
        if (to == *(where + k)) {
#line 197
          kwgt = *(adjwgt + j);
        } else {
#line 197
          kwgt = - *(adjwgt + j);
        }
        {
#line 198
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 198
          *(id + k) += kwgt;
#line 198
          *(ed + k) -= kwgt;
#line 198
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
#line 200
        if (*(bndptr + k) != -1L) {
#line 200
          if (*(ed + k) == 0L) {
            {
#line 201
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 201
              nbnd --;
#line 201
              *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 201
              *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 201
              *(bndptr + k) = (idxtype )-1;
#line 201
              goto while_break___22;
            }
            while_break___22: /* CIL Label */ ;
            }
          }
        }
#line 202
        if (*(bndptr + k) == -1L) {
#line 202
          if (*(ed + k) > 0L) {
            {
#line 203
            while (1) {
              while_continue___23: /* CIL Label */ ;
#line 203
              *(bndind + nbnd) = k;
#line 203
              tmp___9 = nbnd;
#line 203
              nbnd ++;
#line 203
              *(bndptr + k) = tmp___9;
#line 203
              goto while_break___23;
            }
            while_break___23: /* CIL Label */ ;
            }
          }
        }
#line 194
        j ++;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 182
      nswaps --;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 207
    if (ctrl->dbglvl & 8L) {
      {
#line 208
      printf((char const   */* __restrict  */)"\tMincut: %6ld at %5ld, NBND: %6ld, NPwgts: [",
             mincut, mincutorder, nbnd);
#line 209
      l = 0L;
      }
      {
#line 209
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 209
        if (! (l < ncon)) {
#line 209
          goto while_break___24;
        }
        {
#line 210
        printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
               (double )*(npwgts + (ncon + l)));
#line 209
        l ++;
        }
      }
      while_break___24: /* CIL Label */ ;
      }
      {
#line 211
      tmp___10 = __Compute2WayHLoadImbalance(ncon, npwgts, tpwgts);
#line 211
      printf((char const   */* __restrict  */)"], LB: %.3f\n", (double )tmp___10);
      }
    }
#line 214
    graph->mincut = mincut;
#line 215
    graph->nbnd = nbnd;
#line 217
    if (mincutorder == -1L) {
#line 218
      goto while_break___2;
    } else
#line 217
    if (mincut == initcut) {
#line 218
      goto while_break___2;
    }
#line 72
    pass ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 221
  i = 0L;
  {
#line 221
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 221
    if (! (i < ncon)) {
#line 221
      goto while_break___25;
    }
    {
#line 222
    __PQueueFree(ctrl, & parts[i][0]);
#line 223
    __PQueueFree(ctrl, & parts[i][1]);
#line 221
    i ++;
    }
  }
  while_break___25: /* CIL Label */ ;
  }
  {
#line 226
  __idxwspacefree(ctrl, nvtxs);
#line 227
  __idxwspacefree(ctrl, nvtxs);
#line 228
  __idxwspacefree(ctrl, nvtxs);
#line 229
  __idxwspacefree(ctrl, nvtxs);
  }
#line 231
  return;
}
}
#line 238 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mfm.c"
void __SelectQueue(long ncon , float *npwgts , float *tpwgts , long *from , long *cnum ,
                   PQueueType (*queues)[2] ) 
{ 
  long i ;
  long part ;
  long maxgain ;
  float max ;
  float maxdiff ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 240
  maxgain = 0L;
#line 241
  maxdiff = (float )0.0;
#line 243
  *from = -1L;
#line 244
  *cnum = -1L;
#line 247
  part = 0L;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (part < 2L)) {
#line 247
      goto while_break;
    }
#line 248
    i = 0L;
    {
#line 248
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 248
      if (! (i < ncon)) {
#line 248
        goto while_break___0;
      }
#line 249
      if (*(npwgts + (part * ncon + i)) - *(tpwgts + part) >= maxdiff) {
#line 250
        maxdiff = *(npwgts + (part * ncon + i)) - *(tpwgts + part);
#line 251
        *from = part;
#line 252
        *cnum = i;
      }
#line 248
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 247
    part ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  if (*from != -1L) {
    {
#line 259
    tmp___1 = PQueueGetSize(& (*(queues + *cnum))[*from]);
    }
#line 259
    if (tmp___1 == 0L) {
#line 261
      i = 0L;
      {
#line 261
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 261
        if (! (i < ncon)) {
#line 261
          goto while_break___1;
        }
        {
#line 262
        tmp = PQueueGetSize(& (*(queues + i))[*from]);
        }
#line 262
        if (tmp > 0L) {
#line 263
          max = *(npwgts + (*from * ncon + i));
#line 264
          *cnum = i;
#line 265
          goto while_break___1;
        }
#line 261
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 269
      i ++;
      {
#line 269
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 269
        if (! (i < ncon)) {
#line 269
          goto while_break___2;
        }
#line 270
        if (*(npwgts + (*from * ncon + i)) > max) {
          {
#line 270
          tmp___0 = PQueueGetSize(& (*(queues + i))[*from]);
          }
#line 270
          if (tmp___0 > 0L) {
#line 271
            max = *(npwgts + (*from * ncon + i));
#line 272
            *cnum = i;
          }
        }
#line 269
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 278
  if ((double )maxdiff <= 0.0) {
#line 278
    goto _L;
  } else
#line 278
  if (*from == -1L) {
    _L: /* CIL Label */ 
#line 279
    maxgain = -100000L;
#line 281
    part = 0L;
    {
#line 281
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 281
      if (! (part < 2L)) {
#line 281
        goto while_break___3;
      }
#line 282
      i = 0L;
      {
#line 282
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 282
        if (! (i < ncon)) {
#line 282
          goto while_break___4;
        }
        {
#line 283
        tmp___2 = PQueueGetSize(& (*(queues + i))[part]);
        }
#line 283
        if (tmp___2 > 0L) {
          {
#line 283
          tmp___3 = PQueueGetKey(& (*(queues + i))[part]);
          }
#line 283
          if (tmp___3 > maxgain) {
            {
#line 284
            maxgain = PQueueGetKey(& (*(queues + i))[part]);
#line 285
            *from = part;
#line 286
            *cnum = i;
            }
          }
        }
#line 282
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 281
      part ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 293
  return;
}
}
#line 303 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mfm.c"
long __BetterBalance(long ncon , float *npwgts , float *tpwgts , float *diff ) 
{ 
  long i ;
  float ndiff[16] ;
  double tmp ;
  float tmp___0 ;
  float tmp___1 ;

  {
#line 308
  i = 0L;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (i < ncon)) {
#line 308
      goto while_break;
    }
    {
#line 309
    tmp = fabs((double )(*(tpwgts + 0) - *(npwgts + i)));
#line 309
    ndiff[i] = (float )tmp;
#line 308
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 311
  tmp___0 = __snorm2(ncon, ndiff);
#line 311
  tmp___1 = __snorm2(ncon, diff);
  }
#line 311
  return ((long )(tmp___0 < tmp___1));
}
}
#line 319 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mfm.c"
float __Compute2WayHLoadImbalance(long ncon , float *npwgts , float *tpwgts ) 
{ 
  long i ;
  float max ;
  float temp ;
  double tmp ;

  {
#line 322
  max = (float )0.0;
#line 324
  i = 0L;
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! (i < ncon)) {
#line 324
      goto while_break;
    }
    {
#line 326
    tmp = fabs((double )(*(tpwgts + 0) - *(npwgts + i)));
#line 326
    temp = (float )(tmp / (double )*(tpwgts + 0));
    }
#line 327
    if (max < temp) {
#line 327
      max = temp;
    } else {
#line 327
      max = max;
    }
#line 324
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  return ((float )(1.0 + (double )max));
}
}
#line 337 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mfm.c"
void __Compute2WayHLoadImbalanceVec(long ncon , float *npwgts , float *tpwgts , float *lbvec ) 
{ 
  long i ;
  double tmp ;

  {
#line 341
  i = 0L;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! (i < ncon)) {
#line 341
      goto while_break;
    }
    {
#line 342
    tmp = fabs((double )(*(tpwgts + 0) - *(npwgts + i)));
#line 342
    *(lbvec + i) = (float )(1.0 + tmp / (double )*(tpwgts + 0));
#line 341
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return;
}
}
#line 214 "./proto.h"
long __WspaceAvail(CtrlType *ctrl ) ;
#line 374
void __PQueueUpdateUp(PQueueType *queue , long node , long oldgain , long newgain ) ;
#line 376
long __PQueueSeeMax(PQueueType *queue ) ;
#line 378
long __CheckHeap(PQueueType *queue ) ;
#line 23 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pqueue.c"
void __PQueueInit(CtrlType *ctrl , PQueueType *queue , long maxnodes , long maxgain ) 
{ 
  long i ;
  long j ;
  long ncore ;
  idxtype *tmp ;
  idxtype *tmp___0 ;
  idxtype *tmp___1 ;
  idxtype *tmp___2 ;
  long tmp___3 ;
  idxtype *tmp___4 ;

  {
#line 27
  queue->nnodes = 0L;
#line 28
  queue->maxnodes = maxnodes;
#line 30
  queue->buckets = (ListNodeType **)((void *)0);
#line 31
  queue->nodes = (ListNodeType *)((void *)0);
#line 32
  queue->heap = (KeyValueType *)((void *)0);
#line 33
  queue->locator = (idxtype *)((void *)0);
#line 35
  if (maxgain > 500L) {
#line 36
    queue->type = 2L;
  } else
#line 35
  if (maxnodes < 500L) {
#line 36
    queue->type = 2L;
  } else {
#line 38
    queue->type = 1L;
  }
#line 40
  if (queue->type == 1L) {
#line 41
    if (500L >= maxgain) {
#line 41
      queue->pgainspan = maxgain;
    } else {
#line 41
      queue->pgainspan = 500L;
    }
#line 42
    if (500L >= maxgain) {
#line 42
      queue->ngainspan = maxgain;
    } else {
#line 42
      queue->ngainspan = 500L;
    }
    {
#line 44
    j = (queue->ngainspan + queue->pgainspan) + 1L;
#line 46
    ncore = (long )((2UL + (sizeof(ListNodeType ) / sizeof(idxtype )) * (unsigned long )maxnodes) + (sizeof(ListNodeType *) / sizeof(idxtype )) * (unsigned long )j);
#line 48
    tmp___3 = __WspaceAvail(ctrl);
    }
#line 48
    if (tmp___3 > ncore) {
      {
#line 49
      tmp = __idxwspacemalloc(ctrl, (long )((sizeof(ListNodeType ) / sizeof(idxtype )) * (unsigned long )maxnodes));
#line 49
      queue->nodes = (ListNodeType *)tmp;
#line 50
      tmp___0 = __idxwspacemalloc(ctrl, (long )((sizeof(ListNodeType *) / sizeof(idxtype )) * (unsigned long )j));
#line 50
      queue->buckets = (ListNodeType **)tmp___0;
#line 51
      queue->mustfree = 0L;
      }
    } else {
      {
#line 54
      tmp___1 = __idxmalloc((long )((sizeof(ListNodeType ) / sizeof(idxtype )) * (unsigned long )maxnodes),
                            (char *)"PQueueInit: queue->nodes");
#line 54
      queue->nodes = (ListNodeType *)tmp___1;
#line 55
      tmp___2 = __idxmalloc((long )((sizeof(ListNodeType *) / sizeof(idxtype )) * (unsigned long )j),
                            (char *)"PQueueInit: queue->buckets");
#line 55
      queue->buckets = (ListNodeType **)tmp___2;
#line 56
      queue->mustfree = 1L;
      }
    }
#line 59
    i = 0L;
    {
#line 59
    while (1) {
      while_continue: /* CIL Label */ ;
#line 59
      if (! (i < maxnodes)) {
#line 59
        goto while_break;
      }
#line 60
      (queue->nodes + i)->id = i;
#line 59
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 62
    i = 0L;
    {
#line 62
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 62
      if (! (i < j)) {
#line 62
        goto while_break___0;
      }
#line 63
      *(queue->buckets + i) = (ListNodeType *)((void *)0);
#line 62
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 65
    queue->buckets += queue->ngainspan;
#line 66
    queue->maxgain = - queue->ngainspan;
  } else {
    {
#line 69
    tmp___4 = __idxwspacemalloc(ctrl, (long )((sizeof(KeyValueType ) / sizeof(idxtype )) * (unsigned long )maxnodes));
#line 69
    queue->heap = (KeyValueType *)tmp___4;
#line 70
    queue->locator = __idxwspacemalloc(ctrl, maxnodes);
#line 71
    __idxset(maxnodes, (idxtype )-1, queue->locator);
    }
  }
#line 74
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pqueue.c"
void __PQueueReset(PQueueType *queue ) 
{ 
  long i ;
  long j ;

  {
#line 83
  queue->nnodes = 0L;
#line 85
  if (queue->type == 1L) {
#line 86
    queue->maxgain = - queue->ngainspan;
#line 88
    j = (queue->ngainspan + queue->pgainspan) + 1L;
#line 89
    queue->buckets -= queue->ngainspan;
#line 90
    i = 0L;
    {
#line 90
    while (1) {
      while_continue: /* CIL Label */ ;
#line 90
      if (! (i < j)) {
#line 90
        goto while_break;
      }
#line 91
      *(queue->buckets + i) = (ListNodeType *)((void *)0);
#line 90
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 92
    queue->buckets += queue->ngainspan;
  } else {
    {
#line 95
    __idxset(queue->maxnodes, (idxtype )-1, queue->locator);
    }
  }
#line 98
  return;
}
}
#line 104 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pqueue.c"
void __PQueueFree(CtrlType *ctrl , PQueueType *queue ) 
{ 


  {
#line 107
  if (queue->type == 1L) {
#line 108
    if (queue->mustfree) {
      {
#line 109
      queue->buckets -= queue->ngainspan;
#line 110
      __GKfree(& queue->nodes, & queue->buckets, (void **)0);
      }
    } else {
      {
#line 113
      __idxwspacefree(ctrl, (long )((sizeof(ListNodeType *) * (unsigned long )((queue->ngainspan + queue->pgainspan) + 1L)) / sizeof(idxtype )));
#line 114
      __idxwspacefree(ctrl, (long )((sizeof(ListNodeType ) * (unsigned long )queue->maxnodes) / sizeof(idxtype )));
      }
    }
  } else {
    {
#line 118
    __idxwspacefree(ctrl, (long )((sizeof(KeyValueType ) * (unsigned long )queue->maxnodes) / sizeof(idxtype )));
#line 119
    __idxwspacefree(ctrl, queue->maxnodes);
    }
  }
#line 122
  queue->maxnodes = 0L;
#line 123
  return;
}
}
#line 129 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pqueue.c"
long PQueueGetSize(PQueueType *queue ) 
{ 


  {
#line 131
  return (queue->nnodes);
}
}
#line 138 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pqueue.c"
long __PQueueInsert(PQueueType *queue , long node , long gain ) 
{ 
  long i ;
  long j ;
  idxtype *locator ;
  ListNodeType *newnode ;
  KeyValueType *heap ;
  long tmp ;

  {
#line 145
  if (queue->type == 1L) {
#line 149
    (queue->nnodes) ++;
#line 150
    newnode = queue->nodes + node;
#line 153
    newnode->next = *(queue->buckets + gain);
#line 154
    newnode->prev = (struct ListNodeType *)((void *)0);
#line 155
    if ((unsigned long )newnode->next != (unsigned long )((void *)0)) {
#line 156
      (newnode->next)->prev = newnode;
    }
#line 157
    *(queue->buckets + gain) = newnode;
#line 159
    if (queue->maxgain < gain) {
#line 160
      queue->maxgain = gain;
    }
  } else {
#line 165
    heap = queue->heap;
#line 166
    locator = queue->locator;
#line 170
    tmp = queue->nnodes;
#line 170
    (queue->nnodes) ++;
#line 170
    i = tmp;
    {
#line 171
    while (1) {
      while_continue: /* CIL Label */ ;
#line 171
      if (! (i > 0L)) {
#line 171
        goto while_break;
      }
#line 172
      j = (i - 1L) / 2L;
#line 173
      if ((heap + j)->key < gain) {
#line 174
        *(heap + i) = *(heap + j);
#line 175
        *(locator + (heap + i)->val) = i;
#line 176
        i = j;
      } else {
#line 179
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 182
    (heap + i)->key = gain;
#line 183
    (heap + i)->val = node;
#line 184
    *(locator + node) = i;
  }
#line 189
  return (0L);
}
}
#line 197 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pqueue.c"
long __PQueueDelete(PQueueType *queue , long node , long gain ) 
{ 
  long i ;
  long j ;
  long newgain ;
  long oldgain ;
  idxtype *locator ;
  ListNodeType *newnode ;
  ListNodeType **buckets ;
  KeyValueType *heap ;

  {
#line 204
  if (queue->type == 1L) {
#line 208
    buckets = queue->buckets;
#line 209
    (queue->nnodes) --;
#line 210
    newnode = queue->nodes + node;
#line 213
    if ((unsigned long )newnode->prev != (unsigned long )((void *)0)) {
#line 214
      (newnode->prev)->next = newnode->next;
    } else {
#line 216
      *(buckets + gain) = newnode->next;
    }
#line 217
    if ((unsigned long )newnode->next != (unsigned long )((void *)0)) {
#line 218
      (newnode->next)->prev = newnode->prev;
    }
#line 220
    if ((unsigned long )*(buckets + gain) == (unsigned long )((void *)0)) {
#line 220
      if (gain == queue->maxgain) {
#line 221
        if (queue->nnodes == 0L) {
#line 222
          queue->maxgain = - queue->ngainspan;
        } else {
          {
#line 224
          while (1) {
            while_continue: /* CIL Label */ ;
#line 224
            if (! ((unsigned long )*(buckets + queue->maxgain) == (unsigned long )((void *)0))) {
#line 224
              goto while_break;
            }
#line 224
            (queue->maxgain) --;
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    }
  } else {
#line 228
    heap = queue->heap;
#line 229
    locator = queue->locator;
#line 236
    i = *(locator + node);
#line 237
    *(locator + node) = (idxtype )-1;
#line 239
    (queue->nnodes) --;
#line 239
    if (queue->nnodes > 0L) {
#line 239
      if ((heap + queue->nnodes)->val != node) {
#line 240
        node = (heap + queue->nnodes)->val;
#line 241
        newgain = (heap + queue->nnodes)->key;
#line 242
        oldgain = (heap + i)->key;
#line 244
        if (oldgain < newgain) {
          {
#line 245
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 245
            if (! (i > 0L)) {
#line 245
              goto while_break___0;
            }
#line 246
            j = (i - 1L) >> 1;
#line 247
            if ((heap + j)->key < newgain) {
#line 248
              *(heap + i) = *(heap + j);
#line 249
              *(locator + (heap + i)->val) = i;
#line 250
              i = j;
            } else {
#line 253
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 257
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 257
            j = 2L * i + 1L;
#line 257
            if (! (j < queue->nnodes)) {
#line 257
              goto while_break___1;
            }
#line 258
            if ((heap + j)->key > newgain) {
#line 259
              if (j + 1L < queue->nnodes) {
#line 259
                if ((heap + (j + 1L))->key > (heap + j)->key) {
#line 260
                  j ++;
                }
              }
#line 261
              *(heap + i) = *(heap + j);
#line 262
              *(locator + (heap + i)->val) = i;
#line 263
              i = j;
            } else
#line 265
            if (j + 1L < queue->nnodes) {
#line 265
              if ((heap + (j + 1L))->key > newgain) {
#line 266
                j ++;
#line 267
                *(heap + i) = *(heap + j);
#line 268
                *(locator + (heap + i)->val) = i;
#line 269
                i = j;
              } else {
#line 272
                goto while_break___1;
              }
            } else {
#line 272
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 276
        (heap + i)->key = newgain;
#line 277
        (heap + i)->val = node;
#line 278
        *(locator + node) = i;
      }
    }
  }
#line 284
  return (0L);
}
}
#line 293 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pqueue.c"
long __PQueueUpdate(PQueueType *queue , long node , long oldgain , long newgain ) 
{ 
  long i ;
  long j ;
  idxtype *locator ;
  KeyValueType *heap ;
  long tmp ;

  {
#line 300
  if (oldgain == newgain) {
#line 301
    return (0L);
  }
#line 303
  if (queue->type == 1L) {
    {
#line 305
    __PQueueDelete(queue, node, oldgain);
#line 306
    tmp = __PQueueInsert(queue, node, newgain);
    }
#line 306
    return (tmp);
  } else {
#line 309
    heap = queue->heap;
#line 310
    locator = queue->locator;
#line 317
    i = *(locator + node);
#line 319
    if (oldgain < newgain) {
      {
#line 320
      while (1) {
        while_continue: /* CIL Label */ ;
#line 320
        if (! (i > 0L)) {
#line 320
          goto while_break;
        }
#line 321
        j = (i - 1L) >> 1;
#line 322
        if ((heap + j)->key < newgain) {
#line 323
          *(heap + i) = *(heap + j);
#line 324
          *(locator + (heap + i)->val) = i;
#line 325
          i = j;
        } else {
#line 328
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 332
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 332
        j = 2L * i + 1L;
#line 332
        if (! (j < queue->nnodes)) {
#line 332
          goto while_break___0;
        }
#line 333
        if ((heap + j)->key > newgain) {
#line 334
          if (j + 1L < queue->nnodes) {
#line 334
            if ((heap + (j + 1L))->key > (heap + j)->key) {
#line 335
              j ++;
            }
          }
#line 336
          *(heap + i) = *(heap + j);
#line 337
          *(locator + (heap + i)->val) = i;
#line 338
          i = j;
        } else
#line 340
        if (j + 1L < queue->nnodes) {
#line 340
          if ((heap + (j + 1L))->key > newgain) {
#line 341
            j ++;
#line 342
            *(heap + i) = *(heap + j);
#line 343
            *(locator + (heap + i)->val) = i;
#line 344
            i = j;
          } else {
#line 347
            goto while_break___0;
          }
        } else {
#line 347
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 351
    (heap + i)->key = newgain;
#line 352
    (heap + i)->val = node;
#line 353
    *(locator + node) = i;
  }
#line 358
  return (0L);
}
}
#line 367 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pqueue.c"
void __PQueueUpdateUp(PQueueType *queue , long node , long oldgain , long newgain ) 
{ 
  long i ;
  long j ;
  idxtype *locator ;
  ListNodeType *newnode ;
  ListNodeType **buckets ;
  KeyValueType *heap ;

  {
#line 374
  if (oldgain == newgain) {
#line 375
    return;
  }
#line 377
  if (queue->type == 1L) {
#line 382
    buckets = queue->buckets;
#line 383
    newnode = queue->nodes + node;
#line 386
    if ((unsigned long )newnode->prev != (unsigned long )((void *)0)) {
#line 387
      (newnode->prev)->next = newnode->next;
    } else {
#line 389
      *(buckets + oldgain) = newnode->next;
    }
#line 390
    if ((unsigned long )newnode->next != (unsigned long )((void *)0)) {
#line 391
      (newnode->next)->prev = newnode->prev;
    }
#line 394
    newnode->next = *(buckets + newgain);
#line 395
    newnode->prev = (struct ListNodeType *)((void *)0);
#line 396
    if ((unsigned long )newnode->next != (unsigned long )((void *)0)) {
#line 397
      (newnode->next)->prev = newnode;
    }
#line 398
    *(buckets + newgain) = newnode;
#line 400
    if (queue->maxgain < newgain) {
#line 401
      queue->maxgain = newgain;
    }
  } else {
#line 404
    heap = queue->heap;
#line 405
    locator = queue->locator;
#line 414
    i = *(locator + node);
    {
#line 415
    while (1) {
      while_continue: /* CIL Label */ ;
#line 415
      if (! (i > 0L)) {
#line 415
        goto while_break;
      }
#line 416
      j = (i - 1L) >> 1;
#line 417
      if ((heap + j)->key < newgain) {
#line 418
        *(heap + i) = *(heap + j);
#line 419
        *(locator + (heap + i)->val) = i;
#line 420
        i = j;
      } else {
#line 423
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 426
    (heap + i)->key = newgain;
#line 427
    (heap + i)->val = node;
#line 428
    *(locator + node) = i;
  }
#line 433
  return;
}
}
#line 440 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pqueue.c"
long __PQueueGetMax(PQueueType *queue ) 
{ 
  long vtx ;
  long i ;
  long j ;
  long gain ;
  long node ;
  idxtype *locator ;
  ListNodeType *tptr ;
  KeyValueType *heap ;

  {
#line 447
  if (queue->nnodes == 0L) {
#line 448
    return (-1L);
  }
#line 450
  (queue->nnodes) --;
#line 452
  if (queue->type == 1L) {
#line 453
    tptr = *(queue->buckets + queue->maxgain);
#line 454
    *(queue->buckets + queue->maxgain) = tptr->next;
#line 455
    if ((unsigned long )tptr->next != (unsigned long )((void *)0)) {
#line 456
      (tptr->next)->prev = (struct ListNodeType *)((void *)0);
    } else
#line 459
    if (queue->nnodes == 0L) {
#line 460
      queue->maxgain = - queue->ngainspan;
    } else {
      {
#line 463
      while (1) {
        while_continue: /* CIL Label */ ;
#line 463
        if (! ((unsigned long )*(queue->buckets + queue->maxgain) == (unsigned long )((void *)0))) {
#line 463
          goto while_break;
        }
#line 463
        (queue->maxgain) --;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 466
    return (tptr->id);
  } else {
#line 469
    heap = queue->heap;
#line 470
    locator = queue->locator;
#line 472
    vtx = (heap + 0)->val;
#line 473
    *(locator + vtx) = (idxtype )-1;
#line 475
    i = queue->nnodes;
#line 475
    if (i > 0L) {
#line 476
      gain = (heap + i)->key;
#line 477
      node = (heap + i)->val;
#line 478
      i = 0L;
      {
#line 479
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 479
        j = 2L * i + 1L;
#line 479
        if (! (j < queue->nnodes)) {
#line 479
          goto while_break___0;
        }
#line 480
        if ((heap + j)->key > gain) {
#line 481
          if (j + 1L < queue->nnodes) {
#line 481
            if ((heap + (j + 1L))->key > (heap + j)->key) {
#line 482
              j ++;
            }
          }
#line 483
          *(heap + i) = *(heap + j);
#line 484
          *(locator + (heap + i)->val) = i;
#line 485
          i = j;
        } else
#line 487
        if (j + 1L < queue->nnodes) {
#line 487
          if ((heap + (j + 1L))->key > gain) {
#line 488
            j ++;
#line 489
            *(heap + i) = *(heap + j);
#line 490
            *(locator + (heap + i)->val) = i;
#line 491
            i = j;
          } else {
#line 494
            goto while_break___0;
          }
        } else {
#line 494
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 497
      (heap + i)->key = gain;
#line 498
      (heap + i)->val = node;
#line 499
      *(locator + node) = i;
    }
#line 503
    return (vtx);
  }
}
}
#line 511 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pqueue.c"
long __PQueueSeeMax(PQueueType *queue ) 
{ 
  long vtx ;

  {
#line 515
  if (queue->nnodes == 0L) {
#line 516
    return (-1L);
  }
#line 518
  if (queue->type == 1L) {
#line 519
    vtx = (*(queue->buckets + queue->maxgain))->id;
  } else {
#line 521
    vtx = (queue->heap + 0)->val;
  }
#line 523
  return (vtx);
}
}
#line 530 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pqueue.c"
long PQueueGetKey(PQueueType *queue ) 
{ 
  long key ;

  {
#line 534
  if (queue->nnodes == 0L) {
#line 535
    return (-1L);
  }
#line 537
  if (queue->type == 1L) {
#line 538
    key = queue->maxgain;
  } else {
#line 540
    key = (queue->heap + 0)->key;
  }
#line 542
  return (key);
}
}
#line 551 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/pqueue.c"
long __CheckHeap(PQueueType *queue ) 
{ 
  long i ;
  long j ;
  long nnodes ;
  idxtype *locator ;
  KeyValueType *heap ;

  {
#line 557
  heap = queue->heap;
#line 558
  locator = queue->locator;
#line 559
  nnodes = queue->nnodes;
#line 561
  if (nnodes == 0L) {
#line 562
    return (1L);
  }
#line 565
  i = 1L;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 565
    if (! (i < nnodes)) {
#line 565
      goto while_break;
    }
#line 565
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 569
  i = 1L;
  {
#line 569
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 569
    if (! (i < nnodes)) {
#line 569
      goto while_break___0;
    }
#line 569
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 572
  i = 0L;
#line 572
  j = i;
  {
#line 572
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 572
    if (! (i < queue->maxnodes)) {
#line 572
      goto while_break___1;
    }
#line 573
    if (*(locator + i) != -1L) {
#line 574
      j ++;
    }
#line 572
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 578
  return (1L);
}
}
#line 168 "./proto.h"
void __ComputeKWayBoundary(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 274
void __MCRandom_KWayEdgeRefineHorizontal(CtrlType *ctrl , GraphType *graph , long nparts ,
                                         float *orgubvec , long npasses ) ;
#line 275
void __MCGreedy_KWayEdgeBalanceHorizontal(CtrlType *ctrl , GraphType *graph , long nparts ,
                                          float *ubvec , long npasses ) ;
#line 279
long __MocIsHBalanced(long ncon , long nparts , float *npwgts , float *ubvec ) ;
#line 286
void __MocComputeKWayPartitionParams(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 287
void __MocProjectKWayPartition(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 288
void __MocComputeKWayBalanceBoundary(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 20 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mkwayrefine.c"
void __MocRefineKWayHorizontal(CtrlType *ctrl , GraphType *orggraph , GraphType *graph ,
                               long nparts , float *ubvec ) 
{ 
  double tmp ;
  double tmp___0 ;
  long tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  long tmp___5 ;
  double tmp___6 ;

  {
#line 24
  if (ctrl->dbglvl & 1L) {
    {
#line 24
    tmp = __seconds();
#line 24
    ctrl->UncoarsenTmr -= tmp;
    }
  }
  {
#line 27
  __MocComputeKWayPartitionParams(ctrl, graph, nparts);
  }
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (ctrl->dbglvl & 1L) {
      {
#line 30
      tmp___0 = __seconds();
#line 30
      ctrl->RefTmr -= tmp___0;
      }
    }
    {
#line 32
    tmp___1 = __MocIsHBalanced(graph->ncon, nparts, graph->npwgts, ubvec);
    }
#line 32
    if (! tmp___1) {
      {
#line 33
      __MocComputeKWayBalanceBoundary(ctrl, graph, nparts);
#line 34
      __MCGreedy_KWayEdgeBalanceHorizontal(ctrl, graph, nparts, ubvec, 4L);
#line 35
      __ComputeKWayBoundary(ctrl, graph, nparts);
      }
    }
    {
#line 38
    __MCRandom_KWayEdgeRefineHorizontal(ctrl, graph, nparts, ubvec, 10L);
    }
#line 40
    if (ctrl->dbglvl & 1L) {
      {
#line 40
      tmp___2 = __seconds();
#line 40
      ctrl->RefTmr += tmp___2;
      }
    }
#line 42
    if ((unsigned long )graph == (unsigned long )orggraph) {
#line 43
      goto while_break;
    }
#line 45
    graph = graph->finer;
#line 46
    if (ctrl->dbglvl & 1L) {
      {
#line 46
      tmp___3 = __seconds();
#line 46
      ctrl->ProjectTmr -= tmp___3;
      }
    }
    {
#line 47
    __MocProjectKWayPartition(ctrl, graph, nparts);
    }
#line 48
    if (ctrl->dbglvl & 1L) {
      {
#line 48
      tmp___4 = __seconds();
#line 48
      ctrl->ProjectTmr += tmp___4;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 51
  tmp___5 = __MocIsHBalanced(graph->ncon, nparts, graph->npwgts, ubvec);
  }
#line 51
  if (! tmp___5) {
    {
#line 52
    __MocComputeKWayBalanceBoundary(ctrl, graph, nparts);
#line 53
    __MCGreedy_KWayEdgeBalanceHorizontal(ctrl, graph, nparts, ubvec, 4L);
#line 54
    __ComputeKWayBoundary(ctrl, graph, nparts);
#line 55
    __MCRandom_KWayEdgeRefineHorizontal(ctrl, graph, nparts, ubvec, 10L);
    }
  }
#line 58
  if (ctrl->dbglvl & 1L) {
    {
#line 58
    tmp___6 = __seconds();
#line 58
    ctrl->UncoarsenTmr += tmp___6;
    }
  }
#line 59
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mkwayrefine.c"
void __MocAllocateKWayPartitionMemory(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long nvtxs ;
  long ncon ;
  long pad64 ;

  {
  {
#line 71
  nvtxs = graph->nvtxs;
#line 72
  ncon = graph->ncon;
#line 74
  pad64 = (3L * nvtxs) % 2L;
#line 76
  graph->rdata = __idxmalloc((long )(((unsigned long )(3L * nvtxs) + (sizeof(RInfoType ) / sizeof(idxtype )) * (unsigned long )nvtxs) + (unsigned long )pad64),
                             (char *)"AllocateKWayPartitionMemory: rdata");
#line 77
  graph->where = graph->rdata;
#line 78
  graph->bndptr = graph->rdata + nvtxs;
#line 79
  graph->bndind = graph->rdata + 2L * nvtxs;
#line 80
  graph->rinfo = (RInfoType *)((graph->rdata + 3L * nvtxs) + pad64);
#line 82
  graph->npwgts = __fmalloc(ncon * nparts, (char *)"MocAllocateKWayPartitionMemory: npwgts");
  }
#line 83
  return;
}
}
#line 89 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mkwayrefine.c"
void __MocComputeKWayPartitionParams(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long i ;
  long j ;
  long k ;
  long nvtxs ;
  long ncon ;
  long nbnd ;
  long mincut ;
  long me ;
  long other ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *bndind ;
  idxtype *bndptr ;
  RInfoType *rinfo ;
  RInfoType *myrinfo ;
  EDegreeType *myedegrees ;
  float *nvwgt ;
  float *npwgts ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  EDegreeType *tmp___2 ;
  long tmp___3 ;

  {
  {
#line 97
  nvtxs = graph->nvtxs;
#line 98
  ncon = graph->ncon;
#line 99
  xadj = graph->xadj;
#line 100
  nvwgt = graph->nvwgt;
#line 101
  adjncy = graph->adjncy;
#line 102
  adjwgt = graph->adjwgt;
#line 104
  where = graph->where;
#line 105
  npwgts = __sset(ncon * nparts, (float )0.0, graph->npwgts);
#line 106
  bndind = graph->bndind;
#line 107
  bndptr = __idxset(nvtxs, (idxtype )-1, graph->bndptr);
#line 108
  rinfo = graph->rinfo;
#line 114
  ctrl->wspace.cdegree = 0L;
#line 115
  mincut = 0L;
#line 115
  nbnd = mincut;
#line 116
  i = 0L;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < nvtxs)) {
#line 116
      goto while_break;
    }
    {
#line 117
    me = *(where + i);
#line 118
    __saxpy(ncon, (float )1.0, nvwgt + i * ncon, 1L, npwgts + me * ncon, 1L);
#line 120
    myrinfo = rinfo + i;
#line 121
    tmp___0 = 0L;
#line 121
    myrinfo->ndegrees = tmp___0;
#line 121
    tmp = tmp___0;
#line 121
    myrinfo->ed = tmp;
#line 121
    myrinfo->id = tmp;
#line 122
    myrinfo->edegrees = (EDegreeType *)((void *)0);
#line 124
    j = *(xadj + i);
    }
    {
#line 124
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 124
      if (! (j < *(xadj + (i + 1L)))) {
#line 124
        goto while_break___0;
      }
#line 125
      if (me != *(where + *(adjncy + j))) {
#line 126
        myrinfo->ed += *(adjwgt + j);
      }
#line 124
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    myrinfo->id = *(graph->adjwgtsum + i) - myrinfo->ed;
#line 130
    if (myrinfo->ed > 0L) {
#line 131
      mincut += myrinfo->ed;
    }
#line 133
    if (myrinfo->ed - myrinfo->id >= 0L) {
      {
#line 134
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 134
        *(bndind + nbnd) = i;
#line 134
        tmp___1 = nbnd;
#line 134
        nbnd ++;
#line 134
        *(bndptr + i) = tmp___1;
#line 134
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 137
    if (myrinfo->ed > 0L) {
#line 138
      tmp___2 = ctrl->wspace.edegrees + ctrl->wspace.cdegree;
#line 138
      myrinfo->edegrees = tmp___2;
#line 138
      myedegrees = tmp___2;
#line 139
      ctrl->wspace.cdegree += *(xadj + (i + 1L)) - *(xadj + i);
#line 141
      j = *(xadj + i);
      {
#line 141
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 141
        if (! (j < *(xadj + (i + 1L)))) {
#line 141
          goto while_break___2;
        }
#line 142
        other = *(where + *(adjncy + j));
#line 143
        if (me != other) {
#line 144
          k = 0L;
          {
#line 144
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 144
            if (! (k < myrinfo->ndegrees)) {
#line 144
              goto while_break___3;
            }
#line 145
            if ((myedegrees + k)->pid == other) {
#line 146
              (myedegrees + k)->ed += *(adjwgt + j);
#line 147
              goto while_break___3;
            }
#line 144
            k ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 150
          if (k == myrinfo->ndegrees) {
#line 151
            (myedegrees + myrinfo->ndegrees)->pid = other;
#line 152
            tmp___3 = myrinfo->ndegrees;
#line 152
            (myrinfo->ndegrees) ++;
#line 152
            (myedegrees + tmp___3)->ed = *(adjwgt + j);
          }
        }
#line 141
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 116
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  graph->mincut = mincut / 2L;
#line 162
  graph->nbnd = nbnd;
#line 164
  return;
}
}
#line 172 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mkwayrefine.c"
void __MocProjectKWayPartition(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long i ;
  long j ;
  long k ;
  long nvtxs ;
  long nbnd ;
  long me ;
  long other ;
  long istart ;
  long iend ;
  long ndegrees ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *adjwgtsum ;
  idxtype *cmap ;
  idxtype *where ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *cwhere ;
  GraphType *cgraph ;
  RInfoType *crinfo ;
  RInfoType *rinfo ;
  RInfoType *myrinfo ;
  EDegreeType *myedegrees ;
  idxtype *htable ;
  idxtype *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  EDegreeType *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  {
#line 183
  cgraph = graph->coarser;
#line 184
  cwhere = cgraph->where;
#line 185
  crinfo = cgraph->rinfo;
#line 187
  nvtxs = graph->nvtxs;
#line 188
  cmap = graph->cmap;
#line 189
  xadj = graph->xadj;
#line 190
  adjncy = graph->adjncy;
#line 191
  adjwgt = graph->adjwgt;
#line 192
  adjwgtsum = graph->adjwgtsum;
#line 194
  __MocAllocateKWayPartitionMemory(ctrl, graph, nparts);
#line 195
  where = graph->where;
#line 196
  rinfo = graph->rinfo;
#line 197
  bndind = graph->bndind;
#line 198
  bndptr = __idxset(nvtxs, (idxtype )-1, graph->bndptr);
#line 201
  i = 0L;
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (i < nvtxs)) {
#line 201
      goto while_break;
    }
#line 202
    k = *(cmap + i);
#line 203
    *(where + i) = *(cwhere + k);
#line 204
    *(cmap + i) = (crinfo + k)->ed;
#line 201
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 207
  tmp = __idxwspacemalloc(ctrl, nparts);
#line 207
  htable = __idxset(nparts, (idxtype )-1, tmp);
#line 209
  ctrl->wspace.cdegree = 0L;
#line 210
  nbnd = 0L;
#line 210
  i = 0L;
  }
  {
#line 210
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 210
    if (! (i < nvtxs)) {
#line 210
      goto while_break___0;
    }
#line 211
    me = *(where + i);
#line 213
    myrinfo = rinfo + i;
#line 214
    tmp___1 = 0L;
#line 214
    myrinfo->ndegrees = tmp___1;
#line 214
    tmp___0 = tmp___1;
#line 214
    myrinfo->ed = tmp___0;
#line 214
    myrinfo->id = tmp___0;
#line 215
    myrinfo->edegrees = (EDegreeType *)((void *)0);
#line 217
    myrinfo->id = *(adjwgtsum + i);
#line 219
    if (*(cmap + i) > 0L) {
#line 220
      istart = *(xadj + i);
#line 221
      iend = *(xadj + (i + 1L));
#line 223
      tmp___2 = ctrl->wspace.edegrees + ctrl->wspace.cdegree;
#line 223
      myrinfo->edegrees = tmp___2;
#line 223
      myedegrees = tmp___2;
#line 224
      ctrl->wspace.cdegree += iend - istart;
#line 226
      ndegrees = 0L;
#line 227
      j = istart;
      {
#line 227
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 227
        if (! (j < iend)) {
#line 227
          goto while_break___1;
        }
#line 228
        other = *(where + *(adjncy + j));
#line 229
        if (me != other) {
#line 230
          myrinfo->ed += *(adjwgt + j);
#line 231
          k = *(htable + other);
#line 231
          if (k == -1L) {
#line 232
            *(htable + other) = ndegrees;
#line 233
            (myedegrees + ndegrees)->pid = other;
#line 234
            tmp___3 = ndegrees;
#line 234
            ndegrees ++;
#line 234
            (myedegrees + tmp___3)->ed = *(adjwgt + j);
          } else {
#line 237
            (myedegrees + k)->ed += *(adjwgt + j);
          }
        }
#line 227
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 241
      myrinfo->id -= myrinfo->ed;
#line 244
      if (myrinfo->ed == 0L) {
#line 245
        myrinfo->edegrees = (EDegreeType *)((void *)0);
#line 246
        ctrl->wspace.cdegree -= iend - istart;
      } else {
#line 249
        if (myrinfo->ed - myrinfo->id >= 0L) {
          {
#line 250
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 250
            *(bndind + nbnd) = i;
#line 250
            tmp___4 = nbnd;
#line 250
            nbnd ++;
#line 250
            *(bndptr + i) = tmp___4;
#line 250
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 252
        myrinfo->ndegrees = ndegrees;
#line 254
        j = 0L;
        {
#line 254
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 254
          if (! (j < ndegrees)) {
#line 254
            goto while_break___3;
          }
#line 255
          *(htable + (myedegrees + j)->pid) = (idxtype )-1;
#line 254
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 210
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 260
  memcpy((void */* __restrict  */)((void *)graph->npwgts), (void const   */* __restrict  */)((void *)cgraph->npwgts),
         sizeof(float ) * (unsigned long )(graph->ncon * nparts));
#line 261
  graph->mincut = cgraph->mincut;
#line 262
  graph->nbnd = nbnd;
#line 264
  __FreeGraph(graph->coarser);
#line 265
  graph->coarser = (struct graphdef *)((void *)0);
#line 267
  __idxwspacefree(ctrl, nparts);
  }
#line 271
  return;
}
}
#line 278 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mkwayrefine.c"
void __MocComputeKWayBalanceBoundary(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long i ;
  long nvtxs ;
  long nbnd ;
  idxtype *bndind ;
  idxtype *bndptr ;
  long tmp ;

  {
  {
#line 283
  nvtxs = graph->nvtxs;
#line 284
  bndind = graph->bndind;
#line 285
  bndptr = __idxset(nvtxs, (idxtype )-1, graph->bndptr);
#line 289
  nbnd = 0L;
#line 290
  i = 0L;
  }
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (i < nvtxs)) {
#line 290
      goto while_break;
    }
#line 291
    if ((graph->rinfo + i)->ed > 0L) {
      {
#line 292
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 292
        *(bndind + nbnd) = i;
#line 292
        tmp = nbnd;
#line 292
        nbnd ++;
#line 292
        *(bndptr + i) = tmp;
#line 292
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 290
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  graph->nbnd = nbnd;
#line 296
  return;
}
}
#line 109 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 48 "./proto.h"
void __EstimateCFraction(long nvtxs , idxtype *xadj , idxtype *adjncy , float *vfraction ,
                         float *efraction ) ;
#line 49
long __ComputeCoarseGraphSize(long nvtxs , idxtype *xadj , idxtype *adjncy , long cnvtxs ,
                              idxtype *cmap , idxtype *match , idxtype *perm ) ;
#line 57
void __Change2FNumbering2(long nvtxs , idxtype *xadj , idxtype *adjncy ) ;
#line 22 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/estmem.c"
void METIS_EstimateMemory(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                          long *optype , long *nbytes ) 
{ 
  long nedges ;
  long nlevels ;
  float vfraction ;
  float efraction ;
  float vmult ;
  float emult ;
  long coresize ;
  long gdata ;
  long rdata ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 28
  if (*numflag == 1L) {
    {
#line 29
    __Change2CNumbering(*nvtxs, xadj, adjncy);
    }
  }
  {
#line 31
  nedges = *(xadj + *nvtxs);
#line 33
  __InitRandom(-1L);
#line 34
  __EstimateCFraction(*nvtxs, xadj, adjncy, & vfraction, & efraction);
  }
#line 37
  if (*optype == 2L) {
#line 38
    coresize = nedges;
  } else {
#line 40
    coresize = 0L;
  }
  {
#line 41
  coresize = (long )((unsigned long )coresize + ((unsigned long )((nedges + 11L * *nvtxs) + 4096L) + 2002UL * (sizeof(ListNodeType *) / sizeof(idxtype ))));
#line 42
  coresize += 2L * *nvtxs;
#line 44
  gdata = nedges;
#line 46
  tmp = log(100.0 / (double )*nvtxs);
#line 46
  tmp___0 = log((double )vfraction);
#line 46
  nlevels = (long )(tmp / tmp___0 + .5);
#line 47
  tmp___1 = pow((double )vfraction, (double )nlevels);
#line 47
  vmult = (float )(0.5 + (1.0 - tmp___1) / (1.0 - (double )vfraction));
#line 48
  tmp___2 = pow((double )efraction, (double )(nlevels + 1L));
#line 48
  emult = (float )(1.0 + (1.0 - tmp___2) / (1.0 - (double )efraction));
#line 50
  gdata = (long )((float )gdata + ((vmult * (float )4) * (float )*nvtxs + (emult * (float )2) * (float )nedges));
  }
#line 51
  if ((((double )vmult - 1.0) * (double )4) * (double )*nvtxs + (((double )emult - 1.0) * (double )2) * (double )nedges < (double )(5L * *nvtxs)) {
#line 52
    rdata = 0L;
  } else {
#line 54
    rdata = 5L * *nvtxs;
  }
#line 56
  *nbytes = (long )(sizeof(idxtype ) * (unsigned long )(((coresize + gdata) + rdata) + *nvtxs));
#line 58
  if (*numflag == 1L) {
    {
#line 59
    __Change2FNumbering2(*nvtxs, xadj, adjncy);
    }
  }
#line 60
  return;
}
}
#line 66 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/estmem.c"
void __EstimateCFraction(long nvtxs , idxtype *xadj , idxtype *adjncy , float *vfraction ,
                         float *efraction ) 
{ 
  long i ;
  long ii ;
  long j ;
  long cnvtxs ;
  long cnedges ;
  long maxidx ;
  idxtype *match ;
  idxtype *cmap ;
  idxtype *perm ;
  idxtype tmp ;
  long tmp___0 ;

  {
  {
#line 71
  cmap = __idxmalloc(nvtxs, (char *)"cmap");
#line 72
  match = __idxsmalloc(nvtxs, (idxtype )-1, (char *)"match");
#line 73
  perm = __idxmalloc(nvtxs, (char *)"perm");
#line 74
  __RandomPermute(nvtxs, perm, 1L);
#line 76
  cnvtxs = 0L;
#line 77
  ii = 0L;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (ii < nvtxs)) {
#line 77
      goto while_break;
    }
#line 78
    i = *(perm + ii);
#line 80
    if (*(match + i) == -1L) {
#line 81
      maxidx = i;
#line 84
      j = *(xadj + i);
      {
#line 84
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 84
        if (! (j < *(xadj + (i + 1L)))) {
#line 84
          goto while_break___0;
        }
#line 85
        if (*(match + *(adjncy + j)) == -1L) {
#line 86
          maxidx = *(adjncy + j);
#line 87
          goto while_break___0;
        }
#line 84
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 91
      tmp___0 = cnvtxs;
#line 91
      cnvtxs ++;
#line 91
      tmp = tmp___0;
#line 91
      *(cmap + maxidx) = tmp;
#line 91
      *(cmap + i) = tmp;
#line 92
      *(match + i) = maxidx;
#line 93
      *(match + maxidx) = i;
    }
#line 77
    ii ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 97
  cnedges = __ComputeCoarseGraphSize(nvtxs, xadj, adjncy, cnvtxs, cmap, match, perm);
#line 99
  *vfraction = (float )((1.0 * (double )cnvtxs) / (1.0 * (double )nvtxs));
#line 100
  *efraction = (float )((1.0 * (double )cnedges) / (1.0 * (double )*(xadj + nvtxs)));
#line 102
  __GKfree(& cmap, & match, & perm, (void **)0);
  }
#line 103
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/estmem.c"
long __ComputeCoarseGraphSize(long nvtxs , idxtype *xadj , idxtype *adjncy , long cnvtxs ,
                              idxtype *cmap , idxtype *match , idxtype *perm ) 
{ 
  long i ;
  long j ;
  long k ;
  long istart ;
  long iend ;
  long cnedges ;
  long v ;
  long u ;
  idxtype *htable ;

  {
  {
#line 116
  htable = __idxsmalloc(cnvtxs, (idxtype )-1, (char *)"htable");
#line 118
  cnedges = 0L;
#line 118
  cnvtxs = cnedges;
#line 119
  i = 0L;
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! (i < nvtxs)) {
#line 119
      goto while_break;
    }
#line 120
    v = *(perm + i);
#line 121
    if (*(cmap + v) != cnvtxs) {
#line 122
      goto __Cont;
    }
#line 124
    *(htable + cnvtxs) = cnvtxs;
#line 126
    u = *(match + v);
#line 128
    istart = *(xadj + v);
#line 129
    iend = *(xadj + (v + 1L));
#line 130
    j = istart;
    {
#line 130
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 130
      if (! (j < iend)) {
#line 130
        goto while_break___0;
      }
#line 131
      k = *(cmap + *(adjncy + j));
#line 132
      if (*(htable + k) != cnvtxs) {
#line 133
        *(htable + k) = cnvtxs;
#line 134
        cnedges ++;
      }
#line 130
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 138
    if (v != u) {
#line 139
      istart = *(xadj + u);
#line 140
      iend = *(xadj + (u + 1L));
#line 141
      j = istart;
      {
#line 141
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 141
        if (! (j < iend)) {
#line 141
          goto while_break___1;
        }
#line 142
        k = *(cmap + *(adjncy + j));
#line 143
        if (*(htable + k) != cnvtxs) {
#line 144
          *(htable + k) = cnvtxs;
#line 145
          cnedges ++;
        }
#line 141
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 149
    cnvtxs ++;
    __Cont: /* CIL Label */ 
#line 119
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  __GKfree(& htable, (void **)0);
  }
#line 154
  return (cnedges);
}
}
#line 393 "./proto.h"
void __FM_2WayNodeRefineEqWgt(CtrlType *ctrl , GraphType *graph , long npasses ) ;
#line 395
void __FM_2WayNodeBalance(CtrlType *ctrl , GraphType *graph , float ubfactor ) ;
#line 399
void __Refine2WayNode(CtrlType *ctrl , GraphType *orggraph , GraphType *graph , float ubfactor ) ;
#line 402
void __Project2WayNodePartition(CtrlType *ctrl , GraphType *graph ) ;
#line 21 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/srefine.c"
void __Refine2WayNode(CtrlType *ctrl , GraphType *orggraph , GraphType *graph , float ubfactor ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 24
  if (ctrl->dbglvl & 1L) {
    {
#line 24
    tmp = __seconds();
#line 24
    ctrl->UncoarsenTmr -= tmp;
    }
  }
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    if (ctrl->dbglvl & 1L) {
      {
#line 27
      tmp___0 = __seconds();
#line 27
      ctrl->RefTmr -= tmp___0;
      }
    }
#line 28
    if (ctrl->RType != 15L) {
      {
#line 29
      __FM_2WayNodeBalance(ctrl, graph, ubfactor);
      }
    }
    {
#line 32
    if (ctrl->RType == 1L) {
#line 32
      goto case_1;
    }
#line 35
    if (ctrl->RType == 2L) {
#line 35
      goto case_2;
    }
#line 38
    if (ctrl->RType == 3L) {
#line 38
      goto case_3;
    }
#line 42
    if (ctrl->RType == 4L) {
#line 42
      goto case_4;
    }
#line 46
    if (ctrl->RType == 5L) {
#line 46
      goto case_5;
    }
#line 31
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 33
    __FM_2WayNodeRefine(ctrl, graph, ubfactor, 8L);
    }
#line 34
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 36
    __FM_2WayNodeRefine_OneSided(ctrl, graph, ubfactor, 8L);
    }
#line 37
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 39
    __FM_2WayNodeRefine(ctrl, graph, ubfactor, 8L);
#line 40
    __FM_2WayNodeRefine_OneSided(ctrl, graph, ubfactor, 8L);
    }
#line 41
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 43
    __FM_2WayNodeRefine_OneSided(ctrl, graph, ubfactor, 8L);
#line 44
    __FM_2WayNodeRefine(ctrl, graph, ubfactor, 8L);
    }
#line 45
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 47
    __FM_2WayNodeRefineEqWgt(ctrl, graph, 8L);
    }
#line 48
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 50
    if (ctrl->dbglvl & 1L) {
      {
#line 50
      tmp___1 = __seconds();
#line 50
      ctrl->RefTmr += tmp___1;
      }
    }
#line 52
    if ((unsigned long )graph == (unsigned long )orggraph) {
#line 53
      goto while_break;
    }
#line 55
    graph = graph->finer;
#line 56
    if (ctrl->dbglvl & 1L) {
      {
#line 56
      tmp___2 = __seconds();
#line 56
      ctrl->ProjectTmr -= tmp___2;
      }
    }
    {
#line 57
    __Project2WayNodePartition(ctrl, graph);
    }
#line 58
    if (ctrl->dbglvl & 1L) {
      {
#line 58
      tmp___3 = __seconds();
#line 58
      ctrl->ProjectTmr += tmp___3;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  if (ctrl->dbglvl & 1L) {
    {
#line 61
    tmp___4 = __seconds();
#line 61
    ctrl->UncoarsenTmr += tmp___4;
    }
  }
#line 62
  return;
}
}
#line 68 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/srefine.c"
void __Allocate2WayNodePartitionMemory(CtrlType *ctrl , GraphType *graph ) 
{ 
  long nvtxs ;
  long pad64 ;

  {
  {
#line 72
  nvtxs = graph->nvtxs;
#line 74
  pad64 = (3L * nvtxs + 3L) % 2L;
#line 76
  graph->rdata = __idxmalloc((long )(((unsigned long )(3L * nvtxs + 3L) + (sizeof(NRInfoType ) / sizeof(idxtype )) * (unsigned long )nvtxs) + (unsigned long )pad64),
                             (char *)"Allocate2WayPartitionMemory: rdata");
#line 77
  graph->pwgts = graph->rdata;
#line 78
  graph->where = graph->rdata + 3;
#line 79
  graph->bndptr = (graph->rdata + nvtxs) + 3;
#line 80
  graph->bndind = (graph->rdata + 2L * nvtxs) + 3;
#line 81
  graph->nrinfo = (NRInfoType *)(((graph->rdata + 3L * nvtxs) + 3) + pad64);
  }
#line 82
  return;
}
}
#line 89 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/srefine.c"
void __Compute2WayNodePartitionParams(CtrlType *ctrl , GraphType *graph ) 
{ 
  long i ;
  long j ;
  long nvtxs ;
  long nbnd ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *vwgt ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *bndind ;
  idxtype *bndptr ;
  idxtype *edegrees ;
  NRInfoType *rinfo ;
  long me ;
  long other ;
  long tmp ;
  idxtype tmp___0 ;

  {
  {
#line 97
  nvtxs = graph->nvtxs;
#line 98
  xadj = graph->xadj;
#line 99
  vwgt = graph->vwgt;
#line 100
  adjncy = graph->adjncy;
#line 101
  adjwgt = graph->adjwgt;
#line 103
  where = graph->where;
#line 104
  rinfo = graph->nrinfo;
#line 105
  pwgts = __idxset(3L, (idxtype )0, graph->pwgts);
#line 106
  bndind = graph->bndind;
#line 107
  bndptr = __idxset(nvtxs, (idxtype )-1, graph->bndptr);
#line 113
  nbnd = 0L;
#line 114
  i = 0L;
  }
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < nvtxs)) {
#line 114
      goto while_break;
    }
#line 115
    me = *(where + i);
#line 116
    *(pwgts + me) += *(vwgt + i);
#line 120
    if (me == 2L) {
      {
#line 121
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 121
        *(bndind + nbnd) = i;
#line 121
        tmp = nbnd;
#line 121
        nbnd ++;
#line 121
        *(bndptr + i) = tmp;
#line 121
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 123
      edegrees = (rinfo + i)->edegrees;
#line 124
      tmp___0 = (idxtype )0;
#line 124
      *(edegrees + 1) = tmp___0;
#line 124
      *(edegrees + 0) = tmp___0;
#line 126
      j = *(xadj + i);
      {
#line 126
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 126
        if (! (j < *(xadj + (i + 1L)))) {
#line 126
          goto while_break___1;
        }
#line 127
        other = *(where + *(adjncy + j));
#line 128
        if (other != 2L) {
#line 129
          *(edegrees + other) += *(vwgt + *(adjncy + j));
        }
#line 126
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  graph->mincut = *(pwgts + 2);
#line 137
  graph->nbnd = nbnd;
#line 138
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/srefine.c"
void __Project2WayNodePartition(CtrlType *ctrl , GraphType *graph ) 
{ 
  long i ;
  long nvtxs ;
  idxtype *cmap ;
  idxtype *where ;
  idxtype *cwhere ;
  GraphType *cgraph ;

  {
  {
#line 150
  cgraph = graph->coarser;
#line 151
  cwhere = cgraph->where;
#line 153
  nvtxs = graph->nvtxs;
#line 154
  cmap = graph->cmap;
#line 156
  __Allocate2WayNodePartitionMemory(ctrl, graph);
#line 157
  where = graph->where;
#line 160
  i = 0L;
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (i < nvtxs)) {
#line 160
      goto while_break;
    }
#line 161
    *(where + i) = *(cwhere + *(cmap + i));
#line 160
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  __FreeGraph(graph->coarser);
#line 166
  graph->coarser = (struct graphdef *)((void *)0);
#line 168
  __Compute2WayNodePartitionParams(ctrl, graph);
  }
#line 169
  return;
}
}
#line 250 "./proto.h"
long __MinCover_Augment(idxtype *xadj , idxtype *adjncy , long col , idxtype *mate ,
                        idxtype *flag , idxtype *level , long maxlevel ) ;
#line 251
void __MinCover_Decompose(idxtype *xadj , idxtype *adjncy , long asize , long bsize ,
                          idxtype *mate , idxtype *cover , long *csize ) ;
#line 252
void __MinCover_ColDFS(idxtype *xadj , idxtype *adjncy , long root , idxtype *mate ,
                       idxtype *where , long flag ) ;
#line 253
void __MinCover_RowDFS(idxtype *xadj , idxtype *adjncy , long root , idxtype *mate ,
                       idxtype *where , long flag ) ;
#line 42 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mincover.c"
void __MinCover(idxtype *xadj , idxtype *adjncy , long asize , long bsize , idxtype *cover ,
                long *csize ) 
{ 
  long i ;
  long j ;
  idxtype *mate ;
  idxtype *queue ;
  idxtype *flag ;
  idxtype *level ;
  idxtype *lst ;
  long fptr ;
  long rptr ;
  long lstptr ;
  long row ;
  long maxlevel ;
  long col ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 49
  mate = __idxsmalloc(bsize, (idxtype )-1, (char *)"MinCover: mate");
#line 50
  flag = __idxmalloc(bsize, (char *)"MinCover: flag");
#line 51
  level = __idxmalloc(bsize, (char *)"MinCover: level");
#line 52
  queue = __idxmalloc(bsize, (char *)"MinCover: queue");
#line 53
  lst = __idxmalloc(bsize, (char *)"MinCover: lst");
#line 56
  i = 0L;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! (i < asize)) {
#line 56
      goto while_break;
    }
#line 57
    j = *(xadj + i);
    {
#line 57
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 57
      if (! (j < *(xadj + (i + 1L)))) {
#line 57
        goto while_break___0;
      }
#line 58
      if (*(mate + *(adjncy + j)) == -1L) {
#line 59
        *(mate + i) = *(adjncy + j);
#line 60
        *(mate + *(adjncy + j)) = i;
#line 61
        goto while_break___0;
      }
#line 57
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 56
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 69
    rptr = 0L;
#line 69
    fptr = rptr;
#line 70
    lstptr = 0L;
#line 71
    i = 0L;
    {
#line 71
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 71
      if (! (i < bsize)) {
#line 71
        goto while_break___2;
      }
#line 72
      *(level + i) = (idxtype )-1;
#line 73
      *(flag + i) = (idxtype )0;
#line 71
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 75
    maxlevel = bsize;
#line 78
    i = 0L;
    {
#line 78
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 78
      if (! (i < asize)) {
#line 78
        goto while_break___3;
      }
#line 79
      if (*(mate + i) == -1L) {
#line 80
        tmp = rptr;
#line 80
        rptr ++;
#line 80
        *(queue + tmp) = i;
#line 81
        *(level + i) = (idxtype )0;
      }
#line 78
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 85
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 85
      if (! (fptr != rptr)) {
#line 85
        goto while_break___4;
      }
#line 86
      tmp___0 = fptr;
#line 86
      fptr ++;
#line 86
      row = *(queue + tmp___0);
#line 87
      if (*(level + row) < maxlevel) {
#line 88
        *(flag + row) = (idxtype )1;
#line 89
        j = *(xadj + row);
        {
#line 89
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 89
          if (! (j < *(xadj + (row + 1L)))) {
#line 89
            goto while_break___5;
          }
#line 90
          col = *(adjncy + j);
#line 91
          if (! *(flag + col)) {
#line 92
            *(flag + col) = (idxtype )1;
#line 93
            if (*(mate + col) == -1L) {
#line 94
              maxlevel = *(level + row);
#line 95
              tmp___1 = lstptr;
#line 95
              lstptr ++;
#line 95
              *(lst + tmp___1) = col;
            } else {
#line 98
              if (*(flag + *(mate + col))) {
                {
#line 99
                printf((char const   */* __restrict  */)"\nSomething wrong, flag[%ld] is 1",
                       *(mate + col));
                }
              }
#line 100
              tmp___2 = rptr;
#line 100
              rptr ++;
#line 100
              *(queue + tmp___2) = *(mate + col);
#line 101
              *(level + *(mate + col)) = *(level + row) + 1L;
            }
          }
#line 89
          j ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 108
    if (lstptr == 0L) {
#line 109
      goto while_break___1;
    }
#line 112
    i = 0L;
    {
#line 112
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 112
      if (! (i < lstptr)) {
#line 112
        goto while_break___6;
      }
      {
#line 113
      __MinCover_Augment(xadj, adjncy, *(lst + i), mate, flag, level, maxlevel);
#line 112
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 116
  __MinCover_Decompose(xadj, adjncy, asize, bsize, mate, cover, csize);
#line 118
  __GKfree(& mate, & flag, & level, & queue, & lst, (void **)0);
  }
#line 120
  return;
}
}
#line 126 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mincover.c"
long __MinCover_Augment(idxtype *xadj , idxtype *adjncy , long col , idxtype *mate ,
                        idxtype *flag , idxtype *level , long maxlevel ) 
{ 
  long i ;
  long row ;
  long status ;

  {
#line 129
  row = -1L;
#line 132
  *(flag + col) = (idxtype )2;
#line 133
  i = *(xadj + col);
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! (i < *(xadj + (col + 1L)))) {
#line 133
      goto while_break;
    }
#line 134
    row = *(adjncy + i);
#line 136
    if (*(flag + row) == 1L) {
#line 137
      if (*(level + row) == maxlevel) {
#line 138
        *(flag + row) = (idxtype )2;
#line 139
        if (maxlevel != 0L) {
          {
#line 140
          status = __MinCover_Augment(xadj, adjncy, *(mate + row), mate, flag, level,
                                      maxlevel - 1L);
          }
        } else {
#line 142
          status = 1L;
        }
#line 144
        if (status) {
#line 145
          *(mate + col) = row;
#line 146
          *(mate + row) = col;
#line 147
          return (1L);
        }
      }
    }
#line 133
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return (0L);
}
}
#line 163 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mincover.c"
void __MinCover_Decompose(idxtype *xadj , idxtype *adjncy , long asize , long bsize ,
                          idxtype *mate , idxtype *cover , long *csize ) 
{ 
  long i ;
  long k ;
  idxtype *where ;
  long card[10] ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 169
  where = __idxmalloc(bsize, (char *)"MinCover_Decompose: where");
#line 170
  i = 0L;
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (i < 10L)) {
#line 170
      goto while_break;
    }
#line 171
    card[i] = 0L;
#line 170
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  i = 0L;
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (i < asize)) {
#line 173
      goto while_break___0;
    }
#line 174
    *(where + i) = (idxtype )2;
#line 173
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 175
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 175
    if (! (i < bsize)) {
#line 175
      goto while_break___1;
    }
#line 176
    *(where + i) = (idxtype )5;
#line 175
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 178
  i = 0L;
  {
#line 178
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 178
    if (! (i < asize)) {
#line 178
      goto while_break___2;
    }
#line 179
    if (*(mate + i) == -1L) {
      {
#line 180
      __MinCover_ColDFS(xadj, adjncy, i, mate, where, 10L);
      }
    }
#line 178
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 181
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 181
    if (! (i < bsize)) {
#line 181
      goto while_break___3;
    }
#line 182
    if (*(mate + i) == -1L) {
      {
#line 183
      __MinCover_RowDFS(xadj, adjncy, i, mate, where, 20L);
      }
    }
#line 181
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 185
  i = 0L;
  {
#line 185
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 185
    if (! (i < bsize)) {
#line 185
      goto while_break___4;
    }
#line 186
    (card[*(where + i)]) ++;
#line 185
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 188
  k = 0L;
#line 189
  tmp___1 = abs((int )((card[1] + card[2]) - card[6]));
#line 189
  tmp___2 = abs((int )((card[1] - card[5]) - card[6]));
  }
#line 189
  if (tmp___1 < tmp___2) {
#line 191
    i = 0L;
    {
#line 191
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 191
      if (! (i < bsize)) {
#line 191
        goto while_break___5;
      }
#line 192
      if (*(where + i) == 1L) {
#line 193
        tmp = k;
#line 193
        k ++;
#line 193
        *(cover + tmp) = i;
      } else
#line 192
      if (*(where + i) == 2L) {
#line 193
        tmp = k;
#line 193
        k ++;
#line 193
        *(cover + tmp) = i;
      } else
#line 192
      if (*(where + i) == 6L) {
#line 193
        tmp = k;
#line 193
        k ++;
#line 193
        *(cover + tmp) = i;
      }
#line 191
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
#line 197
    i = 0L;
    {
#line 197
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 197
      if (! (i < bsize)) {
#line 197
        goto while_break___6;
      }
#line 198
      if (*(where + i) == 1L) {
#line 199
        tmp___0 = k;
#line 199
        k ++;
#line 199
        *(cover + tmp___0) = i;
      } else
#line 198
      if (*(where + i) == 5L) {
#line 199
        tmp___0 = k;
#line 199
        k ++;
#line 199
        *(cover + tmp___0) = i;
      } else
#line 198
      if (*(where + i) == 6L) {
#line 199
        tmp___0 = k;
#line 199
        k ++;
#line 199
        *(cover + tmp___0) = i;
      }
#line 197
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  {
#line 202
  *csize = k;
#line 203
  free((void *)where);
  }
#line 205
  return;
}
}
#line 212 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mincover.c"
void __MinCover_ColDFS(idxtype *xadj , idxtype *adjncy , long root , idxtype *mate ,
                       idxtype *where , long flag ) 
{ 
  long i ;

  {
#line 216
  if (flag == 10L) {
#line 217
    if (*(where + root) == 3L) {
#line 218
      return;
    }
#line 219
    *(where + root) = (idxtype )3;
#line 220
    i = *(xadj + root);
    {
#line 220
    while (1) {
      while_continue: /* CIL Label */ ;
#line 220
      if (! (i < *(xadj + (root + 1L)))) {
#line 220
        goto while_break;
      }
      {
#line 221
      __MinCover_ColDFS(xadj, adjncy, *(adjncy + i), mate, where, 20L);
#line 220
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 224
    if (*(where + root) == 6L) {
#line 225
      return;
    }
#line 226
    *(where + root) = (idxtype )6;
#line 227
    if (*(mate + root) != -1L) {
      {
#line 228
      __MinCover_ColDFS(xadj, adjncy, *(mate + root), mate, where, 10L);
      }
    }
  }
#line 231
  return;
}
}
#line 237 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mincover.c"
void __MinCover_RowDFS(idxtype *xadj , idxtype *adjncy , long root , idxtype *mate ,
                       idxtype *where , long flag ) 
{ 
  long i ;

  {
#line 241
  if (flag == 20L) {
#line 242
    if (*(where + root) == 4L) {
#line 243
      return;
    }
#line 244
    *(where + root) = (idxtype )4;
#line 245
    i = *(xadj + root);
    {
#line 245
    while (1) {
      while_continue: /* CIL Label */ ;
#line 245
      if (! (i < *(xadj + (root + 1L)))) {
#line 245
        goto while_break;
      }
      {
#line 246
      __MinCover_RowDFS(xadj, adjncy, *(adjncy + i), mate, where, 10L);
#line 245
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 249
    if (*(where + root) == 1L) {
#line 250
      return;
    }
#line 251
    *(where + root) = (idxtype )1;
#line 252
    if (*(mate + root) != -1L) {
      {
#line 253
      __MinCover_RowDFS(xadj, adjncy, *(mate + root), mate, where, 20L);
      }
    }
  }
#line 256
  return;
}
}
#line 384 "./proto.h"
void __Project2WayPartition(CtrlType *ctrl , GraphType *graph ) ;
#line 20 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/refine.c"
void __Refine2Way(CtrlType *ctrl , GraphType *orggraph , GraphType *graph , long *tpwgts ,
                  float ubfactor ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 23
  if (ctrl->dbglvl & 1L) {
    {
#line 23
    tmp = __seconds();
#line 23
    ctrl->UncoarsenTmr -= tmp;
    }
  }
  {
#line 26
  __Compute2WayPartitionParams(ctrl, graph);
  }
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (ctrl->dbglvl & 1L) {
      {
#line 31
      tmp___0 = __seconds();
#line 31
      ctrl->RefTmr -= tmp___0;
      }
    }
    {
#line 33
    if (ctrl->RType == 1L) {
#line 33
      goto case_1;
    }
#line 37
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 34
    __Balance2Way(ctrl, graph, tpwgts, ubfactor);
#line 35
    __FM_2WayEdgeRefine(ctrl, graph, tpwgts, 8L);
    }
#line 36
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 38
    __errexit((char *)"Unknown refinement type: %ld\n", ctrl->RType);
    }
    switch_break: /* CIL Label */ ;
    }
#line 40
    if (ctrl->dbglvl & 1L) {
      {
#line 40
      tmp___1 = __seconds();
#line 40
      ctrl->RefTmr += tmp___1;
      }
    }
#line 42
    if ((unsigned long )graph == (unsigned long )orggraph) {
#line 43
      goto while_break;
    }
#line 45
    graph = graph->finer;
#line 46
    if (ctrl->dbglvl & 1L) {
      {
#line 46
      tmp___2 = __seconds();
#line 46
      ctrl->ProjectTmr -= tmp___2;
      }
    }
    {
#line 47
    __Project2WayPartition(ctrl, graph);
    }
#line 48
    if (ctrl->dbglvl & 1L) {
      {
#line 48
      tmp___3 = __seconds();
#line 48
      ctrl->ProjectTmr += tmp___3;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  if (ctrl->dbglvl & 1L) {
    {
#line 51
    tmp___4 = __seconds();
#line 51
    ctrl->UncoarsenTmr += tmp___4;
    }
  }
#line 52
  return;
}
}
#line 58 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/refine.c"
void __Allocate2WayPartitionMemory(CtrlType *ctrl , GraphType *graph ) 
{ 
  long nvtxs ;

  {
  {
#line 62
  nvtxs = graph->nvtxs;
#line 64
  graph->rdata = __idxmalloc(5L * nvtxs + 2L, (char *)"Allocate2WayPartitionMemory: rdata");
#line 65
  graph->pwgts = graph->rdata;
#line 66
  graph->where = graph->rdata + 2;
#line 67
  graph->id = (graph->rdata + nvtxs) + 2;
#line 68
  graph->ed = (graph->rdata + 2L * nvtxs) + 2;
#line 69
  graph->bndptr = (graph->rdata + 3L * nvtxs) + 2;
#line 70
  graph->bndind = (graph->rdata + 4L * nvtxs) + 2;
  }
#line 71
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/refine.c"
void __Compute2WayPartitionParams(CtrlType *ctrl , GraphType *graph ) 
{ 
  long i ;
  long j ;
  long nvtxs ;
  long nbnd ;
  long mincut ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *pwgts ;
  idxtype *id ;
  idxtype *ed ;
  idxtype *where ;
  idxtype *bndptr ;
  idxtype *bndind ;
  long me ;
  long tmp ;

  {
  {
#line 85
  nvtxs = graph->nvtxs;
#line 86
  xadj = graph->xadj;
#line 87
  vwgt = graph->vwgt;
#line 88
  adjncy = graph->adjncy;
#line 89
  adjwgt = graph->adjwgt;
#line 91
  where = graph->where;
#line 92
  pwgts = __idxset(2L, (idxtype )0, graph->pwgts);
#line 93
  id = __idxset(nvtxs, (idxtype )0, graph->id);
#line 94
  ed = __idxset(nvtxs, (idxtype )0, graph->ed);
#line 95
  bndptr = __idxset(nvtxs, (idxtype )-1, graph->bndptr);
#line 96
  bndind = graph->bndind;
#line 102
  mincut = 0L;
#line 102
  nbnd = mincut;
#line 103
  i = 0L;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (i < nvtxs)) {
#line 103
      goto while_break;
    }
#line 105
    me = *(where + i);
#line 106
    *(pwgts + me) += *(vwgt + i);
#line 108
    j = *(xadj + i);
    {
#line 108
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 108
      if (! (j < *(xadj + (i + 1L)))) {
#line 108
        goto while_break___0;
      }
#line 109
      if (me == *(where + *(adjncy + j))) {
#line 110
        *(id + i) += *(adjwgt + j);
      } else {
#line 112
        *(ed + i) += *(adjwgt + j);
      }
#line 108
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 115
    if (*(ed + i) > 0L) {
#line 116
      mincut += *(ed + i);
#line 117
      *(bndptr + i) = nbnd;
#line 118
      tmp = nbnd;
#line 118
      nbnd ++;
#line 118
      *(bndind + tmp) = i;
    } else
#line 115
    if (*(xadj + i) == *(xadj + (i + 1L))) {
#line 116
      mincut += *(ed + i);
#line 117
      *(bndptr + i) = nbnd;
#line 118
      tmp = nbnd;
#line 118
      nbnd ++;
#line 118
      *(bndind + tmp) = i;
    }
#line 103
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  graph->mincut = mincut / 2L;
#line 123
  graph->nbnd = nbnd;
#line 126
  return;
}
}
#line 134 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/refine.c"
void __Project2WayPartition(CtrlType *ctrl , GraphType *graph ) 
{ 
  long i ;
  long j ;
  long k ;
  long nvtxs ;
  long nbnd ;
  long me ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *adjwgtsum ;
  idxtype *cmap ;
  idxtype *where ;
  idxtype *id ;
  idxtype *ed ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *cwhere ;
  idxtype *cid ;
  idxtype *ced ;
  idxtype *cbndptr ;
  GraphType *cgraph ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 142
  cgraph = graph->coarser;
#line 143
  cwhere = cgraph->where;
#line 144
  cid = cgraph->id;
#line 145
  ced = cgraph->ed;
#line 146
  cbndptr = cgraph->bndptr;
#line 148
  nvtxs = graph->nvtxs;
#line 149
  cmap = graph->cmap;
#line 150
  xadj = graph->xadj;
#line 151
  adjncy = graph->adjncy;
#line 152
  adjwgt = graph->adjwgt;
#line 153
  adjwgtsum = graph->adjwgtsum;
#line 155
  __Allocate2WayPartitionMemory(ctrl, graph);
#line 157
  where = graph->where;
#line 158
  id = __idxset(nvtxs, (idxtype )0, graph->id);
#line 159
  ed = __idxset(nvtxs, (idxtype )0, graph->ed);
#line 160
  bndptr = __idxset(nvtxs, (idxtype )-1, graph->bndptr);
#line 161
  bndind = graph->bndind;
#line 165
  i = 0L;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < nvtxs)) {
#line 165
      goto while_break;
    }
#line 166
    k = *(cmap + i);
#line 167
    *(where + i) = *(cwhere + k);
#line 168
    *(cmap + i) = *(cbndptr + k);
#line 165
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  nbnd = 0L;
#line 171
  i = 0L;
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 171
    if (! (i < nvtxs)) {
#line 171
      goto while_break___0;
    }
#line 172
    me = *(where + i);
#line 174
    *(id + i) = *(adjwgtsum + i);
#line 176
    if (*(xadj + i) == *(xadj + (i + 1L))) {
#line 177
      *(bndptr + i) = nbnd;
#line 178
      tmp = nbnd;
#line 178
      nbnd ++;
#line 178
      *(bndind + tmp) = i;
    } else
#line 181
    if (*(cmap + i) != -1L) {
#line 182
      j = *(xadj + i);
      {
#line 182
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 182
        if (! (j < *(xadj + (i + 1L)))) {
#line 182
          goto while_break___1;
        }
#line 183
        if (me != *(where + *(adjncy + j))) {
#line 184
          *(ed + i) += *(adjwgt + j);
        }
#line 182
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 186
      *(id + i) -= *(ed + i);
#line 188
      if (*(ed + i) > 0L) {
#line 189
        *(bndptr + i) = nbnd;
#line 190
        tmp___0 = nbnd;
#line 190
        nbnd ++;
#line 190
        *(bndind + tmp___0) = i;
      } else
#line 188
      if (*(xadj + i) == *(xadj + (i + 1L))) {
#line 189
        *(bndptr + i) = nbnd;
#line 190
        tmp___0 = nbnd;
#line 190
        nbnd ++;
#line 190
        *(bndind + tmp___0) = i;
      }
    }
#line 171
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 196
  graph->mincut = cgraph->mincut;
#line 197
  graph->nbnd = nbnd;
#line 198
  memcpy((void */* __restrict  */)((void *)graph->pwgts), (void const   */* __restrict  */)((void *)cgraph->pwgts),
         sizeof(idxtype ) * 2UL);
#line 200
  __FreeGraph(graph->coarser);
#line 201
  graph->coarser = (struct graphdef *)((void *)0);
  }
#line 203
  return;
}
}
#line 60 "./proto.h"
void __ChangeMesh2FNumbering(long n , idxtype *mesh , long nvtxs , idxtype *xadj ,
                             idxtype *adjncy ) ;
#line 226
void GENDUALMETIS(long nelmnts , long nvtxs , long etype , idxtype *elmnts , idxtype *dxadj ,
                  idxtype *dadjncy ) ;
#line 227
void __TRINODALMETIS(long nelmnts , long nvtxs , idxtype *elmnts , idxtype *dxadj ,
                     idxtype *dadjncy ) ;
#line 228
void __TETNODALMETIS(long nelmnts , long nvtxs , idxtype *elmnts , idxtype *dxadj ,
                     idxtype *dadjncy ) ;
#line 229
void __HEXNODALMETIS(long nelmnts , long nvtxs , idxtype *elmnts , idxtype *dxadj ,
                     idxtype *dadjncy ) ;
#line 230
void QUADNODALMETIS(long nelmnts , long nvtxs , idxtype *elmnts , idxtype *dxadj ,
                    idxtype *dadjncy ) ;
#line 23 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mesh.c"
void METIS_MeshToDual(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                      idxtype *dxadj , idxtype *dadjncy ) 
{ 
  long esizes[5] ;

  {
#line 26
  esizes[0] = -1L;
#line 26
  esizes[1] = 3L;
#line 26
  esizes[2] = 4L;
#line 26
  esizes[3] = 8L;
#line 26
  esizes[4] = 4L;
#line 28
  if (*numflag == 1L) {
    {
#line 29
    __ChangeMesh2CNumbering(*ne * esizes[*etype], elmnts);
    }
  }
  {
#line 31
  GENDUALMETIS(*ne, *nn, *etype, elmnts, dxadj, dadjncy);
  }
#line 33
  if (*numflag == 1L) {
    {
#line 34
    __ChangeMesh2FNumbering(*ne * esizes[*etype], elmnts, *ne, dxadj, dadjncy);
    }
  }
#line 35
  return;
}
}
#line 42 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mesh.c"
void METIS_MeshToNodal(long *ne , long *nn , idxtype *elmnts , long *etype , long *numflag ,
                       idxtype *dxadj , idxtype *dadjncy ) 
{ 
  long esizes[5] ;

  {
#line 45
  esizes[0] = -1L;
#line 45
  esizes[1] = 3L;
#line 45
  esizes[2] = 4L;
#line 45
  esizes[3] = 8L;
#line 45
  esizes[4] = 4L;
#line 47
  if (*numflag == 1L) {
    {
#line 48
    __ChangeMesh2CNumbering(*ne * esizes[*etype], elmnts);
    }
  }
  {
#line 51
  if (*etype == 1L) {
#line 51
    goto case_1;
  }
#line 54
  if (*etype == 2L) {
#line 54
    goto case_2;
  }
#line 57
  if (*etype == 3L) {
#line 57
    goto case_3;
  }
#line 60
  if (*etype == 4L) {
#line 60
    goto case_4;
  }
#line 50
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 52
  __TRINODALMETIS(*ne, *nn, elmnts, dxadj, dadjncy);
  }
#line 53
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 55
  __TETNODALMETIS(*ne, *nn, elmnts, dxadj, dadjncy);
  }
#line 56
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 58
  __HEXNODALMETIS(*ne, *nn, elmnts, dxadj, dadjncy);
  }
#line 59
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 61
  QUADNODALMETIS(*ne, *nn, elmnts, dxadj, dadjncy);
  }
#line 62
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 65
  if (*numflag == 1L) {
    {
#line 66
    __ChangeMesh2FNumbering(*ne * esizes[*etype], elmnts, *nn, dxadj, dadjncy);
    }
  }
#line 67
  return;
}
}
#line 74 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mesh.c"
void GENDUALMETIS(long nelmnts , long nvtxs , long etype , idxtype *elmnts , idxtype *dxadj ,
                  idxtype *dadjncy ) 
{ 
  long i ;
  long j ;
  long jj ;
  long k ;
  long kk ;
  long kkk ;
  long l ;
  long m ;
  long n ;
  long mask ;
  idxtype *nptr ;
  idxtype *nind ;
  idxtype *mark ;
  idxtype ind[200] ;
  idxtype wgt[200] ;
  long esize ;
  long esizes[5] ;
  long mgcnum ;
  long mgcnums[5] ;
  idxtype tmp ;
  long tmp___0 ;
  long tmp___1 ;
  idxtype tmp___2 ;
  idxtype tmp___3 ;

  {
  {
#line 79
  esizes[0] = -1L;
#line 79
  esizes[1] = 3L;
#line 79
  esizes[2] = 4L;
#line 79
  esizes[3] = 8L;
#line 79
  esizes[4] = 4L;
#line 79
  mgcnums[0] = -1L;
#line 79
  mgcnums[1] = 2L;
#line 79
  mgcnums[2] = 3L;
#line 79
  mgcnums[3] = 4L;
#line 79
  mgcnums[4] = 2L;
#line 82
  mask = (long )((1 << 11) - 1);
#line 83
  mark = __idxsmalloc(mask + 1L, (idxtype )-1, (char *)"GENDUALMETIS: mark");
#line 86
  esize = esizes[etype];
#line 87
  mgcnum = mgcnums[etype];
#line 90
  nptr = __idxsmalloc(nvtxs + 1L, (idxtype )0, (char *)"GENDUALMETIS: nptr");
#line 91
  j = esize * nelmnts;
#line 91
  i = 0L;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < j)) {
#line 91
      goto while_break;
    }
#line 92
    (*(nptr + *(elmnts + i))) ++;
#line 91
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    i = 1L;
    {
#line 93
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 93
      if (! (i < nvtxs)) {
#line 93
        goto while_break___1;
      }
#line 93
      *(nptr + i) += *(nptr + (i - 1L));
#line 93
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 93
    i = nvtxs;
    {
#line 93
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 93
      if (! (i > 0L)) {
#line 93
        goto while_break___2;
      }
#line 93
      *(nptr + i) = *(nptr + (i - 1L));
#line 93
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 93
    *(nptr + 0) = (idxtype )0;
#line 93
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 95
  nind = __idxmalloc(*(nptr + nvtxs), (char *)"GENDUALMETIS: nind");
#line 96
  i = 0L;
#line 96
  k = i;
  }
  {
#line 96
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 96
    if (! (i < nelmnts)) {
#line 96
      goto while_break___3;
    }
#line 97
    j = 0L;
    {
#line 97
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 97
      if (! (j < esize)) {
#line 97
        goto while_break___4;
      }
#line 98
      tmp = *(nptr + *(elmnts + k));
#line 98
      (*(nptr + *(elmnts + k))) ++;
#line 98
      *(nind + tmp) = i;
#line 97
      j ++;
#line 97
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 96
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 100
  i = nvtxs;
  {
#line 100
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 100
    if (! (i > 0L)) {
#line 100
      goto while_break___5;
    }
#line 101
    *(nptr + i) = *(nptr + (i - 1L));
#line 100
    i --;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 102
  *(nptr + 0) = (idxtype )0;
#line 104
  i = 0L;
  {
#line 104
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 104
    if (! (i < nelmnts)) {
#line 104
      goto while_break___6;
    }
#line 105
    *(dxadj + i) = esize * i;
#line 104
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 107
  i = 0L;
  {
#line 107
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 107
    if (! (i < nelmnts)) {
#line 107
      goto while_break___7;
    }
#line 108
    j = 0L;
#line 108
    m = j;
    {
#line 108
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 108
      if (! (j < esize)) {
#line 108
        goto while_break___8;
      }
#line 109
      n = *(elmnts + (esize * i + j));
#line 110
      k = *(nptr + (n + 1L)) - 1L;
      {
#line 110
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 110
        if (! (k >= *(nptr + n))) {
#line 110
          goto while_break___9;
        }
#line 111
        kk = *(nind + k);
#line 111
        if (kk <= i) {
#line 112
          goto while_break___9;
        }
#line 114
        kkk = kk & mask;
#line 115
        l = *(mark + kkk);
#line 115
        if (l == -1L) {
#line 116
          ind[m] = kk;
#line 117
          wgt[m] = (idxtype )1;
#line 118
          tmp___0 = m;
#line 118
          m ++;
#line 118
          *(mark + kkk) = tmp___0;
        } else
#line 120
        if (ind[l] == kk) {
#line 121
          (wgt[l]) ++;
        } else {
#line 124
          jj = 0L;
          {
#line 124
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 124
            if (! (jj < m)) {
#line 124
              goto while_break___10;
            }
#line 125
            if (ind[jj] == kk) {
#line 126
              (wgt[jj]) ++;
#line 127
              goto while_break___10;
            }
#line 124
            jj ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 130
          if (jj == m) {
#line 131
            ind[m] = kk;
#line 132
            tmp___1 = m;
#line 132
            m ++;
#line 132
            wgt[tmp___1] = (idxtype )1;
          }
        }
#line 110
        k --;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 108
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 137
    j = 0L;
    {
#line 137
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 137
      if (! (j < m)) {
#line 137
        goto while_break___11;
      }
#line 138
      if (wgt[j] == mgcnum) {
#line 139
        k = ind[j];
#line 140
        tmp___2 = *(dxadj + i);
#line 140
        (*(dxadj + i)) ++;
#line 140
        *(dadjncy + tmp___2) = k;
#line 141
        tmp___3 = *(dxadj + k);
#line 141
        (*(dxadj + k)) ++;
#line 141
        *(dadjncy + tmp___3) = i;
      }
#line 143
      *(mark + (ind[j] & mask)) = (idxtype )-1;
#line 137
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 107
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 148
  i = 0L;
#line 148
  j = i;
  {
#line 148
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 148
    if (! (i < nelmnts)) {
#line 148
      goto while_break___12;
    }
#line 149
    k = esize * i;
    {
#line 149
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 149
      if (! (k < *(dxadj + i))) {
#line 149
        goto while_break___13;
      }
#line 150
      *(dadjncy + j) = *(dadjncy + k);
#line 149
      k ++;
#line 149
      j ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 151
    *(dxadj + i) = j;
#line 148
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 153
  i = nelmnts;
  {
#line 153
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 153
    if (! (i > 0L)) {
#line 153
      goto while_break___14;
    }
#line 154
    *(dxadj + i) = *(dxadj + (i - 1L));
#line 153
    i --;
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 155
  *(dxadj + 0) = (idxtype )0;
#line 157
  free((void *)mark);
#line 158
  free((void *)nptr);
#line 159
  free((void *)nind);
  }
#line 161
  return;
}
}
#line 169 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mesh.c"
void __TRINODALMETIS(long nelmnts , long nvtxs , idxtype *elmnts , idxtype *dxadj ,
                     idxtype *dadjncy ) 
{ 
  long i ;
  long j ;
  long jj ;
  long k ;
  long kk ;
  long nedges ;
  idxtype *nptr ;
  idxtype *nind ;
  idxtype *mark ;
  idxtype tmp ;
  idxtype tmp___0 ;
  long tmp___1 ;

  {
  {
#line 176
  nptr = __idxsmalloc(nvtxs + 1L, (idxtype )0, (char *)"TRINODALMETIS: nptr");
#line 177
  j = 3L * nelmnts;
#line 177
  i = 0L;
  }
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < j)) {
#line 177
      goto while_break;
    }
#line 178
    (*(nptr + *(elmnts + i))) ++;
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 179
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 179
    i = 1L;
    {
#line 179
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 179
      if (! (i < nvtxs)) {
#line 179
        goto while_break___1;
      }
#line 179
      *(nptr + i) += *(nptr + (i - 1L));
#line 179
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 179
    i = nvtxs;
    {
#line 179
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 179
      if (! (i > 0L)) {
#line 179
        goto while_break___2;
      }
#line 179
      *(nptr + i) = *(nptr + (i - 1L));
#line 179
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 179
    *(nptr + 0) = (idxtype )0;
#line 179
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 181
  nind = __idxmalloc(*(nptr + nvtxs), (char *)"TRINODALMETIS: nind");
#line 182
  i = 0L;
#line 182
  k = i;
  }
  {
#line 182
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 182
    if (! (i < nelmnts)) {
#line 182
      goto while_break___3;
    }
#line 183
    j = 0L;
    {
#line 183
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 183
      if (! (j < 3L)) {
#line 183
        goto while_break___4;
      }
#line 184
      tmp = *(nptr + *(elmnts + k));
#line 184
      (*(nptr + *(elmnts + k))) ++;
#line 184
      *(nind + tmp) = i;
#line 183
      j ++;
#line 183
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 182
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 186
  i = nvtxs;
  {
#line 186
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 186
    if (! (i > 0L)) {
#line 186
      goto while_break___5;
    }
#line 187
    *(nptr + i) = *(nptr + (i - 1L));
#line 186
    i --;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 188
  *(nptr + 0) = (idxtype )0;
#line 191
  mark = __idxsmalloc(nvtxs, (idxtype )-1, (char *)"TRINODALMETIS: mark");
#line 193
  tmp___0 = (idxtype )0;
#line 193
  *(dxadj + 0) = tmp___0;
#line 193
  nedges = tmp___0;
#line 194
  i = 0L;
  }
  {
#line 194
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 194
    if (! (i < nvtxs)) {
#line 194
      goto while_break___6;
    }
#line 195
    *(mark + i) = i;
#line 196
    j = *(nptr + i);
    {
#line 196
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 196
      if (! (j < *(nptr + (i + 1L)))) {
#line 196
        goto while_break___7;
      }
#line 197
      jj = 3L * *(nind + j);
#line 197
      k = 0L;
      {
#line 197
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 197
        if (! (k < 3L)) {
#line 197
          goto while_break___8;
        }
#line 198
        kk = *(elmnts + jj);
#line 199
        if (*(mark + kk) != i) {
#line 200
          *(mark + kk) = i;
#line 201
          tmp___1 = nedges;
#line 201
          nedges ++;
#line 201
          *(dadjncy + tmp___1) = kk;
        }
#line 197
        k ++;
#line 197
        jj ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 196
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 205
    *(dxadj + (i + 1L)) = nedges;
#line 194
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 208
  free((void *)mark);
#line 209
  free((void *)nptr);
#line 210
  free((void *)nind);
  }
#line 212
  return;
}
}
#line 218 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mesh.c"
void __TETNODALMETIS(long nelmnts , long nvtxs , idxtype *elmnts , idxtype *dxadj ,
                     idxtype *dadjncy ) 
{ 
  long i ;
  long j ;
  long jj ;
  long k ;
  long kk ;
  long nedges ;
  idxtype *nptr ;
  idxtype *nind ;
  idxtype *mark ;
  idxtype tmp ;
  idxtype tmp___0 ;
  long tmp___1 ;

  {
  {
#line 225
  nptr = __idxsmalloc(nvtxs + 1L, (idxtype )0, (char *)"TETNODALMETIS: nptr");
#line 226
  j = 4L * nelmnts;
#line 226
  i = 0L;
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (i < j)) {
#line 226
      goto while_break;
    }
#line 227
    (*(nptr + *(elmnts + i))) ++;
#line 226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 228
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 228
    i = 1L;
    {
#line 228
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 228
      if (! (i < nvtxs)) {
#line 228
        goto while_break___1;
      }
#line 228
      *(nptr + i) += *(nptr + (i - 1L));
#line 228
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 228
    i = nvtxs;
    {
#line 228
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 228
      if (! (i > 0L)) {
#line 228
        goto while_break___2;
      }
#line 228
      *(nptr + i) = *(nptr + (i - 1L));
#line 228
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 228
    *(nptr + 0) = (idxtype )0;
#line 228
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 230
  nind = __idxmalloc(*(nptr + nvtxs), (char *)"TETNODALMETIS: nind");
#line 231
  i = 0L;
#line 231
  k = i;
  }
  {
#line 231
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 231
    if (! (i < nelmnts)) {
#line 231
      goto while_break___3;
    }
#line 232
    j = 0L;
    {
#line 232
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 232
      if (! (j < 4L)) {
#line 232
        goto while_break___4;
      }
#line 233
      tmp = *(nptr + *(elmnts + k));
#line 233
      (*(nptr + *(elmnts + k))) ++;
#line 233
      *(nind + tmp) = i;
#line 232
      j ++;
#line 232
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 231
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 235
  i = nvtxs;
  {
#line 235
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 235
    if (! (i > 0L)) {
#line 235
      goto while_break___5;
    }
#line 236
    *(nptr + i) = *(nptr + (i - 1L));
#line 235
    i --;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 237
  *(nptr + 0) = (idxtype )0;
#line 240
  mark = __idxsmalloc(nvtxs, (idxtype )-1, (char *)"TETNODALMETIS: mark");
#line 242
  tmp___0 = (idxtype )0;
#line 242
  *(dxadj + 0) = tmp___0;
#line 242
  nedges = tmp___0;
#line 243
  i = 0L;
  }
  {
#line 243
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 243
    if (! (i < nvtxs)) {
#line 243
      goto while_break___6;
    }
#line 244
    *(mark + i) = i;
#line 245
    j = *(nptr + i);
    {
#line 245
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 245
      if (! (j < *(nptr + (i + 1L)))) {
#line 245
        goto while_break___7;
      }
#line 246
      jj = 4L * *(nind + j);
#line 246
      k = 0L;
      {
#line 246
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 246
        if (! (k < 4L)) {
#line 246
          goto while_break___8;
        }
#line 247
        kk = *(elmnts + jj);
#line 248
        if (*(mark + kk) != i) {
#line 249
          *(mark + kk) = i;
#line 250
          tmp___1 = nedges;
#line 250
          nedges ++;
#line 250
          *(dadjncy + tmp___1) = kk;
        }
#line 246
        k ++;
#line 246
        jj ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 245
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 254
    *(dxadj + (i + 1L)) = nedges;
#line 243
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 257
  free((void *)mark);
#line 258
  free((void *)nptr);
#line 259
  free((void *)nind);
  }
#line 261
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mesh.c"
void __HEXNODALMETIS(long nelmnts , long nvtxs , idxtype *elmnts , idxtype *dxadj ,
                     idxtype *dadjncy ) 
{ 
  long i ;
  long j ;
  long jj ;
  long k ;
  long kk ;
  long nedges ;
  idxtype *nptr ;
  idxtype *nind ;
  idxtype *mark ;
  long table[8][3] ;
  idxtype tmp ;
  idxtype tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 272
  table[0][0] = 1L;
#line 272
  table[0][1] = 3L;
#line 272
  table[0][2] = 4L;
#line 272
  table[1][0] = 0L;
#line 272
  table[1][1] = 2L;
#line 272
  table[1][2] = 5L;
#line 272
  table[2][0] = 1L;
#line 272
  table[2][1] = 3L;
#line 272
  table[2][2] = 6L;
#line 272
  table[3][0] = 0L;
#line 272
  table[3][1] = 2L;
#line 272
  table[3][2] = 7L;
#line 272
  table[4][0] = 0L;
#line 272
  table[4][1] = 5L;
#line 272
  table[4][2] = 7L;
#line 272
  table[5][0] = 1L;
#line 272
  table[5][1] = 4L;
#line 272
  table[5][2] = 6L;
#line 272
  table[6][0] = 2L;
#line 272
  table[6][1] = 5L;
#line 272
  table[6][2] = 7L;
#line 272
  table[7][0] = 3L;
#line 272
  table[7][1] = 4L;
#line 272
  table[7][2] = 6L;
#line 282
  nptr = __idxsmalloc(nvtxs + 1L, (idxtype )0, (char *)"HEXNODALMETIS: nptr");
#line 283
  j = 8L * nelmnts;
#line 283
  i = 0L;
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (i < j)) {
#line 283
      goto while_break;
    }
#line 284
    (*(nptr + *(elmnts + i))) ++;
#line 283
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 285
    i = 1L;
    {
#line 285
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 285
      if (! (i < nvtxs)) {
#line 285
        goto while_break___1;
      }
#line 285
      *(nptr + i) += *(nptr + (i - 1L));
#line 285
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 285
    i = nvtxs;
    {
#line 285
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 285
      if (! (i > 0L)) {
#line 285
        goto while_break___2;
      }
#line 285
      *(nptr + i) = *(nptr + (i - 1L));
#line 285
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 285
    *(nptr + 0) = (idxtype )0;
#line 285
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 287
  nind = __idxmalloc(*(nptr + nvtxs), (char *)"HEXNODALMETIS: nind");
#line 288
  i = 0L;
#line 288
  k = i;
  }
  {
#line 288
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 288
    if (! (i < nelmnts)) {
#line 288
      goto while_break___3;
    }
#line 289
    j = 0L;
    {
#line 289
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 289
      if (! (j < 8L)) {
#line 289
        goto while_break___4;
      }
#line 290
      tmp = *(nptr + *(elmnts + k));
#line 290
      (*(nptr + *(elmnts + k))) ++;
#line 290
      *(nind + tmp) = i;
#line 289
      j ++;
#line 289
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 288
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 292
  i = nvtxs;
  {
#line 292
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 292
    if (! (i > 0L)) {
#line 292
      goto while_break___5;
    }
#line 293
    *(nptr + i) = *(nptr + (i - 1L));
#line 292
    i --;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 294
  *(nptr + 0) = (idxtype )0;
#line 297
  mark = __idxsmalloc(nvtxs, (idxtype )-1, (char *)"HEXNODALMETIS: mark");
#line 299
  tmp___0 = (idxtype )0;
#line 299
  *(dxadj + 0) = tmp___0;
#line 299
  nedges = tmp___0;
#line 300
  i = 0L;
  }
  {
#line 300
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 300
    if (! (i < nvtxs)) {
#line 300
      goto while_break___6;
    }
#line 301
    *(mark + i) = i;
#line 302
    j = *(nptr + i);
    {
#line 302
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 302
      if (! (j < *(nptr + (i + 1L)))) {
#line 302
        goto while_break___7;
      }
#line 303
      jj = 8L * *(nind + j);
#line 304
      k = 0L;
      {
#line 304
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 304
        if (! (k < 8L)) {
#line 304
          goto while_break___8;
        }
#line 305
        if (*(elmnts + (jj + k)) == i) {
#line 306
          goto while_break___8;
        }
#line 304
        k ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 311
      kk = *(elmnts + (jj + table[k][0]));
#line 312
      if (*(mark + kk) != i) {
#line 313
        *(mark + kk) = i;
#line 314
        tmp___1 = nedges;
#line 314
        nedges ++;
#line 314
        *(dadjncy + tmp___1) = kk;
      }
#line 316
      kk = *(elmnts + (jj + table[k][1]));
#line 317
      if (*(mark + kk) != i) {
#line 318
        *(mark + kk) = i;
#line 319
        tmp___2 = nedges;
#line 319
        nedges ++;
#line 319
        *(dadjncy + tmp___2) = kk;
      }
#line 321
      kk = *(elmnts + (jj + table[k][2]));
#line 322
      if (*(mark + kk) != i) {
#line 323
        *(mark + kk) = i;
#line 324
        tmp___3 = nedges;
#line 324
        nedges ++;
#line 324
        *(dadjncy + tmp___3) = kk;
      }
#line 302
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 327
    *(dxadj + (i + 1L)) = nedges;
#line 300
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 330
  free((void *)mark);
#line 331
  free((void *)nptr);
#line 332
  free((void *)nind);
  }
#line 334
  return;
}
}
#line 340 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mesh.c"
void QUADNODALMETIS(long nelmnts , long nvtxs , idxtype *elmnts , idxtype *dxadj ,
                    idxtype *dadjncy ) 
{ 
  long i ;
  long j ;
  long jj ;
  long k ;
  long kk ;
  long nedges ;
  idxtype *nptr ;
  idxtype *nind ;
  idxtype *mark ;
  long table[4][2] ;
  idxtype tmp ;
  idxtype tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 345
  table[0][0] = 1L;
#line 345
  table[0][1] = 3L;
#line 345
  table[1][0] = 0L;
#line 345
  table[1][1] = 2L;
#line 345
  table[2][0] = 1L;
#line 345
  table[2][1] = 3L;
#line 345
  table[3][0] = 0L;
#line 345
  table[3][1] = 2L;
#line 351
  nptr = __idxsmalloc(nvtxs + 1L, (idxtype )0, (char *)"QUADNODALMETIS: nptr");
#line 352
  j = 4L * nelmnts;
#line 352
  i = 0L;
  }
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (i < j)) {
#line 352
      goto while_break;
    }
#line 353
    (*(nptr + *(elmnts + i))) ++;
#line 352
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 354
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 354
    i = 1L;
    {
#line 354
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 354
      if (! (i < nvtxs)) {
#line 354
        goto while_break___1;
      }
#line 354
      *(nptr + i) += *(nptr + (i - 1L));
#line 354
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 354
    i = nvtxs;
    {
#line 354
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 354
      if (! (i > 0L)) {
#line 354
        goto while_break___2;
      }
#line 354
      *(nptr + i) = *(nptr + (i - 1L));
#line 354
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 354
    *(nptr + 0) = (idxtype )0;
#line 354
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 356
  nind = __idxmalloc(*(nptr + nvtxs), (char *)"QUADNODALMETIS: nind");
#line 357
  i = 0L;
#line 357
  k = i;
  }
  {
#line 357
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 357
    if (! (i < nelmnts)) {
#line 357
      goto while_break___3;
    }
#line 358
    j = 0L;
    {
#line 358
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 358
      if (! (j < 4L)) {
#line 358
        goto while_break___4;
      }
#line 359
      tmp = *(nptr + *(elmnts + k));
#line 359
      (*(nptr + *(elmnts + k))) ++;
#line 359
      *(nind + tmp) = i;
#line 358
      j ++;
#line 358
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 357
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 361
  i = nvtxs;
  {
#line 361
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 361
    if (! (i > 0L)) {
#line 361
      goto while_break___5;
    }
#line 362
    *(nptr + i) = *(nptr + (i - 1L));
#line 361
    i --;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 363
  *(nptr + 0) = (idxtype )0;
#line 366
  mark = __idxsmalloc(nvtxs, (idxtype )-1, (char *)"QUADNODALMETIS: mark");
#line 368
  tmp___0 = (idxtype )0;
#line 368
  *(dxadj + 0) = tmp___0;
#line 368
  nedges = tmp___0;
#line 369
  i = 0L;
  }
  {
#line 369
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 369
    if (! (i < nvtxs)) {
#line 369
      goto while_break___6;
    }
#line 370
    *(mark + i) = i;
#line 371
    j = *(nptr + i);
    {
#line 371
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 371
      if (! (j < *(nptr + (i + 1L)))) {
#line 371
        goto while_break___7;
      }
#line 372
      jj = 4L * *(nind + j);
#line 373
      k = 0L;
      {
#line 373
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 373
        if (! (k < 4L)) {
#line 373
          goto while_break___8;
        }
#line 374
        if (*(elmnts + (jj + k)) == i) {
#line 375
          goto while_break___8;
        }
#line 373
        k ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 380
      kk = *(elmnts + (jj + table[k][0]));
#line 381
      if (*(mark + kk) != i) {
#line 382
        *(mark + kk) = i;
#line 383
        tmp___1 = nedges;
#line 383
        nedges ++;
#line 383
        *(dadjncy + tmp___1) = kk;
      }
#line 385
      kk = *(elmnts + (jj + table[k][1]));
#line 386
      if (*(mark + kk) != i) {
#line 387
        *(mark + kk) = i;
#line 388
        tmp___2 = nedges;
#line 388
        nedges ++;
#line 388
        *(dadjncy + tmp___2) = kk;
      }
#line 371
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 391
    *(dxadj + (i + 1L)) = nedges;
#line 369
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 394
  free((void *)mark);
#line 395
  free((void *)nptr);
#line 396
  free((void *)nind);
  }
#line 398
  return;
}
}
#line 326 "./proto.h"
long __AreAllVwgtsBelow(long ncon , float alpha , float *vwgt1 , float beta , float *vwgt2 ,
                        float limit ) ;
#line 327
long __AreAnyVwgtsBelow(long ncon , float alpha , float *vwgt1 , float beta , float *vwgt2 ,
                        float limit ) ;
#line 328
long __AreAllVwgtsAbove(long ncon , float alpha , float *vwgt1 , float beta , float *vwgt2 ,
                        float limit ) ;
#line 21 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mutil.c"
long __AreAllVwgtsBelow(long ncon , float alpha , float *vwgt1 , float beta , float *vwgt2 ,
                        float limit ) 
{ 
  long i ;

  {
#line 25
  i = 0L;
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! (i < ncon)) {
#line 25
      goto while_break;
    }
#line 26
    if (alpha * *(vwgt1 + i) + beta * *(vwgt2 + i) > limit) {
#line 27
      return (0L);
    }
#line 25
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 29
  return (1L);
}
}
#line 37 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mutil.c"
long __AreAnyVwgtsBelow(long ncon , float alpha , float *vwgt1 , float beta , float *vwgt2 ,
                        float limit ) 
{ 
  long i ;

  {
#line 41
  i = 0L;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (i < ncon)) {
#line 41
      goto while_break;
    }
#line 42
    if (alpha * *(vwgt1 + i) + beta * *(vwgt2 + i) < limit) {
#line 43
      return (1L);
    }
#line 41
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return (0L);
}
}
#line 54 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mutil.c"
long __AreAllVwgtsAbove(long ncon , float alpha , float *vwgt1 , float beta , float *vwgt2 ,
                        float limit ) 
{ 
  long i ;

  {
#line 58
  i = 0L;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i < ncon)) {
#line 58
      goto while_break;
    }
#line 59
    if (alpha * *(vwgt1 + i) + beta * *(vwgt2 + i) < limit) {
#line 60
      return (0L);
    }
#line 58
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return (1L);
}
}
#line 70 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mutil.c"
float __ComputeLoadImbalance(long ncon , long nparts , float *npwgts , float *tpwgts ) 
{ 
  long i ;
  long j ;
  float max ;
  float lb ;

  {
#line 73
  lb = (float )0.0;
#line 75
  i = 0L;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i < ncon)) {
#line 75
      goto while_break;
    }
#line 76
    max = (float )0.0;
#line 77
    j = 0L;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 77
      if (! (j < nparts)) {
#line 77
        goto while_break___0;
      }
#line 78
      if (*(npwgts + (j * ncon + i)) > max) {
#line 79
        max = *(npwgts + (j * ncon + i));
      }
#line 77
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 81
    if (max * (float )nparts > lb) {
#line 82
      lb = max * (float )nparts;
    }
#line 75
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (lb);
}
}
#line 92 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mutil.c"
long __AreAllBelow(long ncon , float *v1 , float *v2 ) 
{ 
  long i ;

  {
#line 96
  i = 0L;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (i < ncon)) {
#line 96
      goto while_break;
    }
#line 97
    if (*(v1 + i) > *(v2 + i)) {
#line 98
      return (0L);
    }
#line 96
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (1L);
}
}
#line 276 "./proto.h"
long __AreAllHVwgtsBelow(long ncon , float alpha , float *vwgt1 , float beta , float *vwgt2 ,
                         float *limit ) ;
#line 277
long __AreAllHVwgtsAbove(long ncon , float alpha , float *vwgt1 , float beta , float *vwgt2 ,
                         float *limit ) ;
#line 278
void __ComputeHKWayLoadImbalance(long ncon , long nparts , float *npwgts , float *lbvec ) ;
#line 280
long __IsHBalanceBetterFT(long ncon , long nparts , float *pfrom , float *pto , float *vwgt ,
                          float *ubvec ) ;
#line 281
long __IsHBalanceBetterTT(long ncon , long nparts , float *pt1 , float *pt2 , float *vwgt ,
                          float *ubvec ) ;
#line 445
long __samin(long n , float *x ) ;
#line 20 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mkwayfmh.c"
void __MCRandom_KWayEdgeRefineHorizontal(CtrlType *ctrl , GraphType *graph , long nparts ,
                                         float *orgubvec , long npasses ) 
{ 
  long i ;
  long ii ;
  long iii ;
  long j ;
  long k ;
  long pass ;
  long nvtxs ;
  long ncon ;
  long nmoves ;
  long nbnd ;
  long myndegrees ;
  long same ;
  long from ;
  long me ;
  long to ;
  long oldcut ;
  long gain ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *perm ;
  idxtype *bndptr ;
  idxtype *bndind ;
  EDegreeType *myedegrees ;
  RInfoType *myrinfo ;
  float *npwgts ;
  float *nvwgt ;
  float *minwgt ;
  float *maxwgt ;
  float maxlb ;
  float minlb ;
  float ubvec[16] ;
  float tvec[16] ;
  double tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;

  {
  {
#line 31
  nvtxs = graph->nvtxs;
#line 32
  ncon = graph->ncon;
#line 33
  xadj = graph->xadj;
#line 34
  adjncy = graph->adjncy;
#line 35
  adjwgt = graph->adjwgt;
#line 37
  bndptr = graph->bndptr;
#line 38
  bndind = graph->bndind;
#line 40
  where = graph->where;
#line 41
  npwgts = graph->npwgts;
#line 44
  minwgt = __fwspacemalloc(ctrl, nparts * ncon);
#line 45
  maxwgt = __fwspacemalloc(ctrl, nparts * ncon);
#line 48
  minlb = *(orgubvec + 0);
#line 48
  maxlb = minlb;
#line 49
  i = 1L;
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (i < ncon)) {
#line 49
      goto while_break;
    }
#line 50
    if (*(orgubvec + i) < minlb) {
#line 50
      minlb = *(orgubvec + i);
    } else {
#line 50
      minlb = minlb;
    }
#line 51
    if (*(orgubvec + i) > maxlb) {
#line 51
      maxlb = *(orgubvec + i);
    } else {
#line 51
      maxlb = maxlb;
    }
#line 49
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  tmp___0 = fabs((double )(maxlb - minlb));
  }
#line 53
  if (tmp___0 < .01) {
#line 53
    same = 1L;
  } else {
#line 53
    same = 0L;
  }
  {
#line 57
  __ComputeHKWayLoadImbalance(ncon, nparts, npwgts, ubvec);
#line 58
  i = 0L;
  }
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 58
    if (! (i < ncon)) {
#line 58
      goto while_break___0;
    }
#line 59
    if (ubvec[i] >= *(orgubvec + i)) {
#line 59
      ubvec[i] = ubvec[i];
    } else {
#line 59
      ubvec[i] = *(orgubvec + i);
    }
#line 58
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 61
  if (! same) {
#line 62
    i = 0L;
    {
#line 62
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 62
      if (! (i < nparts)) {
#line 62
        goto while_break___1;
      }
#line 63
      j = 0L;
      {
#line 63
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 63
        if (! (j < ncon)) {
#line 63
          goto while_break___2;
        }
#line 64
        *(maxwgt + (i * ncon + j)) = ubvec[j] / (float )nparts;
#line 65
        *(minwgt + (i * ncon + j)) = (float )(1.0 / (double )(ubvec[j] * (float )nparts));
#line 63
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 62
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 70
    maxlb = ubvec[0];
#line 71
    i = 1L;
    {
#line 71
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 71
      if (! (i < ncon)) {
#line 71
        goto while_break___3;
      }
#line 72
      if (ubvec[i] > maxlb) {
#line 72
        maxlb = ubvec[i];
      } else {
#line 72
        maxlb = maxlb;
      }
#line 71
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 74
    i = 0L;
    {
#line 74
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 74
      if (! (i < nparts)) {
#line 74
        goto while_break___4;
      }
#line 75
      j = 0L;
      {
#line 75
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 75
        if (! (j < ncon)) {
#line 75
          goto while_break___5;
        }
#line 76
        *(maxwgt + (i * ncon + j)) = maxlb / (float )nparts;
#line 77
        *(minwgt + (i * ncon + j)) = (float )(1.0 / (double )(maxlb * (float )nparts));
#line 75
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 74
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 83
  perm = __idxwspacemalloc(ctrl, nvtxs);
  }
#line 85
  if (ctrl->dbglvl & 8L) {
    {
#line 86
    tmp___1 = __samax(ncon * nparts, npwgts);
#line 86
    tmp___2 = __samin(ncon * nparts, npwgts);
#line 86
    printf((char const   */* __restrict  */)"Partitions: [%5.4f %5.4f], Nv-Nb[%6ld %6ld]. Cut: %6ld, LB: ",
           (double )*(npwgts + tmp___2), (double )*(npwgts + tmp___1), graph->nvtxs,
           graph->nbnd, graph->mincut);
#line 89
    __ComputeHKWayLoadImbalance(ncon, nparts, npwgts, tvec);
#line 90
    i = 0L;
    }
    {
#line 90
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 90
      if (! (i < ncon)) {
#line 90
        goto while_break___6;
      }
      {
#line 91
      printf((char const   */* __restrict  */)"%.3f ", (double )tvec[i]);
#line 90
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 92
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 95
  pass = 0L;
  {
#line 95
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 95
    if (! (pass < npasses)) {
#line 95
      goto while_break___7;
    }
    {
#line 98
    oldcut = graph->mincut;
#line 99
    nbnd = graph->nbnd;
#line 101
    __RandomPermute(nbnd, perm, 1L);
#line 102
    iii = 0L;
#line 102
    nmoves = iii;
    }
    {
#line 102
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 102
      if (! (iii < graph->nbnd)) {
#line 102
        goto while_break___8;
      }
#line 103
      ii = *(perm + iii);
#line 104
      if (ii >= nbnd) {
#line 105
        goto __Cont;
      }
#line 106
      i = *(bndind + ii);
#line 108
      myrinfo = graph->rinfo + i;
#line 110
      if (myrinfo->ed >= myrinfo->id) {
#line 111
        from = *(where + i);
#line 112
        nvwgt = graph->nvwgt + i * ncon;
#line 114
        if (myrinfo->id > 0L) {
          {
#line 114
          tmp___3 = __AreAllHVwgtsBelow(ncon, (float )1.0, npwgts + from * ncon, (float )(- 1.0),
                                        nvwgt, minwgt + from * ncon);
          }
#line 114
          if (tmp___3) {
#line 115
            goto __Cont;
          }
        }
#line 117
        myedegrees = myrinfo->edegrees;
#line 118
        myndegrees = myrinfo->ndegrees;
#line 120
        k = 0L;
        {
#line 120
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 120
          if (! (k < myndegrees)) {
#line 120
            goto while_break___9;
          }
#line 121
          to = (myedegrees + k)->pid;
#line 122
          gain = (myedegrees + k)->ed - myrinfo->id;
#line 123
          if (gain >= 0L) {
            {
#line 123
            tmp___4 = __AreAllHVwgtsBelow(ncon, (float )1.0, npwgts + to * ncon, (float )1.0,
                                          nvwgt, maxwgt + to * ncon);
            }
#line 123
            if (tmp___4) {
#line 126
              goto while_break___9;
            } else {
              {
#line 123
              tmp___5 = __IsHBalanceBetterFT(ncon, nparts, npwgts + from * ncon, npwgts + to * ncon,
                                             nvwgt, ubvec);
              }
#line 123
              if (tmp___5) {
#line 126
                goto while_break___9;
              }
            }
          }
#line 120
          k ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 128
        if (k == myndegrees) {
#line 129
          goto __Cont;
        }
#line 131
        j = k + 1L;
        {
#line 131
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 131
          if (! (j < myndegrees)) {
#line 131
            goto while_break___10;
          }
#line 132
          to = (myedegrees + j)->pid;
#line 133
          if ((myedegrees + j)->ed > (myedegrees + k)->ed) {
            {
#line 133
            tmp___6 = __AreAllHVwgtsBelow(ncon, (float )1.0, npwgts + to * ncon, (float )1.0,
                                          nvwgt, maxwgt + to * ncon);
            }
#line 133
            if (tmp___6) {
#line 138
              k = j;
            } else {
              {
#line 133
              tmp___7 = __IsHBalanceBetterFT(ncon, nparts, npwgts + from * ncon, npwgts + to * ncon,
                                             nvwgt, ubvec);
              }
#line 133
              if (tmp___7) {
#line 138
                k = j;
              } else {
#line 133
                goto _L;
              }
            }
          } else
          _L: /* CIL Label */ 
#line 133
          if ((myedegrees + j)->ed == (myedegrees + k)->ed) {
            {
#line 133
            tmp___8 = __IsHBalanceBetterTT(ncon, nparts, npwgts + (myedegrees + k)->pid * ncon,
                                           npwgts + to * ncon, nvwgt, ubvec);
            }
#line 133
            if (tmp___8) {
#line 138
              k = j;
            }
          }
#line 131
          j ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 141
        to = (myedegrees + k)->pid;
#line 143
        if ((myedegrees + k)->ed - myrinfo->id == 0L) {
          {
#line 143
          tmp___9 = __IsHBalanceBetterFT(ncon, nparts, npwgts + from * ncon, npwgts + to * ncon,
                                         nvwgt, ubvec);
          }
#line 143
          if (! tmp___9) {
            {
#line 143
            tmp___10 = __AreAllHVwgtsBelow(ncon, (float )1.0, npwgts + from * ncon,
                                           (float )0.0, npwgts + from * ncon, maxwgt + from * ncon);
            }
#line 143
            if (tmp___10) {
#line 146
              goto __Cont;
            }
          }
        }
#line 151
        graph->mincut -= (myedegrees + k)->ed - myrinfo->id;
#line 153
        if (ctrl->dbglvl & 32L) {
          {
#line 153
          printf((char const   */* __restrict  */)"\t\tMoving %6ld to %3ld. Gain: %4ld. Cut: %6ld\n",
                 i, to, (myedegrees + k)->ed - myrinfo->id, graph->mincut);
          }
        }
        {
#line 156
        __saxpy(ncon, (float )1.0, nvwgt, 1L, npwgts + to * ncon, 1L);
#line 157
        __saxpy(ncon, (float )(- 1.0), nvwgt, 1L, npwgts + from * ncon, 1L);
#line 158
        *(where + i) = to;
#line 159
        myrinfo->ed += myrinfo->id - (myedegrees + k)->ed;
        }
        {
#line 160
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 160
          j = myrinfo->id;
#line 160
          myrinfo->id = (myedegrees + k)->ed;
#line 160
          (myedegrees + k)->ed = j;
#line 160
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 161
        if ((myedegrees + k)->ed == 0L) {
#line 162
          (myrinfo->ndegrees) --;
#line 162
          *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
        } else {
#line 164
          (myedegrees + k)->pid = from;
        }
#line 166
        if (myrinfo->ed - myrinfo->id < 0L) {
          {
#line 167
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 167
            nbnd --;
#line 167
            *(bndind + *(bndptr + i)) = *(bndind + nbnd);
#line 167
            *(bndptr + *(bndind + nbnd)) = *(bndptr + i);
#line 167
            *(bndptr + i) = (idxtype )-1;
#line 167
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
        }
#line 170
        j = *(xadj + i);
        {
#line 170
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 170
          if (! (j < *(xadj + (i + 1L)))) {
#line 170
            goto while_break___13;
          }
#line 171
          ii = *(adjncy + j);
#line 172
          me = *(where + ii);
#line 174
          myrinfo = graph->rinfo + ii;
#line 175
          if ((unsigned long )myrinfo->edegrees == (unsigned long )((void *)0)) {
#line 176
            myrinfo->edegrees = ctrl->wspace.edegrees + ctrl->wspace.cdegree;
#line 177
            ctrl->wspace.cdegree += *(xadj + (ii + 1L)) - *(xadj + ii);
          }
#line 179
          myedegrees = myrinfo->edegrees;
#line 183
          if (me == from) {
            {
#line 184
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 184
              myrinfo->ed += *(adjwgt + j);
#line 184
              myrinfo->id -= *(adjwgt + j);
#line 184
              goto while_break___14;
            }
            while_break___14: /* CIL Label */ ;
            }
#line 186
            if (myrinfo->ed - myrinfo->id >= 0L) {
#line 186
              if (*(bndptr + ii) == -1L) {
                {
#line 187
                while (1) {
                  while_continue___15: /* CIL Label */ ;
#line 187
                  *(bndind + nbnd) = ii;
#line 187
                  tmp___11 = nbnd;
#line 187
                  nbnd ++;
#line 187
                  *(bndptr + ii) = tmp___11;
#line 187
                  goto while_break___15;
                }
                while_break___15: /* CIL Label */ ;
                }
              }
            }
          } else
#line 189
          if (me == to) {
            {
#line 190
            while (1) {
              while_continue___16: /* CIL Label */ ;
#line 190
              myrinfo->id += *(adjwgt + j);
#line 190
              myrinfo->ed -= *(adjwgt + j);
#line 190
              goto while_break___16;
            }
            while_break___16: /* CIL Label */ ;
            }
#line 192
            if (myrinfo->ed - myrinfo->id < 0L) {
#line 192
              if (*(bndptr + ii) != -1L) {
                {
#line 193
                while (1) {
                  while_continue___17: /* CIL Label */ ;
#line 193
                  nbnd --;
#line 193
                  *(bndind + *(bndptr + ii)) = *(bndind + nbnd);
#line 193
                  *(bndptr + *(bndind + nbnd)) = *(bndptr + ii);
#line 193
                  *(bndptr + ii) = (idxtype )-1;
#line 193
                  goto while_break___17;
                }
                while_break___17: /* CIL Label */ ;
                }
              }
            }
          }
#line 197
          if (me != from) {
#line 198
            k = 0L;
            {
#line 198
            while (1) {
              while_continue___18: /* CIL Label */ ;
#line 198
              if (! (k < myrinfo->ndegrees)) {
#line 198
                goto while_break___18;
              }
#line 199
              if ((myedegrees + k)->pid == from) {
#line 200
                if ((myedegrees + k)->ed == *(adjwgt + j)) {
#line 201
                  (myrinfo->ndegrees) --;
#line 201
                  *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
                } else {
#line 203
                  (myedegrees + k)->ed -= *(adjwgt + j);
                }
#line 204
                goto while_break___18;
              }
#line 198
              k ++;
            }
            while_break___18: /* CIL Label */ ;
            }
          }
#line 210
          if (me != to) {
#line 211
            k = 0L;
            {
#line 211
            while (1) {
              while_continue___19: /* CIL Label */ ;
#line 211
              if (! (k < myrinfo->ndegrees)) {
#line 211
                goto while_break___19;
              }
#line 212
              if ((myedegrees + k)->pid == to) {
#line 213
                (myedegrees + k)->ed += *(adjwgt + j);
#line 214
                goto while_break___19;
              }
#line 211
              k ++;
            }
            while_break___19: /* CIL Label */ ;
            }
#line 217
            if (k == myrinfo->ndegrees) {
#line 218
              (myedegrees + myrinfo->ndegrees)->pid = to;
#line 219
              tmp___12 = myrinfo->ndegrees;
#line 219
              (myrinfo->ndegrees) ++;
#line 219
              (myedegrees + tmp___12)->ed = *(adjwgt + j);
            }
          }
#line 170
          j ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 227
        nmoves ++;
      }
      __Cont: /* CIL Label */ 
#line 102
      iii ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 231
    graph->nbnd = nbnd;
#line 233
    if (ctrl->dbglvl & 8L) {
      {
#line 234
      tmp___13 = __samax(ncon * nparts, npwgts);
#line 234
      tmp___14 = __samin(ncon * nparts, npwgts);
#line 234
      printf((char const   */* __restrict  */)"\t [%5.4f %5.4f], Nb: %6ld, Nmoves: %5ld, Cut: %6ld, LB: ",
             (double )*(npwgts + tmp___14), (double )*(npwgts + tmp___13), nbnd, nmoves,
             graph->mincut);
#line 237
      __ComputeHKWayLoadImbalance(ncon, nparts, npwgts, tvec);
#line 238
      i = 0L;
      }
      {
#line 238
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 238
        if (! (i < ncon)) {
#line 238
          goto while_break___20;
        }
        {
#line 239
        printf((char const   */* __restrict  */)"%.3f ", (double )tvec[i]);
#line 238
        i ++;
        }
      }
      while_break___20: /* CIL Label */ ;
      }
      {
#line 240
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 243
    if (graph->mincut == oldcut) {
#line 244
      goto while_break___7;
    }
#line 95
    pass ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 247
  fwspacefree(ctrl, ncon * nparts);
#line 248
  fwspacefree(ctrl, ncon * nparts);
#line 249
  __idxwspacefree(ctrl, nvtxs);
  }
#line 250
  return;
}
}
#line 257 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mkwayfmh.c"
void __MCGreedy_KWayEdgeBalanceHorizontal(CtrlType *ctrl , GraphType *graph , long nparts ,
                                          float *ubvec , long npasses ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long pass ;
  long nvtxs ;
  long ncon ;
  long nbnd ;
  long myndegrees ;
  long oldgain ;
  long gain ;
  long nmoves ;
  long from ;
  long me ;
  long to ;
  long oldcut ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *perm ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *moved ;
  EDegreeType *myedegrees ;
  RInfoType *myrinfo ;
  PQueueType queue ;
  float *npwgts ;
  float *nvwgt ;
  float *minwgt ;
  float *maxwgt ;
  float tvec[16] ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;

  {
  {
#line 269
  nvtxs = graph->nvtxs;
#line 270
  ncon = graph->ncon;
#line 271
  xadj = graph->xadj;
#line 272
  adjncy = graph->adjncy;
#line 273
  adjwgt = graph->adjwgt;
#line 275
  bndind = graph->bndind;
#line 276
  bndptr = graph->bndptr;
#line 278
  where = graph->where;
#line 279
  npwgts = graph->npwgts;
#line 282
  minwgt = __fwspacemalloc(ctrl, ncon * nparts);
#line 283
  maxwgt = __fwspacemalloc(ctrl, ncon * nparts);
#line 285
  i = 0L;
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! (i < nparts)) {
#line 285
      goto while_break;
    }
#line 286
    j = 0L;
    {
#line 286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 286
      if (! (j < ncon)) {
#line 286
        goto while_break___0;
      }
#line 287
      *(maxwgt + (i * ncon + j)) = *(ubvec + j) / (float )nparts;
#line 288
      *(minwgt + (i * ncon + j)) = (float )(1.0 / (double )(*(ubvec + j) * (float )nparts));
#line 286
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 285
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 292
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 293
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 295
  tmp = __idxamax(nvtxs, graph->adjwgtsum);
#line 295
  __PQueueInit(ctrl, & queue, nvtxs, *(graph->adjwgtsum + tmp));
  }
#line 297
  if (ctrl->dbglvl & 8L) {
    {
#line 298
    tmp___0 = __samax(ncon * nparts, npwgts);
#line 298
    tmp___1 = __samin(ncon * nparts, npwgts);
#line 298
    printf((char const   */* __restrict  */)"Partitions: [%5.4f %5.4f], Nv-Nb[%6ld %6ld]. Cut: %6ld, LB: ",
           (double )*(npwgts + tmp___1), (double )*(npwgts + tmp___0), graph->nvtxs,
           graph->nbnd, graph->mincut);
#line 301
    __ComputeHKWayLoadImbalance(ncon, nparts, npwgts, tvec);
#line 302
    i = 0L;
    }
    {
#line 302
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 302
      if (! (i < ncon)) {
#line 302
        goto while_break___1;
      }
      {
#line 303
      printf((char const   */* __restrict  */)"%.3f ", (double )tvec[i]);
#line 302
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 304
    printf((char const   */* __restrict  */)"[B]\n");
    }
  }
#line 308
  pass = 0L;
  {
#line 308
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 308
    if (! (pass < npasses)) {
#line 308
      goto while_break___2;
    }
    {
#line 312
    tmp___2 = __MocIsHBalanced(ncon, nparts, npwgts, ubvec);
    }
#line 312
    if (tmp___2) {
#line 313
      goto while_break___2;
    }
    {
#line 315
    __PQueueReset(& queue);
#line 316
    __idxset(nvtxs, (idxtype )-1, moved);
#line 318
    oldcut = graph->mincut;
#line 319
    nbnd = graph->nbnd;
#line 321
    __RandomPermute(nbnd, perm, 1L);
#line 322
    ii = 0L;
    }
    {
#line 322
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 322
      if (! (ii < nbnd)) {
#line 322
        goto while_break___3;
      }
      {
#line 323
      i = *(bndind + *(perm + ii));
#line 324
      __PQueueInsert(& queue, i, (graph->rinfo + i)->ed - (graph->rinfo + i)->id);
#line 325
      *(moved + i) = (idxtype )2;
#line 322
      ii ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 328
    nmoves = 0L;
    {
#line 329
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 330
      i = __PQueueGetMax(& queue);
      }
#line 330
      if (i == -1L) {
#line 331
        goto while_break___4;
      }
      {
#line 332
      *(moved + i) = (idxtype )1;
#line 334
      myrinfo = graph->rinfo + i;
#line 335
      from = *(where + i);
#line 336
      nvwgt = graph->nvwgt + i * ncon;
#line 338
      tmp___3 = __AreAllHVwgtsBelow(ncon, (float )1.0, npwgts + from * ncon, (float )(- 1.0),
                                    nvwgt, minwgt + from * ncon);
      }
#line 338
      if (tmp___3) {
#line 339
        goto __Cont;
      }
#line 341
      myedegrees = myrinfo->edegrees;
#line 342
      myndegrees = myrinfo->ndegrees;
#line 344
      k = 0L;
      {
#line 344
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 344
        if (! (k < myndegrees)) {
#line 344
          goto while_break___5;
        }
        {
#line 345
        to = (myedegrees + k)->pid;
#line 346
        tmp___4 = __IsHBalanceBetterFT(ncon, nparts, npwgts + from * ncon, npwgts + to * ncon,
                                       nvwgt, ubvec);
        }
#line 346
        if (tmp___4) {
#line 347
          goto while_break___5;
        }
#line 344
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 349
      if (k == myndegrees) {
#line 350
        goto __Cont;
      }
#line 352
      j = k + 1L;
      {
#line 352
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 352
        if (! (j < myndegrees)) {
#line 352
          goto while_break___6;
        }
        {
#line 353
        to = (myedegrees + j)->pid;
#line 354
        tmp___5 = __IsHBalanceBetterTT(ncon, nparts, npwgts + (myedegrees + k)->pid * ncon,
                                       npwgts + to * ncon, nvwgt, ubvec);
        }
#line 354
        if (tmp___5) {
#line 355
          k = j;
        }
#line 352
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 358
      to = (myedegrees + k)->pid;
#line 360
      j = 0L;
#line 361
      tmp___6 = __AreAllHVwgtsBelow(ncon, (float )1.0, npwgts + from * ncon, (float )0.0,
                                    nvwgt, maxwgt + from * ncon);
      }
#line 361
      if (! tmp___6) {
#line 362
        j ++;
      }
#line 363
      if ((myedegrees + k)->ed - myrinfo->id >= 0L) {
#line 364
        j ++;
      }
      {
#line 365
      tmp___7 = __AreAllHVwgtsAbove(ncon, (float )1.0, npwgts + to * ncon, (float )0.0,
                                    nvwgt, minwgt + to * ncon);
      }
#line 365
      if (! tmp___7) {
        {
#line 365
        tmp___8 = __AreAllHVwgtsBelow(ncon, (float )1.0, npwgts + to * ncon, (float )1.0,
                                      nvwgt, maxwgt + to * ncon);
        }
#line 365
        if (tmp___8) {
#line 367
          j ++;
        }
      }
#line 368
      if (j == 0L) {
#line 369
        goto __Cont;
      }
#line 381
      graph->mincut -= (myedegrees + k)->ed - myrinfo->id;
#line 383
      if (ctrl->dbglvl & 32L) {
        {
#line 383
        printf((char const   */* __restrict  */)"\t\tMoving %6ld to %3ld. Gain: %4ld. Cut: %6ld\n",
               i, to, (myedegrees + k)->ed - myrinfo->id, graph->mincut);
        }
      }
      {
#line 386
      __saxpy(ncon, (float )1.0, nvwgt, 1L, npwgts + to * ncon, 1L);
#line 387
      __saxpy(ncon, (float )(- 1.0), nvwgt, 1L, npwgts + from * ncon, 1L);
#line 388
      *(where + i) = to;
#line 389
      myrinfo->ed += myrinfo->id - (myedegrees + k)->ed;
      }
      {
#line 390
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 390
        j = myrinfo->id;
#line 390
        myrinfo->id = (myedegrees + k)->ed;
#line 390
        (myedegrees + k)->ed = j;
#line 390
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 391
      if ((myedegrees + k)->ed == 0L) {
#line 392
        (myrinfo->ndegrees) --;
#line 392
        *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
      } else {
#line 394
        (myedegrees + k)->pid = from;
      }
#line 396
      if (myrinfo->ed == 0L) {
        {
#line 397
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 397
          nbnd --;
#line 397
          *(bndind + *(bndptr + i)) = *(bndind + nbnd);
#line 397
          *(bndptr + *(bndind + nbnd)) = *(bndptr + i);
#line 397
          *(bndptr + i) = (idxtype )-1;
#line 397
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 400
      j = *(xadj + i);
      {
#line 400
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 400
        if (! (j < *(xadj + (i + 1L)))) {
#line 400
          goto while_break___9;
        }
#line 401
        ii = *(adjncy + j);
#line 402
        me = *(where + ii);
#line 404
        myrinfo = graph->rinfo + ii;
#line 405
        if ((unsigned long )myrinfo->edegrees == (unsigned long )((void *)0)) {
#line 406
          myrinfo->edegrees = ctrl->wspace.edegrees + ctrl->wspace.cdegree;
#line 407
          ctrl->wspace.cdegree += *(xadj + (ii + 1L)) - *(xadj + ii);
        }
#line 409
        myedegrees = myrinfo->edegrees;
#line 413
        oldgain = myrinfo->ed - myrinfo->id;
#line 415
        if (me == from) {
          {
#line 416
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 416
            myrinfo->ed += *(adjwgt + j);
#line 416
            myrinfo->id -= *(adjwgt + j);
#line 416
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 418
          if (myrinfo->ed > 0L) {
#line 418
            if (*(bndptr + ii) == -1L) {
              {
#line 419
              while (1) {
                while_continue___11: /* CIL Label */ ;
#line 419
                *(bndind + nbnd) = ii;
#line 419
                tmp___9 = nbnd;
#line 419
                nbnd ++;
#line 419
                *(bndptr + ii) = tmp___9;
#line 419
                goto while_break___11;
              }
              while_break___11: /* CIL Label */ ;
              }
            }
          }
        } else
#line 421
        if (me == to) {
          {
#line 422
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 422
            myrinfo->id += *(adjwgt + j);
#line 422
            myrinfo->ed -= *(adjwgt + j);
#line 422
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 424
          if (myrinfo->ed == 0L) {
#line 424
            if (*(bndptr + ii) != -1L) {
              {
#line 425
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 425
                nbnd --;
#line 425
                *(bndind + *(bndptr + ii)) = *(bndind + nbnd);
#line 425
                *(bndptr + *(bndind + nbnd)) = *(bndptr + ii);
#line 425
                *(bndptr + ii) = (idxtype )-1;
#line 425
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
            }
          }
        }
#line 429
        if (me != from) {
#line 430
          k = 0L;
          {
#line 430
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 430
            if (! (k < myrinfo->ndegrees)) {
#line 430
              goto while_break___14;
            }
#line 431
            if ((myedegrees + k)->pid == from) {
#line 432
              if ((myedegrees + k)->ed == *(adjwgt + j)) {
#line 433
                (myrinfo->ndegrees) --;
#line 433
                *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
              } else {
#line 435
                (myedegrees + k)->ed -= *(adjwgt + j);
              }
#line 436
              goto while_break___14;
            }
#line 430
            k ++;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
#line 442
        if (me != to) {
#line 443
          k = 0L;
          {
#line 443
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 443
            if (! (k < myrinfo->ndegrees)) {
#line 443
              goto while_break___15;
            }
#line 444
            if ((myedegrees + k)->pid == to) {
#line 445
              (myedegrees + k)->ed += *(adjwgt + j);
#line 446
              goto while_break___15;
            }
#line 443
            k ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 449
          if (k == myrinfo->ndegrees) {
#line 450
            (myedegrees + myrinfo->ndegrees)->pid = to;
#line 451
            tmp___10 = myrinfo->ndegrees;
#line 451
            (myrinfo->ndegrees) ++;
#line 451
            (myedegrees + tmp___10)->ed = *(adjwgt + j);
          }
        }
#line 457
        if (me == to) {
#line 457
          goto _L;
        } else
#line 457
        if (me == from) {
          _L: /* CIL Label */ 
#line 458
          gain = myrinfo->ed - myrinfo->id;
#line 459
          if (*(moved + ii) == 2L) {
#line 460
            if (myrinfo->ed > 0L) {
              {
#line 461
              __PQueueUpdate(& queue, ii, oldgain, gain);
              }
            } else {
              {
#line 463
              __PQueueDelete(& queue, ii, oldgain);
#line 464
              *(moved + ii) = (idxtype )-1;
              }
            }
          } else
#line 467
          if (*(moved + ii) == -1L) {
#line 467
            if (myrinfo->ed > 0L) {
              {
#line 468
              __PQueueInsert(& queue, ii, gain);
#line 469
              *(moved + ii) = (idxtype )2;
              }
            }
          }
        }
#line 400
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 476
      nmoves ++;
      __Cont: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 479
    graph->nbnd = nbnd;
#line 481
    if (ctrl->dbglvl & 8L) {
      {
#line 482
      tmp___11 = __samax(ncon * nparts, npwgts);
#line 482
      tmp___12 = __samin(ncon * nparts, npwgts);
#line 482
      printf((char const   */* __restrict  */)"\t [%5.4f %5.4f], Nb: %6ld, Nmoves: %5ld, Cut: %6ld, LB: ",
             (double )*(npwgts + tmp___12), (double )*(npwgts + tmp___11), nbnd, nmoves,
             graph->mincut);
#line 485
      __ComputeHKWayLoadImbalance(ncon, nparts, npwgts, tvec);
#line 486
      i = 0L;
      }
      {
#line 486
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 486
        if (! (i < ncon)) {
#line 486
          goto while_break___16;
        }
        {
#line 487
        printf((char const   */* __restrict  */)"%.3f ", (double )tvec[i]);
#line 486
        i ++;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 488
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 491
    if (nmoves == 0L) {
#line 492
      goto while_break___2;
    }
#line 308
    pass ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 495
  __PQueueFree(ctrl, & queue);
#line 497
  fwspacefree(ctrl, ncon * nparts);
#line 498
  fwspacefree(ctrl, ncon * nparts);
#line 499
  __idxwspacefree(ctrl, nvtxs);
#line 500
  __idxwspacefree(ctrl, nvtxs);
  }
#line 502
  return;
}
}
#line 512 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mkwayfmh.c"
long __AreAllHVwgtsBelow(long ncon , float alpha , float *vwgt1 , float beta , float *vwgt2 ,
                         float *limit ) 
{ 
  long i ;

  {
#line 516
  i = 0L;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! (i < ncon)) {
#line 516
      goto while_break;
    }
#line 517
    if (alpha * *(vwgt1 + i) + beta * *(vwgt2 + i) > *(limit + i)) {
#line 518
      return (0L);
    }
#line 516
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  return (1L);
}
}
#line 529 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mkwayfmh.c"
long __AreAllHVwgtsAbove(long ncon , float alpha , float *vwgt1 , float beta , float *vwgt2 ,
                         float *limit ) 
{ 
  long i ;

  {
#line 533
  i = 0L;
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! (i < ncon)) {
#line 533
      goto while_break;
    }
#line 534
    if (alpha * *(vwgt1 + i) + beta * *(vwgt2 + i) < *(limit + i)) {
#line 535
      return (0L);
    }
#line 533
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 537
  return (1L);
}
}
#line 545 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mkwayfmh.c"
void __ComputeHKWayLoadImbalance(long ncon , long nparts , float *npwgts , float *lbvec ) 
{ 
  long i ;
  long j ;
  float max ;

  {
#line 550
  i = 0L;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    if (! (i < ncon)) {
#line 550
      goto while_break;
    }
#line 551
    max = (float )0.0;
#line 552
    j = 0L;
    {
#line 552
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 552
      if (! (j < nparts)) {
#line 552
        goto while_break___0;
      }
#line 553
      if (*(npwgts + (j * ncon + i)) > max) {
#line 554
        max = *(npwgts + (j * ncon + i));
      }
#line 552
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 557
    *(lbvec + i) = max * (float )nparts;
#line 550
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 559
  return;
}
}
#line 565 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mkwayfmh.c"
long __MocIsHBalanced(long ncon , long nparts , float *npwgts , float *ubvec ) 
{ 
  long i ;
  long j ;
  float max ;

  {
#line 570
  i = 0L;
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
#line 570
    if (! (i < ncon)) {
#line 570
      goto while_break;
    }
#line 571
    max = (float )0.0;
#line 572
    j = 0L;
    {
#line 572
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 572
      if (! (j < nparts)) {
#line 572
        goto while_break___0;
      }
#line 573
      if (*(npwgts + (j * ncon + i)) > max) {
#line 574
        max = *(npwgts + (j * ncon + i));
      }
#line 572
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 577
    if (*(ubvec + i) < max * (float )nparts) {
#line 578
      return (0L);
    }
#line 570
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 581
  return (1L);
}
}
#line 593 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mkwayfmh.c"
long __IsHBalanceBetterFT(long ncon , long nparts , float *pfrom , float *pto , float *vwgt ,
                          float *ubvec ) 
{ 
  long i ;
  float blb1 ;
  float alb1 ;
  float sblb ;
  float salb ;
  float blb2 ;
  float alb2 ;
  float temp ;
  float tmp ;
  float tmp___0 ;

  {
#line 596
  blb1 = (float )0.0;
#line 596
  alb1 = (float )0.0;
#line 596
  sblb = (float )0.0;
#line 596
  salb = (float )0.0;
#line 597
  blb2 = (float )0.0;
#line 597
  alb2 = (float )0.0;
#line 600
  i = 0L;
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 600
    if (! (i < ncon)) {
#line 600
      goto while_break;
    }
#line 601
    if (*(pfrom + i) >= *(pto + i)) {
#line 601
      tmp = *(pfrom + i);
    } else {
#line 601
      tmp = *(pto + i);
    }
#line 601
    temp = (tmp * (float )nparts) / *(ubvec + i);
#line 602
    if (blb1 < temp) {
#line 603
      blb2 = blb1;
#line 604
      blb1 = temp;
    } else
#line 606
    if (blb2 < temp) {
#line 607
      blb2 = temp;
    }
#line 608
    sblb += temp;
#line 610
    if (*(pfrom + i) - *(vwgt + i) >= *(pto + i) + *(vwgt + i)) {
#line 610
      tmp___0 = *(pfrom + i) - *(vwgt + i);
    } else {
#line 610
      tmp___0 = *(pto + i) + *(vwgt + i);
    }
#line 610
    temp = (tmp___0 * (float )nparts) / *(ubvec + i);
#line 611
    if (alb1 < temp) {
#line 612
      alb2 = alb1;
#line 613
      alb1 = temp;
    } else
#line 615
    if (alb2 < temp) {
#line 616
      alb2 = temp;
    }
#line 617
    salb += temp;
#line 600
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 620
  if (alb1 < blb1) {
#line 621
    return (1L);
  }
#line 622
  if (blb1 < alb1) {
#line 623
    return (0L);
  }
#line 624
  if (alb2 < blb2) {
#line 625
    return (1L);
  }
#line 626
  if (blb2 < alb2) {
#line 627
    return (0L);
  }
#line 629
  return ((long )(salb < sblb));
}
}
#line 641 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mkwayfmh.c"
long __IsHBalanceBetterTT(long ncon , long nparts , float *pt1 , float *pt2 , float *vwgt ,
                          float *ubvec ) 
{ 
  long i ;
  float m11 ;
  float m12 ;
  float m21 ;
  float m22 ;
  float sm1 ;
  float sm2 ;
  float temp ;

  {
#line 644
  m11 = (float )0.0;
#line 644
  m12 = (float )0.0;
#line 644
  m21 = (float )0.0;
#line 644
  m22 = (float )0.0;
#line 644
  sm1 = (float )0.0;
#line 644
  sm2 = (float )0.0;
#line 646
  i = 0L;
  {
#line 646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 646
    if (! (i < ncon)) {
#line 646
      goto while_break;
    }
#line 647
    temp = ((*(pt1 + i) + *(vwgt + i)) * (float )nparts) / *(ubvec + i);
#line 648
    if (m11 < temp) {
#line 649
      m12 = m11;
#line 650
      m11 = temp;
    } else
#line 652
    if (m12 < temp) {
#line 653
      m12 = temp;
    }
#line 654
    sm1 += temp;
#line 656
    temp = ((*(pt2 + i) + *(vwgt + i)) * (float )nparts) / *(ubvec + i);
#line 657
    if (m21 < temp) {
#line 658
      m22 = m21;
#line 659
      m21 = temp;
    } else
#line 661
    if (m22 < temp) {
#line 662
      m22 = temp;
    }
#line 663
    sm2 += temp;
#line 646
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 666
  if (m21 < m11) {
#line 667
    return (1L);
  }
#line 668
  if (m21 > m11) {
#line 669
    return (0L);
  }
#line 670
  if (m22 < m12) {
#line 671
    return (1L);
  }
#line 672
  if (m22 > m12) {
#line 673
    return (0L);
  }
#line 675
  return ((long )(sm2 < sm1));
}
}
#line 35 "./proto.h"
void __PruneGraph(CtrlType *ctrl , GraphType *graph , long nvtxs , idxtype *xadj ,
                  idxtype *adjncy , idxtype *iperm , float factor ) ;
#line 433
void *__GKmalloc(long nbytes , char *msg ) ;
#line 21 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/compress.c"
void __CompressGraph(CtrlType *ctrl , GraphType *graph , long nvtxs , idxtype *xadj ,
                     idxtype *adjncy , idxtype *cptr , idxtype *cind ) 
{ 
  long i ;
  long ii ;
  long iii ;
  long j ;
  long jj ;
  long k ;
  long l ;
  long cnvtxs ;
  long cnedges ;
  idxtype *cxadj ;
  idxtype *cadjncy ;
  idxtype *cvwgt ;
  idxtype *mark ;
  idxtype *map ;
  KeyValueType *keys ;
  void *tmp ;
  idxtype tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  idxtype *tmp___3 ;
  idxtype *tmp___4 ;
  idxtype *tmp___5 ;
  idxtype tmp___6 ;
  long tmp___7 ;

  {
  {
#line 27
  mark = __idxsmalloc(nvtxs, (idxtype )-1, (char *)"CompressGraph: mark");
#line 28
  map = __idxsmalloc(nvtxs, (idxtype )-1, (char *)"CompressGraph: map");
#line 29
  tmp = __GKmalloc((long )((unsigned long )nvtxs * sizeof(KeyValueType )), (char *)"CompressGraph: keys");
#line 29
  keys = (KeyValueType *)tmp;
#line 32
  i = 0L;
  }
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! (i < nvtxs)) {
#line 32
      goto while_break;
    }
#line 33
    k = 0L;
#line 34
    j = *(xadj + i);
    {
#line 34
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 34
      if (! (j < *(xadj + (i + 1L)))) {
#line 34
        goto while_break___0;
      }
#line 35
      k += *(adjncy + j);
#line 34
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 36
    (keys + i)->key = k + i;
#line 37
    (keys + i)->val = i;
#line 32
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 40
  __ikeysort(nvtxs, keys);
#line 42
  tmp___0 = (idxtype )0;
#line 42
  *(cptr + 0) = tmp___0;
#line 42
  l = tmp___0;
#line 43
  i = 0L;
#line 43
  cnvtxs = i;
  }
  {
#line 43
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 43
    if (! (i < nvtxs)) {
#line 43
      goto while_break___1;
    }
#line 44
    ii = (keys + i)->val;
#line 45
    if (*(map + ii) == -1L) {
#line 46
      *(mark + ii) = i;
#line 47
      j = *(xadj + ii);
      {
#line 47
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 47
        if (! (j < *(xadj + (ii + 1L)))) {
#line 47
          goto while_break___2;
        }
#line 48
        *(mark + *(adjncy + j)) = i;
#line 47
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 50
      tmp___1 = l;
#line 50
      l ++;
#line 50
      *(cind + tmp___1) = ii;
#line 51
      *(map + ii) = cnvtxs;
#line 53
      j = i + 1L;
      {
#line 53
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 53
        if (! (j < nvtxs)) {
#line 53
          goto while_break___3;
        }
#line 54
        iii = (keys + j)->val;
#line 56
        if ((keys + i)->key != (keys + j)->key) {
#line 57
          goto while_break___3;
        } else
#line 56
        if (*(xadj + (ii + 1L)) - *(xadj + ii) != *(xadj + (iii + 1L)) - *(xadj + iii)) {
#line 57
          goto while_break___3;
        }
#line 59
        if (*(map + iii) == -1L) {
#line 60
          jj = *(xadj + iii);
          {
#line 60
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 60
            if (! (jj < *(xadj + (iii + 1L)))) {
#line 60
              goto while_break___4;
            }
#line 61
            if (*(mark + *(adjncy + jj)) != i) {
#line 62
              goto while_break___4;
            }
#line 60
            jj ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 65
          if (jj == *(xadj + (iii + 1L))) {
#line 66
            *(map + iii) = cnvtxs;
#line 67
            tmp___2 = l;
#line 67
            l ++;
#line 67
            *(cind + tmp___2) = iii;
          }
        }
#line 53
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 72
      cnvtxs ++;
#line 72
      *(cptr + cnvtxs) = l;
    }
#line 43
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 79
  __InitGraph(graph);
  }
#line 81
  if ((double )cnvtxs >= 0.85 * (double )nvtxs) {
    {
#line 82
    graph->nvtxs = nvtxs;
#line 83
    graph->nedges = *(xadj + nvtxs);
#line 84
    graph->ncon = 1L;
#line 85
    graph->xadj = xadj;
#line 86
    graph->adjncy = adjncy;
#line 88
    graph->gdata = __idxmalloc(3L * nvtxs + graph->nedges, (char *)"CompressGraph: gdata");
#line 89
    graph->vwgt = graph->gdata;
#line 90
    graph->adjwgtsum = graph->gdata + nvtxs;
#line 91
    graph->cmap = graph->gdata + 2L * nvtxs;
#line 92
    graph->adjwgt = graph->gdata + 3L * nvtxs;
#line 94
    __idxset(nvtxs, (idxtype )1, graph->vwgt);
#line 95
    __idxset(graph->nedges, (idxtype )1, graph->adjwgt);
#line 96
    i = 0L;
    }
    {
#line 96
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 96
      if (! (i < nvtxs)) {
#line 96
        goto while_break___5;
      }
#line 97
      *(graph->adjwgtsum + i) = *(xadj + (i + 1L)) - *(xadj + i);
#line 96
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 99
    graph->label = __idxmalloc(nvtxs, (char *)"CompressGraph: label");
#line 100
    i = 0L;
    }
    {
#line 100
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 100
      if (! (i < nvtxs)) {
#line 100
        goto while_break___6;
      }
#line 101
      *(graph->label + i) = i;
#line 100
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  } else {
#line 104
    cnedges = 0L;
#line 105
    i = 0L;
    {
#line 105
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 105
      if (! (i < cnvtxs)) {
#line 105
        goto while_break___7;
      }
#line 106
      ii = *(cind + *(cptr + i));
#line 107
      cnedges += *(xadj + (ii + 1L)) - *(xadj + ii);
#line 105
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 111
    graph->gdata = __idxmalloc((4L * cnvtxs + 1L) + 2L * cnedges, (char *)"CompressGraph: gdata");
#line 112
    tmp___3 = graph->gdata;
#line 112
    graph->xadj = tmp___3;
#line 112
    cxadj = tmp___3;
#line 113
    tmp___4 = (graph->gdata + cnvtxs) + 1;
#line 113
    graph->vwgt = tmp___4;
#line 113
    cvwgt = tmp___4;
#line 114
    graph->adjwgtsum = (graph->gdata + 2L * cnvtxs) + 1;
#line 115
    graph->cmap = (graph->gdata + 3L * cnvtxs) + 1;
#line 116
    tmp___5 = (graph->gdata + 4L * cnvtxs) + 1;
#line 116
    graph->adjncy = tmp___5;
#line 116
    cadjncy = tmp___5;
#line 117
    graph->adjwgt = ((graph->gdata + 4L * cnvtxs) + 1) + cnedges;
#line 120
    __idxset(nvtxs, (idxtype )-1, mark);
#line 121
    tmp___6 = (idxtype )0;
#line 121
    *(cxadj + 0) = tmp___6;
#line 121
    l = tmp___6;
#line 122
    i = 0L;
    }
    {
#line 122
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 122
      if (! (i < cnvtxs)) {
#line 122
        goto while_break___8;
      }
#line 123
      *(cvwgt + i) = *(cptr + (i + 1L)) - *(cptr + i);
#line 124
      *(mark + i) = i;
#line 125
      j = *(cptr + i);
      {
#line 125
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 125
        if (! (j < *(cptr + (i + 1L)))) {
#line 125
          goto while_break___9;
        }
#line 126
        ii = *(cind + j);
#line 127
        jj = *(xadj + ii);
        {
#line 127
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 127
          if (! (jj < *(xadj + (ii + 1L)))) {
#line 127
            goto while_break___10;
          }
#line 128
          k = *(map + *(adjncy + jj));
#line 129
          if (*(mark + k) != i) {
#line 130
            tmp___7 = l;
#line 130
            l ++;
#line 130
            *(cadjncy + tmp___7) = k;
          }
#line 131
          *(mark + k) = i;
#line 127
          jj ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 125
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 134
      *(cxadj + (i + 1L)) = l;
#line 122
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 137
    graph->nvtxs = cnvtxs;
#line 138
    graph->nedges = l;
#line 139
    graph->ncon = 1L;
#line 141
    __idxset(graph->nedges, (idxtype )1, graph->adjwgt);
#line 142
    i = 0L;
    }
    {
#line 142
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 142
      if (! (i < cnvtxs)) {
#line 142
        goto while_break___11;
      }
#line 143
      *(graph->adjwgtsum + i) = *(cxadj + (i + 1L)) - *(cxadj + i);
#line 142
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 145
    graph->label = __idxmalloc(cnvtxs, (char *)"CompressGraph: label");
#line 146
    i = 0L;
    }
    {
#line 146
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 146
      if (! (i < cnvtxs)) {
#line 146
        goto while_break___12;
      }
#line 147
      *(graph->label + i) = i;
#line 146
      i ++;
    }
    while_break___12: /* CIL Label */ ;
    }
  }
  {
#line 151
  __GKfree(& keys, & map, & mark, (void **)0);
  }
#line 152
  return;
}
}
#line 160 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/compress.c"
void __PruneGraph(CtrlType *ctrl , GraphType *graph , long nvtxs , idxtype *xadj ,
                  idxtype *adjncy , idxtype *iperm , float factor ) 
{ 
  long i ;
  long j ;
  long k ;
  long l ;
  long nlarge ;
  long pnvtxs ;
  long pnedges ;
  idxtype *pxadj ;
  idxtype *padjncy ;
  idxtype *perm ;
  long tmp ;
  idxtype *tmp___0 ;
  idxtype *tmp___1 ;
  long tmp___2 ;

  {
  {
#line 166
  perm = __idxmalloc(nvtxs, (char *)"PruneGraph: perm");
#line 168
  factor = (factor * (float )*(xadj + nvtxs)) / (float )nvtxs;
#line 170
  nlarge = 0L;
#line 170
  pnedges = nlarge;
#line 170
  pnvtxs = pnedges;
#line 171
  i = 0L;
  }
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! (i < nvtxs)) {
#line 171
      goto while_break;
    }
#line 172
    if ((float )(*(xadj + (i + 1L)) - *(xadj + i)) < factor) {
#line 173
      *(perm + i) = pnvtxs;
#line 174
      tmp = pnvtxs;
#line 174
      pnvtxs ++;
#line 174
      *(iperm + tmp) = i;
#line 175
      pnedges += *(xadj + (i + 1L)) - *(xadj + i);
    } else {
#line 178
      nlarge ++;
#line 178
      *(perm + i) = nvtxs - nlarge;
#line 179
      *(iperm + (nvtxs - nlarge)) = i;
    }
#line 171
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  __InitGraph(graph);
  }
#line 187
  if (nlarge == 0L) {
    {
#line 188
    graph->nvtxs = nvtxs;
#line 189
    graph->nedges = *(xadj + nvtxs);
#line 190
    graph->ncon = 1L;
#line 191
    graph->xadj = xadj;
#line 192
    graph->adjncy = adjncy;
#line 194
    graph->gdata = __idxmalloc(3L * nvtxs + graph->nedges, (char *)"CompressGraph: gdata");
#line 195
    graph->vwgt = graph->gdata;
#line 196
    graph->adjwgtsum = graph->gdata + nvtxs;
#line 197
    graph->cmap = graph->gdata + 2L * nvtxs;
#line 198
    graph->adjwgt = graph->gdata + 3L * nvtxs;
#line 200
    __idxset(nvtxs, (idxtype )1, graph->vwgt);
#line 201
    __idxset(graph->nedges, (idxtype )1, graph->adjwgt);
#line 202
    i = 0L;
    }
    {
#line 202
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 202
      if (! (i < nvtxs)) {
#line 202
        goto while_break___0;
      }
#line 203
      *(graph->adjwgtsum + i) = *(xadj + (i + 1L)) - *(xadj + i);
#line 202
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 205
    graph->label = __idxmalloc(nvtxs, (char *)"CompressGraph: label");
#line 206
    i = 0L;
    }
    {
#line 206
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 206
      if (! (i < nvtxs)) {
#line 206
        goto while_break___1;
      }
#line 207
      *(graph->label + i) = i;
#line 206
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 211
    graph->gdata = __idxmalloc((4L * pnvtxs + 1L) + 2L * pnedges, (char *)"PruneGraph: gdata");
#line 212
    tmp___0 = graph->gdata;
#line 212
    graph->xadj = tmp___0;
#line 212
    pxadj = tmp___0;
#line 213
    graph->vwgt = (graph->gdata + pnvtxs) + 1;
#line 214
    graph->adjwgtsum = (graph->gdata + 2L * pnvtxs) + 1;
#line 215
    graph->cmap = (graph->gdata + 3L * pnvtxs) + 1;
#line 216
    tmp___1 = (graph->gdata + 4L * pnvtxs) + 1;
#line 216
    graph->adjncy = tmp___1;
#line 216
    padjncy = tmp___1;
#line 217
    graph->adjwgt = ((graph->gdata + 4L * pnvtxs) + 1) + pnedges;
#line 219
    l = 0L;
#line 219
    pnedges = l;
#line 219
    *(pxadj + 0) = pnedges;
#line 220
    i = 0L;
    }
    {
#line 220
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 220
      if (! (i < nvtxs)) {
#line 220
        goto while_break___2;
      }
#line 221
      if ((float )(*(xadj + (i + 1L)) - *(xadj + i)) < factor) {
#line 222
        j = *(xadj + i);
        {
#line 222
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 222
          if (! (j < *(xadj + (i + 1L)))) {
#line 222
            goto while_break___3;
          }
#line 223
          k = *(perm + *(adjncy + j));
#line 224
          if (k < pnvtxs) {
#line 225
            tmp___2 = pnedges;
#line 225
            pnedges ++;
#line 225
            *(padjncy + tmp___2) = k;
          }
#line 222
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 227
        l ++;
#line 227
        *(pxadj + l) = pnedges;
      }
#line 220
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 231
    graph->nvtxs = pnvtxs;
#line 232
    graph->nedges = pnedges;
#line 233
    graph->ncon = 1L;
#line 235
    __idxset(pnvtxs, (idxtype )1, graph->vwgt);
#line 236
    __idxset(pnedges, (idxtype )1, graph->adjwgt);
#line 237
    i = 0L;
    }
    {
#line 237
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 237
      if (! (i < pnvtxs)) {
#line 237
        goto while_break___4;
      }
#line 238
      *(graph->adjwgtsum + i) = *(pxadj + (i + 1L)) - *(pxadj + i);
#line 237
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 240
    graph->label = __idxmalloc(pnvtxs, (char *)"CompressGraph: label");
#line 241
    i = 0L;
    }
    {
#line 241
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 241
      if (! (i < pnvtxs)) {
#line 241
        goto while_break___5;
      }
#line 242
      *(graph->label + i) = i;
#line 241
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 245
  free((void *)perm);
  }
#line 247
  return;
}
}
#line 58 "./proto.h"
void __Change2FNumberingOrder(long nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *v1 ,
                              idxtype *v2 ) ;
#line 21 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/fortran.c"
void __Change2CNumbering(long nvtxs , idxtype *xadj , idxtype *adjncy ) 
{ 
  long i ;
  long nedges ;

  {
#line 25
  i = 0L;
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! (i <= nvtxs)) {
#line 25
      goto while_break;
    }
#line 26
    (*(xadj + i)) --;
#line 25
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 28
  nedges = *(xadj + nvtxs);
#line 29
  i = 0L;
  {
#line 29
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 29
    if (! (i < nedges)) {
#line 29
      goto while_break___0;
    }
#line 30
    (*(adjncy + i)) --;
#line 29
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 31
  return;
}
}
#line 36 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/fortran.c"
void __Change2FNumbering(long nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vector ) 
{ 
  long i ;
  long nedges ;

  {
#line 40
  i = 0L;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i < nvtxs)) {
#line 40
      goto while_break;
    }
#line 41
    (*(vector + i)) ++;
#line 40
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  nedges = *(xadj + nvtxs);
#line 44
  i = 0L;
  {
#line 44
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 44
    if (! (i < nedges)) {
#line 44
      goto while_break___0;
    }
#line 45
    (*(adjncy + i)) ++;
#line 44
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 47
  i = 0L;
  {
#line 47
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 47
    if (! (i <= nvtxs)) {
#line 47
      goto while_break___1;
    }
#line 48
    (*(xadj + i)) ++;
#line 47
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 49
  return;
}
}
#line 54 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/fortran.c"
void __Change2FNumbering2(long nvtxs , idxtype *xadj , idxtype *adjncy ) 
{ 
  long i ;
  long nedges ;

  {
#line 58
  nedges = *(xadj + nvtxs);
#line 59
  i = 0L;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! (i < nedges)) {
#line 59
      goto while_break;
    }
#line 60
    (*(adjncy + i)) ++;
#line 59
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  i = 0L;
  {
#line 62
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 62
    if (! (i <= nvtxs)) {
#line 62
      goto while_break___0;
    }
#line 63
    (*(xadj + i)) ++;
#line 62
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 64
  return;
}
}
#line 71 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/fortran.c"
void __Change2FNumberingOrder(long nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *v1 ,
                              idxtype *v2 ) 
{ 
  long i ;
  long nedges ;

  {
#line 75
  i = 0L;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i < nvtxs)) {
#line 75
      goto while_break;
    }
#line 76
    (*(v1 + i)) ++;
#line 77
    (*(v2 + i)) ++;
#line 75
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  nedges = *(xadj + nvtxs);
#line 81
  i = 0L;
  {
#line 81
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 81
    if (! (i < nedges)) {
#line 81
      goto while_break___0;
    }
#line 82
    (*(adjncy + i)) ++;
#line 81
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 84
  i = 0L;
  {
#line 84
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 84
    if (! (i <= nvtxs)) {
#line 84
      goto while_break___1;
    }
#line 85
    (*(xadj + i)) ++;
#line 84
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 87
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/fortran.c"
void __ChangeMesh2CNumbering(long n , idxtype *mesh ) 
{ 
  long i ;

  {
#line 98
  i = 0L;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < n)) {
#line 98
      goto while_break;
    }
#line 99
    (*(mesh + i)) --;
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return;
}
}
#line 107 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/fortran.c"
void __ChangeMesh2FNumbering(long n , idxtype *mesh , long nvtxs , idxtype *xadj ,
                             idxtype *adjncy ) 
{ 
  long i ;
  long nedges ;

  {
#line 111
  i = 0L;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < n)) {
#line 111
      goto while_break;
    }
#line 112
    (*(mesh + i)) ++;
#line 111
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  nedges = *(xadj + nvtxs);
#line 115
  i = 0L;
  {
#line 115
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 115
    if (! (i < nedges)) {
#line 115
      goto while_break___0;
    }
#line 116
    (*(adjncy + i)) ++;
#line 115
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  i = 0L;
  {
#line 118
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 118
    if (! (i <= nvtxs)) {
#line 118
      goto while_break___1;
    }
#line 119
    (*(xadj + i)) ++;
#line 118
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 127 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/fortran.c"
void __ChangeMesh2FNumbering2(long n , idxtype *mesh , long ne , long nn , idxtype *epart ,
                              idxtype *npart ) 
{ 
  long i ;

  {
#line 131
  i = 0L;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < n)) {
#line 131
      goto while_break;
    }
#line 132
    (*(mesh + i)) ++;
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  i = 0L;
  {
#line 134
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 134
    if (! (i < ne)) {
#line 134
      goto while_break___0;
    }
#line 135
    (*(epart + i)) ++;
#line 134
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 137
  i = 0L;
  {
#line 137
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 137
    if (! (i < nn)) {
#line 137
      goto while_break___1;
    }
#line 138
    (*(npart + i)) ++;
#line 137
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 140
  return;
}
}
#line 176 "./proto.h"
void __KWayVolUpdate(CtrlType *ctrl , GraphType *graph , long v , long from , long to ,
                     idxtype *marker , idxtype *phtable , idxtype *updind ) ;
#line 177
void __ComputeKWayVolume(GraphType *graph , long nupd , idxtype *updind , idxtype *marker ,
                         idxtype *phtable ) ;
#line 179
void __CheckVolKWayPartitionParams(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 180
void __ComputeVolSubDomainGraph(GraphType *graph , long nparts , idxtype *pmat , idxtype *ndoms ) ;
#line 19 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolfm.c"
void __Random_KWayVolRefine(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ,
                            float ubfactor , long npasses , long ffactor ) 
{ 
  long i ;
  long ii ;
  long iii ;
  long j ;
  long k ;
  long pass ;
  long nvtxs ;
  long nmoves ;
  long tvwgt ;
  long myndegrees ;
  long xgain ;
  long from ;
  long to ;
  long oldcut ;
  long oldvol ;
  long vwgt ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *perm ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *minwgt ;
  idxtype *maxwgt ;
  idxtype *itpwgts ;
  idxtype *updind ;
  idxtype *marker ;
  idxtype *phtable ;
  VEDegreeType *myedegrees ;
  VRInfoType *myrinfo ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  {
#line 29
  nvtxs = graph->nvtxs;
#line 30
  xadj = graph->xadj;
#line 31
  adjncy = graph->adjncy;
#line 32
  adjwgt = graph->adjwgt;
#line 34
  bndptr = graph->bndptr;
#line 35
  bndind = graph->bndind;
#line 37
  where = graph->where;
#line 38
  pwgts = graph->pwgts;
#line 41
  minwgt = __idxwspacemalloc(ctrl, nparts);
#line 42
  maxwgt = __idxwspacemalloc(ctrl, nparts);
#line 43
  itpwgts = __idxwspacemalloc(ctrl, nparts);
#line 44
  tvwgt = __idxsum(nparts, pwgts);
#line 47
  updind = __idxmalloc(nvtxs, (char *)"Random_KWayVolRefine: updind");
#line 48
  marker = __idxsmalloc(nvtxs, (idxtype )0, (char *)"Random_KWayVolRefine: marker");
#line 49
  phtable = __idxsmalloc(nparts, (idxtype )-1, (char *)"Random_KWayVolRefine: phtable");
#line 51
  i = 0L;
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (i < nparts)) {
#line 51
      goto while_break;
    }
#line 52
    *(itpwgts + i) = (idxtype )(*(tpwgts + i) * (float )tvwgt);
#line 53
    *(maxwgt + i) = (idxtype )((*(tpwgts + i) * (float )tvwgt) * ubfactor);
#line 54
    *(minwgt + i) = (idxtype )((double )(*(tpwgts + i) * (float )tvwgt) * (1.0 / (double )ubfactor));
#line 51
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 57
  perm = __idxwspacemalloc(ctrl, nvtxs);
  }
#line 59
  if (ctrl->dbglvl & 8L) {
    {
#line 59
    tmp = __idxamax(nparts, pwgts);
#line 59
    tmp___0 = __idxamax(nparts, pwgts);
#line 59
    tmp___1 = __idxamin(nparts, pwgts);
#line 59
    printf((char const   */* __restrict  */)"VolPart: [%5ld %5ld]-[%5ld %5ld], Balance: %3.2f, Nv-Nb[%5ld %5ld]. Cut: %5ld, Vol: %5ld\n",
           *(pwgts + tmp___1), *(pwgts + tmp___0), *(minwgt + 0), *(maxwgt + 0), ((1.0 * (double )nparts) * (double )*(pwgts + tmp)) / (double )tvwgt,
           graph->nvtxs, graph->nbnd, graph->mincut, graph->minvol);
    }
  }
#line 65
  pass = 0L;
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 65
    if (! (pass < npasses)) {
#line 65
      goto while_break___0;
    }
    {
#line 68
    oldcut = graph->mincut;
#line 69
    oldvol = graph->minvol;
#line 71
    __RandomPermute(graph->nbnd, perm, 1L);
#line 72
    iii = 0L;
#line 72
    nmoves = iii;
    }
    {
#line 72
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 72
      if (! (iii < graph->nbnd)) {
#line 72
        goto while_break___1;
      }
#line 73
      ii = *(perm + iii);
#line 74
      if (ii >= graph->nbnd) {
#line 75
        goto __Cont;
      }
#line 76
      i = *(bndind + ii);
#line 77
      myrinfo = graph->vrinfo + i;
#line 79
      if (myrinfo->gv >= 0L) {
#line 80
        from = *(where + i);
#line 81
        vwgt = *(graph->vwgt + i);
#line 83
        if (myrinfo->id > 0L) {
#line 83
          if (*(pwgts + from) - vwgt < *(minwgt + from)) {
#line 84
            goto __Cont;
          }
        }
#line 86
        if (myrinfo->id == 0L) {
#line 86
          if (myrinfo->ed > 0L) {
#line 86
            xgain = *(graph->vsize + i);
          } else {
#line 86
            xgain = 0L;
          }
        } else {
#line 86
          xgain = 0L;
        }
#line 88
        myedegrees = myrinfo->edegrees;
#line 89
        myndegrees = myrinfo->ndegrees;
#line 91
        k = 0L;
        {
#line 91
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 91
          if (! (k < myndegrees)) {
#line 91
            goto while_break___2;
          }
#line 92
          to = (myedegrees + k)->pid;
#line 93
          if (*(pwgts + to) + vwgt <= *(maxwgt + to) + ffactor * (myedegrees + k)->gv) {
#line 93
            if (xgain + (myedegrees + k)->gv >= 0L) {
#line 94
              goto while_break___2;
            }
          }
#line 91
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 96
        if (k == myndegrees) {
#line 97
          goto __Cont;
        }
#line 99
        j = k + 1L;
        {
#line 99
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 99
          if (! (j < myndegrees)) {
#line 99
            goto while_break___3;
          }
#line 100
          to = (myedegrees + j)->pid;
#line 101
          if (*(pwgts + to) + vwgt > *(maxwgt + to)) {
#line 102
            goto __Cont___0;
          }
#line 103
          if ((myedegrees + j)->gv > (myedegrees + k)->gv) {
#line 107
            k = j;
          } else
#line 103
          if ((myedegrees + j)->gv == (myedegrees + k)->gv) {
#line 103
            if ((myedegrees + j)->ed > (myedegrees + k)->ed) {
#line 107
              k = j;
            } else {
#line 103
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 103
          if ((myedegrees + j)->gv == (myedegrees + k)->gv) {
#line 103
            if ((myedegrees + j)->ed == (myedegrees + k)->ed) {
#line 103
              if (*(itpwgts + (myedegrees + k)->pid) * *(pwgts + to) < *(itpwgts + to) * *(pwgts + (myedegrees + k)->pid)) {
#line 107
                k = j;
              }
            }
          }
          __Cont___0: /* CIL Label */ 
#line 99
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 110
        to = (myedegrees + k)->pid;
#line 112
        j = 0L;
#line 113
        if (xgain + (myedegrees + k)->gv > 0L) {
#line 114
          j = 1L;
        } else
#line 113
        if ((myedegrees + k)->ed - myrinfo->id > 0L) {
#line 114
          j = 1L;
        } else
#line 115
        if ((myedegrees + k)->ed - myrinfo->id == 0L) {
#line 116
          if ((iii & 5L) == 0L) {
#line 117
            j = 1L;
          } else
#line 116
          if (*(pwgts + from) >= *(maxwgt + from)) {
#line 117
            j = 1L;
          } else
#line 116
          if (*(itpwgts + from) * (*(pwgts + to) + vwgt) < *(itpwgts + to) * *(pwgts + from)) {
#line 117
            j = 1L;
          }
        }
#line 119
        if (j == 0L) {
#line 120
          goto __Cont;
        }
        {
#line 125
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 125
          *(pwgts + to) += vwgt;
#line 125
          *(pwgts + from) -= vwgt;
#line 125
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 126
        graph->mincut -= (myedegrees + k)->ed - myrinfo->id;
#line 127
        graph->minvol -= xgain + (myedegrees + k)->gv;
#line 128
        *(where + i) = to;
#line 130
        if (ctrl->dbglvl & 32L) {
          {
#line 130
          printf((char const   */* __restrict  */)"\t\tMoving %6ld from %3ld to %3ld. Gain: [%4ld %4ld]. Cut: %6ld, Vol: %6ld\n",
                 i, from, to, xgain + (myedegrees + k)->gv, (myedegrees + k)->ed - myrinfo->id,
                 graph->mincut, graph->minvol);
          }
        }
        {
#line 133
        __KWayVolUpdate(ctrl, graph, i, from, to, marker, phtable, updind);
#line 135
        nmoves ++;
        }
      }
      __Cont: /* CIL Label */ 
#line 72
      iii ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 141
    if (ctrl->dbglvl & 8L) {
      {
#line 141
      tmp___2 = __idxamax(nparts, pwgts);
#line 141
      tmp___3 = __idxamax(nparts, pwgts);
#line 141
      tmp___4 = __idxamin(nparts, pwgts);
#line 141
      printf((char const   */* __restrict  */)"\t[%6ld %6ld], Balance: %5.3f, Nb: %6ld. Nmoves: %5ld, Cut: %6ld, Vol: %6ld\n",
             *(pwgts + tmp___4), *(pwgts + tmp___3), ((1.0 * (double )nparts) * (double )*(pwgts + tmp___2)) / (double )tvwgt,
             graph->nbnd, nmoves, graph->mincut, graph->minvol);
      }
    }
#line 147
    if (graph->minvol == oldvol) {
#line 147
      if (graph->mincut == oldcut) {
#line 148
        goto while_break___0;
      }
    }
#line 65
    pass ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 151
  __GKfree(& marker, & updind, & phtable, (void **)0);
#line 153
  __idxwspacefree(ctrl, nparts);
#line 154
  __idxwspacefree(ctrl, nparts);
#line 155
  __idxwspacefree(ctrl, nparts);
#line 156
  __idxwspacefree(ctrl, nvtxs);
  }
#line 157
  return;
}
}
#line 163 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolfm.c"
void __Random_KWayVolRefineMConn(CtrlType *ctrl , GraphType *graph , long nparts ,
                                 float *tpwgts , float ubfactor , long npasses , long ffactor ) 
{ 
  long i ;
  long ii ;
  long iii ;
  long j ;
  long k ;
  long l ;
  long pass ;
  long nvtxs ;
  long nmoves ;
  long tvwgt ;
  long myndegrees ;
  long xgain ;
  long from ;
  long me ;
  long to ;
  long oldcut ;
  long oldvol ;
  long vwgt ;
  long nadd ;
  long maxndoms ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *perm ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *minwgt ;
  idxtype *maxwgt ;
  idxtype *itpwgts ;
  idxtype *updind ;
  idxtype *marker ;
  idxtype *phtable ;
  idxtype *pmat ;
  idxtype *pmatptr ;
  idxtype *ndoms ;
  VEDegreeType *myedegrees ;
  VRInfoType *myrinfo ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;

  {
  {
#line 174
  nvtxs = graph->nvtxs;
#line 175
  xadj = graph->xadj;
#line 176
  adjncy = graph->adjncy;
#line 177
  adjwgt = graph->adjwgt;
#line 179
  bndptr = graph->bndptr;
#line 180
  bndind = graph->bndind;
#line 182
  where = graph->where;
#line 183
  pwgts = graph->pwgts;
#line 186
  minwgt = __idxwspacemalloc(ctrl, nparts);
#line 187
  maxwgt = __idxwspacemalloc(ctrl, nparts);
#line 188
  itpwgts = __idxwspacemalloc(ctrl, nparts);
#line 189
  tvwgt = __idxsum(nparts, pwgts);
#line 192
  updind = __idxmalloc(nvtxs, (char *)"Random_KWayVolRefine: updind");
#line 193
  marker = __idxsmalloc(nvtxs, (idxtype )0, (char *)"Random_KWayVolRefine: marker");
#line 194
  phtable = __idxsmalloc(nparts, (idxtype )-1, (char *)"Random_KWayVolRefine: phtable");
#line 196
  pmat = ctrl->wspace.pmat;
#line 197
  ndoms = __idxwspacemalloc(ctrl, nparts);
#line 199
  __ComputeVolSubDomainGraph(graph, nparts, pmat, ndoms);
#line 201
  i = 0L;
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (i < nparts)) {
#line 201
      goto while_break;
    }
#line 202
    *(itpwgts + i) = (idxtype )(*(tpwgts + i) * (float )tvwgt);
#line 203
    *(maxwgt + i) = (idxtype )((*(tpwgts + i) * (float )tvwgt) * ubfactor);
#line 204
    *(minwgt + i) = (idxtype )((double )(*(tpwgts + i) * (float )tvwgt) * (1.0 / (double )ubfactor));
#line 201
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 207
  perm = __idxwspacemalloc(ctrl, nvtxs);
  }
#line 209
  if (ctrl->dbglvl & 8L) {
    {
#line 209
    tmp = __idxamax(nparts, pwgts);
#line 209
    tmp___0 = __idxamax(nparts, pwgts);
#line 209
    tmp___1 = __idxamin(nparts, pwgts);
#line 209
    printf((char const   */* __restrict  */)"VolPart: [%5ld %5ld]-[%5ld %5ld], Balance: %3.2f, Nv-Nb[%5ld %5ld]. Cut: %5ld, Vol: %5ld\n",
           *(pwgts + tmp___1), *(pwgts + tmp___0), *(minwgt + 0), *(maxwgt + 0), ((1.0 * (double )nparts) * (double )*(pwgts + tmp)) / (double )tvwgt,
           graph->nvtxs, graph->nbnd, graph->mincut, graph->minvol);
    }
  }
#line 215
  pass = 0L;
  {
#line 215
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 215
    if (! (pass < npasses)) {
#line 215
      goto while_break___0;
    }
    {
#line 218
    tmp___2 = __idxamax(nparts, ndoms);
#line 218
    maxndoms = *(ndoms + tmp___2);
#line 220
    oldcut = graph->mincut;
#line 221
    oldvol = graph->minvol;
#line 223
    __RandomPermute(graph->nbnd, perm, 1L);
#line 224
    iii = 0L;
#line 224
    nmoves = iii;
    }
    {
#line 224
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 224
      if (! (iii < graph->nbnd)) {
#line 224
        goto while_break___1;
      }
#line 225
      ii = *(perm + iii);
#line 226
      if (ii >= graph->nbnd) {
#line 227
        goto __Cont;
      }
#line 228
      i = *(bndind + ii);
#line 229
      myrinfo = graph->vrinfo + i;
#line 231
      if (myrinfo->gv >= 0L) {
#line 232
        from = *(where + i);
#line 233
        vwgt = *(graph->vwgt + i);
#line 235
        if (myrinfo->id > 0L) {
#line 235
          if (*(pwgts + from) - vwgt < *(minwgt + from)) {
#line 236
            goto __Cont;
          }
        }
#line 238
        if (myrinfo->id == 0L) {
#line 238
          if (myrinfo->ed > 0L) {
#line 238
            xgain = *(graph->vsize + i);
          } else {
#line 238
            xgain = 0L;
          }
        } else {
#line 238
          xgain = 0L;
        }
#line 240
        myedegrees = myrinfo->edegrees;
#line 241
        myndegrees = myrinfo->ndegrees;
#line 244
        j = 0L;
        {
#line 244
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 244
          if (! (j < myndegrees)) {
#line 244
            goto while_break___2;
          }
#line 245
          to = (myedegrees + j)->pid;
#line 246
          *(phtable + to) = (idxtype )1;
#line 247
          pmatptr = pmat + to * nparts;
#line 248
          nadd = 0L;
#line 248
          k = 0L;
          {
#line 248
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 248
            if (! (k < myndegrees)) {
#line 248
              goto while_break___3;
            }
#line 249
            if (k == j) {
#line 250
              goto __Cont___0;
            }
#line 252
            l = (myedegrees + k)->pid;
#line 253
            if (*(pmatptr + l) == 0L) {
#line 254
              if (*(ndoms + l) > maxndoms - 1L) {
#line 255
                *(phtable + to) = (idxtype )0;
#line 256
                nadd = maxndoms;
#line 257
                goto while_break___3;
              }
#line 259
              nadd ++;
            }
            __Cont___0: /* CIL Label */ 
#line 248
            k ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 262
          if (*(ndoms + to) + nadd > maxndoms) {
#line 263
            *(phtable + to) = (idxtype )0;
          }
#line 264
          if (nadd == 0L) {
#line 265
            *(phtable + to) = (idxtype )2;
          }
#line 244
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 268
        k = 0L;
        {
#line 268
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 268
          if (! (k < myndegrees)) {
#line 268
            goto while_break___4;
          }
#line 269
          to = (myedegrees + k)->pid;
#line 270
          if (! *(phtable + to)) {
#line 271
            goto __Cont___1;
          }
#line 272
          if (*(pwgts + to) + vwgt <= *(maxwgt + to) + ffactor * (myedegrees + k)->gv) {
#line 272
            if (xgain + (myedegrees + k)->gv >= 0L) {
#line 273
              goto while_break___4;
            }
          }
          __Cont___1: /* CIL Label */ 
#line 268
          k ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 275
        if (k == myndegrees) {
#line 276
          goto __Cont;
        }
#line 278
        j = k + 1L;
        {
#line 278
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 278
          if (! (j < myndegrees)) {
#line 278
            goto while_break___5;
          }
#line 279
          to = (myedegrees + j)->pid;
#line 280
          if (! *(phtable + to)) {
#line 281
            goto __Cont___2;
          } else
#line 280
          if (*(pwgts + to) + vwgt > *(maxwgt + to)) {
#line 281
            goto __Cont___2;
          }
#line 282
          if ((myedegrees + j)->gv > (myedegrees + k)->gv) {
#line 286
            k = j;
          } else
#line 282
          if ((myedegrees + j)->gv == (myedegrees + k)->gv) {
#line 282
            if ((myedegrees + j)->ed > (myedegrees + k)->ed) {
#line 286
              k = j;
            } else {
#line 282
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 282
          if ((myedegrees + j)->gv == (myedegrees + k)->gv) {
#line 282
            if ((myedegrees + j)->ed == (myedegrees + k)->ed) {
#line 282
              if (*(itpwgts + (myedegrees + k)->pid) * *(pwgts + to) < *(itpwgts + to) * *(pwgts + (myedegrees + k)->pid)) {
#line 286
                k = j;
              }
            }
          }
          __Cont___2: /* CIL Label */ 
#line 278
          j ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 289
        to = (myedegrees + k)->pid;
#line 291
        j = 0L;
#line 292
        if (xgain + (myedegrees + k)->gv > 0L) {
#line 293
          j = 1L;
        } else
#line 292
        if ((myedegrees + k)->ed - myrinfo->id > 0L) {
#line 293
          j = 1L;
        } else
#line 294
        if ((myedegrees + k)->ed - myrinfo->id == 0L) {
#line 295
          if ((iii & 5L) == 0L) {
#line 296
            j = 1L;
          } else
#line 295
          if (*(phtable + (myedegrees + k)->pid) == 2L) {
#line 296
            j = 1L;
          } else
#line 295
          if (*(pwgts + from) >= *(maxwgt + from)) {
#line 296
            j = 1L;
          } else
#line 295
          if (*(itpwgts + from) * (*(pwgts + to) + vwgt) < *(itpwgts + to) * *(pwgts + from)) {
#line 296
            j = 1L;
          }
        }
#line 299
        if (j == 0L) {
#line 300
          goto __Cont;
        }
#line 302
        j = 0L;
        {
#line 302
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 302
          if (! (j < myndegrees)) {
#line 302
            goto while_break___6;
          }
#line 303
          *(phtable + (myedegrees + j)->pid) = (idxtype )-1;
#line 302
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 309
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 309
          *(pwgts + to) += vwgt;
#line 309
          *(pwgts + from) -= vwgt;
#line 309
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 310
        graph->mincut -= (myedegrees + k)->ed - myrinfo->id;
#line 311
        graph->minvol -= xgain + (myedegrees + k)->gv;
#line 312
        *(where + i) = to;
#line 314
        if (ctrl->dbglvl & 32L) {
          {
#line 314
          printf((char const   */* __restrict  */)"\t\tMoving %6ld from %3ld to %3ld. Gain: [%4ld %4ld]. Cut: %6ld, Vol: %6ld\n",
                 i, from, to, xgain + (myedegrees + k)->gv, (myedegrees + k)->ed - myrinfo->id,
                 graph->mincut, graph->minvol);
          }
        }
#line 318
        *(pmat + (from * nparts + to)) += myrinfo->id - (myedegrees + k)->ed;
#line 319
        *(pmat + (to * nparts + from)) += myrinfo->id - (myedegrees + k)->ed;
#line 320
        if (*(pmat + (from * nparts + to)) == 0L) {
#line 321
          (*(ndoms + from)) --;
#line 322
          if (*(ndoms + from) + 1L == maxndoms) {
            {
#line 323
            tmp___3 = __idxamax(nparts, ndoms);
#line 323
            maxndoms = *(ndoms + tmp___3);
            }
          }
        }
#line 325
        if (*(pmat + (to * nparts + from)) == 0L) {
#line 326
          (*(ndoms + to)) --;
#line 327
          if (*(ndoms + to) + 1L == maxndoms) {
            {
#line 328
            tmp___4 = __idxamax(nparts, ndoms);
#line 328
            maxndoms = *(ndoms + tmp___4);
            }
          }
        }
#line 331
        j = *(xadj + i);
        {
#line 331
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 331
          if (! (j < *(xadj + (i + 1L)))) {
#line 331
            goto while_break___8;
          }
#line 332
          ii = *(adjncy + j);
#line 333
          me = *(where + ii);
#line 336
          if (me != from) {
#line 336
            if (me != to) {
#line 337
              *(pmat + (me * nparts + from)) -= *(adjwgt + j);
#line 338
              *(pmat + (from * nparts + me)) -= *(adjwgt + j);
#line 339
              if (*(pmat + (me * nparts + from)) == 0L) {
#line 340
                (*(ndoms + me)) --;
#line 341
                if (*(ndoms + me) + 1L == maxndoms) {
                  {
#line 342
                  tmp___5 = __idxamax(nparts, ndoms);
#line 342
                  maxndoms = *(ndoms + tmp___5);
                  }
                }
              }
#line 344
              if (*(pmat + (from * nparts + me)) == 0L) {
#line 345
                (*(ndoms + from)) --;
#line 346
                if (*(ndoms + from) + 1L == maxndoms) {
                  {
#line 347
                  tmp___6 = __idxamax(nparts, ndoms);
#line 347
                  maxndoms = *(ndoms + tmp___6);
                  }
                }
              }
#line 350
              if (*(pmat + (me * nparts + to)) == 0L) {
#line 351
                (*(ndoms + me)) ++;
#line 352
                if (*(ndoms + me) > maxndoms) {
                  {
#line 353
                  printf((char const   */* __restrict  */)"You just increased the maxndoms: %ld %ld\n",
                         *(ndoms + me), maxndoms);
#line 354
                  maxndoms = *(ndoms + me);
                  }
                }
              }
#line 357
              if (*(pmat + (to * nparts + me)) == 0L) {
#line 358
                (*(ndoms + to)) ++;
#line 359
                if (*(ndoms + to) > maxndoms) {
                  {
#line 360
                  printf((char const   */* __restrict  */)"You just increased the maxndoms: %ld %ld\n",
                         *(ndoms + to), maxndoms);
#line 361
                  maxndoms = *(ndoms + to);
                  }
                }
              }
#line 364
              *(pmat + (me * nparts + to)) += *(adjwgt + j);
#line 365
              *(pmat + (to * nparts + me)) += *(adjwgt + j);
            }
          }
#line 331
          j ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 369
        __KWayVolUpdate(ctrl, graph, i, from, to, marker, phtable, updind);
#line 371
        nmoves ++;
        }
      }
      __Cont: /* CIL Label */ 
#line 224
      iii ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 377
    if (ctrl->dbglvl & 8L) {
      {
#line 377
      tmp___7 = __idxamax(nparts, pwgts);
#line 377
      tmp___8 = __idxamax(nparts, pwgts);
#line 377
      tmp___9 = __idxamin(nparts, pwgts);
#line 377
      printf((char const   */* __restrict  */)"\t[%6ld %6ld], Balance: %5.3f, Nb: %6ld. Nmoves: %5ld, Cut: %6ld, Vol: %6ld\n",
             *(pwgts + tmp___9), *(pwgts + tmp___8), ((1.0 * (double )nparts) * (double )*(pwgts + tmp___7)) / (double )tvwgt,
             graph->nbnd, nmoves, graph->mincut, graph->minvol);
      }
    }
#line 383
    if (graph->minvol == oldvol) {
#line 383
      if (graph->mincut == oldcut) {
#line 384
        goto while_break___0;
      }
    }
#line 215
    pass ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 387
  __GKfree(& marker, & updind, & phtable, (void **)0);
#line 389
  __idxwspacefree(ctrl, nparts);
#line 390
  __idxwspacefree(ctrl, nparts);
#line 391
  __idxwspacefree(ctrl, nparts);
#line 392
  __idxwspacefree(ctrl, nparts);
#line 393
  __idxwspacefree(ctrl, nvtxs);
  }
#line 394
  return;
}
}
#line 402 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolfm.c"
void __Greedy_KWayVolBalance(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ,
                             float ubfactor , long npasses ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long pass ;
  long nvtxs ;
  long nmoves ;
  long tvwgt ;
  long myndegrees ;
  long xgain ;
  long from ;
  long to ;
  long vwgt ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *perm ;
  idxtype *moved ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *minwgt ;
  idxtype *maxwgt ;
  idxtype *itpwgts ;
  idxtype *updind ;
  idxtype *marker ;
  idxtype *phtable ;
  VEDegreeType *myedegrees ;
  VRInfoType *myrinfo ;
  PQueueType queue ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
  {
#line 413
  nvtxs = graph->nvtxs;
#line 414
  xadj = graph->xadj;
#line 415
  adjncy = graph->adjncy;
#line 416
  adjwgt = graph->adjwgt;
#line 418
  bndptr = graph->bndptr;
#line 419
  bndind = graph->bndind;
#line 421
  where = graph->where;
#line 422
  pwgts = graph->pwgts;
#line 425
  minwgt = __idxwspacemalloc(ctrl, nparts);
#line 426
  maxwgt = __idxwspacemalloc(ctrl, nparts);
#line 427
  itpwgts = __idxwspacemalloc(ctrl, nparts);
#line 428
  tvwgt = __idxsum(nparts, pwgts);
#line 431
  updind = __idxmalloc(nvtxs, (char *)"Random_KWayVolRefine: updind");
#line 432
  marker = __idxsmalloc(nvtxs, (idxtype )0, (char *)"Random_KWayVolRefine: marker");
#line 433
  phtable = __idxsmalloc(nparts, (idxtype )-1, (char *)"Random_KWayVolRefine: phtable");
#line 435
  i = 0L;
  }
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 435
    if (! (i < nparts)) {
#line 435
      goto while_break;
    }
#line 436
    *(itpwgts + i) = (idxtype )(*(tpwgts + i) * (float )tvwgt);
#line 437
    *(maxwgt + i) = (idxtype )((*(tpwgts + i) * (float )tvwgt) * ubfactor);
#line 438
    *(minwgt + i) = (idxtype )((double )(*(tpwgts + i) * (float )tvwgt) * (1.0 / (double )ubfactor));
#line 435
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 441
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 442
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 444
  tmp = __idxamax(nvtxs, graph->adjwgtsum);
#line 444
  __PQueueInit(ctrl, & queue, nvtxs, *(graph->adjwgtsum + tmp));
  }
#line 446
  if (ctrl->dbglvl & 8L) {
    {
#line 446
    tmp___0 = __idxamax(nparts, pwgts);
#line 446
    tmp___1 = __idxamax(nparts, pwgts);
#line 446
    tmp___2 = __idxamin(nparts, pwgts);
#line 446
    printf((char const   */* __restrict  */)"VolPart: [%5ld %5ld]-[%5ld %5ld], Balance: %3.2f, Nv-Nb[%5ld %5ld]. Cut: %5ld, Vol: %5ld [B]\n",
           *(pwgts + tmp___2), *(pwgts + tmp___1), *(minwgt + 0), *(maxwgt + 0), ((1.0 * (double )nparts) * (double )*(pwgts + tmp___0)) / (double )tvwgt,
           graph->nvtxs, graph->nbnd, graph->mincut, graph->minvol);
    }
  }
#line 453
  pass = 0L;
  {
#line 453
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 453
    if (! (pass < npasses)) {
#line 453
      goto while_break___0;
    }
#line 456
    i = 0L;
    {
#line 456
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 456
      if (! (i < nparts)) {
#line 456
        goto while_break___1;
      }
#line 457
      if (*(pwgts + i) > *(maxwgt + i)) {
#line 458
        goto while_break___1;
      }
#line 456
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 460
    if (i == nparts) {
#line 461
      goto while_break___0;
    }
    {
#line 463
    __PQueueReset(& queue);
#line 464
    __idxset(nvtxs, (idxtype )-1, moved);
#line 466
    __RandomPermute(graph->nbnd, perm, 1L);
#line 467
    ii = 0L;
    }
    {
#line 467
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 467
      if (! (ii < graph->nbnd)) {
#line 467
        goto while_break___2;
      }
      {
#line 468
      i = *(bndind + *(perm + ii));
#line 469
      __PQueueInsert(& queue, i, (graph->vrinfo + i)->gv);
#line 470
      *(moved + i) = (idxtype )2;
#line 467
      ii ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 473
    nmoves = 0L;
    {
#line 473
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 474
      i = __PQueueGetMax(& queue);
      }
#line 474
      if (i == -1L) {
#line 475
        goto while_break___3;
      }
#line 476
      *(moved + i) = (idxtype )1;
#line 478
      myrinfo = graph->vrinfo + i;
#line 479
      from = *(where + i);
#line 480
      vwgt = *(graph->vwgt + i);
#line 482
      if (*(pwgts + from) - vwgt < *(minwgt + from)) {
#line 483
        goto __Cont;
      }
#line 485
      if (myrinfo->id == 0L) {
#line 485
        if (myrinfo->ed > 0L) {
#line 485
          xgain = *(graph->vsize + i);
        } else {
#line 485
          xgain = 0L;
        }
      } else {
#line 485
        xgain = 0L;
      }
#line 487
      myedegrees = myrinfo->edegrees;
#line 488
      myndegrees = myrinfo->ndegrees;
#line 490
      k = 0L;
      {
#line 490
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 490
        if (! (k < myndegrees)) {
#line 490
          goto while_break___4;
        }
#line 491
        to = (myedegrees + k)->pid;
#line 492
        if (*(pwgts + to) + vwgt <= *(maxwgt + to)) {
#line 494
          goto while_break___4;
        } else
#line 492
        if (*(itpwgts + from) * (*(pwgts + to) + vwgt) <= *(itpwgts + to) * *(pwgts + from)) {
#line 494
          goto while_break___4;
        }
#line 490
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 496
      if (k == myndegrees) {
#line 497
        goto __Cont;
      }
#line 499
      j = k + 1L;
      {
#line 499
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 499
        if (! (j < myndegrees)) {
#line 499
          goto while_break___5;
        }
#line 500
        to = (myedegrees + j)->pid;
#line 501
        if (*(itpwgts + (myedegrees + k)->pid) * *(pwgts + to) < *(itpwgts + to) * *(pwgts + (myedegrees + k)->pid)) {
#line 502
          k = j;
        }
#line 499
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 505
      to = (myedegrees + k)->pid;
#line 507
      if (*(pwgts + from) < *(maxwgt + from)) {
#line 507
        if (*(pwgts + to) > *(minwgt + to)) {
#line 507
          if (xgain + (myedegrees + k)->gv < 0L) {
#line 511
            goto __Cont;
          } else
#line 507
          if (xgain + (myedegrees + k)->gv == 0L) {
#line 507
            if ((myedegrees + k)->ed - myrinfo->id < 0L) {
#line 511
              goto __Cont;
            }
          }
        }
      }
      {
#line 517
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 517
        *(pwgts + to) += vwgt;
#line 517
        *(pwgts + from) -= vwgt;
#line 517
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 518
      graph->mincut -= (myedegrees + k)->ed - myrinfo->id;
#line 519
      graph->minvol -= xgain + (myedegrees + k)->gv;
#line 520
      *(where + i) = to;
#line 522
      if (ctrl->dbglvl & 32L) {
        {
#line 522
        printf((char const   */* __restrict  */)"\t\tMoving %6ld from %3ld to %3ld. Gain: [%4ld %4ld]. Cut: %6ld, Vol: %6ld\n",
               i, from, to, xgain + (myedegrees + k)->gv, (myedegrees + k)->ed - myrinfo->id,
               graph->mincut, graph->minvol);
        }
      }
      {
#line 525
      __KWayVolUpdate(ctrl, graph, i, from, to, marker, phtable, updind);
#line 527
      nmoves ++;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 532
    if (ctrl->dbglvl & 8L) {
      {
#line 532
      tmp___3 = __idxamax(nparts, pwgts);
#line 532
      tmp___4 = __idxamax(nparts, pwgts);
#line 532
      tmp___5 = __idxamin(nparts, pwgts);
#line 532
      printf((char const   */* __restrict  */)"\t[%6ld %6ld], Balance: %5.3f, Nb: %6ld. Nmoves: %5ld, Cut: %6ld, Vol: %6ld\n",
             *(pwgts + tmp___5), *(pwgts + tmp___4), ((1.0 * (double )nparts) * (double )*(pwgts + tmp___3)) / (double )tvwgt,
             graph->nbnd, nmoves, graph->mincut, graph->minvol);
      }
    }
#line 453
    pass ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 540
  __GKfree(& marker, & updind, & phtable, (void **)0);
#line 542
  __PQueueFree(ctrl, & queue);
#line 544
  __idxwspacefree(ctrl, nparts);
#line 545
  __idxwspacefree(ctrl, nparts);
#line 546
  __idxwspacefree(ctrl, nparts);
#line 547
  __idxwspacefree(ctrl, nvtxs);
#line 548
  __idxwspacefree(ctrl, nvtxs);
  }
#line 549
  return;
}
}
#line 556 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolfm.c"
void __Greedy_KWayVolBalanceMConn(CtrlType *ctrl , GraphType *graph , long nparts ,
                                  float *tpwgts , float ubfactor , long npasses ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long l ;
  long pass ;
  long nvtxs ;
  long nmoves ;
  long tvwgt ;
  long myndegrees ;
  long xgain ;
  long from ;
  long me ;
  long to ;
  long vwgt ;
  long maxndoms ;
  long nadd ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *perm ;
  idxtype *moved ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *minwgt ;
  idxtype *maxwgt ;
  idxtype *itpwgts ;
  idxtype *updind ;
  idxtype *marker ;
  idxtype *phtable ;
  idxtype *pmat ;
  idxtype *pmatptr ;
  idxtype *ndoms ;
  VEDegreeType *myedegrees ;
  VRInfoType *myrinfo ;
  PQueueType queue ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  {
#line 568
  nvtxs = graph->nvtxs;
#line 569
  xadj = graph->xadj;
#line 570
  adjncy = graph->adjncy;
#line 571
  adjwgt = graph->adjwgt;
#line 573
  bndptr = graph->bndptr;
#line 574
  bndind = graph->bndind;
#line 576
  where = graph->where;
#line 577
  pwgts = graph->pwgts;
#line 580
  minwgt = __idxwspacemalloc(ctrl, nparts);
#line 581
  maxwgt = __idxwspacemalloc(ctrl, nparts);
#line 582
  itpwgts = __idxwspacemalloc(ctrl, nparts);
#line 583
  tvwgt = __idxsum(nparts, pwgts);
#line 586
  updind = __idxmalloc(nvtxs, (char *)"Random_KWayVolRefine: updind");
#line 587
  marker = __idxsmalloc(nvtxs, (idxtype )0, (char *)"Random_KWayVolRefine: marker");
#line 588
  phtable = __idxsmalloc(nparts, (idxtype )-1, (char *)"Random_KWayVolRefine: phtable");
#line 590
  pmat = ctrl->wspace.pmat;
#line 591
  ndoms = __idxwspacemalloc(ctrl, nparts);
#line 593
  __ComputeVolSubDomainGraph(graph, nparts, pmat, ndoms);
#line 595
  i = 0L;
  }
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 595
    if (! (i < nparts)) {
#line 595
      goto while_break;
    }
#line 596
    *(itpwgts + i) = (idxtype )(*(tpwgts + i) * (float )tvwgt);
#line 597
    *(maxwgt + i) = (idxtype )((*(tpwgts + i) * (float )tvwgt) * ubfactor);
#line 598
    *(minwgt + i) = (idxtype )((double )(*(tpwgts + i) * (float )tvwgt) * (1.0 / (double )ubfactor));
#line 595
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 601
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 602
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 604
  tmp = __idxamax(nvtxs, graph->adjwgtsum);
#line 604
  __PQueueInit(ctrl, & queue, nvtxs, *(graph->adjwgtsum + tmp));
  }
#line 606
  if (ctrl->dbglvl & 8L) {
    {
#line 606
    tmp___0 = __idxamax(nparts, pwgts);
#line 606
    tmp___1 = __idxamax(nparts, pwgts);
#line 606
    tmp___2 = __idxamin(nparts, pwgts);
#line 606
    printf((char const   */* __restrict  */)"VolPart: [%5ld %5ld]-[%5ld %5ld], Balance: %3.2f, Nv-Nb[%5ld %5ld]. Cut: %5ld, Vol: %5ld [B]\n",
           *(pwgts + tmp___2), *(pwgts + tmp___1), *(minwgt + 0), *(maxwgt + 0), ((1.0 * (double )nparts) * (double )*(pwgts + tmp___0)) / (double )tvwgt,
           graph->nvtxs, graph->nbnd, graph->mincut, graph->minvol);
    }
  }
#line 613
  pass = 0L;
  {
#line 613
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 613
    if (! (pass < npasses)) {
#line 613
      goto while_break___0;
    }
#line 616
    i = 0L;
    {
#line 616
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 616
      if (! (i < nparts)) {
#line 616
        goto while_break___1;
      }
#line 617
      if (*(pwgts + i) > *(maxwgt + i)) {
#line 618
        goto while_break___1;
      }
#line 616
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 620
    if (i == nparts) {
#line 621
      goto while_break___0;
    }
    {
#line 623
    __PQueueReset(& queue);
#line 624
    __idxset(nvtxs, (idxtype )-1, moved);
#line 626
    __RandomPermute(graph->nbnd, perm, 1L);
#line 627
    ii = 0L;
    }
    {
#line 627
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 627
      if (! (ii < graph->nbnd)) {
#line 627
        goto while_break___2;
      }
      {
#line 628
      i = *(bndind + *(perm + ii));
#line 629
      __PQueueInsert(& queue, i, (graph->vrinfo + i)->gv);
#line 630
      *(moved + i) = (idxtype )2;
#line 627
      ii ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 633
    tmp___3 = __idxamax(nparts, ndoms);
#line 633
    maxndoms = *(ndoms + tmp___3);
#line 635
    nmoves = 0L;
    }
    {
#line 635
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 636
      i = __PQueueGetMax(& queue);
      }
#line 636
      if (i == -1L) {
#line 637
        goto while_break___3;
      }
#line 638
      *(moved + i) = (idxtype )1;
#line 640
      myrinfo = graph->vrinfo + i;
#line 641
      from = *(where + i);
#line 642
      vwgt = *(graph->vwgt + i);
#line 644
      if (*(pwgts + from) - vwgt < *(minwgt + from)) {
#line 645
        goto __Cont;
      }
#line 647
      if (myrinfo->id == 0L) {
#line 647
        if (myrinfo->ed > 0L) {
#line 647
          xgain = *(graph->vsize + i);
        } else {
#line 647
          xgain = 0L;
        }
      } else {
#line 647
        xgain = 0L;
      }
#line 649
      myedegrees = myrinfo->edegrees;
#line 650
      myndegrees = myrinfo->ndegrees;
#line 653
      j = 0L;
      {
#line 653
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 653
        if (! (j < myndegrees)) {
#line 653
          goto while_break___4;
        }
#line 654
        to = (myedegrees + j)->pid;
#line 655
        *(phtable + to) = (idxtype )1;
#line 656
        pmatptr = pmat + to * nparts;
#line 657
        nadd = 0L;
#line 657
        k = 0L;
        {
#line 657
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 657
          if (! (k < myndegrees)) {
#line 657
            goto while_break___5;
          }
#line 658
          if (k == j) {
#line 659
            goto __Cont___0;
          }
#line 661
          l = (myedegrees + k)->pid;
#line 662
          if (*(pmatptr + l) == 0L) {
#line 663
            if (*(ndoms + l) > maxndoms - 1L) {
#line 664
              *(phtable + to) = (idxtype )0;
#line 665
              nadd = maxndoms;
#line 666
              goto while_break___5;
            }
#line 668
            nadd ++;
          }
          __Cont___0: /* CIL Label */ 
#line 657
          k ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 671
        if (*(ndoms + to) + nadd > maxndoms) {
#line 672
          *(phtable + to) = (idxtype )0;
        }
#line 653
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 675
      k = 0L;
      {
#line 675
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 675
        if (! (k < myndegrees)) {
#line 675
          goto while_break___6;
        }
#line 676
        to = (myedegrees + k)->pid;
#line 677
        if (! *(phtable + to)) {
#line 678
          goto __Cont___1;
        }
#line 679
        if (*(pwgts + to) + vwgt <= *(maxwgt + to)) {
#line 681
          goto while_break___6;
        } else
#line 679
        if (*(itpwgts + from) * (*(pwgts + to) + vwgt) <= *(itpwgts + to) * *(pwgts + from)) {
#line 681
          goto while_break___6;
        }
        __Cont___1: /* CIL Label */ 
#line 675
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 683
      if (k == myndegrees) {
#line 684
        goto __Cont;
      }
#line 686
      j = k + 1L;
      {
#line 686
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 686
        if (! (j < myndegrees)) {
#line 686
          goto while_break___7;
        }
#line 687
        to = (myedegrees + j)->pid;
#line 688
        if (! *(phtable + to)) {
#line 689
          goto __Cont___2;
        }
#line 690
        if (*(itpwgts + (myedegrees + k)->pid) * *(pwgts + to) < *(itpwgts + to) * *(pwgts + (myedegrees + k)->pid)) {
#line 691
          k = j;
        }
        __Cont___2: /* CIL Label */ 
#line 686
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 694
      to = (myedegrees + k)->pid;
#line 696
      j = 0L;
      {
#line 696
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 696
        if (! (j < myndegrees)) {
#line 696
          goto while_break___8;
        }
#line 697
        *(phtable + (myedegrees + j)->pid) = (idxtype )-1;
#line 696
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 699
      if (*(pwgts + from) < *(maxwgt + from)) {
#line 699
        if (*(pwgts + to) > *(minwgt + to)) {
#line 699
          if (xgain + (myedegrees + k)->gv < 0L) {
#line 703
            goto __Cont;
          } else
#line 699
          if (xgain + (myedegrees + k)->gv == 0L) {
#line 699
            if ((myedegrees + k)->ed - myrinfo->id < 0L) {
#line 703
              goto __Cont;
            }
          }
        }
      }
      {
#line 709
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 709
        *(pwgts + to) += vwgt;
#line 709
        *(pwgts + from) -= vwgt;
#line 709
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 710
      graph->mincut -= (myedegrees + k)->ed - myrinfo->id;
#line 711
      graph->minvol -= xgain + (myedegrees + k)->gv;
#line 712
      *(where + i) = to;
#line 714
      if (ctrl->dbglvl & 32L) {
        {
#line 714
        printf((char const   */* __restrict  */)"\t\tMoving %6ld from %3ld to %3ld. Gain: [%4ld %4ld]. Cut: %6ld, Vol: %6ld\n",
               i, from, to, xgain + (myedegrees + k)->gv, (myedegrees + k)->ed - myrinfo->id,
               graph->mincut, graph->minvol);
        }
      }
#line 718
      *(pmat + (from * nparts + to)) += myrinfo->id - (myedegrees + k)->ed;
#line 719
      *(pmat + (to * nparts + from)) += myrinfo->id - (myedegrees + k)->ed;
#line 720
      if (*(pmat + (from * nparts + to)) == 0L) {
#line 721
        (*(ndoms + from)) --;
#line 722
        if (*(ndoms + from) + 1L == maxndoms) {
          {
#line 723
          tmp___4 = __idxamax(nparts, ndoms);
#line 723
          maxndoms = *(ndoms + tmp___4);
          }
        }
      }
#line 725
      if (*(pmat + (to * nparts + from)) == 0L) {
#line 726
        (*(ndoms + to)) --;
#line 727
        if (*(ndoms + to) + 1L == maxndoms) {
          {
#line 728
          tmp___5 = __idxamax(nparts, ndoms);
#line 728
          maxndoms = *(ndoms + tmp___5);
          }
        }
      }
#line 731
      j = *(xadj + i);
      {
#line 731
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 731
        if (! (j < *(xadj + (i + 1L)))) {
#line 731
          goto while_break___10;
        }
#line 732
        ii = *(adjncy + j);
#line 733
        me = *(where + ii);
#line 736
        if (me != from) {
#line 736
          if (me != to) {
#line 737
            *(pmat + (me * nparts + from)) -= *(adjwgt + j);
#line 738
            *(pmat + (from * nparts + me)) -= *(adjwgt + j);
#line 739
            if (*(pmat + (me * nparts + from)) == 0L) {
#line 740
              (*(ndoms + me)) --;
#line 741
              if (*(ndoms + me) + 1L == maxndoms) {
                {
#line 742
                tmp___6 = __idxamax(nparts, ndoms);
#line 742
                maxndoms = *(ndoms + tmp___6);
                }
              }
            }
#line 744
            if (*(pmat + (from * nparts + me)) == 0L) {
#line 745
              (*(ndoms + from)) --;
#line 746
              if (*(ndoms + from) + 1L == maxndoms) {
                {
#line 747
                tmp___7 = __idxamax(nparts, ndoms);
#line 747
                maxndoms = *(ndoms + tmp___7);
                }
              }
            }
#line 750
            if (*(pmat + (me * nparts + to)) == 0L) {
#line 751
              (*(ndoms + me)) ++;
#line 752
              if (*(ndoms + me) > maxndoms) {
                {
#line 753
                printf((char const   */* __restrict  */)"You just increased the maxndoms: %ld %ld\n",
                       *(ndoms + me), maxndoms);
#line 754
                maxndoms = *(ndoms + me);
                }
              }
            }
#line 757
            if (*(pmat + (to * nparts + me)) == 0L) {
#line 758
              (*(ndoms + to)) ++;
#line 759
              if (*(ndoms + to) > maxndoms) {
                {
#line 760
                printf((char const   */* __restrict  */)"You just increased the maxndoms: %ld %ld\n",
                       *(ndoms + to), maxndoms);
#line 761
                maxndoms = *(ndoms + to);
                }
              }
            }
#line 764
            *(pmat + (me * nparts + to)) += *(adjwgt + j);
#line 765
            *(pmat + (to * nparts + me)) += *(adjwgt + j);
          }
        }
#line 731
        j ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 769
      __KWayVolUpdate(ctrl, graph, i, from, to, marker, phtable, updind);
#line 771
      nmoves ++;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 776
    if (ctrl->dbglvl & 8L) {
      {
#line 776
      tmp___8 = __idxamax(nparts, pwgts);
#line 776
      tmp___9 = __idxamax(nparts, pwgts);
#line 776
      tmp___10 = __idxamin(nparts, pwgts);
#line 776
      printf((char const   */* __restrict  */)"\t[%6ld %6ld], Balance: %5.3f, Nb: %6ld. Nmoves: %5ld, Cut: %6ld, Vol: %6ld\n",
             *(pwgts + tmp___10), *(pwgts + tmp___9), ((1.0 * (double )nparts) * (double )*(pwgts + tmp___8)) / (double )tvwgt,
             graph->nbnd, nmoves, graph->mincut, graph->minvol);
      }
    }
#line 613
    pass ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 784
  __GKfree(& marker, & updind, & phtable, (void **)0);
#line 786
  __PQueueFree(ctrl, & queue);
#line 788
  __idxwspacefree(ctrl, nparts);
#line 789
  __idxwspacefree(ctrl, nparts);
#line 790
  __idxwspacefree(ctrl, nparts);
#line 791
  __idxwspacefree(ctrl, nparts);
#line 792
  __idxwspacefree(ctrl, nvtxs);
#line 793
  __idxwspacefree(ctrl, nvtxs);
  }
#line 794
  return;
}
}
#line 805 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolfm.c"
void __KWayVolUpdate(CtrlType *ctrl , GraphType *graph , long v , long from , long to ,
                     idxtype *marker , idxtype *phtable , idxtype *updind ) 
{ 
  long ii ;
  long j ;
  long jj ;
  long k ;
  long kk ;
  long u ;
  long nupd ;
  long other ;
  long me ;
  long myidx ;
  idxtype *xadj ;
  idxtype *vsize ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  VEDegreeType *myedegrees ;
  VEDegreeType *oedegrees ;
  VRInfoType *myrinfo ;
  VRInfoType *orinfo ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 813
  xadj = graph->xadj;
#line 814
  adjncy = graph->adjncy;
#line 815
  adjwgt = graph->adjwgt;
#line 816
  vsize = graph->vsize;
#line 817
  where = graph->where;
#line 819
  myrinfo = graph->vrinfo + v;
#line 820
  myedegrees = myrinfo->edegrees;
#line 826
  k = 0L;
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 826
    if (! (k < myrinfo->ndegrees)) {
#line 826
      goto while_break;
    }
#line 827
    *(phtable + (myedegrees + k)->pid) = k;
#line 826
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 828
  *(phtable + from) = k;
#line 830
  myidx = *(phtable + to);
#line 832
  j = *(xadj + v);
  {
#line 832
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 832
    if (! (j < *(xadj + (v + 1L)))) {
#line 832
      goto while_break___0;
    }
#line 833
    ii = *(adjncy + j);
#line 834
    other = *(where + ii);
#line 835
    orinfo = graph->vrinfo + ii;
#line 836
    oedegrees = orinfo->edegrees;
#line 838
    if (other == from) {
#line 839
      k = 0L;
      {
#line 839
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 839
        if (! (k < orinfo->ndegrees)) {
#line 839
          goto while_break___1;
        }
#line 840
        if (*(phtable + (oedegrees + k)->pid) == -1L) {
#line 841
          (oedegrees + k)->gv += *(vsize + v);
        }
#line 839
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 847
    if ((myedegrees + *(phtable + other))->ned > 1L) {
#line 848
      k = 0L;
      {
#line 848
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 848
        if (! (k < orinfo->ndegrees)) {
#line 848
          goto while_break___2;
        }
#line 849
        if (*(phtable + (oedegrees + k)->pid) == -1L) {
#line 850
          (oedegrees + k)->gv += *(vsize + v);
        }
#line 848
        k ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 854
      k = 0L;
      {
#line 854
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 854
        if (! (k < orinfo->ndegrees)) {
#line 854
          goto while_break___3;
        }
#line 855
        if (*(phtable + (oedegrees + k)->pid) != -1L) {
#line 856
          (oedegrees + k)->gv -= *(vsize + v);
        }
#line 854
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 832
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 862
  k = 0L;
  {
#line 862
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 862
    if (! (k < myrinfo->ndegrees)) {
#line 862
      goto while_break___4;
    }
#line 863
    *(phtable + (myedegrees + k)->pid) = (idxtype )-1;
#line 862
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 864
  *(phtable + from) = (idxtype )-1;
#line 870
  myrinfo->ed += myrinfo->id - (myedegrees + myidx)->ed;
  {
#line 871
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 871
    j = myrinfo->id;
#line 871
    myrinfo->id = (myedegrees + myidx)->ed;
#line 871
    (myedegrees + myidx)->ed = j;
#line 871
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 872
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 872
    j = myrinfo->nid;
#line 872
    myrinfo->nid = (myedegrees + myidx)->ned;
#line 872
    (myedegrees + myidx)->ned = j;
#line 872
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 873
  if ((myedegrees + myidx)->ed == 0L) {
#line 874
    (myrinfo->ndegrees) --;
#line 874
    *(myedegrees + myidx) = *(myedegrees + myrinfo->ndegrees);
  } else {
#line 876
    (myedegrees + myidx)->pid = from;
  }
#line 881
  *(marker + v) = (idxtype )1;
#line 882
  *(updind + 0) = v;
#line 883
  nupd = 1L;
#line 884
  j = *(xadj + v);
  {
#line 884
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 884
    if (! (j < *(xadj + (v + 1L)))) {
#line 884
      goto while_break___7;
    }
#line 885
    ii = *(adjncy + j);
#line 886
    me = *(where + ii);
#line 888
    if (! *(marker + ii)) {
#line 889
      *(marker + ii) = (idxtype )2;
#line 890
      tmp = nupd;
#line 890
      nupd ++;
#line 890
      *(updind + tmp) = ii;
    }
#line 893
    myrinfo = graph->vrinfo + ii;
#line 894
    if ((unsigned long )myrinfo->edegrees == (unsigned long )((void *)0)) {
#line 895
      myrinfo->edegrees = ctrl->wspace.vedegrees + ctrl->wspace.cdegree;
#line 896
      ctrl->wspace.cdegree += *(xadj + (ii + 1L)) - *(xadj + ii);
    }
#line 898
    myedegrees = myrinfo->edegrees;
#line 900
    if (me == from) {
      {
#line 901
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 901
        myrinfo->ed += *(adjwgt + j);
#line 901
        myrinfo->id -= *(adjwgt + j);
#line 901
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 902
      (myrinfo->nid) --;
    } else
#line 904
    if (me == to) {
      {
#line 905
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 905
        myrinfo->id += *(adjwgt + j);
#line 905
        myrinfo->ed -= *(adjwgt + j);
#line 905
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 906
      (myrinfo->nid) ++;
    }
#line 910
    if (me != from) {
#line 911
      k = 0L;
      {
#line 911
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 911
        if (! (k < myrinfo->ndegrees)) {
#line 911
          goto while_break___10;
        }
#line 912
        if ((myedegrees + k)->pid == from) {
#line 913
          if ((myedegrees + k)->ned == 1L) {
#line 914
            (myrinfo->ndegrees) --;
#line 914
            *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
#line 915
            *(marker + ii) = (idxtype )1;
#line 918
            jj = *(xadj + ii);
            {
#line 918
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 918
              if (! (jj < *(xadj + (ii + 1L)))) {
#line 918
                goto while_break___11;
              }
#line 919
              u = *(adjncy + jj);
#line 920
              other = *(where + u);
#line 921
              orinfo = graph->vrinfo + u;
#line 922
              oedegrees = orinfo->edegrees;
#line 924
              kk = 0L;
              {
#line 924
              while (1) {
                while_continue___12: /* CIL Label */ ;
#line 924
                if (! (kk < orinfo->ndegrees)) {
#line 924
                  goto while_break___12;
                }
#line 925
                if ((oedegrees + kk)->pid == from) {
#line 926
                  (oedegrees + kk)->gv -= *(vsize + ii);
#line 927
                  goto while_break___12;
                }
#line 924
                kk ++;
              }
              while_break___12: /* CIL Label */ ;
              }
#line 918
              jj ++;
            }
            while_break___11: /* CIL Label */ ;
            }
          } else {
#line 933
            (myedegrees + k)->ed -= *(adjwgt + j);
#line 934
            ((myedegrees + k)->ned) --;
#line 937
            if ((myedegrees + k)->ned == 1L) {
#line 939
              jj = *(xadj + ii);
              {
#line 939
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 939
                if (! (jj < *(xadj + (ii + 1L)))) {
#line 939
                  goto while_break___13;
                }
#line 940
                u = *(adjncy + jj);
#line 941
                other = *(where + u);
#line 942
                orinfo = graph->vrinfo + u;
#line 943
                oedegrees = orinfo->edegrees;
#line 945
                if (other == from) {
#line 946
                  kk = 0L;
                  {
#line 946
                  while (1) {
                    while_continue___14: /* CIL Label */ ;
#line 946
                    if (! (kk < orinfo->ndegrees)) {
#line 946
                      goto while_break___14;
                    }
#line 947
                    (oedegrees + kk)->gv += *(vsize + ii);
#line 946
                    kk ++;
                  }
                  while_break___14: /* CIL Label */ ;
                  }
#line 948
                  goto while_break___13;
                }
#line 939
                jj ++;
              }
              while_break___13: /* CIL Label */ ;
              }
            }
          }
#line 954
          goto while_break___10;
        }
#line 911
        k ++;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 960
    if (me != to) {
#line 961
      k = 0L;
      {
#line 961
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 961
        if (! (k < myrinfo->ndegrees)) {
#line 961
          goto while_break___15;
        }
#line 962
        if ((myedegrees + k)->pid == to) {
#line 963
          (myedegrees + k)->ed += *(adjwgt + j);
#line 964
          ((myedegrees + k)->ned) ++;
#line 967
          if ((myedegrees + k)->ned == 2L) {
#line 969
            jj = *(xadj + ii);
            {
#line 969
            while (1) {
              while_continue___16: /* CIL Label */ ;
#line 969
              if (! (jj < *(xadj + (ii + 1L)))) {
#line 969
                goto while_break___16;
              }
#line 970
              u = *(adjncy + jj);
#line 971
              other = *(where + u);
#line 972
              orinfo = graph->vrinfo + u;
#line 973
              oedegrees = orinfo->edegrees;
#line 975
              if (u != v) {
#line 975
                if (other == to) {
#line 976
                  kk = 0L;
                  {
#line 976
                  while (1) {
                    while_continue___17: /* CIL Label */ ;
#line 976
                    if (! (kk < orinfo->ndegrees)) {
#line 976
                      goto while_break___17;
                    }
#line 977
                    (oedegrees + kk)->gv -= *(vsize + ii);
#line 976
                    kk ++;
                  }
                  while_break___17: /* CIL Label */ ;
                  }
#line 978
                  goto while_break___16;
                }
              }
#line 969
              jj ++;
            }
            while_break___16: /* CIL Label */ ;
            }
          }
#line 982
          goto while_break___15;
        }
#line 961
        k ++;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 986
      if (k == myrinfo->ndegrees) {
#line 987
        (myedegrees + myrinfo->ndegrees)->pid = to;
#line 988
        (myedegrees + myrinfo->ndegrees)->ed = *(adjwgt + j);
#line 989
        tmp___0 = myrinfo->ndegrees;
#line 989
        (myrinfo->ndegrees) ++;
#line 989
        (myedegrees + tmp___0)->ned = (idxtype )1;
#line 990
        *(marker + ii) = (idxtype )1;
#line 993
        jj = *(xadj + ii);
        {
#line 993
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 993
          if (! (jj < *(xadj + (ii + 1L)))) {
#line 993
            goto while_break___18;
          }
#line 994
          u = *(adjncy + jj);
#line 995
          other = *(where + u);
#line 996
          orinfo = graph->vrinfo + u;
#line 997
          oedegrees = orinfo->edegrees;
#line 999
          kk = 0L;
          {
#line 999
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 999
            if (! (kk < orinfo->ndegrees)) {
#line 999
              goto while_break___19;
            }
#line 1000
            if ((oedegrees + kk)->pid == to) {
#line 1001
              (oedegrees + kk)->gv += *(vsize + ii);
#line 1002
              if (! *(marker + u)) {
#line 1003
                *(marker + u) = (idxtype )2;
#line 1004
                tmp___1 = nupd;
#line 1004
                nupd ++;
#line 1004
                *(updind + tmp___1) = u;
              }
#line 1006
              goto while_break___19;
            }
#line 999
            kk ++;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 993
          jj ++;
        }
        while_break___18: /* CIL Label */ ;
        }
      }
    }
#line 884
    j ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1019
  myrinfo = graph->vrinfo + v;
#line 1020
  myedegrees = myrinfo->edegrees;
#line 1021
  k = 0L;
  {
#line 1021
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 1021
    if (! (k < myrinfo->ndegrees)) {
#line 1021
      goto while_break___20;
    }
#line 1022
    *(phtable + (myedegrees + k)->pid) = k;
#line 1021
    k ++;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 1023
  *(phtable + to) = k;
#line 1025
  j = *(xadj + v);
  {
#line 1025
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 1025
    if (! (j < *(xadj + (v + 1L)))) {
#line 1025
      goto while_break___21;
    }
#line 1026
    ii = *(adjncy + j);
#line 1027
    other = *(where + ii);
#line 1028
    orinfo = graph->vrinfo + ii;
#line 1029
    oedegrees = orinfo->edegrees;
#line 1031
    if (other == to) {
#line 1032
      k = 0L;
      {
#line 1032
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 1032
        if (! (k < orinfo->ndegrees)) {
#line 1032
          goto while_break___22;
        }
#line 1033
        if (*(phtable + (oedegrees + k)->pid) == -1L) {
#line 1034
          (oedegrees + k)->gv -= *(vsize + v);
        }
#line 1032
        k ++;
      }
      while_break___22: /* CIL Label */ ;
      }
    } else
#line 1040
    if ((myedegrees + *(phtable + other))->ned > 1L) {
#line 1041
      k = 0L;
      {
#line 1041
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 1041
        if (! (k < orinfo->ndegrees)) {
#line 1041
          goto while_break___23;
        }
#line 1042
        if (*(phtable + (oedegrees + k)->pid) == -1L) {
#line 1043
          (oedegrees + k)->gv -= *(vsize + v);
        }
#line 1041
        k ++;
      }
      while_break___23: /* CIL Label */ ;
      }
    } else {
#line 1047
      k = 0L;
      {
#line 1047
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 1047
        if (! (k < orinfo->ndegrees)) {
#line 1047
          goto while_break___24;
        }
#line 1048
        if (*(phtable + (oedegrees + k)->pid) != -1L) {
#line 1049
          (oedegrees + k)->gv += *(vsize + v);
        }
#line 1047
        k ++;
      }
      while_break___24: /* CIL Label */ ;
      }
    }
#line 1025
    j ++;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 1054
  k = 0L;
  {
#line 1054
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 1054
    if (! (k < myrinfo->ndegrees)) {
#line 1054
      goto while_break___25;
    }
#line 1055
    *(phtable + (myedegrees + k)->pid) = (idxtype )-1;
#line 1054
    k ++;
  }
  while_break___25: /* CIL Label */ ;
  }
  {
#line 1056
  *(phtable + to) = (idxtype )-1;
#line 1063
  __ComputeKWayVolume(graph, nupd, updind, marker, phtable);
#line 1069
  j = 0L;
  }
  {
#line 1069
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 1069
    if (! (j < nupd)) {
#line 1069
      goto while_break___26;
    }
#line 1070
    k = *(updind + j);
#line 1071
    *(marker + k) = (idxtype )0;
#line 1072
    myrinfo = graph->vrinfo + k;
#line 1074
    if (myrinfo->gv >= 0L) {
#line 1074
      goto _L;
    } else
#line 1074
    if (myrinfo->ed - myrinfo->id >= 0L) {
      _L: /* CIL Label */ 
#line 1074
      if (*(graph->bndptr + k) == -1L) {
        {
#line 1075
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 1075
          *(graph->bndind + graph->nbnd) = k;
#line 1075
          tmp___2 = graph->nbnd;
#line 1075
          (graph->nbnd) ++;
#line 1075
          *(graph->bndptr + k) = tmp___2;
#line 1075
          goto while_break___27;
        }
        while_break___27: /* CIL Label */ ;
        }
      }
    }
#line 1077
    if (myrinfo->gv < 0L) {
#line 1077
      if (myrinfo->ed - myrinfo->id < 0L) {
#line 1077
        if (*(graph->bndptr + k) != -1L) {
          {
#line 1078
          while (1) {
            while_continue___28: /* CIL Label */ ;
#line 1078
            (graph->nbnd) --;
#line 1078
            *(graph->bndind + *(graph->bndptr + k)) = *(graph->bndind + graph->nbnd);
#line 1078
            *(graph->bndptr + *(graph->bndind + graph->nbnd)) = *(graph->bndptr + k);
#line 1078
            *(graph->bndptr + k) = (idxtype )-1;
#line 1078
            goto while_break___28;
          }
          while_break___28: /* CIL Label */ ;
          }
        }
      }
    }
#line 1069
    j ++;
  }
  while_break___26: /* CIL Label */ ;
  }
#line 1081
  return;
}
}
#line 1089 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolfm.c"
void __ComputeKWayVolume(GraphType *graph , long nupd , idxtype *updind , idxtype *marker ,
                         idxtype *phtable ) 
{ 
  long ii ;
  long iii ;
  long i ;
  long j ;
  long k ;
  long kk ;
  long nvtxs ;
  long me ;
  long other ;
  idxtype *xadj ;
  idxtype *vsize ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  VRInfoType *rinfo ;
  VRInfoType *myrinfo ;
  VRInfoType *orinfo ;
  VEDegreeType *myedegrees ;
  VEDegreeType *oedegrees ;

  {
#line 1096
  nvtxs = graph->nvtxs;
#line 1097
  xadj = graph->xadj;
#line 1098
  vsize = graph->vsize;
#line 1099
  adjncy = graph->adjncy;
#line 1100
  adjwgt = graph->adjwgt;
#line 1101
  where = graph->where;
#line 1102
  rinfo = graph->vrinfo;
#line 1108
  iii = 0L;
  {
#line 1108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1108
    if (! (iii < nupd)) {
#line 1108
      goto while_break;
    }
#line 1109
    i = *(updind + iii);
#line 1110
    me = *(where + i);
#line 1112
    myrinfo = rinfo + i;
#line 1113
    myedegrees = myrinfo->edegrees;
#line 1115
    if (*(marker + i) == 1L) {
#line 1116
      k = 0L;
      {
#line 1116
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1116
        if (! (k < myrinfo->ndegrees)) {
#line 1116
          goto while_break___0;
        }
#line 1117
        (myedegrees + k)->gv = (idxtype )0;
#line 1116
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1119
      j = *(xadj + i);
      {
#line 1119
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1119
        if (! (j < *(xadj + (i + 1L)))) {
#line 1119
          goto while_break___1;
        }
#line 1120
        ii = *(adjncy + j);
#line 1121
        other = *(where + ii);
#line 1122
        orinfo = rinfo + ii;
#line 1123
        oedegrees = orinfo->edegrees;
#line 1125
        kk = 0L;
        {
#line 1125
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1125
          if (! (kk < orinfo->ndegrees)) {
#line 1125
            goto while_break___2;
          }
#line 1126
          *(phtable + (oedegrees + kk)->pid) = kk;
#line 1125
          kk ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1127
        *(phtable + other) = (idxtype )1;
#line 1129
        if (me == other) {
#line 1131
          k = 0L;
          {
#line 1131
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1131
            if (! (k < myrinfo->ndegrees)) {
#line 1131
              goto while_break___3;
            }
#line 1132
            if (*(phtable + (myedegrees + k)->pid) == -1L) {
#line 1133
              (myedegrees + k)->gv -= *(vsize + ii);
            }
#line 1131
            k ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        } else
#line 1140
        if ((oedegrees + *(phtable + me))->ned == 1L) {
#line 1142
          k = 0L;
          {
#line 1142
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1142
            if (! (k < myrinfo->ndegrees)) {
#line 1142
              goto while_break___4;
            }
#line 1143
            if (*(phtable + (myedegrees + k)->pid) != -1L) {
#line 1144
              (myedegrees + k)->gv += *(vsize + ii);
            }
#line 1142
            k ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
#line 1149
          k = 0L;
          {
#line 1149
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1149
            if (! (k < myrinfo->ndegrees)) {
#line 1149
              goto while_break___5;
            }
#line 1150
            if (*(phtable + (myedegrees + k)->pid) == -1L) {
#line 1151
              (myedegrees + k)->gv -= *(vsize + ii);
            }
#line 1149
            k ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 1156
        kk = 0L;
        {
#line 1156
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1156
          if (! (kk < orinfo->ndegrees)) {
#line 1156
            goto while_break___6;
          }
#line 1157
          *(phtable + (oedegrees + kk)->pid) = (idxtype )-1;
#line 1156
          kk ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1158
        *(phtable + other) = (idxtype )-1;
#line 1119
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1163
    myrinfo->gv = - (1L << (8UL * sizeof(idxtype ) - 2UL));
#line 1164
    k = 0L;
    {
#line 1164
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1164
      if (! (k < myrinfo->ndegrees)) {
#line 1164
        goto while_break___7;
      }
#line 1165
      if ((myedegrees + k)->gv > myrinfo->gv) {
#line 1166
        myrinfo->gv = (myedegrees + k)->gv;
      }
#line 1164
      k ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1168
    if (myrinfo->ed > 0L) {
#line 1168
      if (myrinfo->id == 0L) {
#line 1169
        myrinfo->gv += *(vsize + i);
      }
    }
#line 1108
    iii ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1173
  return;
}
}
#line 1180 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolfm.c"
long __ComputeVolume(GraphType *graph , idxtype *where ) 
{ 
  long i ;
  long j ;
  long k ;
  long nvtxs ;
  long nparts ;
  long totalv ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *vsize ;
  idxtype *marker ;
  long tmp ;

  {
#line 1186
  nvtxs = graph->nvtxs;
#line 1187
  xadj = graph->xadj;
#line 1188
  adjncy = graph->adjncy;
#line 1189
  if ((unsigned long )graph->vsize == (unsigned long )((void *)0)) {
#line 1189
    vsize = graph->vwgt;
  } else {
#line 1189
    vsize = graph->vsize;
  }
  {
#line 1191
  tmp = __idxamax(nvtxs, where);
#line 1191
  nparts = *(where + tmp) + 1L;
#line 1192
  marker = __idxsmalloc(nparts, (idxtype )-1, (char *)"ComputeVolume: marker");
#line 1194
  totalv = 0L;
#line 1196
  i = 0L;
  }
  {
#line 1196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1196
    if (! (i < nvtxs)) {
#line 1196
      goto while_break;
    }
#line 1197
    *(marker + *(where + i)) = i;
#line 1198
    j = *(xadj + i);
    {
#line 1198
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1198
      if (! (j < *(xadj + (i + 1L)))) {
#line 1198
        goto while_break___0;
      }
#line 1199
      k = *(where + *(adjncy + j));
#line 1200
      if (*(marker + k) != i) {
#line 1201
        *(marker + k) = i;
#line 1202
        totalv += *(vsize + i);
      }
#line 1198
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1196
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1207
  free((void *)marker);
  }
#line 1209
  return (totalv);
}
}
#line 1219 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolfm.c"
void __CheckVolKWayPartitionParams(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long kk ;
  long nvtxs ;
  long me ;
  long other ;
  long pid ;
  idxtype *xadj ;
  idxtype *vsize ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  VRInfoType *rinfo ;
  VRInfoType *myrinfo ;
  VRInfoType *orinfo ;
  VRInfoType tmprinfo ;
  VEDegreeType *myedegrees ;
  VEDegreeType *oedegrees ;
  VEDegreeType *tmpdegrees ;
  void *tmp ;

  {
  {
#line 1226
  nvtxs = graph->nvtxs;
#line 1227
  xadj = graph->xadj;
#line 1228
  vsize = graph->vsize;
#line 1229
  adjncy = graph->adjncy;
#line 1230
  adjwgt = graph->adjwgt;
#line 1231
  where = graph->where;
#line 1232
  rinfo = graph->vrinfo;
#line 1234
  tmp = __GKmalloc((long )((unsigned long )nparts * sizeof(VEDegreeType )), (char *)"CheckVolKWayPartitionParams: tmpdegrees");
#line 1234
  tmpdegrees = (VEDegreeType *)tmp;
#line 1239
  i = 0L;
  }
  {
#line 1239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1239
    if (! (i < nvtxs)) {
#line 1239
      goto while_break;
    }
#line 1240
    me = *(where + i);
#line 1242
    myrinfo = rinfo + i;
#line 1243
    myedegrees = myrinfo->edegrees;
#line 1245
    k = 0L;
    {
#line 1245
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1245
      if (! (k < myrinfo->ndegrees)) {
#line 1245
        goto while_break___0;
      }
#line 1246
      *(tmpdegrees + k) = *(myedegrees + k);
#line 1245
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1248
    tmprinfo.ndegrees = myrinfo->ndegrees;
#line 1249
    tmprinfo.id = myrinfo->id;
#line 1250
    tmprinfo.ed = myrinfo->ed;
#line 1252
    myrinfo = & tmprinfo;
#line 1253
    myedegrees = tmpdegrees;
#line 1256
    k = 0L;
    {
#line 1256
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1256
      if (! (k < myrinfo->ndegrees)) {
#line 1256
        goto while_break___1;
      }
#line 1257
      (myedegrees + k)->gv = (idxtype )0;
#line 1256
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1259
    j = *(xadj + i);
    {
#line 1259
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1259
      if (! (j < *(xadj + (i + 1L)))) {
#line 1259
        goto while_break___2;
      }
#line 1260
      ii = *(adjncy + j);
#line 1261
      other = *(where + ii);
#line 1262
      orinfo = rinfo + ii;
#line 1263
      oedegrees = orinfo->edegrees;
#line 1265
      if (me == other) {
#line 1267
        k = 0L;
        {
#line 1267
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1267
          if (! (k < myrinfo->ndegrees)) {
#line 1267
            goto while_break___3;
          }
#line 1268
          pid = (myedegrees + k)->pid;
#line 1269
          kk = 0L;
          {
#line 1269
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1269
            if (! (kk < orinfo->ndegrees)) {
#line 1269
              goto while_break___4;
            }
#line 1270
            if ((oedegrees + kk)->pid == pid) {
#line 1271
              goto while_break___4;
            }
#line 1269
            kk ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1273
          if (kk == orinfo->ndegrees) {
#line 1274
            (myedegrees + k)->gv -= *(vsize + ii);
          }
#line 1267
          k ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 1279
        k = 0L;
        {
#line 1279
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1279
          if (! (k < orinfo->ndegrees)) {
#line 1279
            goto while_break___5;
          }
#line 1280
          if ((oedegrees + k)->pid == me) {
#line 1281
            goto while_break___5;
          }
#line 1279
          k ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1284
        if ((oedegrees + k)->ned == 1L) {
#line 1285
          k = 0L;
          {
#line 1285
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1285
            if (! (k < myrinfo->ndegrees)) {
#line 1285
              goto while_break___6;
            }
#line 1286
            if ((myedegrees + k)->pid == other) {
#line 1287
              (myedegrees + k)->gv += *(vsize + ii);
#line 1288
              goto while_break___6;
            }
#line 1285
            k ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 1293
          k = 0L;
          {
#line 1293
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 1293
            if (! (k < myrinfo->ndegrees)) {
#line 1293
              goto while_break___7;
            }
#line 1294
            pid = (myedegrees + k)->pid;
#line 1294
            if (pid == other) {
#line 1295
              goto __Cont;
            }
#line 1296
            kk = 0L;
            {
#line 1296
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 1296
              if (! (kk < orinfo->ndegrees)) {
#line 1296
                goto while_break___8;
              }
#line 1297
              if ((oedegrees + kk)->pid == pid) {
#line 1298
                (myedegrees + k)->gv += *(vsize + ii);
#line 1299
                goto while_break___8;
              }
#line 1296
              kk ++;
            }
            while_break___8: /* CIL Label */ ;
            }
            __Cont: /* CIL Label */ 
#line 1293
            k ++;
          }
          while_break___7: /* CIL Label */ ;
          }
        } else {
#line 1307
          k = 0L;
          {
#line 1307
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 1307
            if (! (k < myrinfo->ndegrees)) {
#line 1307
              goto while_break___9;
            }
#line 1308
            pid = (myedegrees + k)->pid;
#line 1308
            if (pid == other) {
#line 1309
              goto __Cont___0;
            }
#line 1310
            kk = 0L;
            {
#line 1310
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 1310
              if (! (kk < orinfo->ndegrees)) {
#line 1310
                goto while_break___10;
              }
#line 1311
              if ((oedegrees + kk)->pid == pid) {
#line 1312
                goto while_break___10;
              }
#line 1310
              kk ++;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 1314
            if (kk == orinfo->ndegrees) {
#line 1315
              (myedegrees + k)->gv -= *(vsize + ii);
            }
            __Cont___0: /* CIL Label */ 
#line 1307
            k ++;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
#line 1259
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1321
    myrinfo = rinfo + i;
#line 1322
    myedegrees = myrinfo->edegrees;
#line 1324
    k = 0L;
    {
#line 1324
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1324
      if (! (k < myrinfo->ndegrees)) {
#line 1324
        goto while_break___11;
      }
#line 1325
      pid = (myedegrees + k)->pid;
#line 1326
      kk = 0L;
      {
#line 1326
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1326
        if (! (kk < tmprinfo.ndegrees)) {
#line 1326
          goto while_break___12;
        }
#line 1327
        if ((tmpdegrees + kk)->pid == pid) {
#line 1328
          if ((tmpdegrees + kk)->gv != (myedegrees + k)->gv) {
            {
#line 1329
            printf((char const   */* __restrict  */)"[%ld %ld %ld %ld]\n", i, pid,
                   (myedegrees + k)->gv, (tmpdegrees + kk)->gv);
            }
          }
#line 1330
          goto while_break___12;
        }
#line 1326
        kk ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 1324
      k ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1239
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1337
  free((void *)tmpdegrees);
  }
#line 1339
  return;
}
}
#line 1345 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolfm.c"
void __ComputeVolSubDomainGraph(GraphType *graph , long nparts , idxtype *pmat , idxtype *ndoms ) 
{ 
  long i ;
  long j ;
  long k ;
  long me ;
  long nvtxs ;
  long ndegrees ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  VRInfoType *rinfo ;
  VEDegreeType *edegrees ;

  {
  {
#line 1352
  nvtxs = graph->nvtxs;
#line 1353
  xadj = graph->xadj;
#line 1354
  adjncy = graph->adjncy;
#line 1355
  adjwgt = graph->adjwgt;
#line 1356
  where = graph->where;
#line 1357
  rinfo = graph->vrinfo;
#line 1359
  __idxset(nparts * nparts, (idxtype )0, pmat);
#line 1361
  i = 0L;
  }
  {
#line 1361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1361
    if (! (i < nvtxs)) {
#line 1361
      goto while_break;
    }
#line 1362
    if ((rinfo + i)->ed > 0L) {
#line 1363
      me = *(where + i);
#line 1364
      ndegrees = (rinfo + i)->ndegrees;
#line 1365
      edegrees = (rinfo + i)->edegrees;
#line 1367
      k = me * nparts;
#line 1368
      j = 0L;
      {
#line 1368
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1368
        if (! (j < ndegrees)) {
#line 1368
          goto while_break___0;
        }
#line 1369
        *(pmat + (k + (edegrees + j)->pid)) += (edegrees + j)->ed;
#line 1368
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1361
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1373
  i = 0L;
  {
#line 1373
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1373
    if (! (i < nparts)) {
#line 1373
      goto while_break___1;
    }
#line 1374
    *(ndoms + i) = (idxtype )0;
#line 1375
    j = 0L;
    {
#line 1375
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1375
      if (! (j < nparts)) {
#line 1375
        goto while_break___2;
      }
#line 1376
      if (*(pmat + (i * nparts + j)) > 0L) {
#line 1377
        (*(ndoms + i)) ++;
      }
#line 1375
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1373
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1380
  return;
}
}
#line 1387 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolfm.c"
void __EliminateVolSubDomainEdges(CtrlType *ctrl , GraphType *graph , long nparts ,
                                  float *tpwgts ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long me ;
  long other ;
  long nvtxs ;
  long total ;
  long max ;
  long avg ;
  long totalout ;
  long nind ;
  long ncand ;
  long ncand2 ;
  long target ;
  long target2 ;
  long nadd ;
  long min ;
  long move ;
  long cpwgt ;
  long tvwgt ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *vwgt ;
  idxtype *adjwgt ;
  idxtype *pwgts ;
  idxtype *where ;
  idxtype *maxpwgt ;
  idxtype *pmat ;
  idxtype *ndoms ;
  idxtype *mypmat ;
  idxtype *otherpmat ;
  idxtype *ind ;
  KeyValueType *cand ;
  KeyValueType *cand2 ;
  void *tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  {
#line 1394
  nvtxs = graph->nvtxs;
#line 1395
  xadj = graph->xadj;
#line 1396
  adjncy = graph->adjncy;
#line 1397
  vwgt = graph->vwgt;
#line 1398
  adjwgt = graph->adjwgt;
#line 1400
  where = graph->where;
#line 1401
  pwgts = __idxset(nparts, (idxtype )0, graph->pwgts);
#line 1403
  maxpwgt = __idxwspacemalloc(ctrl, nparts);
#line 1404
  ndoms = __idxwspacemalloc(ctrl, nparts);
#line 1405
  otherpmat = __idxwspacemalloc(ctrl, nparts);
#line 1406
  ind = __idxwspacemalloc(ctrl, nvtxs);
#line 1407
  pmat = __idxset(nparts * nparts, (idxtype )0, ctrl->wspace.pmat);
#line 1409
  tmp = __GKmalloc((long )((unsigned long )nparts * sizeof(KeyValueType )), (char *)"EliminateSubDomainEdges: cand");
#line 1409
  cand = (KeyValueType *)tmp;
#line 1410
  tmp___0 = __GKmalloc((long )((unsigned long )nparts * sizeof(KeyValueType )), (char *)"EliminateSubDomainEdges: cand");
#line 1410
  cand2 = (KeyValueType *)tmp___0;
#line 1413
  i = 0L;
  }
  {
#line 1413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1413
    if (! (i < nvtxs)) {
#line 1413
      goto while_break;
    }
#line 1414
    me = *(where + i);
#line 1415
    *(pwgts + me) += *(vwgt + i);
#line 1416
    j = *(xadj + i);
    {
#line 1416
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1416
      if (! (j < *(xadj + (i + 1L)))) {
#line 1416
        goto while_break___0;
      }
#line 1417
      k = *(adjncy + j);
#line 1418
      if (*(where + k) != me) {
#line 1419
        *(pmat + (me * nparts + *(where + k))) += *(adjwgt + j);
      }
#line 1416
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1413
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1424
  tvwgt = __idxsum(nparts, pwgts);
#line 1425
  i = 0L;
  }
  {
#line 1425
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1425
    if (! (i < nparts)) {
#line 1425
      goto while_break___1;
    }
#line 1426
    *(maxpwgt + i) = (idxtype )((1.25 * (double )*(tpwgts + i)) * (double )tvwgt);
#line 1425
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1429
  i = 0L;
  {
#line 1429
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1429
    if (! (i < nparts)) {
#line 1429
      goto while_break___2;
    }
#line 1430
    k = 0L;
#line 1430
    j = 0L;
    {
#line 1430
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1430
      if (! (j < nparts)) {
#line 1430
        goto while_break___3;
      }
#line 1431
      if (*(pmat + (i * nparts + j)) > 0L) {
#line 1432
        k ++;
      }
#line 1430
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1434
    *(ndoms + i) = k;
#line 1429
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1438
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 1439
    total = __idxsum(nparts, ndoms);
#line 1440
    avg = total / nparts;
#line 1441
    tmp___1 = __idxamax(nparts, ndoms);
#line 1441
    max = *(ndoms + tmp___1);
    }
#line 1445
    if ((double )max < 1.5 * (double )avg) {
#line 1446
      goto while_break___4;
    }
    {
#line 1448
    me = __idxamax(nparts, ndoms);
#line 1449
    mypmat = pmat + me * nparts;
#line 1450
    totalout = __idxsum(nparts, mypmat);
#line 1455
    ncand2 = 0L;
#line 1455
    i = 0L;
    }
    {
#line 1455
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1455
      if (! (i < nparts)) {
#line 1455
        goto while_break___5;
      }
#line 1456
      if (*(mypmat + i) > 0L) {
#line 1457
        (cand2 + ncand2)->key = *(mypmat + i);
#line 1458
        tmp___2 = ncand2;
#line 1458
        ncand2 ++;
#line 1458
        (cand2 + tmp___2)->val = i;
      }
#line 1455
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1461
    __ikeysort(ncand2, cand2);
#line 1463
    move = 0L;
#line 1464
    min = 0L;
    }
    {
#line 1464
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1464
      if (! (min < ncand2)) {
#line 1464
        goto while_break___6;
      }
#line 1465
      if ((cand2 + min)->key > totalout / (2L * *(ndoms + me))) {
#line 1466
        goto while_break___6;
      }
      {
#line 1468
      other = (cand2 + min)->val;
#line 1472
      __idxset(nparts, (idxtype )0, otherpmat);
#line 1475
      nind = 0L;
#line 1475
      i = 0L;
      }
      {
#line 1475
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1475
        if (! (i < nvtxs)) {
#line 1475
          goto while_break___7;
        }
#line 1476
        if (*(where + i) == other) {
#line 1477
          j = *(xadj + i);
          {
#line 1477
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 1477
            if (! (j < *(xadj + (i + 1L)))) {
#line 1477
              goto while_break___8;
            }
#line 1478
            if (*(where + *(adjncy + j)) == me) {
#line 1479
              tmp___3 = nind;
#line 1479
              nind ++;
#line 1479
              *(ind + tmp___3) = i;
#line 1480
              goto while_break___8;
            }
#line 1477
            j ++;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
#line 1475
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1487
      cpwgt = 0L;
#line 1487
      ii = 0L;
      {
#line 1487
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1487
        if (! (ii < nind)) {
#line 1487
          goto while_break___9;
        }
#line 1488
        i = *(ind + ii);
#line 1489
        cpwgt += *(vwgt + i);
#line 1491
        j = *(xadj + i);
        {
#line 1491
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1491
          if (! (j < *(xadj + (i + 1L)))) {
#line 1491
            goto while_break___10;
          }
#line 1492
          k = *(adjncy + j);
#line 1493
          if (*(where + k) != other) {
#line 1494
            *(otherpmat + *(where + k)) += *(adjwgt + j);
          }
#line 1491
          j ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 1487
        ii ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1498
      ncand = 0L;
#line 1498
      i = 0L;
      {
#line 1498
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1498
        if (! (i < nparts)) {
#line 1498
          goto while_break___11;
        }
#line 1499
        if (*(otherpmat + i) > 0L) {
#line 1500
          (cand + ncand)->key = - *(otherpmat + i);
#line 1501
          tmp___4 = ncand;
#line 1501
          ncand ++;
#line 1501
          (cand + tmp___4)->val = i;
        }
#line 1498
        i ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 1504
      __ikeysort(ncand, cand);
#line 1511
      target2 = -1L;
#line 1511
      target = target2;
#line 1512
      i = 0L;
      }
      {
#line 1512
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1512
        if (! (i < ncand)) {
#line 1512
          goto while_break___12;
        }
#line 1513
        k = (cand + i)->val;
#line 1515
        if (*(mypmat + k) > 0L) {
#line 1516
          if (*(pwgts + k) + cpwgt > *(maxpwgt + k)) {
#line 1517
            goto __Cont;
          }
#line 1519
          j = 0L;
          {
#line 1519
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 1519
            if (! (j < nparts)) {
#line 1519
              goto while_break___13;
            }
#line 1520
            if (*(otherpmat + j) > 0L) {
#line 1520
              if (*(ndoms + j) >= *(ndoms + me) - 1L) {
#line 1520
                if (*(pmat + (nparts * j + k)) == 0L) {
#line 1521
                  goto while_break___13;
                }
              }
            }
#line 1519
            j ++;
          }
          while_break___13: /* CIL Label */ ;
          }
#line 1523
          if (j == nparts) {
#line 1524
            nadd = 0L;
#line 1524
            j = 0L;
            {
#line 1524
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 1524
              if (! (j < nparts)) {
#line 1524
                goto while_break___14;
              }
#line 1525
              if (*(otherpmat + j) > 0L) {
#line 1525
                if (*(pmat + (nparts * k + j)) == 0L) {
#line 1526
                  nadd ++;
                }
              }
#line 1524
              j ++;
            }
            while_break___14: /* CIL Label */ ;
            }
#line 1530
            if (target2 == -1L) {
#line 1530
              if (*(ndoms + k) + nadd < *(ndoms + me)) {
#line 1531
                target2 = k;
              }
            }
#line 1533
            if (nadd == 0L) {
#line 1534
              target = k;
#line 1535
              goto while_break___12;
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 1512
        i ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 1540
      if (target == -1L) {
#line 1540
        if (target2 != -1L) {
#line 1541
          target = target2;
        }
      }
#line 1543
      if (target == -1L) {
#line 1545
        goto __Cont___0;
      }
      {
#line 1551
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1551
        *(pwgts + target) += cpwgt;
#line 1551
        *(pwgts + other) -= cpwgt;
#line 1551
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 1554
      ii = 0L;
      {
#line 1554
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 1554
        if (! (ii < nind)) {
#line 1554
          goto while_break___16;
        }
#line 1555
        i = *(ind + ii);
#line 1556
        *(where + i) = target;
#line 1559
        j = *(xadj + i);
        {
#line 1559
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 1559
          if (! (j < *(xadj + (i + 1L)))) {
#line 1559
            goto while_break___17;
          }
#line 1560
          k = *(adjncy + j);
#line 1561
          if (*(where + k) != other) {
#line 1562
            if (*(pmat + (nparts * other + *(where + k))) == 0L) {
              {
#line 1563
              printf((char const   */* __restrict  */)"Something wrong\n");
              }
            }
#line 1564
            *(pmat + (nparts * other + *(where + k))) -= *(adjwgt + j);
#line 1565
            if (*(pmat + (nparts * other + *(where + k))) == 0L) {
#line 1566
              (*(ndoms + other)) --;
            }
#line 1568
            if (*(pmat + (nparts * *(where + k) + other)) == 0L) {
              {
#line 1569
              printf((char const   */* __restrict  */)"Something wrong\n");
              }
            }
#line 1570
            *(pmat + (nparts * *(where + k) + other)) -= *(adjwgt + j);
#line 1571
            if (*(pmat + (nparts * *(where + k) + other)) == 0L) {
#line 1572
              (*(ndoms + *(where + k))) --;
            }
          }
#line 1559
          j ++;
        }
        while_break___17: /* CIL Label */ ;
        }
#line 1577
        j = *(xadj + i);
        {
#line 1577
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 1577
          if (! (j < *(xadj + (i + 1L)))) {
#line 1577
            goto while_break___18;
          }
#line 1578
          k = *(adjncy + j);
#line 1579
          if (*(where + k) != target) {
#line 1580
            if (*(pmat + (nparts * target + *(where + k))) == 0L) {
#line 1581
              (*(ndoms + target)) ++;
            }
#line 1582
            *(pmat + (nparts * target + *(where + k))) += *(adjwgt + j);
#line 1584
            if (*(pmat + (nparts * *(where + k) + target)) == 0L) {
#line 1585
              (*(ndoms + *(where + k))) ++;
            }
#line 1586
            *(pmat + (nparts * *(where + k) + target)) += *(adjwgt + j);
          }
#line 1577
          j ++;
        }
        while_break___18: /* CIL Label */ ;
        }
#line 1554
        ii ++;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 1591
      move = 1L;
#line 1592
      goto while_break___6;
      __Cont___0: /* CIL Label */ 
#line 1464
      min ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1595
    if (move == 0L) {
#line 1596
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1599
  __idxwspacefree(ctrl, nparts);
#line 1600
  __idxwspacefree(ctrl, nparts);
#line 1601
  __idxwspacefree(ctrl, nparts);
#line 1602
  __idxwspacefree(ctrl, nvtxs);
#line 1604
  __GKfree(& cand, & cand2, (void **)0);
  }
#line 1605
  return;
}
}
#line 1614 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayvolfm.c"
void EliminateVolComponents(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ,
                            float ubfactor ) 
{ 
  long i ;
  long ii ;
  long j ;
  long jj ;
  long k ;
  long me ;
  long nvtxs ;
  long tvwgt ;
  long first ;
  long last ;
  long nleft ;
  long ncmps ;
  long cwgt ;
  long ncand ;
  long other ;
  long target ;
  long deltawgt ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *vwgt ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *maxpwgt ;
  idxtype *cpvec ;
  idxtype *touched ;
  idxtype *perm ;
  idxtype *todo ;
  idxtype *cind ;
  idxtype *cptr ;
  idxtype *npcmps ;
  KeyValueType *cand ;
  long recompute ;
  idxtype *tmp ;
  idxtype *tmp___0 ;
  idxtype tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  idxtype tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  long tmp___7 ;
  long ttlv ;
  idxtype *marker ;

  {
  {
#line 1620
  recompute = 0L;
#line 1622
  nvtxs = graph->nvtxs;
#line 1623
  xadj = graph->xadj;
#line 1624
  adjncy = graph->adjncy;
#line 1625
  vwgt = graph->vwgt;
#line 1626
  adjwgt = graph->adjwgt;
#line 1628
  where = graph->where;
#line 1629
  pwgts = __idxset(nparts, (idxtype )0, graph->pwgts);
#line 1631
  tmp = __idxwspacemalloc(ctrl, nvtxs);
#line 1631
  touched = __idxset(nvtxs, (idxtype )0, tmp);
#line 1632
  cptr = __idxwspacemalloc(ctrl, nvtxs);
#line 1633
  cind = __idxwspacemalloc(ctrl, nvtxs);
#line 1634
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 1635
  todo = __idxwspacemalloc(ctrl, nvtxs);
#line 1636
  maxpwgt = __idxwspacemalloc(ctrl, nparts);
#line 1637
  cpvec = __idxwspacemalloc(ctrl, nparts);
#line 1638
  tmp___0 = __idxwspacemalloc(ctrl, nparts);
#line 1638
  npcmps = __idxset(nparts, (idxtype )0, tmp___0);
#line 1640
  i = 0L;
  }
  {
#line 1640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1640
    if (! (i < nvtxs)) {
#line 1640
      goto while_break;
    }
#line 1641
    tmp___1 = i;
#line 1641
    *(todo + i) = tmp___1;
#line 1641
    *(perm + i) = tmp___1;
#line 1640
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1644
  ncmps = -1L;
#line 1645
  last = 0L;
#line 1645
  first = last;
#line 1646
  nleft = nvtxs;
  {
#line 1647
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1647
    if (! (nleft > 0L)) {
#line 1647
      goto while_break___0;
    }
#line 1648
    if (first == last) {
#line 1649
      ncmps ++;
#line 1649
      *(cptr + ncmps) = first;
#line 1651
      i = *(todo + 0);
#line 1652
      tmp___2 = last;
#line 1652
      last ++;
#line 1652
      *(cind + tmp___2) = i;
#line 1653
      *(touched + i) = (idxtype )1;
#line 1654
      me = *(where + i);
#line 1655
      (*(npcmps + me)) ++;
    }
#line 1658
    tmp___3 = first;
#line 1658
    first ++;
#line 1658
    i = *(cind + tmp___3);
#line 1659
    k = *(perm + i);
#line 1660
    nleft --;
#line 1660
    tmp___4 = *(todo + nleft);
#line 1660
    *(todo + k) = tmp___4;
#line 1660
    j = tmp___4;
#line 1661
    *(perm + j) = k;
#line 1663
    j = *(xadj + i);
    {
#line 1663
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1663
      if (! (j < *(xadj + (i + 1L)))) {
#line 1663
        goto while_break___1;
      }
#line 1664
      k = *(adjncy + j);
#line 1665
      if (*(where + k) == me) {
#line 1665
        if (! *(touched + k)) {
#line 1666
          tmp___5 = last;
#line 1666
          last ++;
#line 1666
          *(cind + tmp___5) = k;
#line 1667
          *(touched + k) = (idxtype )1;
        }
      }
#line 1663
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1671
  ncmps ++;
#line 1671
  *(cptr + ncmps) = first;
#line 1675
  if (ncmps > nparts) {
    {
#line 1676
    tmp___6 = __GKmalloc((long )((unsigned long )nparts * sizeof(KeyValueType )),
                         (char *)"EliminateSubDomainEdges: cand");
#line 1676
    cand = (KeyValueType *)tmp___6;
#line 1679
    i = 0L;
    }
    {
#line 1679
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1679
      if (! (i < nvtxs)) {
#line 1679
        goto while_break___2;
      }
#line 1680
      *(pwgts + *(where + i)) += *(vwgt + i);
#line 1679
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1681
    tvwgt = __idxsum(nparts, pwgts);
#line 1682
    i = 0L;
    }
    {
#line 1682
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1682
      if (! (i < nparts)) {
#line 1682
        goto while_break___3;
      }
#line 1683
      *(maxpwgt + i) = (idxtype )((ubfactor * *(tpwgts + i)) * (float )tvwgt);
#line 1682
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1685
    deltawgt = tvwgt / (100L * nparts);
#line 1686
    deltawgt = 5L;
#line 1688
    i = 0L;
    {
#line 1688
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1688
      if (! (i < ncmps)) {
#line 1688
        goto while_break___4;
      }
#line 1689
      me = *(where + *(cind + *(cptr + i)));
#line 1690
      if (*(npcmps + me) == 1L) {
#line 1691
        goto __Cont;
      }
      {
#line 1696
      __idxset(nparts, (idxtype )0, cpvec);
#line 1697
      cwgt = 0L;
#line 1697
      j = *(cptr + i);
      }
      {
#line 1697
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1697
        if (! (j < *(cptr + (i + 1L)))) {
#line 1697
          goto while_break___5;
        }
#line 1698
        ii = *(cind + j);
#line 1699
        cwgt += *(vwgt + ii);
#line 1700
        jj = *(xadj + ii);
        {
#line 1700
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1700
          if (! (jj < *(xadj + (ii + 1L)))) {
#line 1700
            goto while_break___6;
          }
#line 1701
          other = *(where + *(adjncy + jj));
#line 1702
          if (me != other) {
#line 1703
            *(cpvec + other) += *(adjwgt + jj);
          }
#line 1700
          jj ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1697
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1709
      if ((double )cwgt > .30 * (double )*(pwgts + me)) {
#line 1710
        goto __Cont;
      }
#line 1712
      ncand = 0L;
#line 1712
      j = 0L;
      {
#line 1712
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1712
        if (! (j < nparts)) {
#line 1712
          goto while_break___7;
        }
#line 1713
        if (*(cpvec + j) > 0L) {
#line 1714
          (cand + ncand)->key = - *(cpvec + j);
#line 1715
          tmp___7 = ncand;
#line 1715
          ncand ++;
#line 1715
          (cand + tmp___7)->val = j;
        }
#line 1712
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1718
      if (ncand == 0L) {
#line 1719
        goto __Cont;
      }
      {
#line 1721
      __ikeysort(ncand, cand);
#line 1723
      target = -1L;
#line 1724
      j = 0L;
      }
      {
#line 1724
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1724
        if (! (j < ncand)) {
#line 1724
          goto while_break___8;
        }
#line 1725
        k = (cand + j)->val;
#line 1726
        if (cwgt < deltawgt) {
#line 1727
          target = k;
#line 1728
          goto while_break___8;
        } else
#line 1726
        if (*(pwgts + k) + cwgt < *(maxpwgt + k)) {
#line 1727
          target = k;
#line 1728
          goto while_break___8;
        }
#line 1724
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1734
      if (target != -1L) {
#line 1736
        *(pwgts + me) -= cwgt;
#line 1737
        *(pwgts + target) += cwgt;
#line 1738
        (*(npcmps + me)) --;
#line 1740
        j = *(cptr + i);
        {
#line 1740
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1740
          if (! (j < *(cptr + (i + 1L)))) {
#line 1740
            goto while_break___9;
          }
#line 1741
          *(where + *(cind + j)) = target;
#line 1740
          j ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 1743
        graph->mincut -= *(cpvec + target);
#line 1744
        recompute = 1L;
      }
      __Cont: /* CIL Label */ 
#line 1688
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1748
    free((void *)cand);
    }
  }
#line 1751
  if (recompute) {
    {
#line 1755
    marker = __idxset(nparts, (idxtype )-1, cpvec);
#line 1756
    ttlv = 0L;
#line 1756
    i = 0L;
    }
    {
#line 1756
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1756
      if (! (i < nvtxs)) {
#line 1756
        goto while_break___10;
      }
#line 1757
      *(marker + *(where + i)) = i;
#line 1758
      j = *(xadj + i);
      {
#line 1758
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1758
        if (! (j < *(xadj + (i + 1L)))) {
#line 1758
          goto while_break___11;
        }
#line 1759
        if (*(marker + *(where + *(adjncy + j))) != i) {
#line 1760
          ttlv += *(graph->vsize + i);
#line 1761
          *(marker + *(where + *(adjncy + j))) = i;
        }
#line 1758
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 1756
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 1765
    graph->minvol = ttlv;
  }
  {
#line 1768
  __idxwspacefree(ctrl, nparts);
#line 1769
  __idxwspacefree(ctrl, nparts);
#line 1770
  __idxwspacefree(ctrl, nparts);
#line 1771
  __idxwspacefree(ctrl, nvtxs);
#line 1772
  __idxwspacefree(ctrl, nvtxs);
#line 1773
  __idxwspacefree(ctrl, nvtxs);
#line 1774
  __idxwspacefree(ctrl, nvtxs);
#line 1775
  __idxwspacefree(ctrl, nvtxs);
  }
#line 1777
  return;
}
}
#line 257 "./proto.h"
void __MocGrowBisection(CtrlType *ctrl , GraphType *graph , float *tpwgts , float ubfactor ) ;
#line 258
void __MocRandomBisection(CtrlType *ctrl , GraphType *graph , float *tpwgts , float ubfactor ) ;
#line 259
void __MocInit2WayBalance(CtrlType *ctrl , GraphType *graph , float *tpwgts ) ;
#line 21 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/minitpart.c"
void __MocInit2WayPartition(CtrlType *ctrl , GraphType *graph , float *tpwgts , float ubfactor ) 
{ 
  long dbglvl ;
  double tmp ;
  double tmp___0 ;

  {
#line 25
  dbglvl = ctrl->dbglvl;
#line 26
  if (ctrl->dbglvl & 8L) {
#line 26
    ctrl->dbglvl -= 8L;
  }
#line 27
  if (ctrl->dbglvl & 32L) {
#line 27
    ctrl->dbglvl -= 32L;
  }
#line 29
  if (ctrl->dbglvl & 1L) {
    {
#line 29
    tmp = __seconds();
#line 29
    ctrl->InitPartTmr -= tmp;
    }
  }
  {
#line 32
  if (ctrl->IType == 1L) {
#line 32
    goto case_1;
  }
#line 35
  if (ctrl->IType == 2L) {
#line 35
    goto case_2;
  }
#line 38
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 33
  __MocGrowBisection(ctrl, graph, tpwgts, ubfactor);
  }
#line 34
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 36
  __MocRandomBisection(ctrl, graph, tpwgts, ubfactor);
  }
#line 37
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 39
  __errexit((char *)"Unknown initial partition type: %ld\n", ctrl->IType);
  }
  switch_break: /* CIL Label */ ;
  }
#line 42
  if (ctrl->dbglvl & 16L) {
    {
#line 42
    printf((char const   */* __restrict  */)"Initial Cut: %ld [%ld]\n", graph->mincut,
           *(graph->where + 0));
    }
  }
#line 43
  if (ctrl->dbglvl & 1L) {
    {
#line 43
    tmp___0 = __seconds();
#line 43
    ctrl->InitPartTmr += tmp___0;
    }
  }
#line 44
  ctrl->dbglvl = dbglvl;
#line 46
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/minitpart.c"
void __MocGrowBisection(CtrlType *ctrl , GraphType *graph , float *tpwgts , float ubfactor ) 
{ 
  long nvtxs ;
  long bestcut ;
  long nbfs ;
  idxtype *bestwhere ;
  idxtype *where ;
  int tmp ;
  double tmp___0 ;

  {
  {
#line 62
  nvtxs = graph->nvtxs;
#line 64
  __MocAllocate2WayPartitionMemory(ctrl, graph);
#line 65
  where = graph->where;
#line 67
  bestwhere = __idxmalloc(nvtxs, (char *)"BisectGraph: bestwhere");
  }
#line 68
  if (nvtxs <= ctrl->CoarsenTo) {
#line 68
    tmp = 3;
  } else {
#line 68
    tmp = 8;
  }
  {
#line 68
  nbfs = (long )(2 * tmp);
#line 69
  bestcut = __idxsum(graph->nedges, graph->adjwgt);
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (nbfs > 0L)) {
#line 71
      goto while_break;
    }
    {
#line 72
    __idxset(nvtxs, (idxtype )1, where);
#line 73
    tmp___0 = drand48();
#line 73
    *(where + (long )(tmp___0 * (double )nvtxs)) = (idxtype )0;
#line 75
    __MocCompute2WayPartitionParams(ctrl, graph);
#line 77
    __MocInit2WayBalance(ctrl, graph, tpwgts);
#line 79
    __MocFM_2WayEdgeRefine(ctrl, graph, tpwgts, 4L);
#line 81
    __MocBalance2Way(ctrl, graph, tpwgts, (float )1.02);
#line 82
    __MocFM_2WayEdgeRefine(ctrl, graph, tpwgts, 4L);
    }
#line 84
    if (bestcut >= graph->mincut) {
      {
#line 85
      bestcut = graph->mincut;
#line 86
      memcpy((void */* __restrict  */)((void *)bestwhere), (void const   */* __restrict  */)((void *)where),
             sizeof(idxtype ) * (unsigned long )nvtxs);
      }
#line 87
      if (bestcut == 0L) {
#line 88
        goto while_break;
      }
    }
#line 71
    nbfs --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  graph->mincut = bestcut;
#line 93
  memcpy((void */* __restrict  */)((void *)where), (void const   */* __restrict  */)((void *)bestwhere),
         sizeof(idxtype ) * (unsigned long )nvtxs);
#line 95
  __GKfree(& bestwhere, (void **)0);
  }
#line 96
  return;
}
}
#line 105 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/minitpart.c"
void __MocRandomBisection(CtrlType *ctrl , GraphType *graph , float *tpwgts , float ubfactor ) 
{ 
  long i ;
  long ii ;
  long nvtxs ;
  long ncon ;
  long bestcut ;
  long nbfs ;
  long qnum ;
  idxtype *bestwhere ;
  idxtype *where ;
  idxtype *perm ;
  long counts[16] ;
  float *nvwgt ;
  int tmp ;

  {
  {
#line 112
  nvtxs = graph->nvtxs;
#line 113
  ncon = graph->ncon;
#line 114
  nvwgt = graph->nvwgt;
#line 116
  __MocAllocate2WayPartitionMemory(ctrl, graph);
#line 117
  where = graph->where;
#line 119
  bestwhere = __idxmalloc(nvtxs, (char *)"BisectGraph: bestwhere");
  }
#line 120
  if (nvtxs <= ctrl->CoarsenTo) {
#line 120
    tmp = 3;
  } else {
#line 120
    tmp = 8;
  }
  {
#line 120
  nbfs = (long )(2 * tmp);
#line 121
  bestcut = __idxsum(graph->nedges, graph->adjwgt);
#line 122
  perm = __idxmalloc(nvtxs, (char *)"BisectGraph: perm");
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (nbfs > 0L)) {
#line 124
      goto while_break;
    }
#line 125
    i = 0L;
    {
#line 125
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 125
      if (! (i < ncon)) {
#line 125
        goto while_break___0;
      }
#line 126
      counts[i] = 0L;
#line 125
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 128
    __RandomPermute(nvtxs, perm, 1L);
#line 131
    ii = 0L;
    }
    {
#line 131
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 131
      if (! (ii < nvtxs)) {
#line 131
        goto while_break___1;
      }
      {
#line 132
      i = *(perm + ii);
#line 133
      qnum = __samax(ncon, nvwgt + i * ncon);
#line 134
      *(where + i) = counts[qnum];
#line 135
      counts[qnum] = (counts[qnum] + 1L) % 2L;
#line 131
      ii ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 138
    __MocCompute2WayPartitionParams(ctrl, graph);
#line 140
    __MocFM_2WayEdgeRefine(ctrl, graph, tpwgts, 6L);
#line 141
    __MocBalance2Way(ctrl, graph, tpwgts, (float )1.02);
#line 142
    __MocFM_2WayEdgeRefine(ctrl, graph, tpwgts, 6L);
#line 143
    __MocBalance2Way(ctrl, graph, tpwgts, (float )1.02);
#line 144
    __MocFM_2WayEdgeRefine(ctrl, graph, tpwgts, 6L);
    }
#line 153
    if (bestcut >= graph->mincut) {
      {
#line 154
      bestcut = graph->mincut;
#line 155
      memcpy((void */* __restrict  */)((void *)bestwhere), (void const   */* __restrict  */)((void *)where),
             sizeof(idxtype ) * (unsigned long )nvtxs);
      }
#line 156
      if (bestcut == 0L) {
#line 157
        goto while_break;
      }
    }
#line 124
    nbfs --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 161
  graph->mincut = bestcut;
#line 162
  memcpy((void */* __restrict  */)((void *)where), (void const   */* __restrict  */)((void *)bestwhere),
         sizeof(idxtype ) * (unsigned long )nvtxs);
#line 164
  __GKfree(& bestwhere, & perm, (void **)0);
  }
#line 165
  return;
}
}
#line 180
long SelectQueueOneWay(long ncon , float *npwgts , float *tpwgts , long from , PQueueType (*queues)[2] ) ;
#line 178 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/minitpart.c"
void __MocInit2WayBalance(CtrlType *ctrl , GraphType *graph , float *tpwgts ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long l ;
  long kwgt ;
  long nvtxs ;
  long nbnd ;
  long ncon ;
  long nswaps ;
  long from ;
  long to ;
  long cnum ;
  long tmp ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *id ;
  idxtype *ed ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *perm ;
  idxtype *qnum ;
  float *nvwgt ;
  float *npwgts ;
  PQueueType parts[16][2] ;
  long higain ;
  long oldgain ;
  long mincut ;
  float tmp___0 ;
  long tmp___1 ;
  float tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  float tmp___5 ;

  {
  {
#line 188
  nvtxs = graph->nvtxs;
#line 189
  ncon = graph->ncon;
#line 190
  xadj = graph->xadj;
#line 191
  adjncy = graph->adjncy;
#line 192
  nvwgt = graph->nvwgt;
#line 193
  adjwgt = graph->adjwgt;
#line 194
  where = graph->where;
#line 195
  id = graph->id;
#line 196
  ed = graph->ed;
#line 197
  npwgts = graph->npwgts;
#line 198
  bndptr = graph->bndptr;
#line 199
  bndind = graph->bndind;
#line 201
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 202
  qnum = __idxwspacemalloc(ctrl, nvtxs);
#line 205
  from = 1L;
#line 206
  to = (from + 1L) % 2L;
  }
#line 208
  if (ctrl->dbglvl & 8L) {
    {
#line 209
    printf((char const   */* __restrict  */)"Parts: [");
#line 210
    l = 0L;
    }
    {
#line 210
    while (1) {
      while_continue: /* CIL Label */ ;
#line 210
      if (! (l < ncon)) {
#line 210
        goto while_break;
      }
      {
#line 211
      printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
             (double )*(npwgts + (ncon + l)));
#line 210
      l ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 212
    tmp___0 = __Compute2WayHLoadImbalance(ncon, npwgts, tpwgts);
#line 212
    printf((char const   */* __restrict  */)"] T[%.3f %.3f], Nv-Nb[%5ld, %5ld]. ICut: %6ld, LB: %.3f [B]\n",
           (double )*(tpwgts + 0), (double )*(tpwgts + 1), graph->nvtxs, graph->nbnd,
           graph->mincut, (double )tmp___0);
    }
  }
#line 217
  i = 0L;
  {
#line 217
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 217
    if (! (i < ncon)) {
#line 217
      goto while_break___0;
    }
    {
#line 218
    __PQueueInit(ctrl, & parts[i][0], nvtxs, 501L);
#line 219
    __PQueueInit(ctrl, & parts[i][1], nvtxs, 501L);
#line 217
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 227
  i = 0L;
  {
#line 227
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 227
    if (! (i < nvtxs)) {
#line 227
      goto while_break___1;
    }
    {
#line 228
    *(qnum + i) = __samax(ncon, nvwgt + i * ncon);
#line 227
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 231
  __RandomPermute(nvtxs, perm, 1L);
#line 232
  ii = 0L;
  }
  {
#line 232
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 232
    if (! (ii < nvtxs)) {
#line 232
      goto while_break___2;
    }
#line 233
    i = *(perm + ii);
#line 234
    if (*(where + i) == from) {
#line 235
      if (*(ed + i) > 0L) {
        {
#line 236
        __PQueueInsert(& parts[*(qnum + i)][0], i, *(ed + i) - *(id + i));
        }
      } else {
        {
#line 238
        __PQueueInsert(& parts[*(qnum + i)][1], i, *(ed + i) - *(id + i));
        }
      }
    }
#line 232
    ii ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 243
  mincut = graph->mincut;
#line 244
  nbnd = graph->nbnd;
#line 245
  nswaps = 0L;
  {
#line 245
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 245
    if (! (nswaps < nvtxs)) {
#line 245
      goto while_break___3;
    }
    {
#line 246
    tmp___1 = __AreAnyVwgtsBelow(ncon, (float )1.0, npwgts + from * ncon, (float )0.0,
                                 nvwgt, *(tpwgts + from));
    }
#line 246
    if (tmp___1) {
#line 247
      goto while_break___3;
    }
    {
#line 249
    cnum = SelectQueueOneWay(ncon, npwgts, tpwgts, from, (PQueueType (*)[2])(parts));
    }
#line 249
    if (cnum == -1L) {
#line 250
      goto while_break___3;
    }
    {
#line 252
    higain = __PQueueGetMax(& parts[cnum][0]);
    }
#line 252
    if (higain == -1L) {
      {
#line 253
      higain = __PQueueGetMax(& parts[cnum][1]);
      }
    }
    {
#line 255
    mincut -= *(ed + higain) - *(id + higain);
#line 256
    __saxpy(ncon, (float )1.0, nvwgt + higain * ncon, 1L, npwgts + to * ncon, 1L);
#line 257
    __saxpy(ncon, (float )(- 1.0), nvwgt + higain * ncon, 1L, npwgts + from * ncon,
            1L);
#line 259
    *(where + higain) = to;
    }
#line 261
    if (ctrl->dbglvl & 32L) {
      {
#line 262
      printf((char const   */* __restrict  */)"Moved %6ld from %ld(%ld). [%5ld] %5ld, NPwgts: ",
             higain, from, cnum, *(ed + higain) - *(id + higain), mincut);
#line 263
      l = 0L;
      }
      {
#line 263
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 263
        if (! (l < ncon)) {
#line 263
          goto while_break___4;
        }
        {
#line 264
        printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
               (double )*(npwgts + (ncon + l)));
#line 263
        l ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 265
      tmp___2 = __Compute2WayHLoadImbalance(ncon, npwgts, tpwgts);
#line 265
      printf((char const   */* __restrict  */)", LB: %.3f\n", (double )tmp___2);
      }
#line 266
      if (*(ed + higain) == 0L) {
#line 266
        if (*(id + higain) > 0L) {
          {
#line 267
          printf((char const   */* __restrict  */)"\t Pulled from the interior!\n");
          }
        }
      }
    }
    {
#line 274
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 274
      tmp = *(id + higain);
#line 274
      *(id + higain) = *(ed + higain);
#line 274
      *(ed + higain) = tmp;
#line 274
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 275
    if (*(ed + higain) == 0L) {
#line 275
      if (*(bndptr + higain) != -1L) {
#line 275
        if (*(xadj + higain) < *(xadj + (higain + 1L))) {
          {
#line 276
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 276
            nbnd --;
#line 276
            *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 276
            *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 276
            *(bndptr + higain) = (idxtype )-1;
#line 276
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
      }
    }
#line 277
    if (*(ed + higain) > 0L) {
#line 277
      if (*(bndptr + higain) == -1L) {
        {
#line 278
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 278
          *(bndind + nbnd) = higain;
#line 278
          tmp___3 = nbnd;
#line 278
          nbnd ++;
#line 278
          *(bndptr + higain) = tmp___3;
#line 278
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    }
#line 280
    j = *(xadj + higain);
    {
#line 280
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 280
      if (! (j < *(xadj + (higain + 1L)))) {
#line 280
        goto while_break___8;
      }
#line 281
      k = *(adjncy + j);
#line 282
      oldgain = *(ed + k) - *(id + k);
#line 284
      if (to == *(where + k)) {
#line 284
        kwgt = *(adjwgt + j);
      } else {
#line 284
        kwgt = - *(adjwgt + j);
      }
      {
#line 285
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 285
        *(id + k) += kwgt;
#line 285
        *(ed + k) -= kwgt;
#line 285
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 288
      if (*(where + k) == from) {
#line 289
        if (*(ed + k) > 0L) {
#line 289
          if (*(bndptr + k) == -1L) {
            {
#line 290
            __PQueueDelete(& parts[*(qnum + k)][1], k, oldgain);
#line 291
            __PQueueInsert(& parts[*(qnum + k)][0], k, *(ed + k) - *(id + k));
            }
          } else {
#line 289
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 294
          if (*(bndptr + k) == -1L) {
            {
#line 295
            printf((char const   */* __restrict  */)"What you thought was wrong!\n");
            }
          }
          {
#line 296
          __PQueueUpdate(& parts[*(qnum + k)][0], k, oldgain, *(ed + k) - *(id + k));
          }
        }
      }
#line 301
      if (*(ed + k) == 0L) {
#line 301
        if (*(bndptr + k) != -1L) {
          {
#line 302
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 302
            nbnd --;
#line 302
            *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 302
            *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 302
            *(bndptr + k) = (idxtype )-1;
#line 302
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
        } else {
#line 301
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 303
      if (*(ed + k) > 0L) {
#line 303
        if (*(bndptr + k) == -1L) {
          {
#line 304
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 304
            *(bndind + nbnd) = k;
#line 304
            tmp___4 = nbnd;
#line 304
            nbnd ++;
#line 304
            *(bndptr + k) = tmp___4;
#line 304
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
        }
      }
#line 280
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 245
    nswaps ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 311
  if (ctrl->dbglvl & 8L) {
    {
#line 312
    printf((char const   */* __restrict  */)"\tMincut: %6ld, NBND: %6ld, NPwgts: ",
           mincut, nbnd);
#line 313
    l = 0L;
    }
    {
#line 313
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 313
      if (! (l < ncon)) {
#line 313
        goto while_break___12;
      }
      {
#line 314
      printf((char const   */* __restrict  */)"(%.3f, %.3f) ", (double )*(npwgts + l),
             (double )*(npwgts + (ncon + l)));
#line 313
      l ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 315
    tmp___5 = __Compute2WayHLoadImbalance(ncon, npwgts, tpwgts);
#line 315
    printf((char const   */* __restrict  */)", LB: %.3f\n", (double )tmp___5);
    }
  }
#line 318
  graph->mincut = mincut;
#line 319
  graph->nbnd = nbnd;
#line 321
  i = 0L;
  {
#line 321
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 321
    if (! (i < ncon)) {
#line 321
      goto while_break___13;
    }
    {
#line 322
    __PQueueFree(ctrl, & parts[i][0]);
#line 323
    __PQueueFree(ctrl, & parts[i][1]);
#line 321
    i ++;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 329
  __idxwspacefree(ctrl, nvtxs);
#line 330
  __idxwspacefree(ctrl, nvtxs);
  }
#line 331
  return;
}
}
#line 340 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/minitpart.c"
long SelectQueueOneWay(long ncon , float *npwgts , float *tpwgts , long from , PQueueType (*queues)[2] ) 
{ 
  long i ;
  long cnum ;
  float max ;
  long tmp ;
  long tmp___0 ;

  {
#line 342
  cnum = -1L;
#line 343
  max = (float )0.0;
#line 345
  i = 0L;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! (i < ncon)) {
#line 345
      goto while_break;
    }
#line 346
    if (*(npwgts + (from * ncon + i)) - *(tpwgts + from) >= max) {
      {
#line 346
      tmp = PQueueGetSize(& (*(queues + i))[0]);
#line 346
      tmp___0 = PQueueGetSize(& (*(queues + i))[1]);
      }
#line 346
      if (tmp + tmp___0 > 0L) {
#line 348
        max = *(npwgts + (from * ncon + i)) - *(tpwgts + 0);
#line 349
        cnum = i;
      }
    }
#line 345
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  return (cnum);
}
}
#line 25 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/bucketsort.c"
void __BucketSortKeysInc(long n , long max , idxtype *keys , idxtype *tperm , idxtype *perm ) 
{ 
  long i ;
  long ii ;
  idxtype *counts ;
  idxtype tmp ;

  {
  {
#line 30
  counts = __idxsmalloc(max + 2L, (idxtype )0, (char *)"BucketSortKeysInc: counts");
#line 32
  i = 0L;
  }
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! (i < n)) {
#line 32
      goto while_break;
    }
#line 33
    (*(counts + *(keys + i))) ++;
#line 32
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 34
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 34
    i = 1L;
    {
#line 34
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 34
      if (! (i < max + 1L)) {
#line 34
        goto while_break___1;
      }
#line 34
      *(counts + i) += *(counts + (i - 1L));
#line 34
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 34
    i = max + 1L;
    {
#line 34
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 34
      if (! (i > 0L)) {
#line 34
        goto while_break___2;
      }
#line 34
      *(counts + i) = *(counts + (i - 1L));
#line 34
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 34
    *(counts + 0) = (idxtype )0;
#line 34
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 36
  ii = 0L;
  {
#line 36
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 36
    if (! (ii < n)) {
#line 36
      goto while_break___3;
    }
#line 37
    i = *(tperm + ii);
#line 38
    tmp = *(counts + *(keys + i));
#line 38
    (*(counts + *(keys + i))) ++;
#line 38
    *(perm + tmp) = i;
#line 36
    ii ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 41
  free((void *)counts);
  }
#line 42
  return;
}
}
#line 155 "./proto.h"
long __MlevelVolKWayPartitioning(CtrlType *ctrl , GraphType *graph , long nparts ,
                                 idxtype *part , float *tpwgts , float ubfactor ) ;
#line 22 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kvmetis.c"
void METIS_PartGraphVKway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                          long *options , long *volume , idxtype *part ) 
{ 
  long i ;
  float *tpwgts ;

  {
  {
#line 29
  tpwgts = __fmalloc(*nparts, (char *)"KMETIS: tpwgts");
#line 30
  i = 0L;
  }
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (i < *nparts)) {
#line 30
      goto while_break;
    }
#line 31
    *(tpwgts + i) = (float )(1.0 / (1.0 * (double )*nparts));
#line 30
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 33
  METIS_WPartGraphVKway(nvtxs, xadj, adjncy, vwgt, vsize, wgtflag, numflag, nparts,
                        tpwgts, options, volume, part);
#line 36
  free((void *)tpwgts);
  }
#line 37
  return;
}
}
#line 43 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kvmetis.c"
void METIS_WPartGraphVKway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                           idxtype *vsize , long *wgtflag , long *numflag , long *nparts ,
                           float *tpwgts , long *options , long *volume , idxtype *part ) 
{ 
  GraphType graph ;
  CtrlType ctrl ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
#line 51
  if (*numflag == 1L) {
    {
#line 52
    __Change2CNumbering(*nvtxs, xadj, adjncy);
    }
  }
  {
#line 54
  __VolSetUpGraph(& graph, 6L, *nvtxs, 1L, xadj, adjncy, vwgt, vsize, *wgtflag);
  }
#line 56
  if (*(options + 0) == 0L) {
#line 57
    ctrl.CType = 3L;
#line 58
    ctrl.IType = 1L;
#line 59
    ctrl.RType = 1L;
#line 60
    ctrl.dbglvl = 0L;
  } else {
#line 63
    ctrl.CType = *(options + 1);
#line 64
    ctrl.IType = *(options + 2);
#line 65
    ctrl.RType = *(options + 3);
#line 66
    ctrl.dbglvl = *(options + 4);
  }
  {
#line 68
  ctrl.optype = 6L;
#line 69
  tmp___1 = __ilog2(*nparts);
  }
#line 69
  if (*nvtxs / (40L * tmp___1) >= 20L * *nparts) {
    {
#line 69
    tmp___0 = __ilog2(*nparts);
#line 69
    ctrl.CoarsenTo = *nvtxs / (40L * tmp___0);
    }
  } else {
#line 69
    ctrl.CoarsenTo = 20L * *nparts;
  }
#line 70
  if (graph.vwgt) {
    {
#line 70
    tmp___2 = __idxsum(*nvtxs, graph.vwgt);
#line 70
    tmp___3 = tmp___2;
    }
  } else {
#line 70
    tmp___3 = *nvtxs;
  }
  {
#line 70
  ctrl.maxvwgt = (long )(1.5 * (double )(tmp___3 / ctrl.CoarsenTo));
#line 72
  __InitRandom(-1L);
#line 74
  __AllocateWorkSpace(& ctrl, & graph, *nparts);
  }
#line 76
  if (ctrl.dbglvl & 1L) {
    {
#line 76
    __InitTimers(& ctrl);
    }
  }
#line 77
  if (ctrl.dbglvl & 1L) {
    {
#line 77
    tmp___4 = __seconds();
#line 77
    ctrl.TotalTmr -= tmp___4;
    }
  }
  {
#line 79
  *volume = __MlevelVolKWayPartitioning(& ctrl, & graph, *nparts, part, tpwgts, (float )1.03);
  }
#line 81
  if (ctrl.dbglvl & 1L) {
    {
#line 81
    tmp___5 = __seconds();
#line 81
    ctrl.TotalTmr += tmp___5;
    }
  }
#line 82
  if (ctrl.dbglvl & 1L) {
    {
#line 82
    __PrintTimers(& ctrl);
    }
  }
  {
#line 84
  __FreeWorkSpace(& ctrl, & graph);
  }
#line 86
  if (*numflag == 1L) {
    {
#line 87
    __Change2FNumbering(*nvtxs, xadj, adjncy, part);
    }
  }
#line 88
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kvmetis.c"
long __MlevelVolKWayPartitioning(CtrlType *ctrl , GraphType *graph , long nparts ,
                                 idxtype *part , float *tpwgts , float ubfactor ) 
{ 
  GraphType *cgraph ;
  long wgtflag ;
  long numflag ;
  long options[10] ;
  long edgecut ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 99
  wgtflag = 3L;
#line 99
  numflag = 0L;
#line 101
  cgraph = __Coarsen2Way(ctrl, graph);
  }
#line 103
  if (ctrl->dbglvl & 1L) {
    {
#line 103
    tmp = __seconds();
#line 103
    ctrl->InitPartTmr -= tmp;
    }
  }
  {
#line 104
  __AllocateVolKWayPartitionMemory(ctrl, cgraph, nparts);
#line 106
  options[0] = 1L;
#line 107
  options[1] = 4L;
#line 108
  options[2] = 1L;
#line 109
  options[3] = 1L;
#line 110
  options[4] = 0L;
#line 112
  METIS_WPartGraphRecursive(& cgraph->nvtxs, cgraph->xadj, cgraph->adjncy, cgraph->vwgt,
                            cgraph->adjwgt, & wgtflag, & numflag, & nparts, tpwgts,
                            options, & edgecut, cgraph->where);
  }
#line 116
  if (ctrl->dbglvl & 1L) {
    {
#line 116
    tmp___0 = __seconds();
#line 116
    ctrl->InitPartTmr += tmp___0;
    }
  }
#line 117
  if (ctrl->dbglvl & 16L) {
    {
#line 117
    printf((char const   */* __restrict  */)"Initial %ld-way partitioning cut: %ld\n",
           nparts, edgecut);
    }
  }
#line 119
  if (ctrl->dbglvl & 64L) {
    {
#line 119
    __ComputePartitionInfo(cgraph, nparts, cgraph->where);
    }
  }
  {
#line 121
  __RefineVolKWay(ctrl, graph, cgraph, nparts, tpwgts, ubfactor);
#line 123
  memcpy((void */* __restrict  */)((void *)part), (void const   */* __restrict  */)((void *)graph->where),
         sizeof(idxtype ) * (unsigned long )graph->nvtxs);
#line 125
  __GKfree(& graph->gdata, & graph->rdata, (void **)0);
  }
#line 127
  return (graph->minvol);
}
}
#line 411 "./proto.h"
void __Random_KWayEdgeRefineMConn(CtrlType *ctrl , GraphType *graph , long nparts ,
                                  float *tpwgts , float ubfactor , long npasses ,
                                  long ffactor ) ;
#line 412
void __Greedy_KWayEdgeBalanceMConn(CtrlType *ctrl , GraphType *graph , long nparts ,
                                   float *tpwgts , float ubfactor , long npasses ) ;
#line 413
void __PrintSubDomainGraph(GraphType *graph , long nparts , idxtype *where ) ;
#line 414
void __ComputeSubDomainGraph(GraphType *graph , long nparts , idxtype *pmat , idxtype *ndoms ) ;
#line 415
void __EliminateSubDomainEdges(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ) ;
#line 416
void __MoveGroupMConn(CtrlType *ctrl , GraphType *graph , idxtype *ndoms , idxtype *pmat ,
                      long nparts , long to , long nind , idxtype *ind ) ;
#line 417
void __EliminateComponents(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ,
                           float ubfactor ) ;
#line 418
void __MoveGroup(CtrlType *ctrl , GraphType *graph , long nparts , long to , long gid ,
                 idxtype *ptr , idxtype *ind ) ;
#line 22 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/subdomains.c"
void __Random_KWayEdgeRefineMConn(CtrlType *ctrl , GraphType *graph , long nparts ,
                                  float *tpwgts , float ubfactor , long npasses ,
                                  long ffactor ) 
{ 
  long i ;
  long ii ;
  long iii ;
  long j ;
  long k ;
  long l ;
  long pass ;
  long nvtxs ;
  long nmoves ;
  long nbnd ;
  long tvwgt ;
  long myndegrees ;
  long from ;
  long me ;
  long to ;
  long oldcut ;
  long vwgt ;
  long gain ;
  long maxndoms ;
  long nadd ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *perm ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *minwgt ;
  idxtype *maxwgt ;
  idxtype *itpwgts ;
  idxtype *phtable ;
  idxtype *pmat ;
  idxtype *pmatptr ;
  idxtype *ndoms ;
  EDegreeType *myedegrees ;
  RInfoType *myrinfo ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;

  {
  {
#line 33
  nvtxs = graph->nvtxs;
#line 34
  xadj = graph->xadj;
#line 35
  adjncy = graph->adjncy;
#line 36
  adjwgt = graph->adjwgt;
#line 38
  bndptr = graph->bndptr;
#line 39
  bndind = graph->bndind;
#line 41
  where = graph->where;
#line 42
  pwgts = graph->pwgts;
#line 44
  pmat = ctrl->wspace.pmat;
#line 45
  phtable = __idxwspacemalloc(ctrl, nparts);
#line 46
  ndoms = __idxwspacemalloc(ctrl, nparts);
#line 48
  __ComputeSubDomainGraph(graph, nparts, pmat, ndoms);
#line 51
  minwgt = __idxwspacemalloc(ctrl, nparts);
#line 52
  maxwgt = __idxwspacemalloc(ctrl, nparts);
#line 53
  itpwgts = __idxwspacemalloc(ctrl, nparts);
#line 54
  tvwgt = __idxsum(nparts, pwgts);
#line 57
  i = 0L;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < nparts)) {
#line 57
      goto while_break;
    }
#line 58
    *(itpwgts + i) = (idxtype )(*(tpwgts + i) * (float )tvwgt);
#line 59
    *(maxwgt + i) = (idxtype )((*(tpwgts + i) * (float )tvwgt) * ubfactor);
#line 60
    *(minwgt + i) = (idxtype )((double )(*(tpwgts + i) * (float )tvwgt) * (1.0 / (double )ubfactor));
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 63
  perm = __idxwspacemalloc(ctrl, nvtxs);
  }
#line 65
  if (ctrl->dbglvl & 8L) {
    {
#line 65
    tmp = __idxamax(nparts, pwgts);
#line 65
    tmp___0 = __idxamax(nparts, pwgts);
#line 65
    tmp___1 = __idxamin(nparts, pwgts);
#line 65
    printf((char const   */* __restrict  */)"Partitions: [%6ld %6ld]-[%6ld %6ld], Balance: %5.3f, Nv-Nb[%6ld %6ld]. Cut: %6ld\n",
           *(pwgts + tmp___1), *(pwgts + tmp___0), *(minwgt + 0), *(maxwgt + 0), ((1.0 * (double )nparts) * (double )*(pwgts + tmp)) / (double )tvwgt,
           graph->nvtxs, graph->nbnd, graph->mincut);
    }
  }
#line 71
  pass = 0L;
  {
#line 71
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 71
    if (! (pass < npasses)) {
#line 71
      goto while_break___0;
    }
    {
#line 74
    tmp___2 = __idxamax(nparts, ndoms);
#line 74
    maxndoms = *(ndoms + tmp___2);
#line 76
    oldcut = graph->mincut;
#line 77
    nbnd = graph->nbnd;
#line 79
    __RandomPermute(nbnd, perm, 1L);
#line 80
    iii = 0L;
#line 80
    nmoves = iii;
    }
    {
#line 80
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 80
      if (! (iii < graph->nbnd)) {
#line 80
        goto while_break___1;
      }
#line 81
      ii = *(perm + iii);
#line 82
      if (ii >= nbnd) {
#line 83
        goto __Cont;
      }
#line 84
      i = *(bndind + ii);
#line 86
      myrinfo = graph->rinfo + i;
#line 88
      if (myrinfo->ed >= myrinfo->id) {
#line 89
        from = *(where + i);
#line 90
        vwgt = *(graph->vwgt + i);
#line 92
        if (myrinfo->id > 0L) {
#line 92
          if (*(pwgts + from) - vwgt < *(minwgt + from)) {
#line 93
            goto __Cont;
          }
        }
#line 95
        myedegrees = myrinfo->edegrees;
#line 96
        myndegrees = myrinfo->ndegrees;
#line 99
        j = 0L;
        {
#line 99
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 99
          if (! (j < myndegrees)) {
#line 99
            goto while_break___2;
          }
#line 100
          to = (myedegrees + j)->pid;
#line 101
          *(phtable + to) = (idxtype )1;
#line 102
          pmatptr = pmat + to * nparts;
#line 103
          nadd = 0L;
#line 103
          k = 0L;
          {
#line 103
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 103
            if (! (k < myndegrees)) {
#line 103
              goto while_break___3;
            }
#line 104
            if (k == j) {
#line 105
              goto __Cont___0;
            }
#line 107
            l = (myedegrees + k)->pid;
#line 108
            if (*(pmatptr + l) == 0L) {
#line 109
              if (*(ndoms + l) > maxndoms - 1L) {
#line 110
                *(phtable + to) = (idxtype )0;
#line 111
                nadd = maxndoms;
#line 112
                goto while_break___3;
              }
#line 114
              nadd ++;
            }
            __Cont___0: /* CIL Label */ 
#line 103
            k ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 117
          if (*(ndoms + to) + nadd > maxndoms) {
#line 118
            *(phtable + to) = (idxtype )0;
          }
#line 119
          if (nadd == 0L) {
#line 120
            *(phtable + to) = (idxtype )2;
          }
#line 99
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 124
        j = myrinfo->id;
#line 125
        k = 0L;
        {
#line 125
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 125
          if (! (k < myndegrees)) {
#line 125
            goto while_break___4;
          }
#line 126
          to = (myedegrees + k)->pid;
#line 127
          if (! *(phtable + to)) {
#line 128
            goto __Cont___1;
          }
#line 129
          gain = (myedegrees + k)->ed - j;
#line 130
          if (*(pwgts + to) + vwgt <= *(maxwgt + to) + ffactor * gain) {
#line 130
            if (gain >= 0L) {
#line 131
              goto while_break___4;
            }
          }
          __Cont___1: /* CIL Label */ 
#line 125
          k ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 133
        if (k == myndegrees) {
#line 134
          goto __Cont;
        }
#line 136
        j = k + 1L;
        {
#line 136
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 136
          if (! (j < myndegrees)) {
#line 136
            goto while_break___5;
          }
#line 137
          to = (myedegrees + j)->pid;
#line 138
          if (! *(phtable + to)) {
#line 139
            goto __Cont___2;
          }
#line 140
          if ((myedegrees + j)->ed > (myedegrees + k)->ed) {
#line 140
            if (*(pwgts + to) + vwgt <= *(maxwgt + to)) {
#line 143
              k = j;
            } else {
#line 140
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 140
          if ((myedegrees + j)->ed == (myedegrees + k)->ed) {
#line 140
            if (*(itpwgts + (myedegrees + k)->pid) * *(pwgts + to) < *(itpwgts + to) * *(pwgts + (myedegrees + k)->pid)) {
#line 143
              k = j;
            }
          }
          __Cont___2: /* CIL Label */ 
#line 136
          j ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 146
        to = (myedegrees + k)->pid;
#line 148
        j = 0L;
#line 149
        if ((myedegrees + k)->ed - myrinfo->id > 0L) {
#line 150
          j = 1L;
        } else
#line 151
        if ((myedegrees + k)->ed - myrinfo->id == 0L) {
#line 152
          if (*(phtable + (myedegrees + k)->pid) == 2L) {
#line 153
            j = 1L;
          } else
#line 152
          if (*(pwgts + from) >= *(maxwgt + from)) {
#line 153
            j = 1L;
          } else
#line 152
          if (*(itpwgts + from) * (*(pwgts + to) + vwgt) < *(itpwgts + to) * *(pwgts + from)) {
#line 153
            j = 1L;
          }
        }
#line 155
        if (j == 0L) {
#line 156
          goto __Cont;
        }
#line 161
        graph->mincut -= (myedegrees + k)->ed - myrinfo->id;
#line 163
        if (ctrl->dbglvl & 32L) {
          {
#line 163
          printf((char const   */* __restrict  */)"\t\tMoving %6ld to %3ld. Gain: %4ld. Cut: %6ld\n",
                 i, to, (myedegrees + k)->ed - myrinfo->id, graph->mincut);
          }
        }
#line 166
        *(pmat + (from * nparts + to)) += myrinfo->id - (myedegrees + k)->ed;
#line 167
        *(pmat + (to * nparts + from)) += myrinfo->id - (myedegrees + k)->ed;
#line 168
        if (*(pmat + (from * nparts + to)) == 0L) {
#line 169
          (*(ndoms + from)) --;
#line 170
          if (*(ndoms + from) + 1L == maxndoms) {
            {
#line 171
            tmp___3 = __idxamax(nparts, ndoms);
#line 171
            maxndoms = *(ndoms + tmp___3);
            }
          }
        }
#line 173
        if (*(pmat + (to * nparts + from)) == 0L) {
#line 174
          (*(ndoms + to)) --;
#line 175
          if (*(ndoms + to) + 1L == maxndoms) {
            {
#line 176
            tmp___4 = __idxamax(nparts, ndoms);
#line 176
            maxndoms = *(ndoms + tmp___4);
            }
          }
        }
#line 180
        *(where + i) = to;
        {
#line 181
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 181
          *(pwgts + to) += vwgt;
#line 181
          *(pwgts + from) -= vwgt;
#line 181
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 182
        myrinfo->ed += myrinfo->id - (myedegrees + k)->ed;
        {
#line 183
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 183
          j = myrinfo->id;
#line 183
          myrinfo->id = (myedegrees + k)->ed;
#line 183
          (myedegrees + k)->ed = j;
#line 183
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 184
        if ((myedegrees + k)->ed == 0L) {
#line 185
          (myrinfo->ndegrees) --;
#line 185
          *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
        } else {
#line 187
          (myedegrees + k)->pid = from;
        }
#line 189
        if (myrinfo->ed - myrinfo->id < 0L) {
          {
#line 190
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 190
            nbnd --;
#line 190
            *(bndind + *(bndptr + i)) = *(bndind + nbnd);
#line 190
            *(bndptr + *(bndind + nbnd)) = *(bndptr + i);
#line 190
            *(bndptr + i) = (idxtype )-1;
#line 190
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
#line 193
        j = *(xadj + i);
        {
#line 193
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 193
          if (! (j < *(xadj + (i + 1L)))) {
#line 193
            goto while_break___9;
          }
#line 194
          ii = *(adjncy + j);
#line 195
          me = *(where + ii);
#line 197
          myrinfo = graph->rinfo + ii;
#line 198
          if ((unsigned long )myrinfo->edegrees == (unsigned long )((void *)0)) {
#line 199
            myrinfo->edegrees = ctrl->wspace.edegrees + ctrl->wspace.cdegree;
#line 200
            ctrl->wspace.cdegree += *(xadj + (ii + 1L)) - *(xadj + ii);
          }
#line 202
          myedegrees = myrinfo->edegrees;
#line 206
          if (me == from) {
            {
#line 207
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 207
              myrinfo->ed += *(adjwgt + j);
#line 207
              myrinfo->id -= *(adjwgt + j);
#line 207
              goto while_break___10;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 209
            if (myrinfo->ed - myrinfo->id >= 0L) {
#line 209
              if (*(bndptr + ii) == -1L) {
                {
#line 210
                while (1) {
                  while_continue___11: /* CIL Label */ ;
#line 210
                  *(bndind + nbnd) = ii;
#line 210
                  tmp___5 = nbnd;
#line 210
                  nbnd ++;
#line 210
                  *(bndptr + ii) = tmp___5;
#line 210
                  goto while_break___11;
                }
                while_break___11: /* CIL Label */ ;
                }
              }
            }
          } else
#line 212
          if (me == to) {
            {
#line 213
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 213
              myrinfo->id += *(adjwgt + j);
#line 213
              myrinfo->ed -= *(adjwgt + j);
#line 213
              goto while_break___12;
            }
            while_break___12: /* CIL Label */ ;
            }
#line 215
            if (myrinfo->ed - myrinfo->id < 0L) {
#line 215
              if (*(bndptr + ii) != -1L) {
                {
#line 216
                while (1) {
                  while_continue___13: /* CIL Label */ ;
#line 216
                  nbnd --;
#line 216
                  *(bndind + *(bndptr + ii)) = *(bndind + nbnd);
#line 216
                  *(bndptr + *(bndind + nbnd)) = *(bndptr + ii);
#line 216
                  *(bndptr + ii) = (idxtype )-1;
#line 216
                  goto while_break___13;
                }
                while_break___13: /* CIL Label */ ;
                }
              }
            }
          }
#line 220
          if (me != from) {
#line 221
            k = 0L;
            {
#line 221
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 221
              if (! (k < myrinfo->ndegrees)) {
#line 221
                goto while_break___14;
              }
#line 222
              if ((myedegrees + k)->pid == from) {
#line 223
                if ((myedegrees + k)->ed == *(adjwgt + j)) {
#line 224
                  (myrinfo->ndegrees) --;
#line 224
                  *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
                } else {
#line 226
                  (myedegrees + k)->ed -= *(adjwgt + j);
                }
#line 227
                goto while_break___14;
              }
#line 221
              k ++;
            }
            while_break___14: /* CIL Label */ ;
            }
          }
#line 233
          if (me != to) {
#line 234
            k = 0L;
            {
#line 234
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 234
              if (! (k < myrinfo->ndegrees)) {
#line 234
                goto while_break___15;
              }
#line 235
              if ((myedegrees + k)->pid == to) {
#line 236
                (myedegrees + k)->ed += *(adjwgt + j);
#line 237
                goto while_break___15;
              }
#line 234
              k ++;
            }
            while_break___15: /* CIL Label */ ;
            }
#line 240
            if (k == myrinfo->ndegrees) {
#line 241
              (myedegrees + myrinfo->ndegrees)->pid = to;
#line 242
              tmp___6 = myrinfo->ndegrees;
#line 242
              (myrinfo->ndegrees) ++;
#line 242
              (myedegrees + tmp___6)->ed = *(adjwgt + j);
            }
          }
#line 247
          if (me != from) {
#line 247
            if (me != to) {
#line 248
              *(pmat + (me * nparts + from)) -= *(adjwgt + j);
#line 249
              *(pmat + (from * nparts + me)) -= *(adjwgt + j);
#line 250
              if (*(pmat + (me * nparts + from)) == 0L) {
#line 251
                (*(ndoms + me)) --;
#line 252
                if (*(ndoms + me) + 1L == maxndoms) {
                  {
#line 253
                  tmp___7 = __idxamax(nparts, ndoms);
#line 253
                  maxndoms = *(ndoms + tmp___7);
                  }
                }
              }
#line 255
              if (*(pmat + (from * nparts + me)) == 0L) {
#line 256
                (*(ndoms + from)) --;
#line 257
                if (*(ndoms + from) + 1L == maxndoms) {
                  {
#line 258
                  tmp___8 = __idxamax(nparts, ndoms);
#line 258
                  maxndoms = *(ndoms + tmp___8);
                  }
                }
              }
#line 261
              if (*(pmat + (me * nparts + to)) == 0L) {
#line 262
                (*(ndoms + me)) ++;
#line 263
                if (*(ndoms + me) > maxndoms) {
                  {
#line 264
                  printf((char const   */* __restrict  */)"You just increased the maxndoms: %ld %ld\n",
                         *(ndoms + me), maxndoms);
#line 265
                  maxndoms = *(ndoms + me);
                  }
                }
              }
#line 268
              if (*(pmat + (to * nparts + me)) == 0L) {
#line 269
                (*(ndoms + to)) ++;
#line 270
                if (*(ndoms + to) > maxndoms) {
                  {
#line 271
                  printf((char const   */* __restrict  */)"You just increased the maxndoms: %ld %ld\n",
                         *(ndoms + to), maxndoms);
#line 272
                  maxndoms = *(ndoms + to);
                  }
                }
              }
#line 275
              *(pmat + (me * nparts + to)) += *(adjwgt + j);
#line 276
              *(pmat + (to * nparts + me)) += *(adjwgt + j);
            }
          }
#line 193
          j ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 283
        nmoves ++;
      }
      __Cont: /* CIL Label */ 
#line 80
      iii ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 287
    graph->nbnd = nbnd;
#line 289
    if (ctrl->dbglvl & 8L) {
      {
#line 289
      tmp___9 = __idxsum(nparts, ndoms);
#line 289
      tmp___10 = __ComputeVolume(graph, where);
#line 289
      tmp___11 = __idxamax(nparts, pwgts);
#line 289
      tmp___12 = __idxamax(nparts, pwgts);
#line 289
      tmp___13 = __idxamin(nparts, pwgts);
#line 289
      printf((char const   */* __restrict  */)"\t[%6ld %6ld], Balance: %5.3f, Nb: %6ld. Nmoves: %5ld, Cut: %5ld, Vol: %5ld, %ld\n",
             *(pwgts + tmp___13), *(pwgts + tmp___12), ((1.0 * (double )nparts) * (double )*(pwgts + tmp___11)) / (double )tvwgt,
             graph->nbnd, nmoves, graph->mincut, tmp___10, tmp___9);
      }
    }
#line 295
    if (graph->mincut == oldcut) {
#line 296
      goto while_break___0;
    }
#line 71
    pass ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 299
  __idxwspacefree(ctrl, nparts);
#line 300
  __idxwspacefree(ctrl, nparts);
#line 301
  __idxwspacefree(ctrl, nparts);
#line 302
  __idxwspacefree(ctrl, nparts);
#line 303
  __idxwspacefree(ctrl, nparts);
#line 304
  __idxwspacefree(ctrl, nvtxs);
  }
#line 305
  return;
}
}
#line 312 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/subdomains.c"
void __Greedy_KWayEdgeBalanceMConn(CtrlType *ctrl , GraphType *graph , long nparts ,
                                   float *tpwgts , float ubfactor , long npasses ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long l ;
  long pass ;
  long nvtxs ;
  long nbnd ;
  long tvwgt ;
  long myndegrees ;
  long oldgain ;
  long gain ;
  long nmoves ;
  long from ;
  long me ;
  long to ;
  long oldcut ;
  long vwgt ;
  long maxndoms ;
  long nadd ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *perm ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *minwgt ;
  idxtype *maxwgt ;
  idxtype *moved ;
  idxtype *itpwgts ;
  idxtype *phtable ;
  idxtype *pmat ;
  idxtype *pmatptr ;
  idxtype *ndoms ;
  EDegreeType *myedegrees ;
  RInfoType *myrinfo ;
  PQueueType queue ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;

  {
  {
#line 323
  nvtxs = graph->nvtxs;
#line 324
  xadj = graph->xadj;
#line 325
  adjncy = graph->adjncy;
#line 326
  adjwgt = graph->adjwgt;
#line 328
  bndind = graph->bndind;
#line 329
  bndptr = graph->bndptr;
#line 331
  where = graph->where;
#line 332
  pwgts = graph->pwgts;
#line 334
  pmat = ctrl->wspace.pmat;
#line 335
  phtable = __idxwspacemalloc(ctrl, nparts);
#line 336
  ndoms = __idxwspacemalloc(ctrl, nparts);
#line 338
  __ComputeSubDomainGraph(graph, nparts, pmat, ndoms);
#line 342
  minwgt = __idxwspacemalloc(ctrl, nparts);
#line 343
  maxwgt = __idxwspacemalloc(ctrl, nparts);
#line 344
  itpwgts = __idxwspacemalloc(ctrl, nparts);
#line 345
  tvwgt = __idxsum(nparts, pwgts);
#line 348
  i = 0L;
  }
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (i < nparts)) {
#line 348
      goto while_break;
    }
#line 349
    *(itpwgts + i) = (idxtype )(*(tpwgts + i) * (float )tvwgt);
#line 350
    *(maxwgt + i) = (idxtype )((*(tpwgts + i) * (float )tvwgt) * ubfactor);
#line 351
    *(minwgt + i) = (idxtype )((double )(*(tpwgts + i) * (float )tvwgt) * (1.0 / (double )ubfactor));
#line 348
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 354
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 355
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 357
  tmp = __idxamax(nvtxs, graph->adjwgtsum);
#line 357
  __PQueueInit(ctrl, & queue, nvtxs, *(graph->adjwgtsum + tmp));
  }
#line 359
  if (ctrl->dbglvl & 8L) {
    {
#line 359
    tmp___0 = __idxamax(nparts, pwgts);
#line 359
    tmp___1 = __idxamax(nparts, pwgts);
#line 359
    tmp___2 = __idxamin(nparts, pwgts);
#line 359
    printf((char const   */* __restrict  */)"Partitions: [%6ld %6ld]-[%6ld %6ld], Balance: %5.3f, Nv-Nb[%6ld %6ld]. Cut: %6ld [B]\n",
           *(pwgts + tmp___2), *(pwgts + tmp___1), *(minwgt + 0), *(maxwgt + 0), ((1.0 * (double )nparts) * (double )*(pwgts + tmp___0)) / (double )tvwgt,
           graph->nvtxs, graph->nbnd, graph->mincut);
    }
  }
#line 365
  pass = 0L;
  {
#line 365
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 365
    if (! (pass < npasses)) {
#line 365
      goto while_break___0;
    }
#line 369
    i = 0L;
    {
#line 369
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 369
      if (! (i < nparts)) {
#line 369
        goto while_break___1;
      }
#line 370
      if (*(pwgts + i) > *(maxwgt + i)) {
#line 371
        goto while_break___1;
      }
#line 369
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 373
    if (i == nparts) {
#line 374
      goto while_break___0;
    }
    {
#line 376
    __PQueueReset(& queue);
#line 377
    __idxset(nvtxs, (idxtype )-1, moved);
#line 379
    oldcut = graph->mincut;
#line 380
    nbnd = graph->nbnd;
#line 382
    __RandomPermute(nbnd, perm, 1L);
#line 383
    ii = 0L;
    }
    {
#line 383
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 383
      if (! (ii < nbnd)) {
#line 383
        goto while_break___2;
      }
      {
#line 384
      i = *(bndind + *(perm + ii));
#line 385
      __PQueueInsert(& queue, i, (graph->rinfo + i)->ed - (graph->rinfo + i)->id);
#line 386
      *(moved + i) = (idxtype )2;
#line 383
      ii ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 389
    tmp___3 = __idxamax(nparts, ndoms);
#line 389
    maxndoms = *(ndoms + tmp___3);
#line 391
    nmoves = 0L;
    }
    {
#line 391
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 392
      i = __PQueueGetMax(& queue);
      }
#line 392
      if (i == -1L) {
#line 393
        goto while_break___3;
      }
#line 394
      *(moved + i) = (idxtype )1;
#line 396
      myrinfo = graph->rinfo + i;
#line 397
      from = *(where + i);
#line 398
      vwgt = *(graph->vwgt + i);
#line 400
      if (*(pwgts + from) - vwgt < *(minwgt + from)) {
#line 401
        goto __Cont;
      }
#line 403
      myedegrees = myrinfo->edegrees;
#line 404
      myndegrees = myrinfo->ndegrees;
#line 407
      j = 0L;
      {
#line 407
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 407
        if (! (j < myndegrees)) {
#line 407
          goto while_break___4;
        }
#line 408
        to = (myedegrees + j)->pid;
#line 409
        *(phtable + to) = (idxtype )1;
#line 410
        pmatptr = pmat + to * nparts;
#line 411
        nadd = 0L;
#line 411
        k = 0L;
        {
#line 411
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 411
          if (! (k < myndegrees)) {
#line 411
            goto while_break___5;
          }
#line 412
          if (k == j) {
#line 413
            goto __Cont___0;
          }
#line 415
          l = (myedegrees + k)->pid;
#line 416
          if (*(pmatptr + l) == 0L) {
#line 417
            if (*(ndoms + l) > maxndoms - 1L) {
#line 418
              *(phtable + to) = (idxtype )0;
#line 419
              nadd = maxndoms;
#line 420
              goto while_break___5;
            }
#line 422
            nadd ++;
          }
          __Cont___0: /* CIL Label */ 
#line 411
          k ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 425
        if (*(ndoms + to) + nadd > maxndoms) {
#line 426
          *(phtable + to) = (idxtype )0;
        }
#line 407
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 429
      k = 0L;
      {
#line 429
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 429
        if (! (k < myndegrees)) {
#line 429
          goto while_break___6;
        }
#line 430
        to = (myedegrees + k)->pid;
#line 431
        if (! *(phtable + to)) {
#line 432
          goto __Cont___1;
        }
#line 433
        if (*(pwgts + to) + vwgt <= *(maxwgt + to)) {
#line 434
          goto while_break___6;
        } else
#line 433
        if (*(itpwgts + from) * (*(pwgts + to) + vwgt) <= *(itpwgts + to) * *(pwgts + from)) {
#line 434
          goto while_break___6;
        }
        __Cont___1: /* CIL Label */ 
#line 429
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 436
      if (k == myndegrees) {
#line 437
        goto __Cont;
      }
#line 439
      j = k + 1L;
      {
#line 439
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 439
        if (! (j < myndegrees)) {
#line 439
          goto while_break___7;
        }
#line 440
        to = (myedegrees + j)->pid;
#line 441
        if (! *(phtable + to)) {
#line 442
          goto __Cont___2;
        }
#line 443
        if (*(itpwgts + (myedegrees + k)->pid) * *(pwgts + to) < *(itpwgts + to) * *(pwgts + (myedegrees + k)->pid)) {
#line 444
          k = j;
        }
        __Cont___2: /* CIL Label */ 
#line 439
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 447
      to = (myedegrees + k)->pid;
#line 449
      if (*(pwgts + from) < *(maxwgt + from)) {
#line 449
        if (*(pwgts + to) > *(minwgt + to)) {
#line 449
          if ((myedegrees + k)->ed - myrinfo->id < 0L) {
#line 450
            goto __Cont;
          }
        }
      }
#line 455
      graph->mincut -= (myedegrees + k)->ed - myrinfo->id;
#line 457
      if (ctrl->dbglvl & 32L) {
        {
#line 457
        printf((char const   */* __restrict  */)"\t\tMoving %6ld to %3ld. Gain: %4ld. Cut: %6ld\n",
               i, to, (myedegrees + k)->ed - myrinfo->id, graph->mincut);
        }
      }
#line 460
      *(pmat + (from * nparts + to)) += myrinfo->id - (myedegrees + k)->ed;
#line 461
      *(pmat + (to * nparts + from)) += myrinfo->id - (myedegrees + k)->ed;
#line 462
      if (*(pmat + (from * nparts + to)) == 0L) {
#line 463
        (*(ndoms + from)) --;
#line 464
        if (*(ndoms + from) + 1L == maxndoms) {
          {
#line 465
          tmp___4 = __idxamax(nparts, ndoms);
#line 465
          maxndoms = *(ndoms + tmp___4);
          }
        }
      }
#line 467
      if (*(pmat + (to * nparts + from)) == 0L) {
#line 468
        (*(ndoms + to)) --;
#line 469
        if (*(ndoms + to) + 1L == maxndoms) {
          {
#line 470
          tmp___5 = __idxamax(nparts, ndoms);
#line 470
          maxndoms = *(ndoms + tmp___5);
          }
        }
      }
#line 475
      *(where + i) = to;
      {
#line 476
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 476
        *(pwgts + to) += vwgt;
#line 476
        *(pwgts + from) -= vwgt;
#line 476
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 477
      myrinfo->ed += myrinfo->id - (myedegrees + k)->ed;
      {
#line 478
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 478
        j = myrinfo->id;
#line 478
        myrinfo->id = (myedegrees + k)->ed;
#line 478
        (myedegrees + k)->ed = j;
#line 478
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 479
      if ((myedegrees + k)->ed == 0L) {
#line 480
        (myrinfo->ndegrees) --;
#line 480
        *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
      } else {
#line 482
        (myedegrees + k)->pid = from;
      }
#line 484
      if (myrinfo->ed == 0L) {
        {
#line 485
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 485
          nbnd --;
#line 485
          *(bndind + *(bndptr + i)) = *(bndind + nbnd);
#line 485
          *(bndptr + *(bndind + nbnd)) = *(bndptr + i);
#line 485
          *(bndptr + i) = (idxtype )-1;
#line 485
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
#line 488
      j = *(xadj + i);
      {
#line 488
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 488
        if (! (j < *(xadj + (i + 1L)))) {
#line 488
          goto while_break___11;
        }
#line 489
        ii = *(adjncy + j);
#line 490
        me = *(where + ii);
#line 492
        myrinfo = graph->rinfo + ii;
#line 493
        if ((unsigned long )myrinfo->edegrees == (unsigned long )((void *)0)) {
#line 494
          myrinfo->edegrees = ctrl->wspace.edegrees + ctrl->wspace.cdegree;
#line 495
          ctrl->wspace.cdegree += *(xadj + (ii + 1L)) - *(xadj + ii);
        }
#line 497
        myedegrees = myrinfo->edegrees;
#line 501
        oldgain = myrinfo->ed - myrinfo->id;
#line 503
        if (me == from) {
          {
#line 504
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 504
            myrinfo->ed += *(adjwgt + j);
#line 504
            myrinfo->id -= *(adjwgt + j);
#line 504
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 506
          if (myrinfo->ed > 0L) {
#line 506
            if (*(bndptr + ii) == -1L) {
              {
#line 507
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 507
                *(bndind + nbnd) = ii;
#line 507
                tmp___6 = nbnd;
#line 507
                nbnd ++;
#line 507
                *(bndptr + ii) = tmp___6;
#line 507
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
            }
          }
        } else
#line 509
        if (me == to) {
          {
#line 510
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 510
            myrinfo->id += *(adjwgt + j);
#line 510
            myrinfo->ed -= *(adjwgt + j);
#line 510
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 512
          if (myrinfo->ed == 0L) {
#line 512
            if (*(bndptr + ii) != -1L) {
              {
#line 513
              while (1) {
                while_continue___15: /* CIL Label */ ;
#line 513
                nbnd --;
#line 513
                *(bndind + *(bndptr + ii)) = *(bndind + nbnd);
#line 513
                *(bndptr + *(bndind + nbnd)) = *(bndptr + ii);
#line 513
                *(bndptr + ii) = (idxtype )-1;
#line 513
                goto while_break___15;
              }
              while_break___15: /* CIL Label */ ;
              }
            }
          }
        }
#line 517
        if (me != from) {
#line 518
          k = 0L;
          {
#line 518
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 518
            if (! (k < myrinfo->ndegrees)) {
#line 518
              goto while_break___16;
            }
#line 519
            if ((myedegrees + k)->pid == from) {
#line 520
              if ((myedegrees + k)->ed == *(adjwgt + j)) {
#line 521
                (myrinfo->ndegrees) --;
#line 521
                *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
              } else {
#line 523
                (myedegrees + k)->ed -= *(adjwgt + j);
              }
#line 524
              goto while_break___16;
            }
#line 518
            k ++;
          }
          while_break___16: /* CIL Label */ ;
          }
        }
#line 530
        if (me != to) {
#line 531
          k = 0L;
          {
#line 531
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 531
            if (! (k < myrinfo->ndegrees)) {
#line 531
              goto while_break___17;
            }
#line 532
            if ((myedegrees + k)->pid == to) {
#line 533
              (myedegrees + k)->ed += *(adjwgt + j);
#line 534
              goto while_break___17;
            }
#line 531
            k ++;
          }
          while_break___17: /* CIL Label */ ;
          }
#line 537
          if (k == myrinfo->ndegrees) {
#line 538
            (myedegrees + myrinfo->ndegrees)->pid = to;
#line 539
            tmp___7 = myrinfo->ndegrees;
#line 539
            (myrinfo->ndegrees) ++;
#line 539
            (myedegrees + tmp___7)->ed = *(adjwgt + j);
          }
        }
#line 544
        if (me != from) {
#line 544
          if (me != to) {
#line 545
            *(pmat + (me * nparts + from)) -= *(adjwgt + j);
#line 546
            *(pmat + (from * nparts + me)) -= *(adjwgt + j);
#line 547
            if (*(pmat + (me * nparts + from)) == 0L) {
#line 548
              (*(ndoms + me)) --;
#line 549
              if (*(ndoms + me) + 1L == maxndoms) {
                {
#line 550
                tmp___8 = __idxamax(nparts, ndoms);
#line 550
                maxndoms = *(ndoms + tmp___8);
                }
              }
            }
#line 552
            if (*(pmat + (from * nparts + me)) == 0L) {
#line 553
              (*(ndoms + from)) --;
#line 554
              if (*(ndoms + from) + 1L == maxndoms) {
                {
#line 555
                tmp___9 = __idxamax(nparts, ndoms);
#line 555
                maxndoms = *(ndoms + tmp___9);
                }
              }
            }
#line 558
            if (*(pmat + (me * nparts + to)) == 0L) {
#line 559
              (*(ndoms + me)) ++;
#line 560
              if (*(ndoms + me) > maxndoms) {
                {
#line 561
                printf((char const   */* __restrict  */)"You just increased the maxndoms: %ld %ld\n",
                       *(ndoms + me), maxndoms);
#line 562
                maxndoms = *(ndoms + me);
                }
              }
            }
#line 565
            if (*(pmat + (to * nparts + me)) == 0L) {
#line 566
              (*(ndoms + to)) ++;
#line 567
              if (*(ndoms + to) > maxndoms) {
                {
#line 568
                printf((char const   */* __restrict  */)"You just increased the maxndoms: %ld %ld\n",
                       *(ndoms + to), maxndoms);
#line 569
                maxndoms = *(ndoms + to);
                }
              }
            }
#line 572
            *(pmat + (me * nparts + to)) += *(adjwgt + j);
#line 573
            *(pmat + (to * nparts + me)) += *(adjwgt + j);
          }
        }
#line 577
        if (me == to) {
#line 577
          goto _L;
        } else
#line 577
        if (me == from) {
          _L: /* CIL Label */ 
#line 578
          gain = myrinfo->ed - myrinfo->id;
#line 579
          if (*(moved + ii) == 2L) {
#line 580
            if (myrinfo->ed > 0L) {
              {
#line 581
              __PQueueUpdate(& queue, ii, oldgain, gain);
              }
            } else {
              {
#line 583
              __PQueueDelete(& queue, ii, oldgain);
#line 584
              *(moved + ii) = (idxtype )-1;
              }
            }
          } else
#line 587
          if (*(moved + ii) == -1L) {
#line 587
            if (myrinfo->ed > 0L) {
              {
#line 588
              __PQueueInsert(& queue, ii, gain);
#line 589
              *(moved + ii) = (idxtype )2;
              }
            }
          }
        }
#line 488
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 596
      nmoves ++;
      __Cont: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 599
    graph->nbnd = nbnd;
#line 601
    if (ctrl->dbglvl & 8L) {
      {
#line 601
      tmp___10 = __idxsum(nparts, ndoms);
#line 601
      tmp___11 = __idxamax(nparts, pwgts);
#line 601
      tmp___12 = __idxamax(nparts, pwgts);
#line 601
      tmp___13 = __idxamin(nparts, pwgts);
#line 601
      printf((char const   */* __restrict  */)"\t[%6ld %6ld], Balance: %5.3f, Nb: %6ld. Nmoves: %5ld, Cut: %6ld, %ld\n",
             *(pwgts + tmp___13), *(pwgts + tmp___12), ((1.0 * (double )nparts) * (double )*(pwgts + tmp___11)) / (double )tvwgt,
             graph->nbnd, nmoves, graph->mincut, tmp___10);
      }
    }
#line 365
    pass ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 607
  __PQueueFree(ctrl, & queue);
#line 609
  __idxwspacefree(ctrl, nparts);
#line 610
  __idxwspacefree(ctrl, nparts);
#line 611
  __idxwspacefree(ctrl, nparts);
#line 612
  __idxwspacefree(ctrl, nparts);
#line 613
  __idxwspacefree(ctrl, nparts);
#line 614
  __idxwspacefree(ctrl, nvtxs);
#line 615
  __idxwspacefree(ctrl, nvtxs);
  }
#line 617
  return;
}
}
#line 625 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/subdomains.c"
void __PrintSubDomainGraph(GraphType *graph , long nparts , idxtype *where ) 
{ 
  long i ;
  long j ;
  long k ;
  long me ;
  long nvtxs ;
  long total ;
  long max ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *pmat ;

  {
  {
#line 630
  nvtxs = graph->nvtxs;
#line 631
  xadj = graph->xadj;
#line 632
  adjncy = graph->adjncy;
#line 633
  adjwgt = graph->adjwgt;
#line 635
  pmat = __idxsmalloc(nparts * nparts, (idxtype )0, (char *)"ComputeSubDomainGraph: pmat");
#line 637
  i = 0L;
  }
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    if (! (i < nvtxs)) {
#line 637
      goto while_break;
    }
#line 638
    me = *(where + i);
#line 639
    j = *(xadj + i);
    {
#line 639
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 639
      if (! (j < *(xadj + (i + 1L)))) {
#line 639
        goto while_break___0;
      }
#line 640
      k = *(adjncy + j);
#line 641
      if (*(where + k) != me) {
#line 642
        *(pmat + (me * nparts + *(where + k))) += *(adjwgt + j);
      }
#line 639
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 637
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 647
  max = 0L;
#line 647
  total = max;
#line 648
  i = 0L;
  {
#line 648
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 648
    if (! (i < nparts)) {
#line 648
      goto while_break___1;
    }
#line 649
    k = 0L;
#line 649
    j = 0L;
    {
#line 649
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 649
      if (! (j < nparts)) {
#line 649
        goto while_break___2;
      }
#line 650
      if (*(pmat + (i * nparts + j)) > 0L) {
#line 651
        k ++;
      }
#line 649
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 653
    total += k;
#line 655
    if (k > max) {
#line 656
      max = k;
    }
#line 648
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 666
  printf((char const   */* __restrict  */)"Total adjacent subdomains: %ld, Max: %ld\n",
         total, max);
#line 668
  free((void *)pmat);
  }
#line 669
  return;
}
}
#line 676 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/subdomains.c"
void __ComputeSubDomainGraph(GraphType *graph , long nparts , idxtype *pmat , idxtype *ndoms ) 
{ 
  long i ;
  long j ;
  long k ;
  long me ;
  long nvtxs ;
  long ndegrees ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  RInfoType *rinfo ;
  EDegreeType *edegrees ;

  {
  {
#line 683
  nvtxs = graph->nvtxs;
#line 684
  xadj = graph->xadj;
#line 685
  adjncy = graph->adjncy;
#line 686
  adjwgt = graph->adjwgt;
#line 687
  where = graph->where;
#line 688
  rinfo = graph->rinfo;
#line 690
  __idxset(nparts * nparts, (idxtype )0, pmat);
#line 692
  i = 0L;
  }
  {
#line 692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 692
    if (! (i < nvtxs)) {
#line 692
      goto while_break;
    }
#line 693
    if ((rinfo + i)->ed > 0L) {
#line 694
      me = *(where + i);
#line 695
      ndegrees = (rinfo + i)->ndegrees;
#line 696
      edegrees = (rinfo + i)->edegrees;
#line 698
      k = me * nparts;
#line 699
      j = 0L;
      {
#line 699
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 699
        if (! (j < ndegrees)) {
#line 699
          goto while_break___0;
        }
#line 700
        *(pmat + (k + (edegrees + j)->pid)) += (edegrees + j)->ed;
#line 699
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 692
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 704
  i = 0L;
  {
#line 704
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 704
    if (! (i < nparts)) {
#line 704
      goto while_break___1;
    }
#line 705
    *(ndoms + i) = (idxtype )0;
#line 706
    j = 0L;
    {
#line 706
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 706
      if (! (j < nparts)) {
#line 706
        goto while_break___2;
      }
#line 707
      if (*(pmat + (i * nparts + j)) > 0L) {
#line 708
        (*(ndoms + i)) ++;
      }
#line 706
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 704
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 712
  return;
}
}
#line 721 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/subdomains.c"
void __EliminateSubDomainEdges(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long me ;
  long other ;
  long nvtxs ;
  long total ;
  long max ;
  long avg ;
  long totalout ;
  long nind ;
  long ncand ;
  long ncand2 ;
  long target ;
  long target2 ;
  long nadd ;
  long min ;
  long move ;
  long cpwgt ;
  long tvwgt ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *vwgt ;
  idxtype *adjwgt ;
  idxtype *pwgts ;
  idxtype *where ;
  idxtype *maxpwgt ;
  idxtype *pmat ;
  idxtype *ndoms ;
  idxtype *mypmat ;
  idxtype *otherpmat ;
  idxtype *ind ;
  KeyValueType *cand ;
  KeyValueType *cand2 ;
  void *tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  {
#line 728
  nvtxs = graph->nvtxs;
#line 729
  xadj = graph->xadj;
#line 730
  adjncy = graph->adjncy;
#line 731
  vwgt = graph->vwgt;
#line 732
  adjwgt = graph->adjwgt;
#line 734
  where = graph->where;
#line 735
  pwgts = graph->pwgts;
#line 737
  maxpwgt = __idxwspacemalloc(ctrl, nparts);
#line 738
  ndoms = __idxwspacemalloc(ctrl, nparts);
#line 739
  otherpmat = __idxwspacemalloc(ctrl, nparts);
#line 740
  ind = __idxwspacemalloc(ctrl, nvtxs);
#line 741
  pmat = ctrl->wspace.pmat;
#line 743
  tmp = __GKmalloc((long )((unsigned long )nparts * sizeof(KeyValueType )), (char *)"EliminateSubDomainEdges: cand");
#line 743
  cand = (KeyValueType *)tmp;
#line 744
  tmp___0 = __GKmalloc((long )((unsigned long )nparts * sizeof(KeyValueType )), (char *)"EliminateSubDomainEdges: cand");
#line 744
  cand2 = (KeyValueType *)tmp___0;
#line 747
  __ComputeSubDomainGraph(graph, nparts, pmat, ndoms);
#line 751
  tvwgt = __idxsum(nparts, pwgts);
#line 752
  i = 0L;
  }
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 752
    if (! (i < nparts)) {
#line 752
      goto while_break;
    }
#line 753
    *(maxpwgt + i) = (idxtype )((1.25 * (double )*(tpwgts + i)) * (double )tvwgt);
#line 752
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 757
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 758
    total = __idxsum(nparts, ndoms);
#line 759
    avg = total / nparts;
#line 760
    tmp___1 = __idxamax(nparts, ndoms);
#line 760
    max = *(ndoms + tmp___1);
    }
#line 764
    if ((double )max < 1.4 * (double )avg) {
#line 765
      goto while_break___0;
    }
    {
#line 767
    me = __idxamax(nparts, ndoms);
#line 768
    mypmat = pmat + me * nparts;
#line 769
    totalout = __idxsum(nparts, mypmat);
#line 774
    ncand2 = 0L;
#line 774
    i = 0L;
    }
    {
#line 774
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 774
      if (! (i < nparts)) {
#line 774
        goto while_break___1;
      }
#line 775
      if (*(mypmat + i) > 0L) {
#line 776
        (cand2 + ncand2)->key = *(mypmat + i);
#line 777
        tmp___2 = ncand2;
#line 777
        ncand2 ++;
#line 777
        (cand2 + tmp___2)->val = i;
      }
#line 774
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 780
    __ikeysort(ncand2, cand2);
#line 782
    move = 0L;
#line 783
    min = 0L;
    }
    {
#line 783
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 783
      if (! (min < ncand2)) {
#line 783
        goto while_break___2;
      }
#line 784
      if ((cand2 + min)->key > totalout / (2L * *(ndoms + me))) {
#line 785
        goto while_break___2;
      }
      {
#line 787
      other = (cand2 + min)->val;
#line 791
      __idxset(nparts, (idxtype )0, otherpmat);
#line 794
      nind = 0L;
#line 794
      i = 0L;
      }
      {
#line 794
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 794
        if (! (i < nvtxs)) {
#line 794
          goto while_break___3;
        }
#line 795
        if (*(where + i) == other) {
#line 796
          j = *(xadj + i);
          {
#line 796
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 796
            if (! (j < *(xadj + (i + 1L)))) {
#line 796
              goto while_break___4;
            }
#line 797
            if (*(where + *(adjncy + j)) == me) {
#line 798
              tmp___3 = nind;
#line 798
              nind ++;
#line 798
              *(ind + tmp___3) = i;
#line 799
              goto while_break___4;
            }
#line 796
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 794
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 806
      cpwgt = 0L;
#line 806
      ii = 0L;
      {
#line 806
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 806
        if (! (ii < nind)) {
#line 806
          goto while_break___5;
        }
#line 807
        i = *(ind + ii);
#line 808
        cpwgt += *(vwgt + i);
#line 810
        j = *(xadj + i);
        {
#line 810
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 810
          if (! (j < *(xadj + (i + 1L)))) {
#line 810
            goto while_break___6;
          }
#line 811
          *(otherpmat + *(where + *(adjncy + j))) += *(adjwgt + j);
#line 810
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 806
        ii ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 813
      *(otherpmat + other) = (idxtype )0;
#line 815
      ncand = 0L;
#line 815
      i = 0L;
      {
#line 815
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 815
        if (! (i < nparts)) {
#line 815
          goto while_break___7;
        }
#line 816
        if (*(otherpmat + i) > 0L) {
#line 817
          (cand + ncand)->key = - *(otherpmat + i);
#line 818
          tmp___4 = ncand;
#line 818
          ncand ++;
#line 818
          (cand + tmp___4)->val = i;
        }
#line 815
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 821
      __ikeysort(ncand, cand);
#line 828
      target2 = -1L;
#line 828
      target = target2;
#line 829
      i = 0L;
      }
      {
#line 829
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 829
        if (! (i < ncand)) {
#line 829
          goto while_break___8;
        }
#line 830
        k = (cand + i)->val;
#line 832
        if (*(mypmat + k) > 0L) {
#line 833
          if (*(pwgts + k) + cpwgt > *(maxpwgt + k)) {
#line 834
            goto __Cont;
          }
#line 836
          j = 0L;
          {
#line 836
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 836
            if (! (j < nparts)) {
#line 836
              goto while_break___9;
            }
#line 837
            if (*(otherpmat + j) > 0L) {
#line 837
              if (*(ndoms + j) >= *(ndoms + me) - 1L) {
#line 837
                if (*(pmat + (nparts * j + k)) == 0L) {
#line 838
                  goto while_break___9;
                }
              }
            }
#line 836
            j ++;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 840
          if (j == nparts) {
#line 841
            nadd = 0L;
#line 841
            j = 0L;
            {
#line 841
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 841
              if (! (j < nparts)) {
#line 841
                goto while_break___10;
              }
#line 842
              if (*(otherpmat + j) > 0L) {
#line 842
                if (*(pmat + (nparts * k + j)) == 0L) {
#line 843
                  nadd ++;
                }
              }
#line 841
              j ++;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 847
            if (target2 == -1L) {
#line 847
              if (*(ndoms + k) + nadd < *(ndoms + me)) {
#line 848
                target2 = k;
              }
            }
#line 850
            if (nadd == 0L) {
#line 851
              target = k;
#line 852
              goto while_break___8;
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 829
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 857
      if (target == -1L) {
#line 857
        if (target2 != -1L) {
#line 858
          target = target2;
        }
      }
#line 860
      if (target == -1L) {
#line 862
        goto __Cont___0;
      }
      {
#line 868
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 868
        *(pwgts + target) += cpwgt;
#line 868
        *(pwgts + other) -= cpwgt;
#line 868
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 870
      __MoveGroupMConn(ctrl, graph, ndoms, pmat, nparts, target, nind, ind);
#line 872
      move = 1L;
      }
#line 873
      goto while_break___2;
      __Cont___0: /* CIL Label */ 
#line 783
      min ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 876
    if (move == 0L) {
#line 877
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 880
  __idxwspacefree(ctrl, nparts);
#line 881
  __idxwspacefree(ctrl, nparts);
#line 882
  __idxwspacefree(ctrl, nparts);
#line 883
  __idxwspacefree(ctrl, nvtxs);
#line 885
  __GKfree(& cand, & cand2, (void **)0);
  }
#line 886
  return;
}
}
#line 892 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/subdomains.c"
void __MoveGroupMConn(CtrlType *ctrl , GraphType *graph , idxtype *ndoms , idxtype *pmat ,
                      long nparts , long to , long nind , idxtype *ind ) 
{ 
  long i ;
  long ii ;
  long iii ;
  long j ;
  long k ;
  long nvtxs ;
  long nbnd ;
  long from ;
  long me ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *bndptr ;
  idxtype *bndind ;
  EDegreeType *myedegrees ;
  RInfoType *myrinfo ;
  long tmp ;
  long tmp___0 ;

  {
#line 902
  nvtxs = graph->nvtxs;
#line 903
  xadj = graph->xadj;
#line 904
  adjncy = graph->adjncy;
#line 905
  adjwgt = graph->adjwgt;
#line 907
  where = graph->where;
#line 908
  bndptr = graph->bndptr;
#line 909
  bndind = graph->bndind;
#line 911
  nbnd = graph->nbnd;
#line 913
  iii = 0L;
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;
#line 913
    if (! (iii < nind)) {
#line 913
      goto while_break;
    }
#line 914
    i = *(ind + iii);
#line 915
    from = *(where + i);
#line 917
    myrinfo = graph->rinfo + i;
#line 918
    if ((unsigned long )myrinfo->edegrees == (unsigned long )((void *)0)) {
#line 919
      myrinfo->edegrees = ctrl->wspace.edegrees + ctrl->wspace.cdegree;
#line 920
      ctrl->wspace.cdegree += *(xadj + (i + 1L)) - *(xadj + i);
#line 921
      myrinfo->ndegrees = 0L;
    }
#line 923
    myedegrees = myrinfo->edegrees;
#line 926
    k = 0L;
    {
#line 926
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 926
      if (! (k < myrinfo->ndegrees)) {
#line 926
        goto while_break___0;
      }
#line 927
      if ((myedegrees + k)->pid == to) {
#line 928
        goto while_break___0;
      }
#line 926
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 930
    if (k == myrinfo->ndegrees) {
#line 931
      (myedegrees + k)->pid = to;
#line 932
      (myedegrees + k)->ed = (idxtype )0;
#line 933
      (myrinfo->ndegrees) ++;
    }
#line 936
    graph->mincut -= (myedegrees + k)->ed - myrinfo->id;
#line 939
    *(pmat + (from * nparts + to)) += myrinfo->id - (myedegrees + k)->ed;
#line 940
    *(pmat + (to * nparts + from)) += myrinfo->id - (myedegrees + k)->ed;
#line 941
    if (*(pmat + (from * nparts + to)) == 0L) {
#line 942
      (*(ndoms + from)) --;
    }
#line 943
    if (*(pmat + (to * nparts + from)) == 0L) {
#line 944
      (*(ndoms + to)) --;
    }
#line 947
    *(where + i) = to;
#line 948
    myrinfo->ed += myrinfo->id - (myedegrees + k)->ed;
    {
#line 949
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 949
      j = myrinfo->id;
#line 949
      myrinfo->id = (myedegrees + k)->ed;
#line 949
      (myedegrees + k)->ed = j;
#line 949
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 950
    if ((myedegrees + k)->ed == 0L) {
#line 951
      (myrinfo->ndegrees) --;
#line 951
      *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
    } else {
#line 953
      (myedegrees + k)->pid = from;
    }
#line 955
    if (myrinfo->ed - myrinfo->id < 0L) {
#line 955
      if (*(bndptr + i) != -1L) {
        {
#line 956
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 956
          nbnd --;
#line 956
          *(bndind + *(bndptr + i)) = *(bndind + nbnd);
#line 956
          *(bndptr + *(bndind + nbnd)) = *(bndptr + i);
#line 956
          *(bndptr + i) = (idxtype )-1;
#line 956
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 959
    j = *(xadj + i);
    {
#line 959
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 959
      if (! (j < *(xadj + (i + 1L)))) {
#line 959
        goto while_break___3;
      }
#line 960
      ii = *(adjncy + j);
#line 961
      me = *(where + ii);
#line 963
      myrinfo = graph->rinfo + ii;
#line 964
      if ((unsigned long )myrinfo->edegrees == (unsigned long )((void *)0)) {
#line 965
        myrinfo->edegrees = ctrl->wspace.edegrees + ctrl->wspace.cdegree;
#line 966
        ctrl->wspace.cdegree += *(xadj + (ii + 1L)) - *(xadj + ii);
      }
#line 968
      myedegrees = myrinfo->edegrees;
#line 972
      if (me == from) {
        {
#line 973
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 973
          myrinfo->ed += *(adjwgt + j);
#line 973
          myrinfo->id -= *(adjwgt + j);
#line 973
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 975
        if (myrinfo->ed - myrinfo->id >= 0L) {
#line 975
          if (*(bndptr + ii) == -1L) {
            {
#line 976
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 976
              *(bndind + nbnd) = ii;
#line 976
              tmp = nbnd;
#line 976
              nbnd ++;
#line 976
              *(bndptr + ii) = tmp;
#line 976
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
        }
      } else
#line 978
      if (me == to) {
        {
#line 979
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 979
          myrinfo->id += *(adjwgt + j);
#line 979
          myrinfo->ed -= *(adjwgt + j);
#line 979
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 981
        if (myrinfo->ed - myrinfo->id < 0L) {
#line 981
          if (*(bndptr + ii) != -1L) {
            {
#line 982
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 982
              nbnd --;
#line 982
              *(bndind + *(bndptr + ii)) = *(bndind + nbnd);
#line 982
              *(bndptr + *(bndind + nbnd)) = *(bndptr + ii);
#line 982
              *(bndptr + ii) = (idxtype )-1;
#line 982
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
        }
      }
#line 986
      if (me != from) {
#line 987
        k = 0L;
        {
#line 987
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 987
          if (! (k < myrinfo->ndegrees)) {
#line 987
            goto while_break___8;
          }
#line 988
          if ((myedegrees + k)->pid == from) {
#line 989
            if ((myedegrees + k)->ed == *(adjwgt + j)) {
#line 990
              (myrinfo->ndegrees) --;
#line 990
              *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
            } else {
#line 992
              (myedegrees + k)->ed -= *(adjwgt + j);
            }
#line 993
            goto while_break___8;
          }
#line 987
          k ++;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 999
      if (me != to) {
#line 1000
        k = 0L;
        {
#line 1000
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1000
          if (! (k < myrinfo->ndegrees)) {
#line 1000
            goto while_break___9;
          }
#line 1001
          if ((myedegrees + k)->pid == to) {
#line 1002
            (myedegrees + k)->ed += *(adjwgt + j);
#line 1003
            goto while_break___9;
          }
#line 1000
          k ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 1006
        if (k == myrinfo->ndegrees) {
#line 1007
          (myedegrees + myrinfo->ndegrees)->pid = to;
#line 1008
          tmp___0 = myrinfo->ndegrees;
#line 1008
          (myrinfo->ndegrees) ++;
#line 1008
          (myedegrees + tmp___0)->ed = *(adjwgt + j);
        }
      }
#line 1013
      if (me != from) {
#line 1013
        if (me != to) {
#line 1014
          *(pmat + (me * nparts + from)) -= *(adjwgt + j);
#line 1015
          *(pmat + (from * nparts + me)) -= *(adjwgt + j);
#line 1016
          if (*(pmat + (me * nparts + from)) == 0L) {
#line 1017
            (*(ndoms + me)) --;
          }
#line 1018
          if (*(pmat + (from * nparts + me)) == 0L) {
#line 1019
            (*(ndoms + from)) --;
          }
#line 1021
          if (*(pmat + (me * nparts + to)) == 0L) {
#line 1022
            (*(ndoms + me)) ++;
          }
#line 1023
          if (*(pmat + (to * nparts + me)) == 0L) {
#line 1024
            (*(ndoms + to)) ++;
          }
#line 1026
          *(pmat + (me * nparts + to)) += *(adjwgt + j);
#line 1027
          *(pmat + (to * nparts + me)) += *(adjwgt + j);
        }
      }
#line 959
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 913
    iii ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1036
  graph->nbnd = nbnd;
#line 1038
  return;
}
}
#line 1048 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/subdomains.c"
void __EliminateComponents(CtrlType *ctrl , GraphType *graph , long nparts , float *tpwgts ,
                           float ubfactor ) 
{ 
  long i ;
  long ii ;
  long j ;
  long jj ;
  long k ;
  long me ;
  long nvtxs ;
  long tvwgt ;
  long first ;
  long last ;
  long nleft ;
  long ncmps ;
  long cwgt ;
  long target ;
  long deltawgt ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *vwgt ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *maxpwgt ;
  idxtype *cpvec ;
  idxtype *touched ;
  idxtype *perm ;
  idxtype *todo ;
  idxtype *cind ;
  idxtype *cptr ;
  idxtype *npcmps ;
  idxtype *tmp ;
  idxtype *tmp___0 ;
  idxtype tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  idxtype tmp___4 ;
  long tmp___5 ;

  {
  {
#line 1054
  nvtxs = graph->nvtxs;
#line 1055
  xadj = graph->xadj;
#line 1056
  adjncy = graph->adjncy;
#line 1057
  vwgt = graph->vwgt;
#line 1058
  adjwgt = graph->adjwgt;
#line 1060
  where = graph->where;
#line 1061
  pwgts = graph->pwgts;
#line 1063
  tmp = __idxwspacemalloc(ctrl, nvtxs);
#line 1063
  touched = __idxset(nvtxs, (idxtype )0, tmp);
#line 1064
  cptr = __idxwspacemalloc(ctrl, nvtxs);
#line 1065
  cind = __idxwspacemalloc(ctrl, nvtxs);
#line 1066
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 1067
  todo = __idxwspacemalloc(ctrl, nvtxs);
#line 1068
  maxpwgt = __idxwspacemalloc(ctrl, nparts);
#line 1069
  cpvec = __idxwspacemalloc(ctrl, nparts);
#line 1070
  tmp___0 = __idxwspacemalloc(ctrl, nparts);
#line 1070
  npcmps = __idxset(nparts, (idxtype )0, tmp___0);
#line 1072
  i = 0L;
  }
  {
#line 1072
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1072
    if (! (i < nvtxs)) {
#line 1072
      goto while_break;
    }
#line 1073
    tmp___1 = i;
#line 1073
    *(todo + i) = tmp___1;
#line 1073
    *(perm + i) = tmp___1;
#line 1072
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1076
  ncmps = -1L;
#line 1077
  last = 0L;
#line 1077
  first = last;
#line 1078
  nleft = nvtxs;
  {
#line 1079
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1079
    if (! (nleft > 0L)) {
#line 1079
      goto while_break___0;
    }
#line 1080
    if (first == last) {
#line 1081
      ncmps ++;
#line 1081
      *(cptr + ncmps) = first;
#line 1083
      i = *(todo + 0);
#line 1084
      tmp___2 = last;
#line 1084
      last ++;
#line 1084
      *(cind + tmp___2) = i;
#line 1085
      *(touched + i) = (idxtype )1;
#line 1086
      me = *(where + i);
#line 1087
      (*(npcmps + me)) ++;
    }
#line 1090
    tmp___3 = first;
#line 1090
    first ++;
#line 1090
    i = *(cind + tmp___3);
#line 1091
    k = *(perm + i);
#line 1092
    nleft --;
#line 1092
    tmp___4 = *(todo + nleft);
#line 1092
    *(todo + k) = tmp___4;
#line 1092
    j = tmp___4;
#line 1093
    *(perm + j) = k;
#line 1095
    j = *(xadj + i);
    {
#line 1095
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1095
      if (! (j < *(xadj + (i + 1L)))) {
#line 1095
        goto while_break___1;
      }
#line 1096
      k = *(adjncy + j);
#line 1097
      if (*(where + k) == me) {
#line 1097
        if (! *(touched + k)) {
#line 1098
          tmp___5 = last;
#line 1098
          last ++;
#line 1098
          *(cind + tmp___5) = k;
#line 1099
          *(touched + k) = (idxtype )1;
        }
      }
#line 1095
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1103
  ncmps ++;
#line 1103
  *(cptr + ncmps) = first;
#line 1107
  if (ncmps > nparts) {
    {
#line 1109
    tvwgt = __idxsum(nparts, pwgts);
#line 1110
    i = 0L;
    }
    {
#line 1110
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1110
      if (! (i < nparts)) {
#line 1110
        goto while_break___2;
      }
#line 1111
      *(maxpwgt + i) = (idxtype )((ubfactor * *(tpwgts + i)) * (float )tvwgt);
#line 1110
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1113
    deltawgt = 5L;
#line 1115
    i = 0L;
    {
#line 1115
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1115
      if (! (i < ncmps)) {
#line 1115
        goto while_break___3;
      }
#line 1116
      me = *(where + *(cind + *(cptr + i)));
#line 1117
      if (*(npcmps + me) == 1L) {
#line 1118
        goto __Cont;
      }
#line 1123
      cwgt = 0L;
#line 1123
      j = *(cptr + i);
      {
#line 1123
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1123
        if (! (j < *(cptr + (i + 1L)))) {
#line 1123
          goto while_break___4;
        }
#line 1124
        cwgt += *(vwgt + *(cind + j));
#line 1123
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1126
      if ((double )cwgt > .30 * (double )*(pwgts + me)) {
#line 1127
        goto __Cont;
      }
      {
#line 1130
      __idxset(nparts, (idxtype )0, cpvec);
#line 1131
      j = *(cptr + i);
      }
      {
#line 1131
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1131
        if (! (j < *(cptr + (i + 1L)))) {
#line 1131
          goto while_break___5;
        }
#line 1132
        ii = *(cind + j);
#line 1133
        jj = *(xadj + ii);
        {
#line 1133
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1133
          if (! (jj < *(xadj + (ii + 1L)))) {
#line 1133
            goto while_break___6;
          }
#line 1134
          *(cpvec + *(where + *(adjncy + jj))) += *(adjwgt + jj);
#line 1133
          jj ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1131
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1136
      *(cpvec + me) = (idxtype )0;
#line 1138
      target = -1L;
#line 1139
      j = 0L;
      {
#line 1139
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1139
        if (! (j < nparts)) {
#line 1139
          goto while_break___7;
        }
#line 1140
        if (*(cpvec + j) > 0L) {
#line 1140
          if (cwgt < deltawgt) {
#line 1140
            goto _L;
          } else
#line 1140
          if (*(pwgts + j) + cwgt < *(maxpwgt + j)) {
            _L: /* CIL Label */ 
#line 1141
            if (target == -1L) {
#line 1142
              target = j;
            } else
#line 1141
            if (*(cpvec + target) < *(cpvec + j)) {
#line 1142
              target = j;
            }
          }
        }
#line 1139
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1148
      if (target != -1L) {
        {
#line 1150
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1150
          *(pwgts + target) += cwgt;
#line 1150
          *(pwgts + me) -= cwgt;
#line 1150
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 1151
        (*(npcmps + me)) --;
#line 1153
        __MoveGroup(ctrl, graph, nparts, target, i, cptr, cind);
        }
      }
      __Cont: /* CIL Label */ 
#line 1115
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 1159
  __idxwspacefree(ctrl, nparts);
#line 1160
  __idxwspacefree(ctrl, nparts);
#line 1161
  __idxwspacefree(ctrl, nparts);
#line 1162
  __idxwspacefree(ctrl, nvtxs);
#line 1163
  __idxwspacefree(ctrl, nvtxs);
#line 1164
  __idxwspacefree(ctrl, nvtxs);
#line 1165
  __idxwspacefree(ctrl, nvtxs);
#line 1166
  __idxwspacefree(ctrl, nvtxs);
  }
#line 1168
  return;
}
}
#line 1174 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/subdomains.c"
void __MoveGroup(CtrlType *ctrl , GraphType *graph , long nparts , long to , long gid ,
                 idxtype *ptr , idxtype *ind ) 
{ 
  long i ;
  long ii ;
  long iii ;
  long j ;
  long k ;
  long nvtxs ;
  long nbnd ;
  long from ;
  long me ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *bndptr ;
  idxtype *bndind ;
  EDegreeType *myedegrees ;
  RInfoType *myrinfo ;
  long tmp ;
  long tmp___0 ;

  {
#line 1183
  nvtxs = graph->nvtxs;
#line 1184
  xadj = graph->xadj;
#line 1185
  adjncy = graph->adjncy;
#line 1186
  adjwgt = graph->adjwgt;
#line 1188
  where = graph->where;
#line 1189
  bndptr = graph->bndptr;
#line 1190
  bndind = graph->bndind;
#line 1192
  nbnd = graph->nbnd;
#line 1194
  iii = *(ptr + gid);
  {
#line 1194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1194
    if (! (iii < *(ptr + (gid + 1L)))) {
#line 1194
      goto while_break;
    }
#line 1195
    i = *(ind + iii);
#line 1196
    from = *(where + i);
#line 1198
    myrinfo = graph->rinfo + i;
#line 1199
    if ((unsigned long )myrinfo->edegrees == (unsigned long )((void *)0)) {
#line 1200
      myrinfo->edegrees = ctrl->wspace.edegrees + ctrl->wspace.cdegree;
#line 1201
      ctrl->wspace.cdegree += *(xadj + (i + 1L)) - *(xadj + i);
#line 1202
      myrinfo->ndegrees = 0L;
    }
#line 1204
    myedegrees = myrinfo->edegrees;
#line 1207
    k = 0L;
    {
#line 1207
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1207
      if (! (k < myrinfo->ndegrees)) {
#line 1207
        goto while_break___0;
      }
#line 1208
      if ((myedegrees + k)->pid == to) {
#line 1209
        goto while_break___0;
      }
#line 1207
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1211
    if (k == myrinfo->ndegrees) {
#line 1212
      (myedegrees + k)->pid = to;
#line 1213
      (myedegrees + k)->ed = (idxtype )0;
#line 1214
      (myrinfo->ndegrees) ++;
    }
#line 1217
    graph->mincut -= (myedegrees + k)->ed - myrinfo->id;
#line 1221
    *(where + i) = to;
#line 1222
    myrinfo->ed += myrinfo->id - (myedegrees + k)->ed;
    {
#line 1223
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1223
      j = myrinfo->id;
#line 1223
      myrinfo->id = (myedegrees + k)->ed;
#line 1223
      (myedegrees + k)->ed = j;
#line 1223
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1224
    if ((myedegrees + k)->ed == 0L) {
#line 1225
      (myrinfo->ndegrees) --;
#line 1225
      *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
    } else {
#line 1227
      (myedegrees + k)->pid = from;
    }
#line 1229
    if (myrinfo->ed - myrinfo->id < 0L) {
#line 1229
      if (*(bndptr + i) != -1L) {
        {
#line 1230
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1230
          nbnd --;
#line 1230
          *(bndind + *(bndptr + i)) = *(bndind + nbnd);
#line 1230
          *(bndptr + *(bndind + nbnd)) = *(bndptr + i);
#line 1230
          *(bndptr + i) = (idxtype )-1;
#line 1230
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 1233
    j = *(xadj + i);
    {
#line 1233
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1233
      if (! (j < *(xadj + (i + 1L)))) {
#line 1233
        goto while_break___3;
      }
#line 1234
      ii = *(adjncy + j);
#line 1235
      me = *(where + ii);
#line 1237
      myrinfo = graph->rinfo + ii;
#line 1238
      if ((unsigned long )myrinfo->edegrees == (unsigned long )((void *)0)) {
#line 1239
        myrinfo->edegrees = ctrl->wspace.edegrees + ctrl->wspace.cdegree;
#line 1240
        ctrl->wspace.cdegree += *(xadj + (ii + 1L)) - *(xadj + ii);
      }
#line 1242
      myedegrees = myrinfo->edegrees;
#line 1246
      if (me == from) {
        {
#line 1247
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1247
          myrinfo->ed += *(adjwgt + j);
#line 1247
          myrinfo->id -= *(adjwgt + j);
#line 1247
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1249
        if (myrinfo->ed - myrinfo->id >= 0L) {
#line 1249
          if (*(bndptr + ii) == -1L) {
            {
#line 1250
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 1250
              *(bndind + nbnd) = ii;
#line 1250
              tmp = nbnd;
#line 1250
              nbnd ++;
#line 1250
              *(bndptr + ii) = tmp;
#line 1250
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
        }
      } else
#line 1252
      if (me == to) {
        {
#line 1253
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1253
          myrinfo->id += *(adjwgt + j);
#line 1253
          myrinfo->ed -= *(adjwgt + j);
#line 1253
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1255
        if (myrinfo->ed - myrinfo->id < 0L) {
#line 1255
          if (*(bndptr + ii) != -1L) {
            {
#line 1256
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 1256
              nbnd --;
#line 1256
              *(bndind + *(bndptr + ii)) = *(bndind + nbnd);
#line 1256
              *(bndptr + *(bndind + nbnd)) = *(bndptr + ii);
#line 1256
              *(bndptr + ii) = (idxtype )-1;
#line 1256
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
        }
      }
#line 1260
      if (me != from) {
#line 1261
        k = 0L;
        {
#line 1261
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1261
          if (! (k < myrinfo->ndegrees)) {
#line 1261
            goto while_break___8;
          }
#line 1262
          if ((myedegrees + k)->pid == from) {
#line 1263
            if ((myedegrees + k)->ed == *(adjwgt + j)) {
#line 1264
              (myrinfo->ndegrees) --;
#line 1264
              *(myedegrees + k) = *(myedegrees + myrinfo->ndegrees);
            } else {
#line 1266
              (myedegrees + k)->ed -= *(adjwgt + j);
            }
#line 1267
            goto while_break___8;
          }
#line 1261
          k ++;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 1273
      if (me != to) {
#line 1274
        k = 0L;
        {
#line 1274
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1274
          if (! (k < myrinfo->ndegrees)) {
#line 1274
            goto while_break___9;
          }
#line 1275
          if ((myedegrees + k)->pid == to) {
#line 1276
            (myedegrees + k)->ed += *(adjwgt + j);
#line 1277
            goto while_break___9;
          }
#line 1274
          k ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 1280
        if (k == myrinfo->ndegrees) {
#line 1281
          (myedegrees + myrinfo->ndegrees)->pid = to;
#line 1282
          tmp___0 = myrinfo->ndegrees;
#line 1282
          (myrinfo->ndegrees) ++;
#line 1282
          (myedegrees + tmp___0)->ed = *(adjwgt + j);
        }
      }
#line 1233
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1194
    iii ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1292
  graph->nbnd = nbnd;
#line 1294
  return;
}
}
#line 296 "./proto.h"
float __BetterVBalance(long ncon , long norm , float *vwgt , float *u1wgt , float *u2wgt ) ;
#line 297
long __AreAllVwgtsBelowFast(long ncon , float *vwgt1 , float *vwgt2 , float limit ) ;
#line 22 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mmatch.c"
void __MCMatch_RM(CtrlType *ctrl , GraphType *graph ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long nvtxs ;
  long ncon ;
  long cnvtxs ;
  long maxidx ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *match ;
  idxtype *cmap ;
  idxtype *perm ;
  float *nvwgt ;
  double tmp ;
  idxtype *tmp___0 ;
  long tmp___1 ;
  idxtype tmp___2 ;
  long tmp___3 ;
  double tmp___4 ;

  {
#line 29
  if (ctrl->dbglvl & 1L) {
    {
#line 29
    tmp = __seconds();
#line 29
    ctrl->MatchTmr -= tmp;
    }
  }
  {
#line 31
  nvtxs = graph->nvtxs;
#line 32
  ncon = graph->ncon;
#line 33
  xadj = graph->xadj;
#line 34
  nvwgt = graph->nvwgt;
#line 35
  adjncy = graph->adjncy;
#line 36
  adjwgt = graph->adjwgt;
#line 38
  cmap = graph->cmap;
#line 39
  tmp___0 = __idxwspacemalloc(ctrl, nvtxs);
#line 39
  match = __idxset(nvtxs, (idxtype )-1, tmp___0);
#line 41
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 42
  __RandomPermute(nvtxs, perm, 1L);
#line 44
  cnvtxs = 0L;
#line 45
  ii = 0L;
  }
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (ii < nvtxs)) {
#line 45
      goto while_break;
    }
#line 46
    i = *(perm + ii);
#line 48
    if (*(match + i) == -1L) {
#line 49
      maxidx = i;
#line 52
      j = *(xadj + i);
      {
#line 52
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 52
        if (! (j < *(xadj + (i + 1L)))) {
#line 52
          goto while_break___0;
        }
#line 53
        k = *(adjncy + j);
#line 54
        if (*(match + k) == -1L) {
          {
#line 54
          tmp___1 = __AreAllVwgtsBelowFast(ncon, nvwgt + i * ncon, nvwgt + k * ncon,
                                           ctrl->nmaxvwgt);
          }
#line 54
          if (tmp___1) {
#line 55
            maxidx = k;
#line 56
            goto while_break___0;
          }
        }
#line 52
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 60
      tmp___3 = cnvtxs;
#line 60
      cnvtxs ++;
#line 60
      tmp___2 = tmp___3;
#line 60
      *(cmap + maxidx) = tmp___2;
#line 60
      *(cmap + i) = tmp___2;
#line 61
      *(match + i) = maxidx;
#line 62
      *(match + maxidx) = i;
    }
#line 45
    ii ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  if (ctrl->dbglvl & 1L) {
    {
#line 66
    tmp___4 = __seconds();
#line 66
    ctrl->MatchTmr += tmp___4;
    }
  }
  {
#line 68
  __CreateCoarseGraph(ctrl, graph, cnvtxs, match, perm);
#line 70
  __idxwspacefree(ctrl, nvtxs);
#line 71
  __idxwspacefree(ctrl, nvtxs);
  }
#line 72
  return;
}
}
#line 79 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mmatch.c"
void __MCMatch_HEM(CtrlType *ctrl , GraphType *graph ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long nvtxs ;
  long cnvtxs ;
  long ncon ;
  long maxidx ;
  long maxwgt ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *match ;
  idxtype *cmap ;
  idxtype *perm ;
  float *nvwgt ;
  double tmp ;
  idxtype *tmp___0 ;
  long tmp___1 ;
  idxtype tmp___2 ;
  long tmp___3 ;
  double tmp___4 ;

  {
#line 86
  if (ctrl->dbglvl & 1L) {
    {
#line 86
    tmp = __seconds();
#line 86
    ctrl->MatchTmr -= tmp;
    }
  }
  {
#line 88
  nvtxs = graph->nvtxs;
#line 89
  ncon = graph->ncon;
#line 90
  xadj = graph->xadj;
#line 91
  nvwgt = graph->nvwgt;
#line 92
  adjncy = graph->adjncy;
#line 93
  adjwgt = graph->adjwgt;
#line 95
  cmap = graph->cmap;
#line 96
  tmp___0 = __idxwspacemalloc(ctrl, nvtxs);
#line 96
  match = __idxset(nvtxs, (idxtype )-1, tmp___0);
#line 98
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 99
  __RandomPermute(nvtxs, perm, 1L);
#line 101
  cnvtxs = 0L;
#line 102
  ii = 0L;
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (ii < nvtxs)) {
#line 102
      goto while_break;
    }
#line 103
    i = *(perm + ii);
#line 105
    if (*(match + i) == -1L) {
#line 106
      maxidx = i;
#line 107
      maxwgt = 0L;
#line 110
      j = *(xadj + i);
      {
#line 110
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 110
        if (! (j < *(xadj + (i + 1L)))) {
#line 110
          goto while_break___0;
        }
#line 111
        k = *(adjncy + j);
#line 112
        if (*(match + k) == -1L) {
#line 112
          if (maxwgt <= *(adjwgt + j)) {
            {
#line 112
            tmp___1 = __AreAllVwgtsBelowFast(ncon, nvwgt + i * ncon, nvwgt + k * ncon,
                                             ctrl->nmaxvwgt);
            }
#line 112
            if (tmp___1) {
#line 114
              maxwgt = *(adjwgt + j);
#line 115
              maxidx = *(adjncy + j);
            }
          }
        }
#line 110
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 119
      tmp___3 = cnvtxs;
#line 119
      cnvtxs ++;
#line 119
      tmp___2 = tmp___3;
#line 119
      *(cmap + maxidx) = tmp___2;
#line 119
      *(cmap + i) = tmp___2;
#line 120
      *(match + i) = maxidx;
#line 121
      *(match + maxidx) = i;
    }
#line 102
    ii ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  if (ctrl->dbglvl & 1L) {
    {
#line 125
    tmp___4 = __seconds();
#line 125
    ctrl->MatchTmr += tmp___4;
    }
  }
  {
#line 127
  __CreateCoarseGraph(ctrl, graph, cnvtxs, match, perm);
#line 129
  __idxwspacefree(ctrl, nvtxs);
#line 130
  __idxwspacefree(ctrl, nvtxs);
  }
#line 131
  return;
}
}
#line 138 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mmatch.c"
void __MCMatch_SHEM(CtrlType *ctrl , GraphType *graph ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long nvtxs ;
  long cnvtxs ;
  long ncon ;
  long maxidx ;
  long maxwgt ;
  long avgdegree ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *match ;
  idxtype *cmap ;
  idxtype *degrees ;
  idxtype *perm ;
  idxtype *tperm ;
  float *nvwgt ;
  double tmp ;
  idxtype *tmp___0 ;
  idxtype tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  idxtype tmp___4 ;
  long tmp___5 ;
  double tmp___6 ;

  {
#line 145
  if (ctrl->dbglvl & 1L) {
    {
#line 145
    tmp = __seconds();
#line 145
    ctrl->MatchTmr -= tmp;
    }
  }
  {
#line 147
  nvtxs = graph->nvtxs;
#line 148
  ncon = graph->ncon;
#line 149
  xadj = graph->xadj;
#line 150
  nvwgt = graph->nvwgt;
#line 151
  adjncy = graph->adjncy;
#line 152
  adjwgt = graph->adjwgt;
#line 154
  cmap = graph->cmap;
#line 155
  tmp___0 = __idxwspacemalloc(ctrl, nvtxs);
#line 155
  match = __idxset(nvtxs, (idxtype )-1, tmp___0);
#line 157
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 158
  tperm = __idxwspacemalloc(ctrl, nvtxs);
#line 159
  degrees = __idxwspacemalloc(ctrl, nvtxs);
#line 161
  __RandomPermute(nvtxs, tperm, 1L);
#line 162
  avgdegree = (long )(0.7 * (double )(*(xadj + nvtxs) / nvtxs));
#line 163
  i = 0L;
  }
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (i < nvtxs)) {
#line 163
      goto while_break;
    }
#line 164
    if (*(xadj + (i + 1L)) - *(xadj + i) > avgdegree) {
#line 164
      *(degrees + i) = avgdegree;
    } else {
#line 164
      *(degrees + i) = *(xadj + (i + 1L)) - *(xadj + i);
    }
#line 163
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  __BucketSortKeysInc(nvtxs, avgdegree, degrees, tperm, perm);
#line 167
  cnvtxs = 0L;
#line 170
  ii = 0L;
  }
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 170
    if (! (ii < nvtxs)) {
#line 170
      goto while_break___0;
    }
#line 171
    i = *(perm + ii);
#line 173
    if (*(match + i) == -1L) {
#line 174
      if (*(xadj + i) < *(xadj + (i + 1L))) {
#line 175
        goto while_break___0;
      }
#line 177
      maxidx = i;
#line 178
      j = nvtxs - 1L;
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! (j > ii)) {
#line 178
          goto while_break___1;
        }
#line 179
        k = *(perm + j);
#line 180
        if (*(match + k) == -1L) {
#line 180
          if (*(xadj + k) < *(xadj + (k + 1L))) {
#line 181
            maxidx = k;
#line 182
            goto while_break___1;
          }
        }
#line 178
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 186
      tmp___2 = cnvtxs;
#line 186
      cnvtxs ++;
#line 186
      tmp___1 = tmp___2;
#line 186
      *(cmap + maxidx) = tmp___1;
#line 186
      *(cmap + i) = tmp___1;
#line 187
      *(match + i) = maxidx;
#line 188
      *(match + maxidx) = i;
    }
#line 170
    ii ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 193
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 193
    if (! (ii < nvtxs)) {
#line 193
      goto while_break___2;
    }
#line 194
    i = *(perm + ii);
#line 196
    if (*(match + i) == -1L) {
#line 197
      maxidx = i;
#line 198
      maxwgt = 0L;
#line 201
      j = *(xadj + i);
      {
#line 201
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 201
        if (! (j < *(xadj + (i + 1L)))) {
#line 201
          goto while_break___3;
        }
#line 202
        k = *(adjncy + j);
#line 203
        if (*(match + k) == -1L) {
#line 203
          if (maxwgt <= *(adjwgt + j)) {
            {
#line 203
            tmp___3 = __AreAllVwgtsBelowFast(ncon, nvwgt + i * ncon, nvwgt + k * ncon,
                                             ctrl->nmaxvwgt);
            }
#line 203
            if (tmp___3) {
#line 205
              maxwgt = *(adjwgt + j);
#line 206
              maxidx = *(adjncy + j);
            }
          }
        }
#line 201
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 210
      tmp___5 = cnvtxs;
#line 210
      cnvtxs ++;
#line 210
      tmp___4 = tmp___5;
#line 210
      *(cmap + maxidx) = tmp___4;
#line 210
      *(cmap + i) = tmp___4;
#line 211
      *(match + i) = maxidx;
#line 212
      *(match + maxidx) = i;
    }
#line 193
    ii ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 216
  if (ctrl->dbglvl & 1L) {
    {
#line 216
    tmp___6 = __seconds();
#line 216
    ctrl->MatchTmr += tmp___6;
    }
  }
  {
#line 218
  __idxwspacefree(ctrl, nvtxs);
#line 219
  __idxwspacefree(ctrl, nvtxs);
#line 221
  __CreateCoarseGraph(ctrl, graph, cnvtxs, match, perm);
#line 223
  __idxwspacefree(ctrl, nvtxs);
#line 224
  __idxwspacefree(ctrl, nvtxs);
  }
#line 225
  return;
}
}
#line 232 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mmatch.c"
void __MCMatch_SHEBM(CtrlType *ctrl , GraphType *graph , long norm ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long nvtxs ;
  long cnvtxs ;
  long ncon ;
  long maxidx ;
  long maxwgt ;
  long avgdegree ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *match ;
  idxtype *cmap ;
  idxtype *degrees ;
  idxtype *perm ;
  idxtype *tperm ;
  float *nvwgt ;
  double tmp ;
  idxtype *tmp___0 ;
  idxtype tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  float tmp___4 ;
  idxtype tmp___5 ;
  long tmp___6 ;
  double tmp___7 ;

  {
#line 239
  if (ctrl->dbglvl & 1L) {
    {
#line 239
    tmp = __seconds();
#line 239
    ctrl->MatchTmr -= tmp;
    }
  }
  {
#line 241
  nvtxs = graph->nvtxs;
#line 242
  ncon = graph->ncon;
#line 243
  xadj = graph->xadj;
#line 244
  nvwgt = graph->nvwgt;
#line 245
  adjncy = graph->adjncy;
#line 246
  adjwgt = graph->adjwgt;
#line 248
  cmap = graph->cmap;
#line 249
  tmp___0 = __idxwspacemalloc(ctrl, nvtxs);
#line 249
  match = __idxset(nvtxs, (idxtype )-1, tmp___0);
#line 251
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 252
  tperm = __idxwspacemalloc(ctrl, nvtxs);
#line 253
  degrees = __idxwspacemalloc(ctrl, nvtxs);
#line 255
  __RandomPermute(nvtxs, tperm, 1L);
#line 256
  avgdegree = (long )(0.7 * (double )(*(xadj + nvtxs) / nvtxs));
#line 257
  i = 0L;
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! (i < nvtxs)) {
#line 257
      goto while_break;
    }
#line 258
    if (*(xadj + (i + 1L)) - *(xadj + i) > avgdegree) {
#line 258
      *(degrees + i) = avgdegree;
    } else {
#line 258
      *(degrees + i) = *(xadj + (i + 1L)) - *(xadj + i);
    }
#line 257
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  __BucketSortKeysInc(nvtxs, avgdegree, degrees, tperm, perm);
#line 261
  cnvtxs = 0L;
#line 264
  ii = 0L;
  }
  {
#line 264
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 264
    if (! (ii < nvtxs)) {
#line 264
      goto while_break___0;
    }
#line 265
    i = *(perm + ii);
#line 267
    if (*(match + i) == -1L) {
#line 268
      if (*(xadj + i) < *(xadj + (i + 1L))) {
#line 269
        goto while_break___0;
      }
#line 271
      maxidx = i;
#line 272
      j = nvtxs - 1L;
      {
#line 272
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 272
        if (! (j > ii)) {
#line 272
          goto while_break___1;
        }
#line 273
        k = *(perm + j);
#line 274
        if (*(match + k) == -1L) {
#line 274
          if (*(xadj + k) < *(xadj + (k + 1L))) {
#line 275
            maxidx = k;
#line 276
            goto while_break___1;
          }
        }
#line 272
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 280
      tmp___2 = cnvtxs;
#line 280
      cnvtxs ++;
#line 280
      tmp___1 = tmp___2;
#line 280
      *(cmap + maxidx) = tmp___1;
#line 280
      *(cmap + i) = tmp___1;
#line 281
      *(match + i) = maxidx;
#line 282
      *(match + maxidx) = i;
    }
#line 264
    ii ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 287
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 287
    if (! (ii < nvtxs)) {
#line 287
      goto while_break___2;
    }
#line 288
    i = *(perm + ii);
#line 290
    if (*(match + i) == -1L) {
#line 291
      maxidx = i;
#line 292
      maxwgt = -1L;
#line 295
      j = *(xadj + i);
      {
#line 295
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 295
        if (! (j < *(xadj + (i + 1L)))) {
#line 295
          goto while_break___3;
        }
#line 296
        k = *(adjncy + j);
#line 298
        if (*(match + k) == -1L) {
          {
#line 298
          tmp___3 = __AreAllVwgtsBelowFast(ncon, nvwgt + i * ncon, nvwgt + k * ncon,
                                           ctrl->nmaxvwgt);
          }
#line 298
          if (tmp___3) {
#line 298
            if (maxwgt < *(adjwgt + j)) {
#line 306
              maxwgt = *(adjwgt + j);
#line 307
              maxidx = k;
            } else
#line 298
            if (maxwgt == *(adjwgt + j)) {
              {
#line 298
              tmp___4 = __BetterVBalance(ncon, norm, nvwgt + i * ncon, nvwgt + maxidx * ncon,
                                         nvwgt + k * ncon);
              }
#line 298
              if (tmp___4 >= (float )0) {
#line 306
                maxwgt = *(adjwgt + j);
#line 307
                maxidx = k;
              }
            }
          }
        }
#line 295
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 311
      tmp___6 = cnvtxs;
#line 311
      cnvtxs ++;
#line 311
      tmp___5 = tmp___6;
#line 311
      *(cmap + maxidx) = tmp___5;
#line 311
      *(cmap + i) = tmp___5;
#line 312
      *(match + i) = maxidx;
#line 313
      *(match + maxidx) = i;
    }
#line 287
    ii ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 317
  if (ctrl->dbglvl & 1L) {
    {
#line 317
    tmp___7 = __seconds();
#line 317
    ctrl->MatchTmr += tmp___7;
    }
  }
  {
#line 319
  __idxwspacefree(ctrl, nvtxs);
#line 320
  __idxwspacefree(ctrl, nvtxs);
#line 322
  __CreateCoarseGraph(ctrl, graph, cnvtxs, match, perm);
#line 324
  __idxwspacefree(ctrl, nvtxs);
#line 325
  __idxwspacefree(ctrl, nvtxs);
  }
#line 326
  return;
}
}
#line 333 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mmatch.c"
void __MCMatch_SBHEM(CtrlType *ctrl , GraphType *graph , long norm ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long nvtxs ;
  long cnvtxs ;
  long ncon ;
  long maxidx ;
  long maxwgt ;
  long avgdegree ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *match ;
  idxtype *cmap ;
  idxtype *degrees ;
  idxtype *perm ;
  idxtype *tperm ;
  float *nvwgt ;
  float vbal ;
  double tmp ;
  idxtype *tmp___0 ;
  idxtype tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  idxtype tmp___4 ;
  long tmp___5 ;
  double tmp___6 ;

  {
#line 340
  if (ctrl->dbglvl & 1L) {
    {
#line 340
    tmp = __seconds();
#line 340
    ctrl->MatchTmr -= tmp;
    }
  }
  {
#line 342
  nvtxs = graph->nvtxs;
#line 343
  ncon = graph->ncon;
#line 344
  xadj = graph->xadj;
#line 345
  nvwgt = graph->nvwgt;
#line 346
  adjncy = graph->adjncy;
#line 347
  adjwgt = graph->adjwgt;
#line 349
  cmap = graph->cmap;
#line 350
  tmp___0 = __idxwspacemalloc(ctrl, nvtxs);
#line 350
  match = __idxset(nvtxs, (idxtype )-1, tmp___0);
#line 352
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 353
  tperm = __idxwspacemalloc(ctrl, nvtxs);
#line 354
  degrees = __idxwspacemalloc(ctrl, nvtxs);
#line 356
  __RandomPermute(nvtxs, tperm, 1L);
#line 357
  avgdegree = (long )(0.7 * (double )(*(xadj + nvtxs) / nvtxs));
#line 358
  i = 0L;
  }
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! (i < nvtxs)) {
#line 358
      goto while_break;
    }
#line 359
    if (*(xadj + (i + 1L)) - *(xadj + i) > avgdegree) {
#line 359
      *(degrees + i) = avgdegree;
    } else {
#line 359
      *(degrees + i) = *(xadj + (i + 1L)) - *(xadj + i);
    }
#line 358
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  __BucketSortKeysInc(nvtxs, avgdegree, degrees, tperm, perm);
#line 362
  cnvtxs = 0L;
#line 365
  ii = 0L;
  }
  {
#line 365
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 365
    if (! (ii < nvtxs)) {
#line 365
      goto while_break___0;
    }
#line 366
    i = *(perm + ii);
#line 368
    if (*(match + i) == -1L) {
#line 369
      if (*(xadj + i) < *(xadj + (i + 1L))) {
#line 370
        goto while_break___0;
      }
#line 372
      maxidx = i;
#line 373
      j = nvtxs - 1L;
      {
#line 373
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 373
        if (! (j > ii)) {
#line 373
          goto while_break___1;
        }
#line 374
        k = *(perm + j);
#line 375
        if (*(match + k) == -1L) {
#line 375
          if (*(xadj + k) < *(xadj + (k + 1L))) {
#line 376
            maxidx = k;
#line 377
            goto while_break___1;
          }
        }
#line 373
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 381
      tmp___2 = cnvtxs;
#line 381
      cnvtxs ++;
#line 381
      tmp___1 = tmp___2;
#line 381
      *(cmap + maxidx) = tmp___1;
#line 381
      *(cmap + i) = tmp___1;
#line 382
      *(match + i) = maxidx;
#line 383
      *(match + maxidx) = i;
    }
#line 365
    ii ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 388
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 388
    if (! (ii < nvtxs)) {
#line 388
      goto while_break___2;
    }
#line 389
    i = *(perm + ii);
#line 391
    if (*(match + i) == -1L) {
#line 392
      maxidx = i;
#line 393
      maxwgt = -1L;
#line 394
      vbal = (float )0.0;
#line 397
      j = *(xadj + i);
      {
#line 397
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 397
        if (! (j < *(xadj + (i + 1L)))) {
#line 397
          goto while_break___3;
        }
#line 398
        k = *(adjncy + j);
#line 399
        if (*(match + k) == -1L) {
          {
#line 399
          tmp___3 = __AreAllVwgtsBelowFast(ncon, nvwgt + i * ncon, nvwgt + k * ncon,
                                           ctrl->nmaxvwgt);
          }
#line 399
          if (tmp___3) {
#line 400
            if (maxidx != i) {
              {
#line 401
              vbal = __BetterVBalance(ncon, norm, nvwgt + i * ncon, nvwgt + maxidx * ncon,
                                      nvwgt + k * ncon);
              }
            }
#line 403
            if (vbal > (float )0) {
#line 404
              maxwgt = *(adjwgt + j);
#line 405
              maxidx = k;
            } else
#line 403
            if ((double )vbal > - .01) {
#line 403
              if (maxwgt < *(adjwgt + j)) {
#line 404
                maxwgt = *(adjwgt + j);
#line 405
                maxidx = k;
              }
            }
          }
        }
#line 397
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 410
      tmp___5 = cnvtxs;
#line 410
      cnvtxs ++;
#line 410
      tmp___4 = tmp___5;
#line 410
      *(cmap + maxidx) = tmp___4;
#line 410
      *(cmap + i) = tmp___4;
#line 411
      *(match + i) = maxidx;
#line 412
      *(match + maxidx) = i;
    }
#line 388
    ii ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 416
  if (ctrl->dbglvl & 1L) {
    {
#line 416
    tmp___6 = __seconds();
#line 416
    ctrl->MatchTmr += tmp___6;
    }
  }
  {
#line 418
  __idxwspacefree(ctrl, nvtxs);
#line 419
  __idxwspacefree(ctrl, nvtxs);
#line 421
  __CreateCoarseGraph(ctrl, graph, cnvtxs, match, perm);
#line 423
  __idxwspacefree(ctrl, nvtxs);
#line 424
  __idxwspacefree(ctrl, nvtxs);
  }
#line 425
  return;
}
}
#line 435 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mmatch.c"
float __BetterVBalance(long ncon , long norm , float *vwgt , float *u1wgt , float *u2wgt ) 
{ 
  long i ;
  float sum1 ;
  float sum2 ;
  float max1 ;
  float max2 ;
  float min1 ;
  float min2 ;
  float diff1 ;
  float diff2 ;
  double tmp ;
  double tmp___0 ;

  {
#line 440
  if (norm == -1L) {
#line 441
    min1 = *(vwgt + 0) + *(u1wgt + 0);
#line 441
    max1 = min1;
#line 442
    min2 = *(vwgt + 0) + *(u2wgt + 0);
#line 442
    max2 = min2;
#line 443
    sum1 = *(vwgt + 0) + *(u1wgt + 0);
#line 444
    sum2 = *(vwgt + 0) + *(u2wgt + 0);
#line 446
    i = 1L;
    {
#line 446
    while (1) {
      while_continue: /* CIL Label */ ;
#line 446
      if (! (i < ncon)) {
#line 446
        goto while_break;
      }
#line 447
      if (max1 < *(vwgt + i) + *(u1wgt + i)) {
#line 448
        max1 = *(vwgt + i) + *(u1wgt + i);
      }
#line 449
      if (min1 > *(vwgt + i) + *(u1wgt + i)) {
#line 450
        min1 = *(vwgt + i) + *(u1wgt + i);
      }
#line 452
      if (max2 < *(vwgt + i) + *(u2wgt + i)) {
#line 453
        max2 = *(vwgt + i) + *(u2wgt + i);
      }
#line 454
      if (min2 > *(vwgt + i) + *(u2wgt + i)) {
#line 455
        min2 = *(vwgt + i) + *(u2wgt + i);
      }
#line 457
      sum1 += *(vwgt + i) + *(u1wgt + i);
#line 458
      sum2 += *(vwgt + i) + *(u2wgt + i);
#line 446
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 461
    if ((double )sum1 == 0.0) {
#line 462
      return ((float )1);
    } else
#line 463
    if ((double )sum2 == 0.0) {
#line 464
      return ((float )-1);
    } else {
#line 466
      return ((max1 - min1) / sum1 - (max2 - min2) / sum2);
    }
  } else
#line 468
  if (norm == 1L) {
#line 469
    sum2 = (float )0.0;
#line 469
    sum1 = sum2;
#line 470
    i = 0L;
    {
#line 470
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 470
      if (! (i < ncon)) {
#line 470
        goto while_break___0;
      }
#line 471
      sum1 += *(vwgt + i) + *(u1wgt + i);
#line 472
      sum2 += *(vwgt + i) + *(u2wgt + i);
#line 470
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 474
    sum1 = (float )((double )sum1 / (1.0 * (double )ncon));
#line 475
    sum2 = (float )((double )sum2 / (1.0 * (double )ncon));
#line 477
    diff2 = (float )0.0;
#line 477
    diff1 = diff2;
#line 478
    i = 0L;
    {
#line 478
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 478
      if (! (i < ncon)) {
#line 478
        goto while_break___1;
      }
      {
#line 479
      tmp = fabs((double )(sum1 - (*(vwgt + i) + *(u1wgt + i))));
#line 479
      diff1 = (float )((double )diff1 + tmp);
#line 480
      tmp___0 = fabs((double )(sum2 - (*(vwgt + i) + *(u2wgt + i))));
#line 480
      diff2 = (float )((double )diff2 + tmp___0);
#line 478
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 483
    return (diff1 - diff2);
  } else {
    {
#line 486
    __errexit((char *)"Unknown norm: %ld\n", norm);
    }
  }
#line 488
  return ((float )0.0);
}
}
#line 496 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/mmatch.c"
long __AreAllVwgtsBelowFast(long ncon , float *vwgt1 , float *vwgt2 , float limit ) 
{ 
  long i ;

  {
#line 500
  i = 0L;
  {
#line 500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 500
    if (! (i < ncon)) {
#line 500
      goto while_break;
    }
#line 501
    if (*(vwgt1 + i) + *(vwgt2 + i) > limit) {
#line 502
      return (0L);
    }
#line 500
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  return (1L);
}
}
#line 189 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) clock)(void) ;
#line 21 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/timing.c"
void __InitTimers(CtrlType *ctrl ) 
{ 


  {
#line 23
  ctrl->TotalTmr = 0.0;
#line 24
  ctrl->InitPartTmr = 0.0;
#line 25
  ctrl->MatchTmr = 0.0;
#line 26
  ctrl->ContractTmr = 0.0;
#line 27
  ctrl->CoarsenTmr = 0.0;
#line 28
  ctrl->UncoarsenTmr = 0.0;
#line 29
  ctrl->RefTmr = 0.0;
#line 30
  ctrl->ProjectTmr = 0.0;
#line 31
  ctrl->SplitTmr = 0.0;
#line 32
  ctrl->SepTmr = 0.0;
#line 33
  ctrl->AuxTmr1 = 0.0;
#line 34
  ctrl->AuxTmr2 = 0.0;
#line 35
  ctrl->AuxTmr3 = 0.0;
#line 36
  ctrl->AuxTmr4 = 0.0;
#line 37
  ctrl->AuxTmr5 = 0.0;
#line 38
  ctrl->AuxTmr6 = 0.0;
#line 39
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/timing.c"
void __PrintTimers(CtrlType *ctrl ) 
{ 


  {
  {
#line 48
  printf((char const   */* __restrict  */)"\nTiming Information -------------------------------------------------");
#line 49
  printf((char const   */* __restrict  */)"\n Multilevel: \t\t %7.3f", ctrl->TotalTmr);
#line 50
  printf((char const   */* __restrict  */)"\n     Coarsening: \t\t %7.3f", ctrl->CoarsenTmr);
#line 51
  printf((char const   */* __restrict  */)"\n            Matching: \t\t\t %7.3f",
         ctrl->MatchTmr);
#line 52
  printf((char const   */* __restrict  */)"\n            Contract: \t\t\t %7.3f",
         ctrl->ContractTmr);
#line 53
  printf((char const   */* __restrict  */)"\n     Initial Partition: \t %7.3f", ctrl->InitPartTmr);
#line 54
  printf((char const   */* __restrict  */)"\n   Construct Separator: \t %7.3f", ctrl->SepTmr);
#line 55
  printf((char const   */* __restrict  */)"\n     Uncoarsening: \t\t %7.3f", ctrl->UncoarsenTmr);
#line 56
  printf((char const   */* __restrict  */)"\n          Refinement: \t\t\t %7.3f",
         ctrl->RefTmr);
#line 57
  printf((char const   */* __restrict  */)"\n          Projection: \t\t\t %7.3f",
         ctrl->ProjectTmr);
#line 58
  printf((char const   */* __restrict  */)"\n     Splitting: \t\t %7.3f", ctrl->SplitTmr);
#line 59
  printf((char const   */* __restrict  */)"\n          AUX1: \t\t %7.3f", ctrl->AuxTmr1);
#line 60
  printf((char const   */* __restrict  */)"\n          AUX2: \t\t %7.3f", ctrl->AuxTmr2);
#line 61
  printf((char const   */* __restrict  */)"\n          AUX3: \t\t %7.3f", ctrl->AuxTmr3);
#line 62
  printf((char const   */* __restrict  */)"\n********************************************************************\n");
  }
#line 63
  return;
}
}
#line 69 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/timing.c"
double __seconds(void) 
{ 
  clock_t tmp ;

  {
  {
#line 71
  tmp = clock();
  }
#line 71
  return ((double )tmp / (double )1000000L);
}
}
#line 19 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/coarsen.c"
GraphType *__Coarsen2Way(CtrlType *ctrl , GraphType *graph ) 
{ 
  long clevel ;
  GraphType *cgraph ;
  double tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  double tmp___4 ;

  {
#line 24
  if (ctrl->dbglvl & 1L) {
    {
#line 24
    tmp = __seconds();
#line 24
    ctrl->CoarsenTmr -= tmp;
    }
  }
#line 26
  cgraph = graph;
#line 30
  if (ctrl->CType > 20L) {
#line 31
    clevel = 1L;
#line 32
    ctrl->CType -= 20L;
  } else {
#line 35
    clevel = 0L;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (ctrl->dbglvl & 4L) {
#line 38
      if (cgraph->vwgt) {
        {
#line 38
        tmp___0 = __idxsum(cgraph->nvtxs, cgraph->vwgt);
#line 38
        tmp___1 = tmp___0;
        }
      } else {
#line 38
        tmp___1 = cgraph->nvtxs;
      }
      {
#line 38
      printf((char const   */* __restrict  */)"%6ld %7ld [%ld] [%ld %ld]\n", cgraph->nvtxs,
             cgraph->nedges, ctrl->CoarsenTo, ctrl->maxvwgt, tmp___1);
      }
    }
#line 42
    if (cgraph->adjwgt) {
      {
#line 44
      if (ctrl->CType == 1L) {
#line 44
        goto case_1;
      }
#line 47
      if (ctrl->CType == 2L) {
#line 47
        goto case_2;
      }
#line 53
      if (ctrl->CType == 3L) {
#line 53
        goto case_3;
      }
#line 59
      if (ctrl->CType == 4L) {
#line 59
        goto case_4;
      }
#line 62
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 45
      __Match_RM(ctrl, cgraph);
      }
#line 46
      goto switch_break;
      case_2: /* CIL Label */ 
#line 48
      if (clevel < 1L) {
        {
#line 49
        __Match_RM(ctrl, cgraph);
        }
      } else {
        {
#line 51
        __Match_HEM(ctrl, cgraph);
        }
      }
#line 52
      goto switch_break;
      case_3: /* CIL Label */ 
#line 54
      if (clevel < 1L) {
        {
#line 55
        __Match_RM(ctrl, cgraph);
        }
      } else {
        {
#line 57
        __Match_SHEM(ctrl, cgraph);
        }
      }
#line 58
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 60
      __Match_SHEM(ctrl, cgraph);
      }
#line 61
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 63
      __errexit((char *)"Unknown CType: %ld\n", ctrl->CType);
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 67
      __Match_RM_NVW(ctrl, cgraph);
      }
    }
#line 70
    cgraph = cgraph->coarser;
#line 71
    clevel ++;
#line 37
    if (cgraph->nvtxs > ctrl->CoarsenTo) {
#line 37
      if ((double )cgraph->nvtxs < 0.90 * (double )(cgraph->finer)->nvtxs) {
#line 37
        if (! (cgraph->nedges > cgraph->nvtxs / 2L)) {
#line 37
          goto while_break;
        }
      } else {
#line 37
        goto while_break;
      }
    } else {
#line 37
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  if (ctrl->dbglvl & 4L) {
#line 75
    if (cgraph->vwgt) {
      {
#line 75
      tmp___2 = __idxsum(cgraph->nvtxs, cgraph->vwgt);
#line 75
      tmp___3 = tmp___2;
      }
    } else {
#line 75
      tmp___3 = cgraph->nvtxs;
    }
    {
#line 75
    printf((char const   */* __restrict  */)"%6ld %7ld [%ld] [%ld %ld]\n", cgraph->nvtxs,
           cgraph->nedges, ctrl->CoarsenTo, ctrl->maxvwgt, tmp___3);
    }
  }
#line 79
  if (ctrl->dbglvl & 1L) {
    {
#line 79
    tmp___4 = __seconds();
#line 79
    ctrl->CoarsenTmr += tmp___4;
    }
  }
#line 81
  return (cgraph);
}
}
#line 163 "./proto.h"
void __RefineKWay(CtrlType *ctrl , GraphType *orggraph , GraphType *graph , long nparts ,
                  float *tpwgts , float ubfactor ) ;
#line 164
void __AllocateKWayPartitionMemory(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 165
void __ComputeKWayPartitionParams(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 166
void __ProjectKWayPartition(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 169
void __ComputeKWayBalanceBoundary(CtrlType *ctrl , GraphType *graph , long nparts ) ;
#line 20 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayrefine.c"
void __RefineKWay(CtrlType *ctrl , GraphType *orggraph , GraphType *graph , long nparts ,
                  float *tpwgts , float ubfactor ) 
{ 
  long i ;
  long nlevels ;
  long mustfree ;
  GraphType *ptr ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  long tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  long tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;

  {
#line 22
  mustfree = 0L;
#line 25
  if (ctrl->dbglvl & 1L) {
    {
#line 25
    tmp = __seconds();
#line 25
    ctrl->UncoarsenTmr -= tmp;
    }
  }
  {
#line 28
  __ComputeKWayPartitionParams(ctrl, graph, nparts);
  }
#line 31
  if (ctrl->dbglvl & 1L) {
    {
#line 31
    tmp___0 = __seconds();
#line 31
    ctrl->AuxTmr1 -= tmp___0;
    }
  }
#line 32
  if (ctrl->RType == 3L) {
    {
#line 33
    __EliminateComponents(ctrl, graph, nparts, tpwgts, (float )1.25);
#line 34
    __EliminateSubDomainEdges(ctrl, graph, nparts, tpwgts);
#line 35
    __EliminateComponents(ctrl, graph, nparts, tpwgts, (float )1.25);
    }
  }
#line 37
  if (ctrl->dbglvl & 1L) {
    {
#line 37
    tmp___1 = __seconds();
#line 37
    ctrl->AuxTmr1 += tmp___1;
    }
  }
#line 40
  ptr = graph;
#line 40
  nlevels = 0L;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! ((unsigned long )ptr != (unsigned long )orggraph)) {
#line 40
      goto while_break;
    }
#line 40
    ptr = ptr->finer;
#line 40
    nlevels ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  i = 0L;
  {
#line 42
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 44
    if (ctrl->RType == 3L) {
#line 44
      if (i == nlevels / 2L) {
        {
#line 45
        __EliminateSubDomainEdges(ctrl, graph, nparts, tpwgts);
        }
      } else
#line 44
      if (i == nlevels / 2L + 1L) {
        {
#line 45
        __EliminateSubDomainEdges(ctrl, graph, nparts, tpwgts);
        }
      }
    }
#line 47
    if (ctrl->dbglvl & 1L) {
      {
#line 47
      tmp___2 = __seconds();
#line 47
      ctrl->RefTmr -= tmp___2;
      }
    }
#line 49
    if (2L * i >= nlevels) {
      {
#line 49
      tmp___3 = __IsBalanced(graph->pwgts, nparts, tpwgts, (float )(1.04 * (double )ubfactor));
      }
#line 49
      if (! tmp___3) {
        {
#line 50
        __ComputeKWayBalanceBoundary(ctrl, graph, nparts);
        }
#line 51
        if (ctrl->RType == 3L) {
          {
#line 52
          __Greedy_KWayEdgeBalanceMConn(ctrl, graph, nparts, tpwgts, ubfactor, 1L);
          }
        } else {
          {
#line 54
          __Greedy_KWayEdgeBalance(ctrl, graph, nparts, tpwgts, ubfactor, 1L);
          }
        }
        {
#line 55
        __ComputeKWayBoundary(ctrl, graph, nparts);
        }
      }
    }
    {
#line 59
    if (ctrl->RType == 1L) {
#line 59
      goto case_1;
    }
#line 62
    if (ctrl->RType == 2L) {
#line 62
      goto case_2;
    }
#line 65
    if (ctrl->RType == 3L) {
#line 65
      goto case_3;
    }
#line 58
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 60
    __Random_KWayEdgeRefine(ctrl, graph, nparts, tpwgts, ubfactor, 10L, 1L);
    }
#line 61
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 63
    __Greedy_KWayEdgeRefine(ctrl, graph, nparts, tpwgts, ubfactor, 10L);
    }
#line 64
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 66
    __Random_KWayEdgeRefineMConn(ctrl, graph, nparts, tpwgts, ubfactor, 10L, 1L);
    }
#line 67
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 69
    if (ctrl->dbglvl & 1L) {
      {
#line 69
      tmp___4 = __seconds();
#line 69
      ctrl->RefTmr += tmp___4;
      }
    }
#line 71
    if ((unsigned long )graph == (unsigned long )orggraph) {
#line 72
      goto while_break___0;
    }
    {
#line 74
    __GKfree(& graph->gdata, (void **)0);
#line 76
    graph = graph->finer;
    }
#line 78
    if (ctrl->dbglvl & 1L) {
      {
#line 78
      tmp___5 = __seconds();
#line 78
      ctrl->ProjectTmr -= tmp___5;
      }
    }
#line 79
    if ((unsigned long )graph->vwgt == (unsigned long )((void *)0)) {
      {
#line 80
      graph->vwgt = __idxsmalloc(graph->nvtxs, (idxtype )1, (char *)"RefineKWay: graph->vwgt");
#line 81
      graph->adjwgt = __idxsmalloc(graph->nedges, (idxtype )1, (char *)"RefineKWay: graph->adjwgt");
#line 82
      mustfree = 1L;
      }
    }
    {
#line 84
    __ProjectKWayPartition(ctrl, graph, nparts);
    }
#line 85
    if (ctrl->dbglvl & 1L) {
      {
#line 85
      tmp___6 = __seconds();
#line 85
      ctrl->ProjectTmr += tmp___6;
      }
    }
#line 42
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 88
  tmp___7 = __IsBalanced(graph->pwgts, nparts, tpwgts, ubfactor);
  }
#line 88
  if (! tmp___7) {
    {
#line 89
    __ComputeKWayBalanceBoundary(ctrl, graph, nparts);
    }
#line 90
    if (ctrl->RType == 3L) {
      {
#line 91
      __Greedy_KWayEdgeBalanceMConn(ctrl, graph, nparts, tpwgts, ubfactor, 8L);
#line 92
      __Random_KWayEdgeRefineMConn(ctrl, graph, nparts, tpwgts, ubfactor, 10L, 0L);
      }
    } else {
      {
#line 95
      __Greedy_KWayEdgeBalance(ctrl, graph, nparts, tpwgts, ubfactor, 8L);
#line 96
      __Random_KWayEdgeRefine(ctrl, graph, nparts, tpwgts, ubfactor, 10L, 0L);
      }
    }
  }
#line 101
  if (ctrl->dbglvl & 1L) {
    {
#line 101
    tmp___8 = __seconds();
#line 101
    ctrl->AuxTmr2 -= tmp___8;
    }
  }
  {
#line 102
  __EliminateComponents(ctrl, graph, nparts, tpwgts, ubfactor);
  }
#line 103
  if (ctrl->dbglvl & 1L) {
    {
#line 103
    tmp___9 = __seconds();
#line 103
    ctrl->AuxTmr2 += tmp___9;
    }
  }
#line 105
  if (mustfree) {
    {
#line 106
    __GKfree(& graph->vwgt, & graph->adjwgt, (void **)0);
    }
  }
#line 108
  if (ctrl->dbglvl & 1L) {
    {
#line 108
    tmp___10 = __seconds();
#line 108
    ctrl->UncoarsenTmr += tmp___10;
    }
  }
#line 109
  return;
}
}
#line 115 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayrefine.c"
void __AllocateKWayPartitionMemory(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long nvtxs ;
  long pad64 ;

  {
  {
#line 119
  nvtxs = graph->nvtxs;
#line 121
  pad64 = (3L * nvtxs + nparts) % 2L;
#line 123
  graph->rdata = __idxmalloc((long )(((unsigned long )(3L * nvtxs + nparts) + (sizeof(RInfoType ) / sizeof(idxtype )) * (unsigned long )nvtxs) + (unsigned long )pad64),
                             (char *)"AllocateKWayPartitionMemory: rdata");
#line 124
  graph->pwgts = graph->rdata;
#line 125
  graph->where = graph->rdata + nparts;
#line 126
  graph->bndptr = (graph->rdata + nvtxs) + nparts;
#line 127
  graph->bndind = (graph->rdata + 2L * nvtxs) + nparts;
#line 128
  graph->rinfo = (RInfoType *)(((graph->rdata + 3L * nvtxs) + nparts) + pad64);
  }
#line 135
  return;
}
}
#line 141 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayrefine.c"
void __ComputeKWayPartitionParams(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long i ;
  long j ;
  long k ;
  long nvtxs ;
  long nbnd ;
  long mincut ;
  long me ;
  long other ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *pwgts ;
  idxtype *where ;
  idxtype *bndind ;
  idxtype *bndptr ;
  RInfoType *rinfo ;
  RInfoType *myrinfo ;
  EDegreeType *myedegrees ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  EDegreeType *tmp___2 ;
  long tmp___3 ;

  {
  {
#line 148
  nvtxs = graph->nvtxs;
#line 149
  xadj = graph->xadj;
#line 150
  vwgt = graph->vwgt;
#line 151
  adjncy = graph->adjncy;
#line 152
  adjwgt = graph->adjwgt;
#line 154
  where = graph->where;
#line 155
  pwgts = __idxset(nparts, (idxtype )0, graph->pwgts);
#line 156
  bndind = graph->bndind;
#line 157
  bndptr = __idxset(nvtxs, (idxtype )-1, graph->bndptr);
#line 158
  rinfo = graph->rinfo;
#line 164
  ctrl->wspace.cdegree = 0L;
#line 165
  mincut = 0L;
#line 165
  nbnd = mincut;
#line 166
  i = 0L;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (i < nvtxs)) {
#line 166
      goto while_break;
    }
#line 167
    me = *(where + i);
#line 168
    *(pwgts + me) += *(vwgt + i);
#line 170
    myrinfo = rinfo + i;
#line 171
    tmp___0 = 0L;
#line 171
    myrinfo->ndegrees = tmp___0;
#line 171
    tmp = tmp___0;
#line 171
    myrinfo->ed = tmp;
#line 171
    myrinfo->id = tmp;
#line 172
    myrinfo->edegrees = (EDegreeType *)((void *)0);
#line 174
    j = *(xadj + i);
    {
#line 174
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 174
      if (! (j < *(xadj + (i + 1L)))) {
#line 174
        goto while_break___0;
      }
#line 175
      if (me != *(where + *(adjncy + j))) {
#line 176
        myrinfo->ed += *(adjwgt + j);
      }
#line 174
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 178
    myrinfo->id = *(graph->adjwgtsum + i) - myrinfo->ed;
#line 180
    if (myrinfo->ed > 0L) {
#line 181
      mincut += myrinfo->ed;
    }
#line 183
    if (myrinfo->ed - myrinfo->id >= 0L) {
      {
#line 184
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 184
        *(bndind + nbnd) = i;
#line 184
        tmp___1 = nbnd;
#line 184
        nbnd ++;
#line 184
        *(bndptr + i) = tmp___1;
#line 184
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 187
    if (myrinfo->ed > 0L) {
#line 188
      tmp___2 = ctrl->wspace.edegrees + ctrl->wspace.cdegree;
#line 188
      myrinfo->edegrees = tmp___2;
#line 188
      myedegrees = tmp___2;
#line 189
      ctrl->wspace.cdegree += *(xadj + (i + 1L)) - *(xadj + i);
#line 191
      j = *(xadj + i);
      {
#line 191
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 191
        if (! (j < *(xadj + (i + 1L)))) {
#line 191
          goto while_break___2;
        }
#line 192
        other = *(where + *(adjncy + j));
#line 193
        if (me != other) {
#line 194
          k = 0L;
          {
#line 194
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 194
            if (! (k < myrinfo->ndegrees)) {
#line 194
              goto while_break___3;
            }
#line 195
            if ((myedegrees + k)->pid == other) {
#line 196
              (myedegrees + k)->ed += *(adjwgt + j);
#line 197
              goto while_break___3;
            }
#line 194
            k ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 200
          if (k == myrinfo->ndegrees) {
#line 201
            (myedegrees + myrinfo->ndegrees)->pid = other;
#line 202
            tmp___3 = myrinfo->ndegrees;
#line 202
            (myrinfo->ndegrees) ++;
#line 202
            (myedegrees + tmp___3)->ed = *(adjwgt + j);
          }
        }
#line 191
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 166
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  graph->mincut = mincut / 2L;
#line 212
  graph->nbnd = nbnd;
#line 214
  return;
}
}
#line 222 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayrefine.c"
void __ProjectKWayPartition(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long i ;
  long j ;
  long k ;
  long nvtxs ;
  long nbnd ;
  long me ;
  long other ;
  long istart ;
  long iend ;
  long ndegrees ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *adjwgtsum ;
  idxtype *cmap ;
  idxtype *where ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *cwhere ;
  GraphType *cgraph ;
  RInfoType *crinfo ;
  RInfoType *rinfo ;
  RInfoType *myrinfo ;
  EDegreeType *myedegrees ;
  idxtype *htable ;
  idxtype *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  EDegreeType *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  {
#line 233
  cgraph = graph->coarser;
#line 234
  cwhere = cgraph->where;
#line 235
  crinfo = cgraph->rinfo;
#line 237
  nvtxs = graph->nvtxs;
#line 238
  cmap = graph->cmap;
#line 239
  xadj = graph->xadj;
#line 240
  adjncy = graph->adjncy;
#line 241
  adjwgt = graph->adjwgt;
#line 242
  adjwgtsum = graph->adjwgtsum;
#line 244
  __AllocateKWayPartitionMemory(ctrl, graph, nparts);
#line 245
  where = graph->where;
#line 246
  rinfo = graph->rinfo;
#line 247
  bndind = graph->bndind;
#line 248
  bndptr = __idxset(nvtxs, (idxtype )-1, graph->bndptr);
#line 251
  i = 0L;
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (i < nvtxs)) {
#line 251
      goto while_break;
    }
#line 252
    k = *(cmap + i);
#line 253
    *(where + i) = *(cwhere + k);
#line 254
    *(cmap + i) = (crinfo + k)->ed;
#line 251
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  tmp = __idxwspacemalloc(ctrl, nparts);
#line 257
  htable = __idxset(nparts, (idxtype )-1, tmp);
#line 259
  ctrl->wspace.cdegree = 0L;
#line 260
  nbnd = 0L;
#line 260
  i = 0L;
  }
  {
#line 260
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 260
    if (! (i < nvtxs)) {
#line 260
      goto while_break___0;
    }
#line 261
    me = *(where + i);
#line 263
    myrinfo = rinfo + i;
#line 264
    tmp___1 = 0L;
#line 264
    myrinfo->ndegrees = tmp___1;
#line 264
    tmp___0 = tmp___1;
#line 264
    myrinfo->ed = tmp___0;
#line 264
    myrinfo->id = tmp___0;
#line 265
    myrinfo->edegrees = (EDegreeType *)((void *)0);
#line 267
    myrinfo->id = *(adjwgtsum + i);
#line 269
    if (*(cmap + i) > 0L) {
#line 270
      istart = *(xadj + i);
#line 271
      iend = *(xadj + (i + 1L));
#line 273
      tmp___2 = ctrl->wspace.edegrees + ctrl->wspace.cdegree;
#line 273
      myrinfo->edegrees = tmp___2;
#line 273
      myedegrees = tmp___2;
#line 274
      ctrl->wspace.cdegree += iend - istart;
#line 276
      ndegrees = 0L;
#line 277
      j = istart;
      {
#line 277
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 277
        if (! (j < iend)) {
#line 277
          goto while_break___1;
        }
#line 278
        other = *(where + *(adjncy + j));
#line 279
        if (me != other) {
#line 280
          myrinfo->ed += *(adjwgt + j);
#line 281
          k = *(htable + other);
#line 281
          if (k == -1L) {
#line 282
            *(htable + other) = ndegrees;
#line 283
            (myedegrees + ndegrees)->pid = other;
#line 284
            tmp___3 = ndegrees;
#line 284
            ndegrees ++;
#line 284
            (myedegrees + tmp___3)->ed = *(adjwgt + j);
          } else {
#line 287
            (myedegrees + k)->ed += *(adjwgt + j);
          }
        }
#line 277
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 291
      myrinfo->id -= myrinfo->ed;
#line 294
      if (myrinfo->ed == 0L) {
#line 295
        myrinfo->edegrees = (EDegreeType *)((void *)0);
#line 296
        ctrl->wspace.cdegree -= iend - istart;
      } else {
#line 299
        if (myrinfo->ed - myrinfo->id >= 0L) {
          {
#line 300
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 300
            *(bndind + nbnd) = i;
#line 300
            tmp___4 = nbnd;
#line 300
            nbnd ++;
#line 300
            *(bndptr + i) = tmp___4;
#line 300
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 302
        myrinfo->ndegrees = ndegrees;
#line 304
        j = 0L;
        {
#line 304
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 304
          if (! (j < ndegrees)) {
#line 304
            goto while_break___3;
          }
#line 305
          *(htable + (myedegrees + j)->pid) = (idxtype )-1;
#line 304
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 260
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 310
  memcpy((void */* __restrict  */)((void *)graph->pwgts), (void const   */* __restrict  */)((void *)cgraph->pwgts),
         sizeof(idxtype ) * (unsigned long )nparts);
#line 311
  graph->mincut = cgraph->mincut;
#line 312
  graph->nbnd = nbnd;
#line 314
  __FreeGraph(graph->coarser);
#line 315
  graph->coarser = (struct graphdef *)((void *)0);
#line 317
  __idxwspacefree(ctrl, nparts);
  }
#line 321
  return;
}
}
#line 329 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayrefine.c"
long __IsBalanced(idxtype *pwgts , long nparts , float *tpwgts , float ubfactor ) 
{ 
  long i ;
  long tvwgt ;

  {
  {
#line 333
  tvwgt = __idxsum(nparts, pwgts);
#line 334
  i = 0L;
  }
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (i < nparts)) {
#line 334
      goto while_break;
    }
#line 335
    if ((double )*(pwgts + i) > (double )(*(tpwgts + i) * (float )tvwgt) * ((double )ubfactor + 0.005)) {
#line 336
      return (0L);
    }
#line 334
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  return (1L);
}
}
#line 346 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayrefine.c"
void __ComputeKWayBoundary(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long i ;
  long nvtxs ;
  long nbnd ;
  idxtype *bndind ;
  idxtype *bndptr ;
  long tmp ;

  {
  {
#line 351
  nvtxs = graph->nvtxs;
#line 352
  bndind = graph->bndind;
#line 353
  bndptr = __idxset(nvtxs, (idxtype )-1, graph->bndptr);
#line 359
  nbnd = 0L;
#line 360
  i = 0L;
  }
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! (i < nvtxs)) {
#line 360
      goto while_break;
    }
#line 361
    if ((graph->rinfo + i)->ed - (graph->rinfo + i)->id >= 0L) {
      {
#line 362
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 362
        *(bndind + nbnd) = i;
#line 362
        tmp = nbnd;
#line 362
        nbnd ++;
#line 362
        *(bndptr + i) = tmp;
#line 362
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 360
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  graph->nbnd = nbnd;
#line 366
  return;
}
}
#line 371 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kwayrefine.c"
void __ComputeKWayBalanceBoundary(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  long i ;
  long nvtxs ;
  long nbnd ;
  idxtype *bndind ;
  idxtype *bndptr ;
  long tmp ;

  {
  {
#line 376
  nvtxs = graph->nvtxs;
#line 377
  bndind = graph->bndind;
#line 378
  bndptr = __idxset(nvtxs, (idxtype )-1, graph->bndptr);
#line 384
  nbnd = 0L;
#line 385
  i = 0L;
  }
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! (i < nvtxs)) {
#line 385
      goto while_break;
    }
#line 386
    if ((graph->rinfo + i)->ed > 0L) {
      {
#line 387
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 387
        *(bndind + nbnd) = i;
#line 387
        tmp = nbnd;
#line 387
        nbnd ++;
#line 387
        *(bndptr + i) = tmp;
#line 387
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 385
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  graph->nbnd = nbnd;
#line 391
  return;
}
}
#line 406 "./proto.h"
void ComputePartitionInfoBipartite(GraphType *graph , long nparts , idxtype *where ) ;
#line 407
void __ComputePartitionBalance(GraphType *graph , long nparts , idxtype *where , float *ubvec ) ;
#line 408
float __ComputeElementBalance(long ne , long nparts , idxtype *where ) ;
#line 441
long __idxamax_strd(long n , idxtype *x , long incx ) ;
#line 21 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/stat.c"
void __ComputePartitionInfo(GraphType *graph , long nparts , idxtype *where ) 
{ 
  long i ;
  long j ;
  long nvtxs ;
  long ncon ;
  long mustfree ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *vwgt ;
  idxtype *adjwgt ;
  idxtype *kpwgts ;
  idxtype *tmpptr ;
  idxtype *padjncy ;
  idxtype *padjwgt ;
  idxtype *padjcut ;
  idxtype *tmp ;
  idxtype *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;

  {
#line 23
  mustfree = 0L;
#line 27
  nvtxs = graph->nvtxs;
#line 28
  ncon = graph->ncon;
#line 29
  xadj = graph->xadj;
#line 30
  adjncy = graph->adjncy;
#line 31
  vwgt = graph->vwgt;
#line 32
  adjwgt = graph->adjwgt;
#line 34
  if ((unsigned long )vwgt == (unsigned long )((void *)0)) {
    {
#line 35
    tmp = __idxsmalloc(nvtxs, (idxtype )1, (char *)"vwgt");
#line 35
    graph->vwgt = tmp;
#line 35
    vwgt = tmp;
#line 36
    mustfree = 1L;
    }
  }
#line 38
  if ((unsigned long )adjwgt == (unsigned long )((void *)0)) {
    {
#line 39
    tmp___0 = __idxsmalloc(*(xadj + nvtxs), (idxtype )1, (char *)"adjwgt");
#line 39
    graph->adjwgt = tmp___0;
#line 39
    adjwgt = tmp___0;
#line 40
    mustfree += 2L;
    }
  }
  {
#line 43
  tmp___1 = __ComputeVolume(graph, where);
#line 43
  tmp___2 = __ComputeCut(graph, where);
#line 43
  printf((char const   */* __restrict  */)"%ld-way Cut: %5ld, Vol: %5ld, ", nparts,
         tmp___2, tmp___1);
#line 46
  kpwgts = __idxsmalloc(ncon * nparts, (idxtype )0, (char *)"ComputePartitionInfo: kpwgts");
#line 48
  i = 0L;
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < nvtxs)) {
#line 48
      goto while_break;
    }
#line 49
    j = 0L;
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 49
      if (! (j < ncon)) {
#line 49
        goto while_break___0;
      }
#line 50
      *(kpwgts + (*(where + i) * ncon + j)) += *(vwgt + (i * ncon + j));
#line 49
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  if (ncon == 1L) {
    {
#line 54
    tmp___3 = __idxamax(nvtxs, vwgt);
#line 54
    tmp___4 = __idxsum(nparts, kpwgts);
#line 54
    tmp___5 = __idxamax(nparts, kpwgts);
#line 54
    tmp___6 = __idxsum(nparts, kpwgts);
#line 54
    printf((char const   */* __restrict  */)"\tBalance: %5.3f out of %5.3f\n", ((1.0 * (double )nparts) * (double )*(kpwgts + tmp___5)) / (1.0 * (double )tmp___6),
           ((1.0 * (double )nparts) * (double )*(vwgt + tmp___3)) / (1.0 * (double )tmp___4));
    }
  } else {
    {
#line 59
    printf((char const   */* __restrict  */)"\tBalance:");
#line 60
    j = 0L;
    }
    {
#line 60
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 60
      if (! (j < ncon)) {
#line 60
        goto while_break___1;
      }
      {
#line 61
      tmp___7 = __idxamax_strd(nvtxs, vwgt + j, ncon);
#line 61
      tmp___8 = __idxsum_strd(nparts, kpwgts + j, ncon);
#line 61
      tmp___9 = __idxamax_strd(nparts, kpwgts + j, ncon);
#line 61
      tmp___10 = __idxsum_strd(nparts, kpwgts + j, ncon);
#line 61
      printf((char const   */* __restrict  */)" (%5.3f out of %5.3f)", ((1.0 * (double )nparts) * (double )*(kpwgts + (ncon * tmp___9 + j))) / (1.0 * (double )tmp___10),
             ((1.0 * (double )nparts) * (double )*(vwgt + (ncon * tmp___7 + j))) / (1.0 * (double )tmp___8));
#line 60
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 64
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 69
  padjncy = __idxsmalloc(nparts * nparts, (idxtype )0, (char *)"ComputePartitionInfo: padjncy");
#line 70
  padjwgt = __idxsmalloc(nparts * nparts, (idxtype )0, (char *)"ComputePartitionInfo: padjwgt");
#line 71
  padjcut = __idxsmalloc(nparts * nparts, (idxtype )0, (char *)"ComputePartitionInfo: padjwgt");
#line 73
  __idxset(nparts, (idxtype )0, kpwgts);
#line 74
  i = 0L;
  }
  {
#line 74
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 74
    if (! (i < nvtxs)) {
#line 74
      goto while_break___2;
    }
#line 75
    j = *(xadj + i);
    {
#line 75
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 75
      if (! (j < *(xadj + (i + 1L)))) {
#line 75
        goto while_break___3;
      }
#line 76
      if (*(where + i) != *(where + *(adjncy + j))) {
#line 77
        *(padjncy + (*(where + i) * nparts + *(where + *(adjncy + j)))) = (idxtype )1;
#line 78
        *(padjcut + (*(where + i) * nparts + *(where + *(adjncy + j)))) += *(adjwgt + j);
#line 79
        if (*(kpwgts + *(where + *(adjncy + j))) == 0L) {
#line 80
          (*(padjwgt + (*(where + i) * nparts + *(where + *(adjncy + j))))) ++;
#line 81
          *(kpwgts + *(where + *(adjncy + j))) = (idxtype )1;
        }
      }
#line 75
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 85
    j = *(xadj + i);
    {
#line 85
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 85
      if (! (j < *(xadj + (i + 1L)))) {
#line 85
        goto while_break___4;
      }
#line 86
      *(kpwgts + *(where + *(adjncy + j))) = (idxtype )0;
#line 85
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 74
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 89
  i = 0L;
  {
#line 89
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 89
    if (! (i < nparts)) {
#line 89
      goto while_break___5;
    }
    {
#line 90
    *(kpwgts + i) = __idxsum(nparts, padjncy + i * nparts);
#line 89
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 91
  tmp___11 = __idxamax(nparts, kpwgts);
#line 91
  tmp___12 = __idxsum(nparts, kpwgts);
#line 91
  tmp___13 = __idxsum(nparts, kpwgts);
#line 91
  tmp___14 = __idxamax(nparts, kpwgts);
#line 91
  tmp___15 = __idxamin(nparts, kpwgts);
#line 91
  printf((char const   */* __restrict  */)"Min/Max/Avg/Bal # of adjacent     subdomains: %5ld %5ld %5.2f %7.3f\n",
         *(kpwgts + tmp___15), *(kpwgts + tmp___14), (1.0 * (double )tmp___13) / (1.0 * (double )nparts),
         ((1.0 * (double )nparts) * (double )*(kpwgts + tmp___11)) / (1.0 * (double )tmp___12));
#line 96
  i = 0L;
  }
  {
#line 96
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 96
    if (! (i < nparts)) {
#line 96
      goto while_break___6;
    }
    {
#line 97
    *(kpwgts + i) = __idxsum(nparts, padjcut + i * nparts);
#line 96
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 98
  tmp___16 = __idxamax(nparts, kpwgts);
#line 98
  tmp___17 = __idxsum(nparts, kpwgts);
#line 98
  tmp___18 = __idxsum(nparts, kpwgts);
#line 98
  tmp___19 = __idxamax(nparts, kpwgts);
#line 98
  tmp___20 = __idxamin(nparts, kpwgts);
#line 98
  printf((char const   */* __restrict  */)"Min/Max/Avg/Bal # of adjacent subdomain cuts: %5ld %5ld %5ld %7.3f\n",
         *(kpwgts + tmp___20), *(kpwgts + tmp___19), tmp___18 / nparts, ((1.0 * (double )nparts) * (double )*(kpwgts + tmp___16)) / (1.0 * (double )tmp___17));
#line 102
  i = 0L;
  }
  {
#line 102
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 102
    if (! (i < nparts)) {
#line 102
      goto while_break___7;
    }
    {
#line 103
    *(kpwgts + i) = __idxsum(nparts, padjwgt + i * nparts);
#line 102
    i ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 104
  tmp___21 = __idxsum(nparts, kpwgts);
#line 104
  tmp___22 = __idxamax(nparts, kpwgts);
#line 104
  tmp___23 = __idxsum(nparts, kpwgts);
#line 104
  tmp___24 = __idxsum(nparts, kpwgts);
#line 104
  tmp___25 = __idxamax(nparts, kpwgts);
#line 104
  tmp___26 = __idxamin(nparts, kpwgts);
#line 104
  printf((char const   */* __restrict  */)"Min/Max/Avg/Bal/Frac # of interface    nodes: %5ld %5ld %5ld %7.3f %7.3f\n",
         *(kpwgts + tmp___26), *(kpwgts + tmp___25), tmp___24 / nparts, ((1.0 * (double )nparts) * (double )*(kpwgts + tmp___22)) / (1.0 * (double )tmp___23),
         (1.0 * (double )tmp___21) / (1.0 * (double )nvtxs));
#line 108
  tmpptr = graph->where;
#line 109
  graph->where = where;
#line 110
  i = 0L;
  }
  {
#line 110
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 110
    if (! (i < nparts)) {
#line 110
      goto while_break___8;
    }
    {
#line 111
    __IsConnectedSubdomain((CtrlType *)((void *)0), graph, i, 1L);
#line 110
    i ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 112
  graph->where = tmpptr;
#line 114
  if (mustfree == 1L) {
    {
#line 115
    free((void *)vwgt);
#line 116
    graph->vwgt = (idxtype *)((void *)0);
    }
  } else
#line 114
  if (mustfree == 3L) {
    {
#line 115
    free((void *)vwgt);
#line 116
    graph->vwgt = (idxtype *)((void *)0);
    }
  }
#line 118
  if (mustfree == 2L) {
    {
#line 119
    free((void *)adjwgt);
#line 120
    graph->adjwgt = (idxtype *)((void *)0);
    }
  } else
#line 118
  if (mustfree == 3L) {
    {
#line 119
    free((void *)adjwgt);
#line 120
    graph->adjwgt = (idxtype *)((void *)0);
    }
  }
  {
#line 123
  __GKfree(& kpwgts, & padjncy, & padjwgt, & padjcut, (void **)0);
  }
#line 124
  return;
}
}
#line 130 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/stat.c"
void ComputePartitionInfoBipartite(GraphType *graph , long nparts , idxtype *where ) 
{ 
  long i ;
  long j ;
  long nvtxs ;
  long ncon ;
  long mustfree ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *vwgt ;
  idxtype *vsize ;
  idxtype *adjwgt ;
  idxtype *kpwgts ;
  idxtype *padjncy ;
  idxtype *padjwgt ;
  idxtype *padjcut ;
  idxtype *tmp ;
  idxtype *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;

  {
#line 132
  mustfree = 0L;
#line 136
  nvtxs = graph->nvtxs;
#line 137
  ncon = graph->ncon;
#line 138
  xadj = graph->xadj;
#line 139
  adjncy = graph->adjncy;
#line 140
  vwgt = graph->vwgt;
#line 141
  vsize = graph->vsize;
#line 142
  adjwgt = graph->adjwgt;
#line 144
  if ((unsigned long )vwgt == (unsigned long )((void *)0)) {
    {
#line 145
    tmp = __idxsmalloc(nvtxs, (idxtype )1, (char *)"vwgt");
#line 145
    graph->vwgt = tmp;
#line 145
    vwgt = tmp;
#line 146
    mustfree = 1L;
    }
  }
#line 148
  if ((unsigned long )adjwgt == (unsigned long )((void *)0)) {
    {
#line 149
    tmp___0 = __idxsmalloc(*(xadj + nvtxs), (idxtype )1, (char *)"adjwgt");
#line 149
    graph->adjwgt = tmp___0;
#line 149
    adjwgt = tmp___0;
#line 150
    mustfree += 2L;
    }
  }
  {
#line 153
  tmp___1 = __ComputeVolume(graph, where);
#line 153
  tmp___2 = __ComputeCut(graph, where);
#line 153
  printf((char const   */* __restrict  */)"%ld-way Cut: %5ld, Vol: %5ld, ", nparts,
         tmp___2, tmp___1);
#line 156
  kpwgts = __idxsmalloc(ncon * nparts, (idxtype )0, (char *)"ComputePartitionInfo: kpwgts");
#line 158
  i = 0L;
  }
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i < nvtxs)) {
#line 158
      goto while_break;
    }
#line 159
    j = 0L;
    {
#line 159
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 159
      if (! (j < ncon)) {
#line 159
        goto while_break___0;
      }
#line 160
      *(kpwgts + (*(where + i) * ncon + j)) += *(vwgt + (i * ncon + j));
#line 159
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  if (ncon == 1L) {
    {
#line 164
    tmp___3 = __idxamax(nvtxs, vwgt);
#line 164
    tmp___4 = __idxsum(nparts, kpwgts);
#line 164
    tmp___5 = __idxamax(nparts, kpwgts);
#line 164
    tmp___6 = __idxsum(nparts, kpwgts);
#line 164
    printf((char const   */* __restrict  */)"\tBalance: %5.3f out of %5.3f\n", ((1.0 * (double )nparts) * (double )*(kpwgts + tmp___5)) / (1.0 * (double )tmp___6),
           ((1.0 * (double )nparts) * (double )*(vwgt + tmp___3)) / (1.0 * (double )tmp___4));
    }
  } else {
    {
#line 169
    printf((char const   */* __restrict  */)"\tBalance:");
#line 170
    j = 0L;
    }
    {
#line 170
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 170
      if (! (j < ncon)) {
#line 170
        goto while_break___1;
      }
      {
#line 171
      tmp___7 = __idxamax_strd(nvtxs, vwgt + j, ncon);
#line 171
      tmp___8 = __idxsum_strd(nparts, kpwgts + j, ncon);
#line 171
      tmp___9 = __idxamax_strd(nparts, kpwgts + j, ncon);
#line 171
      tmp___10 = __idxsum_strd(nparts, kpwgts + j, ncon);
#line 171
      printf((char const   */* __restrict  */)" (%5.3f out of %5.3f)", ((1.0 * (double )nparts) * (double )*(kpwgts + (ncon * tmp___9 + j))) / (1.0 * (double )tmp___10),
             ((1.0 * (double )nparts) * (double )*(vwgt + (ncon * tmp___7 + j))) / (1.0 * (double )tmp___8));
#line 170
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 174
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 179
  padjncy = __idxsmalloc(nparts * nparts, (idxtype )0, (char *)"ComputePartitionInfo: padjncy");
#line 180
  padjwgt = __idxsmalloc(nparts * nparts, (idxtype )0, (char *)"ComputePartitionInfo: padjwgt");
#line 181
  padjcut = __idxsmalloc(nparts * nparts, (idxtype )0, (char *)"ComputePartitionInfo: padjwgt");
#line 183
  __idxset(nparts, (idxtype )0, kpwgts);
#line 184
  i = 0L;
  }
  {
#line 184
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 184
    if (! (i < nvtxs)) {
#line 184
      goto while_break___2;
    }
#line 185
    j = *(xadj + i);
    {
#line 185
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 185
      if (! (j < *(xadj + (i + 1L)))) {
#line 185
        goto while_break___3;
      }
#line 186
      if (*(where + i) != *(where + *(adjncy + j))) {
#line 187
        *(padjncy + (*(where + i) * nparts + *(where + *(adjncy + j)))) = (idxtype )1;
#line 188
        *(padjcut + (*(where + i) * nparts + *(where + *(adjncy + j)))) += *(adjwgt + j);
#line 189
        if (*(kpwgts + *(where + *(adjncy + j))) == 0L) {
#line 190
          *(padjwgt + (*(where + i) * nparts + *(where + *(adjncy + j)))) += *(vsize + i);
#line 191
          *(kpwgts + *(where + *(adjncy + j))) = (idxtype )1;
        }
      }
#line 185
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 195
    j = *(xadj + i);
    {
#line 195
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 195
      if (! (j < *(xadj + (i + 1L)))) {
#line 195
        goto while_break___4;
      }
#line 196
      *(kpwgts + *(where + *(adjncy + j))) = (idxtype )0;
#line 195
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 184
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 199
  i = 0L;
  {
#line 199
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 199
    if (! (i < nparts)) {
#line 199
      goto while_break___5;
    }
    {
#line 200
    *(kpwgts + i) = __idxsum(nparts, padjncy + i * nparts);
#line 199
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 201
  tmp___11 = __idxamax(nparts, kpwgts);
#line 201
  tmp___12 = __idxsum(nparts, kpwgts);
#line 201
  tmp___13 = __idxsum(nparts, kpwgts);
#line 201
  tmp___14 = __idxamax(nparts, kpwgts);
#line 201
  tmp___15 = __idxamin(nparts, kpwgts);
#line 201
  printf((char const   */* __restrict  */)"Min/Max/Avg/Bal # of adjacent     subdomains: %5ld %5ld %5ld %7.3f\n",
         *(kpwgts + tmp___15), *(kpwgts + tmp___14), tmp___13 / nparts, ((1.0 * (double )nparts) * (double )*(kpwgts + tmp___11)) / (1.0 * (double )tmp___12));
#line 205
  i = 0L;
  }
  {
#line 205
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 205
    if (! (i < nparts)) {
#line 205
      goto while_break___6;
    }
    {
#line 206
    *(kpwgts + i) = __idxsum(nparts, padjcut + i * nparts);
#line 205
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 207
  tmp___16 = __idxamax(nparts, kpwgts);
#line 207
  tmp___17 = __idxsum(nparts, kpwgts);
#line 207
  tmp___18 = __idxsum(nparts, kpwgts);
#line 207
  tmp___19 = __idxamax(nparts, kpwgts);
#line 207
  tmp___20 = __idxamin(nparts, kpwgts);
#line 207
  printf((char const   */* __restrict  */)"Min/Max/Avg/Bal # of adjacent subdomain cuts: %5ld %5ld %5ld %7.3f\n",
         *(kpwgts + tmp___20), *(kpwgts + tmp___19), tmp___18 / nparts, ((1.0 * (double )nparts) * (double )*(kpwgts + tmp___16)) / (1.0 * (double )tmp___17));
#line 211
  i = 0L;
  }
  {
#line 211
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 211
    if (! (i < nparts)) {
#line 211
      goto while_break___7;
    }
    {
#line 212
    *(kpwgts + i) = __idxsum(nparts, padjwgt + i * nparts);
#line 211
    i ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 213
  tmp___21 = __idxsum(nparts, kpwgts);
#line 213
  tmp___22 = __idxamax(nparts, kpwgts);
#line 213
  tmp___23 = __idxsum(nparts, kpwgts);
#line 213
  tmp___24 = __idxsum(nparts, kpwgts);
#line 213
  tmp___25 = __idxamax(nparts, kpwgts);
#line 213
  tmp___26 = __idxamin(nparts, kpwgts);
#line 213
  printf((char const   */* __restrict  */)"Min/Max/Avg/Bal/Frac # of interface    nodes: %5ld %5ld %5ld %7.3f %7.3f\n",
         *(kpwgts + tmp___26), *(kpwgts + tmp___25), tmp___24 / nparts, ((1.0 * (double )nparts) * (double )*(kpwgts + tmp___22)) / (1.0 * (double )tmp___23),
         (1.0 * (double )tmp___21) / (1.0 * (double )nvtxs));
  }
#line 218
  if (mustfree == 1L) {
    {
#line 219
    free((void *)vwgt);
#line 220
    graph->vwgt = (idxtype *)((void *)0);
    }
  } else
#line 218
  if (mustfree == 3L) {
    {
#line 219
    free((void *)vwgt);
#line 220
    graph->vwgt = (idxtype *)((void *)0);
    }
  }
#line 222
  if (mustfree == 2L) {
    {
#line 223
    free((void *)adjwgt);
#line 224
    graph->adjwgt = (idxtype *)((void *)0);
    }
  } else
#line 222
  if (mustfree == 3L) {
    {
#line 223
    free((void *)adjwgt);
#line 224
    graph->adjwgt = (idxtype *)((void *)0);
    }
  }
  {
#line 227
  __GKfree(& kpwgts, & padjncy, & padjwgt, & padjcut, (void **)0);
  }
#line 228
  return;
}
}
#line 235 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/stat.c"
void __ComputePartitionBalance(GraphType *graph , long nparts , idxtype *where , float *ubvec ) 
{ 
  long i ;
  long j ;
  long nvtxs ;
  long ncon ;
  idxtype *kpwgts ;
  idxtype *vwgt ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 241
  nvtxs = graph->nvtxs;
#line 242
  ncon = graph->ncon;
#line 243
  vwgt = graph->vwgt;
#line 245
  kpwgts = __idxsmalloc(nparts, (idxtype )0, (char *)"ComputePartitionInfo: kpwgts");
  }
#line 247
  if ((unsigned long )vwgt == (unsigned long )((void *)0)) {
#line 248
    i = 0L;
    {
#line 248
    while (1) {
      while_continue: /* CIL Label */ ;
#line 248
      if (! (i < nvtxs)) {
#line 248
        goto while_break;
      }
#line 249
      (*(kpwgts + *(where + i))) ++;
#line 248
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 250
    tmp = __idxamax(nparts, kpwgts);
#line 250
    *(ubvec + 0) = (float )(((1.0 * (double )nparts) * (double )*(kpwgts + tmp)) / (1.0 * (double )nvtxs));
    }
  } else {
#line 253
    j = 0L;
    {
#line 253
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 253
      if (! (j < ncon)) {
#line 253
        goto while_break___0;
      }
      {
#line 254
      __idxset(nparts, (idxtype )0, kpwgts);
#line 255
      i = 0L;
      }
      {
#line 255
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 255
        if (! (i < graph->nvtxs)) {
#line 255
          goto while_break___1;
        }
#line 256
        *(kpwgts + *(where + i)) += *(vwgt + (i * ncon + j));
#line 255
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 258
      tmp___0 = __idxamax(nparts, kpwgts);
#line 258
      tmp___1 = __idxsum(nparts, kpwgts);
#line 258
      *(ubvec + j) = (float )(((1.0 * (double )nparts) * (double )*(kpwgts + tmp___0)) / (1.0 * (double )tmp___1));
#line 253
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 262
  free((void *)kpwgts);
  }
#line 264
  return;
}
}
#line 270 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/stat.c"
float __ComputeElementBalance(long ne , long nparts , idxtype *where ) 
{ 
  long i ;
  idxtype *kpwgts ;
  float balance ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 276
  kpwgts = __idxsmalloc(nparts, (idxtype )0, (char *)"ComputeElementBalance: kpwgts");
#line 278
  i = 0L;
  }
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! (i < ne)) {
#line 278
      goto while_break;
    }
#line 279
    (*(kpwgts + *(where + i))) ++;
#line 278
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 281
  tmp = __idxamax(nparts, kpwgts);
#line 281
  tmp___0 = __idxsum(nparts, kpwgts);
#line 281
  balance = (float )(((1.0 * (double )nparts) * (double )*(kpwgts + tmp)) / (1.0 * (double )tmp___0));
#line 283
  free((void *)kpwgts);
  }
#line 285
  return (balance);
}
}
#line 396 "./proto.h"
long __ComputeMaxNodeGain(long nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ) ;
#line 21 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/sfm.c"
void __FM_2WayNodeRefine(CtrlType *ctrl , GraphType *graph , float ubfactor , long npasses ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long jj ;
  long kk ;
  long nvtxs ;
  long nbnd ;
  long nswaps ;
  long nmind ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *edegrees ;
  idxtype *bndind ;
  idxtype *bndptr ;
  idxtype *mptr ;
  idxtype *mind ;
  idxtype *moved ;
  idxtype *swaps ;
  idxtype *perm ;
  PQueueType parts[2] ;
  NRInfoType *rinfo ;
  long higain ;
  long oldgain ;
  long mincut ;
  long initcut ;
  long mincutorder ;
  long pass ;
  long to ;
  long other ;
  long limit ;
  long badmaxpwgt ;
  long mindiff ;
  long newdiff ;
  long u[2] ;
  long g[2] ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  idxtype tmp___6 ;
  long tmp___7 ;
  idxtype tmp___8 ;

  {
  {
#line 33
  nvtxs = graph->nvtxs;
#line 34
  xadj = graph->xadj;
#line 35
  adjncy = graph->adjncy;
#line 36
  vwgt = graph->vwgt;
#line 38
  bndind = graph->bndind;
#line 39
  bndptr = graph->bndptr;
#line 40
  where = graph->where;
#line 41
  pwgts = graph->pwgts;
#line 42
  rinfo = graph->nrinfo;
#line 45
  i = __ComputeMaxNodeGain(nvtxs, xadj, adjncy, vwgt);
#line 46
  __PQueueInit(ctrl, & parts[0], nvtxs, i);
#line 47
  __PQueueInit(ctrl, & parts[1], nvtxs, i);
#line 49
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 50
  swaps = __idxwspacemalloc(ctrl, nvtxs);
#line 51
  mptr = __idxwspacemalloc(ctrl, nvtxs + 1L);
#line 52
  mind = __idxwspacemalloc(ctrl, nvtxs);
#line 53
  perm = __idxwspacemalloc(ctrl, nvtxs);
  }
#line 55
  if (ctrl->dbglvl & 8L) {
    {
#line 55
    printf((char const   */* __restrict  */)"Partitions: [%6ld %6ld] Nv-Nb[%6ld %6ld]. ISep: %6ld\n",
           *(pwgts + 0), *(pwgts + 1), graph->nvtxs, graph->nbnd, graph->mincut);
    }
  }
#line 58
  badmaxpwgt = (long )((ubfactor * (float )((*(pwgts + 0) + *(pwgts + 1)) + *(pwgts + 2))) / (float )2);
#line 60
  pass = 0L;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (pass < npasses)) {
#line 60
      goto while_break;
    }
    {
#line 61
    __idxset(nvtxs, (idxtype )-1, moved);
#line 62
    __PQueueReset(& parts[0]);
#line 63
    __PQueueReset(& parts[1]);
#line 65
    mincutorder = -1L;
#line 66
    mincut = graph->mincut;
#line 66
    initcut = mincut;
#line 67
    nbnd = graph->nbnd;
#line 69
    __RandomPermute(nbnd, perm, 1L);
#line 70
    ii = 0L;
    }
    {
#line 70
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 70
      if (! (ii < nbnd)) {
#line 70
        goto while_break___0;
      }
      {
#line 71
      i = *(bndind + *(perm + ii));
#line 73
      __PQueueInsert(& parts[0], i, *(vwgt + i) - (rinfo + i)->edegrees[1]);
#line 74
      __PQueueInsert(& parts[1], i, *(vwgt + i) - (rinfo + i)->edegrees[0]);
#line 70
      ii ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 80
    if (ctrl->oflags & 1L) {
#line 80
      if (5L * nbnd >= 400L) {
#line 80
        tmp = 400L;
      } else {
#line 80
        tmp = 5L * nbnd;
      }
#line 80
      limit = tmp;
    } else {
#line 80
      if (2L * nbnd >= 300L) {
#line 80
        tmp___0 = 300L;
      } else {
#line 80
        tmp___0 = 2L * nbnd;
      }
#line 80
      limit = tmp___0;
    }
    {
#line 85
    nmind = 0L;
#line 85
    *(mptr + 0) = nmind;
#line 86
    tmp___1 = abs((int )(*(pwgts + 0) - *(pwgts + 1)));
#line 86
    mindiff = (long )tmp___1;
    }
#line 87
    if (*(pwgts + 0) < *(pwgts + 1)) {
#line 87
      to = 0L;
    } else {
#line 87
      to = 1L;
    }
#line 88
    nswaps = 0L;
    {
#line 88
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 88
      if (! (nswaps < nvtxs)) {
#line 88
        goto while_break___1;
      }
      {
#line 89
      u[0] = __PQueueSeeMax(& parts[0]);
#line 90
      u[1] = __PQueueSeeMax(& parts[1]);
      }
#line 91
      if (u[0] != -1L) {
#line 91
        if (u[1] != -1L) {
#line 92
          g[0] = *(vwgt + u[0]) - (rinfo + u[0])->edegrees[1];
#line 93
          g[1] = *(vwgt + u[1]) - (rinfo + u[1])->edegrees[0];
#line 95
          if (g[0] > g[1]) {
#line 95
            to = 0L;
          } else {
#line 95
            if (g[0] < g[1]) {
#line 95
              tmp___2 = 1L;
            } else {
#line 95
              tmp___2 = pass % 2L;
            }
#line 95
            to = tmp___2;
          }
#line 98
          if (*(pwgts + to) + *(vwgt + u[to]) > badmaxpwgt) {
#line 99
            to = (to + 1L) % 2L;
          }
        } else {
#line 91
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 101
      if (u[0] == -1L) {
#line 101
        if (u[1] == -1L) {
#line 102
          goto while_break___1;
        } else {
#line 101
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 104
      if (u[0] != -1L) {
#line 104
        if (*(pwgts + 0) + *(vwgt + u[0]) <= badmaxpwgt) {
#line 105
          to = 0L;
        } else {
#line 104
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 107
      if (u[1] != -1L) {
#line 107
        if (*(pwgts + 1) + *(vwgt + u[1]) <= badmaxpwgt) {
#line 108
          to = 1L;
        } else {
#line 111
          goto while_break___1;
        }
      } else {
#line 111
        goto while_break___1;
      }
      {
#line 113
      other = (to + 1L) % 2L;
#line 115
      higain = __PQueueGetMax(& parts[to]);
      }
#line 116
      if (*(moved + higain) == -1L) {
        {
#line 117
        __PQueueDelete(& parts[other], higain, *(vwgt + higain) - (rinfo + higain)->edegrees[to]);
        }
      }
      {
#line 121
      *(pwgts + 2) -= *(vwgt + higain) - (rinfo + higain)->edegrees[other];
#line 123
      tmp___3 = abs((int )((*(pwgts + to) + *(vwgt + higain)) - (*(pwgts + other) - (rinfo + higain)->edegrees[other])));
#line 123
      newdiff = (long )tmp___3;
      }
#line 124
      if (*(pwgts + 2) < mincut) {
#line 125
        mincut = *(pwgts + 2);
#line 126
        mincutorder = nswaps;
#line 127
        mindiff = newdiff;
      } else
#line 124
      if (*(pwgts + 2) == mincut) {
#line 124
        if (newdiff < mindiff) {
#line 125
          mincut = *(pwgts + 2);
#line 126
          mincutorder = nswaps;
#line 127
          mindiff = newdiff;
        } else {
#line 124
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 130
      if (nswaps - mincutorder > limit) {
#line 131
        *(pwgts + 2) += *(vwgt + higain) - (rinfo + higain)->edegrees[other];
#line 132
        goto while_break___1;
      }
      {
#line 136
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 136
        nbnd --;
#line 136
        *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 136
        *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 136
        *(bndptr + higain) = (idxtype )-1;
#line 136
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 137
      *(pwgts + to) += *(vwgt + higain);
#line 138
      *(where + higain) = to;
#line 139
      *(moved + higain) = nswaps;
#line 140
      *(swaps + nswaps) = higain;
#line 146
      j = *(xadj + higain);
      {
#line 146
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 146
        if (! (j < *(xadj + (higain + 1L)))) {
#line 146
          goto while_break___3;
        }
#line 147
        k = *(adjncy + j);
#line 148
        if (*(where + k) == 2L) {
#line 149
          oldgain = *(vwgt + k) - (rinfo + k)->edegrees[to];
#line 150
          (rinfo + k)->edegrees[to] += *(vwgt + higain);
#line 151
          if (*(moved + k) == -1L) {
            {
#line 152
            __PQueueUpdate(& parts[other], k, oldgain, oldgain - *(vwgt + higain));
            }
          } else
#line 151
          if (*(moved + k) == - (2L + other)) {
            {
#line 152
            __PQueueUpdate(& parts[other], k, oldgain, oldgain - *(vwgt + higain));
            }
          }
        } else
#line 154
        if (*(where + k) == other) {
          {
#line 156
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 156
            *(bndind + nbnd) = k;
#line 156
            tmp___4 = nbnd;
#line 156
            nbnd ++;
#line 156
            *(bndptr + k) = tmp___4;
#line 156
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 158
          tmp___5 = nmind;
#line 158
          nmind ++;
#line 158
          *(mind + tmp___5) = k;
#line 159
          *(where + k) = (idxtype )2;
#line 160
          *(pwgts + other) -= *(vwgt + k);
#line 162
          edegrees = (rinfo + k)->edegrees;
#line 163
          tmp___6 = (idxtype )0;
#line 163
          *(edegrees + 1) = tmp___6;
#line 163
          *(edegrees + 0) = tmp___6;
#line 164
          jj = *(xadj + k);
          {
#line 164
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 164
            if (! (jj < *(xadj + (k + 1L)))) {
#line 164
              goto while_break___5;
            }
#line 165
            kk = *(adjncy + jj);
#line 166
            if (*(where + kk) != 2L) {
#line 167
              *(edegrees + *(where + kk)) += *(vwgt + kk);
            } else {
#line 169
              oldgain = *(vwgt + kk) - (rinfo + kk)->edegrees[other];
#line 170
              (rinfo + kk)->edegrees[other] -= *(vwgt + k);
#line 171
              if (*(moved + kk) == -1L) {
                {
#line 172
                __PQueueUpdate(& parts[to], kk, oldgain, oldgain + *(vwgt + k));
                }
              } else
#line 171
              if (*(moved + kk) == - (2L + to)) {
                {
#line 172
                __PQueueUpdate(& parts[to], kk, oldgain, oldgain + *(vwgt + k));
                }
              }
            }
#line 164
            jj ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 177
          if (*(moved + k) == -1L) {
            {
#line 178
            __PQueueInsert(& parts[to], k, *(vwgt + k) - *(edegrees + other));
#line 179
            *(moved + k) = - (2L + to);
            }
          }
        }
#line 146
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 183
      *(mptr + (nswaps + 1L)) = nmind;
#line 185
      if (ctrl->dbglvl & 32L) {
        {
#line 185
        printf((char const   */* __restrict  */)"Moved %6ld to %3ld, Gain: %5ld [%5ld] [%4ld %4ld] \t[%5ld %5ld %5ld]\n",
               higain, to, g[to], g[other], *(vwgt + u[to]), *(vwgt + u[other]), *(pwgts + 0),
               *(pwgts + 1), *(pwgts + 2));
        }
      }
#line 88
      nswaps ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 194
    nswaps --;
    {
#line 194
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 194
      if (! (nswaps > mincutorder)) {
#line 194
        goto while_break___6;
      }
#line 195
      higain = *(swaps + nswaps);
#line 199
      to = *(where + higain);
#line 200
      other = (to + 1L) % 2L;
      {
#line 201
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 201
        *(pwgts + 2) += *(vwgt + higain);
#line 201
        *(pwgts + to) -= *(vwgt + higain);
#line 201
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 202
      *(where + higain) = (idxtype )2;
      {
#line 203
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 203
        *(bndind + nbnd) = higain;
#line 203
        tmp___7 = nbnd;
#line 203
        nbnd ++;
#line 203
        *(bndptr + higain) = tmp___7;
#line 203
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 205
      edegrees = (rinfo + higain)->edegrees;
#line 206
      tmp___8 = (idxtype )0;
#line 206
      *(edegrees + 1) = tmp___8;
#line 206
      *(edegrees + 0) = tmp___8;
#line 207
      j = *(xadj + higain);
      {
#line 207
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 207
        if (! (j < *(xadj + (higain + 1L)))) {
#line 207
          goto while_break___9;
        }
#line 208
        k = *(adjncy + j);
#line 209
        if (*(where + k) == 2L) {
#line 210
          (rinfo + k)->edegrees[to] -= *(vwgt + higain);
        } else {
#line 212
          *(edegrees + *(where + k)) += *(vwgt + k);
        }
#line 207
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 216
      j = *(mptr + nswaps);
      {
#line 216
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 216
        if (! (j < *(mptr + (nswaps + 1L)))) {
#line 216
          goto while_break___10;
        }
#line 217
        k = *(mind + j);
#line 219
        *(where + k) = other;
        {
#line 220
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 220
          *(pwgts + other) += *(vwgt + k);
#line 220
          *(pwgts + 2) -= *(vwgt + k);
#line 220
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 221
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 221
          nbnd --;
#line 221
          *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 221
          *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 221
          *(bndptr + k) = (idxtype )-1;
#line 221
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 222
        jj = *(xadj + k);
        {
#line 222
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 222
          if (! (jj < *(xadj + (k + 1L)))) {
#line 222
            goto while_break___13;
          }
#line 223
          kk = *(adjncy + jj);
#line 224
          if (*(where + kk) == 2L) {
#line 225
            (rinfo + kk)->edegrees[other] += *(vwgt + k);
          }
#line 222
          jj ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 216
        j ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 194
      nswaps --;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 232
    if (ctrl->dbglvl & 8L) {
      {
#line 232
      printf((char const   */* __restrict  */)"\tMinimum sep: %6ld at %5ld, PWGTS: [%6ld %6ld], NBND: %6ld\n",
             mincut, mincutorder, *(pwgts + 0), *(pwgts + 1), nbnd);
      }
    }
#line 235
    graph->mincut = mincut;
#line 236
    graph->nbnd = nbnd;
#line 238
    if (mincutorder == -1L) {
#line 239
      goto while_break;
    } else
#line 238
    if (mincut >= initcut) {
#line 239
      goto while_break;
    }
#line 60
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  __PQueueFree(ctrl, & parts[0]);
#line 243
  __PQueueFree(ctrl, & parts[1]);
#line 245
  __idxwspacefree(ctrl, nvtxs + 1L);
#line 246
  __idxwspacefree(ctrl, nvtxs);
#line 247
  __idxwspacefree(ctrl, nvtxs);
#line 248
  __idxwspacefree(ctrl, nvtxs);
#line 249
  __idxwspacefree(ctrl, nvtxs);
  }
#line 250
  return;
}
}
#line 256 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/sfm.c"
void FM_2WayNodeRefine2(CtrlType *ctrl , GraphType *graph , float ubfactor , long npasses ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long jj ;
  long kk ;
  long nvtxs ;
  long nbnd ;
  long nswaps ;
  long nmind ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *edegrees ;
  idxtype *bndind ;
  idxtype *bndptr ;
  idxtype *mptr ;
  idxtype *mind ;
  idxtype *moved ;
  idxtype *swaps ;
  idxtype *perm ;
  PQueueType parts[2] ;
  NRInfoType *rinfo ;
  long higain ;
  long oldgain ;
  long mincut ;
  long initcut ;
  long mincutorder ;
  long pass ;
  long to ;
  long other ;
  long limit ;
  long badmaxpwgt ;
  long mindiff ;
  long newdiff ;
  long u[2] ;
  long g[2] ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  idxtype tmp___6 ;
  long tmp___7 ;
  idxtype tmp___8 ;

  {
  {
#line 268
  nvtxs = graph->nvtxs;
#line 269
  xadj = graph->xadj;
#line 270
  adjncy = graph->adjncy;
#line 271
  vwgt = graph->vwgt;
#line 273
  bndind = graph->bndind;
#line 274
  bndptr = graph->bndptr;
#line 275
  where = graph->where;
#line 276
  pwgts = graph->pwgts;
#line 277
  rinfo = graph->nrinfo;
#line 280
  i = __ComputeMaxNodeGain(nvtxs, xadj, adjncy, vwgt);
#line 281
  __PQueueInit(ctrl, & parts[0], nvtxs, i);
#line 282
  __PQueueInit(ctrl, & parts[1], nvtxs, i);
#line 284
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 285
  swaps = __idxwspacemalloc(ctrl, nvtxs);
#line 286
  mptr = __idxwspacemalloc(ctrl, nvtxs + 1L);
#line 287
  mind = __idxwspacemalloc(ctrl, nvtxs);
#line 288
  perm = __idxwspacemalloc(ctrl, nvtxs);
  }
#line 290
  if (ctrl->dbglvl & 8L) {
    {
#line 290
    printf((char const   */* __restrict  */)"Partitions: [%6ld %6ld] Nv-Nb[%6ld %6ld]. ISep: %6ld\n",
           *(pwgts + 0), *(pwgts + 1), graph->nvtxs, graph->nbnd, graph->mincut);
    }
  }
#line 293
  badmaxpwgt = (long )((ubfactor * (float )((*(pwgts + 0) + *(pwgts + 1)) + *(pwgts + 2))) / (float )2);
#line 295
  pass = 0L;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! (pass < npasses)) {
#line 295
      goto while_break;
    }
    {
#line 296
    __idxset(nvtxs, (idxtype )-1, moved);
#line 297
    __PQueueReset(& parts[0]);
#line 298
    __PQueueReset(& parts[1]);
#line 300
    mincutorder = -1L;
#line 301
    mincut = graph->mincut;
#line 301
    initcut = mincut;
#line 302
    nbnd = graph->nbnd;
#line 304
    __RandomPermute(nbnd, perm, 1L);
#line 305
    ii = 0L;
    }
    {
#line 305
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 305
      if (! (ii < nbnd)) {
#line 305
        goto while_break___0;
      }
      {
#line 306
      i = *(bndind + *(perm + ii));
#line 308
      __PQueueInsert(& parts[0], i, *(vwgt + i) - (rinfo + i)->edegrees[1]);
#line 309
      __PQueueInsert(& parts[1], i, *(vwgt + i) - (rinfo + i)->edegrees[0]);
#line 305
      ii ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 315
    if (ctrl->oflags & 1L) {
#line 315
      if (5L * nbnd >= 400L) {
#line 315
        tmp = 400L;
      } else {
#line 315
        tmp = 5L * nbnd;
      }
#line 315
      limit = tmp;
    } else {
#line 315
      if (2L * nbnd >= 300L) {
#line 315
        tmp___0 = 300L;
      } else {
#line 315
        tmp___0 = 2L * nbnd;
      }
#line 315
      limit = tmp___0;
    }
    {
#line 320
    nmind = 0L;
#line 320
    *(mptr + 0) = nmind;
#line 321
    tmp___1 = abs((int )(*(pwgts + 0) - *(pwgts + 1)));
#line 321
    mindiff = (long )tmp___1;
    }
#line 322
    if (*(pwgts + 0) < *(pwgts + 1)) {
#line 322
      to = 0L;
    } else {
#line 322
      to = 1L;
    }
#line 323
    nswaps = 0L;
    {
#line 323
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 323
      if (! (nswaps < nvtxs)) {
#line 323
        goto while_break___1;
      }
      {
#line 324
      badmaxpwgt = (long )((ubfactor * (float )((*(pwgts + 0) + *(pwgts + 1)) + *(pwgts + 2) / 2L)) / (float )2);
#line 326
      u[0] = __PQueueSeeMax(& parts[0]);
#line 327
      u[1] = __PQueueSeeMax(& parts[1]);
      }
#line 328
      if (u[0] != -1L) {
#line 328
        if (u[1] != -1L) {
#line 329
          g[0] = *(vwgt + u[0]) - (rinfo + u[0])->edegrees[1];
#line 330
          g[1] = *(vwgt + u[1]) - (rinfo + u[1])->edegrees[0];
#line 332
          if (g[0] > g[1]) {
#line 332
            to = 0L;
          } else {
#line 332
            if (g[0] < g[1]) {
#line 332
              tmp___2 = 1L;
            } else {
#line 332
              tmp___2 = pass % 2L;
            }
#line 332
            to = tmp___2;
          }
#line 335
          if (*(pwgts + to) + *(vwgt + u[to]) > badmaxpwgt) {
#line 336
            to = (to + 1L) % 2L;
          }
        } else {
#line 328
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 338
      if (u[0] == -1L) {
#line 338
        if (u[1] == -1L) {
#line 339
          goto while_break___1;
        } else {
#line 338
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 341
      if (u[0] != -1L) {
#line 341
        if (*(pwgts + 0) + *(vwgt + u[0]) <= badmaxpwgt) {
#line 342
          to = 0L;
        } else {
#line 341
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 344
      if (u[1] != -1L) {
#line 344
        if (*(pwgts + 1) + *(vwgt + u[1]) <= badmaxpwgt) {
#line 345
          to = 1L;
        } else {
#line 348
          goto while_break___1;
        }
      } else {
#line 348
        goto while_break___1;
      }
      {
#line 350
      other = (to + 1L) % 2L;
#line 352
      higain = __PQueueGetMax(& parts[to]);
      }
#line 353
      if (*(moved + higain) == -1L) {
        {
#line 354
        __PQueueDelete(& parts[other], higain, *(vwgt + higain) - (rinfo + higain)->edegrees[to]);
        }
      }
      {
#line 358
      *(pwgts + 2) -= *(vwgt + higain) - (rinfo + higain)->edegrees[other];
#line 360
      tmp___3 = abs((int )((*(pwgts + to) + *(vwgt + higain)) - (*(pwgts + other) - (rinfo + higain)->edegrees[other])));
#line 360
      newdiff = (long )tmp___3;
      }
#line 361
      if (*(pwgts + 2) < mincut) {
#line 362
        mincut = *(pwgts + 2);
#line 363
        mincutorder = nswaps;
#line 364
        mindiff = newdiff;
      } else
#line 361
      if (*(pwgts + 2) == mincut) {
#line 361
        if (newdiff < mindiff) {
#line 362
          mincut = *(pwgts + 2);
#line 363
          mincutorder = nswaps;
#line 364
          mindiff = newdiff;
        } else {
#line 361
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 367
      if (nswaps - mincutorder > limit) {
#line 368
        *(pwgts + 2) += *(vwgt + higain) - (rinfo + higain)->edegrees[other];
#line 369
        goto while_break___1;
      }
      {
#line 373
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 373
        nbnd --;
#line 373
        *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 373
        *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 373
        *(bndptr + higain) = (idxtype )-1;
#line 373
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 374
      *(pwgts + to) += *(vwgt + higain);
#line 375
      *(where + higain) = to;
#line 376
      *(moved + higain) = nswaps;
#line 377
      *(swaps + nswaps) = higain;
#line 383
      j = *(xadj + higain);
      {
#line 383
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 383
        if (! (j < *(xadj + (higain + 1L)))) {
#line 383
          goto while_break___3;
        }
#line 384
        k = *(adjncy + j);
#line 385
        if (*(where + k) == 2L) {
#line 386
          oldgain = *(vwgt + k) - (rinfo + k)->edegrees[to];
#line 387
          (rinfo + k)->edegrees[to] += *(vwgt + higain);
#line 388
          if (*(moved + k) == -1L) {
            {
#line 389
            __PQueueUpdate(& parts[other], k, oldgain, oldgain - *(vwgt + higain));
            }
          } else
#line 388
          if (*(moved + k) == - (2L + other)) {
            {
#line 389
            __PQueueUpdate(& parts[other], k, oldgain, oldgain - *(vwgt + higain));
            }
          }
        } else
#line 391
        if (*(where + k) == other) {
          {
#line 393
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 393
            *(bndind + nbnd) = k;
#line 393
            tmp___4 = nbnd;
#line 393
            nbnd ++;
#line 393
            *(bndptr + k) = tmp___4;
#line 393
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 395
          tmp___5 = nmind;
#line 395
          nmind ++;
#line 395
          *(mind + tmp___5) = k;
#line 396
          *(where + k) = (idxtype )2;
#line 397
          *(pwgts + other) -= *(vwgt + k);
#line 399
          edegrees = (rinfo + k)->edegrees;
#line 400
          tmp___6 = (idxtype )0;
#line 400
          *(edegrees + 1) = tmp___6;
#line 400
          *(edegrees + 0) = tmp___6;
#line 401
          jj = *(xadj + k);
          {
#line 401
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 401
            if (! (jj < *(xadj + (k + 1L)))) {
#line 401
              goto while_break___5;
            }
#line 402
            kk = *(adjncy + jj);
#line 403
            if (*(where + kk) != 2L) {
#line 404
              *(edegrees + *(where + kk)) += *(vwgt + kk);
            } else {
#line 406
              oldgain = *(vwgt + kk) - (rinfo + kk)->edegrees[other];
#line 407
              (rinfo + kk)->edegrees[other] -= *(vwgt + k);
#line 408
              if (*(moved + kk) == -1L) {
                {
#line 409
                __PQueueUpdate(& parts[to], kk, oldgain, oldgain + *(vwgt + k));
                }
              } else
#line 408
              if (*(moved + kk) == - (2L + to)) {
                {
#line 409
                __PQueueUpdate(& parts[to], kk, oldgain, oldgain + *(vwgt + k));
                }
              }
            }
#line 401
            jj ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 414
          if (*(moved + k) == -1L) {
            {
#line 415
            __PQueueInsert(& parts[to], k, *(vwgt + k) - *(edegrees + other));
#line 416
            *(moved + k) = - (2L + to);
            }
          }
        }
#line 383
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 420
      *(mptr + (nswaps + 1L)) = nmind;
#line 422
      if (ctrl->dbglvl & 32L) {
        {
#line 422
        printf((char const   */* __restrict  */)"Moved %6ld to %3ld, Gain: %5ld [%5ld] [%4ld %4ld] \t[%5ld %5ld %5ld]\n",
               higain, to, g[to], g[other], *(vwgt + u[to]), *(vwgt + u[other]), *(pwgts + 0),
               *(pwgts + 1), *(pwgts + 2));
        }
      }
#line 323
      nswaps ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 431
    nswaps --;
    {
#line 431
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 431
      if (! (nswaps > mincutorder)) {
#line 431
        goto while_break___6;
      }
#line 432
      higain = *(swaps + nswaps);
#line 436
      to = *(where + higain);
#line 437
      other = (to + 1L) % 2L;
      {
#line 438
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 438
        *(pwgts + 2) += *(vwgt + higain);
#line 438
        *(pwgts + to) -= *(vwgt + higain);
#line 438
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 439
      *(where + higain) = (idxtype )2;
      {
#line 440
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 440
        *(bndind + nbnd) = higain;
#line 440
        tmp___7 = nbnd;
#line 440
        nbnd ++;
#line 440
        *(bndptr + higain) = tmp___7;
#line 440
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 442
      edegrees = (rinfo + higain)->edegrees;
#line 443
      tmp___8 = (idxtype )0;
#line 443
      *(edegrees + 1) = tmp___8;
#line 443
      *(edegrees + 0) = tmp___8;
#line 444
      j = *(xadj + higain);
      {
#line 444
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 444
        if (! (j < *(xadj + (higain + 1L)))) {
#line 444
          goto while_break___9;
        }
#line 445
        k = *(adjncy + j);
#line 446
        if (*(where + k) == 2L) {
#line 447
          (rinfo + k)->edegrees[to] -= *(vwgt + higain);
        } else {
#line 449
          *(edegrees + *(where + k)) += *(vwgt + k);
        }
#line 444
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 453
      j = *(mptr + nswaps);
      {
#line 453
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 453
        if (! (j < *(mptr + (nswaps + 1L)))) {
#line 453
          goto while_break___10;
        }
#line 454
        k = *(mind + j);
#line 456
        *(where + k) = other;
        {
#line 457
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 457
          *(pwgts + other) += *(vwgt + k);
#line 457
          *(pwgts + 2) -= *(vwgt + k);
#line 457
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 458
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 458
          nbnd --;
#line 458
          *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 458
          *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 458
          *(bndptr + k) = (idxtype )-1;
#line 458
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 459
        jj = *(xadj + k);
        {
#line 459
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 459
          if (! (jj < *(xadj + (k + 1L)))) {
#line 459
            goto while_break___13;
          }
#line 460
          kk = *(adjncy + jj);
#line 461
          if (*(where + kk) == 2L) {
#line 462
            (rinfo + kk)->edegrees[other] += *(vwgt + k);
          }
#line 459
          jj ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 453
        j ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 431
      nswaps --;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 469
    if (ctrl->dbglvl & 8L) {
      {
#line 469
      printf((char const   */* __restrict  */)"\tMinimum sep: %6ld at %5ld, PWGTS: [%6ld %6ld], NBND: %6ld\n",
             mincut, mincutorder, *(pwgts + 0), *(pwgts + 1), nbnd);
      }
    }
#line 472
    graph->mincut = mincut;
#line 473
    graph->nbnd = nbnd;
#line 475
    if (mincutorder == -1L) {
#line 476
      goto while_break;
    } else
#line 475
    if (mincut >= initcut) {
#line 476
      goto while_break;
    }
#line 295
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 479
  __PQueueFree(ctrl, & parts[0]);
#line 480
  __PQueueFree(ctrl, & parts[1]);
#line 482
  __idxwspacefree(ctrl, nvtxs + 1L);
#line 483
  __idxwspacefree(ctrl, nvtxs);
#line 484
  __idxwspacefree(ctrl, nvtxs);
#line 485
  __idxwspacefree(ctrl, nvtxs);
#line 486
  __idxwspacefree(ctrl, nvtxs);
  }
#line 487
  return;
}
}
#line 493 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/sfm.c"
void __FM_2WayNodeRefineEqWgt(CtrlType *ctrl , GraphType *graph , long npasses ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long jj ;
  long kk ;
  long nvtxs ;
  long nbnd ;
  long nswaps ;
  long nmind ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *edegrees ;
  idxtype *bndind ;
  idxtype *bndptr ;
  idxtype *mptr ;
  idxtype *mind ;
  idxtype *moved ;
  idxtype *swaps ;
  idxtype *perm ;
  PQueueType parts[2] ;
  NRInfoType *rinfo ;
  long higain ;
  long oldgain ;
  long mincut ;
  long initcut ;
  long mincutorder ;
  long pass ;
  long to ;
  long other ;
  long limit ;
  long mindiff ;
  long newdiff ;
  long u[2] ;
  long g[2] ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  idxtype tmp___6 ;
  long tmp___7 ;
  idxtype tmp___8 ;

  {
  {
#line 505
  nvtxs = graph->nvtxs;
#line 506
  xadj = graph->xadj;
#line 507
  adjncy = graph->adjncy;
#line 508
  vwgt = graph->vwgt;
#line 510
  bndind = graph->bndind;
#line 511
  bndptr = graph->bndptr;
#line 512
  where = graph->where;
#line 513
  pwgts = graph->pwgts;
#line 514
  rinfo = graph->nrinfo;
#line 517
  i = __ComputeMaxNodeGain(nvtxs, xadj, adjncy, vwgt);
#line 518
  __PQueueInit(ctrl, & parts[0], nvtxs, i);
#line 519
  __PQueueInit(ctrl, & parts[1], nvtxs, i);
#line 521
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 522
  swaps = __idxwspacemalloc(ctrl, nvtxs);
#line 523
  mptr = __idxwspacemalloc(ctrl, nvtxs + 1L);
#line 524
  mind = __idxwspacemalloc(ctrl, nvtxs);
#line 525
  perm = __idxwspacemalloc(ctrl, nvtxs);
  }
#line 527
  if (ctrl->dbglvl & 8L) {
    {
#line 527
    printf((char const   */* __restrict  */)"Partitions: [%6ld %6ld] Nv-Nb[%6ld %6ld]. ISep: %6ld\n",
           *(pwgts + 0), *(pwgts + 1), graph->nvtxs, graph->nbnd, graph->mincut);
    }
  }
#line 530
  pass = 0L;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    if (! (pass < npasses)) {
#line 530
      goto while_break;
    }
    {
#line 531
    __idxset(nvtxs, (idxtype )-1, moved);
#line 532
    __PQueueReset(& parts[0]);
#line 533
    __PQueueReset(& parts[1]);
#line 535
    mincutorder = -1L;
#line 536
    mincut = graph->mincut;
#line 536
    initcut = mincut;
#line 537
    nbnd = graph->nbnd;
#line 539
    __RandomPermute(nbnd, perm, 1L);
#line 540
    ii = 0L;
    }
    {
#line 540
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 540
      if (! (ii < nbnd)) {
#line 540
        goto while_break___0;
      }
      {
#line 541
      i = *(bndind + *(perm + ii));
#line 543
      __PQueueInsert(& parts[0], i, *(vwgt + i) - (rinfo + i)->edegrees[1]);
#line 544
      __PQueueInsert(& parts[1], i, *(vwgt + i) - (rinfo + i)->edegrees[0]);
#line 540
      ii ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 550
    if (ctrl->oflags & 1L) {
#line 550
      if (5L * nbnd >= 400L) {
#line 550
        tmp = 400L;
      } else {
#line 550
        tmp = 5L * nbnd;
      }
#line 550
      limit = tmp;
    } else {
#line 550
      if (2L * nbnd >= 300L) {
#line 550
        tmp___0 = 300L;
      } else {
#line 550
        tmp___0 = 2L * nbnd;
      }
#line 550
      limit = tmp___0;
    }
    {
#line 555
    nmind = 0L;
#line 555
    *(mptr + 0) = nmind;
#line 556
    tmp___1 = abs((int )(*(pwgts + 0) - *(pwgts + 1)));
#line 556
    mindiff = (long )tmp___1;
    }
#line 557
    if (*(pwgts + 0) < *(pwgts + 1)) {
#line 557
      to = 0L;
    } else {
#line 557
      to = 1L;
    }
#line 558
    nswaps = 0L;
    {
#line 558
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 558
      if (! (nswaps < nvtxs)) {
#line 558
        goto while_break___1;
      }
#line 559
      if (*(pwgts + 0) < *(pwgts + 1)) {
#line 559
        to = 0L;
      } else {
#line 559
        to = 1L;
      }
#line 561
      if (*(pwgts + 0) == *(pwgts + 1)) {
        {
#line 562
        u[0] = __PQueueSeeMax(& parts[0]);
#line 563
        u[1] = __PQueueSeeMax(& parts[1]);
        }
#line 564
        if (u[0] != -1L) {
#line 564
          if (u[1] != -1L) {
#line 565
            g[0] = *(vwgt + u[0]) - (rinfo + u[0])->edegrees[1];
#line 566
            g[1] = *(vwgt + u[1]) - (rinfo + u[1])->edegrees[0];
#line 568
            if (g[0] > g[1]) {
#line 568
              to = 0L;
            } else {
#line 568
              if (g[0] < g[1]) {
#line 568
                tmp___2 = 1L;
              } else {
#line 568
                tmp___2 = pass % 2L;
              }
#line 568
              to = tmp___2;
            }
          }
        }
      }
      {
#line 571
      other = (to + 1L) % 2L;
#line 573
      higain = __PQueueGetMax(& parts[to]);
      }
#line 573
      if (higain == -1L) {
#line 574
        goto while_break___1;
      }
#line 576
      if (*(moved + higain) == -1L) {
        {
#line 577
        __PQueueDelete(& parts[other], higain, *(vwgt + higain) - (rinfo + higain)->edegrees[to]);
        }
      }
      {
#line 581
      *(pwgts + 2) -= *(vwgt + higain) - (rinfo + higain)->edegrees[other];
#line 583
      tmp___3 = abs((int )((*(pwgts + to) + *(vwgt + higain)) - (*(pwgts + other) - (rinfo + higain)->edegrees[other])));
#line 583
      newdiff = (long )tmp___3;
      }
#line 584
      if (*(pwgts + 2) < mincut) {
#line 585
        mincut = *(pwgts + 2);
#line 586
        mincutorder = nswaps;
#line 587
        mindiff = newdiff;
      } else
#line 584
      if (*(pwgts + 2) == mincut) {
#line 584
        if (newdiff < mindiff) {
#line 585
          mincut = *(pwgts + 2);
#line 586
          mincutorder = nswaps;
#line 587
          mindiff = newdiff;
        } else {
#line 584
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 590
      if (nswaps - mincutorder > limit) {
#line 591
        *(pwgts + 2) += *(vwgt + higain) - (rinfo + higain)->edegrees[other];
#line 592
        goto while_break___1;
      }
      {
#line 596
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 596
        nbnd --;
#line 596
        *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 596
        *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 596
        *(bndptr + higain) = (idxtype )-1;
#line 596
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 597
      *(pwgts + to) += *(vwgt + higain);
#line 598
      *(where + higain) = to;
#line 599
      *(moved + higain) = nswaps;
#line 600
      *(swaps + nswaps) = higain;
#line 606
      j = *(xadj + higain);
      {
#line 606
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 606
        if (! (j < *(xadj + (higain + 1L)))) {
#line 606
          goto while_break___3;
        }
#line 607
        k = *(adjncy + j);
#line 608
        if (*(where + k) == 2L) {
#line 609
          oldgain = *(vwgt + k) - (rinfo + k)->edegrees[to];
#line 610
          (rinfo + k)->edegrees[to] += *(vwgt + higain);
#line 611
          if (*(moved + k) == -1L) {
            {
#line 612
            __PQueueUpdate(& parts[other], k, oldgain, oldgain - *(vwgt + higain));
            }
          } else
#line 611
          if (*(moved + k) == - (2L + other)) {
            {
#line 612
            __PQueueUpdate(& parts[other], k, oldgain, oldgain - *(vwgt + higain));
            }
          }
        } else
#line 614
        if (*(where + k) == other) {
          {
#line 616
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 616
            *(bndind + nbnd) = k;
#line 616
            tmp___4 = nbnd;
#line 616
            nbnd ++;
#line 616
            *(bndptr + k) = tmp___4;
#line 616
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 618
          tmp___5 = nmind;
#line 618
          nmind ++;
#line 618
          *(mind + tmp___5) = k;
#line 619
          *(where + k) = (idxtype )2;
#line 620
          *(pwgts + other) -= *(vwgt + k);
#line 622
          edegrees = (rinfo + k)->edegrees;
#line 623
          tmp___6 = (idxtype )0;
#line 623
          *(edegrees + 1) = tmp___6;
#line 623
          *(edegrees + 0) = tmp___6;
#line 624
          jj = *(xadj + k);
          {
#line 624
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 624
            if (! (jj < *(xadj + (k + 1L)))) {
#line 624
              goto while_break___5;
            }
#line 625
            kk = *(adjncy + jj);
#line 626
            if (*(where + kk) != 2L) {
#line 627
              *(edegrees + *(where + kk)) += *(vwgt + kk);
            } else {
#line 629
              oldgain = *(vwgt + kk) - (rinfo + kk)->edegrees[other];
#line 630
              (rinfo + kk)->edegrees[other] -= *(vwgt + k);
#line 631
              if (*(moved + kk) == -1L) {
                {
#line 632
                __PQueueUpdate(& parts[to], kk, oldgain, oldgain + *(vwgt + k));
                }
              } else
#line 631
              if (*(moved + kk) == - (2L + to)) {
                {
#line 632
                __PQueueUpdate(& parts[to], kk, oldgain, oldgain + *(vwgt + k));
                }
              }
            }
#line 624
            jj ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 637
          if (*(moved + k) == -1L) {
            {
#line 638
            __PQueueInsert(& parts[to], k, *(vwgt + k) - *(edegrees + other));
#line 639
            *(moved + k) = - (2L + to);
            }
          }
        }
#line 606
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 643
      *(mptr + (nswaps + 1L)) = nmind;
#line 645
      if (ctrl->dbglvl & 32L) {
        {
#line 645
        printf((char const   */* __restrict  */)"Moved %6ld to %3ld, Gain: %5ld [%5ld] [%4ld %4ld] \t[%5ld %5ld %5ld]\n",
               higain, to, g[to], g[other], *(vwgt + u[to]), *(vwgt + u[other]), *(pwgts + 0),
               *(pwgts + 1), *(pwgts + 2));
        }
      }
#line 558
      nswaps ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 654
    nswaps --;
    {
#line 654
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 654
      if (! (nswaps > mincutorder)) {
#line 654
        goto while_break___6;
      }
#line 655
      higain = *(swaps + nswaps);
#line 659
      to = *(where + higain);
#line 660
      other = (to + 1L) % 2L;
      {
#line 661
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 661
        *(pwgts + 2) += *(vwgt + higain);
#line 661
        *(pwgts + to) -= *(vwgt + higain);
#line 661
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 662
      *(where + higain) = (idxtype )2;
      {
#line 663
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 663
        *(bndind + nbnd) = higain;
#line 663
        tmp___7 = nbnd;
#line 663
        nbnd ++;
#line 663
        *(bndptr + higain) = tmp___7;
#line 663
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 665
      edegrees = (rinfo + higain)->edegrees;
#line 666
      tmp___8 = (idxtype )0;
#line 666
      *(edegrees + 1) = tmp___8;
#line 666
      *(edegrees + 0) = tmp___8;
#line 667
      j = *(xadj + higain);
      {
#line 667
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 667
        if (! (j < *(xadj + (higain + 1L)))) {
#line 667
          goto while_break___9;
        }
#line 668
        k = *(adjncy + j);
#line 669
        if (*(where + k) == 2L) {
#line 670
          (rinfo + k)->edegrees[to] -= *(vwgt + higain);
        } else {
#line 672
          *(edegrees + *(where + k)) += *(vwgt + k);
        }
#line 667
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 676
      j = *(mptr + nswaps);
      {
#line 676
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 676
        if (! (j < *(mptr + (nswaps + 1L)))) {
#line 676
          goto while_break___10;
        }
#line 677
        k = *(mind + j);
#line 679
        *(where + k) = other;
        {
#line 680
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 680
          *(pwgts + other) += *(vwgt + k);
#line 680
          *(pwgts + 2) -= *(vwgt + k);
#line 680
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 681
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 681
          nbnd --;
#line 681
          *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 681
          *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 681
          *(bndptr + k) = (idxtype )-1;
#line 681
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 682
        jj = *(xadj + k);
        {
#line 682
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 682
          if (! (jj < *(xadj + (k + 1L)))) {
#line 682
            goto while_break___13;
          }
#line 683
          kk = *(adjncy + jj);
#line 684
          if (*(where + kk) == 2L) {
#line 685
            (rinfo + kk)->edegrees[other] += *(vwgt + k);
          }
#line 682
          jj ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 676
        j ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 654
      nswaps --;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 692
    if (ctrl->dbglvl & 8L) {
      {
#line 692
      printf((char const   */* __restrict  */)"\tMinimum sep: %6ld at %5ld, PWGTS: [%6ld %6ld], NBND: %6ld\n",
             mincut, mincutorder, *(pwgts + 0), *(pwgts + 1), nbnd);
      }
    }
#line 695
    graph->mincut = mincut;
#line 696
    graph->nbnd = nbnd;
#line 698
    if (mincutorder == -1L) {
#line 699
      goto while_break;
    } else
#line 698
    if (mincut >= initcut) {
#line 699
      goto while_break;
    }
#line 530
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 702
  __PQueueFree(ctrl, & parts[0]);
#line 703
  __PQueueFree(ctrl, & parts[1]);
#line 705
  __idxwspacefree(ctrl, nvtxs + 1L);
#line 706
  __idxwspacefree(ctrl, nvtxs);
#line 707
  __idxwspacefree(ctrl, nvtxs);
#line 708
  __idxwspacefree(ctrl, nvtxs);
#line 709
  __idxwspacefree(ctrl, nvtxs);
  }
#line 710
  return;
}
}
#line 717 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/sfm.c"
void __FM_2WayNodeRefine_OneSided(CtrlType *ctrl , GraphType *graph , float ubfactor ,
                                  long npasses ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long jj ;
  long kk ;
  long nvtxs ;
  long nbnd ;
  long nswaps ;
  long nmind ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *edegrees ;
  idxtype *bndind ;
  idxtype *bndptr ;
  idxtype *mptr ;
  idxtype *mind ;
  idxtype *swaps ;
  idxtype *perm ;
  PQueueType parts ;
  NRInfoType *rinfo ;
  long higain ;
  long oldgain ;
  long mincut ;
  long initcut ;
  long mincutorder ;
  long pass ;
  long to ;
  long other ;
  long limit ;
  long badmaxpwgt ;
  long mindiff ;
  long newdiff ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  idxtype tmp___6 ;
  long tmp___7 ;
  idxtype tmp___8 ;

  {
  {
#line 728
  nvtxs = graph->nvtxs;
#line 729
  xadj = graph->xadj;
#line 730
  adjncy = graph->adjncy;
#line 731
  vwgt = graph->vwgt;
#line 733
  bndind = graph->bndind;
#line 734
  bndptr = graph->bndptr;
#line 735
  where = graph->where;
#line 736
  pwgts = graph->pwgts;
#line 737
  rinfo = graph->nrinfo;
#line 739
  tmp = __ComputeMaxNodeGain(nvtxs, xadj, adjncy, vwgt);
#line 739
  __PQueueInit(ctrl, & parts, nvtxs, tmp);
#line 741
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 742
  swaps = __idxwspacemalloc(ctrl, nvtxs);
#line 743
  mptr = __idxwspacemalloc(ctrl, nvtxs);
#line 744
  mind = __idxwspacemalloc(ctrl, nvtxs + 1L);
  }
#line 746
  if (ctrl->dbglvl & 8L) {
    {
#line 746
    printf((char const   */* __restrict  */)"Partitions-N1: [%6ld %6ld] Nv-Nb[%6ld %6ld]. ISep: %6ld\n",
           *(pwgts + 0), *(pwgts + 1), graph->nvtxs, graph->nbnd, graph->mincut);
    }
  }
#line 749
  badmaxpwgt = (long )((ubfactor * (float )((*(pwgts + 0) + *(pwgts + 1)) + *(pwgts + 2))) / (float )2);
#line 751
  if (*(pwgts + 0) < *(pwgts + 1)) {
#line 751
    to = 1L;
  } else {
#line 751
    to = 0L;
  }
#line 752
  pass = 0L;
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 752
    if (! (pass < npasses)) {
#line 752
      goto while_break;
    }
    {
#line 753
    other = to;
#line 754
    to = (to + 1L) % 2L;
#line 756
    __PQueueReset(& parts);
#line 758
    mincutorder = -1L;
#line 759
    mincut = graph->mincut;
#line 759
    initcut = mincut;
#line 760
    nbnd = graph->nbnd;
#line 762
    __RandomPermute(nbnd, perm, 1L);
#line 763
    ii = 0L;
    }
    {
#line 763
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 763
      if (! (ii < nbnd)) {
#line 763
        goto while_break___0;
      }
      {
#line 764
      i = *(bndind + *(perm + ii));
#line 766
      __PQueueInsert(& parts, i, *(vwgt + i) - (rinfo + i)->edegrees[other]);
#line 763
      ii ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 772
    if (ctrl->oflags & 1L) {
#line 772
      if (5L * nbnd >= 400L) {
#line 772
        tmp___0 = 400L;
      } else {
#line 772
        tmp___0 = 5L * nbnd;
      }
#line 772
      limit = tmp___0;
    } else {
#line 772
      if (2L * nbnd >= 300L) {
#line 772
        tmp___1 = 300L;
      } else {
#line 772
        tmp___1 = 2L * nbnd;
      }
#line 772
      limit = tmp___1;
    }
    {
#line 777
    nmind = 0L;
#line 777
    *(mptr + 0) = nmind;
#line 778
    tmp___2 = abs((int )(*(pwgts + 0) - *(pwgts + 1)));
#line 778
    mindiff = (long )tmp___2;
#line 779
    nswaps = 0L;
    }
    {
#line 779
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 779
      if (! (nswaps < nvtxs)) {
#line 779
        goto while_break___1;
      }
      {
#line 781
      higain = __PQueueGetMax(& parts);
      }
#line 781
      if (higain == -1L) {
#line 782
        goto while_break___1;
      }
#line 786
      if (*(pwgts + to) + *(vwgt + higain) > badmaxpwgt) {
#line 787
        goto while_break___1;
      }
      {
#line 789
      *(pwgts + 2) -= *(vwgt + higain) - (rinfo + higain)->edegrees[other];
#line 791
      tmp___3 = abs((int )((*(pwgts + to) + *(vwgt + higain)) - (*(pwgts + other) - (rinfo + higain)->edegrees[other])));
#line 791
      newdiff = (long )tmp___3;
      }
#line 792
      if (*(pwgts + 2) < mincut) {
#line 793
        mincut = *(pwgts + 2);
#line 794
        mincutorder = nswaps;
#line 795
        mindiff = newdiff;
      } else
#line 792
      if (*(pwgts + 2) == mincut) {
#line 792
        if (newdiff < mindiff) {
#line 793
          mincut = *(pwgts + 2);
#line 794
          mincutorder = nswaps;
#line 795
          mindiff = newdiff;
        } else {
#line 792
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 798
      if (nswaps - mincutorder > limit) {
#line 799
        *(pwgts + 2) += *(vwgt + higain) - (rinfo + higain)->edegrees[other];
#line 800
        goto while_break___1;
      }
      {
#line 804
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 804
        nbnd --;
#line 804
        *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 804
        *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 804
        *(bndptr + higain) = (idxtype )-1;
#line 804
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 805
      *(pwgts + to) += *(vwgt + higain);
#line 806
      *(where + higain) = to;
#line 807
      *(swaps + nswaps) = higain;
#line 813
      j = *(xadj + higain);
      {
#line 813
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 813
        if (! (j < *(xadj + (higain + 1L)))) {
#line 813
          goto while_break___3;
        }
#line 814
        k = *(adjncy + j);
#line 815
        if (*(where + k) == 2L) {
#line 816
          (rinfo + k)->edegrees[to] += *(vwgt + higain);
        } else
#line 818
        if (*(where + k) == other) {
          {
#line 820
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 820
            *(bndind + nbnd) = k;
#line 820
            tmp___4 = nbnd;
#line 820
            nbnd ++;
#line 820
            *(bndptr + k) = tmp___4;
#line 820
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 822
          tmp___5 = nmind;
#line 822
          nmind ++;
#line 822
          *(mind + tmp___5) = k;
#line 823
          *(where + k) = (idxtype )2;
#line 824
          *(pwgts + other) -= *(vwgt + k);
#line 826
          edegrees = (rinfo + k)->edegrees;
#line 827
          tmp___6 = (idxtype )0;
#line 827
          *(edegrees + 1) = tmp___6;
#line 827
          *(edegrees + 0) = tmp___6;
#line 828
          jj = *(xadj + k);
          {
#line 828
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 828
            if (! (jj < *(xadj + (k + 1L)))) {
#line 828
              goto while_break___5;
            }
#line 829
            kk = *(adjncy + jj);
#line 830
            if (*(where + kk) != 2L) {
#line 831
              *(edegrees + *(where + kk)) += *(vwgt + kk);
            } else {
              {
#line 833
              oldgain = *(vwgt + kk) - (rinfo + kk)->edegrees[other];
#line 834
              (rinfo + kk)->edegrees[other] -= *(vwgt + k);
#line 837
              __PQueueUpdateUp(& parts, kk, oldgain, oldgain + *(vwgt + k));
              }
            }
#line 828
            jj ++;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 842
          __PQueueInsert(& parts, k, *(vwgt + k) - *(edegrees + other));
          }
        }
#line 813
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 845
      *(mptr + (nswaps + 1L)) = nmind;
#line 848
      if (ctrl->dbglvl & 32L) {
        {
#line 848
        printf((char const   */* __restrict  */)"Moved %6ld to %3ld, Gain: %5ld [%5ld] \t[%5ld %5ld %5ld] [%3ld %2ld]\n",
               higain, to, *(vwgt + higain) - (rinfo + higain)->edegrees[other], *(vwgt + higain),
               *(pwgts + 0), *(pwgts + 1), *(pwgts + 2), nswaps, limit);
        }
      }
#line 779
      nswaps ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 858
    nswaps --;
    {
#line 858
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 858
      if (! (nswaps > mincutorder)) {
#line 858
        goto while_break___6;
      }
#line 859
      higain = *(swaps + nswaps);
      {
#line 864
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 864
        *(pwgts + 2) += *(vwgt + higain);
#line 864
        *(pwgts + to) -= *(vwgt + higain);
#line 864
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 865
      *(where + higain) = (idxtype )2;
      {
#line 866
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 866
        *(bndind + nbnd) = higain;
#line 866
        tmp___7 = nbnd;
#line 866
        nbnd ++;
#line 866
        *(bndptr + higain) = tmp___7;
#line 866
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 868
      edegrees = (rinfo + higain)->edegrees;
#line 869
      tmp___8 = (idxtype )0;
#line 869
      *(edegrees + 1) = tmp___8;
#line 869
      *(edegrees + 0) = tmp___8;
#line 870
      j = *(xadj + higain);
      {
#line 870
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 870
        if (! (j < *(xadj + (higain + 1L)))) {
#line 870
          goto while_break___9;
        }
#line 871
        k = *(adjncy + j);
#line 872
        if (*(where + k) == 2L) {
#line 873
          (rinfo + k)->edegrees[to] -= *(vwgt + higain);
        } else {
#line 875
          *(edegrees + *(where + k)) += *(vwgt + k);
        }
#line 870
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 879
      j = *(mptr + nswaps);
      {
#line 879
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 879
        if (! (j < *(mptr + (nswaps + 1L)))) {
#line 879
          goto while_break___10;
        }
#line 880
        k = *(mind + j);
#line 882
        *(where + k) = other;
        {
#line 883
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 883
          *(pwgts + other) += *(vwgt + k);
#line 883
          *(pwgts + 2) -= *(vwgt + k);
#line 883
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 884
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 884
          nbnd --;
#line 884
          *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 884
          *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 884
          *(bndptr + k) = (idxtype )-1;
#line 884
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 885
        jj = *(xadj + k);
        {
#line 885
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 885
          if (! (jj < *(xadj + (k + 1L)))) {
#line 885
            goto while_break___13;
          }
#line 886
          kk = *(adjncy + jj);
#line 887
          if (*(where + kk) == 2L) {
#line 888
            (rinfo + kk)->edegrees[other] += *(vwgt + k);
          }
#line 885
          jj ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 879
        j ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 858
      nswaps --;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 895
    if (ctrl->dbglvl & 8L) {
      {
#line 895
      printf((char const   */* __restrict  */)"\tMinimum sep: %6ld at %5ld, PWGTS: [%6ld %6ld], NBND: %6ld\n",
             mincut, mincutorder, *(pwgts + 0), *(pwgts + 1), nbnd);
      }
    }
#line 898
    graph->mincut = mincut;
#line 899
    graph->nbnd = nbnd;
#line 901
    if (pass % 2L == 1L) {
#line 901
      if (mincutorder == -1L) {
#line 902
        goto while_break;
      } else
#line 901
      if (mincut >= initcut) {
#line 902
        goto while_break;
      }
    }
#line 752
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 905
  __PQueueFree(ctrl, & parts);
#line 907
  __idxwspacefree(ctrl, nvtxs + 1L);
#line 908
  __idxwspacefree(ctrl, nvtxs);
#line 909
  __idxwspacefree(ctrl, nvtxs);
#line 910
  __idxwspacefree(ctrl, nvtxs);
  }
#line 911
  return;
}
}
#line 918 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/sfm.c"
void __FM_2WayNodeBalance(CtrlType *ctrl , GraphType *graph , float ubfactor ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long jj ;
  long kk ;
  long nvtxs ;
  long nbnd ;
  long nswaps ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *where ;
  idxtype *pwgts ;
  idxtype *edegrees ;
  idxtype *bndind ;
  idxtype *bndptr ;
  idxtype *perm ;
  idxtype *moved ;
  PQueueType parts ;
  NRInfoType *rinfo ;
  long higain ;
  long oldgain ;
  long to ;
  long other ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  idxtype *tmp___3 ;
  long tmp___4 ;
  idxtype tmp___5 ;

  {
  {
#line 928
  nvtxs = graph->nvtxs;
#line 929
  xadj = graph->xadj;
#line 930
  adjncy = graph->adjncy;
#line 931
  vwgt = graph->vwgt;
#line 933
  bndind = graph->bndind;
#line 934
  bndptr = graph->bndptr;
#line 935
  where = graph->where;
#line 936
  pwgts = graph->pwgts;
#line 937
  rinfo = graph->nrinfo;
#line 939
  tmp = abs((int )(*(pwgts + 0) - *(pwgts + 1)));
  }
#line 939
  if ((long )tmp < (long )(((double )ubfactor - 1.0) * (double )(*(pwgts + 0) + *(pwgts + 1)))) {
#line 940
    return;
  }
  {
#line 941
  tmp___0 = abs((int )(*(pwgts + 0) - *(pwgts + 1)));
#line 941
  tmp___1 = __idxsum(nvtxs, vwgt);
  }
#line 941
  if ((long )tmp___0 < (3L * tmp___1) / nvtxs) {
#line 942
    return;
  }
#line 944
  if (*(pwgts + 0) < *(pwgts + 1)) {
#line 944
    to = 0L;
  } else {
#line 944
    to = 1L;
  }
  {
#line 945
  other = (to + 1L) % 2L;
#line 947
  tmp___2 = __ComputeMaxNodeGain(nvtxs, xadj, adjncy, vwgt);
#line 947
  __PQueueInit(ctrl, & parts, nvtxs, tmp___2);
#line 949
  perm = __idxwspacemalloc(ctrl, nvtxs);
#line 950
  tmp___3 = __idxwspacemalloc(ctrl, nvtxs);
#line 950
  moved = __idxset(nvtxs, (idxtype )-1, tmp___3);
  }
#line 952
  if (ctrl->dbglvl & 8L) {
    {
#line 952
    printf((char const   */* __restrict  */)"Partitions: [%6ld %6ld] Nv-Nb[%6ld %6ld]. ISep: %6ld [B]\n",
           *(pwgts + 0), *(pwgts + 1), graph->nvtxs, graph->nbnd, graph->mincut);
    }
  }
  {
#line 955
  nbnd = graph->nbnd;
#line 956
  __RandomPermute(nbnd, perm, 1L);
#line 957
  ii = 0L;
  }
  {
#line 957
  while (1) {
    while_continue: /* CIL Label */ ;
#line 957
    if (! (ii < nbnd)) {
#line 957
      goto while_break;
    }
    {
#line 958
    i = *(bndind + *(perm + ii));
#line 960
    __PQueueInsert(& parts, i, *(vwgt + i) - (rinfo + i)->edegrees[other]);
#line 957
    ii ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 969
  nswaps = 0L;
  {
#line 969
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 969
    if (! (nswaps < nvtxs)) {
#line 969
      goto while_break___0;
    }
    {
#line 970
    higain = __PQueueGetMax(& parts);
    }
#line 970
    if (higain == -1L) {
#line 971
      goto while_break___0;
    }
#line 973
    *(moved + higain) = (idxtype )1;
#line 975
    if (*(pwgts + other) - (rinfo + higain)->edegrees[other] < (*(pwgts + 0) + *(pwgts + 1)) / 2L) {
#line 976
      goto __Cont;
    }
#line 984
    *(pwgts + 2) -= *(vwgt + higain) - (rinfo + higain)->edegrees[other];
    {
#line 986
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 986
      nbnd --;
#line 986
      *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 986
      *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 986
      *(bndptr + higain) = (idxtype )-1;
#line 986
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 987
    *(pwgts + to) += *(vwgt + higain);
#line 988
    *(where + higain) = to;
#line 990
    if (ctrl->dbglvl & 32L) {
      {
#line 990
      printf((char const   */* __restrict  */)"Moved %6ld to %3ld, Gain: %3ld, \t[%5ld %5ld %5ld]\n",
             higain, to, *(vwgt + higain) - (rinfo + higain)->edegrees[other], *(pwgts + 0),
             *(pwgts + 1), *(pwgts + 2));
      }
    }
#line 997
    j = *(xadj + higain);
    {
#line 997
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 997
      if (! (j < *(xadj + (higain + 1L)))) {
#line 997
        goto while_break___2;
      }
#line 998
      k = *(adjncy + j);
#line 999
      if (*(where + k) == 2L) {
#line 1000
        (rinfo + k)->edegrees[to] += *(vwgt + higain);
      } else
#line 1002
      if (*(where + k) == other) {
        {
#line 1004
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1004
          *(bndind + nbnd) = k;
#line 1004
          tmp___4 = nbnd;
#line 1004
          nbnd ++;
#line 1004
          *(bndptr + k) = tmp___4;
#line 1004
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1006
        *(where + k) = (idxtype )2;
#line 1007
        *(pwgts + other) -= *(vwgt + k);
#line 1009
        edegrees = (rinfo + k)->edegrees;
#line 1010
        tmp___5 = (idxtype )0;
#line 1010
        *(edegrees + 1) = tmp___5;
#line 1010
        *(edegrees + 0) = tmp___5;
#line 1011
        jj = *(xadj + k);
        {
#line 1011
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1011
          if (! (jj < *(xadj + (k + 1L)))) {
#line 1011
            goto while_break___4;
          }
#line 1012
          kk = *(adjncy + jj);
#line 1013
          if (*(where + kk) != 2L) {
#line 1014
            *(edegrees + *(where + kk)) += *(vwgt + kk);
          } else {
#line 1017
            oldgain = *(vwgt + kk) - (rinfo + kk)->edegrees[other];
#line 1018
            (rinfo + kk)->edegrees[other] -= *(vwgt + k);
#line 1020
            if (*(moved + kk) == -1L) {
              {
#line 1021
              __PQueueUpdateUp(& parts, kk, oldgain, oldgain + *(vwgt + k));
              }
            }
          }
#line 1011
          jj ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 1026
        __PQueueInsert(& parts, k, *(vwgt + k) - *(edegrees + other));
        }
      }
#line 997
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1030
    if (*(pwgts + to) > *(pwgts + other)) {
#line 1031
      goto while_break___0;
    }
    __Cont: /* CIL Label */ 
#line 969
    nswaps ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1034
  if (ctrl->dbglvl & 8L) {
    {
#line 1034
    printf((char const   */* __restrict  */)"\tBalanced sep: %6ld at %4ld, PWGTS: [%6ld %6ld], NBND: %6ld\n",
           *(pwgts + 2), nswaps, *(pwgts + 0), *(pwgts + 1), nbnd);
    }
  }
  {
#line 1037
  graph->mincut = *(pwgts + 2);
#line 1038
  graph->nbnd = nbnd;
#line 1041
  __PQueueFree(ctrl, & parts);
#line 1043
  __idxwspacefree(ctrl, nvtxs);
#line 1044
  __idxwspacefree(ctrl, nvtxs);
  }
#line 1045
  return;
}
}
#line 1051 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/sfm.c"
long __ComputeMaxNodeGain(long nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ) 
{ 
  long i ;
  long j ;
  long k ;
  long max ;

  {
#line 1055
  max = 0L;
#line 1056
  j = *(xadj + 0);
  {
#line 1056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1056
    if (! (j < *(xadj + 1))) {
#line 1056
      goto while_break;
    }
#line 1057
    max += *(vwgt + *(adjncy + j));
#line 1056
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1059
  i = 1L;
  {
#line 1059
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1059
    if (! (i < nvtxs)) {
#line 1059
      goto while_break___0;
    }
#line 1060
    k = 0L;
#line 1060
    j = *(xadj + i);
    {
#line 1060
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1060
      if (! (j < *(xadj + (i + 1L)))) {
#line 1060
        goto while_break___1;
      }
#line 1061
      k += *(vwgt + *(adjncy + j));
#line 1060
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1062
    if (max < k) {
#line 1063
      max = k;
    }
#line 1059
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1066
  return (max);
}
}
#line 342 "./proto.h"
void __MlevelNestedDissection(CtrlType *ctrl , GraphType *graph , idxtype *order ,
                              float ubfactor , long lastvtx ) ;
#line 343
void __MlevelNestedDissectionCC(CtrlType *ctrl , GraphType *graph , idxtype *order ,
                                float ubfactor , long lastvtx ) ;
#line 345
void __MlevelNodeBisection(CtrlType *ctrl , GraphType *graph , long *tpwgts , float ubfactor ) ;
#line 348
long __SplitGraphOrderCC(CtrlType *ctrl , GraphType *graph , GraphType *sgraphs ,
                         long ncmps , idxtype *cptr , idxtype *cind ) ;
#line 22 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/ometis.c"
void METIS_EdgeND(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                  long *options , idxtype *perm , idxtype *iperm ) 
{ 
  long i ;
  GraphType graph ;
  CtrlType ctrl ;
  long tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 29
  if (*numflag == 1L) {
    {
#line 30
    __Change2CNumbering(*nvtxs, xadj, adjncy);
    }
  }
  {
#line 32
  __SetUpGraph(& graph, 3L, *nvtxs, 1L, xadj, adjncy, (idxtype *)((void *)0), (idxtype *)((void *)0),
               0L);
  }
#line 34
  if (*(options + 0) == 0L) {
#line 35
    ctrl.CType = 3L;
#line 36
    ctrl.IType = 1L;
#line 37
    ctrl.RType = 1L;
#line 38
    ctrl.dbglvl = 0L;
  } else {
#line 41
    ctrl.CType = *(options + 1);
#line 42
    ctrl.IType = *(options + 2);
#line 43
    ctrl.RType = *(options + 3);
#line 44
    ctrl.dbglvl = *(options + 4);
  }
  {
#line 46
  ctrl.oflags = 0L;
#line 47
  ctrl.pfactor = -1L;
#line 48
  ctrl.nseps = 1L;
#line 50
  ctrl.optype = 3L;
#line 51
  ctrl.CoarsenTo = 20L;
#line 52
  tmp = __idxsum(*nvtxs, graph.vwgt);
#line 52
  ctrl.maxvwgt = (long )(1.5 * (double )(tmp / ctrl.CoarsenTo));
#line 54
  __InitRandom(-1L);
#line 56
  __AllocateWorkSpace(& ctrl, & graph, 2L);
  }
#line 58
  if (ctrl.dbglvl & 1L) {
    {
#line 58
    __InitTimers(& ctrl);
    }
  }
#line 59
  if (ctrl.dbglvl & 1L) {
    {
#line 59
    tmp___0 = __seconds();
#line 59
    ctrl.TotalTmr -= tmp___0;
    }
  }
  {
#line 61
  __MlevelNestedDissection(& ctrl, & graph, iperm, (float )1.10, *nvtxs);
  }
#line 63
  if (ctrl.dbglvl & 1L) {
    {
#line 63
    tmp___1 = __seconds();
#line 63
    ctrl.TotalTmr += tmp___1;
    }
  }
#line 64
  if (ctrl.dbglvl & 1L) {
    {
#line 64
    __PrintTimers(& ctrl);
    }
  }
#line 66
  i = 0L;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i < *nvtxs)) {
#line 66
      goto while_break;
    }
#line 67
    *(perm + *(iperm + i)) = i;
#line 66
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  __FreeWorkSpace(& ctrl, & graph);
  }
#line 71
  if (*numflag == 1L) {
    {
#line 72
    __Change2FNumberingOrder(*nvtxs, xadj, adjncy, perm, iperm);
    }
  }
#line 73
  return;
}
}
#line 79 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/ometis.c"
void METIS_NodeND(long *nvtxs , idxtype *xadj , idxtype *adjncy , long *numflag ,
                  long *options , idxtype *perm , idxtype *iperm ) 
{ 
  long i ;
  long ii ;
  long j ;
  long l ;
  GraphType graph ;
  CtrlType ctrl ;
  idxtype *cptr ;
  idxtype *cind ;
  idxtype *piperm ;
  double tmp ;
  long tmp___0 ;
  long tmp___1 ;
  double tmp___2 ;

  {
#line 86
  if (*numflag == 1L) {
    {
#line 87
    __Change2CNumbering(*nvtxs, xadj, adjncy);
    }
  }
#line 89
  if (*(options + 0) == 0L) {
#line 90
    ctrl.CType = 3L;
#line 91
    ctrl.IType = 1L;
#line 92
    ctrl.RType = 2L;
#line 93
    ctrl.dbglvl = 0L;
#line 94
    ctrl.oflags = 1L;
#line 95
    ctrl.pfactor = -1L;
#line 96
    ctrl.nseps = 1L;
  } else {
#line 99
    ctrl.CType = *(options + 1);
#line 100
    ctrl.IType = *(options + 2);
#line 101
    ctrl.RType = *(options + 3);
#line 102
    ctrl.dbglvl = *(options + 4);
#line 103
    ctrl.oflags = *(options + 5);
#line 104
    ctrl.pfactor = *(options + 6);
#line 105
    ctrl.nseps = *(options + 7);
  }
#line 107
  if (ctrl.nseps < 1L) {
#line 108
    ctrl.nseps = 1L;
  }
#line 110
  ctrl.optype = 4L;
#line 111
  ctrl.CoarsenTo = 100L;
#line 113
  if (ctrl.dbglvl & 1L) {
    {
#line 113
    __InitTimers(& ctrl);
    }
  }
#line 114
  if (ctrl.dbglvl & 1L) {
    {
#line 114
    tmp = __seconds();
#line 114
    ctrl.TotalTmr -= tmp;
    }
  }
  {
#line 116
  __InitRandom(-1L);
  }
#line 118
  if (ctrl.pfactor > 0L) {
    {
#line 122
    piperm = __idxmalloc(*nvtxs, (char *)"ONMETIS: piperm");
#line 123
    __PruneGraph(& ctrl, & graph, *nvtxs, xadj, adjncy, piperm, (float )(0.1 * (double )ctrl.pfactor));
    }
  } else
#line 125
  if (ctrl.oflags & 1L) {
    {
#line 129
    cptr = __idxmalloc(*nvtxs + 1L, (char *)"ONMETIS: cptr");
#line 130
    cind = __idxmalloc(*nvtxs, (char *)"ONMETIS: cind");
#line 131
    __CompressGraph(& ctrl, & graph, *nvtxs, xadj, adjncy, cptr, cind);
    }
#line 133
    if ((double )graph.nvtxs >= 0.85 * (double )*nvtxs) {
      {
#line 134
      (ctrl.oflags) --;
#line 135
      __GKfree(& cptr, & cind, (void **)0);
      }
    } else
#line 137
    if (2L * graph.nvtxs < *nvtxs) {
#line 137
      if (ctrl.nseps == 1L) {
#line 138
        ctrl.nseps = 2L;
      }
    }
  } else {
    {
#line 141
    __SetUpGraph(& graph, 4L, *nvtxs, 1L, xadj, adjncy, (idxtype *)((void *)0), (idxtype *)((void *)0),
                 0L);
    }
  }
  {
#line 148
  tmp___0 = __idxsum(graph.nvtxs, graph.vwgt);
#line 148
  ctrl.maxvwgt = (long )(1.5 * (double )(tmp___0 / ctrl.CoarsenTo));
#line 149
  __AllocateWorkSpace(& ctrl, & graph, 2L);
  }
#line 151
  if (ctrl.oflags & 2L) {
    {
#line 152
    __MlevelNestedDissectionCC(& ctrl, & graph, iperm, (float )1.10, graph.nvtxs);
    }
  } else {
    {
#line 154
    __MlevelNestedDissection(& ctrl, & graph, iperm, (float )1.10, graph.nvtxs);
    }
  }
  {
#line 156
  __FreeWorkSpace(& ctrl, & graph);
  }
#line 158
  if (ctrl.pfactor > 0L) {
#line 159
    if (graph.nvtxs < *nvtxs) {
      {
#line 160
      memcpy((void */* __restrict  */)((void *)perm), (void const   */* __restrict  */)((void *)iperm),
             sizeof(idxtype ) * (unsigned long )graph.nvtxs);
#line 161
      i = 0L;
      }
      {
#line 161
      while (1) {
        while_continue: /* CIL Label */ ;
#line 161
        if (! (i < graph.nvtxs)) {
#line 161
          goto while_break;
        }
#line 162
        *(iperm + *(piperm + i)) = *(perm + i);
#line 161
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 163
      i = graph.nvtxs;
      {
#line 163
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 163
        if (! (i < *nvtxs)) {
#line 163
          goto while_break___0;
        }
#line 164
        *(iperm + *(piperm + i)) = i;
#line 163
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 167
    __GKfree(& piperm, (void **)0);
    }
  } else
#line 169
  if (ctrl.oflags & 1L) {
#line 170
    if ((double )graph.nvtxs < 0.85 * (double )*nvtxs) {
#line 172
      i = 0L;
      {
#line 172
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 172
        if (! (i < graph.nvtxs)) {
#line 172
          goto while_break___1;
        }
#line 173
        *(perm + *(iperm + i)) = i;
#line 172
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 174
      ii = 0L;
#line 174
      l = ii;
      {
#line 174
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 174
        if (! (ii < graph.nvtxs)) {
#line 174
          goto while_break___2;
        }
#line 175
        i = *(perm + ii);
#line 176
        j = *(cptr + i);
        {
#line 176
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 176
          if (! (j < *(cptr + (i + 1L)))) {
#line 176
            goto while_break___3;
          }
#line 177
          tmp___1 = l;
#line 177
          l ++;
#line 177
          *(iperm + *(cind + j)) = tmp___1;
#line 176
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 174
        ii ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 181
    __GKfree(& cptr, & cind, (void **)0);
    }
  }
#line 185
  i = 0L;
  {
#line 185
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 185
    if (! (i < *nvtxs)) {
#line 185
      goto while_break___4;
    }
#line 186
    *(perm + *(iperm + i)) = i;
#line 185
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 188
  if (ctrl.dbglvl & 1L) {
    {
#line 188
    tmp___2 = __seconds();
#line 188
    ctrl.TotalTmr += tmp___2;
    }
  }
#line 189
  if (ctrl.dbglvl & 1L) {
    {
#line 189
    __PrintTimers(& ctrl);
    }
  }
#line 191
  if (*numflag == 1L) {
    {
#line 192
    __Change2FNumberingOrder(*nvtxs, xadj, adjncy, perm, iperm);
    }
  }
#line 194
  return;
}
}
#line 201 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/ometis.c"
void METIS_NodeWND(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                   long *numflag , long *options , idxtype *perm , idxtype *iperm ) 
{ 
  long i ;
  GraphType graph ;
  CtrlType ctrl ;
  long tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 208
  if (*numflag == 1L) {
    {
#line 209
    __Change2CNumbering(*nvtxs, xadj, adjncy);
    }
  }
  {
#line 211
  __SetUpGraph(& graph, 4L, *nvtxs, 1L, xadj, adjncy, vwgt, (idxtype *)((void *)0),
               2L);
  }
#line 213
  if (*(options + 0) == 0L) {
#line 214
    ctrl.CType = 3L;
#line 215
    ctrl.IType = 1L;
#line 216
    ctrl.RType = 2L;
#line 217
    ctrl.dbglvl = 0L;
  } else {
#line 220
    ctrl.CType = *(options + 1);
#line 221
    ctrl.IType = *(options + 2);
#line 222
    ctrl.RType = *(options + 3);
#line 223
    ctrl.dbglvl = *(options + 4);
  }
  {
#line 226
  ctrl.oflags = 1L;
#line 227
  ctrl.pfactor = 0L;
#line 228
  ctrl.nseps = 2L;
#line 229
  ctrl.optype = 4L;
#line 230
  ctrl.CoarsenTo = 100L;
#line 231
  tmp = __idxsum(*nvtxs, graph.vwgt);
#line 231
  ctrl.maxvwgt = (long )(1.5 * (double )(tmp / ctrl.CoarsenTo));
#line 233
  __InitRandom(-1L);
#line 235
  __AllocateWorkSpace(& ctrl, & graph, 2L);
  }
#line 237
  if (ctrl.dbglvl & 1L) {
    {
#line 237
    __InitTimers(& ctrl);
    }
  }
#line 238
  if (ctrl.dbglvl & 1L) {
    {
#line 238
    tmp___0 = __seconds();
#line 238
    ctrl.TotalTmr -= tmp___0;
    }
  }
  {
#line 240
  __MlevelNestedDissection(& ctrl, & graph, iperm, (float )1.10, *nvtxs);
  }
#line 242
  if (ctrl.dbglvl & 1L) {
    {
#line 242
    tmp___1 = __seconds();
#line 242
    ctrl.TotalTmr += tmp___1;
    }
  }
#line 243
  if (ctrl.dbglvl & 1L) {
    {
#line 243
    __PrintTimers(& ctrl);
    }
  }
#line 245
  i = 0L;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! (i < *nvtxs)) {
#line 245
      goto while_break;
    }
#line 246
    *(perm + *(iperm + i)) = i;
#line 245
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  __FreeWorkSpace(& ctrl, & graph);
  }
#line 250
  if (*numflag == 1L) {
    {
#line 251
    __Change2FNumberingOrder(*nvtxs, xadj, adjncy, perm, iperm);
    }
  }
#line 252
  return;
}
}
#line 260 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/ometis.c"
void __MlevelNestedDissection(CtrlType *ctrl , GraphType *graph , idxtype *order ,
                              float ubfactor , long lastvtx ) 
{ 
  long i ;
  long nvtxs ;
  long nbnd ;
  long tvwgt ;
  long tpwgts2[2] ;
  idxtype *label ;
  idxtype *bndind ;
  GraphType lgraph ;
  GraphType rgraph ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 266
  nvtxs = graph->nvtxs;
#line 269
  tvwgt = __idxsum(nvtxs, graph->vwgt);
#line 270
  tpwgts2[0] = tvwgt / 2L;
#line 271
  tpwgts2[1] = tvwgt - tpwgts2[0];
  }
  {
#line 274
  if (ctrl->optype == 3L) {
#line 274
    goto case_3;
  }
#line 282
  if (ctrl->optype == 4L) {
#line 282
    goto case_4;
  }
#line 273
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 275
  __MlevelEdgeBisection(ctrl, graph, tpwgts2, ubfactor);
  }
#line 277
  if (ctrl->dbglvl & 1L) {
    {
#line 277
    tmp = __seconds();
#line 277
    ctrl->SepTmr -= tmp;
    }
  }
  {
#line 278
  __ConstructMinCoverSeparator(ctrl, graph, ubfactor);
  }
#line 279
  if (ctrl->dbglvl & 1L) {
    {
#line 279
    tmp___0 = __seconds();
#line 279
    ctrl->SepTmr += tmp___0;
    }
  }
#line 281
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 283
  __MlevelNodeBisectionMultiple(ctrl, graph, tpwgts2, ubfactor);
  }
#line 285
  if (ctrl->dbglvl & 128L) {
    {
#line 285
    printf((char const   */* __restrict  */)"Nvtxs: %6ld, [%6ld %6ld %6ld]\n", graph->nvtxs,
           *(graph->pwgts + 0), *(graph->pwgts + 1), *(graph->pwgts + 2));
    }
  }
#line 287
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 291
  nbnd = graph->nbnd;
#line 292
  bndind = graph->bndind;
#line 293
  label = graph->label;
#line 294
  i = 0L;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i < nbnd)) {
#line 294
      goto while_break;
    }
#line 295
    lastvtx --;
#line 295
    *(order + *(label + *(bndind + i))) = lastvtx;
#line 294
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 297
  __SplitGraphOrder(ctrl, graph, & lgraph, & rgraph);
#line 300
  __GKfree(& graph->gdata, & graph->rdata, & graph->label, (void **)0);
  }
#line 302
  if (rgraph.nvtxs > 200L) {
    {
#line 303
    __MlevelNestedDissection(ctrl, & rgraph, order, ubfactor, lastvtx);
    }
  } else {
    {
#line 305
    __MMDOrder(ctrl, & rgraph, order, lastvtx);
#line 306
    __GKfree(& rgraph.gdata, & rgraph.rdata, & rgraph.label, (void **)0);
    }
  }
#line 308
  if (lgraph.nvtxs > 200L) {
    {
#line 309
    __MlevelNestedDissection(ctrl, & lgraph, order, ubfactor, lastvtx - rgraph.nvtxs);
    }
  } else {
    {
#line 311
    __MMDOrder(ctrl, & lgraph, order, lastvtx - rgraph.nvtxs);
#line 312
    __GKfree(& lgraph.gdata, & lgraph.rdata, & lgraph.label, (void **)0);
    }
  }
#line 314
  return;
}
}
#line 320 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/ometis.c"
void __MlevelNestedDissectionCC(CtrlType *ctrl , GraphType *graph , idxtype *order ,
                                float ubfactor , long lastvtx ) 
{ 
  long i ;
  long nvtxs ;
  long nbnd ;
  long tvwgt ;
  long tpwgts2[2] ;
  long nsgraphs ;
  long ncmps ;
  long rnvtxs ;
  idxtype *label ;
  idxtype *bndind ;
  idxtype *cptr ;
  idxtype *cind ;
  GraphType *sgraphs ;
  void *tmp ;

  {
  {
#line 327
  nvtxs = graph->nvtxs;
#line 330
  tvwgt = __idxsum(nvtxs, graph->vwgt);
#line 331
  tpwgts2[0] = tvwgt / 2L;
#line 332
  tpwgts2[1] = tvwgt - tpwgts2[0];
#line 334
  __MlevelNodeBisectionMultiple(ctrl, graph, tpwgts2, ubfactor);
  }
#line 335
  if (ctrl->dbglvl & 128L) {
    {
#line 335
    printf((char const   */* __restrict  */)"Nvtxs: %6ld, [%6ld %6ld %6ld]\n", graph->nvtxs,
           *(graph->pwgts + 0), *(graph->pwgts + 1), *(graph->pwgts + 2));
    }
  }
#line 338
  nbnd = graph->nbnd;
#line 339
  bndind = graph->bndind;
#line 340
  label = graph->label;
#line 341
  i = 0L;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! (i < nbnd)) {
#line 341
      goto while_break;
    }
#line 342
    lastvtx --;
#line 342
    *(order + *(label + *(bndind + i))) = lastvtx;
#line 341
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 344
  cptr = __idxmalloc(nvtxs, (char *)"MlevelNestedDissectionCC: cptr");
#line 345
  cind = __idxmalloc(nvtxs, (char *)"MlevelNestedDissectionCC: cind");
#line 346
  ncmps = __FindComponents(ctrl, graph, cptr, cind);
#line 353
  tmp = __GKmalloc((long )((unsigned long )ncmps * sizeof(GraphType )), (char *)"MlevelNestedDissectionCC: sgraphs");
#line 353
  sgraphs = (GraphType *)tmp;
#line 355
  nsgraphs = __SplitGraphOrderCC(ctrl, graph, sgraphs, ncmps, cptr, cind);
#line 357
  __GKfree(& cptr, & cind, (void **)0);
#line 360
  __GKfree(& graph->gdata, & graph->rdata, & graph->label, (void **)0);
#line 363
  i = 0L;
#line 363
  rnvtxs = i;
  }
  {
#line 363
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 363
    if (! (i < nsgraphs)) {
#line 363
      goto while_break___0;
    }
#line 364
    if ((unsigned long )(sgraphs + i)->adjwgt == (unsigned long )((void *)0)) {
      {
#line 365
      __MMDOrder(ctrl, sgraphs + i, order, lastvtx - rnvtxs);
#line 366
      __GKfree(& (sgraphs + i)->gdata, & (sgraphs + i)->label, (void **)0);
      }
    } else {
      {
#line 369
      __MlevelNestedDissectionCC(ctrl, sgraphs + i, order, ubfactor, lastvtx - rnvtxs);
      }
    }
#line 371
    rnvtxs += (sgraphs + i)->nvtxs;
#line 363
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 374
  free((void *)sgraphs);
  }
#line 375
  return;
}
}
#line 383 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/ometis.c"
void __MlevelNodeBisectionMultiple(CtrlType *ctrl , GraphType *graph , long *tpwgts ,
                                   float ubfactor ) 
{ 
  long i ;
  long nvtxs ;
  long cnvtxs ;
  long mincut ;
  int PASS ;
  GraphType *cgraph ;
  idxtype *bestwhere ;
  int tmp___0 ;

  {
#line 390
  if (ctrl->nseps == 1L) {
    {
#line 391
    __MlevelNodeBisection(ctrl, graph, tpwgts, ubfactor);
    }
#line 392
    return;
  } else {
#line 390
    if (ctrl->oflags & 1L) {
#line 390
      tmp___0 = 1000;
    } else {
#line 390
      tmp___0 = 2000;
    }
#line 390
    if (graph->nvtxs < (long )tmp___0) {
      {
#line 391
      __MlevelNodeBisection(ctrl, graph, tpwgts, ubfactor);
      }
#line 392
      return;
    }
  }
#line 395
  nvtxs = graph->nvtxs;
#line 397
  if (ctrl->oflags & 1L) {
    {
#line 398
    bestwhere = __idxmalloc(nvtxs, (char *)"MlevelNodeBisection2: bestwhere");
#line 399
    mincut = nvtxs;
#line 400
    PASS = 0;
#line 401
    i = ctrl->nseps;
    }
    {
#line 401
    while (1) {
      while_continue: /* CIL Label */ ;
#line 401
      if (! (i > 0L)) {
#line 401
        goto while_break;
      }
      {
#line 402
      __MlevelNodeBisection(ctrl, graph, tpwgts, ubfactor);
      }
#line 403
      if (graph->mincut < mincut) {
        {
#line 404
        PASS = 1;
#line 405
        mincut = graph->mincut;
#line 406
        memcpy((void */* __restrict  */)((void *)bestwhere), (void const   */* __restrict  */)((void *)graph->where),
               sizeof(idxtype ) * (unsigned long )nvtxs);
        }
      }
      {
#line 409
      __GKfree(& graph->rdata, (void **)0);
      }
#line 410
      if (mincut == 0L) {
#line 411
        goto while_break;
      }
#line 401
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 415
    if (PASS == 1) {
      {
#line 417
      __Allocate2WayNodePartitionMemory(ctrl, graph);
#line 418
      memcpy((void */* __restrict  */)((void *)graph->where), (void const   */* __restrict  */)((void *)bestwhere),
             sizeof(idxtype ) * (unsigned long )nvtxs);
#line 419
      free((void *)bestwhere);
#line 420
      PASS = 0;
      }
    }
    {
#line 424
    __Compute2WayNodePartitionParams(ctrl, graph);
    }
  } else {
    {
#line 427
    ctrl->CoarsenTo = nvtxs - 1L;
#line 429
    cgraph = __Coarsen2Way(ctrl, graph);
#line 431
    cnvtxs = cgraph->nvtxs;
#line 433
    bestwhere = __idxmalloc(cnvtxs, (char *)"MlevelNodeBisection2: bestwhere");
#line 434
    mincut = nvtxs;
#line 435
    PASS = 0;
#line 436
    i = ctrl->nseps;
    }
    {
#line 436
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 436
      if (! (i > 0L)) {
#line 436
        goto while_break___0;
      }
      {
#line 437
      ctrl->CType += 20L;
#line 438
      __MlevelNodeBisection(ctrl, cgraph, tpwgts, ubfactor);
      }
#line 441
      if (cgraph->mincut < mincut) {
        {
#line 442
        PASS = 1;
#line 443
        mincut = cgraph->mincut;
#line 444
        memcpy((void */* __restrict  */)((void *)bestwhere), (void const   */* __restrict  */)((void *)cgraph->where),
               sizeof(idxtype ) * (unsigned long )cnvtxs);
        }
      }
      {
#line 447
      __GKfree(& cgraph->rdata, (void **)0);
      }
#line 449
      if (mincut == 0L) {
#line 450
        goto while_break___0;
      }
#line 436
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 453
    if (PASS == 1) {
      {
#line 455
      __Allocate2WayNodePartitionMemory(ctrl, cgraph);
#line 456
      memcpy((void */* __restrict  */)((void *)cgraph->where), (void const   */* __restrict  */)((void *)bestwhere),
             sizeof(idxtype ) * (unsigned long )cnvtxs);
#line 457
      free((void *)bestwhere);
#line 458
      PASS = 0;
      }
    }
    {
#line 460
    __Compute2WayNodePartitionParams(ctrl, cgraph);
#line 462
    __Refine2WayNode(ctrl, graph, cgraph, ubfactor);
    }
  }
#line 465
  return;
}
}
#line 470 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/ometis.c"
void __MlevelNodeBisection(CtrlType *ctrl , GraphType *graph , long *tpwgts , float ubfactor ) 
{ 
  GraphType *cgraph ;
  double tmp ;
  double tmp___0 ;

  {
#line 474
  ctrl->CoarsenTo = graph->nvtxs / 8L;
#line 475
  if (ctrl->CoarsenTo > 100L) {
#line 476
    ctrl->CoarsenTo = 100L;
  } else
#line 477
  if (ctrl->CoarsenTo < 40L) {
#line 478
    ctrl->CoarsenTo = 40L;
  }
  {
#line 479
  ctrl->maxvwgt = (long )(1.5 * (double )((*(tpwgts + 0) + *(tpwgts + 1)) / ctrl->CoarsenTo));
#line 481
  cgraph = __Coarsen2Way(ctrl, graph);
  }
  {
#line 484
  if (ctrl->IType == 1L) {
#line 484
    goto case_1;
  }
#line 494
  if (ctrl->IType == 2L) {
#line 494
    goto case_2;
  }
#line 483
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 485
  __Init2WayPartition(ctrl, cgraph, tpwgts, ubfactor);
  }
#line 487
  if (ctrl->dbglvl & 1L) {
    {
#line 487
    tmp = __seconds();
#line 487
    ctrl->SepTmr -= tmp;
    }
  }
  {
#line 489
  __Compute2WayPartitionParams(ctrl, cgraph);
#line 490
  __ConstructSeparator(ctrl, cgraph, ubfactor);
  }
#line 492
  if (ctrl->dbglvl & 1L) {
    {
#line 492
    tmp___0 = __seconds();
#line 492
    ctrl->SepTmr += tmp___0;
    }
  }
#line 493
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 495
  __InitSeparator(ctrl, cgraph, ubfactor);
  }
#line 496
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 499
  __Refine2WayNode(ctrl, graph, cgraph, ubfactor);
  }
#line 501
  return;
}
}
#line 510 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/ometis.c"
void __SplitGraphOrder(CtrlType *ctrl , GraphType *graph , GraphType *lgraph , GraphType *rgraph ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long l ;
  long istart ;
  long iend ;
  long mypart ;
  long nvtxs ;
  long snvtxs[3] ;
  long snedges[3] ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *adjwgtsum ;
  idxtype *label ;
  idxtype *where ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *sxadj[2] ;
  idxtype *svwgt[2] ;
  idxtype *sadjncy[2] ;
  idxtype *sadjwgt[2] ;
  idxtype *sadjwgtsum[2] ;
  idxtype *slabel[2] ;
  idxtype *rename___0 ;
  idxtype *auxadjncy ;
  double tmp ;
  long tmp___0 ;
  idxtype tmp___1 ;
  long tmp___2 ;
  double tmp___3 ;

  {
#line 518
  if (ctrl->dbglvl & 1L) {
    {
#line 518
    tmp = __seconds();
#line 518
    ctrl->SplitTmr -= tmp;
    }
  }
  {
#line 520
  nvtxs = graph->nvtxs;
#line 521
  xadj = graph->xadj;
#line 522
  vwgt = graph->vwgt;
#line 523
  adjncy = graph->adjncy;
#line 524
  adjwgt = graph->adjwgt;
#line 525
  adjwgtsum = graph->adjwgtsum;
#line 526
  label = graph->label;
#line 527
  where = graph->where;
#line 528
  bndptr = graph->bndptr;
#line 529
  bndind = graph->bndind;
#line 532
  rename___0 = __idxwspacemalloc(ctrl, nvtxs);
#line 534
  snedges[2] = 0L;
#line 534
  snedges[1] = snedges[2];
#line 534
  snedges[0] = snedges[1];
#line 534
  snvtxs[2] = snedges[0];
#line 534
  snvtxs[1] = snvtxs[2];
#line 534
  snvtxs[0] = snvtxs[1];
#line 535
  i = 0L;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (i < nvtxs)) {
#line 535
      goto while_break;
    }
#line 536
    k = *(where + i);
#line 537
    tmp___0 = snvtxs[k];
#line 537
    (snvtxs[k]) ++;
#line 537
    *(rename___0 + i) = tmp___0;
#line 538
    snedges[k] += *(xadj + (i + 1L)) - *(xadj + i);
#line 535
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  __SetUpSplitGraph(graph, lgraph, snvtxs[0], snedges[0]);
#line 542
  sxadj[0] = lgraph->xadj;
#line 543
  svwgt[0] = lgraph->vwgt;
#line 544
  sadjwgtsum[0] = lgraph->adjwgtsum;
#line 545
  sadjncy[0] = lgraph->adjncy;
#line 546
  sadjwgt[0] = lgraph->adjwgt;
#line 547
  slabel[0] = lgraph->label;
#line 549
  __SetUpSplitGraph(graph, rgraph, snvtxs[1], snedges[1]);
#line 550
  sxadj[1] = rgraph->xadj;
#line 551
  svwgt[1] = rgraph->vwgt;
#line 552
  sadjwgtsum[1] = rgraph->adjwgtsum;
#line 553
  sadjncy[1] = rgraph->adjncy;
#line 554
  sadjwgt[1] = rgraph->adjwgt;
#line 555
  slabel[1] = rgraph->label;
#line 558
  ii = 0L;
  }
  {
#line 558
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 558
    if (! (ii < graph->nbnd)) {
#line 558
      goto while_break___0;
    }
#line 559
    i = *(bndind + ii);
#line 560
    j = *(xadj + i);
    {
#line 560
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 560
      if (! (j < *(xadj + (i + 1L)))) {
#line 560
        goto while_break___1;
      }
#line 561
      *(bndptr + *(adjncy + j)) = (idxtype )1;
#line 560
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 558
    ii ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 564
  snedges[1] = 0L;
#line 564
  snedges[0] = snedges[1];
#line 564
  snvtxs[1] = snedges[0];
#line 564
  snvtxs[0] = snvtxs[1];
#line 565
  tmp___1 = (idxtype )0;
#line 565
  *(sxadj[1] + 0) = tmp___1;
#line 565
  *(sxadj[0] + 0) = tmp___1;
#line 566
  i = 0L;
  {
#line 566
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 566
    if (! (i < nvtxs)) {
#line 566
      goto while_break___2;
    }
#line 567
    mypart = *(where + i);
#line 567
    if (mypart == 2L) {
#line 568
      goto __Cont;
    }
#line 570
    istart = *(xadj + i);
#line 571
    iend = *(xadj + (i + 1L));
#line 572
    if (*(bndptr + i) == -1L) {
#line 573
      auxadjncy = (sadjncy[mypart] + snedges[mypart]) - istart;
#line 574
      j = istart;
      {
#line 574
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 574
        if (! (j < iend)) {
#line 574
          goto while_break___3;
        }
#line 575
        *(auxadjncy + j) = *(adjncy + j);
#line 574
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 576
      snedges[mypart] += iend - istart;
    } else {
#line 579
      auxadjncy = sadjncy[mypart];
#line 580
      l = snedges[mypart];
#line 581
      j = istart;
      {
#line 581
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 581
        if (! (j < iend)) {
#line 581
          goto while_break___4;
        }
#line 582
        k = *(adjncy + j);
#line 583
        if (*(where + k) == mypart) {
#line 584
          tmp___2 = l;
#line 584
          l ++;
#line 584
          *(auxadjncy + tmp___2) = k;
        }
#line 581
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 586
      snedges[mypart] = l;
    }
#line 589
    *(svwgt[mypart] + snvtxs[mypart]) = *(vwgt + i);
#line 590
    *(sadjwgtsum[mypart] + snvtxs[mypart]) = snedges[mypart] - *(sxadj[mypart] + snvtxs[mypart]);
#line 591
    *(slabel[mypart] + snvtxs[mypart]) = *(label + i);
#line 592
    (snvtxs[mypart]) ++;
#line 592
    *(sxadj[mypart] + snvtxs[mypart]) = snedges[mypart];
    __Cont: /* CIL Label */ 
#line 566
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 595
  mypart = 0L;
  {
#line 595
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 595
    if (! (mypart < 2L)) {
#line 595
      goto while_break___5;
    }
    {
#line 596
    iend = snedges[mypart];
#line 597
    __idxset(iend, (idxtype )1, sadjwgt[mypart]);
#line 599
    auxadjncy = sadjncy[mypart];
#line 600
    i = 0L;
    }
    {
#line 600
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 600
      if (! (i < iend)) {
#line 600
        goto while_break___6;
      }
#line 601
      *(auxadjncy + i) = *(rename___0 + *(auxadjncy + i));
#line 600
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 595
    mypart ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 604
  lgraph->nvtxs = snvtxs[0];
#line 605
  lgraph->nedges = snedges[0];
#line 606
  rgraph->nvtxs = snvtxs[1];
#line 607
  rgraph->nedges = snedges[1];
#line 609
  if (ctrl->dbglvl & 1L) {
    {
#line 609
    tmp___3 = __seconds();
#line 609
    ctrl->SplitTmr += tmp___3;
    }
  }
  {
#line 611
  __idxwspacefree(ctrl, nvtxs);
  }
#line 613
  return;
}
}
#line 619 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/ometis.c"
void __MMDOrder(CtrlType *ctrl , GraphType *graph , idxtype *order , long lastvtx ) 
{ 
  long i ;
  long k ;
  long nvtxs ;
  long nofsub ;
  long firstvtx ;
  idxtype *xadj ;
  idxtype *adjncy ;
  idxtype *label ;
  idxtype *perm ;
  idxtype *iperm ;
  idxtype *head ;
  idxtype *qsize ;
  idxtype *list ;
  idxtype *marker ;

  {
#line 625
  nvtxs = graph->nvtxs;
#line 626
  xadj = graph->xadj;
#line 627
  adjncy = graph->adjncy;
#line 630
  k = *(xadj + nvtxs);
#line 631
  i = 0L;
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (! (i < k)) {
#line 631
      goto while_break;
    }
#line 632
    (*(adjncy + i)) ++;
#line 631
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 633
  i = 0L;
  {
#line 633
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 633
    if (! (i < nvtxs + 1L)) {
#line 633
      goto while_break___0;
    }
#line 634
    (*(xadj + i)) ++;
#line 633
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 636
  perm = __idxmalloc(6L * (nvtxs + 5L), (char *)"MMDOrder: perm");
#line 637
  iperm = (perm + nvtxs) + 5;
#line 638
  head = (iperm + nvtxs) + 5;
#line 639
  qsize = (head + nvtxs) + 5;
#line 640
  list = (qsize + nvtxs) + 5;
#line 641
  marker = (list + nvtxs) + 5;
#line 643
  __genmmd(nvtxs, xadj, adjncy, iperm, perm, 1L, head, qsize, list, marker, 1L << (8UL * sizeof(idxtype ) - 2UL),
           & nofsub);
#line 645
  label = graph->label;
#line 646
  firstvtx = lastvtx - nvtxs;
#line 647
  i = 0L;
  }
  {
#line 647
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 647
    if (! (i < nvtxs)) {
#line 647
      goto while_break___1;
    }
#line 648
    *(order + *(label + i)) = (firstvtx + *(iperm + i)) - 1L;
#line 647
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 650
  free((void *)perm);
#line 653
  i = 0L;
  }
  {
#line 653
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 653
    if (! (i < nvtxs + 1L)) {
#line 653
      goto while_break___2;
    }
#line 654
    (*(xadj + i)) --;
#line 653
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 655
  k = *(xadj + nvtxs);
#line 656
  i = 0L;
  {
#line 656
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 656
    if (! (i < k)) {
#line 656
      goto while_break___3;
    }
#line 657
    (*(adjncy + i)) --;
#line 656
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 658
  return;
}
}
#line 665 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/ometis.c"
long __SplitGraphOrderCC(CtrlType *ctrl , GraphType *graph , GraphType *sgraphs ,
                         long ncmps , idxtype *cptr , idxtype *cind ) 
{ 
  long i ;
  long ii ;
  long iii ;
  long j ;
  long k ;
  long l ;
  long istart ;
  long iend ;
  long nvtxs ;
  long snvtxs ;
  long snedges ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *adjwgtsum ;
  idxtype *label ;
  idxtype *where ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *sxadj ;
  idxtype *svwgt ;
  idxtype *sadjncy ;
  idxtype *sadjwgt ;
  idxtype *sadjwgtsum ;
  idxtype *slabel ;
  idxtype *rename___0 ;
  idxtype *auxadjncy ;
  idxtype *auxadjwgt ;
  double tmp ;
  long tmp___0 ;
  idxtype tmp___1 ;
  long tmp___2 ;
  double tmp___3 ;

  {
#line 673
  if (ctrl->dbglvl & 1L) {
    {
#line 673
    tmp = __seconds();
#line 673
    ctrl->SplitTmr -= tmp;
    }
  }
#line 675
  nvtxs = graph->nvtxs;
#line 676
  xadj = graph->xadj;
#line 677
  vwgt = graph->vwgt;
#line 678
  adjncy = graph->adjncy;
#line 679
  adjwgt = graph->adjwgt;
#line 680
  adjwgtsum = graph->adjwgtsum;
#line 681
  label = graph->label;
#line 682
  where = graph->where;
#line 683
  bndptr = graph->bndptr;
#line 684
  bndind = graph->bndind;
#line 688
  ii = 0L;
  {
#line 688
  while (1) {
    while_continue: /* CIL Label */ ;
#line 688
    if (! (ii < graph->nbnd)) {
#line 688
      goto while_break;
    }
#line 689
    i = *(bndind + ii);
#line 690
    j = *(xadj + i);
    {
#line 690
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 690
      if (! (j < *(xadj + (i + 1L)))) {
#line 690
        goto while_break___0;
      }
#line 691
      *(bndptr + *(adjncy + j)) = (idxtype )1;
#line 690
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 688
    ii ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 694
  rename___0 = __idxwspacemalloc(ctrl, nvtxs);
#line 697
  iii = 0L;
  }
  {
#line 697
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 697
    if (! (iii < ncmps)) {
#line 697
      goto while_break___1;
    }
    {
#line 698
    __RandomPermute(*(cptr + (iii + 1L)) - *(cptr + iii), cind + *(cptr + iii), 0L);
#line 699
    snedges = 0L;
#line 699
    snvtxs = snedges;
#line 700
    j = *(cptr + iii);
    }
    {
#line 700
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 700
      if (! (j < *(cptr + (iii + 1L)))) {
#line 700
        goto while_break___2;
      }
#line 701
      i = *(cind + j);
#line 702
      tmp___0 = snvtxs;
#line 702
      snvtxs ++;
#line 702
      *(rename___0 + i) = tmp___0;
#line 703
      snedges += *(xadj + (i + 1L)) - *(xadj + i);
#line 700
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 706
    __SetUpSplitGraph(graph, sgraphs + iii, snvtxs, snedges);
#line 707
    sxadj = (sgraphs + iii)->xadj;
#line 708
    svwgt = (sgraphs + iii)->vwgt;
#line 709
    sadjwgtsum = (sgraphs + iii)->adjwgtsum;
#line 710
    sadjncy = (sgraphs + iii)->adjncy;
#line 711
    sadjwgt = (sgraphs + iii)->adjwgt;
#line 712
    slabel = (sgraphs + iii)->label;
#line 714
    tmp___1 = (idxtype )0;
#line 714
    *(sxadj + 0) = tmp___1;
#line 714
    snedges = tmp___1;
#line 714
    snvtxs = snedges;
#line 715
    ii = *(cptr + iii);
    }
    {
#line 715
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 715
      if (! (ii < *(cptr + (iii + 1L)))) {
#line 715
        goto while_break___3;
      }
#line 716
      i = *(cind + ii);
#line 718
      istart = *(xadj + i);
#line 719
      iend = *(xadj + (i + 1L));
#line 720
      if (*(bndptr + i) == -1L) {
#line 721
        auxadjncy = (sadjncy + snedges) - istart;
#line 722
        auxadjwgt = (sadjwgt + snedges) - istart;
#line 723
        j = istart;
        {
#line 723
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 723
          if (! (j < iend)) {
#line 723
            goto while_break___4;
          }
#line 724
          *(auxadjncy + j) = *(adjncy + j);
#line 723
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 725
        snedges += iend - istart;
      } else {
#line 728
        l = snedges;
#line 729
        j = istart;
        {
#line 729
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 729
          if (! (j < iend)) {
#line 729
            goto while_break___5;
          }
#line 730
          k = *(adjncy + j);
#line 731
          if (*(where + k) != 2L) {
#line 732
            tmp___2 = l;
#line 732
            l ++;
#line 732
            *(sadjncy + tmp___2) = k;
          }
#line 729
          j ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 734
        snedges = l;
      }
#line 737
      *(svwgt + snvtxs) = *(vwgt + i);
#line 738
      *(sadjwgtsum + snvtxs) = snedges - *(sxadj + snvtxs);
#line 739
      *(slabel + snvtxs) = *(label + i);
#line 740
      snvtxs ++;
#line 740
      *(sxadj + snvtxs) = snedges;
#line 715
      ii ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 743
    __idxset(snedges, (idxtype )1, sadjwgt);
#line 744
    i = 0L;
    }
    {
#line 744
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 744
      if (! (i < snedges)) {
#line 744
        goto while_break___6;
      }
#line 745
      *(sadjncy + i) = *(rename___0 + *(sadjncy + i));
#line 744
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 747
    (sgraphs + iii)->nvtxs = snvtxs;
#line 748
    (sgraphs + iii)->nedges = snedges;
#line 749
    (sgraphs + iii)->ncon = 1L;
#line 751
    if (snvtxs < 200L) {
#line 752
      (sgraphs + iii)->adjwgt = (idxtype *)((void *)0);
    }
#line 697
    iii ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 755
  if (ctrl->dbglvl & 1L) {
    {
#line 755
    tmp___3 = __seconds();
#line 755
    ctrl->SplitTmr += tmp___3;
    }
  }
  {
#line 757
  __idxwspacefree(ctrl, nvtxs);
  }
#line 759
  return (ncmps);
}
}
#line 22 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kmetis.c"
void METIS_PartGraphKway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                         idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                         long *options , long *edgecut , idxtype *part ) 
{ 
  long i ;
  float *tpwgts ;

  {
  {
#line 29
  tpwgts = __fmalloc(*nparts, (char *)"KMETIS: tpwgts");
#line 30
  i = 0L;
  }
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (i < *nparts)) {
#line 30
      goto while_break;
    }
#line 31
    *(tpwgts + i) = (float )(1.0 / (1.0 * (double )*nparts));
#line 30
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 33
  METIS_WPartGraphKway(nvtxs, xadj, adjncy, vwgt, adjwgt, wgtflag, numflag, nparts,
                       tpwgts, options, edgecut, part);
#line 36
  free((void *)tpwgts);
  }
#line 37
  return;
}
}
#line 43 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kmetis.c"
void METIS_WPartGraphKway(long *nvtxs , idxtype *xadj , idxtype *adjncy , idxtype *vwgt ,
                          idxtype *adjwgt , long *wgtflag , long *numflag , long *nparts ,
                          float *tpwgts , long *options , long *edgecut , idxtype *part ) 
{ 
  GraphType graph ;
  CtrlType ctrl ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
#line 51
  if (*numflag == 1L) {
    {
#line 52
    __Change2CNumbering(*nvtxs, xadj, adjncy);
    }
  }
  {
#line 54
  __SetUpGraph(& graph, 2L, *nvtxs, 1L, xadj, adjncy, vwgt, adjwgt, *wgtflag);
  }
#line 56
  if (*(options + 0) == 0L) {
#line 57
    ctrl.CType = 3L;
#line 58
    ctrl.IType = 1L;
#line 59
    ctrl.RType = 3L;
#line 60
    ctrl.dbglvl = 0L;
  } else {
#line 63
    ctrl.CType = *(options + 1);
#line 64
    ctrl.IType = *(options + 2);
#line 65
    ctrl.RType = *(options + 3);
#line 66
    ctrl.dbglvl = *(options + 4);
  }
  {
#line 68
  ctrl.optype = 2L;
#line 69
  tmp___1 = __ilog2(*nparts);
  }
#line 69
  if (*nvtxs / (40L * tmp___1) >= 20L * *nparts) {
    {
#line 69
    tmp___0 = __ilog2(*nparts);
#line 69
    ctrl.CoarsenTo = *nvtxs / (40L * tmp___0);
    }
  } else {
#line 69
    ctrl.CoarsenTo = 20L * *nparts;
  }
#line 70
  if (graph.vwgt) {
    {
#line 70
    tmp___2 = __idxsum(*nvtxs, graph.vwgt);
#line 70
    tmp___3 = tmp___2;
    }
  } else {
#line 70
    tmp___3 = *nvtxs;
  }
  {
#line 70
  ctrl.maxvwgt = (long )(1.5 * (double )(tmp___3 / ctrl.CoarsenTo));
#line 72
  __InitRandom(-1L);
#line 74
  __AllocateWorkSpace(& ctrl, & graph, *nparts);
  }
#line 76
  if (ctrl.dbglvl & 1L) {
    {
#line 76
    __InitTimers(& ctrl);
    }
  }
#line 77
  if (ctrl.dbglvl & 1L) {
    {
#line 77
    tmp___4 = __seconds();
#line 77
    ctrl.TotalTmr -= tmp___4;
    }
  }
  {
#line 79
  *edgecut = __MlevelKWayPartitioning(& ctrl, & graph, *nparts, part, tpwgts, (float )1.03);
  }
#line 81
  if (ctrl.dbglvl & 1L) {
    {
#line 81
    tmp___5 = __seconds();
#line 81
    ctrl.TotalTmr += tmp___5;
    }
  }
#line 82
  if (ctrl.dbglvl & 1L) {
    {
#line 82
    __PrintTimers(& ctrl);
    }
  }
  {
#line 84
  __FreeWorkSpace(& ctrl, & graph);
  }
#line 86
  if (*numflag == 1L) {
    {
#line 87
    __Change2FNumbering(*nvtxs, xadj, adjncy, part);
    }
  }
#line 88
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/kmetis.c"
long __MlevelKWayPartitioning(CtrlType *ctrl , GraphType *graph , long nparts , idxtype *part ,
                              float *tpwgts , float ubfactor ) 
{ 
  GraphType *cgraph ;
  long wgtflag ;
  long numflag ;
  long options[10] ;
  long edgecut ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 98
  wgtflag = 3L;
#line 98
  numflag = 0L;
#line 100
  cgraph = __Coarsen2Way(ctrl, graph);
  }
#line 102
  if (ctrl->dbglvl & 1L) {
    {
#line 102
    tmp = __seconds();
#line 102
    ctrl->InitPartTmr -= tmp;
    }
  }
  {
#line 103
  __AllocateKWayPartitionMemory(ctrl, cgraph, nparts);
#line 105
  options[0] = 1L;
#line 106
  options[1] = 4L;
#line 107
  options[2] = 1L;
#line 108
  options[3] = 1L;
#line 109
  options[4] = 0L;
#line 111
  METIS_WPartGraphRecursive(& cgraph->nvtxs, cgraph->xadj, cgraph->adjncy, cgraph->vwgt,
                            cgraph->adjwgt, & wgtflag, & numflag, & nparts, tpwgts,
                            options, & edgecut, cgraph->where);
  }
#line 115
  if (ctrl->dbglvl & 1L) {
    {
#line 115
    tmp___0 = __seconds();
#line 115
    ctrl->InitPartTmr += tmp___0;
    }
  }
#line 116
  if (ctrl->dbglvl & 16L) {
    {
#line 116
    printf((char const   */* __restrict  */)"Initial %ld-way partitioning cut: %ld\n",
           nparts, edgecut);
    }
  }
#line 118
  if (ctrl->dbglvl & 64L) {
    {
#line 118
    __ComputePartitionInfo(cgraph, nparts, cgraph->where);
    }
  }
  {
#line 120
  __RefineKWay(ctrl, graph, cgraph, nparts, tpwgts, ubfactor);
#line 122
  memcpy((void */* __restrict  */)((void *)part), (void const   */* __restrict  */)((void *)graph->where),
         sizeof(idxtype ) * (unsigned long )graph->nvtxs);
#line 124
  __GKfree(& graph->gdata, & graph->rdata, (void **)0);
  }
#line 126
  return (graph->mincut);
}
}
#line 20 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/fm.c"
void __FM_2WayEdgeRefine(CtrlType *ctrl , GraphType *graph , long *tpwgts , long npasses ) 
{ 
  long i ;
  long ii ;
  long j ;
  long k ;
  long kwgt ;
  long nvtxs ;
  long nbnd ;
  long nswaps ;
  long from ;
  long to ;
  long pass ;
  long limit ;
  long tmp ;
  idxtype *xadj ;
  idxtype *vwgt ;
  idxtype *adjncy ;
  idxtype *adjwgt ;
  idxtype *where ;
  idxtype *id ;
  idxtype *ed ;
  idxtype *bndptr ;
  idxtype *bndind ;
  idxtype *pwgts ;
  idxtype *moved ;
  idxtype *swaps ;
  idxtype *perm ;
  PQueueType parts[2] ;
  long higain ;
  long oldgain ;
  long mincut ;
  long mindiff ;
  long origdiff ;
  long initcut ;
  long newcut ;
  long mincutorder ;
  long avgvwgt ;
  double tmp___1 ;
  double tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  idxtype tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;

  {
  {
#line 28
  nvtxs = graph->nvtxs;
#line 29
  xadj = graph->xadj;
#line 30
  vwgt = graph->vwgt;
#line 31
  adjncy = graph->adjncy;
#line 32
  adjwgt = graph->adjwgt;
#line 33
  where = graph->where;
#line 34
  id = graph->id;
#line 35
  ed = graph->ed;
#line 36
  pwgts = graph->pwgts;
#line 37
  bndptr = graph->bndptr;
#line 38
  bndind = graph->bndind;
#line 40
  moved = __idxwspacemalloc(ctrl, nvtxs);
#line 41
  swaps = __idxwspacemalloc(ctrl, nvtxs);
#line 42
  perm = __idxwspacemalloc(ctrl, nvtxs);
  }
#line 44
  if (0.01 * (double )nvtxs >= (double )15) {
#line 44
    tmp___2 = 0.01 * (double )nvtxs;
  } else {
#line 44
    tmp___2 = (double )15;
  }
#line 44
  if (tmp___2 >= (double )100) {
#line 44
    limit = 100L;
  } else {
#line 44
    if (0.01 * (double )nvtxs >= (double )15) {
#line 44
      tmp___1 = 0.01 * (double )nvtxs;
    } else {
#line 44
      tmp___1 = (double )15;
    }
#line 44
    limit = (long )tmp___1;
  }
#line 45
  if ((*(pwgts + 0) + *(pwgts + 1)) / 20L >= (2L * (*(pwgts + 0) + *(pwgts + 1))) / nvtxs) {
#line 45
    avgvwgt = (2L * (*(pwgts + 0) + *(pwgts + 1))) / nvtxs;
  } else {
#line 45
    avgvwgt = (*(pwgts + 0) + *(pwgts + 1)) / 20L;
  }
  {
#line 47
  tmp___3 = __idxamax(nvtxs, graph->adjwgtsum);
#line 47
  tmp = *(graph->adjwgtsum + tmp___3);
#line 48
  __PQueueInit(ctrl, & parts[0], nvtxs, tmp);
#line 49
  __PQueueInit(ctrl, & parts[1], nvtxs, tmp);
  }
#line 51
  if (ctrl->dbglvl & 8L) {
    {
#line 51
    printf((char const   */* __restrict  */)"Partitions: [%6ld %6ld] T[%6ld %6ld], Nv-Nb[%6ld %6ld]. ICut: %6ld\n",
           *(pwgts + 0), *(pwgts + 1), *(tpwgts + 0), *(tpwgts + 1), graph->nvtxs,
           graph->nbnd, graph->mincut);
    }
  }
  {
#line 55
  tmp___4 = abs((int )(*(tpwgts + 0) - *(pwgts + 0)));
#line 55
  origdiff = (long )tmp___4;
#line 56
  __idxset(nvtxs, (idxtype )-1, moved);
#line 57
  pass = 0L;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (pass < npasses)) {
#line 57
      goto while_break;
    }
    {
#line 58
    __PQueueReset(& parts[0]);
#line 59
    __PQueueReset(& parts[1]);
#line 61
    mincutorder = -1L;
#line 62
    initcut = graph->mincut;
#line 62
    mincut = initcut;
#line 62
    newcut = mincut;
#line 63
    tmp___5 = abs((int )(*(tpwgts + 0) - *(pwgts + 0)));
#line 63
    mindiff = (long )tmp___5;
#line 69
    nbnd = graph->nbnd;
#line 70
    __RandomPermute(nbnd, perm, 1L);
#line 71
    ii = 0L;
    }
    {
#line 71
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 71
      if (! (ii < nbnd)) {
#line 71
        goto while_break___0;
      }
      {
#line 72
      i = *(perm + ii);
#line 75
      __PQueueInsert(& parts[*(where + *(bndind + i))], *(bndind + i), *(ed + *(bndind + i)) - *(id + *(bndind + i)));
#line 71
      ii ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 78
    nswaps = 0L;
    {
#line 78
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 78
      if (! (nswaps < nvtxs)) {
#line 78
        goto while_break___1;
      }
#line 79
      if (*(tpwgts + 0) - *(pwgts + 0) < *(tpwgts + 1) - *(pwgts + 1)) {
#line 79
        from = 0L;
      } else {
#line 79
        from = 1L;
      }
      {
#line 80
      to = (from + 1L) % 2L;
#line 82
      higain = __PQueueGetMax(& parts[from]);
      }
#line 82
      if (higain == -1L) {
#line 83
        goto while_break___1;
      }
#line 86
      newcut -= *(ed + higain) - *(id + higain);
      {
#line 87
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 87
        *(pwgts + to) += *(vwgt + higain);
#line 87
        *(pwgts + from) -= *(vwgt + higain);
#line 87
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 89
      if (newcut < mincut) {
        {
#line 89
        tmp___7 = abs((int )(*(tpwgts + 0) - *(pwgts + 0)));
        }
#line 89
        if ((long )tmp___7 <= origdiff + avgvwgt) {
          {
#line 91
          mincut = newcut;
#line 92
          tmp___6 = abs((int )(*(tpwgts + 0) - *(pwgts + 0)));
#line 92
          mindiff = (long )tmp___6;
#line 93
          mincutorder = nswaps;
          }
        } else {
#line 89
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 89
      if (newcut == mincut) {
        {
#line 89
        tmp___8 = abs((int )(*(tpwgts + 0) - *(pwgts + 0)));
        }
#line 89
        if ((long )tmp___8 < mindiff) {
          {
#line 91
          mincut = newcut;
#line 92
          tmp___6 = abs((int )(*(tpwgts + 0) - *(pwgts + 0)));
#line 92
          mindiff = (long )tmp___6;
#line 93
          mincutorder = nswaps;
          }
        } else {
#line 89
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 95
      if (nswaps - mincutorder > limit) {
#line 96
        newcut += *(ed + higain) - *(id + higain);
        {
#line 97
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 97
          *(pwgts + from) += *(vwgt + higain);
#line 97
          *(pwgts + to) -= *(vwgt + higain);
#line 97
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 98
        goto while_break___1;
      }
#line 101
      *(where + higain) = to;
#line 102
      *(moved + higain) = nswaps;
#line 103
      *(swaps + nswaps) = higain;
#line 105
      if (ctrl->dbglvl & 32L) {
        {
#line 105
        printf((char const   */* __restrict  */)"Moved %6ld from %ld. [%3ld %3ld] %5ld [%4ld %4ld]\n",
               higain, from, *(ed + higain) - *(id + higain), *(vwgt + higain), newcut,
               *(pwgts + 0), *(pwgts + 1));
        }
      }
      {
#line 111
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 111
        tmp = *(id + higain);
#line 111
        *(id + higain) = *(ed + higain);
#line 111
        *(ed + higain) = tmp;
#line 111
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 112
      if (*(ed + higain) == 0L) {
#line 112
        if (*(xadj + higain) < *(xadj + (higain + 1L))) {
          {
#line 113
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 113
            nbnd --;
#line 113
            *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 113
            *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 113
            *(bndptr + higain) = (idxtype )-1;
#line 113
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      }
#line 115
      j = *(xadj + higain);
      {
#line 115
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 115
        if (! (j < *(xadj + (higain + 1L)))) {
#line 115
          goto while_break___6;
        }
#line 116
        k = *(adjncy + j);
#line 117
        oldgain = *(ed + k) - *(id + k);
#line 119
        if (to == *(where + k)) {
#line 119
          kwgt = *(adjwgt + j);
        } else {
#line 119
          kwgt = - *(adjwgt + j);
        }
        {
#line 120
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 120
          *(id + k) += kwgt;
#line 120
          *(ed + k) -= kwgt;
#line 120
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 123
        if (*(bndptr + k) != -1L) {
#line 124
          if (*(ed + k) == 0L) {
            {
#line 125
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 125
              nbnd --;
#line 125
              *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 125
              *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 125
              *(bndptr + k) = (idxtype )-1;
#line 125
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 126
            if (*(moved + k) == -1L) {
              {
#line 127
              __PQueueDelete(& parts[*(where + k)], k, oldgain);
              }
            }
          } else
#line 130
          if (*(moved + k) == -1L) {
            {
#line 131
            __PQueueUpdate(& parts[*(where + k)], k, oldgain, *(ed + k) - *(id + k));
            }
          }
        } else
#line 135
        if (*(ed + k) > 0L) {
          {
#line 136
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 136
            *(bndind + nbnd) = k;
#line 136
            tmp___9 = nbnd;
#line 136
            nbnd ++;
#line 136
            *(bndptr + k) = tmp___9;
#line 136
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 137
          if (*(moved + k) == -1L) {
            {
#line 138
            __PQueueInsert(& parts[*(where + k)], k, *(ed + k) - *(id + k));
            }
          }
        }
#line 115
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 78
      nswaps ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 149
    i = 0L;
    {
#line 149
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 149
      if (! (i < nswaps)) {
#line 149
        goto while_break___10;
      }
#line 150
      *(moved + *(swaps + i)) = (idxtype )-1;
#line 149
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 151
    nswaps --;
    {
#line 151
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 151
      if (! (nswaps > mincutorder)) {
#line 151
        goto while_break___11;
      }
#line 152
      higain = *(swaps + nswaps);
#line 154
      tmp___10 = (*(where + higain) + 1L) % 2L;
#line 154
      *(where + higain) = tmp___10;
#line 154
      to = tmp___10;
      {
#line 155
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 155
        tmp = *(id + higain);
#line 155
        *(id + higain) = *(ed + higain);
#line 155
        *(ed + higain) = tmp;
#line 155
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 156
      if (*(ed + higain) == 0L) {
#line 156
        if (*(bndptr + higain) != -1L) {
#line 156
          if (*(xadj + higain) < *(xadj + (higain + 1L))) {
            {
#line 157
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 157
              nbnd --;
#line 157
              *(bndind + *(bndptr + higain)) = *(bndind + nbnd);
#line 157
              *(bndptr + *(bndind + nbnd)) = *(bndptr + higain);
#line 157
              *(bndptr + higain) = (idxtype )-1;
#line 157
              goto while_break___13;
            }
            while_break___13: /* CIL Label */ ;
            }
          } else {
#line 156
            goto _L___2;
          }
        } else {
#line 156
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 158
      if (*(ed + higain) > 0L) {
#line 158
        if (*(bndptr + higain) == -1L) {
          {
#line 159
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 159
            *(bndind + nbnd) = higain;
#line 159
            tmp___11 = nbnd;
#line 159
            nbnd ++;
#line 159
            *(bndptr + higain) = tmp___11;
#line 159
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
      }
      {
#line 161
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 161
        *(pwgts + to) += *(vwgt + higain);
#line 161
        *(pwgts + (to + 1L) % 2L) -= *(vwgt + higain);
#line 161
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 162
      j = *(xadj + higain);
      {
#line 162
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 162
        if (! (j < *(xadj + (higain + 1L)))) {
#line 162
          goto while_break___16;
        }
#line 163
        k = *(adjncy + j);
#line 165
        if (to == *(where + k)) {
#line 165
          kwgt = *(adjwgt + j);
        } else {
#line 165
          kwgt = - *(adjwgt + j);
        }
        {
#line 166
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 166
          *(id + k) += kwgt;
#line 166
          *(ed + k) -= kwgt;
#line 166
          goto while_break___17;
        }
        while_break___17: /* CIL Label */ ;
        }
#line 168
        if (*(bndptr + k) != -1L) {
#line 168
          if (*(ed + k) == 0L) {
            {
#line 169
            while (1) {
              while_continue___18: /* CIL Label */ ;
#line 169
              nbnd --;
#line 169
              *(bndind + *(bndptr + k)) = *(bndind + nbnd);
#line 169
              *(bndptr + *(bndind + nbnd)) = *(bndptr + k);
#line 169
              *(bndptr + k) = (idxtype )-1;
#line 169
              goto while_break___18;
            }
            while_break___18: /* CIL Label */ ;
            }
          }
        }
#line 170
        if (*(bndptr + k) == -1L) {
#line 170
          if (*(ed + k) > 0L) {
            {
#line 171
            while (1) {
              while_continue___19: /* CIL Label */ ;
#line 171
              *(bndind + nbnd) = k;
#line 171
              tmp___12 = nbnd;
#line 171
              nbnd ++;
#line 171
              *(bndptr + k) = tmp___12;
#line 171
              goto while_break___19;
            }
            while_break___19: /* CIL Label */ ;
            }
          }
        }
#line 162
        j ++;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 151
      nswaps --;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 175
    if (ctrl->dbglvl & 8L) {
      {
#line 175
      printf((char const   */* __restrict  */)"\tMinimum cut: %6ld at %5ld, PWGTS: [%6ld %6ld], NBND: %6ld\n",
             mincut, mincutorder, *(pwgts + 0), *(pwgts + 1), nbnd);
      }
    }
#line 178
    graph->mincut = mincut;
#line 179
    graph->nbnd = nbnd;
#line 181
    if (mincutorder == -1L) {
#line 182
      goto while_break;
    } else
#line 181
    if (mincut == initcut) {
#line 182
      goto while_break;
    }
#line 57
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  __PQueueFree(ctrl, & parts[0]);
#line 186
  __PQueueFree(ctrl, & parts[1]);
#line 188
  __idxwspacefree(ctrl, nvtxs);
#line 189
  __idxwspacefree(ctrl, nvtxs);
#line 190
  __idxwspacefree(ctrl, nvtxs);
  }
#line 192
  return;
}
}
#line 21 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/memory.c"
void __AllocateWorkSpace(CtrlType *ctrl , GraphType *graph , long nparts ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  idxtype *tmp___1 ;

  {
#line 23
  ctrl->wspace.pmat = (idxtype *)((void *)0);
#line 25
  if (ctrl->optype == 2L) {
    {
#line 26
    tmp = __GKmalloc((long )((unsigned long )graph->nedges * sizeof(EDegreeType )),
                     (char *)"AllocateWorkSpace: edegrees");
#line 26
    ctrl->wspace.edegrees = (EDegreeType *)tmp;
#line 27
    ctrl->wspace.vedegrees = (VEDegreeType *)((void *)0);
#line 28
    ctrl->wspace.auxcore = (idxtype *)ctrl->wspace.edegrees;
#line 30
    ctrl->wspace.pmat = __idxmalloc(nparts * nparts, (char *)"AllocateWorkSpace: pmat");
#line 45
    ctrl->wspace.maxcore = (long )(((unsigned long )(3L * (graph->nvtxs + 1L) + 5L * (nparts + 1L)) + (unsigned long )graph->nvtxs * (sizeof(ListNodeType ) / sizeof(idxtype ))) + 20UL);
    }
  } else
#line 51
  if (ctrl->optype == 6L) {
    {
#line 52
    ctrl->wspace.edegrees = (EDegreeType *)((void *)0);
#line 53
    tmp___0 = __GKmalloc((long )((unsigned long )graph->nedges * sizeof(VEDegreeType )),
                         (char *)"AllocateWorkSpace: vedegrees");
#line 53
    ctrl->wspace.vedegrees = (VEDegreeType *)tmp___0;
#line 54
    ctrl->wspace.auxcore = (idxtype *)ctrl->wspace.vedegrees;
#line 56
    ctrl->wspace.pmat = __idxmalloc(nparts * nparts, (char *)"AllocateWorkSpace: pmat");
#line 59
    ctrl->wspace.maxcore = (long )(((unsigned long )(3L * (graph->nvtxs + 1L) + 3L * (nparts + 1L)) + (unsigned long )graph->nvtxs * (sizeof(ListNodeType ) / sizeof(idxtype ))) + 20UL);
    }
  } else {
    {
#line 66
    tmp___1 = __idxmalloc(graph->nedges, (char *)"AllocateWorkSpace: edegrees");
#line 66
    ctrl->wspace.edegrees = (EDegreeType *)tmp___1;
#line 67
    ctrl->wspace.vedegrees = (VEDegreeType *)((void *)0);
#line 68
    ctrl->wspace.auxcore = (idxtype *)ctrl->wspace.edegrees;
#line 70
    ctrl->wspace.maxcore = (long )((((unsigned long )(5L * (graph->nvtxs + 1L) + 4L * (nparts + 1L)) + (unsigned long )((2L * graph->ncon) * graph->nvtxs) * (sizeof(ListNodeType ) / sizeof(idxtype ))) + (unsigned long )((2L * graph->ncon) * 1001L) * (sizeof(ListNodeType *) / sizeof(idxtype ))) + 20UL);
    }
  }
  {
#line 78
  ctrl->wspace.maxcore += (long )((1 << 11) - 1);
#line 79
  ctrl->wspace.core = __idxmalloc(ctrl->wspace.maxcore, (char *)"AllocateWorkSpace: maxcore");
#line 80
  ctrl->wspace.ccore = 0L;
  }
#line 81
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/memory.c"
void __FreeWorkSpace(CtrlType *ctrl , GraphType *graph ) 
{ 


  {
  {
#line 89
  __GKfree(& ctrl->wspace.edegrees, & ctrl->wspace.vedegrees, & ctrl->wspace.core,
           & ctrl->wspace.pmat, (void **)0);
  }
#line 90
  return;
}
}
#line 95 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/memory.c"
long __WspaceAvail(CtrlType *ctrl ) 
{ 


  {
#line 97
  return (ctrl->wspace.maxcore - ctrl->wspace.ccore);
}
}
#line 104 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/memory.c"
idxtype *__idxwspacemalloc(CtrlType *ctrl , long n ) 
{ 


  {
#line 106
  n += n % 2L;
#line 108
  ctrl->wspace.ccore += n;
#line 110
  return ((ctrl->wspace.core + ctrl->wspace.ccore) - n);
}
}
#line 116 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/memory.c"
void __idxwspacefree(CtrlType *ctrl , long n ) 
{ 


  {
#line 118
  n += n % 2L;
#line 120
  ctrl->wspace.ccore -= n;
#line 122
  return;
}
}
#line 128 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/memory.c"
float *__fwspacemalloc(CtrlType *ctrl , long n ) 
{ 


  {
#line 130
  n += n % 2L;
#line 132
  ctrl->wspace.ccore += n;
#line 134
  return ((float *)((ctrl->wspace.core + ctrl->wspace.ccore) - n));
}
}
#line 140 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/memory.c"
void fwspacefree(CtrlType *ctrl , long n ) 
{ 


  {
#line 142
  n += n % 2L;
#line 144
  ctrl->wspace.ccore -= n;
#line 146
  return;
}
}
#line 154 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/memory.c"
GraphType *__CreateGraph(void) 
{ 
  GraphType *graph ;
  void *tmp ;

  {
  {
#line 158
  tmp = __GKmalloc((long )sizeof(GraphType ), (char *)"CreateCoarseGraph: graph");
#line 158
  graph = (GraphType *)tmp;
#line 160
  __InitGraph(graph);
  }
#line 162
  return (graph);
}
}
#line 170 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/memory.c"
void __InitGraph(GraphType *graph ) 
{ 
  idxtype *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  idxtype *tmp___2 ;
  idxtype *tmp___3 ;
  idxtype *tmp___4 ;
  idxtype *tmp___5 ;
  idxtype *tmp___6 ;
  idxtype *tmp___7 ;
  struct graphdef *tmp___8 ;

  {
#line 172
  tmp = (idxtype *)((void *)0);
#line 172
  graph->rdata = tmp;
#line 172
  graph->gdata = tmp;
#line 174
  tmp___0 = -1L;
#line 174
  graph->nedges = tmp___0;
#line 174
  graph->nvtxs = tmp___0;
#line 175
  tmp___1 = -1L;
#line 175
  graph->minvol = tmp___1;
#line 175
  graph->mincut = tmp___1;
#line 177
  tmp___4 = (idxtype *)((void *)0);
#line 177
  graph->adjwgt = tmp___4;
#line 177
  tmp___3 = tmp___4;
#line 177
  graph->adjncy = tmp___3;
#line 177
  tmp___2 = tmp___3;
#line 177
  graph->vwgt = tmp___2;
#line 177
  graph->xadj = tmp___2;
#line 178
  graph->adjwgtsum = (idxtype *)((void *)0);
#line 179
  graph->label = (idxtype *)((void *)0);
#line 180
  graph->cmap = (idxtype *)((void *)0);
#line 182
  tmp___5 = (idxtype *)((void *)0);
#line 182
  graph->pwgts = tmp___5;
#line 182
  graph->where = tmp___5;
#line 183
  tmp___6 = (idxtype *)((void *)0);
#line 183
  graph->ed = tmp___6;
#line 183
  graph->id = tmp___6;
#line 184
  tmp___7 = (idxtype *)((void *)0);
#line 184
  graph->bndind = tmp___7;
#line 184
  graph->bndptr = tmp___7;
#line 185
  graph->rinfo = (RInfoType *)((void *)0);
#line 186
  graph->vrinfo = (VRInfoType *)((void *)0);
#line 187
  graph->nrinfo = (NRInfoType *)((void *)0);
#line 189
  graph->ncon = -1L;
#line 190
  graph->nvwgt = (float *)((void *)0);
#line 191
  graph->npwgts = (float *)((void *)0);
#line 193
  graph->vsize = (idxtype *)((void *)0);
#line 195
  tmp___8 = (struct graphdef *)((void *)0);
#line 195
  graph->finer = tmp___8;
#line 195
  graph->coarser = tmp___8;
#line 197
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/memory.c"
void __FreeGraph(GraphType *graph ) 
{ 


  {
  {
#line 205
  __GKfree(& graph->gdata, & graph->nvwgt, & graph->rdata, & graph->npwgts, (void **)0);
#line 206
  free((void *)graph);
  }
#line 207
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 403
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand48)(long __seedval ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 156 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 428 "./proto.h"
long *__imalloc(long n , char *msg ) ;
#line 431
long *__ismalloc(long n , long ival , char *msg ) ;
#line 436
long *__iset(long n , long val , long *x ) ;
#line 448
void __idxadd(long n , idxtype *x , idxtype *y ) ;
#line 449
long __charsum(long n , char *x ) ;
#line 450
long __isum(long n , long *x ) ;
#line 455
float __sdot(long n , float *x , float *y ) ;
#line 460
long __ispow2(long a ) ;
#line 20 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
void __errexit(char *f_str  , ...) 
{ 
  va_list argp ;
  char out1[256] ;
  char out2[256] ;

  {
  {
#line 25
  __builtin_va_start(argp, f_str);
#line 26
  vsprintf((char */* __restrict  */)(out1), (char const   */* __restrict  */)f_str,
           argp);
#line 27
  __builtin_va_end(argp);
#line 29
  sprintf((char */* __restrict  */)(out2), (char const   */* __restrict  */)"Error! %s",
          out1);
#line 31
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
          out2);
#line 32
  fflush(stdout);
#line 34
  abort();
  }
}
}
#line 43 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long *__imalloc(long n , char *msg ) 
{ 
  void *tmp ;

  {
#line 45
  if (n == 0L) {
#line 46
    return ((long *)((void *)0));
  }
  {
#line 48
  tmp = __GKmalloc((long )(sizeof(long ) * (unsigned long )n), msg);
  }
#line 48
  return ((long *)tmp);
}
}
#line 55 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
idxtype *__idxmalloc(long n , char *msg ) 
{ 
  void *tmp ;

  {
#line 57
  if (n == 0L) {
#line 58
    return ((idxtype *)((void *)0));
  }
  {
#line 60
  tmp = __GKmalloc((long )(sizeof(idxtype ) * (unsigned long )n), msg);
  }
#line 60
  return ((idxtype *)tmp);
}
}
#line 67 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
float *__fmalloc(long n , char *msg ) 
{ 
  void *tmp ;

  {
#line 69
  if (n == 0L) {
#line 70
    return ((float *)((void *)0));
  }
  {
#line 72
  tmp = __GKmalloc((long )(sizeof(float ) * (unsigned long )n), msg);
  }
#line 72
  return ((float *)tmp);
}
}
#line 79 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long *__ismalloc(long n , long ival , char *msg ) 
{ 
  void *tmp ;
  long *tmp___0 ;

  {
#line 81
  if (n == 0L) {
#line 82
    return ((long *)((void *)0));
  }
  {
#line 84
  tmp = __GKmalloc((long )(sizeof(long ) * (unsigned long )n), msg);
#line 84
  tmp___0 = __iset(n, ival, (long *)tmp);
  }
#line 84
  return (tmp___0);
}
}
#line 92 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
idxtype *__idxsmalloc(long n , idxtype ival , char *msg ) 
{ 
  void *tmp ;
  idxtype *tmp___0 ;

  {
#line 94
  if (n == 0L) {
#line 95
    return ((idxtype *)((void *)0));
  }
  {
#line 97
  tmp = __GKmalloc((long )(sizeof(idxtype ) * (unsigned long )n), msg);
#line 97
  tmp___0 = __idxset(n, ival, (idxtype *)tmp);
  }
#line 97
  return (tmp___0);
}
}
#line 104 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
void *__GKmalloc(long nbytes , char *msg ) 
{ 
  void *ptr ;
  void *tmp ;

  {
#line 108
  if (nbytes == 0L) {
#line 109
    return ((void *)0);
  }
  {
#line 111
  tmp = malloc((size_t )nbytes);
#line 111
  ptr = tmp;
  }
#line 112
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 113
    __errexit((char *)"***Memory allocation failed for %s. Requested size: %ld bytes",
              msg, nbytes);
    }
  }
#line 115
  return (ptr);
}
}
#line 122 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
void __GKfree(void **ptr1  , ...) 
{ 
  va_list plist ;
  void **ptr ;
  void **tmp ;

  {
#line 127
  if ((unsigned long )*ptr1 != (unsigned long )((void *)0)) {
    {
#line 128
    free(*ptr1);
    }
  }
  {
#line 129
  *ptr1 = (void *)0;
#line 131
  __builtin_va_start(plist, ptr1);
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 134
    tmp = __builtin_va_arg(plist, void **);
#line 134
    ptr = tmp;
    }
#line 134
    if (! ((unsigned long )ptr != (unsigned long )((void **)0))) {
#line 134
      goto while_break;
    }
#line 135
    if ((unsigned long )*ptr != (unsigned long )((void *)0)) {
      {
#line 136
      free(*ptr);
      }
    }
#line 137
    *ptr = (void *)0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  __builtin_va_end(plist);
  }
#line 141
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long *__iset(long n , long val , long *x ) 
{ 
  long i ;

  {
#line 151
  i = 0L;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < n)) {
#line 151
      goto while_break;
    }
#line 152
    *(x + i) = val;
#line 151
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return (x);
}
}
#line 161 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
idxtype *__idxset(long n , idxtype val , idxtype *x ) 
{ 
  long i ;

  {
#line 165
  i = 0L;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < n)) {
#line 165
      goto while_break;
    }
#line 166
    *(x + i) = val;
#line 165
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return (x);
}
}
#line 175 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
float *__sset(long n , float val , float *x ) 
{ 
  long i ;

  {
#line 179
  i = 0L;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i < n)) {
#line 179
      goto while_break;
    }
#line 180
    *(x + i) = val;
#line 179
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return (x);
}
}
#line 190 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long __iamax(long n , long *x ) 
{ 
  long i ;
  long max ;

  {
#line 192
  max = 0L;
#line 194
  i = 1L;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! (i < n)) {
#line 194
      goto while_break;
    }
#line 195
    if (*(x + i) > *(x + max)) {
#line 195
      max = i;
    } else {
#line 195
      max = max;
    }
#line 194
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return (max);
}
}
#line 204 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long __idxamax(long n , idxtype *x ) 
{ 
  long i ;
  long max ;

  {
#line 206
  max = 0L;
#line 208
  i = 1L;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! (i < n)) {
#line 208
      goto while_break;
    }
#line 209
    if (*(x + i) > *(x + max)) {
#line 209
      max = i;
    } else {
#line 209
      max = max;
    }
#line 208
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return (max);
}
}
#line 217 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long __idxamax_strd(long n , idxtype *x , long incx ) 
{ 
  long i ;
  long max ;

  {
#line 219
  max = 0L;
#line 221
  n *= incx;
#line 222
  i = incx;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! (i < n)) {
#line 222
      goto while_break;
    }
#line 223
    if (*(x + i) > *(x + max)) {
#line 223
      max = i;
    } else {
#line 223
      max = max;
    }
#line 222
    i += incx;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return (max / incx);
}
}
#line 233 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long __samax(long n , float *x ) 
{ 
  long i ;
  long max ;

  {
#line 235
  max = 0L;
#line 237
  i = 1L;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! (i < n)) {
#line 237
      goto while_break;
    }
#line 238
    if (*(x + i) > *(x + max)) {
#line 238
      max = i;
    } else {
#line 238
      max = max;
    }
#line 237
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return (max);
}
}
#line 246 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long __samax2(long n , float *x ) 
{ 
  long i ;
  long max1 ;
  long max2 ;

  {
#line 250
  if (*(x + 0) > *(x + 1)) {
#line 251
    max1 = 0L;
#line 252
    max2 = 1L;
  } else {
#line 255
    max1 = 1L;
#line 256
    max2 = 0L;
  }
#line 259
  i = 2L;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! (i < n)) {
#line 259
      goto while_break;
    }
#line 260
    if (*(x + i) > *(x + max1)) {
#line 261
      max2 = max1;
#line 262
      max1 = i;
    } else
#line 264
    if (*(x + i) > *(x + max2)) {
#line 265
      max2 = i;
    }
#line 259
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  return (max2);
}
}
#line 275 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long __idxamin(long n , idxtype *x ) 
{ 
  long i ;
  long min ;

  {
#line 277
  min = 0L;
#line 279
  i = 1L;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! (i < n)) {
#line 279
      goto while_break;
    }
#line 280
    if (*(x + i) < *(x + min)) {
#line 280
      min = i;
    } else {
#line 280
      min = min;
    }
#line 279
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  return (min);
}
}
#line 289 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long __samin(long n , float *x ) 
{ 
  long i ;
  long min ;

  {
#line 291
  min = 0L;
#line 293
  i = 1L;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (i < n)) {
#line 293
      goto while_break;
    }
#line 294
    if (*(x + i) < *(x + min)) {
#line 294
      min = i;
    } else {
#line 294
      min = min;
    }
#line 293
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return (min);
}
}
#line 303 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long __idxsum(long n , idxtype *x ) 
{ 
  long i ;
  long sum ;

  {
#line 305
  sum = 0L;
#line 307
  i = 0L;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! (i < n)) {
#line 307
      goto while_break;
    }
#line 308
    sum += *(x + i);
#line 307
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  return (sum);
}
}
#line 317 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long __idxsum_strd(long n , idxtype *x , long incx ) 
{ 
  long i ;
  long sum ;

  {
#line 319
  sum = 0L;
#line 321
  i = 0L;
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! (i < n)) {
#line 321
      goto while_break;
    }
#line 322
    sum += *x;
#line 321
    i ++;
#line 321
    x += incx;
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  return (sum);
}
}
#line 332 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
void __idxadd(long n , idxtype *x , idxtype *y ) 
{ 


  {
#line 334
  n --;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (n >= 0L)) {
#line 334
      goto while_break;
    }
#line 335
    *(y + n) += *(x + n);
#line 334
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 336
  return;
}
}
#line 342 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long __charsum(long n , char *x ) 
{ 
  long i ;
  long sum ;

  {
#line 344
  sum = 0L;
#line 346
  i = 0L;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! (i < n)) {
#line 346
      goto while_break;
    }
#line 347
    sum += (long )*(x + i);
#line 346
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  return (sum);
}
}
#line 355 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long __isum(long n , long *x ) 
{ 
  long i ;
  long sum ;

  {
#line 357
  sum = 0L;
#line 359
  i = 0L;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (i < n)) {
#line 359
      goto while_break;
    }
#line 360
    sum += *(x + i);
#line 359
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 362
  return (sum);
}
}
#line 368 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
float __ssum(long n , float *x ) 
{ 
  long i ;
  float sum ;

  {
#line 371
  sum = (float )0.0;
#line 373
  i = 0L;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! (i < n)) {
#line 373
      goto while_break;
    }
#line 374
    sum += *(x + i);
#line 373
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  return (sum);
}
}
#line 382 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
float __ssum_strd(long n , float *x , long incx ) 
{ 
  long i ;
  float sum ;

  {
#line 385
  sum = (float )0.0;
#line 387
  i = 0L;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (i < n)) {
#line 387
      goto while_break;
    }
#line 388
    sum += *x;
#line 387
    i ++;
#line 387
    x += incx;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  return (sum);
}
}
#line 396 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
void __sscale(long n , float alpha , float *x ) 
{ 
  long i ;

  {
#line 400
  i = 0L;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! (i < n)) {
#line 400
      goto while_break;
    }
#line 401
    *(x + i) *= alpha;
#line 400
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 402
  return;
}
}
#line 408 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
float __snorm2(long n , float *v ) 
{ 
  long i ;
  float partial ;
  double tmp ;

  {
#line 411
  partial = (float )0;
#line 413
  i = 0L;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! (i < n)) {
#line 413
      goto while_break;
    }
#line 414
    partial += *(v + i) * *(v + i);
#line 413
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 416
  tmp = sqrt((double )partial);
  }
#line 416
  return ((float )tmp);
}
}
#line 424 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
float __sdot(long n , float *x , float *y ) 
{ 
  long i ;
  float partial ;

  {
#line 427
  partial = (float )0;
#line 429
  i = 0L;
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! (i < n)) {
#line 429
      goto while_break;
    }
#line 430
    partial += *(x + i) * *(y + i);
#line 429
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 432
  return (partial);
}
}
#line 439 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
void __saxpy(long n , float alpha , float *x , long incx , float *y , long incy ) 
{ 
  long i ;

  {
#line 443
  i = 0L;
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    if (! (i < n)) {
#line 443
      goto while_break;
    }
#line 444
    *y += alpha * *x;
#line 443
    i ++;
#line 443
    x += incx;
#line 443
    y += incy;
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  return;
}
}
#line 455 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
void __RandomPermute(long n , idxtype *p , long flag ) 
{ 
  long i ;
  long u ;
  long v ;
  idxtype tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 460
  if (flag == 1L) {
#line 461
    i = 0L;
    {
#line 461
    while (1) {
      while_continue: /* CIL Label */ ;
#line 461
      if (! (i < n)) {
#line 461
        goto while_break;
      }
#line 462
      *(p + i) = i;
#line 461
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 465
  if (n <= 4L) {
#line 466
    return;
  }
#line 468
  i = 0L;
  {
#line 468
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 468
    if (! (i < n)) {
#line 468
      goto while_break___0;
    }
    {
#line 469
    tmp___0 = rand();
#line 469
    u = (long )(tmp___0 >> 3) % (n - 4L);
#line 470
    tmp___1 = rand();
#line 470
    v = (long )(tmp___1 >> 3) % (n - 4L);
    }
    {
#line 471
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 471
      tmp = *(p + v);
#line 471
      *(p + v) = *(p + u);
#line 471
      *(p + u) = tmp;
#line 471
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 472
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 472
      tmp = *(p + (v + 1L));
#line 472
      *(p + (v + 1L)) = *(p + (u + 1L));
#line 472
      *(p + (u + 1L)) = tmp;
#line 472
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 473
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 473
      tmp = *(p + (v + 2L));
#line 473
      *(p + (v + 2L)) = *(p + (u + 2L));
#line 473
      *(p + (u + 2L)) = tmp;
#line 473
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 474
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 474
      tmp = *(p + (v + 3L));
#line 474
      *(p + (v + 3L)) = *(p + (u + 3L));
#line 474
      *(p + (u + 3L)) = tmp;
#line 474
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 468
    i += 16L;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 476
  return;
}
}
#line 483 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long __ispow2(long a ) 
{ 
  int tmp ;

  {
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! (a % 2L != 1L)) {
#line 485
      goto while_break;
    }
#line 485
    a >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  if (a > 1L) {
#line 486
    tmp = 0;
  } else {
#line 486
    tmp = 1;
  }
#line 486
  return ((long )tmp);
}
}
#line 493 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
void __InitRandom(long seed ) 
{ 


  {
#line 495
  if (seed == -1L) {
    {
#line 497
    srand48(7654321L);
#line 499
    srand(4321U);
    }
  } else {
    {
#line 503
    srand48(seed);
#line 505
    srand((unsigned int )seed);
    }
  }
#line 507
  return;
}
}
#line 512 "/home/wheatley/newnew/temp/metis-edf-4.1-2/Lib/util.c"
long __ilog2(long a ) 
{ 
  long i ;

  {
#line 516
  i = 1L;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! (a > 1L)) {
#line 516
      goto while_break;
    }
#line 516
    i ++;
#line 516
    a >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  return (i - 1L);
}
}
