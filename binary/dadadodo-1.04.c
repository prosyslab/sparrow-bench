/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 20 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/dadadodo.h"
struct word;
#line 20 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/dadadodo.h"
typedef struct word word;
#line 21
struct word_link;
#line 21 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/dadadodo.h"
typedef struct word_link word_link;
#line 23 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/dadadodo.h"
struct word {
   int string ;
   int count ;
   int start ;
   int cap ;
   int comma ;
   int period ;
   int quem ;
   int bang ;
   int succ_length ;
   int pred_length ;
   word_link *succ ;
   word_link *pred ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/dadadodo.h"
struct word_link {
   int count ;
   int word ;
};
#line 18 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parse.h"
struct pword;
#line 18 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parse.h"
typedef struct pword pword;
#line 16 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parsei.h"
struct pword_link;
#line 16 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parsei.h"
typedef struct pword_link pword_link;
#line 20 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parsei.h"
struct pword {
   int id ;
   unsigned char const   *string ;
   int count ;
   int start ;
   int cap ;
   int comma ;
   int period ;
   int quem ;
   int bang ;
   pword_link *succ ;
   pword_link *pred ;
   int succ_length ;
   int pred_length ;
   int succ_size ;
   int pred_size ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parsei.h"
struct pword_link {
   int count ;
   pword *word ;
};
#line 43
struct pword_pool;
#line 43 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parsei.h"
typedef struct pword_pool pword_pool;
#line 44
struct string_pool;
#line 44 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parsei.h"
typedef struct string_pool string_pool;
#line 52 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parsei.h"
struct pword_pool {
   pword pwords[(512000UL - sizeof(void *) * 4UL) / sizeof(pword )] ;
   int fp ;
   pword_pool *next ;
};
#line 58 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parsei.h"
struct string_pool {
   unsigned char chars[512000UL - sizeof(void *) * 4UL] ;
   int fp ;
   string_pool *next ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 16 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.h"
struct hash_table;
#line 16 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.h"
typedef struct hash_table hash_table;
#line 19 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
struct bucket;
#line 19 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
typedef struct bucket bucket;
#line 21 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
struct hash_table {
   unsigned long size ;
   unsigned long count ;
   long (*hash)(void const   * ) ;
   int (*compare)(void const   * , void const   * ) ;
   bucket *buckets ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
struct bucket {
   void const   *key ;
   void *value ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/dadadodo.c"
struct __anonstruct_entity_31 {
   char const   *string ;
   unsigned char latin1_char ;
   unsigned char length ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/dadadodo.c"
typedef struct __anonstruct_entity_31 entity;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/files.h"
int write_dadadodo_file(FILE *out , char const   *output_name ) ;
#line 18
int read_dadadodo_file(FILE *in ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parse.h"
int total_words ;
#line 23
int total_links ;
#line 24
int total_starters ;
#line 64 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parsei.h"
pword_pool *wpool ;
#line 65
string_pool *spool ;
#line 67
word *all_words ;
#line 68
unsigned char **all_strings ;
#line 69
int *starters ;
#line 35 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/files.c"
static unsigned char write_buf[10240]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/files.c"
static int write_fp  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/files.c"
static int write_flush(FILE *out ) 
{ 
  int status ;
  size_t tmp ;

  {
#line 43
  if (! write_fp) {
#line 43
    return (0);
  }
  {
#line 44
  tmp = fwrite((void const   */* __restrict  */)(write_buf), (size_t )1, (size_t )write_fp,
               (FILE */* __restrict  */)out);
#line 44
  status = (int )tmp;
#line 45
  write_fp = 0;
  }
#line 46
  return (status);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/files.c"
static int write_int32(FILE *out , int x ) 
{ 
  u_long lx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 52
  lx = (u_long )x;
#line 53
  tmp = write_fp;
#line 53
  write_fp ++;
#line 53
  write_buf[tmp] = (unsigned char )(lx >> 24);
#line 54
  tmp___0 = write_fp;
#line 54
  write_fp ++;
#line 54
  write_buf[tmp___0] = (unsigned char )((lx >> 16) & 255UL);
#line 55
  tmp___1 = write_fp;
#line 55
  write_fp ++;
#line 55
  write_buf[tmp___1] = (unsigned char )((lx >> 8) & 255UL);
#line 56
  tmp___2 = write_fp;
#line 56
  write_fp ++;
#line 56
  write_buf[tmp___2] = (unsigned char )(lx & 255UL);
#line 57
  if ((unsigned long )write_fp >= sizeof(write_buf) - 4UL) {
    {
#line 58
    tmp___3 = write_flush(out);
    }
#line 58
    return (tmp___3);
  }
#line 59
  return (0);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/files.c"
static int write_int16(FILE *out , int x ) 
{ 
  u_short sx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 66
  sx = (u_short )x;
#line 67
  tmp = write_fp;
#line 67
  write_fp ++;
#line 67
  write_buf[tmp] = (unsigned char )(((int )sx >> 8) & 255);
#line 68
  tmp___0 = write_fp;
#line 68
  write_fp ++;
#line 68
  write_buf[tmp___0] = (unsigned char )((int )sx & 255);
#line 69
  if ((unsigned long )write_fp >= sizeof(write_buf) - 4UL) {
    {
#line 70
    tmp___1 = write_flush(out);
    }
#line 70
    return (tmp___1);
  }
#line 71
  return (0);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/files.c"
static int write_int8(FILE *out , int x ) 
{ 
  u_short sx ;
  int tmp ;
  int tmp___0 ;

  {
#line 78
  sx = (u_short )x;
#line 79
  tmp = write_fp;
#line 79
  write_fp ++;
#line 79
  if ((int )sx & 255) {
#line 79
    write_buf[tmp] = (unsigned char )((int )sx & 255);
  } else {
#line 79
    write_buf[tmp] = (unsigned char )((int )sx >> 8);
  }
#line 80
  if ((unsigned long )write_fp >= sizeof(write_buf) - 4UL) {
    {
#line 81
    tmp___0 = write_flush(out);
    }
#line 81
    return (tmp___0);
  }
#line 82
  return (0);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/files.c"
int write_dadadodo_file(FILE *out , char const   *output_name ) 
{ 
  int status ;
  int i ;
  int (*write_fn)(FILE *out , int x ) ;
  string_pool *p ;
  string_pool **pools ;
  int npools ;
  int string_bytes ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  pword_pool *p___0 ;
  pword_pool **pools___0 ;
  int npools___0 ;
  void *tmp___2 ;
  int j ;
  int k ;
  pword *w ;
  int nstarters ;
  int j___0 ;
  pword *w___0 ;
  int j___1 ;
  pword *w___1 ;

  {
#line 91
  write_fn = & write_int32;
#line 93
  if (output_name) {
    {
#line 94
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"writing %s (%d words, %d pairs)\n",
            output_name, total_words, total_links / 2);
    }
  }
  {
#line 97
  fputs((char const   */* __restrict  */)"#!DadaDodo\n", (FILE */* __restrict  */)out);
#line 100
  status = write_int32(out, 1);
  }
#line 101
  if (status < 0) {
#line 101
    return (status);
  }
  {
#line 104
  status = write_int32(out, total_words);
  }
#line 105
  if (status < 0) {
#line 105
    return (status);
  }
  {
#line 108
  status = write_int32(out, total_links);
  }
#line 109
  if (status < 0) {
#line 109
    return (status);
  }
#line 114
  npools = 0;
#line 115
  string_bytes = 0;
#line 116
  p = spool;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! p) {
#line 116
      goto while_break;
    }
#line 118
    npools ++;
#line 120
    if ((unsigned long )p == (unsigned long )spool) {
#line 121
      string_bytes += p->fp;
    } else {
#line 123
      string_bytes = (int )((unsigned long )string_bytes + (512000UL - sizeof(void *) * 4UL));
    }
#line 116
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  tmp = malloc((unsigned long )npools * sizeof(*pools));
#line 126
  pools = (string_pool **)tmp;
  }
#line 127
  if (! pools) {
#line 127
    return (-1);
  }
#line 129
  i = npools - 1;
#line 130
  p = spool;
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 130
    if (! p) {
#line 130
      goto while_break___0;
    }
#line 131
    *(pools + i) = p;
#line 130
    p = p->next;
#line 130
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  status = write_int32(out, string_bytes);
  }
#line 135
  if (status < 0) {
#line 135
    return (status);
  }
  {
#line 138
  status = write_flush(out);
  }
#line 139
  if (status < 0) {
#line 139
    return (status);
  }
#line 150
  i = 0;
  {
#line 150
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 150
    if (! (i < npools)) {
#line 150
      goto while_break___1;
    }
#line 152
    p = *(pools + i);
#line 154
    if (i == npools - 1) {
      {
#line 155
      tmp___0 = fwrite((void const   */* __restrict  */)(p->chars), (size_t )1, (size_t )p->fp,
                       (FILE */* __restrict  */)out);
#line 155
      status = (int )tmp___0;
      }
    } else {
#line 158
      if ((unsigned long )p->fp < 512000UL - sizeof(void *) * 4UL) {
        {
#line 159
        memset((void *)(p->chars + p->fp), 0, (512000UL - sizeof(void *) * 4UL) - (unsigned long )p->fp);
        }
      }
      {
#line 160
      tmp___1 = fwrite((void const   */* __restrict  */)(p->chars), (size_t )1, 512000UL - sizeof(void *) * 4UL,
                       (FILE */* __restrict  */)out);
#line 160
      status = (int )tmp___1;
      }
    }
    {
#line 163
    free((void *)p);
    }
#line 164
    if (status < 0) {
#line 164
      return (status);
    }
#line 150
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 166
  free((void *)pools);
#line 173
  npools___0 = 0;
#line 174
  p___0 = wpool;
  }
  {
#line 174
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 174
    if (! p___0) {
#line 174
      goto while_break___2;
    }
#line 175
    npools___0 ++;
#line 174
    p___0 = p___0->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 176
  tmp___2 = malloc((unsigned long )npools___0 * sizeof(*pools___0));
#line 176
  pools___0 = (pword_pool **)tmp___2;
  }
#line 177
  if (! pools___0) {
#line 177
    return (-1);
  }
#line 179
  p___0 = wpool;
#line 179
  i = 0;
  {
#line 179
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 179
    if (! p___0) {
#line 179
      goto while_break___3;
    }
#line 180
    *(pools___0 + ((npools___0 - i) - 1)) = p___0;
#line 179
    p___0 = p___0->next;
#line 179
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 183
  if (total_words > 65535) {
#line 184
    write_fn = & write_int32;
  } else
#line 185
  if (total_words > 255) {
#line 186
    write_fn = & write_int16;
  } else {
#line 188
    write_fn = & write_int8;
  }
#line 190
  i = 0;
  {
#line 190
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 190
    if (! (i < npools___0)) {
#line 190
      goto while_break___4;
    }
#line 193
    p___0 = *(pools___0 + i);
#line 194
    j = 0;
    {
#line 194
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 194
      if (! (j < p___0->fp)) {
#line 194
        goto while_break___5;
      }
      {
#line 197
      w = & p___0->pwords[j];
#line 201
      status = (*write_fn)(out, w->count);
      }
#line 201
      if (status < 0) {
#line 201
        return (status);
      }
      {
#line 202
      status = (*write_fn)(out, w->start);
      }
#line 202
      if (status < 0) {
#line 202
        return (status);
      }
      {
#line 203
      status = (*write_fn)(out, w->cap);
      }
#line 203
      if (status < 0) {
#line 203
        return (status);
      }
      {
#line 204
      status = (*write_fn)(out, w->comma);
      }
#line 204
      if (status < 0) {
#line 204
        return (status);
      }
      {
#line 205
      status = (*write_fn)(out, w->period);
      }
#line 205
      if (status < 0) {
#line 205
        return (status);
      }
      {
#line 206
      status = (*write_fn)(out, w->quem);
      }
#line 206
      if (status < 0) {
#line 206
        return (status);
      }
      {
#line 207
      status = (*write_fn)(out, w->bang);
      }
#line 207
      if (status < 0) {
#line 207
        return (status);
      }
      {
#line 208
      status = (*write_fn)(out, w->succ_length);
      }
#line 208
      if (status < 0) {
#line 208
        return (status);
      }
      {
#line 209
      status = (*write_fn)(out, w->pred_length);
      }
#line 209
      if (status < 0) {
#line 209
        return (status);
      }
#line 210
      k = 0;
      {
#line 210
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 210
        if (! (k < w->succ_length)) {
#line 210
          goto while_break___6;
        }
        {
#line 212
        status = (*write_fn)(out, (w->succ + k)->count);
        }
#line 212
        if (status < 0) {
#line 212
          return (status);
        }
        {
#line 213
        status = (*write_fn)(out, ((w->succ + k)->word)->id);
        }
#line 213
        if (status < 0) {
#line 213
          return (status);
        }
#line 210
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 215
      k = 0;
      {
#line 215
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 215
        if (! (k < w->pred_length)) {
#line 215
          goto while_break___7;
        }
        {
#line 217
        status = (*write_fn)(out, (w->pred + k)->count);
        }
#line 217
        if (status < 0) {
#line 217
          return (status);
        }
        {
#line 218
        status = (*write_fn)(out, ((w->pred + k)->word)->id);
        }
#line 218
        if (status < 0) {
#line 218
          return (status);
        }
#line 215
        k ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 221
      if (w->succ) {
        {
#line 221
        free((void *)w->succ);
        }
      }
#line 222
      if (w->pred) {
        {
#line 222
        free((void *)w->pred);
        }
      }
#line 194
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 190
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 228
  nstarters = 0;
#line 229
  total_starters = 0;
#line 230
  i = 0;
  {
#line 230
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 230
    if (! (i < npools___0)) {
#line 230
      goto while_break___8;
    }
#line 233
    p___0 = *(pools___0 + i);
#line 234
    j___0 = 0;
    {
#line 234
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 234
      if (! (j___0 < p___0->fp)) {
#line 234
        goto while_break___9;
      }
#line 236
      w___0 = & p___0->pwords[j___0];
#line 237
      if (w___0->start) {
#line 239
        total_starters += w___0->start;
#line 240
        nstarters ++;
      }
#line 234
      j___0 ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 230
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 244
  status = write_int32(out, total_starters);
  }
#line 245
  if (status < 0) {
#line 245
    return (status);
  }
  {
#line 247
  status = write_int32(out, nstarters);
  }
#line 248
  if (status < 0) {
#line 248
    return (status);
  }
#line 251
  i = 0;
  {
#line 251
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 251
    if (! (i < npools___0)) {
#line 251
      goto while_break___10;
    }
#line 254
    p___0 = *(pools___0 + i);
#line 255
    j___1 = 0;
    {
#line 255
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 255
      if (! (j___1 < p___0->fp)) {
#line 255
        goto while_break___11;
      }
#line 257
      w___1 = & p___0->pwords[j___1];
#line 258
      if (w___1->start) {
        {
#line 259
        (*write_fn)(out, w___1->id);
        }
      }
#line 255
      j___1 ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 251
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 264
  i = 0;
  {
#line 264
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 264
    if (! (i < npools___0)) {
#line 264
      goto while_break___12;
    }
    {
#line 265
    free((void *)*(pools___0 + i));
#line 264
    i ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 266
  free((void *)pools___0);
#line 269
  status = write_flush(out);
  }
#line 270
  if (status < 0) {
#line 270
    return (status);
  }
  {
#line 271
  status = fflush(out);
  }
#line 272
  return (status);
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/files.c"
int read_dadadodo_file(FILE *in ) 
{ 
  int i ;
  unsigned char *s___0 ;
  unsigned char **as ;
  unsigned char **as2 ;
  word *aw ;
  word_link *al ;
  word_link *al_l ;
  long tw ;
  long tl ;
  long sb ;
  unsigned char **spools ;
  int nspools ;
  int nstarters ;
  int ts ;
  int *st ;
  int fv ;
  void *buf ;
  int buf_size ;
  int buf_elt_size ;
  u_short scratch_ushort ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  uint32_t tmp___3 ;
  size_t tmp___4 ;
  uint32_t tmp___5 ;
  size_t tmp___6 ;
  uint32_t tmp___7 ;
  size_t tmp___8 ;
  uint32_t tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  unsigned char *s___1 ;
  unsigned char *s2 ;
  int bytes_to_read ;
  unsigned long tmp___16 ;
  int this_time ;
  size_t tmp___17 ;
  unsigned char **tmp___18 ;
  size_t tmp___19 ;
  void *tmp___20 ;
  word *w ;
  int j ;
  size_t tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t tmp___29 ;
  uint32_t tmp___30 ;
  uint16_t tmp___31 ;
  uint16_t tmp___32 ;
  uint16_t tmp___33 ;
  uint16_t tmp___34 ;
  uint16_t tmp___35 ;
  uint16_t tmp___36 ;
  uint16_t tmp___37 ;
  uint16_t tmp___38 ;
  uint16_t tmp___39 ;
  int L ;
  int tmp___40 ;
  int s___2 ;
  void *b2 ;
  void *tmp___41 ;
  size_t tmp___42 ;
  uint32_t tmp___43 ;
  uint32_t tmp___44 ;
  uint16_t tmp___45 ;
  uint16_t tmp___46 ;
  size_t tmp___47 ;
  uint32_t tmp___48 ;
  uint32_t tmp___49 ;
  uint16_t tmp___50 ;
  uint16_t tmp___51 ;
  size_t tmp___52 ;
  uint32_t tmp___53 ;
  size_t tmp___54 ;
  uint32_t tmp___55 ;
  void *tmp___56 ;
  void *tmp___57 ;
  void *tmp___58 ;
  int bytes_to_read___0 ;
  char *b2___0 ;
  int bytes_read ;
  size_t tmp___59 ;
  uint32_t tmp___60 ;
  uint16_t tmp___61 ;

  {
  {
#line 282
  i = 0;
#line 283
  s___0 = (unsigned char *)0;
#line 284
  as = (unsigned char **)0;
#line 284
  as2 = (unsigned char **)0;
#line 285
  aw = (word *)0;
#line 286
  al = (word_link *)0;
#line 286
  al_l = (word_link *)0;
#line 287
  tw = 0L;
#line 287
  tl = 0L;
#line 287
  sb = 0L;
#line 288
  spools = (unsigned char **)0;
#line 289
  nspools = 0;
#line 290
  nstarters = 0;
#line 291
  ts = 0;
#line 292
  st = (int *)0;
#line 293
  fv = 0;
#line 295
  buf = (void *)0;
#line 296
  buf_size = 0;
#line 297
  buf_elt_size = 0;
#line 298
  scratch_ushort = (u_short )0;
#line 300
  tmp = fgets((char */* __restrict  */)(write_buf), 100, (FILE */* __restrict  */)in);
#line 300
  s___0 = (unsigned char *)tmp;
  }
#line 301
  if (! s___0) {
    {
#line 303
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not a DadaDodo Data file\n");
    }
#line 304
    goto FAIL;
  } else {
    {
#line 301
    tmp___0 = strlen("#!DadaDodo\n");
#line 301
    tmp___1 = strncmp((char const   *)s___0, "#!DadaDodo\n", tmp___0);
    }
#line 301
    if (tmp___1) {
      {
#line 303
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not a DadaDodo Data file\n");
      }
#line 304
      goto FAIL;
    }
  }
  {
#line 308
  tmp___2 = fread((void */* __restrict  */)((void *)(& fv)), (size_t )1, (size_t )4,
                  (FILE */* __restrict  */)in);
  }
#line 308
  if (4UL != tmp___2) {
#line 309
    goto FAIL;
  }
  {
#line 310
  tmp___3 = ntohl((uint32_t )fv);
#line 310
  fv = (int )((long )tmp___3);
  }
#line 311
  if (fv != 1) {
    {
#line 313
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"incompatible dadadodo file version: %d instead of %d\n",
            fv, 1);
    }
#line 316
    goto FAIL;
  }
  {
#line 319
  tmp___4 = fread((void */* __restrict  */)((void *)(& tw)), (size_t )1, (size_t )4,
                  (FILE */* __restrict  */)in);
  }
#line 319
  if (4UL != tmp___4) {
#line 320
    goto FAIL;
  }
  {
#line 321
  tmp___5 = ntohl((uint32_t )tw);
#line 321
  tw = (long )tmp___5;
  }
#line 322
  if (! tw) {
#line 322
    goto FAIL;
  }
  {
#line 324
  tmp___6 = fread((void */* __restrict  */)((void *)(& tl)), (size_t )1, (size_t )4,
                  (FILE */* __restrict  */)in);
  }
#line 324
  if (4UL != tmp___6) {
#line 325
    goto FAIL;
  }
  {
#line 326
  tmp___7 = ntohl((uint32_t )tl);
#line 326
  tl = (long )tmp___7;
  }
#line 327
  if (! tl) {
#line 327
    goto FAIL;
  }
  {
#line 329
  tmp___8 = fread((void */* __restrict  */)((void *)(& sb)), (size_t )1, (size_t )4,
                  (FILE */* __restrict  */)in);
  }
#line 329
  if (4UL != tmp___8) {
#line 330
    goto FAIL;
  }
  {
#line 331
  tmp___9 = ntohl((uint32_t )sb);
#line 331
  sb = (long )tmp___9;
  }
#line 332
  if (! sb) {
#line 332
    goto FAIL;
  }
  {
#line 335
  nspools = (int )((((unsigned long )sb + (512000UL - sizeof(void *) * 4UL)) - 1UL) / (512000UL - sizeof(void *) * 4UL));
#line 336
  tmp___10 = malloc((unsigned long )nspools * sizeof(*spools));
#line 336
  spools = (unsigned char **)tmp___10;
  }
#line 337
  if (! spools) {
#line 337
    goto FAIL;
  }
  {
#line 338
  memset((void *)spools, 0, (unsigned long )nspools * sizeof(*spools));
#line 339
  i = 0;
  }
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (! (i < nspools)) {
#line 339
      goto while_break;
    }
#line 341
    if (i == nspools - 1) {
      {
#line 342
      tmp___11 = malloc((unsigned long )sb % (512000UL - sizeof(void *) * 4UL));
#line 342
      *(spools + i) = (unsigned char *)tmp___11;
      }
    } else {
      {
#line 344
      tmp___12 = malloc(512000UL - sizeof(void *) * 4UL);
#line 344
      *(spools + i) = (unsigned char *)tmp___12;
      }
    }
#line 345
    if (! *(spools + i)) {
#line 346
      goto FAIL;
    }
#line 339
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 349
  tmp___13 = malloc((unsigned long )tw * sizeof(*as));
#line 349
  as = (unsigned char **)tmp___13;
  }
#line 350
  if (! as) {
#line 350
    goto FAIL;
  }
  {
#line 352
  tmp___14 = malloc((unsigned long )tw * sizeof(*aw));
#line 352
  aw = (word *)tmp___14;
  }
#line 353
  if (! aw) {
#line 353
    goto FAIL;
  }
  {
#line 355
  tmp___15 = malloc((unsigned long )tl * sizeof(*al));
#line 355
  al = (word_link *)tmp___15;
  }
#line 356
  if (! al) {
#line 356
    goto FAIL;
  }
#line 361
  as2 = as;
#line 362
  i = 0;
  {
#line 362
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 362
    if (! (i < nspools)) {
#line 362
      goto while_break___0;
    }
#line 365
    if (i == nspools - 1) {
#line 365
      tmp___16 = (unsigned long )sb % (512000UL - sizeof(void *) * 4UL);
    } else {
#line 365
      tmp___16 = 512000UL - sizeof(void *) * 4UL;
    }
    {
#line 365
    bytes_to_read = (int )tmp___16;
#line 368
    tmp___17 = fread((void */* __restrict  */)*(spools + i), (size_t )1, (size_t )bytes_to_read,
                     (FILE */* __restrict  */)in);
#line 368
    this_time = (int )tmp___17;
    }
#line 369
    if (this_time != bytes_to_read) {
      {
#line 371
      perror("read error");
      }
#line 372
      goto FAIL;
    }
#line 376
    s___1 = *(spools + i);
#line 377
    s2 = s___1 + bytes_to_read;
    {
#line 378
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 378
      if (! ((unsigned long )s___1 < (unsigned long )s2)) {
#line 378
        goto while_break___1;
      }
      {
#line 380
      tmp___18 = as2;
#line 380
      as2 ++;
#line 380
      *tmp___18 = s___1;
#line 381
      tmp___19 = strlen((char const   *)s___1);
#line 381
      s___1 += tmp___19 + 1UL;
      }
      {
#line 382
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 382
        if ((unsigned long )s___1 < (unsigned long )s2) {
#line 382
          if (! (! *s___1)) {
#line 382
            goto while_break___2;
          }
        } else {
#line 382
          goto while_break___2;
        }
#line 383
        s___1 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 362
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 388
  buf_size = 50;
#line 389
  tmp___20 = malloc((unsigned long )buf_size * sizeof(u_long ));
#line 389
  buf = tmp___20;
  }
#line 390
  if (! buf) {
#line 390
    goto FAIL;
  }
#line 394
  if (tw > 65535L) {
#line 395
    buf_elt_size = 4;
  } else
#line 396
  if (tw > 255L) {
#line 397
    buf_elt_size = 2;
  } else {
#line 399
    buf_elt_size = 1;
  }
#line 403
  al_l = al;
#line 404
  i = 0;
  {
#line 404
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 404
    if (! ((long )i < tw)) {
#line 404
      goto while_break___3;
    }
    {
#line 406
    w = aw + i;
#line 407
    tmp___21 = fread((void */* __restrict  */)buf, (size_t )buf_elt_size, (size_t )9,
                     (FILE */* __restrict  */)in);
#line 407
    j = (int )tmp___21;
    }
#line 408
    if (j != 9) {
      {
#line 410
      perror("short read");
      }
#line 411
      goto FAIL;
    }
#line 413
    w->string = i;
    {
#line 417
    if (buf_elt_size == 4) {
#line 417
      goto case_4;
    }
#line 428
    if (buf_elt_size == 2) {
#line 428
      goto case_2;
    }
#line 439
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 418
    tmp___22 = ntohl((uint32_t )*((u_long *)buf + 0));
#line 418
    w->count = (int )tmp___22;
#line 419
    tmp___23 = ntohl((uint32_t )*((u_long *)buf + 1));
#line 419
    w->start = (int )tmp___23;
#line 420
    tmp___24 = ntohl((uint32_t )*((u_long *)buf + 2));
#line 420
    w->cap = (int )tmp___24;
#line 421
    tmp___25 = ntohl((uint32_t )*((u_long *)buf + 3));
#line 421
    w->comma = (int )tmp___25;
#line 422
    tmp___26 = ntohl((uint32_t )*((u_long *)buf + 4));
#line 422
    w->period = (int )tmp___26;
#line 423
    tmp___27 = ntohl((uint32_t )*((u_long *)buf + 5));
#line 423
    w->quem = (int )tmp___27;
#line 424
    tmp___28 = ntohl((uint32_t )*((u_long *)buf + 6));
#line 424
    w->bang = (int )tmp___28;
#line 425
    tmp___29 = ntohl((uint32_t )*((u_long *)buf + 7));
#line 425
    w->succ_length = (int )tmp___29;
#line 426
    tmp___30 = ntohl((uint32_t )*((u_long *)buf + 8));
#line 426
    w->pred_length = (int )tmp___30;
    }
#line 427
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 429
    tmp___31 = ntohs(*((u_short *)buf + 0));
#line 429
    w->count = (int )tmp___31;
#line 430
    tmp___32 = ntohs(*((u_short *)buf + 1));
#line 430
    w->start = (int )tmp___32;
#line 431
    tmp___33 = ntohs(*((u_short *)buf + 2));
#line 431
    w->cap = (int )tmp___33;
#line 432
    tmp___34 = ntohs(*((u_short *)buf + 3));
#line 432
    w->comma = (int )tmp___34;
#line 433
    tmp___35 = ntohs(*((u_short *)buf + 4));
#line 433
    w->period = (int )tmp___35;
#line 434
    tmp___36 = ntohs(*((u_short *)buf + 5));
#line 434
    w->quem = (int )tmp___36;
#line 435
    tmp___37 = ntohs(*((u_short *)buf + 6));
#line 435
    w->bang = (int )tmp___37;
#line 436
    tmp___38 = ntohs(*((u_short *)buf + 7));
#line 436
    w->succ_length = (int )tmp___38;
#line 437
    tmp___39 = ntohs(*((u_short *)buf + 8));
#line 437
    w->pred_length = (int )tmp___39;
    }
#line 438
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 445
    scratch_ushort = ntohs((uint16_t )*((unsigned char *)buf + 0));
    }
#line 445
    if ((int )scratch_ushort & 255) {
#line 445
      w->count = (int )scratch_ushort & 255;
    } else {
#line 445
      w->count = (int )scratch_ushort >> 8;
    }
    {
#line 446
    scratch_ushort = ntohs((uint16_t )*((unsigned char *)buf + 1));
    }
#line 446
    if ((int )scratch_ushort & 255) {
#line 446
      w->start = (int )scratch_ushort & 255;
    } else {
#line 446
      w->start = (int )scratch_ushort >> 8;
    }
    {
#line 447
    scratch_ushort = ntohs((uint16_t )*((unsigned char *)buf + 2));
    }
#line 447
    if ((int )scratch_ushort & 255) {
#line 447
      w->cap = (int )scratch_ushort & 255;
    } else {
#line 447
      w->cap = (int )scratch_ushort >> 8;
    }
    {
#line 448
    scratch_ushort = ntohs((uint16_t )*((unsigned char *)buf + 3));
    }
#line 448
    if ((int )scratch_ushort & 255) {
#line 448
      w->comma = (int )scratch_ushort & 255;
    } else {
#line 448
      w->comma = (int )scratch_ushort >> 8;
    }
    {
#line 449
    scratch_ushort = ntohs((uint16_t )*((unsigned char *)buf + 4));
    }
#line 449
    if ((int )scratch_ushort & 255) {
#line 449
      w->period = (int )scratch_ushort & 255;
    } else {
#line 449
      w->period = (int )scratch_ushort >> 8;
    }
    {
#line 450
    scratch_ushort = ntohs((uint16_t )*((unsigned char *)buf + 5));
    }
#line 450
    if ((int )scratch_ushort & 255) {
#line 450
      w->quem = (int )scratch_ushort & 255;
    } else {
#line 450
      w->quem = (int )scratch_ushort >> 8;
    }
    {
#line 451
    scratch_ushort = ntohs((uint16_t )*((unsigned char *)buf + 6));
    }
#line 451
    if ((int )scratch_ushort & 255) {
#line 451
      w->bang = (int )scratch_ushort & 255;
    } else {
#line 451
      w->bang = (int )scratch_ushort >> 8;
    }
    {
#line 452
    scratch_ushort = ntohs((uint16_t )*((unsigned char *)buf + 7));
    }
#line 452
    if ((int )scratch_ushort & 255) {
#line 452
      w->succ_length = (int )scratch_ushort & 255;
    } else {
#line 452
      w->succ_length = (int )scratch_ushort >> 8;
    }
    {
#line 453
    scratch_ushort = ntohs((uint16_t )*((unsigned char *)buf + 8));
    }
#line 453
    if ((int )scratch_ushort & 255) {
#line 453
      w->pred_length = (int )scratch_ushort & 255;
    } else {
#line 453
      w->pred_length = (int )scratch_ushort >> 8;
    }
#line 454
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 460
    if (w->succ_length > w->pred_length) {
#line 460
      tmp___40 = w->succ_length;
    } else {
#line 460
      tmp___40 = w->pred_length;
    }
#line 460
    L = tmp___40;
#line 462
    if (buf_size < (buf_elt_size * L) * 2) {
      {
#line 464
      s___2 = ((buf_elt_size * L) * 2) * 2;
#line 465
      tmp___41 = realloc(buf, (size_t )s___2);
#line 465
      b2 = tmp___41;
      }
#line 466
      if (! b2) {
#line 466
        goto FAIL;
      }
#line 467
      buf_size = s___2;
#line 468
      buf = b2;
    }
#line 473
    if (! w->succ_length) {
#line 474
      w->succ = (word_link *)0;
    } else {
      {
#line 477
      tmp___42 = fread((void */* __restrict  */)buf, (size_t )buf_elt_size, (size_t )(w->succ_length * 2),
                       (FILE */* __restrict  */)in);
#line 477
      j = (int )tmp___42;
      }
#line 478
      if (j != w->succ_length * 2) {
        {
#line 480
        perror("short read");
        }
#line 481
        goto FAIL;
      }
#line 484
      w->succ = al_l;
#line 485
      j = 0;
      {
#line 485
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 485
        if (! (j < w->succ_length)) {
#line 485
          goto while_break___4;
        }
        {
#line 489
        if (buf_elt_size == 4) {
#line 489
          goto case_4___0;
        }
#line 493
        if (buf_elt_size == 2) {
#line 493
          goto case_2___0;
        }
#line 497
        goto switch_default___0;
        case_4___0: /* CIL Label */ 
        {
#line 490
        tmp___43 = ntohl((uint32_t )*((u_long *)buf + j * 2));
#line 490
        al_l->count = (int )tmp___43;
#line 491
        tmp___44 = ntohl((uint32_t )*((u_long *)buf + (j * 2 + 1)));
#line 491
        al_l->word = (int )tmp___44;
        }
#line 492
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
        {
#line 494
        tmp___45 = ntohs(*((u_short *)buf + j * 2));
#line 494
        al_l->count = (int )tmp___45;
#line 495
        tmp___46 = ntohs(*((u_short *)buf + (j * 2 + 1)));
#line 495
        al_l->word = (int )tmp___46;
        }
#line 496
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 498
        scratch_ushort = ntohs((uint16_t )*((unsigned char *)buf + j * 2));
        }
#line 498
        if ((int )scratch_ushort & 255) {
#line 498
          al_l->count = (int )scratch_ushort & 255;
        } else {
#line 498
          al_l->count = (int )scratch_ushort >> 8;
        }
        {
#line 499
        scratch_ushort = ntohs((uint16_t )*((unsigned char *)buf + (j * 2 + 1)));
        }
#line 499
        if ((int )scratch_ushort & 255) {
#line 499
          al_l->word = (int )scratch_ushort & 255;
        } else {
#line 499
          al_l->word = (int )scratch_ushort >> 8;
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 502
        al_l ++;
#line 485
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 506
    if (! w->pred_length) {
#line 507
      w->pred = (word_link *)0;
    } else {
      {
#line 510
      tmp___47 = fread((void */* __restrict  */)buf, (size_t )buf_elt_size, (size_t )(w->pred_length * 2),
                       (FILE */* __restrict  */)in);
#line 510
      j = (int )tmp___47;
      }
#line 511
      if (j != w->pred_length * 2) {
        {
#line 513
        perror("short read");
        }
#line 514
        goto FAIL;
      }
#line 517
      w->pred = al_l;
#line 518
      j = 0;
      {
#line 518
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 518
        if (! (j < w->pred_length)) {
#line 518
          goto while_break___5;
        }
        {
#line 522
        if (buf_elt_size == 4) {
#line 522
          goto case_4___1;
        }
#line 526
        if (buf_elt_size == 2) {
#line 526
          goto case_2___1;
        }
#line 530
        goto switch_default___1;
        case_4___1: /* CIL Label */ 
        {
#line 523
        tmp___48 = ntohl((uint32_t )*((u_long *)buf + j * 2));
#line 523
        al_l->count = (int )tmp___48;
#line 524
        tmp___49 = ntohl((uint32_t )*((u_long *)buf + (j * 2 + 1)));
#line 524
        al_l->word = (int )tmp___49;
        }
#line 525
        goto switch_break___1;
        case_2___1: /* CIL Label */ 
        {
#line 527
        tmp___50 = ntohs(*((u_short *)buf + j * 2));
#line 527
        al_l->count = (int )tmp___50;
#line 528
        tmp___51 = ntohs(*((u_short *)buf + (j * 2 + 1)));
#line 528
        al_l->word = (int )tmp___51;
        }
#line 529
        goto switch_break___1;
        switch_default___1: /* CIL Label */ 
        {
#line 531
        scratch_ushort = ntohs((uint16_t )*((unsigned char *)buf + j * 2));
        }
#line 531
        if ((int )scratch_ushort & 255) {
#line 531
          al_l->count = (int )scratch_ushort & 255;
        } else {
#line 531
          al_l->count = (int )scratch_ushort >> 8;
        }
        {
#line 532
        scratch_ushort = ntohs((uint16_t )*((unsigned char *)buf + (j * 2 + 1)));
        }
#line 532
        if ((int )scratch_ushort & 255) {
#line 532
          al_l->word = (int )scratch_ushort & 255;
        } else {
#line 532
          al_l->word = (int )scratch_ushort >> 8;
        }
        switch_break___1: /* CIL Label */ ;
        }
#line 535
        al_l ++;
#line 518
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 404
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 540
  if (buf) {
    {
#line 540
    free(buf);
    }
  }
  {
#line 541
  buf = (void *)0;
#line 542
  buf_size = 0;
#line 544
  tmp___52 = fread((void */* __restrict  */)((void *)(& ts)), (size_t )1, (size_t )4,
                   (FILE */* __restrict  */)in);
  }
#line 544
  if (4UL != tmp___52) {
#line 545
    goto FAIL;
  }
  {
#line 546
  tmp___53 = ntohl((uint32_t )ts);
#line 546
  ts = (int )((long )tmp___53);
#line 547
  tmp___54 = fread((void */* __restrict  */)((void *)(& nstarters)), (size_t )1, (size_t )4,
                   (FILE */* __restrict  */)in);
  }
#line 547
  if (4UL != tmp___54) {
#line 548
    goto FAIL;
  }
  {
#line 549
  tmp___55 = ntohl((uint32_t )nstarters);
#line 549
  nstarters = (int )((long )tmp___55);
#line 551
  tmp___56 = malloc((unsigned long )(nstarters + 1) * sizeof(u_long ));
#line 551
  st = (int *)tmp___56;
  }
#line 552
  if (! st) {
#line 552
    goto FAIL;
  }
  {
#line 556
  if (buf_elt_size == 4) {
#line 556
    goto case_4___2;
  }
#line 559
  if (buf_elt_size == 2) {
#line 559
    goto case_2___2;
  }
#line 564
  goto switch_default___2;
  case_4___2: /* CIL Label */ 
#line 557
  buf = (void *)st;
#line 558
  goto switch_break___2;
  case_2___2: /* CIL Label */ 
  {
#line 560
  buf_size = (nstarters + 1) * buf_elt_size;
#line 561
  tmp___57 = malloc((size_t )buf_size);
#line 561
  buf = tmp___57;
  }
#line 562
  if (! buf) {
#line 562
    goto FAIL;
  }
#line 563
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
  {
#line 565
  buf_elt_size = (int )sizeof(char );
#line 566
  buf_size = (nstarters + 1) * buf_elt_size;
#line 567
  tmp___58 = malloc((size_t )buf_size);
#line 567
  buf = tmp___58;
  }
#line 568
  if (! buf) {
#line 568
    goto FAIL;
  }
#line 569
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 573
  bytes_to_read___0 = nstarters * buf_elt_size;
#line 574
  b2___0 = (char *)((unsigned char *)buf);
  {
#line 575
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 576
    tmp___59 = fread((void */* __restrict  */)b2___0, (size_t )1, (size_t )bytes_to_read___0,
                     (FILE */* __restrict  */)in);
#line 576
    bytes_read = (int )tmp___59;
    }
#line 577
    if (bytes_read <= 0) {
#line 579
      if ((unsigned long )buf == (unsigned long )st) {
#line 580
        buf = (void *)0;
      }
#line 581
      goto FAIL;
    }
#line 583
    bytes_to_read___0 -= bytes_read;
#line 584
    b2___0 += bytes_read;
#line 575
    if (! (bytes_to_read___0 > 0)) {
#line 575
      goto while_break___6;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 588
  if ((unsigned long )buf == (unsigned long )st) {
#line 590
    i = 0;
    {
#line 590
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 590
      if (! (i < nstarters)) {
#line 590
        goto while_break___7;
      }
      {
#line 591
      tmp___60 = ntohl((uint32_t )*((u_long *)buf + i));
#line 591
      *(st + i) = (int )tmp___60;
#line 590
      i ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 592
    buf = (void *)0;
  } else
#line 594
  if ((unsigned long )buf_elt_size == sizeof(u_short )) {
#line 595
    i = 0;
    {
#line 595
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 595
      if (! (i < nstarters)) {
#line 595
        goto while_break___8;
      }
      {
#line 596
      tmp___61 = ntohs(*((u_short *)buf + i));
#line 596
      *(st + i) = (int )tmp___61;
#line 595
      i ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
  } else {
#line 598
    i = 0;
    {
#line 598
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 598
      if (! (i < nstarters)) {
#line 598
        goto while_break___9;
      }
      {
#line 599
      scratch_ushort = ntohs((uint16_t )*((unsigned char *)buf + i));
      }
#line 599
      if ((int )scratch_ushort & 255) {
#line 599
        *(st + i) = (int )scratch_ushort & 255;
      } else {
#line 599
        *(st + i) = (int )scratch_ushort >> 8;
      }
#line 598
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
#line 603
  if (buf) {
    {
#line 604
    free(buf);
    }
  }
#line 605
  total_words = (int )tw;
#line 606
  all_words = aw;
#line 607
  all_strings = as;
#line 608
  total_starters = ts;
#line 609
  starters = st;
#line 610
  return (0);
  FAIL: 
#line 613
  if (buf) {
    {
#line 613
    free(buf);
    }
  }
#line 614
  if (as) {
    {
#line 614
    free((void *)as);
    }
  }
#line 615
  if (aw) {
    {
#line 615
    free((void *)aw);
    }
  }
#line 616
  if (al) {
    {
#line 616
    free((void *)al);
    }
  }
#line 617
  if (st) {
    {
#line 617
    free((void *)st);
    }
  }
#line 618
  if (spools) {
#line 620
    i = 0;
    {
#line 620
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 620
      if (! (i < nspools)) {
#line 620
        goto while_break___10;
      }
#line 621
      if (*(spools + i)) {
        {
#line 621
        free((void *)*(spools + i));
        }
      }
#line 620
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 622
    free((void *)spools);
    }
  }
#line 624
  return (-1);
}
}
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/yarandom.h"
unsigned int ya_random(void) ;
#line 29
void ya_rand_init(unsigned int seed ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/yarandom.c"
static unsigned int a[55]  = 
#line 73 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/yarandom.c"
  {      3951096678U,      1141277249U,      2480103125U,      2707569682U, 
        299730482U,      4259445343U,      4196601416U,      1927830288U, 
        2552754534U,      2039360758U,      1739546395U,      2394763994U, 
        2645429346U,      578465010U,      1138168509U,      960347592U, 
        1218805097U,      331920724U,      136757403U,      1372238758U, 
        951837919U,      912608081U,      1641202836U,      3597483205U, 
        2609610878U,      342647964U,      1790781987U,      3083359110U, 
        126547608U,      735593562U,      1364860169U,      88240761U, 
        123161791U,      2168127358U,      2950153604U,      1047427037U, 
        1861311165U,      2109159457U,      890034277U,      2381957287U, 
        1711222699U,      387884763U,      3784965584U,      3233886172U, 
        1607866416U,      4041823072U,      984949279U,      2748545107U, 
        838981238U,      1096414934U,      1859160272U,      1946436445U, 
        1916111696U,      3644183052U,      2082959571U};
#line 87 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/yarandom.c"
static int i1  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/yarandom.c"
static int i2  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/yarandom.c"
unsigned int ya_random(void) 
{ 
  register int ret ;

  {
#line 92
  ret = (int )(a[i1] + a[i2]);
#line 93
  a[i1] = (unsigned int )ret;
#line 94
  i1 ++;
#line 94
  if (i1 >= 55) {
#line 94
    i1 = 0;
  }
#line 95
  i2 ++;
#line 95
  if (i2 >= 55) {
#line 95
    i2 = 0;
  }
#line 96
  return ((unsigned int )ret);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/yarandom.c"
void ya_rand_init(unsigned int seed ) 
{ 
  int i ;
  struct timeval tp ;
  struct timezone tzp ;
  __pid_t tmp ;

  {
#line 103
  if (seed == 0U) {
    {
#line 108
    gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )(& tzp));
#line 113
    tmp = getpid();
#line 113
    seed = (unsigned int )((999L * tp.tv_sec + 1001L * tp.tv_usec) + (__time_t )(1003 * tmp));
    }
  }
#line 116
  a[0] += seed;
#line 117
  i = 1;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 55)) {
#line 117
      goto while_break;
    }
#line 119
    seed = a[i - 1] * 1001U + seed * 999U;
#line 120
    a[i] += seed;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  i1 = (int )(a[0] % 55U);
#line 124
  i2 = (i1 + 20) % 55;
#line 125
  return;
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.h"
hash_table *make_hash_table(long size , long (*hash)(void const   * ) , int (*compare)(void const   * ,
                                                                                       void const   * ) ) ;
#line 22
void free_hash_table(hash_table *table ) ;
#line 24
int puthash(hash_table *table , void const   *key , void *value ) ;
#line 25
void *gethash(hash_table *table , void const   *key , void *def ) ;
#line 26
void clrhash(hash_table *table ) ;
#line 27
int maphash(hash_table *table , int (*mapper)(void const   *key , void const   *value ,
                                              void *arg ) , void *arg ) ;
#line 31
unsigned long string_hash(unsigned char const   *x ) ;
#line 32
unsigned long string_case_hash(unsigned char const   *x ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
static unsigned long const   primes[56]  = 
#line 34 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
  {      (unsigned long const   )107,      (unsigned long const   )131,      (unsigned long const   )163,      (unsigned long const   )197, 
        (unsigned long const   )239,      (unsigned long const   )293,      (unsigned long const   )353,      (unsigned long const   )431, 
        (unsigned long const   )521,      (unsigned long const   )631,      (unsigned long const   )761,      (unsigned long const   )919, 
        (unsigned long const   )1103,      (unsigned long const   )1327,      (unsigned long const   )1597,      (unsigned long const   )1931, 
        (unsigned long const   )2333,      (unsigned long const   )2801,      (unsigned long const   )3371,      (unsigned long const   )4049, 
        (unsigned long const   )4861,      (unsigned long const   )5839,      (unsigned long const   )7013,      (unsigned long const   )8419, 
        (unsigned long const   )10103,      (unsigned long const   )12143,      (unsigned long const   )14591,      (unsigned long const   )17519, 
        (unsigned long const   )21023,      (unsigned long const   )25229,      (unsigned long const   )30293,      (unsigned long const   )36353, 
        (unsigned long const   )43627,      (unsigned long const   )52361,      (unsigned long const   )62851,      (unsigned long const   )75431, 
        (unsigned long const   )90523,      (unsigned long const   )108631,      (unsigned long const   )130363,      (unsigned long const   )156437, 
        (unsigned long const   )187751,      (unsigned long const   )225307,      (unsigned long const   )270371,      (unsigned long const   )324449, 
        (unsigned long const   )389357,      (unsigned long const   )467237,      (unsigned long const   )560689,      (unsigned long const   )672827, 
        (unsigned long const   )807403,      (unsigned long const   )968897,      (unsigned long const   )1162687,      (unsigned long const   )1395263, 
        (unsigned long const   )1674319,      (unsigned long const   )2009191,      (unsigned long const   )2411033,      (unsigned long const   )2893249};
#line 46
static unsigned long toprime(unsigned long size ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
static unsigned int s  =    (unsigned int )(sizeof(primes) / sizeof(primes[0]) - 1UL);
#line 42 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
static unsigned long toprime(unsigned long size ) 
{ 
  unsigned int i ;

  {
#line 47
  i = 0U;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < s)) {
#line 47
      goto while_break;
    }
#line 48
    if (size <= (unsigned long )primes[i]) {
#line 49
      return ((unsigned long )primes[i]);
    }
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((unsigned long )primes[s - 1U]);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
hash_table *make_hash_table(long size , long (*hash)(void const   * ) , int (*compare)(void const   * ,
                                                                                       void const   * ) ) 
{ 
  hash_table *t ;
  void *tmp ;
  unsigned long tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 59
  tmp = malloc(sizeof(*t));
#line 59
  t = (hash_table *)tmp;
  }
#line 60
  if (! t) {
#line 60
    return ((hash_table *)0);
  }
  {
#line 61
  tmp___0 = toprime((unsigned long )((13L * size) / 10L));
#line 61
  size = (long )tmp___0;
#line 62
  t->hash = hash;
#line 63
  t->compare = compare;
#line 64
  t->size = (unsigned long )size;
#line 65
  t->count = 0UL;
#line 66
  tmp___1 = calloc(t->size, sizeof(*(t->buckets)));
#line 66
  t->buckets = (bucket *)tmp___1;
  }
#line 67
  if (! t->buckets) {
    {
#line 69
    free((void *)t);
    }
#line 70
    return ((hash_table *)0);
  }
#line 72
  return (t);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
void clrhash(hash_table *table ) 
{ 


  {
  {
#line 78
  table->count = 0UL;
#line 79
  memset((void *)table->buckets, 0, table->size * sizeof(*(table->buckets)));
  }
#line 80
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
void free_hash_table(hash_table *table ) 
{ 


  {
  {
#line 85
  free((void *)table->buckets);
#line 86
  free((void *)table);
  }
#line 87
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
static int growhash(hash_table *table , unsigned long new_size ) 
{ 
  unsigned long i ;
  unsigned long old_size ;
  bucket *old_buckets ;
  bucket *new_buckets ;
  void *tmp ;

  {
  {
#line 94
  old_size = table->size;
#line 95
  old_buckets = table->buckets;
#line 98
  new_size = toprime(new_size);
#line 99
  tmp = calloc(new_size, sizeof(*(table->buckets)));
#line 99
  new_buckets = (bucket *)tmp;
  }
#line 101
  if (! new_buckets) {
#line 102
    return (-1);
  }
#line 104
  table->size = new_size;
#line 105
  table->buckets = new_buckets;
#line 106
  table->count = 0UL;
#line 108
  i = 0UL;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (i < old_size)) {
#line 108
      goto while_break;
    }
#line 109
    if ((old_buckets + i)->key) {
      {
#line 110
      puthash(table, (old_buckets + i)->key, (old_buckets + i)->value);
      }
    }
#line 108
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  free((void *)old_buckets);
  }
#line 113
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
int puthash(hash_table *table , void const   *key , void *value ) 
{ 
  unsigned long hash ;
  long tmp ;
  unsigned long size ;
  unsigned long n ;
  bucket *b ;
  int status ;
  unsigned long h2 ;
  unsigned long i ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 119
  tmp = (*(table->hash))(key);
#line 119
  hash = (unsigned long )tmp;
#line 120
  size = table->size;
  }
#line 124
  if (size < 1UL + (13UL * table->count) / 10UL) {
    {
#line 128
    status = growhash(table, size + 1UL);
    }
#line 129
    if (status < 0) {
#line 129
      return (status);
    }
#line 130
    size = table->size;
  }
#line 133
  n = hash % size;
#line 134
  b = table->buckets + n;
#line 136
  if (b->key) {
#line 136
    if ((unsigned long )key != (unsigned long )b->key) {
      {
#line 136
      tmp___1 = (*(table->compare))(key, b->key);
      }
#line 136
      if (tmp___1 != 0) {
#line 140
        h2 = size - 2UL;
#line 141
        i = hash % h2 + 1UL;
        {
#line 142
        while (1) {
          while_continue: /* CIL Label */ ;
#line 144
          n += i;
#line 145
          if (n >= size) {
#line 145
            n -= size;
          }
#line 146
          b = table->buckets + n;
#line 142
          if (b->key) {
#line 142
            if ((unsigned long )key != (unsigned long )b->key) {
              {
#line 142
              tmp___0 = (*(table->compare))(key, b->key);
              }
#line 142
              if (! (tmp___0 != 0)) {
#line 142
                goto while_break;
              }
            } else {
#line 142
              goto while_break;
            }
          } else {
#line 142
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 153
  if (! b->key) {
#line 154
    (table->count) ++;
  }
#line 156
  b->key = key;
#line 157
  b->value = value;
#line 158
  return (0);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
void *gethash(hash_table *table , void const   *key , void *def ) 
{ 
  unsigned long hash ;
  long tmp ;
  unsigned long size ;
  unsigned long n ;
  bucket *b ;
  unsigned long h2 ;
  unsigned long i ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 165
  tmp = (*(table->hash))(key);
#line 165
  hash = (unsigned long )tmp;
#line 166
  size = table->size;
#line 167
  n = hash % size;
#line 168
  b = table->buckets + n;
  }
#line 170
  if (b->key) {
#line 170
    if ((unsigned long )key != (unsigned long )b->key) {
      {
#line 170
      tmp___1 = (*(table->compare))(key, b->key);
      }
#line 170
      if (tmp___1 != 0) {
#line 174
        h2 = size - 2UL;
#line 175
        i = hash % h2 + 1UL;
        {
#line 176
        while (1) {
          while_continue: /* CIL Label */ ;
#line 178
          n += i;
#line 179
          if (n >= size) {
#line 179
            n -= size;
          }
#line 180
          b = table->buckets + n;
#line 176
          if (b->key) {
#line 176
            if ((unsigned long )key != (unsigned long )b->key) {
              {
#line 176
              tmp___0 = (*(table->compare))(key, b->key);
              }
#line 176
              if (! (tmp___0 != 0)) {
#line 176
                goto while_break;
              }
            } else {
#line 176
              goto while_break;
            }
          } else {
#line 176
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 187
  return (b->value);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
int maphash(hash_table *table , int (*mapper)(void const   *key , void const   *value ,
                                              void *arg ) , void *arg ) 
{ 
  unsigned long i ;
  int status ;

  {
#line 198
  if (table) {
#line 199
    i = 0UL;
    {
#line 199
    while (1) {
      while_continue: /* CIL Label */ ;
#line 199
      if (! (i < table->size)) {
#line 199
        goto while_break;
      }
#line 200
      if ((table->buckets + i)->key) {
        {
#line 202
        status = (*mapper)((table->buckets + i)->key, (void const   *)(table->buckets + i)->value,
                           arg);
        }
#line 203
        if (status != 0) {
#line 203
          return (status);
        }
      }
#line 199
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 205
  return (0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
unsigned long string_hash(unsigned char const   *x ) 
{ 
  unsigned long g ;
  unsigned long h ;
  unsigned char const   *tmp ;

  {
#line 212
  h = 0UL;
#line 213
  if (! x) {
#line 213
    return (0UL);
  }
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((int const   )*x != 0)) {
#line 214
      goto while_break;
    }
#line 216
    tmp = x;
#line 216
    x ++;
#line 216
    h = (h << 4) + (unsigned long )*tmp;
#line 217
    g = h & 4026531840UL;
#line 217
    if (g != 0UL) {
#line 218
      h = (h ^ (g >> 24)) ^ g;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (h);
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/hash.c"
unsigned long string_case_hash(unsigned char const   *x ) 
{ 
  unsigned long g ;
  unsigned long h ;
  unsigned char const   *tmp ;
  int tmp___0 ;

  {
#line 226
  h = 0UL;
#line 227
  if (! x) {
#line 227
    return (0UL);
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! ((int const   )*x != 0)) {
#line 228
      goto while_break;
    }
    {
#line 230
    tmp = x;
#line 230
    x ++;
#line 230
    tmp___0 = toupper((int )*tmp);
#line 230
    h = (h << 4) + (unsigned long )tmp___0;
#line 231
    g = h & 4026531840UL;
    }
#line 231
    if (g != 0UL) {
#line 232
      h = (h ^ (g >> 24)) ^ g;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return (h);
}
}
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/generate.h"
int random_sentence(FILE *stream , int *column , int indent , int fill_column , int html_p ) ;
#line 20
void word_stats(FILE *stream , word *word___0 ) ;
#line 21
void string_stats(FILE *stream , unsigned char const   *s___0 , int print_header ) ;
#line 23
void stats(FILE *stream ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/generate.c"
word *all_words  =    (word *)0;
#line 27 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/generate.c"
unsigned char **all_strings  =    (unsigned char **)0;
#line 29 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/generate.c"
int total_starters  =    0;
#line 30 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/generate.c"
int *starters  =    (int *)0;
#line 33 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/generate.c"
static word *random_first_word(void) 
{ 
  word *w ;
  int *s___0 ;
  int i ;
  unsigned int tmp ;

  {
  {
#line 36
  w = (word *)0;
#line 37
  s___0 = starters;
#line 38
  tmp = ya_random();
#line 38
  i = (int )((tmp & 2147483647U) % (unsigned int )total_starters);
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    w = all_words + *s___0;
#line 41
    i -= w->start;
#line 42
    s___0 ++;
#line 39
    if (! (i > 0)) {
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  return (w);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/generate.c"
static word *random_linked(word_link *links , int link_length ) 
{ 
  int i ;
  int count ;
  unsigned int tmp ;

  {
#line 52
  count = 0;
#line 55
  i = 0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (i < link_length)) {
#line 55
      goto while_break;
    }
#line 56
    count += (links + i)->count;
#line 55
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 57
  tmp = ya_random();
#line 57
  count = (int )((tmp & 2147483647U) % (unsigned int )count);
#line 58
  i = 0;
  }
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 58
    if (! (i < link_length)) {
#line 58
      goto while_break___0;
    }
#line 60
    count -= (links + i)->count;
#line 61
    if (count <= 0) {
#line 62
      return (all_words + (links + i)->word);
    }
#line 58
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 64
  abort();
  }
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/generate.c"
static word *random_next_word(word *w ) 
{ 
  word *w2 ;
  word *tmp ;
  word *tmp___0 ;
  unsigned int tmp___1 ;
  word *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 70
  if (w->pred_length) {
    {
#line 70
    tmp___1 = ya_random();
    }
#line 70
    if (! ((tmp___1 & 2147483647U) % 10U)) {
      {
#line 73
      tmp = random_linked(w->pred, w->pred_length);
#line 73
      tmp___0 = random_next_word(tmp);
#line 73
      w2 = tmp___0;
      }
#line 74
      if ((unsigned long )w != (unsigned long )w2) {
#line 75
        return (w2);
      }
    }
  }
#line 78
  if (w->succ_length) {
    {
#line 79
    tmp___2 = random_linked(w->succ, w->succ_length);
    }
#line 79
    return (tmp___2);
  } else {
    {
#line 80
    tmp___4 = ya_random();
    }
#line 80
    if (tmp___4 % 4U) {
      {
#line 81
      tmp___3 = ya_random();
      }
#line 81
      return (all_words + (tmp___3 & 2147483647U) % (unsigned int )total_words);
    } else {
#line 83
      return ((word *)0);
    }
  }
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/generate.c"
int random_sentence(FILE *stream , int *column , int indent , int fill_column , int html_p ) 
{ 
  int count ;
  unsigned char buf[10240] ;
  word *word___0 ;
  word *tmp ;
  int first_p ;
  int paren_open_p ;
  int open_paren_p ;
  unsigned char indent_str[255] ;
  int open_paren_next_p ;
  int close_paren_p ;
  int punctuate_chance ;
  int always_cap_p ;
  int cap_p ;
  int tmp___0 ;
  unsigned char const   *c1 ;
  unsigned char *c2 ;
  int new_col ;
  unsigned char const   *punc ;
  int premature_end_slop ;
  unsigned int tmp___1 ;
  int delta ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char const   *tmp___12 ;
  int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char const   *tmp___16 ;
  int tmp___17 ;
  unsigned int tmp___18 ;

  {
  {
#line 91
  count = 0;
#line 93
  tmp = random_first_word();
#line 93
  word___0 = tmp;
#line 94
  first_p = 1;
#line 95
  paren_open_p = 0;
#line 96
  open_paren_p = 0;
#line 99
  count = 0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (count < indent)) {
#line 99
      goto while_break;
    }
#line 100
    indent_str[count] = (unsigned char )' ';
#line 99
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  indent_str[count] = (unsigned char)0;
#line 102
  count = 0;
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 104
    if (! (*column < indent)) {
#line 104
      goto while_break___0;
    }
    {
#line 106
    fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)stream);
#line 107
    (*column) ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 110
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 110
    if (! word___0) {
#line 110
      goto while_break___1;
    }
#line 112
    open_paren_next_p = 0;
#line 113
    close_paren_p = 0;
#line 115
    always_cap_p = word___0->count - word___0->start <= word___0->cap;
#line 116
    if (first_p) {
#line 116
      tmp___0 = 1;
    } else
#line 116
    if (always_cap_p) {
#line 116
      tmp___0 = 1;
    } else {
#line 116
      tmp___0 = 0;
    }
#line 116
    cap_p = tmp___0;
#line 117
    c1 = (unsigned char const   *)*(all_strings + word___0->string);
#line 118
    c2 = buf;
#line 120
    punc = (unsigned char const   *)0;
#line 121
    premature_end_slop = 0;
#line 124
    if (count > 400) {
      {
#line 126
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\nYow!\n%s",
              indent_str);
#line 128
      *column = indent;
      }
#line 129
      return (count);
    }
#line 132
    count ++;
#line 134
    if (word___0->count == 0) {
#line 135
      goto while_continue___1;
    }
    {
#line 137
    tmp___1 = ya_random();
#line 137
    punctuate_chance = (int )((tmp___1 & 2147483647U) % (unsigned int )word___0->count);
    }
#line 141
    if (count % 10 == 0) {
#line 143
      delta = word___0->count / 6;
#line 144
      if (delta == 0) {
#line 144
        tmp___2 = 1;
      } else {
#line 144
        tmp___2 = delta;
      }
#line 144
      premature_end_slop += tmp___2;
    }
#line 147
    if (punctuate_chance < word___0->comma) {
#line 149
      if (paren_open_p) {
#line 151
        punc = (unsigned char const   *)0;
#line 152
        close_paren_p = 0;
      } else {
        {
#line 154
        tmp___3 = ya_random();
        }
#line 154
        if ((tmp___3 & 2147483647U) % 20U) {
#line 155
          punc = (unsigned char const   *)",";
        } else {
#line 157
          open_paren_next_p = 1;
        }
      }
    } else {
#line 161
      punctuate_chance -= word___0->comma;
#line 162
      if (word___0->period) {
#line 162
        if (punctuate_chance < word___0->period + premature_end_slop) {
          {
#line 172
          tmp___5 = ya_random();
          }
#line 172
          if ((tmp___5 & 2147483647U) % 5U == 0U) {
#line 173
            punc = (unsigned char const   *)":";
          } else {
            {
#line 174
            tmp___4 = ya_random();
            }
#line 174
            if ((tmp___4 & 2147483647U) % 4U == 0U) {
#line 175
              punc = (unsigned char const   *)";";
            } else {
#line 178
              close_paren_p = 1;
#line 179
              punc = (unsigned char const   *)". ";
            }
          }
        } else {
#line 162
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 184
        punctuate_chance -= word___0->period;
#line 185
        if (punctuate_chance < word___0->quem) {
#line 186
          punc = (unsigned char const   *)"? ";
        } else {
#line 189
          punctuate_chance -= word___0->quem;
#line 190
          if (punctuate_chance < word___0->bang) {
#line 191
            punc = (unsigned char const   *)"! ";
          } else {
#line 193
            punc = (unsigned char const   *)0;
          }
        }
#line 195
        if (punc) {
#line 196
          close_paren_p = 1;
        }
      }
    }
    {
#line 200
    tmp___6 = strlen((char const   *)c1);
    }
#line 200
    if (punc) {
      {
#line 200
      tmp___7 = strlen((char const   *)punc);
#line 200
      tmp___8 = tmp___7;
      }
    } else {
#line 200
      tmp___8 = (size_t )0;
    }
#line 200
    new_col = (int )(((size_t )*column + tmp___6) + tmp___8);
#line 201
    if (open_paren_p) {
#line 202
      new_col ++;
    } else
#line 201
    if (close_paren_p) {
#line 202
      new_col ++;
    }
#line 212
    first_p = 0;
#line 214
    if (*column <= indent) {
#line 215
      *column = new_col;
    } else
#line 216
    if (new_col < fill_column) {
      {
#line 218
      fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)stream);
#line 219
      *column = new_col + 1;
      }
    } else {
      {
#line 223
      fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stream);
#line 224
      fputs((char const   */* __restrict  */)(indent_str), (FILE */* __restrict  */)stream);
#line 225
      tmp___9 = strlen((char const   *)c1);
#line 225
      *column = (int )(((size_t )indent + tmp___9) + 1UL);
      }
    }
#line 229
    if (open_paren_p) {
#line 231
      tmp___10 = c2;
#line 231
      c2 ++;
#line 231
      *tmp___10 = (unsigned char )'(';
#line 232
      open_paren_p = 0;
#line 233
      open_paren_next_p = 0;
#line 234
      paren_open_p = 1;
    }
#line 243
    if (cap_p) {
#line 243
      goto _L___0;
    } else
#line 243
    if (word___0->count > word___0->start) {
      {
#line 243
      tmp___14 = ya_random();
      }
#line 243
      if ((tmp___14 & 2147483647U) % (unsigned int )(word___0->count - word___0->start) < (unsigned int )word___0->cap) {
        _L___0: /* CIL Label */ 
        {
#line 246
        tmp___11 = c2;
#line 246
        c2 ++;
#line 246
        tmp___12 = c1;
#line 246
        c1 ++;
#line 246
        tmp___13 = toupper((int )*tmp___12);
#line 246
        *tmp___11 = (unsigned char )tmp___13;
        }
      }
    }
#line 248
    if (always_cap_p) {
      {
#line 249
      strcpy((char */* __restrict  */)c2, (char const   */* __restrict  */)c1);
      }
    } else {
      {
#line 252
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 252
        if (! *c1) {
#line 252
          goto while_break___2;
        }
        {
#line 253
        tmp___15 = c2;
#line 253
        c2 ++;
#line 253
        tmp___16 = c1;
#line 253
        c1 ++;
#line 253
        tmp___17 = tolower((int )*tmp___16);
#line 253
        *tmp___15 = (unsigned char )tmp___17;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 254
      *c2 = (unsigned char)0;
    }
    {
#line 257
    fputs((char const   */* __restrict  */)(buf), (FILE */* __restrict  */)stream);
    }
#line 259
    if (punc) {
#line 259
      if ((int const   )*punc == 46) {
#line 260
        word___0 = (word *)0;
      } else
#line 259
      if ((int const   )*punc == 33) {
#line 260
        word___0 = (word *)0;
      } else
#line 259
      if ((int const   )*punc == 63) {
#line 260
        word___0 = (word *)0;
      } else {
#line 259
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 263
      word___0 = random_next_word(word___0);
      }
#line 265
      if (! word___0) {
        {
#line 267
        tmp___18 = ya_random();
        }
        {
#line 269
        if ((tmp___18 & 2147483647U) % 5U == 0U) {
#line 269
          goto case_0;
        }
#line 270
        if ((tmp___18 & 2147483647U) % 5U == 1U) {
#line 270
          goto case_1;
        }
#line 271
        goto switch_default;
        case_0: /* CIL Label */ 
#line 269
        punc = (unsigned char const   *)"! ";
#line 269
        goto switch_break;
        case_1: /* CIL Label */ 
#line 270
        punc = (unsigned char const   *)"? ";
#line 270
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 271
        punc = (unsigned char const   *)". ";
#line 271
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 273
        *column += 2;
#line 274
        close_paren_p = 1;
      }
    }
#line 278
    if (paren_open_p) {
#line 278
      if (close_paren_p) {
        {
#line 280
        fputs((char const   */* __restrict  */)")", (FILE */* __restrict  */)stream);
#line 281
        paren_open_p = 0;
#line 282
        close_paren_p = 0;
#line 283
        open_paren_next_p = 0;
        }
      }
    }
#line 286
    if (punc) {
      {
#line 287
      fputs((char const   */* __restrict  */)punc, (FILE */* __restrict  */)stream);
      }
    }
#line 289
    if (open_paren_next_p) {
#line 290
      open_paren_p = 1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 293
  if (paren_open_p) {
    {
#line 293
    abort();
    }
  }
#line 294
  return (count);
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/generate.c"
void word_stats(FILE *stream , word *word___0 ) 
{ 
  int i ;

  {
  {
#line 301
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%-16s %5d %5d %5d %5d %5d %5d %5d\n",
          *(all_strings + word___0->string), word___0->count, word___0->start, word___0->cap,
          word___0->comma, word___0->period, word___0->quem, word___0->bang);
  }
#line 304
  if (word___0->succ_length) {
    {
#line 305
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"  -->\n");
    }
  }
#line 306
  i = 0;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! (i < word___0->succ_length)) {
#line 306
      goto while_break;
    }
    {
#line 307
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"    %5d %s\n",
            (word___0->succ + i)->count, *(all_strings + (all_words + (word___0->succ + i)->word)->string));
#line 306
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  if (word___0->pred_length) {
    {
#line 311
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"  <--\n");
    }
  }
#line 312
  i = 0;
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    if (! (i < word___0->pred_length)) {
#line 312
      goto while_break___0;
    }
    {
#line 313
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"    %5d %s\n",
            (word___0->pred + i)->count, *(all_strings + (all_words + (word___0->pred + i)->word)->string));
#line 312
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 316
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/generate.c"
void stats(FILE *stream ) 
{ 
  int i ;

  {
  {
#line 325
  fputs((char const   */* __restrict  */)"\nWORD               COUNT START  CAP  COMMA  END  QUEM  BANG\n\n",
        (FILE */* __restrict  */)stream);
#line 326
  i = 0;
  }
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! (i < total_words)) {
#line 326
      goto while_break;
    }
    {
#line 327
    word_stats(stream, all_words + i);
#line 326
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stream);
  }
#line 329
  return;
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/generate.c"
void string_stats(FILE *stream , unsigned char const   *s___0 , int print_header ) 
{ 
  int i ;
  int tmp ;

  {
#line 335
  if (print_header) {
    {
#line 336
    fputs((char const   */* __restrict  */)"\nWORD               COUNT START  CAP  COMMA  END  QUEM  BANG\n\n",
          (FILE */* __restrict  */)stream);
    }
  }
#line 337
  i = 0;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (i < total_words)) {
#line 337
      goto while_break;
    }
    {
#line 338
    tmp = strcasecmp((char const   *)s___0, (char const   *)*(all_strings + (all_words + i)->string));
    }
#line 338
    if (! tmp) {
      {
#line 339
      word_stats(stream, all_words + i);
      }
    }
#line 337
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parse.h"
pword *scan_line(unsigned char *line , hash_table *table , pword *prev ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parse.c"
int total_words  =    0;
#line 25 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parse.c"
int total_links  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parse.c"
pword_pool *wpool  =    (pword_pool *)0;
#line 29 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parse.c"
string_pool *spool  =    (string_pool *)0;
#line 32 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parse.c"
static unsigned char const   *new_string(unsigned char const   *s___0 ) 
{ 
  int L ;
  size_t tmp ;
  string_pool *p ;
  void *tmp___0 ;

  {
  {
#line 35
  tmp = strlen((char const   *)s___0);
#line 35
  L = (int )tmp;
  }
#line 36
  if (! spool) {
#line 36
    goto _L;
  } else
#line 36
  if ((unsigned long )((spool->fp + L) + 2) >= 512000UL - sizeof(void *) * 4UL) {
    _L: /* CIL Label */ 
    {
#line 38
    tmp___0 = malloc(sizeof(*p));
#line 38
    p = (string_pool *)tmp___0;
    }
#line 39
    if (! p) {
#line 39
      return ((unsigned char const   *)0);
    }
#line 40
    p->fp = 0;
#line 41
    p->next = spool;
#line 42
    spool = p;
  }
  {
#line 44
  memcpy((void */* __restrict  */)(spool->chars + spool->fp), (void const   */* __restrict  */)s___0,
         (size_t )(L + 1));
#line 45
  s___0 = (unsigned char const   *)(spool->chars + spool->fp);
#line 46
  spool->fp += L + 1;
  }
#line 47
  return (s___0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parse.c"
static pword *new_pword(unsigned char const   *string ) 
{ 
  pword *pw ;
  pword_pool *p ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 55
  string = new_string(string);
  }
#line 56
  if (! string) {
#line 56
    return ((pword *)0);
  }
#line 57
  if (! wpool) {
#line 57
    goto _L;
  } else
#line 57
  if ((unsigned long )(wpool->fp + 1) >= (512000UL - sizeof(void *) * 4UL) / sizeof(pword )) {
    _L: /* CIL Label */ 
    {
#line 59
    tmp = calloc((size_t )1, sizeof(*p));
#line 59
    p = (pword_pool *)tmp;
    }
#line 60
    if (! p) {
#line 60
      return ((pword *)0);
    }
#line 61
    p->fp = 0;
#line 62
    p->next = wpool;
#line 63
    wpool = p;
  }
#line 66
  tmp___0 = wpool->fp;
#line 66
  (wpool->fp) ++;
#line 66
  pw = & wpool->pwords[tmp___0];
#line 67
  tmp___1 = total_words;
#line 67
  total_words ++;
#line 67
  pw->id = tmp___1;
#line 68
  pw->string = string;
#line 69
  return (pw);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parse.c"
static int increment(pword *pword___0 , pword_link **listP , int *lengthP , int *sizeP ) 
{ 
  int size ;
  int length ;
  pword_link *list ;
  int bot ;
  int top ;
  int mid ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 76
  size = *sizeP;
#line 77
  length = *lengthP;
#line 78
  list = *listP;
#line 80
  bot = 0;
#line 81
  top = length;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (top > bot)) {
#line 86
      goto while_break;
    }
#line 88
    mid = ((top - bot) >> 1) + bot;
#line 89
    if ((unsigned long )pword___0 == (unsigned long )(list + mid)->word) {
#line 91
      ((list + mid)->count) ++;
#line 92
      return (0);
    } else
#line 94
    if ((unsigned long )pword___0 < (unsigned long )(list + mid)->word) {
#line 95
      top = mid;
    } else
#line 96
    if (bot == mid) {
#line 97
      goto while_break;
    } else {
#line 99
      bot = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  if (size == 0) {
    {
#line 108
    size = 10;
#line 109
    tmp = calloc((size_t )size, sizeof(*list));
#line 109
    list = (pword_link *)tmp;
    }
#line 110
    if (! list) {
#line 110
      return (0);
    }
#line 111
    *listP = list;
#line 112
    *sizeP = size;
  } else
#line 114
  if (length + 1 >= size) {
    {
#line 116
    size = ((*sizeP + 10) * 13) / 10;
#line 117
    tmp___0 = realloc((void *)list, (unsigned long )size * sizeof(*list));
#line 117
    list = (pword_link *)tmp___0;
    }
#line 118
    if (! list) {
#line 118
      return (0);
    }
    {
#line 119
    memset((void *)(list + length), 0, (unsigned long )(size - length) * sizeof(*list));
#line 120
    *listP = list;
#line 121
    *sizeP = size;
    }
  }
#line 124
  if (top != length) {
    {
#line 126
    memmove((void *)((list + top) + 1), (void const   *)(list + top), (unsigned long )(length - top) * sizeof(*list));
    }
  }
#line 128
  total_links ++;
#line 129
  (*lengthP) ++;
#line 130
  (list + top)->word = pword___0;
#line 131
  (list + top)->count = 1;
#line 133
  return (0);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parse.c"
static int follow(pword *prev , pword *next ) 
{ 
  int s___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 140
  tmp = increment(next, & prev->succ, & prev->succ_length, & prev->succ_size);
#line 140
  s___0 = tmp;
  }
#line 141
  if (s___0 < 0) {
#line 141
    return (s___0);
  }
  {
#line 142
  tmp___0 = increment(prev, & next->pred, & next->pred_length, & next->pred_size);
  }
#line 142
  return (tmp___0);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parse.c"
static pword *intern(unsigned char const   *string , hash_table *table ) 
{ 
  pword *pw ;
  void *tmp ;
  int status ;

  {
  {
#line 149
  tmp = gethash(table, (void const   *)((void *)string), (void *)0);
#line 149
  pw = (pword *)tmp;
  }
#line 150
  if (! pw) {
    {
#line 153
    pw = new_pword(string);
    }
#line 154
    if (! pw) {
#line 154
      return ((pword *)0);
    }
    {
#line 155
    status = puthash(table, (void const   *)((void *)pw->string), (void *)pw);
    }
#line 156
    if (status < 0) {
#line 159
      return ((pword *)0);
    }
  }
#line 162
  return (pw);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parse.c"
static pword *push(unsigned char const   *string , char punc , hash_table *table ,
                   pword *prev ) 
{ 
  pword *pword___0 ;
  pword *tmp ;
  int terminal ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 170
  tmp = intern(string, table);
#line 170
  pword___0 = tmp;
#line 171
  terminal = 0;
  }
#line 172
  if (! pword___0) {
#line 172
    return ((pword *)0);
  }
#line 174
  (pword___0->count) ++;
#line 176
  if (! prev) {
#line 177
    (pword___0->start) ++;
  } else {
    {
#line 178
    tmp___0 = __ctype_b_loc();
    }
#line 178
    if ((int const   )*(*tmp___0 + (int )*string) & 256) {
#line 179
      (pword___0->cap) ++;
    }
  }
  {
#line 183
  if ((int )punc == 44) {
#line 183
    goto case_44;
  }
#line 184
  if ((int )punc == 46) {
#line 184
    goto case_46;
  }
#line 185
  if ((int )punc == 58) {
#line 185
    goto case_58;
  }
#line 186
  if ((int )punc == 59) {
#line 186
    goto case_59;
  }
#line 187
  if ((int )punc == 63) {
#line 187
    goto case_63;
  }
#line 188
  if ((int )punc == 33) {
#line 188
    goto case_33;
  }
#line 189
  if ((int )punc == 40) {
#line 189
    goto case_40;
  }
#line 190
  if ((int )punc == 41) {
#line 190
    goto case_41;
  }
#line 181
  goto switch_break;
  case_44: /* CIL Label */ 
#line 183
  (pword___0->comma) ++;
#line 183
  goto switch_break;
  case_46: /* CIL Label */ 
#line 184
  (pword___0->period) ++;
#line 184
  terminal = 1;
#line 184
  goto switch_break;
  case_58: /* CIL Label */ 
#line 185
  (pword___0->period) ++;
#line 185
  terminal = 1;
#line 185
  goto switch_break;
  case_59: /* CIL Label */ 
#line 186
  (pword___0->period) ++;
#line 186
  goto switch_break;
  case_63: /* CIL Label */ 
#line 187
  (pword___0->quem) ++;
#line 187
  terminal = 1;
#line 187
  goto switch_break;
  case_33: /* CIL Label */ 
#line 188
  (pword___0->bang) ++;
#line 188
  terminal = 1;
#line 188
  goto switch_break;
  case_40: /* CIL Label */ 
#line 189
  (pword___0->comma) ++;
#line 189
  goto switch_break;
  case_41: /* CIL Label */ 
#line 190
  (pword___0->comma) ++;
#line 190
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 193
  if (prev) {
    {
#line 193
    follow(prev, pword___0);
    }
  }
#line 194
  if (terminal) {
#line 194
    return ((pword *)0);
  }
#line 195
  return (pword___0);
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/parse.c"
pword *scan_line(unsigned char *line , hash_table *table , pword *prev ) 
{ 
  unsigned char *s___0 ;
  int had_dot ;
  int had_digit ;
  unsigned char *start ;
  unsigned char *end ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned char punc ;

  {
#line 205
  s___0 = line;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! *s___0) {
#line 206
      goto while_break;
    }
#line 208
    had_dot = 0;
#line 209
    had_digit = 0;
    {
#line 212
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 212
      if (*s___0) {
        {
#line 212
        tmp = __ctype_b_loc();
        }
#line 212
        if ((int const   )*(*tmp + (int )*s___0) & 8) {
#line 212
          goto while_break___0;
        } else
#line 212
        if ((int )*s___0 == 47) {
#line 212
          goto while_break___0;
        } else
#line 212
        if ((int )*s___0 == 92) {
#line 212
          goto while_break___0;
        }
      } else {
#line 212
        goto while_break___0;
      }
#line 213
      s___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 214
    start = s___0;
#line 217
    if ((int )*start == 47) {
#line 217
      goto _L;
    } else
#line 217
    if ((int )*start == 92) {
#line 217
      goto _L;
    } else
#line 217
    if ((int )*start == 104) {
      {
#line 217
      tmp___1 = strncmp((char const   *)start, "http://", (size_t )7);
      }
#line 217
      if (tmp___1) {
#line 217
        goto _L___2;
      } else {
#line 217
        goto _L;
      }
    } else
    _L___2: /* CIL Label */ 
#line 217
    if ((int )*start == 109) {
      {
#line 217
      tmp___2 = strncmp((char const   *)start, "mailto:", (size_t )7);
      }
#line 217
      if (tmp___2) {
#line 217
        goto _L___1;
      } else {
#line 217
        goto _L;
      }
    } else
    _L___1: /* CIL Label */ 
#line 217
    if ((int )*start == 102) {
      {
#line 217
      tmp___3 = strncmp((char const   *)start, "ftp://", (size_t )6);
      }
#line 217
      if (tmp___3) {
#line 217
        goto _L___0;
      } else {
#line 217
        goto _L;
      }
    } else
    _L___0: /* CIL Label */ 
#line 217
    if ((int )*start == 103) {
      {
#line 217
      tmp___4 = strncmp((char const   *)start, "file://", (size_t )7);
      }
#line 217
      if (! tmp___4) {
        _L: /* CIL Label */ 
        {
#line 224
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 224
          if (*s___0) {
            {
#line 224
            tmp___0 = __ctype_b_loc();
            }
#line 224
            if ((int const   )*(*tmp___0 + (int )*s___0) & 8192) {
#line 224
              goto while_break___1;
            }
          } else {
#line 224
            goto while_break___1;
          }
#line 225
          s___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 226
        start = s___0;
#line 227
        if (*s___0) {
#line 227
          goto while_break;
        }
      }
    }
    AGAIN: 
    {
#line 232
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 232
      if (*s___0) {
        {
#line 232
        tmp___6 = __ctype_b_loc();
        }
#line 232
        if (! ((int const   )*(*tmp___6 + (int )*s___0) & 8)) {
#line 232
          if (! ((int )*s___0 == 39)) {
#line 232
            goto while_break___2;
          }
        }
      } else {
#line 232
        goto while_break___2;
      }
      {
#line 234
      tmp___5 = __ctype_b_loc();
      }
#line 234
      if ((int const   )*(*tmp___5 + (int )*s___0) & 2048) {
#line 234
        had_digit = 1;
      }
#line 235
      s___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 237
    end = s___0;
#line 239
    if ((int )*s___0 == 46) {
#line 239
      goto _L___3;
    } else
#line 239
    if ((int )*s___0 == 64) {
      _L___3: /* CIL Label */ 
      {
#line 239
      tmp___7 = __ctype_b_loc();
      }
#line 239
      if ((int const   )*(*tmp___7 + (int )*(s___0 + 1)) & 8) {
#line 241
        s___0 ++;
#line 242
        had_dot = 1;
#line 243
        goto AGAIN;
      }
    }
#line 246
    if (had_dot) {
#line 248
      goto while_continue;
    }
#line 250
    if (had_digit) {
#line 251
      goto while_continue;
    }
    {
#line 253
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 253
      if ((unsigned long )s___0 > (unsigned long )start) {
        {
#line 253
        tmp___8 = __ctype_b_loc();
        }
#line 253
        if (! ((int const   )*(*tmp___8 + (int )*(s___0 + -1)) & 4)) {
#line 253
          goto while_break___3;
        }
      } else {
#line 253
        goto while_break___3;
      }
#line 254
      s___0 --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 256
    if ((unsigned long )s___0 > (unsigned long )(start + 30)) {
#line 257
      goto while_continue;
    }
#line 259
    if ((unsigned long )s___0 != (unsigned long )start) {
      {
#line 261
      punc = *s___0;
#line 262
      *s___0 = (unsigned char)0;
#line 263
      prev = push((unsigned char const   *)start, (char )punc, table, prev);
#line 264
      *s___0 = punc;
      }
    }
#line 266
    s___0 = end;
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  return (prev);
}
}
#line 1 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/version.h"
static char const   version[75]  = 
#line 1 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/version.h"
  {      (char const   )'@',      (char const   )'(',      (char const   )'#',      (char const   )')', 
        (char const   )'D',      (char const   )'a',      (char const   )'d',      (char const   )'a', 
        (char const   )'D',      (char const   )'o',      (char const   )'d',      (char const   )'o', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'0', 
        (char const   )'4',      (char const   )',',      (char const   )' ',      (char const   )'C', 
        (char const   )'o',      (char const   )'p',      (char const   )'y',      (char const   )'r', 
        (char const   )'i',      (char const   )'g',      (char const   )'h',      (char const   )'t', 
        (char const   )' ',      (char const   )'(',      (char const   )'c',      (char const   )')', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'7',      (char const   )'-',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'3',      (char const   )' ',      (char const   )'b', 
        (char const   )'y',      (char const   )' ',      (char const   )'J',      (char const   )'a', 
        (char const   )'m',      (char const   )'i',      (char const   )'e',      (char const   )' ', 
        (char const   )'Z',      (char const   )'a',      (char const   )'w',      (char const   )'i', 
        (char const   )'n',      (char const   )'s',      (char const   )'k',      (char const   )'i', 
        (char const   )' ',      (char const   )'(',      (char const   )'j',      (char const   )'w', 
        (char const   )'z',      (char const   )'@',      (char const   )'j',      (char const   )'w', 
        (char const   )'z',      (char const   )'.',      (char const   )'o',      (char const   )'r', 
        (char const   )'g',      (char const   )')',      (char const   )'\000'};
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/dadadodo.c"
static entity entities[106]  = 
#line 36 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/dadadodo.c"
  {      {"lt", (unsigned char )'<', (unsigned char)2}, 
        {"LT", (unsigned char )'<', (unsigned char)2}, 
        {"gt", (unsigned char )'>', (unsigned char)2}, 
        {"GT", (unsigned char )'>', (unsigned char)2}, 
        {"amp", (unsigned char )'&', (unsigned char)3}, 
        {"AMP", (unsigned char )'&', (unsigned char)3}, 
        {"quot", (unsigned char )'\"', (unsigned char)4}, 
        {"QUOT", (unsigned char )'\"', (unsigned char)4}, 
        {"nbsp", (unsigned char )' ', (unsigned char)4}, 
        {"reg", (unsigned char )'\256', (unsigned char)3}, 
        {"REG", (unsigned char )'\256', (unsigned char)3}, 
        {"copy", (unsigned char )'\251', (unsigned char)4}, 
        {"COPY", (unsigned char )'\251', (unsigned char)4}, 
        {"iexcl", (unsigned char )'\241', (unsigned char)5}, 
        {"cent", (unsigned char )'\242', (unsigned char)4}, 
        {"pound", (unsigned char )'\243', (unsigned char)5}, 
        {"curren", (unsigned char )'\244', (unsigned char)6}, 
        {"yen", (unsigned char )'\245', (unsigned char)3}, 
        {"brvbar", (unsigned char )'\246', (unsigned char)6}, 
        {"sect", (unsigned char )'\247', (unsigned char)4}, 
        {"uml", (unsigned char )'\250', (unsigned char)3}, 
        {"ordf", (unsigned char )'\252', (unsigned char)4}, 
        {"laquo", (unsigned char )'\253', (unsigned char)5}, 
        {"not", (unsigned char )'\254', (unsigned char)3}, 
        {"shy", (unsigned char )'\255', (unsigned char)3}, 
        {"macr", (unsigned char )'\257', (unsigned char)4}, 
        {"deg", (unsigned char )'\260', (unsigned char)3}, 
        {"plusmn", (unsigned char )'\261', (unsigned char)6}, 
        {"sup2", (unsigned char )'\262', (unsigned char)4}, 
        {"sup3", (unsigned char )'\263', (unsigned char)4}, 
        {"acute", (unsigned char )'\264', (unsigned char)5}, 
        {"micro", (unsigned char )'\265', (unsigned char)5}, 
        {"para", (unsigned char )'\266', (unsigned char)4}, 
        {"middot", (unsigned char )'\267', (unsigned char)6}, 
        {"cedil", (unsigned char )'\270', (unsigned char)5}, 
        {"sup1", (unsigned char )'\271', (unsigned char)4}, 
        {"ordm", (unsigned char )'\272', (unsigned char)4}, 
        {"raquo", (unsigned char )'\273', (unsigned char)5}, 
        {"frac14", (unsigned char )'\274', (unsigned char)6}, 
        {"frac12", (unsigned char )'\275', (unsigned char)6}, 
        {"frac34", (unsigned char )'\276', (unsigned char)6}, 
        {"iquest", (unsigned char )'\277', (unsigned char)6}, 
        {"Agrave", (unsigned char )'\300', (unsigned char)6}, 
        {"Aacute", (unsigned char )'\301', (unsigned char)6}, 
        {"Acirc", (unsigned char )'\302', (unsigned char)5}, 
        {"Atilde", (unsigned char )'\303', (unsigned char)6}, 
        {"Auml", (unsigned char )'\304', (unsigned char)4}, 
        {"Aring", (unsigned char )'\305', (unsigned char)5}, 
        {"AElig", (unsigned char )'\306', (unsigned char)5}, 
        {"Ccedil", (unsigned char )'\307', (unsigned char)6}, 
        {"Egrave", (unsigned char )'\310', (unsigned char)6}, 
        {"Eacute", (unsigned char )'\311', (unsigned char)6}, 
        {"Ecirc", (unsigned char )'\312', (unsigned char)5}, 
        {"Euml", (unsigned char )'\313', (unsigned char)4}, 
        {"Igrave", (unsigned char )'\314', (unsigned char)6}, 
        {"Iacute", (unsigned char )'\315', (unsigned char)6}, 
        {"Icirc", (unsigned char )'\316', (unsigned char)5}, 
        {"Iuml", (unsigned char )'\317', (unsigned char)4}, 
        {"ETH", (unsigned char )'\320', (unsigned char)3}, 
        {"Ntilde", (unsigned char )'\321', (unsigned char)6}, 
        {"Ograve", (unsigned char )'\322', (unsigned char)6}, 
        {"Oacute", (unsigned char )'\323', (unsigned char)6}, 
        {"Ocirc", (unsigned char )'\324', (unsigned char)5}, 
        {"Otilde", (unsigned char )'\325', (unsigned char)6}, 
        {"Ouml", (unsigned char )'\326', (unsigned char)4}, 
        {"times", (unsigned char )'\327', (unsigned char)5}, 
        {"Oslash", (unsigned char )'\330', (unsigned char)6}, 
        {"Ugrave", (unsigned char )'\331', (unsigned char)6}, 
        {"Uacute", (unsigned char )'\332', (unsigned char)6}, 
        {"Ucirc", (unsigned char )'\333', (unsigned char)5}, 
        {"Uuml", (unsigned char )'\334', (unsigned char)4}, 
        {"Yacute", (unsigned char )'\335', (unsigned char)6}, 
        {"THORN", (unsigned char )'\336', (unsigned char)5}, 
        {"szlig", (unsigned char )'\337', (unsigned char)5}, 
        {"agrave", (unsigned char )'\340', (unsigned char)6}, 
        {"aacute", (unsigned char )'\341', (unsigned char)6}, 
        {"acirc", (unsigned char )'\342', (unsigned char)5}, 
        {"atilde", (unsigned char )'\343', (unsigned char)6}, 
        {"auml", (unsigned char )'\344', (unsigned char)4}, 
        {"aring", (unsigned char )'\345', (unsigned char)5}, 
        {"aelig", (unsigned char )'\346', (unsigned char)5}, 
        {"ccedil", (unsigned char )'\347', (unsigned char)6}, 
        {"egrave", (unsigned char )'\350', (unsigned char)6}, 
        {"eacute", (unsigned char )'\351', (unsigned char)6}, 
        {"ecirc", (unsigned char )'\352', (unsigned char)5}, 
        {"euml", (unsigned char )'\353', (unsigned char)4}, 
        {"igrave", (unsigned char )'\354', (unsigned char)6}, 
        {"iacute", (unsigned char )'\355', (unsigned char)6}, 
        {"icirc", (unsigned char )'\356', (unsigned char)5}, 
        {"iuml", (unsigned char )'\357', (unsigned char)4}, 
        {"eth", (unsigned char )'\360', (unsigned char)3}, 
        {"ntilde", (unsigned char )'\361', (unsigned char)6}, 
        {"ograve", (unsigned char )'\362', (unsigned char)6}, 
        {"oacute", (unsigned char )'\363', (unsigned char)6}, 
        {"ocirc", (unsigned char )'\364', (unsigned char)5}, 
        {"otilde", (unsigned char )'\365', (unsigned char)6}, 
        {"ouml", (unsigned char )'\366', (unsigned char)4}, 
        {"divide", (unsigned char )'\367', (unsigned char)6}, 
        {"oslash", (unsigned char )'\370', (unsigned char)6}, 
        {"ugrave", (unsigned char )'\371', (unsigned char)6}, 
        {"uacute", (unsigned char )'\372', (unsigned char)6}, 
        {"ucirc", (unsigned char )'\373', (unsigned char)5}, 
        {"uuml", (unsigned char )'\374', (unsigned char)4}, 
        {"yacute", (unsigned char )'\375', (unsigned char)6}, 
        {"thorn", (unsigned char )'\376', (unsigned char)5}, 
        {"yuml", (unsigned char )'\377', (unsigned char)4}};
#line 157 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/dadadodo.c"
static char get_entity(unsigned char const   *string , int length ) 
{ 
  int i ;
  unsigned char c ;
  int tmp ;

  {
#line 161
  c = (unsigned char )*string;
#line 162
  i = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! ((unsigned long )i < sizeof(entities) / sizeof(entities[0]))) {
#line 162
      goto while_break;
    }
#line 163
    if (length == (int )entities[i].length) {
#line 163
      if ((int )c == (int )*(entities[i].string + 0)) {
        {
#line 163
        tmp = strncmp((char const   *)string, entities[i].string, (size_t )length);
        }
#line 163
        if (! tmp) {
#line 166
          return ((char )entities[i].latin1_char);
        }
      }
    }
#line 162
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return ((char)0);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/dadadodo.c"
static int scan(FILE *file , hash_table *table , char *first_line ) 
{ 
  pword *prev ;
  int line_tick ;
  int line_count ;
  unsigned char buf[10240] ;
  unsigned char *s___0 ;
  int L ;
  int mailbox_p ;
  int in_headers ;
  int in_binhex_p ;
  int contains_msg ;
  int inside_html_tag ;
  int in_comment_p ;
  int in_sig_p ;
  unsigned char *qp_wrap_hack ;
  unsigned char *qp_free_wrap_hack ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  unsigned char *s2 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int got_some ;
  unsigned char *s2___0 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;
  unsigned char const   *w1 ;
  unsigned char const   *w2 ;
  int got_it ;
  unsigned char *s2___1 ;
  int i ;
  unsigned char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  unsigned char const   *s2___2 ;
  unsigned short const   **tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int uue_p ;
  unsigned char const   *s2___3 ;
  int b64_p ;
  unsigned char const   *s2___4 ;
  int tmp___30 ;
  char *tmp___31 ;
  unsigned char *s2___5 ;
  unsigned char *s3 ;
  unsigned char const   *s4 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  unsigned char *tmp___36 ;
  unsigned char const   *tmp___37 ;
  unsigned short const   **tmp___38 ;
  unsigned short const   **tmp___39 ;
  char *tmp___40 ;
  unsigned char *s3___0 ;
  unsigned short const   **tmp___41 ;
  char *tmp___42 ;
  size_t tmp___43 ;
  unsigned short const   **tmp___44 ;
  unsigned char const   *last ;
  unsigned char *s2___6 ;
  unsigned char const   *s3___1 ;
  int close_p ;
  unsigned short const   **tmp___45 ;
  unsigned char *out ;
  unsigned char *tmp___46 ;
  unsigned char *tmp___47 ;
  unsigned char const   *tmp___48 ;
  unsigned char *out___0 ;
  unsigned char *tmp___49 ;
  unsigned char *tmp___50 ;
  unsigned char const   *tmp___51 ;
  unsigned short const   **tmp___52 ;
  char *tmp___53 ;
  unsigned char const   *last___0 ;
  unsigned char *s2___7 ;
  unsigned char *s3___2 ;
  unsigned short const   **tmp___54 ;
  unsigned char e ;
  char tmp___55 ;
  unsigned char *tmp___56 ;
  unsigned char *tmp___57 ;
  unsigned char *tmp___58 ;
  unsigned short const   **tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;

  {
#line 183
  prev = (pword *)0;
#line 184
  line_tick = 0;
#line 185
  line_count = 0;
#line 189
  mailbox_p = 0;
#line 190
  in_headers = 0;
#line 191
  in_binhex_p = 0;
#line 192
  contains_msg = 0;
#line 193
  inside_html_tag = 0;
#line 194
  in_comment_p = 0;
#line 195
  in_sig_p = 0;
#line 197
  qp_wrap_hack = (unsigned char *)0;
#line 198
  qp_free_wrap_hack = (unsigned char *)0;
#line 200
  if (first_line) {
#line 201
    s___0 = (unsigned char *)first_line;
  } else {
    {
#line 204
    tmp = fgets((char */* __restrict  */)(buf), (int )(sizeof(buf) - 1UL), (FILE */* __restrict  */)file);
#line 204
    s___0 = (unsigned char *)tmp;
    }
#line 205
    if (! s___0) {
#line 205
      return (-1);
    }
  }
#line 208
  if ((int )*s___0 == 70) {
    {
#line 208
    tmp___0 = strncmp((char const   *)s___0, "From ", (size_t )5);
    }
#line 208
    if (tmp___0) {
#line 208
      tmp___1 = 0;
    } else {
#line 208
      tmp___1 = 1;
    }
  } else {
#line 208
    tmp___1 = 0;
  }
#line 208
  mailbox_p = tmp___1;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (qp_free_wrap_hack) {
      {
#line 214
      free((void *)qp_free_wrap_hack);
#line 215
      qp_free_wrap_hack = (unsigned char *)0;
      }
    }
#line 217
    if (qp_wrap_hack) {
      {
#line 219
      tmp___2 = strlen((char const   *)s___0);
#line 219
      tmp___3 = strlen((char const   *)qp_wrap_hack);
#line 219
      tmp___4 = malloc((tmp___2 + tmp___3) + 1UL);
#line 219
      qp_free_wrap_hack = (unsigned char *)tmp___4;
      }
#line 221
      if (! qp_free_wrap_hack) {
#line 221
        return (-1);
      }
      {
#line 222
      strcpy((char */* __restrict  */)qp_free_wrap_hack, (char const   */* __restrict  */)qp_wrap_hack);
#line 223
      strcat((char */* __restrict  */)qp_free_wrap_hack, (char const   */* __restrict  */)s___0);
#line 224
      free((void *)qp_wrap_hack);
#line 225
      qp_wrap_hack = (unsigned char *)0;
#line 226
      s___0 = qp_free_wrap_hack;
      }
    }
    {
#line 229
    tmp___5 = strlen((char const   *)s___0);
#line 229
    L = (int )tmp___5;
    }
#line 230
    if (L > 0) {
#line 230
      if ((int )*(s___0 + (L - 1)) == 13) {
#line 230
        L --;
      } else
#line 230
      if ((int )*(s___0 + (L - 1)) == 10) {
#line 230
        L --;
      }
    }
#line 231
    if (L > 0) {
#line 231
      if ((int )*(s___0 + (L - 1)) == 13) {
#line 231
        L --;
      } else
#line 231
      if ((int )*(s___0 + (L - 1)) == 10) {
#line 231
        L --;
      }
    }
#line 233
    line_count ++;
#line 234
    line_tick ++;
#line 234
    if (line_tick == 200) {
      {
#line 236
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
      }
#line 237
      if (line_count % (65 * line_tick) == 0) {
        {
#line 238
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d lines\n",
                line_count);
        }
      }
#line 239
      line_tick = 0;
    }
#line 246
    if (in_binhex_p) {
#line 248
      if (L != 0) {
#line 248
        if (L != 64) {
#line 249
          in_binhex_p = 0;
        }
      }
#line 250
      goto __Cont;
    }
#line 254
    if (inside_html_tag) {
      {
#line 259
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 259
        if (*s___0) {
#line 259
          if (! ((int )*s___0 != 62)) {
#line 259
            goto while_break___0;
          }
        } else {
#line 259
          goto while_break___0;
        }
#line 260
        s___0 ++;
#line 260
        L --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 261
      if (*s___0) {
#line 263
        s___0 ++;
#line 264
        L --;
#line 265
        inside_html_tag = 0;
      }
    } else
#line 268
    if (in_comment_p) {
      {
#line 273
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 273
        if (*s___0) {
#line 273
          if (! ((int )*(s___0 + 0) != 45)) {
#line 273
            if (! ((int )*(s___0 + 1) != 45)) {
#line 273
              if (! ((int )*(s___0 + 2) != 62)) {
#line 273
                goto while_break___1;
              }
            }
          }
        } else {
#line 273
          goto while_break___1;
        }
#line 274
        s___0 ++;
#line 274
        L --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 275
      if (*s___0) {
#line 277
        s___0 += 3;
#line 278
        L -= 3;
#line 279
        in_comment_p = 0;
      }
    } else
#line 282
    if (in_sig_p) {
#line 284
      if (in_sig_p > 20) {
#line 285
        in_sig_p = 0;
      } else
#line 286
      if ((int )*s___0 == 70) {
        {
#line 286
        tmp___6 = strncmp((char const   *)s___0, "From ", (size_t )5);
        }
#line 286
        if (tmp___6) {
#line 293
          in_sig_p ++;
#line 294
          goto __Cont;
        } else {
#line 287
          in_sig_p = 0;
        }
      } else {
#line 293
        in_sig_p ++;
#line 294
        goto __Cont;
      }
    }
#line 299
    if (mailbox_p) {
#line 303
      if ((int )*(s___0 + 0) == 45) {
#line 303
        if ((int )*(s___0 + 1) == 45) {
#line 303
          if ((int )*(s___0 + 2) == 32) {
#line 303
            if ((int )*(s___0 + 3) == 10) {
#line 309
              in_sig_p = 1;
#line 310
              goto __Cont;
            } else
#line 303
            if ((int )*(s___0 + 3) == 13) {
#line 309
              in_sig_p = 1;
#line 310
              goto __Cont;
            } else
#line 303
            if ((int )*(s___0 + 3) == 0) {
#line 309
              in_sig_p = 1;
#line 310
              goto __Cont;
            }
          }
        }
      }
#line 314
      if ((int )*s___0 == 98) {
#line 314
        goto _L;
      } else
#line 314
      if ((int )*s___0 == 66) {
        _L: /* CIL Label */ 
        {
#line 314
        tmp___9 = strncasecmp((char const   *)s___0, "begin:", (size_t )6);
        }
#line 314
        if (! tmp___9) {
#line 316
          s2 = s___0 + 6;
          {
#line 317
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 317
            tmp___7 = __ctype_b_loc();
            }
#line 317
            if (! ((int const   )*(*tmp___7 + (int )*s2) & 8192)) {
#line 317
              goto while_break___2;
            }
#line 317
            s2 ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 318
          tmp___8 = strncasecmp((char const   *)s2, "vcard", (size_t )5);
          }
#line 318
          if (! tmp___8) {
#line 323
            in_sig_p = 1;
#line 324
            goto __Cont;
          }
        }
      }
#line 331
      got_some = 0;
#line 332
      s2___0 = s___0;
      {
#line 333
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 333
        tmp___10 = __ctype_b_loc();
        }
#line 333
        if (! ((int const   )*(*tmp___10 + (int )*s2___0) & 8192)) {
#line 333
          goto while_break___3;
        }
#line 334
        s2___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 335
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 335
        if (! ((int )*s2___0 == 62)) {
#line 335
          if (! ((int )*s2___0 == 93)) {
#line 335
            if (! ((int )*s2___0 == 125)) {
#line 335
              if (! ((int )*s2___0 == 124)) {
#line 335
                if (! ((int )*s2___0 == 58)) {
#line 335
                  goto while_break___4;
                }
              }
            }
          }
        }
#line 338
        got_some = 1;
#line 339
        s2___0 ++;
        {
#line 340
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 340
          tmp___11 = __ctype_b_loc();
          }
#line 340
          if (! ((int const   )*(*tmp___11 + (int )*s2___0) & 8192)) {
#line 340
            goto while_break___5;
          }
#line 341
          s2___0 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 349
      if (got_some) {
        {
#line 351
        s___0 = s2___0;
#line 352
        tmp___12 = strlen((char const   *)s___0);
#line 352
        L = (int )tmp___12;
        }
      }
#line 358
      w1 = (unsigned char const   *)"wrote:";
#line 359
      w2 = (unsigned char const   *)"writes:";
#line 360
      if (L > 10) {
        {
#line 360
        tmp___17 = strstr((char const   *)((s___0 + L) - 10), (char const   *)w1);
        }
#line 360
        if (tmp___17) {
#line 360
          goto _L___0;
        } else {
          {
#line 360
          tmp___18 = strstr((char const   *)((s___0 + L) - 10), (char const   *)w2);
          }
#line 360
          if (tmp___18) {
            _L___0: /* CIL Label */ 
#line 362
            got_it = 0;
#line 369
            s2___1 = s___0;
            {
#line 370
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 370
              if (! ((int )*s2___1 == 32)) {
#line 370
                goto while_break___6;
              }
#line 370
              s2___1 ++;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 371
            tmp___15 = strncmp((char const   *)s2___1, "In ", (size_t )3);
            }
#line 371
            if (tmp___15) {
              {
#line 371
              tmp___16 = strncmp((char const   *)s2___1, "On ", (size_t )3);
              }
#line 371
              if (tmp___16) {
                {
#line 373
                tmp___14 = strchr((char const   *)s2___1, '@');
                }
#line 373
                if (tmp___14) {
#line 374
                  got_it = 1;
                } else {
#line 377
                  i = 0;
                  {
#line 378
                  while (1) {
                    while_continue___7: /* CIL Label */ ;
#line 378
                    if (! *s2___1) {
#line 378
                      goto while_break___7;
                    }
#line 379
                    tmp___13 = s2___1;
#line 379
                    s2___1 ++;
#line 379
                    if ((int )*tmp___13 == 32) {
#line 380
                      i ++;
                    }
                  }
                  while_break___7: /* CIL Label */ ;
                  }
#line 381
                  if (i < 4) {
#line 382
                    got_it = 1;
                  }
                }
              } else {
#line 372
                got_it = 1;
              }
            } else {
#line 372
              got_it = 1;
            }
#line 384
            if (got_it) {
#line 389
              L = 0;
#line 390
              *s___0 = (unsigned char)0;
            }
          }
        }
      }
#line 403
      if ((int )*s___0 == 70) {
        {
#line 403
        tmp___29 = strncmp((char const   *)s___0, "From ", (size_t )5);
        }
#line 403
        if (tmp___29) {
#line 403
          goto _L___18;
        } else {
#line 404
          in_headers = 2;
        }
      } else
      _L___18: /* CIL Label */ 
#line 408
      if (! in_headers) {
#line 408
        if ((int )*s___0 == 45) {
#line 408
          if ((int )*(s___0 + 1) == 45) {
#line 418
            in_headers = 1;
          } else {
#line 408
            goto _L___17;
          }
        } else
        _L___17: /* CIL Label */ 
#line 408
        if ((int )*s___0 == 70) {
#line 408
          goto _L___16;
        } else
#line 408
        if ((int )*s___0 == 102) {
          _L___16: /* CIL Label */ 
          {
#line 408
          tmp___22 = strncmp((char const   *)s___0, "From: ", (size_t )6);
          }
#line 408
          if (tmp___22) {
#line 408
            goto _L___15;
          } else {
#line 418
            in_headers = 1;
          }
        } else
        _L___15: /* CIL Label */ 
#line 408
        if ((int )*s___0 == 68) {
#line 408
          goto _L___14;
        } else
#line 408
        if ((int )*s___0 == 100) {
          _L___14: /* CIL Label */ 
          {
#line 408
          tmp___23 = strncmp((char const   *)s___0, "Date: ", (size_t )6);
          }
#line 408
          if (tmp___23) {
#line 408
            goto _L___13;
          } else {
#line 418
            in_headers = 1;
          }
        } else
        _L___13: /* CIL Label */ 
#line 408
        if ((int )*s___0 == 80) {
#line 408
          goto _L___12;
        } else
#line 408
        if ((int )*s___0 == 112) {
          _L___12: /* CIL Label */ 
          {
#line 408
          tmp___24 = strncmp((char const   *)s___0, "Path: ", (size_t )6);
          }
#line 408
          if (tmp___24) {
#line 408
            goto _L___11;
          } else {
#line 418
            in_headers = 1;
          }
        } else
        _L___11: /* CIL Label */ 
#line 408
        if ((int )*s___0 == 83) {
#line 408
          goto _L___10;
        } else
#line 408
        if ((int )*s___0 == 115) {
          _L___10: /* CIL Label */ 
          {
#line 408
          tmp___25 = strncmp((char const   *)s___0, "Subject: ", (size_t )9);
          }
#line 408
          if (tmp___25) {
#line 408
            goto _L___9;
          } else {
#line 418
            in_headers = 1;
          }
        } else
        _L___9: /* CIL Label */ 
#line 408
        if ((int )*s___0 == 82) {
#line 408
          goto _L___8;
        } else
#line 408
        if ((int )*s___0 == 114) {
          _L___8: /* CIL Label */ 
          {
#line 408
          tmp___26 = strncmp((char const   *)s___0, "Received: ", (size_t )10);
          }
#line 408
          if (tmp___26) {
#line 408
            goto _L___7;
          } else {
#line 418
            in_headers = 1;
          }
        } else
        _L___7: /* CIL Label */ 
#line 408
        if ((int )*s___0 == 77) {
#line 408
          goto _L___6;
        } else
#line 408
        if ((int )*s___0 == 109) {
          _L___6: /* CIL Label */ 
          {
#line 408
          tmp___27 = strncmp((char const   *)s___0, "Message-ID: ", (size_t )12);
          }
#line 408
          if (tmp___27) {
#line 408
            goto _L___5;
          } else {
#line 418
            in_headers = 1;
          }
        } else
        _L___5: /* CIL Label */ 
#line 408
        if ((int )*s___0 == 82) {
#line 408
          goto _L___4;
        } else
#line 408
        if ((int )*s___0 == 114) {
          _L___4: /* CIL Label */ 
          {
#line 408
          tmp___28 = strncmp((char const   *)s___0, "Return-Path: ", (size_t )13);
          }
#line 408
          if (tmp___28) {
#line 408
            goto _L___3;
          } else {
#line 418
            in_headers = 1;
          }
        } else {
#line 408
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 420
      if (in_headers) {
#line 426
        if ((int )*s___0 == 13) {
#line 426
          goto _L___2;
        } else
#line 426
        if ((int )*s___0 == 10) {
          _L___2: /* CIL Label */ 
#line 428
          if (contains_msg) {
#line 429
            contains_msg = 0;
          } else {
#line 431
            in_headers = 0;
          }
        } else
#line 436
        if (in_headers == 1) {
#line 440
          if (! ((int )*s___0 == 32)) {
#line 440
            if (! ((int )*s___0 == 9)) {
#line 447
              s2___2 = (unsigned char const   *)s___0;
              {
#line 447
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 447
                if (*s2___2) {
#line 447
                  if ((int const   )*s2___2 != 58) {
                    {
#line 447
                    tmp___19 = __ctype_b_loc();
                    }
#line 447
                    if ((int const   )*(*tmp___19 + (int )*s2___2) & 8192) {
#line 447
                      goto while_break___8;
                    }
                  } else {
#line 447
                    goto while_break___8;
                  }
                } else {
#line 447
                  goto while_break___8;
                }
#line 447
                s2___2 ++;
              }
              while_break___8: /* CIL Label */ ;
              }
#line 450
              if ((int const   )*s2___2 != 58) {
#line 451
                in_headers = 0;
              }
            }
          }
#line 454
          if (in_headers) {
#line 454
            if (! contains_msg) {
#line 454
              if ((int )*s___0 == 67) {
#line 454
                goto _L___1;
              } else
#line 454
              if ((int )*s___0 == 99) {
                _L___1: /* CIL Label */ 
                {
#line 454
                tmp___20 = strncasecmp((char const   *)s___0, "Content-Type: message/rfc822",
                                       (size_t )28);
                }
#line 454
                if (tmp___20) {
                  {
#line 454
                  tmp___21 = strncasecmp((char const   *)s___0, "Content-Type: message/news",
                                         (size_t )26);
                  }
#line 454
                  if (! tmp___21) {
#line 458
                    contains_msg = 1;
                  }
                } else {
#line 458
                  contains_msg = 1;
                }
              }
            }
          }
        }
      }
#line 471
      if (in_headers) {
#line 473
        prev = (pword *)0;
#line 474
        goto __Cont;
      }
#line 482
      if (L == 61) {
#line 482
        if ((int )*s___0 == 77) {
#line 484
          uue_p = 1;
#line 486
          s2___3 = (unsigned char const   *)s___0;
          {
#line 486
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 486
            if (*s2___3) {
#line 486
              if ((int const   )*s2___3 != 10) {
#line 486
                if (! ((int const   )*s2___3 != 13)) {
#line 486
                  goto while_break___9;
                }
              } else {
#line 486
                goto while_break___9;
              }
            } else {
#line 486
              goto while_break___9;
            }
#line 487
            if ((int const   )*s2___3 < 32) {
#line 489
              uue_p = 0;
#line 490
              goto while_break___9;
            } else
#line 487
            if ((int const   )*s2___3 > 96) {
#line 489
              uue_p = 0;
#line 490
              goto while_break___9;
            }
#line 486
            s2___3 ++;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 495
          if (uue_p) {
#line 496
            goto __Cont;
          }
        }
      }
#line 504
      if (L >= 60) {
#line 504
        goto _L___22;
      } else
#line 504
      if (L > 3) {
#line 504
        if ((int )*(s___0 + (L - 1)) == 61) {
          _L___22: /* CIL Label */ 
#line 506
          b64_p = 1;
#line 508
          s2___4 = (unsigned char const   *)s___0;
          {
#line 508
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 508
            if (*s2___4) {
#line 508
              if ((int const   )*s2___4 != 10) {
#line 508
                if (! ((int const   )*s2___4 != 13)) {
#line 508
                  goto while_break___10;
                }
              } else {
#line 508
                goto while_break___10;
              }
            } else {
#line 508
              goto while_break___10;
            }
#line 509
            if ((int const   )*s2___4 >= 65) {
#line 509
              if (! ((int const   )*s2___4 <= 90)) {
#line 509
                goto _L___21;
              }
            } else
            _L___21: /* CIL Label */ 
#line 509
            if ((int const   )*s2___4 >= 97) {
#line 509
              if (! ((int const   )*s2___4 <= 122)) {
#line 509
                goto _L___20;
              }
            } else
            _L___20: /* CIL Label */ 
#line 509
            if ((int const   )*s2___4 >= 48) {
#line 509
              if (! ((int const   )*s2___4 <= 57)) {
#line 509
                goto _L___19;
              }
            } else
            _L___19: /* CIL Label */ 
#line 509
            if (! ((int const   )*s2___4 == 43)) {
#line 509
              if (! ((int const   )*s2___4 == 47)) {
#line 509
                if (! ((int const   )*s2___4 == 61)) {
#line 516
                  b64_p = 0;
#line 517
                  goto while_break___10;
                }
              }
            }
#line 508
            s2___4 ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 522
          if (b64_p) {
#line 523
            goto __Cont;
          }
        }
      }
#line 529
      if ((int )*(s___0 + 0) == 40) {
#line 529
        if ((int )*(s___0 + 1) == 84) {
          {
#line 529
          tmp___30 = strncmp((char const   *)s___0, "(This file must be converted with BinHex 4.0)",
                             (size_t )45);
          }
#line 529
          if (! tmp___30) {
#line 532
            in_binhex_p = 1;
#line 533
            goto __Cont;
          }
        }
      }
#line 540
      if (L > 60) {
        {
#line 540
        tmp___31 = strchr((char const   *)s___0, ' ');
        }
#line 540
        if (! tmp___31) {
#line 545
          goto __Cont;
        }
      }
    }
#line 556
    s2___5 = s___0;
    {
#line 557
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 557
      tmp___40 = strchr((char const   *)s2___5, '=');
#line 557
      s2___5 = (unsigned char *)tmp___40;
      }
#line 557
      if (! s2___5) {
#line 557
        goto while_break___11;
      }
      {
#line 559
      tmp___38 = __ctype_b_loc();
      }
#line 559
      if ((int const   )*(*tmp___38 + (int )*(s2___5 + 1)) & 4096) {
        {
#line 559
        tmp___39 = __ctype_b_loc();
        }
#line 559
        if ((int const   )*(*tmp___39 + (int )*(s2___5 + 2)) & 4096) {
#line 561
          if (*s2___5) {
#line 563
            s3 = s2___5 + 1;
#line 564
            s4 = (unsigned char const   *)(s2___5 + 3);
#line 565
            if ((int )*(s2___5 + 1) >= 48) {
#line 565
              if ((int )*(s2___5 + 1) <= 57) {
#line 565
                tmp___33 = (int )*(s2___5 + 1) - 48;
              } else {
#line 565
                goto _L___23;
              }
            } else {
              _L___23: /* CIL Label */ 
#line 565
              if ((int )*(s2___5 + 1) >= 65) {
#line 565
                if ((int )*(s2___5 + 1) <= 70) {
#line 565
                  tmp___32 = (int )*(s2___5 + 1) - 55;
                } else {
#line 565
                  tmp___32 = (int )*(s2___5 + 1) - 87;
                }
              } else {
#line 565
                tmp___32 = (int )*(s2___5 + 1) - 87;
              }
#line 565
              tmp___33 = tmp___32;
            }
#line 565
            if ((int )*(s2___5 + 2) >= 48) {
#line 565
              if ((int )*(s2___5 + 2) <= 57) {
#line 565
                tmp___35 = (int )*(s2___5 + 2) - 48;
              } else {
#line 565
                goto _L___24;
              }
            } else {
              _L___24: /* CIL Label */ 
#line 565
              if ((int )*(s2___5 + 2) >= 65) {
#line 565
                if ((int )*(s2___5 + 2) <= 70) {
#line 565
                  tmp___34 = (int )*(s2___5 + 2) - 55;
                } else {
#line 565
                  tmp___34 = (int )*(s2___5 + 2) - 87;
                }
              } else {
#line 565
                tmp___34 = (int )*(s2___5 + 2) - 87;
              }
#line 565
              tmp___35 = tmp___34;
            }
#line 565
            *(s2___5 + 0) = (unsigned char )((tmp___33 << 4) | (tmp___35 << 4));
#line 575
            L -= 2;
            {
#line 576
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 576
              if (! *s4) {
#line 576
                goto while_break___12;
              }
#line 577
              tmp___36 = s3;
#line 577
              s3 ++;
#line 577
              tmp___37 = s4;
#line 577
              s4 ++;
#line 577
              *tmp___36 = (unsigned char )*tmp___37;
            }
            while_break___12: /* CIL Label */ ;
            }
#line 578
            *s3 = (unsigned char)0;
          }
        } else {
#line 560
          s2___5 ++;
        }
      } else {
#line 560
        s2___5 ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
#line 600
    if (L > 1) {
#line 600
      if ((int )*(s___0 + (L - 1)) == 61) {
        {
#line 600
        tmp___44 = __ctype_b_loc();
        }
#line 600
        if ((int const   )*(*tmp___44 + (int )*(s___0 + (L - 2))) & 8) {
#line 604
          s3___0 = (s___0 + L) - 2;
#line 605
          *(s___0 + (L - 1)) = (unsigned char)0;
          {
#line 606
          while (1) {
            while_continue___13: /* CIL Label */ ;
            {
#line 606
            tmp___41 = __ctype_b_loc();
            }
#line 606
            if ((int const   )*(*tmp___41 + (int )*s3___0) & 8) {
#line 606
              if (! ((unsigned long )s3___0 > (unsigned long )s___0)) {
#line 606
                goto while_break___13;
              }
            } else {
#line 606
              goto while_break___13;
            }
#line 607
            s3___0 --;
          }
          while_break___13: /* CIL Label */ ;
          }
          {
#line 608
          *s3___0 = (unsigned char)0;
#line 609
          tmp___42 = strdup((char const   *)(s3___0 + 1));
#line 609
          qp_wrap_hack = (unsigned char *)tmp___42;
#line 610
          tmp___43 = strlen((char const   *)s___0);
#line 610
          L = (int )tmp___43;
          }
        }
      }
    }
#line 621
    last = (unsigned char const   *)s___0;
    {
#line 623
    while (1) {
      while_continue___14: /* CIL Label */ ;
      {
#line 623
      tmp___53 = strchr((char const   *)last, '<');
#line 623
      s2___6 = (unsigned char *)tmp___53;
      }
#line 623
      if (! s2___6) {
#line 623
        goto while_break___14;
      }
#line 625
      s3___1 = (unsigned char const   *)(s2___6 + 1);
#line 626
      close_p = 0;
#line 628
      last = s3___1;
#line 631
      if ((int const   )*last == 60) {
        {
#line 633
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 633
          if (! ((int const   )*last == 60)) {
#line 633
            goto while_break___15;
          }
#line 634
          last ++;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 635
        goto while_continue___14;
      }
#line 639
      if ((int const   )*s3___1 == 47) {
#line 640
        close_p = 1;
#line 640
        s3___1 ++;
      }
      {
#line 641
      while (1) {
        while_continue___16: /* CIL Label */ ;
        {
#line 641
        tmp___45 = __ctype_b_loc();
        }
#line 641
        if (! ((int const   )*(*tmp___45 + (int )*s3___1) & 8)) {
#line 641
          goto while_break___16;
        }
#line 642
        s3___1 ++;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 645
      if ((unsigned long )s3___1 > (unsigned long )((s2___6 + 1) + close_p)) {
#line 645
        if ((unsigned long )s3___1 < (unsigned long )(s2___6 + 20)) {
#line 645
          if ((int const   )*s3___1 == 0) {
#line 645
            goto _L___26;
          } else
#line 645
          if ((int const   )*s3___1 == 62) {
#line 645
            goto _L___26;
          } else {
            {
#line 645
            tmp___52 = __ctype_b_loc();
            }
#line 645
            if ((int const   )*(*tmp___52 + (int )*s3___1) & 8192) {
              _L___26: /* CIL Label */ 
              {
#line 651
              while (1) {
                while_continue___17: /* CIL Label */ ;
#line 651
                if (*s3___1) {
#line 651
                  if (! ((int const   )*s3___1 != 62)) {
#line 651
                    goto while_break___17;
                  }
                } else {
#line 651
                  goto while_break___17;
                }
#line 652
                s3___1 ++;
              }
              while_break___17: /* CIL Label */ ;
              }
#line 653
              if (! *s3___1) {
#line 655
                last = s3___1;
#line 656
                inside_html_tag = 1;
#line 657
                *(s2___6 + 0) = (unsigned char)0;
#line 658
                *(s2___6 + 1) = (unsigned char)0;
              } else {
#line 668
                out = s2___6;
#line 680
                s3___1 ++;
#line 681
                tmp___46 = out;
#line 681
                out ++;
#line 681
                *tmp___46 = (unsigned char )' ';
                {
#line 682
                while (1) {
                  while_continue___18: /* CIL Label */ ;
#line 682
                  if (! *s3___1) {
#line 682
                    goto while_break___18;
                  }
#line 683
                  tmp___47 = out;
#line 683
                  out ++;
#line 683
                  tmp___48 = s3___1;
#line 683
                  s3___1 ++;
#line 683
                  *tmp___47 = (unsigned char )*tmp___48;
                }
                while_break___18: /* CIL Label */ ;
                }
#line 684
                *out = (unsigned char)0;
#line 685
                last = (unsigned char const   *)s2___6;
              }
            } else {
#line 645
              goto _L___27;
            }
          }
        } else {
#line 645
          goto _L___27;
        }
      } else
      _L___27: /* CIL Label */ 
#line 688
      if ((int const   )*(s3___1 + 0) == 33) {
#line 688
        if ((int const   )*(s3___1 + 1) == 45) {
#line 688
          if ((int const   )*(s3___1 + 2) == 45) {
#line 690
            out___0 = s2___6;
#line 691
            in_comment_p = 1;
#line 692
            *(s2___6 + 0) = (unsigned char)0;
#line 693
            *(s2___6 + 1) = (unsigned char)0;
#line 697
            s3___1 += 3;
            {
#line 699
            while (1) {
              while_continue___19: /* CIL Label */ ;
#line 699
              if (*s3___1) {
#line 699
                if (! ((int const   )*(s3___1 + 0) != 45)) {
#line 699
                  if (! ((int const   )*(s3___1 + 1) != 45)) {
#line 699
                    if (! ((int const   )*(s3___1 + 2) != 62)) {
#line 699
                      goto while_break___19;
                    }
                  }
                }
              } else {
#line 699
                goto while_break___19;
              }
#line 700
              s3___1 ++;
            }
            while_break___19: /* CIL Label */ ;
            }
#line 701
            if (*s3___1) {
#line 703
              in_comment_p = 0;
#line 704
              s3___1 += 3;
            }
#line 707
            tmp___49 = out___0;
#line 707
            out___0 ++;
#line 707
            *tmp___49 = (unsigned char )' ';
            {
#line 708
            while (1) {
              while_continue___20: /* CIL Label */ ;
#line 708
              if (! *s3___1) {
#line 708
                goto while_break___20;
              }
#line 709
              tmp___50 = out___0;
#line 709
              out___0 ++;
#line 709
              tmp___51 = s3___1;
#line 709
              s3___1 ++;
#line 709
              *tmp___50 = (unsigned char )*tmp___51;
            }
            while_break___20: /* CIL Label */ ;
            }
#line 710
            *out___0 = (unsigned char)0;
#line 711
            last = (unsigned char const   *)s2___6;
          }
        }
      }
    }
    while_break___14: /* CIL Label */ ;
    }
#line 729
    last___0 = (unsigned char const   *)s___0;
    {
#line 731
    while (1) {
      while_continue___21: /* CIL Label */ ;
      {
#line 731
      tmp___60 = strchr((char const   *)last___0, '&');
#line 731
      s2___7 = (unsigned char *)tmp___60;
      }
#line 731
      if (! s2___7) {
#line 731
        goto while_break___21;
      }
#line 733
      s3___2 = s2___7 + 1;
#line 734
      last___0 = (unsigned char const   *)s3___2;
      {
#line 735
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 735
        if (*s3___2) {
#line 735
          if ((int )*s3___2 != 59) {
            {
#line 735
            tmp___54 = __ctype_b_loc();
            }
#line 735
            if ((int const   )*(*tmp___54 + (int )*s3___2) & 8192) {
#line 735
              goto while_break___22;
            } else
#line 735
            if (! ((unsigned long )s3___2 < (unsigned long )(last___0 + 10))) {
#line 735
              goto while_break___22;
            }
          } else {
#line 735
            goto while_break___22;
          }
        } else {
#line 735
          goto while_break___22;
        }
#line 736
        s3___2 ++;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 737
      if ((int )*s3___2 == 59) {
#line 737
        goto _L___28;
      } else {
        {
#line 737
        tmp___59 = __ctype_b_loc();
        }
#line 737
        if ((int const   )*(*tmp___59 + (int )*s3___2) & 8192) {
          _L___28: /* CIL Label */ 
          {
#line 739
          tmp___55 = get_entity(last___0, (int )(s3___2 - (unsigned char *)last___0));
#line 739
          e = (unsigned char )tmp___55;
          }
#line 740
          if (! e) {
#line 740
            goto while_continue___21;
          }
#line 741
          tmp___56 = s2___7;
#line 741
          s2___7 ++;
#line 741
          *tmp___56 = e;
#line 742
          if (*s3___2) {
#line 742
            s3___2 ++;
          }
          {
#line 743
          while (1) {
            while_continue___23: /* CIL Label */ ;
#line 743
            if (! *s3___2) {
#line 743
              goto while_break___23;
            }
#line 744
            tmp___57 = s2___7;
#line 744
            s2___7 ++;
#line 744
            tmp___58 = s3___2;
#line 744
            s3___2 ++;
#line 744
            *tmp___57 = *tmp___58;
          }
          while_break___23: /* CIL Label */ ;
          }
#line 745
          *s2___7 = (unsigned char)0;
        }
      }
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 750
    prev = scan_line(s___0, table, prev);
    }
    __Cont: /* CIL Label */ 
    {
#line 210
    tmp___61 = fgets((char */* __restrict  */)(buf), (int )(sizeof(buf) - 1UL), (FILE */* __restrict  */)file);
#line 210
    s___0 = (unsigned char *)tmp___61;
    }
#line 210
    if (! s___0) {
#line 210
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 754
  if (qp_free_wrap_hack) {
    {
#line 755
    free((void *)qp_free_wrap_hack);
    }
  }
  {
#line 757
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d lines\n",
          line_count);
  }
#line 759
  return (0);
}
}
#line 763 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/dadadodo.c"
static void usage(char const   *av0 ) 
{ 
  char *s___0 ;
  char *tmp ;
  char *s2 ;
  char *tmp___0 ;

  {
  {
#line 766
  tmp = strdup(version + 4);
#line 766
  s___0 = tmp;
#line 767
  tmp___0 = strchr((char const   *)s___0, '(');
#line 767
  s2 = tmp___0;
#line 768
  *s2 = (char )'<';
#line 769
  s2 = strchr((char const   *)s___0, ')');
#line 770
  *s2 = (char )'>';
#line 771
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          s___0);
#line 772
  free((void *)s___0);
#line 773
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nusage: %s [ options ] [ input-files ]\n",
          av0);
#line 774
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nThis program analyses text files and generates markov chains of word\nfrequencies; it can then generate random sentences based on that data.\nOptions include:\n\n        -h or -help             this message\n        -o or -output <file>    file to save compiled data in (- for stdout)\n        -l or -load <file>      file of compiled data to load (- for stdin)\n        -c or -count <n>        how many sentences to generate (0 = inf)\n        -w or -columns <n>      how many columns wide the output should be\n        -p or -pause <seconds>  delay between paragraphs\n        -html                   output HTML instead of plain-text.\n\nRemaining arguments are input files; these should be text files, but may\nbe mail folders or HTML.  (MIME messages are also handled sensibly.)\n\nWhen no output file is specified, sentences will be generated from the input\ndata directly; however, loading a saved file is far faster than re-parsing\nthe text files each time.\n\n");
  }
#line 793
  return;
}
}
#line 800 "/home/june/repo/benchmarks/collector/temp/dadadodo-1.04/dadadodo.c"
int main(int argc , char **argv ) 
{ 
  int status ;
  int i ;
  int n_input ;
  int count ;
  int pause___0 ;
  int columns ;
  char *columns_str ;
  int html_p ;
  char const   **input ;
  void *tmp ;
  char *output ;
  char *load ;
  char *stat_words ;
  FILE *tmp_file ;
  char const   *sw ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  FILE *out ;
  hash_table *table ;
  hash_table *tmp___15 ;
  unsigned char buf[1024] ;
  unsigned char *s___0 ;
  FILE *f ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *b ;
  size_t tmp___22 ;
  void *tmp___23 ;
  size_t tmp___24 ;
  __pid_t tmp___25 ;
  size_t tmp___26 ;
  char buf___0[255] ;
  char buf___1[255] ;
  int tmp___27 ;
  char buf___2[255] ;
  FILE *f___0 ;
  int done_once ;
  int *s___1 ;
  int i___0 ;
  unsigned char *s___2 ;
  char *tmp___28 ;
  int done_once___0 ;
  char *tmp___29 ;
  int tmp___30 ;
  int column ;
  int words ;
  int n ;
  int indent ;
  int fill_column ;
  int sidebar_p ;
  int sidebar_words ;
  int number_p ;
  FILE *out___0 ;
  int old_indent ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  int i___1 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  int i___2 ;
  int width ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___41 ;
  int sw___0 ;
  int tmp___42 ;
  int tmp___43 ;

  {
  {
#line 805
  n_input = 0;
#line 806
  count = -1;
#line 807
  pause___0 = 1;
#line 809
  columns_str = (char *)((void *)0);
#line 810
  html_p = 0;
#line 811
  tmp = malloc((unsigned long )argc * sizeof(*input));
#line 811
  input = (char const   **)tmp;
#line 812
  output = (char *)0;
#line 813
  load = (char *)0;
#line 814
  stat_words = (char *)0;
#line 815
  tmp_file = (FILE *)0;
#line 817
  setlocale(6, "");
#line 819
  i = 1;
  }
  {
#line 819
  while (1) {
    while_continue: /* CIL Label */ ;
#line 819
    if (! (i < argc)) {
#line 819
      goto while_break;
    }
#line 821
    sw = (char const   *)*(argv + i);
#line 822
    if ((int const   )*(sw + 0) == 45) {
#line 822
      if ((int const   )*(sw + 1) == 45) {
#line 823
        sw ++;
      }
    }
    {
#line 825
    tmp___13 = strcmp(sw, "-h");
    }
#line 825
    if (tmp___13) {
      {
#line 825
      tmp___14 = strcmp((char const   *)*(argv + i), "-help");
      }
#line 825
      if (tmp___14) {
        {
#line 830
        tmp___11 = strcmp(sw, "-o");
        }
#line 830
        if (tmp___11) {
          {
#line 830
          tmp___12 = strcmp(sw, "-output");
          }
#line 830
          if (tmp___12) {
            {
#line 834
            tmp___9 = strcmp(sw, "-l");
            }
#line 834
            if (tmp___9) {
              {
#line 834
              tmp___10 = strcmp(sw, "-load");
              }
#line 834
              if (tmp___10) {
                {
#line 838
                tmp___7 = strcmp(sw, "-c");
                }
#line 838
                if (tmp___7) {
                  {
#line 838
                  tmp___8 = strcmp(sw, "-count");
                  }
#line 838
                  if (tmp___8) {
                    {
#line 847
                    tmp___5 = strcmp(sw, "-w");
                    }
#line 847
                    if (tmp___5) {
                      {
#line 847
                      tmp___6 = strcmp(sw, "-columns");
                      }
#line 847
                      if (tmp___6) {
                        {
#line 856
                        tmp___3 = strcmp(sw, "-p");
                        }
#line 856
                        if (tmp___3) {
                          {
#line 856
                          tmp___4 = strcmp(sw, "-pause");
                          }
#line 856
                          if (tmp___4) {
                            {
#line 865
                            tmp___2 = strcmp(sw, "-html");
                            }
#line 865
                            if (tmp___2) {
                              {
#line 869
                              tmp___1 = strcmp(sw, "-stats");
                              }
#line 869
                              if (tmp___1) {
#line 876
                                if ((int const   )*(sw + 0) == 45) {
#line 876
                                  if (*(sw + 1)) {
                                    {
#line 878
                                    usage((char const   *)*(argv + 0));
#line 879
                                    exit(1);
                                    }
                                  } else {
#line 883
                                    tmp___0 = n_input;
#line 883
                                    n_input ++;
#line 883
                                    *(input + tmp___0) = sw;
                                  }
                                } else {
#line 883
                                  tmp___0 = n_input;
#line 883
                                  n_input ++;
#line 883
                                  *(input + tmp___0) = sw;
                                }
                              } else
#line 871
                              if (argc > i + 1) {
#line 871
                                if ((int )*(*(argv + (i + 1)) + 0) != 45) {
#line 872
                                  i ++;
#line 872
                                  stat_words = *(argv + i);
                                } else {
                                  {
#line 874
                                  stat_words = strdup("");
                                  }
                                }
                              } else {
                                {
#line 874
                                stat_words = strdup("");
                                }
                              }
                            } else {
#line 867
                              html_p = 1;
                            }
                          } else {
                            _L: /* CIL Label */ 
#line 858
                            if (i + 1 >= argc) {
                              {
#line 860
                              usage((char const   *)*(argv + 0));
#line 861
                              exit(1);
                              }
                            }
                            {
#line 863
                            i ++;
#line 863
                            pause___0 = atoi((char const   *)*(argv + i));
                            }
                          }
                        } else {
#line 856
                          goto _L;
                        }
                      } else {
                        _L___0: /* CIL Label */ 
#line 849
                        if (i + 1 >= argc) {
                          {
#line 851
                          usage((char const   *)*(argv + 0));
#line 852
                          exit(1);
                          }
                        }
#line 854
                        i ++;
#line 854
                        columns_str = *(argv + i);
                      }
                    } else {
#line 847
                      goto _L___0;
                    }
                  } else {
                    _L___1: /* CIL Label */ 
#line 840
                    if (i + 1 >= argc) {
                      {
#line 842
                      usage((char const   *)*(argv + 0));
#line 843
                      exit(1);
                      }
                    }
                    {
#line 845
                    i ++;
#line 845
                    count = atoi((char const   *)*(argv + i));
                    }
                  }
                } else {
#line 838
                  goto _L___1;
                }
              } else {
#line 836
                i ++;
#line 836
                load = *(argv + i);
              }
            } else {
#line 836
              i ++;
#line 836
              load = *(argv + i);
            }
          } else {
#line 832
            i ++;
#line 832
            output = *(argv + i);
          }
        } else {
#line 832
          i ++;
#line 832
          output = *(argv + i);
        }
      } else {
        {
#line 827
        usage((char const   *)*(argv + 0));
#line 828
        exit(0);
        }
      }
    } else {
      {
#line 827
      usage((char const   *)*(argv + 0));
#line 828
      exit(0);
      }
    }
#line 819
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 892
  if ((unsigned long )columns_str == (unsigned long )((void *)0)) {
    {
#line 894
    columns_str = getenv("COLUMNS");
    }
  }
#line 897
  if ((unsigned long )columns_str != (unsigned long )((void *)0)) {
    {
#line 899
    columns = atoi((char const   *)columns_str);
    }
  } else {
#line 903
    columns = 72;
  }
#line 906
  if (n_input == 0) {
#line 906
    if (! output) {
#line 906
      if (! load) {
        {
#line 908
        usage((char const   *)*(argv + 0));
#line 909
        exit(1);
        }
      }
    }
  }
#line 912
  if (load) {
#line 912
    if (n_input) {
      {
#line 914
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t load and parse files at the same time.\n",
              *(argv + 0));
#line 916
      usage((char const   *)*(argv + 0));
#line 917
      exit(1);
      }
    }
  }
#line 920
  if (! output) {
#line 920
    if (! stat_words) {
#line 920
      if (count == -1) {
#line 921
        count = 0;
      }
    }
  }
#line 923
  if (n_input) {
    {
#line 926
    tmp___15 = make_hash_table(20000L, (long (*)(void const   * ))(& string_case_hash),
                               (int (*)(void const   * , void const   * ))(& strcasecmp));
#line 926
    table = tmp___15;
#line 931
    i = 0;
    }
    {
#line 931
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 931
      if (! (i < n_input)) {
#line 931
        goto while_break___0;
      }
      {
#line 936
      tmp___16 = strcmp(*(input + i), "-");
      }
#line 936
      if (tmp___16) {
        {
#line 940
        f = fopen((char const   */* __restrict  */)*(input + i), (char const   */* __restrict  */)"r");
        }
#line 941
        if (! f) {
          {
#line 943
          sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s: opening input file %s",
                  *(argv + 0), *(input + i));
#line 944
          perror((char const   *)(buf));
#line 945
          exit(1);
          }
        }
      } else {
#line 937
        f = stdin;
      }
#line 949
      if ((unsigned long )f == (unsigned long )stdin) {
#line 949
        tmp___17 = "stdin";
      } else {
#line 949
        tmp___17 = *(input + i);
      }
      {
#line 949
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: reading %s...\n",
              *(argv + 0), tmp___17);
#line 952
      tmp___18 = fgets((char */* __restrict  */)(buf), (int )(sizeof(buf) - 1UL),
                       (FILE */* __restrict  */)f);
#line 952
      s___0 = (unsigned char *)tmp___18;
      }
#line 953
      if (! s___0) {
#line 955
        status = 0;
      } else {
        {
#line 959
        tmp___19 = strcmp((char const   *)s___0, "#!DadaDodo\n");
        }
#line 959
        if (tmp___19) {
          {
#line 960
          status = scan(f, table, (char *)(buf));
          }
        } else
#line 963
        if (load) {
          {
#line 965
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t load two saved files at once (%s and %s)\n",
                  *(argv + 0), load, *(input + i));
#line 968
          exit(-1);
          }
        } else {
          {
#line 972
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: saved files must be loaded with -load: %s\n",
                  *(argv + 0), *(input + i));
#line 975
          exit(-1);
          }
        }
      }
#line 980
      if ((unsigned long )f != (unsigned long )stdin) {
        {
#line 981
        fclose(f);
        }
      }
#line 983
      if (status < 0) {
        {
#line 985
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: out of memory\n",
                *(argv + 0));
#line 986
        exit(1);
        }
      }
#line 931
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 989
    free_hash_table(table);
#line 990
    free((void *)input);
#line 991
    input = (char const   **)0;
    }
#line 993
    if (! output) {
      {
#line 995
      tmp___21 = getenv("TMPDIR");
#line 995
      tmp___20 = tmp___21;
      }
#line 997
      if (! tmp___20) {
        {
#line 997
        tmp___20 = strdup("/tmp");
        }
      }
      {
#line 998
      tmp___22 = strlen((char const   *)tmp___20);
#line 998
      tmp___23 = malloc(tmp___22 + 40UL);
#line 998
      b = (char *)tmp___23;
#line 999
      strcpy((char */* __restrict  */)b, (char const   */* __restrict  */)tmp___20);
#line 1000
      tmp___24 = strlen((char const   *)b);
      }
#line 1000
      if ((int )*(b + (tmp___24 - 1UL)) != 47) {
        {
#line 1001
        strcat((char */* __restrict  */)b, (char const   */* __restrict  */)"/");
        }
      }
      {
#line 1002
      tmp___25 = getpid();
#line 1002
      tmp___26 = strlen((char const   *)b);
#line 1002
      sprintf((char */* __restrict  */)(b + tmp___26), (char const   */* __restrict  */)"dadadodo.%d",
              tmp___25);
#line 1004
      tmp_file = fopen((char const   */* __restrict  */)b, (char const   */* __restrict  */)"wb+");
      }
#line 1005
      if (! tmp_file) {
        {
#line 1008
        sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%s: opening %s",
                *(argv + 0), b);
#line 1009
        perror((char const   *)(buf___0));
#line 1010
        exit(-1);
        }
      }
      {
#line 1012
      unlink((char const   *)b);
#line 1013
      free((void *)b);
#line 1014
      out = tmp_file;
      }
    } else {
      {
#line 1016
      tmp___27 = strcmp((char const   *)output, "-");
      }
#line 1016
      if (tmp___27) {
        {
#line 1020
        out = fopen((char const   */* __restrict  */)output, (char const   */* __restrict  */)"wb");
        }
#line 1021
        if (! out) {
          {
#line 1024
          sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s: opening output file %s",
                  *(argv + 0), output);
#line 1025
          perror((char const   *)(buf___1));
#line 1026
          exit(1);
          }
        }
      } else {
#line 1017
        out = stdout;
      }
    }
    {
#line 1030
    status = write_dadadodo_file(out, (char const   *)output);
    }
#line 1032
    if ((unsigned long )out == (unsigned long )tmp_file) {
      {
#line 1033
      fflush(out);
      }
    } else
#line 1034
    if ((unsigned long )out != (unsigned long )stdout) {
      {
#line 1035
      fclose(out);
      }
    }
#line 1037
    if (status < 0) {
      {
#line 1040
      sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%s: writing output file %s",
              *(argv + 0), output);
#line 1041
      perror((char const   *)(buf___2));
#line 1042
      exit(1);
      }
    }
  }
#line 1047
  if (count >= 0) {
#line 1047
    goto _L___2;
  } else
#line 1047
  if (stat_words) {
    _L___2: /* CIL Label */ 
#line 1051
    if (load) {
      {
#line 1053
      f___0 = fopen((char const   */* __restrict  */)load, (char const   */* __restrict  */)"rb");
      }
#line 1054
      if (! f___0) {
        {
#line 1056
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t open input file %s\n",
                *(argv + 0), load);
#line 1058
        exit(-1);
        }
      }
    } else
#line 1061
    if (output) {
      {
#line 1063
      f___0 = fopen((char const   */* __restrict  */)output, (char const   */* __restrict  */)"rb");
      }
#line 1064
      if (! f___0) {
        {
#line 1066
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t open output file %s\n",
                *(argv + 0), load);
#line 1068
        exit(-1);
        }
      }
    } else {
      {
#line 1073
      f___0 = tmp_file;
#line 1074
      fseek(f___0, 0L, 0);
      }
    }
    {
#line 1077
    status = read_dadadodo_file(f___0);
    }
#line 1078
    if (status < 0) {
      {
#line 1080
      perror("reading file");
#line 1081
      exit(-1);
      }
    }
    {
#line 1083
    fclose(f___0);
    }
  }
#line 1086
  if (stat_words) {
#line 1088
    if (! *stat_words) {
      {
#line 1089
      stats(stdout);
      }
    } else {
      {
#line 1090
      tmp___30 = strcmp((char const   *)stat_words, "starters");
      }
#line 1090
      if (tmp___30) {
        {
#line 1107
        tmp___28 = strtok((char */* __restrict  */)stat_words, (char const   */* __restrict  */)",; ");
#line 1107
        s___2 = (unsigned char *)tmp___28;
#line 1108
        done_once___0 = 0;
        }
        {
#line 1109
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1111
          string_stats(stdout, (unsigned char const   *)s___2, ! done_once___0);
#line 1112
          done_once___0 = 1;
#line 1109
          tmp___29 = strtok((char */* __restrict  */)0, (char const   */* __restrict  */)",; ");
#line 1109
          s___2 = (unsigned char *)tmp___29;
          }
#line 1109
          if (! s___2) {
#line 1109
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
        {
#line 1092
        done_once = 0;
#line 1093
        s___1 = starters;
#line 1094
        i___0 = 0;
#line 1095
        printf((char const   */* __restrict  */)"\nStarters:");
        }
        {
#line 1096
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1096
          if (! (i___0 < total_starters)) {
#line 1096
            goto while_break___2;
          }
          {
#line 1098
          i___0 += (all_words + *s___1)->start;
#line 1099
          string_stats(stdout, (unsigned char const   *)*(all_strings + (all_words + *s___1)->string),
                       ! done_once);
#line 1101
          done_once = 1;
#line 1102
          s___1 ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
  }
#line 1118
  if (count >= 0) {
    {
#line 1120
    column = 0;
#line 1121
    words = 0;
#line 1122
    n = 0;
#line 1123
    indent = 0;
#line 1124
    fill_column = columns;
#line 1125
    sidebar_p = 0;
#line 1126
    sidebar_words = 0;
#line 1127
    number_p = 0;
#line 1128
    out___0 = stdout;
#line 1130
    ya_rand_init(0U);
    }
    {
#line 1132
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1132
      if (count > 0) {
#line 1132
        tmp___43 = n < count;
      } else {
#line 1132
        tmp___43 = 1;
      }
#line 1132
      if (! tmp___43) {
#line 1132
        goto while_break___3;
      }
#line 1135
      if (words == 0) {
#line 1135
        goto _L___5;
      } else
#line 1135
      if (words > 90) {
#line 1135
        goto _L___5;
      } else
#line 1135
      if (sidebar_words < 0) {
#line 1135
        goto _L___5;
      } else
#line 1135
      if (column > 0) {
        {
#line 1135
        tmp___41 = ya_random();
        }
#line 1135
        if ((tmp___41 & 2147483647U) % 4U == 0U) {
          _L___5: /* CIL Label */ 
          {
#line 1140
          old_indent = indent;
#line 1141
          tmp___32 = ya_random();
          }
#line 1141
          if ((tmp___32 & 2147483647U) % 3U == 0U) {
            {
#line 1142
            tmp___31 = ya_random();
#line 1142
            indent = (int )(((tmp___31 & 2147483647U) % 4U) * 4U);
            }
          }
#line 1144
          fill_column = columns;
#line 1145
          if (indent) {
            {
#line 1145
            tmp___33 = ya_random();
            }
#line 1145
            if ((tmp___33 & 2147483647U) % 2U == 0U) {
#line 1146
              fill_column -= indent;
            }
          }
#line 1148
          if (sidebar_p) {
            {
#line 1150
            fputs((char const   */* __restrict  */)"</TD></TR></TABLE>\n", (FILE */* __restrict  */)out___0);
#line 1151
            sidebar_p = 0;
            }
          }
#line 1154
          if (indent == 0) {
#line 1155
            number_p = 0;
          }
#line 1157
          if (html_p) {
#line 1157
            if (indent != old_indent) {
#line 1160
              if (indent > old_indent) {
#line 1162
                i___1 = old_indent;
                {
#line 1162
                while (1) {
                  while_continue___4: /* CIL Label */ ;
#line 1162
                  if (! (i___1 < indent)) {
#line 1162
                    goto while_break___4;
                  }
                  {
#line 1164
                  tmp___34 = ya_random();
                  }
                  {
#line 1165
                  if ((tmp___34 & 2147483647U) % 4U == 1U) {
#line 1165
                    goto case_1;
                  }
#line 1165
                  if ((tmp___34 & 2147483647U) % 4U == 0U) {
#line 1165
                    goto case_1;
                  }
#line 1168
                  if ((tmp___34 & 2147483647U) % 4U == 2U) {
#line 1168
                    goto case_2;
                  }
#line 1171
                  goto switch_default;
                  case_1: /* CIL Label */ 
                  case_0: /* CIL Label */ 
                  {
#line 1166
                  fputs((char const   */* __restrict  */)"<BLOCKQUOTE>", (FILE */* __restrict  */)out___0);
                  }
#line 1167
                  goto switch_break;
                  case_2: /* CIL Label */ 
                  {
#line 1169
                  tmp___35 = ya_random();
#line 1169
                  fprintf((FILE */* __restrict  */)out___0, (char const   */* __restrict  */)"<OL START=%d>",
                          (tmp___35 & 2147483647U) % 100U);
                  }
#line 1170
                  goto switch_break;
                  switch_default: /* CIL Label */ 
                  {
#line 1172
                  fputs((char const   */* __restrict  */)"<UL>", (FILE */* __restrict  */)out___0);
                  }
#line 1173
                  goto switch_break;
                  switch_break: /* CIL Label */ ;
                  }
#line 1162
                  i___1 += 4;
                }
                while_break___4: /* CIL Label */ ;
                }
                {
#line 1176
                tmp___36 = ya_random();
#line 1176
                number_p = (tmp___36 & 2147483647U) % 5U == 0U;
                }
              } else {
#line 1179
                i___1 = indent;
                {
#line 1179
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 1179
                  if (! (i___1 < old_indent)) {
#line 1179
                    goto while_break___5;
                  }
                  {
#line 1180
                  fputs((char const   */* __restrict  */)"</UL>", (FILE */* __restrict  */)out___0);
#line 1179
                  i___1 += 4;
                  }
                }
                while_break___5: /* CIL Label */ ;
                }
              }
              {
#line 1181
              fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)out___0);
              }
            }
          }
#line 1184
          if (words > 0) {
#line 1186
            if (html_p) {
#line 1188
              if (number_p) {
                {
#line 1188
                tmp___38 = ya_random();
                }
#line 1188
                if ((tmp___38 & 2147483647U) % 3U != 0U) {
                  {
#line 1189
                  fputs((char const   */* __restrict  */)"<P ALIGN=RIGHT><LI>", (FILE */* __restrict  */)out___0);
                  }
                } else {
#line 1188
                  goto _L___3;
                }
              } else {
                _L___3: /* CIL Label */ 
                {
#line 1190
                tmp___37 = ya_random();
                }
#line 1190
                if ((tmp___37 & 2147483647U) % 10U == 0U) {
                  {
#line 1191
                  fputs((char const   */* __restrict  */)"<P ALIGN=RIGHT>", (FILE */* __restrict  */)out___0);
                  }
                } else {
                  {
#line 1193
                  fputs((char const   */* __restrict  */)"<P>", (FILE */* __restrict  */)out___0);
                  }
                }
              }
            }
            {
#line 1195
            fputs((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out___0);
#line 1196
            fflush(out___0);
#line 1197
            column = 0;
#line 1198
            words = 0;
            }
#line 1199
            if (pause___0) {
              {
#line 1200
              sleep((unsigned int )pause___0);
              }
            }
          }
#line 1208
          if (sidebar_words < 0) {
#line 1208
            goto _L___4;
          } else
#line 1208
          if (sidebar_words == 1) {
            _L___4: /* CIL Label */ 
#line 1211
            sidebar_words = 0;
#line 1212
            i___2 = 0;
            {
#line 1212
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 1212
              if (! (i___2 < indent)) {
#line 1212
                goto while_break___6;
              }
              {
#line 1212
              fputs((char const   */* __restrict  */)"</UL>", (FILE */* __restrict  */)out___0);
#line 1212
              i___2 += 4;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
#line 1213
            i___2 = 0;
            {
#line 1213
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 1213
              if (! (i___2 < indent)) {
#line 1213
                goto while_break___7;
              }
              {
#line 1213
              fputs((char const   */* __restrict  */)"<UL>", (FILE */* __restrict  */)out___0);
#line 1213
              i___2 += 4;
              }
            }
            while_break___7: /* CIL Label */ ;
            }
          }
#line 1216
          if (html_p) {
#line 1216
            if (! sidebar_p) {
#line 1216
              if (sidebar_words <= 0) {
                {
#line 1216
                tmp___40 = ya_random();
                }
#line 1216
                if ((tmp___40 & 2147483647U) % 100U == 0U) {
                  {
#line 1221
                  tmp___39 = ya_random();
#line 1221
                  width = (int )(30U + (tmp___39 & 2147483647U) % 30U);
#line 1222
                  fprintf((FILE */* __restrict  */)out___0, (char const   */* __restrict  */)"<TABLE WIDTH=\"%d%%\" ALIGN=RIGHT BORDER=4 CELLPADDING=10 CELLSPACING=0><TR><TD>\n",
                          width);
#line 1226
                  sidebar_p = 1;
#line 1227
                  sidebar_words = 100;
                  }
                }
              }
            }
          }
        }
      }
      {
#line 1232
      tmp___42 = random_sentence(out___0, & column, indent, fill_column, html_p);
#line 1232
      sw___0 = tmp___42;
#line 1234
      fflush(out___0);
#line 1235
      words += sw___0;
#line 1236
      n ++;
      }
#line 1238
      if (sidebar_p) {
#line 1239
        sidebar_words += sw___0;
      } else
#line 1240
      if (sidebar_words > 1) {
#line 1242
        sidebar_words -= sw___0;
#line 1243
        if (sidebar_words == 0) {
#line 1244
          sidebar_words = 1;
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1249
    if (sidebar_p) {
      {
#line 1250
      fputs((char const   */* __restrict  */)"</TD></TR></TABLE>", (FILE */* __restrict  */)out___0);
      }
    }
#line 1251
    if (html_p) {
      {
#line 1252
      fputs((char const   */* __restrict  */)"<P>\n", (FILE */* __restrict  */)out___0);
      }
    } else {
      {
#line 1254
      fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)out___0);
      }
    }
  }
  {
#line 1257
  exit(0);
  }
}
}
