/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 107 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 120 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "/usr/include/asm-generic/int-ll64.h"
typedef short __s16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 47 "/usr/include/linux/joystick.h"
struct js_event {
   __u32 time ;
   __s16 value ;
   __u8 type ;
   __u8 number ;
};
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 108 "/usr/include/X11/X.h"
typedef unsigned char KeyCode;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_59 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_59 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_60 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_60 Depth;
#line 267
struct _XDisplay;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_61 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_61 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_62 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_62 ScreenFormat;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 502
struct _XPrivate;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_77 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_77 *_XPrivDisplay;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_78 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_78 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_79 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_79 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_80 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_80 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_81 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_82 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_82 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_83 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_83 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_84 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_84 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_85 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_85 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_86 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_86 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_87 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_87 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_88 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_88 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_89 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_89 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_90 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_90 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_91 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_91 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_92 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_92 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_93 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_93 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_94 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_94 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_95 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_95 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_96 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_96 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_97 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_97 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_98 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_98 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_99 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_99 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_100 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_100 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_101 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_101 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_102 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_102 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_103 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_103 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_104 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_104 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_106 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_105 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_106 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_105 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_107 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_107 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_108 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_108 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_109 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_109 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_110 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_110 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_111 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_111 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 139 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
enum __anonenum_target_type_145 {
    NONE = 0,
    X = 1,
    RAWCONSOLE = 2,
    TERMINAL = 3
} ;
#line 139 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
typedef enum __anonenum_target_type_145 target_type;
#line 140
enum __anonenum_press_or_release_type_146 {
    PRESS = 0,
    RELEASE = 1
} ;
#line 140 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
typedef enum __anonenum_press_or_release_type_146 press_or_release_type;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 131 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which ,
                                                                                struct itimerval  const  * __restrict  __new ,
                                                                                struct itimerval * __restrict  __old ) ;
#line 1495 "/usr/include/X11/Xlib.h"
extern Display *XOpenDisplay(char const   * ) ;
#line 1530
extern char *XKeysymToString(KeySym  ) ;
#line 1698
extern KeySym __attribute__((__deprecated__))  XKeycodeToKeysym(Display * , KeyCode  ,
                                                                int  ) ;
#line 1722
extern KeySym XStringToKeysym(char const   * ) ;
#line 2134
extern int XCheckWindowEvent(Display * , Window  , long  , XEvent * ) ;
#line 2519
extern int XFlush(Display * ) ;
#line 2528
extern int XFree(void * ) ;
#line 2785
extern KeyCode XKeysymToKeycode(Display * , KeySym  ) ;
#line 3029
extern int XQueryTree(Display * , Window  , Window * , Window * , Window ** , unsigned int * ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3147
extern int XSendEvent(Display * , Window  , int  , long  , XEvent * ) ;
#line 125 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
unsigned int button_actions[256]  ;
#line 126 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
int button_upper[256]  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
int jsfd  =    -1;
#line 127 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
int axis_actions[256][2]  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
int axis_threshold[256][2]  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
int axis_threshold_defined[256]  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
int axis_act_counter  =    0;
#line 127 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
int button_act_counter  =    0;
#line 127 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
int thresh_counter  =    0;
#line 127 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
int deadzone  =    50;
#line 135 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
char *device  =    (char *)"/dev/input/js0";
#line 135 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
char *rcfile  =    (char *)".joy2keyrc";
#line 135 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
char button_repeat_flags[256]  ;
#line 135 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
char common_read  =    (char)0;
#line 141 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
struct itimerval repeat_time  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
target_type target  =    (target_type )0;
#line 151 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
Display *thedisp  ;
#line 152 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
int thewindow  =    0;
#line 152 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
int thescreen  =    0;
#line 154
static Window RegisterCloseEvent(Display *disp , Window win ) ;
#line 155
static void CheckIfWindowClosed(Display *disp , Window parentwin , Window win ) ;
#line 159 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
int consolefd  ;
#line 162
void process_args(int argc , char **argv ) ;
#line 163
int check_config(int argc , char **argv ) ;
#line 165
void sendkey(unsigned int keycode , press_or_release_type PoR , int iscap ) ;
#line 166
void cleanup(int s ) ;
#line 167
void repeat_handler(int s ) ;
#line 168
void calibrate(int num ) ;
#line 169
int argtokey(char *arg ) ;
#line 171 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
int main(int argc , char **argv ) 
{ 
  int parentwin ;
  fd_set close_set ;
  FILE *foo ;
  char string[255] ;
  char axis_hold_flags[256] ;
  char numaxes ;
  char numbuttons ;
  struct js_event js ;
  int i ;
  struct timeval tv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  Window tmp___7 ;
  char const   *tmp___8 ;
  int __d0 ;
  int __d1 ;
  int tmp___9 ;

  {
  {
#line 174
  parentwin = 0;
#line 186
  puts("joy2key - reads joystick status and dispatches keyboard events");
#line 187
  puts("By Peter Amstutz (tetron@interreality.org)");
#line 188
  puts("This is free software under the GNU General Public License (GPL v2)");
#line 189
  puts("              (see COPYING in the joy2key archive)");
#line 190
  puts("You are welcome to use/modify this code, and please e-mail me");
#line 191
  puts("if anything cool comes of it!");
#line 192
  printf((char const   */* __restrict  */)"Version: %s   Binary built on %s at %s\n\n",
         "1.6.3", "Mar  4 2016", "14:54:10");
#line 195
  memset((void *)(axis_threshold), 0, sizeof(axis_threshold));
#line 196
  memset((void *)(axis_threshold_defined), 0, sizeof(axis_threshold_defined));
#line 197
  memset((void *)(axis_actions), 0, sizeof(axis_actions));
#line 198
  memset((void *)(button_actions), 0, sizeof(button_actions));
#line 199
  memset((void *)(button_upper), 0, sizeof(button_upper));
#line 200
  memset((void *)(button_repeat_flags), 0, sizeof(button_repeat_flags));
#line 201
  memset((void *)(axis_hold_flags), 0, sizeof(axis_hold_flags));
#line 202
  repeat_time.it_interval.tv_sec = (__time_t )0;
#line 203
  repeat_time.it_interval.tv_usec = (__suseconds_t )0;
#line 204
  repeat_time.it_value.tv_sec = (__time_t )0;
#line 205
  repeat_time.it_value.tv_usec = (__suseconds_t )0;
#line 207
  argc = check_config(argc, argv);
#line 208
  process_args(argc, argv);
#line 210
  jsfd = open((char const   *)device, 0);
  }
#line 210
  if (jsfd == -1) {
    {
#line 212
    printf((char const   */* __restrict  */)"Error opening %s!\n", device);
#line 213
    puts("Are you sure you have joystick support in your kernel?");
    }
#line 214
    return (1);
  }
  {
#line 216
  tmp = ioctl(jsfd, (unsigned long )(((2U << 30) | (unsigned int )(106 << 8)) | 17U) | (sizeof(__u8 ) << 16),
              & numaxes);
  }
#line 216
  if (tmp) {
    {
#line 219
    perror("joy2key: error getting axes");
    }
#line 220
    return (1);
  }
  {
#line 222
  tmp___0 = ioctl(jsfd, (unsigned long )(((2U << 30) | (unsigned int )(106 << 8)) | 18U) | (sizeof(__u8 ) << 16),
                  & numbuttons);
  }
#line 222
  if (tmp___0) {
    {
#line 223
    perror("joy2key: error getting buttons");
    }
#line 224
    return (1);
  }
#line 227
  if ((int )numaxes < axis_act_counter) {
    {
#line 227
    puts("More axes specificed than joystick has!");
    }
  }
#line 228
  if ((int )numbuttons < button_act_counter) {
    {
#line 228
    puts("More buttons specificed than joystick has!");
    }
  }
  {
#line 233
  if ((unsigned int )target == 1U) {
#line 233
    goto case_1;
  }
#line 267
  if ((unsigned int )target == 3U) {
#line 267
    goto case_3;
  }
#line 267
  if ((unsigned int )target == 2U) {
#line 267
    goto case_3;
  }
#line 281
  goto switch_default;
  case_1: /* CIL Label */ 
#line 234
  thescreen = ((_XPrivDisplay )thedisp)->default_screen;
#line 235
  if (argc == 1) {
    {
#line 237
    puts("Please select a window to send events to");
#line 238
    sprintf((char */* __restrict  */)(string), (char const   */* __restrict  */)"xwininfo");
    }
  } else
#line 235
  if ((int )*(*(argv + 1) + 0) == 45) {
    {
#line 237
    puts("Please select a window to send events to");
#line 238
    sprintf((char */* __restrict  */)(string), (char const   */* __restrict  */)"xwininfo");
    }
  } else {
    {
#line 241
    sprintf((char */* __restrict  */)(string), (char const   */* __restrict  */)"xwininfo -name \"%s\"",
            *(argv + 1));
    }
  }
  {
#line 243
  foo = popen((char const   *)(string), "r");
  }
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 244
    tmp___1 = feof(foo);
    }
#line 244
    if (tmp___1) {
#line 244
      goto while_break;
    } else {
      {
#line 244
      tmp___2 = fgets((char */* __restrict  */)(string), 255, (FILE */* __restrict  */)foo);
      }
#line 244
      if (tmp___2) {
        {
#line 244
        tmp___3 = sscanf((char const   */* __restrict  */)(string), (char const   */* __restrict  */)"xwininfo: Window id: %x",
                         & thewindow);
        }
#line 244
        if (! (tmp___3 != 1)) {
#line 244
          goto while_break;
        }
      } else {
#line 244
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  pclose(foo);
  }
#line 248
  if (thewindow == 0) {
    {
#line 250
    sprintf((char */* __restrict  */)(string), (char const   */* __restrict  */)"xwininfo -id \"%s\"",
            *(argv + 1));
#line 251
    foo = popen((char const   *)(string), "r");
    }
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 252
      tmp___4 = feof(foo);
      }
#line 252
      if (tmp___4) {
#line 252
        goto while_break___0;
      } else {
        {
#line 252
        tmp___5 = fgets((char */* __restrict  */)(string), 255, (FILE */* __restrict  */)foo);
        }
#line 252
        if (tmp___5) {
          {
#line 252
          tmp___6 = sscanf((char const   */* __restrict  */)(string), (char const   */* __restrict  */)"xwininfo: Window id: %x",
                           & thewindow);
          }
#line 252
          if (! (tmp___6 != 1)) {
#line 252
            goto while_break___0;
          }
        } else {
#line 252
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 254
    pclose(foo);
    }
#line 255
    if (thewindow == 0) {
      {
#line 257
      puts("Error!  Can\'t find window to send events to!");
      }
#line 258
      return (1);
    }
  }
  {
#line 261
  tmp___7 = RegisterCloseEvent(thedisp, (Window )thewindow);
#line 261
  parentwin = (int )tmp___7;
#line 262
  XFlush(thedisp);
  }
#line 263
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 268
  if ((int )*(*(argv + 1) + 0) == 47) {
    {
#line 270
    strcpy((char */* __restrict  */)(string), (char const   */* __restrict  */)*(argv + 1));
    }
  } else {
#line 272
    if ((int )*(*(argv + 1) + 0) == 45) {
#line 272
      tmp___8 = "";
    } else {
#line 272
      tmp___8 = (char const   *)*(argv + 1);
    }
    {
#line 272
    sprintf((char */* __restrict  */)(string), (char const   */* __restrict  */)"/dev/tty%s",
            tmp___8);
    }
  }
  {
#line 274
  consolefd = open((char const   *)(string), 0, 0);
  }
#line 274
  if (consolefd < 0) {
    {
#line 276
    printf((char const   */* __restrict  */)"Can\'t open %s\n", string);
    }
#line 277
    return (1);
  }
#line 279
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 282
  puts("Must specify a target!");
#line 283
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 286
  i = 0;
  {
#line 286
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 286
    if (! (i < (int )numaxes)) {
#line 286
      goto while_break___1;
    }
#line 288
    if (! axis_threshold_defined[i]) {
      {
#line 289
      calibrate(i);
      }
    }
#line 286
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 292
  memset((void *)(& js), 0, sizeof(struct js_event ));
#line 294
  signal(2, & cleanup);
#line 295
  signal(15, & cleanup);
  }
#line 296
  if (repeat_time.it_interval.tv_usec) {
    {
#line 298
    signal(14, & repeat_handler);
#line 299
    repeat_time.it_value.tv_usec = repeat_time.it_interval.tv_usec;
#line 300
    setitimer(0, (struct itimerval  const  */* __restrict  */)(& repeat_time), (struct itimerval */* __restrict  */)((void *)0));
    }
  }
  {
#line 303
  puts("Initialization complete, entering main loop, ^C to exit...");
  }
  {
#line 306
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 308
    memset((void *)(& js), 0, sizeof(struct js_event ));
    }
    {
#line 310
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 322
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 322
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& close_set.__fds_bits[0]): "memory");
#line 322
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 323
      close_set.__fds_bits[jsfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << jsfd % (8 * (int )sizeof(__fd_mask ));
#line 324
      tv.tv_sec = (__time_t )0;
#line 325
      tv.tv_usec = (__suseconds_t )200000;
#line 326
      select(jsfd + 1, (fd_set */* __restrict  */)(& close_set), (fd_set */* __restrict  */)((void *)0),
             (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 327
      if ((unsigned int )target == 1U) {
        {
#line 327
        CheckIfWindowClosed(thedisp, (Window )parentwin, (Window )thewindow);
        }
      }
#line 310
      if (! (! ((close_set.__fds_bits[jsfd / (8 * (int )sizeof(__fd_mask ))] & (1L << jsfd % (8 * (int )sizeof(__fd_mask )))) != 0L))) {
#line 310
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 331
    read(jsfd, (void *)(& js), sizeof(struct js_event ));
    }
    {
#line 336
    if ((int )js.type == 1) {
#line 336
      goto case_1___0;
    }
#line 344
    if ((int )js.type == 2) {
#line 344
      goto case_2___0;
    }
#line 334
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 337
    if (button_actions[js.number]) {
#line 339
      button_repeat_flags[js.number] = (char )js.value;
#line 340
      if (js.value) {
#line 340
        tmp___9 = 0;
      } else {
#line 340
        tmp___9 = 1;
      }
      {
#line 340
      sendkey(button_actions[js.number], (press_or_release_type )tmp___9, button_upper[js.number]);
      }
    }
#line 343
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 345
    if (axis_actions[js.number][0]) {
#line 345
      goto _L;
    } else
#line 345
    if (axis_actions[js.number][1]) {
      _L: /* CIL Label */ 
#line 347
      if (axis_hold_flags[js.number]) {
        {
#line 351
        if ((int )axis_hold_flags[js.number] == 1) {
#line 351
          goto case_1___1;
        }
#line 355
        if ((int )axis_hold_flags[js.number] == 2) {
#line 355
          goto case_2___1;
        }
#line 349
        goto switch_break___1;
        case_1___1: /* CIL Label */ 
#line 352
        if ((int )js.value > axis_threshold[js.number][0]) {
          {
#line 353
          sendkey((unsigned int )axis_actions[js.number][0], (press_or_release_type )1,
                  0);
          }
        }
#line 354
        goto switch_break___1;
        case_2___1: /* CIL Label */ 
#line 356
        if ((int )js.value < axis_threshold[js.number][1]) {
          {
#line 357
          sendkey((unsigned int )axis_actions[js.number][1], (press_or_release_type )1,
                  0);
          }
        }
#line 358
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 360
        axis_hold_flags[js.number] = (char)0;
      }
#line 362
      if ((int )js.value < axis_threshold[js.number][0]) {
#line 364
        if (! axis_actions[js.number][0]) {
#line 364
          goto switch_break___0;
        }
        {
#line 365
        sendkey((unsigned int )axis_actions[js.number][0], (press_or_release_type )0,
                0);
#line 366
        axis_hold_flags[js.number] = (char)1;
        }
      }
#line 368
      if ((int )js.value > axis_threshold[js.number][1]) {
#line 370
        if (! axis_actions[js.number][1]) {
#line 370
          goto switch_break___0;
        }
        {
#line 371
        sendkey((unsigned int )axis_actions[js.number][1], (press_or_release_type )0,
                0);
#line 372
        axis_hold_flags[js.number] = (char)2;
        }
      }
    }
#line 375
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 378
    if ((unsigned int )target == 1U) {
      {
#line 378
      XFlush(thedisp);
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
int check_config(int argc , char **argv ) 
{ 
  int i ;
  int x ;
  int f ;
  FILE *file ;
  int rcargc ;
  char *rcargv[255] ;
  char line[255] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;

  {
#line 385
  f = 0;
#line 390
  i = 1;
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i < argc)) {
#line 390
      goto while_break;
    }
    {
#line 392
    tmp___6 = strcmp("-rcfile", (char const   *)*(argv + i));
    }
#line 392
    if (! tmp___6) {
#line 394
      if (i + 2 > argc) {
        {
#line 396
        puts("Not enough arguments to -rcfile");
#line 397
        exit(1);
        }
      }
      {
#line 399
      file = fopen((char const   */* __restrict  */)*(argv + (i + 1)), (char const   */* __restrict  */)"r");
      }
#line 399
      if ((unsigned long )file == (unsigned long )((void *)0)) {
        {
#line 401
        printf((char const   */* __restrict  */)"Cannot open rc file \"%s\"\n", *(argv + (i + 1)));
#line 402
        exit(1);
        }
      }
      {
#line 404
      fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %s ",
             line);
      }
      {
#line 405
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 405
        tmp___5 = feof(file);
        }
#line 405
        if (tmp___5) {
#line 405
          goto while_break___0;
        }
        {
#line 407
        tmp___4 = strcmp((char const   *)(line), "COMMON");
        }
#line 407
        if (! tmp___4) {
          {
#line 409
          fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %s ",
                 line);
#line 410
          rcargc = 1;
          }
          {
#line 410
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 410
            tmp___0 = strcmp((char const   *)(line), "START");
            }
#line 410
            if (tmp___0) {
              {
#line 410
              tmp___1 = strcmp((char const   *)(line), "COMMON");
              }
#line 410
              if (tmp___1) {
                {
#line 410
                tmp___2 = feof(file);
                }
#line 410
                if (tmp___2) {
#line 410
                  goto while_break___1;
                }
              } else {
#line 410
                goto while_break___1;
              }
            } else {
#line 410
              goto while_break___1;
            }
#line 413
            if ((int )line[0] == 35) {
              {
#line 415
              while (1) {
                while_continue___2: /* CIL Label */ ;
                {
#line 415
                tmp = fgetc(file);
                }
#line 415
                if (! (tmp != 10)) {
#line 415
                  goto while_break___2;
                }
              }
              while_break___2: /* CIL Label */ ;
              }
#line 416
              rcargc --;
            } else {
              {
#line 418
              rcargv[rcargc] = strdup((char const   *)(line));
              }
            }
            {
#line 419
            fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %s ",
                   line);
#line 410
            rcargc ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 421
          tmp___3 = feof(file);
          }
#line 421
          if (tmp___3) {
            {
#line 422
            rcargv[rcargc] = strdup((char const   *)(line));
#line 423
            rcargc ++;
            }
          }
          {
#line 425
          process_args(rcargc, rcargv);
#line 426
          rcargc --;
          }
          {
#line 426
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 426
            if (! (rcargc > 0)) {
#line 426
              goto while_break___3;
            }
            {
#line 426
            free((void *)rcargv[rcargc]);
#line 426
            rcargc --;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        {
#line 428
        fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %s ",
               line);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 430
      fclose(file);
#line 431
      common_read = (char)1;
#line 432
      rcfile = *(argv + (i + 1));
#line 433
      argc -= 2;
#line 434
      x = i;
      }
      {
#line 434
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 434
        if (! (x < argc)) {
#line 434
          goto while_break___4;
        }
#line 434
        *(argv + x) = *(argv + (x + 2));
#line 434
        x ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 436
    tmp___28 = strcmp("-config", (char const   *)*(argv + i));
    }
#line 436
    if (! tmp___28) {
#line 438
      if (i + 2 > argc) {
        {
#line 440
        puts("Not enough arguments to -config");
#line 441
        exit(1);
        }
      }
      {
#line 443
      tmp___12 = strcmp((char const   *)rcfile, ".joy2keyrc");
      }
#line 443
      if (tmp___12 == 0) {
        {
#line 445
        tmp___7 = getenv("HOME");
#line 445
        tmp___8 = strlen((char const   *)tmp___7);
#line 445
        tmp___9 = strlen((char const   *)rcfile);
#line 445
        x = (int )((tmp___8 + tmp___9) + 2UL);
#line 446
        tmp___10 = malloc((size_t )x);
#line 446
        rcfile = (char *)tmp___10;
#line 447
        tmp___11 = getenv("HOME");
#line 447
        sprintf((char */* __restrict  */)rcfile, (char const   */* __restrict  */)"%s/%s",
                tmp___11, ".joy2keyrc");
        }
      }
      {
#line 449
      file = fopen((char const   */* __restrict  */)rcfile, (char const   */* __restrict  */)"r");
      }
#line 449
      if ((unsigned long )file == (unsigned long )((void *)0)) {
        {
#line 451
        printf((char const   */* __restrict  */)"Cannot open rc file \"%s\"\n", rcfile);
#line 452
        exit(1);
        }
      }
#line 454
      if (! common_read) {
        {
#line 456
        fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %s ",
               line);
        }
        {
#line 457
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 457
          tmp___19 = feof(file);
          }
#line 457
          if (tmp___19) {
#line 457
            goto while_break___5;
          }
          {
#line 459
          tmp___18 = strcmp((char const   *)(line), "COMMON");
          }
#line 459
          if (! tmp___18) {
            {
#line 461
            fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %s ",
                   line);
#line 462
            rcargc = 1;
            }
            {
#line 462
            while (1) {
              while_continue___6: /* CIL Label */ ;
              {
#line 462
              tmp___14 = strcmp((char const   *)(line), "START");
              }
#line 462
              if (tmp___14) {
                {
#line 462
                tmp___15 = strcmp((char const   *)(line), "COMMON");
                }
#line 462
                if (tmp___15) {
                  {
#line 462
                  tmp___16 = feof(file);
                  }
#line 462
                  if (tmp___16) {
#line 462
                    goto while_break___6;
                  }
                } else {
#line 462
                  goto while_break___6;
                }
              } else {
#line 462
                goto while_break___6;
              }
#line 465
              if ((int )line[0] == 35) {
                {
#line 467
                while (1) {
                  while_continue___7: /* CIL Label */ ;
                  {
#line 467
                  tmp___13 = fgetc(file);
                  }
#line 467
                  if (! (tmp___13 != 10)) {
#line 467
                    goto while_break___7;
                  }
                }
                while_break___7: /* CIL Label */ ;
                }
#line 468
                rcargc --;
              } else {
                {
#line 470
                rcargv[rcargc] = strdup((char const   *)(line));
                }
              }
              {
#line 471
              fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %s ",
                     line);
#line 462
              rcargc ++;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 473
            tmp___17 = feof(file);
            }
#line 473
            if (tmp___17) {
              {
#line 474
              rcargv[rcargc] = strdup((char const   *)(line));
#line 475
              rcargc ++;
              }
            }
            {
#line 478
            process_args(rcargc, rcargv);
#line 479
            rcargc --;
            }
            {
#line 479
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 479
              if (! (rcargc > 0)) {
#line 479
                goto while_break___8;
              }
              {
#line 479
              free((void *)rcargv[rcargc]);
#line 479
              rcargc --;
              }
            }
            while_break___8: /* CIL Label */ ;
            }
          }
          {
#line 481
          fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %s ",
                 line);
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 483
        rewind(file);
#line 484
        common_read = (char)1;
        }
      }
      {
#line 486
      fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %s ",
             line);
      }
      {
#line 487
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 487
        tmp___27 = feof(file);
        }
#line 487
        if (tmp___27) {
#line 487
          goto while_break___9;
        }
        {
#line 489
        tmp___26 = strcmp((char const   *)(line), "START");
        }
#line 489
        if (! tmp___26) {
          {
#line 491
          fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %s ",
                 line);
#line 492
          tmp___25 = strcmp((char const   *)(line), (char const   *)*(argv + (i + 1)));
          }
#line 492
          if (! tmp___25) {
            {
#line 494
            f = 1;
#line 495
            fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %s ",
                   line);
#line 496
            rcargc = 1;
            }
            {
#line 496
            while (1) {
              while_continue___10: /* CIL Label */ ;
              {
#line 496
              tmp___21 = strcmp((char const   *)(line), "START");
              }
#line 496
              if (tmp___21) {
                {
#line 496
                tmp___22 = strcmp((char const   *)(line), "COMMON");
                }
#line 496
                if (tmp___22) {
                  {
#line 496
                  tmp___23 = feof(file);
                  }
#line 496
                  if (tmp___23) {
#line 496
                    goto while_break___10;
                  }
                } else {
#line 496
                  goto while_break___10;
                }
              } else {
#line 496
                goto while_break___10;
              }
#line 499
              if ((int )line[0] == 35) {
                {
#line 501
                while (1) {
                  while_continue___11: /* CIL Label */ ;
                  {
#line 501
                  tmp___20 = fgetc(file);
                  }
#line 501
                  if (! (tmp___20 != 10)) {
#line 501
                    goto while_break___11;
                  }
                }
                while_break___11: /* CIL Label */ ;
                }
#line 502
                rcargc --;
              } else {
                {
#line 504
                rcargv[rcargc] = strdup((char const   *)(line));
                }
              }
              {
#line 505
              fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %s ",
                     line);
#line 496
              rcargc ++;
              }
            }
            while_break___10: /* CIL Label */ ;
            }
            {
#line 507
            tmp___24 = feof(file);
            }
#line 507
            if (tmp___24) {
              {
#line 508
              rcargv[rcargc] = strdup((char const   *)(line));
#line 509
              rcargc ++;
              }
            }
            {
#line 512
            process_args(rcargc, rcargv);
#line 513
            rcargc --;
            }
            {
#line 513
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 513
              if (! (rcargc > 0)) {
#line 513
                goto while_break___12;
              }
              {
#line 513
              free((void *)rcargv[rcargc]);
#line 513
              rcargc --;
              }
            }
            while_break___12: /* CIL Label */ ;
            }
          }
        }
        {
#line 516
        fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %s ",
               line);
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 518
      fclose(file);
      }
#line 519
      if (! f) {
        {
#line 521
        printf((char const   */* __restrict  */)"Can\'t find config \"%s\"\n", *(argv + (i + 1)));
#line 522
        exit(1);
        }
      }
#line 524
      argc -= 2;
#line 525
      x = i;
      {
#line 525
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 525
        if (! (x < argc)) {
#line 525
          goto while_break___13;
        }
#line 525
        *(argv + x) = *(argv + (x + 2));
#line 525
        x ++;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 390
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 528
  return (argc);
}
}
#line 531 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
void process_args(int argc , char **argv ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 535
  if (! *(argv + 1)) {
#line 535
    return;
  }
#line 536
  if (argc == 1) {
#line 536
    i = 1;
  } else
#line 536
  if ((int )*(*(argv + 1) + 0) == 45) {
#line 536
    i = 1;
  } else {
#line 536
    i = 2;
  }
  {
#line 536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 536
    if (! (i < argc)) {
#line 536
      goto while_break;
    }
    {
#line 538
    tmp = strcmp((char const   *)*(argv + i), "-axis");
    }
#line 538
    if (! tmp) {
#line 540
      if ((unsigned int )target == 0U) {
        {
#line 542
        puts("Must specify a target first!");
#line 543
        exit(1);
        }
      }
#line 545
      if (i + 1 == argc) {
        {
#line 547
        puts("Not enough arguments to -axis");
#line 548
        exit(1);
        }
      }
#line 550
      axis_act_counter = 0;
      {
#line 551
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 551
        if (i + 1 < argc) {
#line 551
          if (! ((int )*(*(argv + (i + 1)) + 0) != 45)) {
#line 551
            goto while_break___0;
          }
        } else {
#line 551
          goto while_break___0;
        }
#line 553
        if (i + 2 == argc) {
          {
#line 555
          puts("Not enough arguments to -axis");
#line 556
          exit(1);
          }
        }
        {
#line 558
        i ++;
#line 559
        axis_actions[axis_act_counter][0] = argtokey(*(argv + i));
#line 560
        i ++;
#line 560
        axis_actions[axis_act_counter][1] = argtokey(*(argv + i));
#line 561
        axis_act_counter ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 563
      goto __Cont;
    }
    {
#line 565
    tmp___3 = strcmp((char const   *)*(argv + i), "-buttons");
    }
#line 565
    if (! tmp___3) {
#line 567
      if ((unsigned int )target == 0U) {
        {
#line 569
        puts("Must specify a target first!");
#line 570
        exit(1);
        }
      }
#line 573
      if (i + 1 == argc) {
        {
#line 575
        puts("Not enough arguments to -buttons");
#line 576
        exit(1);
        }
      }
#line 578
      button_act_counter = 0;
      {
#line 579
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 579
        if (i + 1 < argc) {
#line 579
          if (! ((int )*(*(argv + (i + 1)) + 0) != 45)) {
#line 579
            if ((int )*(*(argv + (i + 1)) + 0) == 45) {
#line 579
              if (! (! *(*(argv + (i + 1)) + 1))) {
#line 579
                goto while_break___1;
              }
            } else {
#line 579
              goto while_break___1;
            }
          }
        } else {
#line 579
          goto while_break___1;
        }
        {
#line 582
        i ++;
#line 582
        tmp___0 = argtokey(*(argv + i));
#line 582
        button_actions[button_act_counter] = (unsigned int )tmp___0;
#line 583
        printf((char const   */* __restrict  */)"arg2key fed with %s ", *(argv + i));
#line 586
        button_upper[button_act_counter] = 0;
#line 587
        tmp___1 = strlen((char const   *)*(argv + i));
        }
#line 587
        if (tmp___1 == 1UL) {
          {
#line 587
          tmp___2 = __ctype_b_loc();
          }
#line 587
          if ((int const   )*(*tmp___2 + (int )*(*(argv + i) + 0)) & 256) {
            {
#line 589
            button_upper[button_act_counter] = 1;
#line 590
            printf((char const   */* __restrict  */)"%s is a upper => %d\n", *(argv + i),
                   button_upper[button_act_counter]);
            }
          } else {
            {
#line 594
            printf((char const   */* __restrict  */)"%s is a lower => %d\n", *(argv + i),
                   button_upper[button_act_counter]);
            }
          }
        } else {
          {
#line 594
          printf((char const   */* __restrict  */)"%s is a lower => %d\n", *(argv + i),
                 button_upper[button_act_counter]);
          }
        }
#line 596
        button_act_counter ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 598
      goto __Cont;
    }
    {
#line 600
    tmp___6 = strcmp((char const   *)*(argv + i), "-thresh");
    }
#line 600
    if (! tmp___6) {
#line 602
      if (i + 1 == argc) {
        {
#line 604
        puts("Not enough arguments to -thresh");
#line 605
        exit(1);
        }
      }
      {
#line 607
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 607
        if (i + 1 < argc) {
#line 607
          if (! ((int )*(*(argv + (i + 1)) + 0) != 45)) {
#line 607
            if ((int )*(*(argv + (i + 1)) + 0) == 45) {
              {
#line 607
              tmp___5 = __ctype_b_loc();
              }
#line 607
              if (! ((int const   )*(*tmp___5 + (int )*(*(argv + (i + 1)) + 1)) & 2048)) {
#line 607
                goto while_break___2;
              }
            } else {
#line 607
              goto while_break___2;
            }
          }
        } else {
#line 607
          goto while_break___2;
        }
#line 611
        i ++;
#line 612
        if (i + 1 == argc) {
          {
#line 614
          puts("Not enough arguments to -thresh");
#line 615
          exit(1);
          }
        }
#line 617
        if ((int )*(*(argv + i) + 0) != 120) {
#line 617
          if ((int )*(*(argv + (i + 1)) + 1) != 120) {
#line 618
            axis_threshold_defined[thresh_counter] = 1;
          }
        }
        {
#line 619
        axis_threshold[thresh_counter][0] = atoi((char const   *)*(argv + i));
#line 620
        tmp___4 = thresh_counter;
#line 620
        thresh_counter ++;
#line 620
        i ++;
#line 620
        axis_threshold[tmp___4][1] = atoi((char const   *)*(argv + i));
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 622
      goto __Cont;
    }
    {
#line 624
    tmp___8 = strcmp((char const   *)*(argv + i), "-autorepeat");
    }
#line 624
    if (! tmp___8) {
#line 626
      if (i + 1 == argc) {
#line 628
        repeat_time.it_interval.tv_usec = (__suseconds_t )200000;
#line 629
        goto __Cont;
      } else
#line 626
      if ((int )*(*(argv + (i + 1)) + 0) == 45) {
#line 628
        repeat_time.it_interval.tv_usec = (__suseconds_t )200000;
#line 629
        goto __Cont;
      }
      {
#line 631
      i ++;
#line 631
      tmp___7 = atoi((char const   *)*(argv + i));
#line 631
      repeat_time.it_interval.tv_usec = (__suseconds_t )tmp___7;
      }
#line 631
      if (repeat_time.it_interval.tv_usec == 0L) {
        {
#line 633
        puts("Invalid autorepeat frequency, using default");
#line 634
        repeat_time.it_interval.tv_usec = (__suseconds_t )200000;
        }
      }
#line 636
      if (repeat_time.it_interval.tv_usec > 50L) {
        {
#line 638
        repeat_time.it_interval.tv_usec = (__suseconds_t )20000;
#line 639
        printf((char const   */* __restrict  */)"Set to maximum 50 times / second.\n");
        }
      }
#line 641
      repeat_time.it_interval.tv_usec = 1000000L / repeat_time.it_interval.tv_usec;
#line 643
      goto __Cont;
    }
    {
#line 645
    tmp___9 = strcmp((char const   *)*(argv + i), "-deadzone");
    }
#line 645
    if (! tmp___9) {
#line 647
      if (i + 1 == argc) {
        {
#line 649
        puts("Not enough arguments to -deadzone");
#line 650
        exit(1);
        }
#line 651
        goto __Cont;
      } else
#line 647
      if ((int )*(*(argv + (i + 1)) + 0) == 45) {
        {
#line 649
        puts("Not enough arguments to -deadzone");
#line 650
        exit(1);
        }
#line 651
        goto __Cont;
      }
      {
#line 653
      i ++;
#line 653
      deadzone = atoi((char const   *)*(argv + i));
      }
#line 653
      if (deadzone == 0) {
        {
#line 655
        puts("Invalid deadzone setting, using default");
#line 656
        deadzone = 50;
        }
      }
#line 658
      if (deadzone > 99) {
        {
#line 660
        deadzone = 99;
#line 661
        puts("Set to maximum 99%");
        }
      }
#line 663
      if (deadzone < 1) {
        {
#line 665
        deadzone = 1;
#line 666
        puts("Set to minimum 1%");
        }
      }
#line 668
      goto __Cont;
    }
    {
#line 671
    tmp___10 = strcmp((char const   *)*(argv + i), "-dev");
    }
#line 671
    if (! tmp___10) {
#line 673
      if (i + 1 == argc) {
        {
#line 675
        puts("Not enough arguments to -dev");
#line 676
        exit(1);
        }
      }
      {
#line 678
      i ++;
#line 678
      device = strdup((char const   *)*(argv + i));
      }
#line 679
      goto __Cont;
    }
    {
#line 683
    tmp___11 = strcmp((char const   *)*(argv + i), "-rawconsole");
    }
#line 683
    if (! tmp___11) {
#line 685
      target = (target_type )2;
#line 686
      goto __Cont;
    }
    {
#line 688
    tmp___12 = strcmp((char const   *)*(argv + i), "-terminal");
    }
#line 688
    if (! tmp___12) {
#line 690
      target = (target_type )3;
#line 691
      goto __Cont;
    }
    {
#line 695
    tmp___13 = strcmp((char const   *)*(argv + i), "-X");
    }
#line 695
    if (! tmp___13) {
      {
#line 697
      target = (target_type )1;
#line 698
      thedisp = XOpenDisplay((char const   *)((void *)0));
      }
#line 699
      if ((unsigned long )thedisp == (unsigned long )((void *)0)) {
        {
#line 701
        puts("Error opening X Display");
#line 702
        exit(1);
        }
      }
#line 704
      goto __Cont;
    }
    {
#line 707
    printf((char const   */* __restrict  */)"Unknown option %s\n", *(argv + i));
#line 708
    puts("Usage: joy2key [\"Window Name\"]");
#line 710
    printf((char const   */* __restrict  */)"       [ -rawconsole ]");
#line 711
    printf((char const   */* __restrict  */)"\n       [ -terminal ]");
#line 714
    printf((char const   */* __restrict  */)"\n       [ -X ]");
#line 716
    printf((char const   */* __restrict  */)"\n       [ -axis [(axis0) low hi] [(axis1) low hi]  ... ]");
#line 717
    printf((char const   */* __restrict  */)"\n       [ -thresh [(axis0) low hi] [(axis1) low hi]  ... ]");
#line 718
    printf((char const   */* __restrict  */)"\n       [ -buttons [(button0)] [(button1)] [(button2)] ... ]");
#line 719
    printf((char const   */* __restrict  */)"\n       [ -dev {%s} ]", "/dev/input/js0");
#line 720
    printf((char const   */* __restrict  */)"\n       [ -rcfile {%s} ]", ".joy2keyrc");
#line 721
    printf((char const   */* __restrict  */)"\n       [ -config {no default} ]");
#line 722
    printf((char const   */* __restrict  */)"\n       [ -autorepeat {(freq) %i} ]",
           5);
#line 723
    printf((char const   */* __restrict  */)"\n       [ -deadzone {(percent) %i} ]",
           50);
#line 725
    puts("\n\nnote: [] denotes `optional\' option or argument,");
#line 726
    puts("      () hints at the wanted arguments for options");
#line 727
    puts("      {} denotes default (compiled-in) parameters");
#line 728
    exit(1);
    }
    __Cont: /* CIL Label */ 
#line 536
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 732
  return;
}
}
#line 734 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
void calibrate(int num ) 
{ 
  struct js_event js ;
  int joymid ;

  {
  {
#line 737
  joymid = 0;
#line 739
  printf((char const   */* __restrict  */)"\nCalibrating axis %i\n", num);
#line 740
  printf((char const   */* __restrict  */)"Please center the axis and press a button.\n?");
#line 741
  fflush(stdout);
  }
  {
#line 742
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 744
    read(jsfd, (void *)(& js), sizeof(struct js_event ));
    }
#line 745
    if ((int )js.type == 2) {
#line 745
      if ((int )js.number == num) {
        {
#line 747
        joymid = (int )js.value;
#line 748
        printf((char const   */* __restrict  */)"\rvalue: %i   ", joymid);
#line 749
        fflush(stdout);
        }
      }
    }
#line 742
    if (! ((int )js.type != 1)) {
#line 742
      if ((int )js.type == 1) {
#line 742
        if (! ((int )js.value == 0)) {
#line 742
          goto while_break;
        }
      } else {
#line 742
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 752
  printf((char const   */* __restrict  */)"\nLocked at %i", joymid);
#line 753
  printf((char const   */* __restrict  */)"\nPlease move the axis to its lowest position and press a button.\n?");
#line 754
  fflush(stdout);
  }
  {
#line 755
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 757
    read(jsfd, (void *)(& js), sizeof(struct js_event ));
    }
#line 758
    if ((int )js.type == 2) {
#line 758
      if ((int )js.number == num) {
        {
#line 760
        axis_threshold[num][0] = (int )js.value;
#line 761
        printf((char const   */* __restrict  */)"\rvalue: %i   ", axis_threshold[num][0]);
#line 762
        fflush(stdout);
        }
      }
    }
#line 755
    if (! ((int )js.type != 1)) {
#line 755
      if ((int )js.type == 1) {
#line 755
        if (! ((int )js.value == 0)) {
#line 755
          goto while_break___0;
        }
      } else {
#line 755
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 765
  printf((char const   */* __restrict  */)"\nPlease move the axis to its highest position and press a button.\n?");
#line 766
  fflush(stdout);
  }
  {
#line 767
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 769
    read(jsfd, (void *)(& js), sizeof(struct js_event ));
    }
#line 770
    if ((int )js.type == 2) {
#line 770
      if ((int )js.number == num) {
        {
#line 772
        axis_threshold[num][1] = (int )js.value;
#line 773
        printf((char const   */* __restrict  */)"\rvalue: %i   ", axis_threshold[num][1]);
#line 774
        fflush(stdout);
        }
      }
    }
#line 767
    if (! ((int )js.type != 1)) {
#line 767
      if ((int )js.type == 1) {
#line 767
        if (! ((int )js.value == 0)) {
#line 767
          goto while_break___1;
        }
      } else {
#line 767
        goto while_break___1;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 777
  printf((char const   */* __restrict  */)"\nUsing deadzone of %i%%\n", deadzone);
#line 778
  axis_threshold[num][0] = (int )((double )joymid + (double )(axis_threshold[num][0] - joymid) * ((double )deadzone / 100.0));
#line 779
  axis_threshold[num][1] = (int )((double )joymid + (double )(axis_threshold[num][1] - joymid) * ((double )deadzone / 100.0));
#line 780
  axis_threshold_defined[num] = 1;
#line 781
  puts("Calibrations set at:");
#line 782
  printf((char const   */* __restrict  */)"Axis %i low threshold set at %i\n", num,
         axis_threshold[num][0]);
#line 783
  printf((char const   */* __restrict  */)"Axis %i high threshold set at %i\n", num,
         axis_threshold[num][1]);
#line 784
  puts("(you can put these in your .joy2keyrc to avoid calibrating in the future)");
  }
#line 785
  return;
}
}
#line 787 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
int argtokey(char *arg ) 
{ 
  int ret ;
  KeySym tmp ;
  KeySym tmp___0 ;
  char *tmp___1 ;
  KeySym tmp___2 ;
  KeyCode tmp___3 ;

  {
  {
#line 793
  if ((unsigned int )target == 1U) {
#line 793
    goto case_1;
  }
#line 802
  if ((unsigned int )target == 3U) {
#line 802
    goto case_3;
  }
#line 802
  if ((unsigned int )target == 2U) {
#line 802
    goto case_3;
  }
#line 790
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 794
  tmp = XStringToKeysym((char const   *)arg);
#line 794
  ret = (int )tmp;
  }
#line 794
  if ((long )ret == 0L) {
    {
#line 795
    printf((char const   */* __restrict  */)"argtokey:Can\'t find %s, check include/X11/keysymdef.h\n",
           arg);
    }
  }
  {
#line 796
  tmp___0 = XStringToKeysym((char const   *)arg);
#line 796
  tmp___1 = XKeysymToString(tmp___0);
#line 796
  printf((char const   */* __restrict  */)"argtokey:read key %s dblcheck %s\n", arg,
         tmp___1);
#line 797
  tmp___2 = XStringToKeysym((char const   *)arg);
#line 797
  tmp___3 = XKeysymToKeycode(thedisp, tmp___2);
#line 797
  ret = (int )tmp___3;
  }
#line 798
  return (ret);
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 803
  if (*(arg + 1)) {
    {
#line 805
    sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%i",
           & ret);
    }
  } else {
#line 809
    ret = (int )*(arg + 0);
  }
#line 811
  return (ret);
  switch_break: /* CIL Label */ ;
  }
#line 814
  return (0);
}
}
#line 817 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
void repeat_handler(int s ) 
{ 
  int i ;

  {
  {
#line 821
  signal(14, (void (*)(int  ))1);
#line 823
  i = 0;
  }
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 823
    if (! (i < button_act_counter)) {
#line 823
      goto while_break;
    }
#line 825
    if (button_repeat_flags[i]) {
      {
#line 827
      sendkey(button_actions[i], (press_or_release_type )1, button_upper[i]);
#line 828
      sendkey(button_actions[i], (press_or_release_type )0, button_upper[i]);
      }
    }
#line 823
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 832
  if ((unsigned int )target == 1U) {
    {
#line 832
    XFlush(thedisp);
    }
  }
  {
#line 834
  signal(14, & repeat_handler);
  }
#line 835
  return;
}
}
#line 840 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
static XEvent event  ;
#line 841
void sendkey(unsigned int keycode , press_or_release_type PoR , int iscap ) ;
#line 841 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
static char needinitxev  =    (char)1;
#line 837 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
void sendkey(unsigned int keycode , press_or_release_type PoR , int iscap ) 
{ 
  char conkey ;
  KeySym __attribute__((__deprecated__))  tmp ;
  char *tmp___0 ;
  KeyCode tmp___1 ;
  KeyCode tmp___2 ;

  {
  {
#line 844
  printf((char const   */* __restrict  */)"iscap is now %d  ", iscap);
  }
  {
#line 848
  if ((unsigned int )target == 1U) {
#line 848
    goto case_1;
  }
#line 921
  if ((unsigned int )target == 2U) {
#line 921
    goto case_2;
  }
#line 928
  if ((unsigned int )target == 3U) {
#line 928
    goto case_3;
  }
#line 845
  goto switch_break;
  case_1: /* CIL Label */ 
#line 849
  if (needinitxev) {
    {
#line 851
    memset((void *)(& event), 0, sizeof(event));
#line 852
    event.xkey.type = 2;
#line 853
    event.xkey.root = (((_XPrivDisplay )thedisp)->screens + thescreen)->root;
#line 854
    event.xkey.window = (Window )thewindow;
#line 855
    event.xkey.subwindow = (Window )thewindow;
#line 856
    event.xkey.same_screen = 1;
#line 857
    event.xkey.time = (Time )0L;
#line 858
    event.xkey.display = thedisp;
#line 859
    needinitxev = (char)0;
    }
  }
#line 861
  if ((unsigned int )PoR == 0U) {
#line 861
    event.xkey.type = 2;
  } else {
#line 861
    event.xkey.type = 3;
  }
  {
#line 862
  event.xkey.state = 16U;
#line 863
  event.xkey.keycode = keycode;
#line 864
  printf((char const   */* __restrict  */)"sendkey: button_upper: %d keycode  0x%06x  %0d   ",
         iscap, event.xkey.keycode, keycode);
#line 865
  tmp = XKeycodeToKeysym(thedisp, (KeyCode )event.xkey.keycode, 0);
#line 865
  tmp___0 = XKeysymToString((KeySym )tmp);
#line 865
  printf((char const   */* __restrict  */)"sendkey: keysym %s\n", tmp___0);
#line 866
  printf((char const   */* __restrict  */)"state hex %x\n", event.xkey.state);
  }
#line 869
  if (event.xkey.keycode >= 79U) {
#line 869
    if (event.xkey.keycode <= 90U) {
#line 871
      event.xkey.state = 16U;
    } else {
#line 869
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 875
  if (iscap > 0) {
    {
#line 877
    printf((char const   */* __restrict  */)"executing iscap > 0\n");
    }
    {
#line 880
    if ((unsigned int )PoR == 0U) {
#line 880
      goto case_0;
    }
#line 894
    if ((unsigned int )PoR == 1U) {
#line 894
      goto case_1___0;
    }
#line 905
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 881
    printf((char const   */* __restrict  */)"executing iscap > 0 , sending shiftkey first.\n");
#line 883
    tmp___1 = XKeysymToKeycode(thedisp, (KeySym )65505);
#line 883
    event.xkey.keycode = (unsigned int )tmp___1;
#line 884
    event.xkey.type = 2;
#line 885
    event.xkey.state = 16U;
#line 886
    XSendEvent(thedisp, (Window )thewindow, 0, (long )event.xkey.state, & event);
#line 887
    sleep((unsigned int )0.1);
#line 889
    event.xkey.keycode = keycode;
#line 890
    event.xkey.state = 17U;
#line 891
    XSendEvent(thedisp, (Window )thewindow, 0, (long )event.xkey.state, & event);
    }
#line 892
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 895
    printf((char const   */* __restrict  */)"iscap > 0: RELEASE , sending shiftkey last.\n");
#line 897
    event.xkey.type = 3;
#line 898
    event.xkey.state = 17U;
#line 899
    XSendEvent(thedisp, (Window )thewindow, 0, (long )event.xkey.state, & event);
#line 901
    sleep((unsigned int )0.2);
#line 902
    tmp___2 = XKeysymToKeycode(thedisp, (KeySym )65505);
#line 902
    event.xkey.keycode = (unsigned int )tmp___2;
#line 903
    XSendEvent(thedisp, (Window )thewindow, 0, (long )event.xkey.state, & event);
    }
#line 904
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 906
    printf((char const   */* __restrict  */)" not understood PoR\n");
    }
#line 907
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 914
  XSendEvent(thedisp, (Window )thewindow, 0, (long )event.xkey.state, & event);
#line 915
  sleep((unsigned int )0.2);
  }
#line 917
  goto switch_break;
  case_2: /* CIL Label */ 
#line 922
  if ((unsigned int )PoR == 0U) {
#line 923
    conkey = (char )keycode;
  }
#line 924
  if ((unsigned int )PoR == 1U) {
#line 925
    conkey = (char )(keycode | 128U);
  }
  {
#line 926
  ioctl(consolefd, 21522UL, & conkey);
  }
#line 927
  goto switch_break;
  case_3: /* CIL Label */ 
#line 929
  if ((unsigned int )PoR == 0U) {
    {
#line 931
    conkey = (char )keycode;
#line 932
    ioctl(consolefd, 21522UL, & conkey);
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 936
  return;
}
}
#line 938 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
void cleanup(int s ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 940
  if (s == 2) {
#line 940
    tmp___1 = "SIGINT";
  } else {
#line 940
    if (s == 15) {
#line 940
      tmp___0 = "SIGTERM";
    } else {
#line 940
      if (s == 0) {
#line 940
        tmp = "Window die";
      } else {
#line 940
        tmp = "Unknown";
      }
#line 940
      tmp___0 = tmp;
    }
#line 940
    tmp___1 = tmp___0;
  }
  {
#line 940
  printf((char const   */* __restrict  */)"\n%s caught, cleaning up & quitting.\n",
         tmp___1);
  }
#line 949
  if ((unsigned int )target == 2U) {
    {
#line 949
    close(consolefd);
    }
  } else
#line 949
  if ((unsigned int )target == 3U) {
    {
#line 949
    close(consolefd);
    }
  }
  {
#line 951
  exit(0);
  }
}
}
#line 955 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
static Window RegisterCloseEvent(Display *disp , Window win ) 
{ 
  Window root_return ;
  Window parent_return ;
  Window *children_return ;
  unsigned int nchildren_return ;

  {
  {
#line 960
  parent_return = (Window )0;
#line 964
  XQueryTree(disp, win, & root_return, & parent_return, & children_return, & nchildren_return);
  }
#line 966
  if (parent_return) {
    {
#line 967
    XSelectInput(disp, parent_return, 1L << 19);
    }
  }
#line 969
  if (nchildren_return > 0U) {
    {
#line 970
    XFree((void *)children_return);
    }
  }
#line 972
  return (parent_return);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/joy2key-1.6.3/joy2key.c"
static void CheckIfWindowClosed(Display *disp , Window parentwin , Window win ) 
{ 
  XEvent event___0 ;
  int tmp ;

  {
  {
#line 983
  tmp = XCheckWindowEvent(disp, parentwin, 1L << 19, & event___0);
  }
#line 983
  if (tmp == 1) {
#line 985
    if (event___0.type == 17) {
#line 985
      if (event___0.xdestroywindow.window == win) {
        {
#line 987
        cleanup(0);
        }
      }
    }
  }
#line 990
  return;
}
}
