/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 60 "/usr/include/fcntl.h"
typedef __pid_t pid_t;
#line 48 "/home/june/collector/temp/anacron-2.3/global.h"
struct env_rec1 {
   char *assign ;
   struct env_rec1 *next ;
};
#line 53 "/home/june/collector/temp/anacron-2.3/global.h"
typedef struct env_rec1 env_rec;
#line 55 "/home/june/collector/temp/anacron-2.3/global.h"
struct job_rec1 {
   int period ;
   int named_period ;
   int delay ;
   char *ident ;
   char *command ;
   char *mailto ;
   int tab_line ;
   int arg_num ;
   int timestamp_fd ;
   int output_fd ;
   int mail_header_size ;
   pid_t job_pid ;
   pid_t mailer_pid ;
   struct job_rec1 *next ;
   env_rec *prev_env_rec ;
};
#line 74 "/home/june/collector/temp/anacron-2.3/global.h"
typedef struct job_rec1 job_rec;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_19 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_19 regmatch_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 243 "/usr/include/unistd.h"
typedef __off_t off_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_12 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_12 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 197 "/home/june/collector/temp/anacron-2.3/runjob.c"
union __anonunion_52 {
   int __in ;
   int __i ;
};
#line 201 "/home/june/collector/temp/anacron-2.3/runjob.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 204 "/home/june/collector/temp/anacron-2.3/runjob.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 204 "/home/june/collector/temp/anacron-2.3/runjob.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 200 "/home/june/collector/temp/anacron-2.3/runjob.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 200 "/home/june/collector/temp/anacron-2.3/runjob.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 196 "/home/june/collector/temp/anacron-2.3/runjob.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 196 "/home/june/collector/temp/anacron-2.3/runjob.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 291 "/home/june/collector/temp/anacron-2.3/runjob.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 294 "/home/june/collector/temp/anacron-2.3/runjob.c"
union __anonunion_61 {
   int __in ;
   int __i ;
};
#line 293 "/home/june/collector/temp/anacron-2.3/runjob.c"
union __anonunion_62 {
   int __in ;
   int __i ;
};
#line 290 "/home/june/collector/temp/anacron-2.3/runjob.c"
union __anonunion_63 {
   int __in ;
   int __i ;
};
#line 288 "/home/june/collector/temp/anacron-2.3/runjob.c"
union __anonunion_64 {
   int __in ;
   int __i ;
};
#line 288 "/home/june/collector/temp/anacron-2.3/runjob.c"
union __anonunion_65 {
   int __in ;
   int __i ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_12 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_13 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_14 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_15 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_16 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_17 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_18 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_11 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_12 _kill ;
   struct __anonstruct__timer_13 _timer ;
   struct __anonstruct__rt_14 _rt ;
   struct __anonstruct__sigchld_15 _sigchld ;
   struct __anonstruct__sigfault_16 _sigfault ;
   struct __anonstruct__sigpoll_17 _sigpoll ;
   struct __anonstruct__sigsys_18 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_10 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_11 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_10 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_30 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_30 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 142 "/usr/include/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 149 "/usr/include/obstack.h"
union __anonunion_temp_25 {
   long tempint ;
   void *tempptr ;
};
#line 149 "/usr/include/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_25 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 297 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 478
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 84 "/home/june/collector/temp/anacron-2.3/global.h"
int force ;
#line 85
int day_now ;
#line 86
int year ;
#line 86
int month ;
#line 86
int day_of_month ;
#line 108
void xclose(int fd ) ;
#line 112
void explain(char const   *fmt  , ...) ;
#line 116
void die(char const   *fmt  , ...) ;
#line 117
void die_e(char const   *fmt  , ...) ;
#line 135
int consider_job(job_rec *jr ) ;
#line 136
void unlock(job_rec *jr ) ;
#line 137
void update_timestamp(job_rec *jr ) ;
#line 138
void fake_job(job_rec *jr ) ;
#line 26 "/home/june/collector/temp/anacron-2.3/gregor.h"
int day_num(int year___0 , int month___0 , int day ) ;
#line 27
int days_last_month(void) ;
#line 28
int days_this_month(void) ;
#line 29
int days_last_year(void) ;
#line 30
int days_this_year(void) ;
#line 39 "/home/june/collector/temp/anacron-2.3/lock.c"
static void open_tsfile(job_rec *jr ) 
{ 
  __gid_t tmp ;
  __uid_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 43
  jr->timestamp_fd = open((char const   *)jr->ident, 66, 384);
  }
#line 44
  if (jr->timestamp_fd == -1) {
    {
#line 45
    die_e("Can\'t open timestamp file for job %s", jr->ident);
    }
  }
  {
#line 46
  fcntl(jr->timestamp_fd, 2, 1);
#line 49
  tmp = getgid();
#line 49
  tmp___0 = getuid();
#line 49
  tmp___1 = fchown(jr->timestamp_fd, tmp___0, tmp);
  }
#line 49
  if (tmp___1) {
    {
#line 50
    die_e("Can\'t chown timestamp file %s", jr->ident);
    }
  }
  {
#line 51
  tmp___2 = fchmod(jr->timestamp_fd, (__mode_t )384);
  }
#line 51
  if (tmp___2) {
    {
#line 52
    die_e("Can\'t chmod timestamp file %s", jr->ident);
    }
  }
#line 53
  return;
}
}
#line 55 "/home/june/collector/temp/anacron-2.3/lock.c"
static int lock_file(int fd ) 
{ 
  int r ;
  struct flock sfl ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 64
  sfl.l_type = (short)1;
#line 65
  sfl.l_start = (__off_t )0;
#line 66
  sfl.l_whence = (short)0;
#line 67
  sfl.l_len = (__off_t )0;
#line 68
  tmp = __errno_location();
#line 68
  *tmp = 0;
#line 69
  r = fcntl(fd, 6, & sfl);
  }
#line 70
  if (r != -1) {
#line 70
    return (1);
  }
  {
#line 71
  tmp___0 = __errno_location();
  }
#line 71
  if (*tmp___0 != 13) {
    {
#line 71
    tmp___1 = __errno_location();
    }
#line 71
    if (*tmp___1 != 11) {
      {
#line 72
      die_e("fcntl() error");
      }
    }
  }
#line 73
  return (0);
}
}
#line 76 "/home/june/collector/temp/anacron-2.3/lock.c"
int consider_job(job_rec *jr ) 
{ 
  char timestamp[9] ;
  int ts_year ;
  int ts_month ;
  int ts_day ;
  int dn ;
  ssize_t b ;
  int day_delta ;
  int tmp ;
  int period ;
  int bypass ;
  int tmp___0 ;

  {
  {
#line 86
  open_tsfile(jr);
#line 89
  b = read(jr->timestamp_fd, (void *)(timestamp), (size_t )8);
  }
#line 90
  if (b == -1L) {
    {
#line 90
    die_e("Error reading timestamp file %s", jr->ident);
    }
  }
#line 91
  timestamp[8] = (char)0;
#line 94
  if (! force) {
#line 94
    if (b == 8L) {
      {
#line 97
      tmp = sscanf((char const   */* __restrict  */)(timestamp), (char const   */* __restrict  */)"%4d%2d%2d",
                   & ts_year, & ts_month, & ts_day);
      }
#line 97
      if (tmp == 3) {
        {
#line 98
        dn = day_num(ts_year, ts_month, ts_day);
        }
      } else {
#line 100
        dn = 0;
      }
#line 102
      day_delta = day_now - dn;
#line 109
      if (day_delta >= 0) {
#line 109
        if (day_delta < jr->period) {
          {
#line 112
          xclose(jr->timestamp_fd);
          }
#line 113
          return (0);
        }
      }
#line 120
      if (jr->named_period) {
#line 122
        period = 0;
#line 122
        bypass = 0;
        {
#line 125
        if (jr->named_period == 1) {
#line 125
          goto case_1;
        }
#line 129
        if (jr->named_period == 2) {
#line 129
          goto case_2;
        }
#line 133
        goto switch_default;
        case_1: /* CIL Label */ 
        {
#line 126
        period = days_last_month();
#line 127
        bypass = days_this_month();
        }
#line 128
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 130
        period = days_last_year();
#line 131
        bypass = days_this_year();
        }
#line 132
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 134
        die("Unknown named period for %s (%d)", jr->ident, jr->named_period);
        }
        switch_break: /* CIL Label */ ;
        }
#line 136
        if (day_delta < period) {
#line 136
          if (day_delta != bypass) {
            {
#line 139
            xclose(jr->timestamp_fd);
            }
#line 140
            return (0);
          }
        }
      }
    }
  }
  {
#line 146
  tmp___0 = lock_file(jr->timestamp_fd);
  }
#line 146
  if (tmp___0) {
#line 146
    return (1);
  }
  {
#line 149
  xclose(jr->timestamp_fd);
#line 150
  explain("Job `%s\' locked by another anacron - skipping", jr->ident);
  }
#line 151
  return (0);
}
}
#line 154 "/home/june/collector/temp/anacron-2.3/lock.c"
void unlock(job_rec *jr ) 
{ 


  {
  {
#line 157
  xclose(jr->timestamp_fd);
  }
#line 158
  return;
}
}
#line 160 "/home/june/collector/temp/anacron-2.3/lock.c"
void update_timestamp(job_rec *jr ) 
{ 
  char stamp[10] ;
  __off_t tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 171
  snprintf((char */* __restrict  */)(stamp), (size_t )10, (char const   */* __restrict  */)"%04d%02d%02d\n",
           year, month, day_of_month);
#line 172
  tmp = lseek(jr->timestamp_fd, (__off_t )0, 0);
  }
#line 172
  if (tmp) {
    {
#line 173
    die_e("Can\'t lseek timestamp file for job %s", jr->ident);
    }
  }
  {
#line 174
  tmp___0 = write(jr->timestamp_fd, (void const   *)(stamp), (size_t )9);
  }
#line 174
  if (tmp___0 != 9L) {
    {
#line 175
    die_e("Can\'t write timestamp file for job %s", jr->ident);
    }
  }
  {
#line 176
  tmp___1 = ftruncate(jr->timestamp_fd, (__off_t )9);
  }
#line 176
  if (tmp___1) {
    {
#line 177
    die_e("ftruncate error");
    }
  }
#line 178
  return;
}
}
#line 180 "/home/june/collector/temp/anacron-2.3/lock.c"
void fake_job(job_rec *jr ) 
{ 


  {
  {
#line 184
  open_tsfile(jr);
#line 185
  update_timestamp(jr);
#line 186
  xclose(jr->timestamp_fd);
  }
#line 187
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 25 "/home/june/collector/temp/anacron-2.3/matchrx.h"
int match_rx(char const   *rx , char *string , int n_sub  , ...) ;
#line 32 "/home/june/collector/temp/anacron-2.3/matchrx.c"
int match_rx(char const   *rx , char *string , int n_sub  , ...) 
{ 
  int r ;
  int n ;
  regex_t crx ;
  va_list va ;
  char **substring ;
  regmatch_t *sub_offsets ;
  void *tmp ;
  int tmp___0 ;
  char **tmp___1 ;

  {
  {
#line 50
  tmp = malloc(sizeof(regmatch_t ) * (unsigned long )(n_sub + 1));
#line 50
  sub_offsets = (regmatch_t *)tmp;
#line 51
  memset((void *)sub_offsets, 0, sizeof(regmatch_t ) * (unsigned long )(n_sub + 1));
#line 53
  tmp___0 = regcomp((regex_t */* __restrict  */)(& crx), (char const   */* __restrict  */)rx,
                    1);
  }
#line 53
  if (tmp___0) {
#line 53
    return (-1);
  }
  {
#line 54
  r = regexec((regex_t const   */* __restrict  */)(& crx), (char const   */* __restrict  */)string,
              (size_t )(n_sub + 1), (regmatch_t */* __restrict  */)sub_offsets, 0);
  }
#line 55
  if (r != 0) {
#line 55
    if (r != 1) {
#line 55
      return (-1);
    }
  }
  {
#line 56
  regfree(& crx);
  }
#line 57
  if (r == 1) {
#line 57
    return (0);
  }
  {
#line 59
  __builtin_va_start(va, n_sub);
#line 60
  n = 1;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (n <= n_sub)) {
#line 61
      goto while_break;
    }
    {
#line 63
    tmp___1 = __builtin_va_arg(va, char **);
#line 63
    substring = tmp___1;
    }
#line 64
    if ((unsigned long )substring != (unsigned long )((void *)0)) {
#line 66
      if ((sub_offsets + n)->rm_so == -1) {
#line 66
        return (-1);
      }
#line 67
      *substring = string + (sub_offsets + n)->rm_so;
#line 68
      *(string + (sub_offsets + n)->rm_eo) = (char)0;
    }
#line 70
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  __builtin_va_end(va);
#line 73
  free((void *)sub_offsets);
  }
#line 74
  return (1);
}
}
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 248 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 227 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) tempnam)(char const   *__dir ,
                                                                                char const   *__pfx )  __attribute__((__malloc__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 82 "/home/june/collector/temp/anacron-2.3/global.h"
int old_umask ;
#line 83
sigset_t old_sigmask ;
#line 87
int in_background ;
#line 90
env_rec *first_env_rec ;
#line 95
int njobs ;
#line 96
job_rec **job_array ;
#line 98
int running_jobs ;
#line 98
int running_mailers ;
#line 102
char *mail_charset ;
#line 109
pid_t xfork(void) ;
#line 114
void complain(char const   *fmt  , ...) ;
#line 120
void xcloselog(void) ;
#line 141
void tend_children(void) ;
#line 142
void launch_job(job_rec *jr ) ;
#line 38 "/home/june/collector/temp/anacron-2.3/runjob.c"
static int temp_file(void) 
{ 
  int max_retries ;
  char *name ;
  int fd ;
  int i ;
  int *tmp ;
  int tmp___0 ;

  {
#line 42
  max_retries = 50;
#line 46
  i = 0;
#line 47
  name = (char *)((void *)0);
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 50
    i ++;
#line 51
    free((void *)name);
#line 52
    name = tempnam((char const   *)((void *)0), (char const   *)((void *)0));
    }
#line 53
    if ((unsigned long )name == (unsigned long )((void *)0)) {
      {
#line 53
      die("Can\'t find a unique temporary filename");
      }
    }
    {
#line 54
    fd = open((char const   *)name, 1218, 384);
    }
#line 48
    if (fd == -1) {
      {
#line 48
      tmp = __errno_location();
      }
#line 48
      if (*tmp == 17) {
#line 48
        if (! (i < max_retries)) {
#line 48
          goto while_break;
        }
      } else {
#line 48
        goto while_break;
      }
    } else {
#line 48
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  if (fd == -1) {
    {
#line 59
    die_e("Can\'t open temporary file");
    }
  }
  {
#line 60
  tmp___0 = unlink((char const   *)name);
  }
#line 60
  if (tmp___0) {
    {
#line 60
    die_e("Can\'t unlink temporary file");
    }
  }
  {
#line 61
  free((void *)name);
#line 62
  fcntl(fd, 2, 1);
  }
#line 63
  return (fd);
}
}
#line 66 "/home/june/collector/temp/anacron-2.3/runjob.c"
static off_t file_size(int fd ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 72
  tmp = fstat(fd, & st);
  }
#line 72
  if (tmp) {
    {
#line 72
    die_e("Can\'t fstat temporary file");
    }
  }
#line 73
  return (st.st_size);
}
}
#line 76 "/home/june/collector/temp/anacron-2.3/runjob.c"
static char *username(void) 
{ 
  struct passwd *ps ;
  __uid_t tmp ;

  {
  {
#line 81
  tmp = geteuid();
#line 81
  ps = getpwuid(tmp);
  }
#line 82
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
    {
#line 82
    die_e("getpwuid() error");
    }
  }
#line 83
  return (ps->pw_name);
}
}
#line 86 "/home/june/collector/temp/anacron-2.3/runjob.c"
static void xputenv(char const   *s ) 
{ 
  int tmp ;

  {
  {
#line 89
  tmp = putenv((char *)s);
  }
#line 89
  if (tmp) {
    {
#line 89
    die_e("Can\'t set the environment");
    }
  }
#line 90
  return;
}
}
#line 92 "/home/june/collector/temp/anacron-2.3/runjob.c"
static void setup_env(job_rec const   *jr ) 
{ 
  env_rec *er ;

  {
#line 98
  er = first_env_rec;
#line 99
  if ((unsigned long )er == (unsigned long )((void *)0)) {
#line 99
    return;
  } else
#line 99
  if ((unsigned long )jr->prev_env_rec == (unsigned long )((void *)0)) {
#line 99
    return;
  }
  {
#line 100
  xputenv((char const   *)er->assign);
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! ((unsigned long )er != (unsigned long )jr->prev_env_rec)) {
#line 101
      goto while_break;
    }
    {
#line 103
    er = er->next;
#line 104
    xputenv((char const   *)er->assign);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 108 "/home/june/collector/temp/anacron-2.3/runjob.c"
static void run_job(job_rec const   *jr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 113
  xclose(1);
#line 114
  xclose(2);
#line 115
  tmp = dup2((int )jr->output_fd, 1);
  }
#line 115
  if (tmp != 1) {
    {
#line 116
    die_e("dup2() error");
    }
  } else {
    {
#line 115
    tmp___0 = dup2((int )jr->output_fd, 2);
    }
#line 115
    if (tmp___0 != 2) {
      {
#line 116
      die_e("dup2() error");
      }
    }
  }
  {
#line 117
  in_background = 0;
#line 118
  tmp___1 = chdir("/");
  }
#line 118
  if (tmp___1) {
    {
#line 118
    die_e("Can\'t chdir to \'/\'");
    }
  }
  {
#line 120
  umask((__mode_t )old_umask);
#line 121
  tmp___2 = sigprocmask(2, (sigset_t const   */* __restrict  */)(& old_sigmask), (sigset_t */* __restrict  */)((void *)0));
  }
#line 121
  if (tmp___2) {
    {
#line 122
    die_e("sigprocmask error");
    }
  }
  {
#line 123
  xcloselog();
#line 124
  execl("/bin/sh", "/bin/sh", "-c", jr->command, (char *)((void *)0));
#line 125
  die_e("execl() error");
  }
#line 126
  return;
}
}
#line 128 "/home/june/collector/temp/anacron-2.3/runjob.c"
static void xwrite(int fd , char const   *string ) 
{ 
  size_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 133
  tmp = strlen(string);
#line 133
  tmp___0 = write(fd, (void const   *)string, tmp);
  }
#line 133
  if (tmp___0 == -1L) {
    {
#line 134
    die_e("Can\'t write to temporary file");
    }
  }
#line 135
  return;
}
}
#line 137 "/home/june/collector/temp/anacron-2.3/runjob.c"
static int xwait(pid_t pid , int *status ) 
{ 
  pid_t r ;

  {
  {
#line 145
  r = waitpid(pid, status, 1);
  }
#line 146
  if (r == -1) {
    {
#line 146
    die_e("waitpid() error");
    }
  }
#line 147
  if (r == 0) {
#line 147
    return (0);
  }
#line 148
  return (1);
}
}
#line 151 "/home/june/collector/temp/anacron-2.3/runjob.c"
static void launch_mailer(job_rec *jr ) 
{ 
  pid_t pid ;
  struct stat buf ;
  int tmp ;
  int tmp___0 ;
  __off_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 159
  tmp = stat((char const   */* __restrict  */)"/usr/sbin/sendmail", (struct stat */* __restrict  */)(& buf));
  }
#line 159
  if (tmp) {
    {
#line 161
    complain("Can\'t find sendmail at %s, not mailing output", "/usr/sbin/sendmail");
    }
#line 162
    return;
  }
  {
#line 165
  pid = xfork();
  }
#line 166
  if (pid == 0) {
    {
#line 169
    in_background = 1;
#line 171
    xclose(0);
#line 172
    tmp___0 = dup2(jr->output_fd, 0);
    }
#line 172
    if (tmp___0 != 0) {
      {
#line 172
      die_e("Can\'t dup2()");
      }
    }
    {
#line 173
    tmp___1 = lseek(0, (__off_t )0, 0);
    }
#line 173
    if (tmp___1 != 0L) {
      {
#line 173
      die_e("Can\'t lseek()");
      }
    }
    {
#line 174
    umask((__mode_t )old_umask);
#line 175
    tmp___2 = sigprocmask(2, (sigset_t const   */* __restrict  */)(& old_sigmask),
                          (sigset_t */* __restrict  */)((void *)0));
    }
#line 175
    if (tmp___2) {
      {
#line 176
      die_e("sigprocmask error");
      }
    }
    {
#line 177
    xcloselog();
#line 183
    execl("/usr/sbin/sendmail", "/usr/sbin/sendmail", "-FAnacron", "-odi", jr->mailto,
          (char *)((void *)0));
#line 185
    die_e("Can\'t exec /usr/sbin/sendmail");
    }
  }
#line 189
  jr->mailer_pid = pid;
#line 190
  running_mailers ++;
#line 191
  return;
}
}
#line 193 "/home/june/collector/temp/anacron-2.3/runjob.c"
static void tend_mailer(job_rec *jr , int status ) 
{ 
  union __anonunion_52 __constr_expr_0 ;
  union __anonunion_53 __constr_expr_1 ;
  union __anonunion_54 __constr_expr_2 ;
  union __anonunion_55 __constr_expr_3 ;
  union __anonunion_56 __constr_expr_4 ;
  union __anonunion_57 __constr_expr_5 ;
  union __anonunion_58 __constr_expr_6 ;
  union __anonunion_59 __constr_expr_7 ;

  {
#line 196
  __constr_expr_6.__in = status;
#line 196
  if ((__constr_expr_6.__i & 127) == 0) {
#line 196
    __constr_expr_7.__in = status;
#line 196
    if ((__constr_expr_7.__i & 65280) >> 8 != 0) {
      {
#line 197
      __constr_expr_0.__in = status;
#line 197
      complain("Tried to mail output of job `%s\', but mailer process (/usr/sbin/sendmail) exited with ststus %d",
               jr->ident, (__constr_expr_0.__i & 65280) >> 8);
      }
    } else {
#line 196
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 200
    __constr_expr_4.__in = status;
#line 200
    if ((__constr_expr_4.__i & 127) == 0) {
      _L: /* CIL Label */ 
#line 204
      __constr_expr_2.__in = status;
#line 204
      if (! ((__constr_expr_2.__i & 127) == 0)) {
#line 204
        __constr_expr_3.__in = status;
#line 204
        if (! ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0)) {
          {
#line 205
          complain("Tried to mail output of job `%s\', but mailer process (/usr/sbin/sendmail) terminated abnormally",
                   jr->ident);
          }
        }
      }
    } else {
#line 200
      __constr_expr_5.__in = status;
#line 200
      if ((int )((signed char )((__constr_expr_5.__i & 127) + 1)) >> 1 > 0) {
        {
#line 201
        __constr_expr_1.__in = status;
#line 201
        complain("Tried to mail output of job `%s\', but mailer process (/usr/sbin/sendmail) got signal %d",
                 jr->ident, __constr_expr_1.__i & 127);
        }
      } else {
#line 200
        goto _L;
      }
    }
  }
#line 209
  jr->mailer_pid = 0;
#line 210
  running_mailers --;
#line 211
  return;
}
}
#line 213 "/home/june/collector/temp/anacron-2.3/runjob.c"
void launch_job(job_rec *jr ) 
{ 
  pid_t pid ;
  int fd ;
  char hostname[512] ;
  char *mailto ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  off_t tmp___3 ;

  {
  {
#line 222
  tmp = gethostname(hostname, (size_t )512);
  }
#line 222
  if (tmp) {
    {
#line 223
    strcpy((char */* __restrict  */)(hostname), (char const   */* __restrict  */)"unknown machine");
    }
  }
  {
#line 226
  setup_env((job_rec const   *)jr);
#line 229
  mailto = getenv("MAILTO");
  }
#line 231
  if (mailto) {
#line 232
    jr->mailto = mailto;
  } else {
    {
#line 234
    jr->mailto = username();
    }
  }
  {
#line 237
  tmp___0 = temp_file();
#line 237
  jr->output_fd = tmp___0;
#line 237
  fd = tmp___0;
#line 239
  xwrite(fd, "From: ");
#line 240
  xwrite(fd, "Anacron <");
#line 241
  tmp___1 = username();
#line 241
  xwrite(fd, (char const   *)tmp___1);
#line 242
  xwrite(fd, ">\n");
#line 243
  xwrite(fd, "To: ");
  }
#line 244
  if (mailto) {
    {
#line 245
    xwrite(fd, (char const   *)mailto);
    }
  } else {
    {
#line 247
    tmp___2 = username();
#line 247
    xwrite(fd, (char const   *)tmp___2);
    }
  }
  {
#line 249
  xwrite(fd, "\n");
#line 250
  xwrite(fd, "Subject: Anacron job \'");
#line 251
  xwrite(fd, (char const   *)jr->ident);
#line 252
  xwrite(fd, "\' on ");
#line 253
  xwrite(fd, (char const   *)(hostname));
#line 254
  xwrite(fd, "\n");
#line 255
  xwrite(fd, "Content-Type: text/plain; charset=");
#line 256
  xwrite(fd, (char const   *)mail_charset);
#line 257
  xwrite(fd, "\n\n");
#line 259
  tmp___3 = file_size(fd);
#line 259
  jr->mail_header_size = (int )tmp___3;
#line 261
  pid = xfork();
  }
#line 262
  if (pid == 0) {
    {
#line 265
    in_background = 1;
#line 266
    run_job((job_rec const   *)jr);
    }
  }
  {
#line 270
  explain("Job `%s\' started", jr->ident);
#line 271
  jr->job_pid = pid;
#line 272
  running_jobs ++;
  }
#line 273
  return;
}
}
#line 275 "/home/june/collector/temp/anacron-2.3/runjob.c"
static void tend_job(job_rec *jr , int status ) 
{ 
  int mail_output ;
  char *m ;
  off_t tmp ;
  union __anonunion_60 __constr_expr_8 ;
  union __anonunion_61 __constr_expr_9 ;
  union __anonunion_62 __constr_expr_10 ;
  union __anonunion_63 __constr_expr_11 ;
  union __anonunion_64 __constr_expr_12 ;
  union __anonunion_65 __constr_expr_13 ;

  {
  {
#line 282
  update_timestamp(jr);
#line 283
  unlock(jr);
#line 284
  tmp = file_size(jr->output_fd);
  }
#line 284
  if (tmp > (off_t )jr->mail_header_size) {
#line 284
    mail_output = 1;
  } else {
#line 285
    mail_output = 0;
  }
#line 287
  if (mail_output) {
#line 287
    m = (char *)" (mailing output)";
  } else {
#line 287
    m = (char *)"";
  }
#line 288
  __constr_expr_12.__in = status;
#line 288
  if ((__constr_expr_12.__i & 127) == 0) {
#line 288
    __constr_expr_13.__in = status;
#line 288
    if ((__constr_expr_13.__i & 65280) >> 8 == 0) {
      {
#line 289
      explain("Job `%s\' terminated%s", jr->ident, m);
      }
    } else {
#line 288
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 290
    __constr_expr_11.__in = status;
#line 290
    if ((__constr_expr_11.__i & 127) == 0) {
      {
#line 291
      __constr_expr_8.__in = status;
#line 291
      explain("Job `%s\' terminated (exit status: %d)%s", jr->ident, (__constr_expr_8.__i & 65280) >> 8,
              m);
      }
    } else {
#line 293
      __constr_expr_10.__in = status;
#line 293
      if ((int )((signed char )((__constr_expr_10.__i & 127) + 1)) >> 1 > 0) {
        {
#line 294
        __constr_expr_9.__in = status;
#line 294
        complain("Job `%s\' terminated due to signal %d%s", jr->ident, __constr_expr_9.__i & 127,
                 m);
        }
      } else {
        {
#line 297
        complain("Job `%s\' terminated abnormally%s", jr->ident, m);
        }
      }
    }
  }
#line 299
  jr->job_pid = 0;
#line 300
  running_jobs --;
#line 301
  if (mail_output) {
    {
#line 301
    launch_mailer(jr);
    }
  }
  {
#line 302
  xclose(jr->output_fd);
  }
#line 303
  return;
}
}
#line 305 "/home/june/collector/temp/anacron-2.3/runjob.c"
void tend_children(void) 
{ 
  int j ;
  int status ;
  int tmp ;
  int tmp___0 ;

  {
#line 314
  j = 0;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! (j < njobs)) {
#line 315
      goto while_break;
    }
#line 317
    if ((*(job_array + j))->mailer_pid != 0) {
      {
#line 317
      tmp = xwait((*(job_array + j))->mailer_pid, & status);
      }
#line 317
      if (tmp) {
        {
#line 319
        tend_mailer(*(job_array + j), status);
        }
      }
    }
#line 320
    if ((*(job_array + j))->job_pid != 0) {
      {
#line 320
      tmp___0 = xwait((*(job_array + j))->job_pid, & status);
      }
#line 320
      if (tmp___0) {
        {
#line 322
        tend_job(*(job_array + j), status);
        }
      }
    }
#line 323
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  return;
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 254
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 30 "/home/june/collector/temp/anacron-2.3/gregor.c"
static int const   days_in_month[12]  = 
#line 30 "/home/june/collector/temp/anacron-2.3/gregor.c"
  {      (int const   )31,      (int const   )28,      (int const   )31,      (int const   )30, 
        (int const   )31,      (int const   )30,      (int const   )31,      (int const   )31, 
        (int const   )30,      (int const   )31,      (int const   )30,      (int const   )31};
#line 46
static int leap(int year___0 ) ;
#line 48 "/home/june/collector/temp/anacron-2.3/gregor.c"
int day_num(int year___0 , int month___0 , int day ) 
{ 
  int dn ;
  int i ;
  int isleap ;

  {
#line 75
  if (year___0 < 1) {
#line 75
    return (-1);
  }
#line 77
  if (year___0 > 5867441) {
#line 77
    return (-1);
  }
#line 78
  if (month___0 > 12) {
#line 78
    return (-1);
  } else
#line 78
  if (month___0 < 1) {
#line 78
    return (-1);
  }
#line 79
  if (day < 1) {
#line 79
    return (-1);
  }
  {
#line 81
  isleap = leap(year___0);
  }
#line 83
  if (month___0 != 2) {
#line 84
    if (day > (int )days_in_month[month___0 - 1]) {
#line 84
      return (-1);
    }
  } else
#line 86
  if (isleap) {
#line 86
    if (day > 29) {
#line 87
      return (-1);
    } else {
#line 86
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 86
  if (! isleap) {
#line 86
    if (day > 28) {
#line 87
      return (-1);
    }
  }
#line 92
  i = year___0 - 1;
#line 94
  dn = i * 365 + ((i / 4 - i / 100) + i / 400);
#line 98
  i = month___0 - 1;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i > 0)) {
#line 98
      goto while_break;
    }
#line 99
    dn += (int )days_in_month[i - 1];
#line 98
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (month___0 > 2) {
#line 101
    if (isleap) {
#line 101
      dn ++;
    }
  }
#line 105
  dn += day;
#line 107
  return (dn);
}
}
#line 110 "/home/june/collector/temp/anacron-2.3/gregor.c"
static int leap(int year___0 ) 
{ 
  int tmp ;

  {
#line 117
  if (year___0 % 4 == 0) {
#line 117
    if (year___0 % 100 != 0) {
#line 117
      tmp = 1;
    } else
#line 117
    if (year___0 % 400 == 0) {
#line 117
      tmp = 1;
    } else {
#line 117
      tmp = 0;
    }
  } else {
#line 117
    tmp = 0;
  }
#line 117
  return (tmp);
}
}
#line 120 "/home/june/collector/temp/anacron-2.3/gregor.c"
int days_last_month(void) 
{ 
  struct tm time_record ;
  time_t current_time ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 126
  time(& current_time);
#line 127
  localtime_r((time_t const   */* __restrict  */)(& current_time), (struct tm */* __restrict  */)(& time_record));
  }
  {
#line 130
  if (time_record.tm_mon == 0) {
#line 130
    goto case_0;
  }
#line 131
  if (time_record.tm_mon == 2) {
#line 131
    goto case_2;
  }
#line 132
  goto switch_default;
  case_0: /* CIL Label */ 
#line 130
  return ((int )days_in_month[11]);
  case_2: /* CIL Label */ 
  {
#line 131
  tmp___1 = leap(time_record.tm_year + 1900);
  }
#line 131
  if (tmp___1) {
#line 131
    tmp___0 = 1;
  } else {
#line 131
    tmp___0 = 0;
  }
#line 131
  return ((int )(days_in_month[1] + (int const   )tmp___0));
  switch_default: /* CIL Label */ 
#line 132
  return ((int )days_in_month[time_record.tm_mon - 1]);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 136 "/home/june/collector/temp/anacron-2.3/gregor.c"
int days_this_month(void) 
{ 
  struct tm time_record ;
  time_t current_time ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 142
  time(& current_time);
#line 143
  localtime_r((time_t const   */* __restrict  */)(& current_time), (struct tm */* __restrict  */)(& time_record));
  }
  {
#line 146
  if (time_record.tm_mon == 1) {
#line 146
    goto case_1;
  }
#line 147
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 146
  tmp___1 = leap(time_record.tm_year + 1900);
  }
#line 146
  if (tmp___1) {
#line 146
    tmp___0 = 1;
  } else {
#line 146
    tmp___0 = 0;
  }
#line 146
  return ((int )(days_in_month[1] + (int const   )tmp___0));
  switch_default: /* CIL Label */ 
#line 147
  return ((int )days_in_month[time_record.tm_mon]);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 151 "/home/june/collector/temp/anacron-2.3/gregor.c"
int days_last_year(void) 
{ 
  struct tm time_record ;
  time_t current_time ;
  int tmp ;

  {
  {
#line 157
  time(& current_time);
#line 158
  localtime_r((time_t const   */* __restrict  */)(& current_time), (struct tm */* __restrict  */)(& time_record));
#line 160
  tmp = leap((time_record.tm_year - 1) + 1900);
  }
#line 160
  if (tmp) {
#line 161
    return (366);
  }
#line 164
  return (365);
}
}
#line 167 "/home/june/collector/temp/anacron-2.3/gregor.c"
int days_this_year(void) 
{ 
  struct tm time_record ;
  time_t current_time ;
  int tmp ;

  {
  {
#line 173
  time(& current_time);
#line 174
  localtime_r((time_t const   */* __restrict  */)(& current_time), (struct tm */* __restrict  */)(& time_record));
#line 176
  tmp = leap(time_record.tm_year + 1900);
  }
#line 176
  if (tmp) {
#line 177
    return (366);
  }
#line 180
  return (365);
}
}
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 78 "/home/june/collector/temp/anacron-2.3/global.h"
pid_t primary_pid ;
#line 79
char *program_name ;
#line 84
int quiet ;
#line 100
int complaints ;
#line 113
void explain_e(char const   *fmt  , ...) ;
#line 115
void complain_e(char const   *fmt  , ...) ;
#line 49 "/home/june/collector/temp/anacron-2.3/log.c"
static char truncated[13]  = 
#line 49 "/home/june/collector/temp/anacron-2.3/log.c"
  {      (char )' ',      (char )'(',      (char )'t',      (char )'r', 
        (char )'u',      (char )'n',      (char )'c',      (char )'a', 
        (char )'t',      (char )'e',      (char )'d',      (char )')', 
        (char )'\000'};
#line 50 "/home/june/collector/temp/anacron-2.3/log.c"
static char msg[151]  ;
#line 51 "/home/june/collector/temp/anacron-2.3/log.c"
static int log_open  =    0;
#line 54 "/home/june/collector/temp/anacron-2.3/log.c"
int complaints  =    0;
#line 56 "/home/june/collector/temp/anacron-2.3/log.c"
static void xopenlog(void) 
{ 


  {
#line 59
  if (! log_open) {
    {
#line 61
    openlog((char const   *)program_name, 1, 9 << 3);
#line 62
    log_open = 1;
    }
  }
#line 64
  return;
}
}
#line 66 "/home/june/collector/temp/anacron-2.3/log.c"
void xcloselog(void) 
{ 


  {
#line 69
  if (log_open) {
    {
#line 69
    closelog();
    }
  }
#line 70
  log_open = 0;
#line 71
  return;
}
}
#line 73 "/home/june/collector/temp/anacron-2.3/log.c"
static void make_msg(char const   *fmt , va_list args___0 ) 
{ 
  int len ;

  {
  {
#line 81
  len = vsnprintf((char */* __restrict  */)(msg), sizeof(msg), (char const   */* __restrict  */)fmt,
                  args___0);
  }
#line 82
  if ((unsigned long )len >= sizeof(msg) - 1UL) {
    {
#line 83
    strcpy((char */* __restrict  */)((msg + sizeof(msg)) - sizeof(truncated)), (char const   */* __restrict  */)(truncated));
    }
  }
#line 84
  return;
}
}
#line 86 "/home/june/collector/temp/anacron-2.3/log.c"
static void log(int priority , char const   *fmt , va_list args___0 ) 
{ 


  {
  {
#line 91
  make_msg(fmt, args___0);
#line 92
  xopenlog();
#line 93
  syslog(priority, "%s", msg);
  }
#line 94
  if (! in_background) {
#line 96
    if (priority == 5) {
#line 96
      if (! quiet) {
        {
#line 97
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                msg);
        }
      } else {
#line 96
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 98
    if (priority == 3) {
      {
#line 99
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
              program_name, msg);
      }
    }
  }
#line 101
  return;
}
}
#line 103 "/home/june/collector/temp/anacron-2.3/log.c"
static void log_e(int priority , char const   *fmt , va_list args___0 ) 
{ 
  int saved_errno ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 110
  tmp = __errno_location();
#line 110
  saved_errno = *tmp;
#line 111
  make_msg(fmt, args___0);
#line 112
  xopenlog();
#line 113
  tmp___0 = strerror(saved_errno);
#line 113
  syslog(priority, "%s: %s", msg, tmp___0);
  }
#line 114
  if (! in_background) {
#line 116
    if (priority == 5) {
#line 116
      if (! quiet) {
        {
#line 117
        tmp___1 = strerror(saved_errno);
#line 117
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
                msg, tmp___1);
        }
      } else {
#line 116
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 118
    if (priority == 3) {
      {
#line 119
      tmp___2 = strerror(saved_errno);
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              program_name, msg, tmp___2);
      }
    }
  }
#line 122
  return;
}
}
#line 124 "/home/june/collector/temp/anacron-2.3/log.c"
void explain(char const   *fmt  , ...) 
{ 
  va_list args___0 ;

  {
  {
#line 130
  __builtin_va_start(args___0, fmt);
#line 131
  log(5, fmt, args___0);
#line 132
  __builtin_va_end(args___0);
  }
#line 133
  return;
}
}
#line 135 "/home/june/collector/temp/anacron-2.3/log.c"
void explain_e(char const   *fmt  , ...) 
{ 
  va_list args___0 ;

  {
  {
#line 141
  __builtin_va_start(args___0, fmt);
#line 142
  log_e(5, fmt, args___0);
#line 143
  __builtin_va_end(args___0);
  }
#line 144
  return;
}
}
#line 146 "/home/june/collector/temp/anacron-2.3/log.c"
void complain(char const   *fmt  , ...) 
{ 
  va_list args___0 ;

  {
  {
#line 152
  __builtin_va_start(args___0, fmt);
#line 153
  log(3, fmt, args___0);
#line 154
  __builtin_va_end(args___0);
#line 156
  complaints ++;
  }
#line 157
  return;
}
}
#line 159 "/home/june/collector/temp/anacron-2.3/log.c"
void complain_e(char const   *fmt  , ...) 
{ 
  va_list args___0 ;

  {
  {
#line 165
  __builtin_va_start(args___0, fmt);
#line 166
  log_e(3, fmt, args___0);
#line 167
  __builtin_va_end(args___0);
#line 169
  complaints ++;
  }
#line 170
  return;
}
}
#line 172 "/home/june/collector/temp/anacron-2.3/log.c"
void die(char const   *fmt  , ...) 
{ 
  va_list args___0 ;
  __pid_t tmp ;

  {
  {
#line 178
  __builtin_va_start(args___0, fmt);
#line 179
  log(3, fmt, args___0);
#line 180
  __builtin_va_end(args___0);
#line 181
  tmp = getpid();
  }
#line 181
  if (tmp == primary_pid) {
    {
#line 181
    complain("Aborted");
    }
  }
  {
#line 183
  exit(1);
  }
}
}
#line 186 "/home/june/collector/temp/anacron-2.3/log.c"
void die_e(char const   *fmt  , ...) 
{ 
  va_list args___0 ;
  __pid_t tmp ;

  {
  {
#line 192
  __builtin_va_start(args___0, fmt);
#line 193
  log_e(3, fmt, args___0);
#line 194
  __builtin_va_end(args___0);
#line 195
  tmp = getpid();
  }
#line 195
  if (tmp == primary_pid) {
    {
#line 195
    complain("Aborted");
    }
  }
  {
#line 197
  exit(1);
  }
}
}
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 80
extern int optopt ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 224
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigdelset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 256
extern int ( __attribute__((__nonnull__(1))) sigsuspend)(sigset_t const   *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 583 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 78 "/home/june/collector/temp/anacron-2.3/global.h"
pid_t primary_pid  ;
#line 79 "/home/june/collector/temp/anacron-2.3/global.h"
char *program_name  ;
#line 80 "/home/june/collector/temp/anacron-2.3/global.h"
char *anacrontab  ;
#line 81 "/home/june/collector/temp/anacron-2.3/global.h"
char *spooldir  ;
#line 82 "/home/june/collector/temp/anacron-2.3/global.h"
int old_umask  ;
#line 83 "/home/june/collector/temp/anacron-2.3/global.h"
sigset_t old_sigmask  ;
#line 84 "/home/june/collector/temp/anacron-2.3/global.h"
int serialize  ;
#line 84 "/home/june/collector/temp/anacron-2.3/global.h"
int force  ;
#line 84 "/home/june/collector/temp/anacron-2.3/global.h"
int update_only  ;
#line 84 "/home/june/collector/temp/anacron-2.3/global.h"
int now  ;
#line 84 "/home/june/collector/temp/anacron-2.3/global.h"
int no_daemon  ;
#line 84 "/home/june/collector/temp/anacron-2.3/global.h"
int quiet  ;
#line 84 "/home/june/collector/temp/anacron-2.3/global.h"
int testing_only  ;
#line 85 "/home/june/collector/temp/anacron-2.3/global.h"
int day_now  ;
#line 86 "/home/june/collector/temp/anacron-2.3/global.h"
int year  ;
#line 86 "/home/june/collector/temp/anacron-2.3/global.h"
int month  ;
#line 86 "/home/june/collector/temp/anacron-2.3/global.h"
int day_of_month  ;
#line 87 "/home/june/collector/temp/anacron-2.3/global.h"
int in_background  ;
#line 89 "/home/june/collector/temp/anacron-2.3/global.h"
job_rec *first_job_rec  ;
#line 90 "/home/june/collector/temp/anacron-2.3/global.h"
env_rec *first_env_rec  ;
#line 92 "/home/june/collector/temp/anacron-2.3/global.h"
char **args  ;
#line 93 "/home/june/collector/temp/anacron-2.3/global.h"
int nargs  ;
#line 98 "/home/june/collector/temp/anacron-2.3/global.h"
int running_jobs  ;
#line 98 "/home/june/collector/temp/anacron-2.3/global.h"
int running_mailers  ;
#line 102 "/home/june/collector/temp/anacron-2.3/global.h"
char *mail_charset  ;
#line 107
int xopen(int fd , char const   *file_name , int flags ) ;
#line 131
void read_tab(int cwd ) ;
#line 132
void arrange_jobs(void) ;
#line 51 "/home/june/collector/temp/anacron-2.3/main.c"
char *defarg  =    (char *)"*";
#line 61 "/home/june/collector/temp/anacron-2.3/main.c"
static time_t start_sec  ;
#line 62 "/home/june/collector/temp/anacron-2.3/main.c"
static int volatile   got_sigalrm  ;
#line 62 "/home/june/collector/temp/anacron-2.3/main.c"
static int volatile   got_sigchld  ;
#line 62 "/home/june/collector/temp/anacron-2.3/main.c"
static int volatile   got_sigusr1  ;
#line 65 "/home/june/collector/temp/anacron-2.3/main.c"
static void print_version(void) 
{ 


  {
  {
#line 68
  printf((char const   */* __restrict  */)"Anacron 2.3\nCopyright (C) 1998  Itai Tzur <itzur@actcom.co.il>\nCopyright (C) 1999  Sean \'Shaleh\' Perry <shaleh@debian.org>\nCopyright (C) 2004  Pascal Hakim <pasc@redellipse.net>\n\nMail comments, suggestions and bug reports to <pasc@redellipse.net>.\n\n");
  }
#line 75
  return;
}
}
#line 77 "/home/june/collector/temp/anacron-2.3/main.c"
static void print_usage(void) 
{ 


  {
  {
#line 80
  printf((char const   */* __restrict  */)"Usage:  anacron [-s] [-f] [-n] [-d] [-q] [-t anacrontab] [-S spooldir] [job] ...\n        anacron [-S spooldir] -u [job] ...\n        anacron [-V|-h]\n        anacron -T [-t anacrontab]\n\n -s  Serialize execution of jobs\n -f  Force execution of jobs, even before their time\n -n  Run jobs with no delay, implies -s\n -d  Don\'t fork to the background\n -q  Suppress stderr messages, only applicable with -d\n -u  Update the timestamps without actually running anything\n -t  Use this anacrontab\n -V  Print version information\n -h  Print this message\n -T  Test an anacrontab\n -S  Select a different spool directory\n\nSee the manpage for more details.\n\n");
  }
#line 99
  return;
}
}
#line 101 "/home/june/collector/temp/anacron-2.3/main.c"
static void parse_opts(int argc , char **argv ) 
{ 
  int opt ;

  {
#line 107
  now = 0;
#line 107
  update_only = now;
#line 107
  force = update_only;
#line 107
  serialize = force;
#line 107
  no_daemon = serialize;
#line 107
  quiet = no_daemon;
#line 108
  opterr = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 109
    opt = getopt(argc, (char * const  *)argv, "sfundqt:TS:Vh");
    }
#line 109
    if (! (opt != -1)) {
#line 109
      goto while_break;
    }
    {
#line 113
    if (opt == 115) {
#line 113
      goto case_115;
    }
#line 116
    if (opt == 102) {
#line 116
      goto case_102;
    }
#line 119
    if (opt == 117) {
#line 119
      goto case_117;
    }
#line 122
    if (opt == 110) {
#line 122
      goto case_110;
    }
#line 125
    if (opt == 100) {
#line 125
      goto case_100;
    }
#line 128
    if (opt == 113) {
#line 128
      goto case_113;
    }
#line 131
    if (opt == 116) {
#line 131
      goto case_116;
    }
#line 134
    if (opt == 84) {
#line 134
      goto case_84;
    }
#line 137
    if (opt == 83) {
#line 137
      goto case_83;
    }
#line 140
    if (opt == 86) {
#line 140
      goto case_86;
    }
#line 143
    if (opt == 104) {
#line 143
      goto case_104;
    }
#line 146
    if (opt == 63) {
#line 146
      goto case_63;
    }
#line 111
    goto switch_break;
    case_115: /* CIL Label */ 
#line 114
    serialize = 1;
#line 115
    goto switch_break;
    case_102: /* CIL Label */ 
#line 117
    force = 1;
#line 118
    goto switch_break;
    case_117: /* CIL Label */ 
#line 120
    update_only = 1;
#line 121
    goto switch_break;
    case_110: /* CIL Label */ 
#line 123
    serialize = 1;
#line 123
    now = serialize;
#line 124
    goto switch_break;
    case_100: /* CIL Label */ 
#line 126
    no_daemon = 1;
#line 127
    goto switch_break;
    case_113: /* CIL Label */ 
#line 129
    quiet = 1;
#line 130
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 132
    anacrontab = strdup((char const   *)optarg);
    }
#line 133
    goto switch_break;
    case_84: /* CIL Label */ 
#line 135
    testing_only = 1;
#line 136
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 138
    spooldir = strdup((char const   *)optarg);
    }
#line 139
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 141
    print_version();
#line 142
    exit(0);
    }
    case_104: /* CIL Label */ 
    {
#line 144
    print_usage();
#line 145
    exit(0);
    }
    case_63: /* CIL Label */ 
    {
#line 147
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: invalid option: %c\n",
            program_name, optopt);
#line 149
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"type: `%s -h\' for more information\n",
            program_name);
#line 151
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  if (optind == argc) {
#line 157
    nargs = 1;
#line 158
    args = & defarg;
  } else {
#line 162
    nargs = argc - optind;
#line 163
    args = argv + optind;
  }
#line 165
  return;
}
}
#line 167 "/home/june/collector/temp/anacron-2.3/main.c"
pid_t xfork(void) 
{ 
  pid_t pid ;

  {
  {
#line 173
  pid = fork();
  }
#line 174
  if (pid == -1) {
    {
#line 174
    die_e("Can\'t fork");
    }
  }
#line 175
  return (pid);
}
}
#line 178 "/home/june/collector/temp/anacron-2.3/main.c"
int xopen(int fd , char const   *file_name , int flags ) 
{ 
  int rfd ;

  {
  {
#line 188
  rfd = open(file_name, flags);
  }
#line 189
  if (fd >= 0) {
#line 189
    if (rfd != fd) {
      {
#line 190
      die_e("Can\'t open %s on file-descriptor %d", file_name, fd);
      }
    } else {
#line 189
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 191
  if (rfd < 0) {
    {
#line 192
    die_e("Can\'t open %s", file_name);
    }
  }
#line 193
  return (rfd);
}
}
#line 196 "/home/june/collector/temp/anacron-2.3/main.c"
void xclose(int fd ) 
{ 
  int tmp ;

  {
  {
#line 200
  tmp = close(fd);
  }
#line 200
  if (tmp) {
    {
#line 200
    die_e("Can\'t close file descriptor %d", fd);
    }
  }
#line 201
  return;
}
}
#line 203 "/home/june/collector/temp/anacron-2.3/main.c"
static void go_background(void) 
{ 
  pid_t pid ;
  int tmp ;
  int tmp___0 ;
  __pid_t tmp___1 ;

  {
  {
#line 211
  tmp = fclose(stdout);
  }
#line 211
  if (tmp) {
    {
#line 211
    die_e("Can\'t close stdout");
    }
  }
  {
#line 212
  xopen(1, "/dev/null", 1);
#line 214
  tmp___0 = fclose(stderr);
  }
#line 214
  if (tmp___0) {
    {
#line 214
    die_e("Can\'t close stderr");
    }
  }
  {
#line 215
  xopen(2, "/dev/null", 1);
#line 217
  pid = xfork();
  }
#line 218
  if (pid != 0) {
    {
#line 221
    exit(0);
    }
  } else {
    {
#line 226
    primary_pid = getpid();
#line 227
    tmp___1 = setsid();
    }
#line 227
    if (tmp___1 == -1) {
      {
#line 227
      die_e("setsid() error");
      }
    }
#line 228
    in_background = 1;
  }
#line 230
  return;
}
}
#line 232 "/home/june/collector/temp/anacron-2.3/main.c"
void handle_sigalrm(void) 
{ 


  {
#line 235
  got_sigalrm = (int volatile   )1;
#line 236
  return;
}
}
#line 238 "/home/june/collector/temp/anacron-2.3/main.c"
void handle_sigchld(void) 
{ 


  {
#line 241
  got_sigchld = (int volatile   )1;
#line 242
  return;
}
}
#line 244 "/home/june/collector/temp/anacron-2.3/main.c"
void handle_sigusr1(void) 
{ 


  {
#line 247
  got_sigusr1 = (int volatile   )1;
#line 248
  return;
}
}
#line 250 "/home/june/collector/temp/anacron-2.3/main.c"
static void set_signal_handling(void) 
{ 
  sigset_t ss ;
  struct sigaction sa ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 259
  got_sigusr1 = (int volatile   )0;
#line 259
  got_sigchld = got_sigusr1;
#line 259
  got_sigalrm = got_sigchld;
#line 262
  tmp = sigemptyset(& ss);
  }
#line 262
  if (tmp) {
    {
#line 265
    die_e("sigset error");
    }
  } else {
    {
#line 262
    tmp___0 = sigaddset(& ss, 14);
    }
#line 262
    if (tmp___0) {
      {
#line 265
      die_e("sigset error");
      }
    } else {
      {
#line 262
      tmp___1 = sigaddset(& ss, 17);
      }
#line 262
      if (tmp___1) {
        {
#line 265
        die_e("sigset error");
        }
      } else {
        {
#line 262
        tmp___2 = sigaddset(& ss, 10);
        }
#line 262
        if (tmp___2) {
          {
#line 265
          die_e("sigset error");
          }
        }
      }
    }
  }
  {
#line 266
  tmp___3 = sigprocmask(0, (sigset_t const   */* __restrict  */)(& ss), (sigset_t */* __restrict  */)((void *)0));
  }
#line 266
  if (tmp___3) {
    {
#line 266
    die_e("sigprocmask error");
    }
  }
  {
#line 269
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))(& handle_sigalrm);
#line 270
  sa.sa_mask = ss;
#line 271
  sa.sa_flags = 0;
#line 272
  tmp___4 = sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 272
  if (tmp___4) {
    {
#line 272
    die_e("sigaction error");
    }
  }
  {
#line 275
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))(& handle_sigchld);
#line 276
  sa.sa_mask = ss;
#line 277
  sa.sa_flags = 1;
#line 278
  tmp___5 = sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 278
  if (tmp___5) {
    {
#line 278
    die_e("sigaction error");
    }
  }
  {
#line 281
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))(& handle_sigusr1);
#line 282
  sa.sa_mask = ss;
#line 283
  sa.sa_flags = 0;
#line 284
  tmp___6 = sigaction(10, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 284
  if (tmp___6) {
    {
#line 284
    die_e("sigaction error");
    }
  }
#line 285
  return;
}
}
#line 287 "/home/june/collector/temp/anacron-2.3/main.c"
static void wait_signal(void) 
{ 
  sigset_t ss ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 293
  tmp = sigprocmask(0, (sigset_t const   */* __restrict  */)((void *)0), (sigset_t */* __restrict  */)(& ss));
  }
#line 293
  if (tmp) {
    {
#line 293
    die_e("sigprocmask error");
    }
  }
  {
#line 294
  tmp___0 = sigdelset(& ss, 14);
  }
#line 294
  if (tmp___0) {
    {
#line 296
    die_e("sigset error");
    }
  } else {
    {
#line 294
    tmp___1 = sigdelset(& ss, 17);
    }
#line 294
    if (tmp___1) {
      {
#line 296
      die_e("sigset error");
      }
    } else {
      {
#line 294
      tmp___2 = sigdelset(& ss, 10);
      }
#line 294
      if (tmp___2) {
        {
#line 296
        die_e("sigset error");
        }
      }
    }
  }
  {
#line 297
  sigsuspend((sigset_t const   *)(& ss));
  }
#line 298
  return;
}
}
#line 300 "/home/june/collector/temp/anacron-2.3/main.c"
static void wait_children(void) 
{ 


  {
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (running_jobs > 0)) {
#line 304
      if (! (running_mailers > 0)) {
#line 304
        goto while_break;
      }
    }
    {
#line 306
    wait_signal();
    }
#line 307
    if (got_sigchld) {
      {
#line 307
      tend_children();
      }
    }
#line 308
    got_sigchld = (int volatile   )0;
#line 309
    if (got_sigusr1) {
      {
#line 309
      explain("Received SIGUSR1");
      }
    }
#line 310
    got_sigusr1 = (int volatile   )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  return;
}
}
#line 314 "/home/june/collector/temp/anacron-2.3/main.c"
static void orderly_termination(void) 
{ 


  {
  {
#line 318
  explain("Received SIGUSR1");
#line 319
  got_sigusr1 = (int volatile   )0;
#line 320
  wait_children();
#line 321
  explain("Exited");
#line 322
  exit(0);
  }
}
}
#line 325 "/home/june/collector/temp/anacron-2.3/main.c"
static void xsleep(unsigned int n ) 
{ 


  {
#line 331
  if (n == 0U) {
#line 331
    return;
  }
  {
#line 332
  alarm(n);
  }
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 335
    wait_signal();
    }
#line 336
    if (got_sigchld) {
      {
#line 336
      tend_children();
      }
    }
#line 337
    got_sigchld = (int volatile   )0;
#line 338
    if (got_sigusr1) {
      {
#line 338
      orderly_termination();
      }
    }
#line 333
    if (! (! got_sigalrm)) {
#line 333
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  got_sigalrm = (int volatile   )0;
#line 342
  return;
}
}
#line 344 "/home/june/collector/temp/anacron-2.3/main.c"
static void wait_jobs(void) 
{ 


  {
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! (running_jobs > 0)) {
#line 350
      goto while_break;
    }
    {
#line 352
    wait_signal();
    }
#line 353
    if (got_sigchld) {
      {
#line 353
      tend_children();
      }
    }
#line 354
    got_sigchld = (int volatile   )0;
#line 355
    if (got_sigusr1) {
      {
#line 355
      orderly_termination();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  return;
}
}
#line 359 "/home/june/collector/temp/anacron-2.3/main.c"
static void record_start_time(void) 
{ 
  struct tm *tm_now ;

  {
  {
#line 364
  start_sec = time((time_t *)((void *)0));
#line 365
  tm_now = localtime((time_t const   *)(& start_sec));
#line 366
  year = tm_now->tm_year + 1900;
#line 367
  month = tm_now->tm_mon + 1;
#line 368
  day_of_month = tm_now->tm_mday;
#line 369
  day_now = day_num(year, month, day_of_month);
  }
#line 370
  if (day_now == -1) {
    {
#line 370
    die("Invalid date (this is really embarrassing)");
    }
  }
#line 371
  if (! update_only) {
#line 371
    if (! testing_only) {
      {
#line 372
      explain("Anacron 2.3 started on %04d-%02d-%02d", year, month, day_of_month);
      }
    }
  }
#line 374
  return;
}
}
#line 376 "/home/june/collector/temp/anacron-2.3/main.c"
static int time_till(job_rec *jr ) 
{ 
  unsigned int tj ;
  unsigned int tn ;
  time_t tmp ;

  {
#line 384
  if (now) {
#line 384
    return (0);
  }
  {
#line 385
  tmp = time((time_t *)((void *)0));
#line 385
  tn = (unsigned int )tmp;
#line 386
  tj = (unsigned int )(start_sec + (time_t )(jr->delay * 60));
  }
#line 387
  if (tj < tn) {
#line 387
    return (0);
  }
#line 388
  return ((int )(tj - tn));
}
}
#line 391 "/home/june/collector/temp/anacron-2.3/main.c"
static void fake_jobs(void) 
{ 
  int j ;

  {
#line 396
  j = 0;
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if (! (j < njobs)) {
#line 397
      goto while_break;
    }
    {
#line 399
    fake_job(*(job_array + j));
#line 400
    explain("Updated timestamp for job `%s\' to %04d-%02d-%02d", (*(job_array + j))->ident,
            year, month, day_of_month);
#line 402
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 404
  return;
}
}
#line 406 "/home/june/collector/temp/anacron-2.3/main.c"
static void explain_intentions(void) 
{ 
  int j ;

  {
#line 411
  j = 0;
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (! (j < njobs)) {
#line 412
      goto while_break;
    }
#line 414
    if (now) {
      {
#line 416
      explain("Will run job `%s\'", (*(job_array + j))->ident);
      }
    } else {
      {
#line 420
      explain("Will run job `%s\' in %d min.", (*(job_array + j))->ident, (*(job_array + j))->delay);
      }
    }
#line 423
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  if (serialize) {
#line 425
    if (njobs > 0) {
      {
#line 426
      explain("Jobs will be executed sequentially");
      }
    }
  }
#line 427
  return;
}
}
#line 429 "/home/june/collector/temp/anacron-2.3/main.c"
int main(int argc , char **argv ) 
{ 
  int j ;
  int cwd ;
  char *cs ;
  int tmp ;
  int tmp___0 ;
  __mode_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 437
  anacrontab = (char *)((void *)0);
#line 438
  spooldir = (char *)((void *)0);
#line 440
  program_name = strrchr((char const   *)*(argv + 0), '/');
  }
#line 440
  if ((unsigned long )program_name == (unsigned long )((void *)0)) {
#line 441
    program_name = *(argv + 0);
  } else {
#line 443
    program_name ++;
  }
  {
#line 448
  setlocale(0, "");
#line 451
  cs = nl_langinfo(14);
  }
#line 451
  if (cs) {
    {
#line 451
    tmp = strcmp((char const   *)cs, "ANSI_X3.4-1968");
    }
#line 451
    if (tmp != 0) {
      {
#line 452
      mail_charset = strdup((char const   *)cs);
      }
    } else {
#line 454
      mail_charset = (char *)"US-ASCII";
    }
  } else {
#line 454
    mail_charset = (char *)"US-ASCII";
  }
  {
#line 455
  setlocale(0, "C");
#line 457
  parse_opts(argc, argv);
  }
#line 459
  if ((unsigned long )anacrontab == (unsigned long )((void *)0)) {
    {
#line 460
    anacrontab = strdup("/etc/anacrontab");
    }
  }
#line 462
  if ((unsigned long )spooldir == (unsigned long )((void *)0)) {
    {
#line 463
    spooldir = strdup("/var/spool/anacron");
    }
  }
  {
#line 465
  cwd = open("./", 0);
  }
#line 465
  if (cwd == -1) {
    {
#line 466
    die_e("Can\'t save current directory");
    }
  }
  {
#line 469
  in_background = 0;
#line 471
  tmp___0 = chdir((char const   *)spooldir);
  }
#line 471
  if (tmp___0) {
    {
#line 471
    die_e("Can\'t chdir to %s", spooldir);
    }
  }
  {
#line 473
  tmp___1 = umask((__mode_t )0);
#line 473
  old_umask = (int )tmp___1;
#line 475
  tmp___2 = sigprocmask(0, (sigset_t const   */* __restrict  */)((void *)0), (sigset_t */* __restrict  */)(& old_sigmask));
  }
#line 475
  if (tmp___2) {
    {
#line 475
    die_e("sigset error");
    }
  }
  {
#line 477
  tmp___3 = fclose(stdin);
  }
#line 477
  if (tmp___3) {
    {
#line 477
    die_e("Can\'t close stdin");
    }
  }
  {
#line 478
  xopen(0, "/dev/null", 0);
  }
#line 480
  if (! no_daemon) {
#line 480
    if (! testing_only) {
      {
#line 481
      go_background();
      }
    } else {
      {
#line 483
      primary_pid = getpid();
      }
    }
  } else {
    {
#line 483
    primary_pid = getpid();
    }
  }
  {
#line 485
  record_start_time();
#line 486
  read_tab(cwd);
#line 487
  close(cwd);
#line 488
  arrange_jobs();
  }
#line 490
  if (testing_only) {
#line 492
    if (complaints) {
      {
#line 492
      exit(1);
      }
    }
    {
#line 494
    exit(0);
    }
  }
#line 497
  if (update_only) {
    {
#line 499
    fake_jobs();
#line 500
    exit(0);
    }
  }
  {
#line 503
  explain_intentions();
#line 504
  set_signal_handling();
#line 505
  running_mailers = 0;
#line 505
  running_jobs = running_mailers;
#line 506
  j = 0;
  }
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (j < njobs)) {
#line 506
      goto while_break;
    }
    {
#line 508
    tmp___4 = time_till(*(job_array + j));
#line 508
    xsleep((unsigned int )tmp___4);
    }
#line 509
    if (serialize) {
      {
#line 509
      wait_jobs();
      }
    }
    {
#line 510
    launch_job(*(job_array + j));
#line 506
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 512
  wait_children();
  }
#line 513
  if (njobs == 1) {
#line 513
    tmp___5 = "";
  } else {
#line 513
    tmp___5 = "s";
  }
  {
#line 513
  explain("Normal exit (%d job%s run)", njobs, tmp___5);
#line 514
  exit(0);
  }
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 180 "/usr/include/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 181
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 188
extern void obstack_free(struct obstack *__obstack , void *__glibc_block ) ;
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 501 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchdir)(int __fd ) ;
#line 95 "/home/june/collector/temp/anacron-2.3/global.h"
int njobs  ;
#line 96 "/home/june/collector/temp/anacron-2.3/global.h"
job_rec **job_array  ;
#line 41 "/home/june/collector/temp/anacron-2.3/readtab.c"
static struct obstack input_o  ;
#line 42 "/home/june/collector/temp/anacron-2.3/readtab.c"
static struct obstack tab_o  ;
#line 43 "/home/june/collector/temp/anacron-2.3/readtab.c"
static FILE *tab  ;
#line 46 "/home/june/collector/temp/anacron-2.3/readtab.c"
static int jobs_read  ;
#line 47 "/home/june/collector/temp/anacron-2.3/readtab.c"
static int line_num  ;
#line 48 "/home/june/collector/temp/anacron-2.3/readtab.c"
static job_rec *last_job_rec  ;
#line 49 "/home/june/collector/temp/anacron-2.3/readtab.c"
static env_rec *last_env_rec  ;
#line 55 "/home/june/collector/temp/anacron-2.3/readtab.c"
static void *xmalloc(size_t size ) 
{ 
  void *ptr ;

  {
  {
#line 61
  ptr = malloc(size);
  }
#line 62
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 63
    die("Memory exhausted");
    }
  }
#line 64
  return (ptr);
}
}
#line 67 "/home/june/collector/temp/anacron-2.3/readtab.c"
static int conv2int(char const   *s ) 
{ 
  long l ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 74
  tmp = __errno_location();
#line 74
  *tmp = 0;
#line 75
  l = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)((void *)0),
             10);
#line 77
  tmp___0 = __errno_location();
  }
#line 77
  if (*tmp___0 == 34) {
#line 77
    return (-1);
  } else
#line 77
  if (l < 0L) {
#line 77
    return (-1);
  } else
#line 77
  if (l > 2147483647L) {
#line 77
    return (-1);
  }
#line 78
  return ((int )l);
}
}
#line 81 "/home/june/collector/temp/anacron-2.3/readtab.c"
static char *read_tab_line(void) 
{ 
  int c ;
  int prev ;
  int tmp ;
  struct obstack *__o ;
  char *tmp___0 ;
  struct obstack *__o___0 ;
  char *tmp___1 ;
  struct obstack *__o___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  struct obstack *__o___2 ;
  char *tmp___4 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 87
  prev = 0;
#line 89
  tmp = feof(tab);
  }
#line 89
  if (tmp) {
#line 89
    return ((char *)((void *)0));
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 92
    c = _IO_getc(tab);
    }
#line 93
    if (c == 10) {
#line 93
      if (prev != 92) {
#line 93
        goto _L;
      } else {
#line 93
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 93
    if (c == -1) {
      _L: /* CIL Label */ 
#line 95
      if (0 != prev) {
#line 95
        __o = & input_o;
#line 95
        if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
          {
#line 95
          _obstack_newchunk(__o, 1);
          }
        }
#line 95
        tmp___0 = __o->next_free;
#line 95
        (__o->next_free) ++;
#line 95
        *tmp___0 = (char )prev;
      }
#line 96
      goto while_break;
    }
#line 99
    if (92 != prev) {
#line 99
      if (0 != prev) {
#line 99
        if (10 != prev) {
#line 99
          __o___0 = & input_o;
#line 99
          if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
            {
#line 99
            _obstack_newchunk(__o___0, 1);
            }
          }
#line 99
          tmp___1 = __o___0->next_free;
#line 99
          (__o___0->next_free) ++;
#line 99
          *tmp___1 = (char )prev;
        } else {
#line 99
          goto _L___2;
        }
      } else {
#line 99
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 100
    if (10 == prev) {
#line 100
      __o___1 = & input_o;
#line 100
      if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
        {
#line 100
        _obstack_newchunk(__o___1, 1);
        }
      }
#line 100
      tmp___2 = __o___1->next_free;
#line 100
      (__o___1->next_free) ++;
#line 100
      *tmp___2 = (char )' ';
    }
#line 102
    prev = c;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  tmp___3 = ferror(tab);
  }
#line 104
  if (tmp___3) {
    {
#line 104
    die_e("Error reading %s", anacrontab);
    }
  }
#line 105
  __o___2 = & input_o;
#line 105
  if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
    {
#line 105
    _obstack_newchunk(__o___2, 1);
    }
  }
#line 105
  tmp___4 = __o___2->next_free;
#line 105
  (__o___2->next_free) ++;
#line 105
  *tmp___4 = (char )'\000';
#line 106
  __o1 = & input_o;
#line 106
  __value = (void *)__o1->object_base;
#line 106
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 106
    __o1->maybe_empty_object = 1U;
  }
#line 106
  if (sizeof(long ) < sizeof(void *)) {
#line 106
    tmp___5 = __o1->object_base;
  } else {
#line 106
    tmp___5 = (char *)0;
  }
#line 106
  if (sizeof(long ) < sizeof(void *)) {
#line 106
    tmp___6 = __o1->object_base;
  } else {
#line 106
    tmp___6 = (char *)0;
  }
#line 106
  __o1->next_free = tmp___5 + (((__o1->next_free - tmp___6) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 106
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 106
    __o1->next_free = __o1->chunk_limit;
  }
#line 106
  __o1->object_base = __o1->next_free;
#line 106
  return ((char *)__value);
}
}
#line 109 "/home/june/collector/temp/anacron-2.3/readtab.c"
static int job_arg_num(char const   *ident ) 
{ 
  int i ;
  int r ;

  {
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < nargs)) {
#line 117
      goto while_break;
    }
    {
#line 119
    r = fnmatch((char const   *)*(args + i), ident, 0);
    }
#line 120
    if (r == 0) {
#line 120
      return (i);
    }
#line 121
    if (r != 1) {
      {
#line 121
      die("fnmatch() error");
      }
    }
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return (-1);
}
}
#line 126 "/home/june/collector/temp/anacron-2.3/readtab.c"
static void register_env(char const   *env_var , char const   *value ) 
{ 
  env_rec *er ;
  int var_len ;
  int val_len ;
  size_t tmp ;
  size_t tmp___0 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 133
  tmp = strlen(env_var);
#line 133
  var_len = (int )tmp;
#line 134
  tmp___0 = strlen(value);
#line 134
  val_len = (int )tmp___0;
#line 135
  __h = & tab_o;
#line 135
  __o = __h;
#line 135
  __len = (int )sizeof(env_rec );
  }
#line 135
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 135
    _obstack_newchunk(__o, __len);
    }
  }
#line 135
  __o->next_free += __len;
#line 135
  __o1 = __h;
#line 135
  __value = (void *)__o1->object_base;
#line 135
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 135
    __o1->maybe_empty_object = 1U;
  }
#line 135
  if (sizeof(long ) < sizeof(void *)) {
#line 135
    tmp___1 = __o1->object_base;
  } else {
#line 135
    tmp___1 = (char *)0;
  }
#line 135
  if (sizeof(long ) < sizeof(void *)) {
#line 135
    tmp___2 = __o1->object_base;
  } else {
#line 135
    tmp___2 = (char *)0;
  }
#line 135
  __o1->next_free = tmp___1 + (((__o1->next_free - tmp___2) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 135
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 135
    __o1->next_free = __o1->chunk_limit;
  }
#line 135
  __o1->object_base = __o1->next_free;
#line 135
  er = (env_rec *)__value;
#line 136
  __h___0 = & tab_o;
#line 136
  __o___0 = __h___0;
#line 136
  __len___0 = ((var_len + 1) + val_len) + 1;
#line 136
  if (__o___0->chunk_limit - __o___0->next_free < (long )__len___0) {
    {
#line 136
    _obstack_newchunk(__o___0, __len___0);
    }
  }
#line 136
  __o___0->next_free += __len___0;
#line 136
  __o1___0 = __h___0;
#line 136
  __value___0 = (void *)__o1___0->object_base;
#line 136
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 136
    __o1___0->maybe_empty_object = 1U;
  }
#line 136
  if (sizeof(long ) < sizeof(void *)) {
#line 136
    tmp___3 = __o1___0->object_base;
  } else {
#line 136
    tmp___3 = (char *)0;
  }
#line 136
  if (sizeof(long ) < sizeof(void *)) {
#line 136
    tmp___4 = __o1___0->object_base;
  } else {
#line 136
    tmp___4 = (char *)0;
  }
#line 136
  __o1___0->next_free = tmp___3 + (((__o1___0->next_free - tmp___4) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 136
  if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 136
    __o1___0->next_free = __o1___0->chunk_limit;
  }
  {
#line 136
  __o1___0->object_base = __o1___0->next_free;
#line 136
  er->assign = (char *)__value___0;
#line 137
  strcpy((char */* __restrict  */)er->assign, (char const   */* __restrict  */)env_var);
#line 138
  *(er->assign + var_len) = (char )'=';
#line 139
  strcpy((char */* __restrict  */)((er->assign + var_len) + 1), (char const   */* __restrict  */)value);
#line 140
  *(er->assign + ((var_len + 1) + val_len)) = (char)0;
  }
#line 141
  if ((unsigned long )last_env_rec != (unsigned long )((void *)0)) {
#line 141
    last_env_rec->next = er;
  } else {
#line 142
    first_env_rec = er;
  }
#line 143
  last_env_rec = er;
#line 145
  return;
}
}
#line 147 "/home/june/collector/temp/anacron-2.3/readtab.c"
static void register_job(char const   *periods , char const   *delays , char const   *ident ,
                         char *command ) 
{ 
  int period ;
  int delay ;
  job_rec *jr ;
  int ident_len ;
  int command_len ;
  size_t tmp ;
  size_t tmp___0 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___3 ;
  char *tmp___4 ;
  struct obstack *__h___1 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___5 ;
  char *tmp___6 ;
  pid_t tmp___7 ;

  {
  {
#line 156
  tmp = strlen(ident);
#line 156
  ident_len = (int )tmp;
#line 157
  tmp___0 = strlen((char const   *)command);
#line 157
  command_len = (int )tmp___0;
#line 158
  jobs_read ++;
#line 159
  period = conv2int(periods);
#line 160
  delay = conv2int(delays);
  }
#line 161
  if (period < 0) {
    {
#line 163
    complain("%s: number out of range on line %d, skipping", anacrontab, line_num);
    }
#line 165
    return;
  } else
#line 161
  if (delay < 0) {
    {
#line 163
    complain("%s: number out of range on line %d, skipping", anacrontab, line_num);
    }
#line 165
    return;
  }
#line 167
  __h = & tab_o;
#line 167
  __o = __h;
#line 167
  __len = (int )sizeof(job_rec );
#line 167
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 167
    _obstack_newchunk(__o, __len);
    }
  }
#line 167
  __o->next_free += __len;
#line 167
  __o1 = __h;
#line 167
  __value = (void *)__o1->object_base;
#line 167
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 167
    __o1->maybe_empty_object = 1U;
  }
#line 167
  if (sizeof(long ) < sizeof(void *)) {
#line 167
    tmp___1 = __o1->object_base;
  } else {
#line 167
    tmp___1 = (char *)0;
  }
#line 167
  if (sizeof(long ) < sizeof(void *)) {
#line 167
    tmp___2 = __o1->object_base;
  } else {
#line 167
    tmp___2 = (char *)0;
  }
#line 167
  __o1->next_free = tmp___1 + (((__o1->next_free - tmp___2) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 167
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 167
    __o1->next_free = __o1->chunk_limit;
  }
#line 167
  __o1->object_base = __o1->next_free;
#line 167
  jr = (job_rec *)__value;
#line 168
  jr->period = period;
#line 169
  jr->named_period = 0;
#line 170
  jr->delay = delay;
#line 171
  jr->tab_line = line_num;
#line 172
  __h___0 = & tab_o;
#line 172
  __o___0 = __h___0;
#line 172
  __len___0 = ident_len + 1;
#line 172
  if (__o___0->chunk_limit - __o___0->next_free < (long )__len___0) {
    {
#line 172
    _obstack_newchunk(__o___0, __len___0);
    }
  }
#line 172
  __o___0->next_free += __len___0;
#line 172
  __o1___0 = __h___0;
#line 172
  __value___0 = (void *)__o1___0->object_base;
#line 172
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 172
    __o1___0->maybe_empty_object = 1U;
  }
#line 172
  if (sizeof(long ) < sizeof(void *)) {
#line 172
    tmp___3 = __o1___0->object_base;
  } else {
#line 172
    tmp___3 = (char *)0;
  }
#line 172
  if (sizeof(long ) < sizeof(void *)) {
#line 172
    tmp___4 = __o1___0->object_base;
  } else {
#line 172
    tmp___4 = (char *)0;
  }
#line 172
  __o1___0->next_free = tmp___3 + (((__o1___0->next_free - tmp___4) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 172
  if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 172
    __o1___0->next_free = __o1___0->chunk_limit;
  }
  {
#line 172
  __o1___0->object_base = __o1___0->next_free;
#line 172
  jr->ident = (char *)__value___0;
#line 173
  strcpy((char */* __restrict  */)jr->ident, (char const   */* __restrict  */)ident);
#line 174
  jr->arg_num = job_arg_num(ident);
#line 175
  __h___1 = & tab_o;
#line 175
  __o___1 = __h___1;
#line 175
  __len___1 = command_len + 1;
  }
#line 175
  if (__o___1->chunk_limit - __o___1->next_free < (long )__len___1) {
    {
#line 175
    _obstack_newchunk(__o___1, __len___1);
    }
  }
#line 175
  __o___1->next_free += __len___1;
#line 175
  __o1___1 = __h___1;
#line 175
  __value___1 = (void *)__o1___1->object_base;
#line 175
  if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 175
    __o1___1->maybe_empty_object = 1U;
  }
#line 175
  if (sizeof(long ) < sizeof(void *)) {
#line 175
    tmp___5 = __o1___1->object_base;
  } else {
#line 175
    tmp___5 = (char *)0;
  }
#line 175
  if (sizeof(long ) < sizeof(void *)) {
#line 175
    tmp___6 = __o1___1->object_base;
  } else {
#line 175
    tmp___6 = (char *)0;
  }
#line 175
  __o1___1->next_free = tmp___5 + (((__o1___1->next_free - tmp___6) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 175
  if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 175
    __o1___1->next_free = __o1___1->chunk_limit;
  }
  {
#line 175
  __o1___1->object_base = __o1___1->next_free;
#line 175
  jr->command = (char *)__value___1;
#line 176
  strcpy((char */* __restrict  */)jr->command, (char const   */* __restrict  */)command);
#line 177
  tmp___7 = 0;
#line 177
  jr->mailer_pid = tmp___7;
#line 177
  jr->job_pid = tmp___7;
  }
#line 178
  if ((unsigned long )last_job_rec != (unsigned long )((void *)0)) {
#line 178
    last_job_rec->next = jr;
  } else {
#line 179
    first_job_rec = jr;
  }
#line 180
  last_job_rec = jr;
#line 181
  jr->prev_env_rec = last_env_rec;
#line 182
  jr->next = (struct job_rec1 *)((void *)0);
#line 185
  return;
}
}
#line 187 "/home/june/collector/temp/anacron-2.3/readtab.c"
static void register_period_job(char const   *periods , char const   *delays , char const   *ident ,
                                char *command ) 
{ 
  int delay ;
  job_rec *jr ;
  int period_len ;
  int ident_len ;
  int command_len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___6 ;
  char *tmp___7 ;
  struct obstack *__h___1 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___8 ;
  char *tmp___9 ;
  pid_t tmp___10 ;

  {
  {
#line 196
  tmp = strlen(periods);
#line 196
  period_len = (int )tmp;
#line 197
  tmp___0 = strlen(ident);
#line 197
  ident_len = (int )tmp___0;
#line 198
  tmp___1 = strlen((char const   *)command);
#line 198
  command_len = (int )tmp___1;
#line 199
  jobs_read ++;
#line 200
  delay = conv2int(delays);
  }
#line 201
  if (delay < 0) {
    {
#line 203
    complain("%s: number out of range on line %d, skipping", anacrontab, line_num);
    }
#line 205
    return;
  }
#line 208
  __h = & tab_o;
#line 208
  __o = __h;
#line 208
  __len = (int )sizeof(job_rec );
#line 208
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 208
    _obstack_newchunk(__o, __len);
    }
  }
#line 208
  __o->next_free += __len;
#line 208
  __o1 = __h;
#line 208
  __value = (void *)__o1->object_base;
#line 208
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 208
    __o1->maybe_empty_object = 1U;
  }
#line 208
  if (sizeof(long ) < sizeof(void *)) {
#line 208
    tmp___2 = __o1->object_base;
  } else {
#line 208
    tmp___2 = (char *)0;
  }
#line 208
  if (sizeof(long ) < sizeof(void *)) {
#line 208
    tmp___3 = __o1->object_base;
  } else {
#line 208
    tmp___3 = (char *)0;
  }
#line 208
  __o1->next_free = tmp___2 + (((__o1->next_free - tmp___3) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 208
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 208
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 208
  __o1->object_base = __o1->next_free;
#line 208
  jr = (job_rec *)__value;
#line 209
  tmp___5 = strncmp("@monthly", periods, (size_t )7);
  }
#line 209
  if (tmp___5) {
    {
#line 211
    tmp___4 = strncmp("@yearly", periods, (size_t )7);
    }
#line 211
    if (tmp___4) {
      {
#line 214
      complain("%s: Unknown named period on line %d, skipping", anacrontab, line_num);
      }
    } else {
#line 212
      jr->named_period = 2;
    }
  } else {
#line 210
    jr->named_period = 1;
  }
#line 217
  jr->period = 0;
#line 218
  jr->delay = delay;
#line 219
  jr->tab_line = line_num;
#line 220
  __h___0 = & tab_o;
#line 220
  __o___0 = __h___0;
#line 220
  __len___0 = ident_len + 1;
#line 220
  if (__o___0->chunk_limit - __o___0->next_free < (long )__len___0) {
    {
#line 220
    _obstack_newchunk(__o___0, __len___0);
    }
  }
#line 220
  __o___0->next_free += __len___0;
#line 220
  __o1___0 = __h___0;
#line 220
  __value___0 = (void *)__o1___0->object_base;
#line 220
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 220
    __o1___0->maybe_empty_object = 1U;
  }
#line 220
  if (sizeof(long ) < sizeof(void *)) {
#line 220
    tmp___6 = __o1___0->object_base;
  } else {
#line 220
    tmp___6 = (char *)0;
  }
#line 220
  if (sizeof(long ) < sizeof(void *)) {
#line 220
    tmp___7 = __o1___0->object_base;
  } else {
#line 220
    tmp___7 = (char *)0;
  }
#line 220
  __o1___0->next_free = tmp___6 + (((__o1___0->next_free - tmp___7) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 220
  if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 220
    __o1___0->next_free = __o1___0->chunk_limit;
  }
  {
#line 220
  __o1___0->object_base = __o1___0->next_free;
#line 220
  jr->ident = (char *)__value___0;
#line 221
  strcpy((char */* __restrict  */)jr->ident, (char const   */* __restrict  */)ident);
#line 222
  jr->arg_num = job_arg_num(ident);
#line 223
  __h___1 = & tab_o;
#line 223
  __o___1 = __h___1;
#line 223
  __len___1 = command_len + 1;
  }
#line 223
  if (__o___1->chunk_limit - __o___1->next_free < (long )__len___1) {
    {
#line 223
    _obstack_newchunk(__o___1, __len___1);
    }
  }
#line 223
  __o___1->next_free += __len___1;
#line 223
  __o1___1 = __h___1;
#line 223
  __value___1 = (void *)__o1___1->object_base;
#line 223
  if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 223
    __o1___1->maybe_empty_object = 1U;
  }
#line 223
  if (sizeof(long ) < sizeof(void *)) {
#line 223
    tmp___8 = __o1___1->object_base;
  } else {
#line 223
    tmp___8 = (char *)0;
  }
#line 223
  if (sizeof(long ) < sizeof(void *)) {
#line 223
    tmp___9 = __o1___1->object_base;
  } else {
#line 223
    tmp___9 = (char *)0;
  }
#line 223
  __o1___1->next_free = tmp___8 + (((__o1___1->next_free - tmp___9) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 223
  if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 223
    __o1___1->next_free = __o1___1->chunk_limit;
  }
  {
#line 223
  __o1___1->object_base = __o1___1->next_free;
#line 223
  jr->command = (char *)__value___1;
#line 224
  strcpy((char */* __restrict  */)jr->command, (char const   */* __restrict  */)command);
#line 225
  tmp___10 = 0;
#line 225
  jr->mailer_pid = tmp___10;
#line 225
  jr->job_pid = tmp___10;
  }
#line 226
  if ((unsigned long )last_job_rec != (unsigned long )((void *)0)) {
#line 226
    last_job_rec->next = jr;
  } else {
#line 227
    first_job_rec = jr;
  }
#line 228
  last_job_rec = jr;
#line 229
  jr->prev_env_rec = last_env_rec;
#line 230
  jr->next = (struct job_rec1 *)((void *)0);
#line 233
  return;
}
}
#line 235 "/home/june/collector/temp/anacron-2.3/readtab.c"
static void parse_tab_line(char *line ) 
{ 
  int r ;
  char *env_var ;
  char *value ;
  char *periods ;
  char *delays ;
  char *ident ;
  char *command ;

  {
  {
#line 247
  r = match_rx("^[ \t]*($|#)", line, 0);
  }
#line 248
  if (r == -1) {
#line 248
    goto reg_err;
  }
#line 249
  if (r) {
#line 252
    return;
  }
  {
#line 256
  r = match_rx("^[ \t]*([^ \t=]+)[ \t]*=(.*)$", line, 2, & env_var, & value);
  }
#line 258
  if (r == -1) {
#line 258
    goto reg_err;
  }
#line 259
  if (r) {
    {
#line 261
    register_env((char const   *)env_var, (char const   *)value);
    }
#line 262
    return;
  }
  {
#line 266
  r = match_rx("^[ \t]*([[:digit:]]+)[ \t]+([[:digit:]]+)[ \t]+([^ \t/]+)[ \t]+([^ \t].*)$",
               line, 4, & periods, & delays, & ident, & command);
  }
#line 269
  if (r == -1) {
#line 269
    goto reg_err;
  }
#line 270
  if (r) {
    {
#line 272
    register_job((char const   *)periods, (char const   *)delays, (char const   *)ident,
                 command);
    }
#line 273
    return;
  }
  {
#line 277
  r = match_rx("^[ \t]*(@[^ \t]+)[ \t]+([[:digit:]]+)[ \t]+([^ \t/]+)[ \t]+([^ \t].*)$",
               line, 4, & periods, & delays, & ident, & command);
  }
#line 280
  if (r == -1) {
#line 280
    goto reg_err;
  }
#line 281
  if (r) {
    {
#line 283
    register_period_job((char const   *)periods, (char const   *)delays, (char const   *)ident,
                        command);
    }
#line 284
    return;
  }
  {
#line 287
  complain("Invalid syntax in %s on line %d - skipping this line", anacrontab, line_num);
  }
#line 289
  return;
  reg_err: 
  {
#line 292
  die("Regex error reading %s", anacrontab);
  }
#line 293
  return;
}
}
#line 295 "/home/june/collector/temp/anacron-2.3/readtab.c"
void read_tab(int cwd ) 
{ 
  char *tab_line ;
  int tmp ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 301
  last_job_rec = (job_rec *)((void *)0);
#line 301
  first_job_rec = last_job_rec;
#line 302
  last_env_rec = (env_rec *)((void *)0);
#line 302
  first_env_rec = last_env_rec;
#line 303
  jobs_read = 0;
#line 304
  line_num = 0;
#line 306
  fchdir(cwd);
#line 307
  tab = fopen((char const   */* __restrict  */)anacrontab, (char const   */* __restrict  */)"r");
#line 308
  tmp = chdir((char const   *)spooldir);
  }
#line 308
  if (tmp) {
    {
#line 308
    die_e("Can\'t chdir to %s", spooldir);
    }
  }
#line 310
  if ((unsigned long )tab == (unsigned long )((void *)0)) {
    {
#line 310
    die_e("Error opening %s", anacrontab);
    }
  }
  {
#line 312
  _obstack_begin(& input_o, 0, 0, (void *(*)(long  ))(& xmalloc), (void (*)(void * ))(& free));
#line 313
  _obstack_begin(& tab_o, 0, 0, (void *(*)(long  ))(& xmalloc), (void (*)(void * ))(& free));
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 314
    tab_line = read_tab_line();
    }
#line 314
    if (! ((unsigned long )tab_line != (unsigned long )((void *)0))) {
#line 314
      goto while_break;
    }
    {
#line 316
    line_num ++;
#line 317
    parse_tab_line(tab_line);
#line 318
    __o = & input_o;
#line 318
    __obj = (void *)tab_line;
    }
#line 318
    if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 318
      if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 318
        tmp___0 = (char *)__obj;
#line 318
        __o->object_base = tmp___0;
#line 318
        __o->next_free = tmp___0;
      } else {
        {
#line 318
        obstack_free(__o, __obj);
        }
      }
    } else {
      {
#line 318
      obstack_free(__o, __obj);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 320
  tmp___1 = fclose(tab);
  }
#line 320
  if (tmp___1) {
    {
#line 320
    die_e("Error closing %s", anacrontab);
    }
  }
#line 321
  return;
}
}
#line 323 "/home/june/collector/temp/anacron-2.3/readtab.c"
static int execution_order(job_rec const   **job1 , job_rec const   **job2 ) 
{ 
  int d ;

  {
#line 330
  d = (int )((*job1)->arg_num - (*job2)->arg_num);
#line 331
  if (d != 0) {
#line 331
    if (now) {
#line 331
      return (d);
    }
  }
#line 332
  d = (int )((*job1)->delay - (*job2)->delay);
#line 333
  if (d != 0) {
#line 333
    return (d);
  }
#line 334
  d = (int )((*job1)->tab_line - (*job2)->tab_line);
#line 335
  return (d);
}
}
#line 338 "/home/june/collector/temp/anacron-2.3/readtab.c"
void arrange_jobs(void) 
{ 
  job_rec *j ;
  struct obstack *__o ;
  int __len ;
  int tmp ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 347
  j = first_job_rec;
#line 348
  njobs = 0;
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! ((unsigned long )j != (unsigned long )((void *)0))) {
#line 349
      goto while_break;
    }
#line 351
    if (j->arg_num != -1) {
#line 351
      if (update_only) {
#line 351
        goto _L;
      } else
#line 351
      if (testing_only) {
#line 351
        goto _L;
      } else {
        {
#line 351
        tmp = consider_job(j);
        }
#line 351
        if (tmp) {
          _L: /* CIL Label */ 
#line 353
          njobs ++;
#line 354
          __o = & tab_o;
#line 354
          __len = (int )sizeof(j);
#line 354
          if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
            {
#line 354
            _obstack_newchunk(__o, __len);
            }
          }
          {
#line 354
          memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(& j),
                 (size_t )__len);
#line 354
          __o->next_free += __len;
          }
        }
      }
    }
#line 356
    j = j->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  __o1 = & tab_o;
#line 358
  __value = (void *)__o1->object_base;
#line 358
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 358
    __o1->maybe_empty_object = 1U;
  }
#line 358
  if (sizeof(long ) < sizeof(void *)) {
#line 358
    tmp___0 = __o1->object_base;
  } else {
#line 358
    tmp___0 = (char *)0;
  }
#line 358
  if (sizeof(long ) < sizeof(void *)) {
#line 358
    tmp___1 = __o1->object_base;
  } else {
#line 358
    tmp___1 = (char *)0;
  }
#line 358
  __o1->next_free = tmp___0 + (((__o1->next_free - tmp___1) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 358
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 358
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 358
  __o1->object_base = __o1->next_free;
#line 358
  job_array = (job_rec **)__value;
#line 361
  qsort((void *)job_array, (size_t )njobs, sizeof(*job_array), (int (*)(void const   * ,
                                                                        void const   * ))(& execution_order));
  }
#line 363
  return;
}
}
