/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_15 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_15 pthread_mutex_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_18 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_17 {
   struct __anonstruct___data_18 __data ;
   char __size[48] ;
   long long __align ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_17 pthread_cond_t;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 85 "../../src/include/datatypes.h"
struct _thread_data;
#line 85 "../../src/include/datatypes.h"
typedef struct _thread_data THREAD_DATA;
#line 86 "../../src/include/datatypes.h"
struct _thread_data {
   pthread_mutex_t *mut ;
   pthread_t run_thread ;
   pthread_t poll_thread ;
   pthread_t tempfile_thread ;
   int current_execs ;
   int max_execs ;
};
#line 27 "../../src/include/utils.h"
enum _msg_type;
#line 27 "../../src/include/utils.h"
typedef enum _msg_type MsgType;
#line 28
enum _msg_type {
    MSG_TYPE_ERROR_ABORT = 0,
    MSG_TYPE_ERROR_WARN = 1,
    MSG_TYPE_ERRNO_ABORT = 2,
    MSG_TYPE_ERRNO_WARN = 3,
    MSG_TYPE_MESSAGE = 4,
    MSG_TYPE_DEBUG_L1 = 5,
    MSG_TYPE_DEBUG_L2 = 6
} ;
#line 40 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
struct _file_entry;
#line 40 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
typedef struct _file_entry FileEntry;
#line 41 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
struct _file_entry {
   char *filename ;
   struct timeval tm ;
   int statd ;
   u_int32_t fileno ;
   struct stat sb ;
   FileEntry *next ;
   FileEntry *prev ;
};
#line 61
struct _tempfile_watch_request;
#line 61 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
typedef struct _tempfile_watch_request TempFileRequest;
#line 62 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
struct _tempfile_watch_request {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   int count ;
   int status ;
   void (*create_cb)(char * , struct stat * , void *data ) ;
   void (*remove_cb)(char * , struct stat * , void *data ) ;
   void *cb_data ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 27 "../../src/include/utils.h"
enum _msg_type;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 31 "../../src/include/datatypes.h"
struct _crash_report;
#line 31 "../../src/include/datatypes.h"
typedef struct _crash_report CrashReport;
#line 32 "../../src/include/datatypes.h"
struct __anonstruct_link_79 {
   struct _crash_report *dle_next ;
   struct _crash_report *dle_prev ;
   pthread_mutex_t dle_access ;
   unsigned int dle_reader_count ;
   unsigned int dle_writer_count ;
   pthread_cond_t dle_reader_wait ;
   pthread_cond_t dle_writer_wait ;
};
#line 32 "../../src/include/datatypes.h"
struct _crash_report {
   char *progname ;
   char *args_str ;
   char *env_str ;
   int signal ;
   int didCore ;
   struct __anonstruct_link_79 link ;
};
#line 42
enum _exec_entry_status;
#line 42 "../../src/include/datatypes.h"
typedef enum _exec_entry_status ExecEntryStatus;
#line 43
enum _exec_entry_status {
    EXEC_ENTRY_STATUS_NOTHING = 0,
    EXEC_ENTRY_STATUS_TEST = 1,
    EXEC_ENTRY_STATUS_TESTED = 2
} ;
#line 51
struct _exec_entry;
#line 51 "../../src/include/datatypes.h"
typedef struct _exec_entry ExecEntry;
#line 52 "../../src/include/datatypes.h"
struct __anonstruct_link_80 {
   struct _exec_entry *dle_next ;
   struct _exec_entry *dle_prev ;
   pthread_mutex_t dle_access ;
   unsigned int dle_reader_count ;
   unsigned int dle_writer_count ;
   pthread_cond_t dle_reader_wait ;
   pthread_cond_t dle_writer_wait ;
};
#line 52 "../../src/include/datatypes.h"
struct _exec_entry {
   char *fullname ;
   ExecEntryStatus status ;
   int test_flags ;
   struct stat filestat ;
   struct timeval testtime ;
   struct __anonstruct_link_80 link ;
};
#line 66
struct _test_entry;
#line 66 "../../src/include/datatypes.h"
typedef struct _test_entry TestEntry;
#line 67 "../../src/include/datatypes.h"
struct __anonstruct_link_81 {
   struct _test_entry *dle_next ;
   struct _test_entry *dle_prev ;
   pthread_mutex_t dle_access ;
   unsigned int dle_reader_count ;
   unsigned int dle_writer_count ;
   pthread_cond_t dle_reader_wait ;
   pthread_cond_t dle_writer_wait ;
};
#line 67 "../../src/include/datatypes.h"
struct _test_entry {
   pid_t pid ;
   int status ;
   char *progname ;
   char **args ;
   char *args_str ;
   char **env ;
   char *env_str ;
   int env_flag ;
   struct timeval tm ;
   struct __anonstruct_link_81 link ;
};
#line 27 "../../src/include/utils.h"
enum _msg_type;
#line 47 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/exec.c"
enum _exec_status;
#line 47 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/exec.c"
typedef enum _exec_status ExecStatus;
#line 48
enum _exec_status {
    EXEC_STATUS_DONE = 0,
    EXEC_STATUS_STALE = 1,
    EXEC_STATUS_GARBAGE = 2,
    EXEC_STATUS_NOTDONE = 3
} ;
#line 146 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/exec.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 146 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/exec.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 144 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/exec.c"
union __anonunion_84 {
   int __in ;
   int __i ;
};
#line 142 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/exec.c"
union __anonunion_85 {
   int __in ;
   int __i ;
};
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 534 "/usr/include/pthread.h"
struct __anonstruct___cancel_jmp_buf_40 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 534 "/usr/include/pthread.h"
struct __anonstruct___pthread_unwind_buf_t_39 {
   struct __anonstruct___cancel_jmp_buf_40 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 534 "/usr/include/pthread.h"
typedef struct __anonstruct___pthread_unwind_buf_t_39  __attribute__((__aligned__)) __pthread_unwind_buf_t;
#line 753
struct __jmp_buf_tag;
#line 42 "../../src/include/datatypes.h"
enum _exec_entry_status;
#line 27 "../../src/include/utils.h"
enum _msg_type;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_16 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_16 pthread_mutexattr_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_19 {
   char __size[4] ;
   int __align ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_19 pthread_condattr_t;
#line 42 "../../src/include/datatypes.h"
enum _exec_entry_status;
#line 27 "../../src/include/utils.h"
enum _msg_type;
#line 48 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
struct exec_entry_head {
   struct _exec_entry *dlh_first ;
   pthread_mutex_t dlh_access ;
   pthread_mutex_t dlh_ops ;
};
#line 142 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
struct test_entry_head {
   struct _test_entry *dlh_first ;
   pthread_mutex_t dlh_access ;
   pthread_mutex_t dlh_ops ;
};
#line 222 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
struct crashreport_slist_head {
   struct _crash_report *dlh_first ;
   pthread_mutex_t dlh_access ;
   pthread_mutex_t dlh_ops ;
};
#line 241 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
union __anonunion_65 {
   int __in ;
   int __i ;
};
#line 242 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
union __anonunion_66 {
   int __in ;
   int __i ;
};
#line 42 "../../src/include/datatypes.h"
enum _exec_entry_status;
#line 27 "../../src/include/utils.h"
enum _msg_type;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 183
extern int ( __attribute__((__nonnull__(1,2,3))) readdir_r)(DIR * __restrict  __dirp ,
                                                            struct dirent * __restrict  __entry ,
                                                            struct dirent ** __restrict  __result ) ;
#line 208
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) rewinddir)(DIR *__dirp ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 529
extern void pthread_testcancel(void) ;
#line 773
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 988
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
#line 1000
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
#line 27 "../../src/include/tempfiles.h"
int tempfile_request_add(void (*create)(char * , struct stat * , void *data ) , void (*remove___0)(char * ,
                                                                                                   struct stat * ,
                                                                                                   void *data ) ,
                         void *cbdata ) ;
#line 30
int tempfile_request_subtract(void) ;
#line 33
void tempfile_start(THREAD_DATA *data ) ;
#line 43 "../../src/include/utils.h"
void ( /* format attribute */  __bfbt_message)(MsgType type , char *function , int line ,
                                               char *fmt  , ...) ;
#line 60 "../../src/include/utils.h"
__inline static void *_xmalloc(size_t size , char *function , int line ) 
{ 
  void *temp ;

  {
  {
#line 64
  temp = malloc(size);
  }
#line 65
  if (! temp) {
    {
#line 66
    __bfbt_message((MsgType )2, (char *)"_xmalloc", 67, (char *)"Malloc failed at [%s:%d]",
                   function, line);
    }
  }
#line 68
  return (temp);
}
}
#line 74 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
static int initialized  =    0;
#line 77 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
static FileEntry *head  =    (FileEntry *)((void *)0);
#line 78 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
static FileEntry *tail  =    (FileEntry *)((void *)0);
#line 79 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
static TempFileRequest request  =    {{{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, 0, 0, (void (*)(char * , struct stat * ,
                                                                    void *data ))((void *)0),
    (void (*)(char * , struct stat * , void *data ))((void *)0), (void *)0};
#line 83 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
static int isNew(struct dirent *entry ) 
{ 
  FileEntry *entries ;

  {
#line 86
  entries = head;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (entries) {
#line 91
      if (! (entry->d_ino > (__ino_t )entries->fileno)) {
#line 91
        goto while_break;
      }
    } else {
#line 91
      goto while_break;
    }
#line 93
    entries = entries->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  if (entries) {
#line 95
    if ((__ino_t )entries->fileno == entry->d_ino) {
#line 102
      return (0);
    } else {
#line 104
      return (1);
    }
  } else {
#line 104
    return (1);
  }
}
}
#line 107 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
static void addFile(struct dirent *entry , struct timeval tm ) 
{ 
  FileEntry *new ;
  void *tmp ;
  FileEntry *temp ;

  {
  {
#line 112
  tmp = _xmalloc(sizeof(FileEntry ), (char *)"addFile", 112);
#line 112
  new = (FileEntry *)tmp;
#line 114
  new->filename = strdup((char const   *)(entry->d_name));
#line 115
  new->tm = tm;
#line 119
  new->fileno = (u_int32_t )entry->d_ino;
#line 121
  new->next = (FileEntry *)((void *)0);
#line 122
  new->prev = (FileEntry *)((void *)0);
  }
#line 124
  if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 125
    tail = new;
#line 125
    head = tail;
  } else
#line 126
  if (new->fileno < head->fileno) {
#line 127
    head->prev = new;
#line 128
    new->next = head;
#line 129
    head = new;
  } else
#line 130
  if (new->fileno > tail->fileno) {
#line 131
    new->prev = tail;
#line 132
    tail->next = new;
#line 133
    tail = new;
  } else {
#line 135
    temp = head;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! (new->fileno > temp->fileno)) {
#line 136
        goto while_break;
      }
#line 136
      temp = temp->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 137
    (temp->prev)->next = new;
#line 138
    new->prev = temp->prev;
#line 139
    new->next = temp;
#line 140
    temp->prev = new;
  }
#line 143
  if (request.create_cb) {
#line 143
    if (request.count) {
#line 143
      if (request.status == 2) {
        {
#line 145
        (*(request.create_cb))(new->filename, & new->sb, request.cb_data);
        }
      } else
#line 143
      if (request.status == 3) {
        {
#line 145
        (*(request.create_cb))(new->filename, & new->sb, request.cb_data);
        }
      }
    }
  }
#line 146
  return;
}
}
#line 148 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
static void updateFile(struct dirent *entry , struct timeval tm ) 
{ 
  FileEntry *temp ;

  {
#line 151
  temp = head;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((__ino_t )temp->fileno != entry->d_ino)) {
#line 154
      goto while_break;
    }
#line 160
    temp = temp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  temp->tm = tm;
#line 163
  return;
}
}
#line 166 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
static void removeFile(FileEntry *entry ) 
{ 


  {
#line 169
  if (entry->prev) {
#line 169
    if (entry->next) {
#line 170
      (entry->prev)->next = entry->next;
#line 171
      (entry->next)->prev = entry->prev;
    } else {
#line 169
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 173
  if ((unsigned long )head == (unsigned long )entry) {
#line 174
    if (entry->next) {
#line 175
      (entry->next)->prev = (FileEntry *)((void *)0);
    } else {
#line 177
      tail = (FileEntry *)((void *)0);
    }
#line 178
    head = entry->next;
  } else {
#line 180
    (entry->prev)->next = (FileEntry *)((void *)0);
#line 181
    tail = entry->prev;
  }
#line 185
  if (request.remove_cb) {
#line 185
    if (request.count) {
#line 185
      if (request.status == 2) {
        {
#line 187
        (*(request.remove_cb))(entry->filename, & entry->sb, request.cb_data);
        }
      } else
#line 185
      if (request.status == 3) {
        {
#line 187
        (*(request.remove_cb))(entry->filename, & entry->sb, request.cb_data);
        }
      }
    }
  }
#line 188
  return;
}
}
#line 191 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
static void deleteFile(FileEntry *entry ) 
{ 


  {
#line 194
  if (entry->filename) {
    {
#line 194
    free((void *)entry->filename);
    }
  }
  {
#line 195
  free((void *)entry);
  }
#line 196
  return;
}
}
#line 198 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
static void AddOrUpdate(struct dirent *entry , struct timeval tm ) 
{ 
  int tmp ;

  {
  {
#line 202
  tmp = isNew(entry);
  }
#line 202
  if (tmp) {
    {
#line 203
    addFile(entry, tm);
    }
  } else {
    {
#line 205
    updateFile(entry, tm);
    }
  }
#line 206
  return;
}
}
#line 208 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
static void tempfile_scandir(DIR *dir ) 
{ 
  struct dirent entry ;
  struct dirent *result ;
  int ret ;
  struct timeval tm ;
  FileEntry *temp ;
  FileEntry *dead ;
  int tmp ;

  {
  {
#line 217
  gettimeofday((struct timeval */* __restrict  */)(& tm), (__timezone_ptr_t )((void *)0));
#line 219
  ret = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& entry),
                  (struct dirent **/* __restrict  */)(& result));
  }
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (ret == 0) {
#line 220
      if (! ((unsigned long )result != (unsigned long )((void *)0))) {
#line 220
        goto while_break;
      }
    } else {
#line 220
      goto while_break;
    }
    {
#line 221
    AddOrUpdate(result, tm);
#line 222
    ret = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& entry),
                    (struct dirent **/* __restrict  */)(& result));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  if (ret == 0) {
#line 226
    temp = head;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! temp) {
#line 227
        goto while_break___0;
      }
      {
#line 228
      tmp = memcmp((void const   *)(& temp->tm), (void const   *)(& tm), sizeof(struct timeval ));
      }
#line 228
      if (tmp != 0) {
        {
#line 229
        dead = temp;
#line 230
        temp = temp->next;
#line 231
        removeFile(dead);
#line 232
        deleteFile(dead);
        }
      } else {
#line 234
        temp = temp->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 237
  rewinddir(dir);
  }
#line 238
  return;
}
}
#line 240 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
static void tempfile_request_startup(void) 
{ 


  {
  {
#line 244
  request.status = 2;
#line 245
  pthread_cond_signal(& request.cond);
  }
#line 246
  return;
}
}
#line 248 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
static void tempfile_request_shutdown(void) 
{ 


  {
  {
#line 252
  request.status = 0;
#line 253
  pthread_cond_signal(& request.cond);
  }
#line 254
  return;
}
}
#line 256 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
static void *tempfile_watch(void *data ) 
{ 
  char *dirname ;
  DIR *dir ;
  int lasttime ;

  {
  {
#line 262
  lasttime = 0;
#line 264
  dirname = getenv("BFBT_TMPDIR");
  }
#line 264
  if (! dirname) {
#line 265
    dirname = (char *)"/tmp";
  }
  {
#line 267
  initialized = 1;
#line 268
  dir = opendir((char const   *)dirname);
  }
#line 268
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    {
#line 269
    __bfbt_message((MsgType )0, (char *)"tempfile_watch", 269, (char *)"opendir: %s failed",
                   dirname);
    }
  }
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 272
    tempfile_scandir(dir);
#line 274
    pthread_mutex_lock(& request.mutex);
    }
#line 275
    if (request.status == 1) {
#line 275
      goto _L;
    } else
#line 275
    if (request.status == 3) {
      _L: /* CIL Label */ 
#line 276
      if (request.status == 1) {
#line 277
        if (lasttime) {
          {
#line 278
          tempfile_request_startup();
#line 279
          lasttime = 0;
          }
        } else {
#line 281
          lasttime = 1;
        }
      } else
#line 283
      if (lasttime) {
        {
#line 284
        tempfile_request_shutdown();
#line 285
        lasttime = 0;
        }
      } else {
#line 287
        lasttime = 1;
      }
    } else {
      {
#line 290
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 290
        if (! (request.status == 0)) {
#line 290
          goto while_break___0;
        }
        {
#line 291
        pthread_cond_wait((pthread_cond_t */* __restrict  */)(& request.cond), (pthread_mutex_t */* __restrict  */)(& request.mutex));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 292
    pthread_mutex_unlock(& request.mutex);
#line 293
    pthread_testcancel();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  return ((void *)0);
}
}
#line 298 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
int tempfile_request_add(void (*create)(char * , struct stat * , void *data ) , void (*remove___0)(char * ,
                                                                                                   struct stat * ,
                                                                                                   void *data ) ,
                         void *cbdata ) 
{ 


  {
#line 301
  if (! initialized) {
#line 302
    return (0);
  }
  {
#line 303
  pthread_mutex_lock(& request.mutex);
  }
#line 304
  if (request.count) {
#line 305
    return (-1);
  } else
#line 304
  if (request.status != 0) {
#line 305
    return (-1);
  }
  {
#line 306
  request.count = 1;
#line 307
  request.status = 1;
#line 308
  pthread_cond_signal(& request.cond);
  }
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! (request.status == 1)) {
#line 309
      goto while_break;
    }
    {
#line 310
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& request.cond), (pthread_mutex_t */* __restrict  */)(& request.mutex));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 311
  request.create_cb = create;
#line 312
  request.remove_cb = remove___0;
#line 313
  request.cb_data = cbdata;
#line 314
  pthread_mutex_unlock(& request.mutex);
  }
#line 315
  return (0);
}
}
#line 318 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
int tempfile_request_subtract(void) 
{ 


  {
#line 321
  if (! initialized) {
#line 322
    return (0);
  }
  {
#line 323
  pthread_mutex_unlock(& request.mutex);
  }
#line 324
  if (! request.count) {
#line 325
    return (-1);
  } else
#line 324
  if (request.status != 2) {
#line 325
    return (-1);
  }
#line 326
  request.status = 3;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! (request.status == 3)) {
#line 327
      goto while_break;
    }
    {
#line 328
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& request.cond), (pthread_mutex_t */* __restrict  */)(& request.mutex));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 329
  (request.count) --;
#line 330
  request.create_cb = (void (*)(char * , struct stat * , void *data ))((void *)0);
#line 331
  request.remove_cb = (void (*)(char * , struct stat * , void *data ))((void *)0);
#line 332
  request.cb_data = (void *)0;
#line 333
  pthread_mutex_unlock(& request.mutex);
  }
#line 334
  return (0);
}
}
#line 337 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/tempfiles.c"
void tempfile_start(THREAD_DATA *data ) 
{ 
  int tmp ;

  {
  {
#line 340
  tmp = pthread_create((pthread_t */* __restrict  */)(& data->tempfile_thread), (pthread_attr_t const   */* __restrict  */)((void *)0),
                       & tempfile_watch, (void */* __restrict  */)((void *)0));
  }
#line 340
  if (tmp != 0) {
    {
#line 341
    __bfbt_message((MsgType )2, (char *)"tempfile_start", 341, (char *)"tempfile thread create");
    }
  }
#line 342
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 359
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 72 "../../src/include/utils.h"
__inline static void *_xcalloc(size_t number , size_t size , char *function , int line ) 
{ 
  void *temp ;

  {
  {
#line 76
  temp = calloc(number, size);
  }
#line 77
  if (! temp) {
    {
#line 78
    __bfbt_message((MsgType )2, (char *)"_xcalloc", 79, (char *)"Calloc failed at [%s:%d]",
                   function, line);
    }
  }
#line 80
  return (temp);
}
}
#line 83
char *find_exec_in_path(char *name ) ;
#line 86
char *args_to_str(char **args ) ;
#line 89
char *env_to_str(char **env ) ;
#line 92
char **env_create(char **env ) ;
#line 39 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/utils.c"
FILE *fp_msg ;
#line 40
int debug_level ;
#line 42 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/utils.c"
void ( /* format attribute */  __bfbt_message)(MsgType type , char *function , int line ,
                                               char *fmt  , ...) 
{ 
  va_list args ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 48
  if ((unsigned int )type == 5U) {
#line 48
    if (debug_level < 1) {
#line 49
      return;
    }
  }
#line 50
  if ((unsigned int )type == 6U) {
#line 50
    if (debug_level < 2) {
#line 51
      return;
    }
  }
  {
#line 52
  __builtin_va_start(args, fmt);
  }
#line 54
  if ((unsigned int )type != 4U) {
    {
#line 55
    fprintf((FILE */* __restrict  */)fp_msg, (char const   */* __restrict  */)"[%s:%d] ",
            function, line);
    }
  }
  {
#line 56
  vfprintf((FILE */* __restrict  */)fp_msg, (char const   */* __restrict  */)fmt,
           args);
  }
#line 57
  if ((unsigned int )type == 2U) {
    {
#line 58
    tmp = __errno_location();
#line 58
    tmp___0 = strerror(*tmp);
#line 58
    fprintf((FILE */* __restrict  */)fp_msg, (char const   */* __restrict  */)": %s",
            tmp___0);
    }
  } else
#line 57
  if ((unsigned int )type == 3U) {
    {
#line 58
    tmp = __errno_location();
#line 58
    tmp___0 = strerror(*tmp);
#line 58
    fprintf((FILE */* __restrict  */)fp_msg, (char const   */* __restrict  */)": %s",
            tmp___0);
    }
  }
  {
#line 59
  fprintf((FILE */* __restrict  */)fp_msg, (char const   */* __restrict  */)"\n");
  }
#line 61
  if ((unsigned int )type == 0U) {
    {
#line 62
    exit(1);
    }
  } else
#line 61
  if ((unsigned int )type == 2U) {
    {
#line 62
    exit(1);
    }
  }
  {
#line 64
  __builtin_va_end(args);
  }
#line 65
  return;
}
}
#line 71 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/utils.c"
char *find_exec_in_path(char *name ) 
{ 
  char *str ;
  char *buf ;
  char *last ;
  char *path ;
  char *tmp ;
  char filename[4096] ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 74
  tmp = getenv("PATH");
#line 74
  path = tmp;
  }
#line 77
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 77
    if (! ((int )*(name + 0) != 0)) {
      {
#line 77
      __assert_fail("name != ((void *)0) && name[0] != \'\\0\'", "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/utils.c",
                    77U, "find_exec_in_path");
      }
    }
  } else {
    {
#line 77
    __assert_fail("name != ((void *)0) && name[0] != \'\\0\'", "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/utils.c",
                  77U, "find_exec_in_path");
    }
  }
#line 79
  if (path) {
    {
#line 80
    buf = strdup((char const   *)path);
    }
#line 80
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 81
      __bfbt_message((MsgType )0, (char *)"find_exec_in_path", 81, (char *)"out of memory");
      }
    }
    {
#line 82
    str = strtok_r((char */* __restrict  */)buf, (char const   */* __restrict  */)":",
                   (char **/* __restrict  */)(& last));
    }
    {
#line 83
    while (1) {
      while_continue: /* CIL Label */ ;
#line 83
      if (! str) {
#line 83
        goto while_break;
      }
      {
#line 84
      tmp___2 = strlen((char const   *)str);
      }
#line 84
      if ((int )*(str + (tmp___2 - 1UL)) == 47) {
#line 84
        tmp___1 = "";
      } else {
#line 84
        tmp___1 = "/";
      }
      {
#line 84
      tmp___3 = snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s%s%s",
                         str, tmp___1, name);
      }
#line 84
      if ((unsigned long )tmp___3 >= sizeof(filename)) {
#line 88
        goto __Cont;
      }
      {
#line 89
      tmp___5 = access((char const   *)(filename), 1);
      }
#line 89
      if (tmp___5 == 0) {
        {
#line 90
        free((void *)buf);
#line 91
        tmp___4 = strdup((char const   *)(filename));
        }
#line 91
        return (tmp___4);
      }
      __Cont: /* CIL Label */ 
      {
#line 83
      str = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":",
                     (char **/* __restrict  */)(& last));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 94
    free((void *)buf);
    }
  }
#line 96
  return ((char *)((void *)0));
}
}
#line 99 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/utils.c"
char *args_to_str(char **args ) 
{ 
  char *str ;
  char **temp ;
  int i ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char long_str[(sizeof("[12345]") - 1UL) + 1UL] ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 109
  if ((unsigned long )*(args + 1) == (unsigned long )((void *)0)) {
#line 110
    return ((char *)((void *)0));
  }
#line 112
  i = 0;
#line 112
  temp = args + 1;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! *temp) {
#line 112
      goto while_break;
    }
    {
#line 113
    tmp___2 = strlen((char const   *)*temp);
    }
#line 113
    if (tmp___2 > 100UL) {
#line 113
      tmp___1 = sizeof("[12345]") - 1UL;
    } else {
      {
#line 113
      tmp___0 = strlen((char const   *)*temp);
#line 113
      tmp___1 = tmp___0;
      }
    }
#line 113
    i = (int )((unsigned long )i + (tmp___1 + 1UL));
#line 112
    temp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  tmp___3 = _xcalloc((size_t )1, (size_t )i, (char *)"args_to_str", 115);
#line 115
  str = (char *)tmp___3;
#line 116
  temp = args + 1;
  }
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 116
    if (! *temp) {
#line 116
      goto while_break___0;
    }
    {
#line 117
    tmp___5 = strlen((char const   *)*temp);
    }
#line 117
    if (tmp___5 > 100UL) {
      {
#line 119
      tmp___4 = strlen((char const   *)*temp);
#line 119
      snprintf((char */* __restrict  */)(long_str), (sizeof("[12345]") - 1UL) + 1UL,
               (char const   */* __restrict  */)"[%5.5d]", (int )tmp___4);
#line 121
      strcat((char */* __restrict  */)str, (char const   */* __restrict  */)(long_str));
      }
    } else {
      {
#line 123
      strcat((char */* __restrict  */)str, (char const   */* __restrict  */)*temp);
      }
    }
#line 124
    if (*(temp + 1)) {
      {
#line 125
      strcat((char */* __restrict  */)str, (char const   */* __restrict  */)" ");
      }
    }
#line 116
    temp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 127
  return (str);
}
}
#line 130 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/utils.c"
char *env_to_str(char **env ) 
{ 
  char **temp ;
  char *str ;
  int i ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char long_env[(sizeof("[12345]") - 1UL) + 1UL] ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 139
  i = 0;
#line 139
  temp = env;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! *temp) {
#line 139
      goto while_break;
    }
    {
#line 140
    tmp___3 = strlen((char const   *)*temp);
    }
#line 140
    if (tmp___3 > 100UL) {
      {
#line 140
      tmp___0 = strcspn((char const   *)*temp, "=");
#line 140
      tmp___2 = (tmp___0 + 1UL) + (sizeof("[12345]") - 1UL);
      }
    } else {
      {
#line 140
      tmp___1 = strlen((char const   *)*temp);
#line 140
      tmp___2 = tmp___1;
      }
    }
#line 140
    i = (int )((size_t )i + (tmp___2 + 1UL));
#line 139
    temp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  tmp___4 = _xcalloc((size_t )1, (size_t )i, (char *)"env_to_str", 143);
#line 143
  str = (char *)tmp___4;
#line 144
  temp = env;
  }
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 144
    if (! *temp) {
#line 144
      goto while_break___0;
    }
    {
#line 145
    tmp___7 = strlen((char const   *)*temp);
    }
#line 145
    if (tmp___7 > 100UL) {
      {
#line 147
      tmp___5 = strcspn((char const   *)*temp, "=");
#line 147
      i = (int )tmp___5;
#line 148
      strncat((char */* __restrict  */)str, (char const   */* __restrict  */)*temp,
              (size_t )(i + 1));
#line 149
      tmp___6 = strlen((char const   *)((*temp + i) + 1));
#line 149
      snprintf((char */* __restrict  */)(long_env), (sizeof("[12345]") - 1UL) + 1UL,
               (char const   */* __restrict  */)"[%5.5d]", (int )tmp___6);
#line 151
      strcat((char */* __restrict  */)str, (char const   */* __restrict  */)(long_env));
      }
    } else {
      {
#line 153
      strcat((char */* __restrict  */)str, (char const   */* __restrict  */)*temp);
      }
    }
#line 154
    if (*(temp + 1)) {
      {
#line 155
      strcat((char */* __restrict  */)str, (char const   */* __restrict  */)" ");
      }
    }
#line 144
    temp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 157
  return (str);
}
}
#line 160 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/utils.c"
__inline static int env_not_used(char **env , char *str ) 
{ 
  int len ;
  size_t tmp ;
  char **temp ;
  int tmp___0 ;

  {
  {
#line 163
  tmp = strcspn((char const   *)str, "=");
#line 163
  len = (int )tmp;
#line 165
  temp = env;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! *temp) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___0 = strncmp((char const   *)*temp, (char const   *)str, (size_t )len);
    }
#line 166
    if (tmp___0 == 0) {
#line 167
      return (0);
    }
#line 165
    temp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return (1);
}
}
#line 171
extern char **environ ;
#line 173 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/utils.c"
char **env_create(char **env ) 
{ 
  int i ;
  int j ;
  char **temp ;
  char **temp2 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 184
  i = 0;
#line 184
  temp = env;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! *temp) {
#line 184
      goto while_break;
    }
#line 184
    temp ++;
#line 184
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  temp = environ;
  {
#line 185
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 185
    if (! *temp) {
#line 185
      goto while_break___0;
    }
#line 185
    temp ++;
#line 185
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 188
  tmp = _xcalloc((size_t )1, (unsigned long )(i + 1) * sizeof(*temp2), (char *)"env_create",
                 188);
#line 188
  temp2 = (char **)tmp;
#line 189
  j = 0;
#line 189
  temp = env;
  }
  {
#line 189
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 189
    if (! *temp) {
#line 189
      goto while_break___1;
    }
#line 190
    *(temp2 + j) = *temp;
#line 189
    j ++;
#line 189
    temp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 191
  temp = environ;
  {
#line 191
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 191
    if (! *temp) {
#line 191
      goto while_break___2;
    }
    {
#line 192
    tmp___0 = env_not_used(env, *temp);
    }
#line 192
    if (tmp___0) {
#line 193
      *(temp2 + j) = *temp;
#line 194
      j ++;
    }
#line 191
    temp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 196
  return (temp2);
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 551
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 646
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid ,
                                                                              __pid_t __pgid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 48 "../../src/include/data_stuff.h"
void TestEntry_destroy(TestEntry *entry ) ;
#line 51
TestEntry *TestEntry_create(ExecEntry *parent , char **args , char **env ) ;
#line 54
void TestEntry_insert(TestEntry *entry ) ;
#line 57
void TestEntry_remove(TestEntry *entry ) ;
#line 60
TestEntry *TestEntry_getnext(TestEntry **entry ) ;
#line 63
CrashReport *CrashReport_add(TestEntry *test_entry ) ;
#line 69
void CrashReport_log(CrashReport *report ) ;
#line 25 "../../src/include/exec.h"
int execute_program(ExecEntry *exec_entry , char **args , char **env ) ;
#line 28
void exec_poll(void) ;
#line 45 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/exec.c"
THREAD_DATA *q ;
#line 55 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/exec.c"
int execute_program(ExecEntry *exec_entry , char **args , char **env ) 
{ 
  TestEntry *test_entry ;
  pid_t tmp ;
  pid_t pgid ;
  __pid_t tmp___0 ;
  int tmp___1 ;

  {
#line 60
  if ((unsigned long )args == (unsigned long )((void *)0)) {
#line 61
    return (-1);
  }
#line 62
  if (q->current_execs >= q->max_execs) {
    {
#line 63
    __bfbt_message((MsgType )5, (char *)"execute_program", 63, (char *)"Hit maximum execs");
    }
#line 64
    return (-1);
  }
  {
#line 66
  test_entry = TestEntry_create(exec_entry, args, env);
#line 68
  tmp = fork();
#line 68
  test_entry->pid = tmp;
  }
  {
#line 69
  if (tmp == -1) {
#line 69
    goto case_neg_1;
  }
#line 75
  if (tmp == 0) {
#line 75
    goto case_0;
  }
#line 97
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 71
  __bfbt_message((MsgType )1, (char *)"execute_program", 71, (char *)"Couldn\'t fork process");
#line 72
  TestEntry_destroy(test_entry);
  }
#line 73
  return (1);
  case_0: /* CIL Label */ 
  {
#line 78
  tmp___0 = getpid();
#line 78
  pgid = tmp___0;
#line 79
  tmp___1 = setpgid(pgid, pgid);
  }
#line 79
  if (tmp___1 != 0) {
    {
#line 81
    __bfbt_message((MsgType )3, (char *)"execute_program", 81, (char *)"Couldn\'t set process group");
    }
  }
  {
#line 84
  close(0);
#line 85
  close(1);
#line 86
  close(2);
#line 88
  execve((char const   *)test_entry->progname, (char * const  *)test_entry->args,
         (char * const  *)test_entry->env);
#line 94
  __bfbt_message((MsgType )3, (char *)"execute_program", 94, (char *)"execve \'%s\'",
                 test_entry->progname);
#line 95
  _exit(2);
  }
  switch_default: /* CIL Label */ 
  {
#line 99
  gettimeofday((struct timeval */* __restrict  */)(& test_entry->tm), (__timezone_ptr_t )((void *)0));
#line 101
  TestEntry_insert(test_entry);
#line 102
  (q->current_execs) ++;
  }
  switch_break: /* CIL Label */ ;
  }
#line 105
  return (0);
}
}
#line 108 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/exec.c"
static void exec_kill(pid_t pid ) 
{ 


  {
  {
#line 111
  kill(- pid, 9);
  }
#line 112
  return;
}
}
#line 114 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/exec.c"
static ExecStatus exec_GetStatus(TestEntry *entry ) 
{ 
  struct timeval tm ;
  __pid_t tmp ;
  __pid_t tmp___0 ;

  {
  {
#line 121
  tmp = waitpid(entry->pid, & entry->status, 1);
  }
#line 121
  if (tmp > 0) {
#line 122
    return ((ExecStatus )0);
  }
  {
#line 124
  gettimeofday((struct timeval */* __restrict  */)(& tm), (__timezone_ptr_t )((void *)0));
  }
#line 125
  if (tm.tv_sec - entry->tm.tv_sec > 5L) {
    {
#line 126
    exec_kill(entry->pid);
#line 127
    tmp___0 = waitpid(entry->pid, & entry->status, 1);
    }
#line 127
    if (tmp___0 > 0) {
#line 128
      return ((ExecStatus )0);
    }
  }
#line 130
  if (tm.tv_sec - entry->tm.tv_sec > 40L) {
#line 131
    return ((ExecStatus )2);
  }
#line 132
  if (tm.tv_sec - entry->tm.tv_sec > 20L) {
#line 133
    return ((ExecStatus )1);
  }
#line 135
  return ((ExecStatus )3);
}
}
#line 138 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/exec.c"
static void exec_process_close(TestEntry *entry ) 
{ 
  union __anonunion_82 __constr_expr_0 ;
  union __anonunion_83 __constr_expr_1 ;
  CrashReport *report ;
  CrashReport *tmp ;
  union __anonunion_84 __constr_expr_2 ;
  union __anonunion_85 __constr_expr_3 ;

  {
#line 141
  (q->current_execs) --;
#line 142
  __constr_expr_3.__in = entry->status;
#line 142
  if (! ((__constr_expr_3.__i & 127) == 0)) {
#line 144
    __constr_expr_2.__in = entry->status;
#line 144
    if ((int )((signed char )((__constr_expr_2.__i & 127) + 1)) >> 1 > 0) {
#line 146
      __constr_expr_0.__in = entry->status;
#line 146
      if ((__constr_expr_0.__i & 127) == 9) {
#line 148
        return;
      } else {
#line 146
        __constr_expr_1.__in = entry->status;
#line 146
        if ((__constr_expr_1.__i & 127) == 13) {
#line 148
          return;
        }
      }
      {
#line 152
      tmp = CrashReport_add(entry);
#line 152
      report = tmp;
#line 153
      CrashReport_log(report);
      }
    } else {
      {
#line 156
      __bfbt_message((MsgType )1, (char *)"exec_process_close", 158, (char *)"%s ended in unknown condition, status=%d",
                     entry->progname, entry->status);
      }
    }
  }
#line 159
  return;
}
}
#line 162 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/exec.c"
void exec_poll(void) 
{ 
  TestEntry *temp ;
  TestEntry *dead ;
  ExecStatus tmp ;

  {
  {
#line 167
  temp = (TestEntry *)((void *)0);
#line 168
  temp = TestEntry_getnext(& temp);
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! temp) {
#line 168
      goto while_break;
    }
    {
#line 169
    tmp = exec_GetStatus(temp);
    }
    {
#line 170
    if ((unsigned int )tmp == 3U) {
#line 170
      goto case_3;
    }
#line 173
    if ((unsigned int )tmp == 0U) {
#line 173
      goto case_0;
    }
#line 176
    if ((unsigned int )tmp == 2U) {
#line 176
      goto case_2;
    }
#line 182
    if ((unsigned int )tmp == 1U) {
#line 182
      goto case_1;
    }
#line 169
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 171
    temp = TestEntry_getnext(& temp);
    }
#line 172
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 174
    exec_process_close(temp);
    }
    case_2: /* CIL Label */ 
    {
#line 177
    dead = temp;
#line 178
    temp = TestEntry_getnext(& temp);
#line 179
    TestEntry_remove(dead);
#line 180
    TestEntry_destroy(dead);
    }
#line 181
    goto switch_break;
    case_1: /* CIL Label */ 
#line 183
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return;
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 261 "/usr/include/pthread.h"
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 524
extern int pthread_cancel(pthread_t __th ) ;
#line 691
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 703
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 744
extern  __attribute__((__noreturn__)) void __pthread_unwind_next(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__)) ;
#line 754
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 26 "../../src/include/breaker_data.h"
char const   *args_options[63]  = 
#line 26 "../../src/include/breaker_data.h"
  {      "-0",      "-1",      "-2",      "-3", 
        "-4",      "-5",      "-6",      "-7", 
        "-8",      "-9",      "-@",      "-A", 
        "-B",      "-C",      "-D",      "-E", 
        "-F",      "-G",      "-H",      "-I", 
        "-J",      "-K",      "-L",      "-M", 
        "-N",      "-O",      "-P",      "-Q", 
        "-R",      "-S",      "-T",      "-U", 
        "-V",      "-W",      "-X",      "-Y", 
        "-Z",      "-a",      "-b",      "-c", 
        "-d",      "-e",      "-f",      "-g", 
        "-h",      "-i",      "-j",      "-k", 
        "-l",      "-m",      "-n",      "-o", 
        "-p",      "-q",      "-r",      "-s", 
        "-t",      "-u",      "-v",      "-w", 
        "-x",      "-y",      "-z"};
#line 43 "../../src/include/breaker_data.h"
char const   *envs[252]  = 
#line 43
  {      "USER",      "MAIL",      "HOME",      "ENV", 
        "MORE",      "TOP",      "CVSROOT",      "OLDPWD", 
        "WMAKER_BIN_NAME",      "PAGER",      "RSTAR_NO_WARN",      "OPTIND", 
        "LOGNAME",      "WINDOWID",      "MAILHOST",      "SHOPTYPE", 
        "TERM",      "BLOCKSIZE",      "DISPLAY",      "OPENSSL_CONF", 
        "PWD",      "TERMCAP",      "EDITOR",      "POSIXLY_CORRECT", 
        "BC_ENV_ARGS",      "BC_LINE_LENGTH",      "GNUTARGET",      "GENOCIDED", 
        "COLUMNS",      "EMULATION_ENVIRON",      "TARGET_ENVIRON",      "LD_RUN_PATH", 
        "LD_LIBRARY_PATH",      "TMPDIR",      "KRB5_CONFIG",      "TMP", 
        "TEMP",      "CVS_SERVER",      "CVS_CLIENT_PORT",      "CVS_CLIENT_LOG", 
        "CVS_RSH",      "IGNORE_ENV",      "CVS_PASSFILE",      "CVS_PASSWORD", 
        "TMPDIR_ENV",      "SCSI_MODES",      "EDITOR1_ENV",      "EDITOR2_ENV", 
        "EDITOR3_ENV",      "QUERY_STRINGCVSROOT_ENV",      "CVSREAD_ENV",      "CVSREADONLYFS_ENV", 
        "CVS_OPTIONS",      "CVSUMASK_ENV",      "CVS_SERVER_SLEEP",      "WRAPPER_ENV", 
        "DIFF_OPTIONS",      "DIFF",      "GETARGMANDOC",      "NAME, ENV_NAME", 
        "LANG",      "SUNPRO_DEPENDENCIES",      "DEPENDENCIES_OUTPUT",      "COLLECT_NO_DEMANGLE", 
        "SSL_CIPHER",      "COLLECT_GCC_OPTIONS",      "COLLECT_GCC",      "COMPILER_PATH", 
        "LIBRARY_PATH",      "TLINK_VERBOSE",      "SHELL",      "SSLEAY_CONF", 
        "PATH",      "HISTSIZE",      "GDBHISTFILE",      "PS2", 
        "EMACS",      "_POSIX_OPTION_ORDER",      "TZ",      "PATCH_GET", 
        "AFSLIBPATH",      "SIMPLE_BACKUP_SUFFIX",      "PATCH_VERSION_CONTROL",      "RMT", 
        "VERSION_CONTROL",      "INFOPATH",      "INFO_PRINT_COMMAND",      "LINES", 
        "USERNAME",      "AFS_SYSCALL",      "HZ",      "GREP_OPTIONS", 
        "SYSTEM",      "MANROFFSEQ",      "KRBTKFILE",      "MANSECT", 
        "MANLOCALES",      "MANPATH",      "PATCH_INDEX_FIRST",      "COMSPEC", 
        "TAPE",      "MODEMS",      "MUSIC_CD",      "CD_DRIVE", 
        "DISC",      "CDPLAY",      "CHANGER_ENV_VAR",      "LC_CTYPE", 
        "LS_COLWIDTHS",      "LC_TIME",      "AWKPATH",      "LOCALDEF", 
        "DSTKEYPATH",      "NET_ORDER",      "HES_DOMAIN",      "IRPD_HOST_ENV", 
        "LOCALDOMAIN",      "LCD_TYPE",      "CVS_LOCAL_BRANCH_NUM",      "PROFDIR", 
        "UDICONF",      "KERB_DBG",      "GTAGSWARNING",      "GTAGSDBPATH", 
        "GTAGSROOT",      "KRBCONFDIR",      "GTAGSLIBPATH",      "BROWSER", 
        "GTAGSCONF",      "GTAGSLABEL",      "GROFF_COMMAND_PREFIX",      "GROFF_FONT_PATH", 
        "GROFF_TYPESETTER",      "KRB4PRINCIPAL",      "GROFF_TMPDIR_ENVVAR",      "TMPDIR_ENVVAR", 
        "REFER",      "RANDFILE",      "FONTPATH_ENV_VAR",      "KRB5CCNAME", 
        "BUFMOD_FIXED",      "EL_SIZE",      "ABCDE",      "MOUSE_BUTTONS_123", 
        "NCURSES_NO_PADDING",      "BAUDRATE",      "CC",      "TERMINFO", 
        "TERMINFO_DIRS",      "FAITH_NS",      "TERMPATH",      "NCURSES_NO_SETBUF", 
        "KEYBOARD",      "HACKDIR",      "LC_MESSAGES",      "CSCOPE_DIRS", 
        "NEXINIT",      "EXINIT",      "TTYPROMPT",      "PERL_BADFREE", 
        "PERL_DESTRUCT_LEVEL",      "PERL5OPT",      "PERL_DEBUG_MSTATS",      "PERL5LIB", 
        "PERLLIB",      "YYDEBUG",      "TERMCAP_COLORS",      "PERL5DB", 
        "LANGUAGE",      "LC_ALL",      "LC_COLLATE",      "LC_NUMERIC", 
        "PERL_BADLANG",      "PERL_DL_NONLAZY",      "HOSTALIASES",      "GAI", 
        "USE_UNICODE",      "HACKPAGER",      "MAGIC",      "HACKOPTIONS", 
        "INVENT",      "VISUAL",      "MAILREADER",      "ROGUEOPTS", 
        "WOTD",      "SAILNAME",      "LIBDIR",      "DIALOGRC", 
        "RCSLOCALID",      "RCSINCEXC",      "RCSINIT",      "LDSO", 
        "OBJFORMAT",      "RES_OPTIONS",      "NLSPATH",      "REMOTE", 
        "MALLOC_OPTIONS",      "LIBC_R_DEBUG",      "DEBUGTTY",      "MAKE", 
        "HTTP_PROXY",      "FTP_TIMEOUT",      "LD_BIND_NOW",      "LD_DEBUG", 
        "LD_PRELOAD",      "LD_TRACE_LOADED_OBJECTS",      "LD_TRACE_LOADED_OBJECTS_PROGNAME",      "SYSINSTALL_DEBUG", 
        "LD_TRACE_LOADED_OBJECTS_FMT1",      "VINUM_DATEFORMAT",      "LD_TRACE_LOADED_OBJECTS_FMT2",      "VINUM_HISTORY", 
        "PROM_E_BOOTED_DEV",      "PROM_E_BOOTED_OSFLAGS",      "PHONES",      "PROM_E_BOOTED_FILE", 
        "kernelname",      "PROM_E_TTY_DEV",      "rootdev",      "currdev", 
        "autoboot_delay",      "bootfile",      "DOS_KERNEL",      "MINUSKVAR", 
        "FTP_PASSWORD",      "FTP_LOGIN",      "FTP_PROXY",      "HTTP_TIMEOUT", 
        "HTTP_AUTH",      "HTTP_PROXY_AUTH",      "FINGER",      "REPLYTO", 
        "FTPSERVERPORT",      "LOCATE_PATH",      "MACHINE",      "MACHINE_ARCH", 
        "MAKEOBJDIRPREFIX",      "MAKEOBJDIR",      "MAKEFLAGS",      "OBJFORMAT_PATH", 
        "NLSPROVIDER",      "V_TERMCAP",      "PRINTER",      "PACKAGESITE", 
        "_TOP",      "PKG_DBDIR",      "PKG_ADD_BASE",      "PKG_PATH", 
        "PKG_TMPDIR",      "CONNECT",      "EL_EDITOR",      "PW_SCAN_BIG_IDS"};
#line 36 "../../src/include/data_stuff.h"
ExecEntry *ExecEntry_getnext(ExecEntry **entry ) ;
#line 40 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/breaker.c"
static void breaker_execute_command(ExecEntry *exec_entry , char **args , char **env ) 
{ 
  int i ;
  int tmp ;

  {
#line 49
  i = 10000;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 49
    tmp = execute_program(exec_entry, args, env);
    }
#line 49
    if (! (tmp != 0)) {
#line 49
      goto while_break;
    }
    {
#line 50
    usleep((__useconds_t )i);
#line 49
    i *= 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return;
}
}
#line 57 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/breaker.c"
static void breaker_test_singlearg(ExecEntry *entry ) 
{ 
  char *args[4] ;
  char *long_arg ;
  int i ;
  int long_arg_len ;
  int short_arg_len ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 60
  args[0] = entry->fullname;
#line 60
  args[1] = (char *)((void *)0);
#line 60
  args[2] = (char *)((void *)0);
#line 60
  args[3] = (char *)((void *)0);
#line 64
  long_arg_len = 51201;
#line 64
  short_arg_len = 5121;
#line 66
  __bfbt_message((MsgType )4, (char *)"breaker_test_singlearg", 66, (char *)"   * Single argument testing");
#line 67
  tmp = _xcalloc((size_t )1, (size_t )short_arg_len, (char *)"breaker_test_singlearg",
                 67);
#line 67
  long_arg = (char *)tmp;
#line 68
  memset((void *)long_arg, 'A', (size_t )(short_arg_len - 1));
#line 69
  args[2] = long_arg;
#line 70
  i = 0;
  }
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! ((unsigned long )i < sizeof(args_options) / sizeof(args_options[0]))) {
#line 70
      goto while_break;
    }
    {
#line 71
    args[1] = (char *)args_options[i];
#line 72
    breaker_execute_command(entry, args, (char **)((void *)0));
#line 70
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  free((void *)long_arg);
#line 75
  tmp___0 = _xcalloc((size_t )1, (size_t )long_arg_len, (char *)"breaker_test_singlearg",
                     75);
#line 75
  long_arg = (char *)tmp___0;
#line 76
  memset((void *)long_arg, 'A', (size_t )(long_arg_len - 1));
#line 77
  args[2] = long_arg;
#line 78
  i = 0;
  }
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 78
    if (! ((unsigned long )i < sizeof(args_options) / sizeof(args_options[0]))) {
#line 78
      goto while_break___0;
    }
    {
#line 79
    args[1] = (char *)args_options[i];
#line 80
    breaker_execute_command(entry, args, (char **)((void *)0));
#line 78
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 82
  args[1] = long_arg;
#line 83
  args[2] = (char *)((void *)0);
#line 84
  breaker_execute_command(entry, args, (char **)((void *)0));
#line 85
  free((void *)long_arg);
#line 86
  sleep(1U);
  }
#line 88
  return;
}
}
#line 90 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/breaker.c"
static void breaker_test_multiplearg(ExecEntry *entry ) 
{ 
  char *args[7] ;
  unsigned int tmp ;
  char *long_arg ;
  int i ;
  int j ;
  int arg_len ;
  void *tmp___0 ;

  {
#line 93
  args[0] = (char *)((void *)0);
#line 93
  tmp = 1U;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (tmp >= 7U) {
#line 93
      goto while_break;
    }
#line 93
    args[tmp] = (char *)0;
#line 93
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 96
  arg_len = 10241;
#line 97
  args[0] = entry->fullname;
#line 99
  __bfbt_message((MsgType )4, (char *)"breaker_test_multiplearg", 99, (char *)"   * Multiple arguments testing");
#line 100
  tmp___0 = _xcalloc((size_t )1, (size_t )arg_len, (char *)"breaker_test_multiplearg",
                     100);
#line 100
  long_arg = (char *)tmp___0;
#line 101
  memset((void *)long_arg, 'A', (size_t )(arg_len - 1));
#line 102
  args[2] = long_arg;
#line 102
  args[3] = long_arg;
#line 102
  args[4] = (char *)((void *)0);
#line 103
  i = 0;
  }
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 103
    if (! ((unsigned long )i < sizeof(args_options) / sizeof(args_options[0]))) {
#line 103
      goto while_break___0;
    }
    {
#line 104
    args[1] = (char *)args_options[i];
#line 105
    breaker_execute_command(entry, args, (char **)((void *)0));
#line 103
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  args[2] = long_arg;
#line 107
  args[4] = long_arg;
#line 107
  args[5] = (char *)((void *)0);
#line 108
  i = 0;
  {
#line 108
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 108
    if (! ((unsigned long )i < sizeof(args_options) / sizeof(args_options[0]))) {
#line 108
      goto while_break___1;
    }
#line 109
    args[1] = (char *)args_options[i];
#line 110
    j = 0;
    {
#line 110
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 110
      if (! ((unsigned long )j < sizeof(args_options) / sizeof(args_options[0]))) {
#line 110
        goto while_break___2;
      }
      {
#line 111
      args[3] = (char *)args_options[j];
#line 112
      breaker_execute_command(entry, args, (char **)((void *)0));
#line 110
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 108
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 115
  args[2] = long_arg;
#line 115
  args[4] = long_arg;
#line 115
  args[5] = long_arg;
#line 115
  args[6] = (char *)((void *)0);
#line 116
  i = 0;
  {
#line 116
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 116
    if (! ((unsigned long )i < sizeof(args_options) / sizeof(args_options[0]))) {
#line 116
      goto while_break___3;
    }
#line 117
    args[1] = (char *)args_options[i];
#line 118
    j = 0;
    {
#line 118
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 118
      if (! ((unsigned long )j < sizeof(args_options) / sizeof(args_options[0]))) {
#line 118
        goto while_break___4;
      }
      {
#line 119
      args[3] = (char *)args_options[j];
#line 120
      breaker_execute_command(entry, args, (char **)((void *)0));
#line 118
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 116
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 123
  args[1] = long_arg;
#line 123
  args[2] = long_arg;
#line 123
  args[3] = (char *)((void *)0);
#line 124
  breaker_execute_command(entry, args, (char **)((void *)0));
#line 125
  free((void *)long_arg);
#line 126
  sleep(1U);
  }
#line 127
  return;
}
}
#line 129 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/breaker.c"
static void breaker_test_env(ExecEntry *entry ) 
{ 
  char *args_arr[3] ;
  char *envs_arr[2] ;
  char *long_arg ;
  char *long_arg2 ;
  int i ;
  int env_len ;
  int long_arg_len ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 132
  args_arr[0] = entry->fullname;
#line 132
  args_arr[1] = (char *)((void *)0);
#line 132
  args_arr[2] = (char *)((void *)0);
#line 133
  envs_arr[0] = (char *)((void *)0);
#line 133
  envs_arr[1] = (char *)((void *)0);
#line 136
  long_arg_len = 10241;
#line 138
  __bfbt_message((MsgType )4, (char *)"breaker_test_env", 138, (char *)"   * Environment variable testing");
#line 139
  tmp = _xcalloc((size_t )1, (size_t )long_arg_len, (char *)"breaker_test_env", 139);
#line 139
  long_arg = (char *)tmp;
#line 140
  tmp___0 = _xcalloc((size_t )1, (size_t )long_arg_len, (char *)"breaker_test_env",
                     140);
#line 140
  long_arg2 = (char *)tmp___0;
#line 141
  memset((void *)long_arg2, 'A', (size_t )(long_arg_len - 1));
#line 142
  envs_arr[0] = long_arg;
#line 143
  i = 0;
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! ((unsigned long )i < sizeof(envs) / sizeof(envs[0]))) {
#line 143
      goto while_break;
    }
    {
#line 144
    tmp___1 = strlen(envs[i]);
#line 144
    env_len = (int )tmp___1;
    }
#line 145
    if (env_len + 1 >= long_arg_len - 1) {
#line 145
      goto __Cont;
    }
    {
#line 146
    strcpy((char */* __restrict  */)long_arg, (char const   */* __restrict  */)envs[i]);
#line 147
    *(long_arg + env_len) = (char )'=';
#line 148
    memset((void *)((long_arg + env_len) + 1), 'A', (size_t )(((long_arg_len - env_len) - 1) - 1));
#line 150
    breaker_execute_command(entry, args_arr, envs_arr);
#line 152
    args_arr[1] = long_arg2;
#line 153
    breaker_execute_command(entry, args_arr, envs_arr);
#line 154
    args_arr[1] = (char *)((void *)0);
    }
    __Cont: /* CIL Label */ 
#line 143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 156
  free((void *)long_arg);
#line 157
  free((void *)long_arg2);
  }
#line 158
  return;
}
}
#line 160 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/breaker.c"
void breaker_tempfile_createcb(char *filename , struct stat *sb , void *data ) 
{ 
  ExecEntry *entry ;

  {
  {
#line 163
  entry = (ExecEntry *)data;
#line 165
  __bfbt_message((MsgType )4, (char *)"breaker_tempfile_createcb", 166, (char *)"[Tempfile: %s]+ \"%s\"",
                 entry->fullname, filename);
  }
#line 167
  return;
}
}
#line 169 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/breaker.c"
void breaker_tempfile_removecb(char *filename , struct stat *sb , void *data ) 
{ 
  ExecEntry *entry ;

  {
  {
#line 172
  entry = (ExecEntry *)data;
#line 174
  __bfbt_message((MsgType )4, (char *)"breaker_tempfile_removecb", 175, (char *)"[Tempfile: %s]- \"%s\"",
                 entry->fullname, filename);
  }
#line 176
  return;
}
}
#line 178 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/breaker.c"
static void breaker_runtests(ExecEntry *entry ) 
{ 
  int test_flags ;

  {
  {
#line 181
  test_flags = entry->test_flags;
#line 183
  tempfile_request_add(& breaker_tempfile_createcb, & breaker_tempfile_removecb, (void *)entry);
#line 186
  __bfbt_message((MsgType )4, (char *)"breaker_runtests", 186, (char *)"=> %s", entry->fullname);
  }
#line 187
  if (entry->filestat.st_mode & 2048U) {
    {
#line 188
    __bfbt_message((MsgType )4, (char *)"breaker_runtests", 189, (char *)" (setuid: %d)",
                   (int )entry->filestat.st_uid);
    }
  }
#line 190
  if (entry->filestat.st_mode & 1024U) {
    {
#line 191
    __bfbt_message((MsgType )4, (char *)"breaker_runtests", 192, (char *)" (setgid: %d)",
                   (int )entry->filestat.st_gid);
    }
  }
#line 195
  if (test_flags & 1) {
    {
#line 196
    breaker_test_singlearg(entry);
    }
  }
#line 199
  if (test_flags & (1 << 1)) {
    {
#line 200
    breaker_test_multiplearg(entry);
    }
  }
#line 203
  if (test_flags & (1 << 2)) {
    {
#line 204
    breaker_test_env(entry);
    }
  }
  {
#line 206
  tempfile_request_subtract();
  }
#line 207
  return;
}
}
#line 212 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/breaker.c"
static void breaker_cleanup(void *arg ) 
{ 


  {
  {
#line 215
  __bfbt_message((MsgType )4, (char *)"breaker_cleanup", 215, (char *)"Cleaning up...might take a few seconds");
#line 216
  sleep(6U);
#line 217
  exec_poll();
#line 218
  exec_poll();
  }
#line 219
  return;
}
}
#line 221 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/breaker.c"
void *breaker_run(void *data ) 
{ 
  ExecEntry *entry ;

  {
  {
#line 224
  entry = (ExecEntry *)((void *)0);
#line 226
  entry = ExecEntry_getnext(& entry);
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! entry) {
#line 227
      goto while_break;
    }
#line 228
    if ((unsigned int )entry->status == 1U) {
      {
#line 229
      gettimeofday((struct timeval */* __restrict  */)(& entry->testtime), (__timezone_ptr_t )((void *)0));
#line 230
      breaker_runtests(entry);
#line 231
      entry->status = (ExecEntryStatus )2;
      }
    }
    {
#line 233
    entry = ExecEntry_getnext(& entry);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return ((void *)0);
}
}
#line 244 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/breaker.c"
static void *poll_execs(void *data ) 
{ 
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 248
    __cancel_routine = & breaker_cleanup;
#line 248
    __cancel_arg = (void *)0;
#line 248
    tmp = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                      0);
#line 248
    __not_first_call = tmp;
#line 248
    tmp___0 = __builtin_expect((long )__not_first_call, 0L);
    }
#line 248
    if (tmp___0) {
      {
#line 248
      (*__cancel_routine)(__cancel_arg);
#line 248
      __pthread_unwind_next(& __cancel_buf);
      }
    }
    {
#line 248
    __pthread_register_cancel(& __cancel_buf);
    }
    {
#line 248
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 249
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 250
        exec_poll();
#line 251
        usleep((__useconds_t )100000);
#line 252
        pthread_testcancel();
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 254
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 254
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 248
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 254
    __pthread_unregister_cancel(& __cancel_buf);
    }
#line 248
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return ((void *)0);
}
}
#line 259 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/breaker.c"
void breaker_start(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 262
  tmp = pthread_create((pthread_t */* __restrict  */)(& q->run_thread), (pthread_attr_t const   */* __restrict  */)((void *)0),
                       & breaker_run, (void */* __restrict  */)((void *)0));
  }
#line 262
  if (tmp != 0) {
    {
#line 263
    __bfbt_message((MsgType )2, (char *)"breaker_start", 263, (char *)"Can\'t create run thread");
    }
  }
  {
#line 265
  tmp___0 = pthread_create((pthread_t */* __restrict  */)(& q->poll_thread), (pthread_attr_t const   */* __restrict  */)((void *)0),
                           & poll_execs, (void */* __restrict  */)((void *)0));
  }
#line 265
  if (tmp___0 != 0) {
    {
#line 266
    __bfbt_message((MsgType )2, (char *)"breaker_start", 266, (char *)"Can\'t create poll thread");
    }
  }
#line 268
  return;
}
}
#line 270 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/breaker.c"
void breaker_wait(void) 
{ 


  {
  {
#line 273
  pthread_join(q->run_thread, (void **)((void *)0));
#line 275
  pthread_cancel(q->poll_thread);
#line 276
  pthread_join(q->poll_thread, (void **)((void *)0));
  }
#line 278
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strsignal)(int __sig ) ;
#line 760 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 765
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 979
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                                        pthread_condattr_t const   * __restrict  __cond_attr ) ;
#line 984
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
#line 992
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
#line 26 "../../src/include/data_stuff.h"
ExecEntry *ExecEntry_add(char *name , struct stat *sb , ExecEntryStatus status , int test_flags ) ;
#line 30
void ExecEntry_subtract(ExecEntry *entry ) ;
#line 39
ExecEntry *ExecEntry_findbyname(char *name ) ;
#line 42
void ExecEntry_release(ExecEntry *entry ) ;
#line 45
int ExecEntry_isempty(void) ;
#line 66
void CrashReport_subtract(CrashReport *report ) ;
#line 48 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
struct exec_entry_head ExecEntry_Head  ;
#line 50
static void ExecEntry_constructor(void)  __attribute__((__constructor__)) ;
#line 53
static void ExecEntry_constructor(void)  __attribute__((__constructor__)) ;
#line 53 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
static void ExecEntry_constructor(void) 
{ 


  {
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 56
    ExecEntry_Head.dlh_first = (struct _exec_entry *)((void *)0);
#line 56
    pthread_mutex_init(& ExecEntry_Head.dlh_access, (pthread_mutexattr_t const   *)((void *)0));
#line 56
    pthread_mutex_init(& ExecEntry_Head.dlh_ops, (pthread_mutexattr_t const   *)((void *)0));
    }
#line 56
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return;
}
}
#line 59 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
__inline static void ExecEntry_init(ExecEntry *entry , struct stat *sb , char *fullname ,
                                    ExecEntryStatus status , int test_flags ) 
{ 


  {
  {
#line 63
  entry->fullname = strdup((char const   *)fullname);
#line 64
  memcpy((void */* __restrict  */)(& entry->filestat), (void const   */* __restrict  */)sb,
         sizeof(entry->filestat));
#line 65
  entry->status = status;
#line 66
  entry->test_flags = test_flags;
#line 67
  entry->testtime.tv_sec = (__time_t )0;
#line 68
  entry->testtime.tv_usec = (__suseconds_t )0;
  }
#line 69
  return;
}
}
#line 71 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
static void ExecEntry_destroy(ExecEntry *entry ) 
{ 


  {
#line 74
  if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
    {
#line 74
    __assert_fail("entry != ((void *)0)", "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c",
                  74U, "ExecEntry_destroy");
    }
  }
#line 75
  if (entry->fullname) {
    {
#line 75
    free((void *)entry->fullname);
    }
  }
  {
#line 76
  free((void *)entry);
  }
#line 77
  return;
}
}
#line 88 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
ExecEntry *ExecEntry_add(char *name , struct stat *sb , ExecEntryStatus status , int test_flags ) 
{ 
  ExecEntry *new ;
  void *tmp ;

  {
#line 94
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 94
    if (! ((unsigned long )sb != (unsigned long )((void *)0))) {
      {
#line 94
      __assert_fail("name != ((void *)0) && sb != ((void *)0)", "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c",
                    94U, "ExecEntry_add");
      }
    }
  } else {
    {
#line 94
    __assert_fail("name != ((void *)0) && sb != ((void *)0)", "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c",
                  94U, "ExecEntry_add");
    }
  }
  {
#line 96
  tmp = _xmalloc(sizeof(ExecEntry ), (char *)"ExecEntry_add", 96);
#line 96
  new = (ExecEntry *)tmp;
#line 97
  ExecEntry_init(new, sb, name, status, test_flags);
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 98
      pthread_mutex_init(& new->link.dle_access, (pthread_mutexattr_t const   *)((void *)0));
#line 98
      new->link.dle_reader_count = 0U;
#line 98
      new->link.dle_writer_count = 0U;
#line 98
      pthread_cond_init((pthread_cond_t */* __restrict  */)(& new->link.dle_reader_wait),
                        (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 98
      pthread_cond_init((pthread_cond_t */* __restrict  */)(& new->link.dle_writer_wait),
                        (pthread_condattr_t const   */* __restrict  */)((void *)0));
      }
#line 98
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 98
    pthread_mutex_lock(& ExecEntry_Head.dlh_ops);
#line 98
    pthread_mutex_lock(& ExecEntry_Head.dlh_access);
    }
    {
#line 98
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 98
      pthread_mutex_lock(& new->link.dle_access);
#line 98
      (new->link.dle_writer_count) ++;
      }
      {
#line 98
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 98
        if (! new->link.dle_reader_count) {
#line 98
          goto while_break___2;
        }
        {
#line 98
        pthread_cond_wait((pthread_cond_t */* __restrict  */)(& new->link.dle_writer_wait),
                          (pthread_mutex_t */* __restrict  */)(& new->link.dle_access));
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 98
      pthread_mutex_unlock(& new->link.dle_access);
      }
#line 98
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 98
    if (! ((unsigned long )ExecEntry_Head.dlh_first == (unsigned long )((void *)0))) {
      {
#line 98
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 98
        pthread_mutex_lock(& (ExecEntry_Head.dlh_first)->link.dle_access);
#line 98
        ((ExecEntry_Head.dlh_first)->link.dle_writer_count) ++;
        }
        {
#line 98
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 98
          if (! (ExecEntry_Head.dlh_first)->link.dle_reader_count) {
#line 98
            goto while_break___4;
          }
          {
#line 98
          pthread_cond_wait((pthread_cond_t */* __restrict  */)(& (ExecEntry_Head.dlh_first)->link.dle_writer_wait),
                            (pthread_mutex_t */* __restrict  */)(& (ExecEntry_Head.dlh_first)->link.dle_access));
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 98
        pthread_mutex_unlock(& (ExecEntry_Head.dlh_first)->link.dle_access);
        }
#line 98
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 98
      (ExecEntry_Head.dlh_first)->link.dle_prev = new;
      {
#line 98
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 98
        pthread_mutex_lock(& (ExecEntry_Head.dlh_first)->link.dle_access);
#line 98
        ((ExecEntry_Head.dlh_first)->link.dle_writer_count) --;
        }
#line 98
        if ((ExecEntry_Head.dlh_first)->link.dle_reader_count) {
          {
#line 98
          pthread_cond_broadcast(& (ExecEntry_Head.dlh_first)->link.dle_reader_wait);
          }
        }
        {
#line 98
        pthread_mutex_unlock(& (ExecEntry_Head.dlh_first)->link.dle_access);
        }
#line 98
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 98
    new->link.dle_next = ExecEntry_Head.dlh_first;
#line 98
    new->link.dle_prev = (struct _exec_entry *)((void *)0);
#line 98
    ExecEntry_Head.dlh_first = new;
    {
#line 98
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 98
      pthread_mutex_lock(& new->link.dle_access);
#line 98
      (new->link.dle_writer_count) --;
      }
#line 98
      if (new->link.dle_reader_count) {
        {
#line 98
        pthread_cond_broadcast(& new->link.dle_reader_wait);
        }
      }
      {
#line 98
      pthread_mutex_unlock(& new->link.dle_access);
      }
#line 98
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 98
    pthread_mutex_unlock(& ExecEntry_Head.dlh_access);
#line 98
    pthread_mutex_unlock(& ExecEntry_Head.dlh_ops);
    }
#line 98
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (new);
}
}
#line 102 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
void ExecEntry_subtract(ExecEntry *entry ) 
{ 


  {
#line 105
  if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
    {
#line 105
    __assert_fail("entry != ((void *)0)", "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c",
                  105U, "ExecEntry_subtract");
    }
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    pthread_mutex_lock(& ExecEntry_Head.dlh_ops);
    }
#line 106
    if ((unsigned long )entry->link.dle_prev == (unsigned long )((void *)0)) {
      {
#line 106
      pthread_mutex_lock(& ExecEntry_Head.dlh_access);
#line 106
      ExecEntry_Head.dlh_first = entry->link.dle_next;
      }
    } else {
      {
#line 106
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 106
        pthread_mutex_lock(& (entry->link.dle_prev)->link.dle_access);
#line 106
        ((entry->link.dle_prev)->link.dle_writer_count) ++;
        }
        {
#line 106
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 106
          if (! (entry->link.dle_prev)->link.dle_reader_count) {
#line 106
            goto while_break___1;
          }
          {
#line 106
          pthread_cond_wait((pthread_cond_t */* __restrict  */)(& (entry->link.dle_prev)->link.dle_writer_wait),
                            (pthread_mutex_t */* __restrict  */)(& (entry->link.dle_prev)->link.dle_access));
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 106
        pthread_mutex_unlock(& (entry->link.dle_prev)->link.dle_access);
        }
#line 106
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 106
      (entry->link.dle_prev)->link.dle_next = entry->link.dle_next;
    }
    {
#line 106
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 106
      pthread_mutex_lock(& entry->link.dle_access);
#line 106
      (entry->link.dle_writer_count) ++;
      }
      {
#line 106
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 106
        if (! entry->link.dle_reader_count) {
#line 106
          goto while_break___3;
        }
        {
#line 106
        pthread_cond_wait((pthread_cond_t */* __restrict  */)(& entry->link.dle_writer_wait),
                          (pthread_mutex_t */* __restrict  */)(& entry->link.dle_access));
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 106
      pthread_mutex_unlock(& entry->link.dle_access);
      }
#line 106
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 106
    if (! ((unsigned long )entry->link.dle_next == (unsigned long )((void *)0))) {
#line 106
      (entry->link.dle_next)->link.dle_prev = entry->link.dle_prev;
    }
    {
#line 106
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 106
      pthread_mutex_lock(& entry->link.dle_access);
#line 106
      (entry->link.dle_writer_count) --;
      }
#line 106
      if (entry->link.dle_reader_count) {
        {
#line 106
        pthread_cond_broadcast(& entry->link.dle_reader_wait);
        }
      }
      {
#line 106
      pthread_mutex_unlock(& entry->link.dle_access);
      }
#line 106
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 106
    if ((unsigned long )entry->link.dle_prev == (unsigned long )((void *)0)) {
      {
#line 106
      pthread_mutex_unlock(& ExecEntry_Head.dlh_access);
      }
    } else {
      {
#line 106
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 106
        pthread_mutex_lock(& (entry->link.dle_prev)->link.dle_access);
#line 106
        ((entry->link.dle_prev)->link.dle_writer_count) --;
        }
#line 106
        if ((entry->link.dle_prev)->link.dle_reader_count) {
          {
#line 106
          pthread_cond_broadcast(& (entry->link.dle_prev)->link.dle_reader_wait);
          }
        }
        {
#line 106
        pthread_mutex_unlock(& (entry->link.dle_prev)->link.dle_access);
        }
#line 106
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
#line 106
    pthread_mutex_unlock(& ExecEntry_Head.dlh_ops);
    }
    {
#line 106
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 106
      pthread_mutex_destroy(& entry->link.dle_access);
#line 106
      pthread_cond_destroy(& entry->link.dle_reader_wait);
#line 106
      pthread_cond_destroy(& entry->link.dle_writer_wait);
      }
#line 106
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  ExecEntry_destroy(entry);
  }
#line 108
  return;
}
}
#line 110 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
ExecEntry *ExecEntry_getnext(ExecEntry **entry ) 
{ 


  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if ((unsigned long )*entry == (unsigned long )((void *)0)) {
      {
#line 113
      pthread_mutex_lock(& ExecEntry_Head.dlh_access);
#line 113
      *entry = ExecEntry_Head.dlh_first;
      }
#line 113
      if ((unsigned long )*entry != (unsigned long )((void *)0)) {
        {
#line 113
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 113
          pthread_mutex_lock(& (*entry)->link.dle_access);
          }
          {
#line 113
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 113
            if (! (*entry)->link.dle_writer_count) {
#line 113
              goto while_break___1;
            }
            {
#line 113
            pthread_cond_wait((pthread_cond_t */* __restrict  */)(& (*entry)->link.dle_reader_wait),
                              (pthread_mutex_t */* __restrict  */)(& (*entry)->link.dle_access));
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 113
          ((*entry)->link.dle_reader_count) ++;
#line 113
          pthread_mutex_unlock(& (*entry)->link.dle_access);
          }
#line 113
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 113
      pthread_mutex_unlock(& ExecEntry_Head.dlh_access);
      }
    } else
#line 113
    if ((unsigned long )(*entry)->link.dle_next == (unsigned long )((void *)0)) {
      {
#line 113
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 113
        pthread_mutex_lock(& (*entry)->link.dle_access);
#line 113
        ((*entry)->link.dle_reader_count) --;
        }
#line 113
        if ((*entry)->link.dle_writer_count) {
#line 113
          if ((*entry)->link.dle_reader_count == 0U) {
            {
#line 113
            pthread_cond_broadcast(& (*entry)->link.dle_writer_wait);
            }
          }
        }
        {
#line 113
        pthread_mutex_unlock(& (*entry)->link.dle_access);
        }
#line 113
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 113
      *entry = (ExecEntry *)((void *)0);
    } else {
#line 113
      *entry = (*entry)->link.dle_next;
      {
#line 113
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 113
        pthread_mutex_lock(& (*entry)->link.dle_access);
        }
        {
#line 113
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 113
          if (! (*entry)->link.dle_writer_count) {
#line 113
            goto while_break___4;
          }
          {
#line 113
          pthread_cond_wait((pthread_cond_t */* __restrict  */)(& (*entry)->link.dle_reader_wait),
                            (pthread_mutex_t */* __restrict  */)(& (*entry)->link.dle_access));
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 113
        ((*entry)->link.dle_reader_count) ++;
#line 113
        pthread_mutex_unlock(& (*entry)->link.dle_access);
        }
#line 113
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 113
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 113
        pthread_mutex_lock(& ((*entry)->link.dle_prev)->link.dle_access);
#line 113
        (((*entry)->link.dle_prev)->link.dle_reader_count) --;
        }
#line 113
        if (((*entry)->link.dle_prev)->link.dle_writer_count) {
#line 113
          if (((*entry)->link.dle_prev)->link.dle_reader_count == 0U) {
            {
#line 113
            pthread_cond_broadcast(& ((*entry)->link.dle_prev)->link.dle_writer_wait);
            }
          }
        }
        {
#line 113
        pthread_mutex_unlock(& ((*entry)->link.dle_prev)->link.dle_access);
        }
#line 113
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return (*entry);
}
}
#line 117 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
ExecEntry *ExecEntry_findbyname(char *name ) 
{ 
  ExecEntry *entry ;
  int tmp ;

  {
  {
#line 120
  entry = (ExecEntry *)((void *)0);
#line 122
  entry = ExecEntry_getnext(& entry);
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (entry) {
      {
#line 123
      tmp = strcmp((char const   *)entry->fullname, (char const   *)name);
      }
#line 123
      if (! (tmp != 0)) {
#line 123
        goto while_break;
      }
    } else {
#line 123
      goto while_break;
    }
    {
#line 124
    entry = ExecEntry_getnext(& entry);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return (entry);
}
}
#line 128 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
void ExecEntry_release(ExecEntry *entry ) 
{ 


  {
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 131
    pthread_mutex_lock(& entry->link.dle_access);
#line 131
    (entry->link.dle_reader_count) --;
    }
#line 131
    if (entry->link.dle_writer_count) {
#line 131
      if (entry->link.dle_reader_count == 0U) {
        {
#line 131
        pthread_cond_broadcast(& entry->link.dle_writer_wait);
        }
      }
    }
    {
#line 131
    pthread_mutex_unlock(& entry->link.dle_access);
    }
#line 131
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return;
}
}
#line 134 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
int ExecEntry_isempty(void) 
{ 


  {
#line 137
  return ((unsigned long )ExecEntry_Head.dlh_first == (unsigned long )((void *)0));
}
}
#line 142 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
struct test_entry_head TestEntry_Head  ;
#line 144
static void TestEntry_constructor(void)  __attribute__((__constructor__)) ;
#line 147
static void TestEntry_constructor(void)  __attribute__((__constructor__)) ;
#line 147 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
static void TestEntry_constructor(void) 
{ 


  {
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 150
    TestEntry_Head.dlh_first = (struct _test_entry *)((void *)0);
#line 150
    pthread_mutex_init(& TestEntry_Head.dlh_access, (pthread_mutexattr_t const   *)((void *)0));
#line 150
    pthread_mutex_init(& TestEntry_Head.dlh_ops, (pthread_mutexattr_t const   *)((void *)0));
    }
#line 150
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  return;
}
}
#line 155 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
__inline static void TestEntry_init(TestEntry *entry , ExecEntry *parent , char **args ,
                                    char **env ) 
{ 
  char *tmp ;

  {
#line 158
  if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
    {
#line 158
    __assert_fail("entry != ((void *)0)", "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c",
                  158U, "TestEntry_init");
    }
  }
  {
#line 159
  entry->pid = -1;
#line 160
  entry->status = 0;
#line 161
  tmp = strdup((char const   *)parent->fullname);
#line 161
  entry->progname = tmp;
  }
#line 161
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 162
    __bfbt_message((MsgType )2, (char *)"TestEntry_init", 162, (char *)"Out of memory");
    }
  }
  {
#line 163
  entry->args = args;
#line 164
  entry->args_str = args_to_str(entry->args);
  }
#line 165
  if (env) {
    {
#line 166
    entry->env = env_create(env);
#line 167
    entry->env_flag = 0;
#line 168
    entry->env_str = env_to_str(env);
    }
  } else {
#line 170
    entry->env = environ;
#line 171
    entry->env_flag = 1;
#line 172
    entry->env_str = (char *)((void *)0);
  }
#line 174
  return;
}
}
#line 176 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
void TestEntry_destroy(TestEntry *entry ) 
{ 


  {
#line 179
  if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
    {
#line 179
    __assert_fail("entry != ((void *)0)", "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c",
                  179U, "TestEntry_destroy");
    }
  }
#line 180
  if (entry->progname) {
    {
#line 180
    free((void *)entry->progname);
    }
  }
#line 181
  if (entry->args_str) {
    {
#line 181
    free((void *)entry->args_str);
    }
  }
#line 182
  if (entry->env) {
#line 182
    if (entry->env_flag == 0) {
      {
#line 182
      free((void *)entry->env);
      }
    }
  }
#line 183
  if (entry->env_str) {
    {
#line 183
    free((void *)entry->env_str);
    }
  }
  {
#line 184
  free((void *)entry);
  }
#line 185
  return;
}
}
#line 187 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
TestEntry *TestEntry_create(ExecEntry *parent , char **args , char **env ) 
{ 
  TestEntry *new ;
  void *tmp ;

  {
  {
#line 192
  tmp = _xmalloc(sizeof(TestEntry ), (char *)"TestEntry_create", 192);
#line 192
  new = (TestEntry *)tmp;
#line 193
  TestEntry_init(new, parent, args, env);
  }
#line 195
  return (new);
}
}
#line 198 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
void TestEntry_insert(TestEntry *entry ) 
{ 


  {
#line 201
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
#line 201
    if (! (entry->pid != -1)) {
      {
#line 201
      __assert_fail("entry != ((void *)0) && entry->pid != -1", "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c",
                    201U, "TestEntry_insert");
      }
    }
  } else {
    {
#line 201
    __assert_fail("entry != ((void *)0) && entry->pid != -1", "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c",
                  201U, "TestEntry_insert");
    }
  }
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 202
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 202
      pthread_mutex_init(& entry->link.dle_access, (pthread_mutexattr_t const   *)((void *)0));
#line 202
      entry->link.dle_reader_count = 0U;
#line 202
      entry->link.dle_writer_count = 0U;
#line 202
      pthread_cond_init((pthread_cond_t */* __restrict  */)(& entry->link.dle_reader_wait),
                        (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 202
      pthread_cond_init((pthread_cond_t */* __restrict  */)(& entry->link.dle_writer_wait),
                        (pthread_condattr_t const   */* __restrict  */)((void *)0));
      }
#line 202
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 202
    pthread_mutex_lock(& TestEntry_Head.dlh_ops);
#line 202
    pthread_mutex_lock(& TestEntry_Head.dlh_access);
    }
    {
#line 202
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 202
      pthread_mutex_lock(& entry->link.dle_access);
#line 202
      (entry->link.dle_writer_count) ++;
      }
      {
#line 202
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 202
        if (! entry->link.dle_reader_count) {
#line 202
          goto while_break___2;
        }
        {
#line 202
        pthread_cond_wait((pthread_cond_t */* __restrict  */)(& entry->link.dle_writer_wait),
                          (pthread_mutex_t */* __restrict  */)(& entry->link.dle_access));
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 202
      pthread_mutex_unlock(& entry->link.dle_access);
      }
#line 202
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 202
    if (! ((unsigned long )TestEntry_Head.dlh_first == (unsigned long )((void *)0))) {
      {
#line 202
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 202
        pthread_mutex_lock(& (TestEntry_Head.dlh_first)->link.dle_access);
#line 202
        ((TestEntry_Head.dlh_first)->link.dle_writer_count) ++;
        }
        {
#line 202
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 202
          if (! (TestEntry_Head.dlh_first)->link.dle_reader_count) {
#line 202
            goto while_break___4;
          }
          {
#line 202
          pthread_cond_wait((pthread_cond_t */* __restrict  */)(& (TestEntry_Head.dlh_first)->link.dle_writer_wait),
                            (pthread_mutex_t */* __restrict  */)(& (TestEntry_Head.dlh_first)->link.dle_access));
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 202
        pthread_mutex_unlock(& (TestEntry_Head.dlh_first)->link.dle_access);
        }
#line 202
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 202
      (TestEntry_Head.dlh_first)->link.dle_prev = entry;
      {
#line 202
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 202
        pthread_mutex_lock(& (TestEntry_Head.dlh_first)->link.dle_access);
#line 202
        ((TestEntry_Head.dlh_first)->link.dle_writer_count) --;
        }
#line 202
        if ((TestEntry_Head.dlh_first)->link.dle_reader_count) {
          {
#line 202
          pthread_cond_broadcast(& (TestEntry_Head.dlh_first)->link.dle_reader_wait);
          }
        }
        {
#line 202
        pthread_mutex_unlock(& (TestEntry_Head.dlh_first)->link.dle_access);
        }
#line 202
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 202
    entry->link.dle_next = TestEntry_Head.dlh_first;
#line 202
    entry->link.dle_prev = (struct _test_entry *)((void *)0);
#line 202
    TestEntry_Head.dlh_first = entry;
    {
#line 202
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 202
      pthread_mutex_lock(& entry->link.dle_access);
#line 202
      (entry->link.dle_writer_count) --;
      }
#line 202
      if (entry->link.dle_reader_count) {
        {
#line 202
        pthread_cond_broadcast(& entry->link.dle_reader_wait);
        }
      }
      {
#line 202
      pthread_mutex_unlock(& entry->link.dle_access);
      }
#line 202
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 202
    pthread_mutex_unlock(& TestEntry_Head.dlh_access);
#line 202
    pthread_mutex_unlock(& TestEntry_Head.dlh_ops);
    }
#line 202
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return;
}
}
#line 205 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
void TestEntry_remove(TestEntry *entry ) 
{ 


  {
#line 208
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
#line 208
    if (! (entry->pid != -1)) {
      {
#line 208
      __assert_fail("entry != ((void *)0) && entry->pid != -1", "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c",
                    208U, "TestEntry_remove");
      }
    }
  } else {
    {
#line 208
    __assert_fail("entry != ((void *)0) && entry->pid != -1", "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c",
                  208U, "TestEntry_remove");
    }
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 210
    pthread_mutex_lock(& TestEntry_Head.dlh_ops);
    }
#line 210
    if ((unsigned long )entry->link.dle_prev == (unsigned long )((void *)0)) {
      {
#line 210
      pthread_mutex_lock(& TestEntry_Head.dlh_access);
#line 210
      TestEntry_Head.dlh_first = entry->link.dle_next;
      }
    } else {
      {
#line 210
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 210
        pthread_mutex_lock(& (entry->link.dle_prev)->link.dle_access);
#line 210
        ((entry->link.dle_prev)->link.dle_writer_count) ++;
        }
        {
#line 210
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 210
          if (! (entry->link.dle_prev)->link.dle_reader_count) {
#line 210
            goto while_break___1;
          }
          {
#line 210
          pthread_cond_wait((pthread_cond_t */* __restrict  */)(& (entry->link.dle_prev)->link.dle_writer_wait),
                            (pthread_mutex_t */* __restrict  */)(& (entry->link.dle_prev)->link.dle_access));
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 210
        pthread_mutex_unlock(& (entry->link.dle_prev)->link.dle_access);
        }
#line 210
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 210
      (entry->link.dle_prev)->link.dle_next = entry->link.dle_next;
    }
    {
#line 210
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 210
      pthread_mutex_lock(& entry->link.dle_access);
#line 210
      (entry->link.dle_writer_count) ++;
      }
      {
#line 210
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 210
        if (! entry->link.dle_reader_count) {
#line 210
          goto while_break___3;
        }
        {
#line 210
        pthread_cond_wait((pthread_cond_t */* __restrict  */)(& entry->link.dle_writer_wait),
                          (pthread_mutex_t */* __restrict  */)(& entry->link.dle_access));
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 210
      pthread_mutex_unlock(& entry->link.dle_access);
      }
#line 210
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 210
    if (! ((unsigned long )entry->link.dle_next == (unsigned long )((void *)0))) {
#line 210
      (entry->link.dle_next)->link.dle_prev = entry->link.dle_prev;
    }
    {
#line 210
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 210
      pthread_mutex_lock(& entry->link.dle_access);
#line 210
      (entry->link.dle_writer_count) --;
      }
#line 210
      if (entry->link.dle_reader_count) {
        {
#line 210
        pthread_cond_broadcast(& entry->link.dle_reader_wait);
        }
      }
      {
#line 210
      pthread_mutex_unlock(& entry->link.dle_access);
      }
#line 210
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 210
    if ((unsigned long )entry->link.dle_prev == (unsigned long )((void *)0)) {
      {
#line 210
      pthread_mutex_unlock(& TestEntry_Head.dlh_access);
      }
    } else {
      {
#line 210
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 210
        pthread_mutex_lock(& (entry->link.dle_prev)->link.dle_access);
#line 210
        ((entry->link.dle_prev)->link.dle_writer_count) --;
        }
#line 210
        if ((entry->link.dle_prev)->link.dle_reader_count) {
          {
#line 210
          pthread_cond_broadcast(& (entry->link.dle_prev)->link.dle_reader_wait);
          }
        }
        {
#line 210
        pthread_mutex_unlock(& (entry->link.dle_prev)->link.dle_access);
        }
#line 210
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
#line 210
    pthread_mutex_unlock(& TestEntry_Head.dlh_ops);
    }
    {
#line 210
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 210
      pthread_mutex_destroy(& entry->link.dle_access);
#line 210
      pthread_cond_destroy(& entry->link.dle_reader_wait);
#line 210
      pthread_cond_destroy(& entry->link.dle_writer_wait);
      }
#line 210
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 210
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return;
}
}
#line 213 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
TestEntry *TestEntry_getnext(TestEntry **entry ) 
{ 


  {
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if ((unsigned long )*entry == (unsigned long )((void *)0)) {
      {
#line 216
      pthread_mutex_lock(& TestEntry_Head.dlh_access);
#line 216
      *entry = TestEntry_Head.dlh_first;
      }
#line 216
      if ((unsigned long )*entry != (unsigned long )((void *)0)) {
        {
#line 216
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 216
          pthread_mutex_lock(& (*entry)->link.dle_access);
          }
          {
#line 216
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 216
            if (! (*entry)->link.dle_writer_count) {
#line 216
              goto while_break___1;
            }
            {
#line 216
            pthread_cond_wait((pthread_cond_t */* __restrict  */)(& (*entry)->link.dle_reader_wait),
                              (pthread_mutex_t */* __restrict  */)(& (*entry)->link.dle_access));
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 216
          ((*entry)->link.dle_reader_count) ++;
#line 216
          pthread_mutex_unlock(& (*entry)->link.dle_access);
          }
#line 216
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 216
      pthread_mutex_unlock(& TestEntry_Head.dlh_access);
      }
    } else
#line 216
    if ((unsigned long )(*entry)->link.dle_next == (unsigned long )((void *)0)) {
      {
#line 216
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 216
        pthread_mutex_lock(& (*entry)->link.dle_access);
#line 216
        ((*entry)->link.dle_reader_count) --;
        }
#line 216
        if ((*entry)->link.dle_writer_count) {
#line 216
          if ((*entry)->link.dle_reader_count == 0U) {
            {
#line 216
            pthread_cond_broadcast(& (*entry)->link.dle_writer_wait);
            }
          }
        }
        {
#line 216
        pthread_mutex_unlock(& (*entry)->link.dle_access);
        }
#line 216
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 216
      *entry = (TestEntry *)((void *)0);
    } else {
#line 216
      *entry = (*entry)->link.dle_next;
      {
#line 216
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 216
        pthread_mutex_lock(& (*entry)->link.dle_access);
        }
        {
#line 216
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 216
          if (! (*entry)->link.dle_writer_count) {
#line 216
            goto while_break___4;
          }
          {
#line 216
          pthread_cond_wait((pthread_cond_t */* __restrict  */)(& (*entry)->link.dle_reader_wait),
                            (pthread_mutex_t */* __restrict  */)(& (*entry)->link.dle_access));
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 216
        ((*entry)->link.dle_reader_count) ++;
#line 216
        pthread_mutex_unlock(& (*entry)->link.dle_access);
        }
#line 216
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 216
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 216
        pthread_mutex_lock(& ((*entry)->link.dle_prev)->link.dle_access);
#line 216
        (((*entry)->link.dle_prev)->link.dle_reader_count) --;
        }
#line 216
        if (((*entry)->link.dle_prev)->link.dle_writer_count) {
#line 216
          if (((*entry)->link.dle_prev)->link.dle_reader_count == 0U) {
            {
#line 216
            pthread_cond_broadcast(& ((*entry)->link.dle_prev)->link.dle_writer_wait);
            }
          }
        }
        {
#line 216
        pthread_mutex_unlock(& ((*entry)->link.dle_prev)->link.dle_access);
        }
#line 216
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 216
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return (*entry);
}
}
#line 222 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
struct crashreport_slist_head CrashReport_Head  ;
#line 224
static void CrashReport_constructor(void)  __attribute__((__constructor__)) ;
#line 227
static void CrashReport_constructor(void)  __attribute__((__constructor__)) ;
#line 227 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
static void CrashReport_constructor(void) 
{ 


  {
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 230
    CrashReport_Head.dlh_first = (struct _crash_report *)((void *)0);
#line 230
    pthread_mutex_init(& CrashReport_Head.dlh_access, (pthread_mutexattr_t const   *)((void *)0));
#line 230
    pthread_mutex_init(& CrashReport_Head.dlh_ops, (pthread_mutexattr_t const   *)((void *)0));
    }
#line 230
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return;
}
}
#line 233 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
static void CrashReport_init(CrashReport *report , TestEntry *test_entry ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  union __anonunion_65 __constr_expr_4 ;
  union __anonunion_66 __constr_expr_5 ;

  {
  {
#line 236
  report->progname = strdup((char const   *)test_entry->progname);
  }
#line 237
  if (test_entry->args_str) {
    {
#line 237
    tmp = strdup((char const   *)test_entry->args_str);
#line 237
    report->args_str = tmp;
    }
  } else {
#line 237
    report->args_str = (char *)((void *)0);
  }
#line 239
  if (test_entry->env_str) {
    {
#line 239
    tmp___0 = strdup((char const   *)test_entry->env_str);
#line 239
    report->env_str = tmp___0;
    }
  } else {
#line 239
    report->env_str = (char *)((void *)0);
  }
#line 241
  __constr_expr_4.__in = test_entry->status;
#line 241
  report->signal = __constr_expr_4.__i & 127;
#line 242
  __constr_expr_5.__in = test_entry->status;
#line 242
  report->didCore = __constr_expr_5.__i & 128;
#line 243
  return;
}
}
#line 245 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
static void CrashReport_destroy(CrashReport *report ) 
{ 


  {
#line 248
  if (report->progname) {
    {
#line 248
    free((void *)report->progname);
    }
  }
#line 249
  if (report->args_str) {
    {
#line 249
    free((void *)report->args_str);
    }
  }
#line 250
  if (report->env_str) {
    {
#line 250
    free((void *)report->env_str);
    }
  }
  {
#line 251
  free((void *)report);
  }
#line 252
  return;
}
}
#line 254 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
CrashReport *CrashReport_add(TestEntry *test_entry ) 
{ 
  CrashReport *new ;
  void *tmp ;

  {
#line 259
  if (! ((unsigned long )test_entry != (unsigned long )((void *)0))) {
    {
#line 259
    __assert_fail("test_entry != ((void *)0)", "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c",
                  259U, "CrashReport_add");
    }
  }
  {
#line 260
  tmp = _xmalloc(sizeof(CrashReport ), (char *)"CrashReport_add", 260);
#line 260
  new = (CrashReport *)tmp;
#line 261
  CrashReport_init(new, test_entry);
  }
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 262
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 262
      pthread_mutex_init(& new->link.dle_access, (pthread_mutexattr_t const   *)((void *)0));
#line 262
      new->link.dle_reader_count = 0U;
#line 262
      new->link.dle_writer_count = 0U;
#line 262
      pthread_cond_init((pthread_cond_t */* __restrict  */)(& new->link.dle_reader_wait),
                        (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 262
      pthread_cond_init((pthread_cond_t */* __restrict  */)(& new->link.dle_writer_wait),
                        (pthread_condattr_t const   */* __restrict  */)((void *)0));
      }
#line 262
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 262
    pthread_mutex_lock(& CrashReport_Head.dlh_ops);
#line 262
    pthread_mutex_lock(& CrashReport_Head.dlh_access);
    }
    {
#line 262
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 262
      pthread_mutex_lock(& new->link.dle_access);
#line 262
      (new->link.dle_writer_count) ++;
      }
      {
#line 262
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 262
        if (! new->link.dle_reader_count) {
#line 262
          goto while_break___2;
        }
        {
#line 262
        pthread_cond_wait((pthread_cond_t */* __restrict  */)(& new->link.dle_writer_wait),
                          (pthread_mutex_t */* __restrict  */)(& new->link.dle_access));
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 262
      pthread_mutex_unlock(& new->link.dle_access);
      }
#line 262
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 262
    if (! ((unsigned long )CrashReport_Head.dlh_first == (unsigned long )((void *)0))) {
      {
#line 262
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 262
        pthread_mutex_lock(& (CrashReport_Head.dlh_first)->link.dle_access);
#line 262
        ((CrashReport_Head.dlh_first)->link.dle_writer_count) ++;
        }
        {
#line 262
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 262
          if (! (CrashReport_Head.dlh_first)->link.dle_reader_count) {
#line 262
            goto while_break___4;
          }
          {
#line 262
          pthread_cond_wait((pthread_cond_t */* __restrict  */)(& (CrashReport_Head.dlh_first)->link.dle_writer_wait),
                            (pthread_mutex_t */* __restrict  */)(& (CrashReport_Head.dlh_first)->link.dle_access));
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 262
        pthread_mutex_unlock(& (CrashReport_Head.dlh_first)->link.dle_access);
        }
#line 262
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 262
      (CrashReport_Head.dlh_first)->link.dle_prev = new;
      {
#line 262
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 262
        pthread_mutex_lock(& (CrashReport_Head.dlh_first)->link.dle_access);
#line 262
        ((CrashReport_Head.dlh_first)->link.dle_writer_count) --;
        }
#line 262
        if ((CrashReport_Head.dlh_first)->link.dle_reader_count) {
          {
#line 262
          pthread_cond_broadcast(& (CrashReport_Head.dlh_first)->link.dle_reader_wait);
          }
        }
        {
#line 262
        pthread_mutex_unlock(& (CrashReport_Head.dlh_first)->link.dle_access);
        }
#line 262
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 262
    new->link.dle_next = CrashReport_Head.dlh_first;
#line 262
    new->link.dle_prev = (struct _crash_report *)((void *)0);
#line 262
    CrashReport_Head.dlh_first = new;
    {
#line 262
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 262
      pthread_mutex_lock(& new->link.dle_access);
#line 262
      (new->link.dle_writer_count) --;
      }
#line 262
      if (new->link.dle_reader_count) {
        {
#line 262
        pthread_cond_broadcast(& new->link.dle_reader_wait);
        }
      }
      {
#line 262
      pthread_mutex_unlock(& new->link.dle_access);
      }
#line 262
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 262
    pthread_mutex_unlock(& CrashReport_Head.dlh_access);
#line 262
    pthread_mutex_unlock(& CrashReport_Head.dlh_ops);
    }
#line 262
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return (new);
}
}
#line 266 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
void CrashReport_subtract(CrashReport *report ) 
{ 


  {
#line 269
  if (! ((unsigned long )report != (unsigned long )((void *)0))) {
    {
#line 269
    __assert_fail("report != ((void *)0)", "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c",
                  269U, "CrashReport_subtract");
    }
  }
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 270
    pthread_mutex_lock(& CrashReport_Head.dlh_ops);
    }
#line 270
    if ((unsigned long )report->link.dle_prev == (unsigned long )((void *)0)) {
      {
#line 270
      pthread_mutex_lock(& CrashReport_Head.dlh_access);
#line 270
      CrashReport_Head.dlh_first = report->link.dle_next;
      }
    } else {
      {
#line 270
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 270
        pthread_mutex_lock(& (report->link.dle_prev)->link.dle_access);
#line 270
        ((report->link.dle_prev)->link.dle_writer_count) ++;
        }
        {
#line 270
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 270
          if (! (report->link.dle_prev)->link.dle_reader_count) {
#line 270
            goto while_break___1;
          }
          {
#line 270
          pthread_cond_wait((pthread_cond_t */* __restrict  */)(& (report->link.dle_prev)->link.dle_writer_wait),
                            (pthread_mutex_t */* __restrict  */)(& (report->link.dle_prev)->link.dle_access));
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 270
        pthread_mutex_unlock(& (report->link.dle_prev)->link.dle_access);
        }
#line 270
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 270
      (report->link.dle_prev)->link.dle_next = report->link.dle_next;
    }
    {
#line 270
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 270
      pthread_mutex_lock(& report->link.dle_access);
#line 270
      (report->link.dle_writer_count) ++;
      }
      {
#line 270
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 270
        if (! report->link.dle_reader_count) {
#line 270
          goto while_break___3;
        }
        {
#line 270
        pthread_cond_wait((pthread_cond_t */* __restrict  */)(& report->link.dle_writer_wait),
                          (pthread_mutex_t */* __restrict  */)(& report->link.dle_access));
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 270
      pthread_mutex_unlock(& report->link.dle_access);
      }
#line 270
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 270
    if (! ((unsigned long )report->link.dle_next == (unsigned long )((void *)0))) {
#line 270
      (report->link.dle_next)->link.dle_prev = report->link.dle_prev;
    }
    {
#line 270
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 270
      pthread_mutex_lock(& report->link.dle_access);
#line 270
      (report->link.dle_writer_count) --;
      }
#line 270
      if (report->link.dle_reader_count) {
        {
#line 270
        pthread_cond_broadcast(& report->link.dle_reader_wait);
        }
      }
      {
#line 270
      pthread_mutex_unlock(& report->link.dle_access);
      }
#line 270
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 270
    if ((unsigned long )report->link.dle_prev == (unsigned long )((void *)0)) {
      {
#line 270
      pthread_mutex_unlock(& CrashReport_Head.dlh_access);
      }
    } else {
      {
#line 270
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 270
        pthread_mutex_lock(& (report->link.dle_prev)->link.dle_access);
#line 270
        ((report->link.dle_prev)->link.dle_writer_count) --;
        }
#line 270
        if ((report->link.dle_prev)->link.dle_reader_count) {
          {
#line 270
          pthread_cond_broadcast(& (report->link.dle_prev)->link.dle_reader_wait);
          }
        }
        {
#line 270
        pthread_mutex_unlock(& (report->link.dle_prev)->link.dle_access);
        }
#line 270
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
#line 270
    pthread_mutex_unlock(& CrashReport_Head.dlh_ops);
    }
    {
#line 270
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 270
      pthread_mutex_destroy(& report->link.dle_access);
#line 270
      pthread_cond_destroy(& report->link.dle_reader_wait);
#line 270
      pthread_cond_destroy(& report->link.dle_writer_wait);
      }
#line 270
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 270
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 271
  CrashReport_destroy(report);
  }
#line 272
  return;
}
}
#line 274 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/data_stuff.c"
void CrashReport_log(CrashReport *report ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 277
  if (report->didCore) {
#line 277
    tmp = "Yes";
  } else {
#line 277
    tmp = "No";
  }
  {
#line 277
  tmp___0 = strsignal(report->signal);
  }
#line 277
  if (report->env_str) {
#line 277
    tmp___1 = (char const   *)report->env_str;
  } else {
#line 277
    tmp___1 = "";
  }
#line 277
  if (report->args_str) {
#line 277
    tmp___2 = (char const   *)report->args_str;
  } else {
#line 277
    tmp___2 = "";
  }
  {
#line 277
  __bfbt_message((MsgType )4, (char *)"CrashReport_log", 287, (char *)"*** Crash <%s> ***\nargs:\t\t%s\nenvs:\t\t%s\nSignal:\t\t%d ( %s )\nCore?\t\t%s\n",
                 report->progname, tmp___2, tmp___1, report->signal, tmp___0, tmp);
  }
#line 288
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 46 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/bfbtester.c"
static void usage(char *progname ) ;
#line 49
static void run_breaker(void) ;
#line 52
static void load_execs(char **av , ExecEntryStatus status , int flags , char *rejects ) ;
#line 55 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/bfbtester.c"
THREAD_DATA *q  ;
#line 57 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/bfbtester.c"
FILE *fp_msg  =    (FILE *)((void *)0);
#line 58 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/bfbtester.c"
int debug_level  ;
#line 63 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/bfbtester.c"
int main(int ac , char **av ) 
{ 
  char *progname ;
  char *rejects ;
  int t_on ;
  int max_execs ;
  int ch ;
  int flags ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 66
  rejects = (char *)((void *)0);
#line 67
  t_on = 0;
#line 68
  max_execs = 250;
#line 69
  flags = 0;
#line 71
  progname = strrchr((char const   *)*(av + 0), '/');
  }
#line 71
  if ((unsigned long )progname != (unsigned long )((void *)0)) {
#line 72
    progname ++;
  } else {
#line 74
    progname = *(av + 0);
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 76
    ch = getopt(ac, (char * const  *)av, "ad:ehmo:r:stvx:");
    }
#line 76
    if (! (ch != -1)) {
#line 76
      goto while_break;
    }
    {
#line 78
    if (ch == 97) {
#line 78
      goto case_97;
    }
#line 81
    if (ch == 100) {
#line 81
      goto case_100;
    }
#line 84
    if (ch == 101) {
#line 84
      goto case_101;
    }
#line 87
    if (ch == 104) {
#line 87
      goto case_104;
    }
#line 90
    if (ch == 109) {
#line 90
      goto case_109;
    }
#line 93
    if (ch == 111) {
#line 93
      goto case_111;
    }
#line 99
    if (ch == 114) {
#line 99
      goto case_114;
    }
#line 102
    if (ch == 115) {
#line 102
      goto case_115;
    }
#line 105
    if (ch == 116) {
#line 105
      goto case_116;
    }
#line 108
    if (ch == 118) {
#line 108
      goto case_118;
    }
#line 112
    if (ch == 120) {
#line 112
      goto case_120;
    }
#line 115
    goto switch_default;
    case_97: /* CIL Label */ 
#line 79
    flags |= (1 | (1 << 1)) | (1 << 2);
#line 80
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 82
    debug_level = atoi((char const   *)optarg);
    }
#line 83
    goto switch_break;
    case_101: /* CIL Label */ 
#line 85
    flags |= 1 << 2;
#line 86
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 88
    usage(progname);
    }
#line 89
    goto switch_break;
    case_109: /* CIL Label */ 
#line 91
    flags |= 1 << 1;
#line 92
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 94
    fp_msg = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"w");
    }
#line 94
    if ((unsigned long )fp_msg == (unsigned long )((void *)0)) {
      {
#line 95
      printf((char const   */* __restrict  */)"Can\'t open output file: %s\n", optarg);
      }
#line 96
      return (-1);
    }
#line 98
    goto switch_break;
    case_114: /* CIL Label */ 
#line 100
    rejects = optarg;
#line 101
    goto switch_break;
    case_115: /* CIL Label */ 
#line 103
    flags |= 1;
#line 104
    goto switch_break;
    case_116: /* CIL Label */ 
#line 106
    t_on = 1;
#line 107
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 109
    printf((char const   */* __restrict  */)"%s v. %s\n", "BFBTester: Brute Force Binary Tester",
           "2.0.1");
    }
#line 110
    return (0);
    case_120: /* CIL Label */ 
    {
#line 113
    max_execs = atoi((char const   *)optarg);
    }
#line 114
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 116
    usage(progname);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  ac -= optind;
#line 121
  av += optind;
#line 123
  if ((unsigned long )fp_msg == (unsigned long )((void *)0)) {
#line 124
    fp_msg = stdout;
  }
#line 125
  if (! flags) {
    {
#line 126
    usage(progname);
    }
  } else
#line 125
  if ((unsigned long )*av == (unsigned long )((void *)0)) {
    {
#line 126
    usage(progname);
    }
  }
  {
#line 128
  tmp = _xcalloc((size_t )1, sizeof(THREAD_DATA ), (char *)"main", 128);
#line 128
  q = (THREAD_DATA *)tmp;
#line 129
  q->max_execs = max_execs;
#line 130
  tmp___0 = _xmalloc(sizeof(pthread_mutex_t ), (char *)"main", 130);
#line 130
  q->mut = (pthread_mutex_t *)tmp___0;
#line 132
  tmp___1 = pthread_mutex_init(q->mut, (pthread_mutexattr_t const   *)((void *)0));
  }
#line 132
  if (tmp___1 != 0) {
    {
#line 133
    __bfbt_message((MsgType )2, (char *)"main", 133, (char *)"mutex init");
    }
  }
#line 152
  if (t_on) {
    {
#line 153
    tempfile_start(q);
    }
  }
  {
#line 155
  load_execs(av, (ExecEntryStatus )1, flags, rejects);
#line 156
  run_breaker();
  }
#line 158
  return (0);
}
}
#line 162 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/bfbtester.c"
static void usage(char *progname ) 
{ 
  size_t tmp ;

  {
  {
#line 165
  tmp = strlen((char const   *)progname);
#line 165
  printf((char const   */* __restrict  */)"%s [-htv] [-d level ] [-r rejects] [-o out-file]\n%*s [-x max-execs] -asme file [file2 file3 ...]\nMust specify one or more of the following tests:\n    -s\tSingle Argument Test\n    -m\tMultiple Argument Test\n    -e\tEnvironment Variable Test\n    -a\tSelects all tests\nOptions:\n    -h  Print this message\n    -t  Enable tempfile monitoring\n    -v  Print version string\n    -d level     Set debug level (default = 0, max = 2)\n    -r rejects   Comma separated list of binaries to skip\n    -o out-file  Output to out-file rather than stdout\n    -x max-execs Set maximum executables to run in parallel (default = %d)\nfile    Specific binary or a directory of binaries to test\n",
         progname, (int )tmp, "", 250);
#line 182
  exit(2);
  }
}
}
#line 185 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/bfbtester.c"
static void add_exec(char *filename , ExecEntryStatus status , int flags , char *rejects ) 
{ 
  struct stat sb ;
  char *ptr ;
  char *ptr2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 190
  if (rejects) {
    {
#line 193
    ptr = strstr((char const   *)rejects, (char const   *)filename);
    }
#line 193
    if (ptr) {
#line 194
      if ((unsigned long )ptr == (unsigned long )rejects) {
#line 194
        goto _L;
      } else
#line 194
      if ((int )*(ptr - 1) == 32) {
#line 194
        goto _L;
      } else
#line 194
      if ((int )*(ptr - 1) == 44) {
        _L: /* CIL Label */ 
        {
#line 195
        tmp = strlen((char const   *)filename);
        }
#line 195
        if ((int )*(ptr + tmp) == 0) {
#line 197
          return;
        } else {
          {
#line 195
          tmp___0 = strlen((char const   *)filename);
          }
#line 195
          if ((int )*(ptr + tmp___0) == 32) {
#line 197
            return;
          } else {
            {
#line 195
            tmp___1 = strlen((char const   *)filename);
            }
#line 195
            if ((int )*(ptr + tmp___1) == 44) {
#line 197
              return;
            }
          }
        }
      }
    }
    {
#line 198
    ptr2 = strrchr((char const   *)filename, '/');
    }
#line 198
    if (ptr2) {
      {
#line 198
      ptr2 ++;
#line 198
      ptr = strstr((char const   *)rejects, (char const   *)ptr2);
      }
#line 198
      if (ptr) {
#line 199
        if ((unsigned long )ptr == (unsigned long )rejects) {
#line 199
          goto _L___0;
        } else
#line 199
        if ((int )*(ptr - 1) == 32) {
#line 199
          goto _L___0;
        } else
#line 199
        if ((int )*(ptr - 1) == 44) {
          _L___0: /* CIL Label */ 
          {
#line 200
          tmp___2 = strlen((char const   *)ptr2);
          }
#line 200
          if ((int )*(ptr + tmp___2) == 0) {
#line 202
            return;
          } else {
            {
#line 200
            tmp___3 = strlen((char const   *)ptr2);
            }
#line 200
            if ((int )*(ptr + tmp___3) == 32) {
#line 202
              return;
            } else {
              {
#line 200
              tmp___4 = strlen((char const   *)ptr2);
              }
#line 200
              if ((int )*(ptr + tmp___4) == 44) {
#line 202
                return;
              }
            }
          }
        }
      }
    }
  }
  {
#line 205
  tmp___5 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& sb));
  }
#line 205
  if (tmp___5 == 0) {
#line 205
    if ((sb.st_mode & 61440U) == 32768U) {
      {
#line 205
      tmp___6 = access((char const   *)filename, 1);
      }
#line 205
      if (tmp___6 == 0) {
        {
#line 208
        ExecEntry_add(filename, & sb, status, flags);
        }
      }
    }
  }
#line 209
  return;
}
}
#line 212 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/bfbtester.c"
static void load_execs(char **av , ExecEntryStatus status , int flags , char *rejects ) 
{ 
  struct stat sb ;
  char *filename ;
  char *pwd ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  DIR *dir ;
  struct dirent entry ;
  struct dirent *result ;
  int ret ;
  char fname[4096] ;
  char const   *tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 217
  tmp = getenv("PWD");
#line 217
  pwd = tmp;
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! *av) {
#line 219
      goto while_break;
    }
#line 239
    if ((int )*(*(av + 0)) == 47) {
      {
#line 240
      filename = strdup((char const   *)*av);
      }
    } else
#line 242
    if (pwd) {
      {
#line 242
      tmp___0 = strlen((char const   *)pwd);
#line 242
      tmp___1 = strlen((char const   *)*av);
#line 242
      tmp___2 = _xmalloc((tmp___0 + tmp___1) + 2UL, (char *)"load_execs", 243);
#line 242
      filename = (char *)tmp___2;
      }
#line 242
      if (filename) {
        {
#line 242
        tmp___5 = strlen((char const   *)pwd);
        }
#line 242
        if ((int )*(pwd + (tmp___5 - 1UL)) == 47) {
#line 242
          tmp___4 = "";
        } else {
#line 242
          tmp___4 = "/";
        }
        {
#line 242
        tmp___6 = sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%s%s",
                          pwd, tmp___4, *av);
        }
#line 242
        if (tmp___6) {
          {
#line 242
          tmp___7 = access((char const   *)filename, 1);
          }
#line 242
          if (! (tmp___7 == 0)) {
            {
#line 249
            filename = find_exec_in_path(*av);
            }
          }
        } else {
          {
#line 249
          filename = find_exec_in_path(*av);
          }
        }
      } else {
        {
#line 249
        filename = find_exec_in_path(*av);
        }
      }
    } else {
      {
#line 249
      filename = find_exec_in_path(*av);
      }
    }
#line 251
    if (filename) {
      {
#line 251
      tmp___12 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& sb));
      }
#line 251
      if (tmp___12 == 0) {
        {
#line 251
        tmp___13 = access((char const   *)filename, 1);
        }
#line 251
        if (tmp___13 == 0) {
#line 254
          if ((sb.st_mode & 61440U) == 16384U) {
            {
#line 260
            dir = opendir((char const   *)filename);
            }
#line 260
            if ((unsigned long )dir == (unsigned long )((void *)0)) {
              {
#line 261
              __bfbt_message((MsgType )1, (char *)"load_execs", 262, (char *)"Can\'t open dir %s",
                             filename);
#line 263
              free((void *)filename);
              }
#line 264
              goto __Cont;
            }
            {
#line 266
            ret = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& entry),
                            (struct dirent **/* __restrict  */)(& result));
            }
            {
#line 267
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 267
              if (ret == 0) {
#line 267
                if (! ((unsigned long )result != (unsigned long )((void *)0))) {
#line 267
                  goto while_break___0;
                }
              } else {
#line 267
                goto while_break___0;
              }
              {
#line 268
              tmp___10 = strlen((char const   *)filename);
              }
#line 268
              if ((int )*(filename + (tmp___10 - 1UL)) == 47) {
#line 268
                tmp___9 = "";
              } else {
#line 268
                tmp___9 = "/";
              }
              {
#line 268
              tmp___11 = snprintf((char */* __restrict  */)(fname), sizeof(fname),
                                  (char const   */* __restrict  */)"%s%s%s", filename,
                                  tmp___9, result->d_name);
              }
#line 268
              if ((unsigned long )tmp___11 < sizeof(fname)) {
                {
#line 271
                add_exec(fname, status, flags, rejects);
                }
              }
              {
#line 272
              ret = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& entry),
                              (struct dirent **/* __restrict  */)(& result));
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          } else {
            {
#line 275
            add_exec(filename, status, flags, rejects);
            }
          }
        } else {
#line 251
          goto _L___0;
        }
      } else {
#line 251
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 277
    if (filename) {
      {
#line 278
      __bfbt_message((MsgType )1, (char *)"load_execs", 279, (char *)"Can\'t access file: %s (%s)",
                     filename, *av);
      }
    } else {
      {
#line 281
      __bfbt_message((MsgType )1, (char *)"load_execs", 281, (char *)"Can\'t find file: %s",
                     *av);
      }
    }
#line 283
    if (filename) {
      {
#line 284
      free((void *)filename);
      }
    }
    __Cont: /* CIL Label */ 
#line 219
    av ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  return;
}
}
#line 288 "/home/june/collector/temp/bfbtester-2.0.1/src/bfbt/bfbtester.c"
static void run_breaker(void) 
{ 
  int tmp ;

  {
  {
#line 291
  tmp = ExecEntry_isempty();
  }
#line 291
  if (! tmp) {
    {
#line 292
    breaker_start();
#line 293
    breaker_wait();
    }
  }
#line 295
  return;
}
}
