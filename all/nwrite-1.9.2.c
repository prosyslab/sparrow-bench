/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct __anonstruct_ut_tv_14 {
   int32_t tv_sec ;
   int32_t tv_usec ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   int32_t ut_session ;
   struct __anonstruct_ut_tv_14 ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 182 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
struct pref_t {
   int nodelay ;
   int beep ;
   int bold ;
   int headers ;
   int whoeof ;
   int showtarg ;
   char preftty[24] ;
   char *line_header ;
};
#line 182 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
typedef struct pref_t pref_t;
#line 193 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
struct tty_info_t {
   char name[24] ;
   FILE *file ;
   int found ;
   int specified ;
   struct tty_info_t *next ;
};
#line 193 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
typedef struct tty_info_t tty_info_t;
#line 201 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
struct local_user_t {
   char *name ;
   tty_info_t *ttys ;
   pref_t pref ;
   int header_sent ;
   int ttys_requested ;
   int ttys_found ;
};
#line 201 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
typedef struct local_user_t local_user_t;
#line 209
enum __anonenum_type_55 {
    LOCAL = 0,
    REMOTE = 1
} ;
#line 209 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
union __anonunion_info_56 {
   local_user_t *local ;
};
#line 209 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
struct user_t {
   struct user_t *next ;
   enum __anonenum_type_55 type ;
   union __anonunion_info_56 info ;
};
#line 209 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
typedef struct user_t user_t;
#line 43 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
char const   sccsid[104]  = 
#line 43
  {      (char const   )'@',      (char const   )'(',      (char const   )'#',      (char const   )')', 
        (char const   )'n',      (char const   )'w',      (char const   )'r',      (char const   )'i', 
        (char const   )'t',      (char const   )'e',      (char const   )'.',      (char const   )'c', 
        (char const   )'\t',      (char const   )'$',      (char const   )'R',      (char const   )'e', 
        (char const   )'v',      (char const   )'i',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )':',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'9',      (char const   )'.', 
        (char const   )'1',      (char const   )' ',      (char const   )'$',      (char const   )' ', 
        (char const   )'$',      (char const   )'D',      (char const   )'a',      (char const   )'t', 
        (char const   )'e',      (char const   )':',      (char const   )' ',      (char const   )'9', 
        (char const   )'7',      (char const   )'/',      (char const   )'1',      (char const   )'1', 
        (char const   )'/',      (char const   )'1',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'8',      (char const   )':',      (char const   )'4', 
        (char const   )'0',      (char const   )':',      (char const   )'3',      (char const   )'8', 
        (char const   )' ',      (char const   )'$',      (char const   )' ',      (char const   )'M', 
        (char const   )'a',      (char const   )'r',      (char const   )'c',      (char const   )'o', 
        (char const   )' ',      (char const   )'N',      (char const   )'i',      (char const   )'c', 
        (char const   )'o',      (char const   )'s',      (char const   )'i',      (char const   )'a', 
        (char const   )',',      (char const   )' ',      (char const   )'A',      (char const   )'a', 
        (char const   )'r',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'S',      (char const   )'m',      (char const   )'i',      (char const   )'t', 
        (char const   )'h',      (char const   )',',      (char const   )' ',      (char const   )'A', 
        (char const   )'l',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'C',      (char const   )'o',      (char const   )'o',      (char const   )'p', 
        (char const   )'e',      (char const   )'r',      (char const   )'s',      (char const   )'m', 
        (char const   )'i',      (char const   )'t',      (char const   )'h',      (char const   )'\000'};
#line 44 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
char const   rcsid[5]  = {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )'$', 
        (char const   )'\000'};
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 580
extern int putchar(int __c ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 770
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ttyname)(int __fd ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 173 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
char const   bold_start[5]  = {      (char const   )'\033',      (char const   )'[',      (char const   )'1',      (char const   )'m', 
        (char const   )'\000'};
#line 174 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
char const   bold_end[4]  = {      (char const   )'\033',      (char const   )'[',      (char const   )'m',      (char const   )'\000'};
#line 218
char *make_idle(int diff ) ;
#line 219
void sigint_handler(void) ;
#line 220
void get_prefs(local_user_t *usr , char *target ) ;
#line 221
void read_prefs(char *prefsFileName , pref_t *prefTarget ) ;
#line 222
void send_header(user_t *usr ) ;
#line 225 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
FILE *utmpd  ;
#line 227 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
char *myname  ;
#line 228 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
char mytty[24]  ;
#line 229 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
char *myrcname  ;
#line 230 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
user_t *user_list  =    (user_t *)((void *)0);
#line 231 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
int local_req_count  =    0;
#line 232 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
int local_req_found  =    0;
#line 233 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
struct utmp utmp_entry  ;
#line 234 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
struct stat stat_buf  ;
#line 235 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
struct passwd pwd_stack  ;
#line 236 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
struct passwd *pwd  =    & pwd_stack;
#line 237 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
time_t now  ;
#line 238 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
int debugmode  =    0;
#line 240 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
struct pref_t default_pref  = 
#line 240
     {0, 1, 0, 1, 0, 1, {(char )'\000'}, (char *)((void *)0)};
#line 252 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
tty_info_t *new_tty_info_t(void) 
{ 
  tty_info_t *new_tit ;
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 256
  tmp = calloc((size_t )1, sizeof(tty_info_t ));
#line 256
  new_tit = (tty_info_t *)tmp;
  }
#line 258
  if ((unsigned long )new_tit == (unsigned long )((void *)0)) {
    {
#line 259
    perror("nwrite: fatal memory allocation error");
#line 260
    tmp___0 = __errno_location();
#line 260
    exit(*tmp___0);
    }
  }
#line 262
  return (new_tit);
}
}
#line 265 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
void init_globals(void) 
{ 
  char buf[1024] ;
  int myttyfd ;
  char *myttyname ;
  __uid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;

  {
  {
#line 275
  time(& now);
#line 277
  tmp = getuid();
#line 277
  pwd = getpwuid(tmp);
  }
#line 278
  if ((unsigned long )pwd == (unsigned long )((void *)0)) {
    {
#line 279
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nwrite: couldn\'t determine your login name.\n");
#line 280
    exit(1);
    }
  }
  {
#line 282
  myname = strdup((char const   *)pwd->pw_name);
#line 285
  tmp___4 = fileno(stdin);
#line 285
  tmp___5 = isatty(tmp___4);
  }
#line 285
  if (tmp___5) {
    {
#line 286
    myttyfd = fileno(stdin);
    }
  } else {
    {
#line 287
    tmp___2 = fileno(stdout);
#line 287
    tmp___3 = isatty(tmp___2);
    }
#line 287
    if (tmp___3) {
      {
#line 288
      myttyfd = fileno(stdout);
      }
    } else {
      {
#line 289
      tmp___0 = fileno(stderr);
#line 289
      tmp___1 = isatty(tmp___0);
      }
#line 289
      if (tmp___1) {
        {
#line 290
        myttyfd = fileno(stderr);
        }
      } else {
        {
#line 292
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nwrite: could not find your tty.\n");
#line 293
        exit(2);
        }
      }
    }
  }
  {
#line 296
  tmp___6 = fstat(myttyfd, & stat_buf);
  }
#line 296
  if (tmp___6 == -1) {
    {
#line 297
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nwrite: could not stat your tty.\n");
#line 298
    exit(2);
    }
  }
#line 306
  if (! (stat_buf.st_mode & (unsigned int )(128 >> 3))) {
#line 307
    if (debugmode) {
#line 307
      tmp___7 = " group";
    } else {
#line 307
      tmp___7 = "";
    }
    {
#line 307
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nwrite: your tty is not%s writable.\n",
            tmp___7);
    }
  }
  {
#line 311
  myttyname = ttyname(myttyfd);
  }
#line 312
  if ((unsigned long )myttyname == (unsigned long )((void *)0)) {
    {
#line 313
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nwrite: could not determine your tty.\n");
#line 314
    exit(3);
    }
  } else {
    {
#line 317
    strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)myttyname,
            (size_t )24);
    }
  }
  {
#line 319
  myttyname = strchr((char const   *)(buf + 1), '/');
  }
#line 320
  if ((unsigned long )myttyname != (unsigned long )((void *)0)) {
    {
#line 322
    strcpy((char */* __restrict  */)(mytty), (char const   */* __restrict  */)(myttyname + 1));
    }
  } else {
    {
#line 325
    strcpy((char */* __restrict  */)(mytty), (char const   */* __restrict  */)(buf));
    }
  }
  {
#line 328
  read_prefs((char *)"/usr/local/etc/nwrite.rc", & default_pref);
  }
#line 330
  return;
}
}
#line 332 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
void get_prefs(local_user_t *usr , char *target ) 
{ 
  char prefsFileName[4096] ;

  {
#line 337
  usr->pref = default_pref;
#line 339
  if ((unsigned long )target == (unsigned long )((void *)0)) {
#line 340
    return;
  }
  {
#line 342
  snprintf((char */* __restrict  */)(prefsFileName), sizeof(prefsFileName), (char const   */* __restrict  */)"%s%s",
           target, "/.nwriterc");
#line 343
  read_prefs(prefsFileName, & usr->pref);
  }
#line 344
  return;
}
}
#line 347 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
void read_prefs(char *prefsFileName , pref_t *prefTarget ) 
{ 
  char buf[1024] ;
  char option[1024] ;
  char pref_str[1024] ;
  char scratch_buf[1024] ;
  int value ;
  FILE *prefs ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;

  {
#line 353
  prefs = (FILE *)((void *)0);
#line 355
  scratch_buf[0] = (char )'\000';
#line 357
  if (debugmode) {
    {
#line 358
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Opening %s...",
            prefsFileName);
    }
  }
  {
#line 359
  prefs = fopen((char const   */* __restrict  */)prefsFileName, (char const   */* __restrict  */)"r");
  }
#line 360
  if ((unsigned long )prefs == (unsigned long )((void *)0)) {
#line 361
    if (debugmode) {
      {
#line 362
      perror((char const   *)prefsFileName);
      }
    }
#line 363
    return;
  }
#line 366
  if (debugmode) {
    {
#line 367
    printf((char const   */* __restrict  */)"succeeded\n");
    }
  }
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 369
    tmp___15 = fgets((char */* __restrict  */)(buf), 1024, (FILE */* __restrict  */)prefs);
    }
#line 369
    if (! ((unsigned long )tmp___15 != (unsigned long )((void *)0))) {
#line 369
      goto while_break;
    }
    {
#line 370
    sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%s%s",
           option, pref_str);
    }
#line 371
    if (debugmode) {
      {
#line 372
      printf((char const   */* __restrict  */)"option: \'%s\'\tpref_str: \'%s\'\n",
             option, pref_str);
      }
    }
    {
#line 373
    value = atoi((char const   *)(pref_str));
#line 374
    tmp___14 = strncmp((char const   *)(option), "beep", sizeof("beep") - 1UL);
    }
#line 374
    if (tmp___14 == 0) {
#line 375
      prefTarget->beep = value;
    } else {
      {
#line 376
      tmp___13 = strncmp((char const   *)(option), "nodelay", sizeof("nodelay") - 1UL);
      }
#line 376
      if (tmp___13 == 0) {
#line 377
        prefTarget->nodelay = value;
      } else {
        {
#line 378
        tmp___12 = strncmp((char const   *)(option), "boldhdr", sizeof("boldhdr") - 1UL);
        }
#line 378
        if (tmp___12 == 0) {
#line 379
          prefTarget->bold = 2;
        } else {
          {
#line 380
          tmp___11 = strncmp((char const   *)(option), "bold", sizeof("bold") - 1UL);
          }
#line 380
          if (tmp___11 == 0) {
            {
#line 381
            strcpy((char */* __restrict  */)(scratch_buf), (char const   */* __restrict  */)(pref_str));
#line 382
            tmp___3 = strncmp((char const   *)(scratch_buf), "never", sizeof("never") - 1UL);
            }
#line 382
            if (tmp___3 == 0) {
#line 383
              prefTarget->bold = 0;
            } else {
              {
#line 384
              tmp___2 = strncmp((char const   *)(scratch_buf), "header", sizeof("header") - 1UL);
              }
#line 384
              if (tmp___2 == 0) {
#line 385
                prefTarget->bold = 1;
              } else {
                {
#line 386
                tmp___1 = strncmp((char const   *)(scratch_buf), "tag", sizeof("tag") - 1UL);
                }
#line 386
                if (tmp___1 == 0) {
#line 387
                  prefTarget->bold = 2;
                } else {
                  {
#line 388
                  tmp___0 = strncmp((char const   *)(scratch_buf), "all", sizeof("all") - 1UL);
                  }
#line 388
                  if (tmp___0 == 0) {
#line 389
                    prefTarget->bold = 3;
                  } else {
                    {
#line 390
                    tmp = strlen((char const   *)(scratch_buf));
                    }
#line 390
                    if (tmp == 1UL) {
                      {
#line 391
                      prefTarget->bold = atoi((char const   *)(scratch_buf));
                      }
                    }
                  }
                }
              }
            }
          } else {
            {
#line 393
            tmp___10 = strncmp((char const   *)(option), "headers", sizeof("headers") - 1UL);
            }
#line 393
            if (tmp___10 == 0) {
#line 394
              prefTarget->headers = value;
            } else {
              {
#line 395
              tmp___9 = strncmp((char const   *)(option), "whoeof", sizeof("whoeof") - 1UL);
              }
#line 395
              if (tmp___9 == 0) {
#line 396
                prefTarget->whoeof = value;
              } else {
                {
#line 397
                tmp___8 = strncmp((char const   *)(option), "showtarg", sizeof("showtarg") - 1UL);
                }
#line 397
                if (tmp___8 == 0) {
                  {
#line 398
                  strcpy((char */* __restrict  */)(scratch_buf), (char const   */* __restrict  */)(pref_str));
#line 399
                  tmp___6 = strncmp((char const   *)(scratch_buf), "never", sizeof("never") - 1UL);
                  }
#line 399
                  if (tmp___6 == 0) {
#line 400
                    prefTarget->showtarg = 0;
                  } else {
                    {
#line 401
                    tmp___5 = strncmp((char const   *)(scratch_buf), "multi", sizeof("multi") - 1UL);
                    }
#line 401
                    if (tmp___5 == 0) {
#line 402
                      prefTarget->showtarg = 1;
                    } else {
                      {
#line 403
                      tmp___4 = strncmp((char const   *)(scratch_buf), "always", sizeof("always") - 1UL);
                      }
#line 403
                      if (tmp___4 == 0) {
#line 404
                        prefTarget->showtarg = 2;
                      }
                    }
                  }
                } else {
                  {
#line 406
                  tmp___7 = strncmp((char const   *)(option), "preftty", sizeof("preftty") - 1UL);
                  }
#line 406
                  if (tmp___7 == 0) {
                    {
#line 407
                    strcpy((char */* __restrict  */)(prefTarget->preftty), (char const   */* __restrict  */)(pref_str));
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  if (debugmode) {
    {
#line 410
    printf((char const   */* __restrict  */)"Options are:\nNodelay: %d\nBeep: %d\nBold: %d\nHeaders: %d\nWhoEOF: %d\nShowTarg: %d\nPrefTTY: %s\n",
           prefTarget->nodelay, prefTarget->beep, prefTarget->bold, prefTarget->headers,
           prefTarget->whoeof, prefTarget->showtarg, prefTarget->preftty);
    }
  }
#line 422
  return;
}
}
#line 878
extern int ( /* missing proto */  toascii)() ;
#line 879
extern int ( /* missing proto */  isprint)() ;
#line 879
extern int ( /* missing proto */  isspace)() ;
#line 424 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
int main(int argc , char **argv ) 
{ 
  char buf[1024] ;
  char *bufptr ;
  int IFLAG ;
  time_t idle_limit ;
  char *idle_string ;
  tty_info_t *the_tty ;
  user_t *usr ;
  user_t *prev ;
  __sighandler_t tmp ;
  __sighandler_t tmp___0 ;
  int c ;
  int tmp___1 ;
  char *ttyptr ;
  int new_usr ;
  tty_info_t *new_tty ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  time_t idle_time ;
  int tty_fd ;
  int matched ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  FILE *tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  void *tmp___20 ;
  char *tmp___21 ;
  user_t *next_usr ;
  tty_info_t *prev_tty ;
  tty_info_t *cur_tty ;
  tty_info_t *next_tty ;
  char const   *tmp___22 ;
  char *p ;
  char *o ;
  int i ;
  char obuf[2048] ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int ok ;
  tty_info_t *tmp_tty ;
  user_t *temp ;
  user_t *temp_prev ;
  int tmp___27 ;
  char *tmp___28 ;

  {
  {
#line 427
  bufptr = buf;
#line 429
  IFLAG = 0;
#line 433
  idle_limit = (time_t )0;
#line 434
  idle_string = (char *)((void *)0);
#line 441
  tmp = signal(2, (void (*)(int  ))(& sigint_handler));
  }
#line 441
  if ((unsigned long )tmp == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 442
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nwrite: Error installing SIGINT handler.\n");
    }
  }
  {
#line 444
  tmp___0 = signal(1, (void (*)(int  ))(& sigint_handler));
  }
#line 444
  if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 445
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nwrite: Error installing SIGHUP handler.\n");
    }
  }
#line 448
  if (argc < 2) {
    usage: 
    {
#line 450
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: nwrite [flags] user[.tty] [user[.tty] ...]\n\t-i <time>\t do not write to ttys more than <time> minutes idle\n");
#line 455
    exit(1);
    }
  } else {
    {
#line 462
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 462
      c = getopt(argc, (char * const  *)argv, "i:D");
      }
#line 462
      if (! (c != -1)) {
#line 462
        goto while_break;
      }
      {
#line 465
      if (c == 105) {
#line 465
        goto case_105;
      }
#line 474
      if (c == 68) {
#line 474
        goto case_68;
      }
#line 477
      goto switch_default;
      case_105: /* CIL Label */ 
      {
#line 466
      IFLAG = 1;
#line 467
      tmp___1 = atoi((char const   *)optarg);
#line 467
      idle_limit = (time_t )(tmp___1 * 60);
      }
#line 468
      goto switch_break;
      case_68: /* CIL Label */ 
#line 475
      debugmode = 1;
#line 476
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 478
      goto usage;
#line 479
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 482
  if (optind == argc) {
#line 483
    goto usage;
  }
  {
#line 485
  init_globals();
  }
  {
#line 487
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 487
    if (! (optind < argc)) {
#line 487
      goto while_break___0;
    }
    {
#line 489
    new_usr = 0;
#line 491
    tmp___12 = strchr((char const   *)*(argv + optind), '@');
    }
#line 491
    if (tmp___12) {
      {
#line 494
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nwrite: writing to remote hosts not supported (yet)\n        skipping %s\n",
              *(argv + optind));
      }
    } else {
      {
#line 500
      new_tty = (tty_info_t *)((void *)0);
#line 502
      new_usr = 1;
#line 503
      ttyptr = strrchr((char const   *)*(argv + optind), '.');
      }
#line 504
      if ((unsigned long )ttyptr != (unsigned long )((void *)0)) {
#line 505
        tmp___2 = ttyptr;
#line 505
        ttyptr ++;
#line 505
        *tmp___2 = (char )'\000';
      }
#line 507
      usr = user_list;
      {
#line 507
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 507
        if ((unsigned long )usr != (unsigned long )((void *)0)) {
#line 507
          if (! new_usr) {
#line 507
            goto while_break___1;
          }
        } else {
#line 507
          goto while_break___1;
        }
#line 509
        if ((unsigned int )usr->type == 0U) {
          {
#line 509
          tmp___3 = strcmp((char const   *)(usr->info.local)->name, (char const   *)*(argv + optind));
          }
#line 509
          if (tmp___3) {
#line 516
            usr = usr->next;
          } else {
#line 512
            new_usr = 0;
          }
        } else {
#line 516
          usr = usr->next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 520
      if (new_usr) {
        {
#line 521
        tmp___4 = malloc(sizeof(user_t ));
#line 521
        usr = (user_t *)tmp___4;
#line 523
        usr->type = (enum __anonenum_type_55 )0;
#line 524
        tmp___5 = malloc(sizeof(local_user_t ));
#line 524
        usr->info.local = (local_user_t *)tmp___5;
#line 525
        (usr->info.local)->name = strdup((char const   *)*(argv + optind));
#line 527
        pwd = getpwnam((char const   *)(usr->info.local)->name);
        }
#line 528
        if (pwd) {
          {
#line 529
          get_prefs(usr->info.local, pwd->pw_dir);
          }
        } else {
          {
#line 532
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nwrite: could not find user named %s",
                  (usr->info.local)->name);
#line 534
          free((void *)usr);
#line 535
          usr = user_list;
          }
#line 537
          if ((unsigned long )usr == (unsigned long )((void *)0)) {
            {
#line 539
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" - skipping that user.\n");
            }
          } else
#line 537
          if ((unsigned long )ttyptr != (unsigned long )((void *)0)) {
            {
#line 539
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" - skipping that user.\n");
            }
          } else
#line 537
          if (((usr->info.local)->ttys)->specified == 1) {
            {
#line 539
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" - skipping that user.\n");
            }
          } else {
            {
#line 541
            tmp___7 = strncmp((char const   *)*(argv + optind), "pts/", sizeof("pts/") - 1UL);
            }
#line 541
            if (tmp___7 == 0) {
              {
#line 546
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" - assuming it\'s a tty name.\n");
#line 548
              strcpy((char */* __restrict  */)(((usr->info.local)->ttys)->name), (char const   */* __restrict  */)"/dev/");
#line 549
              strcat((char */* __restrict  */)(((usr->info.local)->ttys)->name), (char const   */* __restrict  */)*(argv + optind));
#line 550
              ((usr->info.local)->ttys)->specified = 1;
              }
            } else {
              {
#line 541
              tmp___8 = strncmp((char const   *)*(argv + optind), "tty", sizeof("tty") - 1UL);
              }
#line 541
              if (tmp___8 == 0) {
                {
#line 546
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" - assuming it\'s a tty name.\n");
#line 548
                strcpy((char */* __restrict  */)(((usr->info.local)->ttys)->name),
                       (char const   */* __restrict  */)"/dev/");
#line 549
                strcat((char */* __restrict  */)(((usr->info.local)->ttys)->name),
                       (char const   */* __restrict  */)*(argv + optind));
#line 550
                ((usr->info.local)->ttys)->specified = 1;
                }
              } else {
                {
#line 552
                tmp___6 = strncmp((char const   *)*(argv + optind), "/dev/", sizeof("/dev/") - 1UL);
                }
#line 552
                if (tmp___6 == 0) {
                  {
#line 555
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" - assuming it\'s a tty name.\n");
#line 557
                  strcat((char */* __restrict  */)(((usr->info.local)->ttys)->name),
                         (char const   */* __restrict  */)*(argv + optind));
#line 558
                  ((usr->info.local)->ttys)->specified = 1;
                  }
                } else {
                  {
#line 560
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" - skipping that user.\n");
                  }
                }
              }
            }
          }
#line 563
          optind ++;
#line 564
          goto while_continue___0;
        }
#line 567
        (usr->info.local)->ttys = (tty_info_t *)((void *)0);
#line 568
        (usr->info.local)->ttys_found = 0;
#line 569
        (usr->info.local)->ttys_requested = 0;
#line 570
        (usr->info.local)->header_sent = 0;
#line 572
        usr->next = user_list;
#line 573
        user_list = usr;
      }
      {
#line 577
      new_tty = new_tty_info_t();
#line 578
      new_tty->file = (FILE *)((void *)0);
#line 579
      new_tty->next = (usr->info.local)->ttys;
#line 580
      (usr->info.local)->ttys = new_tty;
#line 581
      ((usr->info.local)->ttys_requested) ++;
#line 582
      local_req_count ++;
      }
#line 584
      if ((unsigned long )ttyptr == (unsigned long )((void *)0)) {
#line 585
        new_tty->specified = 0;
      } else {
        {
#line 589
        new_tty->specified = 1;
#line 591
        tmp___11 = strncmp((char const   *)ttyptr, "/dev/", sizeof("/dev/") - 1UL);
        }
#line 591
        if (tmp___11 != 0) {
          {
#line 594
          strncpy((char */* __restrict  */)(new_tty->name), (char const   */* __restrict  */)"/dev/",
                  sizeof(new_tty->name));
#line 596
          tmp___9 = strncmp((char const   *)ttyptr, "pts/", sizeof("pts/") - 1UL);
          }
#line 596
          if (tmp___9 != 0) {
            {
#line 596
            tmp___10 = strncmp((char const   *)ttyptr, "tty", sizeof("tty") - 1UL);
            }
#line 596
            if (tmp___10 != 0) {
              {
#line 600
              strcat((char */* __restrict  */)(new_tty->name), (char const   */* __restrict  */)"tty");
              }
            }
          }
        }
        {
#line 603
        strcat((char */* __restrict  */)(new_tty->name), (char const   */* __restrict  */)ttyptr);
        }
      }
    }
#line 607
    optind ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 623
  utmpd = fopen((char const   */* __restrict  */)"/var/run/utmp", (char const   */* __restrict  */)"r");
  }
#line 623
  if ((unsigned long )utmpd == (unsigned long )((void *)0)) {
    {
#line 625
    perror("nwrite (/var/run/utmp):");
#line 626
    exit(1);
    }
  }
  {
#line 630
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 630
    if (local_req_found < local_req_count) {
      {
#line 630
      tmp___19 = fread((void */* __restrict  */)((char *)(& utmp_entry)), sizeof(utmp_entry),
                       (size_t )1, (FILE */* __restrict  */)utmpd);
      }
#line 630
      if (! (tmp___19 == 1UL)) {
#line 630
        goto while_break___2;
      }
    } else {
#line 630
      goto while_break___2;
    }
#line 639
    if ((int )utmp_entry.ut_type != 7) {
#line 640
      goto while_continue___2;
    }
#line 644
    if ((int )utmp_entry.ut_line[0] == 0) {
#line 645
      goto while_continue___2;
    } else
#line 644
    if ((int )utmp_entry.ut_user[0] == 0) {
#line 645
      goto while_continue___2;
    }
#line 647
    usr = user_list;
    {
#line 647
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 647
      if (! ((unsigned long )usr != (unsigned long )((void *)0))) {
#line 647
        goto while_break___3;
      }
      {
#line 649
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 649
        if ((unsigned long )usr != (unsigned long )((void *)0)) {
#line 649
          if ((unsigned int )usr->type != 0U) {
#line 649
            if (! ((usr->info.local)->ttys_requested >= (usr->info.local)->ttys_found)) {
#line 649
              goto while_break___4;
            }
          } else {
#line 649
            goto while_break___4;
          }
        } else {
#line 649
          goto while_break___4;
        }
#line 651
        usr = usr->next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 654
      if ((unsigned long )usr == (unsigned long )((void *)0)) {
#line 655
        goto while_break___3;
      }
      {
#line 657
      tmp___18 = strncmp((char const   *)(utmp_entry.ut_user), (char const   *)(usr->info.local)->name,
                         sizeof(utmp_entry.ut_user));
      }
#line 657
      if (! tmp___18) {
#line 659
        idle_time = (time_t )0;
#line 661
        matched = 0;
#line 663
        the_tty = (usr->info.local)->ttys;
        {
#line 663
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 663
          if ((unsigned long )the_tty != (unsigned long )((void *)0)) {
#line 663
            if (! (! matched)) {
#line 663
              goto while_break___5;
            }
          } else {
#line 663
            goto while_break___5;
          }
#line 667
          if (! the_tty->found) {
#line 668
            if (the_tty->specified) {
              {
#line 669
              tmp___13 = strncmp((char const   *)(utmp_entry.ut_line), (char const   *)((the_tty->name + sizeof("/dev/")) - 1),
                                 (size_t )32);
              }
#line 669
              if (! tmp___13) {
#line 673
                the_tty->found = 1;
              }
            } else {
              {
#line 676
              the_tty->found = 1;
#line 677
              matched ++;
#line 678
              strcpy((char */* __restrict  */)(the_tty->name), (char const   */* __restrict  */)"/dev/");
#line 679
              strncat((char */* __restrict  */)(the_tty->name), (char const   */* __restrict  */)(utmp_entry.ut_line),
                      sizeof(utmp_entry.ut_line));
              }
            }
#line 683
            if (the_tty->found == 1) {
              {
#line 684
              tmp___14 = stat((char const   */* __restrict  */)(the_tty->name), (struct stat */* __restrict  */)(& stat_buf));
              }
#line 684
              if (tmp___14 != 0) {
                {
#line 685
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nwrite: couldn\'t stat %s.\n",
                        the_tty->name);
                }
              } else {
#line 688
                if (stat_buf.st_mtim.tv_sec < stat_buf.st_atim.tv_sec) {
#line 689
                  if (now < stat_buf.st_mtim.tv_sec) {
#line 689
                    idle_time = (time_t )0;
                  } else {
#line 689
                    idle_time = now - stat_buf.st_mtim.tv_sec;
                  }
                } else
#line 692
                if (now < stat_buf.st_atim.tv_sec) {
#line 692
                  idle_time = (time_t )0;
                } else {
#line 692
                  idle_time = now - stat_buf.st_atim.tv_sec;
                }
                {
#line 695
                idle_string = make_idle((int )idle_time);
                }
#line 696
                if (IFLAG) {
#line 696
                  if (the_tty->specified == 0) {
#line 697
                    if (idle_time > idle_limit) {
                      {
#line 698
                      printf((char const   */* __restrict  */)"ignoring %s on %s (idle %s)\n",
                             (usr->info.local)->name, (the_tty->name + sizeof("/dev/")) - 1,
                             idle_string);
#line 702
                      the_tty->found = 0;
                      }
#line 703
                      goto __Cont;
                    }
                  }
                }
              }
              {
#line 716
              tty_fd = open((char const   *)(the_tty->name), 257);
              }
#line 721
              if (tty_fd < 0) {
#line 721
                goto _L;
              } else {
                {
#line 721
                tmp___16 = isatty(tty_fd);
                }
#line 721
                if (tmp___16) {
                  {
#line 721
                  tmp___17 = fdopen(tty_fd, "w");
#line 721
                  the_tty->file = tmp___17;
                  }
#line 721
                  if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
                    _L: /* CIL Label */ 
#line 723
                    if ((unsigned long )(buf) == (unsigned long )bufptr) {
                      {
#line 724
                      strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"nwrite: could not open ");
#line 725
                      bufptr += sizeof("nwrite: could not open ") - 1UL;
                      }
                    } else {
                      {
#line 727
                      strcat((char */* __restrict  */)bufptr, (char const   */* __restrict  */)", ");
                      }
                    }
                    {
#line 729
                    strncat((char */* __restrict  */)bufptr, (char const   */* __restrict  */)(utmp_entry.ut_user),
                            (size_t )32);
#line 730
                    strcat((char */* __restrict  */)bufptr, (char const   */* __restrict  */)".");
#line 731
                    strncat((char */* __restrict  */)bufptr, (char const   */* __restrict  */)(utmp_entry.ut_line),
                            (size_t )32);
#line 733
                    tmp___15 = strlen((char const   *)bufptr);
#line 733
                    bufptr += tmp___15;
#line 734
                    the_tty->found = 0;
                    }
#line 735
                    goto __Cont;
                  }
                } else {
#line 721
                  goto _L;
                }
              }
#line 738
              if (idle_time > 60L) {
                {
#line 739
                printf((char const   */* __restrict  */)"writing to %s on %s (idle %s)\n",
                       (usr->info.local)->name, (the_tty->name + sizeof("/dev/")) - 1,
                       idle_string);
                }
              } else {
                {
#line 744
                printf((char const   */* __restrict  */)"writing to %s on %s\n", (usr->info.local)->name,
                       (the_tty->name + sizeof("/dev/")) - 1);
                }
              }
#line 748
              ((usr->info.local)->ttys_found) ++;
#line 749
              local_req_found ++;
#line 750
              if (debugmode) {
                {
#line 751
                printf((char const   */* __restrict  */)"local_req_count: %d\tlocal_req_found: %d\n",
                       local_req_count, local_req_found);
                }
              }
#line 753
              goto while_break___5;
            }
          }
          __Cont: /* CIL Label */ 
#line 663
          the_tty = the_tty->next;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 647
      usr = usr->next;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 760
  if ((unsigned long )bufptr != (unsigned long )(buf)) {
    {
#line 761
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            buf);
    }
  }
  {
#line 763
  fclose(utmpd);
  }
#line 765
  if (IFLAG) {
#line 765
    if (idle_limit) {
      {
#line 766
      tmp___20 = malloc((size_t )64);
#line 766
      idle_string = (char *)tmp___20;
#line 767
      tmp___21 = make_idle((int )idle_limit);
#line 767
      snprintf((char */* __restrict  */)idle_string, (size_t )64, (char const   */* __restrict  */)" that were less than %s idle",
               tmp___21);
      }
    } else {
#line 770
      idle_string = (char *)"";
    }
  } else {
#line 770
    idle_string = (char *)"";
  }
#line 773
  usr = user_list;
#line 774
  prev = (user_t *)((void *)0);
  {
#line 776
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 776
    if (! usr) {
#line 776
      goto while_break___6;
    }
#line 777
    if ((unsigned int )usr->type == 0U) {
#line 778
      if ((usr->info.local)->ttys_found < (usr->info.local)->ttys_requested) {
#line 780
        the_tty = (usr->info.local)->ttys;
        {
#line 780
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 780
          if (! ((unsigned long )the_tty != (unsigned long )((void *)0))) {
#line 780
            goto while_break___7;
          }
#line 783
          if (! the_tty->found) {
#line 783
            if (the_tty->specified) {
              {
#line 784
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nwrite: utmp says %s is not logged onto tty %s.\n",
                      (usr->info.local)->name, the_tty->name);
              }
            }
          }
#line 780
          the_tty = the_tty->next;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 790
        if ((usr->info.local)->ttys_found == 0) {
          {
#line 794
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nwrite: no writable ttys found for %s%s.\n",
                  (usr->info.local)->name, idle_string);
          }
#line 797
          if (prev) {
#line 798
            prev->next = usr->next;
          } else {
#line 800
            user_list = usr->next;
          }
          {
#line 802
          next_usr = usr->next;
#line 803
          local_req_count -= (usr->info.local)->ttys_requested;
#line 804
          free((void *)usr);
#line 805
          usr = next_usr;
          }
#line 806
          goto while_continue___6;
        } else {
#line 812
          if ((usr->info.local)->ttys_found > 1) {
#line 812
            tmp___22 = "s";
          } else {
#line 812
            tmp___22 = "";
          }
          {
#line 812
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nwrite: only found %d writable tty%s for %s%s.\n",
                  (usr->info.local)->ttys_found, tmp___22, (usr->info.local)->name,
                  idle_string);
#line 819
          prev_tty = (tty_info_t *)((void *)0);
#line 820
          cur_tty = (usr->info.local)->ttys;
          }
          {
#line 821
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 821
            if (! ((unsigned long )cur_tty != (unsigned long )((void *)0))) {
#line 821
              goto while_break___8;
            }
#line 822
            if (cur_tty->found == 0) {
#line 823
              next_tty = cur_tty->next;
#line 825
              if ((unsigned long )prev_tty == (unsigned long )((void *)0)) {
#line 826
                (usr->info.local)->ttys = next_tty;
              } else {
#line 828
                prev_tty->next = next_tty;
              }
              {
#line 830
              free((void *)cur_tty);
#line 831
              cur_tty = next_tty;
              }
            } else {
#line 835
              prev_tty = cur_tty;
#line 836
              cur_tty = prev_tty->next;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
        }
      }
    }
#line 842
    prev = usr;
#line 843
    usr = usr->next;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 847
  if (debugmode) {
#line 848
    usr = user_list;
    {
#line 849
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 849
      if (! usr) {
#line 849
        goto while_break___9;
      }
#line 850
      if ((unsigned int )usr->type == 0U) {
#line 850
        if ((usr->info.local)->ttys_found == 0) {
          {
#line 851
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"messed up: %s\n",
                  (usr->info.local)->name);
          }
        }
      }
#line 852
      usr = usr->next;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  {
#line 855
  fflush(stderr);
  }
#line 856
  if (local_req_found == 0) {
    {
#line 857
    exit(1);
    }
  }
#line 860
  usr = user_list;
  {
#line 860
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 860
    if (! ((unsigned long )usr != (unsigned long )((void *)0))) {
#line 860
      goto while_break___10;
    }
#line 861
    if ((usr->info.local)->pref.nodelay) {
      {
#line 862
      send_header(usr);
      }
    }
#line 860
    usr = usr->next;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 866
  while (1) {
    while_continue___11: /* CIL Label */ ;
    {
#line 866
    tmp___28 = fgets((char */* __restrict  */)(buf), 1024, (FILE */* __restrict  */)stdin);
    }
#line 866
    if (! ((unsigned long )tmp___28 != (unsigned long )((void *)0))) {
#line 866
      goto while_break___11;
    }
    {
#line 873
    p = strrchr((char const   *)(buf), '\n');
    }
#line 873
    if (p) {
#line 873
      *p = (char )'\000';
    }
#line 876
    o = obuf;
#line 877
    p = buf;
    {
#line 877
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 877
      if (! ((int )*p != 0)) {
#line 877
        goto while_break___12;
      }
      {
#line 878
      i = toascii((int )*p);
#line 879
      tmp___24 = isprint(i);
      }
#line 879
      if (! tmp___24) {
        {
#line 879
        tmp___25 = isspace(i);
        }
#line 879
        if (! tmp___25) {
#line 879
          if (i != 7) {
#line 880
            tmp___23 = o;
#line 880
            o ++;
#line 880
            *tmp___23 = (char )'^';
#line 881
            i ^= 64;
          }
        }
      }
#line 883
      tmp___26 = o;
#line 883
      o ++;
#line 883
      *tmp___26 = (char )i;
#line 877
      p ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 885
    *o = (char )'\000';
#line 887
    usr = user_list;
    {
#line 888
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 888
      if (! usr) {
#line 888
        goto while_break___13;
      }
#line 889
      ok = 0;
#line 891
      if (! (usr->info.local)->header_sent) {
        {
#line 892
        send_header(usr);
        }
      }
#line 895
      the_tty = (usr->info.local)->ttys;
      {
#line 895
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 895
        if (! ((unsigned long )the_tty != (unsigned long )((void *)0))) {
#line 895
          goto while_break___14;
        }
#line 898
        if ((usr->info.local)->pref.bold == 3) {
          {
#line 899
          ok = fprintf((FILE */* __restrict  */)the_tty->file, (char const   */* __restrict  */)"%s%s\033[m \r\n",
                       (usr->info.local)->pref.line_header, obuf);
          }
        } else {
          {
#line 902
          ok = fprintf((FILE */* __restrict  */)the_tty->file, (char const   */* __restrict  */)"%s%s\r\n",
                       (usr->info.local)->pref.line_header, obuf);
          }
        }
#line 905
        if (ok < 0) {
#line 905
          goto _L___0;
        } else {
          {
#line 905
          tmp___27 = fflush(the_tty->file);
          }
#line 905
          if (tmp___27 == -1) {
            _L___0: /* CIL Label */ 
            {
#line 906
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\anwrite: write to %s on %s failed, user logged out?\n",
                    (usr->info.local)->name, the_tty->name);
#line 909
            fclose(the_tty->file);
            }
#line 910
            if ((usr->info.local)->ttys_found > 1) {
#line 911
              if ((unsigned long )(usr->info.local)->ttys == (unsigned long )the_tty) {
#line 912
                (usr->info.local)->ttys = the_tty->next;
              } else {
#line 914
                tmp_tty = (usr->info.local)->ttys;
                {
#line 916
                while (1) {
                  while_continue___15: /* CIL Label */ ;
#line 916
                  if ((unsigned long )tmp_tty != (unsigned long )((void *)0)) {
#line 916
                    if (! ((unsigned long )tmp_tty->next != (unsigned long )the_tty)) {
#line 916
                      goto while_break___15;
                    }
                  } else {
#line 916
                    goto while_break___15;
                  }
#line 917
                  tmp_tty = tmp_tty->next;
                }
                while_break___15: /* CIL Label */ ;
                }
#line 919
                if ((unsigned long )tmp_tty != (unsigned long )((void *)0)) {
                  {
#line 920
                  tmp_tty->next = the_tty->next;
#line 921
                  free((void *)the_tty);
                  }
                }
              }
            } else
#line 925
            if ((unsigned long )usr == (unsigned long )user_list) {
#line 926
              if ((unsigned long )usr->next != (unsigned long )((void *)0)) {
                {
#line 927
                user_list = usr->next;
#line 928
                free((void *)usr);
#line 929
                local_req_count --;
                }
              } else {
                {
#line 932
                exit(1);
                }
              }
            } else {
#line 936
              temp_prev = user_list;
#line 937
              temp = user_list->next;
              {
#line 939
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 939
                if ((unsigned long )temp != (unsigned long )usr) {
#line 939
                  if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 939
                    goto while_break___16;
                  }
                } else {
#line 939
                  goto while_break___16;
                }
#line 941
                temp_prev = temp;
#line 942
                temp = temp->next;
              }
              while_break___16: /* CIL Label */ ;
              }
              {
#line 945
              temp_prev->next = usr->next;
#line 946
              free((void *)usr);
#line 947
              local_req_count --;
              }
            }
          }
        }
#line 895
        the_tty = the_tty->next;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 952
      usr = usr->next;
    }
    while_break___13: /* CIL Label */ ;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 955
  sigint_handler();
  }
#line 956
  return (0);
}
}
#line 959 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
char *make_idle(int diff ) 
{ 
  char *idle ;
  void *tmp ;

  {
  {
#line 963
  tmp = malloc(20UL * sizeof(char ));
#line 963
  idle = (char *)tmp;
  }
#line 965
  if (diff == 0) {
#line 966
    *(idle + 0) = (char )'\000';
  } else
#line 967
  if (diff < 60) {
    {
#line 968
    snprintf((char */* __restrict  */)idle, (size_t )20, (char const   */* __restrict  */)"%ds",
             diff);
    }
  } else
#line 969
  if (diff < 3600) {
    {
#line 970
    snprintf((char */* __restrict  */)idle, (size_t )20, (char const   */* __restrict  */)"%dm",
             diff / 60);
    }
  } else
#line 971
  if (diff < 86400) {
    {
#line 972
    snprintf((char */* __restrict  */)idle, (size_t )20, (char const   */* __restrict  */)"%d:%.2d",
             diff / 3600, (diff % 3600) / 60);
    }
  } else {
    {
#line 974
    snprintf((char */* __restrict  */)idle, (size_t )20, (char const   */* __restrict  */)"%dd",
             diff / 86400);
    }
  }
#line 975
  return (idle);
}
}
#line 978 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
void sigint_handler(void) 
{ 
  user_t *usr ;
  tty_info_t *tty ;

  {
#line 982
  usr = user_list;
  {
#line 982
  while (1) {
    while_continue: /* CIL Label */ ;
#line 982
    if (! ((unsigned long )usr != (unsigned long )((void *)0))) {
#line 982
      goto while_break;
    }
    {
#line 985
    if ((unsigned int )usr->type == 0U) {
#line 985
      goto case_0;
    }
#line 1008
    goto switch_default;
    case_0: /* CIL Label */ 
#line 986
    if ((unsigned long )usr->info.local != (unsigned long )((void *)0)) {
#line 987
      tty = (usr->info.local)->ttys;
      {
#line 987
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 987
        if (! ((unsigned long )tty != (unsigned long )((void *)0))) {
#line 987
          goto while_break___0;
        }
#line 990
        if ((usr->info.local)->header_sent) {
#line 991
          if ((usr->info.local)->pref.bold) {
            {
#line 992
            fprintf((FILE */* __restrict  */)tty->file, (char const   */* __restrict  */)"\033[1mEOF");
            }
          } else {
            {
#line 994
            fprintf((FILE */* __restrict  */)tty->file, (char const   */* __restrict  */)"EOF");
            }
          }
#line 995
          if ((usr->info.local)->pref.whoeof) {
#line 995
            if (myname) {
              {
#line 996
              fprintf((FILE */* __restrict  */)tty->file, (char const   */* __restrict  */)"(%s)",
                      myname);
              }
            }
          }
#line 997
          if ((usr->info.local)->pref.bold) {
            {
#line 998
            fprintf((FILE */* __restrict  */)tty->file, (char const   */* __restrict  */)"\033[m\n");
            }
          } else {
            {
#line 1000
            fprintf((FILE */* __restrict  */)tty->file, (char const   */* __restrict  */)"\n");
            }
          }
        }
        {
#line 1002
        fclose(tty->file);
#line 987
        tty = tty->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1005
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1009
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Non-local ttys not implemented yet");
    }
#line 1010
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 982
    usr = usr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1014
  putchar('\n');
#line 1015
  exit(0);
  }
}
}
#line 1021
void send_header(user_t *usr ) ;
#line 1021 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
static char timebuf[32]  = {      (char )'\000'};
#line 1018 "/home/wheatley/newnew/temp/nwrite-1.9.2/nwrite.c"
void send_header(user_t *usr ) 
{ 
  user_t *tmp ;
  tty_info_t *the_tty ;
  char *ttime ;
  struct tm *the_time ;
  struct tm *tmp___0 ;
  char *temptr ;
  char *endptr ;
  size_t tempsize ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 1020
  tmp = user_list;
#line 1024
  if ((int )timebuf[0] == 0) {
    {
#line 1029
    tmp___0 = localtime((time_t const   *)(& now));
#line 1029
    the_time = tmp___0;
    }
#line 1031
    if ((unsigned long )the_time != (unsigned long )((void *)0)) {
      {
#line 1032
      strftime((char */* __restrict  */)(timebuf), sizeof(timebuf), (char const   */* __restrict  */)"%X",
               (struct tm  const  */* __restrict  */)the_time);
      }
    }
#line 1034
    if ((int )timebuf[0] == 0) {
      {
#line 1037
      ttime = ctime((time_t const   *)(& now));
#line 1038
      strncat((char */* __restrict  */)(timebuf), (char const   */* __restrict  */)(ttime + 11),
              (size_t )8);
      }
    }
  }
#line 1041
  the_tty = (usr->info.local)->ttys;
  {
#line 1041
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1041
    if (! ((unsigned long )the_tty != (unsigned long )((void *)0))) {
#line 1041
      goto while_break;
    }
#line 1044
    if ((unsigned long )the_tty->file != (unsigned long )((void *)0)) {
      {
#line 1046
      fprintf((FILE */* __restrict  */)the_tty->file, (char const   */* __restrict  */)"\r\n");
      }
#line 1047
      if ((usr->info.local)->pref.beep) {
        {
#line 1048
        fprintf((FILE */* __restrict  */)the_tty->file, (char const   */* __restrict  */)"\a\a\a");
        }
      }
#line 1049
      if ((usr->info.local)->pref.bold) {
        {
#line 1050
        fprintf((FILE */* __restrict  */)the_tty->file, (char const   */* __restrict  */)"%s",
                bold_start);
        }
      }
      {
#line 1052
      fprintf((FILE */* __restrict  */)the_tty->file, (char const   */* __restrict  */)"Message from %s on %s ",
              myname, mytty);
      }
#line 1053
      if ((usr->info.local)->pref.showtarg == 1) {
#line 1053
        if (user_list->next) {
#line 1053
          goto _L;
        } else {
#line 1053
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1053
      if ((usr->info.local)->pref.showtarg == 2) {
        _L: /* CIL Label */ 
        {
#line 1056
        fprintf((FILE */* __restrict  */)the_tty->file, (char const   */* __restrict  */)"to ");
#line 1057
        tmp = user_list;
        }
        {
#line 1057
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1057
          if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 1057
            goto while_break___0;
          }
          {
#line 1058
          fprintf((FILE */* __restrict  */)the_tty->file, (char const   */* __restrict  */)"%s ",
                  (tmp->info.local)->name);
#line 1057
          tmp = tmp->next;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 1061
      fprintf((FILE */* __restrict  */)the_tty->file, (char const   */* __restrict  */)"at %s ... \r\n",
              timebuf);
      }
#line 1062
      if ((usr->info.local)->pref.bold) {
        {
#line 1063
        fprintf((FILE */* __restrict  */)the_tty->file, (char const   */* __restrict  */)"%s",
                bold_end);
        }
      }
      {
#line 1064
      fflush(the_tty->file);
      }
    }
#line 1041
    the_tty = the_tty->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1068
  if ((usr->info.local)->pref.headers) {
    {
#line 1072
    tmp___1 = strlen((char const   *)myname);
#line 1072
    tempsize = ((sizeof("\033[1m") + sizeof("\033[m")) + 3UL) + tmp___1;
#line 1074
    tmp___2 = malloc(tempsize);
#line 1074
    (usr->info.local)->pref.line_header = (char *)tmp___2;
#line 1076
    temptr = (usr->info.local)->pref.line_header;
#line 1077
    *temptr = (char )'\000';
#line 1078
    endptr = temptr + tempsize;
    }
#line 1080
    if ((usr->info.local)->pref.bold > 1) {
      {
#line 1081
      strcpy((char */* __restrict  */)temptr, (char const   */* __restrict  */)(bold_start));
#line 1082
      temptr += sizeof("\033[1m") - 1UL;
      }
    }
    {
#line 1085
    snprintf((char */* __restrict  */)temptr, (size_t )(endptr - temptr), (char const   */* __restrict  */)" %s> ",
             myname);
    }
#line 1087
    if ((usr->info.local)->pref.bold == 2) {
      {
#line 1088
      strcat((char */* __restrict  */)temptr, (char const   */* __restrict  */)(bold_end));
      }
    }
#line 1089
    if (debugmode) {
      {
#line 1090
      printf((char const   */* __restrict  */)"line header for writing to %s: %s\n",
             (usr->info.local)->name, (usr->info.local)->pref.line_header);
      }
    }
  } else
#line 1093
  if ((usr->info.local)->pref.bold == 3) {
    {
#line 1094
    (usr->info.local)->pref.line_header = strdup(bold_start);
    }
  }
#line 1096
  (usr->info.local)->header_sent = 1;
#line 1097
  return;
}
}
