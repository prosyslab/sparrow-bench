/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 32 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools/inotifytools.h"
struct inotify_event;
#line 65 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.h"
enum __anonenum_VISIT_7 {
    preorder = 0,
    postorder = 1,
    endorder = 2,
    leaf = 3
} ;
#line 65 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.h"
typedef enum __anonenum_VISIT_7 VISIT;
#line 74
struct rbnode;
#line 74 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.h"
struct rblists {
   struct rbnode  const  *rootp ;
   struct rbnode  const  *nextp ;
};
#line 81 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.h"
struct rbtree {
   int (*rb_cmp)(void const   * , void const   * , void const   * ) ;
   void const   *rb_config ;
   struct rbnode *rb_root ;
};
#line 8 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools_p.h"
struct watch {
   char *filename ;
   int wd ;
   unsigned int hit_access ;
   unsigned int hit_modify ;
   unsigned int hit_attrib ;
   unsigned int hit_close_write ;
   unsigned int hit_close_nowrite ;
   unsigned int hit_open ;
   unsigned int hit_moved_from ;
   unsigned int hit_moved_to ;
   unsigned int hit_create ;
   unsigned int hit_delete ;
   unsigned int hit_delete_self ;
   unsigned int hit_unmount ;
   unsigned int hit_move_self ;
   unsigned int hit_total ;
};
#line 8 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools_p.h"
typedef struct watch watch;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_15 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_15 __sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_16 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_16 fd_set;
#line 119 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_32 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_32 regmatch_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/sys/inotify.h"
struct inotify_event {
   int wd ;
   uint32_t mask ;
   uint32_t cookie ;
   uint32_t len ;
   char name[] ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
enum nodecolour {
    BLACK = 0,
    RED = 1
} ;
#line 42 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
struct rbnode {
   struct rbnode *left ;
   struct rbnode *right ;
   struct rbnode *up ;
   enum nodecolour colour ;
   void const   *key ;
};
#line 13 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/common.h"
struct __anonstruct_FileList_1 {
   char const   **watch_files ;
   char const   **exclude_files ;
};
#line 13 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/common.h"
typedef struct __anonstruct_FileList_1 FileList;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 405
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools/inotifytools.h"
int inotifytools_str_to_event(char const   *event___2 ) ;
#line 12
int inotifytools_str_to_event_sep(char const   *event___2 , char sep ) ;
#line 13
char *inotifytools_event_to_str(int events___0 ) ;
#line 14
char *inotifytools_event_to_str_sep(int events___0 , char sep ) ;
#line 15
void inotifytools_set_filename_by_wd(int wd___2 , char const   *filename___2 ) ;
#line 16
void inotifytools_set_filename_by_filename(char const   *oldname , char const   *newname ) ;
#line 18
void inotifytools_replace_filename(char const   *oldname , char const   *newname ) ;
#line 20
char *inotifytools_filename_from_wd(int wd___2 ) ;
#line 21
int inotifytools_wd_from_filename(char const   *filename___2 ) ;
#line 22
int inotifytools_remove_watch_by_filename(char const   *filename___2 ) ;
#line 23
int inotifytools_remove_watch_by_wd(int wd___2 ) ;
#line 24
int inotifytools_watch_file(char const   *filename___2 , int events___0 ) ;
#line 25
int inotifytools_watch_files(char const   **filenames___2 , int events___0 ) ;
#line 26
int inotifytools_watch_recursively(char const   *path , int events___0 ) ;
#line 27
int inotifytools_watch_recursively_with_exclude(char const   *path , int events___0 ,
                                                char const   **exclude_list ) ;
#line 31
int inotifytools_ignore_events_by_regex(char const   *pattern , int flags ) ;
#line 32
struct inotify_event *inotifytools_next_event(int timeout ) ;
#line 33
struct inotify_event *inotifytools_next_events(int timeout , int num_events ) ;
#line 34
int inotifytools_error(void) ;
#line 35
int inotifytools_get_stat_by_wd(int wd___2 , int event___2 ) ;
#line 36
int inotifytools_get_stat_total(int event___2 ) ;
#line 37
int inotifytools_get_stat_by_filename(char const   *filename___2 , int event___2 ) ;
#line 39
void inotifytools_initialize_stats(void) ;
#line 40
int inotifytools_initialize(void) ;
#line 41
void inotifytools_cleanup(void) ;
#line 42
int inotifytools_get_num_watches(void) ;
#line 44
int inotifytools_printf(struct inotify_event *event___2 , char *fmt ) ;
#line 45
int inotifytools_fprintf(FILE *file , struct inotify_event *event___2 , char *fmt ) ;
#line 46
int inotifytools_sprintf(char *out___2 , struct inotify_event *event___2 , char *fmt ) ;
#line 47
int inotifytools_snprintf(char *out___2 , int size , struct inotify_event *event___2 ,
                          char *fmt ) ;
#line 49
void inotifytools_set_printf_timefmt(char *fmt ) ;
#line 51
int inotifytools_get_max_user_watches(void) ;
#line 52
int inotifytools_get_max_user_instances(void) ;
#line 53
int inotifytools_get_max_queued_events(void) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.h"
struct rbtree *rbinit(int (*cmp)(void const   * , void const   * , void const   * ) ,
                      void const   *config ) ;
#line 100
void const   *rbdelete(void const   *key , struct rbtree *rbinfo ) ;
#line 104
void const   *rbfind(void const   *key , struct rbtree *rbinfo ) ;
#line 112
void const   *rbsearch(void const   *key , struct rbtree *rbinfo ) ;
#line 116
void rbdestroy(struct rbtree *rbinfo ) ;
#line 120
void rbwalk(struct rbtree  const  *rbinfo , void (*action)(void const   * , VISIT const    ,
                                                           int const    , void * ) ,
            void *arg ) ;
#line 126
struct rblists *rbopenlist(struct rbtree  const  *rbinfo ) ;
#line 127
void const   *rbreadlist(struct rblists *rblistp ) ;
#line 128
void rbcloselist(struct rblists *rblistp ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools_p.h"
struct rbtree *inotifytools_wd_sorted_by_event(int sort_event ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 276 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat64)(char const   * __restrict  __file ,
                                                                                                struct stat64 * __restrict  __buf ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 74
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 84 "/usr/include/x86_64-linux-gnu/sys/inotify.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inotify_init)(void) ;
#line 91
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inotify_add_watch)(int __fd ,
                                                                                        char const   *__name ,
                                                                                        uint32_t __mask ) ;
#line 95
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inotify_rm_watch)(int __fd ,
                                                                                       int __wd ) ;
#line 129 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int inotify_fd  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_access  ;
#line 131 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_modify  ;
#line 132 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_attrib  ;
#line 133 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_close_nowrite  ;
#line 134 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_close_write  ;
#line 135 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_open  ;
#line 136 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_move_self  ;
#line 137 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_moved_to  ;
#line 138 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_moved_from  ;
#line 139 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_create  ;
#line 140 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_delete  ;
#line 141 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_delete_self  ;
#line 142 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_unmount  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_total  ;
#line 144 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int collect_stats  =    0;
#line 146 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
struct rbtree *tree_wd  =    (struct rbtree *)0;
#line 147 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
struct rbtree *tree_filename  =    (struct rbtree *)0;
#line 148 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int error  =    0;
#line 149 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int init  =    0;
#line 150 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char *timefmt  =    (char *)0;
#line 151 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static regex_t *regex  =    (regex_t *)0;
#line 153
int isdir(char const   *path ) ;
#line 154
void record_stats(struct inotify_event  const  *event___2 ) ;
#line 155
int onestr_to_event(char const   *event___2 ) ;
#line 196 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
void _niceassert(long cond , int line , char const   *file , char const   *condstr ,
                 char const   *mesg ) 
{ 


  {
#line 198
  if (cond) {
#line 198
    return;
  }
#line 200
  if (mesg) {
    {
#line 201
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d assertion ( %s ) failed: %s\n",
            file, line, condstr, mesg);
    }
  } else {
    {
#line 205
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d assertion ( %s ) failed.\n",
            file, line, condstr);
    }
  }
#line 207
  return;
}
}
#line 219
char *chrtostr(char ch ) ;
#line 219 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char str[2]  = {      (char )'\000',      (char )'\000'};
#line 218 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
char *chrtostr(char ch ) 
{ 


  {
#line 220
  str[0] = ch;
#line 221
  return (str);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int read_num_from_file(char *filename___2 , int *num ) 
{ 
  FILE *file ;
  FILE *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 228
  tmp = fopen((char const   */* __restrict  */)filename___2, (char const   */* __restrict  */)"r");
#line 228
  file = tmp;
  }
#line 229
  if (! file) {
    {
#line 230
    tmp___0 = __errno_location();
#line 230
    error = *tmp___0;
    }
#line 231
    return (0);
  }
  {
#line 234
  tmp___2 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d",
                   num);
  }
#line 234
  if (-1 == tmp___2) {
    {
#line 235
    tmp___1 = __errno_location();
#line 235
    error = *tmp___1;
    }
#line 236
    return (0);
  }
  {
#line 239
  tmp___3 = fclose(file);
#line 239
  _niceassert((long )(0L == (long )tmp___3), 239, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
              "0 == fclose( file )", (char const   *)0);
  }
#line 241
  return (1);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int wd_compare(void const   *d1 , void const   *d2 , void const   *config ) 
{ 


  {
#line 245
  if (! d1) {
#line 245
    return ((int )(d1 - d2));
  } else
#line 245
  if (! d2) {
#line 245
    return ((int )(d1 - d2));
  }
#line 246
  return (((watch *)d1)->wd - ((watch *)d2)->wd);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int filename_compare(void const   *d1 , void const   *d2 , void const   *config ) 
{ 
  int tmp ;

  {
#line 250
  if (! d1) {
#line 250
    return ((int )(d1 - d2));
  } else
#line 250
  if (! d2) {
#line 250
    return ((int )(d1 - d2));
  }
  {
#line 251
  tmp = strcmp((char const   *)((watch *)d1)->filename, (char const   *)((watch *)d2)->filename);
  }
#line 251
  return (tmp);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
watch *watch_from_wd(int wd___2 ) 
{ 
  watch w ;
  void const   *tmp ;

  {
  {
#line 259
  w.wd = wd___2;
#line 260
  tmp = rbfind((void const   *)(& w), tree_wd);
  }
#line 260
  return ((watch *)tmp);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
watch *watch_from_filename(char const   *filename___2 ) 
{ 
  watch w ;
  void const   *tmp ;

  {
  {
#line 268
  w.filename = (char *)filename___2;
#line 269
  tmp = rbfind((void const   *)(& w), tree_filename);
  }
#line 269
  return ((watch *)tmp);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_initialize(void) 
{ 


  {
#line 282
  if (init) {
#line 282
    return (1);
  }
  {
#line 284
  error = 0;
#line 286
  inotify_fd = inotify_init();
  }
#line 287
  if (inotify_fd < 0) {
#line 288
    error = inotify_fd;
#line 289
    return (0);
  }
  {
#line 292
  collect_stats = 0;
#line 293
  init = 1;
#line 294
  tree_wd = rbinit(& wd_compare, (void const   *)0);
#line 295
  tree_filename = rbinit(& filename_compare, (void const   *)0);
#line 296
  timefmt = (char *)0;
  }
#line 298
  return (1);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
void destroy_watch(watch *w ) 
{ 


  {
#line 305
  if (w->filename) {
    {
#line 305
    free((void *)w->filename);
    }
  }
  {
#line 306
  free((void *)w);
  }
#line 307
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
void cleanup_tree(void const   *nodep , VISIT const   which , int const   depth ,
                  void *arg ) 
{ 
  watch *w ;

  {
#line 315
  if ((unsigned int const   )which != 2U) {
#line 315
    if ((unsigned int const   )which != 3U) {
#line 315
      return;
    }
  }
  {
#line 316
  w = (watch *)nodep;
#line 317
  destroy_watch(w);
  }
#line 318
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
void inotifytools_cleanup(void) 
{ 


  {
#line 327
  if (! init) {
#line 327
    return;
  }
  {
#line 329
  init = 0;
#line 330
  close(inotify_fd);
#line 331
  collect_stats = 0;
#line 332
  error = 0;
#line 333
  timefmt = (char *)0;
  }
#line 335
  if (regex) {
    {
#line 336
    regfree(regex);
#line 337
    free((void *)regex);
#line 338
    regex = (regex_t *)0;
    }
  }
  {
#line 341
  rbwalk((struct rbtree  const  *)tree_wd, & cleanup_tree, (void *)0);
#line 342
  rbdestroy(tree_wd);
#line 342
  tree_wd = (struct rbtree *)0;
#line 343
  rbdestroy(tree_filename);
#line 343
  tree_filename = (struct rbtree *)0;
  }
#line 344
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
void empty_stats(void const   *nodep , VISIT const   which , int const   depth , void *arg ) 
{ 
  watch *w ;

  {
#line 352
  if ((unsigned int const   )which != 2U) {
#line 352
    if ((unsigned int const   )which != 3U) {
#line 352
      return;
    }
  }
#line 353
  w = (watch *)nodep;
#line 354
  w->hit_access = 0U;
#line 355
  w->hit_modify = 0U;
#line 356
  w->hit_attrib = 0U;
#line 357
  w->hit_close_nowrite = 0U;
#line 358
  w->hit_close_write = 0U;
#line 359
  w->hit_open = 0U;
#line 360
  w->hit_move_self = 0U;
#line 361
  w->hit_moved_from = 0U;
#line 362
  w->hit_moved_to = 0U;
#line 363
  w->hit_create = 0U;
#line 364
  w->hit_delete = 0U;
#line 365
  w->hit_delete_self = 0U;
#line 366
  w->hit_unmount = 0U;
#line 367
  w->hit_total = 0U;
#line 368
  return;
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
void replace_filename(void const   *nodep , VISIT const   which , int const   depth ,
                      void *arg ) 
{ 
  watch *w ;
  char *old_name ;
  char *new_name___1 ;
  int old_len ;
  char *name ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 376
  if ((unsigned int const   )which != 2U) {
#line 376
    if ((unsigned int const   )which != 3U) {
#line 376
      return;
    }
  }
  {
#line 377
  w = (watch *)nodep;
#line 378
  old_name = *((char **)arg + 0);
#line 379
  new_name___1 = *((char **)arg + 1);
#line 380
  old_len = *((int *)((char **)arg + 2));
#line 382
  tmp___1 = strncmp((char const   *)old_name, (char const   *)w->filename, (size_t )old_len);
  }
#line 382
  if (0 == tmp___1) {
    {
#line 383
    tmp = asprintf((char **/* __restrict  */)(& name), (char const   */* __restrict  */)"%s%s",
                   new_name___1, w->filename + old_len);
#line 383
    _niceassert((long )(-1L != (long )tmp), 383, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
                "-1 != asprintf(&name, \"%s%s\", new_name, &(w->filename[old_len]))",
                "out of memory");
#line 384
    tmp___0 = strcmp((char const   *)w->filename, (char const   *)new_name___1);
    }
#line 384
    if (tmp___0) {
      {
#line 387
      rbdelete((void const   *)w, tree_filename);
#line 388
      free((void *)w->filename);
#line 389
      w->filename = name;
#line 390
      rbsearch((void const   *)w, tree_filename);
      }
    } else {
      {
#line 385
      free((void *)name);
      }
    }
  }
#line 393
  return;
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
void get_num(void const   *nodep , VISIT const   which , int const   depth , void *arg ) 
{ 


  {
#line 401
  if ((unsigned int const   )which != 2U) {
#line 401
    if ((unsigned int const   )which != 3U) {
#line 401
      return;
    }
  }
#line 402
  (*((int *)arg)) ++;
#line 403
  return;
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
void inotifytools_initialize_stats(void) 
{ 


  {
  {
#line 419
  _niceassert((long )init, 419, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
              "init", "inotifytools_initialize not called yet");
  }
#line 422
  if (collect_stats) {
    {
#line 423
    rbwalk((struct rbtree  const  *)tree_wd, & empty_stats, (void *)0);
    }
  }
#line 426
  num_access = 0U;
#line 427
  num_modify = 0U;
#line 428
  num_attrib = 0U;
#line 429
  num_close_nowrite = 0U;
#line 430
  num_close_write = 0U;
#line 431
  num_open = 0U;
#line 432
  num_move_self = 0U;
#line 433
  num_moved_from = 0U;
#line 434
  num_moved_to = 0U;
#line 435
  num_create = 0U;
#line 436
  num_delete = 0U;
#line 437
  num_delete_self = 0U;
#line 438
  num_unmount = 0U;
#line 439
  num_total = 0U;
#line 441
  collect_stats = 1;
#line 442
  return;
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_str_to_event_sep(char const   *event___2 , char sep ) 
{ 
  char *tmp ;
  int ret___11 ;
  int ret1 ;
  int len ;
  char *event1 ;
  char *event2 ;
  char eventstr___2[4096] ;
  size_t tmp___0 ;

  {
  {
#line 472
  tmp = strchr("_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", (int )sep);
  }
#line 472
  if (tmp) {
#line 474
    return (-1);
  }
#line 480
  ret___11 = 0;
#line 482
  if (! event___2) {
#line 482
    return (0);
  } else
#line 482
  if (! *(event___2 + 0)) {
#line 482
    return (0);
  }
  {
#line 484
  event1 = (char *)event___2;
#line 485
  event2 = strchr((char const   *)event1, (int )sep);
  }
  {
#line 486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 486
    if (event1) {
#line 486
      if (! *(event1 + 0)) {
#line 486
        goto while_break;
      }
    } else {
#line 486
      goto while_break;
    }
#line 487
    if (event2) {
      {
#line 488
      len = (int )(event2 - event1);
#line 489
      _niceassert((long )((long )len < 4096L), 489, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
                  "len < 4096", "malformed event string (very long)");
      }
    } else {
      {
#line 492
      tmp___0 = strlen((char const   *)event1);
#line 492
      len = (int )tmp___0;
      }
    }
#line 494
    if (len > 4095) {
#line 494
      len = 4095;
    }
    {
#line 495
    strncpy((char */* __restrict  */)(eventstr___2), (char const   */* __restrict  */)event1,
            (size_t )len);
#line 496
    eventstr___2[len] = (char)0;
#line 498
    ret1 = onestr_to_event((char const   *)(eventstr___2));
    }
#line 499
    if (0 == ret1) {
#line 500
      ret___11 = ret1;
#line 501
      goto while_break;
    } else
#line 499
    if (-1 == ret1) {
#line 500
      ret___11 = ret1;
#line 501
      goto while_break;
    }
#line 503
    ret___11 |= ret1;
#line 505
    event1 = event2;
#line 506
    if (event1) {
#line 506
      if (*(event1 + 0)) {
#line 508
        event1 ++;
#line 510
        if (! *(event1 + 0)) {
#line 510
          return (0);
        }
        {
#line 511
        event2 = strchr((char const   *)event1, (int )sep);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 515
  return (ret___11);
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_str_to_event(char const   *event___2 ) 
{ 
  int tmp ;

  {
  {
#line 542
  tmp = inotifytools_str_to_event_sep(event___2, (char )',');
  }
#line 542
  return (tmp);
}
}
#line 558 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int ret  ;
#line 556 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int onestr_to_event(char const   *event___2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 559
  ret = -1;
#line 561
  if (! event___2) {
#line 562
    ret = 0;
  } else
#line 561
  if (! *(event___2 + 0)) {
#line 562
    ret = 0;
  } else {
    {
#line 563
    tmp___18 = strcasecmp(event___2, "ACCESS");
    }
#line 563
    if (0 == tmp___18) {
#line 564
      ret = 1;
    } else {
      {
#line 565
      tmp___17 = strcasecmp(event___2, "MODIFY");
      }
#line 565
      if (0 == tmp___17) {
#line 566
        ret = 2;
      } else {
        {
#line 567
        tmp___16 = strcasecmp(event___2, "ATTRIB");
        }
#line 567
        if (0 == tmp___16) {
#line 568
          ret = 4;
        } else {
          {
#line 569
          tmp___15 = strcasecmp(event___2, "CLOSE_WRITE");
          }
#line 569
          if (0 == tmp___15) {
#line 570
            ret = 8;
          } else {
            {
#line 571
            tmp___14 = strcasecmp(event___2, "CLOSE_NOWRITE");
            }
#line 571
            if (0 == tmp___14) {
#line 572
              ret = 16;
            } else {
              {
#line 573
              tmp___13 = strcasecmp(event___2, "OPEN");
              }
#line 573
              if (0 == tmp___13) {
#line 574
                ret = 32;
              } else {
                {
#line 575
                tmp___12 = strcasecmp(event___2, "MOVED_FROM");
                }
#line 575
                if (0 == tmp___12) {
#line 576
                  ret = 64;
                } else {
                  {
#line 577
                  tmp___11 = strcasecmp(event___2, "MOVED_TO");
                  }
#line 577
                  if (0 == tmp___11) {
#line 578
                    ret = 128;
                  } else {
                    {
#line 579
                    tmp___10 = strcasecmp(event___2, "CREATE");
                    }
#line 579
                    if (0 == tmp___10) {
#line 580
                      ret = 256;
                    } else {
                      {
#line 581
                      tmp___9 = strcasecmp(event___2, "DELETE");
                      }
#line 581
                      if (0 == tmp___9) {
#line 582
                        ret = 512;
                      } else {
                        {
#line 583
                        tmp___8 = strcasecmp(event___2, "DELETE_SELF");
                        }
#line 583
                        if (0 == tmp___8) {
#line 584
                          ret = 1024;
                        } else {
                          {
#line 585
                          tmp___7 = strcasecmp(event___2, "UNMOUNT");
                          }
#line 585
                          if (0 == tmp___7) {
#line 586
                            ret = 8192;
                          } else {
                            {
#line 587
                            tmp___6 = strcasecmp(event___2, "Q_OVERFLOW");
                            }
#line 587
                            if (0 == tmp___6) {
#line 588
                              ret = 16384;
                            } else {
                              {
#line 589
                              tmp___5 = strcasecmp(event___2, "IGNORED");
                              }
#line 589
                              if (0 == tmp___5) {
#line 590
                                ret = 32768;
                              } else {
                                {
#line 591
                                tmp___4 = strcasecmp(event___2, "CLOSE");
                                }
#line 591
                                if (0 == tmp___4) {
#line 592
                                  ret = 24;
                                } else {
                                  {
#line 593
                                  tmp___3 = strcasecmp(event___2, "MOVE_SELF");
                                  }
#line 593
                                  if (0 == tmp___3) {
#line 594
                                    ret = 2048;
                                  } else {
                                    {
#line 595
                                    tmp___2 = strcasecmp(event___2, "MOVE");
                                    }
#line 595
                                    if (0 == tmp___2) {
#line 596
                                      ret = 192;
                                    } else {
                                      {
#line 597
                                      tmp___1 = strcasecmp(event___2, "ISDIR");
                                      }
#line 597
                                      if (0 == tmp___1) {
#line 598
                                        ret = 1073741824;
                                      } else {
                                        {
#line 599
                                        tmp___0 = strcasecmp(event___2, "ONESHOT");
                                        }
#line 599
                                        if (0 == tmp___0) {
#line 600
                                          ret = (-0x7FFFFFFF-1);
                                        } else {
                                          {
#line 601
                                          tmp = strcasecmp(event___2, "ALL_EVENTS");
                                          }
#line 601
                                          if (0 == tmp) {
#line 602
                                            ret = 4095;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 604
  return (ret);
}
}
#line 628 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
char *inotifytools_event_to_str(int events___0 ) 
{ 
  char *tmp ;

  {
  {
#line 629
  tmp = inotifytools_event_to_str_sep(events___0, (char )',');
  }
#line 629
  return (tmp);
}
}
#line 658 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char ret___0[1024]  ;
#line 656 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
char *inotifytools_event_to_str_sep(int events___0 , char sep ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;

  {
#line 659
  ret___0[0] = (char )'\000';
#line 660
  ret___0[1] = (char )'\000';
#line 662
  if (1 & events___0) {
    {
#line 663
    tmp = chrtostr(sep);
#line 663
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp);
#line 664
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"ACCESS");
    }
  }
#line 666
  if (2 & events___0) {
    {
#line 667
    tmp___0 = chrtostr(sep);
#line 667
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___0);
#line 668
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"MODIFY");
    }
  }
#line 670
  if (4 & events___0) {
    {
#line 671
    tmp___1 = chrtostr(sep);
#line 671
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___1);
#line 672
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"ATTRIB");
    }
  }
#line 674
  if (8 & events___0) {
    {
#line 675
    tmp___2 = chrtostr(sep);
#line 675
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___2);
#line 676
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"CLOSE_WRITE");
    }
  }
#line 678
  if (16 & events___0) {
    {
#line 679
    tmp___3 = chrtostr(sep);
#line 679
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___3);
#line 680
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"CLOSE_NOWRITE");
    }
  }
#line 682
  if (32 & events___0) {
    {
#line 683
    tmp___4 = chrtostr(sep);
#line 683
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___4);
#line 684
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"OPEN");
    }
  }
#line 686
  if (64 & events___0) {
    {
#line 687
    tmp___5 = chrtostr(sep);
#line 687
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___5);
#line 688
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"MOVED_FROM");
    }
  }
#line 690
  if (128 & events___0) {
    {
#line 691
    tmp___6 = chrtostr(sep);
#line 691
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___6);
#line 692
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"MOVED_TO");
    }
  }
#line 694
  if (256 & events___0) {
    {
#line 695
    tmp___7 = chrtostr(sep);
#line 695
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___7);
#line 696
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"CREATE");
    }
  }
#line 698
  if (512 & events___0) {
    {
#line 699
    tmp___8 = chrtostr(sep);
#line 699
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___8);
#line 700
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"DELETE");
    }
  }
#line 702
  if (1024 & events___0) {
    {
#line 703
    tmp___9 = chrtostr(sep);
#line 703
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___9);
#line 704
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"DELETE_SELF");
    }
  }
#line 706
  if (8192 & events___0) {
    {
#line 707
    tmp___10 = chrtostr(sep);
#line 707
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___10);
#line 708
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"UNMOUNT");
    }
  }
#line 710
  if (16384 & events___0) {
    {
#line 711
    tmp___11 = chrtostr(sep);
#line 711
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___11);
#line 712
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"Q_OVERFLOW");
    }
  }
#line 714
  if (32768 & events___0) {
    {
#line 715
    tmp___12 = chrtostr(sep);
#line 715
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___12);
#line 716
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"IGNORED");
    }
  }
#line 718
  if (24 & events___0) {
    {
#line 719
    tmp___13 = chrtostr(sep);
#line 719
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___13);
#line 720
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"CLOSE");
    }
  }
#line 722
  if (2048 & events___0) {
    {
#line 723
    tmp___14 = chrtostr(sep);
#line 723
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___14);
#line 724
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"MOVE_SELF");
    }
  }
#line 726
  if (1073741824 & events___0) {
    {
#line 727
    tmp___15 = chrtostr(sep);
#line 727
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___15);
#line 728
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"ISDIR");
    }
  }
#line 730
  if (2147483648U & (unsigned int )events___0) {
    {
#line 731
    tmp___16 = chrtostr(sep);
#line 731
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)tmp___16);
#line 732
    strcat((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"ONESHOT");
    }
  }
#line 736
  if ((int )ret___0[0] == 0) {
    {
#line 737
    tmp___17 = sprintf((char */* __restrict  */)(ret___0), (char const   */* __restrict  */)"%c0x%08x",
                       (int )sep, events___0);
#line 737
    _niceassert((long )(-1L != (long )tmp___17), 737, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
                "-1 != sprintf( ret, \"%c0x%08x\", sep, events )", (char const   *)0);
    }
  }
#line 740
  return (& ret___0[1]);
}
}
#line 763 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
char *inotifytools_filename_from_wd(int wd___2 ) 
{ 
  watch *w ;
  watch *tmp ;

  {
  {
#line 764
  _niceassert((long )init, 764, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
              "init", "inotifytools_initialize not called yet");
#line 765
  tmp = watch_from_wd(wd___2);
#line 765
  w = tmp;
  }
#line 766
  if (! w) {
#line 767
    return ((char *)((void *)0));
  }
#line 769
  return (w->filename);
}
}
#line 786 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_wd_from_filename(char const   *filename___2 ) 
{ 
  watch *w ;
  watch *tmp ;

  {
  {
#line 787
  _niceassert((long )init, 787, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
              "init", "inotifytools_initialize not called yet");
#line 788
  tmp = watch_from_filename(filename___2);
#line 788
  w = tmp;
  }
#line 789
  if (! w) {
#line 789
    return (-1);
  }
#line 790
  return (w->wd);
}
}
#line 807 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
void inotifytools_set_filename_by_wd(int wd___2 , char const   *filename___2 ) 
{ 
  watch *w ;
  watch *tmp ;

  {
  {
#line 808
  _niceassert((long )init, 808, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
              "init", "inotifytools_initialize not called yet");
#line 809
  tmp = watch_from_wd(wd___2);
#line 809
  w = tmp;
  }
#line 810
  if (! w) {
#line 810
    return;
  }
#line 811
  if (w->filename) {
    {
#line 811
    free((void *)w->filename);
    }
  }
  {
#line 812
  w->filename = strdup(filename___2);
  }
#line 813
  return;
}
}
#line 829 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
void inotifytools_set_filename_by_filename(char const   *oldname , char const   *newname ) 
{ 
  watch *w ;
  watch *tmp ;

  {
  {
#line 831
  tmp = watch_from_filename(oldname);
#line 831
  w = tmp;
  }
#line 832
  if (! w) {
#line 832
    return;
  }
#line 833
  if (w->filename) {
    {
#line 833
    free((void *)w->filename);
    }
  }
  {
#line 834
  w->filename = strdup(newname);
  }
#line 835
  return;
}
}
#line 859 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
void inotifytools_replace_filename(char const   *oldname , char const   *newname ) 
{ 
  char *names[2UL + sizeof(int ) / sizeof(char *)] ;
  size_t tmp ;

  {
#line 861
  if (! oldname) {
#line 861
    return;
  } else
#line 861
  if (! newname) {
#line 861
    return;
  }
  {
#line 863
  names[0] = (char *)oldname;
#line 864
  names[1] = (char *)newname;
#line 865
  tmp = strlen(oldname);
#line 865
  *((int *)(& names[2])) = (int )tmp;
#line 866
  rbwalk((struct rbtree  const  *)tree_filename, & replace_filename, (void *)(names));
  }
#line 867
  return;
}
}
#line 872 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int remove_inotify_watch(watch *w ) 
{ 
  int status___2 ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 873
  error = 0;
#line 874
  tmp = inotify_rm_watch(inotify_fd, w->wd);
#line 874
  status___2 = tmp;
  }
#line 875
  if (status___2 < 0) {
    {
#line 876
    tmp___0 = strerror(status___2);
#line 876
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to remove watch on %s: %s\n",
            w->filename, tmp___0);
#line 878
    error = status___2;
    }
#line 879
    return (0);
  }
#line 881
  return (1);
}
}
#line 887 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
watch *create_watch(int wd___2 , char *filename___2 ) 
{ 
  watch *w ;
  void *tmp ;

  {
#line 888
  if (wd___2 <= 0) {
#line 888
    return ((watch *)0);
  } else
#line 888
  if (! filename___2) {
#line 888
    return ((watch *)0);
  }
  {
#line 890
  tmp = calloc((size_t )1, sizeof(watch ));
#line 890
  w = (watch *)tmp;
#line 891
  w->wd = wd___2;
#line 892
  w->filename = strdup((char const   *)filename___2);
#line 893
  rbsearch((void const   *)w, tree_wd);
#line 894
  rbsearch((void const   *)w, tree_filename);
  }
#line 895
  return ((watch *)0);
}
}
#line 909 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_remove_watch_by_wd(int wd___2 ) 
{ 
  watch *w ;
  watch *tmp ;
  int tmp___0 ;

  {
  {
#line 910
  _niceassert((long )init, 910, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
              "init", "inotifytools_initialize not called yet");
#line 911
  tmp = watch_from_wd(wd___2);
#line 911
  w = tmp;
  }
#line 912
  if (! w) {
#line 912
    return (1);
  }
  {
#line 914
  tmp___0 = remove_inotify_watch(w);
  }
#line 914
  if (! tmp___0) {
#line 914
    return (0);
  }
  {
#line 915
  rbdelete((void const   *)w, tree_wd);
#line 916
  rbdelete((void const   *)w, tree_filename);
#line 917
  destroy_watch(w);
  }
#line 918
  return (1);
}
}
#line 932 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_remove_watch_by_filename(char const   *filename___2 ) 
{ 
  watch *w ;
  watch *tmp ;
  int tmp___0 ;

  {
  {
#line 933
  _niceassert((long )init, 933, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
              "init", "inotifytools_initialize not called yet");
#line 934
  tmp = watch_from_filename(filename___2);
#line 934
  w = tmp;
  }
#line 935
  if (! w) {
#line 935
    return (1);
  }
  {
#line 937
  tmp___0 = remove_inotify_watch(w);
  }
#line 937
  if (! tmp___0) {
#line 937
    return (0);
  }
  {
#line 938
  rbdelete((void const   *)w, tree_wd);
#line 939
  rbdelete((void const   *)w, tree_filename);
#line 940
  destroy_watch(w);
  }
#line 941
  return (1);
}
}
#line 956 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char const   *filenames[2]  ;
#line 955 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_watch_file(char const   *filename___2 , int events___0 ) 
{ 
  int tmp ;

  {
  {
#line 957
  filenames[0] = filename___2;
#line 958
  filenames[1] = (char const   *)((void *)0);
#line 959
  tmp = inotifytools_watch_files(filenames, events___0);
  }
#line 959
  return (tmp);
}
}
#line 981 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int i  ;
#line 983 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int wd  ;
#line 977 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_watch_files(char const   **filenames___2 , int events___0 ) 
{ 
  int *tmp ;
  char *filename___2 ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 978
  _niceassert((long )init, 978, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
              "init", "inotifytools_initialize not called yet");
#line 979
  error = 0;
#line 982
  i = 0;
  }
  {
#line 982
  while (1) {
    while_continue: /* CIL Label */ ;
#line 982
    if (! *(filenames___2 + i)) {
#line 982
      goto while_break;
    }
    {
#line 984
    wd = inotify_add_watch(inotify_fd, *(filenames___2 + i), (uint32_t )events___0);
    }
#line 985
    if (wd < 0) {
#line 986
      if (wd == -1) {
        {
#line 987
        tmp = __errno_location();
#line 987
        error = *tmp;
        }
#line 988
        return (0);
      } else {
        {
#line 991
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to watch %s: returned wd was %d (expected -1 or >0 )",
                *(filenames___2 + i), wd);
        }
#line 994
        return (0);
      }
    }
    {
#line 1000
    tmp___1 = isdir(*(filenames___2 + i));
    }
#line 1000
    if (tmp___1) {
      {
#line 1000
      tmp___2 = strlen(*(filenames___2 + i));
      }
#line 1000
      if ((int const   )*(*(filenames___2 + i) + (tmp___2 - 1UL)) == 47) {
        {
#line 1002
        filename___2 = strdup(*(filenames___2 + i));
        }
      } else {
        {
#line 1005
        tmp___0 = asprintf((char **/* __restrict  */)(& filename___2), (char const   */* __restrict  */)"%s/",
                           *(filenames___2 + i));
#line 1005
        _niceassert((long )(-1L != (long )tmp___0), 1005, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
                    "-1 != asprintf(&filename, \"%s/\", filenames[i])", "out of memory");
        }
      }
    } else {
      {
#line 1002
      filename___2 = strdup(*(filenames___2 + i));
      }
    }
    {
#line 1007
    create_watch(wd, filename___2);
#line 1008
    free((void *)filename___2);
#line 982
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1011
  return (1);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
struct inotify_event *inotifytools_next_event(int timeout ) 
{ 
  struct inotify_event *tmp ;

  {
  {
#line 1041
  tmp = inotifytools_next_events(timeout, 1);
  }
#line 1041
  return (tmp);
}
}
#line 1100 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct inotify_event event[4096]  ;
#line 1101 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct inotify_event *ret___1  ;
#line 1102 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int first_byte  =    0;
#line 1103 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static ssize_t bytes  ;
#line 1104 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static jmp_buf jmp  ;
#line 1105 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char match_name[4096]  ;
#line 1161 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static ssize_t this_bytes  ;
#line 1162 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int bytes_to_read  ;
#line 1163 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int rc  ;
#line 1164 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static fd_set read_fds  ;
#line 1166 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct timeval read_timeout  ;
#line 1169 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct timeval *read_timeout_ptr  ;
#line 1094 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
struct inotify_event *inotifytools_next_events(int timeout , int num_events ) 
{ 
  struct inotify_event *tmp ;
  int tmp___0 ;
  int __d0 ;
  int __d1 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1095
  _niceassert((long )init, 1095, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
              "init", "inotifytools_initialize not called yet");
#line 1096
  _niceassert((long )((long )num_events <= 4096L), 1096, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
              "num_events <= MAX_EVENTS", "too many events requested");
  }
#line 1098
  if (num_events < 1) {
#line 1098
    return ((struct inotify_event *)((void *)0));
  }
  {
#line 1120
  _setjmp((struct __jmp_buf_tag *)(jmp));
#line 1122
  error = 0;
  }
#line 1125
  if (first_byte != 0) {
#line 1125
    if (first_byte <= (int )((unsigned long )bytes - sizeof(struct inotify_event ))) {
#line 1128
      ret___1 = (struct inotify_event *)((char *)(& event[0]) + first_byte);
#line 1129
      first_byte = (int )((unsigned long )first_byte + (sizeof(struct inotify_event ) + (unsigned long )ret___1->len));
#line 1133
      if ((ssize_t )first_byte == bytes) {
#line 1134
        first_byte = 0;
      } else
#line 1136
      if ((ssize_t )first_byte > bytes) {
        {
#line 1143
        _niceassert((long )((long )(((char *)(& event[0]) + sizeof(struct inotify_event )) + event[0].len) <= (long )ret___1),
                    1146, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
                    "(long)((char *)&event[0] + sizeof(struct inotify_event) + event[0].len) <= (long)ret",
                    "extremely unlucky user, death imminent");
#line 1148
        bytes = ((char *)(& event[0]) + bytes) - (char *)ret___1;
#line 1149
        memcpy((void */* __restrict  */)(& event[0]), (void const   */* __restrict  */)ret___1,
               (size_t )bytes);
#line 1150
        tmp = inotifytools_next_events(timeout, num_events);
        }
#line 1150
        return (tmp);
      }
#line 1152
      if (regex) {
        {
#line 1152
        inotifytools_snprintf(match_name, 4096, ret___1, (char *)"%w%f");
#line 1152
        tmp___0 = regexec((regex_t const   */* __restrict  */)regex, (char const   */* __restrict  */)(match_name),
                          (size_t )0, (regmatch_t */* __restrict  */)0, 0);
        }
#line 1152
        if (0 == tmp___0) {
          {
#line 1152
          longjmp((struct __jmp_buf_tag *)(jmp), 0);
          }
        }
      }
#line 1152
      if (collect_stats) {
        {
#line 1152
        record_stats((struct inotify_event  const  *)ret___1);
        }
      }
#line 1152
      return (ret___1);
    } else {
#line 1125
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1156
  if (first_byte == 0) {
#line 1157
    bytes = (ssize_t )0;
  }
#line 1167
  read_timeout.tv_sec = (__time_t )timeout;
#line 1168
  read_timeout.tv_usec = (__suseconds_t )0;
#line 1170
  if (timeout <= 0) {
#line 1170
    read_timeout_ptr = (struct timeval *)((void *)0);
  } else {
#line 1170
    read_timeout_ptr = & read_timeout;
  }
  {
#line 1172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1172
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& read_fds.fds_bits[0]): "memory");
#line 1172
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1173
  read_fds.fds_bits[inotify_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << inotify_fd % (8 * (int )sizeof(__fd_mask ));
#line 1174
  rc = select(inotify_fd + 1, (fd_set */* __restrict  */)(& read_fds), (fd_set */* __restrict  */)((void *)0),
              (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)read_timeout_ptr);
  }
#line 1176
  if (rc < 0) {
    {
#line 1178
    tmp___1 = __errno_location();
#line 1178
    error = *tmp___1;
    }
#line 1179
    return ((struct inotify_event *)((void *)0));
  } else
#line 1181
  if (rc == 0) {
#line 1183
    return ((struct inotify_event *)((void *)0));
  }
  {
#line 1187
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1188
    rc = ioctl(inotify_fd, 21531UL, & bytes_to_read);
    }
#line 1187
    if (! rc) {
#line 1187
      if (! ((unsigned long )bytes_to_read < sizeof(struct inotify_event ) * (unsigned long )num_events)) {
#line 1187
        goto while_break___0;
      }
    } else {
#line 1187
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1192
  if (rc == -1) {
    {
#line 1193
    tmp___2 = __errno_location();
#line 1193
    error = *tmp___2;
    }
#line 1194
    return ((struct inotify_event *)((void *)0));
  }
  {
#line 1197
  this_bytes = read(inotify_fd, (void *)(& event[0] + bytes), sizeof(struct inotify_event ) * 4096UL - (unsigned long )bytes);
  }
#line 1199
  if (this_bytes < 0L) {
    {
#line 1200
    tmp___3 = __errno_location();
#line 1200
    error = *tmp___3;
    }
#line 1201
    return ((struct inotify_event *)((void *)0));
  }
#line 1203
  if (this_bytes == 0L) {
    {
#line 1204
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Inotify reported end-of-file.  Possibly too many events occurred at once.\n");
    }
#line 1206
    return ((struct inotify_event *)((void *)0));
  }
  {
#line 1208
  bytes += this_bytes;
#line 1210
  ret___1 = & event[0];
#line 1211
  first_byte = (int )(sizeof(struct inotify_event ) + (unsigned long )ret___1->len);
#line 1212
  _niceassert((long )((long )first_byte <= bytes), 1213, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
              "first_byte <= bytes", "ridiculously long filename, things will almost certainly screw up.");
  }
#line 1214
  if ((ssize_t )first_byte == bytes) {
#line 1215
    first_byte = 0;
  }
#line 1218
  if (regex) {
    {
#line 1218
    inotifytools_snprintf(match_name, 4096, ret___1, (char *)"%w%f");
#line 1218
    tmp___4 = regexec((regex_t const   */* __restrict  */)regex, (char const   */* __restrict  */)(match_name),
                      (size_t )0, (regmatch_t */* __restrict  */)0, 0);
    }
#line 1218
    if (0 == tmp___4) {
      {
#line 1218
      longjmp((struct __jmp_buf_tag *)(jmp), 0);
      }
    }
  }
#line 1218
  if (collect_stats) {
    {
#line 1218
    record_stats((struct inotify_event  const  *)ret___1);
    }
  }
#line 1218
  return (ret___1);
}
}
#line 1248 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_watch_recursively(char const   *path , int events___0 ) 
{ 
  int tmp ;

  {
  {
#line 1249
  tmp = inotifytools_watch_recursively_with_exclude(path, events___0, (char const   **)0);
  }
#line 1249
  return (tmp);
}
}
#line 1310 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct dirent *ent  ;
#line 1312 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct stat64 my_stat  ;
#line 1333 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int no_watch  ;
#line 1334 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char const   **exclude_entry  ;
#line 1340 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int exclude_length  ;
#line 1353 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int status  ;
#line 1284 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_watch_recursively_with_exclude(char const   *path , int events___0 ,
                                                char const   **exclude_list ) 
{ 
  DIR *dir ;
  char *my_path ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *next_file ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int ret___11 ;
  int tmp___15 ;

  {
  {
#line 1286
  _niceassert((long )init, 1286, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
              "init", "inotifytools_initialize not called yet");
#line 1290
  error = 0;
#line 1291
  dir = opendir(path);
  }
#line 1292
  if (! dir) {
    {
#line 1294
    tmp___1 = __errno_location();
    }
#line 1294
    if (*tmp___1 == 20) {
      {
#line 1295
      tmp = inotifytools_watch_file(path, events___0);
      }
#line 1295
      return (tmp);
    } else {
      {
#line 1298
      tmp___0 = __errno_location();
#line 1298
      error = *tmp___0;
      }
#line 1299
      return (0);
    }
  }
  {
#line 1303
  tmp___3 = strlen(path);
  }
#line 1303
  if ((int const   )*(path + (tmp___3 - 1UL)) != 47) {
    {
#line 1304
    tmp___2 = asprintf((char **/* __restrict  */)(& my_path), (char const   */* __restrict  */)"%s/",
                       path);
#line 1304
    _niceassert((long )(-1L != (long )tmp___2), 1304, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
                "-1 != asprintf(&my_path, \"%s/\", path)", "out of memory");
    }
  } else {
#line 1307
    my_path = (char *)path;
  }
  {
#line 1313
  ent = readdir(dir);
  }
  {
#line 1315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1315
    if (! ent) {
#line 1315
      goto while_break;
    }
    {
#line 1316
    tmp___13 = strcmp((char const   *)(ent->d_name), ".");
    }
#line 1316
    if (0 != tmp___13) {
      {
#line 1316
      tmp___14 = strcmp((char const   *)(ent->d_name), "..");
      }
#line 1316
      if (0 != tmp___14) {
        {
#line 1318
        tmp___4 = asprintf((char **/* __restrict  */)(& next_file), (char const   */* __restrict  */)"%s%s",
                           my_path, ent->d_name);
#line 1318
        _niceassert((long )(-1L != (long )tmp___4), 1318, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
                    "-1 != asprintf(&next_file,\"%s%s\", my_path, ent->d_name)", "out of memory");
#line 1319
        tmp___12 = lstat64((char const   */* __restrict  */)next_file, (struct stat64 */* __restrict  */)(& my_stat));
        }
#line 1319
        if (-1 == tmp___12) {
          {
#line 1320
          tmp___5 = __errno_location();
#line 1320
          error = *tmp___5;
#line 1321
          free((void *)next_file);
#line 1322
          tmp___7 = __errno_location();
          }
#line 1322
          if (*tmp___7 != 13) {
            {
#line 1323
            tmp___6 = __errno_location();
#line 1323
            error = *tmp___6;
            }
#line 1324
            if ((unsigned long )my_path != (unsigned long )path) {
              {
#line 1324
              free((void *)my_path);
              }
            }
            {
#line 1325
            closedir(dir);
            }
#line 1326
            return (0);
          }
        } else
#line 1329
        if ((my_stat.st_mode & 61440U) == 16384U) {
#line 1329
          if (! ((my_stat.st_mode & 61440U) == 40960U)) {
            {
#line 1331
            free((void *)next_file);
#line 1332
            tmp___8 = asprintf((char **/* __restrict  */)(& next_file), (char const   */* __restrict  */)"%s%s/",
                               my_path, ent->d_name);
#line 1332
            _niceassert((long )(-1L != (long )tmp___8), 1332, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
                        "-1 != asprintf(&next_file,\"%s%s/\", my_path, ent->d_name)",
                        "out of memory");
#line 1336
            no_watch = 0U;
#line 1337
            exclude_entry = exclude_list;
            }
            {
#line 1337
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1337
              if (exclude_entry) {
#line 1337
                if (*exclude_entry) {
#line 1337
                  if (! (! no_watch)) {
#line 1337
                    goto while_break___0;
                  }
                } else {
#line 1337
                  goto while_break___0;
                }
              } else {
#line 1337
                goto while_break___0;
              }
              {
#line 1342
              tmp___9 = strlen(*exclude_entry);
#line 1342
              exclude_length = (int )tmp___9;
              }
#line 1343
              if ((int const   )*(*exclude_entry + (exclude_length - 1)) == 47) {
#line 1344
                exclude_length --;
              }
              {
#line 1346
              tmp___10 = strlen((char const   *)next_file);
              }
#line 1346
              if (tmp___10 == (size_t )((unsigned int )(exclude_length + 1))) {
                {
#line 1346
                tmp___11 = strncmp(*exclude_entry, (char const   *)next_file, (size_t )exclude_length);
                }
#line 1346
                if (! tmp___11) {
#line 1349
                  no_watch = 1U;
                }
              }
#line 1337
              exclude_entry ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 1352
            if (! no_watch) {
              {
#line 1354
              status = inotifytools_watch_recursively_with_exclude((char const   *)next_file,
                                                                   events___0, exclude_list);
              }
#line 1359
              if (! status) {
#line 1359
                if (13 != error) {
#line 1359
                  if (2 != error) {
#line 1359
                    if (40 != error) {
                      {
#line 1361
                      free((void *)next_file);
                      }
#line 1362
                      if ((unsigned long )my_path != (unsigned long )path) {
                        {
#line 1362
                        free((void *)my_path);
                        }
                      }
                      {
#line 1363
                      closedir(dir);
                      }
#line 1364
                      return (0);
                    }
                  }
                }
              }
            }
            {
#line 1367
            free((void *)next_file);
            }
          } else {
            {
#line 1370
            free((void *)next_file);
            }
          }
        } else {
          {
#line 1370
          free((void *)next_file);
          }
        }
      }
    }
    {
#line 1373
    ent = readdir(dir);
#line 1374
    error = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1377
  closedir(dir);
#line 1379
  tmp___15 = inotifytools_watch_file((char const   *)my_path, events___0);
#line 1379
  ret___11 = tmp___15;
  }
#line 1380
  if ((unsigned long )my_path != (unsigned long )path) {
    {
#line 1380
    free((void *)my_path);
    }
  }
#line 1381
  return (ret___11);
}
}
#line 1387 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
void record_stats(struct inotify_event  const  *event___2 ) 
{ 
  watch *w ;
  watch *tmp ;

  {
#line 1388
  if (! event___2) {
#line 1388
    return;
  }
  {
#line 1389
  tmp = watch_from_wd((int )event___2->wd);
#line 1389
  w = tmp;
  }
#line 1390
  if (! w) {
#line 1390
    return;
  }
#line 1391
  if (1U & event___2->mask) {
#line 1392
    (w->hit_access) ++;
#line 1393
    num_access ++;
  }
#line 1395
  if (2U & event___2->mask) {
#line 1396
    (w->hit_modify) ++;
#line 1397
    num_modify ++;
  }
#line 1399
  if (4U & event___2->mask) {
#line 1400
    (w->hit_attrib) ++;
#line 1401
    num_attrib ++;
  }
#line 1403
  if (8U & event___2->mask) {
#line 1404
    (w->hit_close_write) ++;
#line 1405
    num_close_write ++;
  }
#line 1407
  if (16U & event___2->mask) {
#line 1408
    (w->hit_close_nowrite) ++;
#line 1409
    num_close_nowrite ++;
  }
#line 1411
  if (32U & event___2->mask) {
#line 1412
    (w->hit_open) ++;
#line 1413
    num_open ++;
  }
#line 1415
  if (64U & event___2->mask) {
#line 1416
    (w->hit_moved_from) ++;
#line 1417
    num_moved_from ++;
  }
#line 1419
  if (128U & event___2->mask) {
#line 1420
    (w->hit_moved_to) ++;
#line 1421
    num_moved_to ++;
  }
#line 1423
  if (256U & event___2->mask) {
#line 1424
    (w->hit_create) ++;
#line 1425
    num_create ++;
  }
#line 1427
  if (512U & event___2->mask) {
#line 1428
    (w->hit_delete) ++;
#line 1429
    num_delete ++;
  }
#line 1431
  if (1024U & event___2->mask) {
#line 1432
    (w->hit_delete_self) ++;
#line 1433
    num_delete_self ++;
  }
#line 1435
  if (8192U & event___2->mask) {
#line 1436
    (w->hit_unmount) ++;
#line 1437
    num_unmount ++;
  }
#line 1439
  if (2048U & event___2->mask) {
#line 1440
    (w->hit_move_self) ++;
#line 1441
    num_move_self ++;
  }
#line 1444
  (w->hit_total) ++;
#line 1445
  num_total ++;
#line 1447
  return;
}
}
#line 1449 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int *stat_ptr(watch *w , int event___2 ) 
{ 


  {
#line 1451
  if (1 == event___2) {
#line 1452
    return ((int *)(& w->hit_access));
  }
#line 1453
  if (2 == event___2) {
#line 1454
    return ((int *)(& w->hit_modify));
  }
#line 1455
  if (4 == event___2) {
#line 1456
    return ((int *)(& w->hit_attrib));
  }
#line 1457
  if (8 == event___2) {
#line 1458
    return ((int *)(& w->hit_close_write));
  }
#line 1459
  if (16 == event___2) {
#line 1460
    return ((int *)(& w->hit_close_nowrite));
  }
#line 1461
  if (32 == event___2) {
#line 1462
    return ((int *)(& w->hit_open));
  }
#line 1463
  if (64 == event___2) {
#line 1464
    return ((int *)(& w->hit_moved_from));
  }
#line 1465
  if (128 == event___2) {
#line 1466
    return ((int *)(& w->hit_moved_to));
  }
#line 1467
  if (256 == event___2) {
#line 1468
    return ((int *)(& w->hit_create));
  }
#line 1469
  if (512 == event___2) {
#line 1470
    return ((int *)(& w->hit_delete));
  }
#line 1471
  if (1024 == event___2) {
#line 1472
    return ((int *)(& w->hit_delete_self));
  }
#line 1473
  if (8192 == event___2) {
#line 1474
    return ((int *)(& w->hit_unmount));
  }
#line 1475
  if (2048 == event___2) {
#line 1476
    return ((int *)(& w->hit_move_self));
  }
#line 1477
  if (0 == event___2) {
#line 1478
    return ((int *)(& w->hit_total));
  }
#line 1479
  return ((int *)0);
}
}
#line 1497 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_get_stat_by_wd(int wd___2 , int event___2 ) 
{ 
  watch *w ;
  watch *tmp ;
  int *i___6 ;
  int *tmp___0 ;

  {
#line 1498
  if (! collect_stats) {
#line 1498
    return (-1);
  }
  {
#line 1500
  tmp = watch_from_wd(wd___2);
#line 1500
  w = tmp;
  }
#line 1501
  if (! w) {
#line 1501
    return (-1);
  }
  {
#line 1502
  tmp___0 = stat_ptr(w, event___2);
#line 1502
  i___6 = tmp___0;
  }
#line 1503
  if (! i___6) {
#line 1503
    return (-1);
  }
#line 1504
  return (*i___6);
}
}
#line 1520 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_get_stat_total(int event___2 ) 
{ 


  {
#line 1521
  if (! collect_stats) {
#line 1521
    return (-1);
  }
#line 1522
  if (1 == event___2) {
#line 1523
    return ((int )num_access);
  }
#line 1524
  if (2 == event___2) {
#line 1525
    return ((int )num_modify);
  }
#line 1526
  if (4 == event___2) {
#line 1527
    return ((int )num_attrib);
  }
#line 1528
  if (8 == event___2) {
#line 1529
    return ((int )num_close_write);
  }
#line 1530
  if (16 == event___2) {
#line 1531
    return ((int )num_close_nowrite);
  }
#line 1532
  if (32 == event___2) {
#line 1533
    return ((int )num_open);
  }
#line 1534
  if (64 == event___2) {
#line 1535
    return ((int )num_moved_from);
  }
#line 1536
  if (128 == event___2) {
#line 1537
    return ((int )num_moved_to);
  }
#line 1538
  if (256 == event___2) {
#line 1539
    return ((int )num_create);
  }
#line 1540
  if (512 == event___2) {
#line 1541
    return ((int )num_delete);
  }
#line 1542
  if (1024 == event___2) {
#line 1543
    return ((int )num_delete_self);
  }
#line 1544
  if (8192 == event___2) {
#line 1545
    return ((int )num_unmount);
  }
#line 1546
  if (2048 == event___2) {
#line 1547
    return ((int )num_move_self);
  }
#line 1549
  if (0 == event___2) {
#line 1550
    return ((int )num_total);
  }
#line 1552
  return (-1);
}
}
#line 1574 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_get_stat_by_filename(char const   *filename___2 , int event___2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1576
  tmp = inotifytools_wd_from_filename(filename___2);
#line 1576
  tmp___0 = inotifytools_get_stat_by_wd(tmp, event___2);
  }
#line 1576
  return (tmp___0);
}
}
#line 1590 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_error(void) 
{ 


  {
#line 1591
  return (error);
}
}
#line 1598 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct stat64 my_stat___0  ;
#line 1597 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int isdir(char const   *path ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1600
  tmp___2 = lstat64((char const   */* __restrict  */)path, (struct stat64 */* __restrict  */)(& my_stat___0));
  }
#line 1600
  if (-1 == tmp___2) {
    {
#line 1601
    tmp = __errno_location();
    }
#line 1601
    if (*tmp == 2) {
#line 1601
      return (0);
    }
    {
#line 1602
    tmp___0 = __errno_location();
#line 1602
    tmp___1 = strerror(*tmp___0);
#line 1602
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stat failed on %s: %s\n",
            path, tmp___1);
    }
#line 1603
    return (0);
  }
#line 1606
  if ((my_stat___0.st_mode & 61440U) == 16384U) {
#line 1606
    if (! ((my_stat___0.st_mode & 61440U) == 40960U)) {
#line 1606
      tmp___3 = 1;
    } else {
#line 1606
      tmp___3 = 0;
    }
  } else {
#line 1606
    tmp___3 = 0;
  }
#line 1606
  return (tmp___3);
}
}
#line 1616 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_get_num_watches(void) 
{ 
  int ret___11 ;

  {
  {
#line 1617
  ret___11 = 0;
#line 1618
  rbwalk((struct rbtree  const  *)tree_filename, & get_num, (void *)(& ret___11));
  }
#line 1619
  return (ret___11);
}
}
#line 1662 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_printf(struct inotify_event *event___2 , char *fmt ) 
{ 
  int tmp ;

  {
  {
#line 1663
  tmp = inotifytools_fprintf(stdout, event___2, fmt);
  }
#line 1663
  return (tmp);
}
}
#line 1708 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char out[4097]  ;
#line 1709 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int ret___2  ;
#line 1707 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_fprintf(FILE *file , struct inotify_event *event___2 , char *fmt ) 
{ 


  {
  {
#line 1710
  ret___2 = inotifytools_sprintf(out, event___2, fmt);
  }
#line 1711
  if (-1 != ret___2) {
    {
#line 1711
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%s",
            out);
    }
  }
#line 1712
  return (ret___2);
}
}
#line 1765 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_sprintf(char *out___2 , struct inotify_event *event___2 , char *fmt ) 
{ 
  int tmp ;

  {
  {
#line 1766
  tmp = inotifytools_snprintf(out___2, 4096, event___2, fmt);
  }
#line 1766
  return (tmp);
}
}
#line 1818 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char *filename  ;
#line 1818 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char *eventname  ;
#line 1818 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char *eventstr  ;
#line 1819 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int i___0  ;
#line 1819 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int ind  ;
#line 1820 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char ch1  ;
#line 1821 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char timestr[4096]  ;
#line 1822 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static time_t now  ;
#line 1816 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_snprintf(char *out___2 , int size , struct inotify_event *event___2 ,
                          char *fmt ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  unsigned int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  struct tm *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  size_t tmp___14 ;

  {
#line 1825
  if (event___2->len > 0U) {
#line 1826
    eventname = event___2->name;
  } else {
#line 1829
    eventname = (char *)((void *)0);
  }
  {
#line 1833
  filename = inotifytools_filename_from_wd(event___2->wd);
  }
#line 1835
  if (! fmt) {
#line 1836
    error = 22;
#line 1837
    return (-1);
  } else {
    {
#line 1835
    tmp = strlen((char const   *)fmt);
    }
#line 1835
    if (0UL == tmp) {
#line 1836
      error = 22;
#line 1837
      return (-1);
    }
  }
  {
#line 1839
  tmp___0 = strlen((char const   *)fmt);
  }
#line 1839
  if (tmp___0 > 4096UL) {
#line 1840
    error = 90;
#line 1841
    return (-1);
  } else
#line 1839
  if (size > 4096) {
#line 1840
    error = 90;
#line 1841
    return (-1);
  }
#line 1844
  ind = 0U;
#line 1845
  i___0 = 0U;
  {
#line 1845
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1845
    tmp___14 = strlen((char const   *)fmt);
    }
#line 1845
    if ((size_t )i___0 < tmp___14) {
#line 1845
      if (! ((int )ind < size - 1)) {
#line 1845
        goto while_break;
      }
    } else {
#line 1845
      goto while_break;
    }
#line 1847
    if ((int )*(fmt + i___0) != 37) {
#line 1848
      tmp___1 = ind;
#line 1848
      ind ++;
#line 1848
      *(out___2 + tmp___1) = *(fmt + i___0);
#line 1849
      goto __Cont;
    }
    {
#line 1852
    tmp___2 = strlen((char const   *)fmt);
    }
#line 1852
    if ((size_t )i___0 == tmp___2 - 1UL) {
#line 1854
      error = 22;
#line 1855
      return ((int )ind);
    }
#line 1858
    ch1 = *(fmt + (i___0 + 1U));
#line 1860
    if ((int )ch1 == 37) {
#line 1861
      tmp___3 = ind;
#line 1861
      ind ++;
#line 1861
      *(out___2 + tmp___3) = (char )'%';
#line 1862
      i___0 ++;
#line 1863
      goto __Cont;
    }
#line 1866
    if ((int )ch1 == 119) {
#line 1867
      if (filename) {
        {
#line 1868
        strncpy((char */* __restrict  */)(out___2 + ind), (char const   */* __restrict  */)filename,
                (size_t )((unsigned int )size - ind));
#line 1869
        tmp___4 = strlen((char const   *)filename);
#line 1869
        ind = (unsigned int )((size_t )ind + tmp___4);
        }
      }
#line 1871
      i___0 ++;
#line 1872
      goto __Cont;
    }
#line 1875
    if ((int )ch1 == 102) {
#line 1876
      if (eventname) {
        {
#line 1877
        strncpy((char */* __restrict  */)(out___2 + ind), (char const   */* __restrict  */)eventname,
                (size_t )((unsigned int )size - ind));
#line 1878
        tmp___5 = strlen((char const   *)eventname);
#line 1878
        ind = (unsigned int )((size_t )ind + tmp___5);
        }
      }
#line 1880
      i___0 ++;
#line 1881
      goto __Cont;
    }
#line 1884
    if ((int )ch1 == 101) {
      {
#line 1885
      eventstr = inotifytools_event_to_str((int )event___2->mask);
#line 1886
      strncpy((char */* __restrict  */)(out___2 + ind), (char const   */* __restrict  */)eventstr,
              (size_t )((unsigned int )size - ind));
#line 1887
      tmp___6 = strlen((char const   *)eventstr);
#line 1887
      ind = (unsigned int )((size_t )ind + tmp___6);
#line 1888
      i___0 ++;
      }
#line 1889
      goto __Cont;
    }
#line 1892
    if ((int )ch1 == 84) {
#line 1894
      if (timefmt) {
        {
#line 1896
        now = time((time_t *)0);
#line 1897
        tmp___7 = localtime((time_t const   *)(& now));
#line 1897
        tmp___8 = strftime((char */* __restrict  */)(timestr), (size_t )4095, (char const   */* __restrict  */)timefmt,
                           (struct tm  const  */* __restrict  */)tmp___7);
        }
#line 1897
        if (0UL >= tmp___8) {
#line 1901
          error = 22;
#line 1902
          return ((int )ind);
        }
      } else {
#line 1906
        timestr[0] = (char)0;
      }
      {
#line 1909
      strncpy((char */* __restrict  */)(out___2 + ind), (char const   */* __restrict  */)(timestr),
              (size_t )((unsigned int )size - ind));
#line 1910
      tmp___9 = strlen((char const   *)(timestr));
#line 1910
      ind = (unsigned int )((size_t )ind + tmp___9);
#line 1911
      i___0 ++;
      }
#line 1912
      goto __Cont;
    }
    {
#line 1916
    tmp___11 = strlen((char const   *)fmt);
    }
#line 1916
    if ((size_t )i___0 < tmp___11 - 2UL) {
#line 1916
      if ((int )*(fmt + (i___0 + 2U)) == 101) {
        {
#line 1917
        eventstr = inotifytools_event_to_str_sep((int )event___2->mask, ch1);
#line 1918
        strncpy((char */* __restrict  */)(out___2 + ind), (char const   */* __restrict  */)eventstr,
                (size_t )((unsigned int )size - ind));
#line 1919
        tmp___10 = strlen((char const   *)eventstr);
#line 1919
        ind = (unsigned int )((size_t )ind + tmp___10);
#line 1920
        i___0 += 2U;
        }
#line 1921
        goto __Cont;
      }
    }
#line 1925
    if (ind < 4096U) {
#line 1925
      tmp___12 = ind;
#line 1925
      ind ++;
#line 1925
      *(out___2 + tmp___12) = (char )'%';
    }
#line 1926
    if (ind < 4096U) {
#line 1926
      tmp___13 = ind;
#line 1926
      ind ++;
#line 1926
      *(out___2 + tmp___13) = ch1;
    }
#line 1927
    i___0 ++;
    __Cont: /* CIL Label */ 
#line 1845
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1929
  *(out___2 + ind) = (char)0;
#line 1931
  return ((int )(ind - 1U));
}
}
#line 1943 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
void inotifytools_set_printf_timefmt(char *fmt ) 
{ 


  {
#line 1944
  timefmt = fmt;
#line 1945
  return;
}
}
#line 1955 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_get_max_queued_events(void) 
{ 
  int ret___11 ;
  int tmp ;

  {
  {
#line 1957
  tmp = read_num_from_file((char *)"/proc/sys/fs/inotify/max_queued_watches", & ret___11);
  }
#line 1957
  if (! tmp) {
#line 1957
    return (-1);
  }
#line 1958
  return (ret___11);
}
}
#line 1970 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_get_max_user_instances(void) 
{ 
  int ret___11 ;
  int tmp ;

  {
  {
#line 1972
  tmp = read_num_from_file((char *)"/proc/sys/fs/inotify/max_user_instances", & ret___11);
  }
#line 1972
  if (! tmp) {
#line 1972
    return (-1);
  }
#line 1973
  return (ret___11);
}
}
#line 1985 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_get_max_user_watches(void) 
{ 
  int ret___11 ;
  int tmp ;

  {
  {
#line 1987
  tmp = read_num_from_file((char *)"/proc/sys/fs/inotify/max_user_watches", & ret___11);
  }
#line 1987
  if (! tmp) {
#line 1987
    return (-1);
  }
#line 1988
  return (ret___11);
}
}
#line 2002 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int inotifytools_ignore_events_by_regex(char const   *pattern , int flags ) 
{ 
  void *tmp ;
  int ret___11 ;
  int tmp___0 ;

  {
#line 2003
  if (! pattern) {
#line 2004
    if (regex) {
      {
#line 2005
      regfree(regex);
#line 2006
      free((void *)regex);
#line 2007
      regex = (regex_t *)0;
      }
    }
#line 2009
    return (1);
  }
#line 2012
  if (regex) {
    {
#line 2012
    regfree(regex);
    }
  } else {
    {
#line 2013
    tmp = malloc(sizeof(regex_t ));
#line 2013
    regex = (regex_t *)tmp;
    }
  }
  {
#line 2015
  tmp___0 = regcomp((regex_t */* __restrict  */)regex, (char const   */* __restrict  */)pattern,
                    flags | (((1 << 1) << 1) << 1));
#line 2015
  ret___11 = tmp___0;
  }
#line 2016
  if (0 == ret___11) {
#line 2016
    return (1);
  }
  {
#line 2018
  regfree(regex);
#line 2019
  free((void *)regex);
#line 2020
  regex = (regex_t *)0;
#line 2021
  error = 22;
  }
#line 2022
  return (0);
}
}
#line 2025 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
int event_compare(void const   *p1 , void const   *p2 , void const   *config ) 
{ 
  char asc ;
  int sort_event ;
  int *i1 ;
  int *tmp ;
  int *i2 ;
  int *tmp___0 ;

  {
#line 2027
  if (! p1) {
#line 2027
    return ((int )(p1 - p2));
  } else
#line 2027
  if (! p2) {
#line 2027
    return ((int )(p1 - p2));
  }
#line 2028
  asc = (char)1;
#line 2029
  sort_event = (int )config;
#line 2030
  if (sort_event == -1) {
#line 2031
    sort_event = 0;
#line 2032
    asc = (char)0;
  } else
#line 2033
  if (sort_event < 0) {
#line 2034
    sort_event = - sort_event;
#line 2035
    asc = (char)0;
  }
  {
#line 2037
  tmp = stat_ptr((watch *)p1, sort_event);
#line 2037
  i1 = tmp;
#line 2038
  tmp___0 = stat_ptr((watch *)p2, sort_event);
#line 2038
  i2 = tmp___0;
  }
#line 2039
  if (0 == *i1 - *i2) {
#line 2040
    return (((watch *)p1)->wd - ((watch *)p2)->wd);
  }
#line 2042
  if (asc) {
#line 2043
    return (*i1 - *i2);
  } else {
#line 2045
    return (*i2 - *i1);
  }
}
}
#line 2048 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
struct rbtree *inotifytools_wd_sorted_by_event(int sort_event ) 
{ 
  struct rbtree *ret___11 ;
  struct rbtree *tmp ;
  struct rblists *all ;
  struct rblists *tmp___0 ;
  void const   *p ;
  void const   *tmp___1 ;
  void const   *r ;
  void const   *tmp___2 ;

  {
  {
#line 2050
  tmp = rbinit(& event_compare, (void const   *)((void *)sort_event));
#line 2050
  ret___11 = tmp;
#line 2051
  tmp___0 = rbopenlist((struct rbtree  const  *)tree_wd);
#line 2051
  all = tmp___0;
#line 2052
  tmp___1 = rbreadlist(all);
#line 2052
  p = tmp___1;
  }
  {
#line 2053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2053
    if (! p) {
#line 2053
      goto while_break;
    }
    {
#line 2054
    tmp___2 = rbsearch(p, ret___11);
#line 2054
    r = tmp___2;
#line 2055
    _niceassert((long )((unsigned long )r == (unsigned long )p), 2055, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c",
                "(int)(r == p)", "Couldn\'t insert watch into new tree");
#line 2056
    p = rbreadlist(all);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2058
  rbcloselist(all);
  }
#line 2059
  return (ret___11);
}
}
#line 1 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static char rcsid[53]  = 
#line 1 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'r',      (char )'e',      (char )'d', 
        (char )'b',      (char )'l',      (char )'a',      (char )'c', 
        (char )'k',      (char )'.',      (char )'c',      (char )',', 
        (char )'v',      (char )' ',      (char )'1',      (char )'.', 
        (char )'9',      (char )' ',      (char )'2',      (char )'0', 
        (char )'0',      (char )'3',      (char )'/',      (char )'1', 
        (char )'0',      (char )'/',      (char )'2',      (char )'4', 
        (char )' ',      (char )'0',      (char )'1',      (char )':', 
        (char )'3',      (char )'1',      (char )':',      (char )'2', 
        (char )'1',      (char )' ',      (char )'d',      (char )'a', 
        (char )'m',      (char )'o',      (char )' ',      (char )'E', 
        (char )'x',      (char )'p',      (char )' ',      (char )'$', 
        (char )'\000'};
#line 108 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.h"
void const   *rblookup(int mode , void const   *key , struct rbtree *rbinfo ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
struct rbnode rb_null  =    {& rb_null, & rb_null, & rb_null, (enum nodecolour )0, (void const   *)0};
#line 76 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rbnode *rb_alloc(void) 
{ 
  void *tmp ;

  {
  {
#line 76
  tmp = malloc(sizeof(struct rbnode ));
  }
#line 76
  return ((struct rbnode *)tmp);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_free(struct rbnode *x ) 
{ 


  {
  {
#line 77
  free((void *)x);
  }
#line 77
  return;
}
}
#line 82
static void rb_left_rotate(struct rbnode **rootp , struct rbnode *x ) ;
#line 83
static void rb_right_rotate(struct rbnode **rootp , struct rbnode *y ) ;
#line 84
static struct rbnode *rb_successor(struct rbnode  const  *x ) ;
#line 85
static struct rbnode *rb_predecessor(struct rbnode  const  *x ) ;
#line 86
static struct rbnode *rb_traverse(int insert , void const   *key , struct rbtree *rbinfo ) ;
#line 90
static struct rbnode *rb_lookup(int mode , void const   *key , struct rbtree *rbinfo ) ;
#line 94
static void rb_destroy(struct rbnode *x ) ;
#line 98
static void rb_delete(struct rbnode **rootp , struct rbnode *z ) ;
#line 99
static void rb_delete_fix(struct rbnode **rootp , struct rbnode *x ) ;
#line 103
static void rb_walk(struct rbnode  const  *x , void (*action)(void const   * , VISIT const    ,
                                                              int const    , void * ) ,
                    void *arg , int level ) ;
#line 107
static struct rblists *rb_openlist(struct rbnode  const  *rootp ) ;
#line 108
static void const   *rb_readlist(struct rblists *rblistp ) ;
#line 109
static void rb_closelist(struct rblists *rblistp ) ;
#line 136 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
struct rbtree *rbinit(int (*cmp)(void const   * , void const   * , void const   * ) ,
                      void const   *config ) 
{ 
  struct rbtree *retval ;
  char c ;
  void *tmp ;

  {
  {
#line 145
  c = rcsid[0];
#line 147
  tmp = malloc(sizeof(struct rbtree ));
#line 147
  retval = (struct rbtree *)tmp;
  }
#line 147
  if ((unsigned long )retval == (unsigned long )((void *)0)) {
#line 148
    return ((struct rbtree *)((void *)0));
  }
#line 151
  retval->rb_cmp = cmp;
#line 152
  retval->rb_config = config;
#line 154
  retval->rb_root = & rb_null;
#line 156
  return (retval);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
void rbdestroy(struct rbtree *rbinfo ) 
{ 


  {
#line 163
  if ((unsigned long )rbinfo == (unsigned long )((void *)0)) {
#line 164
    return;
  }
#line 166
  if ((unsigned long )rbinfo->rb_root != (unsigned long )(& rb_null)) {
    {
#line 167
    rb_destroy(rbinfo->rb_root);
    }
  }
  {
#line 169
  free((void *)rbinfo);
  }
#line 170
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
void const   *rbsearch(void const   *key , struct rbtree *rbinfo ) 
{ 
  struct rbnode *x ;
  void *tmp ;

  {
#line 179
  if ((unsigned long )rbinfo == (unsigned long )((void *)0)) {
#line 180
    return ((void const   *)((void *)0));
  }
  {
#line 182
  x = rb_traverse(1, key, rbinfo);
  }
#line 184
  if ((unsigned long )x == (unsigned long )(& rb_null)) {
#line 184
    tmp = (void *)0;
  } else {
#line 184
    tmp = (void *)x->key;
  }
#line 184
  return ((void const   *)tmp);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
void const   *rbfind(void const   *key , struct rbtree *rbinfo ) 
{ 
  struct rbnode *x ;
  void *tmp ;

  {
#line 194
  if ((unsigned long )rbinfo == (unsigned long )((void *)0)) {
#line 195
    return ((void const   *)((void *)0));
  }
#line 198
  if ((unsigned long )rbinfo->rb_root == (unsigned long )(& rb_null)) {
#line 199
    return ((void const   *)((void *)0));
  }
  {
#line 201
  x = rb_traverse(0, key, rbinfo);
  }
#line 203
  if ((unsigned long )x == (unsigned long )(& rb_null)) {
#line 203
    tmp = (void *)0;
  } else {
#line 203
    tmp = (void *)x->key;
  }
#line 203
  return ((void const   *)tmp);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
void const   *rbdelete(void const   *key , struct rbtree *rbinfo ) 
{ 
  struct rbnode *x ;
  void const   *y ;

  {
#line 214
  if ((unsigned long )rbinfo == (unsigned long )((void *)0)) {
#line 215
    return ((void const   *)((void *)0));
  }
  {
#line 217
  x = rb_traverse(0, key, rbinfo);
  }
#line 219
  if ((unsigned long )x == (unsigned long )(& rb_null)) {
#line 221
    return ((void const   *)((void *)0));
  } else {
    {
#line 225
    y = x->key;
#line 226
    rb_delete(& rbinfo->rb_root, x);
    }
#line 228
    return (y);
  }
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
void rbwalk(struct rbtree  const  *rbinfo , void (*action)(void const   * , VISIT const    ,
                                                           int const    , void * ) ,
            void *arg ) 
{ 


  {
#line 237
  if ((unsigned long )rbinfo == (unsigned long )((void *)0)) {
#line 238
    return;
  }
  {
#line 240
  rb_walk((struct rbnode  const  *)rbinfo->rb_root, action, arg, 0);
  }
#line 241
  return;
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
struct rblists *rbopenlist(struct rbtree  const  *rbinfo ) 
{ 
  struct rblists *tmp ;

  {
#line 248
  if ((unsigned long )rbinfo == (unsigned long )((void *)0)) {
#line 249
    return ((struct rblists *)((void *)0));
  }
  {
#line 251
  tmp = rb_openlist((struct rbnode  const  *)rbinfo->rb_root);
  }
#line 251
  return (tmp);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
void const   *rbreadlist(struct rblists *rblistp ) 
{ 
  void const   *tmp ;

  {
#line 257
  if ((unsigned long )rblistp == (unsigned long )((void *)0)) {
#line 258
    return ((void const   *)((void *)0));
  }
  {
#line 260
  tmp = rb_readlist(rblistp);
  }
#line 260
  return (tmp);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
void rbcloselist(struct rblists *rblistp ) 
{ 


  {
#line 266
  if ((unsigned long )rblistp == (unsigned long )((void *)0)) {
#line 267
    return;
  }
  {
#line 269
  rb_closelist(rblistp);
  }
#line 270
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
void const   *rblookup(int mode , void const   *key , struct rbtree *rbinfo ) 
{ 
  struct rbnode *x ;
  void *tmp ;

  {
#line 280
  if ((unsigned long )rbinfo == (unsigned long )((void *)0)) {
#line 281
    return ((void const   *)((void *)0));
  } else
#line 280
  if ((unsigned long )rbinfo->rb_root == (unsigned long )((void *)0)) {
#line 281
    return ((void const   *)((void *)0));
  }
  {
#line 283
  x = rb_lookup(mode, key, rbinfo);
  }
#line 285
  if ((unsigned long )x == (unsigned long )(& rb_null)) {
#line 285
    tmp = (void *)0;
  } else {
#line 285
    tmp = (void *)x->key;
  }
#line 285
  return ((void const   *)tmp);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rbnode *rb_traverse(int insert , void const   *key , struct rbtree *rbinfo ) 
{ 
  struct rbnode *x ;
  struct rbnode *y ;
  struct rbnode *z ;
  int cmp ;
  int found ;

  {
#line 299
  found = 0;
#line 302
  y = & rb_null;
#line 303
  x = rbinfo->rb_root;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if ((unsigned long )x != (unsigned long )(& rb_null)) {
#line 306
      if (! (found == 0)) {
#line 306
        goto while_break;
      }
    } else {
#line 306
      goto while_break;
    }
    {
#line 308
    y = x;
#line 311
    cmp = (*(rbinfo->rb_cmp))(key, x->key, rbinfo->rb_config);
    }
#line 316
    if (cmp < 0) {
#line 317
      x = x->left;
    } else
#line 318
    if (cmp > 0) {
#line 319
      x = x->right;
    } else {
#line 321
      found = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  if (found) {
#line 325
    return (x);
  } else
#line 324
  if (! insert) {
#line 325
    return (x);
  }
  {
#line 327
  z = rb_alloc();
  }
#line 327
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 330
    return (& rb_null);
  }
#line 333
  z->key = key;
#line 334
  z->up = y;
#line 335
  if ((unsigned long )y == (unsigned long )(& rb_null)) {
#line 337
    rbinfo->rb_root = z;
  } else {
    {
#line 342
    cmp = (*(rbinfo->rb_cmp))(z->key, y->key, rbinfo->rb_config);
    }
#line 346
    if (cmp < 0) {
#line 347
      y->left = z;
    } else {
#line 349
      y->right = z;
    }
  }
#line 352
  z->left = & rb_null;
#line 353
  z->right = & rb_null;
#line 356
  z->colour = (enum nodecolour )1;
#line 361
  x = z;
  {
#line 368
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 368
    if ((unsigned long )x != (unsigned long )rbinfo->rb_root) {
#line 368
      if (! ((unsigned int )(x->up)->colour == 1U)) {
#line 368
        goto while_break___0;
      }
    } else {
#line 368
      goto while_break___0;
    }
#line 371
    if ((unsigned long )x->up == (unsigned long )((x->up)->up)->left) {
#line 374
      y = ((x->up)->up)->right;
#line 375
      if ((unsigned int )y->colour == 1U) {
#line 378
        (x->up)->colour = (enum nodecolour )0;
#line 380
        y->colour = (enum nodecolour )0;
#line 382
        ((x->up)->up)->colour = (enum nodecolour )1;
#line 385
        x = (x->up)->up;
      } else {
#line 390
        if ((unsigned long )x == (unsigned long )(x->up)->right) {
          {
#line 393
          x = x->up;
#line 394
          rb_left_rotate(& rbinfo->rb_root, x);
          }
        }
        {
#line 398
        (x->up)->colour = (enum nodecolour )0;
#line 400
        ((x->up)->up)->colour = (enum nodecolour )1;
#line 402
        rb_right_rotate(& rbinfo->rb_root, (x->up)->up);
        }
      }
    } else {
#line 411
      y = ((x->up)->up)->left;
#line 412
      if ((unsigned int )y->colour == 1U) {
#line 414
        (x->up)->colour = (enum nodecolour )0;
#line 415
        y->colour = (enum nodecolour )0;
#line 416
        ((x->up)->up)->colour = (enum nodecolour )1;
#line 418
        x = (x->up)->up;
      } else {
#line 422
        if ((unsigned long )x == (unsigned long )(x->up)->left) {
          {
#line 424
          x = x->up;
#line 425
          rb_right_rotate(& rbinfo->rb_root, x);
          }
        }
        {
#line 428
        (x->up)->colour = (enum nodecolour )0;
#line 429
        ((x->up)->up)->colour = (enum nodecolour )1;
#line 430
        rb_left_rotate(& rbinfo->rb_root, (x->up)->up);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 436
  (rbinfo->rb_root)->colour = (enum nodecolour )0;
#line 438
  return (z);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rbnode *rb_lookup(int mode , void const   *key , struct rbtree *rbinfo ) 
{ 
  struct rbnode *x ;
  struct rbnode *y ;
  int cmp ;
  int found ;
  struct rbnode *tmp ;
  struct rbnode *tmp___0 ;
  struct rbnode *tmp___1 ;
  struct rbnode *tmp___2 ;

  {
#line 449
  found = 0;
#line 451
  y = & rb_null;
#line 452
  x = rbinfo->rb_root;
#line 454
  if (mode == 7) {
    {
#line 457
    while (1) {
      while_continue: /* CIL Label */ ;
#line 457
      if (! ((unsigned long )x != (unsigned long )(& rb_null))) {
#line 457
        goto while_break;
      }
#line 459
      y = x;
#line 460
      x = x->left;
    }
    while_break: /* CIL Label */ ;
    }
#line 463
    return (y);
  } else
#line 465
  if (mode == 8) {
    {
#line 468
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 468
      if (! ((unsigned long )x != (unsigned long )(& rb_null))) {
#line 468
        goto while_break___0;
      }
#line 470
      y = x;
#line 471
      x = x->right;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 474
    return (y);
  }
  {
#line 478
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 478
    if ((unsigned long )x != (unsigned long )(& rb_null)) {
#line 478
      if (! (found == 0)) {
#line 478
        goto while_break___1;
      }
    } else {
#line 478
      goto while_break___1;
    }
    {
#line 480
    y = x;
#line 483
    cmp = (*(rbinfo->rb_cmp))(key, x->key, rbinfo->rb_config);
    }
#line 489
    if (cmp < 0) {
#line 490
      x = x->left;
    } else
#line 491
    if (cmp > 0) {
#line 492
      x = x->right;
    } else {
#line 494
      found = 1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 497
  if (found) {
#line 497
    if (mode == 0) {
#line 498
      return (x);
    } else
#line 497
    if (mode == 1) {
#line 498
      return (x);
    } else
#line 497
    if (mode == 2) {
#line 498
      return (x);
    }
  }
#line 500
  if (! found) {
#line 500
    if (mode == 0) {
#line 501
      return (& rb_null);
    } else
#line 500
    if (mode == 5) {
#line 501
      return (& rb_null);
    } else
#line 500
    if (mode == 6) {
#line 501
      return (& rb_null);
    }
  }
#line 503
  if (mode == 1) {
#line 503
    goto _L;
  } else
#line 503
  if (! found) {
#line 503
    if (mode == 4) {
      _L: /* CIL Label */ 
#line 505
      if (cmp > 0) {
        {
#line 506
        tmp = rb_successor((struct rbnode  const  *)y);
        }
#line 506
        return (tmp);
      } else {
#line 508
        return (y);
      }
    }
  }
#line 511
  if (mode == 2) {
#line 511
    goto _L___0;
  } else
#line 511
  if (! found) {
#line 511
    if (mode == 3) {
      _L___0: /* CIL Label */ 
#line 513
      if (cmp < 0) {
        {
#line 514
        tmp___0 = rb_predecessor((struct rbnode  const  *)y);
        }
#line 514
        return (tmp___0);
      } else {
#line 516
        return (y);
      }
    }
  }
#line 519
  if (mode == 5) {
    {
#line 520
    tmp___1 = rb_successor((struct rbnode  const  *)x);
    }
#line 520
    return (tmp___1);
  } else
#line 519
  if (found) {
#line 519
    if (mode == 4) {
      {
#line 520
      tmp___1 = rb_successor((struct rbnode  const  *)x);
      }
#line 520
      return (tmp___1);
    }
  }
#line 522
  if (mode == 6) {
    {
#line 523
    tmp___2 = rb_predecessor((struct rbnode  const  *)x);
    }
#line 523
    return (tmp___2);
  } else
#line 522
  if (found) {
#line 522
    if (mode == 3) {
      {
#line 523
      tmp___2 = rb_predecessor((struct rbnode  const  *)x);
      }
#line 523
      return (tmp___2);
    }
  }
#line 526
  return (& rb_null);
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_destroy(struct rbnode *x ) 
{ 


  {
#line 538
  if ((unsigned long )x != (unsigned long )(& rb_null)) {
#line 540
    if ((unsigned long )x->left != (unsigned long )(& rb_null)) {
      {
#line 541
      rb_destroy(x->left);
      }
    }
#line 542
    if ((unsigned long )x->right != (unsigned long )(& rb_null)) {
      {
#line 543
      rb_destroy(x->right);
      }
    }
    {
#line 544
    rb_free(x);
    }
  }
#line 546
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_left_rotate(struct rbnode **rootp , struct rbnode *x ) 
{ 
  struct rbnode *y ;

  {
#line 571
  y = x->right;
#line 574
  x->right = y->left;
#line 577
  if ((unsigned long )y->left != (unsigned long )(& rb_null)) {
#line 578
    (y->left)->up = x;
  }
#line 581
  y->up = x->up;
#line 584
  if ((unsigned long )x->up == (unsigned long )(& rb_null)) {
#line 586
    *rootp = y;
  } else
#line 591
  if ((unsigned long )x == (unsigned long )(x->up)->left) {
#line 593
    (x->up)->left = y;
  } else {
#line 597
    (x->up)->right = y;
  }
#line 602
  y->left = x;
#line 605
  x->up = y;
#line 606
  return;
}
}
#line 608 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_right_rotate(struct rbnode **rootp , struct rbnode *y ) 
{ 
  struct rbnode *x ;

  {
#line 616
  x = y->left;
#line 619
  y->left = x->right;
#line 622
  if ((unsigned long )x->right != (unsigned long )(& rb_null)) {
#line 623
    (x->right)->up = y;
  }
#line 626
  x->up = y->up;
#line 629
  if ((unsigned long )y->up == (unsigned long )(& rb_null)) {
#line 631
    *rootp = x;
  } else
#line 636
  if ((unsigned long )y == (unsigned long )(y->up)->left) {
#line 638
    (y->up)->left = x;
  } else {
#line 642
    (y->up)->right = x;
  }
#line 647
  x->right = y;
#line 650
  y->up = x;
#line 651
  return;
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rbnode *rb_successor(struct rbnode  const  *x ) 
{ 
  struct rbnode *y ;

  {
#line 660
  if ((unsigned long )x->right != (unsigned long )(& rb_null)) {
#line 666
    y = (struct rbnode *)x->right;
    {
#line 666
    while (1) {
      while_continue: /* CIL Label */ ;
#line 666
      if (! ((unsigned long )y->left != (unsigned long )(& rb_null))) {
#line 666
        goto while_break;
      }
#line 666
      y = y->left;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 674
    y = (struct rbnode *)x->up;
    {
#line 675
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 675
      if ((unsigned long )y != (unsigned long )(& rb_null)) {
#line 675
        if (! ((unsigned long )x == (unsigned long )y->right)) {
#line 675
          goto while_break___0;
        }
      } else {
#line 675
        goto while_break___0;
      }
#line 677
      x = (struct rbnode  const  *)y;
#line 678
      y = y->up;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 681
  return (y);
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rbnode *rb_predecessor(struct rbnode  const  *x ) 
{ 
  struct rbnode *y ;

  {
#line 691
  if ((unsigned long )x->left != (unsigned long )(& rb_null)) {
#line 697
    y = (struct rbnode *)x->left;
    {
#line 697
    while (1) {
      while_continue: /* CIL Label */ ;
#line 697
      if (! ((unsigned long )y->right != (unsigned long )(& rb_null))) {
#line 697
        goto while_break;
      }
#line 697
      y = y->right;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 705
    y = (struct rbnode *)x->up;
    {
#line 706
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 706
      if ((unsigned long )y != (unsigned long )(& rb_null)) {
#line 706
        if (! ((unsigned long )x == (unsigned long )y->left)) {
#line 706
          goto while_break___0;
        }
      } else {
#line 706
        goto while_break___0;
      }
#line 708
      x = (struct rbnode  const  *)y;
#line 709
      y = y->up;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 712
  return (y);
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_delete(struct rbnode **rootp , struct rbnode *z ) 
{ 
  struct rbnode *x ;
  struct rbnode *y ;

  {
#line 723
  if ((unsigned long )z->left == (unsigned long )(& rb_null)) {
#line 724
    y = z;
  } else
#line 723
  if ((unsigned long )z->right == (unsigned long )(& rb_null)) {
#line 724
    y = z;
  } else {
    {
#line 726
    y = rb_successor((struct rbnode  const  *)z);
    }
  }
#line 728
  if ((unsigned long )y->left != (unsigned long )(& rb_null)) {
#line 729
    x = y->left;
  } else {
#line 731
    x = y->right;
  }
#line 733
  x->up = y->up;
#line 735
  if ((unsigned long )y->up == (unsigned long )(& rb_null)) {
#line 737
    *rootp = x;
  } else
#line 741
  if ((unsigned long )y == (unsigned long )(y->up)->left) {
#line 742
    (y->up)->left = x;
  } else {
#line 744
    (y->up)->right = x;
  }
#line 747
  if ((unsigned long )y != (unsigned long )z) {
#line 749
    z->key = y->key;
  }
#line 752
  if ((unsigned int )y->colour == 0U) {
    {
#line 753
    rb_delete_fix(rootp, x);
    }
  }
  {
#line 755
  rb_free(y);
  }
#line 756
  return;
}
}
#line 759 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_delete_fix(struct rbnode **rootp , struct rbnode *x ) 
{ 
  struct rbnode *w ;

  {
  {
#line 764
  while (1) {
    while_continue: /* CIL Label */ ;
#line 764
    if ((unsigned long )x != (unsigned long )*rootp) {
#line 764
      if (! ((unsigned int )x->colour == 0U)) {
#line 764
        goto while_break;
      }
    } else {
#line 764
      goto while_break;
    }
#line 766
    if ((unsigned long )x == (unsigned long )(x->up)->left) {
#line 768
      w = (x->up)->right;
#line 769
      if ((unsigned int )w->colour == 1U) {
        {
#line 771
        w->colour = (enum nodecolour )0;
#line 772
        (x->up)->colour = (enum nodecolour )1;
#line 773
        rb_left_rotate(rootp, x->up);
#line 774
        w = (x->up)->right;
        }
      }
#line 777
      if ((unsigned int )(w->left)->colour == 0U) {
#line 777
        if ((unsigned int )(w->right)->colour == 0U) {
#line 779
          w->colour = (enum nodecolour )1;
#line 780
          x = x->up;
        } else {
#line 777
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 784
        if ((unsigned int )(w->right)->colour == 0U) {
          {
#line 786
          (w->left)->colour = (enum nodecolour )0;
#line 787
          w->colour = (enum nodecolour )1;
#line 788
          rb_right_rotate(rootp, w);
#line 789
          w = (x->up)->right;
          }
        }
        {
#line 793
        w->colour = (x->up)->colour;
#line 794
        (x->up)->colour = (enum nodecolour )0;
#line 795
        (w->right)->colour = (enum nodecolour )0;
#line 796
        rb_left_rotate(rootp, x->up);
#line 797
        x = *rootp;
        }
      }
    } else {
#line 802
      w = (x->up)->left;
#line 803
      if ((unsigned int )w->colour == 1U) {
        {
#line 805
        w->colour = (enum nodecolour )0;
#line 806
        (x->up)->colour = (enum nodecolour )1;
#line 807
        rb_right_rotate(rootp, x->up);
#line 808
        w = (x->up)->left;
        }
      }
#line 811
      if ((unsigned int )(w->right)->colour == 0U) {
#line 811
        if ((unsigned int )(w->left)->colour == 0U) {
#line 813
          w->colour = (enum nodecolour )1;
#line 814
          x = x->up;
        } else {
#line 811
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 818
        if ((unsigned int )(w->left)->colour == 0U) {
          {
#line 820
          (w->right)->colour = (enum nodecolour )0;
#line 821
          w->colour = (enum nodecolour )1;
#line 822
          rb_left_rotate(rootp, w);
#line 823
          w = (x->up)->left;
          }
        }
        {
#line 826
        w->colour = (x->up)->colour;
#line 827
        (x->up)->colour = (enum nodecolour )0;
#line 828
        (w->left)->colour = (enum nodecolour )0;
#line 829
        rb_right_rotate(rootp, x->up);
#line 830
        x = *rootp;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 835
  x->colour = (enum nodecolour )0;
#line 836
  return;
}
}
#line 840 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_walk(struct rbnode  const  *x , void (*action)(void const   * , VISIT const    ,
                                                              int const    , void * ) ,
                    void *arg , int level ) 
{ 


  {
#line 843
  if ((unsigned long )x == (unsigned long )(& rb_null)) {
#line 844
    return;
  }
#line 846
  if ((unsigned long )x->left == (unsigned long )(& rb_null)) {
#line 846
    if ((unsigned long )x->right == (unsigned long )(& rb_null)) {
      {
#line 849
      (*action)((void const   *)x->key, (VISIT const   )3, (int const   )level, arg);
      }
    } else {
      {
#line 853
      (*action)((void const   *)x->key, (VISIT const   )0, (int const   )level, arg);
#line 855
      rb_walk((struct rbnode  const  *)x->left, action, arg, level + 1);
#line 857
      (*action)((void const   *)x->key, (VISIT const   )1, (int const   )level, arg);
#line 859
      rb_walk((struct rbnode  const  *)x->right, action, arg, level + 1);
#line 861
      (*action)((void const   *)x->key, (VISIT const   )2, (int const   )level, arg);
      }
    }
  } else {
    {
#line 853
    (*action)((void const   *)x->key, (VISIT const   )0, (int const   )level, arg);
#line 855
    rb_walk((struct rbnode  const  *)x->left, action, arg, level + 1);
#line 857
    (*action)((void const   *)x->key, (VISIT const   )1, (int const   )level, arg);
#line 859
    rb_walk((struct rbnode  const  *)x->right, action, arg, level + 1);
#line 861
    (*action)((void const   *)x->key, (VISIT const   )2, (int const   )level, arg);
    }
  }
#line 863
  return;
}
}
#line 867 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rblists *rb_openlist(struct rbnode  const  *rootp ) 
{ 
  struct rblists *rblistp ;
  void *tmp ;

  {
  {
#line 872
  tmp = malloc(sizeof(struct rblists ));
#line 872
  rblistp = (struct rblists *)tmp;
  }
#line 873
  if (! rblistp) {
#line 874
    return ((struct rblists *)((void *)0));
  }
#line 876
  rblistp->rootp = rootp;
#line 877
  rblistp->nextp = rootp;
#line 879
  if ((unsigned long )rootp != (unsigned long )(& rb_null)) {
    {
#line 881
    while (1) {
      while_continue: /* CIL Label */ ;
#line 881
      if (! ((unsigned long )(rblistp->nextp)->left != (unsigned long )(& rb_null))) {
#line 881
        goto while_break;
      }
#line 883
      rblistp->nextp = (struct rbnode  const  *)(rblistp->nextp)->left;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 887
  return (rblistp);
}
}
#line 890 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void const   *rb_readlist(struct rblists *rblistp ) 
{ 
  void const   *key ;
  struct rbnode *tmp ;

  {
#line 893
  key = (void const   *)((void *)0);
#line 895
  if ((unsigned long )rblistp != (unsigned long )((void *)0)) {
#line 895
    if ((unsigned long )rblistp->nextp != (unsigned long )(& rb_null)) {
      {
#line 897
      key = (void const   *)(rblistp->nextp)->key;
#line 898
      tmp = rb_successor(rblistp->nextp);
#line 898
      rblistp->nextp = (struct rbnode  const  *)tmp;
      }
    }
  }
#line 901
  return (key);
}
}
#line 904 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_closelist(struct rblists *rblistp ) 
{ 


  {
#line 907
  if (rblistp) {
    {
#line 908
    free((void *)rblistp);
    }
  }
#line 909
  return;
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/common.h"
void print_event_descriptions(void) ;
#line 17
FileList construct_path_list(int argc , char **argv , char const   *filename___2 ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/common.c"
void print_event_descriptions(void) 
{ 


  {
  {
#line 24
  printf((char const   */* __restrict  */)"\taccess\t\tfile or directory contents were read\n");
#line 25
  printf((char const   */* __restrict  */)"\tmodify\t\tfile or directory contents were written\n");
#line 26
  printf((char const   */* __restrict  */)"\tattrib\t\tfile or directory attributes changed\n");
#line 27
  printf((char const   */* __restrict  */)"\tclose_write\tfile or directory closed, after being opened in\n\t           \twritable mode\n");
#line 29
  printf((char const   */* __restrict  */)"\tclose_nowrite\tfile or directory closed, after being opened in\n\t           \tread-only mode\n");
#line 31
  printf((char const   */* __restrict  */)"\tclose\t\tfile or directory closed, regardless of read/write mode\n");
#line 33
  printf((char const   */* __restrict  */)"\topen\t\tfile or directory opened\n");
#line 34
  printf((char const   */* __restrict  */)"\tmoved_to\tfile or directory moved to watched directory\n");
#line 35
  printf((char const   */* __restrict  */)"\tmoved_from\tfile or directory moved from watched directory\n");
#line 36
  printf((char const   */* __restrict  */)"\tmove\t\tfile or directory moved to or from watched directory\n");
#line 37
  printf((char const   */* __restrict  */)"\tcreate\t\tfile or directory created within watched directory\n");
#line 38
  printf((char const   */* __restrict  */)"\tdelete\t\tfile or directory deleted within watched directory\n");
#line 39
  printf((char const   */* __restrict  */)"\tdelete_self\tfile or directory was deleted\n");
#line 40
  printf((char const   */* __restrict  */)"\tunmount\t\tfile system containing file or directory unmounted\n");
  }
#line 41
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/common.c"
static struct stat64 my_stat___1  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/common.c"
FileList construct_path_list(int argc , char **argv , char const   *filename___2 ) 
{ 
  FileList list ;
  FILE *file ;
  int tmp ;
  int watch_len ;
  int exclude_len ;
  int watch_count ;
  int exclude_count ;
  void *tmp___0 ;
  void *tmp___1 ;
  char name[4096] ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int i___6 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;
  int tmp___18 ;

  {
#line 57
  list.watch_files = (char const   **)0;
#line 58
  list.exclude_files = (char const   **)0;
#line 59
  file = (FILE *)0;
#line 61
  if (! (! filename___2)) {
    {
#line 63
    tmp = strcmp(filename___2, "-");
    }
#line 63
    if (tmp) {
      {
#line 67
      file = fopen((char const   */* __restrict  */)filename___2, (char const   */* __restrict  */)"r");
      }
    } else {
#line 64
      file = stdin;
    }
  }
  {
#line 70
  watch_len = 1024;
#line 71
  exclude_len = 1024;
#line 72
  watch_count = 0;
#line 73
  exclude_count = 0;
#line 74
  tmp___0 = malloc(sizeof(char *) * (unsigned long )watch_len);
#line 74
  list.watch_files = (char const   **)tmp___0;
#line 75
  tmp___1 = malloc(sizeof(char *) * (unsigned long )exclude_len);
#line 75
  list.exclude_files = (char const   **)tmp___1;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (file) {
      {
#line 78
      tmp___12 = fgets((char */* __restrict  */)(name), 4096, (FILE */* __restrict  */)file);
      }
#line 78
      if (! tmp___12) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
    {
#line 79
    tmp___3 = strlen((char const   *)(name));
    }
#line 79
    if ((int )name[tmp___3 - 1UL] == 10) {
      {
#line 79
      tmp___2 = strlen((char const   *)(name));
#line 79
      name[tmp___2 - 1UL] = (char)0;
      }
    }
    {
#line 80
    tmp___4 = strlen((char const   *)(name));
    }
#line 80
    if (tmp___4 == 0UL) {
#line 80
      goto while_continue;
    }
#line 81
    if (64 == (int )name[0]) {
      {
#line 81
      tmp___5 = strlen((char const   *)(name));
      }
#line 81
      if (tmp___5 == 1UL) {
#line 81
        goto while_continue;
      }
    }
#line 82
    if (64 == (int )name[0]) {
#line 83
      if (exclude_count >= exclude_len - 1) {
        {
#line 83
        exclude_len += 1024;
#line 83
        tmp___6 = realloc((void *)list.exclude_files, sizeof(char *) * (unsigned long )exclude_len);
#line 83
        list.exclude_files = (char const   **)tmp___6;
        }
      }
      {
#line 84
      tmp___7 = exclude_count;
#line 84
      exclude_count ++;
#line 84
      tmp___8 = strdup((char const   *)(& name[1]));
#line 84
      *(list.exclude_files + tmp___7) = (char const   *)tmp___8;
      }
    } else {
#line 87
      if (watch_count >= watch_len - 1) {
        {
#line 87
        watch_len += 1024;
#line 87
        tmp___9 = realloc((void *)list.watch_files, sizeof(char *) * (unsigned long )watch_len);
#line 87
        list.watch_files = (char const   **)tmp___9;
        }
      }
      {
#line 88
      tmp___10 = watch_count;
#line 88
      watch_count ++;
#line 88
      tmp___11 = strdup((char const   *)(name));
#line 88
      *(list.watch_files + tmp___10) = (char const   *)tmp___11;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  if (file) {
#line 91
    if ((unsigned long )file != (unsigned long )stdin) {
      {
#line 91
      fclose(file);
      }
    }
  }
#line 93
  i___6 = 0;
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    if (! (i___6 < argc)) {
#line 93
      goto while_break___0;
    }
    {
#line 94
    tmp___13 = strlen((char const   *)*(argv + i___6));
    }
#line 94
    if (tmp___13 == 0UL) {
#line 94
      goto __Cont;
    }
#line 95
    if (64 == (int )*(*(argv + i___6) + 0)) {
      {
#line 95
      tmp___14 = strlen((char const   *)*(argv + i___6));
      }
#line 95
      if (tmp___14 == 1UL) {
#line 95
        goto __Cont;
      }
    }
#line 96
    if (64 == (int )*(*(argv + i___6) + 0)) {
#line 97
      if (exclude_count >= exclude_len - 1) {
        {
#line 97
        exclude_len += 1024;
#line 97
        tmp___15 = realloc((void *)list.exclude_files, sizeof(char *) * (unsigned long )exclude_len);
#line 97
        list.exclude_files = (char const   **)tmp___15;
        }
      }
#line 98
      tmp___16 = exclude_count;
#line 98
      exclude_count ++;
#line 98
      *(list.exclude_files + tmp___16) = (char const   *)(*(argv + i___6) + 1);
    } else {
#line 101
      if (watch_count >= watch_len - 1) {
        {
#line 101
        watch_len += 1024;
#line 101
        tmp___17 = realloc((void *)list.watch_files, sizeof(char *) * (unsigned long )watch_len);
#line 101
        list.watch_files = (char const   **)tmp___17;
        }
      }
#line 102
      tmp___18 = watch_count;
#line 102
      watch_count ++;
#line 102
      *(list.watch_files + tmp___18) = (char const   *)*(argv + i___6);
    }
    __Cont: /* CIL Label */ 
#line 93
    i___6 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 105
  *(list.exclude_files + exclude_count) = (char const   *)0;
#line 106
  *(list.watch_files + watch_count) = (char const   *)0;
#line 107
  return (list);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int inotify_fd___0  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_access___0  ;
#line 131 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_modify___0  ;
#line 132 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_attrib___0  ;
#line 133 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_close_nowrite___0  ;
#line 134 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_close_write___0  ;
#line 135 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_open___0  ;
#line 136 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_move_self___0  ;
#line 137 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_moved_to___0  ;
#line 138 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_moved_from___0  ;
#line 139 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_create___0  ;
#line 140 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_delete___0  ;
#line 141 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_delete_self___0  ;
#line 142 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_unmount___0  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_total___0  ;
#line 144 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int collect_stats___0  =    0;
#line 148 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int error___0  =    0;
#line 149 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int init___0  =    0;
#line 150 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char *timefmt___0  =    (char *)0;
#line 151 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static regex_t *regex___0  =    (regex_t *)0;
#line 219 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char str___0[2]  = {      (char )'\000',      (char )'\000'};
#line 558 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int ret___3  ;
#line 658 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char ret___4[1024]  ;
#line 956 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char const   *filenames___0[2]  ;
#line 981 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int i___1  ;
#line 983 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int wd___0  ;
#line 1100 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct inotify_event event___0[4096]  ;
#line 1101 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct inotify_event *ret___5  ;
#line 1102 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int first_byte___0  =    0;
#line 1103 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static ssize_t bytes___0  ;
#line 1104 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static jmp_buf jmp___0  ;
#line 1105 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char match_name___0[4096]  ;
#line 1161 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static ssize_t this_bytes___0  ;
#line 1162 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int bytes_to_read___0  ;
#line 1163 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int rc___0  ;
#line 1164 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static fd_set read_fds___0  ;
#line 1166 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct timeval read_timeout___0  ;
#line 1169 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct timeval *read_timeout_ptr___0  ;
#line 1310 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct dirent *ent___0  ;
#line 1312 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct stat64 my_stat___2  ;
#line 1333 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int no_watch___0  ;
#line 1334 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char const   **exclude_entry___0  ;
#line 1340 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int exclude_length___0  ;
#line 1353 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int status___0  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct stat64 my_stat___3  ;
#line 1708 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char out___0[4097]  ;
#line 1709 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int ret___6  ;
#line 1818 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char *filename___0  ;
#line 1818 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char *eventname___0  ;
#line 1818 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char *eventstr___0  ;
#line 1819 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int i___2  ;
#line 1819 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int ind___0  ;
#line 1820 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char ch1___0  ;
#line 1821 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char timestr___0[4096]  ;
#line 1822 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static time_t now___0  ;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 200
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c"
_Bool parse_opts(int *argc , char ***argv , int *events___0 , _Bool *monitor , int *quiet ,
                 unsigned long *timeout , int *recursive , _Bool *csv___0 , _Bool *daemon___0 ,
                 _Bool *syslog___0 , char **format , char **timefmt___2 , char **fromfile ,
                 char **outfile , char **regex___2 , char **iregex ) ;
#line 54
void print_help(void) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c"
static char csv[4097]  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c"
static unsigned int i___3  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c"
static unsigned int ind___1  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c"
char *csv_escape(char *string ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  size_t tmp___7 ;
  unsigned int tmp___8 ;

  {
  {
#line 61
  tmp = strlen((char const   *)string);
  }
#line 61
  if (tmp > 4096UL) {
#line 62
    return ((char *)((void *)0));
  }
  {
#line 65
  tmp___0 = strlen((char const   *)string);
  }
#line 65
  if (tmp___0 == 0UL) {
#line 66
    return ((char *)((void *)0));
  }
  {
#line 70
  tmp___1 = strchr((char const   *)string, '\"');
  }
#line 70
  if (! tmp___1) {
    {
#line 70
    tmp___2 = strchr((char const   *)string, ',');
    }
#line 70
    if (! tmp___2) {
      {
#line 70
      tmp___3 = strchr((char const   *)string, '\n');
      }
#line 70
      if (! tmp___3) {
#line 70
        if ((int )*(string + 0) != 32) {
          {
#line 70
          tmp___4 = strlen((char const   *)string);
          }
#line 70
          if ((int )*(string + (tmp___4 - 1UL)) != 32) {
            {
#line 72
            strcpy((char */* __restrict  */)(csv), (char const   */* __restrict  */)string);
            }
#line 73
            return (csv);
          }
        }
      }
    }
  }
#line 77
  csv[0] = (char )'\"';
#line 78
  ind___1 = 1U;
#line 79
  i___3 = 0U;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___7 = strlen((char const   *)string);
    }
#line 79
    if (! ((size_t )i___3 < tmp___7)) {
#line 79
      goto while_break;
    }
#line 80
    if ((int )*(string + i___3) == 34) {
#line 81
      tmp___5 = ind___1;
#line 81
      ind___1 ++;
#line 81
      csv[tmp___5] = (char )'\"';
    }
#line 83
    tmp___6 = ind___1;
#line 83
    ind___1 ++;
#line 83
    csv[tmp___6] = *(string + i___3);
#line 79
    i___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  tmp___8 = ind___1;
#line 85
  ind___1 ++;
#line 85
  csv[tmp___8] = (char )'\"';
#line 86
  csv[ind___1] = (char )'\000';
#line 88
  return (csv);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c"
void validate_format(char *fmt ) 
{ 
  struct inotify_event *event___2 ;
  void *tmp ;
  FILE *devnull ;
  FILE *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 94
  tmp = malloc(sizeof(struct inotify_event ) + 4UL);
#line 94
  event___2 = (struct inotify_event *)tmp;
  }
#line 96
  if (! event___2) {
    {
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seem to be out of memory... yikes!\n");
#line 98
    exit(1);
    }
  }
  {
#line 100
  event___2->wd = 0;
#line 101
  event___2->mask = (uint32_t )4095;
#line 102
  event___2->len = (uint32_t )3;
#line 103
  strcpy((char */* __restrict  */)(event___2->name), (char const   */* __restrict  */)"foo");
#line 104
  tmp___0 = fopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"a");
#line 104
  devnull = tmp___0;
  }
#line 105
  if (! devnull) {
    {
#line 106
    tmp___1 = __errno_location();
#line 106
    tmp___2 = strerror(*tmp___1);
#line 106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t open /dev/null: %s\n",
            tmp___2);
#line 107
    free((void *)event___2);
    }
#line 108
    return;
  }
  {
#line 110
  tmp___3 = inotifytools_fprintf(devnull, event___2, fmt);
  }
#line 110
  if (-1 == tmp___3) {
    {
#line 111
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Something is wrong with your format string.\n");
#line 112
    exit(1);
    }
  }
  {
#line 114
  free((void *)event___2);
#line 115
  fclose(devnull);
  }
#line 116
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c"
void output_event_csv(struct inotify_event *event___2 ) 
{ 
  char *filename___2 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 120
  tmp = inotifytools_filename_from_wd(event___2->wd);
#line 120
  tmp___0 = csv_escape(tmp);
#line 120
  filename___2 = tmp___0;
  }
#line 121
  if ((unsigned long )filename___2 != (unsigned long )((void *)0)) {
    {
#line 122
    tmp___1 = csv_escape(filename___2);
#line 122
    printf((char const   */* __restrict  */)"%s,", tmp___1);
    }
  }
  {
#line 124
  tmp___2 = inotifytools_event_to_str((int )event___2->mask);
#line 124
  tmp___3 = csv_escape(tmp___2);
#line 124
  printf((char const   */* __restrict  */)"%s,", tmp___3);
  }
#line 125
  if (event___2->len > 0U) {
    {
#line 126
    tmp___4 = csv_escape(event___2->name);
#line 126
    printf((char const   */* __restrict  */)"%s", tmp___4);
    }
  }
  {
#line 127
  printf((char const   */* __restrict  */)"\n");
  }
#line 128
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c"
void output_error(_Bool syslog___0 , char *fmt  , ...) 
{ 
  va_list va ;

  {
  {
#line 133
  __builtin_va_start(va, fmt);
  }
#line 134
  if (syslog___0) {
    {
#line 135
    vsyslog(6, (char const   *)fmt, va);
    }
  } else {
    {
#line 137
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             va);
    }
  }
  {
#line 139
  __builtin_va_end(va);
  }
#line 140
  return;
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c"
static char *new_file  ;
#line 385 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c"
static char *new_name  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c"
int main(int argc , char **argv ) 
{ 
  int events___0 ;
  int orig_events ;
  _Bool monitor ;
  int quiet ;
  unsigned long timeout ;
  int recursive ;
  _Bool csv___0 ;
  _Bool daemon___0 ;
  _Bool syslog___0 ;
  char *format ;
  char *timefmt___2 ;
  char *fromfile ;
  char *outfile ;
  char *regex___2 ;
  char *iregex ;
  pid_t pid ;
  int fd ;
  _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  FileList list ;
  FileList tmp___3 ;
  __pid_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int i___6 ;
  char const   *this_file ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  struct inotify_event *event___2 ;
  char *moved_from ;
  int tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;

  {
  {
#line 145
  events___0 = 0;
#line 147
  monitor = (_Bool)0;
#line 148
  quiet = 0;
#line 149
  timeout = 0UL;
#line 150
  recursive = 0;
#line 151
  csv___0 = (_Bool)0;
#line 152
  daemon___0 = (_Bool)0;
#line 153
  syslog___0 = (_Bool)0;
#line 154
  format = (char *)((void *)0);
#line 155
  timefmt___2 = (char *)((void *)0);
#line 156
  fromfile = (char *)((void *)0);
#line 157
  outfile = (char *)((void *)0);
#line 158
  regex___2 = (char *)((void *)0);
#line 159
  iregex = (char *)((void *)0);
#line 164
  tmp = parse_opts(& argc, & argv, & events___0, & monitor, & quiet, & timeout, & recursive,
                   & csv___0, & daemon___0, & syslog___0, & format, & timefmt___2,
                   & fromfile, & outfile, & regex___2, & iregex);
  }
#line 164
  if (! tmp) {
#line 167
    return (1);
  }
  {
#line 170
  tmp___0 = inotifytools_initialize();
  }
#line 170
  if (! tmp___0) {
    {
#line 171
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t initialize inotify.  Are you running Linux 2.6.13 or later, and was the\nCONFIG_INOTIFY option enabled when your kernel was compiled?  If so, \nsomething mysterious has gone wrong.  Please e-mail radu.voicilas@gmail.com\n and mention that you saw this message.\n");
    }
#line 178
    return (1);
  }
#line 181
  if (timefmt___2) {
    {
#line 181
    inotifytools_set_printf_timefmt(timefmt___2);
    }
  }
#line 182
  if (regex___2) {
    {
#line 182
    tmp___1 = inotifytools_ignore_events_by_regex((char const   *)regex___2, 1);
    }
#line 182
    if (tmp___1) {
#line 182
      goto _L;
    } else {
      {
#line 187
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in `exclude\' regular expression.\n");
      }
#line 188
      return (1);
    }
  } else
  _L: /* CIL Label */ 
#line 182
  if (iregex) {
    {
#line 182
    tmp___2 = inotifytools_ignore_events_by_regex((char const   *)iregex, 1 | (1 << 1));
    }
#line 182
    if (! tmp___2) {
      {
#line 187
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in `exclude\' regular expression.\n");
      }
#line 188
      return (1);
    }
  }
#line 192
  if (format) {
    {
#line 192
    validate_format(format);
    }
  }
#line 196
  if (events___0 == 0) {
#line 197
    events___0 = 4095;
  }
#line 198
  orig_events = events___0;
#line 199
  if (monitor) {
#line 199
    if (recursive) {
#line 200
      events___0 = ((events___0 | 256) | 128) | 64;
    }
  }
  {
#line 203
  tmp___3 = construct_path_list(argc, argv, (char const   *)fromfile);
#line 203
  list = tmp___3;
  }
#line 205
  if ((unsigned long )((char const   *)0) == (unsigned long )*(list.watch_files + 0)) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No files specified to watch!\n");
    }
#line 207
    return (1);
  }
#line 212
  if (daemon___0) {
    {
#line 214
    pid = fork();
    }
#line 215
    if (pid < 0) {
      {
#line 216
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to fork1 whilst daemonizing!\n");
      }
#line 217
      return (1);
    }
#line 219
    if (pid > 0) {
      {
#line 220
      _exit(0);
      }
    }
    {
#line 222
    tmp___4 = setsid();
    }
#line 222
    if (tmp___4 < 0) {
      {
#line 223
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to setsid whilst daemonizing!\n");
      }
#line 224
      return (1);
    }
    {
#line 226
    signal(1, (void (*)(int  ))1);
#line 227
    pid = fork();
    }
#line 228
    if (pid < 0) {
      {
#line 229
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to fork2 whilst daemonizing!\n");
      }
#line 230
      return (1);
    }
#line 232
    if (pid > 0) {
      {
#line 233
      _exit(0);
      }
    }
    {
#line 235
    tmp___5 = chdir("/");
    }
#line 235
    if (tmp___5 < 0) {
      {
#line 236
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to chdir whilst daemonizing!\n");
      }
#line 237
      return (1);
    }
    {
#line 241
    fd = open("/dev/null", 0);
#line 242
    tmp___7 = fileno(stdin);
    }
#line 242
    if (fd != tmp___7) {
      {
#line 243
      tmp___6 = fileno(stdin);
#line 243
      dup2(fd, tmp___6);
#line 244
      close(fd);
      }
    }
    {
#line 248
    fd = open((char const   *)outfile, 1089, 384);
    }
#line 249
    if (fd < 0) {
      {
#line 250
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open output file %s\n",
              outfile);
      }
#line 251
      return (1);
    }
    {
#line 253
    tmp___9 = fileno(stdout);
    }
#line 253
    if (fd != tmp___9) {
      {
#line 254
      tmp___8 = fileno(stdout);
#line 254
      dup2(fd, tmp___8);
#line 255
      close(fd);
      }
    }
    {
#line 259
    fd = open("/dev/null", 1);
#line 260
    tmp___11 = fileno(stderr);
    }
#line 260
    if (fd != tmp___11) {
      {
#line 261
      tmp___10 = fileno(stderr);
#line 261
      dup2(fd, tmp___10);
#line 262
      close(fd);
      }
    }
  } else
#line 265
  if ((unsigned long )outfile != (unsigned long )((void *)0)) {
    {
#line 266
    fd = open((char const   *)outfile, 1089, 384);
    }
#line 267
    if (fd < 0) {
      {
#line 268
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open output file %s\n",
              outfile);
      }
#line 269
      return (1);
    }
    {
#line 271
    tmp___13 = fileno(stdout);
    }
#line 271
    if (fd != tmp___13) {
      {
#line 272
      tmp___12 = fileno(stdout);
#line 272
      dup2(fd, tmp___12);
#line 273
      close(fd);
      }
    }
  }
#line 277
  if (syslog___0) {
    {
#line 278
    openlog("inotifywait", 11, 3 << 3);
    }
  }
#line 281
  if (! quiet) {
#line 282
    if (recursive) {
      {
#line 283
      output_error(syslog___0, (char *)"Setting up watches.  Beware: since -r was given, this may take a while!\n");
      }
    } else {
      {
#line 286
      output_error(syslog___0, (char *)"Setting up watches.\n");
      }
    }
  }
#line 291
  i___6 = 0;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (! *(list.watch_files + i___6)) {
#line 291
      goto while_break;
    }
#line 292
    this_file = *(list.watch_files + i___6);
#line 293
    if (recursive) {
      {
#line 293
      tmp___17 = inotifytools_watch_recursively_with_exclude(this_file, events___0,
                                                             list.exclude_files);
      }
#line 293
      if (tmp___17) {
#line 293
        goto _L___1;
      } else {
#line 293
        goto _L___0;
      }
    } else
    _L___1: /* CIL Label */ 
#line 293
    if (! recursive) {
      {
#line 293
      tmp___18 = inotifytools_watch_file(this_file, events___0);
      }
#line 293
      if (! tmp___18) {
        _L___0: /* CIL Label */ 
        {
#line 298
        tmp___16 = inotifytools_error();
        }
#line 298
        if (tmp___16 == 28) {
          {
#line 299
          output_error(syslog___0, (char *)"Failed to watch %s; upper limit on inotify watches reached!\n",
                       this_file);
#line 301
          output_error(syslog___0, (char *)"Please increase the amount of inotify watches allowed per user via `/proc/sys/fs/inotify/max_user_watches\'.\n");
          }
        } else {
          {
#line 306
          tmp___14 = inotifytools_error();
#line 306
          tmp___15 = strerror(tmp___14);
#line 306
          output_error(syslog___0, (char *)"Couldn\'t watch %s: %s\n", this_file,
                       tmp___15);
          }
        }
#line 309
        return (1);
      }
    }
#line 291
    i___6 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (! quiet) {
    {
#line 314
    output_error(syslog___0, (char *)"Watches established.\n");
    }
  }
#line 319
  moved_from = (char *)0;
  {
#line 321
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 322
    event___2 = inotifytools_next_event((int )timeout);
    }
#line 323
    if (! event___2) {
      {
#line 324
      tmp___21 = inotifytools_error();
      }
#line 324
      if (tmp___21) {
        {
#line 328
        tmp___19 = inotifytools_error();
#line 328
        tmp___20 = strerror(tmp___19);
#line 328
        output_error(syslog___0, (char *)"%s\n", tmp___20);
        }
#line 329
        return (1);
      } else {
#line 325
        return (2);
      }
    }
#line 333
    if (quiet < 2) {
#line 333
      if (event___2->mask & (unsigned int )orig_events) {
#line 334
        if (csv___0) {
          {
#line 335
          output_event_csv(event___2);
          }
        } else
#line 337
        if (format) {
          {
#line 338
          inotifytools_printf(event___2, format);
          }
        } else {
          {
#line 341
          inotifytools_printf(event___2, (char *)"%w %,e %f\n");
          }
        }
      }
    }
#line 347
    if (moved_from) {
#line 347
      if (! (event___2->mask & 128U)) {
        {
#line 348
        tmp___24 = inotifytools_remove_watch_by_filename((char const   *)moved_from);
        }
#line 348
        if (! tmp___24) {
          {
#line 349
          tmp___22 = inotifytools_error();
#line 349
          tmp___23 = strerror(tmp___22);
#line 349
          output_error(syslog___0, (char *)"Error removing watch on %s: %s\n", moved_from,
                       tmp___23);
          }
        }
        {
#line 352
        free((void *)moved_from);
#line 353
        moved_from = (char *)0;
        }
      }
    }
#line 356
    if (monitor) {
#line 356
      if (recursive) {
#line 357
        if (event___2->mask & 256U) {
#line 357
          goto _L___2;
        } else
#line 357
        if (! moved_from) {
#line 357
          if (event___2->mask & 128U) {
            _L___2: /* CIL Label */ 
            {
#line 362
            tmp___25 = inotifytools_filename_from_wd(event___2->wd);
#line 362
            tmp___26 = asprintf((char **/* __restrict  */)(& new_file), (char const   */* __restrict  */)"%s%s",
                                tmp___25, event___2->name);
#line 362
            _niceassert((long )(-1L != (long )tmp___26), 364, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                        "-1 != asprintf(&new_file, \"%s%s\", inotifytools_filename_from_wd( event->wd ), event->name)",
                        "out of memory");
#line 366
            tmp___29 = isdir((char const   *)new_file);
            }
#line 366
            if (tmp___29) {
              {
#line 366
              tmp___30 = inotifytools_watch_recursively((char const   *)new_file,
                                                        events___0);
              }
#line 366
              if (! tmp___30) {
                {
#line 368
                tmp___27 = inotifytools_error();
#line 368
                tmp___28 = strerror(tmp___27);
#line 368
                output_error(syslog___0, (char *)"Couldn\'t watch new directory %s: %s\n",
                             new_file, tmp___28);
                }
              }
            }
            {
#line 371
            free((void *)new_file);
            }
          } else {
#line 357
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 373
        if (event___2->mask & 64U) {
          {
#line 374
          tmp___31 = inotifytools_filename_from_wd(event___2->wd);
#line 374
          tmp___32 = asprintf((char **/* __restrict  */)(& moved_from), (char const   */* __restrict  */)"%s%s/",
                              tmp___31, event___2->name);
#line 374
          _niceassert((long )(-1L != (long )tmp___32), 376, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                      "-1 != asprintf(&moved_from, \"%s%s/\", inotifytools_filename_from_wd( event->wd ), event->name)",
                      "out of memory");
#line 378
          tmp___33 = inotifytools_wd_from_filename((char const   *)moved_from);
          }
#line 378
          if (tmp___33 == -1) {
            {
#line 379
            free((void *)moved_from);
#line 380
            moved_from = (char *)0;
            }
          }
        } else
#line 383
        if (event___2->mask & 128U) {
#line 384
          if (moved_from) {
            {
#line 386
            tmp___34 = inotifytools_filename_from_wd(event___2->wd);
#line 386
            tmp___35 = asprintf((char **/* __restrict  */)(& new_name), (char const   */* __restrict  */)"%s%s/",
                                tmp___34, event___2->name);
#line 386
            _niceassert((long )(-1L != (long )tmp___35), 388, "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                        "-1 != asprintf(&new_name, \"%s%s/\", inotifytools_filename_from_wd( event->wd ), event->name)",
                        "out of memory");
#line 389
            inotifytools_replace_filename((char const   *)moved_from, (char const   *)new_name);
#line 390
            free((void *)moved_from);
#line 391
            moved_from = (char *)0;
            }
          }
        }
      }
    }
    {
#line 396
    fflush((FILE *)((void *)0));
    }
#line 321
    if (! monitor) {
#line 321
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 401
  if (((unsigned int )events___0 & event___2->mask) == 0U) {
#line 403
    return (1);
  }
#line 406
  return (0);
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c"
static char *newlineformat  ;
#line 410 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c"
_Bool parse_opts(int *argc , char ***argv , int *events___0 , _Bool *monitor , int *quiet ,
                 unsigned long *timeout , int *recursive , _Bool *csv___0 , _Bool *daemon___0 ,
                 _Bool *syslog___0 , char **format , char **timefmt___2 , char **fromfile ,
                 char **outfile , char **regex___2 , char **iregex ) 
{ 
  char *opt_string ;
  struct option long_opts[17] ;
  int new_event ;
  char *timeout_end ;
  char curr_opt ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 428
  if (! argc) {
    {
#line 428
    __assert_fail("argc", "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                  428U, "parse_opts");
    }
  }
#line 428
  if (! argv) {
    {
#line 428
    __assert_fail("argv", "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                  428U, "parse_opts");
    }
  }
#line 428
  if (! events___0) {
    {
#line 428
    __assert_fail("events", "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                  428U, "parse_opts");
    }
  }
#line 428
  if (! monitor) {
    {
#line 428
    __assert_fail("monitor", "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                  428U, "parse_opts");
    }
  }
#line 429
  if (! quiet) {
    {
#line 429
    __assert_fail("quiet", "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                  429U, "parse_opts");
    }
  }
#line 429
  if (! timeout) {
    {
#line 429
    __assert_fail("timeout", "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                  429U, "parse_opts");
    }
  }
#line 429
  if (! csv___0) {
    {
#line 429
    __assert_fail("csv", "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                  429U, "parse_opts");
    }
  }
#line 429
  if (! daemon___0) {
    {
#line 429
    __assert_fail("daemon", "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                  429U, "parse_opts");
    }
  }
#line 430
  if (! syslog___0) {
    {
#line 430
    __assert_fail("syslog", "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                  430U, "parse_opts");
    }
  }
#line 430
  if (! format) {
    {
#line 430
    __assert_fail("format", "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                  430U, "parse_opts");
    }
  }
#line 430
  if (! timefmt___2) {
    {
#line 430
    __assert_fail("timefmt", "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                  430U, "parse_opts");
    }
  }
#line 430
  if (! fromfile) {
    {
#line 430
    __assert_fail("fromfile", "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                  430U, "parse_opts");
    }
  }
#line 431
  if (! outfile) {
    {
#line 431
    __assert_fail("outfile", "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                  431U, "parse_opts");
    }
  }
#line 431
  if (! regex___2) {
    {
#line 431
    __assert_fail("regex", "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                  431U, "parse_opts");
    }
  }
#line 431
  if (! iregex) {
    {
#line 431
    __assert_fail("iregex", "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c",
                  431U, "parse_opts");
    }
  }
  {
#line 434
  opt_string = (char *)"mrhcdsqt:fo:e:";
#line 440
  long_opts[0].name = "help";
#line 441
  long_opts[0].has_arg = 0;
#line 442
  long_opts[0].flag = (int *)((void *)0);
#line 443
  long_opts[0].val = 'h';
#line 445
  long_opts[1].name = "event";
#line 446
  long_opts[1].has_arg = 1;
#line 447
  long_opts[1].flag = (int *)((void *)0);
#line 448
  long_opts[1].val = 'e';
#line 451
  long_opts[2].name = "monitor";
#line 452
  long_opts[2].has_arg = 0;
#line 453
  long_opts[2].flag = (int *)((void *)0);
#line 454
  long_opts[2].val = 'm';
#line 456
  long_opts[3].name = "quiet";
#line 457
  long_opts[3].has_arg = 0;
#line 458
  long_opts[3].flag = (int *)((void *)0);
#line 459
  long_opts[3].val = 'q';
#line 461
  long_opts[4].name = "timeout";
#line 462
  long_opts[4].has_arg = 1;
#line 463
  long_opts[4].flag = (int *)((void *)0);
#line 464
  long_opts[4].val = 't';
#line 465
  timeout_end = (char *)((void *)0);
#line 467
  long_opts[5].name = "filename";
#line 468
  long_opts[5].has_arg = 0;
#line 469
  long_opts[5].flag = (int *)((void *)0);
#line 470
  long_opts[5].val = 'f';
#line 472
  long_opts[6].name = "recursive";
#line 473
  long_opts[6].has_arg = 0;
#line 474
  long_opts[6].flag = (int *)((void *)0);
#line 475
  long_opts[6].val = 'r';
#line 477
  long_opts[7].name = "csv";
#line 478
  long_opts[7].has_arg = 0;
#line 479
  long_opts[7].flag = (int *)((void *)0);
#line 480
  long_opts[7].val = 'c';
#line 482
  long_opts[8].name = "daemon";
#line 483
  long_opts[8].has_arg = 0;
#line 484
  long_opts[8].flag = (int *)((void *)0);
#line 485
  long_opts[8].val = 'd';
#line 487
  long_opts[9].name = "syslog";
#line 488
  long_opts[9].has_arg = 0;
#line 489
  long_opts[9].flag = (int *)((void *)0);
#line 490
  long_opts[9].val = 's';
#line 492
  long_opts[10].name = "format";
#line 493
  long_opts[10].has_arg = 1;
#line 494
  long_opts[10].flag = (int *)((void *)0);
#line 495
  long_opts[10].val = 'n';
#line 499
  long_opts[11].name = "timefmt";
#line 500
  long_opts[11].has_arg = 1;
#line 501
  long_opts[11].flag = (int *)((void *)0);
#line 502
  long_opts[11].val = 'i';
#line 504
  long_opts[12].name = "fromfile";
#line 505
  long_opts[12].has_arg = 1;
#line 506
  long_opts[12].flag = (int *)((void *)0);
#line 507
  long_opts[12].val = 'z';
#line 509
  long_opts[13].name = "outfile";
#line 510
  long_opts[13].has_arg = 1;
#line 511
  long_opts[13].flag = (int *)((void *)0);
#line 512
  long_opts[13].val = 'o';
#line 514
  long_opts[14].name = "exclude";
#line 515
  long_opts[14].has_arg = 1;
#line 516
  long_opts[14].flag = (int *)((void *)0);
#line 517
  long_opts[14].val = 'a';
#line 519
  long_opts[15].name = "excludei";
#line 520
  long_opts[15].has_arg = 1;
#line 521
  long_opts[15].flag = (int *)((void *)0);
#line 522
  long_opts[15].val = 'b';
#line 524
  long_opts[16].name = (char const   *)0;
#line 525
  long_opts[16].has_arg = 0;
#line 526
  long_opts[16].flag = (int *)0;
#line 527
  long_opts[16].val = 0;
#line 530
  tmp = getopt_long(*argc, (char * const  *)*argv, (char const   *)opt_string, (struct option  const  *)(long_opts),
                    (int *)((void *)0));
#line 530
  curr_opt = (char )tmp;
  }
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if ((int )curr_opt != 63) {
#line 533
      if (! ((int )curr_opt != -1)) {
#line 533
        goto while_break;
      }
    } else {
#line 533
      goto while_break;
    }
    {
#line 538
    if ((int )curr_opt == 104) {
#line 538
      goto case_104;
    }
#line 545
    if ((int )curr_opt == 109) {
#line 545
      goto case_109;
    }
#line 550
    if ((int )curr_opt == 113) {
#line 550
      goto case_113;
    }
#line 555
    if ((int )curr_opt == 114) {
#line 555
      goto case_114;
    }
#line 560
    if ((int )curr_opt == 99) {
#line 560
      goto case_99;
    }
#line 565
    if ((int )curr_opt == 100) {
#line 565
      goto case_100;
    }
#line 572
    if ((int )curr_opt == 115) {
#line 572
      goto case_115;
    }
#line 577
    if ((int )curr_opt == 102) {
#line 577
      goto case_102;
    }
#line 585
    if ((int )curr_opt == 110) {
#line 585
      goto case_110;
    }
#line 593
    if ((int )curr_opt == 105) {
#line 593
      goto case_105;
    }
#line 598
    if ((int )curr_opt == 97) {
#line 598
      goto case_97;
    }
#line 603
    if ((int )curr_opt == 98) {
#line 603
      goto case_98;
    }
#line 608
    if ((int )curr_opt == 122) {
#line 608
      goto case_122;
    }
#line 617
    if ((int )curr_opt == 111) {
#line 617
      goto case_111;
    }
#line 626
    if ((int )curr_opt == 116) {
#line 626
      goto case_116;
    }
#line 639
    if ((int )curr_opt == 101) {
#line 639
      goto case_101;
    }
#line 535
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 539
    print_help();
    }
#line 541
    return ((_Bool)0);
#line 542
    goto switch_break;
    case_109: /* CIL Label */ 
#line 546
    *monitor = (_Bool)1;
#line 547
    goto switch_break;
    case_113: /* CIL Label */ 
#line 551
    (*quiet) ++;
#line 552
    goto switch_break;
    case_114: /* CIL Label */ 
#line 556
    (*recursive) ++;
#line 557
    goto switch_break;
    case_99: /* CIL Label */ 
#line 561
    *csv___0 = (_Bool)1;
#line 562
    goto switch_break;
    case_100: /* CIL Label */ 
#line 566
    *daemon___0 = (_Bool)1;
#line 567
    *monitor = (_Bool)1;
#line 568
    *syslog___0 = (_Bool)1;
#line 569
    goto switch_break;
    case_115: /* CIL Label */ 
#line 573
    *syslog___0 = (_Bool)1;
#line 574
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 578
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The \'--filename\' option no longer exists.  The option it enabled in earlier\nversions of inotifywait is now turned on by default.\n");
    }
#line 581
    return ((_Bool)0);
#line 582
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 586
    tmp___0 = strlen((char const   *)optarg);
#line 586
    tmp___1 = malloc(tmp___0 + 2UL);
#line 586
    newlineformat = (char *)tmp___1;
#line 587
    strcpy((char */* __restrict  */)newlineformat, (char const   */* __restrict  */)optarg);
#line 588
    strcat((char */* __restrict  */)newlineformat, (char const   */* __restrict  */)"\n");
#line 589
    *format = newlineformat;
    }
#line 590
    goto switch_break;
    case_105: /* CIL Label */ 
#line 594
    *timefmt___2 = optarg;
#line 595
    goto switch_break;
    case_97: /* CIL Label */ 
#line 599
    *regex___2 = optarg;
#line 600
    goto switch_break;
    case_98: /* CIL Label */ 
#line 604
    *iregex = optarg;
#line 605
    goto switch_break;
    case_122: /* CIL Label */ 
#line 609
    if (*fromfile) {
      {
#line 610
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Multiple --fromfile options given.\n");
      }
#line 611
      return ((_Bool)0);
    }
#line 613
    *fromfile = optarg;
#line 614
    goto switch_break;
    case_111: /* CIL Label */ 
#line 618
    if (*outfile) {
      {
#line 619
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Multiple --outfile options given.\n");
      }
#line 620
      return ((_Bool)0);
    }
#line 622
    *outfile = optarg;
#line 623
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 627
    *timeout = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& timeout_end),
                       10);
    }
#line 628
    if ((int )*timeout_end != 0) {
      {
#line 630
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'%s\' is not a valid timeout value.\nPlease specify an integer of value 0 or greater.\n",
              optarg);
      }
#line 634
      return ((_Bool)0);
    }
#line 636
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 641
    new_event = inotifytools_str_to_event((char const   *)optarg);
    }
#line 644
    if (new_event == -1) {
      {
#line 646
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'%s\' is not a valid event!  Run with the \'--help\' option to see a list of events.\n",
              optarg);
      }
#line 649
      return ((_Bool)0);
    }
#line 653
    *events___0 |= new_event;
#line 655
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 660
    tmp___2 = getopt_long(*argc, (char * const  *)*argv, (char const   *)opt_string,
                          (struct option  const  *)(long_opts), (int *)((void *)0));
#line 660
    curr_opt = (char )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 664
  if (*monitor) {
#line 664
    if (*timeout != 0UL) {
      {
#line 665
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-m and -t cannot both be specified.\n");
      }
#line 666
      return ((_Bool)0);
    }
  }
#line 669
  if (*regex___2) {
#line 669
    if (*iregex) {
      {
#line 670
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--exclude and --excludei cannot both be specified.\n");
      }
#line 671
      return ((_Bool)0);
    }
  }
#line 674
  if (*format) {
#line 674
    if (*csv___0) {
      {
#line 675
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-c and --format cannot both be specified.\n");
      }
#line 676
      return ((_Bool)0);
    }
  }
#line 679
  if (! *format) {
#line 679
    if (*timefmt___2) {
      {
#line 680
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--timefmt cannot be specified without --format.\n");
      }
#line 681
      return ((_Bool)0);
    }
  }
#line 684
  if (*format) {
    {
#line 684
    tmp___3 = strstr((char const   *)*format, "%T");
    }
#line 684
    if (tmp___3) {
#line 684
      if (! *timefmt___2) {
        {
#line 685
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%%T is in --format string, but --timefmt was not specified.\n");
        }
#line 687
        return ((_Bool)0);
      }
    }
  }
#line 690
  if (*daemon___0) {
#line 690
    if ((unsigned long )*outfile == (unsigned long )((void *)0)) {
      {
#line 691
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-o must be specified with -d.\n");
      }
#line 692
      return ((_Bool)0);
    }
  }
#line 695
  *argc -= optind;
#line 696
  *argv += optind;
#line 699
  return ((_Bool )((int )curr_opt != 63));
}
}
#line 703 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywait.c"
void print_help(void) 
{ 


  {
  {
#line 705
  printf((char const   */* __restrict  */)"inotifywait %s\n", "3.14");
#line 706
  printf((char const   */* __restrict  */)"Wait for a particular event on a file or set of files.\n");
#line 707
  printf((char const   */* __restrict  */)"Usage: inotifywait [ options ] file1 [ file2 ] [ file3 ] [ ... ]\n");
#line 709
  printf((char const   */* __restrict  */)"Options:\n");
#line 710
  printf((char const   */* __restrict  */)"\t-h|--help     \tShow this help text.\n");
#line 711
  printf((char const   */* __restrict  */)"\t@<file>       \tExclude the specified file from being watched.\n");
#line 713
  printf((char const   */* __restrict  */)"\t--exclude <pattern>\n\t              \tExclude all events on files matching the\n\t              \textended regular expression <pattern>.\n");
#line 716
  printf((char const   */* __restrict  */)"\t--excludei <pattern>\n\t              \tLike --exclude but case insensitive.\n");
#line 718
  printf((char const   */* __restrict  */)"\t-m|--monitor  \tKeep listening for events forever.  Without\n\t              \tthis option, inotifywait will exit after one\n\t              \tevent is received.\n");
#line 721
  printf((char const   */* __restrict  */)"\t-d|--daemon   \tSame as --monitor, except run in the background\n\t              \tlogging events to a file specified by --outfile.\n\t              \tImplies --syslog.\n");
#line 724
  printf((char const   */* __restrict  */)"\t-r|--recursive\tWatch directories recursively.\n");
#line 725
  printf((char const   */* __restrict  */)"\t--fromfile <file>\n\t              \tRead files to watch from <file> or `-\' for stdin.\n");
#line 728
  printf((char const   */* __restrict  */)"\t-o|--outfile <file>\n\t              \tPrint events to <file> rather than stdout.\n");
#line 730
  printf((char const   */* __restrict  */)"\t-s|--syslog   \tSend errors to syslog rather than stderr.\n");
#line 731
  printf((char const   */* __restrict  */)"\t-q|--quiet    \tPrint less (only print events).\n");
#line 732
  printf((char const   */* __restrict  */)"\t-qq           \tPrint nothing (not even events).\n");
#line 733
  printf((char const   */* __restrict  */)"\t--format <fmt>\tPrint using a specified printf-like format\n\t              \tstring; read the man page for more details.\n");
#line 735
  printf((char const   */* __restrict  */)"\t--timefmt <fmt>\tstrftime-compatible format string for use with\n\t              \t%%T in --format string.\n");
#line 737
  printf((char const   */* __restrict  */)"\t-c|--csv      \tPrint events in CSV format.\n");
#line 738
  printf((char const   */* __restrict  */)"\t-t|--timeout <seconds>\n\t              \tWhen listening for a single event, time out after\n\t              \twaiting for an event for <seconds> seconds.\n\t              \tIf <seconds> is 0, inotifywait will never time out.\n");
#line 744
  printf((char const   */* __restrict  */)"\t-e|--event <event1> [ -e|--event <event2> ... ]\n\t\tListen for specific event(s).  If omitted, all events are \n\t\tlistened for.\n\n");
#line 747
  printf((char const   */* __restrict  */)"Exit status:\n");
#line 748
  printf((char const   */* __restrict  */)"\t%d  -  An event you asked to watch for was received.\n",
         0);
#line 750
  printf((char const   */* __restrict  */)"\t%d  -  An event you did not ask to watch for was received\n",
         1);
#line 752
  printf((char const   */* __restrict  */)"\t      (usually delete_self or unmount), or some error occurred.\n");
#line 754
  printf((char const   */* __restrict  */)"\t%d  -  The --timeout option was given and no events occurred\n",
         2);
#line 756
  printf((char const   */* __restrict  */)"\t      in the specified interval of time.\n\n");
#line 757
  printf((char const   */* __restrict  */)"Events:\n");
#line 758
  print_event_descriptions();
  }
#line 759
  return;
}
}
#line 1 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static char rcsid___0[53]  = 
#line 1 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'r',      (char )'e',      (char )'d', 
        (char )'b',      (char )'l',      (char )'a',      (char )'c', 
        (char )'k',      (char )'.',      (char )'c',      (char )',', 
        (char )'v',      (char )' ',      (char )'1',      (char )'.', 
        (char )'9',      (char )' ',      (char )'2',      (char )'0', 
        (char )'0',      (char )'3',      (char )'/',      (char )'1', 
        (char )'0',      (char )'/',      (char )'2',      (char )'4', 
        (char )' ',      (char )'0',      (char )'1',      (char )':', 
        (char )'3',      (char )'1',      (char )':',      (char )'2', 
        (char )'1',      (char )' ',      (char )'d',      (char )'a', 
        (char )'m',      (char )'o',      (char )' ',      (char )'E', 
        (char )'x',      (char )'p',      (char )' ',      (char )'$', 
        (char )'\000'};
#line 76 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rbnode *rb_alloc___0(void) 
{ 
  void *tmp ;

  {
  {
#line 76
  tmp = malloc(sizeof(struct rbnode ));
  }
#line 76
  return ((struct rbnode *)tmp);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_free___0(struct rbnode *x ) 
{ 


  {
  {
#line 77
  free((void *)x);
  }
#line 77
  return;
}
}
#line 82
static void rb_left_rotate___0(struct rbnode **rootp , struct rbnode *x ) ;
#line 83
static void rb_right_rotate___0(struct rbnode **rootp , struct rbnode *y ) ;
#line 84
static struct rbnode *rb_successor___0(struct rbnode  const  *x ) ;
#line 85
static struct rbnode *rb_predecessor___0(struct rbnode  const  *x ) ;
#line 86
static struct rbnode *rb_traverse___0(int insert , void const   *key , struct rbtree *rbinfo ) ;
#line 90
static struct rbnode *rb_lookup___0(int mode , void const   *key , struct rbtree *rbinfo ) ;
#line 94
static void rb_destroy___0(struct rbnode *x ) ;
#line 98
static void rb_delete___0(struct rbnode **rootp , struct rbnode *z ) ;
#line 99
static void rb_delete_fix___0(struct rbnode **rootp , struct rbnode *x ) ;
#line 103
static void rb_walk___0(struct rbnode  const  *x , void (*action)(void const   * ,
                                                                  VISIT const    ,
                                                                  int const    , void * ) ,
                        void *arg , int level ) ;
#line 107
static struct rblists *rb_openlist___0(struct rbnode  const  *rootp ) ;
#line 108
static void const   *rb_readlist___0(struct rblists *rblistp ) ;
#line 109
static void rb_closelist___0(struct rblists *rblistp ) ;
#line 294 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rbnode *rb_traverse___0(int insert , void const   *key , struct rbtree *rbinfo ) 
{ 
  struct rbnode *x ;
  struct rbnode *y ;
  struct rbnode *z ;
  int cmp ;
  int found ;

  {
#line 299
  found = 0;
#line 302
  y = & rb_null;
#line 303
  x = rbinfo->rb_root;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if ((unsigned long )x != (unsigned long )(& rb_null)) {
#line 306
      if (! (found == 0)) {
#line 306
        goto while_break;
      }
    } else {
#line 306
      goto while_break;
    }
    {
#line 308
    y = x;
#line 311
    cmp = (*(rbinfo->rb_cmp))(key, x->key, rbinfo->rb_config);
    }
#line 316
    if (cmp < 0) {
#line 317
      x = x->left;
    } else
#line 318
    if (cmp > 0) {
#line 319
      x = x->right;
    } else {
#line 321
      found = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  if (found) {
#line 325
    return (x);
  } else
#line 324
  if (! insert) {
#line 325
    return (x);
  }
  {
#line 327
  z = rb_alloc___0();
  }
#line 327
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 330
    return (& rb_null);
  }
#line 333
  z->key = key;
#line 334
  z->up = y;
#line 335
  if ((unsigned long )y == (unsigned long )(& rb_null)) {
#line 337
    rbinfo->rb_root = z;
  } else {
    {
#line 342
    cmp = (*(rbinfo->rb_cmp))(z->key, y->key, rbinfo->rb_config);
    }
#line 346
    if (cmp < 0) {
#line 347
      y->left = z;
    } else {
#line 349
      y->right = z;
    }
  }
#line 352
  z->left = & rb_null;
#line 353
  z->right = & rb_null;
#line 356
  z->colour = (enum nodecolour )1;
#line 361
  x = z;
  {
#line 368
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 368
    if ((unsigned long )x != (unsigned long )rbinfo->rb_root) {
#line 368
      if (! ((unsigned int )(x->up)->colour == 1U)) {
#line 368
        goto while_break___0;
      }
    } else {
#line 368
      goto while_break___0;
    }
#line 371
    if ((unsigned long )x->up == (unsigned long )((x->up)->up)->left) {
#line 374
      y = ((x->up)->up)->right;
#line 375
      if ((unsigned int )y->colour == 1U) {
#line 378
        (x->up)->colour = (enum nodecolour )0;
#line 380
        y->colour = (enum nodecolour )0;
#line 382
        ((x->up)->up)->colour = (enum nodecolour )1;
#line 385
        x = (x->up)->up;
      } else {
#line 390
        if ((unsigned long )x == (unsigned long )(x->up)->right) {
          {
#line 393
          x = x->up;
#line 394
          rb_left_rotate___0(& rbinfo->rb_root, x);
          }
        }
        {
#line 398
        (x->up)->colour = (enum nodecolour )0;
#line 400
        ((x->up)->up)->colour = (enum nodecolour )1;
#line 402
        rb_right_rotate___0(& rbinfo->rb_root, (x->up)->up);
        }
      }
    } else {
#line 411
      y = ((x->up)->up)->left;
#line 412
      if ((unsigned int )y->colour == 1U) {
#line 414
        (x->up)->colour = (enum nodecolour )0;
#line 415
        y->colour = (enum nodecolour )0;
#line 416
        ((x->up)->up)->colour = (enum nodecolour )1;
#line 418
        x = (x->up)->up;
      } else {
#line 422
        if ((unsigned long )x == (unsigned long )(x->up)->left) {
          {
#line 424
          x = x->up;
#line 425
          rb_right_rotate___0(& rbinfo->rb_root, x);
          }
        }
        {
#line 428
        (x->up)->colour = (enum nodecolour )0;
#line 429
        ((x->up)->up)->colour = (enum nodecolour )1;
#line 430
        rb_left_rotate___0(& rbinfo->rb_root, (x->up)->up);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 436
  (rbinfo->rb_root)->colour = (enum nodecolour )0;
#line 438
  return (z);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rbnode *rb_lookup___0(int mode , void const   *key , struct rbtree *rbinfo ) 
{ 
  struct rbnode *x ;
  struct rbnode *y ;
  int cmp ;
  int found ;
  struct rbnode *tmp ;
  struct rbnode *tmp___0 ;
  struct rbnode *tmp___1 ;
  struct rbnode *tmp___2 ;

  {
#line 449
  found = 0;
#line 451
  y = & rb_null;
#line 452
  x = rbinfo->rb_root;
#line 454
  if (mode == 7) {
    {
#line 457
    while (1) {
      while_continue: /* CIL Label */ ;
#line 457
      if (! ((unsigned long )x != (unsigned long )(& rb_null))) {
#line 457
        goto while_break;
      }
#line 459
      y = x;
#line 460
      x = x->left;
    }
    while_break: /* CIL Label */ ;
    }
#line 463
    return (y);
  } else
#line 465
  if (mode == 8) {
    {
#line 468
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 468
      if (! ((unsigned long )x != (unsigned long )(& rb_null))) {
#line 468
        goto while_break___0;
      }
#line 470
      y = x;
#line 471
      x = x->right;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 474
    return (y);
  }
  {
#line 478
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 478
    if ((unsigned long )x != (unsigned long )(& rb_null)) {
#line 478
      if (! (found == 0)) {
#line 478
        goto while_break___1;
      }
    } else {
#line 478
      goto while_break___1;
    }
    {
#line 480
    y = x;
#line 483
    cmp = (*(rbinfo->rb_cmp))(key, x->key, rbinfo->rb_config);
    }
#line 489
    if (cmp < 0) {
#line 490
      x = x->left;
    } else
#line 491
    if (cmp > 0) {
#line 492
      x = x->right;
    } else {
#line 494
      found = 1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 497
  if (found) {
#line 497
    if (mode == 0) {
#line 498
      return (x);
    } else
#line 497
    if (mode == 1) {
#line 498
      return (x);
    } else
#line 497
    if (mode == 2) {
#line 498
      return (x);
    }
  }
#line 500
  if (! found) {
#line 500
    if (mode == 0) {
#line 501
      return (& rb_null);
    } else
#line 500
    if (mode == 5) {
#line 501
      return (& rb_null);
    } else
#line 500
    if (mode == 6) {
#line 501
      return (& rb_null);
    }
  }
#line 503
  if (mode == 1) {
#line 503
    goto _L;
  } else
#line 503
  if (! found) {
#line 503
    if (mode == 4) {
      _L: /* CIL Label */ 
#line 505
      if (cmp > 0) {
        {
#line 506
        tmp = rb_successor___0((struct rbnode  const  *)y);
        }
#line 506
        return (tmp);
      } else {
#line 508
        return (y);
      }
    }
  }
#line 511
  if (mode == 2) {
#line 511
    goto _L___0;
  } else
#line 511
  if (! found) {
#line 511
    if (mode == 3) {
      _L___0: /* CIL Label */ 
#line 513
      if (cmp < 0) {
        {
#line 514
        tmp___0 = rb_predecessor___0((struct rbnode  const  *)y);
        }
#line 514
        return (tmp___0);
      } else {
#line 516
        return (y);
      }
    }
  }
#line 519
  if (mode == 5) {
    {
#line 520
    tmp___1 = rb_successor___0((struct rbnode  const  *)x);
    }
#line 520
    return (tmp___1);
  } else
#line 519
  if (found) {
#line 519
    if (mode == 4) {
      {
#line 520
      tmp___1 = rb_successor___0((struct rbnode  const  *)x);
      }
#line 520
      return (tmp___1);
    }
  }
#line 522
  if (mode == 6) {
    {
#line 523
    tmp___2 = rb_predecessor___0((struct rbnode  const  *)x);
    }
#line 523
    return (tmp___2);
  } else
#line 522
  if (found) {
#line 522
    if (mode == 3) {
      {
#line 523
      tmp___2 = rb_predecessor___0((struct rbnode  const  *)x);
      }
#line 523
      return (tmp___2);
    }
  }
#line 526
  return (& rb_null);
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_destroy___0(struct rbnode *x ) 
{ 


  {
#line 538
  if ((unsigned long )x != (unsigned long )(& rb_null)) {
#line 540
    if ((unsigned long )x->left != (unsigned long )(& rb_null)) {
      {
#line 541
      rb_destroy___0(x->left);
      }
    }
#line 542
    if ((unsigned long )x->right != (unsigned long )(& rb_null)) {
      {
#line 543
      rb_destroy___0(x->right);
      }
    }
    {
#line 544
    rb_free___0(x);
    }
  }
#line 546
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_left_rotate___0(struct rbnode **rootp , struct rbnode *x ) 
{ 
  struct rbnode *y ;

  {
#line 571
  y = x->right;
#line 574
  x->right = y->left;
#line 577
  if ((unsigned long )y->left != (unsigned long )(& rb_null)) {
#line 578
    (y->left)->up = x;
  }
#line 581
  y->up = x->up;
#line 584
  if ((unsigned long )x->up == (unsigned long )(& rb_null)) {
#line 586
    *rootp = y;
  } else
#line 591
  if ((unsigned long )x == (unsigned long )(x->up)->left) {
#line 593
    (x->up)->left = y;
  } else {
#line 597
    (x->up)->right = y;
  }
#line 602
  y->left = x;
#line 605
  x->up = y;
#line 606
  return;
}
}
#line 608 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_right_rotate___0(struct rbnode **rootp , struct rbnode *y ) 
{ 
  struct rbnode *x ;

  {
#line 616
  x = y->left;
#line 619
  y->left = x->right;
#line 622
  if ((unsigned long )x->right != (unsigned long )(& rb_null)) {
#line 623
    (x->right)->up = y;
  }
#line 626
  x->up = y->up;
#line 629
  if ((unsigned long )y->up == (unsigned long )(& rb_null)) {
#line 631
    *rootp = x;
  } else
#line 636
  if ((unsigned long )y == (unsigned long )(y->up)->left) {
#line 638
    (y->up)->left = x;
  } else {
#line 642
    (y->up)->right = x;
  }
#line 647
  x->right = y;
#line 650
  y->up = x;
#line 651
  return;
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rbnode *rb_successor___0(struct rbnode  const  *x ) 
{ 
  struct rbnode *y ;

  {
#line 660
  if ((unsigned long )x->right != (unsigned long )(& rb_null)) {
#line 666
    y = (struct rbnode *)x->right;
    {
#line 666
    while (1) {
      while_continue: /* CIL Label */ ;
#line 666
      if (! ((unsigned long )y->left != (unsigned long )(& rb_null))) {
#line 666
        goto while_break;
      }
#line 666
      y = y->left;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 674
    y = (struct rbnode *)x->up;
    {
#line 675
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 675
      if ((unsigned long )y != (unsigned long )(& rb_null)) {
#line 675
        if (! ((unsigned long )x == (unsigned long )y->right)) {
#line 675
          goto while_break___0;
        }
      } else {
#line 675
        goto while_break___0;
      }
#line 677
      x = (struct rbnode  const  *)y;
#line 678
      y = y->up;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 681
  return (y);
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rbnode *rb_predecessor___0(struct rbnode  const  *x ) 
{ 
  struct rbnode *y ;

  {
#line 691
  if ((unsigned long )x->left != (unsigned long )(& rb_null)) {
#line 697
    y = (struct rbnode *)x->left;
    {
#line 697
    while (1) {
      while_continue: /* CIL Label */ ;
#line 697
      if (! ((unsigned long )y->right != (unsigned long )(& rb_null))) {
#line 697
        goto while_break;
      }
#line 697
      y = y->right;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 705
    y = (struct rbnode *)x->up;
    {
#line 706
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 706
      if ((unsigned long )y != (unsigned long )(& rb_null)) {
#line 706
        if (! ((unsigned long )x == (unsigned long )y->left)) {
#line 706
          goto while_break___0;
        }
      } else {
#line 706
        goto while_break___0;
      }
#line 708
      x = (struct rbnode  const  *)y;
#line 709
      y = y->up;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 712
  return (y);
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_delete___0(struct rbnode **rootp , struct rbnode *z ) 
{ 
  struct rbnode *x ;
  struct rbnode *y ;

  {
#line 723
  if ((unsigned long )z->left == (unsigned long )(& rb_null)) {
#line 724
    y = z;
  } else
#line 723
  if ((unsigned long )z->right == (unsigned long )(& rb_null)) {
#line 724
    y = z;
  } else {
    {
#line 726
    y = rb_successor___0((struct rbnode  const  *)z);
    }
  }
#line 728
  if ((unsigned long )y->left != (unsigned long )(& rb_null)) {
#line 729
    x = y->left;
  } else {
#line 731
    x = y->right;
  }
#line 733
  x->up = y->up;
#line 735
  if ((unsigned long )y->up == (unsigned long )(& rb_null)) {
#line 737
    *rootp = x;
  } else
#line 741
  if ((unsigned long )y == (unsigned long )(y->up)->left) {
#line 742
    (y->up)->left = x;
  } else {
#line 744
    (y->up)->right = x;
  }
#line 747
  if ((unsigned long )y != (unsigned long )z) {
#line 749
    z->key = y->key;
  }
#line 752
  if ((unsigned int )y->colour == 0U) {
    {
#line 753
    rb_delete_fix___0(rootp, x);
    }
  }
  {
#line 755
  rb_free___0(y);
  }
#line 756
  return;
}
}
#line 759 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_delete_fix___0(struct rbnode **rootp , struct rbnode *x ) 
{ 
  struct rbnode *w ;

  {
  {
#line 764
  while (1) {
    while_continue: /* CIL Label */ ;
#line 764
    if ((unsigned long )x != (unsigned long )*rootp) {
#line 764
      if (! ((unsigned int )x->colour == 0U)) {
#line 764
        goto while_break;
      }
    } else {
#line 764
      goto while_break;
    }
#line 766
    if ((unsigned long )x == (unsigned long )(x->up)->left) {
#line 768
      w = (x->up)->right;
#line 769
      if ((unsigned int )w->colour == 1U) {
        {
#line 771
        w->colour = (enum nodecolour )0;
#line 772
        (x->up)->colour = (enum nodecolour )1;
#line 773
        rb_left_rotate___0(rootp, x->up);
#line 774
        w = (x->up)->right;
        }
      }
#line 777
      if ((unsigned int )(w->left)->colour == 0U) {
#line 777
        if ((unsigned int )(w->right)->colour == 0U) {
#line 779
          w->colour = (enum nodecolour )1;
#line 780
          x = x->up;
        } else {
#line 777
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 784
        if ((unsigned int )(w->right)->colour == 0U) {
          {
#line 786
          (w->left)->colour = (enum nodecolour )0;
#line 787
          w->colour = (enum nodecolour )1;
#line 788
          rb_right_rotate___0(rootp, w);
#line 789
          w = (x->up)->right;
          }
        }
        {
#line 793
        w->colour = (x->up)->colour;
#line 794
        (x->up)->colour = (enum nodecolour )0;
#line 795
        (w->right)->colour = (enum nodecolour )0;
#line 796
        rb_left_rotate___0(rootp, x->up);
#line 797
        x = *rootp;
        }
      }
    } else {
#line 802
      w = (x->up)->left;
#line 803
      if ((unsigned int )w->colour == 1U) {
        {
#line 805
        w->colour = (enum nodecolour )0;
#line 806
        (x->up)->colour = (enum nodecolour )1;
#line 807
        rb_right_rotate___0(rootp, x->up);
#line 808
        w = (x->up)->left;
        }
      }
#line 811
      if ((unsigned int )(w->right)->colour == 0U) {
#line 811
        if ((unsigned int )(w->left)->colour == 0U) {
#line 813
          w->colour = (enum nodecolour )1;
#line 814
          x = x->up;
        } else {
#line 811
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 818
        if ((unsigned int )(w->left)->colour == 0U) {
          {
#line 820
          (w->right)->colour = (enum nodecolour )0;
#line 821
          w->colour = (enum nodecolour )1;
#line 822
          rb_left_rotate___0(rootp, w);
#line 823
          w = (x->up)->left;
          }
        }
        {
#line 826
        w->colour = (x->up)->colour;
#line 827
        (x->up)->colour = (enum nodecolour )0;
#line 828
        (w->left)->colour = (enum nodecolour )0;
#line 829
        rb_right_rotate___0(rootp, x->up);
#line 830
        x = *rootp;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 835
  x->colour = (enum nodecolour )0;
#line 836
  return;
}
}
#line 840 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_walk___0(struct rbnode  const  *x , void (*action)(void const   * ,
                                                                  VISIT const    ,
                                                                  int const    , void * ) ,
                        void *arg , int level ) 
{ 


  {
#line 843
  if ((unsigned long )x == (unsigned long )(& rb_null)) {
#line 844
    return;
  }
#line 846
  if ((unsigned long )x->left == (unsigned long )(& rb_null)) {
#line 846
    if ((unsigned long )x->right == (unsigned long )(& rb_null)) {
      {
#line 849
      (*action)((void const   *)x->key, (VISIT const   )3, (int const   )level, arg);
      }
    } else {
      {
#line 853
      (*action)((void const   *)x->key, (VISIT const   )0, (int const   )level, arg);
#line 855
      rb_walk___0((struct rbnode  const  *)x->left, action, arg, level + 1);
#line 857
      (*action)((void const   *)x->key, (VISIT const   )1, (int const   )level, arg);
#line 859
      rb_walk___0((struct rbnode  const  *)x->right, action, arg, level + 1);
#line 861
      (*action)((void const   *)x->key, (VISIT const   )2, (int const   )level, arg);
      }
    }
  } else {
    {
#line 853
    (*action)((void const   *)x->key, (VISIT const   )0, (int const   )level, arg);
#line 855
    rb_walk___0((struct rbnode  const  *)x->left, action, arg, level + 1);
#line 857
    (*action)((void const   *)x->key, (VISIT const   )1, (int const   )level, arg);
#line 859
    rb_walk___0((struct rbnode  const  *)x->right, action, arg, level + 1);
#line 861
    (*action)((void const   *)x->key, (VISIT const   )2, (int const   )level, arg);
    }
  }
#line 863
  return;
}
}
#line 867 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rblists *rb_openlist___0(struct rbnode  const  *rootp ) 
{ 
  struct rblists *rblistp ;
  void *tmp ;

  {
  {
#line 872
  tmp = malloc(sizeof(struct rblists ));
#line 872
  rblistp = (struct rblists *)tmp;
  }
#line 873
  if (! rblistp) {
#line 874
    return ((struct rblists *)((void *)0));
  }
#line 876
  rblistp->rootp = rootp;
#line 877
  rblistp->nextp = rootp;
#line 879
  if ((unsigned long )rootp != (unsigned long )(& rb_null)) {
    {
#line 881
    while (1) {
      while_continue: /* CIL Label */ ;
#line 881
      if (! ((unsigned long )(rblistp->nextp)->left != (unsigned long )(& rb_null))) {
#line 881
        goto while_break;
      }
#line 883
      rblistp->nextp = (struct rbnode  const  *)(rblistp->nextp)->left;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 887
  return (rblistp);
}
}
#line 890 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void const   *rb_readlist___0(struct rblists *rblistp ) 
{ 
  void const   *key ;
  struct rbnode *tmp ;

  {
#line 893
  key = (void const   *)((void *)0);
#line 895
  if ((unsigned long )rblistp != (unsigned long )((void *)0)) {
#line 895
    if ((unsigned long )rblistp->nextp != (unsigned long )(& rb_null)) {
      {
#line 897
      key = (void const   *)(rblistp->nextp)->key;
#line 898
      tmp = rb_successor___0(rblistp->nextp);
#line 898
      rblistp->nextp = (struct rbnode  const  *)tmp;
      }
    }
  }
#line 901
  return (key);
}
}
#line 904 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_closelist___0(struct rblists *rblistp ) 
{ 


  {
#line 907
  if (rblistp) {
    {
#line 908
    free((void *)rblistp);
    }
  }
#line 909
  return;
}
}
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 432 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywatch.c"
static _Bool done  ;
#line 54
void handle_impatient_user(int signal___0  __attribute__((__unused__)) ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywatch.c"
static int times_called  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywatch.c"
void handle_impatient_user(int signal___0  __attribute__((__unused__)) ) 
{ 


  {
#line 55
  if (times_called) {
    {
#line 56
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No statistics collected, asked to abort before all watches could be established.\n");
#line 58
    exit(1);
    }
  }
  {
#line 60
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No statistics have been collected because I haven\'t finished establishing\ninotify watches yet.  If you are sure you want me to exit, interrupt me again.\n");
#line 64
  times_called ++;
  }
#line 65
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywatch.c"
void handle_signal(int signal___0  __attribute__((__unused__)) ) 
{ 


  {
#line 68
  done = (_Bool)1;
#line 69
  return;
}
}
#line 71
int print_info(void) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywatch.c"
void print_info_now(int signal___0  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 74
  print_info();
#line 75
  printf((char const   */* __restrict  */)"\n");
  }
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywatch.c"
int events  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywatch.c"
int sort  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywatch.c"
int zero  ;
#line 227 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywatch.c"
static char *new_file___0  ;
#line 252 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywatch.c"
static char *new_name___0  ;
#line 267 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/inotifywatch.c"
int print_info(void) 
{ 
  unsigned int num_watches ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  struct rbtree *tree ;
  struct rbtree *tmp___14 ;
  struct rblists *rblist ;
  struct rblists *tmp___15 ;
  watch *w ;
  void const   *tmp___16 ;
  void const   *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  void const   *tmp___31 ;

  {
  {
#line 268
  num_watches = 0U;
#line 269
  tmp = inotifytools_get_num_watches();
#line 269
  num_watches = (unsigned int )tmp;
#line 271
  tmp___0 = inotifytools_get_stat_total(0);
  }
#line 271
  if (! tmp___0) {
    {
#line 272
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No events occurred.\n");
    }
#line 273
    return (0);
  }
  {
#line 277
  printf((char const   */* __restrict  */)"total  ");
  }
#line 278
  if (1 & events) {
#line 278
    if (zero) {
      {
#line 280
      printf((char const   */* __restrict  */)"access  ");
      }
    } else {
      {
#line 278
      tmp___1 = inotifytools_get_stat_total(1);
      }
#line 278
      if (tmp___1) {
        {
#line 280
        printf((char const   */* __restrict  */)"access  ");
        }
      }
    }
  }
#line 281
  if (2 & events) {
#line 281
    if (zero) {
      {
#line 283
      printf((char const   */* __restrict  */)"modify  ");
      }
    } else {
      {
#line 281
      tmp___2 = inotifytools_get_stat_total(2);
      }
#line 281
      if (tmp___2) {
        {
#line 283
        printf((char const   */* __restrict  */)"modify  ");
        }
      }
    }
  }
#line 284
  if (4 & events) {
#line 284
    if (zero) {
      {
#line 286
      printf((char const   */* __restrict  */)"attrib  ");
      }
    } else {
      {
#line 284
      tmp___3 = inotifytools_get_stat_total(4);
      }
#line 284
      if (tmp___3) {
        {
#line 286
        printf((char const   */* __restrict  */)"attrib  ");
        }
      }
    }
  }
#line 287
  if (8 & events) {
#line 287
    if (zero) {
      {
#line 289
      printf((char const   */* __restrict  */)"close_write  ");
      }
    } else {
      {
#line 287
      tmp___4 = inotifytools_get_stat_total(8);
      }
#line 287
      if (tmp___4) {
        {
#line 289
        printf((char const   */* __restrict  */)"close_write  ");
        }
      }
    }
  }
#line 290
  if (16 & events) {
#line 290
    if (zero) {
      {
#line 292
      printf((char const   */* __restrict  */)"close_nowrite  ");
      }
    } else {
      {
#line 290
      tmp___5 = inotifytools_get_stat_total(16);
      }
#line 290
      if (tmp___5) {
        {
#line 292
        printf((char const   */* __restrict  */)"close_nowrite  ");
        }
      }
    }
  }
#line 293
  if (32 & events) {
#line 293
    if (zero) {
      {
#line 295
      printf((char const   */* __restrict  */)"open  ");
      }
    } else {
      {
#line 293
      tmp___6 = inotifytools_get_stat_total(32);
      }
#line 293
      if (tmp___6) {
        {
#line 295
        printf((char const   */* __restrict  */)"open  ");
        }
      }
    }
  }
#line 296
  if (64 & events) {
#line 296
    if (zero) {
      {
#line 298
      printf((char const   */* __restrict  */)"moved_from  ");
      }
    } else {
      {
#line 296
      tmp___7 = inotifytools_get_stat_total(64);
      }
#line 296
      if (tmp___7) {
        {
#line 298
        printf((char const   */* __restrict  */)"moved_from  ");
        }
      }
    }
  }
#line 299
  if (128 & events) {
#line 299
    if (zero) {
      {
#line 301
      printf((char const   */* __restrict  */)"moved_to  ");
      }
    } else {
      {
#line 299
      tmp___8 = inotifytools_get_stat_total(128);
      }
#line 299
      if (tmp___8) {
        {
#line 301
        printf((char const   */* __restrict  */)"moved_to  ");
        }
      }
    }
  }
#line 302
  if (2048 & events) {
#line 302
    if (zero) {
      {
#line 304
      printf((char const   */* __restrict  */)"move_self  ");
      }
    } else {
      {
#line 302
      tmp___9 = inotifytools_get_stat_total(2048);
      }
#line 302
      if (tmp___9) {
        {
#line 304
        printf((char const   */* __restrict  */)"move_self  ");
        }
      }
    }
  }
#line 305
  if (256 & events) {
#line 305
    if (zero) {
      {
#line 307
      printf((char const   */* __restrict  */)"create  ");
      }
    } else {
      {
#line 305
      tmp___10 = inotifytools_get_stat_total(256);
      }
#line 305
      if (tmp___10) {
        {
#line 307
        printf((char const   */* __restrict  */)"create  ");
        }
      }
    }
  }
#line 308
  if (512 & events) {
#line 308
    if (zero) {
      {
#line 310
      printf((char const   */* __restrict  */)"delete  ");
      }
    } else {
      {
#line 308
      tmp___11 = inotifytools_get_stat_total(512);
      }
#line 308
      if (tmp___11) {
        {
#line 310
        printf((char const   */* __restrict  */)"delete  ");
        }
      }
    }
  }
#line 311
  if (1024 & events) {
#line 311
    if (zero) {
      {
#line 313
      printf((char const   */* __restrict  */)"delete_self  ");
      }
    } else {
      {
#line 311
      tmp___12 = inotifytools_get_stat_total(1024);
      }
#line 311
      if (tmp___12) {
        {
#line 313
        printf((char const   */* __restrict  */)"delete_self  ");
        }
      }
    }
  }
#line 314
  if (8192 & events) {
#line 314
    if (zero) {
      {
#line 316
      printf((char const   */* __restrict  */)"unmount  ");
      }
    } else {
      {
#line 314
      tmp___13 = inotifytools_get_stat_total(8192);
      }
#line 314
      if (tmp___13) {
        {
#line 316
        printf((char const   */* __restrict  */)"unmount  ");
        }
      }
    }
  }
  {
#line 318
  printf((char const   */* __restrict  */)"filename\n");
#line 320
  tmp___14 = inotifytools_wd_sorted_by_event(sort);
#line 320
  tree = tmp___14;
#line 321
  tmp___15 = rbopenlist((struct rbtree  const  *)tree);
#line 321
  rblist = tmp___15;
#line 322
  tmp___16 = rbreadlist(rblist);
#line 322
  w = (watch *)tmp___16;
  }
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! w) {
#line 324
      goto while_break;
    }
#line 325
    if (! zero) {
#line 325
      if (! w->hit_total) {
        {
#line 326
        tmp___17 = rbreadlist(rblist);
#line 326
        w = (watch *)tmp___17;
        }
#line 327
        goto while_continue;
      }
    }
    {
#line 329
    printf((char const   */* __restrict  */)"%-5u  ", w->hit_total);
    }
#line 330
    if (1 & events) {
#line 330
      if (zero) {
        {
#line 332
        printf((char const   */* __restrict  */)"%-6u  ", w->hit_access);
        }
      } else {
        {
#line 330
        tmp___18 = inotifytools_get_stat_total(1);
        }
#line 330
        if (tmp___18) {
          {
#line 332
          printf((char const   */* __restrict  */)"%-6u  ", w->hit_access);
          }
        }
      }
    }
#line 333
    if (2 & events) {
#line 333
      if (zero) {
        {
#line 335
        printf((char const   */* __restrict  */)"%-6u  ", w->hit_modify);
        }
      } else {
        {
#line 333
        tmp___19 = inotifytools_get_stat_total(2);
        }
#line 333
        if (tmp___19) {
          {
#line 335
          printf((char const   */* __restrict  */)"%-6u  ", w->hit_modify);
          }
        }
      }
    }
#line 336
    if (4 & events) {
#line 336
      if (zero) {
        {
#line 338
        printf((char const   */* __restrict  */)"%-6u  ", w->hit_attrib);
        }
      } else {
        {
#line 336
        tmp___20 = inotifytools_get_stat_total(4);
        }
#line 336
        if (tmp___20) {
          {
#line 338
          printf((char const   */* __restrict  */)"%-6u  ", w->hit_attrib);
          }
        }
      }
    }
#line 339
    if (8 & events) {
#line 339
      if (zero) {
        {
#line 341
        printf((char const   */* __restrict  */)"%-11u  ", w->hit_close_write);
        }
      } else {
        {
#line 339
        tmp___21 = inotifytools_get_stat_total(8);
        }
#line 339
        if (tmp___21) {
          {
#line 341
          printf((char const   */* __restrict  */)"%-11u  ", w->hit_close_write);
          }
        }
      }
    }
#line 342
    if (16 & events) {
#line 342
      if (zero) {
        {
#line 344
        printf((char const   */* __restrict  */)"%-13u  ", w->hit_close_nowrite);
        }
      } else {
        {
#line 342
        tmp___22 = inotifytools_get_stat_total(16);
        }
#line 342
        if (tmp___22) {
          {
#line 344
          printf((char const   */* __restrict  */)"%-13u  ", w->hit_close_nowrite);
          }
        }
      }
    }
#line 345
    if (32 & events) {
#line 345
      if (zero) {
        {
#line 347
        printf((char const   */* __restrict  */)"%-4u  ", w->hit_open);
        }
      } else {
        {
#line 345
        tmp___23 = inotifytools_get_stat_total(32);
        }
#line 345
        if (tmp___23) {
          {
#line 347
          printf((char const   */* __restrict  */)"%-4u  ", w->hit_open);
          }
        }
      }
    }
#line 348
    if (64 & events) {
#line 348
      if (zero) {
        {
#line 350
        printf((char const   */* __restrict  */)"%-10u  ", w->hit_moved_from);
        }
      } else {
        {
#line 348
        tmp___24 = inotifytools_get_stat_total(64);
        }
#line 348
        if (tmp___24) {
          {
#line 350
          printf((char const   */* __restrict  */)"%-10u  ", w->hit_moved_from);
          }
        }
      }
    }
#line 351
    if (128 & events) {
#line 351
      if (zero) {
        {
#line 353
        printf((char const   */* __restrict  */)"%-8u  ", w->hit_moved_to);
        }
      } else {
        {
#line 351
        tmp___25 = inotifytools_get_stat_total(128);
        }
#line 351
        if (tmp___25) {
          {
#line 353
          printf((char const   */* __restrict  */)"%-8u  ", w->hit_moved_to);
          }
        }
      }
    }
#line 354
    if (2048 & events) {
#line 354
      if (zero) {
        {
#line 356
        printf((char const   */* __restrict  */)"%-9u  ", w->hit_move_self);
        }
      } else {
        {
#line 354
        tmp___26 = inotifytools_get_stat_total(2048);
        }
#line 354
        if (tmp___26) {
          {
#line 356
          printf((char const   */* __restrict  */)"%-9u  ", w->hit_move_self);
          }
        }
      }
    }
#line 357
    if (256 & events) {
#line 357
      if (zero) {
        {
#line 359
        printf((char const   */* __restrict  */)"%-6u  ", w->hit_create);
        }
      } else {
        {
#line 357
        tmp___27 = inotifytools_get_stat_total(256);
        }
#line 357
        if (tmp___27) {
          {
#line 359
          printf((char const   */* __restrict  */)"%-6u  ", w->hit_create);
          }
        }
      }
    }
#line 360
    if (512 & events) {
#line 360
      if (zero) {
        {
#line 362
        printf((char const   */* __restrict  */)"%-6u  ", w->hit_delete);
        }
      } else {
        {
#line 360
        tmp___28 = inotifytools_get_stat_total(512);
        }
#line 360
        if (tmp___28) {
          {
#line 362
          printf((char const   */* __restrict  */)"%-6u  ", w->hit_delete);
          }
        }
      }
    }
#line 363
    if (1024 & events) {
#line 363
      if (zero) {
        {
#line 365
        printf((char const   */* __restrict  */)"%-11u  ", w->hit_delete_self);
        }
      } else {
        {
#line 363
        tmp___29 = inotifytools_get_stat_total(1024);
        }
#line 363
        if (tmp___29) {
          {
#line 365
          printf((char const   */* __restrict  */)"%-11u  ", w->hit_delete_self);
          }
        }
      }
    }
#line 366
    if (8192 & events) {
#line 366
      if (zero) {
        {
#line 368
        printf((char const   */* __restrict  */)"%-7u  ", w->hit_unmount);
        }
      } else {
        {
#line 366
        tmp___30 = inotifytools_get_stat_total(8192);
        }
#line 366
        if (tmp___30) {
          {
#line 368
          printf((char const   */* __restrict  */)"%-7u  ", w->hit_unmount);
          }
        }
      }
    }
    {
#line 370
    printf((char const   */* __restrict  */)"%s\n", w->filename);
#line 371
    tmp___31 = rbreadlist(rblist);
#line 371
    w = (watch *)tmp___31;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 373
  rbcloselist(rblist);
#line 374
  rbdestroy(tree);
  }
#line 376
  return (0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/src/common.c"
static struct stat64 my_stat___4  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int inotify_fd___1  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_access___1  ;
#line 131 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_modify___1  ;
#line 132 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_attrib___1  ;
#line 133 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_close_nowrite___1  ;
#line 134 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_close_write___1  ;
#line 135 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_open___1  ;
#line 136 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_move_self___1  ;
#line 137 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_moved_to___1  ;
#line 138 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_moved_from___1  ;
#line 139 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_create___1  ;
#line 140 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_delete___1  ;
#line 141 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_delete_self___1  ;
#line 142 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_unmount___1  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int num_total___1  ;
#line 144 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int collect_stats___1  =    0;
#line 148 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int error___1  =    0;
#line 149 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int init___1  =    0;
#line 150 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char *timefmt___1  =    (char *)0;
#line 151 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static regex_t *regex___1  =    (regex_t *)0;
#line 219 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char str___1[2]  = {      (char )'\000',      (char )'\000'};
#line 558 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int ret___7  ;
#line 658 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char ret___8[1024]  ;
#line 956 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char const   *filenames___1[2]  ;
#line 981 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int i___4  ;
#line 983 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int wd___1  ;
#line 1100 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct inotify_event event___1[4096]  ;
#line 1101 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct inotify_event *ret___9  ;
#line 1102 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int first_byte___1  =    0;
#line 1103 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static ssize_t bytes___1  ;
#line 1104 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static jmp_buf jmp___1  ;
#line 1105 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char match_name___1[4096]  ;
#line 1161 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static ssize_t this_bytes___1  ;
#line 1162 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int bytes_to_read___1  ;
#line 1163 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int rc___1  ;
#line 1164 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static fd_set read_fds___1  ;
#line 1166 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct timeval read_timeout___1  ;
#line 1169 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct timeval *read_timeout_ptr___1  ;
#line 1310 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct dirent *ent___1  ;
#line 1312 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct stat64 my_stat___5  ;
#line 1333 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int no_watch___1  ;
#line 1334 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char const   **exclude_entry___1  ;
#line 1340 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int exclude_length___1  ;
#line 1353 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int status___1  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static struct stat64 my_stat___6  ;
#line 1708 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char out___1[4097]  ;
#line 1709 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static int ret___10  ;
#line 1818 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char *filename___1  ;
#line 1818 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char *eventname___1  ;
#line 1818 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char *eventstr___1  ;
#line 1819 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int i___5  ;
#line 1819 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static unsigned int ind___2  ;
#line 1820 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char ch1___1  ;
#line 1821 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static char timestr___1[4096]  ;
#line 1822 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/inotifytools.c"
static time_t now___1  ;
#line 1 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static char rcsid___1[53]  = 
#line 1 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'r',      (char )'e',      (char )'d', 
        (char )'b',      (char )'l',      (char )'a',      (char )'c', 
        (char )'k',      (char )'.',      (char )'c',      (char )',', 
        (char )'v',      (char )' ',      (char )'1',      (char )'.', 
        (char )'9',      (char )' ',      (char )'2',      (char )'0', 
        (char )'0',      (char )'3',      (char )'/',      (char )'1', 
        (char )'0',      (char )'/',      (char )'2',      (char )'4', 
        (char )' ',      (char )'0',      (char )'1',      (char )':', 
        (char )'3',      (char )'1',      (char )':',      (char )'2', 
        (char )'1',      (char )' ',      (char )'d',      (char )'a', 
        (char )'m',      (char )'o',      (char )' ',      (char )'E', 
        (char )'x',      (char )'p',      (char )' ',      (char )'$', 
        (char )'\000'};
#line 76 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rbnode *rb_alloc___1(void) 
{ 
  void *tmp ;

  {
  {
#line 76
  tmp = malloc(sizeof(struct rbnode ));
  }
#line 76
  return ((struct rbnode *)tmp);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_free___1(struct rbnode *x ) 
{ 


  {
  {
#line 77
  free((void *)x);
  }
#line 77
  return;
}
}
#line 82
static void rb_left_rotate___1(struct rbnode **rootp , struct rbnode *x ) ;
#line 83
static void rb_right_rotate___1(struct rbnode **rootp , struct rbnode *y ) ;
#line 84
static struct rbnode *rb_successor___1(struct rbnode  const  *x ) ;
#line 85
static struct rbnode *rb_predecessor___1(struct rbnode  const  *x ) ;
#line 86
static struct rbnode *rb_traverse___1(int insert , void const   *key , struct rbtree *rbinfo ) ;
#line 90
static struct rbnode *rb_lookup___1(int mode , void const   *key , struct rbtree *rbinfo ) ;
#line 94
static void rb_destroy___1(struct rbnode *x ) ;
#line 98
static void rb_delete___1(struct rbnode **rootp , struct rbnode *z ) ;
#line 99
static void rb_delete_fix___1(struct rbnode **rootp , struct rbnode *x ) ;
#line 103
static void rb_walk___1(struct rbnode  const  *x , void (*action)(void const   * ,
                                                                  VISIT const    ,
                                                                  int const    , void * ) ,
                        void *arg , int level ) ;
#line 107
static struct rblists *rb_openlist___1(struct rbnode  const  *rootp ) ;
#line 108
static void const   *rb_readlist___1(struct rblists *rblistp ) ;
#line 109
static void rb_closelist___1(struct rblists *rblistp ) ;
#line 294 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rbnode *rb_traverse___1(int insert , void const   *key , struct rbtree *rbinfo ) 
{ 
  struct rbnode *x ;
  struct rbnode *y ;
  struct rbnode *z ;
  int cmp ;
  int found ;

  {
#line 299
  found = 0;
#line 302
  y = & rb_null;
#line 303
  x = rbinfo->rb_root;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if ((unsigned long )x != (unsigned long )(& rb_null)) {
#line 306
      if (! (found == 0)) {
#line 306
        goto while_break;
      }
    } else {
#line 306
      goto while_break;
    }
    {
#line 308
    y = x;
#line 311
    cmp = (*(rbinfo->rb_cmp))(key, x->key, rbinfo->rb_config);
    }
#line 316
    if (cmp < 0) {
#line 317
      x = x->left;
    } else
#line 318
    if (cmp > 0) {
#line 319
      x = x->right;
    } else {
#line 321
      found = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  if (found) {
#line 325
    return (x);
  } else
#line 324
  if (! insert) {
#line 325
    return (x);
  }
  {
#line 327
  z = rb_alloc___1();
  }
#line 327
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 330
    return (& rb_null);
  }
#line 333
  z->key = key;
#line 334
  z->up = y;
#line 335
  if ((unsigned long )y == (unsigned long )(& rb_null)) {
#line 337
    rbinfo->rb_root = z;
  } else {
    {
#line 342
    cmp = (*(rbinfo->rb_cmp))(z->key, y->key, rbinfo->rb_config);
    }
#line 346
    if (cmp < 0) {
#line 347
      y->left = z;
    } else {
#line 349
      y->right = z;
    }
  }
#line 352
  z->left = & rb_null;
#line 353
  z->right = & rb_null;
#line 356
  z->colour = (enum nodecolour )1;
#line 361
  x = z;
  {
#line 368
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 368
    if ((unsigned long )x != (unsigned long )rbinfo->rb_root) {
#line 368
      if (! ((unsigned int )(x->up)->colour == 1U)) {
#line 368
        goto while_break___0;
      }
    } else {
#line 368
      goto while_break___0;
    }
#line 371
    if ((unsigned long )x->up == (unsigned long )((x->up)->up)->left) {
#line 374
      y = ((x->up)->up)->right;
#line 375
      if ((unsigned int )y->colour == 1U) {
#line 378
        (x->up)->colour = (enum nodecolour )0;
#line 380
        y->colour = (enum nodecolour )0;
#line 382
        ((x->up)->up)->colour = (enum nodecolour )1;
#line 385
        x = (x->up)->up;
      } else {
#line 390
        if ((unsigned long )x == (unsigned long )(x->up)->right) {
          {
#line 393
          x = x->up;
#line 394
          rb_left_rotate___1(& rbinfo->rb_root, x);
          }
        }
        {
#line 398
        (x->up)->colour = (enum nodecolour )0;
#line 400
        ((x->up)->up)->colour = (enum nodecolour )1;
#line 402
        rb_right_rotate___1(& rbinfo->rb_root, (x->up)->up);
        }
      }
    } else {
#line 411
      y = ((x->up)->up)->left;
#line 412
      if ((unsigned int )y->colour == 1U) {
#line 414
        (x->up)->colour = (enum nodecolour )0;
#line 415
        y->colour = (enum nodecolour )0;
#line 416
        ((x->up)->up)->colour = (enum nodecolour )1;
#line 418
        x = (x->up)->up;
      } else {
#line 422
        if ((unsigned long )x == (unsigned long )(x->up)->left) {
          {
#line 424
          x = x->up;
#line 425
          rb_right_rotate___1(& rbinfo->rb_root, x);
          }
        }
        {
#line 428
        (x->up)->colour = (enum nodecolour )0;
#line 429
        ((x->up)->up)->colour = (enum nodecolour )1;
#line 430
        rb_left_rotate___1(& rbinfo->rb_root, (x->up)->up);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 436
  (rbinfo->rb_root)->colour = (enum nodecolour )0;
#line 438
  return (z);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rbnode *rb_lookup___1(int mode , void const   *key , struct rbtree *rbinfo ) 
{ 
  struct rbnode *x ;
  struct rbnode *y ;
  int cmp ;
  int found ;
  struct rbnode *tmp ;
  struct rbnode *tmp___0 ;
  struct rbnode *tmp___1 ;
  struct rbnode *tmp___2 ;

  {
#line 449
  found = 0;
#line 451
  y = & rb_null;
#line 452
  x = rbinfo->rb_root;
#line 454
  if (mode == 7) {
    {
#line 457
    while (1) {
      while_continue: /* CIL Label */ ;
#line 457
      if (! ((unsigned long )x != (unsigned long )(& rb_null))) {
#line 457
        goto while_break;
      }
#line 459
      y = x;
#line 460
      x = x->left;
    }
    while_break: /* CIL Label */ ;
    }
#line 463
    return (y);
  } else
#line 465
  if (mode == 8) {
    {
#line 468
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 468
      if (! ((unsigned long )x != (unsigned long )(& rb_null))) {
#line 468
        goto while_break___0;
      }
#line 470
      y = x;
#line 471
      x = x->right;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 474
    return (y);
  }
  {
#line 478
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 478
    if ((unsigned long )x != (unsigned long )(& rb_null)) {
#line 478
      if (! (found == 0)) {
#line 478
        goto while_break___1;
      }
    } else {
#line 478
      goto while_break___1;
    }
    {
#line 480
    y = x;
#line 483
    cmp = (*(rbinfo->rb_cmp))(key, x->key, rbinfo->rb_config);
    }
#line 489
    if (cmp < 0) {
#line 490
      x = x->left;
    } else
#line 491
    if (cmp > 0) {
#line 492
      x = x->right;
    } else {
#line 494
      found = 1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 497
  if (found) {
#line 497
    if (mode == 0) {
#line 498
      return (x);
    } else
#line 497
    if (mode == 1) {
#line 498
      return (x);
    } else
#line 497
    if (mode == 2) {
#line 498
      return (x);
    }
  }
#line 500
  if (! found) {
#line 500
    if (mode == 0) {
#line 501
      return (& rb_null);
    } else
#line 500
    if (mode == 5) {
#line 501
      return (& rb_null);
    } else
#line 500
    if (mode == 6) {
#line 501
      return (& rb_null);
    }
  }
#line 503
  if (mode == 1) {
#line 503
    goto _L;
  } else
#line 503
  if (! found) {
#line 503
    if (mode == 4) {
      _L: /* CIL Label */ 
#line 505
      if (cmp > 0) {
        {
#line 506
        tmp = rb_successor___1((struct rbnode  const  *)y);
        }
#line 506
        return (tmp);
      } else {
#line 508
        return (y);
      }
    }
  }
#line 511
  if (mode == 2) {
#line 511
    goto _L___0;
  } else
#line 511
  if (! found) {
#line 511
    if (mode == 3) {
      _L___0: /* CIL Label */ 
#line 513
      if (cmp < 0) {
        {
#line 514
        tmp___0 = rb_predecessor___1((struct rbnode  const  *)y);
        }
#line 514
        return (tmp___0);
      } else {
#line 516
        return (y);
      }
    }
  }
#line 519
  if (mode == 5) {
    {
#line 520
    tmp___1 = rb_successor___1((struct rbnode  const  *)x);
    }
#line 520
    return (tmp___1);
  } else
#line 519
  if (found) {
#line 519
    if (mode == 4) {
      {
#line 520
      tmp___1 = rb_successor___1((struct rbnode  const  *)x);
      }
#line 520
      return (tmp___1);
    }
  }
#line 522
  if (mode == 6) {
    {
#line 523
    tmp___2 = rb_predecessor___1((struct rbnode  const  *)x);
    }
#line 523
    return (tmp___2);
  } else
#line 522
  if (found) {
#line 522
    if (mode == 3) {
      {
#line 523
      tmp___2 = rb_predecessor___1((struct rbnode  const  *)x);
      }
#line 523
      return (tmp___2);
    }
  }
#line 526
  return (& rb_null);
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_destroy___1(struct rbnode *x ) 
{ 


  {
#line 538
  if ((unsigned long )x != (unsigned long )(& rb_null)) {
#line 540
    if ((unsigned long )x->left != (unsigned long )(& rb_null)) {
      {
#line 541
      rb_destroy___1(x->left);
      }
    }
#line 542
    if ((unsigned long )x->right != (unsigned long )(& rb_null)) {
      {
#line 543
      rb_destroy___1(x->right);
      }
    }
    {
#line 544
    rb_free___1(x);
    }
  }
#line 546
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_left_rotate___1(struct rbnode **rootp , struct rbnode *x ) 
{ 
  struct rbnode *y ;

  {
#line 571
  y = x->right;
#line 574
  x->right = y->left;
#line 577
  if ((unsigned long )y->left != (unsigned long )(& rb_null)) {
#line 578
    (y->left)->up = x;
  }
#line 581
  y->up = x->up;
#line 584
  if ((unsigned long )x->up == (unsigned long )(& rb_null)) {
#line 586
    *rootp = y;
  } else
#line 591
  if ((unsigned long )x == (unsigned long )(x->up)->left) {
#line 593
    (x->up)->left = y;
  } else {
#line 597
    (x->up)->right = y;
  }
#line 602
  y->left = x;
#line 605
  x->up = y;
#line 606
  return;
}
}
#line 608 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_right_rotate___1(struct rbnode **rootp , struct rbnode *y ) 
{ 
  struct rbnode *x ;

  {
#line 616
  x = y->left;
#line 619
  y->left = x->right;
#line 622
  if ((unsigned long )x->right != (unsigned long )(& rb_null)) {
#line 623
    (x->right)->up = y;
  }
#line 626
  x->up = y->up;
#line 629
  if ((unsigned long )y->up == (unsigned long )(& rb_null)) {
#line 631
    *rootp = x;
  } else
#line 636
  if ((unsigned long )y == (unsigned long )(y->up)->left) {
#line 638
    (y->up)->left = x;
  } else {
#line 642
    (y->up)->right = x;
  }
#line 647
  x->right = y;
#line 650
  y->up = x;
#line 651
  return;
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rbnode *rb_successor___1(struct rbnode  const  *x ) 
{ 
  struct rbnode *y ;

  {
#line 660
  if ((unsigned long )x->right != (unsigned long )(& rb_null)) {
#line 666
    y = (struct rbnode *)x->right;
    {
#line 666
    while (1) {
      while_continue: /* CIL Label */ ;
#line 666
      if (! ((unsigned long )y->left != (unsigned long )(& rb_null))) {
#line 666
        goto while_break;
      }
#line 666
      y = y->left;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 674
    y = (struct rbnode *)x->up;
    {
#line 675
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 675
      if ((unsigned long )y != (unsigned long )(& rb_null)) {
#line 675
        if (! ((unsigned long )x == (unsigned long )y->right)) {
#line 675
          goto while_break___0;
        }
      } else {
#line 675
        goto while_break___0;
      }
#line 677
      x = (struct rbnode  const  *)y;
#line 678
      y = y->up;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 681
  return (y);
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rbnode *rb_predecessor___1(struct rbnode  const  *x ) 
{ 
  struct rbnode *y ;

  {
#line 691
  if ((unsigned long )x->left != (unsigned long )(& rb_null)) {
#line 697
    y = (struct rbnode *)x->left;
    {
#line 697
    while (1) {
      while_continue: /* CIL Label */ ;
#line 697
      if (! ((unsigned long )y->right != (unsigned long )(& rb_null))) {
#line 697
        goto while_break;
      }
#line 697
      y = y->right;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 705
    y = (struct rbnode *)x->up;
    {
#line 706
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 706
      if ((unsigned long )y != (unsigned long )(& rb_null)) {
#line 706
        if (! ((unsigned long )x == (unsigned long )y->left)) {
#line 706
          goto while_break___0;
        }
      } else {
#line 706
        goto while_break___0;
      }
#line 708
      x = (struct rbnode  const  *)y;
#line 709
      y = y->up;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 712
  return (y);
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_delete___1(struct rbnode **rootp , struct rbnode *z ) 
{ 
  struct rbnode *x ;
  struct rbnode *y ;

  {
#line 723
  if ((unsigned long )z->left == (unsigned long )(& rb_null)) {
#line 724
    y = z;
  } else
#line 723
  if ((unsigned long )z->right == (unsigned long )(& rb_null)) {
#line 724
    y = z;
  } else {
    {
#line 726
    y = rb_successor___1((struct rbnode  const  *)z);
    }
  }
#line 728
  if ((unsigned long )y->left != (unsigned long )(& rb_null)) {
#line 729
    x = y->left;
  } else {
#line 731
    x = y->right;
  }
#line 733
  x->up = y->up;
#line 735
  if ((unsigned long )y->up == (unsigned long )(& rb_null)) {
#line 737
    *rootp = x;
  } else
#line 741
  if ((unsigned long )y == (unsigned long )(y->up)->left) {
#line 742
    (y->up)->left = x;
  } else {
#line 744
    (y->up)->right = x;
  }
#line 747
  if ((unsigned long )y != (unsigned long )z) {
#line 749
    z->key = y->key;
  }
#line 752
  if ((unsigned int )y->colour == 0U) {
    {
#line 753
    rb_delete_fix___1(rootp, x);
    }
  }
  {
#line 755
  rb_free___1(y);
  }
#line 756
  return;
}
}
#line 759 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_delete_fix___1(struct rbnode **rootp , struct rbnode *x ) 
{ 
  struct rbnode *w ;

  {
  {
#line 764
  while (1) {
    while_continue: /* CIL Label */ ;
#line 764
    if ((unsigned long )x != (unsigned long )*rootp) {
#line 764
      if (! ((unsigned int )x->colour == 0U)) {
#line 764
        goto while_break;
      }
    } else {
#line 764
      goto while_break;
    }
#line 766
    if ((unsigned long )x == (unsigned long )(x->up)->left) {
#line 768
      w = (x->up)->right;
#line 769
      if ((unsigned int )w->colour == 1U) {
        {
#line 771
        w->colour = (enum nodecolour )0;
#line 772
        (x->up)->colour = (enum nodecolour )1;
#line 773
        rb_left_rotate___1(rootp, x->up);
#line 774
        w = (x->up)->right;
        }
      }
#line 777
      if ((unsigned int )(w->left)->colour == 0U) {
#line 777
        if ((unsigned int )(w->right)->colour == 0U) {
#line 779
          w->colour = (enum nodecolour )1;
#line 780
          x = x->up;
        } else {
#line 777
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 784
        if ((unsigned int )(w->right)->colour == 0U) {
          {
#line 786
          (w->left)->colour = (enum nodecolour )0;
#line 787
          w->colour = (enum nodecolour )1;
#line 788
          rb_right_rotate___1(rootp, w);
#line 789
          w = (x->up)->right;
          }
        }
        {
#line 793
        w->colour = (x->up)->colour;
#line 794
        (x->up)->colour = (enum nodecolour )0;
#line 795
        (w->right)->colour = (enum nodecolour )0;
#line 796
        rb_left_rotate___1(rootp, x->up);
#line 797
        x = *rootp;
        }
      }
    } else {
#line 802
      w = (x->up)->left;
#line 803
      if ((unsigned int )w->colour == 1U) {
        {
#line 805
        w->colour = (enum nodecolour )0;
#line 806
        (x->up)->colour = (enum nodecolour )1;
#line 807
        rb_right_rotate___1(rootp, x->up);
#line 808
        w = (x->up)->left;
        }
      }
#line 811
      if ((unsigned int )(w->right)->colour == 0U) {
#line 811
        if ((unsigned int )(w->left)->colour == 0U) {
#line 813
          w->colour = (enum nodecolour )1;
#line 814
          x = x->up;
        } else {
#line 811
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 818
        if ((unsigned int )(w->left)->colour == 0U) {
          {
#line 820
          (w->right)->colour = (enum nodecolour )0;
#line 821
          w->colour = (enum nodecolour )1;
#line 822
          rb_left_rotate___1(rootp, w);
#line 823
          w = (x->up)->left;
          }
        }
        {
#line 826
        w->colour = (x->up)->colour;
#line 827
        (x->up)->colour = (enum nodecolour )0;
#line 828
        (w->left)->colour = (enum nodecolour )0;
#line 829
        rb_right_rotate___1(rootp, x->up);
#line 830
        x = *rootp;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 835
  x->colour = (enum nodecolour )0;
#line 836
  return;
}
}
#line 840 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_walk___1(struct rbnode  const  *x , void (*action)(void const   * ,
                                                                  VISIT const    ,
                                                                  int const    , void * ) ,
                        void *arg , int level ) 
{ 


  {
#line 843
  if ((unsigned long )x == (unsigned long )(& rb_null)) {
#line 844
    return;
  }
#line 846
  if ((unsigned long )x->left == (unsigned long )(& rb_null)) {
#line 846
    if ((unsigned long )x->right == (unsigned long )(& rb_null)) {
      {
#line 849
      (*action)((void const   *)x->key, (VISIT const   )3, (int const   )level, arg);
      }
    } else {
      {
#line 853
      (*action)((void const   *)x->key, (VISIT const   )0, (int const   )level, arg);
#line 855
      rb_walk___1((struct rbnode  const  *)x->left, action, arg, level + 1);
#line 857
      (*action)((void const   *)x->key, (VISIT const   )1, (int const   )level, arg);
#line 859
      rb_walk___1((struct rbnode  const  *)x->right, action, arg, level + 1);
#line 861
      (*action)((void const   *)x->key, (VISIT const   )2, (int const   )level, arg);
      }
    }
  } else {
    {
#line 853
    (*action)((void const   *)x->key, (VISIT const   )0, (int const   )level, arg);
#line 855
    rb_walk___1((struct rbnode  const  *)x->left, action, arg, level + 1);
#line 857
    (*action)((void const   *)x->key, (VISIT const   )1, (int const   )level, arg);
#line 859
    rb_walk___1((struct rbnode  const  *)x->right, action, arg, level + 1);
#line 861
    (*action)((void const   *)x->key, (VISIT const   )2, (int const   )level, arg);
    }
  }
#line 863
  return;
}
}
#line 867 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static struct rblists *rb_openlist___1(struct rbnode  const  *rootp ) 
{ 
  struct rblists *rblistp ;
  void *tmp ;

  {
  {
#line 872
  tmp = malloc(sizeof(struct rblists ));
#line 872
  rblistp = (struct rblists *)tmp;
  }
#line 873
  if (! rblistp) {
#line 874
    return ((struct rblists *)((void *)0));
  }
#line 876
  rblistp->rootp = rootp;
#line 877
  rblistp->nextp = rootp;
#line 879
  if ((unsigned long )rootp != (unsigned long )(& rb_null)) {
    {
#line 881
    while (1) {
      while_continue: /* CIL Label */ ;
#line 881
      if (! ((unsigned long )(rblistp->nextp)->left != (unsigned long )(& rb_null))) {
#line 881
        goto while_break;
      }
#line 883
      rblistp->nextp = (struct rbnode  const  *)(rblistp->nextp)->left;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 887
  return (rblistp);
}
}
#line 890 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void const   *rb_readlist___1(struct rblists *rblistp ) 
{ 
  void const   *key ;
  struct rbnode *tmp ;

  {
#line 893
  key = (void const   *)((void *)0);
#line 895
  if ((unsigned long )rblistp != (unsigned long )((void *)0)) {
#line 895
    if ((unsigned long )rblistp->nextp != (unsigned long )(& rb_null)) {
      {
#line 897
      key = (void const   *)(rblistp->nextp)->key;
#line 898
      tmp = rb_successor___1(rblistp->nextp);
#line 898
      rblistp->nextp = (struct rbnode  const  *)tmp;
      }
    }
  }
#line 901
  return (key);
}
}
#line 904 "/home/june/repo/benchmarks/collector/temp/inotify-tools-3.14/libinotifytools/src/redblack.c"
static void rb_closelist___1(struct rblists *rblistp ) 
{ 


  {
#line 907
  if (rblistp) {
    {
#line 908
    free((void *)rblistp);
    }
  }
#line 909
  return;
}
}
