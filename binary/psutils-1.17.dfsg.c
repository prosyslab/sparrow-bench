/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 92 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 19 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.h"
struct papersize {
   char *name ;
   int width ;
   int height ;
};
#line 19 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.h"
typedef struct papersize Paper;
#line 35 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psselect.c"
struct pgrange {
   int first ;
   int last ;
   struct pgrange *next ;
};
#line 35 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psselect.c"
typedef struct pgrange PageRange;
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 8 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/pserror.c"
char *program ;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 20 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/pserror.h"
void message(int flags , char *format  , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 27 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/pserror.c"
static int column  =    0;
#line 24 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/pserror.c"
void message(int flags , char *format  , ...) 
{ 
  va_list args ;
  char msgbuf[256] ;
  char *bufptr ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char c ;
  int done ;
  int longform ;
  int index___0 ;
  char fmtbuf[16] ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  double d ;
  double tmp___7 ;
  size_t tmp___8 ;
  long l ;
  long tmp___10 ;
  int i ;
  int tmp___12 ;
  size_t tmp___13 ;
  char *s ;
  char *tmp___15 ;
  size_t tmp___16 ;
  int len ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int len___0 ;

  {
#line 29
  bufptr = msgbuf;
#line 31
  if (flags & 1) {
#line 31
    if (column != 0) {
      {
#line 32
      _IO_putc('\n', stderr);
#line 33
      column = 0;
      }
    }
  }
#line 36
  if (flags & 2) {
    {
#line 37
    strcpy((char */* __restrict  */)bufptr, (char const   */* __restrict  */)program);
#line 38
    tmp = strlen((char const   *)program);
#line 38
    bufptr += tmp;
#line 39
    tmp___0 = bufptr;
#line 39
    bufptr ++;
#line 39
    *tmp___0 = (char )':';
#line 40
    tmp___1 = bufptr;
#line 40
    bufptr ++;
#line 40
    *tmp___1 = (char )' ';
    }
  }
  {
#line 43
  __builtin_va_start(args, format);
  }
#line 44
  if ((unsigned long )format != (unsigned long )((void *)0)) {
    {
#line 46
    while (1) {
      while_continue: /* CIL Label */ ;
#line 46
      tmp___19 = format;
#line 46
      format ++;
#line 46
      c = *tmp___19;
#line 46
      if (! ((int )c != 0)) {
#line 46
        goto while_break;
      }
#line 47
      if ((int )c == 37) {
#line 50
        index___0 = 0;
#line 50
        longform = index___0;
#line 51
        tmp___2 = index___0;
#line 51
        index___0 ++;
#line 51
        fmtbuf[tmp___2] = c;
        {
#line 52
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 53
          done = 1;
#line 54
          tmp___3 = index___0;
#line 54
          index___0 ++;
#line 54
          tmp___4 = format;
#line 54
          format ++;
#line 54
          c = *tmp___4;
#line 54
          fmtbuf[tmp___3] = c;
#line 55
          fmtbuf[index___0] = (char )'\000';
          {
#line 57
          if ((int )c == 37) {
#line 57
            goto case_37;
          }
#line 59
          if ((int )c == 0) {
#line 59
            goto case_0;
          }
#line 61
          if ((int )c == 71) {
#line 61
            goto case_71;
          }
#line 61
          if ((int )c == 103) {
#line 61
            goto case_71;
          }
#line 61
          if ((int )c == 102) {
#line 61
            goto case_71;
          }
#line 61
          if ((int )c == 69) {
#line 61
            goto case_71;
          }
#line 61
          if ((int )c == 101) {
#line 61
            goto case_71;
          }
#line 69
          if ((int )c == 88) {
#line 69
            goto case_88;
          }
#line 69
          if ((int )c == 120) {
#line 69
            goto case_88;
          }
#line 69
          if ((int )c == 117) {
#line 69
            goto case_88;
          }
#line 69
          if ((int )c == 112) {
#line 69
            goto case_88;
          }
#line 69
          if ((int )c == 111) {
#line 69
            goto case_88;
          }
#line 69
          if ((int )c == 105) {
#line 69
            goto case_88;
          }
#line 69
          if ((int )c == 100) {
#line 69
            goto case_88;
          }
#line 69
          if ((int )c == 99) {
#line 69
            goto case_88;
          }
#line 79
          if ((int )c == 115) {
#line 79
            goto case_115;
          }
#line 86
          if ((int )c == 108) {
#line 86
            goto case_108;
          }
#line 89
          goto switch_default;
          case_37: /* CIL Label */ 
#line 58
          tmp___5 = bufptr;
#line 58
          bufptr ++;
#line 58
          *tmp___5 = (char )'%';
          case_0: /* CIL Label */ 
#line 60
          goto switch_break;
          case_71: /* CIL Label */ 
          case_103: /* CIL Label */ 
          case_102: /* CIL Label */ 
          case_69: /* CIL Label */ 
          case_101: /* CIL Label */ 
          {
#line 63
          tmp___7 = __builtin_va_arg(args, double );
#line 63
          d = tmp___7;
#line 64
          sprintf((char */* __restrict  */)bufptr, (char const   */* __restrict  */)(fmtbuf),
                  d);
#line 65
          tmp___8 = strlen((char const   *)bufptr);
#line 65
          bufptr += tmp___8;
          }
#line 67
          goto switch_break;
          case_88: /* CIL Label */ 
          case_120: /* CIL Label */ 
          case_117: /* CIL Label */ 
          case_112: /* CIL Label */ 
          case_111: /* CIL Label */ 
          case_105: /* CIL Label */ 
          case_100: /* CIL Label */ 
          case_99: /* CIL Label */ 
#line 70
          if (longform) {
            {
#line 71
            tmp___10 = __builtin_va_arg(args, long );
#line 71
            l = tmp___10;
#line 72
            sprintf((char */* __restrict  */)bufptr, (char const   */* __restrict  */)(fmtbuf),
                    l);
            }
          } else {
            {
#line 74
            tmp___12 = __builtin_va_arg(args, int );
#line 74
            i = tmp___12;
#line 75
            sprintf((char */* __restrict  */)bufptr, (char const   */* __restrict  */)(fmtbuf),
                    i);
            }
          }
          {
#line 77
          tmp___13 = strlen((char const   *)bufptr);
#line 77
          bufptr += tmp___13;
          }
#line 78
          goto switch_break;
          case_115: /* CIL Label */ 
          {
#line 81
          tmp___15 = __builtin_va_arg(args, char *);
#line 81
          s = tmp___15;
#line 82
          sprintf((char */* __restrict  */)bufptr, (char const   */* __restrict  */)(fmtbuf),
                  s);
#line 83
          tmp___16 = strlen((char const   *)bufptr);
#line 83
          bufptr += tmp___16;
          }
#line 85
          goto switch_break;
          case_108: /* CIL Label */ 
#line 87
          longform = 1;
          switch_default: /* CIL Label */ 
#line 90
          done = 0;
          switch_break: /* CIL Label */ ;
          }
#line 52
          if (! (! done)) {
#line 52
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 93
      if ((int )c == 10) {
#line 94
        len = (int )(bufptr - msgbuf);
#line 95
        tmp___17 = bufptr;
#line 95
        bufptr ++;
#line 95
        *tmp___17 = (char )'\n';
#line 96
        *bufptr = (char )'\000';
#line 97
        if (column + len > 78) {
#line 97
          if (column > 0) {
            {
#line 98
            _IO_putc('\n', stderr);
#line 99
            column = 0;
            }
          }
        }
        {
#line 101
        bufptr = msgbuf;
#line 101
        fputs((char const   */* __restrict  */)bufptr, (FILE */* __restrict  */)stderr);
#line 102
        column = 0;
        }
      } else {
#line 104
        tmp___18 = bufptr;
#line 104
        bufptr ++;
#line 104
        *tmp___18 = c;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 106
    *bufptr = (char )'\000';
#line 108
    len___0 = (int )(bufptr - msgbuf);
#line 109
    if (column + len___0 > 78) {
#line 109
      if (column > 0) {
        {
#line 110
        _IO_putc('\n', stderr);
#line 111
        column = 0;
        }
      }
    }
    {
#line 113
    fputs((char const   */* __restrict  */)(msgbuf), (FILE */* __restrict  */)stderr);
#line 114
    column += len___0;
#line 116
    fflush(stderr);
    }
  }
  {
#line 118
  __builtin_va_end(args);
  }
#line 120
  if (flags & 4) {
    {
#line 121
    exit(1);
    }
  }
#line 122
  return;
}
}
#line 198 "/usr/include/stdio.h"
extern FILE *tmpfile(void)  __asm__("tmpfile64")  ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 781
extern int fseeko(FILE *__stream , __off_t __off , int __whence )  __asm__("fseeko64")  ;
#line 784
extern __off_t ftello(FILE *__stream )  __asm__("ftello64")  ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 28 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.h"
Paper *findpaper(char const   *name ) ;
#line 29
FILE *seekable(FILE *fp ) ;
#line 30
void writepage(int p ) ;
#line 31
void seekpage(int p ) ;
#line 32
void writepageheader(char *label , int page ) ;
#line 33
void writepagesetup(void) ;
#line 34
void writepagebody(int p ) ;
#line 35
void writeheader(int p , off_t *ignore ) ;
#line 36
void writeheadermedia(int p , off_t *ignore , double width , double height ) ;
#line 37
int writepartprolog(void) ;
#line 38
void writeprolog(void) ;
#line 39
void writesetup(void) ;
#line 40
void writetrailer(void) ;
#line 41
void writeemptypage(void) ;
#line 42
void scanpages(off_t *sizeheaders ) ;
#line 43
void writestring(char *s ) ;
#line 48
int pages ;
#line 49
int verbose ;
#line 50
FILE *infile ;
#line 51
FILE *outfile ;
#line 52
char pagelabel[8192] ;
#line 53
int pageno ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 41 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static char buffer[8192]  ;
#line 42 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static long bytes  =    0L;
#line 43 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static off_t pagescmt  =    (off_t )0;
#line 44 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static off_t headerpos  =    (off_t )0;
#line 45 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static off_t endsetup  =    (off_t )0;
#line 46 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static off_t beginprocset  =    (off_t )0;
#line 47 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static off_t endprocset  =    (off_t )0;
#line 48 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static int outputpage  =    0;
#line 49 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static int maxpages  =    100;
#line 50 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static off_t *pageptr  ;
#line 53 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static Paper papersizes[24]  = 
#line 53
  {      {(char *)"a0", 2382, 3369}, 
        {(char *)"a1", 1684, 2382}, 
        {(char *)"a2", 1191, 1684}, 
        {(char *)"a3", 842, 1191}, 
        {(char *)"a4", 595, 842}, 
        {(char *)"a5", 421, 595}, 
        {(char *)"b5", 516, 729}, 
        {(char *)"A0", 2382, 3369}, 
        {(char *)"A1", 1684, 2382}, 
        {(char *)"A2", 1191, 1684}, 
        {(char *)"A3", 842, 1191}, 
        {(char *)"A4", 595, 842}, 
        {(char *)"A5", 421, 595}, 
        {(char *)"B5", 516, 729}, 
        {(char *)"letter", 612, 792}, 
        {(char *)"legal", 612, 1008}, 
        {(char *)"ledger", 1224, 792}, 
        {(char *)"tabloid", 792, 1224}, 
        {(char *)"statement", 396, 612}, 
        {(char *)"executive", 540, 720}, 
        {(char *)"folio", 612, 936}, 
        {(char *)"quarto", 610, 780}, 
        {(char *)"10x14", 720, 1008}, 
        {(char *)((void *)0), 0, 0}};
#line 81 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
Paper *findpaper(char const   *name ) 
{ 
  Paper *pp ;
  int tmp ;

  {
#line 84
  pp = papersizes;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! pp->name) {
#line 84
      goto while_break;
    }
    {
#line 85
    tmp = strcmp((char const   *)pp->name, name);
    }
#line 85
    if (tmp == 0) {
#line 86
      return (pp);
    }
#line 84
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return ((Paper *)((void *)0));
}
}
#line 93 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
FILE *seekable(FILE *fp ) 
{ 
  FILE *ft ;
  long r ;
  long w ;
  char *p ;
  char buffer___1[8192] ;
  off_t fpos ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 111
  fpos = ftello(fp);
  }
#line 111
  if (fpos >= 0L) {
    {
#line 112
    tmp = fseeko(fp, (off_t )0, 2);
    }
#line 112
    if (! tmp) {
      {
#line 112
      tmp___0 = fseeko(fp, fpos, 0);
      }
#line 112
      if (! tmp___0) {
#line 113
        return (fp);
      }
    }
  }
  {
#line 120
  ft = tmpfile();
  }
#line 120
  if ((unsigned long )ft == (unsigned long )((void *)0)) {
#line 121
    return ((FILE *)((void *)0));
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 123
    p = buffer___1;
#line 123
    tmp___2 = fread((void */* __restrict  */)p, sizeof(char ), (size_t )8192, (FILE */* __restrict  */)fp);
#line 123
    r = (long )tmp___2;
    }
#line 123
    if (! (r > 0L)) {
#line 123
      goto while_break;
    }
    {
#line 124
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 125
      tmp___1 = fwrite((void const   */* __restrict  */)p, sizeof(char ), (size_t )r,
                       (FILE */* __restrict  */)ft);
#line 125
      w = (long )tmp___1;
      }
#line 125
      if (w == 0L) {
#line 126
        return ((FILE *)((void *)0));
      }
#line 127
      p += w;
#line 128
      r -= w;
#line 124
      if (! (r > 0L)) {
#line 124
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 132
  tmp___3 = feof(fp);
  }
#line 132
  if (! tmp___3) {
#line 133
    return ((FILE *)((void *)0));
  }
  {
#line 136
  fclose(fp);
#line 137
  tmp___4 = fseeko(ft, (off_t )0, 0);
  }
#line 137
  if (tmp___4 != 0) {
#line 138
    return ((FILE *)((void *)0));
  }
#line 140
  return (ft);
}
}
#line 147 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static int fcopy(off_t upto , off_t *ignorelist ) 
{ 
  off_t here ;
  __off_t tmp ;
  off_t bytes_left ;
  int r ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t rw_result ;
  size_t numtocopy ;
  off_t tmp___2 ;

  {
  {
#line 149
  tmp = ftello(infile);
#line 149
  here = tmp;
  }
#line 152
  if ((unsigned long )ignorelist != (unsigned long )((void *)0)) {
    {
#line 153
    while (1) {
      while_continue: /* CIL Label */ ;
#line 153
      if (*ignorelist > 0L) {
#line 153
        if (! (*ignorelist < here)) {
#line 153
          goto while_break;
        }
      } else {
#line 153
        goto while_break;
      }
#line 154
      ignorelist ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 156
      if (*ignorelist > 0L) {
#line 156
        if (! (*ignorelist < upto)) {
#line 156
          goto while_break___0;
        }
      } else {
#line 156
        goto while_break___0;
      }
      {
#line 157
      tmp___0 = fcopy(*ignorelist, (off_t *)((void *)0));
#line 157
      r = tmp___0;
      }
#line 158
      if (! r) {
#line 159
        return (0);
      } else {
        {
#line 158
        tmp___1 = fgets((char */* __restrict  */)(buffer), 8192, (FILE */* __restrict  */)infile);
        }
#line 158
        if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 159
          return (0);
        }
      }
      {
#line 160
      ignorelist ++;
#line 161
      here = ftello(infile);
      }
      {
#line 162
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 162
        if (*ignorelist > 0L) {
#line 162
          if (! (*ignorelist < here)) {
#line 162
            goto while_break___1;
          }
        } else {
#line 162
          goto while_break___1;
        }
#line 163
        ignorelist ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 166
  bytes_left = upto - here;
  {
#line 168
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 168
    if (! (bytes_left > 0L)) {
#line 168
      goto while_break___2;
    }
#line 170
    if (bytes_left > 8192L) {
#line 170
      tmp___2 = (off_t )8192;
    } else {
#line 170
      tmp___2 = bytes_left;
    }
    {
#line 170
    numtocopy = (size_t )tmp___2;
#line 171
    rw_result = fread((void */* __restrict  */)(buffer), (size_t )1, numtocopy, (FILE */* __restrict  */)infile);
    }
#line 172
    if (rw_result < numtocopy) {
#line 172
      return (0);
    }
    {
#line 173
    rw_result = fwrite((void const   */* __restrict  */)(buffer), (size_t )1, numtocopy,
                       (FILE */* __restrict  */)outfile);
    }
#line 174
    if (rw_result < numtocopy) {
#line 174
      return (0);
    }
#line 175
    bytes_left = (off_t )((size_t )bytes_left - numtocopy);
#line 176
    bytes = (long )((size_t )bytes + numtocopy);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 178
  return (1);
}
}
#line 182 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
void scanpages(off_t *sizeheaders ) 
{ 
  register char *comment ;
  register int nesting ;
  register off_t record ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  off_t *tmp___2 ;
  off_t *tmp___3 ;
  off_t *tmp___4 ;
  off_t *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  size_t tmp___34 ;
  int tmp___35 ;
  size_t tmp___36 ;
  int tmp___37 ;
  size_t tmp___38 ;
  int tmp___39 ;
  size_t tmp___40 ;
  int tmp___41 ;
  size_t tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;

  {
#line 184
  comment = buffer + 2;
#line 185
  nesting = 0;
#line 188
  if (sizeheaders) {
#line 189
    *sizeheaders = (off_t )0;
  }
  {
#line 191
  tmp = malloc(sizeof(off_t ) * (unsigned long )maxpages);
#line 191
  pageptr = (off_t *)tmp;
  }
#line 191
  if ((unsigned long )pageptr == (unsigned long )((void *)0)) {
    {
#line 192
    message(7, (char *)"out of memory\n");
    }
  }
  {
#line 193
  pages = 0;
#line 194
  fseeko(infile, (off_t )0, 0);
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 195
    record = ftello(infile);
#line 195
    tmp___44 = fgets((char */* __restrict  */)(buffer), 8192, (FILE */* __restrict  */)infile);
    }
#line 195
    if (! ((unsigned long )tmp___44 != (unsigned long )((void *)0))) {
#line 195
      goto while_break;
    }
#line 196
    if ((int )buffer[0] == 37) {
#line 197
      if ((int )buffer[1] == 37) {
#line 198
        if (nesting == 0) {
          {
#line 198
          tmp___42 = strlen("Page:");
#line 198
          tmp___43 = strncmp((char const   *)comment, "Page:", tmp___42);
          }
#line 198
          if (tmp___43 == 0) {
#line 199
            if (pages >= maxpages - 1) {
              {
#line 200
              maxpages *= 2;
#line 201
              tmp___0 = realloc((void *)((char *)pageptr), sizeof(off_t ) * (unsigned long )maxpages);
#line 201
              pageptr = (off_t *)tmp___0;
              }
#line 201
              if ((unsigned long )pageptr == (unsigned long )((void *)0)) {
                {
#line 203
                message(7, (char *)"out of memory\n");
                }
              }
            }
#line 205
            tmp___1 = pages;
#line 205
            pages ++;
#line 205
            *(pageptr + tmp___1) = record;
          } else {
#line 198
            goto _L___10;
          }
        } else
        _L___10: /* CIL Label */ 
#line 206
        if (headerpos == 0L) {
          {
#line 206
          tmp___40 = strlen("BoundingBox:");
#line 206
          tmp___41 = strncmp((char const   *)comment, "BoundingBox:", tmp___40);
          }
#line 206
          if (tmp___41 == 0) {
#line 207
            if (sizeheaders) {
#line 208
              tmp___2 = sizeheaders;
#line 208
              sizeheaders ++;
#line 208
              *tmp___2 = record;
#line 209
              *sizeheaders = (off_t )0;
            }
          } else {
#line 206
            goto _L___9;
          }
        } else
        _L___9: /* CIL Label */ 
#line 211
        if (headerpos == 0L) {
          {
#line 211
          tmp___38 = strlen("HiResBoundingBox:");
#line 211
          tmp___39 = strncmp((char const   *)comment, "HiResBoundingBox:", tmp___38);
          }
#line 211
          if (tmp___39 == 0) {
#line 212
            if (sizeheaders) {
#line 213
              tmp___3 = sizeheaders;
#line 213
              sizeheaders ++;
#line 213
              *tmp___3 = record;
#line 214
              *sizeheaders = (off_t )0;
            }
          } else {
#line 211
            goto _L___8;
          }
        } else
        _L___8: /* CIL Label */ 
#line 216
        if (headerpos == 0L) {
          {
#line 216
          tmp___36 = strlen("DocumentPaperSizes:");
#line 216
          tmp___37 = strncmp((char const   *)comment, "DocumentPaperSizes:", tmp___36);
          }
#line 216
          if (tmp___37 == 0) {
#line 217
            if (sizeheaders) {
#line 218
              tmp___4 = sizeheaders;
#line 218
              sizeheaders ++;
#line 218
              *tmp___4 = record;
#line 219
              *sizeheaders = (off_t )0;
            }
          } else {
#line 216
            goto _L___7;
          }
        } else
        _L___7: /* CIL Label */ 
#line 221
        if (headerpos == 0L) {
          {
#line 221
          tmp___34 = strlen("DocumentMedia:");
#line 221
          tmp___35 = strncmp((char const   *)comment, "DocumentMedia:", tmp___34);
          }
#line 221
          if (tmp___35 == 0) {
#line 222
            if (sizeheaders) {
#line 223
              tmp___5 = sizeheaders;
#line 223
              sizeheaders ++;
#line 223
              *tmp___5 = record;
#line 224
              *sizeheaders = (off_t )0;
            }
          } else {
#line 221
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 226
        if (headerpos == 0L) {
          {
#line 226
          tmp___32 = strlen("Pages:");
#line 226
          tmp___33 = strncmp((char const   *)comment, "Pages:", tmp___32);
          }
#line 226
          if (tmp___33 == 0) {
#line 227
            pagescmt = record;
          } else {
#line 226
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 228
        if (headerpos == 0L) {
          {
#line 228
          tmp___30 = strlen("EndComments");
#line 228
          tmp___31 = strncmp((char const   *)comment, "EndComments", tmp___30);
          }
#line 228
          if (tmp___31 == 0) {
            {
#line 229
            headerpos = ftello(infile);
            }
          } else {
#line 228
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
          {
#line 230
          tmp___24 = strlen("BeginDocument");
#line 230
          tmp___25 = strncmp((char const   *)comment, "BeginDocument", tmp___24);
          }
#line 230
          if (tmp___25 == 0) {
#line 233
            nesting ++;
          } else {
            {
#line 230
            tmp___26 = strlen("BeginBinary");
#line 230
            tmp___27 = strncmp((char const   *)comment, "BeginBinary", tmp___26);
            }
#line 230
            if (tmp___27 == 0) {
#line 233
              nesting ++;
            } else {
              {
#line 230
              tmp___28 = strlen("BeginFile");
#line 230
              tmp___29 = strncmp((char const   *)comment, "BeginFile", tmp___28);
              }
#line 230
              if (tmp___29 == 0) {
#line 233
                nesting ++;
              } else {
                {
#line 234
                tmp___18 = strlen("EndDocument");
#line 234
                tmp___19 = strncmp((char const   *)comment, "EndDocument", tmp___18);
                }
#line 234
                if (tmp___19 == 0) {
#line 237
                  nesting --;
                } else {
                  {
#line 234
                  tmp___20 = strlen("EndBinary");
#line 234
                  tmp___21 = strncmp((char const   *)comment, "EndBinary", tmp___20);
                  }
#line 234
                  if (tmp___21 == 0) {
#line 237
                    nesting --;
                  } else {
                    {
#line 234
                    tmp___22 = strlen("EndFile");
#line 234
                    tmp___23 = strncmp((char const   *)comment, "EndFile", tmp___22);
                    }
#line 234
                    if (tmp___23 == 0) {
#line 237
                      nesting --;
                    } else
#line 238
                    if (nesting == 0) {
                      {
#line 238
                      tmp___16 = strlen("EndSetup");
#line 238
                      tmp___17 = strncmp((char const   *)comment, "EndSetup", tmp___16);
                      }
#line 238
                      if (tmp___17 == 0) {
#line 239
                        endsetup = record;
                      } else {
#line 238
                        goto _L___3;
                      }
                    } else
                    _L___3: /* CIL Label */ 
#line 240
                    if (nesting == 0) {
                      {
#line 240
                      tmp___14 = strlen("BeginProlog");
#line 240
                      tmp___15 = strncmp((char const   *)comment, "BeginProlog", tmp___14);
                      }
#line 240
                      if (tmp___15 == 0) {
                        {
#line 241
                        headerpos = ftello(infile);
                        }
                      } else {
#line 240
                        goto _L___2;
                      }
                    } else
                    _L___2: /* CIL Label */ 
#line 242
                    if (nesting == 0) {
                      {
#line 242
                      tmp___12 = strlen("BeginProcSet: PStoPS");
#line 242
                      tmp___13 = strncmp((char const   *)comment, "BeginProcSet: PStoPS",
                                         tmp___12);
                      }
#line 242
                      if (tmp___13 == 0) {
#line 244
                        beginprocset = record;
                      } else {
#line 242
                        goto _L___1;
                      }
                    } else
                    _L___1: /* CIL Label */ 
#line 245
                    if (beginprocset) {
#line 245
                      if (! endprocset) {
                        {
#line 245
                        tmp___10 = strlen("EndProcSet");
#line 245
                        tmp___11 = strncmp((char const   *)comment, "EndProcSet",
                                           tmp___10);
                        }
#line 245
                        if (tmp___11 == 0) {
                          {
#line 247
                          endprocset = ftello(infile);
                          }
                        } else {
#line 245
                          goto _L___0;
                        }
                      } else {
#line 245
                        goto _L___0;
                      }
                    } else
                    _L___0: /* CIL Label */ 
#line 248
                    if (nesting == 0) {
                      {
#line 248
                      tmp___6 = strlen("Trailer");
#line 248
                      tmp___7 = strncmp((char const   *)comment, "Trailer", tmp___6);
                      }
#line 248
                      if (tmp___7 == 0) {
                        {
#line 250
                        fseeko(infile, record, 0);
                        }
#line 251
                        goto while_break;
                      } else {
                        {
#line 248
                        tmp___8 = strlen("EOF");
#line 248
                        tmp___9 = strncmp((char const   *)comment, "EOF", tmp___8);
                        }
#line 248
                        if (tmp___9 == 0) {
                          {
#line 250
                          fseeko(infile, record, 0);
                          }
#line 251
                          goto while_break;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else
#line 253
      if (headerpos == 0L) {
#line 253
        if ((int )buffer[1] != 33) {
#line 254
          headerpos = record;
        }
      }
    } else
#line 255
    if (headerpos == 0L) {
#line 256
      headerpos = record;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  *(pageptr + pages) = ftello(infile);
  }
#line 258
  if (endsetup == 0L) {
#line 259
    endsetup = *(pageptr + 0);
  } else
#line 258
  if (endsetup > *(pageptr + 0)) {
#line 259
    endsetup = *(pageptr + 0);
  }
#line 260
  return;
}
}
#line 263 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
void seekpage(int p ) 
{ 
  char *start ;
  char *end ;
  unsigned short const   **tmp ;
  int paren ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 265
  fseeko(infile, *(pageptr + p), 0);
#line 266
  tmp___1 = fgets((char */* __restrict  */)(buffer), 8192, (FILE */* __restrict  */)infile);
  }
#line 266
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
    {
#line 266
    tmp___2 = strlen("%%Page:");
#line 266
    tmp___3 = strncmp((char const   *)(buffer), "%%Page:", tmp___2);
    }
#line 266
    if (tmp___3 == 0) {
#line 269
      start = buffer + 7;
      {
#line 269
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 269
        tmp = __ctype_b_loc();
        }
#line 269
        if (! ((int const   )*(*tmp + (int )*start) & 8192)) {
#line 269
          goto while_break;
        }
#line 269
        start ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 270
      if ((int )*start == 40) {
#line 271
        paren = 1;
#line 272
        end = start + 1;
        {
#line 272
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 272
          if (! (paren > 0)) {
#line 272
            goto while_break___0;
          }
          {
#line 274
          if ((int )*end == 0) {
#line 274
            goto case_0;
          }
#line 276
          if ((int )*end == 40) {
#line 276
            goto case_40;
          }
#line 279
          if ((int )*end == 41) {
#line 279
            goto case_41;
          }
#line 273
          goto switch_break;
          case_0: /* CIL Label */ 
          {
#line 275
          message(7, (char *)"Bad page label while seeking page %d\n", p);
          }
          case_40: /* CIL Label */ 
#line 277
          paren ++;
#line 278
          goto switch_break;
          case_41: /* CIL Label */ 
#line 280
          paren --;
#line 281
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 272
          end ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 284
        end = start;
        {
#line 284
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 284
          tmp___0 = __ctype_b_loc();
          }
#line 284
          if ((int const   )*(*tmp___0 + (int )*end) & 8192) {
#line 284
            goto while_break___1;
          }
#line 284
          end ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 285
      strncpy((char */* __restrict  */)(pagelabel), (char const   */* __restrict  */)start,
              (size_t )(end - start));
#line 286
      pagelabel[end - start] = (char )'\000';
#line 287
      pageno = atoi((char const   *)end);
      }
    } else {
      {
#line 289
      message(7, (char *)"I/O error seeking page %d\n", p);
      }
    }
  } else {
    {
#line 289
    message(7, (char *)"I/O error seeking page %d\n", p);
    }
  }
#line 290
  return;
}
}
#line 294 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
void writestring(char *s ) 
{ 
  size_t tmp ;

  {
  {
#line 296
  fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)outfile);
#line 297
  tmp = strlen((char const   *)s);
#line 297
  bytes = (long )((size_t )bytes + tmp);
  }
#line 298
  return;
}
}
#line 301 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
void writepageheader(char *label , int page ) 
{ 


  {
#line 303
  if (verbose) {
    {
#line 304
    message(0, (char *)"[%d] ", page);
    }
  }
  {
#line 305
  outputpage ++;
#line 305
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%%%%Page: %s %d\n",
          label, outputpage);
#line 306
  writestring(buffer);
  }
#line 307
  return;
}
}
#line 310 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
void writepagesetup(void) 
{ 
  char buffer___1[8192] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
#line 313
  if (beginprocset) {
    {
#line 314
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 315
      tmp = fgets((char */* __restrict  */)(buffer___1), 8192, (FILE */* __restrict  */)infile);
      }
#line 315
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
#line 316
        message(7, (char *)"I/O error reading page setup %d\n", outputpage);
        }
      }
      {
#line 317
      tmp___0 = strncmp((char const   *)(buffer___1), "PStoPSxform", (size_t )11);
      }
#line 317
      if (! tmp___0) {
#line 318
        goto while_break;
      }
      {
#line 319
      tmp___1 = fputs((char const   */* __restrict  */)(buffer___1), (FILE */* __restrict  */)outfile);
      }
#line 319
      if (tmp___1 == -1) {
        {
#line 320
        message(7, (char *)"I/O error writing page setup %d\n", outputpage);
        }
      }
      {
#line 321
      tmp___2 = strlen((char const   *)(buffer___1));
#line 321
      bytes = (long )((size_t )bytes + tmp___2);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 324
  return;
}
}
#line 327 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
void writepagebody(int p ) 
{ 
  int tmp ;

  {
  {
#line 329
  tmp = fcopy(*(pageptr + (p + 1)), (off_t *)((void *)0));
  }
#line 329
  if (! tmp) {
    {
#line 330
    message(7, (char *)"I/O error writing page %d\n", outputpage);
    }
  }
#line 331
  return;
}
}
#line 334 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
void writepage(int p ) 
{ 


  {
  {
#line 336
  seekpage(p);
#line 337
  writepageheader(pagelabel, p + 1);
#line 338
  writepagebody(p);
  }
#line 339
  return;
}
}
#line 342 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
void writeheader(int p , off_t *ignore ) 
{ 


  {
  {
#line 344
  writeheadermedia(p, ignore, (double )-1, (double )-1);
  }
#line 345
  return;
}
}
#line 347 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
void writeheadermedia(int p , off_t *ignore , double width , double height ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 349
  fseeko(infile, (off_t )0, 0);
  }
#line 350
  if (pagescmt) {
    {
#line 351
    tmp = fcopy(pagescmt, ignore);
    }
#line 351
    if (tmp) {
      {
#line 351
      tmp___0 = fgets((char */* __restrict  */)(buffer), 8192, (FILE */* __restrict  */)infile);
      }
#line 351
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 352
        message(7, (char *)"I/O error in header\n");
        }
      }
    } else {
      {
#line 352
      message(7, (char *)"I/O error in header\n");
      }
    }
#line 353
    if (width > (double )-1) {
#line 353
      if (height > (double )-1) {
        {
#line 354
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%%%%DocumentMedia: plain %d %d 0 () ()\n",
                (int )width, (int )height);
#line 355
        writestring(buffer);
#line 356
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%%%%BoundingBox: 0 0 %d %d\n",
                (int )width, (int )height);
#line 357
        writestring(buffer);
        }
      }
    }
    {
#line 359
    sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%%%%Pages: %d 0\n",
            p);
#line 360
    writestring(buffer);
    }
  }
  {
#line 362
  tmp___1 = fcopy(headerpos, ignore);
  }
#line 362
  if (! tmp___1) {
    {
#line 363
    message(7, (char *)"I/O error in header\n");
    }
  }
#line 364
  return;
}
}
#line 367 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
int writepartprolog(void) 
{ 
  int tmp ;

  {
#line 369
  if (beginprocset) {
    {
#line 369
    tmp = fcopy(beginprocset, (off_t *)((void *)0));
    }
#line 369
    if (! tmp) {
      {
#line 370
      message(7, (char *)"I/O error in prologue\n");
      }
    }
  }
#line 371
  if (endprocset) {
    {
#line 372
    fseeko(infile, endprocset, 0);
    }
  }
  {
#line 373
  writeprolog();
  }
#line 374
  return (! beginprocset);
}
}
#line 378 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
void writeprolog(void) 
{ 
  int tmp ;

  {
  {
#line 380
  tmp = fcopy(endsetup, (off_t *)((void *)0));
  }
#line 380
  if (! tmp) {
    {
#line 381
    message(7, (char *)"I/O error in prologue\n");
    }
  }
#line 382
  return;
}
}
#line 385 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
void writesetup(void) 
{ 
  int tmp ;

  {
  {
#line 387
  tmp = fcopy(*(pageptr + 0), (off_t *)((void *)0));
  }
#line 387
  if (! tmp) {
    {
#line 388
    message(7, (char *)"I/O error in prologue\n");
    }
  }
#line 389
  return;
}
}
#line 392 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
void writetrailer(void) 
{ 
  char *tmp ;

  {
  {
#line 394
  fseeko(infile, *(pageptr + pages), 0);
  }
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 395
    tmp = fgets((char */* __restrict  */)(buffer), 8192, (FILE */* __restrict  */)infile);
    }
#line 395
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 395
      goto while_break;
    }
    {
#line 396
    writestring(buffer);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 398
  if (verbose) {
    {
#line 399
    message(0, (char *)"Wrote %d pages, %ld bytes\n", outputpage, bytes);
    }
  }
#line 400
  return;
}
}
#line 403 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
void writeemptypage(void) 
{ 


  {
#line 405
  if (verbose) {
    {
#line 406
    message(0, (char *)"[*] ");
    }
  }
  {
#line 407
  outputpage ++;
#line 407
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%%%%Page: * %d\n",
          outputpage);
#line 408
  writestring(buffer);
  }
#line 409
  if (beginprocset) {
    {
#line 410
    writestring((char *)"PStoPSxform concat\n");
    }
  }
  {
#line 411
  writestring((char *)"showpage\n");
  }
#line 412
  return;
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 47 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.h"
char *program  ;
#line 48 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.h"
int pages  ;
#line 49 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.h"
int verbose  ;
#line 50 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.h"
FILE *infile  ;
#line 51 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.h"
FILE *outfile  ;
#line 52 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.h"
char pagelabel[8192]  ;
#line 53 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.h"
int pageno  ;
#line 25 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psbook.c"
static void usage(void) 
{ 


  {
  {
#line 27
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s release %d patchlevel %d\n",
          program, 1, 17);
#line 28
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Copyright (C) Angus J. C. Duggan, 1991-1995. See file LICENSE for details.\n");
#line 29
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-q] [-s<signature>] [infile [outfile]]\n",
          program);
#line 31
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       <signature> must be positive and divisible by 4\n");
#line 32
  fflush(stderr);
#line 33
  exit(1);
  }
}
}
#line 37 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psbook.c"
int main(int argc , char **argv ) 
{ 
  int signature ;
  int currentpg ;
  int maxpage ;
  int opt ;
  int actualpg ;

  {
#line 40
  signature = 0;
#line 44
  verbose = 1;
#line 45
  program = *argv;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 47
    opt = getopt(argc, (char * const  *)argv, "vqs:");
    }
#line 47
    if (! (opt != -1)) {
#line 47
      goto while_break;
    }
    {
#line 49
    if (opt == 115) {
#line 49
      goto case_115;
    }
#line 53
    if (opt == 113) {
#line 53
      goto case_113;
    }
#line 57
    goto switch_default;
    case_115: /* CIL Label */ 
    {
#line 50
    signature = atoi((char const   *)optarg);
    }
#line 51
    if (signature < 1) {
      {
#line 51
      usage();
      }
    } else
#line 51
    if (signature % 4) {
      {
#line 51
      usage();
      }
    }
#line 52
    goto switch_break;
    case_113: /* CIL Label */ 
#line 54
    verbose = 0;
#line 55
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 58
    usage();
    }
#line 59
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  infile = stdin;
#line 64
  outfile = stdout;
#line 67
  if (argc - optind < 0) {
    {
#line 67
    usage();
    }
  } else
#line 67
  if (argc - optind > 2) {
    {
#line 67
    usage();
    }
  }
#line 69
  if (optind != argc) {
    {
#line 71
    infile = fopen((char const   */* __restrict  */)*(argv + optind), (char const   */* __restrict  */)"r");
    }
#line 71
    if ((unsigned long )infile == (unsigned long )((void *)0)) {
      {
#line 72
      message(7, (char *)"can\'t open input file %s\n", *(argv + optind));
      }
    }
#line 73
    optind ++;
  }
#line 76
  if (optind != argc) {
    {
#line 78
    outfile = fopen((char const   */* __restrict  */)*(argv + optind), (char const   */* __restrict  */)"w");
    }
#line 78
    if ((unsigned long )outfile == (unsigned long )((void *)0)) {
      {
#line 79
      message(7, (char *)"can\'t open output file %s\n", *(argv + optind));
      }
    }
#line 80
    optind ++;
  }
#line 83
  if (optind != argc) {
    {
#line 83
    usage();
    }
  }
  {
#line 97
  infile = seekable(infile);
  }
#line 97
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 98
    message(7, (char *)"can\'t seek input\n");
    }
  }
  {
#line 100
  scanpages((off_t *)((void *)0));
  }
#line 102
  if (! signature) {
#line 103
    maxpage = pages + (4 - pages % 4) % 4;
#line 103
    signature = maxpage;
  } else {
#line 105
    maxpage = pages + (signature - pages % signature) % signature;
  }
  {
#line 108
  writeheader(maxpage, (off_t *)((void *)0));
#line 109
  writeprolog();
#line 110
  writesetup();
#line 111
  currentpg = 0;
  }
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! (currentpg < maxpage)) {
#line 111
      goto while_break___0;
    }
#line 112
    actualpg = currentpg - currentpg % signature;
    {
#line 115
    if (currentpg % 4 == 3) {
#line 115
      goto case_3;
    }
#line 115
    if (currentpg % 4 == 0) {
#line 115
      goto case_3;
    }
#line 119
    if (currentpg % 4 == 2) {
#line 119
      goto case_2;
    }
#line 119
    if (currentpg % 4 == 1) {
#line 119
      goto case_2;
    }
#line 113
    goto switch_break___0;
    case_3: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 116
    actualpg += (signature - 1) - (currentpg % signature) / 2;
#line 117
    goto switch_break___0;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 120
    actualpg += (currentpg % signature) / 2;
#line 121
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 123
    if (actualpg < pages) {
      {
#line 124
      writepage(actualpg);
      }
    } else {
      {
#line 126
      writeemptypage();
      }
    }
#line 111
    currentpg ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 128
  writetrailer();
#line 130
  exit(0);
  }
}
}
#line 24 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psselect.c"
static void usage___0(void) 
{ 


  {
  {
#line 26
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s release %d patchlevel %d\n",
          program, 1, 17);
#line 27
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Copyright (C) Angus J. C. Duggan, 1991-1995. See file LICENSE for details.\n");
#line 28
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-q] [-e] [-o] [-r] [-p<pages>] [infile [outfile]]\n",
          program);
#line 31
  fflush(stderr);
#line 32
  exit(1);
  }
}
}
#line 40 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psselect.c"
static PageRange *makerange(int beg , int end , PageRange *next ) 
{ 
  PageRange *new ;
  void *tmp ;

  {
  {
#line 43
  tmp = malloc(sizeof(PageRange ));
#line 43
  new = (PageRange *)tmp;
  }
#line 43
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    {
#line 44
    message(7, (char *)"out of memory\n");
    }
  }
#line 45
  new->first = beg;
#line 46
  new->last = end;
#line 47
  new->next = next;
#line 48
  return (new);
}
}
#line 52 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psselect.c"
static PageRange *addrange(char *str , PageRange *rp ) 
{ 
  int first ;
  int sign ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  PageRange *tmp___2 ;
  PageRange *tmp___3 ;
  PageRange *tmp___4 ;
  int last ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  PageRange *tmp___7 ;
  PageRange *tmp___8 ;
  PageRange *tmp___9 ;
  PageRange *tmp___10 ;
  PageRange *tmp___11 ;
  PageRange *tmp___12 ;
  unsigned short const   **tmp___13 ;

  {
#line 54
  first = 0;
#line 57
  if (! str) {
#line 57
    return ((PageRange *)((void *)0));
  }
#line 59
  if ((int )*str == 95) {
#line 59
    str ++;
#line 59
    if (str) {
#line 59
      sign = -1;
    } else {
#line 59
      sign = 1;
    }
  } else {
#line 59
    sign = 1;
  }
  {
#line 60
  tmp___1 = __ctype_b_loc();
  }
#line 60
  if ((int const   )*(*tmp___1 + (int )*str) & 2048) {
    {
#line 61
    tmp = atoi((char const   *)str);
#line 61
    first = sign * tmp;
    }
    {
#line 62
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 62
      tmp___0 = __ctype_b_loc();
      }
#line 62
      if (! ((int const   )*(*tmp___0 + (int )*str) & 2048)) {
#line 62
        goto while_break;
      }
#line 62
      str ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 65
  if ((int )*str == 0) {
#line 65
    goto case_0;
  }
#line 69
  if ((int )*str == 44) {
#line 69
    goto case_44;
  }
#line 74
  if ((int )*str == 58) {
#line 74
    goto case_58;
  }
#line 74
  if ((int )*str == 45) {
#line 74
    goto case_58;
  }
#line 64
  goto switch_break;
  case_0: /* CIL Label */ 
#line 66
  if (first) {
    {
#line 67
    tmp___2 = makerange(first, first, rp);
    }
#line 67
    return (tmp___2);
  } else
#line 66
  if (sign < 0) {
    {
#line 67
    tmp___2 = makerange(first, first, rp);
    }
#line 67
    return (tmp___2);
  }
#line 68
  goto switch_break;
  case_44: /* CIL Label */ 
#line 70
  if (first) {
    {
#line 71
    tmp___3 = makerange(first, first, rp);
#line 71
    tmp___4 = addrange(str + 1, tmp___3);
    }
#line 71
    return (tmp___4);
  } else
#line 70
  if (sign < 0) {
    {
#line 71
    tmp___3 = makerange(first, first, rp);
#line 71
    tmp___4 = addrange(str + 1, tmp___3);
    }
#line 71
    return (tmp___4);
  }
#line 72
  goto switch_break;
  case_58: /* CIL Label */ 
  case_45: /* CIL Label */ 
#line 75
  str ++;
#line 76
  if ((int )*str == 95) {
#line 76
    str ++;
#line 76
    if (str) {
#line 76
      sign = -1;
    } else {
#line 76
      sign = 1;
    }
  } else {
#line 76
    sign = 1;
  }
#line 77
  if (! first) {
#line 78
    first = 1;
  }
  {
#line 79
  tmp___13 = __ctype_b_loc();
  }
#line 79
  if ((int const   )*(*tmp___13 + (int )*str) & 2048) {
    {
#line 80
    tmp___5 = atoi((char const   *)str);
#line 80
    last = sign * tmp___5;
    }
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 81
      tmp___6 = __ctype_b_loc();
      }
#line 81
      if (! ((int const   )*(*tmp___6 + (int )*str) & 2048)) {
#line 81
        goto while_break___0;
      }
#line 81
      str ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 83
    if ((int )*str == 0) {
#line 83
      goto case_0___0;
    }
#line 85
    if ((int )*str == 44) {
#line 85
      goto case_44___0;
    }
#line 82
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 84
    tmp___7 = makerange(first, last, rp);
    }
#line 84
    return (tmp___7);
    case_44___0: /* CIL Label */ 
    {
#line 86
    tmp___8 = makerange(first, last, rp);
#line 86
    tmp___9 = addrange(str + 1, tmp___8);
    }
#line 86
    return (tmp___9);
    switch_break___0: /* CIL Label */ ;
    }
  } else
#line 88
  if ((int )*str == 0) {
    {
#line 89
    tmp___10 = makerange(first, -1, rp);
    }
#line 89
    return (tmp___10);
  } else
#line 90
  if ((int )*str == 44) {
    {
#line 91
    tmp___11 = makerange(first, -1, rp);
#line 91
    tmp___12 = addrange(str + 1, tmp___11);
    }
#line 91
    return (tmp___12);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 93
  message(7, (char *)"invalid page range\n");
  }
#line 94
  return ((PageRange *)0);
}
}
#line 27 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/pserror.c"
static int column___0  =    0;
#line 41 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static char buffer___0[8192]  ;
#line 42 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static long bytes___0  =    0L;
#line 43 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static off_t pagescmt___0  =    (off_t )0;
#line 44 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static off_t headerpos___0  =    (off_t )0;
#line 45 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static off_t endsetup___0  =    (off_t )0;
#line 46 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static off_t beginprocset___0  =    (off_t )0;
#line 47 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static off_t endprocset___0  =    (off_t )0;
#line 48 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static int outputpage___0  =    0;
#line 49 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static int maxpages___0  =    100;
#line 50 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static off_t *pageptr___0  ;
#line 53 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static Paper papersizes___0[24]  = 
#line 53
  {      {(char *)"a0", 2382, 3369}, 
        {(char *)"a1", 1684, 2382}, 
        {(char *)"a2", 1191, 1684}, 
        {(char *)"a3", 842, 1191}, 
        {(char *)"a4", 595, 842}, 
        {(char *)"a5", 421, 595}, 
        {(char *)"b5", 516, 729}, 
        {(char *)"A0", 2382, 3369}, 
        {(char *)"A1", 1684, 2382}, 
        {(char *)"A2", 1191, 1684}, 
        {(char *)"A3", 842, 1191}, 
        {(char *)"A4", 595, 842}, 
        {(char *)"A5", 421, 595}, 
        {(char *)"B5", 516, 729}, 
        {(char *)"letter", 612, 792}, 
        {(char *)"legal", 612, 1008}, 
        {(char *)"ledger", 1224, 792}, 
        {(char *)"tabloid", 792, 1224}, 
        {(char *)"statement", 396, 612}, 
        {(char *)"executive", 540, 720}, 
        {(char *)"folio", 612, 936}, 
        {(char *)"quarto", 610, 780}, 
        {(char *)"10x14", 720, 1008}, 
        {(char *)((void *)0), 0, 0}};
#line 147 "/home/wheatley/newnew/temp/psutils-1.17.dfsg/psutil.c"
static int fcopy___0(off_t upto , off_t *ignorelist ) 
{ 
  off_t here ;
  __off_t tmp ;
  off_t bytes_left ;
  int r ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t rw_result ;
  size_t numtocopy ;
  off_t tmp___2 ;

  {
  {
#line 149
  tmp = ftello(infile);
#line 149
  here = tmp;
  }
#line 152
  if ((unsigned long )ignorelist != (unsigned long )((void *)0)) {
    {
#line 153
    while (1) {
      while_continue: /* CIL Label */ ;
#line 153
      if (*ignorelist > 0L) {
#line 153
        if (! (*ignorelist < here)) {
#line 153
          goto while_break;
        }
      } else {
#line 153
        goto while_break;
      }
#line 154
      ignorelist ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 156
      if (*ignorelist > 0L) {
#line 156
        if (! (*ignorelist < upto)) {
#line 156
          goto while_break___0;
        }
      } else {
#line 156
        goto while_break___0;
      }
      {
#line 157
      tmp___0 = fcopy___0(*ignorelist, (off_t *)((void *)0));
#line 157
      r = tmp___0;
      }
#line 158
      if (! r) {
#line 159
        return (0);
      } else {
        {
#line 158
        tmp___1 = fgets((char */* __restrict  */)(buffer___0), 8192, (FILE */* __restrict  */)infile);
        }
#line 158
        if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 159
          return (0);
        }
      }
      {
#line 160
      ignorelist ++;
#line 161
      here = ftello(infile);
      }
      {
#line 162
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 162
        if (*ignorelist > 0L) {
#line 162
          if (! (*ignorelist < here)) {
#line 162
            goto while_break___1;
          }
        } else {
#line 162
          goto while_break___1;
        }
#line 163
        ignorelist ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 166
  bytes_left = upto - here;
  {
#line 168
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 168
    if (! (bytes_left > 0L)) {
#line 168
      goto while_break___2;
    }
#line 170
    if (bytes_left > 8192L) {
#line 170
      tmp___2 = (off_t )8192;
    } else {
#line 170
      tmp___2 = bytes_left;
    }
    {
#line 170
    numtocopy = (size_t )tmp___2;
#line 171
    rw_result = fread((void */* __restrict  */)(buffer___0), (size_t )1, numtocopy,
                      (FILE */* __restrict  */)infile);
    }
#line 172
    if (rw_result < numtocopy) {
#line 172
      return (0);
    }
    {
#line 173
    rw_result = fwrite((void const   */* __restrict  */)(buffer___0), (size_t )1,
                       numtocopy, (FILE */* __restrict  */)outfile);
    }
#line 174
    if (rw_result < numtocopy) {
#line 174
      return (0);
    }
#line 175
    bytes_left = (off_t )((size_t )bytes_left - numtocopy);
#line 176
    bytes___0 = (long )((size_t )bytes___0 + numtocopy);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 178
  return (1);
}
}
