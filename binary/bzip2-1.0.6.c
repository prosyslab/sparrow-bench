/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 41 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
typedef unsigned long long MaybeUInt64;
#line 53 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
typedef unsigned int UInt32;
#line 54 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
typedef int Int32;
#line 55 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
typedef unsigned char UChar;
#line 56 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
typedef char Char;
#line 57 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
typedef unsigned char Bool;
#line 145 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
struct __anonstruct_BitStream_28 {
   FILE *handle ;
   Int32 buffer ;
   Int32 buffLive ;
   Char mode ;
};
#line 145 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
typedef struct __anonstruct_BitStream_28 BitStream;
#line 48 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.h"
struct __anonstruct_bz_stream_26 {
   char *next_in ;
   unsigned int avail_in ;
   unsigned int total_in_lo32 ;
   unsigned int total_in_hi32 ;
   char *next_out ;
   unsigned int avail_out ;
   unsigned int total_out_lo32 ;
   unsigned int total_out_hi32 ;
   void *state ;
   void *(*bzalloc)(void * , int  , int  ) ;
   void (*bzfree)(void * , void * ) ;
   void *opaque ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.h"
typedef struct __anonstruct_bz_stream_26 bz_stream;
#line 137 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.h"
typedef void BZFILE;
#line 47 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib_private.h"
typedef unsigned short UInt16;
#line 196 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib_private.h"
struct __anonstruct_EState_27 {
   bz_stream *strm ;
   Int32 mode ;
   Int32 state ;
   UInt32 avail_in_expect ;
   UInt32 *arr1 ;
   UInt32 *arr2 ;
   UInt32 *ftab ;
   Int32 origPtr ;
   UInt32 *ptr ;
   UChar *block ;
   UInt16 *mtfv ;
   UChar *zbits ;
   Int32 workFactor ;
   UInt32 state_in_ch ;
   Int32 state_in_len ;
   Int32 rNToGo ;
   Int32 rTPos ;
   Int32 nblock ;
   Int32 nblockMAX ;
   Int32 numZ ;
   Int32 state_out_pos ;
   Int32 nInUse ;
   Bool inUse[256] ;
   UChar unseqToSeq[256] ;
   UInt32 bsBuff ;
   Int32 bsLive ;
   UInt32 blockCRC ;
   UInt32 combinedCRC ;
   Int32 verbosity ;
   Int32 blockNo ;
   Int32 blockSize100k ;
   Int32 nMTF ;
   Int32 mtfFreq[258] ;
   UChar selector[18002] ;
   UChar selectorMtf[18002] ;
   UChar len[6][258] ;
   Int32 code[6][258] ;
   Int32 rfreq[6][258] ;
   UInt32 len_pack[258][4] ;
};
#line 196 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib_private.h"
typedef struct __anonstruct_EState_27 EState;
#line 347 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib_private.h"
struct __anonstruct_DState_28 {
   bz_stream *strm ;
   Int32 state ;
   UChar state_out_ch ;
   Int32 state_out_len ;
   Bool blockRandomised ;
   Int32 rNToGo ;
   Int32 rTPos ;
   UInt32 bsBuff ;
   Int32 bsLive ;
   Int32 blockSize100k ;
   Bool smallDecompress ;
   Int32 currBlockNo ;
   Int32 verbosity ;
   Int32 origPtr ;
   UInt32 tPos ;
   Int32 k0 ;
   Int32 unzftab[256] ;
   Int32 nblock_used ;
   Int32 cftab[257] ;
   Int32 cftabCopy[257] ;
   UInt32 *tt ;
   UInt16 *ll16 ;
   UChar *ll4 ;
   UInt32 storedBlockCRC ;
   UInt32 storedCombinedCRC ;
   UInt32 calculatedBlockCRC ;
   UInt32 calculatedCombinedCRC ;
   Int32 nInUse ;
   Bool inUse[256] ;
   Bool inUse16[16] ;
   UChar seqToUnseq[256] ;
   UChar mtfa[4096] ;
   Int32 mtfbase[16] ;
   UChar selector[18002] ;
   UChar selectorMtf[18002] ;
   UChar len[6][258] ;
   Int32 limit[6][258] ;
   Int32 base[6][258] ;
   Int32 perm[6][258] ;
   Int32 minLens[6] ;
   Int32 save_i ;
   Int32 save_j ;
   Int32 save_t ;
   Int32 save_alphaSize ;
   Int32 save_nGroups ;
   Int32 save_nSelectors ;
   Int32 save_EOB ;
   Int32 save_groupNo ;
   Int32 save_groupPos ;
   Int32 save_nextSym ;
   Int32 save_nblockMAX ;
   Int32 save_nblock ;
   Int32 save_es ;
   Int32 save_N ;
   Int32 save_curr ;
   Int32 save_zt ;
   Int32 save_zn ;
   Int32 save_zvec ;
   Int32 save_zj ;
   Int32 save_gSel ;
   Int32 save_gMinlen ;
   Int32 *save_gLimit ;
   Int32 *save_gBase ;
   Int32 *save_gPerm ;
};
#line 347 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib_private.h"
typedef struct __anonstruct_DState_28 DState;
#line 892 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
struct __anonstruct_bzFile_29 {
   FILE *handle ;
   Char buf[5000] ;
   Int32 bufN ;
   Bool writing ;
   bz_stream strm ;
   Int32 lastErr ;
   Bool initialisedOk ;
};
#line 892 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
typedef struct __anonstruct_bzFile_29 bzFile;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 166 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
typedef short Int16;
#line 232 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
struct __anonstruct_UInt64_56 {
   UChar b[8] ;
};
#line 232 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
typedef struct __anonstruct_UInt64_56 UInt64;
#line 1694 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
struct zzzz {
   Char *name ;
   struct zzzz *link ;
};
#line 1694 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
typedef struct zzzz Cell;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 435
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
Char inFileName[2000]  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
Char outFileName[2000]  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
Char progName[2000]  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
MaybeUInt64 bytesOut  =    (MaybeUInt64 )0;
#line 69 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
MaybeUInt64 bytesIn  =    (MaybeUInt64 )0;
#line 87 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
static void readError(void) 
{ 


  {
  {
#line 89
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: I/O error reading `%s\', possible reason follows.\n",
          progName, inFileName);
#line 92
  perror((char const   *)(progName));
#line 93
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: output file(s) may be incomplete.\n",
          progName);
#line 95
  exit(1);
  }
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
static void writeError(void) 
{ 


  {
  {
#line 102
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: I/O error reading `%s\', possible reason follows.\n",
          progName, inFileName);
#line 105
  perror((char const   *)(progName));
#line 106
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: output file(s) may be incomplete.\n",
          progName);
#line 108
  exit(1);
  }
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
static void mallocFail(Int32 n ) 
{ 


  {
  {
#line 115
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: malloc failed on request for %d bytes.\n",
          progName, n);
#line 118
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: output file(s) may be incomplete.\n",
          progName);
#line 120
  exit(1);
  }
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
static void tooManyBlocks(Int32 max_handled_blocks ) 
{ 


  {
  {
#line 127
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: `%s\' appears to contain more than %d blocks\n",
          progName, inFileName, max_handled_blocks);
#line 130
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: and cannot be handled.  To fix, increase\n",
          progName);
#line 133
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: BZ_MAX_HANDLED_BLOCKS in bzip2recover.c, and recompile.\n",
          progName);
#line 136
  exit(1);
  }
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
static BitStream *bsOpenReadStream(FILE *stream ) 
{ 
  BitStream *bs ;
  void *tmp ;

  {
  {
#line 158
  tmp = malloc(sizeof(BitStream ));
#line 158
  bs = (BitStream *)tmp;
  }
#line 159
  if ((unsigned long )bs == (unsigned long )((void *)0)) {
    {
#line 159
    mallocFail((Int32 )sizeof(BitStream ));
    }
  }
#line 160
  bs->handle = stream;
#line 161
  bs->buffer = 0;
#line 162
  bs->buffLive = 0;
#line 163
  bs->mode = (Char )'r';
#line 164
  return (bs);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
static BitStream *bsOpenWriteStream(FILE *stream ) 
{ 
  BitStream *bs ;
  void *tmp ;

  {
  {
#line 171
  tmp = malloc(sizeof(BitStream ));
#line 171
  bs = (BitStream *)tmp;
  }
#line 172
  if ((unsigned long )bs == (unsigned long )((void *)0)) {
    {
#line 172
    mallocFail((Int32 )sizeof(BitStream ));
    }
  }
#line 173
  bs->handle = stream;
#line 174
  bs->buffer = 0;
#line 175
  bs->buffLive = 0;
#line 176
  bs->mode = (Char )'w';
#line 177
  return (bs);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
static void bsPutBit(BitStream *bs , Int32 bit ) 
{ 
  Int32 retVal ;
  int tmp ;

  {
#line 184
  if (bs->buffLive == 8) {
    {
#line 185
    tmp = _IO_putc((int )((UChar )bs->buffer), bs->handle);
#line 185
    retVal = tmp;
    }
#line 186
    if (retVal == -1) {
      {
#line 186
      writeError();
      }
    }
#line 187
    bytesOut ++;
#line 188
    bs->buffLive = 1;
#line 189
    bs->buffer = bit & 1;
  } else {
#line 191
    bs->buffer = (bs->buffer << 1) | (bit & 1);
#line 192
    (bs->buffLive) ++;
  }
#line 194
  return;
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
static Int32 bsGetBit(BitStream *bs ) 
{ 
  Int32 retVal ;
  int tmp ;
  int *tmp___0 ;

  {
#line 203
  if (bs->buffLive > 0) {
#line 204
    (bs->buffLive) --;
#line 205
    return ((bs->buffer >> bs->buffLive) & 1);
  } else {
    {
#line 207
    tmp = _IO_getc(bs->handle);
#line 207
    retVal = tmp;
    }
#line 208
    if (retVal == -1) {
      {
#line 209
      tmp___0 = __errno_location();
      }
#line 209
      if (*tmp___0 != 0) {
        {
#line 209
        readError();
        }
      }
#line 210
      return (2);
    }
#line 212
    bs->buffLive = 7;
#line 213
    bs->buffer = retVal;
#line 214
    return ((bs->buffer >> 7) & 1);
  }
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
static void bsClose(BitStream *bs ) 
{ 
  Int32 retVal ;

  {
#line 224
  if ((int )bs->mode == 119) {
    {
#line 225
    while (1) {
      while_continue: /* CIL Label */ ;
#line 225
      if (! (bs->buffLive < 8)) {
#line 225
        goto while_break;
      }
#line 226
      (bs->buffLive) ++;
#line 227
      bs->buffer <<= 1;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 229
    retVal = _IO_putc((int )((UChar )bs->buffer), bs->handle);
    }
#line 230
    if (retVal == -1) {
      {
#line 230
      writeError();
      }
    }
    {
#line 231
    bytesOut ++;
#line 232
    retVal = fflush(bs->handle);
    }
#line 233
    if (retVal == -1) {
      {
#line 233
      writeError();
      }
    }
  }
  {
#line 235
  retVal = fclose(bs->handle);
  }
#line 236
  if (retVal == -1) {
#line 237
    if ((int )bs->mode == 119) {
      {
#line 237
      writeError();
      }
    } else {
      {
#line 237
      readError();
      }
    }
  }
  {
#line 239
  free((void *)bs);
  }
#line 240
  return;
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
static void bsPutUChar(BitStream *bs , UChar c ) 
{ 
  Int32 i ;

  {
#line 247
  i = 7;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (i >= 0)) {
#line 247
      goto while_break;
    }
    {
#line 248
    bsPutBit(bs, (Int32 )(((UInt32 )c >> i) & 1U));
#line 247
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
static void bsPutUInt32(BitStream *bs , UInt32 c ) 
{ 
  Int32 i ;

  {
#line 257
  i = 31;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! (i >= 0)) {
#line 257
      goto while_break;
    }
    {
#line 258
    bsPutBit(bs, (Int32 )((c >> i) & 1U));
#line 257
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
static Bool endsInBz2(Char *name ) 
{ 
  Int32 n ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 265
  tmp = strlen((char const   *)name);
#line 265
  n = (Int32 )tmp;
  }
#line 266
  if (n <= 4) {
#line 266
    return ((Bool )0);
  }
#line 267
  if ((int )*(name + (n - 4)) == 46) {
#line 267
    if ((int )*(name + (n - 3)) == 98) {
#line 267
      if ((int )*(name + (n - 2)) == 122) {
#line 267
        if ((int )*(name + (n - 1)) == 50) {
#line 267
          tmp___0 = 1;
        } else {
#line 267
          tmp___0 = 0;
        }
      } else {
#line 267
        tmp___0 = 0;
      }
    } else {
#line 267
      tmp___0 = 0;
    }
  } else {
#line 267
    tmp___0 = 0;
  }
#line 267
  return ((Bool )tmp___0);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
FILE *fopen_output(Char *name , char const   *mode ) 
{ 
  FILE *fp ;
  int fh ;

  {
  {
#line 281
  fh = open((char const   *)name, 193, 384);
  }
#line 282
  if (fh == -1) {
#line 282
    return ((FILE *)((void *)0));
  }
  {
#line 283
  fp = fdopen(fh, mode);
  }
#line 284
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 284
    close(fh);
    }
  }
#line 285
  return (fp);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
MaybeUInt64 bStart[50000]  ;
#line 312 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
MaybeUInt64 bEnd[50000]  ;
#line 313 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
MaybeUInt64 rbStart[50000]  ;
#line 314 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
MaybeUInt64 rbEnd[50000]  ;
#line 316 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2recover.c"
Int32 main(Int32 argc , Char **argv ) 
{ 
  FILE *inFile ;
  FILE *outFile ;
  BitStream *bsIn ;
  BitStream *bsWr ;
  Int32 b ;
  Int32 wrBlock ;
  Int32 currBlock ;
  Int32 rbCtr ;
  MaybeUInt64 bitsRead ;
  UInt32 buffHi ;
  UInt32 buffLo ;
  UInt32 blockCRC ;
  Char *p ;
  size_t tmp ;
  size_t tmp___0 ;
  Char *split ;
  Int32 ofs ;
  Int32 k ;
  Bool tmp___1 ;

  {
  {
#line 327
  strcpy((char */* __restrict  */)(progName), (char const   */* __restrict  */)*(argv + 0));
#line 328
  outFileName[0] = (Char )0;
#line 328
  inFileName[0] = outFileName[0];
#line 330
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bzip2recover 1.0.6: extracts blocks from damaged .bz2 files.\n");
  }
#line 333
  if (argc != 2) {
    {
#line 334
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: usage is `%s damaged_file_name\'.\n",
            progName, progName);
    }
    {
#line 337
    if (sizeof(MaybeUInt64 ) == 8UL) {
#line 337
      goto case_8;
    }
#line 341
    if (sizeof(MaybeUInt64 ) == 4UL) {
#line 341
      goto case_4;
    }
#line 348
    goto switch_default;
    case_8: /* CIL Label */ 
    {
#line 338
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\trestrictions on size of recovered file: None\n");
    }
#line 340
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 342
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\trestrictions on size of recovered file: 512 MB\n");
#line 344
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tto circumvent, recompile with MaybeUInt64 as an\n\tunsigned 64-bit int.\n");
    }
#line 347
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 349
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tsizeof(MaybeUInt64) is not 4 or 8 -- configuration error.\n");
    }
#line 352
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 354
    exit(1);
    }
  }
  {
#line 357
  tmp___0 = strlen((char const   *)*(argv + 1));
  }
#line 357
  if (tmp___0 >= 1980UL) {
    {
#line 358
    tmp = strlen((char const   *)*(argv + 1));
#line 358
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: supplied filename is suspiciously (>= %d chars) long.  Bye!\n",
            progName, (int )tmp);
#line 361
    exit(1);
    }
  }
  {
#line 364
  strcpy((char */* __restrict  */)(inFileName), (char const   */* __restrict  */)*(argv + 1));
#line 366
  inFile = fopen((char const   */* __restrict  */)(inFileName), (char const   */* __restrict  */)"rb");
  }
#line 367
  if ((unsigned long )inFile == (unsigned long )((void *)0)) {
    {
#line 368
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t read `%s\'\n",
            progName, inFileName);
#line 369
    exit(1);
    }
  }
  {
#line 372
  bsIn = bsOpenReadStream(inFile);
#line 373
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: searching for block boundaries ...\n",
          progName);
#line 375
  bitsRead = (MaybeUInt64 )0;
#line 376
  buffLo = (UInt32 )0;
#line 376
  buffHi = buffLo;
#line 377
  currBlock = 0;
#line 378
  bStart[currBlock] = (MaybeUInt64 )0;
#line 380
  rbCtr = 0;
  }
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    b = bsGetBit(bsIn);
#line 384
    bitsRead ++;
    }
#line 385
    if (b == 2) {
#line 386
      if (bitsRead >= bStart[currBlock]) {
#line 386
        if (bitsRead - bStart[currBlock] >= 40ULL) {
#line 388
          bEnd[currBlock] = bitsRead - 1ULL;
#line 389
          if (currBlock > 0) {
            {
#line 390
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   block %d runs from %Lu to %Lu (incomplete)\n",
                    currBlock, bStart[currBlock], bEnd[currBlock]);
            }
          }
        } else {
#line 394
          currBlock --;
        }
      } else {
#line 394
        currBlock --;
      }
#line 395
      goto while_break;
    }
#line 397
    buffHi = (buffHi << 1) | (buffLo >> 31);
#line 398
    buffLo = (buffLo << 1) | (unsigned int )(b & 1);
#line 399
    if ((unsigned long )(buffHi & 65535U) == 12609UL) {
#line 399
      if ((unsigned long )buffLo == 1495683929UL) {
#line 399
        goto _L;
      } else {
#line 399
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 399
    if ((unsigned long )(buffHi & 65535U) == 6002UL) {
#line 399
      if ((unsigned long )buffLo == 1161318544UL) {
        _L: /* CIL Label */ 
#line 405
        if (bitsRead > 49ULL) {
#line 406
          bEnd[currBlock] = bitsRead - 49ULL;
        } else {
#line 408
          bEnd[currBlock] = (MaybeUInt64 )0;
        }
#line 410
        if (currBlock > 0) {
#line 410
          if (bEnd[currBlock] - bStart[currBlock] >= 130ULL) {
            {
#line 412
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   block %d runs from %Lu to %Lu\n",
                    rbCtr + 1, bStart[currBlock], bEnd[currBlock]);
#line 415
            rbStart[rbCtr] = bStart[currBlock];
#line 416
            rbEnd[rbCtr] = bEnd[currBlock];
#line 417
            rbCtr ++;
            }
          }
        }
#line 419
        if (currBlock >= 50000) {
          {
#line 420
          tooManyBlocks(50000);
          }
        }
#line 421
        currBlock ++;
#line 423
        bStart[currBlock] = bitsRead;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 427
  bsClose(bsIn);
  }
#line 431
  if (rbCtr < 1) {
    {
#line 432
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: sorry, I couldn\'t find any block boundaries.\n",
            progName);
#line 435
    exit(1);
    }
  }
  {
#line 438
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: splitting into blocks\n",
          progName);
#line 440
  inFile = fopen((char const   */* __restrict  */)(inFileName), (char const   */* __restrict  */)"rb");
  }
#line 441
  if ((unsigned long )inFile == (unsigned long )((void *)0)) {
    {
#line 442
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t open `%s\'\n",
            progName, inFileName);
#line 443
    exit(1);
    }
  }
  {
#line 445
  bsIn = bsOpenReadStream(inFile);
#line 448
  blockCRC = (UInt32 )0;
#line 448
  bsWr = (BitStream *)0;
#line 450
  bitsRead = (MaybeUInt64 )0;
#line 451
  outFile = (FILE *)((void *)0);
#line 452
  wrBlock = 0;
  }
  {
#line 453
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 454
    b = bsGetBit(bsIn);
    }
#line 455
    if (b == 2) {
#line 455
      goto while_break___0;
    }
#line 456
    buffHi = (buffHi << 1) | (buffLo >> 31);
#line 457
    buffLo = (buffLo << 1) | (unsigned int )(b & 1);
#line 458
    if (bitsRead == 47ULL + rbStart[wrBlock]) {
#line 459
      blockCRC = (buffHi << 16) | (buffLo >> 16);
    }
#line 461
    if ((unsigned long )outFile != (unsigned long )((void *)0)) {
#line 461
      if (bitsRead >= rbStart[wrBlock]) {
#line 461
        if (bitsRead <= rbEnd[wrBlock]) {
          {
#line 463
          bsPutBit(bsWr, b);
          }
        }
      }
    }
#line 466
    bitsRead ++;
#line 468
    if (bitsRead == rbEnd[wrBlock] + 1ULL) {
#line 469
      if ((unsigned long )outFile != (unsigned long )((void *)0)) {
        {
#line 470
        bsPutUChar(bsWr, (UChar )23);
#line 470
        bsPutUChar(bsWr, (UChar )114);
#line 471
        bsPutUChar(bsWr, (UChar )69);
#line 471
        bsPutUChar(bsWr, (UChar )56);
#line 472
        bsPutUChar(bsWr, (UChar )80);
#line 472
        bsPutUChar(bsWr, (UChar )144);
#line 473
        bsPutUInt32(bsWr, blockCRC);
#line 474
        bsClose(bsWr);
        }
      }
#line 476
      if (wrBlock >= rbCtr) {
#line 476
        goto while_break___0;
      }
#line 477
      wrBlock ++;
    } else
#line 479
    if (bitsRead == rbStart[wrBlock]) {
#line 484
      k = 0;
      {
#line 484
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 484
        if (! (k < 2000)) {
#line 484
          goto while_break___1;
        }
#line 485
        outFileName[k] = (Char )0;
#line 484
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 486
      strcpy((char */* __restrict  */)(outFileName), (char const   */* __restrict  */)(inFileName));
#line 487
      split = strrchr((char const   *)(outFileName), '/');
      }
#line 488
      if ((unsigned long )split == (unsigned long )((void *)0)) {
#line 489
        split = outFileName;
      } else {
#line 491
        split ++;
      }
      {
#line 494
      ofs = (Int32 )(split - outFileName);
#line 495
      sprintf((char */* __restrict  */)split, (char const   */* __restrict  */)"rec%5d",
              wrBlock + 1);
#line 496
      p = split;
      }
      {
#line 496
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 496
        if (! ((int )*p != 0)) {
#line 496
          goto while_break___2;
        }
#line 496
        if ((int )*p == 32) {
#line 496
          *p = (Char )'0';
        }
#line 496
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 497
      strcat((char */* __restrict  */)(outFileName), (char const   */* __restrict  */)(inFileName + ofs));
#line 499
      tmp___1 = endsInBz2(outFileName);
      }
#line 499
      if (! tmp___1) {
        {
#line 499
        strcat((char */* __restrict  */)(outFileName), (char const   */* __restrict  */)".bz2");
        }
      }
      {
#line 501
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   writing block %d to `%s\' ...\n",
              wrBlock + 1, outFileName);
#line 504
      outFile = fopen_output(outFileName, "wb");
      }
#line 505
      if ((unsigned long )outFile == (unsigned long )((void *)0)) {
        {
#line 506
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t write `%s\'\n",
                progName, outFileName);
#line 508
        exit(1);
        }
      }
      {
#line 510
      bsWr = bsOpenWriteStream(outFile);
#line 511
      bsPutUChar(bsWr, (UChar )66);
#line 512
      bsPutUChar(bsWr, (UChar )90);
#line 513
      bsPutUChar(bsWr, (UChar )104);
#line 514
      bsPutUChar(bsWr, (UChar )57);
#line 515
      bsPutUChar(bsWr, (UChar )49);
#line 515
      bsPutUChar(bsWr, (UChar )65);
#line 516
      bsPutUChar(bsWr, (UChar )89);
#line 516
      bsPutUChar(bsWr, (UChar )38);
#line 517
      bsPutUChar(bsWr, (UChar )83);
#line 517
      bsPutUChar(bsWr, (UChar )89);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 521
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: finished\n",
          progName);
  }
#line 522
  return (0);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib_private.h"
UInt32 BZ2_crc32Table[256] ;
#line 31 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/crctable.c"
UInt32 BZ2_crc32Table[256]  = 
#line 31 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/crctable.c"
  {      (UInt32 )0L,      (UInt32 )79764919L,      (UInt32 )159529838L,      (UInt32 )222504665L, 
        (UInt32 )319059676L,      (UInt32 )398814059L,      (UInt32 )445009330L,      (UInt32 )507990021L, 
        (UInt32 )638119352L,      (UInt32 )583659535L,      (UInt32 )797628118L,      (UInt32 )726387553L, 
        (UInt32 )890018660L,      (UInt32 )835552979L,      (UInt32 )1015980042L,      (UInt32 )944750013L, 
        (UInt32 )1276238704L,      (UInt32 )1221641927L,      (UInt32 )1167319070L,      (UInt32 )1095957929L, 
        (UInt32 )1595256236L,      (UInt32 )1540665371L,      (UInt32 )1452775106L,      (UInt32 )1381403509L, 
        (UInt32 )1780037320L,      (UInt32 )1859660671L,      (UInt32 )1671105958L,      (UInt32 )1733955601L, 
        (UInt32 )2031960084L,      (UInt32 )2111593891L,      (UInt32 )1889500026L,      (UInt32 )1952343757L, 
        (UInt32 )2552477408L,      (UInt32 )2632100695L,      (UInt32 )2443283854L,      (UInt32 )2506133561L, 
        (UInt32 )2334638140L,      (UInt32 )2414271883L,      (UInt32 )2191915858L,      (UInt32 )2254759653L, 
        (UInt32 )3190512472L,      (UInt32 )3135915759L,      (UInt32 )3081330742L,      (UInt32 )3009969537L, 
        (UInt32 )2905550212L,      (UInt32 )2850959411L,      (UInt32 )2762807018L,      (UInt32 )2691435357L, 
        (UInt32 )3560074640L,      (UInt32 )3505614887L,      (UInt32 )3719321342L,      (UInt32 )3648080713L, 
        (UInt32 )3342211916L,      (UInt32 )3287746299L,      (UInt32 )3467911202L,      (UInt32 )3396681109L, 
        (UInt32 )4063920168L,      (UInt32 )4143685023L,      (UInt32 )4223187782L,      (UInt32 )4286162673L, 
        (UInt32 )3779000052L,      (UInt32 )3858754371L,      (UInt32 )3904687514L,      (UInt32 )3967668269L, 
        (UInt32 )881225847L,      (UInt32 )809987520L,      (UInt32 )1023691545L,      (UInt32 )969234094L, 
        (UInt32 )662832811L,      (UInt32 )591600412L,      (UInt32 )771767749L,      (UInt32 )717299826L, 
        (UInt32 )311336399L,      (UInt32 )374308984L,      (UInt32 )453813921L,      (UInt32 )533576470L, 
        (UInt32 )25881363L,      (UInt32 )88864420L,      (UInt32 )134795389L,      (UInt32 )214552010L, 
        (UInt32 )2023205639L,      (UInt32 )2086057648L,      (UInt32 )1897238633L,      (UInt32 )1976864222L, 
        (UInt32 )1804852699L,      (UInt32 )1867694188L,      (UInt32 )1645340341L,      (UInt32 )1724971778L, 
        (UInt32 )1587496639L,      (UInt32 )1516133128L,      (UInt32 )1461550545L,      (UInt32 )1406951526L, 
        (UInt32 )1302016099L,      (UInt32 )1230646740L,      (UInt32 )1142491917L,      (UInt32 )1087903418L, 
        (UInt32 )2896545431L,      (UInt32 )2825181984L,      (UInt32 )2770861561L,      (UInt32 )2716262478L, 
        (UInt32 )3215044683L,      (UInt32 )3143675388L,      (UInt32 )3055782693L,      (UInt32 )3001194130L, 
        (UInt32 )2326604591L,      (UInt32 )2389456536L,      (UInt32 )2200899649L,      (UInt32 )2280525302L, 
        (UInt32 )2578013683L,      (UInt32 )2640855108L,      (UInt32 )2418763421L,      (UInt32 )2498394922L, 
        (UInt32 )3769900519L,      (UInt32 )3832873040L,      (UInt32 )3912640137L,      (UInt32 )3992402750L, 
        (UInt32 )4088425275L,      (UInt32 )4151408268L,      (UInt32 )4197601365L,      (UInt32 )4277358050L, 
        (UInt32 )3334271071L,      (UInt32 )3263032808L,      (UInt32 )3476998961L,      (UInt32 )3422541446L, 
        (UInt32 )3585640067L,      (UInt32 )3514407732L,      (UInt32 )3694837229L,      (UInt32 )3640369242L, 
        (UInt32 )1762451694L,      (UInt32 )1842216281L,      (UInt32 )1619975040L,      (UInt32 )1682949687L, 
        (UInt32 )2047383090L,      (UInt32 )2127137669L,      (UInt32 )1938468188L,      (UInt32 )2001449195L, 
        (UInt32 )1325665622L,      (UInt32 )1271206113L,      (UInt32 )1183200824L,      (UInt32 )1111960463L, 
        (UInt32 )1543535498L,      (UInt32 )1489069629L,      (UInt32 )1434599652L,      (UInt32 )1363369299L, 
        (UInt32 )622672798L,      (UInt32 )568075817L,      (UInt32 )748617968L,      (UInt32 )677256519L, 
        (UInt32 )907627842L,      (UInt32 )853037301L,      (UInt32 )1067152940L,      (UInt32 )995781531L, 
        (UInt32 )51762726L,      (UInt32 )131386257L,      (UInt32 )177728840L,      (UInt32 )240578815L, 
        (UInt32 )269590778L,      (UInt32 )349224269L,      (UInt32 )429104020L,      (UInt32 )491947555L, 
        (UInt32 )4046411278L,      (UInt32 )4126034873L,      (UInt32 )4172115296L,      (UInt32 )4234965207L, 
        (UInt32 )3794477266L,      (UInt32 )3874110821L,      (UInt32 )3953728444L,      (UInt32 )4016571915L, 
        (UInt32 )3609705398L,      (UInt32 )3555108353L,      (UInt32 )3735388376L,      (UInt32 )3664026991L, 
        (UInt32 )3290680682L,      (UInt32 )3236090077L,      (UInt32 )3449943556L,      (UInt32 )3378572211L, 
        (UInt32 )3174993278L,      (UInt32 )3120533705L,      (UInt32 )3032266256L,      (UInt32 )2961025959L, 
        (UInt32 )2923101090L,      (UInt32 )2868635157L,      (UInt32 )2813903052L,      (UInt32 )2742672763L, 
        (UInt32 )2604032198L,      (UInt32 )2683796849L,      (UInt32 )2461293480L,      (UInt32 )2524268063L, 
        (UInt32 )2284983834L,      (UInt32 )2364738477L,      (UInt32 )2175806836L,      (UInt32 )2238787779L, 
        (UInt32 )1569362073L,      (UInt32 )1498123566L,      (UInt32 )1409854455L,      (UInt32 )1355396672L, 
        (UInt32 )1317987909L,      (UInt32 )1246755826L,      (UInt32 )1192025387L,      (UInt32 )1137557660L, 
        (UInt32 )2072149281L,      (UInt32 )2135122070L,      (UInt32 )1912620623L,      (UInt32 )1992383480L, 
        (UInt32 )1753615357L,      (UInt32 )1816598090L,      (UInt32 )1627664531L,      (UInt32 )1707420964L, 
        (UInt32 )295390185L,      (UInt32 )358241886L,      (UInt32 )404320391L,      (UInt32 )483945776L, 
        (UInt32 )43990325L,      (UInt32 )106832002L,      (UInt32 )186451547L,      (UInt32 )266083308L, 
        (UInt32 )932423249L,      (UInt32 )861060070L,      (UInt32 )1041341759L,      (UInt32 )986742920L, 
        (UInt32 )613929101L,      (UInt32 )542559546L,      (UInt32 )756411363L,      (UInt32 )701822548L, 
        (UInt32 )3316196985L,      (UInt32 )3244833742L,      (UInt32 )3425377559L,      (UInt32 )3370778784L, 
        (UInt32 )3601682597L,      (UInt32 )3530312978L,      (UInt32 )3744426955L,      (UInt32 )3689838204L, 
        (UInt32 )3819031489L,      (UInt32 )3881883254L,      (UInt32 )3928223919L,      (UInt32 )4007849240L, 
        (UInt32 )4037393693L,      (UInt32 )4100235434L,      (UInt32 )4180117107L,      (UInt32 )4259748804L, 
        (UInt32 )2310601993L,      (UInt32 )2373574846L,      (UInt32 )2151335527L,      (UInt32 )2231098320L, 
        (UInt32 )2596047829L,      (UInt32 )2659030626L,      (UInt32 )2470359227L,      (UInt32 )2550115596L, 
        (UInt32 )2947551409L,      (UInt32 )2876312838L,      (UInt32 )2788305887L,      (UInt32 )2733848168L, 
        (UInt32 )3165939309L,      (UInt32 )3094707162L,      (UInt32 )3040238851L,      (UInt32 )2985771188L};
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 100 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.h"
int BZ2_bzCompressInit(bz_stream *strm , int blockSize100k___0 , int verbosity___0 ,
                       int workFactor___0 ) ;
#line 107
int BZ2_bzCompress(bz_stream *strm , int action ) ;
#line 112
int BZ2_bzCompressEnd(bz_stream *strm ) ;
#line 116
int BZ2_bzDecompressInit(bz_stream *strm , int verbosity___0 , int small ) ;
#line 122
int BZ2_bzDecompress(bz_stream *strm ) ;
#line 126
int BZ2_bzDecompressEnd(bz_stream *strm ) ;
#line 139
BZFILE *BZ2_bzReadOpen(int *bzerror , FILE *f , int verbosity___0 , int small , void *unused ,
                       int nUnused ) ;
#line 148
void BZ2_bzReadClose(int *bzerror , BZFILE *b ) ;
#line 153
void BZ2_bzReadGetUnused(int *bzerror , BZFILE *b , void **unused , int *nUnused ) ;
#line 160
int BZ2_bzRead(int *bzerror , BZFILE *b , void *buf , int len ) ;
#line 167
BZFILE *BZ2_bzWriteOpen(int *bzerror , FILE *f , int blockSize100k___0 , int verbosity___0 ,
                        int workFactor___0 ) ;
#line 175
void BZ2_bzWrite(int *bzerror , BZFILE *b , void *buf , int len ) ;
#line 182
void BZ2_bzWriteClose(int *bzerror , BZFILE *b , int abandon , unsigned int *nbytes_in ,
                      unsigned int *nbytes_out ) ;
#line 190
void BZ2_bzWriteClose64(int *bzerror , BZFILE *b , int abandon , unsigned int *nbytes_in_lo32 ,
                        unsigned int *nbytes_in_hi32 , unsigned int *nbytes_out_lo32 ,
                        unsigned int *nbytes_out_hi32 ) ;
#line 204
int BZ2_bzBuffToBuffCompress(char *dest , unsigned int *destLen , char *source , unsigned int sourceLen ,
                             int blockSize100k___0 , int verbosity___0 , int workFactor___0 ) ;
#line 214
int BZ2_bzBuffToBuffDecompress(char *dest , unsigned int *destLen , char *source ,
                               unsigned int sourceLen , int small , int verbosity___0 ) ;
#line 233
char const   *BZ2_bzlibVersion(void) ;
#line 238
BZFILE *BZ2_bzopen(char const   *path , char const   *mode ) ;
#line 243
BZFILE *BZ2_bzdopen(int fd , char const   *mode ) ;
#line 248
int BZ2_bzread(BZFILE *b , void *buf , int len ) ;
#line 254
int BZ2_bzwrite(BZFILE *b , void *buf , int len ) ;
#line 260
int BZ2_bzflush(BZFILE *b ) ;
#line 264
void BZ2_bzclose(BZFILE *b ) ;
#line 268
char const   *BZ2_bzerror(BZFILE *b , int *errnum ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib_private.h"
void BZ2_bz__AssertH__fail(int errcode ) ;
#line 131
Int32 BZ2_rNums[512] ;
#line 275
void BZ2_compressBlock(EState *s , Bool is_last_block ) ;
#line 484
__inline Int32 BZ2_indexIntoF(Int32 indx , Int32 *cftab ) ;
#line 487
Int32 BZ2_decompress(DState *s ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
void BZ2_bz__AssertH__fail(int errcode ) 
{ 
  char const   *tmp ;

  {
  {
#line 43
  tmp = BZ2_bzlibVersion();
#line 43
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\nbzip2/libbzip2: internal error number %d.\nThis is a bug in bzip2/libbzip2, %s.\nPlease report it to me at: jseward@bzip.org.  If this happened\nwhen you were using some program which uses libbzip2 as a\ncomponent, you should also report this bug to the author(s)\nof that program.  Please make an effort to report this bug;\ntimely and accurate bug reports eventually lead to higher\nquality software.  Thanks.  Julian Seward, 10 December 2007.\n\n",
          errcode, tmp);
  }
#line 56
  if (errcode == 1007) {
    {
#line 57
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n*** A special note about internal error number 1007 ***\n\nExperience suggests that a common cause of i.e. 1007\nis unreliable memory or other hardware.  The 1007 assertion\njust happens to cross-check the results of huge numbers of\nmemory reads/writes, and so acts (unintendedly) as a stress\ntest of your memory system.\n\nI suggest the following: try compressing the file again,\npossibly monitoring progress in detail with the -vv flag.\n\n* If the error cannot be reproduced, and/or happens at different\n  points in compression, you may have a flaky memory system.\n  Try a memory-test program.  I have used Memtest86\n  (www.memtest86.com).  At the time of writing it is free (GPLd).\n  Memtest86 tests memory much more thorougly than your BIOSs\n  power-on test, and may find failures that the BIOS doesn\'t.\n\n* If the error can be repeatably reproduced, this is a bug in\n  bzip2, and I would very much like to hear about it.  Please\n  let me know, and, ideally, save a copy of the file causing the\n  problem -- without which I will be unable to investigate it.\n\n");
    }
  }
  {
#line 84
  exit(3);
  }
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static int bz_config_ok(void) 
{ 


  {
#line 93
  if (sizeof(int ) != 4UL) {
#line 93
    return (0);
  }
#line 94
  if (sizeof(short ) != 2UL) {
#line 94
    return (0);
  }
#line 95
  if (sizeof(char ) != 1UL) {
#line 95
    return (0);
  }
#line 96
  return (1);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static void *default_bzalloc(void *opaque , Int32 items , Int32 size ) 
{ 
  void *v ;
  void *tmp ;

  {
  {
#line 104
  tmp = malloc((size_t )(items * size));
#line 104
  v = tmp;
  }
#line 105
  return (v);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static void default_bzfree(void *opaque , void *addr ) 
{ 


  {
#line 111
  if ((unsigned long )addr != (unsigned long )((void *)0)) {
    {
#line 111
    free(addr);
    }
  }
#line 112
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static void prepare_new_block(EState *s ) 
{ 
  Int32 i ;

  {
#line 120
  s->nblock = 0;
#line 121
  s->numZ = 0;
#line 122
  s->state_out_pos = 0;
#line 123
  s->blockCRC = (UInt32 )4294967295L;
#line 124
  i = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < 256)) {
#line 124
      goto while_break;
    }
#line 124
    s->inUse[i] = (Bool )0;
#line 124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  (s->blockNo) ++;
#line 126
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static void init_RL(EState *s ) 
{ 


  {
#line 133
  s->state_in_ch = (UInt32 )256;
#line 134
  s->state_in_len = 0;
#line 135
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static Bool isempty_RL(EState *s ) 
{ 


  {
#line 141
  if (s->state_in_ch < 256U) {
#line 141
    if (s->state_in_len > 0) {
#line 142
      return ((Bool )0);
    } else {
#line 143
      return ((Bool )1);
    }
  } else {
#line 143
    return ((Bool )1);
  }
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
int BZ2_bzCompressInit(bz_stream *strm , int blockSize100k___0 , int verbosity___0 ,
                       int workFactor___0 ) 
{ 
  Int32 n ;
  EState *s ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 157
  tmp = bz_config_ok();
  }
#line 157
  if (! tmp) {
#line 157
    return (-9);
  }
#line 159
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
#line 162
    return (-2);
  } else
#line 159
  if (blockSize100k___0 < 1) {
#line 162
    return (-2);
  } else
#line 159
  if (blockSize100k___0 > 9) {
#line 162
    return (-2);
  } else
#line 159
  if (workFactor___0 < 0) {
#line 162
    return (-2);
  } else
#line 159
  if (workFactor___0 > 250) {
#line 162
    return (-2);
  }
#line 164
  if (workFactor___0 == 0) {
#line 164
    workFactor___0 = 30;
  }
#line 165
  if ((unsigned long )strm->bzalloc == (unsigned long )((void *)0)) {
#line 165
    strm->bzalloc = & default_bzalloc;
  }
#line 166
  if ((unsigned long )strm->bzfree == (unsigned long )((void *)0)) {
#line 166
    strm->bzfree = & default_bzfree;
  }
  {
#line 168
  tmp___0 = (*(strm->bzalloc))(strm->opaque, (int )sizeof(EState ), 1);
#line 168
  s = (EState *)tmp___0;
  }
#line 169
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 169
    return (-3);
  }
  {
#line 170
  s->strm = strm;
#line 172
  s->arr1 = (UInt32 *)((void *)0);
#line 173
  s->arr2 = (UInt32 *)((void *)0);
#line 174
  s->ftab = (UInt32 *)((void *)0);
#line 176
  n = 100000 * blockSize100k___0;
#line 177
  tmp___1 = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )n * sizeof(UInt32 )),
                               1);
#line 177
  s->arr1 = (UInt32 *)tmp___1;
#line 178
  tmp___2 = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )(n + 34) * sizeof(UInt32 )),
                               1);
#line 178
  s->arr2 = (UInt32 *)tmp___2;
#line 179
  tmp___3 = (*(strm->bzalloc))(strm->opaque, (int )(65537UL * sizeof(UInt32 )), 1);
#line 179
  s->ftab = (UInt32 *)tmp___3;
  }
#line 181
  if ((unsigned long )s->arr1 == (unsigned long )((void *)0)) {
#line 181
    goto _L;
  } else
#line 181
  if ((unsigned long )s->arr2 == (unsigned long )((void *)0)) {
#line 181
    goto _L;
  } else
#line 181
  if ((unsigned long )s->ftab == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 182
    if ((unsigned long )s->arr1 != (unsigned long )((void *)0)) {
      {
#line 182
      (*(strm->bzfree))(strm->opaque, (void *)s->arr1);
      }
    }
#line 183
    if ((unsigned long )s->arr2 != (unsigned long )((void *)0)) {
      {
#line 183
      (*(strm->bzfree))(strm->opaque, (void *)s->arr2);
      }
    }
#line 184
    if ((unsigned long )s->ftab != (unsigned long )((void *)0)) {
      {
#line 184
      (*(strm->bzfree))(strm->opaque, (void *)s->ftab);
      }
    }
#line 185
    if ((unsigned long )s != (unsigned long )((void *)0)) {
      {
#line 185
      (*(strm->bzfree))(strm->opaque, (void *)s);
      }
    }
#line 186
    return (-3);
  }
  {
#line 189
  s->blockNo = 0;
#line 190
  s->state = 2;
#line 191
  s->mode = 2;
#line 192
  s->combinedCRC = (UInt32 )0;
#line 193
  s->blockSize100k = blockSize100k___0;
#line 194
  s->nblockMAX = 100000 * blockSize100k___0 - 19;
#line 195
  s->verbosity = verbosity___0;
#line 196
  s->workFactor = workFactor___0;
#line 198
  s->block = (UChar *)s->arr2;
#line 199
  s->mtfv = (UInt16 *)s->arr1;
#line 200
  s->zbits = (UChar *)((void *)0);
#line 201
  s->ptr = s->arr1;
#line 203
  strm->state = (void *)s;
#line 204
  strm->total_in_lo32 = 0U;
#line 205
  strm->total_in_hi32 = 0U;
#line 206
  strm->total_out_lo32 = 0U;
#line 207
  strm->total_out_hi32 = 0U;
#line 208
  init_RL(s);
#line 209
  prepare_new_block(s);
  }
#line 210
  return (0);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static void add_pair_to_block(EState *s ) 
{ 
  Int32 i ;
  UChar ch ;

  {
#line 219
  ch = (UChar )s->state_in_ch;
#line 220
  i = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (i < s->state_in_len)) {
#line 220
      goto while_break;
    }
#line 221
    s->blockCRC = (s->blockCRC << 8) ^ BZ2_crc32Table[(s->blockCRC >> 24) ^ (unsigned int )ch];
#line 220
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  s->inUse[s->state_in_ch] = (Bool )1;
  {
#line 225
  if (s->state_in_len == 1) {
#line 225
    goto case_1;
  }
#line 228
  if (s->state_in_len == 2) {
#line 228
    goto case_2;
  }
#line 232
  if (s->state_in_len == 3) {
#line 232
    goto case_3;
  }
#line 237
  goto switch_default;
  case_1: /* CIL Label */ 
#line 226
  *(s->block + s->nblock) = ch;
#line 226
  (s->nblock) ++;
#line 227
  goto switch_break;
  case_2: /* CIL Label */ 
#line 229
  *(s->block + s->nblock) = ch;
#line 229
  (s->nblock) ++;
#line 230
  *(s->block + s->nblock) = ch;
#line 230
  (s->nblock) ++;
#line 231
  goto switch_break;
  case_3: /* CIL Label */ 
#line 233
  *(s->block + s->nblock) = ch;
#line 233
  (s->nblock) ++;
#line 234
  *(s->block + s->nblock) = ch;
#line 234
  (s->nblock) ++;
#line 235
  *(s->block + s->nblock) = ch;
#line 235
  (s->nblock) ++;
#line 236
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 238
  s->inUse[s->state_in_len - 4] = (Bool )1;
#line 239
  *(s->block + s->nblock) = ch;
#line 239
  (s->nblock) ++;
#line 240
  *(s->block + s->nblock) = ch;
#line 240
  (s->nblock) ++;
#line 241
  *(s->block + s->nblock) = ch;
#line 241
  (s->nblock) ++;
#line 242
  *(s->block + s->nblock) = ch;
#line 242
  (s->nblock) ++;
#line 243
  *(s->block + s->nblock) = (UChar )(s->state_in_len - 4);
#line 244
  (s->nblock) ++;
#line 245
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 247
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static void flush_RL(EState *s ) 
{ 


  {
#line 254
  if (s->state_in_ch < 256U) {
    {
#line 254
    add_pair_to_block(s);
    }
  }
  {
#line 255
  init_RL(s);
  }
#line 256
  return;
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static Bool copy_input_until_stop(EState *s ) 
{ 
  Bool progress_in ;
  UInt32 zchh ;
  UChar ch ;
  UInt32 zchh___0 ;
  UChar ch___0 ;

  {
#line 291
  progress_in = (Bool )0;
#line 293
  if (s->mode == 2) {
    {
#line 296
    while (1) {
      while_continue: /* CIL Label */ ;
#line 298
      if (s->nblock >= s->nblockMAX) {
#line 298
        goto while_break;
      }
#line 300
      if ((s->strm)->avail_in == 0U) {
#line 300
        goto while_break;
      }
#line 301
      progress_in = (Bool )1;
#line 302
      zchh = (UInt32 )*((UChar *)(s->strm)->next_in);
#line 302
      if (zchh != s->state_in_ch) {
#line 302
        if (s->state_in_len == 1) {
#line 302
          ch = (UChar )s->state_in_ch;
#line 302
          s->blockCRC = (s->blockCRC << 8) ^ BZ2_crc32Table[(s->blockCRC >> 24) ^ (unsigned int )ch];
#line 302
          s->inUse[s->state_in_ch] = (Bool )1;
#line 302
          *(s->block + s->nblock) = ch;
#line 302
          (s->nblock) ++;
#line 302
          s->state_in_ch = zchh;
        } else {
#line 302
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 302
      if (zchh != s->state_in_ch) {
#line 302
        goto _L;
      } else
#line 302
      if (s->state_in_len == 255) {
        _L: /* CIL Label */ 
#line 302
        if (s->state_in_ch < 256U) {
          {
#line 302
          add_pair_to_block(s);
          }
        }
#line 302
        s->state_in_ch = zchh;
#line 302
        s->state_in_len = 1;
      } else {
#line 302
        (s->state_in_len) ++;
      }
#line 303
      ((s->strm)->next_in) ++;
#line 304
      ((s->strm)->avail_in) --;
#line 305
      ((s->strm)->total_in_lo32) ++;
#line 306
      if ((s->strm)->total_in_lo32 == 0U) {
#line 306
        ((s->strm)->total_in_hi32) ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 312
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 314
      if (s->nblock >= s->nblockMAX) {
#line 314
        goto while_break___0;
      }
#line 316
      if ((s->strm)->avail_in == 0U) {
#line 316
        goto while_break___0;
      }
#line 318
      if (s->avail_in_expect == 0U) {
#line 318
        goto while_break___0;
      }
#line 319
      progress_in = (Bool )1;
#line 320
      zchh___0 = (UInt32 )*((UChar *)(s->strm)->next_in);
#line 320
      if (zchh___0 != s->state_in_ch) {
#line 320
        if (s->state_in_len == 1) {
#line 320
          ch___0 = (UChar )s->state_in_ch;
#line 320
          s->blockCRC = (s->blockCRC << 8) ^ BZ2_crc32Table[(s->blockCRC >> 24) ^ (unsigned int )ch___0];
#line 320
          s->inUse[s->state_in_ch] = (Bool )1;
#line 320
          *(s->block + s->nblock) = ch___0;
#line 320
          (s->nblock) ++;
#line 320
          s->state_in_ch = zchh___0;
        } else {
#line 320
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 320
      if (zchh___0 != s->state_in_ch) {
#line 320
        goto _L___1;
      } else
#line 320
      if (s->state_in_len == 255) {
        _L___1: /* CIL Label */ 
#line 320
        if (s->state_in_ch < 256U) {
          {
#line 320
          add_pair_to_block(s);
          }
        }
#line 320
        s->state_in_ch = zchh___0;
#line 320
        s->state_in_len = 1;
      } else {
#line 320
        (s->state_in_len) ++;
      }
#line 321
      ((s->strm)->next_in) ++;
#line 322
      ((s->strm)->avail_in) --;
#line 323
      ((s->strm)->total_in_lo32) ++;
#line 324
      if ((s->strm)->total_in_lo32 == 0U) {
#line 324
        ((s->strm)->total_in_hi32) ++;
      }
#line 325
      (s->avail_in_expect) --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 328
  return (progress_in);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static Bool copy_output_until_stop(EState *s ) 
{ 
  Bool progress_out ;

  {
#line 336
  progress_out = (Bool )0;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if ((s->strm)->avail_out == 0U) {
#line 341
      goto while_break;
    }
#line 344
    if (s->state_out_pos >= s->numZ) {
#line 344
      goto while_break;
    }
#line 346
    progress_out = (Bool )1;
#line 347
    *((s->strm)->next_out) = (char )*(s->zbits + s->state_out_pos);
#line 348
    (s->state_out_pos) ++;
#line 349
    ((s->strm)->avail_out) --;
#line 350
    ((s->strm)->next_out) ++;
#line 351
    ((s->strm)->total_out_lo32) ++;
#line 352
    if ((s->strm)->total_out_lo32 == 0U) {
#line 352
      ((s->strm)->total_out_hi32) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return (progress_out);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static Bool handle_compress(bz_stream *strm ) 
{ 
  Bool progress_in ;
  Bool progress_out ;
  EState *s ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;
  Bool tmp___2 ;
  int tmp___3 ;

  {
#line 363
  progress_in = (Bool )0;
#line 364
  progress_out = (Bool )0;
#line 365
  s = (EState *)strm->state;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (s->state == 1) {
      {
#line 370
      tmp = copy_output_until_stop(s);
#line 370
      progress_out = (Bool )((int )progress_out | (int )tmp);
      }
#line 371
      if (s->state_out_pos < s->numZ) {
#line 371
        goto while_break;
      }
#line 372
      if (s->mode == 4) {
#line 372
        if (s->avail_in_expect == 0U) {
          {
#line 372
          tmp___0 = isempty_RL(s);
          }
#line 372
          if (tmp___0) {
#line 374
            goto while_break;
          }
        }
      }
      {
#line 375
      prepare_new_block(s);
#line 376
      s->state = 2;
      }
#line 377
      if (s->mode == 3) {
#line 377
        if (s->avail_in_expect == 0U) {
          {
#line 377
          tmp___1 = isempty_RL(s);
          }
#line 377
          if (tmp___1) {
#line 379
            goto while_break;
          }
        }
      }
    }
#line 382
    if (s->state == 2) {
      {
#line 383
      tmp___2 = copy_input_until_stop(s);
#line 383
      progress_in = (Bool )((int )progress_in | (int )tmp___2);
      }
#line 384
      if (s->mode != 2) {
#line 384
        if (s->avail_in_expect == 0U) {
          {
#line 385
          flush_RL(s);
#line 386
          BZ2_compressBlock(s, (Bool )(s->mode == 4));
#line 387
          s->state = 1;
          }
        } else {
#line 384
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 390
      if (s->nblock >= s->nblockMAX) {
        {
#line 391
        BZ2_compressBlock(s, (Bool )0);
#line 392
        s->state = 1;
        }
      } else
#line 395
      if ((s->strm)->avail_in == 0U) {
#line 396
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 402
  if (progress_in) {
#line 402
    tmp___3 = 1;
  } else
#line 402
  if (progress_out) {
#line 402
    tmp___3 = 1;
  } else {
#line 402
    tmp___3 = 0;
  }
#line 402
  return ((Bool )tmp___3);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
int BZ2_bzCompress(bz_stream *strm , int action ) 
{ 
  Bool progress ;
  EState *s ;
  int tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;

  {
#line 411
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
#line 411
    return (-2);
  }
#line 412
  s = (EState *)strm->state;
#line 413
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 413
    return (-2);
  }
#line 414
  if ((unsigned long )s->strm != (unsigned long )strm) {
#line 414
    return (-2);
  }
  preswitch: 
  {
#line 419
  if (s->mode == 1) {
#line 419
    goto case_1;
  }
#line 422
  if (s->mode == 2) {
#line 422
    goto case_2;
  }
#line 442
  if (s->mode == 3) {
#line 442
    goto case_3;
  }
#line 452
  if (s->mode == 4) {
#line 452
    goto case_4;
  }
#line 417
  goto switch_break;
  case_1: /* CIL Label */ 
#line 420
  return (-1);
  case_2: /* CIL Label */ 
#line 423
  if (action == 0) {
    {
#line 424
    progress = handle_compress(strm);
    }
#line 425
    if (progress) {
#line 425
      tmp = 1;
    } else {
#line 425
      tmp = -2;
    }
#line 425
    return (tmp);
  } else
#line 428
  if (action == 1) {
#line 429
    s->avail_in_expect = strm->avail_in;
#line 430
    s->mode = 3;
#line 431
    goto preswitch;
  } else
#line 434
  if (action == 2) {
#line 435
    s->avail_in_expect = strm->avail_in;
#line 436
    s->mode = 4;
#line 437
    goto preswitch;
  } else {
#line 440
    return (-2);
  }
  case_3: /* CIL Label */ 
#line 443
  if (action != 1) {
#line 443
    return (-1);
  }
#line 444
  if (s->avail_in_expect != (s->strm)->avail_in) {
#line 445
    return (-1);
  }
  {
#line 446
  progress = handle_compress(strm);
  }
#line 447
  if (s->avail_in_expect > 0U) {
#line 448
    return (2);
  } else {
    {
#line 447
    tmp___0 = isempty_RL(s);
    }
#line 447
    if (tmp___0) {
#line 447
      if (s->state_out_pos < s->numZ) {
#line 448
        return (2);
      }
    } else {
#line 448
      return (2);
    }
  }
#line 449
  s->mode = 2;
#line 450
  return (1);
  case_4: /* CIL Label */ 
#line 453
  if (action != 2) {
#line 453
    return (-1);
  }
#line 454
  if (s->avail_in_expect != (s->strm)->avail_in) {
#line 455
    return (-1);
  }
  {
#line 456
  progress = handle_compress(strm);
  }
#line 457
  if (! progress) {
#line 457
    return (-1);
  }
#line 458
  if (s->avail_in_expect > 0U) {
#line 459
    return (3);
  } else {
    {
#line 458
    tmp___1 = isempty_RL(s);
    }
#line 458
    if (tmp___1) {
#line 458
      if (s->state_out_pos < s->numZ) {
#line 459
        return (3);
      }
    } else {
#line 459
      return (3);
    }
  }
#line 460
  s->mode = 1;
#line 461
  return (4);
  switch_break: /* CIL Label */ ;
  }
#line 463
  return (0);
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
int BZ2_bzCompressEnd(bz_stream *strm ) 
{ 
  EState *s ;

  {
#line 471
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
#line 471
    return (-2);
  }
#line 472
  s = (EState *)strm->state;
#line 473
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 473
    return (-2);
  }
#line 474
  if ((unsigned long )s->strm != (unsigned long )strm) {
#line 474
    return (-2);
  }
#line 476
  if ((unsigned long )s->arr1 != (unsigned long )((void *)0)) {
    {
#line 476
    (*(strm->bzfree))(strm->opaque, (void *)s->arr1);
    }
  }
#line 477
  if ((unsigned long )s->arr2 != (unsigned long )((void *)0)) {
    {
#line 477
    (*(strm->bzfree))(strm->opaque, (void *)s->arr2);
    }
  }
#line 478
  if ((unsigned long )s->ftab != (unsigned long )((void *)0)) {
    {
#line 478
    (*(strm->bzfree))(strm->opaque, (void *)s->ftab);
    }
  }
  {
#line 479
  (*(strm->bzfree))(strm->opaque, strm->state);
#line 481
  strm->state = (void *)0;
  }
#line 483
  return (0);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
int BZ2_bzDecompressInit(bz_stream *strm , int verbosity___0 , int small ) 
{ 
  DState *s ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 499
  tmp = bz_config_ok();
  }
#line 499
  if (! tmp) {
#line 499
    return (-9);
  }
#line 501
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
#line 501
    return (-2);
  }
#line 502
  if (small != 0) {
#line 502
    if (small != 1) {
#line 502
      return (-2);
    }
  }
#line 503
  if (verbosity___0 < 0) {
#line 503
    return (-2);
  } else
#line 503
  if (verbosity___0 > 4) {
#line 503
    return (-2);
  }
#line 505
  if ((unsigned long )strm->bzalloc == (unsigned long )((void *)0)) {
#line 505
    strm->bzalloc = & default_bzalloc;
  }
#line 506
  if ((unsigned long )strm->bzfree == (unsigned long )((void *)0)) {
#line 506
    strm->bzfree = & default_bzfree;
  }
  {
#line 508
  tmp___0 = (*(strm->bzalloc))(strm->opaque, (int )sizeof(DState ), 1);
#line 508
  s = (DState *)tmp___0;
  }
#line 509
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 509
    return (-3);
  }
#line 510
  s->strm = strm;
#line 511
  strm->state = (void *)s;
#line 512
  s->state = 10;
#line 513
  s->bsLive = 0;
#line 514
  s->bsBuff = (UInt32 )0;
#line 515
  s->calculatedCombinedCRC = (UInt32 )0;
#line 516
  strm->total_in_lo32 = 0U;
#line 517
  strm->total_in_hi32 = 0U;
#line 518
  strm->total_out_lo32 = 0U;
#line 519
  strm->total_out_hi32 = 0U;
#line 520
  s->smallDecompress = (Bool )small;
#line 521
  s->ll4 = (UChar *)((void *)0);
#line 522
  s->ll16 = (UInt16 *)((void *)0);
#line 523
  s->tt = (UInt32 *)((void *)0);
#line 524
  s->currBlockNo = 0;
#line 525
  s->verbosity = verbosity___0;
#line 527
  return (0);
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static Bool unRLE_obuf_to_output_FAST(DState *s ) 
{ 
  UChar k1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  UInt32 c_calculatedBlockCRC ;
  UChar c_state_out_ch ;
  Int32 c_state_out_len ;
  Int32 c_nblock_used ;
  Int32 c_k0 ;
  UInt32 *c_tt ;
  UInt32 c_tPos ;
  char *cs_next_out ;
  unsigned int cs_avail_out ;
  Int32 ro_blockSize100k ;
  UInt32 avail_out_INIT ;
  Int32 s_save_nblockPP ;
  unsigned int total_out_lo32_old ;

  {
#line 540
  if (s->blockRandomised) {
    {
#line 542
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 544
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 545
        if ((s->strm)->avail_out == 0U) {
#line 545
          return ((Bool )0);
        }
#line 546
        if (s->state_out_len == 0) {
#line 546
          goto while_break___0;
        }
#line 547
        *((UChar *)(s->strm)->next_out) = s->state_out_ch;
#line 548
        s->calculatedBlockCRC = (s->calculatedBlockCRC << 8) ^ BZ2_crc32Table[(s->calculatedBlockCRC >> 24) ^ (unsigned int )s->state_out_ch];
#line 549
        (s->state_out_len) --;
#line 550
        ((s->strm)->next_out) ++;
#line 551
        ((s->strm)->avail_out) --;
#line 552
        ((s->strm)->total_out_lo32) ++;
#line 553
        if ((s->strm)->total_out_lo32 == 0U) {
#line 553
          ((s->strm)->total_out_hi32) ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 557
      if (s->nblock_used == s->save_nblock + 1) {
#line 557
        return ((Bool )0);
      }
#line 560
      if (s->nblock_used > s->save_nblock + 1) {
#line 561
        return ((Bool )1);
      }
#line 563
      s->state_out_len = 1;
#line 564
      s->state_out_ch = (UChar )s->k0;
#line 565
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 565
        return ((Bool )1);
      }
#line 565
      s->tPos = *(s->tt + s->tPos);
#line 565
      k1 = (UChar )(s->tPos & 255U);
#line 565
      s->tPos >>= 8;
#line 565
      if (s->rNToGo == 0) {
#line 565
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 565
        (s->rTPos) ++;
#line 565
        if (s->rTPos == 512) {
#line 565
          s->rTPos = 0;
        }
      }
#line 565
      (s->rNToGo) --;
#line 566
      if (s->rNToGo == 1) {
#line 566
        tmp = 1;
      } else {
#line 566
        tmp = 0;
      }
#line 566
      k1 = (UChar )((int )k1 ^ tmp);
#line 566
      (s->nblock_used) ++;
#line 567
      if (s->nblock_used == s->save_nblock + 1) {
#line 567
        goto while_continue;
      }
#line 568
      if ((int )k1 != s->k0) {
#line 568
        s->k0 = (Int32 )k1;
#line 568
        goto while_continue;
      }
#line 570
      s->state_out_len = 2;
#line 571
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 571
        return ((Bool )1);
      }
#line 571
      s->tPos = *(s->tt + s->tPos);
#line 571
      k1 = (UChar )(s->tPos & 255U);
#line 571
      s->tPos >>= 8;
#line 571
      if (s->rNToGo == 0) {
#line 571
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 571
        (s->rTPos) ++;
#line 571
        if (s->rTPos == 512) {
#line 571
          s->rTPos = 0;
        }
      }
#line 571
      (s->rNToGo) --;
#line 572
      if (s->rNToGo == 1) {
#line 572
        tmp___0 = 1;
      } else {
#line 572
        tmp___0 = 0;
      }
#line 572
      k1 = (UChar )((int )k1 ^ tmp___0);
#line 572
      (s->nblock_used) ++;
#line 573
      if (s->nblock_used == s->save_nblock + 1) {
#line 573
        goto while_continue;
      }
#line 574
      if ((int )k1 != s->k0) {
#line 574
        s->k0 = (Int32 )k1;
#line 574
        goto while_continue;
      }
#line 576
      s->state_out_len = 3;
#line 577
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 577
        return ((Bool )1);
      }
#line 577
      s->tPos = *(s->tt + s->tPos);
#line 577
      k1 = (UChar )(s->tPos & 255U);
#line 577
      s->tPos >>= 8;
#line 577
      if (s->rNToGo == 0) {
#line 577
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 577
        (s->rTPos) ++;
#line 577
        if (s->rTPos == 512) {
#line 577
          s->rTPos = 0;
        }
      }
#line 577
      (s->rNToGo) --;
#line 578
      if (s->rNToGo == 1) {
#line 578
        tmp___1 = 1;
      } else {
#line 578
        tmp___1 = 0;
      }
#line 578
      k1 = (UChar )((int )k1 ^ tmp___1);
#line 578
      (s->nblock_used) ++;
#line 579
      if (s->nblock_used == s->save_nblock + 1) {
#line 579
        goto while_continue;
      }
#line 580
      if ((int )k1 != s->k0) {
#line 580
        s->k0 = (Int32 )k1;
#line 580
        goto while_continue;
      }
#line 582
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 582
        return ((Bool )1);
      }
#line 582
      s->tPos = *(s->tt + s->tPos);
#line 582
      k1 = (UChar )(s->tPos & 255U);
#line 582
      s->tPos >>= 8;
#line 582
      if (s->rNToGo == 0) {
#line 582
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 582
        (s->rTPos) ++;
#line 582
        if (s->rTPos == 512) {
#line 582
          s->rTPos = 0;
        }
      }
#line 582
      (s->rNToGo) --;
#line 583
      if (s->rNToGo == 1) {
#line 583
        tmp___2 = 1;
      } else {
#line 583
        tmp___2 = 0;
      }
#line 583
      k1 = (UChar )((int )k1 ^ tmp___2);
#line 583
      (s->nblock_used) ++;
#line 584
      s->state_out_len = (Int32 )k1 + 4;
#line 585
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 585
        return ((Bool )1);
      }
#line 585
      s->tPos = *(s->tt + s->tPos);
#line 585
      s->k0 = (Int32 )((UChar )(s->tPos & 255U));
#line 585
      s->tPos >>= 8;
#line 585
      if (s->rNToGo == 0) {
#line 585
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 585
        (s->rTPos) ++;
#line 585
        if (s->rTPos == 512) {
#line 585
          s->rTPos = 0;
        }
      }
#line 585
      (s->rNToGo) --;
#line 586
      if (s->rNToGo == 1) {
#line 586
        tmp___3 = 1;
      } else {
#line 586
        tmp___3 = 0;
      }
#line 586
      s->k0 ^= tmp___3;
#line 586
      (s->nblock_used) ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 592
    c_calculatedBlockCRC = s->calculatedBlockCRC;
#line 593
    c_state_out_ch = s->state_out_ch;
#line 594
    c_state_out_len = s->state_out_len;
#line 595
    c_nblock_used = s->nblock_used;
#line 596
    c_k0 = s->k0;
#line 597
    c_tt = s->tt;
#line 598
    c_tPos = s->tPos;
#line 599
    cs_next_out = (s->strm)->next_out;
#line 600
    cs_avail_out = (s->strm)->avail_out;
#line 601
    ro_blockSize100k = s->blockSize100k;
#line 604
    avail_out_INIT = cs_avail_out;
#line 605
    s_save_nblockPP = s->save_nblock + 1;
    {
#line 608
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 611
      if (c_state_out_len > 0) {
        {
#line 612
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 613
          if (cs_avail_out == 0U) {
#line 613
            goto return_notr;
          }
#line 614
          if (c_state_out_len == 1) {
#line 614
            goto while_break___2;
          }
#line 615
          *((UChar *)cs_next_out) = c_state_out_ch;
#line 616
          c_calculatedBlockCRC = (c_calculatedBlockCRC << 8) ^ BZ2_crc32Table[(c_calculatedBlockCRC >> 24) ^ (unsigned int )c_state_out_ch];
#line 617
          c_state_out_len --;
#line 618
          cs_next_out ++;
#line 619
          cs_avail_out --;
        }
        while_break___2: /* CIL Label */ ;
        }
        s_state_out_len_eq_one: 
#line 623
        if (cs_avail_out == 0U) {
#line 624
          c_state_out_len = 1;
#line 624
          goto return_notr;
        }
#line 626
        *((UChar *)cs_next_out) = c_state_out_ch;
#line 627
        c_calculatedBlockCRC = (c_calculatedBlockCRC << 8) ^ BZ2_crc32Table[(c_calculatedBlockCRC >> 24) ^ (unsigned int )c_state_out_ch];
#line 628
        cs_next_out ++;
#line 629
        cs_avail_out --;
      }
#line 633
      if (c_nblock_used > s_save_nblockPP) {
#line 634
        return ((Bool )1);
      }
#line 637
      if (c_nblock_used == s_save_nblockPP) {
#line 638
        c_state_out_len = 0;
#line 638
        goto return_notr;
      }
#line 640
      c_state_out_ch = (UChar )c_k0;
#line 641
      if (c_tPos >= 100000U * (UInt32 )ro_blockSize100k) {
#line 641
        return ((Bool )1);
      }
#line 641
      c_tPos = *(c_tt + c_tPos);
#line 641
      k1 = (UChar )(c_tPos & 255U);
#line 641
      c_tPos >>= 8;
#line 641
      c_nblock_used ++;
#line 642
      if ((int )k1 != c_k0) {
#line 643
        c_k0 = (Int32 )k1;
#line 643
        goto s_state_out_len_eq_one;
      }
#line 645
      if (c_nblock_used == s_save_nblockPP) {
#line 646
        goto s_state_out_len_eq_one;
      }
#line 648
      c_state_out_len = 2;
#line 649
      if (c_tPos >= 100000U * (UInt32 )ro_blockSize100k) {
#line 649
        return ((Bool )1);
      }
#line 649
      c_tPos = *(c_tt + c_tPos);
#line 649
      k1 = (UChar )(c_tPos & 255U);
#line 649
      c_tPos >>= 8;
#line 649
      c_nblock_used ++;
#line 650
      if (c_nblock_used == s_save_nblockPP) {
#line 650
        goto while_continue___1;
      }
#line 651
      if ((int )k1 != c_k0) {
#line 651
        c_k0 = (Int32 )k1;
#line 651
        goto while_continue___1;
      }
#line 653
      c_state_out_len = 3;
#line 654
      if (c_tPos >= 100000U * (UInt32 )ro_blockSize100k) {
#line 654
        return ((Bool )1);
      }
#line 654
      c_tPos = *(c_tt + c_tPos);
#line 654
      k1 = (UChar )(c_tPos & 255U);
#line 654
      c_tPos >>= 8;
#line 654
      c_nblock_used ++;
#line 655
      if (c_nblock_used == s_save_nblockPP) {
#line 655
        goto while_continue___1;
      }
#line 656
      if ((int )k1 != c_k0) {
#line 656
        c_k0 = (Int32 )k1;
#line 656
        goto while_continue___1;
      }
#line 658
      if (c_tPos >= 100000U * (UInt32 )ro_blockSize100k) {
#line 658
        return ((Bool )1);
      }
#line 658
      c_tPos = *(c_tt + c_tPos);
#line 658
      k1 = (UChar )(c_tPos & 255U);
#line 658
      c_tPos >>= 8;
#line 658
      c_nblock_used ++;
#line 659
      c_state_out_len = (Int32 )k1 + 4;
#line 660
      if (c_tPos >= 100000U * (UInt32 )ro_blockSize100k) {
#line 660
        return ((Bool )1);
      }
#line 660
      c_tPos = *(c_tt + c_tPos);
#line 660
      c_k0 = (Int32 )((UChar )(c_tPos & 255U));
#line 660
      c_tPos >>= 8;
#line 660
      c_nblock_used ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    return_notr: 
#line 664
    total_out_lo32_old = (s->strm)->total_out_lo32;
#line 665
    (s->strm)->total_out_lo32 += avail_out_INIT - cs_avail_out;
#line 666
    if ((s->strm)->total_out_lo32 < total_out_lo32_old) {
#line 667
      ((s->strm)->total_out_hi32) ++;
    }
#line 670
    s->calculatedBlockCRC = c_calculatedBlockCRC;
#line 671
    s->state_out_ch = c_state_out_ch;
#line 672
    s->state_out_len = c_state_out_len;
#line 673
    s->nblock_used = c_nblock_used;
#line 674
    s->k0 = c_k0;
#line 675
    s->tt = c_tt;
#line 676
    s->tPos = c_tPos;
#line 677
    (s->strm)->next_out = cs_next_out;
#line 678
    (s->strm)->avail_out = cs_avail_out;
  }
#line 681
  return ((Bool )0);
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
__inline Int32 BZ2_indexIntoF(Int32 indx , Int32 *cftab ) 
{ 
  Int32 nb ;
  Int32 na ;
  Int32 mid ;

  {
#line 690
  nb = 0;
#line 691
  na = 256;
  {
#line 692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 693
    mid = (nb + na) >> 1;
#line 694
    if (indx >= *(cftab + mid)) {
#line 694
      nb = mid;
    } else {
#line 694
      na = mid;
    }
#line 692
    if (! (na - nb != 1)) {
#line 692
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 697
  return (nb);
}
}
#line 705 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static Bool unRLE_obuf_to_output_SMALL(DState *s ) 
{ 
  UChar k1 ;
  Int32 tmp ;
  int tmp___0 ;
  Int32 tmp___1 ;
  int tmp___2 ;
  Int32 tmp___3 ;
  int tmp___4 ;
  Int32 tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Int32 tmp___8 ;
  Int32 tmp___9 ;
  Int32 tmp___10 ;
  Int32 tmp___11 ;

  {
#line 710
  if (s->blockRandomised) {
    {
#line 712
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 714
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 715
        if ((s->strm)->avail_out == 0U) {
#line 715
          return ((Bool )0);
        }
#line 716
        if (s->state_out_len == 0) {
#line 716
          goto while_break___0;
        }
#line 717
        *((UChar *)(s->strm)->next_out) = s->state_out_ch;
#line 718
        s->calculatedBlockCRC = (s->calculatedBlockCRC << 8) ^ BZ2_crc32Table[(s->calculatedBlockCRC >> 24) ^ (unsigned int )s->state_out_ch];
#line 719
        (s->state_out_len) --;
#line 720
        ((s->strm)->next_out) ++;
#line 721
        ((s->strm)->avail_out) --;
#line 722
        ((s->strm)->total_out_lo32) ++;
#line 723
        if ((s->strm)->total_out_lo32 == 0U) {
#line 723
          ((s->strm)->total_out_hi32) ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 727
      if (s->nblock_used == s->save_nblock + 1) {
#line 727
        return ((Bool )0);
      }
#line 730
      if (s->nblock_used > s->save_nblock + 1) {
#line 731
        return ((Bool )1);
      }
#line 733
      s->state_out_len = 1;
#line 734
      s->state_out_ch = (UChar )s->k0;
#line 735
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 735
        return ((Bool )1);
      }
      {
#line 735
      tmp = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 735
      k1 = (UChar )tmp;
#line 735
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      }
#line 735
      if (s->rNToGo == 0) {
#line 735
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 735
        (s->rTPos) ++;
#line 735
        if (s->rTPos == 512) {
#line 735
          s->rTPos = 0;
        }
      }
#line 735
      (s->rNToGo) --;
#line 736
      if (s->rNToGo == 1) {
#line 736
        tmp___0 = 1;
      } else {
#line 736
        tmp___0 = 0;
      }
#line 736
      k1 = (UChar )((int )k1 ^ tmp___0);
#line 736
      (s->nblock_used) ++;
#line 737
      if (s->nblock_used == s->save_nblock + 1) {
#line 737
        goto while_continue;
      }
#line 738
      if ((int )k1 != s->k0) {
#line 738
        s->k0 = (Int32 )k1;
#line 738
        goto while_continue;
      }
#line 740
      s->state_out_len = 2;
#line 741
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 741
        return ((Bool )1);
      }
      {
#line 741
      tmp___1 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 741
      k1 = (UChar )tmp___1;
#line 741
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      }
#line 741
      if (s->rNToGo == 0) {
#line 741
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 741
        (s->rTPos) ++;
#line 741
        if (s->rTPos == 512) {
#line 741
          s->rTPos = 0;
        }
      }
#line 741
      (s->rNToGo) --;
#line 742
      if (s->rNToGo == 1) {
#line 742
        tmp___2 = 1;
      } else {
#line 742
        tmp___2 = 0;
      }
#line 742
      k1 = (UChar )((int )k1 ^ tmp___2);
#line 742
      (s->nblock_used) ++;
#line 743
      if (s->nblock_used == s->save_nblock + 1) {
#line 743
        goto while_continue;
      }
#line 744
      if ((int )k1 != s->k0) {
#line 744
        s->k0 = (Int32 )k1;
#line 744
        goto while_continue;
      }
#line 746
      s->state_out_len = 3;
#line 747
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 747
        return ((Bool )1);
      }
      {
#line 747
      tmp___3 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 747
      k1 = (UChar )tmp___3;
#line 747
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      }
#line 747
      if (s->rNToGo == 0) {
#line 747
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 747
        (s->rTPos) ++;
#line 747
        if (s->rTPos == 512) {
#line 747
          s->rTPos = 0;
        }
      }
#line 747
      (s->rNToGo) --;
#line 748
      if (s->rNToGo == 1) {
#line 748
        tmp___4 = 1;
      } else {
#line 748
        tmp___4 = 0;
      }
#line 748
      k1 = (UChar )((int )k1 ^ tmp___4);
#line 748
      (s->nblock_used) ++;
#line 749
      if (s->nblock_used == s->save_nblock + 1) {
#line 749
        goto while_continue;
      }
#line 750
      if ((int )k1 != s->k0) {
#line 750
        s->k0 = (Int32 )k1;
#line 750
        goto while_continue;
      }
#line 752
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 752
        return ((Bool )1);
      }
      {
#line 752
      tmp___5 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 752
      k1 = (UChar )tmp___5;
#line 752
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      }
#line 752
      if (s->rNToGo == 0) {
#line 752
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 752
        (s->rTPos) ++;
#line 752
        if (s->rTPos == 512) {
#line 752
          s->rTPos = 0;
        }
      }
#line 752
      (s->rNToGo) --;
#line 753
      if (s->rNToGo == 1) {
#line 753
        tmp___6 = 1;
      } else {
#line 753
        tmp___6 = 0;
      }
#line 753
      k1 = (UChar )((int )k1 ^ tmp___6);
#line 753
      (s->nblock_used) ++;
#line 754
      s->state_out_len = (Int32 )k1 + 4;
#line 755
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 755
        return ((Bool )1);
      }
      {
#line 755
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 755
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      }
#line 755
      if (s->rNToGo == 0) {
#line 755
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 755
        (s->rTPos) ++;
#line 755
        if (s->rTPos == 512) {
#line 755
          s->rTPos = 0;
        }
      }
#line 755
      (s->rNToGo) --;
#line 756
      if (s->rNToGo == 1) {
#line 756
        tmp___7 = 1;
      } else {
#line 756
        tmp___7 = 0;
      }
#line 756
      s->k0 ^= tmp___7;
#line 756
      (s->nblock_used) ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 761
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 763
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 764
        if ((s->strm)->avail_out == 0U) {
#line 764
          return ((Bool )0);
        }
#line 765
        if (s->state_out_len == 0) {
#line 765
          goto while_break___2;
        }
#line 766
        *((UChar *)(s->strm)->next_out) = s->state_out_ch;
#line 767
        s->calculatedBlockCRC = (s->calculatedBlockCRC << 8) ^ BZ2_crc32Table[(s->calculatedBlockCRC >> 24) ^ (unsigned int )s->state_out_ch];
#line 768
        (s->state_out_len) --;
#line 769
        ((s->strm)->next_out) ++;
#line 770
        ((s->strm)->avail_out) --;
#line 771
        ((s->strm)->total_out_lo32) ++;
#line 772
        if ((s->strm)->total_out_lo32 == 0U) {
#line 772
          ((s->strm)->total_out_hi32) ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 776
      if (s->nblock_used == s->save_nblock + 1) {
#line 776
        return ((Bool )0);
      }
#line 779
      if (s->nblock_used > s->save_nblock + 1) {
#line 780
        return ((Bool )1);
      }
#line 782
      s->state_out_len = 1;
#line 783
      s->state_out_ch = (UChar )s->k0;
#line 784
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 784
        return ((Bool )1);
      }
      {
#line 784
      tmp___8 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 784
      k1 = (UChar )tmp___8;
#line 784
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 784
      (s->nblock_used) ++;
      }
#line 785
      if (s->nblock_used == s->save_nblock + 1) {
#line 785
        goto while_continue___1;
      }
#line 786
      if ((int )k1 != s->k0) {
#line 786
        s->k0 = (Int32 )k1;
#line 786
        goto while_continue___1;
      }
#line 788
      s->state_out_len = 2;
#line 789
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 789
        return ((Bool )1);
      }
      {
#line 789
      tmp___9 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 789
      k1 = (UChar )tmp___9;
#line 789
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 789
      (s->nblock_used) ++;
      }
#line 790
      if (s->nblock_used == s->save_nblock + 1) {
#line 790
        goto while_continue___1;
      }
#line 791
      if ((int )k1 != s->k0) {
#line 791
        s->k0 = (Int32 )k1;
#line 791
        goto while_continue___1;
      }
#line 793
      s->state_out_len = 3;
#line 794
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 794
        return ((Bool )1);
      }
      {
#line 794
      tmp___10 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 794
      k1 = (UChar )tmp___10;
#line 794
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 794
      (s->nblock_used) ++;
      }
#line 795
      if (s->nblock_used == s->save_nblock + 1) {
#line 795
        goto while_continue___1;
      }
#line 796
      if ((int )k1 != s->k0) {
#line 796
        s->k0 = (Int32 )k1;
#line 796
        goto while_continue___1;
      }
#line 798
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 798
        return ((Bool )1);
      }
      {
#line 798
      tmp___11 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 798
      k1 = (UChar )tmp___11;
#line 798
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 798
      (s->nblock_used) ++;
#line 799
      s->state_out_len = (Int32 )k1 + 4;
      }
#line 800
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 800
        return ((Bool )1);
      }
      {
#line 800
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 800
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 800
      (s->nblock_used) ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
}
}
#line 808 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
int BZ2_bzDecompress(bz_stream *strm ) 
{ 
  Bool corrupt ;
  DState *s ;
  Int32 r ;
  Int32 tmp ;

  {
#line 812
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
#line 812
    return (-2);
  }
#line 813
  s = (DState *)strm->state;
#line 814
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 814
    return (-2);
  }
#line 815
  if ((unsigned long )s->strm != (unsigned long )strm) {
#line 815
    return (-2);
  }
  {
#line 817
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (s->state == 1) {
#line 818
      return (-1);
    }
#line 819
    if (s->state == 2) {
#line 820
      if (s->smallDecompress) {
        {
#line 821
        corrupt = unRLE_obuf_to_output_SMALL(s);
        }
      } else {
        {
#line 822
        corrupt = unRLE_obuf_to_output_FAST(s);
        }
      }
#line 823
      if (corrupt) {
#line 823
        return (-4);
      }
#line 824
      if (s->nblock_used == s->save_nblock + 1) {
#line 824
        if (s->state_out_len == 0) {
#line 825
          s->calculatedBlockCRC = ~ s->calculatedBlockCRC;
#line 826
          if (s->verbosity >= 3) {
            {
#line 827
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" {0x%08x, 0x%08x}",
                    s->storedBlockCRC, s->calculatedBlockCRC);
            }
          }
#line 829
          if (s->verbosity >= 2) {
            {
#line 829
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"]");
            }
          }
#line 830
          if (s->calculatedBlockCRC != s->storedBlockCRC) {
#line 831
            return (-4);
          }
#line 832
          s->calculatedCombinedCRC = (s->calculatedCombinedCRC << 1) | (s->calculatedCombinedCRC >> 31);
#line 835
          s->calculatedCombinedCRC ^= s->calculatedBlockCRC;
#line 836
          s->state = 14;
        } else {
#line 838
          return (0);
        }
      } else {
#line 838
        return (0);
      }
    }
#line 841
    if (s->state >= 10) {
      {
#line 842
      tmp = BZ2_decompress(s);
#line 842
      r = tmp;
      }
#line 843
      if (r == 4) {
#line 844
        if (s->verbosity >= 3) {
          {
#line 845
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n    combined CRCs: stored = 0x%08x, computed = 0x%08x",
                  s->storedCombinedCRC, s->calculatedCombinedCRC);
          }
        }
#line 847
        if (s->calculatedCombinedCRC != s->storedCombinedCRC) {
#line 848
          return (-4);
        }
#line 849
        return (r);
      }
#line 851
      if (s->state != 2) {
#line 851
        return (r);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 855
  BZ2_bz__AssertH__fail(6001);
  }
#line 857
  return (0);
}
}
#line 862 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
int BZ2_bzDecompressEnd(bz_stream *strm ) 
{ 
  DState *s ;

  {
#line 865
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
#line 865
    return (-2);
  }
#line 866
  s = (DState *)strm->state;
#line 867
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 867
    return (-2);
  }
#line 868
  if ((unsigned long )s->strm != (unsigned long )strm) {
#line 868
    return (-2);
  }
#line 870
  if ((unsigned long )s->tt != (unsigned long )((void *)0)) {
    {
#line 870
    (*(strm->bzfree))(strm->opaque, (void *)s->tt);
    }
  }
#line 871
  if ((unsigned long )s->ll16 != (unsigned long )((void *)0)) {
    {
#line 871
    (*(strm->bzfree))(strm->opaque, (void *)s->ll16);
    }
  }
#line 872
  if ((unsigned long )s->ll4 != (unsigned long )((void *)0)) {
    {
#line 872
    (*(strm->bzfree))(strm->opaque, (void *)s->ll4);
    }
  }
  {
#line 874
  (*(strm->bzfree))(strm->opaque, strm->state);
#line 875
  strm->state = (void *)0;
  }
#line 877
  return (0);
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static Bool myfeof(FILE *f ) 
{ 
  Int32 c ;
  int tmp ;

  {
  {
#line 908
  tmp = fgetc(f);
#line 908
  c = tmp;
  }
#line 909
  if (c == -1) {
#line 909
    return ((Bool )1);
  }
  {
#line 910
  ungetc(c, f);
  }
#line 911
  return ((Bool )0);
}
}
#line 916 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
BZFILE *BZ2_bzWriteOpen(int *bzerror , FILE *f , int blockSize100k___0 , int verbosity___0 ,
                        int workFactor___0 ) 
{ 
  Int32 ret ;
  bzFile *bzf ;
  int tmp ;
  void *tmp___0 ;

  {
#line 924
  bzf = (bzFile *)((void *)0);
#line 926
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 926
    *bzerror = 0;
  }
#line 926
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 926
    bzf->lastErr = 0;
  }
#line 928
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 928
    goto _L___0;
  } else
#line 928
  if (blockSize100k___0 < 1) {
#line 928
    goto _L___0;
  } else
#line 928
  if (blockSize100k___0 > 9) {
#line 928
    goto _L___0;
  } else
#line 928
  if (workFactor___0 < 0) {
#line 928
    goto _L___0;
  } else
#line 928
  if (workFactor___0 > 250) {
#line 928
    goto _L___0;
  } else
#line 928
  if (verbosity___0 < 0) {
#line 928
    goto _L___0;
  } else
#line 928
  if (verbosity___0 > 4) {
    _L___0: /* CIL Label */ 
#line 932
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 932
      *bzerror = -2;
    }
#line 932
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 932
      bzf->lastErr = -2;
    }
#line 932
    return ((void *)0);
  }
  {
#line 934
  tmp = ferror(f);
  }
#line 934
  if (tmp) {
#line 935
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 935
      *bzerror = -6;
    }
#line 935
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 935
      bzf->lastErr = -6;
    }
#line 935
    return ((void *)0);
  }
  {
#line 937
  tmp___0 = malloc(sizeof(bzFile ));
#line 937
  bzf = (bzFile *)tmp___0;
  }
#line 938
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 939
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 939
      *bzerror = -3;
    }
#line 939
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 939
      bzf->lastErr = -3;
    }
#line 939
    return ((void *)0);
  }
#line 941
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 941
    *bzerror = 0;
  }
#line 941
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 941
    bzf->lastErr = 0;
  }
#line 942
  bzf->initialisedOk = (Bool )0;
#line 943
  bzf->bufN = 0;
#line 944
  bzf->handle = f;
#line 945
  bzf->writing = (Bool )1;
#line 946
  bzf->strm.bzalloc = (void *(*)(void * , int  , int  ))((void *)0);
#line 947
  bzf->strm.bzfree = (void (*)(void * , void * ))((void *)0);
#line 948
  bzf->strm.opaque = (void *)0;
#line 950
  if (workFactor___0 == 0) {
#line 950
    workFactor___0 = 30;
  }
  {
#line 951
  ret = BZ2_bzCompressInit(& bzf->strm, blockSize100k___0, verbosity___0, workFactor___0);
  }
#line 953
  if (ret != 0) {
#line 954
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 954
      *bzerror = ret;
    }
#line 954
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 954
      bzf->lastErr = ret;
    }
    {
#line 954
    free((void *)bzf);
    }
#line 954
    return ((void *)0);
  }
#line 956
  bzf->strm.avail_in = 0U;
#line 957
  bzf->initialisedOk = (Bool )1;
#line 958
  return ((BZFILE *)bzf);
}
}
#line 964 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
void BZ2_bzWrite(int *bzerror , BZFILE *b , void *buf , int len ) 
{ 
  Int32 n ;
  Int32 n2 ;
  Int32 ret ;
  bzFile *bzf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 971
  bzf = (bzFile *)b;
#line 973
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 973
    *bzerror = 0;
  }
#line 973
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 973
    bzf->lastErr = 0;
  }
#line 974
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 974
    goto _L;
  } else
#line 974
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 974
    goto _L;
  } else
#line 974
  if (len < 0) {
    _L: /* CIL Label */ 
#line 975
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 975
      *bzerror = -2;
    }
#line 975
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 975
      bzf->lastErr = -2;
    }
#line 975
    return;
  }
#line 976
  if (! bzf->writing) {
#line 977
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 977
      *bzerror = -1;
    }
#line 977
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 977
      bzf->lastErr = -1;
    }
#line 977
    return;
  }
  {
#line 978
  tmp = ferror(bzf->handle);
  }
#line 978
  if (tmp) {
#line 979
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 979
      *bzerror = -6;
    }
#line 979
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 979
      bzf->lastErr = -6;
    }
#line 979
    return;
  }
#line 981
  if (len == 0) {
#line 982
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 982
      *bzerror = 0;
    }
#line 982
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 982
      bzf->lastErr = 0;
    }
#line 982
    return;
  }
#line 984
  bzf->strm.avail_in = (unsigned int )len;
#line 985
  bzf->strm.next_in = (char *)buf;
  {
#line 987
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 988
    bzf->strm.avail_out = 5000U;
#line 989
    bzf->strm.next_out = bzf->buf;
#line 990
    ret = BZ2_bzCompress(& bzf->strm, 0);
    }
#line 991
    if (ret != 1) {
#line 992
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 992
        *bzerror = ret;
      }
#line 992
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 992
        bzf->lastErr = ret;
      }
#line 992
      return;
    }
#line 994
    if (bzf->strm.avail_out < 5000U) {
      {
#line 995
      n = (Int32 )(5000U - bzf->strm.avail_out);
#line 996
      tmp___0 = fwrite((void const   */* __restrict  */)((void *)(bzf->buf)), sizeof(UChar ),
                       (size_t )n, (FILE */* __restrict  */)bzf->handle);
#line 996
      n2 = (Int32 )tmp___0;
      }
#line 998
      if (n != n2) {
#line 998
        goto _L___0;
      } else {
        {
#line 998
        tmp___1 = ferror(bzf->handle);
        }
#line 998
        if (tmp___1) {
          _L___0: /* CIL Label */ 
#line 999
          if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 999
            *bzerror = -6;
          }
#line 999
          if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 999
            bzf->lastErr = -6;
          }
#line 999
          return;
        }
      }
    }
#line 1002
    if (bzf->strm.avail_in == 0U) {
#line 1003
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1003
        *bzerror = 0;
      }
#line 1003
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1003
        bzf->lastErr = 0;
      }
#line 1003
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1009 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
void BZ2_bzWriteClose(int *bzerror , BZFILE *b , int abandon , unsigned int *nbytes_in ,
                      unsigned int *nbytes_out ) 
{ 


  {
  {
#line 1016
  BZ2_bzWriteClose64(bzerror, b, abandon, nbytes_in, (unsigned int *)((void *)0),
                     nbytes_out, (unsigned int *)((void *)0));
  }
#line 1018
  return;
}
}
#line 1021 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
void BZ2_bzWriteClose64(int *bzerror , BZFILE *b , int abandon , unsigned int *nbytes_in_lo32 ,
                        unsigned int *nbytes_in_hi32 , unsigned int *nbytes_out_lo32 ,
                        unsigned int *nbytes_out_hi32 ) 
{ 
  Int32 n ;
  Int32 n2 ;
  Int32 ret ;
  bzFile *bzf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1031
  bzf = (bzFile *)b;
#line 1033
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 1034
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1034
      *bzerror = 0;
    }
#line 1034
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1034
      bzf->lastErr = 0;
    }
#line 1034
    return;
  }
#line 1035
  if (! bzf->writing) {
#line 1036
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1036
      *bzerror = -1;
    }
#line 1036
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1036
      bzf->lastErr = -1;
    }
#line 1036
    return;
  }
  {
#line 1037
  tmp = ferror(bzf->handle);
  }
#line 1037
  if (tmp) {
#line 1038
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1038
      *bzerror = -6;
    }
#line 1038
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1038
      bzf->lastErr = -6;
    }
#line 1038
    return;
  }
#line 1040
  if ((unsigned long )nbytes_in_lo32 != (unsigned long )((void *)0)) {
#line 1040
    *nbytes_in_lo32 = 0U;
  }
#line 1041
  if ((unsigned long )nbytes_in_hi32 != (unsigned long )((void *)0)) {
#line 1041
    *nbytes_in_hi32 = 0U;
  }
#line 1042
  if ((unsigned long )nbytes_out_lo32 != (unsigned long )((void *)0)) {
#line 1042
    *nbytes_out_lo32 = 0U;
  }
#line 1043
  if ((unsigned long )nbytes_out_hi32 != (unsigned long )((void *)0)) {
#line 1043
    *nbytes_out_hi32 = 0U;
  }
#line 1045
  if (! abandon) {
#line 1045
    if (bzf->lastErr == 0) {
      {
#line 1046
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1047
        bzf->strm.avail_out = 5000U;
#line 1048
        bzf->strm.next_out = bzf->buf;
#line 1049
        ret = BZ2_bzCompress(& bzf->strm, 2);
        }
#line 1050
        if (ret != 3) {
#line 1050
          if (ret != 4) {
#line 1051
            if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1051
              *bzerror = ret;
            }
#line 1051
            if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1051
              bzf->lastErr = ret;
            }
#line 1051
            return;
          }
        }
#line 1053
        if (bzf->strm.avail_out < 5000U) {
          {
#line 1054
          n = (Int32 )(5000U - bzf->strm.avail_out);
#line 1055
          tmp___0 = fwrite((void const   */* __restrict  */)((void *)(bzf->buf)),
                           sizeof(UChar ), (size_t )n, (FILE */* __restrict  */)bzf->handle);
#line 1055
          n2 = (Int32 )tmp___0;
          }
#line 1057
          if (n != n2) {
#line 1057
            goto _L;
          } else {
            {
#line 1057
            tmp___1 = ferror(bzf->handle);
            }
#line 1057
            if (tmp___1) {
              _L: /* CIL Label */ 
#line 1058
              if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1058
                *bzerror = -6;
              }
#line 1058
              if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1058
                bzf->lastErr = -6;
              }
#line 1058
              return;
            }
          }
        }
#line 1061
        if (ret == 4) {
#line 1061
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1065
  if (! abandon) {
    {
#line 1065
    tmp___3 = ferror(bzf->handle);
    }
#line 1065
    if (! tmp___3) {
      {
#line 1066
      fflush(bzf->handle);
#line 1067
      tmp___2 = ferror(bzf->handle);
      }
#line 1067
      if (tmp___2) {
#line 1068
        if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1068
          *bzerror = -6;
        }
#line 1068
        if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1068
          bzf->lastErr = -6;
        }
#line 1068
        return;
      }
    }
  }
#line 1071
  if ((unsigned long )nbytes_in_lo32 != (unsigned long )((void *)0)) {
#line 1072
    *nbytes_in_lo32 = bzf->strm.total_in_lo32;
  }
#line 1073
  if ((unsigned long )nbytes_in_hi32 != (unsigned long )((void *)0)) {
#line 1074
    *nbytes_in_hi32 = bzf->strm.total_in_hi32;
  }
#line 1075
  if ((unsigned long )nbytes_out_lo32 != (unsigned long )((void *)0)) {
#line 1076
    *nbytes_out_lo32 = bzf->strm.total_out_lo32;
  }
#line 1077
  if ((unsigned long )nbytes_out_hi32 != (unsigned long )((void *)0)) {
#line 1078
    *nbytes_out_hi32 = bzf->strm.total_out_hi32;
  }
#line 1080
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1080
    *bzerror = 0;
  }
#line 1080
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1080
    bzf->lastErr = 0;
  }
  {
#line 1081
  BZ2_bzCompressEnd(& bzf->strm);
#line 1082
  free((void *)bzf);
  }
#line 1083
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
BZFILE *BZ2_bzReadOpen(int *bzerror , FILE *f , int verbosity___0 , int small , void *unused ,
                       int nUnused ) 
{ 
  bzFile *bzf ;
  int ret ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1095
  bzf = (bzFile *)((void *)0);
#line 1098
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1098
    *bzerror = 0;
  }
#line 1098
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1098
    bzf->lastErr = 0;
  }
#line 1100
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 1100
    goto _L___0;
  } else
#line 1100
  if (small != 0) {
#line 1100
    if (small != 1) {
#line 1100
      goto _L___0;
    } else {
#line 1100
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1100
  if (verbosity___0 < 0) {
#line 1100
    goto _L___0;
  } else
#line 1100
  if (verbosity___0 > 4) {
#line 1100
    goto _L___0;
  } else
#line 1100
  if ((unsigned long )unused == (unsigned long )((void *)0)) {
#line 1100
    if (nUnused != 0) {
#line 1100
      goto _L___0;
    } else {
#line 1100
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1100
  if ((unsigned long )unused != (unsigned long )((void *)0)) {
#line 1100
    if (nUnused < 0) {
#line 1100
      goto _L___0;
    } else
#line 1100
    if (nUnused > 5000) {
      _L___0: /* CIL Label */ 
#line 1105
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1105
        *bzerror = -2;
      }
#line 1105
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1105
        bzf->lastErr = -2;
      }
#line 1105
      return ((void *)0);
    }
  }
  {
#line 1107
  tmp = ferror(f);
  }
#line 1107
  if (tmp) {
#line 1108
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1108
      *bzerror = -6;
    }
#line 1108
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1108
      bzf->lastErr = -6;
    }
#line 1108
    return ((void *)0);
  }
  {
#line 1110
  tmp___0 = malloc(sizeof(bzFile ));
#line 1110
  bzf = (bzFile *)tmp___0;
  }
#line 1111
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 1112
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1112
      *bzerror = -3;
    }
#line 1112
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1112
      bzf->lastErr = -3;
    }
#line 1112
    return ((void *)0);
  }
#line 1114
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1114
    *bzerror = 0;
  }
#line 1114
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1114
    bzf->lastErr = 0;
  }
#line 1116
  bzf->initialisedOk = (Bool )0;
#line 1117
  bzf->handle = f;
#line 1118
  bzf->bufN = 0;
#line 1119
  bzf->writing = (Bool )0;
#line 1120
  bzf->strm.bzalloc = (void *(*)(void * , int  , int  ))((void *)0);
#line 1121
  bzf->strm.bzfree = (void (*)(void * , void * ))((void *)0);
#line 1122
  bzf->strm.opaque = (void *)0;
  {
#line 1124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1124
    if (! (nUnused > 0)) {
#line 1124
      goto while_break;
    }
#line 1125
    bzf->buf[bzf->bufN] = (Char )*((UChar *)unused);
#line 1125
    (bzf->bufN) ++;
#line 1126
    unused = (void *)((UChar *)unused + 1);
#line 1127
    nUnused --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1130
  ret = BZ2_bzDecompressInit(& bzf->strm, verbosity___0, small);
  }
#line 1131
  if (ret != 0) {
#line 1132
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1132
      *bzerror = ret;
    }
#line 1132
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1132
      bzf->lastErr = ret;
    }
    {
#line 1132
    free((void *)bzf);
    }
#line 1132
    return ((void *)0);
  }
#line 1134
  bzf->strm.avail_in = (unsigned int )bzf->bufN;
#line 1135
  bzf->strm.next_in = bzf->buf;
#line 1137
  bzf->initialisedOk = (Bool )1;
#line 1138
  return ((BZFILE *)bzf);
}
}
#line 1143 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
void BZ2_bzReadClose(int *bzerror , BZFILE *b ) 
{ 
  bzFile *bzf ;

  {
#line 1145
  bzf = (bzFile *)b;
#line 1147
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1147
    *bzerror = 0;
  }
#line 1147
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1147
    bzf->lastErr = 0;
  }
#line 1148
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 1149
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1149
      *bzerror = 0;
    }
#line 1149
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1149
      bzf->lastErr = 0;
    }
#line 1149
    return;
  }
#line 1151
  if (bzf->writing) {
#line 1152
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1152
      *bzerror = -1;
    }
#line 1152
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1152
      bzf->lastErr = -1;
    }
#line 1152
    return;
  }
#line 1154
  if (bzf->initialisedOk) {
    {
#line 1155
    BZ2_bzDecompressEnd(& bzf->strm);
    }
  }
  {
#line 1156
  free((void *)bzf);
  }
#line 1157
  return;
}
}
#line 1161 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
int BZ2_bzRead(int *bzerror , BZFILE *b , void *buf , int len ) 
{ 
  Int32 n ;
  Int32 ret ;
  bzFile *bzf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  Bool tmp___2 ;
  Bool tmp___3 ;

  {
#line 1168
  bzf = (bzFile *)b;
#line 1170
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1170
    *bzerror = 0;
  }
#line 1170
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1170
    bzf->lastErr = 0;
  }
#line 1172
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 1172
    goto _L;
  } else
#line 1172
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 1172
    goto _L;
  } else
#line 1172
  if (len < 0) {
    _L: /* CIL Label */ 
#line 1173
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1173
      *bzerror = -2;
    }
#line 1173
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1173
      bzf->lastErr = -2;
    }
#line 1173
    return (0);
  }
#line 1175
  if (bzf->writing) {
#line 1176
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1176
      *bzerror = -1;
    }
#line 1176
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1176
      bzf->lastErr = -1;
    }
#line 1176
    return (0);
  }
#line 1178
  if (len == 0) {
#line 1179
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1179
      *bzerror = 0;
    }
#line 1179
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1179
      bzf->lastErr = 0;
    }
#line 1179
    return (0);
  }
#line 1181
  bzf->strm.avail_out = (unsigned int )len;
#line 1182
  bzf->strm.next_out = (char *)buf;
  {
#line 1184
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1186
    tmp = ferror(bzf->handle);
    }
#line 1186
    if (tmp) {
#line 1187
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1187
        *bzerror = -6;
      }
#line 1187
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1187
        bzf->lastErr = -6;
      }
#line 1187
      return (0);
    }
#line 1189
    if (bzf->strm.avail_in == 0U) {
      {
#line 1189
      tmp___2 = myfeof(bzf->handle);
      }
#line 1189
      if (! tmp___2) {
        {
#line 1190
        tmp___0 = fread((void */* __restrict  */)(bzf->buf), sizeof(UChar ), (size_t )5000,
                        (FILE */* __restrict  */)bzf->handle);
#line 1190
        n = (Int32 )tmp___0;
#line 1192
        tmp___1 = ferror(bzf->handle);
        }
#line 1192
        if (tmp___1) {
#line 1193
          if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1193
            *bzerror = -6;
          }
#line 1193
          if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1193
            bzf->lastErr = -6;
          }
#line 1193
          return (0);
        }
#line 1194
        bzf->bufN = n;
#line 1195
        bzf->strm.avail_in = (unsigned int )bzf->bufN;
#line 1196
        bzf->strm.next_in = bzf->buf;
      }
    }
    {
#line 1199
    ret = BZ2_bzDecompress(& bzf->strm);
    }
#line 1201
    if (ret != 0) {
#line 1201
      if (ret != 4) {
#line 1202
        if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1202
          *bzerror = ret;
        }
#line 1202
        if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1202
          bzf->lastErr = ret;
        }
#line 1202
        return (0);
      }
    }
#line 1204
    if (ret == 0) {
      {
#line 1204
      tmp___3 = myfeof(bzf->handle);
      }
#line 1204
      if (tmp___3) {
#line 1204
        if (bzf->strm.avail_in == 0U) {
#line 1204
          if (bzf->strm.avail_out > 0U) {
#line 1206
            if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1206
              *bzerror = -7;
            }
#line 1206
            if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1206
              bzf->lastErr = -7;
            }
#line 1206
            return (0);
          }
        }
      }
    }
#line 1208
    if (ret == 4) {
#line 1209
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1209
        *bzerror = 4;
      }
#line 1209
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1209
        bzf->lastErr = 4;
      }
#line 1210
      return ((int )((unsigned int )len - bzf->strm.avail_out));
    }
#line 1211
    if (bzf->strm.avail_out == 0U) {
#line 1212
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1212
        *bzerror = 0;
      }
#line 1212
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1212
        bzf->lastErr = 0;
      }
#line 1212
      return (len);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1216
  return (0);
}
}
#line 1221 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
void BZ2_bzReadGetUnused(int *bzerror , BZFILE *b , void **unused , int *nUnused ) 
{ 
  bzFile *bzf ;

  {
#line 1227
  bzf = (bzFile *)b;
#line 1228
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 1229
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1229
      *bzerror = -2;
    }
#line 1229
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1229
      bzf->lastErr = -2;
    }
#line 1229
    return;
  }
#line 1230
  if (bzf->lastErr != 4) {
#line 1231
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1231
      *bzerror = -1;
    }
#line 1231
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1231
      bzf->lastErr = -1;
    }
#line 1231
    return;
  }
#line 1232
  if ((unsigned long )unused == (unsigned long )((void *)0)) {
#line 1232
    goto _L;
  } else
#line 1232
  if ((unsigned long )nUnused == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 1233
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1233
      *bzerror = -2;
    }
#line 1233
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1233
      bzf->lastErr = -2;
    }
#line 1233
    return;
  }
#line 1235
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1235
    *bzerror = 0;
  }
#line 1235
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1235
    bzf->lastErr = 0;
  }
#line 1236
  *nUnused = (int )bzf->strm.avail_in;
#line 1237
  *unused = (void *)bzf->strm.next_in;
#line 1238
  return;
}
}
#line 1247 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
int BZ2_bzBuffToBuffCompress(char *dest , unsigned int *destLen , char *source , unsigned int sourceLen ,
                             int blockSize100k___0 , int verbosity___0 , int workFactor___0 ) 
{ 
  bz_stream strm ;
  int ret ;

  {
#line 1259
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 1264
    return (-2);
  } else
#line 1259
  if ((unsigned long )destLen == (unsigned long )((void *)0)) {
#line 1264
    return (-2);
  } else
#line 1259
  if ((unsigned long )source == (unsigned long )((void *)0)) {
#line 1264
    return (-2);
  } else
#line 1259
  if (blockSize100k___0 < 1) {
#line 1264
    return (-2);
  } else
#line 1259
  if (blockSize100k___0 > 9) {
#line 1264
    return (-2);
  } else
#line 1259
  if (verbosity___0 < 0) {
#line 1264
    return (-2);
  } else
#line 1259
  if (verbosity___0 > 4) {
#line 1264
    return (-2);
  } else
#line 1259
  if (workFactor___0 < 0) {
#line 1264
    return (-2);
  } else
#line 1259
  if (workFactor___0 > 250) {
#line 1264
    return (-2);
  }
#line 1266
  if (workFactor___0 == 0) {
#line 1266
    workFactor___0 = 30;
  }
  {
#line 1267
  strm.bzalloc = (void *(*)(void * , int  , int  ))((void *)0);
#line 1268
  strm.bzfree = (void (*)(void * , void * ))((void *)0);
#line 1269
  strm.opaque = (void *)0;
#line 1270
  ret = BZ2_bzCompressInit(& strm, blockSize100k___0, verbosity___0, workFactor___0);
  }
#line 1272
  if (ret != 0) {
#line 1272
    return (ret);
  }
  {
#line 1274
  strm.next_in = source;
#line 1275
  strm.next_out = dest;
#line 1276
  strm.avail_in = sourceLen;
#line 1277
  strm.avail_out = *destLen;
#line 1279
  ret = BZ2_bzCompress(& strm, 2);
  }
#line 1280
  if (ret == 3) {
#line 1280
    goto output_overflow;
  }
#line 1281
  if (ret != 4) {
#line 1281
    goto errhandler;
  }
  {
#line 1284
  *destLen -= strm.avail_out;
#line 1285
  BZ2_bzCompressEnd(& strm);
  }
#line 1286
  return (0);
  output_overflow: 
  {
#line 1289
  BZ2_bzCompressEnd(& strm);
  }
#line 1290
  return (-8);
  errhandler: 
  {
#line 1293
  BZ2_bzCompressEnd(& strm);
  }
#line 1294
  return (ret);
}
}
#line 1299 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
int BZ2_bzBuffToBuffDecompress(char *dest , unsigned int *destLen , char *source ,
                               unsigned int sourceLen , int small , int verbosity___0 ) 
{ 
  bz_stream strm ;
  int ret ;

  {
#line 1310
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 1314
    return (-2);
  } else
#line 1310
  if ((unsigned long )destLen == (unsigned long )((void *)0)) {
#line 1314
    return (-2);
  } else
#line 1310
  if ((unsigned long )source == (unsigned long )((void *)0)) {
#line 1314
    return (-2);
  } else
#line 1310
  if (small != 0) {
#line 1310
    if (small != 1) {
#line 1314
      return (-2);
    } else {
#line 1310
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1310
  if (verbosity___0 < 0) {
#line 1314
    return (-2);
  } else
#line 1310
  if (verbosity___0 > 4) {
#line 1314
    return (-2);
  }
  {
#line 1316
  strm.bzalloc = (void *(*)(void * , int  , int  ))((void *)0);
#line 1317
  strm.bzfree = (void (*)(void * , void * ))((void *)0);
#line 1318
  strm.opaque = (void *)0;
#line 1319
  ret = BZ2_bzDecompressInit(& strm, verbosity___0, small);
  }
#line 1320
  if (ret != 0) {
#line 1320
    return (ret);
  }
  {
#line 1322
  strm.next_in = source;
#line 1323
  strm.next_out = dest;
#line 1324
  strm.avail_in = sourceLen;
#line 1325
  strm.avail_out = *destLen;
#line 1327
  ret = BZ2_bzDecompress(& strm);
  }
#line 1328
  if (ret == 0) {
#line 1328
    goto output_overflow_or_eof;
  }
#line 1329
  if (ret != 4) {
#line 1329
    goto errhandler;
  }
  {
#line 1332
  *destLen -= strm.avail_out;
#line 1333
  BZ2_bzDecompressEnd(& strm);
  }
#line 1334
  return (0);
  output_overflow_or_eof: 
#line 1337
  if (strm.avail_out > 0U) {
    {
#line 1338
    BZ2_bzDecompressEnd(& strm);
    }
#line 1339
    return (-7);
  } else {
    {
#line 1341
    BZ2_bzDecompressEnd(& strm);
    }
#line 1342
    return (-8);
  }
  errhandler: 
  {
#line 1346
  BZ2_bzDecompressEnd(& strm);
  }
#line 1347
  return (ret);
}
}
#line 1366 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
char const   *BZ2_bzlibVersion(void) 
{ 


  {
#line 1368
  return ("1.0.6, 6-Sept-2010");
}
}
#line 1382 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static BZFILE *bzopen_or_bzdopen(char const   *path , int fd , char const   *mode ,
                                 int open_mode ) 
{ 
  int bzerr ;
  char unused[5000] ;
  int blockSize100k___0 ;
  int writing ;
  char mode2[10] ;
  unsigned int tmp ;
  FILE *fp ;
  BZFILE *bzfp ;
  int verbosity___0 ;
  int workFactor___0 ;
  int smallMode___0 ;
  int nUnused ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1391
  blockSize100k___0 = 9;
#line 1392
  writing = 0;
#line 1393
  mode2[0] = (char )'\000';
#line 1393
  tmp = 1U;
  {
#line 1393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1393
    if (tmp >= 10U) {
#line 1393
      goto while_break;
    }
#line 1393
    mode2[tmp] = (char)0;
#line 1393
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1394
  fp = (FILE *)((void *)0);
#line 1395
  bzfp = (void *)0;
#line 1396
  verbosity___0 = 0;
#line 1397
  workFactor___0 = 30;
#line 1398
  smallMode___0 = 0;
#line 1399
  nUnused = 0;
#line 1401
  if ((unsigned long )mode == (unsigned long )((void *)0)) {
#line 1401
    return ((void *)0);
  }
  {
#line 1402
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1402
    if (! *mode) {
#line 1402
      goto while_break___0;
    }
    {
#line 1404
    if ((int const   )*mode == 114) {
#line 1404
      goto case_114;
    }
#line 1406
    if ((int const   )*mode == 119) {
#line 1406
      goto case_119;
    }
#line 1408
    if ((int const   )*mode == 115) {
#line 1408
      goto case_115;
    }
#line 1410
    goto switch_default;
    case_114: /* CIL Label */ 
#line 1405
    writing = 0;
#line 1405
    goto switch_break;
    case_119: /* CIL Label */ 
#line 1407
    writing = 1;
#line 1407
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1409
    smallMode___0 = 1;
#line 1409
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1411
    tmp___0 = __ctype_b_loc();
    }
#line 1411
    if ((int const   )*(*tmp___0 + (int )*mode) & 2048) {
#line 1412
      blockSize100k___0 = (int )((int const   )*mode - 48);
    }
    switch_break: /* CIL Label */ ;
    }
#line 1415
    mode ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1417
  if (writing) {
#line 1417
    tmp___1 = "w";
  } else {
#line 1417
    tmp___1 = "r";
  }
  {
#line 1417
  strcat((char */* __restrict  */)(mode2), (char const   */* __restrict  */)tmp___1);
#line 1418
  strcat((char */* __restrict  */)(mode2), (char const   */* __restrict  */)"b");
  }
#line 1420
  if (open_mode == 0) {
#line 1421
    if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 1421
      goto _L;
    } else {
      {
#line 1421
      tmp___2 = strcmp(path, "");
      }
#line 1421
      if (tmp___2 == 0) {
        _L: /* CIL Label */ 
#line 1422
        if (writing) {
#line 1422
          fp = stdout;
        } else {
#line 1422
          fp = stdin;
        }
      } else {
        {
#line 1425
        fp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)(mode2));
        }
      }
    }
  } else {
    {
#line 1431
    fp = fdopen(fd, (char const   *)(mode2));
    }
  }
#line 1434
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1434
    return ((void *)0);
  }
#line 1436
  if (writing) {
#line 1438
    if (blockSize100k___0 < 1) {
#line 1438
      blockSize100k___0 = 1;
    }
#line 1439
    if (blockSize100k___0 > 9) {
#line 1439
      blockSize100k___0 = 9;
    }
    {
#line 1440
    bzfp = BZ2_bzWriteOpen(& bzerr, fp, blockSize100k___0, verbosity___0, workFactor___0);
    }
  } else {
    {
#line 1443
    bzfp = BZ2_bzReadOpen(& bzerr, fp, verbosity___0, smallMode___0, (void *)(unused),
                          nUnused);
    }
  }
#line 1446
  if ((unsigned long )bzfp == (unsigned long )((void *)0)) {
#line 1447
    if ((unsigned long )fp != (unsigned long )stdin) {
#line 1447
      if ((unsigned long )fp != (unsigned long )stdout) {
        {
#line 1447
        fclose(fp);
        }
      }
    }
#line 1448
    return ((void *)0);
  }
#line 1450
  return (bzfp);
}
}
#line 1460 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
BZFILE *BZ2_bzopen(char const   *path , char const   *mode ) 
{ 
  BZFILE *tmp ;

  {
  {
#line 1464
  tmp = bzopen_or_bzdopen(path, -1, mode, 0);
  }
#line 1464
  return (tmp);
}
}
#line 1469 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
BZFILE *BZ2_bzdopen(int fd , char const   *mode ) 
{ 
  BZFILE *tmp ;

  {
  {
#line 1473
  tmp = bzopen_or_bzdopen((char const   *)((void *)0), fd, mode, 1);
  }
#line 1473
  return (tmp);
}
}
#line 1478 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
int BZ2_bzread(BZFILE *b , void *buf , int len ) 
{ 
  int bzerr ;
  int nread ;

  {
#line 1481
  if (((bzFile *)b)->lastErr == 4) {
#line 1481
    return (0);
  }
  {
#line 1482
  nread = BZ2_bzRead(& bzerr, b, buf, len);
  }
#line 1483
  if (bzerr == 0) {
#line 1484
    return (nread);
  } else
#line 1483
  if (bzerr == 4) {
#line 1484
    return (nread);
  } else {
#line 1486
    return (-1);
  }
}
}
#line 1492 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
int BZ2_bzwrite(BZFILE *b , void *buf , int len ) 
{ 
  int bzerr ;

  {
  {
#line 1496
  BZ2_bzWrite(& bzerr, b, buf, len);
  }
#line 1497
  if (bzerr == 0) {
#line 1498
    return (len);
  } else {
#line 1500
    return (-1);
  }
}
}
#line 1506 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
int BZ2_bzflush(BZFILE *b ) 
{ 


  {
#line 1509
  return (0);
}
}
#line 1514 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
void BZ2_bzclose(BZFILE *b ) 
{ 
  int bzerr ;
  FILE *fp ;

  {
#line 1519
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1519
    return;
  }
#line 1520
  fp = ((bzFile *)b)->handle;
#line 1521
  if (((bzFile *)b)->writing) {
    {
#line 1522
    BZ2_bzWriteClose(& bzerr, b, 0, (unsigned int *)((void *)0), (unsigned int *)((void *)0));
    }
#line 1523
    if (bzerr != 0) {
      {
#line 1524
      BZ2_bzWriteClose((int *)((void *)0), b, 1, (unsigned int *)((void *)0), (unsigned int *)((void *)0));
      }
    }
  } else {
    {
#line 1527
    BZ2_bzReadClose(& bzerr, b);
    }
  }
#line 1529
  if ((unsigned long )fp != (unsigned long )stdin) {
#line 1529
    if ((unsigned long )fp != (unsigned long )stdout) {
      {
#line 1530
      fclose(fp);
      }
    }
  }
#line 1532
  return;
}
}
#line 1539 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static char const   *bzerrorstrings[16]  = 
#line 1539
  {      "OK",      "SEQUENCE_ERROR",      "PARAM_ERROR",      "MEM_ERROR", 
        "DATA_ERROR",      "DATA_ERROR_MAGIC",      "IO_ERROR",      "UNEXPECTED_EOF", 
        "OUTBUFF_FULL",      "CONFIG_ERROR",      "???",      "???", 
        "???",      "???",      "???",      "???"};
#line 1559 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
char const   *BZ2_bzerror(BZFILE *b , int *errnum ) 
{ 
  int err ;

  {
#line 1561
  err = ((bzFile *)b)->lastErr;
#line 1563
  if (err > 0) {
#line 1563
    err = 0;
  }
#line 1564
  *errnum = err;
#line 1565
  return (bzerrorstrings[err * -1]);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib_private.h"
void BZ2_blockSort(EState *s ) ;
#line 278
void BZ2_bsInitWrite(EState *s ) ;
#line 281
void BZ2_hbAssignCodes(Int32 *code , UChar *length , Int32 minLen , Int32 maxLen ,
                       Int32 alphaSize ) ;
#line 284
void BZ2_hbMakeCodeLengths(UChar *len , Int32 *freq , Int32 alphaSize , Int32 maxLen ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/compress.c"
void BZ2_bsInitWrite(EState *s ) 
{ 


  {
#line 39
  s->bsLive = 0;
#line 40
  s->bsBuff = (UInt32 )0;
#line 41
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/compress.c"
static void bsFinishWrite(EState *s ) 
{ 


  {
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (s->bsLive > 0)) {
#line 48
      goto while_break;
    }
#line 49
    *(s->zbits + s->numZ) = (UChar )(s->bsBuff >> 24);
#line 50
    (s->numZ) ++;
#line 51
    s->bsBuff <<= 8;
#line 52
    s->bsLive -= 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/compress.c"
__inline static void bsW(EState *s , Int32 n , UInt32 v ) 
{ 


  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (s->bsLive >= 8)) {
#line 75
      goto while_break;
    }
#line 75
    *(s->zbits + s->numZ) = (UChar )(s->bsBuff >> 24);
#line 75
    (s->numZ) ++;
#line 75
    s->bsBuff <<= 8;
#line 75
    s->bsLive -= 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  s->bsBuff |= v << ((32 - s->bsLive) - n);
#line 77
  s->bsLive += n;
#line 78
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/compress.c"
static void bsPutUInt32___0(EState *s , UInt32 u ) 
{ 


  {
  {
#line 85
  bsW(s, 8, (UInt32 )((long )(u >> 24) & 255L));
#line 86
  bsW(s, 8, (UInt32 )((long )(u >> 16) & 255L));
#line 87
  bsW(s, 8, (UInt32 )((long )(u >> 8) & 255L));
#line 88
  bsW(s, 8, (UInt32 )((long )u & 255L));
  }
#line 89
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/compress.c"
static void bsPutUChar___0(EState *s , UChar c ) 
{ 


  {
  {
#line 96
  bsW(s, 8, (UInt32 )c);
  }
#line 97
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/compress.c"
static void makeMaps_e(EState *s ) 
{ 
  Int32 i ;

  {
#line 109
  s->nInUse = 0;
#line 110
  i = 0;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (i < 256)) {
#line 110
      goto while_break;
    }
#line 111
    if (s->inUse[i]) {
#line 112
      s->unseqToSeq[i] = (UChar )s->nInUse;
#line 113
      (s->nInUse) ++;
    }
#line 110
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/compress.c"
static void generateMTFValues(EState *s ) 
{ 
  UChar yy[256] ;
  Int32 i ;
  Int32 j ;
  Int32 zPend ;
  Int32 wr ;
  Int32 EOB ;
  UInt32 *ptr ;
  UChar *block ;
  UInt16 *mtfv ;
  UChar ll_i ;
  register UChar rtmp ;
  register UChar *ryy_j ;
  register UChar rll_i ;
  register UChar rtmp2 ;

  {
  {
#line 150
  ptr = s->ptr;
#line 151
  block = s->block;
#line 152
  mtfv = s->mtfv;
#line 154
  makeMaps_e(s);
#line 155
  EOB = s->nInUse + 1;
#line 157
  i = 0;
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i <= EOB)) {
#line 157
      goto while_break;
    }
#line 157
    s->mtfFreq[i] = 0;
#line 157
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  wr = 0;
#line 160
  zPend = 0;
#line 161
  i = 0;
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 161
    if (! (i < s->nInUse)) {
#line 161
      goto while_break___0;
    }
#line 161
    yy[i] = (UChar )i;
#line 161
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 163
  i = 0;
  {
#line 163
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 163
    if (! (i < s->nblock)) {
#line 163
      goto while_break___1;
    }
#line 166
    j = (Int32 )(*(ptr + i) - 1U);
#line 166
    if (j < 0) {
#line 166
      j += s->nblock;
    }
#line 167
    ll_i = s->unseqToSeq[*(block + j)];
#line 170
    if ((int )yy[0] == (int )ll_i) {
#line 171
      zPend ++;
    } else {
#line 174
      if (zPend > 0) {
#line 175
        zPend --;
        {
#line 176
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 177
          if (zPend & 1) {
#line 178
            *(mtfv + wr) = (UInt16 )1;
#line 178
            wr ++;
#line 179
            (s->mtfFreq[1]) ++;
          } else {
#line 181
            *(mtfv + wr) = (UInt16 )0;
#line 181
            wr ++;
#line 182
            (s->mtfFreq[0]) ++;
          }
#line 184
          if (zPend < 2) {
#line 184
            goto while_break___2;
          }
#line 185
          zPend = (zPend - 2) / 2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 187
        zPend = 0;
      }
#line 193
      rtmp = yy[1];
#line 194
      yy[1] = yy[0];
#line 195
      ryy_j = & yy[1];
#line 196
      rll_i = ll_i;
      {
#line 197
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 197
        if (! ((int )rll_i != (int )rtmp)) {
#line 197
          goto while_break___3;
        }
#line 199
        ryy_j ++;
#line 200
        rtmp2 = rtmp;
#line 201
        rtmp = *ryy_j;
#line 202
        *ryy_j = rtmp2;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 204
      yy[0] = rtmp;
#line 205
      j = (Int32 )(ryy_j - & yy[0]);
#line 206
      *(mtfv + wr) = (UInt16 )(j + 1);
#line 206
      wr ++;
#line 206
      (s->mtfFreq[j + 1]) ++;
    }
#line 163
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 212
  if (zPend > 0) {
#line 213
    zPend --;
    {
#line 214
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 215
      if (zPend & 1) {
#line 216
        *(mtfv + wr) = (UInt16 )1;
#line 216
        wr ++;
#line 217
        (s->mtfFreq[1]) ++;
      } else {
#line 219
        *(mtfv + wr) = (UInt16 )0;
#line 219
        wr ++;
#line 220
        (s->mtfFreq[0]) ++;
      }
#line 222
      if (zPend < 2) {
#line 222
        goto while_break___4;
      }
#line 223
      zPend = (zPend - 2) / 2;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 225
    zPend = 0;
  }
#line 228
  *(mtfv + wr) = (UInt16 )EOB;
#line 228
  wr ++;
#line 228
  (s->mtfFreq[EOB]) ++;
#line 230
  s->nMTF = wr;
#line 231
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/compress.c"
static void sendMTFValues(EState *s ) 
{ 
  Int32 v ;
  Int32 t ;
  Int32 i ;
  Int32 j ;
  Int32 gs ;
  Int32 ge ;
  Int32 totc ;
  Int32 bt ;
  Int32 bc ;
  Int32 iter ;
  Int32 nSelectors ;
  Int32 alphaSize ;
  Int32 minLen ;
  Int32 maxLen ;
  Int32 selCtr ;
  Int32 nGroups ;
  Int32 nBytes ;
  UInt16 cost[6] ;
  Int32 fave[6] ;
  UInt16 *mtfv ;
  Int32 nPart ;
  Int32 remF ;
  Int32 tFreq ;
  Int32 aFreq ;
  register UInt32 cost01 ;
  register UInt32 cost23 ;
  register UInt32 cost45 ;
  register UInt16 icv ;
  UInt16 icv___0 ;
  UChar pos[6] ;
  UChar ll_i ;
  UChar tmp2 ;
  UChar tmp ;
  Bool inUse16[16] ;
  Int32 curr ;
  UInt16 mtfv_i ;
  UChar *s_len_sel_selCtr ;
  Int32 *s_code_sel_selCtr ;

  {
#line 259
  mtfv = s->mtfv;
#line 261
  if (s->verbosity >= 3) {
    {
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      %d in block, %d after MTF & 1-2 coding, %d+2 syms in use\n",
            s->nblock, s->nMTF, s->nInUse);
    }
  }
#line 266
  alphaSize = s->nInUse + 2;
#line 267
  t = 0;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! (t < 6)) {
#line 267
      goto while_break;
    }
#line 268
    v = 0;
    {
#line 268
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 268
      if (! (v < alphaSize)) {
#line 268
        goto while_break___0;
      }
#line 269
      s->len[t][v] = (UChar )15;
#line 268
      v ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 267
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  if (! (s->nMTF > 0)) {
    {
#line 272
    BZ2_bz__AssertH__fail(3001);
    }
  }
#line 273
  if (s->nMTF < 200) {
#line 273
    nGroups = 2;
  } else
#line 274
  if (s->nMTF < 600) {
#line 274
    nGroups = 3;
  } else
#line 275
  if (s->nMTF < 1200) {
#line 275
    nGroups = 4;
  } else
#line 276
  if (s->nMTF < 2400) {
#line 276
    nGroups = 5;
  } else {
#line 277
    nGroups = 6;
  }
#line 283
  nPart = nGroups;
#line 284
  remF = s->nMTF;
#line 285
  gs = 0;
  {
#line 286
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 286
    if (! (nPart > 0)) {
#line 286
      goto while_break___1;
    }
#line 287
    tFreq = remF / nPart;
#line 288
    ge = gs - 1;
#line 289
    aFreq = 0;
    {
#line 290
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 290
      if (aFreq < tFreq) {
#line 290
        if (! (ge < alphaSize - 1)) {
#line 290
          goto while_break___2;
        }
      } else {
#line 290
        goto while_break___2;
      }
#line 291
      ge ++;
#line 292
      aFreq += s->mtfFreq[ge];
    }
    while_break___2: /* CIL Label */ ;
    }
#line 295
    if (ge > gs) {
#line 295
      if (nPart != nGroups) {
#line 295
        if (nPart != 1) {
#line 295
          if ((nGroups - nPart) % 2 == 1) {
#line 298
            aFreq -= s->mtfFreq[ge];
#line 299
            ge --;
          }
        }
      }
    }
#line 302
    if (s->verbosity >= 3) {
      {
#line 303
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      initial group %d, [%d .. %d], has %d syms (%4.1f%%)\n",
              nPart, gs, ge, aFreq, (100.0 * (double )((float )aFreq)) / (double )((float )s->nMTF));
      }
    }
#line 308
    v = 0;
    {
#line 308
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 308
      if (! (v < alphaSize)) {
#line 308
        goto while_break___3;
      }
#line 309
      if (v >= gs) {
#line 309
        if (v <= ge) {
#line 310
          s->len[nPart - 1][v] = (UChar )0;
        } else {
#line 311
          s->len[nPart - 1][v] = (UChar )15;
        }
      } else {
#line 311
        s->len[nPart - 1][v] = (UChar )15;
      }
#line 308
      v ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 313
    nPart --;
#line 314
    gs = ge + 1;
#line 315
    remF -= aFreq;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 322
  iter = 0;
  {
#line 322
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 322
    if (! (iter < 4)) {
#line 322
      goto while_break___4;
    }
#line 324
    t = 0;
    {
#line 324
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 324
      if (! (t < nGroups)) {
#line 324
        goto while_break___5;
      }
#line 324
      fave[t] = 0;
#line 324
      t ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 326
    t = 0;
    {
#line 326
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 326
      if (! (t < nGroups)) {
#line 326
        goto while_break___6;
      }
#line 327
      v = 0;
      {
#line 327
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 327
        if (! (v < alphaSize)) {
#line 327
          goto while_break___7;
        }
#line 328
        s->rfreq[t][v] = 0;
#line 327
        v ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 326
      t ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 334
    if (nGroups == 6) {
#line 335
      v = 0;
      {
#line 335
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 335
        if (! (v < alphaSize)) {
#line 335
          goto while_break___8;
        }
#line 336
        s->len_pack[v][0] = (UInt32 )(((int )s->len[1][v] << 16) | (int )s->len[0][v]);
#line 337
        s->len_pack[v][1] = (UInt32 )(((int )s->len[3][v] << 16) | (int )s->len[2][v]);
#line 338
        s->len_pack[v][2] = (UInt32 )(((int )s->len[5][v] << 16) | (int )s->len[4][v]);
#line 335
        v ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 342
    nSelectors = 0;
#line 343
    totc = 0;
#line 344
    gs = 0;
    {
#line 345
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 348
      if (gs >= s->nMTF) {
#line 348
        goto while_break___9;
      }
#line 349
      ge = (gs + 50) - 1;
#line 350
      if (ge >= s->nMTF) {
#line 350
        ge = s->nMTF - 1;
      }
#line 356
      t = 0;
      {
#line 356
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 356
        if (! (t < nGroups)) {
#line 356
          goto while_break___10;
        }
#line 356
        cost[t] = (UInt16 )0;
#line 356
        t ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 358
      if (nGroups == 6) {
#line 358
        if (50 == (ge - gs) + 1) {
#line 362
          cost45 = (UInt32 )0;
#line 362
          cost23 = cost45;
#line 362
          cost01 = cost23;
#line 370
          icv = *(mtfv + gs);
#line 370
          cost01 += s->len_pack[icv][0];
#line 370
          cost23 += s->len_pack[icv][1];
#line 370
          cost45 += s->len_pack[icv][2];
#line 370
          icv = *(mtfv + (gs + 1));
#line 370
          cost01 += s->len_pack[icv][0];
#line 370
          cost23 += s->len_pack[icv][1];
#line 370
          cost45 += s->len_pack[icv][2];
#line 370
          icv = *(mtfv + (gs + 2));
#line 370
          cost01 += s->len_pack[icv][0];
#line 370
          cost23 += s->len_pack[icv][1];
#line 370
          cost45 += s->len_pack[icv][2];
#line 370
          icv = *(mtfv + (gs + 3));
#line 370
          cost01 += s->len_pack[icv][0];
#line 370
          cost23 += s->len_pack[icv][1];
#line 370
          cost45 += s->len_pack[icv][2];
#line 370
          icv = *(mtfv + (gs + 4));
#line 370
          cost01 += s->len_pack[icv][0];
#line 370
          cost23 += s->len_pack[icv][1];
#line 370
          cost45 += s->len_pack[icv][2];
#line 371
          icv = *(mtfv + (gs + 5));
#line 371
          cost01 += s->len_pack[icv][0];
#line 371
          cost23 += s->len_pack[icv][1];
#line 371
          cost45 += s->len_pack[icv][2];
#line 371
          icv = *(mtfv + (gs + 6));
#line 371
          cost01 += s->len_pack[icv][0];
#line 371
          cost23 += s->len_pack[icv][1];
#line 371
          cost45 += s->len_pack[icv][2];
#line 371
          icv = *(mtfv + (gs + 7));
#line 371
          cost01 += s->len_pack[icv][0];
#line 371
          cost23 += s->len_pack[icv][1];
#line 371
          cost45 += s->len_pack[icv][2];
#line 371
          icv = *(mtfv + (gs + 8));
#line 371
          cost01 += s->len_pack[icv][0];
#line 371
          cost23 += s->len_pack[icv][1];
#line 371
          cost45 += s->len_pack[icv][2];
#line 371
          icv = *(mtfv + (gs + 9));
#line 371
          cost01 += s->len_pack[icv][0];
#line 371
          cost23 += s->len_pack[icv][1];
#line 371
          cost45 += s->len_pack[icv][2];
#line 372
          icv = *(mtfv + (gs + 10));
#line 372
          cost01 += s->len_pack[icv][0];
#line 372
          cost23 += s->len_pack[icv][1];
#line 372
          cost45 += s->len_pack[icv][2];
#line 372
          icv = *(mtfv + (gs + 11));
#line 372
          cost01 += s->len_pack[icv][0];
#line 372
          cost23 += s->len_pack[icv][1];
#line 372
          cost45 += s->len_pack[icv][2];
#line 372
          icv = *(mtfv + (gs + 12));
#line 372
          cost01 += s->len_pack[icv][0];
#line 372
          cost23 += s->len_pack[icv][1];
#line 372
          cost45 += s->len_pack[icv][2];
#line 372
          icv = *(mtfv + (gs + 13));
#line 372
          cost01 += s->len_pack[icv][0];
#line 372
          cost23 += s->len_pack[icv][1];
#line 372
          cost45 += s->len_pack[icv][2];
#line 372
          icv = *(mtfv + (gs + 14));
#line 372
          cost01 += s->len_pack[icv][0];
#line 372
          cost23 += s->len_pack[icv][1];
#line 372
          cost45 += s->len_pack[icv][2];
#line 373
          icv = *(mtfv + (gs + 15));
#line 373
          cost01 += s->len_pack[icv][0];
#line 373
          cost23 += s->len_pack[icv][1];
#line 373
          cost45 += s->len_pack[icv][2];
#line 373
          icv = *(mtfv + (gs + 16));
#line 373
          cost01 += s->len_pack[icv][0];
#line 373
          cost23 += s->len_pack[icv][1];
#line 373
          cost45 += s->len_pack[icv][2];
#line 373
          icv = *(mtfv + (gs + 17));
#line 373
          cost01 += s->len_pack[icv][0];
#line 373
          cost23 += s->len_pack[icv][1];
#line 373
          cost45 += s->len_pack[icv][2];
#line 373
          icv = *(mtfv + (gs + 18));
#line 373
          cost01 += s->len_pack[icv][0];
#line 373
          cost23 += s->len_pack[icv][1];
#line 373
          cost45 += s->len_pack[icv][2];
#line 373
          icv = *(mtfv + (gs + 19));
#line 373
          cost01 += s->len_pack[icv][0];
#line 373
          cost23 += s->len_pack[icv][1];
#line 373
          cost45 += s->len_pack[icv][2];
#line 374
          icv = *(mtfv + (gs + 20));
#line 374
          cost01 += s->len_pack[icv][0];
#line 374
          cost23 += s->len_pack[icv][1];
#line 374
          cost45 += s->len_pack[icv][2];
#line 374
          icv = *(mtfv + (gs + 21));
#line 374
          cost01 += s->len_pack[icv][0];
#line 374
          cost23 += s->len_pack[icv][1];
#line 374
          cost45 += s->len_pack[icv][2];
#line 374
          icv = *(mtfv + (gs + 22));
#line 374
          cost01 += s->len_pack[icv][0];
#line 374
          cost23 += s->len_pack[icv][1];
#line 374
          cost45 += s->len_pack[icv][2];
#line 374
          icv = *(mtfv + (gs + 23));
#line 374
          cost01 += s->len_pack[icv][0];
#line 374
          cost23 += s->len_pack[icv][1];
#line 374
          cost45 += s->len_pack[icv][2];
#line 374
          icv = *(mtfv + (gs + 24));
#line 374
          cost01 += s->len_pack[icv][0];
#line 374
          cost23 += s->len_pack[icv][1];
#line 374
          cost45 += s->len_pack[icv][2];
#line 375
          icv = *(mtfv + (gs + 25));
#line 375
          cost01 += s->len_pack[icv][0];
#line 375
          cost23 += s->len_pack[icv][1];
#line 375
          cost45 += s->len_pack[icv][2];
#line 375
          icv = *(mtfv + (gs + 26));
#line 375
          cost01 += s->len_pack[icv][0];
#line 375
          cost23 += s->len_pack[icv][1];
#line 375
          cost45 += s->len_pack[icv][2];
#line 375
          icv = *(mtfv + (gs + 27));
#line 375
          cost01 += s->len_pack[icv][0];
#line 375
          cost23 += s->len_pack[icv][1];
#line 375
          cost45 += s->len_pack[icv][2];
#line 375
          icv = *(mtfv + (gs + 28));
#line 375
          cost01 += s->len_pack[icv][0];
#line 375
          cost23 += s->len_pack[icv][1];
#line 375
          cost45 += s->len_pack[icv][2];
#line 375
          icv = *(mtfv + (gs + 29));
#line 375
          cost01 += s->len_pack[icv][0];
#line 375
          cost23 += s->len_pack[icv][1];
#line 375
          cost45 += s->len_pack[icv][2];
#line 376
          icv = *(mtfv + (gs + 30));
#line 376
          cost01 += s->len_pack[icv][0];
#line 376
          cost23 += s->len_pack[icv][1];
#line 376
          cost45 += s->len_pack[icv][2];
#line 376
          icv = *(mtfv + (gs + 31));
#line 376
          cost01 += s->len_pack[icv][0];
#line 376
          cost23 += s->len_pack[icv][1];
#line 376
          cost45 += s->len_pack[icv][2];
#line 376
          icv = *(mtfv + (gs + 32));
#line 376
          cost01 += s->len_pack[icv][0];
#line 376
          cost23 += s->len_pack[icv][1];
#line 376
          cost45 += s->len_pack[icv][2];
#line 376
          icv = *(mtfv + (gs + 33));
#line 376
          cost01 += s->len_pack[icv][0];
#line 376
          cost23 += s->len_pack[icv][1];
#line 376
          cost45 += s->len_pack[icv][2];
#line 376
          icv = *(mtfv + (gs + 34));
#line 376
          cost01 += s->len_pack[icv][0];
#line 376
          cost23 += s->len_pack[icv][1];
#line 376
          cost45 += s->len_pack[icv][2];
#line 377
          icv = *(mtfv + (gs + 35));
#line 377
          cost01 += s->len_pack[icv][0];
#line 377
          cost23 += s->len_pack[icv][1];
#line 377
          cost45 += s->len_pack[icv][2];
#line 377
          icv = *(mtfv + (gs + 36));
#line 377
          cost01 += s->len_pack[icv][0];
#line 377
          cost23 += s->len_pack[icv][1];
#line 377
          cost45 += s->len_pack[icv][2];
#line 377
          icv = *(mtfv + (gs + 37));
#line 377
          cost01 += s->len_pack[icv][0];
#line 377
          cost23 += s->len_pack[icv][1];
#line 377
          cost45 += s->len_pack[icv][2];
#line 377
          icv = *(mtfv + (gs + 38));
#line 377
          cost01 += s->len_pack[icv][0];
#line 377
          cost23 += s->len_pack[icv][1];
#line 377
          cost45 += s->len_pack[icv][2];
#line 377
          icv = *(mtfv + (gs + 39));
#line 377
          cost01 += s->len_pack[icv][0];
#line 377
          cost23 += s->len_pack[icv][1];
#line 377
          cost45 += s->len_pack[icv][2];
#line 378
          icv = *(mtfv + (gs + 40));
#line 378
          cost01 += s->len_pack[icv][0];
#line 378
          cost23 += s->len_pack[icv][1];
#line 378
          cost45 += s->len_pack[icv][2];
#line 378
          icv = *(mtfv + (gs + 41));
#line 378
          cost01 += s->len_pack[icv][0];
#line 378
          cost23 += s->len_pack[icv][1];
#line 378
          cost45 += s->len_pack[icv][2];
#line 378
          icv = *(mtfv + (gs + 42));
#line 378
          cost01 += s->len_pack[icv][0];
#line 378
          cost23 += s->len_pack[icv][1];
#line 378
          cost45 += s->len_pack[icv][2];
#line 378
          icv = *(mtfv + (gs + 43));
#line 378
          cost01 += s->len_pack[icv][0];
#line 378
          cost23 += s->len_pack[icv][1];
#line 378
          cost45 += s->len_pack[icv][2];
#line 378
          icv = *(mtfv + (gs + 44));
#line 378
          cost01 += s->len_pack[icv][0];
#line 378
          cost23 += s->len_pack[icv][1];
#line 378
          cost45 += s->len_pack[icv][2];
#line 379
          icv = *(mtfv + (gs + 45));
#line 379
          cost01 += s->len_pack[icv][0];
#line 379
          cost23 += s->len_pack[icv][1];
#line 379
          cost45 += s->len_pack[icv][2];
#line 379
          icv = *(mtfv + (gs + 46));
#line 379
          cost01 += s->len_pack[icv][0];
#line 379
          cost23 += s->len_pack[icv][1];
#line 379
          cost45 += s->len_pack[icv][2];
#line 379
          icv = *(mtfv + (gs + 47));
#line 379
          cost01 += s->len_pack[icv][0];
#line 379
          cost23 += s->len_pack[icv][1];
#line 379
          cost45 += s->len_pack[icv][2];
#line 379
          icv = *(mtfv + (gs + 48));
#line 379
          cost01 += s->len_pack[icv][0];
#line 379
          cost23 += s->len_pack[icv][1];
#line 379
          cost45 += s->len_pack[icv][2];
#line 379
          icv = *(mtfv + (gs + 49));
#line 379
          cost01 += s->len_pack[icv][0];
#line 379
          cost23 += s->len_pack[icv][1];
#line 379
          cost45 += s->len_pack[icv][2];
#line 383
          cost[0] = (UInt16 )(cost01 & 65535U);
#line 383
          cost[1] = (UInt16 )(cost01 >> 16);
#line 384
          cost[2] = (UInt16 )(cost23 & 65535U);
#line 384
          cost[3] = (UInt16 )(cost23 >> 16);
#line 385
          cost[4] = (UInt16 )(cost45 & 65535U);
#line 385
          cost[5] = (UInt16 )(cost45 >> 16);
        } else {
#line 358
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 389
        i = gs;
        {
#line 389
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 389
          if (! (i <= ge)) {
#line 389
            goto while_break___11;
          }
#line 390
          icv___0 = *(mtfv + i);
#line 391
          t = 0;
          {
#line 391
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 391
            if (! (t < nGroups)) {
#line 391
              goto while_break___12;
            }
#line 391
            cost[t] = (UInt16 )((int )cost[t] + (int )s->len[t][icv___0]);
#line 391
            t ++;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 389
          i ++;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
#line 399
      bc = 999999999;
#line 399
      bt = -1;
#line 400
      t = 0;
      {
#line 400
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 400
        if (! (t < nGroups)) {
#line 400
          goto while_break___13;
        }
#line 401
        if ((int )cost[t] < bc) {
#line 401
          bc = (Int32 )cost[t];
#line 401
          bt = t;
        }
#line 400
        t ++;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 402
      totc += bc;
#line 403
      (fave[bt]) ++;
#line 404
      s->selector[nSelectors] = (UChar )bt;
#line 405
      nSelectors ++;
#line 410
      if (nGroups == 6) {
#line 410
        if (50 == (ge - gs) + 1) {
#line 415
          (s->rfreq[bt][*(mtfv + gs)]) ++;
#line 415
          (s->rfreq[bt][*(mtfv + (gs + 1))]) ++;
#line 415
          (s->rfreq[bt][*(mtfv + (gs + 2))]) ++;
#line 415
          (s->rfreq[bt][*(mtfv + (gs + 3))]) ++;
#line 415
          (s->rfreq[bt][*(mtfv + (gs + 4))]) ++;
#line 416
          (s->rfreq[bt][*(mtfv + (gs + 5))]) ++;
#line 416
          (s->rfreq[bt][*(mtfv + (gs + 6))]) ++;
#line 416
          (s->rfreq[bt][*(mtfv + (gs + 7))]) ++;
#line 416
          (s->rfreq[bt][*(mtfv + (gs + 8))]) ++;
#line 416
          (s->rfreq[bt][*(mtfv + (gs + 9))]) ++;
#line 417
          (s->rfreq[bt][*(mtfv + (gs + 10))]) ++;
#line 417
          (s->rfreq[bt][*(mtfv + (gs + 11))]) ++;
#line 417
          (s->rfreq[bt][*(mtfv + (gs + 12))]) ++;
#line 417
          (s->rfreq[bt][*(mtfv + (gs + 13))]) ++;
#line 417
          (s->rfreq[bt][*(mtfv + (gs + 14))]) ++;
#line 418
          (s->rfreq[bt][*(mtfv + (gs + 15))]) ++;
#line 418
          (s->rfreq[bt][*(mtfv + (gs + 16))]) ++;
#line 418
          (s->rfreq[bt][*(mtfv + (gs + 17))]) ++;
#line 418
          (s->rfreq[bt][*(mtfv + (gs + 18))]) ++;
#line 418
          (s->rfreq[bt][*(mtfv + (gs + 19))]) ++;
#line 419
          (s->rfreq[bt][*(mtfv + (gs + 20))]) ++;
#line 419
          (s->rfreq[bt][*(mtfv + (gs + 21))]) ++;
#line 419
          (s->rfreq[bt][*(mtfv + (gs + 22))]) ++;
#line 419
          (s->rfreq[bt][*(mtfv + (gs + 23))]) ++;
#line 419
          (s->rfreq[bt][*(mtfv + (gs + 24))]) ++;
#line 420
          (s->rfreq[bt][*(mtfv + (gs + 25))]) ++;
#line 420
          (s->rfreq[bt][*(mtfv + (gs + 26))]) ++;
#line 420
          (s->rfreq[bt][*(mtfv + (gs + 27))]) ++;
#line 420
          (s->rfreq[bt][*(mtfv + (gs + 28))]) ++;
#line 420
          (s->rfreq[bt][*(mtfv + (gs + 29))]) ++;
#line 421
          (s->rfreq[bt][*(mtfv + (gs + 30))]) ++;
#line 421
          (s->rfreq[bt][*(mtfv + (gs + 31))]) ++;
#line 421
          (s->rfreq[bt][*(mtfv + (gs + 32))]) ++;
#line 421
          (s->rfreq[bt][*(mtfv + (gs + 33))]) ++;
#line 421
          (s->rfreq[bt][*(mtfv + (gs + 34))]) ++;
#line 422
          (s->rfreq[bt][*(mtfv + (gs + 35))]) ++;
#line 422
          (s->rfreq[bt][*(mtfv + (gs + 36))]) ++;
#line 422
          (s->rfreq[bt][*(mtfv + (gs + 37))]) ++;
#line 422
          (s->rfreq[bt][*(mtfv + (gs + 38))]) ++;
#line 422
          (s->rfreq[bt][*(mtfv + (gs + 39))]) ++;
#line 423
          (s->rfreq[bt][*(mtfv + (gs + 40))]) ++;
#line 423
          (s->rfreq[bt][*(mtfv + (gs + 41))]) ++;
#line 423
          (s->rfreq[bt][*(mtfv + (gs + 42))]) ++;
#line 423
          (s->rfreq[bt][*(mtfv + (gs + 43))]) ++;
#line 423
          (s->rfreq[bt][*(mtfv + (gs + 44))]) ++;
#line 424
          (s->rfreq[bt][*(mtfv + (gs + 45))]) ++;
#line 424
          (s->rfreq[bt][*(mtfv + (gs + 46))]) ++;
#line 424
          (s->rfreq[bt][*(mtfv + (gs + 47))]) ++;
#line 424
          (s->rfreq[bt][*(mtfv + (gs + 48))]) ++;
#line 424
          (s->rfreq[bt][*(mtfv + (gs + 49))]) ++;
        } else {
#line 410
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 430
        i = gs;
        {
#line 430
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 430
          if (! (i <= ge)) {
#line 430
            goto while_break___14;
          }
#line 431
          (s->rfreq[bt][*(mtfv + i)]) ++;
#line 430
          i ++;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
#line 434
      gs = ge + 1;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 436
    if (s->verbosity >= 3) {
      {
#line 437
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      pass %d: size is %d, grp uses are ",
              iter + 1, totc / 8);
#line 439
      t = 0;
      }
      {
#line 439
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 439
        if (! (t < nGroups)) {
#line 439
          goto while_break___15;
        }
        {
#line 440
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d ",
                fave[t]);
#line 439
        t ++;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 441
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 449
    t = 0;
    {
#line 449
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 449
      if (! (t < nGroups)) {
#line 449
        goto while_break___16;
      }
      {
#line 450
      BZ2_hbMakeCodeLengths(& s->len[t][0], & s->rfreq[t][0], alphaSize, 17);
#line 449
      t ++;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
#line 322
    iter ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 455
  if (! (nGroups < 8)) {
    {
#line 455
    BZ2_bz__AssertH__fail(3002);
    }
  }
#line 456
  if (nSelectors < 32768) {
#line 456
    if (! (nSelectors <= 18002)) {
      {
#line 456
      BZ2_bz__AssertH__fail(3003);
      }
    }
  } else {
    {
#line 456
    BZ2_bz__AssertH__fail(3003);
    }
  }
#line 464
  i = 0;
  {
#line 464
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 464
    if (! (i < nGroups)) {
#line 464
      goto while_break___17;
    }
#line 464
    pos[i] = (UChar )i;
#line 464
    i ++;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 465
  i = 0;
  {
#line 465
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 465
    if (! (i < nSelectors)) {
#line 465
      goto while_break___18;
    }
#line 466
    ll_i = s->selector[i];
#line 467
    j = 0;
#line 468
    tmp = pos[j];
    {
#line 469
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 469
      if (! ((int )ll_i != (int )tmp)) {
#line 469
        goto while_break___19;
      }
#line 470
      j ++;
#line 471
      tmp2 = tmp;
#line 472
      tmp = pos[j];
#line 473
      pos[j] = tmp2;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 475
    pos[0] = tmp;
#line 476
    s->selectorMtf[i] = (UChar )j;
#line 465
    i ++;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 481
  t = 0;
  {
#line 481
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 481
    if (! (t < nGroups)) {
#line 481
      goto while_break___20;
    }
#line 482
    minLen = 32;
#line 483
    maxLen = 0;
#line 484
    i = 0;
    {
#line 484
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 484
      if (! (i < alphaSize)) {
#line 484
        goto while_break___21;
      }
#line 485
      if ((int )s->len[t][i] > maxLen) {
#line 485
        maxLen = (Int32 )s->len[t][i];
      }
#line 486
      if ((int )s->len[t][i] < minLen) {
#line 486
        minLen = (Int32 )s->len[t][i];
      }
#line 484
      i ++;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 488
    if (! (! (maxLen > 17))) {
      {
#line 488
      BZ2_bz__AssertH__fail(3004);
      }
    }
#line 489
    if (! (! (minLen < 1))) {
      {
#line 489
      BZ2_bz__AssertH__fail(3005);
      }
    }
    {
#line 490
    BZ2_hbAssignCodes(& s->code[t][0], & s->len[t][0], minLen, maxLen, alphaSize);
#line 481
    t ++;
    }
  }
  while_break___20: /* CIL Label */ ;
  }
#line 497
  i = 0;
  {
#line 497
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 497
    if (! (i < 16)) {
#line 497
      goto while_break___22;
    }
#line 498
    inUse16[i] = (Bool )0;
#line 499
    j = 0;
    {
#line 499
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 499
      if (! (j < 16)) {
#line 499
        goto while_break___23;
      }
#line 500
      if (s->inUse[i * 16 + j]) {
#line 500
        inUse16[i] = (Bool )1;
      }
#line 499
      j ++;
    }
    while_break___23: /* CIL Label */ ;
    }
#line 497
    i ++;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 503
  nBytes = s->numZ;
#line 504
  i = 0;
  {
#line 504
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 504
    if (! (i < 16)) {
#line 504
      goto while_break___24;
    }
#line 505
    if (inUse16[i]) {
      {
#line 505
      bsW(s, 1, (UInt32 )1);
      }
    } else {
      {
#line 505
      bsW(s, 1, (UInt32 )0);
      }
    }
#line 504
    i ++;
  }
  while_break___24: /* CIL Label */ ;
  }
#line 507
  i = 0;
  {
#line 507
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 507
    if (! (i < 16)) {
#line 507
      goto while_break___25;
    }
#line 508
    if (inUse16[i]) {
#line 509
      j = 0;
      {
#line 509
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 509
        if (! (j < 16)) {
#line 509
          goto while_break___26;
        }
#line 510
        if (s->inUse[i * 16 + j]) {
          {
#line 510
          bsW(s, 1, (UInt32 )1);
          }
        } else {
          {
#line 510
          bsW(s, 1, (UInt32 )0);
          }
        }
#line 509
        j ++;
      }
      while_break___26: /* CIL Label */ ;
      }
    }
#line 507
    i ++;
  }
  while_break___25: /* CIL Label */ ;
  }
#line 513
  if (s->verbosity >= 3) {
    {
#line 514
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      bytes: mapping %d, ",
            s->numZ - nBytes);
    }
  }
  {
#line 518
  nBytes = s->numZ;
#line 519
  bsW(s, 3, (UInt32 )nGroups);
#line 520
  bsW(s, 15, (UInt32 )nSelectors);
#line 521
  i = 0;
  }
  {
#line 521
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 521
    if (! (i < nSelectors)) {
#line 521
      goto while_break___27;
    }
#line 522
    j = 0;
    {
#line 522
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 522
      if (! (j < (Int32 )s->selectorMtf[i])) {
#line 522
        goto while_break___28;
      }
      {
#line 522
      bsW(s, 1, (UInt32 )1);
#line 522
      j ++;
      }
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 523
    bsW(s, 1, (UInt32 )0);
#line 521
    i ++;
    }
  }
  while_break___27: /* CIL Label */ ;
  }
#line 525
  if (s->verbosity >= 3) {
    {
#line 526
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"selectors %d, ",
            s->numZ - nBytes);
    }
  }
#line 529
  nBytes = s->numZ;
#line 531
  t = 0;
  {
#line 531
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 531
    if (! (t < nGroups)) {
#line 531
      goto while_break___29;
    }
    {
#line 532
    curr = (Int32 )s->len[t][0];
#line 533
    bsW(s, 5, (UInt32 )curr);
#line 534
    i = 0;
    }
    {
#line 534
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 534
      if (! (i < alphaSize)) {
#line 534
        goto while_break___30;
      }
      {
#line 535
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 535
        if (! (curr < (Int32 )s->len[t][i])) {
#line 535
          goto while_break___31;
        }
        {
#line 535
        bsW(s, 2, (UInt32 )2);
#line 535
        curr ++;
        }
      }
      while_break___31: /* CIL Label */ ;
      }
      {
#line 536
      while (1) {
        while_continue___32: /* CIL Label */ ;
#line 536
        if (! (curr > (Int32 )s->len[t][i])) {
#line 536
          goto while_break___32;
        }
        {
#line 536
        bsW(s, 2, (UInt32 )3);
#line 536
        curr --;
        }
      }
      while_break___32: /* CIL Label */ ;
      }
      {
#line 537
      bsW(s, 1, (UInt32 )0);
#line 534
      i ++;
      }
    }
    while_break___30: /* CIL Label */ ;
    }
#line 531
    t ++;
  }
  while_break___29: /* CIL Label */ ;
  }
#line 541
  if (s->verbosity >= 3) {
    {
#line 542
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"code lengths %d, ",
            s->numZ - nBytes);
    }
  }
#line 545
  nBytes = s->numZ;
#line 546
  selCtr = 0;
#line 547
  gs = 0;
  {
#line 548
  while (1) {
    while_continue___33: /* CIL Label */ ;
#line 549
    if (gs >= s->nMTF) {
#line 549
      goto while_break___33;
    }
#line 550
    ge = (gs + 50) - 1;
#line 551
    if (ge >= s->nMTF) {
#line 551
      ge = s->nMTF - 1;
    }
#line 552
    if (! ((int )s->selector[selCtr] < nGroups)) {
      {
#line 552
      BZ2_bz__AssertH__fail(3006);
      }
    }
#line 554
    if (nGroups == 6) {
#line 554
      if (50 == (ge - gs) + 1) {
        {
#line 557
        s_len_sel_selCtr = & s->len[s->selector[selCtr]][0];
#line 559
        s_code_sel_selCtr = & s->code[s->selector[selCtr]][0];
#line 568
        mtfv_i = *(mtfv + gs);
#line 568
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 568
        mtfv_i = *(mtfv + (gs + 1));
#line 568
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 568
        mtfv_i = *(mtfv + (gs + 2));
#line 568
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 568
        mtfv_i = *(mtfv + (gs + 3));
#line 568
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 568
        mtfv_i = *(mtfv + (gs + 4));
#line 568
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 569
        mtfv_i = *(mtfv + (gs + 5));
#line 569
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 569
        mtfv_i = *(mtfv + (gs + 6));
#line 569
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 569
        mtfv_i = *(mtfv + (gs + 7));
#line 569
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 569
        mtfv_i = *(mtfv + (gs + 8));
#line 569
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 569
        mtfv_i = *(mtfv + (gs + 9));
#line 569
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 570
        mtfv_i = *(mtfv + (gs + 10));
#line 570
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 570
        mtfv_i = *(mtfv + (gs + 11));
#line 570
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 570
        mtfv_i = *(mtfv + (gs + 12));
#line 570
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 570
        mtfv_i = *(mtfv + (gs + 13));
#line 570
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 570
        mtfv_i = *(mtfv + (gs + 14));
#line 570
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 571
        mtfv_i = *(mtfv + (gs + 15));
#line 571
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 571
        mtfv_i = *(mtfv + (gs + 16));
#line 571
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 571
        mtfv_i = *(mtfv + (gs + 17));
#line 571
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 571
        mtfv_i = *(mtfv + (gs + 18));
#line 571
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 571
        mtfv_i = *(mtfv + (gs + 19));
#line 571
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 572
        mtfv_i = *(mtfv + (gs + 20));
#line 572
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 572
        mtfv_i = *(mtfv + (gs + 21));
#line 572
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 572
        mtfv_i = *(mtfv + (gs + 22));
#line 572
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 572
        mtfv_i = *(mtfv + (gs + 23));
#line 572
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 572
        mtfv_i = *(mtfv + (gs + 24));
#line 572
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 573
        mtfv_i = *(mtfv + (gs + 25));
#line 573
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 573
        mtfv_i = *(mtfv + (gs + 26));
#line 573
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 573
        mtfv_i = *(mtfv + (gs + 27));
#line 573
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 573
        mtfv_i = *(mtfv + (gs + 28));
#line 573
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 573
        mtfv_i = *(mtfv + (gs + 29));
#line 573
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 574
        mtfv_i = *(mtfv + (gs + 30));
#line 574
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 574
        mtfv_i = *(mtfv + (gs + 31));
#line 574
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 574
        mtfv_i = *(mtfv + (gs + 32));
#line 574
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 574
        mtfv_i = *(mtfv + (gs + 33));
#line 574
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 574
        mtfv_i = *(mtfv + (gs + 34));
#line 574
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 575
        mtfv_i = *(mtfv + (gs + 35));
#line 575
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 575
        mtfv_i = *(mtfv + (gs + 36));
#line 575
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 575
        mtfv_i = *(mtfv + (gs + 37));
#line 575
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 575
        mtfv_i = *(mtfv + (gs + 38));
#line 575
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 575
        mtfv_i = *(mtfv + (gs + 39));
#line 575
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 576
        mtfv_i = *(mtfv + (gs + 40));
#line 576
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 576
        mtfv_i = *(mtfv + (gs + 41));
#line 576
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 576
        mtfv_i = *(mtfv + (gs + 42));
#line 576
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 576
        mtfv_i = *(mtfv + (gs + 43));
#line 576
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 576
        mtfv_i = *(mtfv + (gs + 44));
#line 576
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 577
        mtfv_i = *(mtfv + (gs + 45));
#line 577
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 577
        mtfv_i = *(mtfv + (gs + 46));
#line 577
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 577
        mtfv_i = *(mtfv + (gs + 47));
#line 577
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 577
        mtfv_i = *(mtfv + (gs + 48));
#line 577
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 577
        mtfv_i = *(mtfv + (gs + 49));
#line 577
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        }
      } else {
#line 554
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 583
      i = gs;
      {
#line 583
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 583
        if (! (i <= ge)) {
#line 583
          goto while_break___34;
        }
        {
#line 584
        bsW(s, (Int32 )s->len[s->selector[selCtr]][*(mtfv + i)], (UInt32 )s->code[s->selector[selCtr]][*(mtfv + i)]);
#line 583
        i ++;
        }
      }
      while_break___34: /* CIL Label */ ;
      }
    }
#line 591
    gs = ge + 1;
#line 592
    selCtr ++;
  }
  while_break___33: /* CIL Label */ ;
  }
#line 594
  if (! (selCtr == nSelectors)) {
    {
#line 594
    BZ2_bz__AssertH__fail(3007);
    }
  }
#line 596
  if (s->verbosity >= 3) {
    {
#line 597
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"codes %d\n",
            s->numZ - nBytes);
    }
  }
#line 598
  return;
}
}
#line 602 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/compress.c"
void BZ2_compressBlock(EState *s , Bool is_last_block ) 
{ 


  {
#line 604
  if (s->nblock > 0) {
#line 606
    s->blockCRC = ~ s->blockCRC;
#line 607
    s->combinedCRC = (s->combinedCRC << 1) | (s->combinedCRC >> 31);
#line 608
    s->combinedCRC ^= s->blockCRC;
#line 609
    if (s->blockNo > 1) {
#line 609
      s->numZ = 0;
    }
#line 611
    if (s->verbosity >= 2) {
      {
#line 612
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    block %d: crc = 0x%08x, combined CRC = 0x%08x, size = %d\n",
              s->blockNo, s->blockCRC, s->combinedCRC, s->nblock);
      }
    }
    {
#line 616
    BZ2_blockSort(s);
    }
  }
#line 619
  s->zbits = (UChar *)s->arr2 + s->nblock;
#line 622
  if (s->blockNo == 1) {
    {
#line 623
    BZ2_bsInitWrite(s);
#line 624
    bsPutUChar___0(s, (UChar )66);
#line 625
    bsPutUChar___0(s, (UChar )90);
#line 626
    bsPutUChar___0(s, (UChar )104);
#line 627
    bsPutUChar___0(s, (UChar )(48 + s->blockSize100k));
    }
  }
#line 630
  if (s->nblock > 0) {
    {
#line 632
    bsPutUChar___0(s, (UChar )49);
#line 632
    bsPutUChar___0(s, (UChar )65);
#line 633
    bsPutUChar___0(s, (UChar )89);
#line 633
    bsPutUChar___0(s, (UChar )38);
#line 634
    bsPutUChar___0(s, (UChar )83);
#line 634
    bsPutUChar___0(s, (UChar )89);
#line 637
    bsPutUInt32___0(s, s->blockCRC);
#line 648
    bsW(s, 1, (UInt32 )0);
#line 650
    bsW(s, 24, (UInt32 )s->origPtr);
#line 651
    generateMTFValues(s);
#line 652
    sendMTFValues(s);
    }
  }
#line 657
  if (is_last_block) {
    {
#line 659
    bsPutUChar___0(s, (UChar )23);
#line 659
    bsPutUChar___0(s, (UChar )114);
#line 660
    bsPutUChar___0(s, (UChar )69);
#line 660
    bsPutUChar___0(s, (UChar )56);
#line 661
    bsPutUChar___0(s, (UChar )80);
#line 661
    bsPutUChar___0(s, (UChar )144);
#line 662
    bsPutUInt32___0(s, s->combinedCRC);
    }
#line 663
    if (s->verbosity >= 2) {
      {
#line 664
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    final combined CRC = 0x%08x\n   ",
              s->combinedCRC);
      }
    }
    {
#line 665
    bsFinishWrite(s);
    }
  }
#line 667
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
__inline static void fallbackSimpleSort(UInt32 *fmap , UInt32 *eclass , Int32 lo ,
                                        Int32 hi ) 
{ 
  Int32 i ;
  Int32 j ;
  Int32 tmp ;
  UInt32 ec_tmp ;

  {
#line 40
  if (lo == hi) {
#line 40
    return;
  }
#line 42
  if (hi - lo > 3) {
#line 43
    i = hi - 4;
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 43
      if (! (i >= lo)) {
#line 43
        goto while_break;
      }
#line 44
      tmp = (Int32 )*(fmap + i);
#line 45
      ec_tmp = *(eclass + tmp);
#line 46
      j = i + 4;
      {
#line 46
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 46
        if (j <= hi) {
#line 46
          if (! (ec_tmp > *(eclass + *(fmap + j)))) {
#line 46
            goto while_break___0;
          }
        } else {
#line 46
          goto while_break___0;
        }
#line 47
        *(fmap + (j - 4)) = *(fmap + j);
#line 46
        j += 4;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 48
      *(fmap + (j - 4)) = (UInt32 )tmp;
#line 43
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 52
  i = hi - 1;
  {
#line 52
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 52
    if (! (i >= lo)) {
#line 52
      goto while_break___1;
    }
#line 53
    tmp = (Int32 )*(fmap + i);
#line 54
    ec_tmp = *(eclass + tmp);
#line 55
    j = i + 1;
    {
#line 55
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 55
      if (j <= hi) {
#line 55
        if (! (ec_tmp > *(eclass + *(fmap + j)))) {
#line 55
          goto while_break___2;
        }
      } else {
#line 55
        goto while_break___2;
      }
#line 56
      *(fmap + (j - 1)) = *(fmap + j);
#line 55
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 57
    *(fmap + (j - 1)) = (UInt32 )tmp;
#line 52
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 59
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
static void fallbackQSort3(UInt32 *fmap , UInt32 *eclass , Int32 loSt , Int32 hiSt ) 
{ 
  Int32 unLo ;
  Int32 unHi ;
  Int32 ltLo ;
  Int32 gtHi ;
  Int32 n ;
  Int32 m ;
  Int32 sp ;
  Int32 lo ;
  Int32 hi ;
  UInt32 med ;
  UInt32 r ;
  UInt32 r3 ;
  Int32 stackLo[100] ;
  Int32 stackHi[100] ;
  Int32 zztmp ;
  Int32 zztmp___0 ;
  Int32 zztmp___1 ;
  Int32 yyp1 ;
  Int32 yyp2 ;
  Int32 yyn ;
  Int32 zztmp___2 ;
  Int32 yyp1___0 ;
  Int32 yyp2___0 ;
  Int32 yyn___0 ;
  Int32 zztmp___3 ;

  {
#line 104
  r = (UInt32 )0;
#line 106
  sp = 0;
#line 107
  stackLo[sp] = loSt;
#line 107
  stackHi[sp] = hiSt;
#line 107
  sp ++;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (sp > 0)) {
#line 109
      goto while_break;
    }
#line 111
    if (! (sp < 99)) {
      {
#line 111
      BZ2_bz__AssertH__fail(1004);
      }
    }
#line 113
    sp --;
#line 113
    lo = stackLo[sp];
#line 113
    hi = stackHi[sp];
#line 114
    if (hi - lo < 10) {
      {
#line 115
      fallbackSimpleSort(fmap, eclass, lo, hi);
      }
#line 116
      goto while_continue;
    }
#line 126
    r = (r * 7621U + 1U) % 32768U;
#line 127
    r3 = r % 3U;
#line 128
    if (r3 == 0U) {
#line 128
      med = *(eclass + *(fmap + lo));
    } else
#line 129
    if (r3 == 1U) {
#line 129
      med = *(eclass + *(fmap + ((lo + hi) >> 1)));
    } else {
#line 130
      med = *(eclass + *(fmap + hi));
    }
#line 132
    ltLo = lo;
#line 132
    unLo = ltLo;
#line 133
    gtHi = hi;
#line 133
    unHi = gtHi;
    {
#line 135
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 136
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 137
        if (unLo > unHi) {
#line 137
          goto while_break___1;
        }
#line 138
        n = (Int32 )*(eclass + *(fmap + unLo)) - (Int32 )med;
#line 139
        if (n == 0) {
#line 140
          zztmp = (Int32 )*(fmap + unLo);
#line 140
          *(fmap + unLo) = *(fmap + ltLo);
#line 140
          *(fmap + ltLo) = (UInt32 )zztmp;
#line 141
          ltLo ++;
#line 141
          unLo ++;
#line 142
          goto while_continue___1;
        }
#line 144
        if (n > 0) {
#line 144
          goto while_break___1;
        }
#line 145
        unLo ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 147
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 148
        if (unLo > unHi) {
#line 148
          goto while_break___2;
        }
#line 149
        n = (Int32 )*(eclass + *(fmap + unHi)) - (Int32 )med;
#line 150
        if (n == 0) {
#line 151
          zztmp___0 = (Int32 )*(fmap + unHi);
#line 151
          *(fmap + unHi) = *(fmap + gtHi);
#line 151
          *(fmap + gtHi) = (UInt32 )zztmp___0;
#line 152
          gtHi --;
#line 152
          unHi --;
#line 153
          goto while_continue___2;
        }
#line 155
        if (n < 0) {
#line 155
          goto while_break___2;
        }
#line 156
        unHi --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 158
      if (unLo > unHi) {
#line 158
        goto while_break___0;
      }
#line 159
      zztmp___1 = (Int32 )*(fmap + unLo);
#line 159
      *(fmap + unLo) = *(fmap + unHi);
#line 159
      *(fmap + unHi) = (UInt32 )zztmp___1;
#line 159
      unLo ++;
#line 159
      unHi --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 164
    if (gtHi < ltLo) {
#line 164
      goto while_continue;
    }
#line 166
    if (ltLo - lo < unLo - ltLo) {
#line 166
      n = ltLo - lo;
    } else {
#line 166
      n = unLo - ltLo;
    }
#line 166
    yyp1 = lo;
#line 166
    yyp2 = unLo - n;
#line 166
    yyn = n;
    {
#line 166
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 166
      if (! (yyn > 0)) {
#line 166
        goto while_break___3;
      }
#line 166
      zztmp___2 = (Int32 )*(fmap + yyp1);
#line 166
      *(fmap + yyp1) = *(fmap + yyp2);
#line 166
      *(fmap + yyp2) = (UInt32 )zztmp___2;
#line 166
      yyp1 ++;
#line 166
      yyp2 ++;
#line 166
      yyn --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 167
    if (hi - gtHi < gtHi - unHi) {
#line 167
      m = hi - gtHi;
    } else {
#line 167
      m = gtHi - unHi;
    }
#line 167
    yyp1___0 = unLo;
#line 167
    yyp2___0 = (hi - m) + 1;
#line 167
    yyn___0 = m;
    {
#line 167
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 167
      if (! (yyn___0 > 0)) {
#line 167
        goto while_break___4;
      }
#line 167
      zztmp___3 = (Int32 )*(fmap + yyp1___0);
#line 167
      *(fmap + yyp1___0) = *(fmap + yyp2___0);
#line 167
      *(fmap + yyp2___0) = (UInt32 )zztmp___3;
#line 167
      yyp1___0 ++;
#line 167
      yyp2___0 ++;
#line 167
      yyn___0 --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 169
    n = ((lo + unLo) - ltLo) - 1;
#line 170
    m = (hi - (gtHi - unHi)) + 1;
#line 172
    if (n - lo > hi - m) {
#line 173
      stackLo[sp] = lo;
#line 173
      stackHi[sp] = n;
#line 173
      sp ++;
#line 174
      stackLo[sp] = m;
#line 174
      stackHi[sp] = hi;
#line 174
      sp ++;
    } else {
#line 176
      stackLo[sp] = m;
#line 176
      stackHi[sp] = hi;
#line 176
      sp ++;
#line 177
      stackLo[sp] = lo;
#line 177
      stackHi[sp] = n;
#line 177
      sp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return;
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
static void fallbackSort(UInt32 *fmap , UInt32 *eclass , UInt32 *bhtab , Int32 nblock ,
                         Int32 verb ) 
{ 
  Int32 ftab[257] ;
  Int32 ftabCopy[256] ;
  Int32 H ;
  Int32 i ;
  Int32 j ;
  Int32 k ;
  Int32 l ;
  Int32 r ;
  Int32 cc ;
  Int32 cc1 ;
  Int32 nNotDone ;
  Int32 nBhtab ;
  UChar *eclass8 ;

  {
#line 223
  eclass8 = (UChar *)eclass;
#line 229
  if (verb >= 4) {
    {
#line 230
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        bucket sorting ...\n");
    }
  }
#line 231
  i = 0;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! (i < 257)) {
#line 231
      goto while_break;
    }
#line 231
    ftab[i] = 0;
#line 231
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  i = 0;
  {
#line 232
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 232
    if (! (i < nblock)) {
#line 232
      goto while_break___0;
    }
#line 232
    (ftab[*(eclass8 + i)]) ++;
#line 232
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 233
  i = 0;
  {
#line 233
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 233
    if (! (i < 256)) {
#line 233
      goto while_break___1;
    }
#line 233
    ftabCopy[i] = ftab[i];
#line 233
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 234
  i = 1;
  {
#line 234
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 234
    if (! (i < 257)) {
#line 234
      goto while_break___2;
    }
#line 234
    ftab[i] += ftab[i - 1];
#line 234
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 236
  i = 0;
  {
#line 236
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 236
    if (! (i < nblock)) {
#line 236
      goto while_break___3;
    }
#line 237
    j = (Int32 )*(eclass8 + i);
#line 238
    k = ftab[j] - 1;
#line 239
    ftab[j] = k;
#line 240
    *(fmap + k) = (UInt32 )i;
#line 236
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 243
  nBhtab = 2 + nblock / 32;
#line 244
  i = 0;
  {
#line 244
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 244
    if (! (i < nBhtab)) {
#line 244
      goto while_break___4;
    }
#line 244
    *(bhtab + i) = (UInt32 )0;
#line 244
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 245
  i = 0;
  {
#line 245
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 245
    if (! (i < 256)) {
#line 245
      goto while_break___5;
    }
#line 245
    *(bhtab + (ftab[i] >> 5)) |= (unsigned int )(1 << (ftab[i] & 31));
#line 245
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 254
  i = 0;
  {
#line 254
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 254
    if (! (i < 32)) {
#line 254
      goto while_break___6;
    }
#line 255
    *(bhtab + ((nblock + 2 * i) >> 5)) |= (unsigned int )(1 << ((nblock + 2 * i) & 31));
#line 256
    *(bhtab + (((nblock + 2 * i) + 1) >> 5)) &= (unsigned int )(~ (1 << (((nblock + 2 * i) + 1) & 31)));
#line 254
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 260
  H = 1;
  {
#line 261
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 263
    if (verb >= 4) {
      {
#line 264
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        depth %6d has ",
              H);
      }
    }
#line 266
    j = 0;
#line 267
    i = 0;
    {
#line 267
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 267
      if (! (i < nblock)) {
#line 267
        goto while_break___8;
      }
#line 268
      if (*(bhtab + (i >> 5)) & (unsigned int )(1 << (i & 31))) {
#line 268
        j = i;
      }
#line 269
      k = (Int32 )(*(fmap + i) - (UInt32 )H);
#line 269
      if (k < 0) {
#line 269
        k += nblock;
      }
#line 270
      *(eclass + k) = (UInt32 )j;
#line 267
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 273
    nNotDone = 0;
#line 274
    r = -1;
    {
#line 275
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 278
      k = r + 1;
      {
#line 279
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 279
        if (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31))) {
#line 279
          if (! (k & 31)) {
#line 279
            goto while_break___10;
          }
        } else {
#line 279
          goto while_break___10;
        }
#line 279
        k ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 280
      if (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31))) {
        {
#line 281
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 281
          if (! (*(bhtab + (k >> 5)) == 4294967295U)) {
#line 281
            goto while_break___11;
          }
#line 281
          k += 32;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 282
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 282
          if (! (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31)))) {
#line 282
            goto while_break___12;
          }
#line 282
          k ++;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
#line 284
      l = k - 1;
#line 285
      if (l >= nblock) {
#line 285
        goto while_break___9;
      }
      {
#line 286
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 286
        if (! (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31)))) {
#line 286
          if (! (k & 31)) {
#line 286
            goto while_break___13;
          }
        } else {
#line 286
          goto while_break___13;
        }
#line 286
        k ++;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 287
      if (! (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31)))) {
        {
#line 288
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 288
          if (! (*(bhtab + (k >> 5)) == 0U)) {
#line 288
            goto while_break___14;
          }
#line 288
          k += 32;
        }
        while_break___14: /* CIL Label */ ;
        }
        {
#line 289
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 289
          if (! (! (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31))))) {
#line 289
            goto while_break___15;
          }
#line 289
          k ++;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
#line 291
      r = k - 1;
#line 292
      if (r >= nblock) {
#line 292
        goto while_break___9;
      }
#line 295
      if (r > l) {
        {
#line 296
        nNotDone += (r - l) + 1;
#line 297
        fallbackQSort3(fmap, eclass, l, r);
#line 300
        cc = -1;
#line 301
        i = l;
        }
        {
#line 301
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 301
          if (! (i <= r)) {
#line 301
            goto while_break___16;
          }
#line 302
          cc1 = (Int32 )*(eclass + *(fmap + i));
#line 303
          if (cc != cc1) {
#line 303
            *(bhtab + (i >> 5)) |= (unsigned int )(1 << (i & 31));
#line 303
            cc = cc1;
          }
#line 301
          i ++;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
    }
    while_break___9: /* CIL Label */ ;
    }
#line 308
    if (verb >= 4) {
      {
#line 309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%6d unresolved strings\n",
              nNotDone);
      }
    }
#line 311
    H *= 2;
#line 312
    if (H > nblock) {
#line 312
      goto while_break___7;
    } else
#line 312
    if (nNotDone == 0) {
#line 312
      goto while_break___7;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 320
  if (verb >= 4) {
    {
#line 321
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        reconstructing block ...\n");
    }
  }
#line 322
  j = 0;
#line 323
  i = 0;
  {
#line 323
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 323
    if (! (i < nblock)) {
#line 323
      goto while_break___17;
    }
    {
#line 324
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 324
      if (! (ftabCopy[j] == 0)) {
#line 324
        goto while_break___18;
      }
#line 324
      j ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 325
    (ftabCopy[j]) --;
#line 326
    *(eclass8 + *(fmap + i)) = (UChar )j;
#line 323
    i ++;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 328
  if (! (j < 256)) {
    {
#line 328
    BZ2_bz__AssertH__fail(1005);
    }
  }
#line 329
  return;
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
__inline static Bool mainGtU(UInt32 i1 , UInt32 i2 , UChar *block , UInt16 *quadrant ,
                             UInt32 nblock , Int32 *budget ) 
{ 
  Int32 k ;
  UChar c1 ;
  UChar c2 ;
  UInt16 s1 ;
  UInt16 s2 ;

  {
#line 360
  c1 = *(block + i1);
#line 360
  c2 = *(block + i2);
#line 361
  if ((int )c1 != (int )c2) {
#line 361
    return ((Bool )((int )c1 > (int )c2));
  }
#line 362
  i1 ++;
#line 362
  i2 ++;
#line 364
  c1 = *(block + i1);
#line 364
  c2 = *(block + i2);
#line 365
  if ((int )c1 != (int )c2) {
#line 365
    return ((Bool )((int )c1 > (int )c2));
  }
#line 366
  i1 ++;
#line 366
  i2 ++;
#line 368
  c1 = *(block + i1);
#line 368
  c2 = *(block + i2);
#line 369
  if ((int )c1 != (int )c2) {
#line 369
    return ((Bool )((int )c1 > (int )c2));
  }
#line 370
  i1 ++;
#line 370
  i2 ++;
#line 372
  c1 = *(block + i1);
#line 372
  c2 = *(block + i2);
#line 373
  if ((int )c1 != (int )c2) {
#line 373
    return ((Bool )((int )c1 > (int )c2));
  }
#line 374
  i1 ++;
#line 374
  i2 ++;
#line 376
  c1 = *(block + i1);
#line 376
  c2 = *(block + i2);
#line 377
  if ((int )c1 != (int )c2) {
#line 377
    return ((Bool )((int )c1 > (int )c2));
  }
#line 378
  i1 ++;
#line 378
  i2 ++;
#line 380
  c1 = *(block + i1);
#line 380
  c2 = *(block + i2);
#line 381
  if ((int )c1 != (int )c2) {
#line 381
    return ((Bool )((int )c1 > (int )c2));
  }
#line 382
  i1 ++;
#line 382
  i2 ++;
#line 384
  c1 = *(block + i1);
#line 384
  c2 = *(block + i2);
#line 385
  if ((int )c1 != (int )c2) {
#line 385
    return ((Bool )((int )c1 > (int )c2));
  }
#line 386
  i1 ++;
#line 386
  i2 ++;
#line 388
  c1 = *(block + i1);
#line 388
  c2 = *(block + i2);
#line 389
  if ((int )c1 != (int )c2) {
#line 389
    return ((Bool )((int )c1 > (int )c2));
  }
#line 390
  i1 ++;
#line 390
  i2 ++;
#line 392
  c1 = *(block + i1);
#line 392
  c2 = *(block + i2);
#line 393
  if ((int )c1 != (int )c2) {
#line 393
    return ((Bool )((int )c1 > (int )c2));
  }
#line 394
  i1 ++;
#line 394
  i2 ++;
#line 396
  c1 = *(block + i1);
#line 396
  c2 = *(block + i2);
#line 397
  if ((int )c1 != (int )c2) {
#line 397
    return ((Bool )((int )c1 > (int )c2));
  }
#line 398
  i1 ++;
#line 398
  i2 ++;
#line 400
  c1 = *(block + i1);
#line 400
  c2 = *(block + i2);
#line 401
  if ((int )c1 != (int )c2) {
#line 401
    return ((Bool )((int )c1 > (int )c2));
  }
#line 402
  i1 ++;
#line 402
  i2 ++;
#line 404
  c1 = *(block + i1);
#line 404
  c2 = *(block + i2);
#line 405
  if ((int )c1 != (int )c2) {
#line 405
    return ((Bool )((int )c1 > (int )c2));
  }
#line 406
  i1 ++;
#line 406
  i2 ++;
#line 408
  k = (Int32 )(nblock + 8U);
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    c1 = *(block + i1);
#line 412
    c2 = *(block + i2);
#line 413
    if ((int )c1 != (int )c2) {
#line 413
      return ((Bool )((int )c1 > (int )c2));
    }
#line 414
    s1 = *(quadrant + i1);
#line 414
    s2 = *(quadrant + i2);
#line 415
    if ((int )s1 != (int )s2) {
#line 415
      return ((Bool )((int )s1 > (int )s2));
    }
#line 416
    i1 ++;
#line 416
    i2 ++;
#line 418
    c1 = *(block + i1);
#line 418
    c2 = *(block + i2);
#line 419
    if ((int )c1 != (int )c2) {
#line 419
      return ((Bool )((int )c1 > (int )c2));
    }
#line 420
    s1 = *(quadrant + i1);
#line 420
    s2 = *(quadrant + i2);
#line 421
    if ((int )s1 != (int )s2) {
#line 421
      return ((Bool )((int )s1 > (int )s2));
    }
#line 422
    i1 ++;
#line 422
    i2 ++;
#line 424
    c1 = *(block + i1);
#line 424
    c2 = *(block + i2);
#line 425
    if ((int )c1 != (int )c2) {
#line 425
      return ((Bool )((int )c1 > (int )c2));
    }
#line 426
    s1 = *(quadrant + i1);
#line 426
    s2 = *(quadrant + i2);
#line 427
    if ((int )s1 != (int )s2) {
#line 427
      return ((Bool )((int )s1 > (int )s2));
    }
#line 428
    i1 ++;
#line 428
    i2 ++;
#line 430
    c1 = *(block + i1);
#line 430
    c2 = *(block + i2);
#line 431
    if ((int )c1 != (int )c2) {
#line 431
      return ((Bool )((int )c1 > (int )c2));
    }
#line 432
    s1 = *(quadrant + i1);
#line 432
    s2 = *(quadrant + i2);
#line 433
    if ((int )s1 != (int )s2) {
#line 433
      return ((Bool )((int )s1 > (int )s2));
    }
#line 434
    i1 ++;
#line 434
    i2 ++;
#line 436
    c1 = *(block + i1);
#line 436
    c2 = *(block + i2);
#line 437
    if ((int )c1 != (int )c2) {
#line 437
      return ((Bool )((int )c1 > (int )c2));
    }
#line 438
    s1 = *(quadrant + i1);
#line 438
    s2 = *(quadrant + i2);
#line 439
    if ((int )s1 != (int )s2) {
#line 439
      return ((Bool )((int )s1 > (int )s2));
    }
#line 440
    i1 ++;
#line 440
    i2 ++;
#line 442
    c1 = *(block + i1);
#line 442
    c2 = *(block + i2);
#line 443
    if ((int )c1 != (int )c2) {
#line 443
      return ((Bool )((int )c1 > (int )c2));
    }
#line 444
    s1 = *(quadrant + i1);
#line 444
    s2 = *(quadrant + i2);
#line 445
    if ((int )s1 != (int )s2) {
#line 445
      return ((Bool )((int )s1 > (int )s2));
    }
#line 446
    i1 ++;
#line 446
    i2 ++;
#line 448
    c1 = *(block + i1);
#line 448
    c2 = *(block + i2);
#line 449
    if ((int )c1 != (int )c2) {
#line 449
      return ((Bool )((int )c1 > (int )c2));
    }
#line 450
    s1 = *(quadrant + i1);
#line 450
    s2 = *(quadrant + i2);
#line 451
    if ((int )s1 != (int )s2) {
#line 451
      return ((Bool )((int )s1 > (int )s2));
    }
#line 452
    i1 ++;
#line 452
    i2 ++;
#line 454
    c1 = *(block + i1);
#line 454
    c2 = *(block + i2);
#line 455
    if ((int )c1 != (int )c2) {
#line 455
      return ((Bool )((int )c1 > (int )c2));
    }
#line 456
    s1 = *(quadrant + i1);
#line 456
    s2 = *(quadrant + i2);
#line 457
    if ((int )s1 != (int )s2) {
#line 457
      return ((Bool )((int )s1 > (int )s2));
    }
#line 458
    i1 ++;
#line 458
    i2 ++;
#line 460
    if (i1 >= nblock) {
#line 460
      i1 -= nblock;
    }
#line 461
    if (i2 >= nblock) {
#line 461
      i2 -= nblock;
    }
#line 463
    k -= 8;
#line 464
    (*budget) --;
#line 410
    if (! (k >= 0)) {
#line 410
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return ((Bool )0);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
static Int32 incs[14]  = 
#line 479
  {      1,      4,      13,      40, 
        121,      364,      1093,      3280, 
        9841,      29524,      88573,      265720, 
        797161,      2391484};
#line 484 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
static void mainSimpleSort(UInt32 *ptr , UChar *block , UInt16 *quadrant , Int32 nblock ,
                           Int32 lo , Int32 hi , Int32 d , Int32 *budget ) 
{ 
  Int32 i ;
  Int32 j ;
  Int32 h ;
  Int32 bigN ;
  Int32 hp ;
  UInt32 v ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;

  {
#line 497
  bigN = (hi - lo) + 1;
#line 498
  if (bigN < 2) {
#line 498
    return;
  }
#line 500
  hp = 0;
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    if (! (incs[hp] < bigN)) {
#line 501
      goto while_break;
    }
#line 501
    hp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 502
  hp --;
  {
#line 504
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 504
    if (! (hp >= 0)) {
#line 504
      goto while_break___0;
    }
#line 505
    h = incs[hp];
#line 507
    i = lo + h;
    {
#line 508
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 511
      if (i > hi) {
#line 511
        goto while_break___1;
      }
#line 512
      v = *(ptr + i);
#line 513
      j = i;
      {
#line 514
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 514
        tmp = mainGtU(*(ptr + (j - h)) + (UInt32 )d, v + (UInt32 )d, block, quadrant,
                      (UInt32 )nblock, budget);
        }
#line 514
        if (! tmp) {
#line 514
          goto while_break___2;
        }
#line 517
        *(ptr + j) = *(ptr + (j - h));
#line 518
        j -= h;
#line 519
        if (j <= (lo + h) - 1) {
#line 519
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 521
      *(ptr + j) = v;
#line 522
      i ++;
#line 525
      if (i > hi) {
#line 525
        goto while_break___1;
      }
#line 526
      v = *(ptr + i);
#line 527
      j = i;
      {
#line 528
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 528
        tmp___0 = mainGtU(*(ptr + (j - h)) + (UInt32 )d, v + (UInt32 )d, block, quadrant,
                          (UInt32 )nblock, budget);
        }
#line 528
        if (! tmp___0) {
#line 528
          goto while_break___3;
        }
#line 531
        *(ptr + j) = *(ptr + (j - h));
#line 532
        j -= h;
#line 533
        if (j <= (lo + h) - 1) {
#line 533
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 535
      *(ptr + j) = v;
#line 536
      i ++;
#line 539
      if (i > hi) {
#line 539
        goto while_break___1;
      }
#line 540
      v = *(ptr + i);
#line 541
      j = i;
      {
#line 542
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 542
        tmp___1 = mainGtU(*(ptr + (j - h)) + (UInt32 )d, v + (UInt32 )d, block, quadrant,
                          (UInt32 )nblock, budget);
        }
#line 542
        if (! tmp___1) {
#line 542
          goto while_break___4;
        }
#line 545
        *(ptr + j) = *(ptr + (j - h));
#line 546
        j -= h;
#line 547
        if (j <= (lo + h) - 1) {
#line 547
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 549
      *(ptr + j) = v;
#line 550
      i ++;
#line 552
      if (*budget < 0) {
#line 552
        return;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 504
    hp --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 555
  return;
}
}
#line 581 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
__inline static UChar mmed3(UChar a , UChar b , UChar c ) 
{ 
  UChar t ;

  {
#line 586
  if ((int )a > (int )b) {
#line 586
    t = a;
#line 586
    a = b;
#line 586
    b = t;
  }
#line 587
  if ((int )b > (int )c) {
#line 588
    b = c;
#line 589
    if ((int )a > (int )b) {
#line 589
      b = a;
    }
  }
#line 591
  return (b);
}
}
#line 620 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
static void mainQSort3(UInt32 *ptr , UChar *block , UInt16 *quadrant , Int32 nblock ,
                       Int32 loSt , Int32 hiSt , Int32 dSt , Int32 *budget ) 
{ 
  Int32 unLo ;
  Int32 unHi ;
  Int32 ltLo ;
  Int32 gtHi ;
  Int32 n ;
  Int32 m ;
  Int32 med ;
  Int32 sp ;
  Int32 lo ;
  Int32 hi ;
  Int32 d ;
  Int32 stackLo[100] ;
  Int32 stackHi[100] ;
  Int32 stackD[100] ;
  Int32 nextLo[3] ;
  Int32 nextHi[3] ;
  Int32 nextD[3] ;
  UChar tmp ;
  Int32 zztmp ;
  Int32 zztmp___0 ;
  Int32 zztmp___1 ;
  Int32 yyp1 ;
  Int32 yyp2 ;
  Int32 yyn ;
  Int32 zztmp___2 ;
  Int32 yyp1___0 ;
  Int32 yyp2___0 ;
  Int32 yyn___0 ;
  Int32 zztmp___3 ;
  Int32 tz ;
  Int32 tz___0 ;
  Int32 tz___1 ;

  {
#line 641
  sp = 0;
#line 642
  stackLo[sp] = loSt;
#line 642
  stackHi[sp] = hiSt;
#line 642
  stackD[sp] = dSt;
#line 642
  sp ++;
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    if (! (sp > 0)) {
#line 644
      goto while_break;
    }
#line 646
    if (! (sp < 98)) {
      {
#line 646
      BZ2_bz__AssertH__fail(1001);
      }
    }
#line 648
    sp --;
#line 648
    lo = stackLo[sp];
#line 648
    hi = stackHi[sp];
#line 648
    d = stackD[sp];
#line 649
    if (hi - lo < 20) {
#line 649
      goto _L;
    } else
#line 649
    if (d > 14) {
      _L: /* CIL Label */ 
      {
#line 651
      mainSimpleSort(ptr, block, quadrant, nblock, lo, hi, d, budget);
      }
#line 652
      if (*budget < 0) {
#line 652
        return;
      }
#line 653
      goto while_continue;
    }
    {
#line 656
    tmp = mmed3(*(block + (*(ptr + lo) + (UInt32 )d)), *(block + (*(ptr + hi) + (UInt32 )d)),
                *(block + (*(ptr + ((lo + hi) >> 1)) + (UInt32 )d)));
#line 656
    med = (Int32 )tmp;
#line 661
    ltLo = lo;
#line 661
    unLo = ltLo;
#line 662
    gtHi = hi;
#line 662
    unHi = gtHi;
    }
    {
#line 664
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 665
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 666
        if (unLo > unHi) {
#line 666
          goto while_break___1;
        }
#line 667
        n = (Int32 )*(block + (*(ptr + unLo) + (UInt32 )d)) - med;
#line 668
        if (n == 0) {
#line 669
          zztmp = (Int32 )*(ptr + unLo);
#line 669
          *(ptr + unLo) = *(ptr + ltLo);
#line 669
          *(ptr + ltLo) = (UInt32 )zztmp;
#line 670
          ltLo ++;
#line 670
          unLo ++;
#line 670
          goto while_continue___1;
        }
#line 672
        if (n > 0) {
#line 672
          goto while_break___1;
        }
#line 673
        unLo ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 675
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 676
        if (unLo > unHi) {
#line 676
          goto while_break___2;
        }
#line 677
        n = (Int32 )*(block + (*(ptr + unHi) + (UInt32 )d)) - med;
#line 678
        if (n == 0) {
#line 679
          zztmp___0 = (Int32 )*(ptr + unHi);
#line 679
          *(ptr + unHi) = *(ptr + gtHi);
#line 679
          *(ptr + gtHi) = (UInt32 )zztmp___0;
#line 680
          gtHi --;
#line 680
          unHi --;
#line 680
          goto while_continue___2;
        }
#line 682
        if (n < 0) {
#line 682
          goto while_break___2;
        }
#line 683
        unHi --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 685
      if (unLo > unHi) {
#line 685
        goto while_break___0;
      }
#line 686
      zztmp___1 = (Int32 )*(ptr + unLo);
#line 686
      *(ptr + unLo) = *(ptr + unHi);
#line 686
      *(ptr + unHi) = (UInt32 )zztmp___1;
#line 686
      unLo ++;
#line 686
      unHi --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 691
    if (gtHi < ltLo) {
#line 692
      stackLo[sp] = lo;
#line 692
      stackHi[sp] = hi;
#line 692
      stackD[sp] = d + 1;
#line 692
      sp ++;
#line 693
      goto while_continue;
    }
#line 696
    if (ltLo - lo < unLo - ltLo) {
#line 696
      n = ltLo - lo;
    } else {
#line 696
      n = unLo - ltLo;
    }
#line 696
    yyp1 = lo;
#line 696
    yyp2 = unLo - n;
#line 696
    yyn = n;
    {
#line 696
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 696
      if (! (yyn > 0)) {
#line 696
        goto while_break___3;
      }
#line 696
      zztmp___2 = (Int32 )*(ptr + yyp1);
#line 696
      *(ptr + yyp1) = *(ptr + yyp2);
#line 696
      *(ptr + yyp2) = (UInt32 )zztmp___2;
#line 696
      yyp1 ++;
#line 696
      yyp2 ++;
#line 696
      yyn --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 697
    if (hi - gtHi < gtHi - unHi) {
#line 697
      m = hi - gtHi;
    } else {
#line 697
      m = gtHi - unHi;
    }
#line 697
    yyp1___0 = unLo;
#line 697
    yyp2___0 = (hi - m) + 1;
#line 697
    yyn___0 = m;
    {
#line 697
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 697
      if (! (yyn___0 > 0)) {
#line 697
        goto while_break___4;
      }
#line 697
      zztmp___3 = (Int32 )*(ptr + yyp1___0);
#line 697
      *(ptr + yyp1___0) = *(ptr + yyp2___0);
#line 697
      *(ptr + yyp2___0) = (UInt32 )zztmp___3;
#line 697
      yyp1___0 ++;
#line 697
      yyp2___0 ++;
#line 697
      yyn___0 --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 699
    n = ((lo + unLo) - ltLo) - 1;
#line 700
    m = (hi - (gtHi - unHi)) + 1;
#line 702
    nextLo[0] = lo;
#line 702
    nextHi[0] = n;
#line 702
    nextD[0] = d;
#line 703
    nextLo[1] = m;
#line 703
    nextHi[1] = hi;
#line 703
    nextD[1] = d;
#line 704
    nextLo[2] = n + 1;
#line 704
    nextHi[2] = m - 1;
#line 704
    nextD[2] = d + 1;
#line 706
    if (nextHi[0] - nextLo[0] < nextHi[1] - nextLo[1]) {
#line 706
      tz = nextLo[0];
#line 706
      nextLo[0] = nextLo[1];
#line 706
      nextLo[1] = tz;
#line 706
      tz = nextHi[0];
#line 706
      nextHi[0] = nextHi[1];
#line 706
      nextHi[1] = tz;
#line 706
      tz = nextD[0];
#line 706
      nextD[0] = nextD[1];
#line 706
      nextD[1] = tz;
    }
#line 707
    if (nextHi[1] - nextLo[1] < nextHi[2] - nextLo[2]) {
#line 707
      tz___0 = nextLo[1];
#line 707
      nextLo[1] = nextLo[2];
#line 707
      nextLo[2] = tz___0;
#line 707
      tz___0 = nextHi[1];
#line 707
      nextHi[1] = nextHi[2];
#line 707
      nextHi[2] = tz___0;
#line 707
      tz___0 = nextD[1];
#line 707
      nextD[1] = nextD[2];
#line 707
      nextD[2] = tz___0;
    }
#line 708
    if (nextHi[0] - nextLo[0] < nextHi[1] - nextLo[1]) {
#line 708
      tz___1 = nextLo[0];
#line 708
      nextLo[0] = nextLo[1];
#line 708
      nextLo[1] = tz___1;
#line 708
      tz___1 = nextHi[0];
#line 708
      nextHi[0] = nextHi[1];
#line 708
      nextHi[1] = tz___1;
#line 708
      tz___1 = nextD[0];
#line 708
      nextD[0] = nextD[1];
#line 708
      nextD[1] = tz___1;
    }
#line 713
    stackLo[sp] = nextLo[0];
#line 713
    stackHi[sp] = nextHi[0];
#line 713
    stackD[sp] = nextD[0];
#line 713
    sp ++;
#line 714
    stackLo[sp] = nextLo[1];
#line 714
    stackHi[sp] = nextHi[1];
#line 714
    stackD[sp] = nextD[1];
#line 714
    sp ++;
#line 715
    stackLo[sp] = nextLo[2];
#line 715
    stackHi[sp] = nextHi[2];
#line 715
    stackD[sp] = nextD[2];
#line 715
    sp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 717
  return;
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
static void mainSort(UInt32 *ptr , UChar *block , UInt16 *quadrant , UInt32 *ftab ,
                     Int32 nblock , Int32 verb , Int32 *budget ) 
{ 
  Int32 i ;
  Int32 j ;
  Int32 k ;
  Int32 ss ;
  Int32 sb ;
  Int32 runningOrder[256] ;
  Bool bigDone[256] ;
  Int32 copyStart[256] ;
  Int32 copyEnd[256] ;
  UChar c1 ;
  Int32 numQSorted ;
  UInt16 s ;
  Int32 vv ;
  Int32 h ;
  Int32 lo ;
  Int32 hi ;
  Int32 tmp ;
  Int32 tmp___0 ;
  Int32 bbStart ;
  Int32 bbSize ;
  Int32 shifts ;
  Int32 a2update ;
  UInt16 qVal ;

  {
#line 767
  if (verb >= 4) {
    {
#line 767
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        main sort initialise ...\n");
    }
  }
#line 770
  i = 65536;
  {
#line 770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 770
    if (! (i >= 0)) {
#line 770
      goto while_break;
    }
#line 770
    *(ftab + i) = (UInt32 )0;
#line 770
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 772
  j = (int )*(block + 0) << 8;
#line 773
  i = nblock - 1;
  {
#line 774
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 774
    if (! (i >= 3)) {
#line 774
      goto while_break___0;
    }
#line 775
    *(quadrant + i) = (UInt16 )0;
#line 776
    j = (j >> 8) | ((int )((UInt16 )*(block + i)) << 8);
#line 777
    (*(ftab + j)) ++;
#line 778
    *(quadrant + (i - 1)) = (UInt16 )0;
#line 779
    j = (j >> 8) | ((int )((UInt16 )*(block + (i - 1))) << 8);
#line 780
    (*(ftab + j)) ++;
#line 781
    *(quadrant + (i - 2)) = (UInt16 )0;
#line 782
    j = (j >> 8) | ((int )((UInt16 )*(block + (i - 2))) << 8);
#line 783
    (*(ftab + j)) ++;
#line 784
    *(quadrant + (i - 3)) = (UInt16 )0;
#line 785
    j = (j >> 8) | ((int )((UInt16 )*(block + (i - 3))) << 8);
#line 786
    (*(ftab + j)) ++;
#line 774
    i -= 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 788
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 788
    if (! (i >= 0)) {
#line 788
      goto while_break___1;
    }
#line 789
    *(quadrant + i) = (UInt16 )0;
#line 790
    j = (j >> 8) | ((int )((UInt16 )*(block + i)) << 8);
#line 791
    (*(ftab + j)) ++;
#line 788
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 795
  i = 0;
  {
#line 795
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 795
    if (! (i < 34)) {
#line 795
      goto while_break___2;
    }
#line 796
    *(block + (nblock + i)) = *(block + i);
#line 797
    *(quadrant + (nblock + i)) = (UInt16 )0;
#line 795
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 800
  if (verb >= 4) {
    {
#line 800
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        bucket sorting ...\n");
    }
  }
#line 803
  i = 1;
  {
#line 803
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 803
    if (! (i <= 65536)) {
#line 803
      goto while_break___3;
    }
#line 803
    *(ftab + i) += *(ftab + (i - 1));
#line 803
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 805
  s = (UInt16 )((int )*(block + 0) << 8);
#line 806
  i = nblock - 1;
  {
#line 807
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 807
    if (! (i >= 3)) {
#line 807
      goto while_break___4;
    }
#line 808
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + i) << 8));
#line 809
    j = (Int32 )(*(ftab + s) - 1U);
#line 810
    *(ftab + s) = (UInt32 )j;
#line 811
    *(ptr + j) = (UInt32 )i;
#line 812
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + (i - 1)) << 8));
#line 813
    j = (Int32 )(*(ftab + s) - 1U);
#line 814
    *(ftab + s) = (UInt32 )j;
#line 815
    *(ptr + j) = (UInt32 )(i - 1);
#line 816
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + (i - 2)) << 8));
#line 817
    j = (Int32 )(*(ftab + s) - 1U);
#line 818
    *(ftab + s) = (UInt32 )j;
#line 819
    *(ptr + j) = (UInt32 )(i - 2);
#line 820
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + (i - 3)) << 8));
#line 821
    j = (Int32 )(*(ftab + s) - 1U);
#line 822
    *(ftab + s) = (UInt32 )j;
#line 823
    *(ptr + j) = (UInt32 )(i - 3);
#line 807
    i -= 4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 825
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 825
    if (! (i >= 0)) {
#line 825
      goto while_break___5;
    }
#line 826
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + i) << 8));
#line 827
    j = (Int32 )(*(ftab + s) - 1U);
#line 828
    *(ftab + s) = (UInt32 )j;
#line 829
    *(ptr + j) = (UInt32 )i;
#line 825
    i --;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 837
  i = 0;
  {
#line 837
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 837
    if (! (i <= 255)) {
#line 837
      goto while_break___6;
    }
#line 838
    bigDone[i] = (Bool )0;
#line 839
    runningOrder[i] = i;
#line 837
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 844
  h = 1;
  {
#line 845
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 845
    h = 3 * h + 1;
#line 845
    if (! (h <= 256)) {
#line 845
      goto while_break___7;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 846
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 847
    h /= 3;
#line 848
    i = h;
    {
#line 848
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 848
      if (! (i <= 255)) {
#line 848
        goto while_break___9;
      }
#line 849
      vv = runningOrder[i];
#line 850
      j = i;
      {
#line 851
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 851
        if (! (*(ftab + ((runningOrder[j - h] + 1) << 8)) - *(ftab + (runningOrder[j - h] << 8)) > *(ftab + ((vv + 1) << 8)) - *(ftab + (vv << 8)))) {
#line 851
          goto while_break___10;
        }
#line 852
        runningOrder[j] = runningOrder[j - h];
#line 853
        j -= h;
#line 854
        if (j <= h - 1) {
#line 854
          goto zero;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      zero: 
#line 857
      runningOrder[j] = vv;
#line 848
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 846
    if (! (h != 1)) {
#line 846
      goto while_break___8;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 866
  numQSorted = 0;
#line 868
  i = 0;
  {
#line 868
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 868
    if (! (i <= 255)) {
#line 868
      goto while_break___11;
    }
#line 876
    ss = runningOrder[i];
#line 886
    j = 0;
    {
#line 886
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 886
      if (! (j <= 255)) {
#line 886
        goto while_break___12;
      }
#line 887
      if (j != ss) {
#line 888
        sb = (ss << 8) + j;
#line 889
        if (! (*(ftab + sb) & (unsigned int )(1 << 21))) {
#line 890
          lo = (Int32 )(*(ftab + sb) & (unsigned int )(~ (1 << 21)));
#line 891
          hi = (Int32 )((*(ftab + (sb + 1)) & (unsigned int )(~ (1 << 21))) - 1U);
#line 892
          if (hi > lo) {
#line 893
            if (verb >= 4) {
              {
#line 894
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        qsort [0x%x, 0x%x]   done %d   this %d\n",
                      ss, j, numQSorted, (hi - lo) + 1);
              }
            }
            {
#line 897
            mainQSort3(ptr, block, quadrant, nblock, lo, hi, 2, budget);
#line 901
            numQSorted += (hi - lo) + 1;
            }
#line 902
            if (*budget < 0) {
#line 902
              return;
            }
          }
        }
#line 905
        *(ftab + sb) |= (unsigned int )(1 << 21);
      }
#line 886
      j ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 909
    if (! (! bigDone[ss])) {
      {
#line 909
      BZ2_bz__AssertH__fail(1006);
      }
    }
#line 919
    j = 0;
    {
#line 919
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 919
      if (! (j <= 255)) {
#line 919
        goto while_break___13;
      }
#line 920
      copyStart[j] = (Int32 )(*(ftab + ((j << 8) + ss)) & (unsigned int )(~ (1 << 21)));
#line 921
      copyEnd[j] = (Int32 )((*(ftab + (((j << 8) + ss) + 1)) & (unsigned int )(~ (1 << 21))) - 1U);
#line 919
      j ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 923
    j = (Int32 )(*(ftab + (ss << 8)) & (unsigned int )(~ (1 << 21)));
    {
#line 923
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 923
      if (! (j < copyStart[ss])) {
#line 923
        goto while_break___14;
      }
#line 924
      k = (Int32 )(*(ptr + j) - 1U);
#line 924
      if (k < 0) {
#line 924
        k += nblock;
      }
#line 925
      c1 = *(block + k);
#line 926
      if (! bigDone[c1]) {
#line 927
        tmp = copyStart[c1];
#line 927
        (copyStart[c1]) ++;
#line 927
        *(ptr + tmp) = (UInt32 )k;
      }
#line 923
      j ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 929
    j = (Int32 )((*(ftab + ((ss + 1) << 8)) & (unsigned int )(~ (1 << 21))) - 1U);
    {
#line 929
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 929
      if (! (j > copyEnd[ss])) {
#line 929
        goto while_break___15;
      }
#line 930
      k = (Int32 )(*(ptr + j) - 1U);
#line 930
      if (k < 0) {
#line 930
        k += nblock;
      }
#line 931
      c1 = *(block + k);
#line 932
      if (! bigDone[c1]) {
#line 933
        tmp___0 = copyEnd[c1];
#line 933
        (copyEnd[c1]) --;
#line 933
        *(ptr + tmp___0) = (UInt32 )k;
      }
#line 929
      j --;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 937
    if (! (copyStart[ss] - 1 == copyEnd[ss])) {
#line 937
      if (copyStart[ss] == 0) {
#line 937
        if (! (copyEnd[ss] == nblock - 1)) {
          {
#line 937
          BZ2_bz__AssertH__fail(1007);
          }
        }
      } else {
        {
#line 937
        BZ2_bz__AssertH__fail(1007);
        }
      }
    }
#line 946
    j = 0;
    {
#line 946
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 946
      if (! (j <= 255)) {
#line 946
        goto while_break___16;
      }
#line 946
      *(ftab + ((j << 8) + ss)) |= (unsigned int )(1 << 21);
#line 946
      j ++;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 987
    bigDone[ss] = (Bool )1;
#line 989
    if (i < 255) {
#line 990
      bbStart = (Int32 )(*(ftab + (ss << 8)) & (unsigned int )(~ (1 << 21)));
#line 991
      bbSize = (Int32 )((*(ftab + ((ss + 1) << 8)) & (unsigned int )(~ (1 << 21))) - (unsigned int )bbStart);
#line 992
      shifts = 0;
      {
#line 994
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 994
        if (! (bbSize >> shifts > 65534)) {
#line 994
          goto while_break___17;
        }
#line 994
        shifts ++;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 996
      j = bbSize - 1;
      {
#line 996
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 996
        if (! (j >= 0)) {
#line 996
          goto while_break___18;
        }
#line 997
        a2update = (Int32 )*(ptr + (bbStart + j));
#line 998
        qVal = (UInt16 )(j >> shifts);
#line 999
        *(quadrant + a2update) = qVal;
#line 1000
        if (a2update < 34) {
#line 1001
          *(quadrant + (a2update + nblock)) = qVal;
        }
#line 996
        j --;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 1003
      if (! ((bbSize - 1) >> shifts <= 65535)) {
        {
#line 1003
        BZ2_bz__AssertH__fail(1002);
        }
      }
    }
#line 868
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1008
  if (verb >= 4) {
    {
#line 1009
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        %d pointers, %d sorted, %d scanned\n",
            nblock, numQSorted, nblock - numQSorted);
    }
  }
#line 1011
  return;
}
}
#line 1031 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
void BZ2_blockSort(EState *s ) 
{ 
  UInt32 *ptr ;
  UChar *block ;
  UInt32 *ftab ;
  Int32 nblock ;
  Int32 verb ;
  Int32 wfact ;
  UInt16 *quadrant ;
  Int32 budget ;
  Int32 budgetInit ;
  Int32 i ;
  int tmp ;

  {
#line 1033
  ptr = s->ptr;
#line 1034
  block = s->block;
#line 1035
  ftab = s->ftab;
#line 1036
  nblock = s->nblock;
#line 1037
  verb = s->verbosity;
#line 1038
  wfact = s->workFactor;
#line 1044
  if (nblock < 10000) {
    {
#line 1045
    fallbackSort(s->arr1, s->arr2, ftab, nblock, verb);
    }
  } else {
#line 1052
    i = nblock + 34;
#line 1053
    if (i & 1) {
#line 1053
      i ++;
    }
#line 1054
    quadrant = (UInt16 *)(block + i);
#line 1063
    if (wfact < 1) {
#line 1063
      wfact = 1;
    }
#line 1064
    if (wfact > 100) {
#line 1064
      wfact = 100;
    }
    {
#line 1065
    budgetInit = nblock * ((wfact - 1) / 3);
#line 1066
    budget = budgetInit;
#line 1068
    mainSort(ptr, block, quadrant, ftab, nblock, verb, & budget);
    }
#line 1069
    if (verb >= 3) {
#line 1070
      if (nblock == 0) {
#line 1070
        tmp = 1;
      } else {
#line 1070
        tmp = nblock;
      }
      {
#line 1070
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      %d work, %d block, ratio %5.2f\n",
              budgetInit - budget, nblock, (double )((float )(budgetInit - budget) / (float )tmp));
      }
    }
#line 1075
    if (budget < 0) {
#line 1076
      if (verb >= 2) {
        {
#line 1077
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    too repetitive; using fallback sorting algorithm\n");
        }
      }
      {
#line 1079
      fallbackSort(s->arr1, s->arr2, ftab, nblock, verb);
      }
    }
  }
#line 1083
  s->origPtr = -1;
#line 1084
  i = 0;
  {
#line 1084
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1084
    if (! (i < s->nblock)) {
#line 1084
      goto while_break;
    }
#line 1085
    if (*(ptr + i) == 0U) {
#line 1086
      s->origPtr = i;
#line 1086
      goto while_break;
    }
#line 1084
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1088
  if (! (s->origPtr != -1)) {
    {
#line 1088
    BZ2_bz__AssertH__fail(1003);
    }
  }
#line 1089
  return;
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib_private.h"
void BZ2_hbCreateDecodeTables(Int32 *limit , Int32 *base , Int32 *perm , UChar *length ,
                              Int32 minLen , Int32 maxLen , Int32 alphaSize ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/huffman.c"
void BZ2_hbMakeCodeLengths(UChar *len , Int32 *freq , Int32 alphaSize , Int32 maxLen ) 
{ 
  Int32 nNodes ;
  Int32 nHeap ;
  Int32 n1 ;
  Int32 n2 ;
  Int32 i ;
  Int32 j ;
  Int32 k ;
  Bool tooLong ;
  Int32 heap[260] ;
  Int32 weight[516] ;
  Int32 parent[516] ;
  int tmp ;
  Int32 zz ;
  Int32 tmp___0 ;
  Int32 zz___0 ;
  Int32 yy ;
  Int32 tmp___1 ;
  Int32 zz___1 ;
  Int32 yy___0 ;
  Int32 tmp___2 ;
  Int32 tmp___3 ;
  int tmp___4 ;
  Int32 zz___2 ;
  Int32 tmp___5 ;

  {
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < alphaSize)) {
#line 79
      goto while_break;
    }
#line 80
    if (*(freq + i) == 0) {
#line 80
      tmp = 1;
    } else {
#line 80
      tmp = *(freq + i);
    }
#line 80
    weight[i + 1] = tmp << 8;
#line 79
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 82
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    nNodes = alphaSize;
#line 85
    nHeap = 0;
#line 87
    heap[0] = 0;
#line 88
    weight[0] = 0;
#line 89
    parent[0] = -2;
#line 91
    i = 1;
    {
#line 91
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 91
      if (! (i <= alphaSize)) {
#line 91
        goto while_break___1;
      }
#line 92
      parent[i] = -1;
#line 93
      nHeap ++;
#line 94
      heap[nHeap] = i;
#line 95
      zz = nHeap;
#line 95
      tmp___0 = heap[zz];
      {
#line 95
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 95
        if (! (weight[tmp___0] < weight[heap[zz >> 1]])) {
#line 95
          goto while_break___2;
        }
#line 95
        heap[zz] = heap[zz >> 1];
#line 95
        zz >>= 1;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 95
      heap[zz] = tmp___0;
#line 91
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 98
    if (! (nHeap < 260)) {
      {
#line 98
      BZ2_bz__AssertH__fail(2001);
      }
    }
    {
#line 100
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 100
      if (! (nHeap > 1)) {
#line 100
        goto while_break___3;
      }
#line 101
      n1 = heap[1];
#line 101
      heap[1] = heap[nHeap];
#line 101
      nHeap --;
#line 101
      zz___0 = 1;
#line 101
      tmp___1 = heap[zz___0];
      {
#line 101
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 101
        yy = zz___0 << 1;
#line 101
        if (yy > nHeap) {
#line 101
          goto while_break___4;
        }
#line 101
        if (yy < nHeap) {
#line 101
          if (weight[heap[yy + 1]] < weight[heap[yy]]) {
#line 101
            yy ++;
          }
        }
#line 101
        if (weight[tmp___1] < weight[heap[yy]]) {
#line 101
          goto while_break___4;
        }
#line 101
        heap[zz___0] = heap[yy];
#line 101
        zz___0 = yy;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 101
      heap[zz___0] = tmp___1;
#line 102
      n2 = heap[1];
#line 102
      heap[1] = heap[nHeap];
#line 102
      nHeap --;
#line 102
      zz___1 = 1;
#line 102
      tmp___2 = heap[zz___1];
      {
#line 102
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 102
        yy___0 = zz___1 << 1;
#line 102
        if (yy___0 > nHeap) {
#line 102
          goto while_break___5;
        }
#line 102
        if (yy___0 < nHeap) {
#line 102
          if (weight[heap[yy___0 + 1]] < weight[heap[yy___0]]) {
#line 102
            yy___0 ++;
          }
        }
#line 102
        if (weight[tmp___2] < weight[heap[yy___0]]) {
#line 102
          goto while_break___5;
        }
#line 102
        heap[zz___1] = heap[yy___0];
#line 102
        zz___1 = yy___0;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 102
      heap[zz___1] = tmp___2;
#line 103
      nNodes ++;
#line 104
      tmp___3 = nNodes;
#line 104
      parent[n2] = tmp___3;
#line 104
      parent[n1] = tmp___3;
#line 105
      if ((weight[n1] & 255) > (weight[n2] & 255)) {
#line 105
        tmp___4 = weight[n1] & 255;
      } else {
#line 105
        tmp___4 = weight[n2] & 255;
      }
#line 105
      weight[nNodes] = (Int32 )((((unsigned int )weight[n1] & 4294967040U) + ((unsigned int )weight[n2] & 4294967040U)) | (unsigned int )(1 + tmp___4));
#line 106
      parent[nNodes] = -1;
#line 107
      nHeap ++;
#line 108
      heap[nHeap] = nNodes;
#line 109
      zz___2 = nHeap;
#line 109
      tmp___5 = heap[zz___2];
      {
#line 109
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 109
        if (! (weight[tmp___5] < weight[heap[zz___2 >> 1]])) {
#line 109
          goto while_break___6;
        }
#line 109
        heap[zz___2] = heap[zz___2 >> 1];
#line 109
        zz___2 >>= 1;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 109
      heap[zz___2] = tmp___5;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 112
    if (! (nNodes < 516)) {
      {
#line 112
      BZ2_bz__AssertH__fail(2002);
      }
    }
#line 114
    tooLong = (Bool )0;
#line 115
    i = 1;
    {
#line 115
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 115
      if (! (i <= alphaSize)) {
#line 115
        goto while_break___7;
      }
#line 116
      j = 0;
#line 117
      k = i;
      {
#line 118
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 118
        if (! (parent[k] >= 0)) {
#line 118
          goto while_break___8;
        }
#line 118
        k = parent[k];
#line 118
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 119
      *(len + (i - 1)) = (UChar )j;
#line 120
      if (j > maxLen) {
#line 120
        tooLong = (Bool )1;
      }
#line 115
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 123
    if (! tooLong) {
#line 123
      goto while_break___0;
    }
#line 142
    i = 1;
    {
#line 142
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 142
      if (! (i <= alphaSize)) {
#line 142
        goto while_break___9;
      }
#line 143
      j = weight[i] >> 8;
#line 144
      j = 1 + j / 2;
#line 145
      weight[i] = j << 8;
#line 142
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/huffman.c"
void BZ2_hbAssignCodes(Int32 *code , UChar *length , Int32 minLen , Int32 maxLen ,
                       Int32 alphaSize ) 
{ 
  Int32 n ;
  Int32 vec ;
  Int32 i ;

  {
#line 160
  vec = 0;
#line 161
  n = minLen;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (n <= maxLen)) {
#line 161
      goto while_break;
    }
#line 162
    i = 0;
    {
#line 162
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 162
      if (! (i < alphaSize)) {
#line 162
        goto while_break___0;
      }
#line 163
      if ((int )*(length + i) == n) {
#line 163
        *(code + i) = vec;
#line 163
        vec ++;
      }
#line 162
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 164
    vec <<= 1;
#line 161
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/huffman.c"
void BZ2_hbCreateDecodeTables(Int32 *limit , Int32 *base , Int32 *perm , UChar *length ,
                              Int32 minLen , Int32 maxLen , Int32 alphaSize ) 
{ 
  Int32 pp ;
  Int32 i ;
  Int32 j ;
  Int32 vec ;

  {
#line 180
  pp = 0;
#line 181
  i = minLen;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (i <= maxLen)) {
#line 181
      goto while_break;
    }
#line 182
    j = 0;
    {
#line 182
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 182
      if (! (j < alphaSize)) {
#line 182
        goto while_break___0;
      }
#line 183
      if ((int )*(length + j) == i) {
#line 183
        *(perm + pp) = j;
#line 183
        pp ++;
      }
#line 182
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 181
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  i = 0;
  {
#line 185
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 185
    if (! (i < 23)) {
#line 185
      goto while_break___1;
    }
#line 185
    *(base + i) = 0;
#line 185
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 186
  i = 0;
  {
#line 186
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 186
    if (! (i < alphaSize)) {
#line 186
      goto while_break___2;
    }
#line 186
    (*(base + ((int )*(length + i) + 1))) ++;
#line 186
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 188
  i = 1;
  {
#line 188
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 188
    if (! (i < 23)) {
#line 188
      goto while_break___3;
    }
#line 188
    *(base + i) += *(base + (i - 1));
#line 188
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 190
  i = 0;
  {
#line 190
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 190
    if (! (i < 23)) {
#line 190
      goto while_break___4;
    }
#line 190
    *(limit + i) = 0;
#line 190
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 191
  vec = 0;
#line 193
  i = minLen;
  {
#line 193
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 193
    if (! (i <= maxLen)) {
#line 193
      goto while_break___5;
    }
#line 194
    vec += *(base + (i + 1)) - *(base + i);
#line 195
    *(limit + i) = vec - 1;
#line 196
    vec <<= 1;
#line 193
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 198
  i = minLen + 1;
  {
#line 198
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 198
    if (! (i <= maxLen)) {
#line 198
      goto while_break___6;
    }
#line 199
    *(base + i) = ((*(limit + (i - 1)) + 1) << 1) - *(base + i);
#line 198
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 200
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/decompress.c"
static void makeMaps_d(DState *s ) 
{ 
  Int32 i ;

  {
#line 30
  s->nInUse = 0;
#line 31
  i = 0;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i < 256)) {
#line 31
      goto while_break;
    }
#line 32
    if (s->inUse[i]) {
#line 33
      s->seqToUnseq[s->nInUse] = (UChar )i;
#line 34
      (s->nInUse) ++;
    }
#line 31
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 36
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/decompress.c"
Int32 BZ2_decompress(DState *s ) 
{ 
  UChar uc ;
  Int32 retVal ;
  Int32 minLen ;
  Int32 maxLen ;
  bz_stream *strm ;
  Int32 i ;
  Int32 j ;
  Int32 t ;
  Int32 alphaSize ;
  Int32 nGroups ;
  Int32 nSelectors ;
  Int32 EOB ;
  Int32 groupNo ;
  Int32 groupPos ;
  Int32 nextSym ;
  Int32 nblockMAX ;
  Int32 nblock ;
  Int32 es ;
  Int32 N ;
  Int32 curr ;
  Int32 zt ;
  Int32 zn ;
  Int32 zvec ;
  Int32 zj ;
  Int32 gSel ;
  Int32 gMinlen ;
  Int32 *gLimit ;
  Int32 *gBase ;
  Int32 *gPerm ;
  UInt32 v ;
  UInt32 v___0 ;
  UInt32 v___1 ;
  UInt32 v___2 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  UInt32 v___3 ;
  UInt32 v___4 ;
  UInt32 v___5 ;
  UInt32 v___6 ;
  UInt32 v___7 ;
  UInt32 v___8 ;
  UInt32 v___9 ;
  UInt32 v___10 ;
  UInt32 v___11 ;
  UInt32 v___12 ;
  UInt32 v___13 ;
  UInt32 v___14 ;
  UInt32 v___15 ;
  UInt32 v___16 ;
  UInt32 v___17 ;
  UInt32 v___18 ;
  UInt32 v___19 ;
  UInt32 v___20 ;
  UInt32 v___21 ;
  UChar pos[6] ;
  UChar tmp___2 ;
  UChar v___22 ;
  UInt32 v___23 ;
  UInt32 v___24 ;
  UInt32 v___25 ;
  Int32 ii ;
  Int32 jj ;
  Int32 kk ;
  UInt32 v___26 ;
  UInt32 v___27 ;
  UInt32 v___28 ;
  UInt32 v___29 ;
  Int32 ii___0 ;
  Int32 jj___0 ;
  Int32 kk___0 ;
  Int32 pp ;
  Int32 lno ;
  Int32 off ;
  UInt32 nn ;
  Int32 z ;
  UInt32 v___30 ;
  UInt32 v___31 ;
  Int32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  UInt32 v___32 ;
  UInt32 v___33 ;
  UInt32 v___34 ;
  UInt32 v___35 ;
  UInt32 v___36 ;
  UInt32 v___37 ;
  UInt32 v___38 ;
  UInt32 v___39 ;
  UInt32 v___40 ;

  {
#line 111
  strm = s->strm;
#line 139
  if (s->state == 10) {
#line 141
    s->save_i = 0;
#line 142
    s->save_j = 0;
#line 143
    s->save_t = 0;
#line 144
    s->save_alphaSize = 0;
#line 145
    s->save_nGroups = 0;
#line 146
    s->save_nSelectors = 0;
#line 147
    s->save_EOB = 0;
#line 148
    s->save_groupNo = 0;
#line 149
    s->save_groupPos = 0;
#line 150
    s->save_nextSym = 0;
#line 151
    s->save_nblockMAX = 0;
#line 152
    s->save_nblock = 0;
#line 153
    s->save_es = 0;
#line 154
    s->save_N = 0;
#line 155
    s->save_curr = 0;
#line 156
    s->save_zt = 0;
#line 157
    s->save_zn = 0;
#line 158
    s->save_zvec = 0;
#line 159
    s->save_zj = 0;
#line 160
    s->save_gSel = 0;
#line 161
    s->save_gMinlen = 0;
#line 162
    s->save_gLimit = (Int32 *)((void *)0);
#line 163
    s->save_gBase = (Int32 *)((void *)0);
#line 164
    s->save_gPerm = (Int32 *)((void *)0);
  }
#line 168
  i = s->save_i;
#line 169
  j = s->save_j;
#line 170
  t = s->save_t;
#line 171
  alphaSize = s->save_alphaSize;
#line 172
  nGroups = s->save_nGroups;
#line 173
  nSelectors = s->save_nSelectors;
#line 174
  EOB = s->save_EOB;
#line 175
  groupNo = s->save_groupNo;
#line 176
  groupPos = s->save_groupPos;
#line 177
  nextSym = s->save_nextSym;
#line 178
  nblockMAX = s->save_nblockMAX;
#line 179
  nblock = s->save_nblock;
#line 180
  es = s->save_es;
#line 181
  N = s->save_N;
#line 182
  curr = s->save_curr;
#line 183
  zt = s->save_zt;
#line 184
  zn = s->save_zn;
#line 185
  zvec = s->save_zvec;
#line 186
  zj = s->save_zj;
#line 187
  gSel = s->save_gSel;
#line 188
  gMinlen = s->save_gMinlen;
#line 189
  gLimit = s->save_gLimit;
#line 190
  gBase = s->save_gBase;
#line 191
  gPerm = s->save_gPerm;
#line 193
  retVal = 0;
  {
#line 197
  if (s->state == 10) {
#line 197
    goto case_10;
  }
#line 200
  if (s->state == 11) {
#line 200
    goto case_11;
  }
#line 203
  if (s->state == 12) {
#line 203
    goto case_12;
  }
#line 206
  if (s->state == 13) {
#line 206
    goto case_13;
  }
#line 222
  if (s->state == 14) {
#line 222
    goto case_14;
  }
#line 226
  if (s->state == 15) {
#line 226
    goto case_15;
  }
#line 228
  if (s->state == 16) {
#line 228
    goto case_16;
  }
#line 230
  if (s->state == 17) {
#line 230
    goto case_17;
  }
#line 232
  if (s->state == 18) {
#line 232
    goto case_18;
  }
#line 234
  if (s->state == 19) {
#line 234
    goto case_19;
  }
#line 242
  if (s->state == 20) {
#line 242
    goto case_20;
  }
#line 244
  if (s->state == 21) {
#line 244
    goto case_21;
  }
#line 246
  if (s->state == 22) {
#line 246
    goto case_22;
  }
#line 248
  if (s->state == 23) {
#line 248
    goto case_23;
  }
#line 251
  if (s->state == 24) {
#line 251
    goto case_24;
  }
#line 254
  if (s->state == 25) {
#line 254
    goto case_25;
  }
#line 256
  if (s->state == 26) {
#line 256
    goto case_26;
  }
#line 258
  if (s->state == 27) {
#line 258
    goto case_27;
  }
#line 268
  if (s->state == 28) {
#line 268
    goto case_28;
  }
#line 279
  if (s->state == 29) {
#line 279
    goto case_29;
  }
#line 287
  if (s->state == 30) {
#line 287
    goto case_30;
  }
#line 289
  if (s->state == 31) {
#line 289
    goto case_31;
  }
#line 294
  if (s->state == 32) {
#line 294
    goto case_32;
  }
#line 318
  if (s->state == 33) {
#line 318
    goto case_33;
  }
#line 322
  if (s->state == 34) {
#line 322
    goto case_34;
  }
#line 324
  if (s->state == 35) {
#line 324
    goto case_35;
  }
#line 373
  if (s->state == 36) {
#line 373
    goto case_36;
  }
#line 373
  if (s->state == 37) {
#line 373
    goto case_37;
  }
#line 394
  if (s->state == 38) {
#line 394
    goto case_38;
  }
#line 394
  if (s->state == 39) {
#line 394
    goto case_39;
  }
#line 483
  if (s->state == 40) {
#line 483
    goto case_40;
  }
#line 483
  if (s->state == 41) {
#line 483
    goto case_41;
  }
#line 584
  if (s->state == 42) {
#line 584
    goto endhdr_2;
  }
#line 586
  if (s->state == 43) {
#line 586
    goto case_43;
  }
#line 588
  if (s->state == 44) {
#line 588
    goto case_44;
  }
#line 590
  if (s->state == 45) {
#line 590
    goto case_45;
  }
#line 592
  if (s->state == 46) {
#line 592
    goto case_46;
  }
#line 596
  if (s->state == 47) {
#line 596
    goto case_47;
  }
#line 598
  if (s->state == 48) {
#line 598
    goto case_48;
  }
#line 600
  if (s->state == 49) {
#line 600
    goto case_49;
  }
#line 602
  if (s->state == 50) {
#line 602
    goto case_50;
  }
#line 608
  goto switch_default;
  case_10: /* CIL Label */ 
#line 197
  s->state = 10;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (s->bsLive >= 8) {
#line 197
      v = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 197
      s->bsLive -= 8;
#line 197
      uc = (UChar )v;
#line 197
      goto while_break;
    }
#line 197
    if ((s->strm)->avail_in == 0U) {
#line 197
      retVal = 0;
#line 197
      goto save_state_and_return;
    }
#line 197
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 197
    s->bsLive += 8;
#line 197
    ((s->strm)->next_in) ++;
#line 197
    ((s->strm)->avail_in) --;
#line 197
    ((s->strm)->total_in_lo32) ++;
#line 197
    if ((s->strm)->total_in_lo32 == 0U) {
#line 197
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  if ((int )uc != 66) {
#line 198
    retVal = -5;
#line 198
    goto save_state_and_return;
  }
  case_11: /* CIL Label */ 
#line 200
  s->state = 11;
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 200
    if (s->bsLive >= 8) {
#line 200
      v___0 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 200
      s->bsLive -= 8;
#line 200
      uc = (UChar )v___0;
#line 200
      goto while_break___0;
    }
#line 200
    if ((s->strm)->avail_in == 0U) {
#line 200
      retVal = 0;
#line 200
      goto save_state_and_return;
    }
#line 200
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 200
    s->bsLive += 8;
#line 200
    ((s->strm)->next_in) ++;
#line 200
    ((s->strm)->avail_in) --;
#line 200
    ((s->strm)->total_in_lo32) ++;
#line 200
    if ((s->strm)->total_in_lo32 == 0U) {
#line 200
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 201
  if ((int )uc != 90) {
#line 201
    retVal = -5;
#line 201
    goto save_state_and_return;
  }
  case_12: /* CIL Label */ 
#line 203
  s->state = 12;
  {
#line 203
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 203
    if (s->bsLive >= 8) {
#line 203
      v___1 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 203
      s->bsLive -= 8;
#line 203
      uc = (UChar )v___1;
#line 203
      goto while_break___1;
    }
#line 203
    if ((s->strm)->avail_in == 0U) {
#line 203
      retVal = 0;
#line 203
      goto save_state_and_return;
    }
#line 203
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 203
    s->bsLive += 8;
#line 203
    ((s->strm)->next_in) ++;
#line 203
    ((s->strm)->avail_in) --;
#line 203
    ((s->strm)->total_in_lo32) ++;
#line 203
    if ((s->strm)->total_in_lo32 == 0U) {
#line 203
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 204
  if ((int )uc != 104) {
#line 204
    retVal = -5;
#line 204
    goto save_state_and_return;
  }
  case_13: /* CIL Label */ 
#line 206
  s->state = 13;
  {
#line 206
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 206
    if (s->bsLive >= 8) {
#line 206
      v___2 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 206
      s->bsLive -= 8;
#line 206
      s->blockSize100k = (Int32 )v___2;
#line 206
      goto while_break___2;
    }
#line 206
    if ((s->strm)->avail_in == 0U) {
#line 206
      retVal = 0;
#line 206
      goto save_state_and_return;
    }
#line 206
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 206
    s->bsLive += 8;
#line 206
    ((s->strm)->next_in) ++;
#line 206
    ((s->strm)->avail_in) --;
#line 206
    ((s->strm)->total_in_lo32) ++;
#line 206
    if ((s->strm)->total_in_lo32 == 0U) {
#line 206
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 207
  if (s->blockSize100k < 49) {
#line 208
    retVal = -5;
#line 208
    goto save_state_and_return;
  } else
#line 207
  if (s->blockSize100k > 57) {
#line 208
    retVal = -5;
#line 208
    goto save_state_and_return;
  }
#line 209
  s->blockSize100k -= 48;
#line 211
  if (s->smallDecompress) {
    {
#line 212
    tmp = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )(s->blockSize100k * 100000) * sizeof(UInt16 )),
                             1);
#line 212
    s->ll16 = (UInt16 *)tmp;
#line 213
    tmp___0 = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar )),
                                 1);
#line 213
    s->ll4 = (UChar *)tmp___0;
    }
#line 216
    if ((unsigned long )s->ll16 == (unsigned long )((void *)0)) {
#line 216
      retVal = -3;
#line 216
      goto save_state_and_return;
    } else
#line 216
    if ((unsigned long )s->ll4 == (unsigned long )((void *)0)) {
#line 216
      retVal = -3;
#line 216
      goto save_state_and_return;
    }
  } else {
    {
#line 218
    tmp___1 = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )(s->blockSize100k * 100000) * sizeof(Int32 )),
                                 1);
#line 218
    s->tt = (UInt32 *)tmp___1;
    }
#line 219
    if ((unsigned long )s->tt == (unsigned long )((void *)0)) {
#line 219
      retVal = -3;
#line 219
      goto save_state_and_return;
    }
  }
  case_14: /* CIL Label */ 
#line 222
  s->state = 14;
  {
#line 222
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 222
    if (s->bsLive >= 8) {
#line 222
      v___3 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 222
      s->bsLive -= 8;
#line 222
      uc = (UChar )v___3;
#line 222
      goto while_break___3;
    }
#line 222
    if ((s->strm)->avail_in == 0U) {
#line 222
      retVal = 0;
#line 222
      goto save_state_and_return;
    }
#line 222
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 222
    s->bsLive += 8;
#line 222
    ((s->strm)->next_in) ++;
#line 222
    ((s->strm)->avail_in) --;
#line 222
    ((s->strm)->total_in_lo32) ++;
#line 222
    if ((s->strm)->total_in_lo32 == 0U) {
#line 222
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 224
  if ((int )uc == 23) {
#line 224
    goto endhdr_2;
  }
#line 225
  if ((int )uc != 49) {
#line 225
    retVal = -4;
#line 225
    goto save_state_and_return;
  }
  case_15: /* CIL Label */ 
#line 226
  s->state = 15;
  {
#line 226
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 226
    if (s->bsLive >= 8) {
#line 226
      v___4 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 226
      s->bsLive -= 8;
#line 226
      uc = (UChar )v___4;
#line 226
      goto while_break___4;
    }
#line 226
    if ((s->strm)->avail_in == 0U) {
#line 226
      retVal = 0;
#line 226
      goto save_state_and_return;
    }
#line 226
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 226
    s->bsLive += 8;
#line 226
    ((s->strm)->next_in) ++;
#line 226
    ((s->strm)->avail_in) --;
#line 226
    ((s->strm)->total_in_lo32) ++;
#line 226
    if ((s->strm)->total_in_lo32 == 0U) {
#line 226
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 227
  if ((int )uc != 65) {
#line 227
    retVal = -4;
#line 227
    goto save_state_and_return;
  }
  case_16: /* CIL Label */ 
#line 228
  s->state = 16;
  {
#line 228
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 228
    if (s->bsLive >= 8) {
#line 228
      v___5 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 228
      s->bsLive -= 8;
#line 228
      uc = (UChar )v___5;
#line 228
      goto while_break___5;
    }
#line 228
    if ((s->strm)->avail_in == 0U) {
#line 228
      retVal = 0;
#line 228
      goto save_state_and_return;
    }
#line 228
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 228
    s->bsLive += 8;
#line 228
    ((s->strm)->next_in) ++;
#line 228
    ((s->strm)->avail_in) --;
#line 228
    ((s->strm)->total_in_lo32) ++;
#line 228
    if ((s->strm)->total_in_lo32 == 0U) {
#line 228
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 229
  if ((int )uc != 89) {
#line 229
    retVal = -4;
#line 229
    goto save_state_and_return;
  }
  case_17: /* CIL Label */ 
#line 230
  s->state = 17;
  {
#line 230
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 230
    if (s->bsLive >= 8) {
#line 230
      v___6 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 230
      s->bsLive -= 8;
#line 230
      uc = (UChar )v___6;
#line 230
      goto while_break___6;
    }
#line 230
    if ((s->strm)->avail_in == 0U) {
#line 230
      retVal = 0;
#line 230
      goto save_state_and_return;
    }
#line 230
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 230
    s->bsLive += 8;
#line 230
    ((s->strm)->next_in) ++;
#line 230
    ((s->strm)->avail_in) --;
#line 230
    ((s->strm)->total_in_lo32) ++;
#line 230
    if ((s->strm)->total_in_lo32 == 0U) {
#line 230
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 231
  if ((int )uc != 38) {
#line 231
    retVal = -4;
#line 231
    goto save_state_and_return;
  }
  case_18: /* CIL Label */ 
#line 232
  s->state = 18;
  {
#line 232
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 232
    if (s->bsLive >= 8) {
#line 232
      v___7 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 232
      s->bsLive -= 8;
#line 232
      uc = (UChar )v___7;
#line 232
      goto while_break___7;
    }
#line 232
    if ((s->strm)->avail_in == 0U) {
#line 232
      retVal = 0;
#line 232
      goto save_state_and_return;
    }
#line 232
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 232
    s->bsLive += 8;
#line 232
    ((s->strm)->next_in) ++;
#line 232
    ((s->strm)->avail_in) --;
#line 232
    ((s->strm)->total_in_lo32) ++;
#line 232
    if ((s->strm)->total_in_lo32 == 0U) {
#line 232
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 233
  if ((int )uc != 83) {
#line 233
    retVal = -4;
#line 233
    goto save_state_and_return;
  }
  case_19: /* CIL Label */ 
#line 234
  s->state = 19;
  {
#line 234
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 234
    if (s->bsLive >= 8) {
#line 234
      v___8 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 234
      s->bsLive -= 8;
#line 234
      uc = (UChar )v___8;
#line 234
      goto while_break___8;
    }
#line 234
    if ((s->strm)->avail_in == 0U) {
#line 234
      retVal = 0;
#line 234
      goto save_state_and_return;
    }
#line 234
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 234
    s->bsLive += 8;
#line 234
    ((s->strm)->next_in) ++;
#line 234
    ((s->strm)->avail_in) --;
#line 234
    ((s->strm)->total_in_lo32) ++;
#line 234
    if ((s->strm)->total_in_lo32 == 0U) {
#line 234
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 235
  if ((int )uc != 89) {
#line 235
    retVal = -4;
#line 235
    goto save_state_and_return;
  }
#line 237
  (s->currBlockNo) ++;
#line 238
  if (s->verbosity >= 2) {
    {
#line 239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n    [%d: huff+mtf ",
            s->currBlockNo);
    }
  }
#line 241
  s->storedBlockCRC = (UInt32 )0;
  case_20: /* CIL Label */ 
#line 242
  s->state = 20;
  {
#line 242
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 242
    if (s->bsLive >= 8) {
#line 242
      v___9 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 242
      s->bsLive -= 8;
#line 242
      uc = (UChar )v___9;
#line 242
      goto while_break___9;
    }
#line 242
    if ((s->strm)->avail_in == 0U) {
#line 242
      retVal = 0;
#line 242
      goto save_state_and_return;
    }
#line 242
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 242
    s->bsLive += 8;
#line 242
    ((s->strm)->next_in) ++;
#line 242
    ((s->strm)->avail_in) --;
#line 242
    ((s->strm)->total_in_lo32) ++;
#line 242
    if ((s->strm)->total_in_lo32 == 0U) {
#line 242
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 243
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case_21: /* CIL Label */ 
#line 244
  s->state = 21;
  {
#line 244
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 244
    if (s->bsLive >= 8) {
#line 244
      v___10 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 244
      s->bsLive -= 8;
#line 244
      uc = (UChar )v___10;
#line 244
      goto while_break___10;
    }
#line 244
    if ((s->strm)->avail_in == 0U) {
#line 244
      retVal = 0;
#line 244
      goto save_state_and_return;
    }
#line 244
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 244
    s->bsLive += 8;
#line 244
    ((s->strm)->next_in) ++;
#line 244
    ((s->strm)->avail_in) --;
#line 244
    ((s->strm)->total_in_lo32) ++;
#line 244
    if ((s->strm)->total_in_lo32 == 0U) {
#line 244
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 245
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case_22: /* CIL Label */ 
#line 246
  s->state = 22;
  {
#line 246
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 246
    if (s->bsLive >= 8) {
#line 246
      v___11 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 246
      s->bsLive -= 8;
#line 246
      uc = (UChar )v___11;
#line 246
      goto while_break___11;
    }
#line 246
    if ((s->strm)->avail_in == 0U) {
#line 246
      retVal = 0;
#line 246
      goto save_state_and_return;
    }
#line 246
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 246
    s->bsLive += 8;
#line 246
    ((s->strm)->next_in) ++;
#line 246
    ((s->strm)->avail_in) --;
#line 246
    ((s->strm)->total_in_lo32) ++;
#line 246
    if ((s->strm)->total_in_lo32 == 0U) {
#line 246
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
#line 247
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case_23: /* CIL Label */ 
#line 248
  s->state = 23;
  {
#line 248
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 248
    if (s->bsLive >= 8) {
#line 248
      v___12 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 248
      s->bsLive -= 8;
#line 248
      uc = (UChar )v___12;
#line 248
      goto while_break___12;
    }
#line 248
    if ((s->strm)->avail_in == 0U) {
#line 248
      retVal = 0;
#line 248
      goto save_state_and_return;
    }
#line 248
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 248
    s->bsLive += 8;
#line 248
    ((s->strm)->next_in) ++;
#line 248
    ((s->strm)->avail_in) --;
#line 248
    ((s->strm)->total_in_lo32) ++;
#line 248
    if ((s->strm)->total_in_lo32 == 0U) {
#line 248
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 249
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case_24: /* CIL Label */ 
#line 251
  s->state = 24;
  {
#line 251
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 251
    if (s->bsLive >= 1) {
#line 251
      v___13 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 251
      (s->bsLive) --;
#line 251
      s->blockRandomised = (Bool )v___13;
#line 251
      goto while_break___13;
    }
#line 251
    if ((s->strm)->avail_in == 0U) {
#line 251
      retVal = 0;
#line 251
      goto save_state_and_return;
    }
#line 251
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 251
    s->bsLive += 8;
#line 251
    ((s->strm)->next_in) ++;
#line 251
    ((s->strm)->avail_in) --;
#line 251
    ((s->strm)->total_in_lo32) ++;
#line 251
    if ((s->strm)->total_in_lo32 == 0U) {
#line 251
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
#line 253
  s->origPtr = 0;
  case_25: /* CIL Label */ 
#line 254
  s->state = 25;
  {
#line 254
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 254
    if (s->bsLive >= 8) {
#line 254
      v___14 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 254
      s->bsLive -= 8;
#line 254
      uc = (UChar )v___14;
#line 254
      goto while_break___14;
    }
#line 254
    if ((s->strm)->avail_in == 0U) {
#line 254
      retVal = 0;
#line 254
      goto save_state_and_return;
    }
#line 254
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 254
    s->bsLive += 8;
#line 254
    ((s->strm)->next_in) ++;
#line 254
    ((s->strm)->avail_in) --;
#line 254
    ((s->strm)->total_in_lo32) ++;
#line 254
    if ((s->strm)->total_in_lo32 == 0U) {
#line 254
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
#line 255
  s->origPtr = (s->origPtr << 8) | (Int32 )uc;
  case_26: /* CIL Label */ 
#line 256
  s->state = 26;
  {
#line 256
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 256
    if (s->bsLive >= 8) {
#line 256
      v___15 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 256
      s->bsLive -= 8;
#line 256
      uc = (UChar )v___15;
#line 256
      goto while_break___15;
    }
#line 256
    if ((s->strm)->avail_in == 0U) {
#line 256
      retVal = 0;
#line 256
      goto save_state_and_return;
    }
#line 256
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 256
    s->bsLive += 8;
#line 256
    ((s->strm)->next_in) ++;
#line 256
    ((s->strm)->avail_in) --;
#line 256
    ((s->strm)->total_in_lo32) ++;
#line 256
    if ((s->strm)->total_in_lo32 == 0U) {
#line 256
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___15: /* CIL Label */ ;
  }
#line 257
  s->origPtr = (s->origPtr << 8) | (Int32 )uc;
  case_27: /* CIL Label */ 
#line 258
  s->state = 27;
  {
#line 258
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 258
    if (s->bsLive >= 8) {
#line 258
      v___16 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 258
      s->bsLive -= 8;
#line 258
      uc = (UChar )v___16;
#line 258
      goto while_break___16;
    }
#line 258
    if ((s->strm)->avail_in == 0U) {
#line 258
      retVal = 0;
#line 258
      goto save_state_and_return;
    }
#line 258
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 258
    s->bsLive += 8;
#line 258
    ((s->strm)->next_in) ++;
#line 258
    ((s->strm)->avail_in) --;
#line 258
    ((s->strm)->total_in_lo32) ++;
#line 258
    if ((s->strm)->total_in_lo32 == 0U) {
#line 258
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 259
  s->origPtr = (s->origPtr << 8) | (Int32 )uc;
#line 261
  if (s->origPtr < 0) {
#line 262
    retVal = -4;
#line 262
    goto save_state_and_return;
  }
#line 263
  if (s->origPtr > 10 + 100000 * s->blockSize100k) {
#line 264
    retVal = -4;
#line 264
    goto save_state_and_return;
  }
#line 267
  i = 0;
  {
#line 267
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 267
    if (! (i < 16)) {
#line 267
      goto while_break___17;
    }
    case_28: /* CIL Label */ 
#line 268
    s->state = 28;
    {
#line 268
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 268
      if (s->bsLive >= 1) {
#line 268
        v___17 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 268
        (s->bsLive) --;
#line 268
        uc = (UChar )v___17;
#line 268
        goto while_break___18;
      }
#line 268
      if ((s->strm)->avail_in == 0U) {
#line 268
        retVal = 0;
#line 268
        goto save_state_and_return;
      }
#line 268
      s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 268
      s->bsLive += 8;
#line 268
      ((s->strm)->next_in) ++;
#line 268
      ((s->strm)->avail_in) --;
#line 268
      ((s->strm)->total_in_lo32) ++;
#line 268
      if ((s->strm)->total_in_lo32 == 0U) {
#line 268
        ((s->strm)->total_in_hi32) ++;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
#line 269
    if ((int )uc == 1) {
#line 270
      s->inUse16[i] = (Bool )1;
    } else {
#line 271
      s->inUse16[i] = (Bool )0;
    }
#line 267
    i ++;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 274
  i = 0;
  {
#line 274
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 274
    if (! (i < 256)) {
#line 274
      goto while_break___19;
    }
#line 274
    s->inUse[i] = (Bool )0;
#line 274
    i ++;
  }
  while_break___19: /* CIL Label */ ;
  }
#line 276
  i = 0;
  {
#line 276
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 276
    if (! (i < 16)) {
#line 276
      goto while_break___20;
    }
#line 277
    if (s->inUse16[i]) {
#line 278
      j = 0;
      {
#line 278
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 278
        if (! (j < 16)) {
#line 278
          goto while_break___21;
        }
        case_29: /* CIL Label */ 
#line 279
        s->state = 29;
        {
#line 279
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 279
          if (s->bsLive >= 1) {
#line 279
            v___18 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 279
            (s->bsLive) --;
#line 279
            uc = (UChar )v___18;
#line 279
            goto while_break___22;
          }
#line 279
          if ((s->strm)->avail_in == 0U) {
#line 279
            retVal = 0;
#line 279
            goto save_state_and_return;
          }
#line 279
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 279
          s->bsLive += 8;
#line 279
          ((s->strm)->next_in) ++;
#line 279
          ((s->strm)->avail_in) --;
#line 279
          ((s->strm)->total_in_lo32) ++;
#line 279
          if ((s->strm)->total_in_lo32 == 0U) {
#line 279
            ((s->strm)->total_in_hi32) ++;
          }
        }
        while_break___22: /* CIL Label */ ;
        }
#line 280
        if ((int )uc == 1) {
#line 280
          s->inUse[i * 16 + j] = (Bool )1;
        }
#line 278
        j ++;
      }
      while_break___21: /* CIL Label */ ;
      }
    }
#line 276
    i ++;
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 282
  makeMaps_d(s);
  }
#line 283
  if (s->nInUse == 0) {
#line 283
    retVal = -4;
#line 283
    goto save_state_and_return;
  }
#line 284
  alphaSize = s->nInUse + 2;
  case_30: /* CIL Label */ 
#line 287
  s->state = 30;
  {
#line 287
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 287
    if (s->bsLive >= 3) {
#line 287
      v___19 = (s->bsBuff >> (s->bsLive - 3)) & (unsigned int )((1 << 3) - 1);
#line 287
      s->bsLive -= 3;
#line 287
      nGroups = (Int32 )v___19;
#line 287
      goto while_break___23;
    }
#line 287
    if ((s->strm)->avail_in == 0U) {
#line 287
      retVal = 0;
#line 287
      goto save_state_and_return;
    }
#line 287
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 287
    s->bsLive += 8;
#line 287
    ((s->strm)->next_in) ++;
#line 287
    ((s->strm)->avail_in) --;
#line 287
    ((s->strm)->total_in_lo32) ++;
#line 287
    if ((s->strm)->total_in_lo32 == 0U) {
#line 287
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___23: /* CIL Label */ ;
  }
#line 288
  if (nGroups < 2) {
#line 288
    retVal = -4;
#line 288
    goto save_state_and_return;
  } else
#line 288
  if (nGroups > 6) {
#line 288
    retVal = -4;
#line 288
    goto save_state_and_return;
  }
  case_31: /* CIL Label */ 
#line 289
  s->state = 31;
  {
#line 289
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 289
    if (s->bsLive >= 15) {
#line 289
      v___20 = (s->bsBuff >> (s->bsLive - 15)) & (unsigned int )((1 << 15) - 1);
#line 289
      s->bsLive -= 15;
#line 289
      nSelectors = (Int32 )v___20;
#line 289
      goto while_break___24;
    }
#line 289
    if ((s->strm)->avail_in == 0U) {
#line 289
      retVal = 0;
#line 289
      goto save_state_and_return;
    }
#line 289
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 289
    s->bsLive += 8;
#line 289
    ((s->strm)->next_in) ++;
#line 289
    ((s->strm)->avail_in) --;
#line 289
    ((s->strm)->total_in_lo32) ++;
#line 289
    if ((s->strm)->total_in_lo32 == 0U) {
#line 289
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___24: /* CIL Label */ ;
  }
#line 290
  if (nSelectors < 1) {
#line 290
    retVal = -4;
#line 290
    goto save_state_and_return;
  }
#line 291
  i = 0;
  {
#line 291
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 291
    if (! (i < nSelectors)) {
#line 291
      goto while_break___25;
    }
#line 292
    j = 0;
    {
#line 293
    while (1) {
      while_continue___26: /* CIL Label */ ;
      case_32: /* CIL Label */ 
#line 294
      s->state = 32;
      {
#line 294
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 294
        if (s->bsLive >= 1) {
#line 294
          v___21 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 294
          (s->bsLive) --;
#line 294
          uc = (UChar )v___21;
#line 294
          goto while_break___27;
        }
#line 294
        if ((s->strm)->avail_in == 0U) {
#line 294
          retVal = 0;
#line 294
          goto save_state_and_return;
        }
#line 294
        s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 294
        s->bsLive += 8;
#line 294
        ((s->strm)->next_in) ++;
#line 294
        ((s->strm)->avail_in) --;
#line 294
        ((s->strm)->total_in_lo32) ++;
#line 294
        if ((s->strm)->total_in_lo32 == 0U) {
#line 294
          ((s->strm)->total_in_hi32) ++;
        }
      }
      while_break___27: /* CIL Label */ ;
      }
#line 295
      if ((int )uc == 0) {
#line 295
        goto while_break___26;
      }
#line 296
      j ++;
#line 297
      if (j >= nGroups) {
#line 297
        retVal = -4;
#line 297
        goto save_state_and_return;
      }
    }
    while_break___26: /* CIL Label */ ;
    }
#line 299
    s->selectorMtf[i] = (UChar )j;
#line 291
    i ++;
  }
  while_break___25: /* CIL Label */ ;
  }
#line 305
  v___22 = (UChar )0;
  {
#line 305
  while (1) {
    while_continue___28: /* CIL Label */ ;
#line 305
    if (! ((int )v___22 < nGroups)) {
#line 305
      goto while_break___28;
    }
#line 305
    pos[v___22] = v___22;
#line 305
    v___22 = (UChar )((int )v___22 + 1);
  }
  while_break___28: /* CIL Label */ ;
  }
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 307
    if (! (i < nSelectors)) {
#line 307
      goto while_break___29;
    }
#line 308
    v___22 = s->selectorMtf[i];
#line 309
    tmp___2 = pos[v___22];
    {
#line 310
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 310
      if (! ((int )v___22 > 0)) {
#line 310
        goto while_break___30;
      }
#line 310
      pos[v___22] = pos[(int )v___22 - 1];
#line 310
      v___22 = (UChar )((int )v___22 - 1);
    }
    while_break___30: /* CIL Label */ ;
    }
#line 311
    pos[0] = tmp___2;
#line 312
    s->selector[i] = tmp___2;
#line 307
    i ++;
  }
  while_break___29: /* CIL Label */ ;
  }
#line 317
  t = 0;
  {
#line 317
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 317
    if (! (t < nGroups)) {
#line 317
      goto while_break___31;
    }
    case_33: /* CIL Label */ 
#line 318
    s->state = 33;
    {
#line 318
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 318
      if (s->bsLive >= 5) {
#line 318
        v___23 = (s->bsBuff >> (s->bsLive - 5)) & (unsigned int )((1 << 5) - 1);
#line 318
        s->bsLive -= 5;
#line 318
        curr = (Int32 )v___23;
#line 318
        goto while_break___32;
      }
#line 318
      if ((s->strm)->avail_in == 0U) {
#line 318
        retVal = 0;
#line 318
        goto save_state_and_return;
      }
#line 318
      s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 318
      s->bsLive += 8;
#line 318
      ((s->strm)->next_in) ++;
#line 318
      ((s->strm)->avail_in) --;
#line 318
      ((s->strm)->total_in_lo32) ++;
#line 318
      if ((s->strm)->total_in_lo32 == 0U) {
#line 318
        ((s->strm)->total_in_hi32) ++;
      }
    }
    while_break___32: /* CIL Label */ ;
    }
#line 319
    i = 0;
    {
#line 319
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 319
      if (! (i < alphaSize)) {
#line 319
        goto while_break___33;
      }
      {
#line 320
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 321
        if (curr < 1) {
#line 321
          retVal = -4;
#line 321
          goto save_state_and_return;
        } else
#line 321
        if (curr > 20) {
#line 321
          retVal = -4;
#line 321
          goto save_state_and_return;
        }
        case_34: /* CIL Label */ 
#line 322
        s->state = 34;
        {
#line 322
        while (1) {
          while_continue___35: /* CIL Label */ ;
#line 322
          if (s->bsLive >= 1) {
#line 322
            v___24 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 322
            (s->bsLive) --;
#line 322
            uc = (UChar )v___24;
#line 322
            goto while_break___35;
          }
#line 322
          if ((s->strm)->avail_in == 0U) {
#line 322
            retVal = 0;
#line 322
            goto save_state_and_return;
          }
#line 322
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 322
          s->bsLive += 8;
#line 322
          ((s->strm)->next_in) ++;
#line 322
          ((s->strm)->avail_in) --;
#line 322
          ((s->strm)->total_in_lo32) ++;
#line 322
          if ((s->strm)->total_in_lo32 == 0U) {
#line 322
            ((s->strm)->total_in_hi32) ++;
          }
        }
        while_break___35: /* CIL Label */ ;
        }
#line 323
        if ((int )uc == 0) {
#line 323
          goto while_break___34;
        }
        case_35: /* CIL Label */ 
#line 324
        s->state = 35;
        {
#line 324
        while (1) {
          while_continue___36: /* CIL Label */ ;
#line 324
          if (s->bsLive >= 1) {
#line 324
            v___25 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 324
            (s->bsLive) --;
#line 324
            uc = (UChar )v___25;
#line 324
            goto while_break___36;
          }
#line 324
          if ((s->strm)->avail_in == 0U) {
#line 324
            retVal = 0;
#line 324
            goto save_state_and_return;
          }
#line 324
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 324
          s->bsLive += 8;
#line 324
          ((s->strm)->next_in) ++;
#line 324
          ((s->strm)->avail_in) --;
#line 324
          ((s->strm)->total_in_lo32) ++;
#line 324
          if ((s->strm)->total_in_lo32 == 0U) {
#line 324
            ((s->strm)->total_in_hi32) ++;
          }
        }
        while_break___36: /* CIL Label */ ;
        }
#line 325
        if ((int )uc == 0) {
#line 325
          curr ++;
        } else {
#line 325
          curr --;
        }
      }
      while_break___34: /* CIL Label */ ;
      }
#line 327
      s->len[t][i] = (UChar )curr;
#line 319
      i ++;
    }
    while_break___33: /* CIL Label */ ;
    }
#line 317
    t ++;
  }
  while_break___31: /* CIL Label */ ;
  }
#line 332
  t = 0;
  {
#line 332
  while (1) {
    while_continue___37: /* CIL Label */ ;
#line 332
    if (! (t < nGroups)) {
#line 332
      goto while_break___37;
    }
#line 333
    minLen = 32;
#line 334
    maxLen = 0;
#line 335
    i = 0;
    {
#line 335
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 335
      if (! (i < alphaSize)) {
#line 335
        goto while_break___38;
      }
#line 336
      if ((int )s->len[t][i] > maxLen) {
#line 336
        maxLen = (Int32 )s->len[t][i];
      }
#line 337
      if ((int )s->len[t][i] < minLen) {
#line 337
        minLen = (Int32 )s->len[t][i];
      }
#line 335
      i ++;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 339
    BZ2_hbCreateDecodeTables(& s->limit[t][0], & s->base[t][0], & s->perm[t][0], & s->len[t][0],
                             minLen, maxLen, alphaSize);
#line 346
    s->minLens[t] = minLen;
#line 332
    t ++;
    }
  }
  while_break___37: /* CIL Label */ ;
  }
#line 351
  EOB = s->nInUse + 1;
#line 352
  nblockMAX = 100000 * s->blockSize100k;
#line 353
  groupNo = -1;
#line 354
  groupPos = 0;
#line 356
  i = 0;
  {
#line 356
  while (1) {
    while_continue___39: /* CIL Label */ ;
#line 356
    if (! (i <= 255)) {
#line 356
      goto while_break___39;
    }
#line 356
    s->unzftab[i] = 0;
#line 356
    i ++;
  }
  while_break___39: /* CIL Label */ ;
  }
#line 361
  kk = 4095;
#line 362
  ii = 15;
  {
#line 362
  while (1) {
    while_continue___40: /* CIL Label */ ;
#line 362
    if (! (ii >= 0)) {
#line 362
      goto while_break___40;
    }
#line 363
    jj = 15;
    {
#line 363
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 363
      if (! (jj >= 0)) {
#line 363
        goto while_break___41;
      }
#line 364
      s->mtfa[kk] = (UChar )(ii * 16 + jj);
#line 365
      kk --;
#line 363
      jj --;
    }
    while_break___41: /* CIL Label */ ;
    }
#line 367
    s->mtfbase[ii] = kk + 1;
#line 362
    ii --;
  }
  while_break___40: /* CIL Label */ ;
  }
#line 372
  nblock = 0;
#line 373
  if (groupPos == 0) {
#line 373
    groupNo ++;
#line 373
    if (groupNo >= nSelectors) {
#line 373
      retVal = -4;
#line 373
      goto save_state_and_return;
    }
#line 373
    groupPos = 50;
#line 373
    gSel = (Int32 )s->selector[groupNo];
#line 373
    gMinlen = s->minLens[gSel];
#line 373
    gLimit = & s->limit[gSel][0];
#line 373
    gPerm = & s->perm[gSel][0];
#line 373
    gBase = & s->base[gSel][0];
  }
#line 373
  groupPos --;
#line 373
  zn = gMinlen;
  case_36: /* CIL Label */ 
#line 373
  s->state = 36;
  {
#line 373
  while (1) {
    while_continue___42: /* CIL Label */ ;
#line 373
    if (s->bsLive >= zn) {
#line 373
      v___26 = (s->bsBuff >> (s->bsLive - zn)) & (unsigned int )((1 << zn) - 1);
#line 373
      s->bsLive -= zn;
#line 373
      zvec = (Int32 )v___26;
#line 373
      goto while_break___42;
    }
#line 373
    if ((s->strm)->avail_in == 0U) {
#line 373
      retVal = 0;
#line 373
      goto save_state_and_return;
    }
#line 373
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 373
    s->bsLive += 8;
#line 373
    ((s->strm)->next_in) ++;
#line 373
    ((s->strm)->avail_in) --;
#line 373
    ((s->strm)->total_in_lo32) ++;
#line 373
    if ((s->strm)->total_in_lo32 == 0U) {
#line 373
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___42: /* CIL Label */ ;
  }
  {
#line 373
  while (1) {
    while_continue___43: /* CIL Label */ ;
#line 373
    if (zn > 20) {
#line 373
      retVal = -4;
#line 373
      goto save_state_and_return;
    }
#line 373
    if (zvec <= *(gLimit + zn)) {
#line 373
      goto while_break___43;
    }
#line 373
    zn ++;
    case_37: /* CIL Label */ 
#line 373
    s->state = 37;
    {
#line 373
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 373
      if (s->bsLive >= 1) {
#line 373
        v___27 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 373
        (s->bsLive) --;
#line 373
        zj = (Int32 )v___27;
#line 373
        goto while_break___44;
      }
#line 373
      if ((s->strm)->avail_in == 0U) {
#line 373
        retVal = 0;
#line 373
        goto save_state_and_return;
      }
#line 373
      s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 373
      s->bsLive += 8;
#line 373
      ((s->strm)->next_in) ++;
#line 373
      ((s->strm)->avail_in) --;
#line 373
      ((s->strm)->total_in_lo32) ++;
#line 373
      if ((s->strm)->total_in_lo32 == 0U) {
#line 373
        ((s->strm)->total_in_hi32) ++;
      }
    }
    while_break___44: /* CIL Label */ ;
    }
#line 373
    zvec = (zvec << 1) | zj;
  }
  while_break___43: /* CIL Label */ ;
  }
#line 373
  if (zvec - *(gBase + zn) < 0) {
#line 373
    retVal = -4;
#line 373
    goto save_state_and_return;
  } else
#line 373
  if (zvec - *(gBase + zn) >= 258) {
#line 373
    retVal = -4;
#line 373
    goto save_state_and_return;
  }
#line 373
  nextSym = *(gPerm + (zvec - *(gBase + zn)));
  {
#line 375
  while (1) {
    while_continue___45: /* CIL Label */ ;
#line 377
    if (nextSym == EOB) {
#line 377
      goto while_break___45;
    }
#line 379
    if (nextSym == 0) {
#line 379
      goto _L;
    } else
#line 379
    if (nextSym == 1) {
      _L: /* CIL Label */ 
#line 381
      es = -1;
#line 382
      N = 1;
      {
#line 383
      while (1) {
        while_continue___46: /* CIL Label */ ;
#line 390
        if (N >= 2097152) {
#line 390
          retVal = -4;
#line 390
          goto save_state_and_return;
        }
#line 391
        if (nextSym == 0) {
#line 391
          es += N;
        } else
#line 392
        if (nextSym == 1) {
#line 392
          es += 2 * N;
        }
#line 393
        N *= 2;
#line 394
        if (groupPos == 0) {
#line 394
          groupNo ++;
#line 394
          if (groupNo >= nSelectors) {
#line 394
            retVal = -4;
#line 394
            goto save_state_and_return;
          }
#line 394
          groupPos = 50;
#line 394
          gSel = (Int32 )s->selector[groupNo];
#line 394
          gMinlen = s->minLens[gSel];
#line 394
          gLimit = & s->limit[gSel][0];
#line 394
          gPerm = & s->perm[gSel][0];
#line 394
          gBase = & s->base[gSel][0];
        }
#line 394
        groupPos --;
#line 394
        zn = gMinlen;
        case_38: /* CIL Label */ 
#line 394
        s->state = 38;
        {
#line 394
        while (1) {
          while_continue___47: /* CIL Label */ ;
#line 394
          if (s->bsLive >= zn) {
#line 394
            v___28 = (s->bsBuff >> (s->bsLive - zn)) & (unsigned int )((1 << zn) - 1);
#line 394
            s->bsLive -= zn;
#line 394
            zvec = (Int32 )v___28;
#line 394
            goto while_break___47;
          }
#line 394
          if ((s->strm)->avail_in == 0U) {
#line 394
            retVal = 0;
#line 394
            goto save_state_and_return;
          }
#line 394
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 394
          s->bsLive += 8;
#line 394
          ((s->strm)->next_in) ++;
#line 394
          ((s->strm)->avail_in) --;
#line 394
          ((s->strm)->total_in_lo32) ++;
#line 394
          if ((s->strm)->total_in_lo32 == 0U) {
#line 394
            ((s->strm)->total_in_hi32) ++;
          }
        }
        while_break___47: /* CIL Label */ ;
        }
        {
#line 394
        while (1) {
          while_continue___48: /* CIL Label */ ;
#line 394
          if (zn > 20) {
#line 394
            retVal = -4;
#line 394
            goto save_state_and_return;
          }
#line 394
          if (zvec <= *(gLimit + zn)) {
#line 394
            goto while_break___48;
          }
#line 394
          zn ++;
          case_39: /* CIL Label */ 
#line 394
          s->state = 39;
          {
#line 394
          while (1) {
            while_continue___49: /* CIL Label */ ;
#line 394
            if (s->bsLive >= 1) {
#line 394
              v___29 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 394
              (s->bsLive) --;
#line 394
              zj = (Int32 )v___29;
#line 394
              goto while_break___49;
            }
#line 394
            if ((s->strm)->avail_in == 0U) {
#line 394
              retVal = 0;
#line 394
              goto save_state_and_return;
            }
#line 394
            s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 394
            s->bsLive += 8;
#line 394
            ((s->strm)->next_in) ++;
#line 394
            ((s->strm)->avail_in) --;
#line 394
            ((s->strm)->total_in_lo32) ++;
#line 394
            if ((s->strm)->total_in_lo32 == 0U) {
#line 394
              ((s->strm)->total_in_hi32) ++;
            }
          }
          while_break___49: /* CIL Label */ ;
          }
#line 394
          zvec = (zvec << 1) | zj;
        }
        while_break___48: /* CIL Label */ ;
        }
#line 394
        if (zvec - *(gBase + zn) < 0) {
#line 394
          retVal = -4;
#line 394
          goto save_state_and_return;
        } else
#line 394
        if (zvec - *(gBase + zn) >= 258) {
#line 394
          retVal = -4;
#line 394
          goto save_state_and_return;
        }
#line 394
        nextSym = *(gPerm + (zvec - *(gBase + zn)));
#line 383
        if (! (nextSym == 0)) {
#line 383
          if (! (nextSym == 1)) {
#line 383
            goto while_break___46;
          }
        }
      }
      while_break___46: /* CIL Label */ ;
      }
#line 398
      es ++;
#line 399
      uc = s->seqToUnseq[s->mtfa[s->mtfbase[0]]];
#line 400
      s->unzftab[uc] += es;
#line 402
      if (s->smallDecompress) {
        {
#line 403
        while (1) {
          while_continue___50: /* CIL Label */ ;
#line 403
          if (! (es > 0)) {
#line 403
            goto while_break___50;
          }
#line 404
          if (nblock >= nblockMAX) {
#line 404
            retVal = -4;
#line 404
            goto save_state_and_return;
          }
#line 405
          *(s->ll16 + nblock) = (UInt16 )uc;
#line 406
          nblock ++;
#line 407
          es --;
        }
        while_break___50: /* CIL Label */ ;
        }
      } else {
        {
#line 410
        while (1) {
          while_continue___51: /* CIL Label */ ;
#line 410
          if (! (es > 0)) {
#line 410
            goto while_break___51;
          }
#line 411
          if (nblock >= nblockMAX) {
#line 411
            retVal = -4;
#line 411
            goto save_state_and_return;
          }
#line 412
          *(s->tt + nblock) = (UInt32 )uc;
#line 413
          nblock ++;
#line 414
          es --;
        }
        while_break___51: /* CIL Label */ ;
        }
      }
#line 417
      goto while_continue___45;
    } else {
#line 421
      if (nblock >= nblockMAX) {
#line 421
        retVal = -4;
#line 421
        goto save_state_and_return;
      }
#line 427
      nn = (UInt32 )(nextSym - 1);
#line 429
      if (nn < 16U) {
#line 431
        pp = s->mtfbase[0];
#line 432
        uc = s->mtfa[(UInt32 )pp + nn];
        {
#line 433
        while (1) {
          while_continue___52: /* CIL Label */ ;
#line 433
          if (! (nn > 3U)) {
#line 433
            goto while_break___52;
          }
#line 434
          z = (Int32 )((UInt32 )pp + nn);
#line 435
          s->mtfa[z] = s->mtfa[z - 1];
#line 436
          s->mtfa[z - 1] = s->mtfa[z - 2];
#line 437
          s->mtfa[z - 2] = s->mtfa[z - 3];
#line 438
          s->mtfa[z - 3] = s->mtfa[z - 4];
#line 439
          nn -= 4U;
        }
        while_break___52: /* CIL Label */ ;
        }
        {
#line 441
        while (1) {
          while_continue___53: /* CIL Label */ ;
#line 441
          if (! (nn > 0U)) {
#line 441
            goto while_break___53;
          }
#line 442
          s->mtfa[(UInt32 )pp + nn] = s->mtfa[((UInt32 )pp + nn) - 1U];
#line 442
          nn --;
        }
        while_break___53: /* CIL Label */ ;
        }
#line 444
        s->mtfa[pp] = uc;
      } else {
#line 447
        lno = (Int32 )(nn / 16U);
#line 448
        off = (Int32 )(nn % 16U);
#line 449
        pp = s->mtfbase[lno] + off;
#line 450
        uc = s->mtfa[pp];
        {
#line 451
        while (1) {
          while_continue___54: /* CIL Label */ ;
#line 451
          if (! (pp > s->mtfbase[lno])) {
#line 451
            goto while_break___54;
          }
#line 452
          s->mtfa[pp] = s->mtfa[pp - 1];
#line 452
          pp --;
        }
        while_break___54: /* CIL Label */ ;
        }
#line 454
        (s->mtfbase[lno]) ++;
        {
#line 455
        while (1) {
          while_continue___55: /* CIL Label */ ;
#line 455
          if (! (lno > 0)) {
#line 455
            goto while_break___55;
          }
#line 456
          (s->mtfbase[lno]) --;
#line 457
          s->mtfa[s->mtfbase[lno]] = s->mtfa[(s->mtfbase[lno - 1] + 16) - 1];
#line 459
          lno --;
        }
        while_break___55: /* CIL Label */ ;
        }
#line 461
        (s->mtfbase[0]) --;
#line 462
        s->mtfa[s->mtfbase[0]] = uc;
#line 463
        if (s->mtfbase[0] == 0) {
#line 464
          kk___0 = 4095;
#line 465
          ii___0 = 15;
          {
#line 465
          while (1) {
            while_continue___56: /* CIL Label */ ;
#line 465
            if (! (ii___0 >= 0)) {
#line 465
              goto while_break___56;
            }
#line 466
            jj___0 = 15;
            {
#line 466
            while (1) {
              while_continue___57: /* CIL Label */ ;
#line 466
              if (! (jj___0 >= 0)) {
#line 466
                goto while_break___57;
              }
#line 467
              s->mtfa[kk___0] = s->mtfa[s->mtfbase[ii___0] + jj___0];
#line 468
              kk___0 --;
#line 466
              jj___0 --;
            }
            while_break___57: /* CIL Label */ ;
            }
#line 470
            s->mtfbase[ii___0] = kk___0 + 1;
#line 465
            ii___0 --;
          }
          while_break___56: /* CIL Label */ ;
          }
        }
      }
#line 477
      (s->unzftab[s->seqToUnseq[uc]]) ++;
#line 478
      if (s->smallDecompress) {
#line 479
        *(s->ll16 + nblock) = (UInt16 )s->seqToUnseq[uc];
      } else {
#line 480
        *(s->tt + nblock) = (UInt32 )s->seqToUnseq[uc];
      }
#line 481
      nblock ++;
#line 483
      if (groupPos == 0) {
#line 483
        groupNo ++;
#line 483
        if (groupNo >= nSelectors) {
#line 483
          retVal = -4;
#line 483
          goto save_state_and_return;
        }
#line 483
        groupPos = 50;
#line 483
        gSel = (Int32 )s->selector[groupNo];
#line 483
        gMinlen = s->minLens[gSel];
#line 483
        gLimit = & s->limit[gSel][0];
#line 483
        gPerm = & s->perm[gSel][0];
#line 483
        gBase = & s->base[gSel][0];
      }
#line 483
      groupPos --;
#line 483
      zn = gMinlen;
      case_40: /* CIL Label */ 
#line 483
      s->state = 40;
      {
#line 483
      while (1) {
        while_continue___58: /* CIL Label */ ;
#line 483
        if (s->bsLive >= zn) {
#line 483
          v___30 = (s->bsBuff >> (s->bsLive - zn)) & (unsigned int )((1 << zn) - 1);
#line 483
          s->bsLive -= zn;
#line 483
          zvec = (Int32 )v___30;
#line 483
          goto while_break___58;
        }
#line 483
        if ((s->strm)->avail_in == 0U) {
#line 483
          retVal = 0;
#line 483
          goto save_state_and_return;
        }
#line 483
        s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 483
        s->bsLive += 8;
#line 483
        ((s->strm)->next_in) ++;
#line 483
        ((s->strm)->avail_in) --;
#line 483
        ((s->strm)->total_in_lo32) ++;
#line 483
        if ((s->strm)->total_in_lo32 == 0U) {
#line 483
          ((s->strm)->total_in_hi32) ++;
        }
      }
      while_break___58: /* CIL Label */ ;
      }
      {
#line 483
      while (1) {
        while_continue___59: /* CIL Label */ ;
#line 483
        if (zn > 20) {
#line 483
          retVal = -4;
#line 483
          goto save_state_and_return;
        }
#line 483
        if (zvec <= *(gLimit + zn)) {
#line 483
          goto while_break___59;
        }
#line 483
        zn ++;
        case_41: /* CIL Label */ 
#line 483
        s->state = 41;
        {
#line 483
        while (1) {
          while_continue___60: /* CIL Label */ ;
#line 483
          if (s->bsLive >= 1) {
#line 483
            v___31 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 483
            (s->bsLive) --;
#line 483
            zj = (Int32 )v___31;
#line 483
            goto while_break___60;
          }
#line 483
          if ((s->strm)->avail_in == 0U) {
#line 483
            retVal = 0;
#line 483
            goto save_state_and_return;
          }
#line 483
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 483
          s->bsLive += 8;
#line 483
          ((s->strm)->next_in) ++;
#line 483
          ((s->strm)->avail_in) --;
#line 483
          ((s->strm)->total_in_lo32) ++;
#line 483
          if ((s->strm)->total_in_lo32 == 0U) {
#line 483
            ((s->strm)->total_in_hi32) ++;
          }
        }
        while_break___60: /* CIL Label */ ;
        }
#line 483
        zvec = (zvec << 1) | zj;
      }
      while_break___59: /* CIL Label */ ;
      }
#line 483
      if (zvec - *(gBase + zn) < 0) {
#line 483
        retVal = -4;
#line 483
        goto save_state_and_return;
      } else
#line 483
      if (zvec - *(gBase + zn) >= 258) {
#line 483
        retVal = -4;
#line 483
        goto save_state_and_return;
      }
#line 483
      nextSym = *(gPerm + (zvec - *(gBase + zn)));
#line 484
      goto while_continue___45;
    }
  }
  while_break___45: /* CIL Label */ ;
  }
#line 491
  if (s->origPtr < 0) {
#line 492
    retVal = -4;
#line 492
    goto save_state_and_return;
  } else
#line 491
  if (s->origPtr >= nblock) {
#line 492
    retVal = -4;
#line 492
    goto save_state_and_return;
  }
#line 496
  i = 0;
  {
#line 496
  while (1) {
    while_continue___61: /* CIL Label */ ;
#line 496
    if (! (i <= 255)) {
#line 496
      goto while_break___61;
    }
#line 497
    if (s->unzftab[i] < 0) {
#line 498
      retVal = -4;
#line 498
      goto save_state_and_return;
    } else
#line 497
    if (s->unzftab[i] > nblock) {
#line 498
      retVal = -4;
#line 498
      goto save_state_and_return;
    }
#line 496
    i ++;
  }
  while_break___61: /* CIL Label */ ;
  }
#line 501
  s->cftab[0] = 0;
#line 502
  i = 1;
  {
#line 502
  while (1) {
    while_continue___62: /* CIL Label */ ;
#line 502
    if (! (i <= 256)) {
#line 502
      goto while_break___62;
    }
#line 502
    s->cftab[i] = s->unzftab[i - 1];
#line 502
    i ++;
  }
  while_break___62: /* CIL Label */ ;
  }
#line 503
  i = 1;
  {
#line 503
  while (1) {
    while_continue___63: /* CIL Label */ ;
#line 503
    if (! (i <= 256)) {
#line 503
      goto while_break___63;
    }
#line 503
    s->cftab[i] += s->cftab[i - 1];
#line 503
    i ++;
  }
  while_break___63: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___64: /* CIL Label */ ;
#line 505
    if (! (i <= 256)) {
#line 505
      goto while_break___64;
    }
#line 506
    if (s->cftab[i] < 0) {
#line 508
      retVal = -4;
#line 508
      goto save_state_and_return;
    } else
#line 506
    if (s->cftab[i] > nblock) {
#line 508
      retVal = -4;
#line 508
      goto save_state_and_return;
    }
#line 505
    i ++;
  }
  while_break___64: /* CIL Label */ ;
  }
#line 512
  i = 1;
  {
#line 512
  while (1) {
    while_continue___65: /* CIL Label */ ;
#line 512
    if (! (i <= 256)) {
#line 512
      goto while_break___65;
    }
#line 513
    if (s->cftab[i - 1] > s->cftab[i]) {
#line 514
      retVal = -4;
#line 514
      goto save_state_and_return;
    }
#line 512
    i ++;
  }
  while_break___65: /* CIL Label */ ;
  }
#line 518
  s->state_out_len = 0;
#line 519
  s->state_out_ch = (UChar )0;
#line 520
  s->calculatedBlockCRC = (UInt32 )4294967295L;
#line 521
  s->state = 2;
#line 522
  if (s->verbosity >= 2) {
    {
#line 522
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rt+rld");
    }
  }
#line 524
  if (s->smallDecompress) {
#line 527
    i = 0;
    {
#line 527
    while (1) {
      while_continue___66: /* CIL Label */ ;
#line 527
      if (! (i <= 256)) {
#line 527
        goto while_break___66;
      }
#line 527
      s->cftabCopy[i] = s->cftab[i];
#line 527
      i ++;
    }
    while_break___66: /* CIL Label */ ;
    }
#line 530
    i = 0;
    {
#line 530
    while (1) {
      while_continue___67: /* CIL Label */ ;
#line 530
      if (! (i < nblock)) {
#line 530
        goto while_break___67;
      }
#line 531
      uc = (UChar )*(s->ll16 + i);
#line 532
      *(s->ll16 + i) = (UInt16 )(s->cftabCopy[uc] & 65535);
#line 532
      if ((i & 1) == 0) {
#line 532
        *(s->ll4 + (i >> 1)) = (UChar )(((int )*(s->ll4 + (i >> 1)) & 240) | (s->cftabCopy[uc] >> 16));
      } else {
#line 532
        *(s->ll4 + (i >> 1)) = (UChar )(((int )*(s->ll4 + (i >> 1)) & 15) | ((s->cftabCopy[uc] >> 16) << 4));
      }
#line 533
      (s->cftabCopy[uc]) ++;
#line 530
      i ++;
    }
    while_break___67: /* CIL Label */ ;
    }
#line 537
    i = s->origPtr;
#line 538
    j = (Int32 )((UInt32 )*(s->ll16 + i) | ((((UInt32 )*(s->ll4 + (i >> 1)) >> ((i << 2) & 4)) & 15U) << 16));
    {
#line 539
    while (1) {
      while_continue___68: /* CIL Label */ ;
#line 540
      tmp___3 = (Int32 )((UInt32 )*(s->ll16 + j) | ((((UInt32 )*(s->ll4 + (j >> 1)) >> ((j << 2) & 4)) & 15U) << 16));
#line 541
      *(s->ll16 + j) = (UInt16 )(i & 65535);
#line 541
      if ((j & 1) == 0) {
#line 541
        *(s->ll4 + (j >> 1)) = (UChar )(((int )*(s->ll4 + (j >> 1)) & 240) | (i >> 16));
      } else {
#line 541
        *(s->ll4 + (j >> 1)) = (UChar )(((int )*(s->ll4 + (j >> 1)) & 15) | ((i >> 16) << 4));
      }
#line 542
      i = j;
#line 543
      j = tmp___3;
#line 539
      if (! (i != s->origPtr)) {
#line 539
        goto while_break___68;
      }
    }
    while_break___68: /* CIL Label */ ;
    }
#line 547
    s->tPos = (UInt32 )s->origPtr;
#line 548
    s->nblock_used = 0;
#line 549
    if (s->blockRandomised) {
#line 550
      s->rNToGo = 0;
#line 550
      s->rTPos = 0;
#line 551
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 551
        return ((Int32 )((Bool )1));
      }
      {
#line 551
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 551
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 551
      (s->nblock_used) ++;
      }
#line 552
      if (s->rNToGo == 0) {
#line 552
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 552
        (s->rTPos) ++;
#line 552
        if (s->rTPos == 512) {
#line 552
          s->rTPos = 0;
        }
      }
#line 552
      (s->rNToGo) --;
#line 552
      if (s->rNToGo == 1) {
#line 552
        tmp___4 = 1;
      } else {
#line 552
        tmp___4 = 0;
      }
#line 552
      s->k0 ^= tmp___4;
    } else {
#line 554
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 554
        return ((Int32 )((Bool )1));
      }
      {
#line 554
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 554
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 554
      (s->nblock_used) ++;
      }
    }
  } else {
#line 560
    i = 0;
    {
#line 560
    while (1) {
      while_continue___69: /* CIL Label */ ;
#line 560
      if (! (i < nblock)) {
#line 560
        goto while_break___69;
      }
#line 561
      uc = (UChar )(*(s->tt + i) & 255U);
#line 562
      *(s->tt + s->cftab[uc]) |= (unsigned int )(i << 8);
#line 563
      (s->cftab[uc]) ++;
#line 560
      i ++;
    }
    while_break___69: /* CIL Label */ ;
    }
#line 566
    s->tPos = *(s->tt + s->origPtr) >> 8;
#line 567
    s->nblock_used = 0;
#line 568
    if (s->blockRandomised) {
#line 569
      s->rNToGo = 0;
#line 569
      s->rTPos = 0;
#line 570
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 570
        return ((Int32 )((Bool )1));
      }
#line 570
      s->tPos = *(s->tt + s->tPos);
#line 570
      s->k0 = (Int32 )((UChar )(s->tPos & 255U));
#line 570
      s->tPos >>= 8;
#line 570
      (s->nblock_used) ++;
#line 571
      if (s->rNToGo == 0) {
#line 571
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 571
        (s->rTPos) ++;
#line 571
        if (s->rTPos == 512) {
#line 571
          s->rTPos = 0;
        }
      }
#line 571
      (s->rNToGo) --;
#line 571
      if (s->rNToGo == 1) {
#line 571
        tmp___5 = 1;
      } else {
#line 571
        tmp___5 = 0;
      }
#line 571
      s->k0 ^= tmp___5;
    } else {
#line 573
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 573
        return ((Int32 )((Bool )1));
      }
#line 573
      s->tPos = *(s->tt + s->tPos);
#line 573
      s->k0 = (Int32 )((UChar )(s->tPos & 255U));
#line 573
      s->tPos >>= 8;
#line 573
      (s->nblock_used) ++;
    }
  }
#line 578
  retVal = 0;
#line 578
  goto save_state_and_return;
  endhdr_2: 
  case_42: /* CIL Label */ 
#line 584
  s->state = 42;
  {
#line 584
  while (1) {
    while_continue___70: /* CIL Label */ ;
#line 584
    if (s->bsLive >= 8) {
#line 584
      v___32 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 584
      s->bsLive -= 8;
#line 584
      uc = (UChar )v___32;
#line 584
      goto while_break___70;
    }
#line 584
    if ((s->strm)->avail_in == 0U) {
#line 584
      retVal = 0;
#line 584
      goto save_state_and_return;
    }
#line 584
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 584
    s->bsLive += 8;
#line 584
    ((s->strm)->next_in) ++;
#line 584
    ((s->strm)->avail_in) --;
#line 584
    ((s->strm)->total_in_lo32) ++;
#line 584
    if ((s->strm)->total_in_lo32 == 0U) {
#line 584
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___70: /* CIL Label */ ;
  }
#line 585
  if ((int )uc != 114) {
#line 585
    retVal = -4;
#line 585
    goto save_state_and_return;
  }
  case_43: /* CIL Label */ 
#line 586
  s->state = 43;
  {
#line 586
  while (1) {
    while_continue___71: /* CIL Label */ ;
#line 586
    if (s->bsLive >= 8) {
#line 586
      v___33 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 586
      s->bsLive -= 8;
#line 586
      uc = (UChar )v___33;
#line 586
      goto while_break___71;
    }
#line 586
    if ((s->strm)->avail_in == 0U) {
#line 586
      retVal = 0;
#line 586
      goto save_state_and_return;
    }
#line 586
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 586
    s->bsLive += 8;
#line 586
    ((s->strm)->next_in) ++;
#line 586
    ((s->strm)->avail_in) --;
#line 586
    ((s->strm)->total_in_lo32) ++;
#line 586
    if ((s->strm)->total_in_lo32 == 0U) {
#line 586
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___71: /* CIL Label */ ;
  }
#line 587
  if ((int )uc != 69) {
#line 587
    retVal = -4;
#line 587
    goto save_state_and_return;
  }
  case_44: /* CIL Label */ 
#line 588
  s->state = 44;
  {
#line 588
  while (1) {
    while_continue___72: /* CIL Label */ ;
#line 588
    if (s->bsLive >= 8) {
#line 588
      v___34 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 588
      s->bsLive -= 8;
#line 588
      uc = (UChar )v___34;
#line 588
      goto while_break___72;
    }
#line 588
    if ((s->strm)->avail_in == 0U) {
#line 588
      retVal = 0;
#line 588
      goto save_state_and_return;
    }
#line 588
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 588
    s->bsLive += 8;
#line 588
    ((s->strm)->next_in) ++;
#line 588
    ((s->strm)->avail_in) --;
#line 588
    ((s->strm)->total_in_lo32) ++;
#line 588
    if ((s->strm)->total_in_lo32 == 0U) {
#line 588
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___72: /* CIL Label */ ;
  }
#line 589
  if ((int )uc != 56) {
#line 589
    retVal = -4;
#line 589
    goto save_state_and_return;
  }
  case_45: /* CIL Label */ 
#line 590
  s->state = 45;
  {
#line 590
  while (1) {
    while_continue___73: /* CIL Label */ ;
#line 590
    if (s->bsLive >= 8) {
#line 590
      v___35 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 590
      s->bsLive -= 8;
#line 590
      uc = (UChar )v___35;
#line 590
      goto while_break___73;
    }
#line 590
    if ((s->strm)->avail_in == 0U) {
#line 590
      retVal = 0;
#line 590
      goto save_state_and_return;
    }
#line 590
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 590
    s->bsLive += 8;
#line 590
    ((s->strm)->next_in) ++;
#line 590
    ((s->strm)->avail_in) --;
#line 590
    ((s->strm)->total_in_lo32) ++;
#line 590
    if ((s->strm)->total_in_lo32 == 0U) {
#line 590
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___73: /* CIL Label */ ;
  }
#line 591
  if ((int )uc != 80) {
#line 591
    retVal = -4;
#line 591
    goto save_state_and_return;
  }
  case_46: /* CIL Label */ 
#line 592
  s->state = 46;
  {
#line 592
  while (1) {
    while_continue___74: /* CIL Label */ ;
#line 592
    if (s->bsLive >= 8) {
#line 592
      v___36 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 592
      s->bsLive -= 8;
#line 592
      uc = (UChar )v___36;
#line 592
      goto while_break___74;
    }
#line 592
    if ((s->strm)->avail_in == 0U) {
#line 592
      retVal = 0;
#line 592
      goto save_state_and_return;
    }
#line 592
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 592
    s->bsLive += 8;
#line 592
    ((s->strm)->next_in) ++;
#line 592
    ((s->strm)->avail_in) --;
#line 592
    ((s->strm)->total_in_lo32) ++;
#line 592
    if ((s->strm)->total_in_lo32 == 0U) {
#line 592
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___74: /* CIL Label */ ;
  }
#line 593
  if ((int )uc != 144) {
#line 593
    retVal = -4;
#line 593
    goto save_state_and_return;
  }
#line 595
  s->storedCombinedCRC = (UInt32 )0;
  case_47: /* CIL Label */ 
#line 596
  s->state = 47;
  {
#line 596
  while (1) {
    while_continue___75: /* CIL Label */ ;
#line 596
    if (s->bsLive >= 8) {
#line 596
      v___37 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 596
      s->bsLive -= 8;
#line 596
      uc = (UChar )v___37;
#line 596
      goto while_break___75;
    }
#line 596
    if ((s->strm)->avail_in == 0U) {
#line 596
      retVal = 0;
#line 596
      goto save_state_and_return;
    }
#line 596
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 596
    s->bsLive += 8;
#line 596
    ((s->strm)->next_in) ++;
#line 596
    ((s->strm)->avail_in) --;
#line 596
    ((s->strm)->total_in_lo32) ++;
#line 596
    if ((s->strm)->total_in_lo32 == 0U) {
#line 596
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___75: /* CIL Label */ ;
  }
#line 597
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
  case_48: /* CIL Label */ 
#line 598
  s->state = 48;
  {
#line 598
  while (1) {
    while_continue___76: /* CIL Label */ ;
#line 598
    if (s->bsLive >= 8) {
#line 598
      v___38 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 598
      s->bsLive -= 8;
#line 598
      uc = (UChar )v___38;
#line 598
      goto while_break___76;
    }
#line 598
    if ((s->strm)->avail_in == 0U) {
#line 598
      retVal = 0;
#line 598
      goto save_state_and_return;
    }
#line 598
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 598
    s->bsLive += 8;
#line 598
    ((s->strm)->next_in) ++;
#line 598
    ((s->strm)->avail_in) --;
#line 598
    ((s->strm)->total_in_lo32) ++;
#line 598
    if ((s->strm)->total_in_lo32 == 0U) {
#line 598
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___76: /* CIL Label */ ;
  }
#line 599
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
  case_49: /* CIL Label */ 
#line 600
  s->state = 49;
  {
#line 600
  while (1) {
    while_continue___77: /* CIL Label */ ;
#line 600
    if (s->bsLive >= 8) {
#line 600
      v___39 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 600
      s->bsLive -= 8;
#line 600
      uc = (UChar )v___39;
#line 600
      goto while_break___77;
    }
#line 600
    if ((s->strm)->avail_in == 0U) {
#line 600
      retVal = 0;
#line 600
      goto save_state_and_return;
    }
#line 600
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 600
    s->bsLive += 8;
#line 600
    ((s->strm)->next_in) ++;
#line 600
    ((s->strm)->avail_in) --;
#line 600
    ((s->strm)->total_in_lo32) ++;
#line 600
    if ((s->strm)->total_in_lo32 == 0U) {
#line 600
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___77: /* CIL Label */ ;
  }
#line 601
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
  case_50: /* CIL Label */ 
#line 602
  s->state = 50;
  {
#line 602
  while (1) {
    while_continue___78: /* CIL Label */ ;
#line 602
    if (s->bsLive >= 8) {
#line 602
      v___40 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 602
      s->bsLive -= 8;
#line 602
      uc = (UChar )v___40;
#line 602
      goto while_break___78;
    }
#line 602
    if ((s->strm)->avail_in == 0U) {
#line 602
      retVal = 0;
#line 602
      goto save_state_and_return;
    }
#line 602
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 602
    s->bsLive += 8;
#line 602
    ((s->strm)->next_in) ++;
#line 602
    ((s->strm)->avail_in) --;
#line 602
    ((s->strm)->total_in_lo32) ++;
#line 602
    if ((s->strm)->total_in_lo32 == 0U) {
#line 602
      ((s->strm)->total_in_hi32) ++;
    }
  }
  while_break___78: /* CIL Label */ ;
  }
#line 603
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
#line 605
  s->state = 1;
#line 606
  retVal = 4;
#line 606
  goto save_state_and_return;
  switch_default: /* CIL Label */ 
  {
#line 608
  BZ2_bz__AssertH__fail(4001);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 611
  BZ2_bz__AssertH__fail(4002);
  }
  save_state_and_return: 
#line 615
  s->save_i = i;
#line 616
  s->save_j = j;
#line 617
  s->save_t = t;
#line 618
  s->save_alphaSize = alphaSize;
#line 619
  s->save_nGroups = nGroups;
#line 620
  s->save_nSelectors = nSelectors;
#line 621
  s->save_EOB = EOB;
#line 622
  s->save_groupNo = groupNo;
#line 623
  s->save_groupPos = groupPos;
#line 624
  s->save_nextSym = nextSym;
#line 625
  s->save_nblockMAX = nblockMAX;
#line 626
  s->save_nblock = nblock;
#line 627
  s->save_es = es;
#line 628
  s->save_N = N;
#line 629
  s->save_curr = curr;
#line 630
  s->save_zt = zt;
#line 631
  s->save_zn = zn;
#line 632
  s->save_zvec = zvec;
#line 633
  s->save_zj = zj;
#line 634
  s->save_gSel = gSel;
#line 635
  s->save_gMinlen = gMinlen;
#line 636
  s->save_gLimit = gLimit;
#line 637
  s->save_gBase = gBase;
#line 638
  s->save_gPerm = gPerm;
#line 640
  return (retVal);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/randtable.c"
Int32 BZ2_rNums[512]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/randtable.c"
  {      619,      720,      127,      481, 
        931,      816,      813,      233, 
        566,      247,      985,      724, 
        205,      454,      863,      491, 
        741,      242,      949,      214, 
        733,      859,      335,      708, 
        621,      574,      73,      654, 
        730,      472,      419,      436, 
        278,      496,      867,      210, 
        399,      680,      480,      51, 
        878,      465,      811,      169, 
        869,      675,      611,      697, 
        867,      561,      862,      687, 
        507,      283,      482,      129, 
        807,      591,      733,      623, 
        150,      238,      59,      379, 
        684,      877,      625,      169, 
        643,      105,      170,      607, 
        520,      932,      727,      476, 
        693,      425,      174,      647, 
        73,      122,      335,      530, 
        442,      853,      695,      249, 
        445,      515,      909,      545, 
        703,      919,      874,      474, 
        882,      500,      594,      612, 
        641,      801,      220,      162, 
        819,      984,      589,      513, 
        495,      799,      161,      604, 
        958,      533,      221,      400, 
        386,      867,      600,      782, 
        382,      596,      414,      171, 
        516,      375,      682,      485, 
        911,      276,      98,      553, 
        163,      354,      666,      933, 
        424,      341,      533,      870, 
        227,      730,      475,      186, 
        263,      647,      537,      686, 
        600,      224,      469,      68, 
        770,      919,      190,      373, 
        294,      822,      808,      206, 
        184,      943,      795,      384, 
        383,      461,      404,      758, 
        839,      887,      715,      67, 
        618,      276,      204,      918, 
        873,      777,      604,      560, 
        951,      160,      578,      722, 
        79,      804,      96,      409, 
        713,      940,      652,      934, 
        970,      447,      318,      353, 
        859,      672,      112,      785, 
        645,      863,      803,      350, 
        139,      93,      354,      99, 
        820,      908,      609,      772, 
        154,      274,      580,      184, 
        79,      626,      630,      742, 
        653,      282,      762,      623, 
        680,      81,      927,      626, 
        789,      125,      411,      521, 
        938,      300,      821,      78, 
        343,      175,      128,      250, 
        170,      774,      972,      275, 
        999,      639,      495,      78, 
        352,      126,      857,      956, 
        358,      619,      580,      124, 
        737,      594,      701,      612, 
        669,      112,      134,      694, 
        363,      992,      809,      743, 
        168,      974,      944,      375, 
        748,      52,      600,      747, 
        642,      182,      862,      81, 
        344,      805,      988,      739, 
        511,      655,      814,      334, 
        249,      515,      897,      955, 
        664,      981,      649,      113, 
        974,      459,      893,      228, 
        433,      837,      553,      268, 
        926,      240,      102,      654, 
        459,      51,      686,      754, 
        806,      760,      493,      403, 
        415,      394,      687,      700, 
        946,      670,      656,      610, 
        738,      392,      760,      799, 
        887,      653,      978,      321, 
        576,      617,      626,      502, 
        894,      679,      243,      440, 
        680,      879,      194,      572, 
        640,      724,      926,      56, 
        204,      700,      707,      151, 
        457,      449,      797,      195, 
        791,      558,      945,      679, 
        297,      59,      87,      824, 
        713,      663,      412,      693, 
        342,      606,      134,      108, 
        571,      364,      631,      212, 
        174,      643,      304,      329, 
        343,      97,      430,      751, 
        497,      314,      983,      374, 
        822,      928,      140,      206, 
        73,      263,      980,      736, 
        876,      478,      430,      305, 
        170,      514,      364,      692, 
        829,      82,      855,      953, 
        676,      246,      369,      970, 
        294,      750,      807,      827, 
        150,      790,      288,      923, 
        804,      378,      215,      828, 
        592,      281,      565,      555, 
        710,      82,      896,      831, 
        547,      261,      524,      462, 
        293,      465,      502,      56, 
        661,      821,      976,      991, 
        658,      869,      905,      758, 
        745,      193,      768,      550, 
        608,      933,      378,      286, 
        215,      979,      792,      961, 
        61,      688,      793,      644, 
        986,      403,      106,      366, 
        905,      644,      372,      567, 
        466,      434,      645,      210, 
        389,      550,      919,      135, 
        780,      773,      635,      389, 
        707,      100,      626,      958, 
        165,      504,      920,      176, 
        193,      713,      857,      265, 
        203,      50,      668,      108, 
        645,      990,      626,      197, 
        510,      357,      358,      850, 
        858,      364,      936,      638};
#line 178 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 478 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 267
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf )  __asm__("lstat64")  ;
#line 297
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 183 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Int32 verbosity  ;
#line 184 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Bool keepInputFiles  ;
#line 184 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Bool smallMode  ;
#line 184 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Bool deleteOutputOnInterrupt  ;
#line 185 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Bool forceOverwrite  ;
#line 185 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Bool testFailsExist  ;
#line 185 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Bool unzFailsExist  ;
#line 185 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Bool noisy  ;
#line 186 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Int32 numFileNames  ;
#line 186 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Int32 numFilesProcessed  ;
#line 186 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Int32 blockSize100k  ;
#line 187 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Int32 exitValue  ;
#line 199 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Int32 opMode  ;
#line 200 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Int32 srcMode  ;
#line 204 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Int32 longestFileName  ;
#line 205 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Char inName[1034]  ;
#line 206 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Char outName[1034]  ;
#line 207 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Char tmpName[1034]  ;
#line 209 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Char progNameReally[1034]  ;
#line 210 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
FILE *outputHandleJustInCase  ;
#line 211 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Int32 workFactor  ;
#line 213
static  __attribute__((__noreturn__)) void panic(Char const   *s ) ;
#line 214
static  __attribute__((__noreturn__)) void ioError(void) ;
#line 215
static  __attribute__((__noreturn__)) void outOfMemory(void) ;
#line 216
static  __attribute__((__noreturn__)) void configError(void) ;
#line 217
static  __attribute__((__noreturn__)) void crcError(void) ;
#line 218
static  __attribute__((__noreturn__)) void cleanUpAndFail(Int32 ec ) ;
#line 219
static  __attribute__((__noreturn__)) void compressedStreamEOF(void) ;
#line 221
static void copyFileName(Char *to , Char *from ) ;
#line 222
static void *myMalloc(Int32 n ) ;
#line 223
static void applySavedFileAttrToOutputFile(Int32 fd ) ;
#line 237 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void uInt64_from_UInt32s(UInt64 *n , UInt32 lo32 , UInt32 hi32 ) 
{ 


  {
#line 240
  n->b[7] = (UChar )((hi32 >> 24) & 255U);
#line 241
  n->b[6] = (UChar )((hi32 >> 16) & 255U);
#line 242
  n->b[5] = (UChar )((hi32 >> 8) & 255U);
#line 243
  n->b[4] = (UChar )(hi32 & 255U);
#line 244
  n->b[3] = (UChar )((lo32 >> 24) & 255U);
#line 245
  n->b[2] = (UChar )((lo32 >> 16) & 255U);
#line 246
  n->b[1] = (UChar )((lo32 >> 8) & 255U);
#line 247
  n->b[0] = (UChar )(lo32 & 255U);
#line 248
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static double uInt64_to_double(UInt64 *n ) 
{ 
  Int32 i ;
  double base ;
  double sum ;

  {
#line 255
  base = 1.0;
#line 256
  sum = 0.0;
#line 257
  i = 0;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! (i < 8)) {
#line 257
      goto while_break;
    }
#line 258
    sum += base * (double )n->b[i];
#line 259
    base *= 256.0;
#line 257
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  return (sum);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static Bool uInt64_isZero(UInt64 *n ) 
{ 
  Int32 i ;

  {
#line 269
  i = 0;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! (i < 8)) {
#line 269
      goto while_break;
    }
#line 270
    if ((int )n->b[i] != 0) {
#line 270
      return ((Bool )0);
    }
#line 269
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  return ((Bool )1);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static Int32 uInt64_qrm10(UInt64 *n ) 
{ 
  UInt32 rem ;
  UInt32 tmp ;
  Int32 i ;

  {
#line 281
  rem = (UInt32 )0;
#line 282
  i = 7;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! (i >= 0)) {
#line 282
      goto while_break;
    }
#line 283
    tmp = rem * 256U + (UInt32 )n->b[i];
#line 284
    n->b[i] = (UChar )(tmp / 10U);
#line 285
    rem = tmp % 10U;
#line 282
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return ((Int32 )rem);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void uInt64_toAscii(char *outbuf , UInt64 *n ) 
{ 
  Int32 i ;
  Int32 q ;
  UChar buf[32] ;
  Int32 nBuf ;
  UInt64 n_copy ;
  Bool tmp ;

  {
#line 299
  nBuf = 0;
#line 300
  n_copy = *n;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 302
    q = uInt64_qrm10(& n_copy);
#line 303
    buf[nBuf] = (UChar )(q + 48);
#line 304
    nBuf ++;
#line 301
    tmp = uInt64_isZero(& n_copy);
    }
#line 301
    if (tmp) {
#line 301
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  *(outbuf + nBuf) = (char)0;
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 307
    if (! (i < nBuf)) {
#line 307
      goto while_break___0;
    }
#line 308
    *(outbuf + i) = (char )buf[(nBuf - i) - 1];
#line 307
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 309
  return;
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static Bool myfeof___0(FILE *f ) 
{ 
  Int32 c ;
  int tmp ;

  {
  {
#line 320
  tmp = fgetc(f);
#line 320
  c = tmp;
  }
#line 321
  if (c == -1) {
#line 321
    return ((Bool )1);
  }
  {
#line 322
  ungetc(c, f);
  }
#line 323
  return ((Bool )0);
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void compressStream(FILE *stream , FILE *zStream ) 
{ 
  BZFILE *bzf ;
  UChar ibuf[5000] ;
  Int32 nIbuf ;
  UInt32 nbytes_in_lo32 ;
  UInt32 nbytes_in_hi32 ;
  UInt32 nbytes_out_lo32 ;
  UInt32 nbytes_out_hi32 ;
  Int32 bzerr ;
  Int32 bzerr_dummy ;
  Int32 ret ;
  int tmp ;
  int tmp___0 ;
  Bool tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  Int32 fd ;
  int tmp___5 ;
  int tmp___6 ;
  Char buf_nin[32] ;
  Char buf_nout[32] ;
  UInt64 nbytes_in ;
  UInt64 nbytes_out ;
  double nbytes_in_d ;
  double nbytes_out_d ;

  {
  {
#line 331
  bzf = (void *)0;
#line 341
  tmp = ferror(stream);
  }
#line 341
  if (tmp) {
#line 341
    goto errhandler_io;
  }
  {
#line 342
  tmp___0 = ferror(zStream);
  }
#line 342
  if (tmp___0) {
#line 342
    goto errhandler_io;
  }
  {
#line 344
  bzf = BZ2_bzWriteOpen(& bzerr, zStream, blockSize100k, verbosity, workFactor);
  }
#line 346
  if (bzerr != 0) {
#line 346
    goto errhandler;
  }
#line 348
  if (verbosity >= 2) {
    {
#line 348
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 352
    tmp___1 = myfeof___0(stream);
    }
#line 352
    if (tmp___1) {
#line 352
      goto while_break;
    }
    {
#line 353
    tmp___2 = fread((void */* __restrict  */)(ibuf), sizeof(UChar ), (size_t )5000,
                    (FILE */* __restrict  */)stream);
#line 353
    nIbuf = (Int32 )tmp___2;
#line 354
    tmp___3 = ferror(stream);
    }
#line 354
    if (tmp___3) {
#line 354
      goto errhandler_io;
    }
#line 355
    if (nIbuf > 0) {
      {
#line 355
      BZ2_bzWrite(& bzerr, bzf, (void *)(ibuf), nIbuf);
      }
    }
#line 356
    if (bzerr != 0) {
#line 356
      goto errhandler;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  BZ2_bzWriteClose64(& bzerr, bzf, 0, & nbytes_in_lo32, & nbytes_in_hi32, & nbytes_out_lo32,
                     & nbytes_out_hi32);
  }
#line 363
  if (bzerr != 0) {
#line 363
    goto errhandler;
  }
  {
#line 365
  tmp___4 = ferror(zStream);
  }
#line 365
  if (tmp___4) {
#line 365
    goto errhandler_io;
  }
  {
#line 366
  ret = fflush(zStream);
  }
#line 367
  if (ret == -1) {
#line 367
    goto errhandler_io;
  }
#line 368
  if ((unsigned long )zStream != (unsigned long )stdout) {
    {
#line 369
    tmp___5 = fileno(zStream);
#line 369
    fd = tmp___5;
    }
#line 370
    if (fd < 0) {
#line 370
      goto errhandler_io;
    }
    {
#line 371
    applySavedFileAttrToOutputFile(fd);
#line 372
    ret = fclose(zStream);
#line 373
    outputHandleJustInCase = (FILE *)((void *)0);
    }
#line 374
    if (ret == -1) {
#line 374
      goto errhandler_io;
    }
  }
  {
#line 376
  outputHandleJustInCase = (FILE *)((void *)0);
#line 377
  tmp___6 = ferror(stream);
  }
#line 377
  if (tmp___6) {
#line 377
    goto errhandler_io;
  }
  {
#line 378
  ret = fclose(stream);
  }
#line 379
  if (ret == -1) {
#line 379
    goto errhandler_io;
  }
#line 381
  if (verbosity >= 1) {
#line 382
    if (nbytes_in_lo32 == 0U) {
#line 382
      if (nbytes_in_hi32 == 0U) {
        {
#line 383
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" no data compressed.\n");
        }
      } else {
#line 382
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 388
      uInt64_from_UInt32s(& nbytes_in, nbytes_in_lo32, nbytes_in_hi32);
#line 390
      uInt64_from_UInt32s(& nbytes_out, nbytes_out_lo32, nbytes_out_hi32);
#line 392
      nbytes_in_d = uInt64_to_double(& nbytes_in);
#line 393
      nbytes_out_d = uInt64_to_double(& nbytes_out);
#line 394
      uInt64_toAscii(buf_nin, & nbytes_in);
#line 395
      uInt64_toAscii(buf_nout, & nbytes_out);
#line 396
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%6.3f:1, %6.3f bits/byte, %5.2f%% saved, %s in, %s out.\n",
              nbytes_in_d / nbytes_out_d, (8.0 * nbytes_out_d) / nbytes_in_d, 100.0 * (1.0 - nbytes_out_d / nbytes_in_d),
              buf_nin, buf_nout);
      }
    }
  }
#line 407
  return;
  errhandler: 
  {
#line 410
  BZ2_bzWriteClose64(& bzerr_dummy, bzf, 1, & nbytes_in_lo32, & nbytes_in_hi32, & nbytes_out_lo32,
                     & nbytes_out_hi32);
  }
  {
#line 414
  if (bzerr == -9) {
#line 414
    goto case_neg_9;
  }
#line 416
  if (bzerr == -3) {
#line 416
    goto case_neg_3;
  }
#line 418
  if (bzerr == -6) {
#line 418
    goto errhandler_io;
  }
#line 421
  goto switch_default;
  case_neg_9: /* CIL Label */ 
  {
#line 415
  configError();
  }
#line 415
  goto switch_break;
  case_neg_3: /* CIL Label */ 
  {
#line 417
  outOfMemory();
  }
#line 417
  goto switch_break;
  errhandler_io: 
  case_neg_6: /* CIL Label */ 
  {
#line 420
  ioError();
  }
#line 420
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 422
  panic("compress:unexpected error");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 425
  panic("compress:end");
  }
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static Bool uncompressStream(FILE *zStream , FILE *stream ) 
{ 
  BZFILE *bzf ;
  Int32 bzerr ;
  Int32 bzerr_dummy ;
  Int32 ret ;
  Int32 nread ;
  Int32 streamNo ;
  Int32 i ;
  UChar obuf[5000] ;
  UChar unused[5000] ;
  Int32 nUnused ;
  void *unusedTmpV ;
  UChar *unusedTmp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  Bool tmp___2 ;
  int tmp___3 ;
  Int32 fd ;
  int tmp___4 ;
  int tmp___5 ;
  Bool tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 435
  bzf = (void *)0;
#line 443
  nUnused = 0;
#line 444
  streamNo = 0;
#line 449
  tmp = ferror(stream);
  }
#line 449
  if (tmp) {
#line 449
    goto errhandler_io;
  }
  {
#line 450
  tmp___0 = ferror(zStream);
  }
#line 450
  if (tmp___0) {
#line 450
    goto errhandler_io;
  }
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 454
    bzf = BZ2_bzReadOpen(& bzerr, zStream, verbosity, (int )smallMode, (void *)(unused),
                         nUnused);
    }
#line 458
    if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 458
      goto errhandler;
    } else
#line 458
    if (bzerr != 0) {
#line 458
      goto errhandler;
    }
#line 459
    streamNo ++;
    {
#line 461
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 461
      if (! (bzerr == 0)) {
#line 461
        goto while_break___0;
      }
      {
#line 462
      nread = BZ2_bzRead(& bzerr, bzf, (void *)(obuf), 5000);
      }
#line 463
      if (bzerr == -5) {
#line 463
        goto trycat;
      }
#line 464
      if (bzerr == 0) {
#line 464
        goto _L;
      } else
#line 464
      if (bzerr == 4) {
        _L: /* CIL Label */ 
#line 464
        if (nread > 0) {
          {
#line 465
          fwrite((void const   */* __restrict  */)(obuf), sizeof(UChar ), (size_t )nread,
                 (FILE */* __restrict  */)stream);
          }
        }
      }
      {
#line 466
      tmp___1 = ferror(stream);
      }
#line 466
      if (tmp___1) {
#line 466
        goto errhandler_io;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 468
    if (bzerr != 4) {
#line 468
      goto errhandler;
    }
    {
#line 470
    BZ2_bzReadGetUnused(& bzerr, bzf, & unusedTmpV, & nUnused);
    }
#line 471
    if (bzerr != 0) {
      {
#line 471
      panic("decompress:bzReadGetUnused");
      }
    }
#line 473
    unusedTmp = (UChar *)unusedTmpV;
#line 474
    i = 0;
    {
#line 474
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 474
      if (! (i < nUnused)) {
#line 474
        goto while_break___1;
      }
#line 474
      unused[i] = *(unusedTmp + i);
#line 474
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 476
    BZ2_bzReadClose(& bzerr, bzf);
    }
#line 477
    if (bzerr != 0) {
      {
#line 477
      panic("decompress:bzReadGetUnused");
      }
    }
#line 479
    if (nUnused == 0) {
      {
#line 479
      tmp___2 = myfeof___0(zStream);
      }
#line 479
      if (tmp___2) {
#line 479
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  closeok: 
  {
#line 483
  tmp___3 = ferror(zStream);
  }
#line 483
  if (tmp___3) {
#line 483
    goto errhandler_io;
  }
#line 484
  if ((unsigned long )stream != (unsigned long )stdout) {
    {
#line 485
    tmp___4 = fileno(stream);
#line 485
    fd = tmp___4;
    }
#line 486
    if (fd < 0) {
#line 486
      goto errhandler_io;
    }
    {
#line 487
    applySavedFileAttrToOutputFile(fd);
    }
  }
  {
#line 489
  ret = fclose(zStream);
  }
#line 490
  if (ret == -1) {
#line 490
    goto errhandler_io;
  }
  {
#line 492
  tmp___5 = ferror(stream);
  }
#line 492
  if (tmp___5) {
#line 492
    goto errhandler_io;
  }
  {
#line 493
  ret = fflush(stream);
  }
#line 494
  if (ret != 0) {
#line 494
    goto errhandler_io;
  }
#line 495
  if ((unsigned long )stream != (unsigned long )stdout) {
    {
#line 496
    ret = fclose(stream);
#line 497
    outputHandleJustInCase = (FILE *)((void *)0);
    }
#line 498
    if (ret == -1) {
#line 498
      goto errhandler_io;
    }
  }
#line 500
  outputHandleJustInCase = (FILE *)((void *)0);
#line 501
  if (verbosity >= 2) {
    {
#line 501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n    ");
    }
  }
#line 502
  return ((Bool )1);
  trycat: 
#line 505
  if (forceOverwrite) {
    {
#line 506
    rewind(zStream);
    }
    {
#line 507
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 508
      tmp___6 = myfeof___0(zStream);
      }
#line 508
      if (tmp___6) {
#line 508
        goto while_break___2;
      }
      {
#line 509
      tmp___7 = fread((void */* __restrict  */)(obuf), sizeof(UChar ), (size_t )5000,
                      (FILE */* __restrict  */)zStream);
#line 509
      nread = (Int32 )tmp___7;
#line 510
      tmp___8 = ferror(zStream);
      }
#line 510
      if (tmp___8) {
#line 510
        goto errhandler_io;
      }
#line 511
      if (nread > 0) {
        {
#line 511
        fwrite((void const   */* __restrict  */)(obuf), sizeof(UChar ), (size_t )nread,
               (FILE */* __restrict  */)stream);
        }
      }
      {
#line 512
      tmp___9 = ferror(stream);
      }
#line 512
      if (tmp___9) {
#line 512
        goto errhandler_io;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 514
    goto closeok;
  }
  errhandler: 
  {
#line 518
  BZ2_bzReadClose(& bzerr_dummy, bzf);
  }
  {
#line 520
  if (bzerr == -9) {
#line 520
    goto case_neg_9;
  }
#line 522
  if (bzerr == -6) {
#line 522
    goto errhandler_io;
  }
#line 525
  if (bzerr == -4) {
#line 525
    goto case_neg_4;
  }
#line 527
  if (bzerr == -3) {
#line 527
    goto case_neg_3;
  }
#line 529
  if (bzerr == -7) {
#line 529
    goto case_neg_7;
  }
#line 531
  if (bzerr == -5) {
#line 531
    goto case_neg_5;
  }
#line 543
  goto switch_default;
  case_neg_9: /* CIL Label */ 
  {
#line 521
  configError();
  }
#line 521
  goto switch_break;
  errhandler_io: 
  case_neg_6: /* CIL Label */ 
  {
#line 524
  ioError();
  }
#line 524
  goto switch_break;
  case_neg_4: /* CIL Label */ 
  {
#line 526
  crcError();
  }
  case_neg_3: /* CIL Label */ 
  {
#line 528
  outOfMemory();
  }
  case_neg_7: /* CIL Label */ 
  {
#line 530
  compressedStreamEOF();
  }
  case_neg_5: /* CIL Label */ 
#line 532
  if ((unsigned long )zStream != (unsigned long )stdin) {
    {
#line 532
    fclose(zStream);
    }
  }
#line 533
  if ((unsigned long )stream != (unsigned long )stdout) {
    {
#line 533
    fclose(stream);
    }
  }
#line 534
  if (streamNo == 1) {
#line 535
    return ((Bool )0);
  } else {
#line 537
    if (noisy) {
      {
#line 538
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: trailing garbage after EOF ignored\n",
              progName, inName);
      }
    }
#line 541
    return ((Bool )1);
  }
  switch_default: /* CIL Label */ 
  {
#line 544
  panic("decompress:unexpected error");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 547
  panic("decompress:end");
  }
#line 548
  return ((Bool )1);
}
}
#line 553 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static Bool testStream(FILE *zStream ) 
{ 
  BZFILE *bzf ;
  Int32 bzerr ;
  Int32 bzerr_dummy ;
  Int32 ret ;
  Int32 nread ;
  Int32 streamNo ;
  Int32 i ;
  UChar obuf[5000] ;
  UChar unused[5000] ;
  Int32 nUnused ;
  void *unusedTmpV ;
  UChar *unusedTmp ;
  int tmp ;
  Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 556
  bzf = (void *)0;
#line 564
  nUnused = 0;
#line 565
  streamNo = 0;
#line 568
  tmp = ferror(zStream);
  }
#line 568
  if (tmp) {
#line 568
    goto errhandler_io;
  }
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 572
    bzf = BZ2_bzReadOpen(& bzerr, zStream, verbosity, (int )smallMode, (void *)(unused),
                         nUnused);
    }
#line 576
    if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 576
      goto errhandler;
    } else
#line 576
    if (bzerr != 0) {
#line 576
      goto errhandler;
    }
#line 577
    streamNo ++;
    {
#line 579
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 579
      if (! (bzerr == 0)) {
#line 579
        goto while_break___0;
      }
      {
#line 580
      nread = BZ2_bzRead(& bzerr, bzf, (void *)(obuf), 5000);
      }
#line 581
      if (bzerr == -5) {
#line 581
        goto errhandler;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 583
    if (bzerr != 4) {
#line 583
      goto errhandler;
    }
    {
#line 585
    BZ2_bzReadGetUnused(& bzerr, bzf, & unusedTmpV, & nUnused);
    }
#line 586
    if (bzerr != 0) {
      {
#line 586
      panic("test:bzReadGetUnused");
      }
    }
#line 588
    unusedTmp = (UChar *)unusedTmpV;
#line 589
    i = 0;
    {
#line 589
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 589
      if (! (i < nUnused)) {
#line 589
        goto while_break___1;
      }
#line 589
      unused[i] = *(unusedTmp + i);
#line 589
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 591
    BZ2_bzReadClose(& bzerr, bzf);
    }
#line 592
    if (bzerr != 0) {
      {
#line 592
      panic("test:bzReadGetUnused");
      }
    }
#line 593
    if (nUnused == 0) {
      {
#line 593
      tmp___0 = myfeof___0(zStream);
      }
#line 593
      if (tmp___0) {
#line 593
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 597
  tmp___1 = ferror(zStream);
  }
#line 597
  if (tmp___1) {
#line 597
    goto errhandler_io;
  }
  {
#line 598
  ret = fclose(zStream);
  }
#line 599
  if (ret == -1) {
#line 599
    goto errhandler_io;
  }
#line 601
  if (verbosity >= 2) {
    {
#line 601
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n    ");
    }
  }
#line 602
  return ((Bool )1);
  errhandler: 
  {
#line 605
  BZ2_bzReadClose(& bzerr_dummy, bzf);
  }
#line 606
  if (verbosity == 0) {
    {
#line 607
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: ",
            progName, inName);
    }
  }
  {
#line 609
  if (bzerr == -9) {
#line 609
    goto case_neg_9;
  }
#line 611
  if (bzerr == -6) {
#line 611
    goto errhandler_io;
  }
#line 614
  if (bzerr == -4) {
#line 614
    goto case_neg_4;
  }
#line 618
  if (bzerr == -3) {
#line 618
    goto case_neg_3;
  }
#line 620
  if (bzerr == -7) {
#line 620
    goto case_neg_7;
  }
#line 624
  if (bzerr == -5) {
#line 624
    goto case_neg_5;
  }
#line 636
  goto switch_default;
  case_neg_9: /* CIL Label */ 
  {
#line 610
  configError();
  }
#line 610
  goto switch_break;
  errhandler_io: 
  case_neg_6: /* CIL Label */ 
  {
#line 613
  ioError();
  }
#line 613
  goto switch_break;
  case_neg_4: /* CIL Label */ 
  {
#line 615
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"data integrity (CRC) error in data\n");
  }
#line 617
  return ((Bool )0);
  case_neg_3: /* CIL Label */ 
  {
#line 619
  outOfMemory();
  }
  case_neg_7: /* CIL Label */ 
  {
#line 621
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file ends unexpectedly\n");
  }
#line 623
  return ((Bool )0);
  case_neg_5: /* CIL Label */ 
#line 625
  if ((unsigned long )zStream != (unsigned long )stdin) {
    {
#line 625
    fclose(zStream);
    }
  }
#line 626
  if (streamNo == 1) {
    {
#line 627
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad magic number (file not created by bzip2)\n");
    }
#line 629
    return ((Bool )0);
  } else {
#line 631
    if (noisy) {
      {
#line 632
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trailing garbage after EOF ignored\n");
      }
    }
#line 634
    return ((Bool )1);
  }
  switch_default: /* CIL Label */ 
  {
#line 637
  panic("test:unexpected error");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 640
  panic("test:end");
  }
#line 641
  return ((Bool )1);
}
}
#line 650 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void setExit(Int32 v ) 
{ 


  {
#line 653
  if (v > exitValue) {
#line 653
    exitValue = v;
  }
#line 654
  return;
}
}
#line 658 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void cadvise(void) 
{ 


  {
#line 661
  if (noisy) {
    {
#line 662
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nIt is possible that the compressed file(s) have become corrupted.\nYou can use the -tvv option to test integrity of such files.\n\nYou can use the `bzip2recover\' program to attempt to recover\ndata from undamaged sections of corrupted files.\n\n");
    }
  }
#line 669
  return;
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void showFileNames(void) 
{ 


  {
#line 676
  if (noisy) {
    {
#line 677
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tInput file = %s, output file = %s\n",
            inName, outName);
    }
  }
#line 682
  return;
}
}
#line 686
static  __attribute__((__noreturn__)) void cleanUpAndFail(Int32 ec ) ;
#line 686 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void cleanUpAndFail(Int32 ec ) 
{ 
  Int32 retVal ;
  struct stat statBuf ;

  {
#line 692
  if (srcMode == 3) {
#line 692
    if (opMode != 3) {
#line 692
      if (deleteOutputOnInterrupt) {
        {
#line 701
        retVal = stat((char const   */* __restrict  */)(inName), (struct stat */* __restrict  */)(& statBuf));
        }
#line 702
        if (retVal == 0) {
#line 703
          if (noisy) {
            {
#line 704
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Deleting output file %s, if it exists.\n",
                    progName, outName);
            }
          }
#line 707
          if ((unsigned long )outputHandleJustInCase != (unsigned long )((void *)0)) {
            {
#line 708
            fclose(outputHandleJustInCase);
            }
          }
          {
#line 709
          retVal = remove((char const   *)(outName));
          }
#line 710
          if (retVal != 0) {
            {
#line 711
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: WARNING: deletion of output file (apparently) failed.\n",
                    progName);
            }
          }
        } else {
          {
#line 716
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: WARNING: deletion of output file suppressed\n",
                  progName);
#line 719
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:    since input file no longer exists.  Output file\n",
                  progName);
#line 722
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:    `%s\' may be incomplete.\n",
                  progName, outName);
#line 725
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:    I suggest doing an integrity test (bzip2 -tv) of it.\n",
                  progName);
          }
        }
      }
    }
  }
#line 732
  if (noisy) {
#line 732
    if (numFileNames > 0) {
#line 732
      if (numFilesProcessed < numFileNames) {
        {
#line 733
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: WARNING: some files have not been processed:\n%s:    %d specified on command line, %d not processed yet.\n\n",
                progName, progName, numFileNames, numFileNames - numFilesProcessed);
        }
      }
    }
  }
  {
#line 739
  setExit(ec);
#line 740
  exit(exitValue);
  }
}
}
#line 745
static  __attribute__((__noreturn__)) void panic(Char const   *s ) ;
#line 745 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void panic(Char const   *s ) 
{ 


  {
  {
#line 748
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: PANIC -- internal consistency error:\n\t%s\n\tThis is a BUG.  Please report it to me at:\n\tjseward@bzip.org\n",
          progName, s);
#line 754
  showFileNames();
#line 755
  cleanUpAndFail(3);
  }
}
}
#line 760
static  __attribute__((__noreturn__)) void crcError(void) ;
#line 760 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void crcError(void) 
{ 


  {
  {
#line 763
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: Data integrity error when decompressing.\n",
          progName);
#line 766
  showFileNames();
#line 767
  cadvise();
#line 768
  cleanUpAndFail(2);
  }
}
}
#line 773
static  __attribute__((__noreturn__)) void compressedStreamEOF(void) ;
#line 773 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void compressedStreamEOF(void) 
{ 


  {
#line 776
  if (noisy) {
    {
#line 777
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: Compressed file ends unexpectedly;\n\tperhaps it is corrupted?  *Possible* reason follows.\n",
            progName);
#line 781
    perror((char const   *)progName);
#line 782
    showFileNames();
#line 783
    cadvise();
    }
  }
  {
#line 785
  cleanUpAndFail(2);
  }
}
}
#line 790
static  __attribute__((__noreturn__)) void ioError(void) ;
#line 790 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void ioError(void) 
{ 


  {
  {
#line 793
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: I/O or other error, bailing out.  Possible reason follows.\n",
          progName);
#line 797
  perror((char const   *)progName);
#line 798
  showFileNames();
#line 799
  cleanUpAndFail(1);
  }
}
}
#line 804 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void mySignalCatcher(Int32 n ) 
{ 


  {
  {
#line 807
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: Control-C or similar caught, quitting.\n",
          progName);
#line 810
  cleanUpAndFail(1);
  }
}
}
#line 815 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void mySIGSEGVorSIGBUScatcher(Int32 n ) 
{ 


  {
#line 818
  if (opMode == 1) {
    {
#line 819
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: Caught a SIGSEGV or SIGBUS whilst compressing.\n\n   Possible causes are (most likely first):\n   (1) This computer has unreliable memory or cache hardware\n       (a surprisingly common problem; try a different machine.)\n   (2) A bug in the compiler used to create this executable\n       (unlikely, if you didn\'t compile bzip2 yourself.)\n   (3) A real bug in bzip2 -- I hope this should never be the case.\n   The user\'s manual, Section 4.3, has more info on (1) and (2).\n   \n   If you suspect this is a bug in bzip2, or are unsure about (1)\n   or (2), feel free to report it to me at: jseward@bzip.org.\n   Section 4.3 of the user\'s manual describes the info a useful\n   bug report should have.  If the manual is available on your\n   system, please try and read it before mailing me.  If you don\'t\n   have the manual or can\'t be bothered to read it, mail me anyway.\n\n",
            progName);
    }
  } else {
    {
#line 840
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: Caught a SIGSEGV or SIGBUS whilst decompressing.\n\n   Possible causes are (most likely first):\n   (1) The compressed data is corrupted, and bzip2\'s usual checks\n       failed to detect this.  Try bzip2 -tvv my_file.bz2.\n   (2) This computer has unreliable memory or cache hardware\n       (a surprisingly common problem; try a different machine.)\n   (3) A bug in the compiler used to create this executable\n       (unlikely, if you didn\'t compile bzip2 yourself.)\n   (4) A real bug in bzip2 -- I hope this should never be the case.\n   The user\'s manual, Section 4.3, has more info on (2) and (3).\n   \n   If you suspect this is a bug in bzip2, or are unsure about (2)\n   or (3), feel free to report it to me at: jseward@bzip.org.\n   Section 4.3 of the user\'s manual describes the info a useful\n   bug report should have.  If the manual is available on your\n   system, please try and read it before mailing me.  If you don\'t\n   have the manual or can\'t be bothered to read it, mail me anyway.\n\n",
            progName);
    }
  }
  {
#line 863
  showFileNames();
  }
#line 864
  if (opMode == 1) {
    {
#line 865
    cleanUpAndFail(3);
    }
  } else {
    {
#line 866
    cadvise();
#line 866
    cleanUpAndFail(2);
    }
  }
}
}
#line 871
static  __attribute__((__noreturn__)) void outOfMemory(void) ;
#line 871 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void outOfMemory(void) 
{ 


  {
  {
#line 874
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: couldn\'t allocate enough memory\n",
          progName);
#line 877
  showFileNames();
#line 878
  cleanUpAndFail(1);
  }
}
}
#line 883
static  __attribute__((__noreturn__)) void configError(void) ;
#line 883 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void configError(void) 
{ 


  {
  {
#line 886
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bzip2: I\'m not configured correctly for this platform!\n\tI require Int32, Int16 and Char to have sizes\n\tof 4, 2 and 1 bytes to run properly, and they don\'t.\n\tProbably you can fix this by defining them correctly,\n\tand recompiling.  Bye!\n");
#line 892
  setExit(3);
#line 893
  exit(exitValue);
  }
}
}
#line 907 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void pad(Char *s ) 
{ 
  Int32 i ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 911
  tmp = strlen((char const   *)s);
  }
#line 911
  if ((Int32 )tmp >= longestFileName) {
#line 911
    return;
  }
#line 912
  i = 1;
  {
#line 912
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 912
    tmp___0 = strlen((char const   *)s);
    }
#line 912
    if (! (i <= longestFileName - (Int32 )tmp___0)) {
#line 912
      goto while_break;
    }
    {
#line 913
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
#line 912
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 914
  return;
}
}
#line 918 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void copyFileName(Char *to , Char *from ) 
{ 
  size_t tmp ;

  {
  {
#line 921
  tmp = strlen((char const   *)from);
  }
#line 921
  if (tmp > 1024UL) {
    {
#line 922
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bzip2: file name\n`%s\'\nis suspiciously (more than %d chars) long.\nTry using a reasonable file name instead.  Sorry! :-)\n",
            from, 1024);
#line 929
    setExit(1);
#line 930
    exit(exitValue);
    }
  }
  {
#line 933
  strncpy((char */* __restrict  */)to, (char const   */* __restrict  */)from, (size_t )1024);
#line 934
  *(to + 1024) = (Char )'\000';
  }
#line 935
  return;
}
}
#line 939 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static Bool fileExists(Char *name ) 
{ 
  FILE *tmp ;
  FILE *tmp___0 ;
  Bool exists ;

  {
  {
#line 942
  tmp___0 = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"rb");
#line 942
  tmp = tmp___0;
#line 943
  exists = (Bool )((unsigned long )tmp != (unsigned long )((void *)0));
  }
#line 944
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    {
#line 944
    fclose(tmp);
    }
  }
#line 945
  return (exists);
}
}
#line 959 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static FILE *fopen_output_safely(Char *name , char const   *mode ) 
{ 
  FILE *fp ;
  Int32 fh ;

  {
  {
#line 965
  fh = open((char const   *)name, 193, 384);
  }
#line 966
  if (fh == -1) {
#line 966
    return ((FILE *)((void *)0));
  }
  {
#line 967
  fp = fdopen(fh, mode);
  }
#line 968
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 968
    close(fh);
    }
  }
#line 969
  return (fp);
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static Bool notAStandardFile(Char *name ) 
{ 
  Int32 i ;
  struct stat statBuf ;

  {
  {
#line 986
  i = lstat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& statBuf));
  }
#line 987
  if (i != 0) {
#line 987
    return ((Bool )1);
  }
#line 988
  if ((statBuf.st_mode & 61440U) == 32768U) {
#line 988
    return ((Bool )0);
  }
#line 989
  return ((Bool )1);
}
}
#line 997 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static Int32 countHardLinks(Char *name ) 
{ 
  Int32 i ;
  struct stat statBuf ;

  {
  {
#line 1003
  i = lstat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& statBuf));
  }
#line 1004
  if (i != 0) {
#line 1004
    return (0);
  }
#line 1005
  return ((Int32 )(statBuf.st_nlink - 1UL));
}
}
#line 1033 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static struct stat fileMetaInfo  ;
#line 1037 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void saveInputFileMetaInfo(Char *srcName ) 
{ 
  Int32 retVal ;

  {
  {
#line 1043
  retVal = stat((char const   */* __restrict  */)srcName, (struct stat */* __restrict  */)(& fileMetaInfo));
  }
#line 1044
  if (retVal != 0) {
    {
#line 1044
    ioError();
    }
  }
#line 1046
  return;
}
}
#line 1049 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void applySavedTimeInfoToOutputFile(Char *dstName ) 
{ 
  Int32 retVal ;
  struct utimbuf uTimBuf ;

  {
  {
#line 1056
  uTimBuf.actime = fileMetaInfo.st_atim.tv_sec;
#line 1057
  uTimBuf.modtime = fileMetaInfo.st_mtim.tv_sec;
#line 1059
  retVal = utime((char const   *)dstName, (struct utimbuf  const  *)(& uTimBuf));
  }
#line 1060
  if (retVal != 0) {
    {
#line 1060
    ioError();
    }
  }
#line 1062
  return;
}
}
#line 1064 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void applySavedFileAttrToOutputFile(Int32 fd ) 
{ 
  Int32 retVal ;

  {
  {
#line 1070
  retVal = fchmod(fd, fileMetaInfo.st_mode);
  }
#line 1071
  if (retVal != 0) {
    {
#line 1071
    ioError();
    }
  }
  {
#line 1073
  fchown(fd, fileMetaInfo.st_uid, fileMetaInfo.st_gid);
  }
#line 1078
  return;
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static Bool containsDubiousChars(Char *name ) 
{ 


  {
#line 1089
  return ((Bool )0);
}
}
#line 1104 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Char const   *zSuffix[4]  = {      ".bz2",      ".bz",      ".tbz2",      ".tbz"};
#line 1106 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
Char const   *unzSuffix[4]  = {      "",      "",      ".tar",      ".tar"};
#line 1109 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static Bool hasSuffix(Char *s , Char const   *suffix ) 
{ 
  Int32 ns ;
  size_t tmp ;
  Int32 nx ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1112
  tmp = strlen((char const   *)s);
#line 1112
  ns = (Int32 )tmp;
#line 1113
  tmp___0 = strlen(suffix);
#line 1113
  nx = (Int32 )tmp___0;
  }
#line 1114
  if (ns < nx) {
#line 1114
    return ((Bool )0);
  }
  {
#line 1115
  tmp___1 = strcmp((char const   *)((s + ns) - nx), suffix);
  }
#line 1115
  if (tmp___1 == 0) {
#line 1115
    return ((Bool )1);
  }
#line 1116
  return ((Bool )0);
}
}
#line 1119 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static Bool mapSuffix(Char *name , Char const   *oldSuffix , Char const   *newSuffix ) 
{ 
  Bool tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 1124
  tmp = hasSuffix(name, oldSuffix);
  }
#line 1124
  if (! tmp) {
#line 1124
    return ((Bool )0);
  }
  {
#line 1125
  tmp___0 = strlen((char const   *)name);
#line 1125
  tmp___1 = strlen(oldSuffix);
#line 1125
  *(name + (tmp___0 - tmp___1)) = (Char )0;
#line 1126
  strcat((char */* __restrict  */)name, (char const   */* __restrict  */)newSuffix);
  }
#line 1127
  return ((Bool )1);
}
}
#line 1132 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void compress(Char *name ) 
{ 
  FILE *inStr ;
  FILE *outStr ;
  Int32 n ;
  Int32 i ;
  struct stat statBuf ;
  Bool tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  Bool tmp___2 ;
  Bool tmp___3 ;
  Bool tmp___4 ;
  Bool tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  Int32 retVal ;
  int tmp___17 ;

  {
#line 1140
  deleteOutputOnInterrupt = (Bool )0;
#line 1142
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1142
    if (srcMode != 1) {
      {
#line 1143
      panic("compress: bad modes\n");
      }
    }
  }
  {
#line 1146
  if (srcMode == 1) {
#line 1146
    goto case_1;
  }
#line 1150
  if (srcMode == 3) {
#line 1150
    goto case_3;
  }
#line 1155
  if (srcMode == 2) {
#line 1155
    goto case_2;
  }
#line 1145
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1147
  copyFileName(inName, (Char *)"(stdin)");
#line 1148
  copyFileName(outName, (Char *)"(stdout)");
  }
#line 1149
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1151
  copyFileName(inName, name);
#line 1152
  copyFileName(outName, name);
#line 1153
  strcat((char */* __restrict  */)(outName), (char const   */* __restrict  */)".bz2");
  }
#line 1154
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1156
  copyFileName(inName, name);
#line 1157
  copyFileName(outName, (Char *)"(stdout)");
  }
#line 1158
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1161
  if (srcMode != 1) {
    {
#line 1161
    tmp = containsDubiousChars(inName);
    }
#line 1161
    if (tmp) {
#line 1162
      if (noisy) {
        {
#line 1163
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: There are no files matching `%s\'.\n",
                progName, inName);
        }
      }
      {
#line 1165
      setExit(1);
      }
#line 1166
      return;
    }
  }
#line 1168
  if (srcMode != 1) {
    {
#line 1168
    tmp___2 = fileExists(inName);
    }
#line 1168
    if (! tmp___2) {
      {
#line 1169
      tmp___0 = __errno_location();
#line 1169
      tmp___1 = strerror(*tmp___0);
#line 1169
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input file %s: %s.\n",
              progName, inName, tmp___1);
#line 1171
      setExit(1);
      }
#line 1172
      return;
    }
  }
#line 1174
  i = 0;
  {
#line 1174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1174
    if (! (i < 4)) {
#line 1174
      goto while_break;
    }
    {
#line 1175
    tmp___3 = hasSuffix(inName, zSuffix[i]);
    }
#line 1175
    if (tmp___3) {
#line 1176
      if (noisy) {
        {
#line 1177
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s already has %s suffix.\n",
                progName, inName, zSuffix[i]);
        }
      }
      {
#line 1180
      setExit(1);
      }
#line 1181
      return;
    }
#line 1174
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  if (srcMode == 3) {
#line 1184
    goto _L;
  } else
#line 1184
  if (srcMode == 2) {
    _L: /* CIL Label */ 
    {
#line 1185
    stat((char const   */* __restrict  */)(inName), (struct stat */* __restrict  */)(& statBuf));
    }
#line 1186
    if ((statBuf.st_mode & 61440U) == 16384U) {
      {
#line 1187
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s is a directory.\n",
              progName, inName);
#line 1190
      setExit(1);
      }
#line 1191
      return;
    }
  }
#line 1194
  if (srcMode == 3) {
#line 1194
    if (! forceOverwrite) {
      {
#line 1194
      tmp___4 = notAStandardFile(inName);
      }
#line 1194
      if (tmp___4) {
#line 1195
        if (noisy) {
          {
#line 1196
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s is not a normal file.\n",
                  progName, inName);
          }
        }
        {
#line 1198
        setExit(1);
        }
#line 1199
        return;
      }
    }
  }
#line 1201
  if (srcMode == 3) {
    {
#line 1201
    tmp___5 = fileExists(outName);
    }
#line 1201
    if (tmp___5) {
#line 1202
      if (forceOverwrite) {
        {
#line 1203
        remove((char const   *)(outName));
        }
      } else {
        {
#line 1205
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Output file %s already exists.\n",
                progName, outName);
#line 1207
        setExit(1);
        }
#line 1208
        return;
      }
    }
  }
#line 1211
  if (srcMode == 3) {
#line 1211
    if (! forceOverwrite) {
      {
#line 1211
      n = countHardLinks(inName);
      }
#line 1211
      if (n > 0) {
#line 1213
        if (n > 1) {
#line 1213
          tmp___6 = "s";
        } else {
#line 1213
          tmp___6 = "";
        }
        {
#line 1213
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s has %d other link%s.\n",
                progName, inName, n, tmp___6);
#line 1215
        setExit(1);
        }
#line 1216
        return;
      }
    }
  }
#line 1219
  if (srcMode == 3) {
    {
#line 1222
    saveInputFileMetaInfo(inName);
    }
  }
  {
#line 1227
  if (srcMode == 1) {
#line 1227
    goto case_1___0;
  }
#line 1241
  if (srcMode == 2) {
#line 1241
    goto case_2___0;
  }
#line 1262
  if (srcMode == 3) {
#line 1262
    goto case_3___0;
  }
#line 1281
  goto switch_default;
  case_1___0: /* CIL Label */ 
  {
#line 1228
  inStr = stdin;
#line 1229
  outStr = stdout;
#line 1230
  tmp___7 = fileno(stdout);
#line 1230
  tmp___8 = isatty(tmp___7);
  }
#line 1230
  if (tmp___8) {
    {
#line 1231
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: I won\'t write compressed data to a terminal.\n",
            progName);
#line 1234
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: For help, type: `%s --help\'.\n",
            progName, progName);
#line 1236
    setExit(1);
    }
#line 1237
    return;
  }
#line 1239
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 1242
  inStr = fopen((char const   */* __restrict  */)(inName), (char const   */* __restrict  */)"rb");
#line 1243
  outStr = stdout;
#line 1244
  tmp___9 = fileno(stdout);
#line 1244
  tmp___10 = isatty(tmp___9);
  }
#line 1244
  if (tmp___10) {
    {
#line 1245
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: I won\'t write compressed data to a terminal.\n",
            progName);
#line 1248
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: For help, type: `%s --help\'.\n",
            progName, progName);
    }
#line 1250
    if ((unsigned long )inStr != (unsigned long )((void *)0)) {
      {
#line 1250
      fclose(inStr);
      }
    }
    {
#line 1251
    setExit(1);
    }
#line 1252
    return;
  }
#line 1254
  if ((unsigned long )inStr == (unsigned long )((void *)0)) {
    {
#line 1255
    tmp___11 = __errno_location();
#line 1255
    tmp___12 = strerror(*tmp___11);
#line 1255
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input file %s: %s.\n",
            progName, inName, tmp___12);
#line 1257
    setExit(1);
    }
#line 1258
    return;
  }
#line 1260
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 1263
  inStr = fopen((char const   */* __restrict  */)(inName), (char const   */* __restrict  */)"rb");
#line 1264
  outStr = fopen_output_safely(outName, "wb");
  }
#line 1265
  if ((unsigned long )outStr == (unsigned long )((void *)0)) {
    {
#line 1266
    tmp___13 = __errno_location();
#line 1266
    tmp___14 = strerror(*tmp___13);
#line 1266
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t create output file %s: %s.\n",
            progName, outName, tmp___14);
    }
#line 1268
    if ((unsigned long )inStr != (unsigned long )((void *)0)) {
      {
#line 1268
      fclose(inStr);
      }
    }
    {
#line 1269
    setExit(1);
    }
#line 1270
    return;
  }
#line 1272
  if ((unsigned long )inStr == (unsigned long )((void *)0)) {
    {
#line 1273
    tmp___15 = __errno_location();
#line 1273
    tmp___16 = strerror(*tmp___15);
#line 1273
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input file %s: %s.\n",
            progName, inName, tmp___16);
    }
#line 1275
    if ((unsigned long )outStr != (unsigned long )((void *)0)) {
      {
#line 1275
      fclose(outStr);
      }
    }
    {
#line 1276
    setExit(1);
    }
#line 1277
    return;
  }
#line 1279
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 1282
  panic("compress: bad srcMode");
  }
#line 1283
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1286
  if (verbosity >= 1) {
    {
#line 1287
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s: ",
            inName);
#line 1288
    pad(inName);
#line 1289
    fflush(stderr);
    }
  }
  {
#line 1293
  outputHandleJustInCase = outStr;
#line 1294
  deleteOutputOnInterrupt = (Bool )1;
#line 1295
  compressStream(inStr, outStr);
#line 1296
  outputHandleJustInCase = (FILE *)((void *)0);
  }
#line 1299
  if (srcMode == 3) {
    {
#line 1300
    applySavedTimeInfoToOutputFile(outName);
#line 1301
    deleteOutputOnInterrupt = (Bool )0;
    }
#line 1302
    if (! keepInputFiles) {
      {
#line 1303
      tmp___17 = remove((char const   *)(inName));
#line 1303
      retVal = tmp___17;
      }
#line 1304
      if (retVal != 0) {
        {
#line 1304
        ioError();
        }
      }
    }
  }
#line 1308
  deleteOutputOnInterrupt = (Bool )0;
#line 1309
  return;
}
}
#line 1313 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void uncompress(Char *name ) 
{ 
  FILE *inStr ;
  FILE *outStr ;
  Int32 n ;
  Int32 i ;
  Bool magicNumberOK ;
  Bool cantGuess ;
  struct stat statBuf ;
  Bool tmp ;
  Bool tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  Bool tmp___3 ;
  Bool tmp___4 ;
  Bool tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  Int32 retVal ;
  int tmp___15 ;
  Int32 retVal___0 ;
  int tmp___16 ;

  {
#line 1323
  deleteOutputOnInterrupt = (Bool )0;
#line 1325
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1325
    if (srcMode != 1) {
      {
#line 1326
      panic("uncompress: bad modes\n");
      }
    }
  }
#line 1328
  cantGuess = (Bool )0;
  {
#line 1330
  if (srcMode == 1) {
#line 1330
    goto case_1;
  }
#line 1334
  if (srcMode == 3) {
#line 1334
    goto case_3;
  }
#line 1343
  if (srcMode == 2) {
#line 1343
    goto case_2;
  }
#line 1329
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1331
  copyFileName(inName, (Char *)"(stdin)");
#line 1332
  copyFileName(outName, (Char *)"(stdout)");
  }
#line 1333
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1335
  copyFileName(inName, name);
#line 1336
  copyFileName(outName, name);
#line 1337
  i = 0;
  }
  {
#line 1337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1337
    if (! (i < 4)) {
#line 1337
      goto while_break;
    }
    {
#line 1338
    tmp = mapSuffix(outName, zSuffix[i], unzSuffix[i]);
    }
#line 1338
    if (tmp) {
#line 1339
      goto zzz;
    }
#line 1337
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1340
  cantGuess = (Bool )1;
#line 1341
  strcat((char */* __restrict  */)(outName), (char const   */* __restrict  */)".out");
  }
#line 1342
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1344
  copyFileName(inName, name);
#line 1345
  copyFileName(outName, (Char *)"(stdout)");
  }
#line 1346
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  zzz: 
#line 1350
  if (srcMode != 1) {
    {
#line 1350
    tmp___0 = containsDubiousChars(inName);
    }
#line 1350
    if (tmp___0) {
#line 1351
      if (noisy) {
        {
#line 1352
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: There are no files matching `%s\'.\n",
                progName, inName);
        }
      }
      {
#line 1354
      setExit(1);
      }
#line 1355
      return;
    }
  }
#line 1357
  if (srcMode != 1) {
    {
#line 1357
    tmp___3 = fileExists(inName);
    }
#line 1357
    if (! tmp___3) {
      {
#line 1358
      tmp___1 = __errno_location();
#line 1358
      tmp___2 = strerror(*tmp___1);
#line 1358
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input file %s: %s.\n",
              progName, inName, tmp___2);
#line 1360
      setExit(1);
      }
#line 1361
      return;
    }
  }
#line 1363
  if (srcMode == 3) {
#line 1363
    goto _L;
  } else
#line 1363
  if (srcMode == 2) {
    _L: /* CIL Label */ 
    {
#line 1364
    stat((char const   */* __restrict  */)(inName), (struct stat */* __restrict  */)(& statBuf));
    }
#line 1365
    if ((statBuf.st_mode & 61440U) == 16384U) {
      {
#line 1366
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s is a directory.\n",
              progName, inName);
#line 1369
      setExit(1);
      }
#line 1370
      return;
    }
  }
#line 1373
  if (srcMode == 3) {
#line 1373
    if (! forceOverwrite) {
      {
#line 1373
      tmp___4 = notAStandardFile(inName);
      }
#line 1373
      if (tmp___4) {
#line 1374
        if (noisy) {
          {
#line 1375
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s is not a normal file.\n",
                  progName, inName);
          }
        }
        {
#line 1377
        setExit(1);
        }
#line 1378
        return;
      }
    }
  }
#line 1380
  if (cantGuess) {
#line 1381
    if (noisy) {
      {
#line 1382
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t guess original name for %s -- using %s\n",
              progName, inName, outName);
      }
    }
  }
#line 1387
  if (srcMode == 3) {
    {
#line 1387
    tmp___5 = fileExists(outName);
    }
#line 1387
    if (tmp___5) {
#line 1388
      if (forceOverwrite) {
        {
#line 1389
        remove((char const   *)(outName));
        }
      } else {
        {
#line 1391
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Output file %s already exists.\n",
                progName, outName);
#line 1393
        setExit(1);
        }
#line 1394
        return;
      }
    }
  }
#line 1397
  if (srcMode == 3) {
#line 1397
    if (! forceOverwrite) {
      {
#line 1397
      n = countHardLinks(inName);
      }
#line 1397
      if (n > 0) {
#line 1399
        if (n > 1) {
#line 1399
          tmp___6 = "s";
        } else {
#line 1399
          tmp___6 = "";
        }
        {
#line 1399
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s has %d other link%s.\n",
                progName, inName, n, tmp___6);
#line 1401
        setExit(1);
        }
#line 1402
        return;
      }
    }
  }
#line 1405
  if (srcMode == 3) {
    {
#line 1408
    saveInputFileMetaInfo(inName);
    }
  }
  {
#line 1413
  if (srcMode == 1) {
#line 1413
    goto case_1___0;
  }
#line 1427
  if (srcMode == 2) {
#line 1427
    goto case_2___0;
  }
#line 1439
  if (srcMode == 3) {
#line 1439
    goto case_3___0;
  }
#line 1458
  goto switch_default;
  case_1___0: /* CIL Label */ 
  {
#line 1414
  inStr = stdin;
#line 1415
  outStr = stdout;
#line 1416
  tmp___7 = fileno(stdin);
#line 1416
  tmp___8 = isatty(tmp___7);
  }
#line 1416
  if (tmp___8) {
    {
#line 1417
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: I won\'t read compressed data from a terminal.\n",
            progName);
#line 1420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: For help, type: `%s --help\'.\n",
            progName, progName);
#line 1422
    setExit(1);
    }
#line 1423
    return;
  }
#line 1425
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 1428
  inStr = fopen((char const   */* __restrict  */)(inName), (char const   */* __restrict  */)"rb");
#line 1429
  outStr = stdout;
  }
#line 1430
  if ((unsigned long )inStr == (unsigned long )((void *)0)) {
    {
#line 1431
    tmp___9 = __errno_location();
#line 1431
    tmp___10 = strerror(*tmp___9);
#line 1431
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input file %s:%s.\n",
            progName, inName, tmp___10);
    }
#line 1433
    if ((unsigned long )inStr != (unsigned long )((void *)0)) {
      {
#line 1433
      fclose(inStr);
      }
    }
    {
#line 1434
    setExit(1);
    }
#line 1435
    return;
  }
#line 1437
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 1440
  inStr = fopen((char const   */* __restrict  */)(inName), (char const   */* __restrict  */)"rb");
#line 1441
  outStr = fopen_output_safely(outName, "wb");
  }
#line 1442
  if ((unsigned long )outStr == (unsigned long )((void *)0)) {
    {
#line 1443
    tmp___11 = __errno_location();
#line 1443
    tmp___12 = strerror(*tmp___11);
#line 1443
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t create output file %s: %s.\n",
            progName, outName, tmp___12);
    }
#line 1445
    if ((unsigned long )inStr != (unsigned long )((void *)0)) {
      {
#line 1445
      fclose(inStr);
      }
    }
    {
#line 1446
    setExit(1);
    }
#line 1447
    return;
  }
#line 1449
  if ((unsigned long )inStr == (unsigned long )((void *)0)) {
    {
#line 1450
    tmp___13 = __errno_location();
#line 1450
    tmp___14 = strerror(*tmp___13);
#line 1450
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input file %s: %s.\n",
            progName, inName, tmp___14);
    }
#line 1452
    if ((unsigned long )outStr != (unsigned long )((void *)0)) {
      {
#line 1452
      fclose(outStr);
      }
    }
    {
#line 1453
    setExit(1);
    }
#line 1454
    return;
  }
#line 1456
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 1459
  panic("uncompress: bad srcMode");
  }
#line 1460
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1463
  if (verbosity >= 1) {
    {
#line 1464
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s: ",
            inName);
#line 1465
    pad(inName);
#line 1466
    fflush(stderr);
    }
  }
  {
#line 1470
  outputHandleJustInCase = outStr;
#line 1471
  deleteOutputOnInterrupt = (Bool )1;
#line 1472
  magicNumberOK = uncompressStream(inStr, outStr);
#line 1473
  outputHandleJustInCase = (FILE *)((void *)0);
  }
#line 1476
  if (magicNumberOK) {
#line 1477
    if (srcMode == 3) {
      {
#line 1478
      applySavedTimeInfoToOutputFile(outName);
#line 1479
      deleteOutputOnInterrupt = (Bool )0;
      }
#line 1480
      if (! keepInputFiles) {
        {
#line 1481
        tmp___15 = remove((char const   *)(inName));
#line 1481
        retVal = tmp___15;
        }
#line 1482
        if (retVal != 0) {
          {
#line 1482
          ioError();
          }
        }
      }
    }
  } else {
#line 1486
    unzFailsExist = (Bool )1;
#line 1487
    deleteOutputOnInterrupt = (Bool )0;
#line 1488
    if (srcMode == 3) {
      {
#line 1489
      tmp___16 = remove((char const   *)(outName));
#line 1489
      retVal___0 = tmp___16;
      }
#line 1490
      if (retVal___0 != 0) {
        {
#line 1490
        ioError();
        }
      }
    }
  }
#line 1493
  deleteOutputOnInterrupt = (Bool )0;
#line 1495
  if (magicNumberOK) {
#line 1496
    if (verbosity >= 1) {
      {
#line 1497
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done\n");
      }
    }
  } else {
    {
#line 1499
    setExit(2);
    }
#line 1500
    if (verbosity >= 1) {
      {
#line 1501
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not a bzip2 file.\n");
      }
    } else {
      {
#line 1502
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is not a bzip2 file.\n",
              progName, inName);
      }
    }
  }
#line 1507
  return;
}
}
#line 1511 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void testf(Char *name ) 
{ 
  FILE *inStr ;
  Bool allOK ;
  struct stat statBuf ;
  Bool tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  Bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 1518
  deleteOutputOnInterrupt = (Bool )0;
#line 1520
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1520
    if (srcMode != 1) {
      {
#line 1521
      panic("testf: bad modes\n");
      }
    }
  }
  {
#line 1523
  copyFileName(outName, (Char *)"(none)");
  }
  {
#line 1525
  if (srcMode == 1) {
#line 1525
    goto case_1;
  }
#line 1526
  if (srcMode == 3) {
#line 1526
    goto case_3;
  }
#line 1527
  if (srcMode == 2) {
#line 1527
    goto case_2;
  }
#line 1524
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1525
  copyFileName(inName, (Char *)"(stdin)");
  }
#line 1525
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1526
  copyFileName(inName, name);
  }
#line 1526
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1527
  copyFileName(inName, name);
  }
#line 1527
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1530
  if (srcMode != 1) {
    {
#line 1530
    tmp = containsDubiousChars(inName);
    }
#line 1530
    if (tmp) {
#line 1531
      if (noisy) {
        {
#line 1532
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: There are no files matching `%s\'.\n",
                progName, inName);
        }
      }
      {
#line 1534
      setExit(1);
      }
#line 1535
      return;
    }
  }
#line 1537
  if (srcMode != 1) {
    {
#line 1537
    tmp___2 = fileExists(inName);
    }
#line 1537
    if (! tmp___2) {
      {
#line 1538
      tmp___0 = __errno_location();
#line 1538
      tmp___1 = strerror(*tmp___0);
#line 1538
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input %s: %s.\n",
              progName, inName, tmp___1);
#line 1540
      setExit(1);
      }
#line 1541
      return;
    }
  }
#line 1543
  if (srcMode != 1) {
    {
#line 1544
    stat((char const   */* __restrict  */)(inName), (struct stat */* __restrict  */)(& statBuf));
    }
#line 1545
    if ((statBuf.st_mode & 61440U) == 16384U) {
      {
#line 1546
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s is a directory.\n",
              progName, inName);
#line 1549
      setExit(1);
      }
#line 1550
      return;
    }
  }
  {
#line 1556
  if (srcMode == 1) {
#line 1556
    goto case_1___0;
  }
#line 1569
  if (srcMode == 3) {
#line 1569
    goto case_3___0;
  }
#line 1569
  if (srcMode == 2) {
#line 1569
    goto case_3___0;
  }
#line 1579
  goto switch_default;
  case_1___0: /* CIL Label */ 
  {
#line 1557
  tmp___3 = fileno(stdin);
#line 1557
  tmp___4 = isatty(tmp___3);
  }
#line 1557
  if (tmp___4) {
    {
#line 1558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: I won\'t read compressed data from a terminal.\n",
            progName);
#line 1561
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: For help, type: `%s --help\'.\n",
            progName, progName);
#line 1563
    setExit(1);
    }
#line 1564
    return;
  }
#line 1566
  inStr = stdin;
#line 1567
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  {
#line 1570
  inStr = fopen((char const   */* __restrict  */)(inName), (char const   */* __restrict  */)"rb");
  }
#line 1571
  if ((unsigned long )inStr == (unsigned long )((void *)0)) {
    {
#line 1572
    tmp___5 = __errno_location();
#line 1572
    tmp___6 = strerror(*tmp___5);
#line 1572
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input file %s:%s.\n",
            progName, inName, tmp___6);
#line 1574
    setExit(1);
    }
#line 1575
    return;
  }
#line 1577
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 1580
  panic("testf: bad srcMode");
  }
#line 1581
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1584
  if (verbosity >= 1) {
    {
#line 1585
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s: ",
            inName);
#line 1586
    pad(inName);
#line 1587
    fflush(stderr);
    }
  }
  {
#line 1591
  outputHandleJustInCase = (FILE *)((void *)0);
#line 1592
  allOK = testStream(inStr);
  }
#line 1594
  if (allOK) {
#line 1594
    if (verbosity >= 1) {
      {
#line 1594
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ok\n");
      }
    }
  }
#line 1595
  if (! allOK) {
#line 1595
    testFailsExist = (Bool )1;
  }
#line 1596
  return;
}
}
#line 1600 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void license(void) 
{ 
  char const   *tmp ;

  {
  {
#line 1603
  tmp = BZ2_bzlibVersion();
#line 1603
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bzip2, a block-sorting file compressor.  Version %s.\n   \n   Copyright (C) 1996-2010 by Julian Seward.\n   \n   This program is free software; you can redistribute it and/or modify\n   it under the terms set out in the LICENSE file, which is included\n   in the bzip2-1.0.6 source distribution.\n   \n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   LICENSE file for more details.\n   \n",
          tmp);
  }
#line 1621
  return;
}
}
#line 1625 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void usage(Char *fullProgName ) 
{ 
  char const   *tmp ;

  {
  {
#line 1628
  tmp = BZ2_bzlibVersion();
#line 1628
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bzip2, a block-sorting file compressor.  Version %s.\n\n   usage: %s [flags and input files in any order]\n\n   -h --help           print this message\n   -d --decompress     force decompression\n   -z --compress       force compression\n   -k --keep           keep (don\'t delete) input files\n   -f --force          overwrite existing output files\n   -t --test           test compressed file integrity\n   -c --stdout         output to standard out\n   -q --quiet          suppress noncritical error messages\n   -v --verbose        be verbose (a 2nd -v gives more)\n   -L --license        display software version & license\n   -V --version        display software version & license\n   -s --small          use less memory (at most 2500k)\n   -1 .. -9            set block size to 100k .. 900k\n   --fast              alias for -1\n   --best              alias for -9\n\n   If invoked as `bzip2\', default action is to compress.\n              as `bunzip2\',  default action is to decompress.\n              as `bzcat\', default action is to decompress to stdout.\n\n   If no file names are given, bzip2 compresses or decompresses\n   from standard input to standard output.  You can combine\n   short flags, so `-v -4\' means the same as -v4 or -4v, &c.\n\n",
          tmp, fullProgName);
  }
#line 1665
  return;
}
}
#line 1669 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void redundant(Char *flag ) 
{ 


  {
  {
#line 1672
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is redundant in versions 0.9.5 and above\n",
          progName, flag);
  }
#line 1676
  return;
}
}
#line 1703 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void *myMalloc(Int32 n ) 
{ 
  void *p ;

  {
  {
#line 1708
  p = malloc((size_t )n);
  }
#line 1709
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 1709
    outOfMemory();
    }
  }
#line 1710
  return (p);
}
}
#line 1715 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static Cell *mkCell(void) 
{ 
  Cell *c ;
  void *tmp ;

  {
  {
#line 1720
  tmp = myMalloc((Int32 )sizeof(Cell ));
#line 1720
  c = (Cell *)tmp;
#line 1721
  c->name = (Char *)((void *)0);
#line 1722
  c->link = (struct zzzz *)((void *)0);
  }
#line 1723
  return (c);
}
}
#line 1728 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static Cell *snocString(Cell *root , Char *name ) 
{ 
  Cell *tmp ;
  Cell *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  Cell *tmp___3 ;

  {
#line 1731
  if ((unsigned long )root == (unsigned long )((void *)0)) {
    {
#line 1732
    tmp___0 = mkCell();
#line 1732
    tmp = tmp___0;
#line 1733
    tmp___1 = strlen((char const   *)name);
#line 1733
    tmp___2 = myMalloc((Int32 )(5UL + tmp___1));
#line 1733
    tmp->name = (Char *)tmp___2;
#line 1734
    strcpy((char */* __restrict  */)tmp->name, (char const   */* __restrict  */)name);
    }
#line 1735
    return (tmp);
  } else {
#line 1737
    tmp___3 = root;
    {
#line 1738
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1738
      if (! ((unsigned long )tmp___3->link != (unsigned long )((void *)0))) {
#line 1738
        goto while_break;
      }
#line 1738
      tmp___3 = tmp___3->link;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1739
    tmp___3->link = snocString(tmp___3->link, name);
    }
#line 1740
    return (root);
  }
}
}
#line 1746 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzip2.c"
static void addFlagsFromEnvVar(Cell **argList , Char *varName ) 
{ 
  Int32 i ;
  Int32 j ;
  Int32 k ;
  Char *envbase ;
  Char *p ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 1752
  envbase = getenv((char const   *)varName);
  }
#line 1753
  if ((unsigned long )envbase != (unsigned long )((void *)0)) {
#line 1754
    p = envbase;
#line 1755
    i = 0;
    {
#line 1756
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1757
      if ((int )*(p + i) == 0) {
#line 1757
        goto while_break;
      }
#line 1758
      p += i;
#line 1759
      i = 0;
      {
#line 1760
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1760
        tmp = __ctype_b_loc();
        }
#line 1760
        if (! ((int const   )*(*tmp + (Int32 )*(p + 0)) & 8192)) {
#line 1760
          goto while_break___0;
        }
#line 1760
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1761
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1761
        if ((int )*(p + i) != 0) {
          {
#line 1761
          tmp___0 = __ctype_b_loc();
          }
#line 1761
          if ((int const   )*(*tmp___0 + (Int32 )*(p + i)) & 8192) {
#line 1761
            goto while_break___1;
          }
        } else {
#line 1761
          goto while_break___1;
        }
#line 1761
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1762
      if (i > 0) {
#line 1763
        k = i;
#line 1763
        if (k > 1024) {
#line 1763
          k = 1024;
        }
#line 1764
        j = 0;
        {
#line 1764
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1764
          if (! (j < k)) {
#line 1764
            goto while_break___2;
          }
#line 1764
          tmpName[j] = *(p + j);
#line 1764
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1765
        tmpName[k] = (Char )0;
#line 1766
        *argList = snocString(*argList, tmpName);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1770
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static int bz_config_ok___0(void) 
{ 


  {
#line 93
  if (sizeof(int ) != 4UL) {
#line 93
    return (0);
  }
#line 94
  if (sizeof(short ) != 2UL) {
#line 94
    return (0);
  }
#line 95
  if (sizeof(char ) != 1UL) {
#line 95
    return (0);
  }
#line 96
  return (1);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static void *default_bzalloc___0(void *opaque , Int32 items , Int32 size ) 
{ 
  void *v ;
  void *tmp ;

  {
  {
#line 104
  tmp = malloc((size_t )(items * size));
#line 104
  v = tmp;
  }
#line 105
  return (v);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static void default_bzfree___0(void *opaque , void *addr ) 
{ 


  {
#line 111
  if ((unsigned long )addr != (unsigned long )((void *)0)) {
    {
#line 111
    free(addr);
    }
  }
#line 112
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static void prepare_new_block___0(EState *s ) 
{ 
  Int32 i ;

  {
#line 120
  s->nblock = 0;
#line 121
  s->numZ = 0;
#line 122
  s->state_out_pos = 0;
#line 123
  s->blockCRC = (UInt32 )4294967295L;
#line 124
  i = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < 256)) {
#line 124
      goto while_break;
    }
#line 124
    s->inUse[i] = (Bool )0;
#line 124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  (s->blockNo) ++;
#line 126
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static void init_RL___0(EState *s ) 
{ 


  {
#line 133
  s->state_in_ch = (UInt32 )256;
#line 134
  s->state_in_len = 0;
#line 135
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static Bool isempty_RL___0(EState *s ) 
{ 


  {
#line 141
  if (s->state_in_ch < 256U) {
#line 141
    if (s->state_in_len > 0) {
#line 142
      return ((Bool )0);
    } else {
#line 143
      return ((Bool )1);
    }
  } else {
#line 143
    return ((Bool )1);
  }
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static void add_pair_to_block___0(EState *s ) 
{ 
  Int32 i ;
  UChar ch ;

  {
#line 219
  ch = (UChar )s->state_in_ch;
#line 220
  i = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (i < s->state_in_len)) {
#line 220
      goto while_break;
    }
#line 221
    s->blockCRC = (s->blockCRC << 8) ^ BZ2_crc32Table[(s->blockCRC >> 24) ^ (unsigned int )ch];
#line 220
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  s->inUse[s->state_in_ch] = (Bool )1;
  {
#line 225
  if (s->state_in_len == 1) {
#line 225
    goto case_1;
  }
#line 228
  if (s->state_in_len == 2) {
#line 228
    goto case_2;
  }
#line 232
  if (s->state_in_len == 3) {
#line 232
    goto case_3;
  }
#line 237
  goto switch_default;
  case_1: /* CIL Label */ 
#line 226
  *(s->block + s->nblock) = ch;
#line 226
  (s->nblock) ++;
#line 227
  goto switch_break;
  case_2: /* CIL Label */ 
#line 229
  *(s->block + s->nblock) = ch;
#line 229
  (s->nblock) ++;
#line 230
  *(s->block + s->nblock) = ch;
#line 230
  (s->nblock) ++;
#line 231
  goto switch_break;
  case_3: /* CIL Label */ 
#line 233
  *(s->block + s->nblock) = ch;
#line 233
  (s->nblock) ++;
#line 234
  *(s->block + s->nblock) = ch;
#line 234
  (s->nblock) ++;
#line 235
  *(s->block + s->nblock) = ch;
#line 235
  (s->nblock) ++;
#line 236
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 238
  s->inUse[s->state_in_len - 4] = (Bool )1;
#line 239
  *(s->block + s->nblock) = ch;
#line 239
  (s->nblock) ++;
#line 240
  *(s->block + s->nblock) = ch;
#line 240
  (s->nblock) ++;
#line 241
  *(s->block + s->nblock) = ch;
#line 241
  (s->nblock) ++;
#line 242
  *(s->block + s->nblock) = ch;
#line 242
  (s->nblock) ++;
#line 243
  *(s->block + s->nblock) = (UChar )(s->state_in_len - 4);
#line 244
  (s->nblock) ++;
#line 245
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 247
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static void flush_RL___0(EState *s ) 
{ 


  {
#line 254
  if (s->state_in_ch < 256U) {
    {
#line 254
    add_pair_to_block___0(s);
    }
  }
  {
#line 255
  init_RL___0(s);
  }
#line 256
  return;
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static Bool copy_input_until_stop___0(EState *s ) 
{ 
  Bool progress_in ;
  UInt32 zchh ;
  UChar ch ;
  UInt32 zchh___0 ;
  UChar ch___0 ;

  {
#line 291
  progress_in = (Bool )0;
#line 293
  if (s->mode == 2) {
    {
#line 296
    while (1) {
      while_continue: /* CIL Label */ ;
#line 298
      if (s->nblock >= s->nblockMAX) {
#line 298
        goto while_break;
      }
#line 300
      if ((s->strm)->avail_in == 0U) {
#line 300
        goto while_break;
      }
#line 301
      progress_in = (Bool )1;
#line 302
      zchh = (UInt32 )*((UChar *)(s->strm)->next_in);
#line 302
      if (zchh != s->state_in_ch) {
#line 302
        if (s->state_in_len == 1) {
#line 302
          ch = (UChar )s->state_in_ch;
#line 302
          s->blockCRC = (s->blockCRC << 8) ^ BZ2_crc32Table[(s->blockCRC >> 24) ^ (unsigned int )ch];
#line 302
          s->inUse[s->state_in_ch] = (Bool )1;
#line 302
          *(s->block + s->nblock) = ch;
#line 302
          (s->nblock) ++;
#line 302
          s->state_in_ch = zchh;
        } else {
#line 302
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 302
      if (zchh != s->state_in_ch) {
#line 302
        goto _L;
      } else
#line 302
      if (s->state_in_len == 255) {
        _L: /* CIL Label */ 
#line 302
        if (s->state_in_ch < 256U) {
          {
#line 302
          add_pair_to_block___0(s);
          }
        }
#line 302
        s->state_in_ch = zchh;
#line 302
        s->state_in_len = 1;
      } else {
#line 302
        (s->state_in_len) ++;
      }
#line 303
      ((s->strm)->next_in) ++;
#line 304
      ((s->strm)->avail_in) --;
#line 305
      ((s->strm)->total_in_lo32) ++;
#line 306
      if ((s->strm)->total_in_lo32 == 0U) {
#line 306
        ((s->strm)->total_in_hi32) ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 312
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 314
      if (s->nblock >= s->nblockMAX) {
#line 314
        goto while_break___0;
      }
#line 316
      if ((s->strm)->avail_in == 0U) {
#line 316
        goto while_break___0;
      }
#line 318
      if (s->avail_in_expect == 0U) {
#line 318
        goto while_break___0;
      }
#line 319
      progress_in = (Bool )1;
#line 320
      zchh___0 = (UInt32 )*((UChar *)(s->strm)->next_in);
#line 320
      if (zchh___0 != s->state_in_ch) {
#line 320
        if (s->state_in_len == 1) {
#line 320
          ch___0 = (UChar )s->state_in_ch;
#line 320
          s->blockCRC = (s->blockCRC << 8) ^ BZ2_crc32Table[(s->blockCRC >> 24) ^ (unsigned int )ch___0];
#line 320
          s->inUse[s->state_in_ch] = (Bool )1;
#line 320
          *(s->block + s->nblock) = ch___0;
#line 320
          (s->nblock) ++;
#line 320
          s->state_in_ch = zchh___0;
        } else {
#line 320
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 320
      if (zchh___0 != s->state_in_ch) {
#line 320
        goto _L___1;
      } else
#line 320
      if (s->state_in_len == 255) {
        _L___1: /* CIL Label */ 
#line 320
        if (s->state_in_ch < 256U) {
          {
#line 320
          add_pair_to_block___0(s);
          }
        }
#line 320
        s->state_in_ch = zchh___0;
#line 320
        s->state_in_len = 1;
      } else {
#line 320
        (s->state_in_len) ++;
      }
#line 321
      ((s->strm)->next_in) ++;
#line 322
      ((s->strm)->avail_in) --;
#line 323
      ((s->strm)->total_in_lo32) ++;
#line 324
      if ((s->strm)->total_in_lo32 == 0U) {
#line 324
        ((s->strm)->total_in_hi32) ++;
      }
#line 325
      (s->avail_in_expect) --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 328
  return (progress_in);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static Bool copy_output_until_stop___0(EState *s ) 
{ 
  Bool progress_out ;

  {
#line 336
  progress_out = (Bool )0;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if ((s->strm)->avail_out == 0U) {
#line 341
      goto while_break;
    }
#line 344
    if (s->state_out_pos >= s->numZ) {
#line 344
      goto while_break;
    }
#line 346
    progress_out = (Bool )1;
#line 347
    *((s->strm)->next_out) = (char )*(s->zbits + s->state_out_pos);
#line 348
    (s->state_out_pos) ++;
#line 349
    ((s->strm)->avail_out) --;
#line 350
    ((s->strm)->next_out) ++;
#line 351
    ((s->strm)->total_out_lo32) ++;
#line 352
    if ((s->strm)->total_out_lo32 == 0U) {
#line 352
      ((s->strm)->total_out_hi32) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return (progress_out);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static Bool handle_compress___0(bz_stream *strm ) 
{ 
  Bool progress_in ;
  Bool progress_out ;
  EState *s ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;
  Bool tmp___2 ;
  int tmp___3 ;

  {
#line 363
  progress_in = (Bool )0;
#line 364
  progress_out = (Bool )0;
#line 365
  s = (EState *)strm->state;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (s->state == 1) {
      {
#line 370
      tmp = copy_output_until_stop___0(s);
#line 370
      progress_out = (Bool )((int )progress_out | (int )tmp);
      }
#line 371
      if (s->state_out_pos < s->numZ) {
#line 371
        goto while_break;
      }
#line 372
      if (s->mode == 4) {
#line 372
        if (s->avail_in_expect == 0U) {
          {
#line 372
          tmp___0 = isempty_RL___0(s);
          }
#line 372
          if (tmp___0) {
#line 374
            goto while_break;
          }
        }
      }
      {
#line 375
      prepare_new_block___0(s);
#line 376
      s->state = 2;
      }
#line 377
      if (s->mode == 3) {
#line 377
        if (s->avail_in_expect == 0U) {
          {
#line 377
          tmp___1 = isempty_RL___0(s);
          }
#line 377
          if (tmp___1) {
#line 379
            goto while_break;
          }
        }
      }
    }
#line 382
    if (s->state == 2) {
      {
#line 383
      tmp___2 = copy_input_until_stop___0(s);
#line 383
      progress_in = (Bool )((int )progress_in | (int )tmp___2);
      }
#line 384
      if (s->mode != 2) {
#line 384
        if (s->avail_in_expect == 0U) {
          {
#line 385
          flush_RL___0(s);
#line 386
          BZ2_compressBlock(s, (Bool )(s->mode == 4));
#line 387
          s->state = 1;
          }
        } else {
#line 384
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 390
      if (s->nblock >= s->nblockMAX) {
        {
#line 391
        BZ2_compressBlock(s, (Bool )0);
#line 392
        s->state = 1;
        }
      } else
#line 395
      if ((s->strm)->avail_in == 0U) {
#line 396
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 402
  if (progress_in) {
#line 402
    tmp___3 = 1;
  } else
#line 402
  if (progress_out) {
#line 402
    tmp___3 = 1;
  } else {
#line 402
    tmp___3 = 0;
  }
#line 402
  return ((Bool )tmp___3);
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static Bool unRLE_obuf_to_output_FAST___0(DState *s ) 
{ 
  UChar k1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  UInt32 c_calculatedBlockCRC ;
  UChar c_state_out_ch ;
  Int32 c_state_out_len ;
  Int32 c_nblock_used ;
  Int32 c_k0 ;
  UInt32 *c_tt ;
  UInt32 c_tPos ;
  char *cs_next_out ;
  unsigned int cs_avail_out ;
  Int32 ro_blockSize100k ;
  UInt32 avail_out_INIT ;
  Int32 s_save_nblockPP ;
  unsigned int total_out_lo32_old ;

  {
#line 540
  if (s->blockRandomised) {
    {
#line 542
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 544
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 545
        if ((s->strm)->avail_out == 0U) {
#line 545
          return ((Bool )0);
        }
#line 546
        if (s->state_out_len == 0) {
#line 546
          goto while_break___0;
        }
#line 547
        *((UChar *)(s->strm)->next_out) = s->state_out_ch;
#line 548
        s->calculatedBlockCRC = (s->calculatedBlockCRC << 8) ^ BZ2_crc32Table[(s->calculatedBlockCRC >> 24) ^ (unsigned int )s->state_out_ch];
#line 549
        (s->state_out_len) --;
#line 550
        ((s->strm)->next_out) ++;
#line 551
        ((s->strm)->avail_out) --;
#line 552
        ((s->strm)->total_out_lo32) ++;
#line 553
        if ((s->strm)->total_out_lo32 == 0U) {
#line 553
          ((s->strm)->total_out_hi32) ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 557
      if (s->nblock_used == s->save_nblock + 1) {
#line 557
        return ((Bool )0);
      }
#line 560
      if (s->nblock_used > s->save_nblock + 1) {
#line 561
        return ((Bool )1);
      }
#line 563
      s->state_out_len = 1;
#line 564
      s->state_out_ch = (UChar )s->k0;
#line 565
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 565
        return ((Bool )1);
      }
#line 565
      s->tPos = *(s->tt + s->tPos);
#line 565
      k1 = (UChar )(s->tPos & 255U);
#line 565
      s->tPos >>= 8;
#line 565
      if (s->rNToGo == 0) {
#line 565
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 565
        (s->rTPos) ++;
#line 565
        if (s->rTPos == 512) {
#line 565
          s->rTPos = 0;
        }
      }
#line 565
      (s->rNToGo) --;
#line 566
      if (s->rNToGo == 1) {
#line 566
        tmp = 1;
      } else {
#line 566
        tmp = 0;
      }
#line 566
      k1 = (UChar )((int )k1 ^ tmp);
#line 566
      (s->nblock_used) ++;
#line 567
      if (s->nblock_used == s->save_nblock + 1) {
#line 567
        goto while_continue;
      }
#line 568
      if ((int )k1 != s->k0) {
#line 568
        s->k0 = (Int32 )k1;
#line 568
        goto while_continue;
      }
#line 570
      s->state_out_len = 2;
#line 571
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 571
        return ((Bool )1);
      }
#line 571
      s->tPos = *(s->tt + s->tPos);
#line 571
      k1 = (UChar )(s->tPos & 255U);
#line 571
      s->tPos >>= 8;
#line 571
      if (s->rNToGo == 0) {
#line 571
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 571
        (s->rTPos) ++;
#line 571
        if (s->rTPos == 512) {
#line 571
          s->rTPos = 0;
        }
      }
#line 571
      (s->rNToGo) --;
#line 572
      if (s->rNToGo == 1) {
#line 572
        tmp___0 = 1;
      } else {
#line 572
        tmp___0 = 0;
      }
#line 572
      k1 = (UChar )((int )k1 ^ tmp___0);
#line 572
      (s->nblock_used) ++;
#line 573
      if (s->nblock_used == s->save_nblock + 1) {
#line 573
        goto while_continue;
      }
#line 574
      if ((int )k1 != s->k0) {
#line 574
        s->k0 = (Int32 )k1;
#line 574
        goto while_continue;
      }
#line 576
      s->state_out_len = 3;
#line 577
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 577
        return ((Bool )1);
      }
#line 577
      s->tPos = *(s->tt + s->tPos);
#line 577
      k1 = (UChar )(s->tPos & 255U);
#line 577
      s->tPos >>= 8;
#line 577
      if (s->rNToGo == 0) {
#line 577
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 577
        (s->rTPos) ++;
#line 577
        if (s->rTPos == 512) {
#line 577
          s->rTPos = 0;
        }
      }
#line 577
      (s->rNToGo) --;
#line 578
      if (s->rNToGo == 1) {
#line 578
        tmp___1 = 1;
      } else {
#line 578
        tmp___1 = 0;
      }
#line 578
      k1 = (UChar )((int )k1 ^ tmp___1);
#line 578
      (s->nblock_used) ++;
#line 579
      if (s->nblock_used == s->save_nblock + 1) {
#line 579
        goto while_continue;
      }
#line 580
      if ((int )k1 != s->k0) {
#line 580
        s->k0 = (Int32 )k1;
#line 580
        goto while_continue;
      }
#line 582
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 582
        return ((Bool )1);
      }
#line 582
      s->tPos = *(s->tt + s->tPos);
#line 582
      k1 = (UChar )(s->tPos & 255U);
#line 582
      s->tPos >>= 8;
#line 582
      if (s->rNToGo == 0) {
#line 582
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 582
        (s->rTPos) ++;
#line 582
        if (s->rTPos == 512) {
#line 582
          s->rTPos = 0;
        }
      }
#line 582
      (s->rNToGo) --;
#line 583
      if (s->rNToGo == 1) {
#line 583
        tmp___2 = 1;
      } else {
#line 583
        tmp___2 = 0;
      }
#line 583
      k1 = (UChar )((int )k1 ^ tmp___2);
#line 583
      (s->nblock_used) ++;
#line 584
      s->state_out_len = (Int32 )k1 + 4;
#line 585
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 585
        return ((Bool )1);
      }
#line 585
      s->tPos = *(s->tt + s->tPos);
#line 585
      s->k0 = (Int32 )((UChar )(s->tPos & 255U));
#line 585
      s->tPos >>= 8;
#line 585
      if (s->rNToGo == 0) {
#line 585
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 585
        (s->rTPos) ++;
#line 585
        if (s->rTPos == 512) {
#line 585
          s->rTPos = 0;
        }
      }
#line 585
      (s->rNToGo) --;
#line 586
      if (s->rNToGo == 1) {
#line 586
        tmp___3 = 1;
      } else {
#line 586
        tmp___3 = 0;
      }
#line 586
      s->k0 ^= tmp___3;
#line 586
      (s->nblock_used) ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 592
    c_calculatedBlockCRC = s->calculatedBlockCRC;
#line 593
    c_state_out_ch = s->state_out_ch;
#line 594
    c_state_out_len = s->state_out_len;
#line 595
    c_nblock_used = s->nblock_used;
#line 596
    c_k0 = s->k0;
#line 597
    c_tt = s->tt;
#line 598
    c_tPos = s->tPos;
#line 599
    cs_next_out = (s->strm)->next_out;
#line 600
    cs_avail_out = (s->strm)->avail_out;
#line 601
    ro_blockSize100k = s->blockSize100k;
#line 604
    avail_out_INIT = cs_avail_out;
#line 605
    s_save_nblockPP = s->save_nblock + 1;
    {
#line 608
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 611
      if (c_state_out_len > 0) {
        {
#line 612
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 613
          if (cs_avail_out == 0U) {
#line 613
            goto return_notr;
          }
#line 614
          if (c_state_out_len == 1) {
#line 614
            goto while_break___2;
          }
#line 615
          *((UChar *)cs_next_out) = c_state_out_ch;
#line 616
          c_calculatedBlockCRC = (c_calculatedBlockCRC << 8) ^ BZ2_crc32Table[(c_calculatedBlockCRC >> 24) ^ (unsigned int )c_state_out_ch];
#line 617
          c_state_out_len --;
#line 618
          cs_next_out ++;
#line 619
          cs_avail_out --;
        }
        while_break___2: /* CIL Label */ ;
        }
        s_state_out_len_eq_one: 
#line 623
        if (cs_avail_out == 0U) {
#line 624
          c_state_out_len = 1;
#line 624
          goto return_notr;
        }
#line 626
        *((UChar *)cs_next_out) = c_state_out_ch;
#line 627
        c_calculatedBlockCRC = (c_calculatedBlockCRC << 8) ^ BZ2_crc32Table[(c_calculatedBlockCRC >> 24) ^ (unsigned int )c_state_out_ch];
#line 628
        cs_next_out ++;
#line 629
        cs_avail_out --;
      }
#line 633
      if (c_nblock_used > s_save_nblockPP) {
#line 634
        return ((Bool )1);
      }
#line 637
      if (c_nblock_used == s_save_nblockPP) {
#line 638
        c_state_out_len = 0;
#line 638
        goto return_notr;
      }
#line 640
      c_state_out_ch = (UChar )c_k0;
#line 641
      if (c_tPos >= 100000U * (UInt32 )ro_blockSize100k) {
#line 641
        return ((Bool )1);
      }
#line 641
      c_tPos = *(c_tt + c_tPos);
#line 641
      k1 = (UChar )(c_tPos & 255U);
#line 641
      c_tPos >>= 8;
#line 641
      c_nblock_used ++;
#line 642
      if ((int )k1 != c_k0) {
#line 643
        c_k0 = (Int32 )k1;
#line 643
        goto s_state_out_len_eq_one;
      }
#line 645
      if (c_nblock_used == s_save_nblockPP) {
#line 646
        goto s_state_out_len_eq_one;
      }
#line 648
      c_state_out_len = 2;
#line 649
      if (c_tPos >= 100000U * (UInt32 )ro_blockSize100k) {
#line 649
        return ((Bool )1);
      }
#line 649
      c_tPos = *(c_tt + c_tPos);
#line 649
      k1 = (UChar )(c_tPos & 255U);
#line 649
      c_tPos >>= 8;
#line 649
      c_nblock_used ++;
#line 650
      if (c_nblock_used == s_save_nblockPP) {
#line 650
        goto while_continue___1;
      }
#line 651
      if ((int )k1 != c_k0) {
#line 651
        c_k0 = (Int32 )k1;
#line 651
        goto while_continue___1;
      }
#line 653
      c_state_out_len = 3;
#line 654
      if (c_tPos >= 100000U * (UInt32 )ro_blockSize100k) {
#line 654
        return ((Bool )1);
      }
#line 654
      c_tPos = *(c_tt + c_tPos);
#line 654
      k1 = (UChar )(c_tPos & 255U);
#line 654
      c_tPos >>= 8;
#line 654
      c_nblock_used ++;
#line 655
      if (c_nblock_used == s_save_nblockPP) {
#line 655
        goto while_continue___1;
      }
#line 656
      if ((int )k1 != c_k0) {
#line 656
        c_k0 = (Int32 )k1;
#line 656
        goto while_continue___1;
      }
#line 658
      if (c_tPos >= 100000U * (UInt32 )ro_blockSize100k) {
#line 658
        return ((Bool )1);
      }
#line 658
      c_tPos = *(c_tt + c_tPos);
#line 658
      k1 = (UChar )(c_tPos & 255U);
#line 658
      c_tPos >>= 8;
#line 658
      c_nblock_used ++;
#line 659
      c_state_out_len = (Int32 )k1 + 4;
#line 660
      if (c_tPos >= 100000U * (UInt32 )ro_blockSize100k) {
#line 660
        return ((Bool )1);
      }
#line 660
      c_tPos = *(c_tt + c_tPos);
#line 660
      c_k0 = (Int32 )((UChar )(c_tPos & 255U));
#line 660
      c_tPos >>= 8;
#line 660
      c_nblock_used ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    return_notr: 
#line 664
    total_out_lo32_old = (s->strm)->total_out_lo32;
#line 665
    (s->strm)->total_out_lo32 += avail_out_INIT - cs_avail_out;
#line 666
    if ((s->strm)->total_out_lo32 < total_out_lo32_old) {
#line 667
      ((s->strm)->total_out_hi32) ++;
    }
#line 670
    s->calculatedBlockCRC = c_calculatedBlockCRC;
#line 671
    s->state_out_ch = c_state_out_ch;
#line 672
    s->state_out_len = c_state_out_len;
#line 673
    s->nblock_used = c_nblock_used;
#line 674
    s->k0 = c_k0;
#line 675
    s->tt = c_tt;
#line 676
    s->tPos = c_tPos;
#line 677
    (s->strm)->next_out = cs_next_out;
#line 678
    (s->strm)->avail_out = cs_avail_out;
  }
#line 681
  return ((Bool )0);
}
}
#line 705 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static Bool unRLE_obuf_to_output_SMALL___0(DState *s ) 
{ 
  UChar k1 ;
  Int32 tmp ;
  int tmp___0 ;
  Int32 tmp___1 ;
  int tmp___2 ;
  Int32 tmp___3 ;
  int tmp___4 ;
  Int32 tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Int32 tmp___8 ;
  Int32 tmp___9 ;
  Int32 tmp___10 ;
  Int32 tmp___11 ;

  {
#line 710
  if (s->blockRandomised) {
    {
#line 712
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 714
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 715
        if ((s->strm)->avail_out == 0U) {
#line 715
          return ((Bool )0);
        }
#line 716
        if (s->state_out_len == 0) {
#line 716
          goto while_break___0;
        }
#line 717
        *((UChar *)(s->strm)->next_out) = s->state_out_ch;
#line 718
        s->calculatedBlockCRC = (s->calculatedBlockCRC << 8) ^ BZ2_crc32Table[(s->calculatedBlockCRC >> 24) ^ (unsigned int )s->state_out_ch];
#line 719
        (s->state_out_len) --;
#line 720
        ((s->strm)->next_out) ++;
#line 721
        ((s->strm)->avail_out) --;
#line 722
        ((s->strm)->total_out_lo32) ++;
#line 723
        if ((s->strm)->total_out_lo32 == 0U) {
#line 723
          ((s->strm)->total_out_hi32) ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 727
      if (s->nblock_used == s->save_nblock + 1) {
#line 727
        return ((Bool )0);
      }
#line 730
      if (s->nblock_used > s->save_nblock + 1) {
#line 731
        return ((Bool )1);
      }
#line 733
      s->state_out_len = 1;
#line 734
      s->state_out_ch = (UChar )s->k0;
#line 735
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 735
        return ((Bool )1);
      }
      {
#line 735
      tmp = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 735
      k1 = (UChar )tmp;
#line 735
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      }
#line 735
      if (s->rNToGo == 0) {
#line 735
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 735
        (s->rTPos) ++;
#line 735
        if (s->rTPos == 512) {
#line 735
          s->rTPos = 0;
        }
      }
#line 735
      (s->rNToGo) --;
#line 736
      if (s->rNToGo == 1) {
#line 736
        tmp___0 = 1;
      } else {
#line 736
        tmp___0 = 0;
      }
#line 736
      k1 = (UChar )((int )k1 ^ tmp___0);
#line 736
      (s->nblock_used) ++;
#line 737
      if (s->nblock_used == s->save_nblock + 1) {
#line 737
        goto while_continue;
      }
#line 738
      if ((int )k1 != s->k0) {
#line 738
        s->k0 = (Int32 )k1;
#line 738
        goto while_continue;
      }
#line 740
      s->state_out_len = 2;
#line 741
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 741
        return ((Bool )1);
      }
      {
#line 741
      tmp___1 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 741
      k1 = (UChar )tmp___1;
#line 741
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      }
#line 741
      if (s->rNToGo == 0) {
#line 741
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 741
        (s->rTPos) ++;
#line 741
        if (s->rTPos == 512) {
#line 741
          s->rTPos = 0;
        }
      }
#line 741
      (s->rNToGo) --;
#line 742
      if (s->rNToGo == 1) {
#line 742
        tmp___2 = 1;
      } else {
#line 742
        tmp___2 = 0;
      }
#line 742
      k1 = (UChar )((int )k1 ^ tmp___2);
#line 742
      (s->nblock_used) ++;
#line 743
      if (s->nblock_used == s->save_nblock + 1) {
#line 743
        goto while_continue;
      }
#line 744
      if ((int )k1 != s->k0) {
#line 744
        s->k0 = (Int32 )k1;
#line 744
        goto while_continue;
      }
#line 746
      s->state_out_len = 3;
#line 747
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 747
        return ((Bool )1);
      }
      {
#line 747
      tmp___3 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 747
      k1 = (UChar )tmp___3;
#line 747
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      }
#line 747
      if (s->rNToGo == 0) {
#line 747
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 747
        (s->rTPos) ++;
#line 747
        if (s->rTPos == 512) {
#line 747
          s->rTPos = 0;
        }
      }
#line 747
      (s->rNToGo) --;
#line 748
      if (s->rNToGo == 1) {
#line 748
        tmp___4 = 1;
      } else {
#line 748
        tmp___4 = 0;
      }
#line 748
      k1 = (UChar )((int )k1 ^ tmp___4);
#line 748
      (s->nblock_used) ++;
#line 749
      if (s->nblock_used == s->save_nblock + 1) {
#line 749
        goto while_continue;
      }
#line 750
      if ((int )k1 != s->k0) {
#line 750
        s->k0 = (Int32 )k1;
#line 750
        goto while_continue;
      }
#line 752
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 752
        return ((Bool )1);
      }
      {
#line 752
      tmp___5 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 752
      k1 = (UChar )tmp___5;
#line 752
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      }
#line 752
      if (s->rNToGo == 0) {
#line 752
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 752
        (s->rTPos) ++;
#line 752
        if (s->rTPos == 512) {
#line 752
          s->rTPos = 0;
        }
      }
#line 752
      (s->rNToGo) --;
#line 753
      if (s->rNToGo == 1) {
#line 753
        tmp___6 = 1;
      } else {
#line 753
        tmp___6 = 0;
      }
#line 753
      k1 = (UChar )((int )k1 ^ tmp___6);
#line 753
      (s->nblock_used) ++;
#line 754
      s->state_out_len = (Int32 )k1 + 4;
#line 755
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 755
        return ((Bool )1);
      }
      {
#line 755
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 755
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
      }
#line 755
      if (s->rNToGo == 0) {
#line 755
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 755
        (s->rTPos) ++;
#line 755
        if (s->rTPos == 512) {
#line 755
          s->rTPos = 0;
        }
      }
#line 755
      (s->rNToGo) --;
#line 756
      if (s->rNToGo == 1) {
#line 756
        tmp___7 = 1;
      } else {
#line 756
        tmp___7 = 0;
      }
#line 756
      s->k0 ^= tmp___7;
#line 756
      (s->nblock_used) ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 761
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 763
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 764
        if ((s->strm)->avail_out == 0U) {
#line 764
          return ((Bool )0);
        }
#line 765
        if (s->state_out_len == 0) {
#line 765
          goto while_break___2;
        }
#line 766
        *((UChar *)(s->strm)->next_out) = s->state_out_ch;
#line 767
        s->calculatedBlockCRC = (s->calculatedBlockCRC << 8) ^ BZ2_crc32Table[(s->calculatedBlockCRC >> 24) ^ (unsigned int )s->state_out_ch];
#line 768
        (s->state_out_len) --;
#line 769
        ((s->strm)->next_out) ++;
#line 770
        ((s->strm)->avail_out) --;
#line 771
        ((s->strm)->total_out_lo32) ++;
#line 772
        if ((s->strm)->total_out_lo32 == 0U) {
#line 772
          ((s->strm)->total_out_hi32) ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 776
      if (s->nblock_used == s->save_nblock + 1) {
#line 776
        return ((Bool )0);
      }
#line 779
      if (s->nblock_used > s->save_nblock + 1) {
#line 780
        return ((Bool )1);
      }
#line 782
      s->state_out_len = 1;
#line 783
      s->state_out_ch = (UChar )s->k0;
#line 784
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 784
        return ((Bool )1);
      }
      {
#line 784
      tmp___8 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 784
      k1 = (UChar )tmp___8;
#line 784
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 784
      (s->nblock_used) ++;
      }
#line 785
      if (s->nblock_used == s->save_nblock + 1) {
#line 785
        goto while_continue___1;
      }
#line 786
      if ((int )k1 != s->k0) {
#line 786
        s->k0 = (Int32 )k1;
#line 786
        goto while_continue___1;
      }
#line 788
      s->state_out_len = 2;
#line 789
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 789
        return ((Bool )1);
      }
      {
#line 789
      tmp___9 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 789
      k1 = (UChar )tmp___9;
#line 789
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 789
      (s->nblock_used) ++;
      }
#line 790
      if (s->nblock_used == s->save_nblock + 1) {
#line 790
        goto while_continue___1;
      }
#line 791
      if ((int )k1 != s->k0) {
#line 791
        s->k0 = (Int32 )k1;
#line 791
        goto while_continue___1;
      }
#line 793
      s->state_out_len = 3;
#line 794
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 794
        return ((Bool )1);
      }
      {
#line 794
      tmp___10 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 794
      k1 = (UChar )tmp___10;
#line 794
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 794
      (s->nblock_used) ++;
      }
#line 795
      if (s->nblock_used == s->save_nblock + 1) {
#line 795
        goto while_continue___1;
      }
#line 796
      if ((int )k1 != s->k0) {
#line 796
        s->k0 = (Int32 )k1;
#line 796
        goto while_continue___1;
      }
#line 798
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 798
        return ((Bool )1);
      }
      {
#line 798
      tmp___11 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 798
      k1 = (UChar )tmp___11;
#line 798
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 798
      (s->nblock_used) ++;
#line 799
      s->state_out_len = (Int32 )k1 + 4;
      }
#line 800
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 800
        return ((Bool )1);
      }
      {
#line 800
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 800
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 800
      (s->nblock_used) ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static Bool myfeof___1(FILE *f ) 
{ 
  Int32 c ;
  int tmp ;

  {
  {
#line 908
  tmp = fgetc(f);
#line 908
  c = tmp;
  }
#line 909
  if (c == -1) {
#line 909
    return ((Bool )1);
  }
  {
#line 910
  ungetc(c, f);
  }
#line 911
  return ((Bool )0);
}
}
#line 1382 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static BZFILE *bzopen_or_bzdopen___0(char const   *path , int fd , char const   *mode ,
                                     int open_mode ) 
{ 
  int bzerr ;
  char unused[5000] ;
  int blockSize100k___0 ;
  int writing ;
  char mode2[10] ;
  unsigned int tmp ;
  FILE *fp ;
  BZFILE *bzfp ;
  int verbosity___0 ;
  int workFactor___0 ;
  int smallMode___0 ;
  int nUnused ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1391
  blockSize100k___0 = 9;
#line 1392
  writing = 0;
#line 1393
  mode2[0] = (char )'\000';
#line 1393
  tmp = 1U;
  {
#line 1393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1393
    if (tmp >= 10U) {
#line 1393
      goto while_break;
    }
#line 1393
    mode2[tmp] = (char)0;
#line 1393
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1394
  fp = (FILE *)((void *)0);
#line 1395
  bzfp = (void *)0;
#line 1396
  verbosity___0 = 0;
#line 1397
  workFactor___0 = 30;
#line 1398
  smallMode___0 = 0;
#line 1399
  nUnused = 0;
#line 1401
  if ((unsigned long )mode == (unsigned long )((void *)0)) {
#line 1401
    return ((void *)0);
  }
  {
#line 1402
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1402
    if (! *mode) {
#line 1402
      goto while_break___0;
    }
    {
#line 1404
    if ((int const   )*mode == 114) {
#line 1404
      goto case_114;
    }
#line 1406
    if ((int const   )*mode == 119) {
#line 1406
      goto case_119;
    }
#line 1408
    if ((int const   )*mode == 115) {
#line 1408
      goto case_115;
    }
#line 1410
    goto switch_default;
    case_114: /* CIL Label */ 
#line 1405
    writing = 0;
#line 1405
    goto switch_break;
    case_119: /* CIL Label */ 
#line 1407
    writing = 1;
#line 1407
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1409
    smallMode___0 = 1;
#line 1409
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1411
    tmp___0 = __ctype_b_loc();
    }
#line 1411
    if ((int const   )*(*tmp___0 + (int )*mode) & 2048) {
#line 1412
      blockSize100k___0 = (int )((int const   )*mode - 48);
    }
    switch_break: /* CIL Label */ ;
    }
#line 1415
    mode ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1417
  if (writing) {
#line 1417
    tmp___1 = "w";
  } else {
#line 1417
    tmp___1 = "r";
  }
  {
#line 1417
  strcat((char */* __restrict  */)(mode2), (char const   */* __restrict  */)tmp___1);
#line 1418
  strcat((char */* __restrict  */)(mode2), (char const   */* __restrict  */)"b");
  }
#line 1420
  if (open_mode == 0) {
#line 1421
    if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 1421
      goto _L;
    } else {
      {
#line 1421
      tmp___2 = strcmp(path, "");
      }
#line 1421
      if (tmp___2 == 0) {
        _L: /* CIL Label */ 
#line 1422
        if (writing) {
#line 1422
          fp = stdout;
        } else {
#line 1422
          fp = stdin;
        }
      } else {
        {
#line 1425
        fp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)(mode2));
        }
      }
    }
  } else {
    {
#line 1431
    fp = fdopen(fd, (char const   *)(mode2));
    }
  }
#line 1434
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1434
    return ((void *)0);
  }
#line 1436
  if (writing) {
#line 1438
    if (blockSize100k___0 < 1) {
#line 1438
      blockSize100k___0 = 1;
    }
#line 1439
    if (blockSize100k___0 > 9) {
#line 1439
      blockSize100k___0 = 9;
    }
    {
#line 1440
    bzfp = BZ2_bzWriteOpen(& bzerr, fp, blockSize100k___0, verbosity___0, workFactor___0);
    }
  } else {
    {
#line 1443
    bzfp = BZ2_bzReadOpen(& bzerr, fp, verbosity___0, smallMode___0, (void *)(unused),
                          nUnused);
    }
  }
#line 1446
  if ((unsigned long )bzfp == (unsigned long )((void *)0)) {
#line 1447
    if ((unsigned long )fp != (unsigned long )stdin) {
#line 1447
      if ((unsigned long )fp != (unsigned long )stdout) {
        {
#line 1447
        fclose(fp);
        }
      }
    }
#line 1448
    return ((void *)0);
  }
#line 1450
  return (bzfp);
}
}
#line 1539 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/bzlib.c"
static char const   *bzerrorstrings___0[16]  = 
#line 1539
  {      "OK",      "SEQUENCE_ERROR",      "PARAM_ERROR",      "MEM_ERROR", 
        "DATA_ERROR",      "DATA_ERROR_MAGIC",      "IO_ERROR",      "UNEXPECTED_EOF", 
        "OUTBUFF_FULL",      "CONFIG_ERROR",      "???",      "???", 
        "???",      "???",      "???",      "???"};
#line 26 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/decompress.c"
static void makeMaps_d___0(DState *s ) 
{ 
  Int32 i ;

  {
#line 30
  s->nInUse = 0;
#line 31
  i = 0;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i < 256)) {
#line 31
      goto while_break;
    }
#line 32
    if (s->inUse[i]) {
#line 33
      s->seqToUnseq[s->nInUse] = (UChar )i;
#line 34
      (s->nInUse) ++;
    }
#line 31
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 36
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/compress.c"
static void bsFinishWrite___0(EState *s ) 
{ 


  {
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (s->bsLive > 0)) {
#line 48
      goto while_break;
    }
#line 49
    *(s->zbits + s->numZ) = (UChar )(s->bsBuff >> 24);
#line 50
    (s->numZ) ++;
#line 51
    s->bsBuff <<= 8;
#line 52
    s->bsLive -= 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/compress.c"
static void bsPutUInt32___1(EState *s , UInt32 u ) 
{ 


  {
  {
#line 85
  bsW(s, 8, (UInt32 )((long )(u >> 24) & 255L));
#line 86
  bsW(s, 8, (UInt32 )((long )(u >> 16) & 255L));
#line 87
  bsW(s, 8, (UInt32 )((long )(u >> 8) & 255L));
#line 88
  bsW(s, 8, (UInt32 )((long )u & 255L));
  }
#line 89
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/compress.c"
static void bsPutUChar___1(EState *s , UChar c ) 
{ 


  {
  {
#line 96
  bsW(s, 8, (UInt32 )c);
  }
#line 97
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/compress.c"
static void makeMaps_e___0(EState *s ) 
{ 
  Int32 i ;

  {
#line 109
  s->nInUse = 0;
#line 110
  i = 0;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (i < 256)) {
#line 110
      goto while_break;
    }
#line 111
    if (s->inUse[i]) {
#line 112
      s->unseqToSeq[i] = (UChar )s->nInUse;
#line 113
      (s->nInUse) ++;
    }
#line 110
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/compress.c"
static void generateMTFValues___0(EState *s ) 
{ 
  UChar yy[256] ;
  Int32 i ;
  Int32 j ;
  Int32 zPend ;
  Int32 wr ;
  Int32 EOB ;
  UInt32 *ptr ;
  UChar *block ;
  UInt16 *mtfv ;
  UChar ll_i ;
  register UChar rtmp ;
  register UChar *ryy_j ;
  register UChar rll_i ;
  register UChar rtmp2 ;

  {
  {
#line 150
  ptr = s->ptr;
#line 151
  block = s->block;
#line 152
  mtfv = s->mtfv;
#line 154
  makeMaps_e___0(s);
#line 155
  EOB = s->nInUse + 1;
#line 157
  i = 0;
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i <= EOB)) {
#line 157
      goto while_break;
    }
#line 157
    s->mtfFreq[i] = 0;
#line 157
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  wr = 0;
#line 160
  zPend = 0;
#line 161
  i = 0;
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 161
    if (! (i < s->nInUse)) {
#line 161
      goto while_break___0;
    }
#line 161
    yy[i] = (UChar )i;
#line 161
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 163
  i = 0;
  {
#line 163
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 163
    if (! (i < s->nblock)) {
#line 163
      goto while_break___1;
    }
#line 166
    j = (Int32 )(*(ptr + i) - 1U);
#line 166
    if (j < 0) {
#line 166
      j += s->nblock;
    }
#line 167
    ll_i = s->unseqToSeq[*(block + j)];
#line 170
    if ((int )yy[0] == (int )ll_i) {
#line 171
      zPend ++;
    } else {
#line 174
      if (zPend > 0) {
#line 175
        zPend --;
        {
#line 176
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 177
          if (zPend & 1) {
#line 178
            *(mtfv + wr) = (UInt16 )1;
#line 178
            wr ++;
#line 179
            (s->mtfFreq[1]) ++;
          } else {
#line 181
            *(mtfv + wr) = (UInt16 )0;
#line 181
            wr ++;
#line 182
            (s->mtfFreq[0]) ++;
          }
#line 184
          if (zPend < 2) {
#line 184
            goto while_break___2;
          }
#line 185
          zPend = (zPend - 2) / 2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 187
        zPend = 0;
      }
#line 193
      rtmp = yy[1];
#line 194
      yy[1] = yy[0];
#line 195
      ryy_j = & yy[1];
#line 196
      rll_i = ll_i;
      {
#line 197
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 197
        if (! ((int )rll_i != (int )rtmp)) {
#line 197
          goto while_break___3;
        }
#line 199
        ryy_j ++;
#line 200
        rtmp2 = rtmp;
#line 201
        rtmp = *ryy_j;
#line 202
        *ryy_j = rtmp2;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 204
      yy[0] = rtmp;
#line 205
      j = (Int32 )(ryy_j - & yy[0]);
#line 206
      *(mtfv + wr) = (UInt16 )(j + 1);
#line 206
      wr ++;
#line 206
      (s->mtfFreq[j + 1]) ++;
    }
#line 163
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 212
  if (zPend > 0) {
#line 213
    zPend --;
    {
#line 214
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 215
      if (zPend & 1) {
#line 216
        *(mtfv + wr) = (UInt16 )1;
#line 216
        wr ++;
#line 217
        (s->mtfFreq[1]) ++;
      } else {
#line 219
        *(mtfv + wr) = (UInt16 )0;
#line 219
        wr ++;
#line 220
        (s->mtfFreq[0]) ++;
      }
#line 222
      if (zPend < 2) {
#line 222
        goto while_break___4;
      }
#line 223
      zPend = (zPend - 2) / 2;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 225
    zPend = 0;
  }
#line 228
  *(mtfv + wr) = (UInt16 )EOB;
#line 228
  wr ++;
#line 228
  (s->mtfFreq[EOB]) ++;
#line 230
  s->nMTF = wr;
#line 231
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/compress.c"
static void sendMTFValues___0(EState *s ) 
{ 
  Int32 v ;
  Int32 t ;
  Int32 i ;
  Int32 j ;
  Int32 gs ;
  Int32 ge ;
  Int32 totc ;
  Int32 bt ;
  Int32 bc ;
  Int32 iter ;
  Int32 nSelectors ;
  Int32 alphaSize ;
  Int32 minLen ;
  Int32 maxLen ;
  Int32 selCtr ;
  Int32 nGroups ;
  Int32 nBytes ;
  UInt16 cost[6] ;
  Int32 fave[6] ;
  UInt16 *mtfv ;
  Int32 nPart ;
  Int32 remF ;
  Int32 tFreq ;
  Int32 aFreq ;
  register UInt32 cost01 ;
  register UInt32 cost23 ;
  register UInt32 cost45 ;
  register UInt16 icv ;
  UInt16 icv___0 ;
  UChar pos[6] ;
  UChar ll_i ;
  UChar tmp2 ;
  UChar tmp ;
  Bool inUse16[16] ;
  Int32 curr ;
  UInt16 mtfv_i ;
  UChar *s_len_sel_selCtr ;
  Int32 *s_code_sel_selCtr ;

  {
#line 259
  mtfv = s->mtfv;
#line 261
  if (s->verbosity >= 3) {
    {
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      %d in block, %d after MTF & 1-2 coding, %d+2 syms in use\n",
            s->nblock, s->nMTF, s->nInUse);
    }
  }
#line 266
  alphaSize = s->nInUse + 2;
#line 267
  t = 0;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! (t < 6)) {
#line 267
      goto while_break;
    }
#line 268
    v = 0;
    {
#line 268
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 268
      if (! (v < alphaSize)) {
#line 268
        goto while_break___0;
      }
#line 269
      s->len[t][v] = (UChar )15;
#line 268
      v ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 267
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  if (! (s->nMTF > 0)) {
    {
#line 272
    BZ2_bz__AssertH__fail(3001);
    }
  }
#line 273
  if (s->nMTF < 200) {
#line 273
    nGroups = 2;
  } else
#line 274
  if (s->nMTF < 600) {
#line 274
    nGroups = 3;
  } else
#line 275
  if (s->nMTF < 1200) {
#line 275
    nGroups = 4;
  } else
#line 276
  if (s->nMTF < 2400) {
#line 276
    nGroups = 5;
  } else {
#line 277
    nGroups = 6;
  }
#line 283
  nPart = nGroups;
#line 284
  remF = s->nMTF;
#line 285
  gs = 0;
  {
#line 286
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 286
    if (! (nPart > 0)) {
#line 286
      goto while_break___1;
    }
#line 287
    tFreq = remF / nPart;
#line 288
    ge = gs - 1;
#line 289
    aFreq = 0;
    {
#line 290
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 290
      if (aFreq < tFreq) {
#line 290
        if (! (ge < alphaSize - 1)) {
#line 290
          goto while_break___2;
        }
      } else {
#line 290
        goto while_break___2;
      }
#line 291
      ge ++;
#line 292
      aFreq += s->mtfFreq[ge];
    }
    while_break___2: /* CIL Label */ ;
    }
#line 295
    if (ge > gs) {
#line 295
      if (nPart != nGroups) {
#line 295
        if (nPart != 1) {
#line 295
          if ((nGroups - nPart) % 2 == 1) {
#line 298
            aFreq -= s->mtfFreq[ge];
#line 299
            ge --;
          }
        }
      }
    }
#line 302
    if (s->verbosity >= 3) {
      {
#line 303
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      initial group %d, [%d .. %d], has %d syms (%4.1f%%)\n",
              nPart, gs, ge, aFreq, (100.0 * (double )((float )aFreq)) / (double )((float )s->nMTF));
      }
    }
#line 308
    v = 0;
    {
#line 308
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 308
      if (! (v < alphaSize)) {
#line 308
        goto while_break___3;
      }
#line 309
      if (v >= gs) {
#line 309
        if (v <= ge) {
#line 310
          s->len[nPart - 1][v] = (UChar )0;
        } else {
#line 311
          s->len[nPart - 1][v] = (UChar )15;
        }
      } else {
#line 311
        s->len[nPart - 1][v] = (UChar )15;
      }
#line 308
      v ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 313
    nPart --;
#line 314
    gs = ge + 1;
#line 315
    remF -= aFreq;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 322
  iter = 0;
  {
#line 322
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 322
    if (! (iter < 4)) {
#line 322
      goto while_break___4;
    }
#line 324
    t = 0;
    {
#line 324
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 324
      if (! (t < nGroups)) {
#line 324
        goto while_break___5;
      }
#line 324
      fave[t] = 0;
#line 324
      t ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 326
    t = 0;
    {
#line 326
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 326
      if (! (t < nGroups)) {
#line 326
        goto while_break___6;
      }
#line 327
      v = 0;
      {
#line 327
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 327
        if (! (v < alphaSize)) {
#line 327
          goto while_break___7;
        }
#line 328
        s->rfreq[t][v] = 0;
#line 327
        v ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 326
      t ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 334
    if (nGroups == 6) {
#line 335
      v = 0;
      {
#line 335
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 335
        if (! (v < alphaSize)) {
#line 335
          goto while_break___8;
        }
#line 336
        s->len_pack[v][0] = (UInt32 )(((int )s->len[1][v] << 16) | (int )s->len[0][v]);
#line 337
        s->len_pack[v][1] = (UInt32 )(((int )s->len[3][v] << 16) | (int )s->len[2][v]);
#line 338
        s->len_pack[v][2] = (UInt32 )(((int )s->len[5][v] << 16) | (int )s->len[4][v]);
#line 335
        v ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 342
    nSelectors = 0;
#line 343
    totc = 0;
#line 344
    gs = 0;
    {
#line 345
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 348
      if (gs >= s->nMTF) {
#line 348
        goto while_break___9;
      }
#line 349
      ge = (gs + 50) - 1;
#line 350
      if (ge >= s->nMTF) {
#line 350
        ge = s->nMTF - 1;
      }
#line 356
      t = 0;
      {
#line 356
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 356
        if (! (t < nGroups)) {
#line 356
          goto while_break___10;
        }
#line 356
        cost[t] = (UInt16 )0;
#line 356
        t ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 358
      if (nGroups == 6) {
#line 358
        if (50 == (ge - gs) + 1) {
#line 362
          cost45 = (UInt32 )0;
#line 362
          cost23 = cost45;
#line 362
          cost01 = cost23;
#line 370
          icv = *(mtfv + gs);
#line 370
          cost01 += s->len_pack[icv][0];
#line 370
          cost23 += s->len_pack[icv][1];
#line 370
          cost45 += s->len_pack[icv][2];
#line 370
          icv = *(mtfv + (gs + 1));
#line 370
          cost01 += s->len_pack[icv][0];
#line 370
          cost23 += s->len_pack[icv][1];
#line 370
          cost45 += s->len_pack[icv][2];
#line 370
          icv = *(mtfv + (gs + 2));
#line 370
          cost01 += s->len_pack[icv][0];
#line 370
          cost23 += s->len_pack[icv][1];
#line 370
          cost45 += s->len_pack[icv][2];
#line 370
          icv = *(mtfv + (gs + 3));
#line 370
          cost01 += s->len_pack[icv][0];
#line 370
          cost23 += s->len_pack[icv][1];
#line 370
          cost45 += s->len_pack[icv][2];
#line 370
          icv = *(mtfv + (gs + 4));
#line 370
          cost01 += s->len_pack[icv][0];
#line 370
          cost23 += s->len_pack[icv][1];
#line 370
          cost45 += s->len_pack[icv][2];
#line 371
          icv = *(mtfv + (gs + 5));
#line 371
          cost01 += s->len_pack[icv][0];
#line 371
          cost23 += s->len_pack[icv][1];
#line 371
          cost45 += s->len_pack[icv][2];
#line 371
          icv = *(mtfv + (gs + 6));
#line 371
          cost01 += s->len_pack[icv][0];
#line 371
          cost23 += s->len_pack[icv][1];
#line 371
          cost45 += s->len_pack[icv][2];
#line 371
          icv = *(mtfv + (gs + 7));
#line 371
          cost01 += s->len_pack[icv][0];
#line 371
          cost23 += s->len_pack[icv][1];
#line 371
          cost45 += s->len_pack[icv][2];
#line 371
          icv = *(mtfv + (gs + 8));
#line 371
          cost01 += s->len_pack[icv][0];
#line 371
          cost23 += s->len_pack[icv][1];
#line 371
          cost45 += s->len_pack[icv][2];
#line 371
          icv = *(mtfv + (gs + 9));
#line 371
          cost01 += s->len_pack[icv][0];
#line 371
          cost23 += s->len_pack[icv][1];
#line 371
          cost45 += s->len_pack[icv][2];
#line 372
          icv = *(mtfv + (gs + 10));
#line 372
          cost01 += s->len_pack[icv][0];
#line 372
          cost23 += s->len_pack[icv][1];
#line 372
          cost45 += s->len_pack[icv][2];
#line 372
          icv = *(mtfv + (gs + 11));
#line 372
          cost01 += s->len_pack[icv][0];
#line 372
          cost23 += s->len_pack[icv][1];
#line 372
          cost45 += s->len_pack[icv][2];
#line 372
          icv = *(mtfv + (gs + 12));
#line 372
          cost01 += s->len_pack[icv][0];
#line 372
          cost23 += s->len_pack[icv][1];
#line 372
          cost45 += s->len_pack[icv][2];
#line 372
          icv = *(mtfv + (gs + 13));
#line 372
          cost01 += s->len_pack[icv][0];
#line 372
          cost23 += s->len_pack[icv][1];
#line 372
          cost45 += s->len_pack[icv][2];
#line 372
          icv = *(mtfv + (gs + 14));
#line 372
          cost01 += s->len_pack[icv][0];
#line 372
          cost23 += s->len_pack[icv][1];
#line 372
          cost45 += s->len_pack[icv][2];
#line 373
          icv = *(mtfv + (gs + 15));
#line 373
          cost01 += s->len_pack[icv][0];
#line 373
          cost23 += s->len_pack[icv][1];
#line 373
          cost45 += s->len_pack[icv][2];
#line 373
          icv = *(mtfv + (gs + 16));
#line 373
          cost01 += s->len_pack[icv][0];
#line 373
          cost23 += s->len_pack[icv][1];
#line 373
          cost45 += s->len_pack[icv][2];
#line 373
          icv = *(mtfv + (gs + 17));
#line 373
          cost01 += s->len_pack[icv][0];
#line 373
          cost23 += s->len_pack[icv][1];
#line 373
          cost45 += s->len_pack[icv][2];
#line 373
          icv = *(mtfv + (gs + 18));
#line 373
          cost01 += s->len_pack[icv][0];
#line 373
          cost23 += s->len_pack[icv][1];
#line 373
          cost45 += s->len_pack[icv][2];
#line 373
          icv = *(mtfv + (gs + 19));
#line 373
          cost01 += s->len_pack[icv][0];
#line 373
          cost23 += s->len_pack[icv][1];
#line 373
          cost45 += s->len_pack[icv][2];
#line 374
          icv = *(mtfv + (gs + 20));
#line 374
          cost01 += s->len_pack[icv][0];
#line 374
          cost23 += s->len_pack[icv][1];
#line 374
          cost45 += s->len_pack[icv][2];
#line 374
          icv = *(mtfv + (gs + 21));
#line 374
          cost01 += s->len_pack[icv][0];
#line 374
          cost23 += s->len_pack[icv][1];
#line 374
          cost45 += s->len_pack[icv][2];
#line 374
          icv = *(mtfv + (gs + 22));
#line 374
          cost01 += s->len_pack[icv][0];
#line 374
          cost23 += s->len_pack[icv][1];
#line 374
          cost45 += s->len_pack[icv][2];
#line 374
          icv = *(mtfv + (gs + 23));
#line 374
          cost01 += s->len_pack[icv][0];
#line 374
          cost23 += s->len_pack[icv][1];
#line 374
          cost45 += s->len_pack[icv][2];
#line 374
          icv = *(mtfv + (gs + 24));
#line 374
          cost01 += s->len_pack[icv][0];
#line 374
          cost23 += s->len_pack[icv][1];
#line 374
          cost45 += s->len_pack[icv][2];
#line 375
          icv = *(mtfv + (gs + 25));
#line 375
          cost01 += s->len_pack[icv][0];
#line 375
          cost23 += s->len_pack[icv][1];
#line 375
          cost45 += s->len_pack[icv][2];
#line 375
          icv = *(mtfv + (gs + 26));
#line 375
          cost01 += s->len_pack[icv][0];
#line 375
          cost23 += s->len_pack[icv][1];
#line 375
          cost45 += s->len_pack[icv][2];
#line 375
          icv = *(mtfv + (gs + 27));
#line 375
          cost01 += s->len_pack[icv][0];
#line 375
          cost23 += s->len_pack[icv][1];
#line 375
          cost45 += s->len_pack[icv][2];
#line 375
          icv = *(mtfv + (gs + 28));
#line 375
          cost01 += s->len_pack[icv][0];
#line 375
          cost23 += s->len_pack[icv][1];
#line 375
          cost45 += s->len_pack[icv][2];
#line 375
          icv = *(mtfv + (gs + 29));
#line 375
          cost01 += s->len_pack[icv][0];
#line 375
          cost23 += s->len_pack[icv][1];
#line 375
          cost45 += s->len_pack[icv][2];
#line 376
          icv = *(mtfv + (gs + 30));
#line 376
          cost01 += s->len_pack[icv][0];
#line 376
          cost23 += s->len_pack[icv][1];
#line 376
          cost45 += s->len_pack[icv][2];
#line 376
          icv = *(mtfv + (gs + 31));
#line 376
          cost01 += s->len_pack[icv][0];
#line 376
          cost23 += s->len_pack[icv][1];
#line 376
          cost45 += s->len_pack[icv][2];
#line 376
          icv = *(mtfv + (gs + 32));
#line 376
          cost01 += s->len_pack[icv][0];
#line 376
          cost23 += s->len_pack[icv][1];
#line 376
          cost45 += s->len_pack[icv][2];
#line 376
          icv = *(mtfv + (gs + 33));
#line 376
          cost01 += s->len_pack[icv][0];
#line 376
          cost23 += s->len_pack[icv][1];
#line 376
          cost45 += s->len_pack[icv][2];
#line 376
          icv = *(mtfv + (gs + 34));
#line 376
          cost01 += s->len_pack[icv][0];
#line 376
          cost23 += s->len_pack[icv][1];
#line 376
          cost45 += s->len_pack[icv][2];
#line 377
          icv = *(mtfv + (gs + 35));
#line 377
          cost01 += s->len_pack[icv][0];
#line 377
          cost23 += s->len_pack[icv][1];
#line 377
          cost45 += s->len_pack[icv][2];
#line 377
          icv = *(mtfv + (gs + 36));
#line 377
          cost01 += s->len_pack[icv][0];
#line 377
          cost23 += s->len_pack[icv][1];
#line 377
          cost45 += s->len_pack[icv][2];
#line 377
          icv = *(mtfv + (gs + 37));
#line 377
          cost01 += s->len_pack[icv][0];
#line 377
          cost23 += s->len_pack[icv][1];
#line 377
          cost45 += s->len_pack[icv][2];
#line 377
          icv = *(mtfv + (gs + 38));
#line 377
          cost01 += s->len_pack[icv][0];
#line 377
          cost23 += s->len_pack[icv][1];
#line 377
          cost45 += s->len_pack[icv][2];
#line 377
          icv = *(mtfv + (gs + 39));
#line 377
          cost01 += s->len_pack[icv][0];
#line 377
          cost23 += s->len_pack[icv][1];
#line 377
          cost45 += s->len_pack[icv][2];
#line 378
          icv = *(mtfv + (gs + 40));
#line 378
          cost01 += s->len_pack[icv][0];
#line 378
          cost23 += s->len_pack[icv][1];
#line 378
          cost45 += s->len_pack[icv][2];
#line 378
          icv = *(mtfv + (gs + 41));
#line 378
          cost01 += s->len_pack[icv][0];
#line 378
          cost23 += s->len_pack[icv][1];
#line 378
          cost45 += s->len_pack[icv][2];
#line 378
          icv = *(mtfv + (gs + 42));
#line 378
          cost01 += s->len_pack[icv][0];
#line 378
          cost23 += s->len_pack[icv][1];
#line 378
          cost45 += s->len_pack[icv][2];
#line 378
          icv = *(mtfv + (gs + 43));
#line 378
          cost01 += s->len_pack[icv][0];
#line 378
          cost23 += s->len_pack[icv][1];
#line 378
          cost45 += s->len_pack[icv][2];
#line 378
          icv = *(mtfv + (gs + 44));
#line 378
          cost01 += s->len_pack[icv][0];
#line 378
          cost23 += s->len_pack[icv][1];
#line 378
          cost45 += s->len_pack[icv][2];
#line 379
          icv = *(mtfv + (gs + 45));
#line 379
          cost01 += s->len_pack[icv][0];
#line 379
          cost23 += s->len_pack[icv][1];
#line 379
          cost45 += s->len_pack[icv][2];
#line 379
          icv = *(mtfv + (gs + 46));
#line 379
          cost01 += s->len_pack[icv][0];
#line 379
          cost23 += s->len_pack[icv][1];
#line 379
          cost45 += s->len_pack[icv][2];
#line 379
          icv = *(mtfv + (gs + 47));
#line 379
          cost01 += s->len_pack[icv][0];
#line 379
          cost23 += s->len_pack[icv][1];
#line 379
          cost45 += s->len_pack[icv][2];
#line 379
          icv = *(mtfv + (gs + 48));
#line 379
          cost01 += s->len_pack[icv][0];
#line 379
          cost23 += s->len_pack[icv][1];
#line 379
          cost45 += s->len_pack[icv][2];
#line 379
          icv = *(mtfv + (gs + 49));
#line 379
          cost01 += s->len_pack[icv][0];
#line 379
          cost23 += s->len_pack[icv][1];
#line 379
          cost45 += s->len_pack[icv][2];
#line 383
          cost[0] = (UInt16 )(cost01 & 65535U);
#line 383
          cost[1] = (UInt16 )(cost01 >> 16);
#line 384
          cost[2] = (UInt16 )(cost23 & 65535U);
#line 384
          cost[3] = (UInt16 )(cost23 >> 16);
#line 385
          cost[4] = (UInt16 )(cost45 & 65535U);
#line 385
          cost[5] = (UInt16 )(cost45 >> 16);
        } else {
#line 358
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 389
        i = gs;
        {
#line 389
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 389
          if (! (i <= ge)) {
#line 389
            goto while_break___11;
          }
#line 390
          icv___0 = *(mtfv + i);
#line 391
          t = 0;
          {
#line 391
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 391
            if (! (t < nGroups)) {
#line 391
              goto while_break___12;
            }
#line 391
            cost[t] = (UInt16 )((int )cost[t] + (int )s->len[t][icv___0]);
#line 391
            t ++;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 389
          i ++;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
#line 399
      bc = 999999999;
#line 399
      bt = -1;
#line 400
      t = 0;
      {
#line 400
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 400
        if (! (t < nGroups)) {
#line 400
          goto while_break___13;
        }
#line 401
        if ((int )cost[t] < bc) {
#line 401
          bc = (Int32 )cost[t];
#line 401
          bt = t;
        }
#line 400
        t ++;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 402
      totc += bc;
#line 403
      (fave[bt]) ++;
#line 404
      s->selector[nSelectors] = (UChar )bt;
#line 405
      nSelectors ++;
#line 410
      if (nGroups == 6) {
#line 410
        if (50 == (ge - gs) + 1) {
#line 415
          (s->rfreq[bt][*(mtfv + gs)]) ++;
#line 415
          (s->rfreq[bt][*(mtfv + (gs + 1))]) ++;
#line 415
          (s->rfreq[bt][*(mtfv + (gs + 2))]) ++;
#line 415
          (s->rfreq[bt][*(mtfv + (gs + 3))]) ++;
#line 415
          (s->rfreq[bt][*(mtfv + (gs + 4))]) ++;
#line 416
          (s->rfreq[bt][*(mtfv + (gs + 5))]) ++;
#line 416
          (s->rfreq[bt][*(mtfv + (gs + 6))]) ++;
#line 416
          (s->rfreq[bt][*(mtfv + (gs + 7))]) ++;
#line 416
          (s->rfreq[bt][*(mtfv + (gs + 8))]) ++;
#line 416
          (s->rfreq[bt][*(mtfv + (gs + 9))]) ++;
#line 417
          (s->rfreq[bt][*(mtfv + (gs + 10))]) ++;
#line 417
          (s->rfreq[bt][*(mtfv + (gs + 11))]) ++;
#line 417
          (s->rfreq[bt][*(mtfv + (gs + 12))]) ++;
#line 417
          (s->rfreq[bt][*(mtfv + (gs + 13))]) ++;
#line 417
          (s->rfreq[bt][*(mtfv + (gs + 14))]) ++;
#line 418
          (s->rfreq[bt][*(mtfv + (gs + 15))]) ++;
#line 418
          (s->rfreq[bt][*(mtfv + (gs + 16))]) ++;
#line 418
          (s->rfreq[bt][*(mtfv + (gs + 17))]) ++;
#line 418
          (s->rfreq[bt][*(mtfv + (gs + 18))]) ++;
#line 418
          (s->rfreq[bt][*(mtfv + (gs + 19))]) ++;
#line 419
          (s->rfreq[bt][*(mtfv + (gs + 20))]) ++;
#line 419
          (s->rfreq[bt][*(mtfv + (gs + 21))]) ++;
#line 419
          (s->rfreq[bt][*(mtfv + (gs + 22))]) ++;
#line 419
          (s->rfreq[bt][*(mtfv + (gs + 23))]) ++;
#line 419
          (s->rfreq[bt][*(mtfv + (gs + 24))]) ++;
#line 420
          (s->rfreq[bt][*(mtfv + (gs + 25))]) ++;
#line 420
          (s->rfreq[bt][*(mtfv + (gs + 26))]) ++;
#line 420
          (s->rfreq[bt][*(mtfv + (gs + 27))]) ++;
#line 420
          (s->rfreq[bt][*(mtfv + (gs + 28))]) ++;
#line 420
          (s->rfreq[bt][*(mtfv + (gs + 29))]) ++;
#line 421
          (s->rfreq[bt][*(mtfv + (gs + 30))]) ++;
#line 421
          (s->rfreq[bt][*(mtfv + (gs + 31))]) ++;
#line 421
          (s->rfreq[bt][*(mtfv + (gs + 32))]) ++;
#line 421
          (s->rfreq[bt][*(mtfv + (gs + 33))]) ++;
#line 421
          (s->rfreq[bt][*(mtfv + (gs + 34))]) ++;
#line 422
          (s->rfreq[bt][*(mtfv + (gs + 35))]) ++;
#line 422
          (s->rfreq[bt][*(mtfv + (gs + 36))]) ++;
#line 422
          (s->rfreq[bt][*(mtfv + (gs + 37))]) ++;
#line 422
          (s->rfreq[bt][*(mtfv + (gs + 38))]) ++;
#line 422
          (s->rfreq[bt][*(mtfv + (gs + 39))]) ++;
#line 423
          (s->rfreq[bt][*(mtfv + (gs + 40))]) ++;
#line 423
          (s->rfreq[bt][*(mtfv + (gs + 41))]) ++;
#line 423
          (s->rfreq[bt][*(mtfv + (gs + 42))]) ++;
#line 423
          (s->rfreq[bt][*(mtfv + (gs + 43))]) ++;
#line 423
          (s->rfreq[bt][*(mtfv + (gs + 44))]) ++;
#line 424
          (s->rfreq[bt][*(mtfv + (gs + 45))]) ++;
#line 424
          (s->rfreq[bt][*(mtfv + (gs + 46))]) ++;
#line 424
          (s->rfreq[bt][*(mtfv + (gs + 47))]) ++;
#line 424
          (s->rfreq[bt][*(mtfv + (gs + 48))]) ++;
#line 424
          (s->rfreq[bt][*(mtfv + (gs + 49))]) ++;
        } else {
#line 410
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 430
        i = gs;
        {
#line 430
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 430
          if (! (i <= ge)) {
#line 430
            goto while_break___14;
          }
#line 431
          (s->rfreq[bt][*(mtfv + i)]) ++;
#line 430
          i ++;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
#line 434
      gs = ge + 1;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 436
    if (s->verbosity >= 3) {
      {
#line 437
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      pass %d: size is %d, grp uses are ",
              iter + 1, totc / 8);
#line 439
      t = 0;
      }
      {
#line 439
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 439
        if (! (t < nGroups)) {
#line 439
          goto while_break___15;
        }
        {
#line 440
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d ",
                fave[t]);
#line 439
        t ++;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 441
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 449
    t = 0;
    {
#line 449
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 449
      if (! (t < nGroups)) {
#line 449
        goto while_break___16;
      }
      {
#line 450
      BZ2_hbMakeCodeLengths(& s->len[t][0], & s->rfreq[t][0], alphaSize, 17);
#line 449
      t ++;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
#line 322
    iter ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 455
  if (! (nGroups < 8)) {
    {
#line 455
    BZ2_bz__AssertH__fail(3002);
    }
  }
#line 456
  if (nSelectors < 32768) {
#line 456
    if (! (nSelectors <= 18002)) {
      {
#line 456
      BZ2_bz__AssertH__fail(3003);
      }
    }
  } else {
    {
#line 456
    BZ2_bz__AssertH__fail(3003);
    }
  }
#line 464
  i = 0;
  {
#line 464
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 464
    if (! (i < nGroups)) {
#line 464
      goto while_break___17;
    }
#line 464
    pos[i] = (UChar )i;
#line 464
    i ++;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 465
  i = 0;
  {
#line 465
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 465
    if (! (i < nSelectors)) {
#line 465
      goto while_break___18;
    }
#line 466
    ll_i = s->selector[i];
#line 467
    j = 0;
#line 468
    tmp = pos[j];
    {
#line 469
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 469
      if (! ((int )ll_i != (int )tmp)) {
#line 469
        goto while_break___19;
      }
#line 470
      j ++;
#line 471
      tmp2 = tmp;
#line 472
      tmp = pos[j];
#line 473
      pos[j] = tmp2;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 475
    pos[0] = tmp;
#line 476
    s->selectorMtf[i] = (UChar )j;
#line 465
    i ++;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 481
  t = 0;
  {
#line 481
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 481
    if (! (t < nGroups)) {
#line 481
      goto while_break___20;
    }
#line 482
    minLen = 32;
#line 483
    maxLen = 0;
#line 484
    i = 0;
    {
#line 484
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 484
      if (! (i < alphaSize)) {
#line 484
        goto while_break___21;
      }
#line 485
      if ((int )s->len[t][i] > maxLen) {
#line 485
        maxLen = (Int32 )s->len[t][i];
      }
#line 486
      if ((int )s->len[t][i] < minLen) {
#line 486
        minLen = (Int32 )s->len[t][i];
      }
#line 484
      i ++;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 488
    if (! (! (maxLen > 17))) {
      {
#line 488
      BZ2_bz__AssertH__fail(3004);
      }
    }
#line 489
    if (! (! (minLen < 1))) {
      {
#line 489
      BZ2_bz__AssertH__fail(3005);
      }
    }
    {
#line 490
    BZ2_hbAssignCodes(& s->code[t][0], & s->len[t][0], minLen, maxLen, alphaSize);
#line 481
    t ++;
    }
  }
  while_break___20: /* CIL Label */ ;
  }
#line 497
  i = 0;
  {
#line 497
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 497
    if (! (i < 16)) {
#line 497
      goto while_break___22;
    }
#line 498
    inUse16[i] = (Bool )0;
#line 499
    j = 0;
    {
#line 499
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 499
      if (! (j < 16)) {
#line 499
        goto while_break___23;
      }
#line 500
      if (s->inUse[i * 16 + j]) {
#line 500
        inUse16[i] = (Bool )1;
      }
#line 499
      j ++;
    }
    while_break___23: /* CIL Label */ ;
    }
#line 497
    i ++;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 503
  nBytes = s->numZ;
#line 504
  i = 0;
  {
#line 504
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 504
    if (! (i < 16)) {
#line 504
      goto while_break___24;
    }
#line 505
    if (inUse16[i]) {
      {
#line 505
      bsW(s, 1, (UInt32 )1);
      }
    } else {
      {
#line 505
      bsW(s, 1, (UInt32 )0);
      }
    }
#line 504
    i ++;
  }
  while_break___24: /* CIL Label */ ;
  }
#line 507
  i = 0;
  {
#line 507
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 507
    if (! (i < 16)) {
#line 507
      goto while_break___25;
    }
#line 508
    if (inUse16[i]) {
#line 509
      j = 0;
      {
#line 509
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 509
        if (! (j < 16)) {
#line 509
          goto while_break___26;
        }
#line 510
        if (s->inUse[i * 16 + j]) {
          {
#line 510
          bsW(s, 1, (UInt32 )1);
          }
        } else {
          {
#line 510
          bsW(s, 1, (UInt32 )0);
          }
        }
#line 509
        j ++;
      }
      while_break___26: /* CIL Label */ ;
      }
    }
#line 507
    i ++;
  }
  while_break___25: /* CIL Label */ ;
  }
#line 513
  if (s->verbosity >= 3) {
    {
#line 514
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      bytes: mapping %d, ",
            s->numZ - nBytes);
    }
  }
  {
#line 518
  nBytes = s->numZ;
#line 519
  bsW(s, 3, (UInt32 )nGroups);
#line 520
  bsW(s, 15, (UInt32 )nSelectors);
#line 521
  i = 0;
  }
  {
#line 521
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 521
    if (! (i < nSelectors)) {
#line 521
      goto while_break___27;
    }
#line 522
    j = 0;
    {
#line 522
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 522
      if (! (j < (Int32 )s->selectorMtf[i])) {
#line 522
        goto while_break___28;
      }
      {
#line 522
      bsW(s, 1, (UInt32 )1);
#line 522
      j ++;
      }
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 523
    bsW(s, 1, (UInt32 )0);
#line 521
    i ++;
    }
  }
  while_break___27: /* CIL Label */ ;
  }
#line 525
  if (s->verbosity >= 3) {
    {
#line 526
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"selectors %d, ",
            s->numZ - nBytes);
    }
  }
#line 529
  nBytes = s->numZ;
#line 531
  t = 0;
  {
#line 531
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 531
    if (! (t < nGroups)) {
#line 531
      goto while_break___29;
    }
    {
#line 532
    curr = (Int32 )s->len[t][0];
#line 533
    bsW(s, 5, (UInt32 )curr);
#line 534
    i = 0;
    }
    {
#line 534
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 534
      if (! (i < alphaSize)) {
#line 534
        goto while_break___30;
      }
      {
#line 535
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 535
        if (! (curr < (Int32 )s->len[t][i])) {
#line 535
          goto while_break___31;
        }
        {
#line 535
        bsW(s, 2, (UInt32 )2);
#line 535
        curr ++;
        }
      }
      while_break___31: /* CIL Label */ ;
      }
      {
#line 536
      while (1) {
        while_continue___32: /* CIL Label */ ;
#line 536
        if (! (curr > (Int32 )s->len[t][i])) {
#line 536
          goto while_break___32;
        }
        {
#line 536
        bsW(s, 2, (UInt32 )3);
#line 536
        curr --;
        }
      }
      while_break___32: /* CIL Label */ ;
      }
      {
#line 537
      bsW(s, 1, (UInt32 )0);
#line 534
      i ++;
      }
    }
    while_break___30: /* CIL Label */ ;
    }
#line 531
    t ++;
  }
  while_break___29: /* CIL Label */ ;
  }
#line 541
  if (s->verbosity >= 3) {
    {
#line 542
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"code lengths %d, ",
            s->numZ - nBytes);
    }
  }
#line 545
  nBytes = s->numZ;
#line 546
  selCtr = 0;
#line 547
  gs = 0;
  {
#line 548
  while (1) {
    while_continue___33: /* CIL Label */ ;
#line 549
    if (gs >= s->nMTF) {
#line 549
      goto while_break___33;
    }
#line 550
    ge = (gs + 50) - 1;
#line 551
    if (ge >= s->nMTF) {
#line 551
      ge = s->nMTF - 1;
    }
#line 552
    if (! ((int )s->selector[selCtr] < nGroups)) {
      {
#line 552
      BZ2_bz__AssertH__fail(3006);
      }
    }
#line 554
    if (nGroups == 6) {
#line 554
      if (50 == (ge - gs) + 1) {
        {
#line 557
        s_len_sel_selCtr = & s->len[s->selector[selCtr]][0];
#line 559
        s_code_sel_selCtr = & s->code[s->selector[selCtr]][0];
#line 568
        mtfv_i = *(mtfv + gs);
#line 568
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 568
        mtfv_i = *(mtfv + (gs + 1));
#line 568
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 568
        mtfv_i = *(mtfv + (gs + 2));
#line 568
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 568
        mtfv_i = *(mtfv + (gs + 3));
#line 568
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 568
        mtfv_i = *(mtfv + (gs + 4));
#line 568
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 569
        mtfv_i = *(mtfv + (gs + 5));
#line 569
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 569
        mtfv_i = *(mtfv + (gs + 6));
#line 569
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 569
        mtfv_i = *(mtfv + (gs + 7));
#line 569
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 569
        mtfv_i = *(mtfv + (gs + 8));
#line 569
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 569
        mtfv_i = *(mtfv + (gs + 9));
#line 569
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 570
        mtfv_i = *(mtfv + (gs + 10));
#line 570
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 570
        mtfv_i = *(mtfv + (gs + 11));
#line 570
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 570
        mtfv_i = *(mtfv + (gs + 12));
#line 570
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 570
        mtfv_i = *(mtfv + (gs + 13));
#line 570
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 570
        mtfv_i = *(mtfv + (gs + 14));
#line 570
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 571
        mtfv_i = *(mtfv + (gs + 15));
#line 571
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 571
        mtfv_i = *(mtfv + (gs + 16));
#line 571
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 571
        mtfv_i = *(mtfv + (gs + 17));
#line 571
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 571
        mtfv_i = *(mtfv + (gs + 18));
#line 571
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 571
        mtfv_i = *(mtfv + (gs + 19));
#line 571
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 572
        mtfv_i = *(mtfv + (gs + 20));
#line 572
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 572
        mtfv_i = *(mtfv + (gs + 21));
#line 572
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 572
        mtfv_i = *(mtfv + (gs + 22));
#line 572
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 572
        mtfv_i = *(mtfv + (gs + 23));
#line 572
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 572
        mtfv_i = *(mtfv + (gs + 24));
#line 572
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 573
        mtfv_i = *(mtfv + (gs + 25));
#line 573
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 573
        mtfv_i = *(mtfv + (gs + 26));
#line 573
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 573
        mtfv_i = *(mtfv + (gs + 27));
#line 573
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 573
        mtfv_i = *(mtfv + (gs + 28));
#line 573
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 573
        mtfv_i = *(mtfv + (gs + 29));
#line 573
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 574
        mtfv_i = *(mtfv + (gs + 30));
#line 574
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 574
        mtfv_i = *(mtfv + (gs + 31));
#line 574
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 574
        mtfv_i = *(mtfv + (gs + 32));
#line 574
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 574
        mtfv_i = *(mtfv + (gs + 33));
#line 574
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 574
        mtfv_i = *(mtfv + (gs + 34));
#line 574
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 575
        mtfv_i = *(mtfv + (gs + 35));
#line 575
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 575
        mtfv_i = *(mtfv + (gs + 36));
#line 575
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 575
        mtfv_i = *(mtfv + (gs + 37));
#line 575
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 575
        mtfv_i = *(mtfv + (gs + 38));
#line 575
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 575
        mtfv_i = *(mtfv + (gs + 39));
#line 575
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 576
        mtfv_i = *(mtfv + (gs + 40));
#line 576
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 576
        mtfv_i = *(mtfv + (gs + 41));
#line 576
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 576
        mtfv_i = *(mtfv + (gs + 42));
#line 576
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 576
        mtfv_i = *(mtfv + (gs + 43));
#line 576
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 576
        mtfv_i = *(mtfv + (gs + 44));
#line 576
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 577
        mtfv_i = *(mtfv + (gs + 45));
#line 577
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 577
        mtfv_i = *(mtfv + (gs + 46));
#line 577
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 577
        mtfv_i = *(mtfv + (gs + 47));
#line 577
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 577
        mtfv_i = *(mtfv + (gs + 48));
#line 577
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 577
        mtfv_i = *(mtfv + (gs + 49));
#line 577
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
        }
      } else {
#line 554
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 583
      i = gs;
      {
#line 583
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 583
        if (! (i <= ge)) {
#line 583
          goto while_break___34;
        }
        {
#line 584
        bsW(s, (Int32 )s->len[s->selector[selCtr]][*(mtfv + i)], (UInt32 )s->code[s->selector[selCtr]][*(mtfv + i)]);
#line 583
        i ++;
        }
      }
      while_break___34: /* CIL Label */ ;
      }
    }
#line 591
    gs = ge + 1;
#line 592
    selCtr ++;
  }
  while_break___33: /* CIL Label */ ;
  }
#line 594
  if (! (selCtr == nSelectors)) {
    {
#line 594
    BZ2_bz__AssertH__fail(3007);
    }
  }
#line 596
  if (s->verbosity >= 3) {
    {
#line 597
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"codes %d\n",
            s->numZ - nBytes);
    }
  }
#line 598
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
static void fallbackQSort3___0(UInt32 *fmap , UInt32 *eclass , Int32 loSt , Int32 hiSt ) 
{ 
  Int32 unLo ;
  Int32 unHi ;
  Int32 ltLo ;
  Int32 gtHi ;
  Int32 n ;
  Int32 m ;
  Int32 sp ;
  Int32 lo ;
  Int32 hi ;
  UInt32 med ;
  UInt32 r ;
  UInt32 r3 ;
  Int32 stackLo[100] ;
  Int32 stackHi[100] ;
  Int32 zztmp ;
  Int32 zztmp___0 ;
  Int32 zztmp___1 ;
  Int32 yyp1 ;
  Int32 yyp2 ;
  Int32 yyn ;
  Int32 zztmp___2 ;
  Int32 yyp1___0 ;
  Int32 yyp2___0 ;
  Int32 yyn___0 ;
  Int32 zztmp___3 ;

  {
#line 104
  r = (UInt32 )0;
#line 106
  sp = 0;
#line 107
  stackLo[sp] = loSt;
#line 107
  stackHi[sp] = hiSt;
#line 107
  sp ++;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (sp > 0)) {
#line 109
      goto while_break;
    }
#line 111
    if (! (sp < 99)) {
      {
#line 111
      BZ2_bz__AssertH__fail(1004);
      }
    }
#line 113
    sp --;
#line 113
    lo = stackLo[sp];
#line 113
    hi = stackHi[sp];
#line 114
    if (hi - lo < 10) {
      {
#line 115
      fallbackSimpleSort(fmap, eclass, lo, hi);
      }
#line 116
      goto while_continue;
    }
#line 126
    r = (r * 7621U + 1U) % 32768U;
#line 127
    r3 = r % 3U;
#line 128
    if (r3 == 0U) {
#line 128
      med = *(eclass + *(fmap + lo));
    } else
#line 129
    if (r3 == 1U) {
#line 129
      med = *(eclass + *(fmap + ((lo + hi) >> 1)));
    } else {
#line 130
      med = *(eclass + *(fmap + hi));
    }
#line 132
    ltLo = lo;
#line 132
    unLo = ltLo;
#line 133
    gtHi = hi;
#line 133
    unHi = gtHi;
    {
#line 135
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 136
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 137
        if (unLo > unHi) {
#line 137
          goto while_break___1;
        }
#line 138
        n = (Int32 )*(eclass + *(fmap + unLo)) - (Int32 )med;
#line 139
        if (n == 0) {
#line 140
          zztmp = (Int32 )*(fmap + unLo);
#line 140
          *(fmap + unLo) = *(fmap + ltLo);
#line 140
          *(fmap + ltLo) = (UInt32 )zztmp;
#line 141
          ltLo ++;
#line 141
          unLo ++;
#line 142
          goto while_continue___1;
        }
#line 144
        if (n > 0) {
#line 144
          goto while_break___1;
        }
#line 145
        unLo ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 147
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 148
        if (unLo > unHi) {
#line 148
          goto while_break___2;
        }
#line 149
        n = (Int32 )*(eclass + *(fmap + unHi)) - (Int32 )med;
#line 150
        if (n == 0) {
#line 151
          zztmp___0 = (Int32 )*(fmap + unHi);
#line 151
          *(fmap + unHi) = *(fmap + gtHi);
#line 151
          *(fmap + gtHi) = (UInt32 )zztmp___0;
#line 152
          gtHi --;
#line 152
          unHi --;
#line 153
          goto while_continue___2;
        }
#line 155
        if (n < 0) {
#line 155
          goto while_break___2;
        }
#line 156
        unHi --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 158
      if (unLo > unHi) {
#line 158
        goto while_break___0;
      }
#line 159
      zztmp___1 = (Int32 )*(fmap + unLo);
#line 159
      *(fmap + unLo) = *(fmap + unHi);
#line 159
      *(fmap + unHi) = (UInt32 )zztmp___1;
#line 159
      unLo ++;
#line 159
      unHi --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 164
    if (gtHi < ltLo) {
#line 164
      goto while_continue;
    }
#line 166
    if (ltLo - lo < unLo - ltLo) {
#line 166
      n = ltLo - lo;
    } else {
#line 166
      n = unLo - ltLo;
    }
#line 166
    yyp1 = lo;
#line 166
    yyp2 = unLo - n;
#line 166
    yyn = n;
    {
#line 166
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 166
      if (! (yyn > 0)) {
#line 166
        goto while_break___3;
      }
#line 166
      zztmp___2 = (Int32 )*(fmap + yyp1);
#line 166
      *(fmap + yyp1) = *(fmap + yyp2);
#line 166
      *(fmap + yyp2) = (UInt32 )zztmp___2;
#line 166
      yyp1 ++;
#line 166
      yyp2 ++;
#line 166
      yyn --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 167
    if (hi - gtHi < gtHi - unHi) {
#line 167
      m = hi - gtHi;
    } else {
#line 167
      m = gtHi - unHi;
    }
#line 167
    yyp1___0 = unLo;
#line 167
    yyp2___0 = (hi - m) + 1;
#line 167
    yyn___0 = m;
    {
#line 167
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 167
      if (! (yyn___0 > 0)) {
#line 167
        goto while_break___4;
      }
#line 167
      zztmp___3 = (Int32 )*(fmap + yyp1___0);
#line 167
      *(fmap + yyp1___0) = *(fmap + yyp2___0);
#line 167
      *(fmap + yyp2___0) = (UInt32 )zztmp___3;
#line 167
      yyp1___0 ++;
#line 167
      yyp2___0 ++;
#line 167
      yyn___0 --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 169
    n = ((lo + unLo) - ltLo) - 1;
#line 170
    m = (hi - (gtHi - unHi)) + 1;
#line 172
    if (n - lo > hi - m) {
#line 173
      stackLo[sp] = lo;
#line 173
      stackHi[sp] = n;
#line 173
      sp ++;
#line 174
      stackLo[sp] = m;
#line 174
      stackHi[sp] = hi;
#line 174
      sp ++;
    } else {
#line 176
      stackLo[sp] = m;
#line 176
      stackHi[sp] = hi;
#line 176
      sp ++;
#line 177
      stackLo[sp] = lo;
#line 177
      stackHi[sp] = n;
#line 177
      sp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return;
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
static void fallbackSort___0(UInt32 *fmap , UInt32 *eclass , UInt32 *bhtab , Int32 nblock ,
                             Int32 verb ) 
{ 
  Int32 ftab[257] ;
  Int32 ftabCopy[256] ;
  Int32 H ;
  Int32 i ;
  Int32 j ;
  Int32 k ;
  Int32 l ;
  Int32 r ;
  Int32 cc ;
  Int32 cc1 ;
  Int32 nNotDone ;
  Int32 nBhtab ;
  UChar *eclass8 ;

  {
#line 223
  eclass8 = (UChar *)eclass;
#line 229
  if (verb >= 4) {
    {
#line 230
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        bucket sorting ...\n");
    }
  }
#line 231
  i = 0;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! (i < 257)) {
#line 231
      goto while_break;
    }
#line 231
    ftab[i] = 0;
#line 231
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  i = 0;
  {
#line 232
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 232
    if (! (i < nblock)) {
#line 232
      goto while_break___0;
    }
#line 232
    (ftab[*(eclass8 + i)]) ++;
#line 232
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 233
  i = 0;
  {
#line 233
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 233
    if (! (i < 256)) {
#line 233
      goto while_break___1;
    }
#line 233
    ftabCopy[i] = ftab[i];
#line 233
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 234
  i = 1;
  {
#line 234
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 234
    if (! (i < 257)) {
#line 234
      goto while_break___2;
    }
#line 234
    ftab[i] += ftab[i - 1];
#line 234
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 236
  i = 0;
  {
#line 236
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 236
    if (! (i < nblock)) {
#line 236
      goto while_break___3;
    }
#line 237
    j = (Int32 )*(eclass8 + i);
#line 238
    k = ftab[j] - 1;
#line 239
    ftab[j] = k;
#line 240
    *(fmap + k) = (UInt32 )i;
#line 236
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 243
  nBhtab = 2 + nblock / 32;
#line 244
  i = 0;
  {
#line 244
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 244
    if (! (i < nBhtab)) {
#line 244
      goto while_break___4;
    }
#line 244
    *(bhtab + i) = (UInt32 )0;
#line 244
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 245
  i = 0;
  {
#line 245
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 245
    if (! (i < 256)) {
#line 245
      goto while_break___5;
    }
#line 245
    *(bhtab + (ftab[i] >> 5)) |= (unsigned int )(1 << (ftab[i] & 31));
#line 245
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 254
  i = 0;
  {
#line 254
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 254
    if (! (i < 32)) {
#line 254
      goto while_break___6;
    }
#line 255
    *(bhtab + ((nblock + 2 * i) >> 5)) |= (unsigned int )(1 << ((nblock + 2 * i) & 31));
#line 256
    *(bhtab + (((nblock + 2 * i) + 1) >> 5)) &= (unsigned int )(~ (1 << (((nblock + 2 * i) + 1) & 31)));
#line 254
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 260
  H = 1;
  {
#line 261
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 263
    if (verb >= 4) {
      {
#line 264
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        depth %6d has ",
              H);
      }
    }
#line 266
    j = 0;
#line 267
    i = 0;
    {
#line 267
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 267
      if (! (i < nblock)) {
#line 267
        goto while_break___8;
      }
#line 268
      if (*(bhtab + (i >> 5)) & (unsigned int )(1 << (i & 31))) {
#line 268
        j = i;
      }
#line 269
      k = (Int32 )(*(fmap + i) - (UInt32 )H);
#line 269
      if (k < 0) {
#line 269
        k += nblock;
      }
#line 270
      *(eclass + k) = (UInt32 )j;
#line 267
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 273
    nNotDone = 0;
#line 274
    r = -1;
    {
#line 275
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 278
      k = r + 1;
      {
#line 279
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 279
        if (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31))) {
#line 279
          if (! (k & 31)) {
#line 279
            goto while_break___10;
          }
        } else {
#line 279
          goto while_break___10;
        }
#line 279
        k ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 280
      if (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31))) {
        {
#line 281
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 281
          if (! (*(bhtab + (k >> 5)) == 4294967295U)) {
#line 281
            goto while_break___11;
          }
#line 281
          k += 32;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 282
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 282
          if (! (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31)))) {
#line 282
            goto while_break___12;
          }
#line 282
          k ++;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
#line 284
      l = k - 1;
#line 285
      if (l >= nblock) {
#line 285
        goto while_break___9;
      }
      {
#line 286
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 286
        if (! (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31)))) {
#line 286
          if (! (k & 31)) {
#line 286
            goto while_break___13;
          }
        } else {
#line 286
          goto while_break___13;
        }
#line 286
        k ++;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 287
      if (! (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31)))) {
        {
#line 288
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 288
          if (! (*(bhtab + (k >> 5)) == 0U)) {
#line 288
            goto while_break___14;
          }
#line 288
          k += 32;
        }
        while_break___14: /* CIL Label */ ;
        }
        {
#line 289
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 289
          if (! (! (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31))))) {
#line 289
            goto while_break___15;
          }
#line 289
          k ++;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
#line 291
      r = k - 1;
#line 292
      if (r >= nblock) {
#line 292
        goto while_break___9;
      }
#line 295
      if (r > l) {
        {
#line 296
        nNotDone += (r - l) + 1;
#line 297
        fallbackQSort3___0(fmap, eclass, l, r);
#line 300
        cc = -1;
#line 301
        i = l;
        }
        {
#line 301
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 301
          if (! (i <= r)) {
#line 301
            goto while_break___16;
          }
#line 302
          cc1 = (Int32 )*(eclass + *(fmap + i));
#line 303
          if (cc != cc1) {
#line 303
            *(bhtab + (i >> 5)) |= (unsigned int )(1 << (i & 31));
#line 303
            cc = cc1;
          }
#line 301
          i ++;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
    }
    while_break___9: /* CIL Label */ ;
    }
#line 308
    if (verb >= 4) {
      {
#line 309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%6d unresolved strings\n",
              nNotDone);
      }
    }
#line 311
    H *= 2;
#line 312
    if (H > nblock) {
#line 312
      goto while_break___7;
    } else
#line 312
    if (nNotDone == 0) {
#line 312
      goto while_break___7;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 320
  if (verb >= 4) {
    {
#line 321
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        reconstructing block ...\n");
    }
  }
#line 322
  j = 0;
#line 323
  i = 0;
  {
#line 323
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 323
    if (! (i < nblock)) {
#line 323
      goto while_break___17;
    }
    {
#line 324
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 324
      if (! (ftabCopy[j] == 0)) {
#line 324
        goto while_break___18;
      }
#line 324
      j ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 325
    (ftabCopy[j]) --;
#line 326
    *(eclass8 + *(fmap + i)) = (UChar )j;
#line 323
    i ++;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 328
  if (! (j < 256)) {
    {
#line 328
    BZ2_bz__AssertH__fail(1005);
    }
  }
#line 329
  return;
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
static Int32 incs___0[14]  = 
#line 479
  {      1,      4,      13,      40, 
        121,      364,      1093,      3280, 
        9841,      29524,      88573,      265720, 
        797161,      2391484};
#line 484 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
static void mainSimpleSort___0(UInt32 *ptr , UChar *block , UInt16 *quadrant , Int32 nblock ,
                               Int32 lo , Int32 hi , Int32 d , Int32 *budget ) 
{ 
  Int32 i ;
  Int32 j ;
  Int32 h ;
  Int32 bigN ;
  Int32 hp ;
  UInt32 v ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;

  {
#line 497
  bigN = (hi - lo) + 1;
#line 498
  if (bigN < 2) {
#line 498
    return;
  }
#line 500
  hp = 0;
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    if (! (incs___0[hp] < bigN)) {
#line 501
      goto while_break;
    }
#line 501
    hp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 502
  hp --;
  {
#line 504
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 504
    if (! (hp >= 0)) {
#line 504
      goto while_break___0;
    }
#line 505
    h = incs___0[hp];
#line 507
    i = lo + h;
    {
#line 508
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 511
      if (i > hi) {
#line 511
        goto while_break___1;
      }
#line 512
      v = *(ptr + i);
#line 513
      j = i;
      {
#line 514
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 514
        tmp = mainGtU(*(ptr + (j - h)) + (UInt32 )d, v + (UInt32 )d, block, quadrant,
                      (UInt32 )nblock, budget);
        }
#line 514
        if (! tmp) {
#line 514
          goto while_break___2;
        }
#line 517
        *(ptr + j) = *(ptr + (j - h));
#line 518
        j -= h;
#line 519
        if (j <= (lo + h) - 1) {
#line 519
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 521
      *(ptr + j) = v;
#line 522
      i ++;
#line 525
      if (i > hi) {
#line 525
        goto while_break___1;
      }
#line 526
      v = *(ptr + i);
#line 527
      j = i;
      {
#line 528
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 528
        tmp___0 = mainGtU(*(ptr + (j - h)) + (UInt32 )d, v + (UInt32 )d, block, quadrant,
                          (UInt32 )nblock, budget);
        }
#line 528
        if (! tmp___0) {
#line 528
          goto while_break___3;
        }
#line 531
        *(ptr + j) = *(ptr + (j - h));
#line 532
        j -= h;
#line 533
        if (j <= (lo + h) - 1) {
#line 533
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 535
      *(ptr + j) = v;
#line 536
      i ++;
#line 539
      if (i > hi) {
#line 539
        goto while_break___1;
      }
#line 540
      v = *(ptr + i);
#line 541
      j = i;
      {
#line 542
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 542
        tmp___1 = mainGtU(*(ptr + (j - h)) + (UInt32 )d, v + (UInt32 )d, block, quadrant,
                          (UInt32 )nblock, budget);
        }
#line 542
        if (! tmp___1) {
#line 542
          goto while_break___4;
        }
#line 545
        *(ptr + j) = *(ptr + (j - h));
#line 546
        j -= h;
#line 547
        if (j <= (lo + h) - 1) {
#line 547
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 549
      *(ptr + j) = v;
#line 550
      i ++;
#line 552
      if (*budget < 0) {
#line 552
        return;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 504
    hp --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 555
  return;
}
}
#line 620 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
static void mainQSort3___0(UInt32 *ptr , UChar *block , UInt16 *quadrant , Int32 nblock ,
                           Int32 loSt , Int32 hiSt , Int32 dSt , Int32 *budget ) 
{ 
  Int32 unLo ;
  Int32 unHi ;
  Int32 ltLo ;
  Int32 gtHi ;
  Int32 n ;
  Int32 m ;
  Int32 med ;
  Int32 sp ;
  Int32 lo ;
  Int32 hi ;
  Int32 d ;
  Int32 stackLo[100] ;
  Int32 stackHi[100] ;
  Int32 stackD[100] ;
  Int32 nextLo[3] ;
  Int32 nextHi[3] ;
  Int32 nextD[3] ;
  UChar tmp ;
  Int32 zztmp ;
  Int32 zztmp___0 ;
  Int32 zztmp___1 ;
  Int32 yyp1 ;
  Int32 yyp2 ;
  Int32 yyn ;
  Int32 zztmp___2 ;
  Int32 yyp1___0 ;
  Int32 yyp2___0 ;
  Int32 yyn___0 ;
  Int32 zztmp___3 ;
  Int32 tz ;
  Int32 tz___0 ;
  Int32 tz___1 ;

  {
#line 641
  sp = 0;
#line 642
  stackLo[sp] = loSt;
#line 642
  stackHi[sp] = hiSt;
#line 642
  stackD[sp] = dSt;
#line 642
  sp ++;
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    if (! (sp > 0)) {
#line 644
      goto while_break;
    }
#line 646
    if (! (sp < 98)) {
      {
#line 646
      BZ2_bz__AssertH__fail(1001);
      }
    }
#line 648
    sp --;
#line 648
    lo = stackLo[sp];
#line 648
    hi = stackHi[sp];
#line 648
    d = stackD[sp];
#line 649
    if (hi - lo < 20) {
#line 649
      goto _L;
    } else
#line 649
    if (d > 14) {
      _L: /* CIL Label */ 
      {
#line 651
      mainSimpleSort___0(ptr, block, quadrant, nblock, lo, hi, d, budget);
      }
#line 652
      if (*budget < 0) {
#line 652
        return;
      }
#line 653
      goto while_continue;
    }
    {
#line 656
    tmp = mmed3(*(block + (*(ptr + lo) + (UInt32 )d)), *(block + (*(ptr + hi) + (UInt32 )d)),
                *(block + (*(ptr + ((lo + hi) >> 1)) + (UInt32 )d)));
#line 656
    med = (Int32 )tmp;
#line 661
    ltLo = lo;
#line 661
    unLo = ltLo;
#line 662
    gtHi = hi;
#line 662
    unHi = gtHi;
    }
    {
#line 664
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 665
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 666
        if (unLo > unHi) {
#line 666
          goto while_break___1;
        }
#line 667
        n = (Int32 )*(block + (*(ptr + unLo) + (UInt32 )d)) - med;
#line 668
        if (n == 0) {
#line 669
          zztmp = (Int32 )*(ptr + unLo);
#line 669
          *(ptr + unLo) = *(ptr + ltLo);
#line 669
          *(ptr + ltLo) = (UInt32 )zztmp;
#line 670
          ltLo ++;
#line 670
          unLo ++;
#line 670
          goto while_continue___1;
        }
#line 672
        if (n > 0) {
#line 672
          goto while_break___1;
        }
#line 673
        unLo ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 675
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 676
        if (unLo > unHi) {
#line 676
          goto while_break___2;
        }
#line 677
        n = (Int32 )*(block + (*(ptr + unHi) + (UInt32 )d)) - med;
#line 678
        if (n == 0) {
#line 679
          zztmp___0 = (Int32 )*(ptr + unHi);
#line 679
          *(ptr + unHi) = *(ptr + gtHi);
#line 679
          *(ptr + gtHi) = (UInt32 )zztmp___0;
#line 680
          gtHi --;
#line 680
          unHi --;
#line 680
          goto while_continue___2;
        }
#line 682
        if (n < 0) {
#line 682
          goto while_break___2;
        }
#line 683
        unHi --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 685
      if (unLo > unHi) {
#line 685
        goto while_break___0;
      }
#line 686
      zztmp___1 = (Int32 )*(ptr + unLo);
#line 686
      *(ptr + unLo) = *(ptr + unHi);
#line 686
      *(ptr + unHi) = (UInt32 )zztmp___1;
#line 686
      unLo ++;
#line 686
      unHi --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 691
    if (gtHi < ltLo) {
#line 692
      stackLo[sp] = lo;
#line 692
      stackHi[sp] = hi;
#line 692
      stackD[sp] = d + 1;
#line 692
      sp ++;
#line 693
      goto while_continue;
    }
#line 696
    if (ltLo - lo < unLo - ltLo) {
#line 696
      n = ltLo - lo;
    } else {
#line 696
      n = unLo - ltLo;
    }
#line 696
    yyp1 = lo;
#line 696
    yyp2 = unLo - n;
#line 696
    yyn = n;
    {
#line 696
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 696
      if (! (yyn > 0)) {
#line 696
        goto while_break___3;
      }
#line 696
      zztmp___2 = (Int32 )*(ptr + yyp1);
#line 696
      *(ptr + yyp1) = *(ptr + yyp2);
#line 696
      *(ptr + yyp2) = (UInt32 )zztmp___2;
#line 696
      yyp1 ++;
#line 696
      yyp2 ++;
#line 696
      yyn --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 697
    if (hi - gtHi < gtHi - unHi) {
#line 697
      m = hi - gtHi;
    } else {
#line 697
      m = gtHi - unHi;
    }
#line 697
    yyp1___0 = unLo;
#line 697
    yyp2___0 = (hi - m) + 1;
#line 697
    yyn___0 = m;
    {
#line 697
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 697
      if (! (yyn___0 > 0)) {
#line 697
        goto while_break___4;
      }
#line 697
      zztmp___3 = (Int32 )*(ptr + yyp1___0);
#line 697
      *(ptr + yyp1___0) = *(ptr + yyp2___0);
#line 697
      *(ptr + yyp2___0) = (UInt32 )zztmp___3;
#line 697
      yyp1___0 ++;
#line 697
      yyp2___0 ++;
#line 697
      yyn___0 --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 699
    n = ((lo + unLo) - ltLo) - 1;
#line 700
    m = (hi - (gtHi - unHi)) + 1;
#line 702
    nextLo[0] = lo;
#line 702
    nextHi[0] = n;
#line 702
    nextD[0] = d;
#line 703
    nextLo[1] = m;
#line 703
    nextHi[1] = hi;
#line 703
    nextD[1] = d;
#line 704
    nextLo[2] = n + 1;
#line 704
    nextHi[2] = m - 1;
#line 704
    nextD[2] = d + 1;
#line 706
    if (nextHi[0] - nextLo[0] < nextHi[1] - nextLo[1]) {
#line 706
      tz = nextLo[0];
#line 706
      nextLo[0] = nextLo[1];
#line 706
      nextLo[1] = tz;
#line 706
      tz = nextHi[0];
#line 706
      nextHi[0] = nextHi[1];
#line 706
      nextHi[1] = tz;
#line 706
      tz = nextD[0];
#line 706
      nextD[0] = nextD[1];
#line 706
      nextD[1] = tz;
    }
#line 707
    if (nextHi[1] - nextLo[1] < nextHi[2] - nextLo[2]) {
#line 707
      tz___0 = nextLo[1];
#line 707
      nextLo[1] = nextLo[2];
#line 707
      nextLo[2] = tz___0;
#line 707
      tz___0 = nextHi[1];
#line 707
      nextHi[1] = nextHi[2];
#line 707
      nextHi[2] = tz___0;
#line 707
      tz___0 = nextD[1];
#line 707
      nextD[1] = nextD[2];
#line 707
      nextD[2] = tz___0;
    }
#line 708
    if (nextHi[0] - nextLo[0] < nextHi[1] - nextLo[1]) {
#line 708
      tz___1 = nextLo[0];
#line 708
      nextLo[0] = nextLo[1];
#line 708
      nextLo[1] = tz___1;
#line 708
      tz___1 = nextHi[0];
#line 708
      nextHi[0] = nextHi[1];
#line 708
      nextHi[1] = tz___1;
#line 708
      tz___1 = nextD[0];
#line 708
      nextD[0] = nextD[1];
#line 708
      nextD[1] = tz___1;
    }
#line 713
    stackLo[sp] = nextLo[0];
#line 713
    stackHi[sp] = nextHi[0];
#line 713
    stackD[sp] = nextD[0];
#line 713
    sp ++;
#line 714
    stackLo[sp] = nextLo[1];
#line 714
    stackHi[sp] = nextHi[1];
#line 714
    stackD[sp] = nextD[1];
#line 714
    sp ++;
#line 715
    stackLo[sp] = nextLo[2];
#line 715
    stackHi[sp] = nextHi[2];
#line 715
    stackD[sp] = nextD[2];
#line 715
    sp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 717
  return;
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/bzip2-1.0.6/blocksort.c"
static void mainSort___0(UInt32 *ptr , UChar *block , UInt16 *quadrant , UInt32 *ftab ,
                         Int32 nblock , Int32 verb , Int32 *budget ) 
{ 
  Int32 i ;
  Int32 j ;
  Int32 k ;
  Int32 ss ;
  Int32 sb ;
  Int32 runningOrder[256] ;
  Bool bigDone[256] ;
  Int32 copyStart[256] ;
  Int32 copyEnd[256] ;
  UChar c1 ;
  Int32 numQSorted ;
  UInt16 s ;
  Int32 vv ;
  Int32 h ;
  Int32 lo ;
  Int32 hi ;
  Int32 tmp ;
  Int32 tmp___0 ;
  Int32 bbStart ;
  Int32 bbSize ;
  Int32 shifts ;
  Int32 a2update ;
  UInt16 qVal ;

  {
#line 767
  if (verb >= 4) {
    {
#line 767
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        main sort initialise ...\n");
    }
  }
#line 770
  i = 65536;
  {
#line 770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 770
    if (! (i >= 0)) {
#line 770
      goto while_break;
    }
#line 770
    *(ftab + i) = (UInt32 )0;
#line 770
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 772
  j = (int )*(block + 0) << 8;
#line 773
  i = nblock - 1;
  {
#line 774
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 774
    if (! (i >= 3)) {
#line 774
      goto while_break___0;
    }
#line 775
    *(quadrant + i) = (UInt16 )0;
#line 776
    j = (j >> 8) | ((int )((UInt16 )*(block + i)) << 8);
#line 777
    (*(ftab + j)) ++;
#line 778
    *(quadrant + (i - 1)) = (UInt16 )0;
#line 779
    j = (j >> 8) | ((int )((UInt16 )*(block + (i - 1))) << 8);
#line 780
    (*(ftab + j)) ++;
#line 781
    *(quadrant + (i - 2)) = (UInt16 )0;
#line 782
    j = (j >> 8) | ((int )((UInt16 )*(block + (i - 2))) << 8);
#line 783
    (*(ftab + j)) ++;
#line 784
    *(quadrant + (i - 3)) = (UInt16 )0;
#line 785
    j = (j >> 8) | ((int )((UInt16 )*(block + (i - 3))) << 8);
#line 786
    (*(ftab + j)) ++;
#line 774
    i -= 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 788
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 788
    if (! (i >= 0)) {
#line 788
      goto while_break___1;
    }
#line 789
    *(quadrant + i) = (UInt16 )0;
#line 790
    j = (j >> 8) | ((int )((UInt16 )*(block + i)) << 8);
#line 791
    (*(ftab + j)) ++;
#line 788
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 795
  i = 0;
  {
#line 795
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 795
    if (! (i < 34)) {
#line 795
      goto while_break___2;
    }
#line 796
    *(block + (nblock + i)) = *(block + i);
#line 797
    *(quadrant + (nblock + i)) = (UInt16 )0;
#line 795
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 800
  if (verb >= 4) {
    {
#line 800
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        bucket sorting ...\n");
    }
  }
#line 803
  i = 1;
  {
#line 803
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 803
    if (! (i <= 65536)) {
#line 803
      goto while_break___3;
    }
#line 803
    *(ftab + i) += *(ftab + (i - 1));
#line 803
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 805
  s = (UInt16 )((int )*(block + 0) << 8);
#line 806
  i = nblock - 1;
  {
#line 807
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 807
    if (! (i >= 3)) {
#line 807
      goto while_break___4;
    }
#line 808
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + i) << 8));
#line 809
    j = (Int32 )(*(ftab + s) - 1U);
#line 810
    *(ftab + s) = (UInt32 )j;
#line 811
    *(ptr + j) = (UInt32 )i;
#line 812
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + (i - 1)) << 8));
#line 813
    j = (Int32 )(*(ftab + s) - 1U);
#line 814
    *(ftab + s) = (UInt32 )j;
#line 815
    *(ptr + j) = (UInt32 )(i - 1);
#line 816
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + (i - 2)) << 8));
#line 817
    j = (Int32 )(*(ftab + s) - 1U);
#line 818
    *(ftab + s) = (UInt32 )j;
#line 819
    *(ptr + j) = (UInt32 )(i - 2);
#line 820
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + (i - 3)) << 8));
#line 821
    j = (Int32 )(*(ftab + s) - 1U);
#line 822
    *(ftab + s) = (UInt32 )j;
#line 823
    *(ptr + j) = (UInt32 )(i - 3);
#line 807
    i -= 4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 825
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 825
    if (! (i >= 0)) {
#line 825
      goto while_break___5;
    }
#line 826
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + i) << 8));
#line 827
    j = (Int32 )(*(ftab + s) - 1U);
#line 828
    *(ftab + s) = (UInt32 )j;
#line 829
    *(ptr + j) = (UInt32 )i;
#line 825
    i --;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 837
  i = 0;
  {
#line 837
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 837
    if (! (i <= 255)) {
#line 837
      goto while_break___6;
    }
#line 838
    bigDone[i] = (Bool )0;
#line 839
    runningOrder[i] = i;
#line 837
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 844
  h = 1;
  {
#line 845
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 845
    h = 3 * h + 1;
#line 845
    if (! (h <= 256)) {
#line 845
      goto while_break___7;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 846
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 847
    h /= 3;
#line 848
    i = h;
    {
#line 848
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 848
      if (! (i <= 255)) {
#line 848
        goto while_break___9;
      }
#line 849
      vv = runningOrder[i];
#line 850
      j = i;
      {
#line 851
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 851
        if (! (*(ftab + ((runningOrder[j - h] + 1) << 8)) - *(ftab + (runningOrder[j - h] << 8)) > *(ftab + ((vv + 1) << 8)) - *(ftab + (vv << 8)))) {
#line 851
          goto while_break___10;
        }
#line 852
        runningOrder[j] = runningOrder[j - h];
#line 853
        j -= h;
#line 854
        if (j <= h - 1) {
#line 854
          goto zero;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      zero: 
#line 857
      runningOrder[j] = vv;
#line 848
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 846
    if (! (h != 1)) {
#line 846
      goto while_break___8;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 866
  numQSorted = 0;
#line 868
  i = 0;
  {
#line 868
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 868
    if (! (i <= 255)) {
#line 868
      goto while_break___11;
    }
#line 876
    ss = runningOrder[i];
#line 886
    j = 0;
    {
#line 886
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 886
      if (! (j <= 255)) {
#line 886
        goto while_break___12;
      }
#line 887
      if (j != ss) {
#line 888
        sb = (ss << 8) + j;
#line 889
        if (! (*(ftab + sb) & (unsigned int )(1 << 21))) {
#line 890
          lo = (Int32 )(*(ftab + sb) & (unsigned int )(~ (1 << 21)));
#line 891
          hi = (Int32 )((*(ftab + (sb + 1)) & (unsigned int )(~ (1 << 21))) - 1U);
#line 892
          if (hi > lo) {
#line 893
            if (verb >= 4) {
              {
#line 894
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        qsort [0x%x, 0x%x]   done %d   this %d\n",
                      ss, j, numQSorted, (hi - lo) + 1);
              }
            }
            {
#line 897
            mainQSort3___0(ptr, block, quadrant, nblock, lo, hi, 2, budget);
#line 901
            numQSorted += (hi - lo) + 1;
            }
#line 902
            if (*budget < 0) {
#line 902
              return;
            }
          }
        }
#line 905
        *(ftab + sb) |= (unsigned int )(1 << 21);
      }
#line 886
      j ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 909
    if (! (! bigDone[ss])) {
      {
#line 909
      BZ2_bz__AssertH__fail(1006);
      }
    }
#line 919
    j = 0;
    {
#line 919
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 919
      if (! (j <= 255)) {
#line 919
        goto while_break___13;
      }
#line 920
      copyStart[j] = (Int32 )(*(ftab + ((j << 8) + ss)) & (unsigned int )(~ (1 << 21)));
#line 921
      copyEnd[j] = (Int32 )((*(ftab + (((j << 8) + ss) + 1)) & (unsigned int )(~ (1 << 21))) - 1U);
#line 919
      j ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 923
    j = (Int32 )(*(ftab + (ss << 8)) & (unsigned int )(~ (1 << 21)));
    {
#line 923
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 923
      if (! (j < copyStart[ss])) {
#line 923
        goto while_break___14;
      }
#line 924
      k = (Int32 )(*(ptr + j) - 1U);
#line 924
      if (k < 0) {
#line 924
        k += nblock;
      }
#line 925
      c1 = *(block + k);
#line 926
      if (! bigDone[c1]) {
#line 927
        tmp = copyStart[c1];
#line 927
        (copyStart[c1]) ++;
#line 927
        *(ptr + tmp) = (UInt32 )k;
      }
#line 923
      j ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 929
    j = (Int32 )((*(ftab + ((ss + 1) << 8)) & (unsigned int )(~ (1 << 21))) - 1U);
    {
#line 929
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 929
      if (! (j > copyEnd[ss])) {
#line 929
        goto while_break___15;
      }
#line 930
      k = (Int32 )(*(ptr + j) - 1U);
#line 930
      if (k < 0) {
#line 930
        k += nblock;
      }
#line 931
      c1 = *(block + k);
#line 932
      if (! bigDone[c1]) {
#line 933
        tmp___0 = copyEnd[c1];
#line 933
        (copyEnd[c1]) --;
#line 933
        *(ptr + tmp___0) = (UInt32 )k;
      }
#line 929
      j --;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 937
    if (! (copyStart[ss] - 1 == copyEnd[ss])) {
#line 937
      if (copyStart[ss] == 0) {
#line 937
        if (! (copyEnd[ss] == nblock - 1)) {
          {
#line 937
          BZ2_bz__AssertH__fail(1007);
          }
        }
      } else {
        {
#line 937
        BZ2_bz__AssertH__fail(1007);
        }
      }
    }
#line 946
    j = 0;
    {
#line 946
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 946
      if (! (j <= 255)) {
#line 946
        goto while_break___16;
      }
#line 946
      *(ftab + ((j << 8) + ss)) |= (unsigned int )(1 << 21);
#line 946
      j ++;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 987
    bigDone[ss] = (Bool )1;
#line 989
    if (i < 255) {
#line 990
      bbStart = (Int32 )(*(ftab + (ss << 8)) & (unsigned int )(~ (1 << 21)));
#line 991
      bbSize = (Int32 )((*(ftab + ((ss + 1) << 8)) & (unsigned int )(~ (1 << 21))) - (unsigned int )bbStart);
#line 992
      shifts = 0;
      {
#line 994
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 994
        if (! (bbSize >> shifts > 65534)) {
#line 994
          goto while_break___17;
        }
#line 994
        shifts ++;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 996
      j = bbSize - 1;
      {
#line 996
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 996
        if (! (j >= 0)) {
#line 996
          goto while_break___18;
        }
#line 997
        a2update = (Int32 )*(ptr + (bbStart + j));
#line 998
        qVal = (UInt16 )(j >> shifts);
#line 999
        *(quadrant + a2update) = qVal;
#line 1000
        if (a2update < 34) {
#line 1001
          *(quadrant + (a2update + nblock)) = qVal;
        }
#line 996
        j --;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 1003
      if (! ((bbSize - 1) >> shifts <= 65535)) {
        {
#line 1003
        BZ2_bz__AssertH__fail(1002);
        }
      }
    }
#line 868
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1008
  if (verb >= 4) {
    {
#line 1009
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        %d pointers, %d sorted, %d scanned\n",
            nblock, numQSorted, nblock - numQSorted);
    }
  }
#line 1011
  return;
}
}
