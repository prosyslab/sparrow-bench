/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 87 "/usr/include/linux/fd.h"
struct floppy_max_errors {
   unsigned int abort ;
   unsigned int read_track ;
   unsigned int reset ;
   unsigned int recal ;
   unsigned int reporting ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 169 "/usr/include/linux/cdrom.h"
struct cdrom_msf {
   __u8 cdmsf_min0 ;
   __u8 cdmsf_sec0 ;
   __u8 cdmsf_frame0 ;
   __u8 cdmsf_min1 ;
   __u8 cdmsf_sec1 ;
   __u8 cdmsf_frame1 ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 93 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off64_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 20 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/mergebad.c"
struct __anonstruct_badblock_28 {
   off64_t offset ;
   off64_t block_size ;
};
#line 20 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/mergebad.c"
typedef struct __anonstruct_badblock_28 badblock;
#line 26 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/mergebad.c"
struct __anonstruct_image_29 {
   badblock *bb_list ;
   int bb_list_size ;
   int fd ;
   char *filename ;
   off64_t size ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/mergebad.c"
typedef struct __anonstruct_image_29 image;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/dev.h"
int init_device(int fd , int dev_type , int rotation_speed ) ;
#line 20
int clear_buffers(int fd , int dev_type ) ;
#line 21
int reset_controller(int fd , int dev_type ) ;
#line 22
int reset_device(int fd , int dev_type ) ;
#line 23
int read_raw_cd(int fd , unsigned char minute , unsigned char second , unsigned char frame ,
                char *whereto ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/dev.c"
int init_device(int fd , int dev_type , int rotation_speed ) 
{ 
  struct floppy_max_errors fme ;
  int tmp ;
  int tmp___0 ;
  int speed ;
  int tmp___1 ;

  {
  {
#line 30
  if (dev_type == 10) {
#line 30
    goto case_10;
  }
#line 50
  if (dev_type == 31) {
#line 50
    goto case_31;
  }
#line 50
  if (dev_type == 30) {
#line 50
    goto case_31;
  }
#line 50
  if (dev_type == 21) {
#line 50
    goto case_31;
  }
#line 50
  if (dev_type == 20) {
#line 50
    goto case_31;
  }
#line 28
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 33
  tmp = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 14U) | (sizeof(struct floppy_max_errors ) << 16),
              & fme, sizeof(fme));
  }
#line 33
  if (tmp == -1) {
    {
#line 35
    perror("FDGETMAXERRS");
    }
#line 36
    return (-1);
  }
  {
#line 38
  fme.reset = 2U;
#line 39
  fme.recal = 3U;
#line 40
  tmp___0 = ioctl(fd, (unsigned long )(((1U << 30) | (unsigned int )(2 << 8)) | 76U) | (sizeof(struct floppy_max_errors ) << 16),
                  & fme, sizeof(fme));
  }
#line 40
  if (tmp___0 == -1) {
    {
#line 42
    perror("FDSETMAXERRS");
    }
#line 43
    return (-1);
  }
#line 46
  goto switch_break;
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  {
#line 52
  speed = rotation_speed;
#line 53
  tmp___1 = ioctl(fd, 21282UL, speed);
  }
#line 53
  if (tmp___1 == -1) {
    {
#line 55
    perror("CDROM_SELECT_SPEED");
    }
#line 56
    return (-1);
  }
#line 59
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 63
  return (0);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/dev.c"
int clear_buffers(int fd , int dev_type ) 
{ 
  int tmp ;

  {
  {
#line 71
  if (dev_type == 10) {
#line 71
    goto case_10;
  }
#line 69
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 72
  tmp = ioctl(fd, (unsigned long )((unsigned int )(2 << 8) | 75U));
  }
#line 72
  if (tmp == -1) {
    {
#line 74
    perror("FDFLUSH");
    }
#line 75
    return (-1);
  }
#line 77
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 81
  return (0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/dev.c"
int reset_controller(int fd , int dev_type ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 89
  if (dev_type == 10) {
#line 89
    goto case_10;
  }
#line 97
  if (dev_type == 41) {
#line 97
    goto case_41;
  }
#line 87
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 90
  tmp = ioctl(fd, (unsigned long )((unsigned int )(2 << 8) | 84U));
  }
#line 90
  if (tmp == -1) {
    {
#line 92
    perror("FDRESET");
    }
#line 93
    return (-1);
  }
#line 95
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 98
  tmp___0 = ioctl(fd, 8836UL);
  }
#line 98
  if (tmp___0 == -1) {
    {
#line 100
    perror("SG_SCSI_RESET");
    }
#line 101
    return (-1);
  }
#line 103
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 107
  return (0);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/dev.c"
int reset_device(int fd , int dev_type ) 
{ 
  int tmp ;

  {
  {
#line 115
  if (dev_type == 40) {
#line 115
    goto case_40;
  }
#line 125
  if (dev_type == 41) {
#line 125
    goto case_41;
  }
#line 145
  if (dev_type == 31) {
#line 145
    goto case_31;
  }
#line 145
  if (dev_type == 30) {
#line 145
    goto case_31;
  }
#line 145
  if (dev_type == 21) {
#line 145
    goto case_31;
  }
#line 145
  if (dev_type == 20) {
#line 145
    goto case_31;
  }
#line 113
  goto switch_break;
  case_40: /* CIL Label */ 
#line 123
  goto switch_break;
  case_41: /* CIL Label */ 
#line 141
  goto switch_break;
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  {
#line 146
  tmp = ioctl(fd, 21266UL);
  }
#line 146
  if (tmp == -1) {
    {
#line 148
    perror("CDROMRESET");
    }
#line 149
    return (-1);
  }
#line 151
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 155
  return (0);
}
}
#line 174
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 158 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/dev.c"
int read_raw_cd(int fd , unsigned char minute , unsigned char second , unsigned char frame ,
                char *whereto ) 
{ 
  char *pframe ;
  void *tmp ;
  struct cdrom_msf *msf ;
  __u8 tmp___0 ;
  __u8 tmp___1 ;
  __u8 tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 161
  tmp = malloc((size_t )2646);
#line 161
  pframe = (char *)tmp;
#line 162
  msf = (struct cdrom_msf *)pframe;
#line 164
  tmp___0 = minute;
#line 164
  msf->cdmsf_min1 = tmp___0;
#line 164
  msf->cdmsf_min0 = tmp___0;
#line 165
  tmp___1 = second;
#line 165
  msf->cdmsf_sec1 = tmp___1;
#line 165
  msf->cdmsf_sec0 = tmp___1;
#line 166
  tmp___2 = frame;
#line 166
  msf->cdmsf_frame1 = tmp___2;
#line 166
  msf->cdmsf_frame0 = tmp___2;
#line 168
  tmp___4 = ioctl(fd, 21268UL, msf);
  }
#line 168
  if (tmp___4 == -1) {
    {
#line 170
    tmp___3 = __errno_location();
    }
#line 170
    if (*tmp___3 != 5) {
#line 171
      return (-1);
    }
  }
  {
#line 174
  memcpy(whereto, pframe + 16, 2048);
  }
#line 176
  return (0);
}
}
#line 228 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat64)(char const   * __restrict  __file ,
                                                                                               struct stat64 * __restrict  __buf ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 345 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek64)(int __fd ,
                                                                                    __off64_t __offset ,
                                                                                    int __whence ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/io.h"
ssize_t READ(int fd , char *whereto , size_t len ) ;
#line 3
ssize_t phantom_write(int fd , char *in , size_t nbytes ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/utils.h"
void *mymalloc(size_t size , char *what ) ;
#line 2
void *myrealloc(void *oldp , size_t newsize , char *what ) ;
#line 3
off64_t get_filesize(char *filename ) ;
#line 4
int copy_block(int fd_in , int fd_out , off64_t block_size ) ;
#line 5
void myseek(int fd , off64_t offset ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/error.h"
void error_exit(char *format  , ...) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/utils.c"
void *mymalloc(size_t size , char *what ) 
{ 
  void *dummy ;
  void *tmp ;

  {
  {
#line 19
  tmp = malloc(size);
#line 19
  dummy = tmp;
  }
#line 20
  if (! dummy) {
    {
#line 21
    error_exit((char *)"failed to allocate %d bytes for %s\n", size, what);
    }
  }
#line 23
  return (dummy);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/utils.c"
void *myrealloc(void *oldp , size_t newsize , char *what ) 
{ 
  void *dummy ;
  void *tmp ;

  {
  {
#line 28
  tmp = realloc(oldp, newsize);
#line 28
  dummy = tmp;
  }
#line 29
  if (! dummy) {
    {
#line 30
    error_exit((char *)"failed to reallocate to %d bytes for %s\n", newsize, what);
    }
  }
#line 32
  return (dummy);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/utils.c"
off64_t get_filesize(char *filename ) 
{ 
  struct stat64 finfo ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 39
  tmp___2 = stat64((char const   */* __restrict  */)filename, (struct stat64 */* __restrict  */)(& finfo));
  }
#line 39
  if (tmp___2 == -1) {
    {
#line 40
    tmp = __errno_location();
#line 40
    tmp___0 = __errno_location();
#line 40
    tmp___1 = strerror(*tmp___0);
#line 40
    error_exit((char *)"Failed to retrieve length of file %s: %s (%d)\n", filename,
               tmp___1, *tmp);
    }
  }
#line 42
  return (finfo.st_size);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/utils.c"
int copy_block(int fd_in , int fd_out , off64_t block_size ) 
{ 
  char buffer[512] ;
  size_t sector_size ;
  off64_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  ssize_t tmp___7 ;

  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (block_size > 0L)) {
#line 49
      goto while_break;
    }
#line 51
    if (block_size < 512L) {
#line 51
      tmp = block_size;
    } else {
#line 51
      tmp = (off64_t )512;
    }
    {
#line 51
    sector_size = (size_t )tmp;
#line 54
    tmp___3 = READ(fd_in, buffer, sector_size);
    }
#line 54
    if ((size_t )tmp___3 != sector_size) {
      {
#line 56
      tmp___0 = __errno_location();
#line 56
      tmp___1 = __errno_location();
#line 56
      tmp___2 = strerror(*tmp___1);
#line 56
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to read %d bytes from inputfile: %s (%d)\n",
              sector_size, tmp___2, *tmp___0);
      }
#line 57
      return (-1);
    }
    {
#line 61
    tmp___7 = phantom_write(fd_out, buffer, sector_size);
    }
#line 61
    if ((size_t )tmp___7 != sector_size) {
      {
#line 63
      tmp___4 = __errno_location();
#line 63
      tmp___5 = __errno_location();
#line 63
      tmp___6 = strerror(*tmp___5);
#line 63
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to write to outputfile: %s (%d)\n",
              tmp___6, *tmp___4);
      }
#line 64
      return (-1);
    }
#line 68
    block_size = (off64_t )((size_t )block_size - sector_size);
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (0);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/utils.c"
void myseek(int fd , off64_t offset ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  __off64_t tmp___2 ;

  {
  {
#line 77
  tmp___2 = lseek64(fd, offset, 0);
  }
#line 77
  if (tmp___2 == -1L) {
    {
#line 78
    tmp = __errno_location();
#line 78
    tmp___0 = __errno_location();
#line 78
    tmp___1 = strerror(*tmp___0);
#line 78
    error_exit((char *)"Failed to seek in file to offset %lld: %s (%d)\n", offset,
               tmp___1, *tmp);
    }
  }
#line 79
  return;
}
}
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 2 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/io.h"
ssize_t WRITE(int fd , char *whereto , size_t len ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/io.c"
ssize_t READ(int fd , char *whereto , size_t len ) 
{ 
  ssize_t cnt ;
  ssize_t rc ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 17
  cnt = (ssize_t )0;
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
#line 19
    if (! (len > 0UL)) {
#line 19
      goto while_break;
    }
    {
#line 23
    rc = read(fd, (void *)whereto, len);
    }
#line 25
    if (rc == -1L) {
      {
#line 27
      tmp___3 = __errno_location();
      }
#line 27
      if (*tmp___3 != 4) {
        {
#line 29
        tmp___2 = __errno_location();
        }
#line 29
        if (*tmp___2 != 5) {
          {
#line 30
          tmp = __errno_location();
#line 30
          tmp___0 = __errno_location();
#line 30
          tmp___1 = strerror(*tmp___0);
#line 30
          error_exit((char *)"unexpected error while reading: %s (%d)\n", tmp___1,
                     *tmp);
          }
        }
#line 32
        return ((ssize_t )-1);
      }
    } else
#line 35
    if (rc == 0L) {
#line 37
      goto while_break;
    } else {
#line 41
      whereto += rc;
#line 42
      len -= (size_t )rc;
#line 43
      cnt += rc;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return (cnt);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/io.c"
ssize_t WRITE(int fd , char *whereto , size_t len ) 
{ 
  ssize_t cnt ;
  ssize_t rc ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 52
  cnt = (ssize_t )0;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (len > 0UL)) {
#line 54
      goto while_break;
    }
    {
#line 58
    rc = write(fd, (void const   *)whereto, len);
    }
#line 60
    if (rc == -1L) {
      {
#line 62
      tmp___0 = __errno_location();
      }
#line 62
      if (*tmp___0 != 4) {
        {
#line 64
        tmp = __errno_location();
#line 64
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WRITE::write: %d\n",
                *tmp);
        }
#line 65
        return ((ssize_t )-1);
      }
    } else
#line 68
    if (rc == 0L) {
#line 70
      goto while_break;
    } else {
#line 74
      whereto += rc;
#line 75
      len -= (size_t )rc;
#line 76
      cnt += rc;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (cnt);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/io.c"
ssize_t phantom_write(int fd , char *in , size_t nbytes ) 
{ 
  ssize_t cnt ;
  size_t move_a_little ;
  off64_t curpos ;
  int dummy_rc ;
  int *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int rc ;
  ssize_t tmp___2 ;
  int loop ;
  char nulls ;
  int *tmp___3 ;
  __off64_t tmp___4 ;
  int *tmp___5 ;
  ssize_t tmp___6 ;
  int *tmp___7 ;
  ssize_t tmp___8 ;

  {
  {
#line 85
  cnt = (ssize_t )0;
#line 91
  dummy_rc = fcntl(fd, 3);
  }
#line 92
  if (dummy_rc == -1) {
    {
#line 94
    tmp = __errno_location();
#line 94
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"phantom_write::fnctl: %d\n",
            *tmp);
    }
#line 95
    return ((ssize_t )-1);
  }
#line 97
  if ((dummy_rc & 1024) == 1024) {
    {
#line 98
    tmp___0 = WRITE(fd, in, nbytes);
    }
#line 98
    return (tmp___0);
  }
  {
#line 100
  curpos = lseek64(fd, (off64_t )0, 1);
  }
#line 102
  if (curpos == -1L) {
    {
#line 104
    tmp___1 = __errno_location();
#line 104
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"phantom_write::lseek error: %d\n",
            *tmp___1);
    }
#line 105
    return ((ssize_t )-1);
  }
#line 111
  move_a_little = (size_t )(512L - (curpos & 511L));
#line 112
  if (move_a_little == 512UL) {
#line 113
    move_a_little = (size_t )0;
  } else
#line 115
  if (nbytes < move_a_little) {
#line 115
    move_a_little = nbytes;
  } else {
#line 115
    move_a_little = move_a_little;
  }
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (nbytes > 0UL)) {
#line 117
      goto while_break;
    }
#line 124
    if (move_a_little > 0UL) {
      {
#line 126
      tmp___2 = WRITE(fd, in, move_a_little);
#line 126
      rc = (int )tmp___2;
      }
#line 126
      if (rc <= 0) {
        {
#line 128
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"phantom_write::WRITE: error\n");
        }
#line 129
        return ((ssize_t )rc);
      }
#line 132
      move_a_little -= (size_t )rc;
    } else
#line 137
    if (nbytes >= 512UL) {
#line 139
      loop = 0;
#line 140
      nulls = (char)1;
#line 142
      loop = 0;
      {
#line 142
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 142
        if (! (loop < 512)) {
#line 142
          goto while_break___0;
        }
#line 144
        if (*(in + loop)) {
#line 146
          nulls = (char)0;
#line 147
          goto while_break___0;
        }
#line 142
        loop ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 151
      if (nulls) {
        {
#line 153
        tmp___4 = lseek64(fd, (off64_t )512, 1);
        }
#line 153
        if (tmp___4 == -1L) {
          {
#line 155
          tmp___3 = __errno_location();
#line 155
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"phantom_write::lseek: %d\n",
                  *tmp___3);
          }
#line 156
          return ((ssize_t )-1);
        }
#line 159
        rc = 512;
      } else {
        {
#line 163
        tmp___6 = WRITE(fd, in, (size_t )512);
#line 163
        rc = (int )tmp___6;
        }
#line 163
        if (rc <= 0) {
          {
#line 165
          tmp___5 = __errno_location();
#line 165
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"phantom_write::WRITE: error: %d\n",
                  *tmp___5);
          }
#line 166
          return ((ssize_t )rc);
        }
      }
    } else {
      {
#line 172
      tmp___8 = WRITE(fd, in, nbytes);
#line 172
      rc = (int )tmp___8;
      }
#line 172
      if (rc <= 0) {
        {
#line 174
        tmp___7 = __errno_location();
#line 174
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"phantom_write::WRITE: error: %d\n",
                *tmp___7);
        }
#line 175
        return ((ssize_t )rc);
      }
    }
#line 179
    in += rc;
#line 180
    cnt += (ssize_t )rc;
#line 181
    nbytes -= (size_t )rc;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return (cnt);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 156 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open64)(char const   *__file , int __oflag 
                                                     , ...) ;
#line 238
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) posix_fadvise)(int __fd ,
                                                                                    off_t __offset ,
                                                                                    off_t __len ,
                                                                                    int __advise ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 157
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/recoverdm.c"
void version(void) 
{ 


  {
  {
#line 22
  printf((char const   */* __restrict  */)"recoverdm v0.20, (c) 2003-2004 by folkert@vanheusden.com\n\n");
  }
#line 23
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/recoverdm.c"
void usage(void) 
{ 


  {
  {
#line 27
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: recoverdm -t <type> -i <file/device-in> -o <fileout> [-l <sectorsfile>] [-n # retries]\n");
#line 28
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 [-s rotation speed (CD-ROM etc.)] [-r # CD/DVD RAW read retries]\n");
#line 29
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 [-b start offset] [-p skip blocks count]\n");
#line 30
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Number of retries defaults to %d. For CD-ROMs it\'s advised to use 1.\n",
          6);
#line 31
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Number of CD/DVD RAW read retries defaults to %d. It is advised to use at least 3.\n",
          6);
#line 32
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CD-ROM (and DVD) speed defaults to %d.\n",
          1);
#line 33
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Skip blocks count is how many sectors are skipped after non-read one. Use\n");
#line 34
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"more to speed-up the recover process. Default is 1.\n");
#line 35
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Type can be:\n");
#line 36
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tFILE\t\t1\n");
#line 37
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tFLOPPY\t\t10\n");
#line 38
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tFLOPPY_IDE\t11\n");
#line 39
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tFLOPPY_SCSI\t12\n");
#line 40
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tCDROM_IDE\t20\n");
#line 41
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tCDROM_SCSI\t21\n");
#line 42
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tDVD_IDE\t\t30\n");
#line 43
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tDVD_SCSI\t31\n");
#line 44
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tDISK_IDE\t40\n");
#line 45
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tDISK_SCSI\t41\n");
#line 46
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-l generates a mapfile containing checksums and a list of badsectors. This map-\n");
#line 47
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   file can then be used with `mergebad\' to create one correct image from\n");
#line 48
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   several damaged images\n");
  }
#line 49
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/recoverdm.c"
void lba_to_msf(off64_t lba , unsigned char *minute , unsigned char *second , unsigned char *frame ) 
{ 


  {
#line 53
  if (lba >= -150L) {
#line 55
    *minute = (unsigned char )((lba + 150L) / 4500L);
#line 56
    lba -= (off64_t )(((int )*minute * 60) * 75);
#line 57
    *second = (unsigned char )((lba + 150L) / 75L);
#line 58
    lba -= (off64_t )((int )*second * 75);
#line 59
    *frame = (unsigned char )(lba + 150L);
  } else {
#line 63
    *minute = (unsigned char )((lba + 450150L) / 4500L);
#line 64
    lba -= (off64_t )(((int )*minute * 60) * 75);
#line 65
    *second = (unsigned char )((lba + 450150L) / 75L);
#line 66
    lba -= (off64_t )((int )*second * 75);
#line 67
    *frame = (unsigned char )(lba + 450150L);
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/recoverdm.c"
int create_sector(unsigned char **sectors , int n_sectors , size_t block_size , char **psector_out ) 
{ 
  short *n_times_ok ;
  unsigned long __lengthofn_times_ok ;
  void *tmp ;
  short max_n_ok ;
  char *selection ;
  unsigned long __lengthofselection ;
  void *tmp___0 ;
  char *sector_out ;
  void *tmp___1 ;
  int loop ;
  int max_n_ok_index ;
  int loop2 ;
  short chosen_byte ;
  short chosen_byte_count ;
  int count[256] ;

  {
  {
#line 73
  __lengthofn_times_ok = (unsigned long )n_sectors;
#line 73
  tmp = __builtin_alloca(sizeof(*n_times_ok) * __lengthofn_times_ok);
#line 73
  n_times_ok = (short *)tmp;
#line 73
  max_n_ok = (short)0;
#line 74
  __lengthofselection = block_size;
#line 74
  tmp___0 = __builtin_alloca(sizeof(*selection) * __lengthofselection);
#line 74
  selection = (char *)tmp___0;
#line 75
  tmp___1 = mymalloc(block_size, (char *)"sector");
#line 75
  sector_out = (char *)tmp___1;
#line 76
  max_n_ok_index = 0;
#line 78
  *psector_out = sector_out;
#line 80
  memset((void *)n_times_ok, 0, sizeof(*n_times_ok) * __lengthofn_times_ok);
#line 81
  memset((void *)selection, 0, sizeof(*selection) * __lengthofselection);
#line 84
  loop = 0;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! ((size_t )loop < block_size)) {
#line 84
      goto while_break;
    }
    {
#line 87
    chosen_byte = (short)-1;
#line 87
    chosen_byte_count = (short)1;
#line 92
    memset((void *)(count), 0, sizeof(count));
#line 98
    loop2 = 0;
    }
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! (loop2 < n_sectors)) {
#line 98
        goto while_break___0;
      }
#line 100
      (count[*(*(sectors + loop2) + loop)]) ++;
#line 98
      loop2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 103
    loop2 = 0;
    {
#line 103
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 103
      if (! (loop2 < 256)) {
#line 103
        goto while_break___1;
      }
#line 105
      if (count[loop2] > (int )chosen_byte_count) {
#line 107
        chosen_byte_count = (short )count[loop2];
#line 108
        chosen_byte = (short )loop2;
      }
#line 103
      loop2 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 116
    if ((int )chosen_byte != -1) {
#line 119
      loop2 = 0;
      {
#line 119
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 119
        if (! (loop2 < n_sectors)) {
#line 119
          goto while_break___2;
        }
#line 121
        if ((int )*(*(sectors + loop2) + loop) == (int )chosen_byte) {
#line 122
          *(n_times_ok + loop2) = (short )((int )*(n_times_ok + loop2) + 1);
        }
#line 119
        loop2 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 126
      *(sector_out + loop) = (char )chosen_byte;
#line 128
      *(selection + loop) = (char)1;
    }
#line 84
    loop ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  loop = 0;
  {
#line 133
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 133
    if (! (loop < n_sectors)) {
#line 133
      goto while_break___3;
    }
#line 135
    if ((int )*(n_times_ok + loop) > (int )max_n_ok) {
#line 137
      max_n_ok = *(n_times_ok + loop);
#line 138
      max_n_ok_index = loop;
    }
#line 133
    loop ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 145
  loop = 0;
  {
#line 145
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 145
    if (! ((size_t )loop < block_size)) {
#line 145
      goto while_break___4;
    }
#line 147
    if ((int )*(selection + loop) == 0) {
#line 149
      *(sector_out + loop) = (char )*(*(sectors + max_n_ok_index) + loop);
    }
#line 145
    loop ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 153
  return (0);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/recoverdm.c"
int get_raw_cd(int fd , int dev_type , off64_t cur_pos , int n_raw_retries , char *whereto ) 
{ 
  int rc ;
  unsigned char minute ;
  unsigned char second ;
  unsigned char frame ;
  size_t block_size ;
  char **sector_list ;
  void *tmp ;
  int loop ;
  char *dummy ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 158
  rc = 0;
#line 160
  block_size = (size_t )2048;
#line 162
  lba_to_msf(cur_pos / 2048L, & minute, & second, & frame);
  }
#line 164
  if (n_raw_retries == 2) {
#line 165
    n_raw_retries = 1;
  }
#line 167
  if (n_raw_retries >= 3) {
    {
#line 169
    tmp = mymalloc(sizeof(char *) * (unsigned long )n_raw_retries, (char *)"sectorlist");
#line 169
    sector_list = (char **)tmp;
#line 171
    dummy = (char *)((void *)0);
#line 173
    loop = 0;
    }
    {
#line 173
    while (1) {
      while_continue: /* CIL Label */ ;
#line 173
      if (! (loop < n_raw_retries)) {
#line 173
        goto while_break;
      }
      {
#line 174
      tmp___0 = mymalloc(block_size, (char *)"sector");
#line 174
      *(sector_list + loop) = (char *)tmp___0;
#line 173
      loop ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 176
    loop = 0;
    {
#line 176
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 176
      if (! (loop < n_raw_retries)) {
#line 176
        goto while_break___0;
      }
      {
#line 178
      rc = read_raw_cd(fd, minute, second, frame, *(sector_list + loop));
      }
#line 178
      if (rc == -1) {
#line 179
        goto while_break___0;
      }
#line 176
      loop ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 182
    if (rc == 0) {
      {
#line 184
      tmp___1 = create_sector((unsigned char **)sector_list, n_raw_retries, block_size,
                              & dummy);
      }
#line 184
      if (tmp___1 == -1) {
#line 185
        rc = -1;
      }
    }
#line 188
    loop = 0;
    {
#line 188
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 188
      if (! (loop < n_raw_retries)) {
#line 188
        goto while_break___1;
      }
      {
#line 189
      free((void *)*(sector_list + loop));
#line 188
      loop ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 190
    free((void *)sector_list);
    }
#line 192
    if (dummy) {
      {
#line 194
      memcpy((void */* __restrict  */)whereto, (void const   */* __restrict  */)dummy,
             block_size);
#line 195
      free((void *)dummy);
      }
    }
  } else {
    {
#line 200
    rc = read_raw_cd(fd, minute, second, frame, whereto);
    }
  }
#line 203
  return (rc);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/recoverdm.c"
int main(int argc , char **argv ) 
{ 
  int fdin ;
  int fdout ;
  off64_t prevpos ;
  off64_t curpos ;
  off64_t lastok ;
  off64_t the_end ;
  off64_t start_offset ;
  int skip_value ;
  int n ;
  size_t block_size ;
  int c ;
  char dev_type ;
  char cd_speed ;
  char n_retries ;
  char n_raw_cd_retries ;
  FILE *dsecfile ;
  char *file_in ;
  char *file_out ;
  char *file_list ;
  char *buffer ;
  char *buffer2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long long tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  __off64_t tmp___9 ;
  ssize_t rc ;
  int *tmp___10 ;
  __off64_t tmp___11 ;
  int *tmp___12 ;
  ssize_t tmp___13 ;
  int *tmp___14 ;
  __off64_t tmp___15 ;
  char ok ;
  char raw_buffer[2048] ;
  int *tmp___16 ;
  int *tmp___17 ;
  ssize_t tmp___18 ;
  __off64_t tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  __off64_t tmp___22 ;

  {
  {
#line 209
  curpos = (off64_t )-1;
#line 209
  lastok = (off64_t )-1;
#line 210
  start_offset = (off64_t )0;
#line 211
  skip_value = 1;
#line 212
  n = 0;
#line 215
  dev_type = (char)-1;
#line 215
  cd_speed = (char)1;
#line 216
  n_retries = (char)6;
#line 217
  n_raw_cd_retries = (char)6;
#line 218
  dsecfile = (FILE *)((void *)0);
#line 219
  file_in = (char *)((void *)0);
#line 219
  file_out = (char *)((void *)0);
#line 219
  file_list = (char *)((void *)0);
#line 222
  version();
  }
#line 224
  if (argc == 1) {
    {
#line 226
    usage();
    }
#line 227
    return (-1);
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 230
    c = getopt(argc, (char * const  *)argv, "i:o:l:t:p:n:s:r:b:Vh");
    }
#line 230
    if (! (c != -1)) {
#line 230
      goto while_break;
    }
    {
#line 234
    if (c == 116) {
#line 234
      goto case_116;
    }
#line 246
    if (c == 105) {
#line 246
      goto case_105;
    }
#line 249
    if (c == 111) {
#line 249
      goto case_111;
    }
#line 252
    if (c == 108) {
#line 252
      goto case_108;
    }
#line 255
    if (c == 110) {
#line 255
      goto case_110;
    }
#line 258
    if (c == 112) {
#line 258
      goto case_112;
    }
#line 261
    if (c == 115) {
#line 261
      goto case_115;
    }
#line 264
    if (c == 114) {
#line 264
      goto case_114;
    }
#line 267
    if (c == 86) {
#line 267
      goto case_86;
    }
#line 269
    if (c == 98) {
#line 269
      goto case_98;
    }
#line 273
    if (c == 104) {
#line 273
      goto case_104;
    }
#line 273
    if (c == 63) {
#line 273
      goto case_104;
    }
#line 276
    goto switch_default;
    case_116: /* CIL Label */ 
    {
#line 235
    tmp = atoi((char const   *)optarg);
#line 235
    dev_type = (char )tmp;
    }
#line 236
    if ((int )dev_type != 1) {
#line 236
      if ((int )dev_type != 10) {
#line 236
        if ((int )dev_type != 11) {
#line 236
          if ((int )dev_type != 12) {
#line 236
            if ((int )dev_type != 20) {
#line 236
              if ((int )dev_type != 21) {
#line 236
                if ((int )dev_type != 30) {
#line 236
                  if ((int )dev_type != 31) {
#line 236
                    if ((int )dev_type != 40) {
#line 236
                      if ((int )dev_type != 41) {
                        {
#line 242
                        usage();
                        }
#line 243
                        return (-1);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 245
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 247
    file_in = strdup((char const   *)optarg);
    }
#line 248
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 250
    file_out = strdup((char const   *)optarg);
    }
#line 251
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 253
    file_list = strdup((char const   *)optarg);
    }
#line 254
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 256
    tmp___0 = atoi((char const   *)optarg);
#line 256
    n_retries = (char )tmp___0;
    }
#line 257
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 259
    skip_value = atoi((char const   *)optarg);
    }
#line 260
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 262
    tmp___1 = atoi((char const   *)optarg);
#line 262
    cd_speed = (char )tmp___1;
    }
#line 263
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 265
    tmp___2 = atoi((char const   *)optarg);
#line 265
    n_raw_cd_retries = (char )tmp___2;
    }
#line 266
    goto switch_break;
    case_86: /* CIL Label */ 
#line 268
    return (0);
    case_98: /* CIL Label */ 
    {
#line 270
    tmp___3 = atoll((char const   *)optarg);
#line 270
    start_offset = (off64_t )tmp___3;
    }
#line 271
    goto switch_break;
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 274
    usage();
    }
#line 275
    return (0);
    switch_default: /* CIL Label */ 
    {
#line 277
    usage();
    }
#line 278
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  if ((unsigned long )file_in == (unsigned long )((void *)0)) {
    {
#line 284
    usage();
    }
#line 285
    return (-1);
  } else
#line 282
  if ((unsigned long )file_out == (unsigned long )((void *)0)) {
    {
#line 284
    usage();
    }
#line 285
    return (-1);
  }
#line 288
  if (start_offset & 511L) {
    {
#line 290
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Start offset must be a multiple of 512!\n");
    }
#line 291
    return (-1);
  }
#line 294
  if (skip_value <= 0) {
    {
#line 296
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Skip value must be positive!\n");
    }
#line 297
    return (-1);
  }
#line 300
  if ((int )dev_type == 20) {
#line 301
    block_size = (size_t )2048;
  } else
#line 300
  if ((int )dev_type == 21) {
#line 301
    block_size = (size_t )2048;
  } else
#line 302
  if ((int )dev_type == 30) {
#line 303
    block_size = (size_t )2048;
  } else
#line 302
  if ((int )dev_type == 31) {
#line 303
    block_size = (size_t )2048;
  } else {
#line 305
    block_size = (size_t )512;
  }
  {
#line 307
  tmp___4 = mymalloc(block_size, (char *)"sectorbuffer");
#line 307
  buffer = (char *)tmp___4;
#line 308
  tmp___5 = mymalloc(block_size, (char *)"sectorbuffer for retries");
#line 308
  buffer2 = (char *)tmp___5;
#line 310
  fdout = open64((char const   *)file_out, 1052865, 384);
  }
#line 311
  if (fdout == -1) {
    {
#line 313
    tmp___6 = __errno_location();
#line 313
    tmp___7 = strerror(*tmp___6);
#line 313
    printf((char const   */* __restrict  */)"Cannot create file %s! (%s)\n", file_out,
           tmp___7);
    }
#line 314
    return (-1);
  }
  {
#line 317
  posix_fadvise(fdout, (off_t )0, (off_t )0, 2);
#line 320
  fdin = open64((char const   *)file_in, 0);
  }
#line 321
  if (fdin == -1) {
    {
#line 323
    printf((char const   */* __restrict  */)"Cannot open file %s: this is beyond the capabilities\n",
           file_in);
#line 324
    printf((char const   */* __restrict  */)"of this program.\n");
    }
#line 325
    return (-1);
  }
  {
#line 328
  posix_fadvise(fdin, (off_t )0, (off_t )0, 2);
  }
#line 331
  if ((unsigned long )file_list != (unsigned long )((void *)0)) {
    {
#line 333
    dsecfile = fopen((char const   */* __restrict  */)file_list, (char const   */* __restrict  */)"w");
    }
#line 334
    if (! dsecfile) {
      {
#line 336
      printf((char const   */* __restrict  */)"Cannot create file %s.\n", file_list);
      }
#line 337
      return (-1);
    }
    {
#line 340
    tmp___8 = fileno(dsecfile);
#line 340
    posix_fadvise(tmp___8, (off_t )0, (off_t )0, 2);
    }
  }
  {
#line 344
  init_device(fdin, (int )dev_type, (int )cd_speed);
#line 346
  the_end = lseek64(fdin, (off64_t )0, 2);
#line 348
  tmp___9 = lseek64(fdin, start_offset, 0);
  }
#line 348
  if (tmp___9 == -1L) {
    {
#line 350
    printf((char const   */* __restrict  */)"Problem seeking to start of file/device.\n");
    }
#line 351
    return (-1);
  }
  {
#line 354
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 358
    prevpos = curpos;
#line 359
    curpos = lseek64(fdin, (off64_t )0, 1);
#line 361
    printf((char const   */* __restrict  */)"%lld\r", curpos);
#line 362
    fflush(stdout);
#line 364
    rc = READ(fdin, buffer, block_size);
    }
#line 366
    if (rc == 0L) {
#line 367
      goto while_break___0;
    }
#line 369
    if (rc > 0L) {
      {
#line 371
      n = 0;
#line 373
      tmp___11 = lseek64(fdout, curpos, 0);
      }
#line 373
      if (tmp___11 == -1L) {
        {
#line 375
        tmp___10 = __errno_location();
#line 375
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Problem seeking in outputfile! [%d]\n",
                *tmp___10);
        }
#line 376
        goto while_break___0;
      }
      {
#line 378
      tmp___13 = phantom_write(fdout, buffer, (size_t )rc);
      }
#line 378
      if (tmp___13 <= 0L) {
        {
#line 380
        tmp___12 = __errno_location();
#line 380
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing to file! [%d]\n",
                *tmp___12);
        }
#line 381
        goto while_break___0;
      }
    } else
#line 384
    if (rc == -1L) {
      {
#line 386
      n ++;
#line 388
      printf((char const   */* __restrict  */)"error at %lld bytes, retrying: %d\n",
             curpos, n);
#line 389
      fflush(stdout);
      }
#line 391
      if (n > 1) {
#line 393
        if (prevpos != curpos) {
          {
#line 395
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Confused! Continuing...\n");
          }
        }
      }
      {
#line 402
      if (n == 2) {
#line 402
        goto case_2;
      }
#line 412
      if (n == 3) {
#line 412
        goto case_3;
      }
#line 422
      if (n == 4) {
#line 422
        goto case_4;
      }
#line 427
      if (n == 5) {
#line 427
        goto case_5;
      }
#line 400
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 403
      if (lastok != -1L) {
        {
#line 405
        printf((char const   */* __restrict  */)"seek to last known good...\n");
#line 406
        lseek64(fdin, lastok, 0);
#line 407
        clear_buffers(fdin, (int )dev_type);
#line 408
        READ(fdin, buffer2, block_size);
        }
      }
#line 410
      goto switch_break___0;
      case_3: /* CIL Label */ 
#line 413
      if (the_end != -1L) {
        {
#line 415
        printf((char const   */* __restrict  */)"seek to end...\n");
#line 416
        lseek64(fdin, the_end, 0);
#line 417
        clear_buffers(fdin, (int )dev_type);
#line 418
        READ(fdin, buffer2, block_size);
        }
      }
#line 420
      goto switch_break___0;
      case_4: /* CIL Label */ 
      {
#line 423
      printf((char const   */* __restrict  */)"resetting device...\n");
#line 424
      reset_device(fdin, (int )dev_type);
      }
#line 425
      goto switch_break___0;
      case_5: /* CIL Label */ 
      {
#line 428
      printf((char const   */* __restrict  */)"resetting controller...\n");
#line 429
      reset_controller(fdin, (int )dev_type);
      }
#line 430
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 433
      tmp___15 = lseek64(fdin, curpos, 0);
      }
#line 433
      if (tmp___15 == -1L) {
        {
#line 435
        tmp___14 = __errno_location();
#line 435
        printf((char const   */* __restrict  */)"Problem seeking in input-file! [%d] (current sector)\n",
               *tmp___14);
        }
      }
#line 438
      if (n == (int )n_retries) {
#line 440
        ok = (char)1;
#line 443
        if (dsecfile) {
          {
#line 445
          fprintf((FILE */* __restrict  */)dsecfile, (char const   */* __restrict  */)"%lld %ld\n",
                  curpos, block_size * (size_t )skip_value);
#line 446
          fflush(dsecfile);
          }
        }
#line 449
        n = 0;
#line 451
        if ((int )dev_type == 20) {
#line 451
          goto _L;
        } else
#line 451
        if ((int )dev_type == 21) {
#line 451
          goto _L;
        } else
#line 451
        if ((int )dev_type == 30) {
#line 451
          goto _L;
        } else
#line 451
        if ((int )dev_type == 31) {
          _L: /* CIL Label */ 
          {
#line 456
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Trying RAW read...\n");
#line 458
          tmp___20 = get_raw_cd(fdin, (int )dev_type, curpos, (int )n_raw_cd_retries,
                                raw_buffer);
          }
#line 458
          if (tmp___20 == 0) {
            {
#line 460
            tmp___19 = lseek64(fdout, curpos, 0);
            }
#line 460
            if (tmp___19 == -1L) {
              {
#line 462
              tmp___16 = __errno_location();
#line 462
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Problem seeking in outputfile! [%d]\n",
                      *tmp___16);
#line 463
              ok = (char)0;
              }
            } else {
              {
#line 465
              tmp___18 = phantom_write(fdout, raw_buffer, (size_t )2048);
              }
#line 465
              if (tmp___18 <= 0L) {
                {
#line 467
                tmp___17 = __errno_location();
#line 467
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing to file! [%d]\n",
                        *tmp___17);
#line 468
                ok = (char)0;
                }
              }
            }
          } else {
#line 473
            ok = (char)0;
          }
        }
        {
#line 477
        printf((char const   */* __restrict  */)"Tried reading %d times, failed doing that. Skiping %d blocks...\n",
               (int )n_retries, skip_value);
#line 479
        tmp___22 = lseek64(fdin, curpos + (off64_t )block_size * (off64_t )skip_value,
                           0);
        }
#line 479
        if (tmp___22 == -1L) {
          {
#line 481
          tmp___21 = __errno_location();
#line 481
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Problem seeking in input-file! [%d] (sector %d after current)\n",
                  *tmp___21, skip_value);
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 487
  close(fdout);
#line 488
  close(fdin);
  }
#line 490
  if (dsecfile) {
    {
#line 491
    fclose(dsecfile);
    }
  }
  {
#line 493
  printf((char const   */* __restrict  */)"Done\n");
  }
#line 495
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/error.c"
void error_exit(char *format  , ...) 
{ 
  va_list ap ;
  int *tmp ;

  {
  {
#line 12
  fflush((FILE *)((void *)0));
#line 14
  __builtin_va_start(ap, format);
#line 15
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           ap);
#line 16
  __builtin_va_end(ap);
#line 17
  tmp = __errno_location();
#line 17
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"errno=%d (if applicable)\n",
          *tmp);
#line 19
  exit(1);
  }
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 425 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/mergebad.c"
char verbose  =    (char)0;
#line 40 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/mergebad.c"
int find_image_without_badblock(image *imgs , int n_imgs , off64_t offset ) 
{ 
  int img_index ;
  int badblock_index ;
  char ok ;
  off64_t cur_offset ;
  off64_t cur_bb_end ;

  {
#line 44
  if ((int )verbose >= 3) {
    {
#line 45
    printf((char const   */* __restrict  */)"> find_image_without_badblock(%p %d %lld)\n",
           imgs, n_imgs, offset);
    }
  }
#line 48
  img_index = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (img_index < n_imgs)) {
#line 48
      goto while_break;
    }
#line 50
    ok = (char)1;
#line 53
    badblock_index = 0;
    {
#line 53
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 53
      if (! (badblock_index < (imgs + img_index)->bb_list_size)) {
#line 53
        goto while_break___0;
      }
#line 55
      cur_offset = ((imgs + img_index)->bb_list + badblock_index)->offset;
#line 56
      cur_bb_end = cur_offset + ((imgs + img_index)->bb_list + badblock_index)->block_size;
#line 58
      if ((int )verbose >= 4) {
        {
#line 59
        printf((char const   */* __restrict  */)"= %d/%d, %lld - %lld\n", img_index,
               badblock_index, cur_offset, cur_bb_end);
        }
      }
#line 62
      if (offset >= cur_offset) {
#line 62
        if (offset < cur_bb_end) {
#line 67
          ok = (char)0;
#line 68
          goto while_break___0;
        } else {
#line 62
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 74
      if (cur_offset > offset) {
#line 76
        goto while_break___0;
      }
#line 53
      badblock_index ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 81
    if (ok) {
#line 83
      if ((int )verbose >= 3) {
        {
#line 84
        printf((char const   */* __restrict  */)"< find_image_without_badblock: %d\n",
               img_index);
        }
      }
#line 86
      return (img_index);
    }
#line 48
    img_index ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if ((int )verbose >= 3) {
    {
#line 91
    printf((char const   */* __restrict  */)"< find_image_without_badblock: %d\n",
           img_index);
    }
  }
#line 94
  return (-1);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/mergebad.c"
void find_smallest_current_badblock(image *imgs , int n_imgs , off64_t offset , int *selected_image ,
                                    int *selected_badblock ) 
{ 
  off64_t smallest_block_size ;
  int img_index ;
  int badblock_index ;
  off64_t cur_offset ;
  off64_t cur_bb_end ;
  off64_t block_size_left ;

  {
#line 99
  smallest_block_size = 1L << (sizeof(off64_t ) * 8UL - 2UL);
#line 102
  if ((int )verbose >= 3) {
    {
#line 103
    printf((char const   */* __restrict  */)"> find_smallest_current_badblock(%p %d %lld %p %p)\n",
           imgs, n_imgs, offset, selected_image, selected_badblock);
    }
  }
#line 105
  *selected_image = -1;
#line 106
  *selected_badblock = -1;
#line 109
  img_index = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (img_index < n_imgs)) {
#line 109
      goto while_break;
    }
#line 112
    badblock_index = 0;
    {
#line 112
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 112
      if (! (badblock_index < (imgs + img_index)->bb_list_size)) {
#line 112
        goto while_break___0;
      }
#line 114
      cur_offset = ((imgs + img_index)->bb_list + badblock_index)->offset;
#line 115
      cur_bb_end = cur_offset + ((imgs + img_index)->bb_list + badblock_index)->block_size;
#line 117
      if ((int )verbose >= 4) {
        {
#line 118
        printf((char const   */* __restrict  */)"= %d/%d, %lld - %lld\n", img_index,
               badblock_index, cur_offset, cur_bb_end);
        }
      }
#line 121
      if (offset >= cur_offset) {
#line 121
        if (offset < cur_bb_end) {
#line 123
          block_size_left = cur_bb_end - offset;
#line 129
          if ((int )verbose >= 4) {
            {
#line 130
            printf((char const   */* __restrict  */)"= # bytes left: %lld\n", block_size_left);
            }
          }
#line 133
          if (block_size_left < smallest_block_size) {
#line 135
            if ((int )verbose >= 4) {
              {
#line 136
              printf((char const   */* __restrict  */)"! block selected\n");
              }
            }
#line 138
            *selected_image = img_index;
#line 139
            *selected_badblock = badblock_index;
#line 140
            smallest_block_size = block_size_left;
#line 141
            goto while_break___0;
          }
        }
      }
#line 112
      badblock_index ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 109
    img_index ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  if ((int )verbose >= 3) {
    {
#line 148
    printf((char const   */* __restrict  */)"> find_smallest_current_badblock: %d %d (%lld)\n",
           *selected_image, *selected_badblock, smallest_block_size);
    }
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/mergebad.c"
int find_badblock_after_offset(badblock *bb_list , int bb_list_size , off64_t offset ) 
{ 
  int badblock_index ;

  {
#line 156
  badblock_index = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (badblock_index < bb_list_size)) {
#line 156
      goto while_break;
    }
#line 158
    if ((bb_list + badblock_index)->offset >= offset) {
#line 159
      return (badblock_index);
    }
#line 156
    badblock_index ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return (-1);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/mergebad.c"
int read_mapfile(char *filename , badblock **pbb , int *nbb ) 
{ 
  int n_bb ;
  badblock *bbs ;
  FILE *fh ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  off64_t offset ;
  int block_size ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 167
  n_bb = 0;
#line 168
  bbs = (badblock *)((void *)0);
#line 171
  if ((int )verbose >= 2) {
    {
#line 172
    printf((char const   */* __restrict  */)"Reading mapfile from %s\n", filename);
    }
  }
  {
#line 174
  fh = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
  }
#line 175
  if (! fh) {
    {
#line 177
    tmp = __errno_location();
#line 177
    tmp___0 = __errno_location();
#line 177
    tmp___1 = strerror(*tmp___0);
#line 177
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Problem opening %s for read! %s (%d)\n",
            filename, tmp___1, *tmp);
    }
#line 178
    return (-1);
  }
  {
#line 181
  tmp___2 = fileno(fh);
#line 181
  posix_fadvise(tmp___2, (off_t )0, (off_t )0, 2);
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 184
    tmp___4 = feof(fh);
    }
#line 184
    if (tmp___4) {
#line 184
      goto while_break;
    }
    {
#line 189
    fscanf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"%lld %d",
           & offset, & block_size);
#line 191
    tmp___3 = myrealloc((void *)bbs, sizeof(badblock ) * (unsigned long )(n_bb + 1),
                        (char *)"badblocks list");
#line 191
    bbs = (badblock *)tmp___3;
#line 192
    (bbs + n_bb)->offset = offset;
#line 193
    (bbs + n_bb)->block_size = (off64_t )block_size;
    }
#line 195
    if ((int )verbose >= 4) {
      {
#line 196
      printf((char const   */* __restrict  */)"%d] %lld %lld\n", n_bb, offset, block_size);
      }
    }
#line 198
    n_bb ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  *pbb = bbs;
#line 202
  *nbb = n_bb;
#line 204
  return (0);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/recoverdm-0.20/mergebad.c"
char select_most_occuring_byte(unsigned char *bytes , int n_imgs ) 
{ 
  char selected_byte ;
  int loop ;
  int counters[256] ;
  int count_used ;

  {
  {
#line 209
  selected_byte = (char)0;
#line 212
  count_used = -1;
#line 214
  memset((void *)(counters), 0, sizeof(counters));
#line 217
  loop = 0;
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (loop < n_imgs)) {
#line 217
      goto while_break;
    }
#line 219
    (counters[*(bytes + loop)]) ++;
#line 217
    loop ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  loop = 0;
  {
#line 223
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 223
    if (! (loop < 256)) {
#line 223
      goto while_break___0;
    }
#line 225
    if (counters[loop] > count_used) {
#line 227
      count_used = counters[loop];
#line 228
      selected_byte = (char )loop;
    }
#line 223
    loop ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 234
  if (count_used == -1) {
    {
#line 235
    error_exit((char *)"Internal error: no byte found!");
    }
  }
#line 237
  return (selected_byte);
}
}
