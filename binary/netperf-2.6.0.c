/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 275 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.h"
struct __anonstruct_content_60 {
   int request_type ;
   int dummy ;
   int test_specific_data[162] ;
};
#line 275 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.h"
union netperf_request_struct {
   struct __anonstruct_content_60 content ;
   double dummy ;
};
#line 284 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.h"
struct __anonstruct_content_61 {
   int response_type ;
   int serv_errno ;
   int test_specific_data[162] ;
};
#line 284 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.h"
union netperf_response_struct {
   struct __anonstruct_content_61 content ;
   double dummy ;
};
#line 183 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
struct listen_elt {
   int fd ;
   struct listen_elt *next ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_60 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_60 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 264 "/usr/include/netinet/in.h"
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 149 "/usr/include/linux/tcp.h"
struct tcp_info {
   __u8 tcpi_state ;
   __u8 tcpi_ca_state ;
   __u8 tcpi_retransmits ;
   __u8 tcpi_probes ;
   __u8 tcpi_backoff ;
   __u8 tcpi_options ;
   __u8 tcpi_snd_wscale : 4 ;
   __u8 tcpi_rcv_wscale : 4 ;
   __u32 tcpi_rto ;
   __u32 tcpi_ato ;
   __u32 tcpi_snd_mss ;
   __u32 tcpi_rcv_mss ;
   __u32 tcpi_unacked ;
   __u32 tcpi_sacked ;
   __u32 tcpi_lost ;
   __u32 tcpi_retrans ;
   __u32 tcpi_fackets ;
   __u32 tcpi_last_data_sent ;
   __u32 tcpi_last_ack_sent ;
   __u32 tcpi_last_data_recv ;
   __u32 tcpi_last_ack_recv ;
   __u32 tcpi_pmtu ;
   __u32 tcpi_rcv_ssthresh ;
   __u32 tcpi_rtt ;
   __u32 tcpi_rttvar ;
   __u32 tcpi_snd_ssthresh ;
   __u32 tcpi_snd_cwnd ;
   __u32 tcpi_advmss ;
   __u32 tcpi_reordering ;
   __u32 tcpi_rcv_rtt ;
   __u32 tcpi_rcv_space ;
   __u32 tcpi_total_retrans ;
};
#line 326 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 244 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.h"
enum sock_buffer {
    SEND_BUFFER = 0,
    RECV_BUFFER = 1
} ;
#line 249
enum netperf_output_modes {
    HUMAN = 0,
    CSV = 1,
    KEYVAL = 2
} ;
#line 293 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.h"
struct ring_elt {
   struct ring_elt *next ;
   char *buffer_base ;
   char *buffer_ptr ;
   void *completion_ptr ;
};
#line 46 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct omni_request_struct {
   int32_t send_buf_size ;
   uint32_t send_size ;
   uint32_t send_alignment ;
   uint32_t send_offset ;
   uint32_t send_width ;
   int32_t request_size ;
   int32_t recv_buf_size ;
   uint32_t receive_size ;
   uint32_t recv_alignment ;
   uint32_t recv_offset ;
   uint32_t recv_width ;
   int32_t response_size ;
   uint32_t flags ;
   float cpu_rate ;
   int32_t test_length ;
   uint32_t so_rcvavoid ;
   uint32_t so_sndavoid ;
   uint32_t send_dirty_count ;
   uint32_t recv_dirty_count ;
   uint32_t recv_clean_count ;
   uint32_t data_port ;
   uint32_t ipfamily ;
   uint32_t socket_type ;
   uint32_t protocol ;
   uint32_t direction ;
   uint32_t netperf_port ;
   uint32_t interval_burst ;
   uint32_t interval_usecs ;
   uint32_t netperf_ip[4] ;
   uint32_t netserver_ip[4] ;
   int32_t socket_prio ;
   int32_t socket_tos ;
   char cong_control[16] ;
   char fill_file[32] ;
};
#line 94 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct omni_response_struct {
   int32_t recv_buf_size ;
   uint32_t receive_size ;
   int32_t recv_width ;
   int32_t send_buf_size ;
   uint32_t send_size ;
   int32_t send_width ;
   uint32_t flags ;
   float cpu_rate ;
   uint32_t test_length ;
   uint32_t so_rcvavoid ;
   uint32_t so_sndavoid ;
   uint32_t data_port ;
   uint32_t interval_burst ;
   uint32_t interval_usecs ;
   uint32_t cpu_frequency ;
   uint32_t security_info ;
   int32_t socket_prio ;
   int32_t socket_tos ;
   char system_model[33] ;
   char cpu_model[80] ;
   char security_string[16] ;
};
#line 135 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct omni_results_struct {
   uint32_t bytes_received_hi ;
   uint32_t bytes_received_lo ;
   uint32_t recv_calls ;
   int32_t recv_buf_size ;
   uint32_t bytes_sent_hi ;
   uint32_t bytes_sent_lo ;
   uint32_t send_calls ;
   int32_t send_buf_size ;
   uint32_t failed_sends ;
   uint32_t trans_received ;
   float elapsed_time ;
   float cpu_util ;
   float serv_dem ;
   uint32_t cpu_method ;
   uint32_t num_cpus ;
   int32_t peak_cpu_id ;
   float peak_cpu_util ;
   int32_t vendor ;
   int32_t device ;
   int32_t subvendor ;
   int32_t subdevice ;
   int32_t transport_retrans ;
   char ifname[16] ;
   char driver[32] ;
   char version[32] ;
   char firmware[32] ;
   char bus[32] ;
   char ifslot[16] ;
   char cong_control[16] ;
};
#line 49 "/home/wheatley/newnew/temp/netperf-2.6.0/src/hist.h"
struct histogram_struct {
   int unit_usec[100] ;
   int ten_usec[100] ;
   int hundred_usec[100] ;
   int unit_msec[100] ;
   int ten_msec[100] ;
   int hundred_msec[100] ;
   int unit_sec[100] ;
   int ten_sec[100] ;
   int ridiculous ;
   int total ;
   int64_t sum ;
   double sumsquare ;
   int hmin ;
   int hmax ;
   int limit ;
   int count ;
   int producer ;
   int consumer ;
   struct timeval *time_ones ;
   struct timeval time_two ;
};
#line 84 "/home/wheatley/newnew/temp/netperf-2.6.0/src/hist.h"
typedef struct histogram_struct *HIST;
#line 468 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
enum netperf_output_type {
    NETPERF_TYPE_UNKNOWN = 0,
    NETPERF_TYPE_UINT32 = 1,
    NETPERF_TYPE_INT32 = 2,
    NETPERF_TYPE_UINT64 = 3,
    NETPERF_TYPE_INT64 = 4,
    NETPERF_TYPE_CHAR = 5,
    NETPERF_TYPE_FLOAT = 6,
    NETPERF_TYPE_DOUBLE = 7
} ;
#line 482
enum netperf_output_name {
    NETPERF_OUTPUT_UNKNOWN = 0,
    OUTPUT_NONE = 1,
    SOCKET_TYPE = 2,
    PROTOCOL = 3,
    DIRECTION = 4,
    ELAPSED_TIME = 5,
    THROUGHPUT = 6,
    THROUGHPUT_UNITS = 7,
    LSS_SIZE_REQ = 8,
    LSS_SIZE = 9,
    LSS_SIZE_END = 10,
    LSR_SIZE_REQ = 11,
    LSR_SIZE = 12,
    LSR_SIZE_END = 13,
    RSS_SIZE_REQ = 14,
    RSS_SIZE = 15,
    RSS_SIZE_END = 16,
    RSR_SIZE_REQ = 17,
    RSR_SIZE = 18,
    RSR_SIZE_END = 19,
    LOCAL_SEND_SIZE = 20,
    LOCAL_RECV_SIZE = 21,
    REMOTE_SEND_SIZE = 22,
    REMOTE_RECV_SIZE = 23,
    REQUEST_SIZE = 24,
    RESPONSE_SIZE = 25,
    LOCAL_CPU_UTIL = 26,
    LOCAL_CPU_METHOD = 27,
    LOCAL_SD = 28,
    REMOTE_CPU_UTIL = 29,
    REMOTE_CPU_METHOD = 30,
    REMOTE_SD = 31,
    SD_UNITS = 32,
    CONFIDENCE_LEVEL = 33,
    CONFIDENCE_INTERVAL = 34,
    CONFIDENCE_ITERATION = 35,
    THROUGHPUT_CONFID = 36,
    LOCAL_CPU_CONFID = 37,
    REMOTE_CPU_CONFID = 38,
    TRANSACTION_RATE = 39,
    RT_LATENCY = 40,
    BURST_SIZE = 41,
    LOCAL_TRANSPORT_RETRANS = 42,
    REMOTE_TRANSPORT_RETRANS = 43,
    TRANSPORT_MSS = 44,
    LOCAL_SEND_THROUGHPUT = 45,
    LOCAL_RECV_THROUGHPUT = 46,
    REMOTE_SEND_THROUGHPUT = 47,
    REMOTE_RECV_THROUGHPUT = 48,
    LOCAL_CPU_BIND = 49,
    LOCAL_CPU_COUNT = 50,
    LOCAL_CPU_PEAK_UTIL = 51,
    LOCAL_CPU_PEAK_ID = 52,
    LOCAL_CPU_MODEL = 53,
    LOCAL_CPU_FREQUENCY = 54,
    REMOTE_CPU_BIND = 55,
    REMOTE_CPU_COUNT = 56,
    REMOTE_CPU_PEAK_UTIL = 57,
    REMOTE_CPU_PEAK_ID = 58,
    REMOTE_CPU_MODEL = 59,
    REMOTE_CPU_FREQUENCY = 60,
    SOURCE_PORT = 61,
    SOURCE_ADDR = 62,
    SOURCE_FAMILY = 63,
    DEST_PORT = 64,
    DEST_ADDR = 65,
    DEST_FAMILY = 66,
    LOCAL_SEND_CALLS = 67,
    LOCAL_RECV_CALLS = 68,
    LOCAL_BYTES_PER_RECV = 69,
    LOCAL_BYTES_PER_SEND = 70,
    LOCAL_BYTES_SENT = 71,
    LOCAL_BYTES_RECVD = 72,
    LOCAL_BYTES_XFERD = 73,
    LOCAL_SEND_OFFSET = 74,
    LOCAL_RECV_OFFSET = 75,
    LOCAL_SEND_ALIGN = 76,
    LOCAL_RECV_ALIGN = 77,
    LOCAL_SEND_WIDTH = 78,
    LOCAL_RECV_WIDTH = 79,
    LOCAL_SEND_DIRTY_COUNT = 80,
    LOCAL_RECV_DIRTY_COUNT = 81,
    LOCAL_RECV_CLEAN_COUNT = 82,
    LOCAL_NODELAY = 83,
    LOCAL_CORK = 84,
    REMOTE_SEND_CALLS = 85,
    REMOTE_RECV_CALLS = 86,
    REMOTE_BYTES_PER_RECV = 87,
    REMOTE_BYTES_PER_SEND = 88,
    REMOTE_BYTES_SENT = 89,
    REMOTE_BYTES_RECVD = 90,
    REMOTE_BYTES_XFERD = 91,
    REMOTE_SEND_OFFSET = 92,
    REMOTE_RECV_OFFSET = 93,
    REMOTE_SEND_ALIGN = 94,
    REMOTE_RECV_ALIGN = 95,
    REMOTE_SEND_WIDTH = 96,
    REMOTE_RECV_WIDTH = 97,
    REMOTE_SEND_DIRTY_COUNT = 98,
    REMOTE_RECV_DIRTY_COUNT = 99,
    REMOTE_RECV_CLEAN_COUNT = 100,
    REMOTE_NODELAY = 101,
    REMOTE_CORK = 102,
    LOCAL_SYSNAME = 103,
    LOCAL_SYSTEM_MODEL = 104,
    LOCAL_RELEASE = 105,
    LOCAL_VERSION = 106,
    LOCAL_MACHINE = 107,
    REMOTE_SYSNAME = 108,
    REMOTE_SYSTEM_MODEL = 109,
    REMOTE_RELEASE = 110,
    REMOTE_VERSION = 111,
    REMOTE_MACHINE = 112,
    LOCAL_INTERFACE_NAME = 113,
    LOCAL_INTERFACE_VENDOR = 114,
    LOCAL_INTERFACE_DEVICE = 115,
    LOCAL_INTERFACE_SUBVENDOR = 116,
    LOCAL_INTERFACE_SUBDEVICE = 117,
    LOCAL_DRIVER_NAME = 118,
    LOCAL_DRIVER_VERSION = 119,
    LOCAL_DRIVER_FIRMWARE = 120,
    LOCAL_DRIVER_BUS = 121,
    LOCAL_INTERFACE_SLOT = 122,
    REMOTE_INTERFACE_NAME = 123,
    REMOTE_INTERFACE_VENDOR = 124,
    REMOTE_INTERFACE_DEVICE = 125,
    REMOTE_INTERFACE_SUBVENDOR = 126,
    REMOTE_INTERFACE_SUBDEVICE = 127,
    REMOTE_DRIVER_NAME = 128,
    REMOTE_DRIVER_VERSION = 129,
    REMOTE_DRIVER_FIRMWARE = 130,
    REMOTE_DRIVER_BUS = 131,
    REMOTE_INTERFACE_SLOT = 132,
    LOCAL_INTERVAL_USECS = 133,
    LOCAL_INTERVAL_BURST = 134,
    REMOTE_INTERVAL_USECS = 135,
    REMOTE_INTERVAL_BURST = 136,
    LOCAL_SECURITY_TYPE_ID = 137,
    LOCAL_SECURITY_TYPE = 138,
    LOCAL_SECURITY_ENABLED_NUM = 139,
    LOCAL_SECURITY_ENABLED = 140,
    LOCAL_SECURITY_SPECIFIC = 141,
    REMOTE_SECURITY_TYPE_ID = 142,
    REMOTE_SECURITY_TYPE = 143,
    REMOTE_SECURITY_ENABLED_NUM = 144,
    REMOTE_SECURITY_ENABLED = 145,
    REMOTE_SECURITY_SPECIFIC = 146,
    RESULT_BRAND = 147,
    UUID = 148,
    MIN_LATENCY = 149,
    MAX_LATENCY = 150,
    P50_LATENCY = 151,
    P90_LATENCY = 152,
    P99_LATENCY = 153,
    MEAN_LATENCY = 154,
    STDDEV_LATENCY = 155,
    LOCAL_SOCKET_PRIO = 156,
    REMOTE_SOCKET_PRIO = 157,
    LOCAL_SOCKET_TOS = 158,
    REMOTE_SOCKET_TOS = 159,
    LOCAL_CONG_CONTROL = 160,
    REMOTE_CONG_CONTROL = 161,
    LOCAL_FILL_FILE = 162,
    REMOTE_FILL_FILE = 163,
    COMMAND_LINE = 164,
    OUTPUT_END = 165,
    NETPERF_OUTPUT_MAX = 166
} ;
#line 669 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
struct netperf_output_elt {
   enum netperf_output_name output_name ;
   int max_line_len ;
   int tot_line_len ;
   char *line[4] ;
   char *brief ;
   char *format ;
   void *display_value ;
   enum netperf_output_type output_type ;
   int output_default ;
   unsigned int output_group ;
};
#line 669 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
typedef struct netperf_output_elt netperf_output_elt_t;
#line 100 "/home/wheatley/newnew/temp/netperf-2.6.0/src/dscp.c"
struct __anonstruct_ipqos_32 {
   char const   *name ;
   int value ;
};
#line 177 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat___0 {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   __time_t st_atime ;
   __syscall_ulong_t st_atimensec ;
   __time_t st_mtime ;
   __syscall_ulong_t st_mtimensec ;
   __time_t st_ctime ;
   __syscall_ulong_t st_ctimensec ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 105 "/usr/include/ftw.h"
struct FTW {
   int base ;
   int level ;
};
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_26 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_27 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_26 ifr_ifrn ;
   union __anonunion_ifr_ifru_27 ifr_ifru ;
};
#line 83 "/usr/include/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32] ;
   char version[32] ;
   char fw_version[32] ;
   char bus_info[32] ;
   char reserved1[32] ;
   char reserved2[12] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 11 "/usr/include/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 35 "/usr/include/linux/netlink.h"
struct sockaddr_nl {
   __kernel_sa_family_t nl_family ;
   unsigned short nl_pad ;
   __u32 nl_pid ;
   __u32 nl_groups ;
};
#line 42 "/usr/include/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 149 "/usr/include/linux/rtnetlink.h"
struct rtattr {
   unsigned short rta_len ;
   unsigned short rta_type ;
};
#line 175 "/usr/include/linux/rtnetlink.h"
struct rtmsg {
   unsigned char rtm_family ;
   unsigned char rtm_dst_len ;
   unsigned char rtm_src_len ;
   unsigned char rtm_tos ;
   unsigned char rtm_table ;
   unsigned char rtm_protocol ;
   unsigned char rtm_scope ;
   unsigned char rtm_type ;
   unsigned int rtm_flags ;
};
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 44 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netrt_rtnetlink.c"
struct __anonstruct_request_77 {
   struct nlmsghdr nl ;
   struct rtmsg rt ;
   char buf[1024] ;
};
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 397 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.h"
struct sendfile_ring_elt {
   struct sendfile_ring_elt *next ;
   int fildes ;
   off_t offset ;
   size_t length ;
   struct iovec *hdtrl ;
   int flags ;
};
#line 178 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct tcp_stream_request_struct {
   int send_buf_size ;
   int recv_buf_size ;
   int receive_size ;
   int recv_alignment ;
   int recv_offset ;
   int no_delay ;
   int measure_cpu ;
   float cpu_rate ;
   int test_length ;
   int so_rcvavoid ;
   int so_sndavoid ;
   int dirty_count ;
   int clean_count ;
   int port ;
   int ipfamily ;
};
#line 206 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct tcp_stream_response_struct {
   int recv_buf_size ;
   int receive_size ;
   int no_delay ;
   int measure_cpu ;
   int test_length ;
   int send_buf_size ;
   int data_port_number ;
   float cpu_rate ;
   int so_rcvavoid ;
   int so_sndavoid ;
};
#line 219 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct tcp_stream_results_struct {
   double bytes_received ;
   unsigned int recv_calls ;
   float elapsed_time ;
   float cpu_util ;
   float serv_dem ;
   int cpu_method ;
   int num_cpus ;
   int recv_buf_size ;
   int send_buf_size ;
};
#line 231 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct tcp_maerts_request_struct {
   int send_buf_size ;
   int recv_buf_size ;
   int send_size ;
   int send_alignment ;
   int send_offset ;
   int no_delay ;
   int measure_cpu ;
   float cpu_rate ;
   int test_length ;
   int so_rcvavoid ;
   int so_sndavoid ;
   int dirty_count ;
   int clean_count ;
   int port ;
   int ipfamily ;
};
#line 259 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct tcp_maerts_response_struct {
   int recv_buf_size ;
   int send_size ;
   int no_delay ;
   int measure_cpu ;
   int test_length ;
   int send_buf_size ;
   int data_port_number ;
   float cpu_rate ;
   int so_rcvavoid ;
   int so_sndavoid ;
};
#line 272 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct tcp_maerts_results_struct {
   double bytes_sent ;
   unsigned int send_calls ;
   float elapsed_time ;
   float cpu_util ;
   float serv_dem ;
   int cpu_method ;
   int num_cpus ;
};
#line 282 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct tcp_rr_request_struct {
   int recv_buf_size ;
   int send_buf_size ;
   int recv_alignment ;
   int recv_offset ;
   int send_alignment ;
   int send_offset ;
   int request_size ;
   int response_size ;
   int no_delay ;
   int measure_cpu ;
   float cpu_rate ;
   int test_length ;
   int so_rcvavoid ;
   int so_sndavoid ;
   int port ;
   int ipfamily ;
};
#line 304 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct tcp_rr_response_struct {
   int recv_buf_size ;
   int no_delay ;
   int measure_cpu ;
   int test_length ;
   int send_buf_size ;
   int data_port_number ;
   float cpu_rate ;
   int so_rcvavoid ;
   int so_sndavoid ;
};
#line 316 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct tcp_rr_results_struct {
   unsigned int bytes_received ;
   unsigned int recv_calls ;
   unsigned int trans_received ;
   float elapsed_time ;
   float cpu_util ;
   float serv_dem ;
   int cpu_method ;
   int num_cpus ;
};
#line 327 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct tcp_conn_rr_request_struct {
   int recv_buf_size ;
   int send_buf_size ;
   int recv_alignment ;
   int recv_offset ;
   int send_alignment ;
   int send_offset ;
   int request_size ;
   int response_size ;
   int no_delay ;
   int measure_cpu ;
   float cpu_rate ;
   int test_length ;
   int so_rcvavoid ;
   int so_sndavoid ;
   int port ;
   int ipfamily ;
};
#line 350 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct tcp_conn_rr_response_struct {
   int recv_buf_size ;
   int no_delay ;
   int measure_cpu ;
   int test_length ;
   int send_buf_size ;
   int data_port_number ;
   float cpu_rate ;
   int so_rcvavoid ;
   int so_sndavoid ;
};
#line 362 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct tcp_conn_rr_results_struct {
   unsigned int bytes_received ;
   unsigned int recv_calls ;
   unsigned int trans_received ;
   float elapsed_time ;
   float cpu_util ;
   float serv_dem ;
   int cpu_method ;
   int num_cpus ;
};
#line 420 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct udp_stream_request_struct {
   int recv_buf_size ;
   int message_size ;
   int recv_connected ;
   int recv_alignment ;
   int recv_offset ;
   int checksum_off ;
   int measure_cpu ;
   float cpu_rate ;
   int test_length ;
   int so_rcvavoid ;
   int so_sndavoid ;
   int port ;
   int ipfamily ;
};
#line 440 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct udp_stream_response_struct {
   int recv_buf_size ;
   int send_buf_size ;
   int measure_cpu ;
   int test_length ;
   int data_port_number ;
   float cpu_rate ;
   int so_rcvavoid ;
   int so_sndavoid ;
};
#line 451 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct udp_stream_results_struct {
   unsigned int messages_recvd ;
   unsigned int bytes_received ;
   float elapsed_time ;
   float cpu_util ;
   int cpu_method ;
   int num_cpus ;
};
#line 461 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct udp_rr_request_struct {
   int recv_buf_size ;
   int send_buf_size ;
   int recv_alignment ;
   int recv_offset ;
   int send_alignment ;
   int send_offset ;
   int request_size ;
   int response_size ;
   int no_delay ;
   int measure_cpu ;
   float cpu_rate ;
   int test_length ;
   int so_rcvavoid ;
   int so_sndavoid ;
   int port ;
   int ipfamily ;
};
#line 483 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct udp_rr_response_struct {
   int recv_buf_size ;
   int no_delay ;
   int measure_cpu ;
   int test_length ;
   int send_buf_size ;
   int data_port_number ;
   float cpu_rate ;
   int so_rcvavoid ;
   int so_sndavoid ;
};
#line 495 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct udp_rr_results_struct {
   unsigned int bytes_received ;
   unsigned int recv_calls ;
   unsigned int trans_received ;
   float elapsed_time ;
   float cpu_util ;
   float serv_dem ;
   int cpu_method ;
   int num_cpus ;
};
#line 506 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct tcp_cc_request_struct {
   int recv_buf_size ;
   int send_buf_size ;
   int recv_alignment ;
   int recv_offset ;
   int send_alignment ;
   int send_offset ;
   int request_size ;
   int response_size ;
   int no_delay ;
   int measure_cpu ;
   float cpu_rate ;
   int test_length ;
   int so_rcvavoid ;
   int so_sndavoid ;
   int port ;
   int ipfamily ;
};
#line 529 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct tcp_cc_response_struct {
   int recv_buf_size ;
   int no_delay ;
   int measure_cpu ;
   int test_length ;
   int send_buf_size ;
   int data_port_number ;
   float cpu_rate ;
   int so_rcvavoid ;
   int so_sndavoid ;
};
#line 541 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
struct tcp_cc_results_struct {
   unsigned int bytes_received ;
   unsigned int recv_calls ;
   unsigned int trans_received ;
   float elapsed_time ;
   float cpu_util ;
   float serv_dem ;
   int cpu_method ;
   int num_cpus ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 73 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
typedef uint64_t uuid_time_t;
#line 75 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
struct __anonstruct_uuid_node_t_28 {
   char nodeID[6] ;
};
#line 75 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
typedef struct __anonstruct_uuid_node_t_28 uuid_node_t;
#line 80 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
struct __anonstruct_uuid_t_29 {
   uint32_t time_low ;
   uint16_t time_mid ;
   uint16_t time_hi_and_version ;
   uint8_t clock_seq_hi_and_reserved ;
   uint8_t clock_seq_low ;
   uint8_t node[6] ;
};
#line 80 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
typedef struct __anonstruct_uuid_t_29 uuid_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_1 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_1 __sigset_t;
#line 49 "/usr/include/signal.h"
typedef __sigset_t sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_5 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_6 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_7 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_8 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_9 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_10 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_11 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_4 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_5 _kill ;
   struct __anonstruct__timer_6 _timer ;
   struct __anonstruct__rt_7 _rt ;
   struct __anonstruct__sigchld_8 _sigchld ;
   struct __anonstruct__sigfault_9 _sigfault ;
   struct __anonstruct__sigpoll_10 _sigpoll ;
   struct __anonstruct__sigsys_11 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_3 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_4 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_3 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_23 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_23 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 616 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
union __anonunion_conv_rec_64 {
   double whole_thing ;
   unsigned int words[2] ;
   unsigned char bytes[8] ;
};
#line 665 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
union __anonunion_conv_rec_65 {
   double whole_thing ;
   unsigned int words[2] ;
   unsigned char bytes[8] ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/sched.h"
typedef unsigned long __cpu_mask;
#line 125 "/usr/include/x86_64-linux-gnu/bits/sched.h"
struct __anonstruct_cpu_set_t_66 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/sched.h"
typedef struct __anonstruct_cpu_set_t_66 cpu_set_t;
#line 2277 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
typedef cpu_set_t netperf_cpu_set_t;
#line 47 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
struct cpu_states {
   uint64_t user ;
   uint64_t nice ;
   uint64_t sys ;
   uint64_t idle ;
   uint64_t iowait ;
   uint64_t hard_irq ;
   uint64_t soft_irq ;
   uint64_t steal ;
   uint64_t guest ;
};
#line 47 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
typedef struct cpu_states cpu_states_t;
#line 100 "/home/wheatley/newnew/temp/netperf-2.6.0/src/dscp.c"
struct __anonstruct_ipqos_32___0 {
   char const   *name ;
   int value ;
};
#line 44 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netrt_rtnetlink.c"
struct __anonstruct_request_77___0 {
   struct nlmsghdr nl ;
   struct rtmsg rt ;
   char buf[1024] ;
};
#line 616 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
union __anonunion_conv_rec_64___0 {
   double whole_thing ;
   unsigned int words[2] ;
   unsigned char bytes[8] ;
};
#line 665 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
union __anonunion_conv_rec_65___0 {
   double whole_thing ;
   unsigned int words[2] ;
   unsigned char bytes[8] ;
};
#line 47 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
char netserver_id[74]  = 
#line 47 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
  {      (char )'@',      (char )'(',      (char )'#',      (char )')', 
        (char )'n',      (char )'e',      (char )'t',      (char )'s', 
        (char )'e',      (char )'r',      (char )'v',      (char )'e', 
        (char )'r',      (char )'.',      (char )'c',      (char )' ', 
        (char )'(',      (char )'c',      (char )')',      (char )' ', 
        (char )'C',      (char )'o',      (char )'p',      (char )'y', 
        (char )'r',      (char )'i',      (char )'g',      (char )'h', 
        (char )'t',      (char )' ',      (char )'1',      (char )'9', 
        (char )'9',      (char )'3',      (char )'-',      (char )'2', 
        (char )'0',      (char )'1',      (char )'2',      (char )' ', 
        (char )'H',      (char )'e',      (char )'w',      (char )'l', 
        (char )'e',      (char )'t',      (char )'t',      (char )'-', 
        (char )'P',      (char )'a',      (char )'c',      (char )'k', 
        (char )'a',      (char )'r',      (char )'d',      (char )' ', 
        (char )'C',      (char )'o',      (char )'.',      (char )' ', 
        (char )'V',      (char )'e',      (char )'r',      (char )'s', 
        (char )'i',      (char )'o',      (char )'n',      (char )' ', 
        (char )'2',      (char )'.',      (char )'6',      (char )'.', 
        (char )'0',      (char )'\000'};
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 464 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.h"
char *local_sysname ;
#line 465
char *local_release ;
#line 466
char *local_version ;
#line 467
char *local_machine ;
#line 473
union netperf_request_struct netperf_request ;
#line 474
union netperf_response_struct netperf_response ;
#line 487
int lib_num_loc_cpus ;
#line 489
int server_sock ;
#line 491
FILE *where ;
#line 512
void netlib_init(void) ;
#line 528
void send_response(void) ;
#line 529
int recv_request(void) ;
#line 530
int recv_request_timed_n(int n , int seconds ) ;
#line 533
void send_response_n(int n ) ;
#line 536
void dump_request(void) ;
#line 537
void dump_addrinfo(FILE *dumploc , struct addrinfo *info , char const   *host , char *port ,
                   int family ) ;
#line 571
char *inet_ftos(int family ) ;
#line 585
float calibrate_local_cpu(float local_cpu_rate___0 ) ;
#line 632 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
void recv_omni(void) ;
#line 634
void recv_tcp_stream(void) ;
#line 635
void recv_tcp_maerts(void) ;
#line 636
void recv_tcp_rr(void) ;
#line 637
void recv_tcp_conn_rr(void) ;
#line 638
void recv_tcp_cc(void) ;
#line 639
void recv_udp_stream(void) ;
#line 640
void recv_udp_rr(void) ;
#line 77 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.h"
char *program ;
#line 80
char *passphrase ;
#line 84
char local_host_name[255] ;
#line 88
int local_address_family ;
#line 89
int parse_address_family(char *family_string ) ;
#line 97
void break_args_explicit(char *s , char *arg1 , char *arg2 ) ;
#line 99
void print_netserver_usage(void) ;
#line 102
int debug ;
#line 102
int verbosity ;
#line 185
int shell_num_cpus ;
#line 179 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
char FileName[4096]  ;
#line 181 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
char listen_port[10]  ;
#line 188 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
struct listen_elt *listen_list  =    (struct listen_elt *)((void *)0);
#line 190 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
int server_control  ;
#line 192 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
int child  ;
#line 194 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
int netperf_daemon  ;
#line 195 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
int daemon_parent  =    0;
#line 196 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
int not_inetd  ;
#line 197 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
int want_daemonize  ;
#line 198 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
int spawn_on_accept  ;
#line 199 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
int suppress_debug  =    0;
#line 206 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
static void init_netserver_globals(void) 
{ 


  {
#line 213
  spawn_on_accept = 1;
#line 218
  want_daemonize = 1;
#line 222
  child = 0;
#line 223
  not_inetd = 0;
#line 224
  netperf_daemon = 0;
#line 225
  return;
}
}
#line 227 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
void unlink_empty_debug_file(void) 
{ 
  struct stat buf ;
  int tmp ;

  {
  {
#line 233
  tmp = stat((char const   */* __restrict  */)(FileName), (struct stat */* __restrict  */)(& buf));
  }
#line 233
  if (tmp == 0) {
#line 235
    if (buf.st_size == 0L) {
      {
#line 236
      unlink((char const   *)(FileName));
      }
    }
  }
#line 239
  return;
}
}
#line 244 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
void open_debug_file(void) 
{ 
  FILE *rd_null_fp ;
  __pid_t tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 255
  if ((unsigned long )where != (unsigned long )((void *)0)) {
    {
#line 255
    fflush(where);
    }
  }
  {
#line 257
  tmp = getpid();
#line 257
  snprintf((char */* __restrict  */)(FileName), sizeof(FileName), (char const   */* __restrict  */)"%s_%d",
           "/var/log/netserver.debug", tmp);
  }
#line 267
  if (suppress_debug) {
#line 267
    tmp___0 = "/dev/null";
  } else {
#line 267
    tmp___0 = (char const   *)(FileName);
  }
  {
#line 267
  where = fopen((char const   */* __restrict  */)tmp___0, (char const   */* __restrict  */)"w");
  }
#line 267
  if ((unsigned long )where == (unsigned long )((void *)0)) {
    {
#line 269
    perror("netserver: debug file");
#line 270
    exit(1);
    }
  }
  {
#line 275
  chmod((char const   *)(FileName), (__mode_t )420);
#line 278
  rd_null_fp = fopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"r");
  }
#line 279
  if ((unsigned long )((void *)0) == (unsigned long )rd_null_fp) {
    {
#line 280
    tmp___1 = __errno_location();
#line 280
    tmp___2 = __errno_location();
#line 280
    tmp___3 = strerror(*tmp___2);
#line 280
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: opening of %s failed: %s (errno %d)\n",
            "open_debug_file", "/dev/null", tmp___3, *tmp___1);
#line 286
    fflush(where);
#line 287
    exit(1);
    }
  }
  {
#line 290
  tmp___7 = close(0);
  }
#line 290
  if (tmp___7 == -1) {
    {
#line 291
    tmp___4 = __errno_location();
#line 291
    tmp___5 = __errno_location();
#line 291
    tmp___6 = strerror(*tmp___5);
#line 291
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: close of STDIN_FILENO failed: %s (errno %d)\n",
            "open_debug_file", tmp___6, *tmp___4);
#line 296
    fflush(where);
#line 297
    exit(1);
    }
  }
  {
#line 300
  tmp___11 = fileno(rd_null_fp);
#line 300
  tmp___12 = dup(tmp___11);
  }
#line 300
  if (tmp___12 == -1) {
    {
#line 301
    tmp___8 = __errno_location();
#line 301
    tmp___9 = __errno_location();
#line 301
    tmp___10 = strerror(*tmp___9);
#line 301
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: dup of rd_null_fp to stdin failed: %s (errno %d)\n",
            "open_debug_file", tmp___10, *tmp___8);
#line 306
    fflush(where);
#line 307
    exit(1);
    }
  }
  {
#line 311
  tmp___16 = close(1);
  }
#line 311
  if (tmp___16 == -1) {
    {
#line 312
    tmp___13 = __errno_location();
#line 312
    tmp___14 = __errno_location();
#line 312
    tmp___15 = strerror(*tmp___14);
#line 312
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: close of STDOUT_FILENO failed: %s (errno %d)\n",
            "open_debug_file", tmp___15, *tmp___13);
#line 317
    fflush(where);
#line 318
    exit(1);
    }
  }
  {
#line 321
  tmp___20 = fileno(where);
#line 321
  tmp___21 = dup(tmp___20);
  }
#line 321
  if (tmp___21 == -1) {
    {
#line 322
    tmp___17 = __errno_location();
#line 322
    tmp___18 = __errno_location();
#line 322
    tmp___19 = strerror(*tmp___18);
#line 322
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: dup of where to stdout failed: %s (errno %d)\n",
            "open_debug_file", tmp___19, *tmp___17);
#line 327
    fflush(where);
#line 328
    exit(1);
    }
  }
  {
#line 332
  tmp___25 = close(2);
  }
#line 332
  if (tmp___25 == -1) {
    {
#line 333
    tmp___22 = __errno_location();
#line 333
    tmp___23 = __errno_location();
#line 333
    tmp___24 = strerror(*tmp___23);
#line 333
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: close of STDERR_FILENO failed: %s (errno %d)\n",
            "open_debug_file", tmp___24, *tmp___22);
#line 338
    fflush(where);
#line 339
    exit(1);
    }
  }
  {
#line 342
  tmp___29 = fileno(where);
#line 342
  tmp___30 = dup(tmp___29);
  }
#line 342
  if (tmp___30 == -1) {
    {
#line 343
    tmp___26 = __errno_location();
#line 343
    tmp___27 = __errno_location();
#line 343
    tmp___28 = strerror(*tmp___27);
#line 343
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: dup of where to stderr failed: %s (errno %d)\n",
            "open_debug_file", tmp___28, *tmp___26);
#line 348
    fflush(where);
#line 349
    exit(1);
    }
  }
#line 372
  return;
}
}
#line 379 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
void set_server_sock(void) 
{ 


  {
#line 382
  if (debug) {
    {
#line 383
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: enter\n",
            "set_server_sock");
#line 386
    fflush(where);
    }
  }
#line 392
  if (server_sock != -1) {
    {
#line 393
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Yo, Iz ain\'t invalid!\n");
#line 394
    fflush(where);
#line 395
    exit(1);
    }
  }
  {
#line 401
  server_sock = dup(0);
  }
#line 416
  return;
}
}
#line 419 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
void create_listens(char *hostname , char *port , int af___0 ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *local_res ;
  struct addrinfo *local_res_temp ;
  int count ;
  int error ;
  int on ;
  int temp_socket ;
  struct listen_elt *temp_elt ;
  char *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 426
  on = 1;
#line 430
  if (debug) {
    {
#line 431
    tmp = inet_ftos(af___0);
#line 431
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: called with host \'%s\' port \'%s\' family %s(%d)\n",
            "create_listens", hostname, port, tmp, af___0);
#line 438
    fflush(stderr);
    }
  }
  {
#line 440
  memset((void *)(& hints), 0, sizeof(hints));
#line 441
  hints.ai_family = af___0;
#line 442
  hints.ai_socktype = 1;
#line 443
  hints.ai_protocol = 6;
#line 444
  hints.ai_flags = 1;
#line 446
  count = 0;
  }
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 448
    error = getaddrinfo((char const   */* __restrict  */)hostname, (char const   */* __restrict  */)port,
                        (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& local_res));
#line 452
    count ++;
    }
#line 453
    if (error == -3) {
#line 454
      if (debug) {
        {
#line 455
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Sleeping on getaddrinfo EAI_AGAIN\n",
                "create_listens");
#line 458
        fflush(stderr);
        }
      }
      {
#line 460
      sleep(1U);
      }
    }
#line 447
    if (error == -3) {
#line 447
      if (! (count <= 5)) {
#line 447
        goto while_break;
      }
    } else {
#line 447
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  if (error) {
#line 465
    if (debug) {
      {
#line 467
      tmp___0 = gai_strerror(error);
#line 467
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: could not resolve remote \'%s\' port \'%s\' af %d\n\tgetaddrinfo returned %s (%d)\n",
              "create_listens", hostname, port, af___0, tmp___0, error);
      }
    }
#line 478
    return;
  }
#line 481
  if (debug) {
    {
#line 482
    dump_addrinfo(stderr, local_res, hostname, port, af___0);
    }
  }
#line 485
  local_res_temp = local_res;
  {
#line 487
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 487
    if (! ((unsigned long )local_res_temp != (unsigned long )((void *)0))) {
#line 487
      goto while_break___0;
    }
    {
#line 489
    temp_socket = socket(local_res_temp->ai_family, 1, 0);
    }
#line 491
    if (temp_socket == -1) {
#line 492
      if (debug) {
        {
#line 493
        tmp___1 = __errno_location();
#line 493
        tmp___2 = __errno_location();
#line 493
        tmp___3 = strerror(*tmp___2);
#line 493
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s could not allocate a socket: %s (errno %d)\n",
                "create_listens", tmp___3, *tmp___1);
#line 498
        fflush(stderr);
        }
      }
#line 500
      local_res_temp = local_res_temp->ai_next;
#line 501
      goto while_continue___0;
    }
    {
#line 505
    tmp___7 = setsockopt(temp_socket, 1, 2, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
    }
#line 505
    if (tmp___7 == -1) {
#line 510
      if (debug) {
        {
#line 511
        tmp___4 = __errno_location();
#line 511
        tmp___5 = __errno_location();
#line 511
        tmp___6 = strerror(*tmp___5);
#line 511
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: could not set SO_REUSEADDR: %s (errno %d)\n",
                "create_listens", tmp___6, *tmp___4);
#line 516
        fflush(stderr);
        }
      }
    }
    {
#line 521
    tmp___12 = bind(temp_socket, (struct sockaddr  const  *)local_res_temp->ai_addr,
                    local_res_temp->ai_addrlen);
    }
#line 521
    if (tmp___12 != -1) {
      {
#line 521
      tmp___13 = listen(temp_socket, 128);
      }
#line 521
      if (tmp___13 != -1) {
        {
#line 527
        tmp___8 = malloc(sizeof(struct listen_elt ));
#line 527
        temp_elt = (struct listen_elt *)tmp___8;
        }
#line 528
        if (temp_elt) {
#line 529
          temp_elt->fd = temp_socket;
#line 530
          if (listen_list) {
#line 531
            temp_elt->next = listen_list;
          } else {
#line 534
            temp_elt->next = (struct listen_elt *)((void *)0);
          }
#line 536
          listen_list = temp_elt;
        } else {
          {
#line 539
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: could not malloc a listen_elt\n",
                  "create_listens");
#line 542
          fflush(stderr);
#line 543
          exit(1);
          }
        }
      } else {
#line 521
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 549
      if (debug) {
        {
#line 550
        tmp___9 = __errno_location();
#line 550
        tmp___10 = __errno_location();
#line 550
        tmp___11 = strerror(*tmp___10);
#line 550
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: bind or listen call failure: %s (errno %d)\n",
                "create_listens", tmp___11, *tmp___9);
#line 555
        fflush(stderr);
        }
      }
      {
#line 557
      close(temp_socket);
      }
    }
#line 559
    local_res_temp = local_res_temp->ai_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 562
  return;
}
}
#line 564 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
void setup_listens(char *name , char *port , int af___0 ) 
{ 
  int do_inet ;
  int no_name ;
  int do_inet6 ;
  int tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 568
  no_name = 0;
#line 573
  if (debug) {
    {
#line 574
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: enter\n",
            "setup_listens");
#line 577
    fflush(where);
    }
  }
  {
#line 581
  tmp = strcmp((char const   *)name, "");
  }
#line 581
  if (tmp == 0) {
#line 582
    no_name = 1;
    {
#line 584
    if (af___0 == 0) {
#line 584
      goto case_0;
    }
#line 590
    if (af___0 == 2) {
#line 590
      goto case_2;
    }
#line 597
    if (af___0 == 10) {
#line 597
      goto case_10;
    }
#line 602
    goto switch_default;
    case_0: /* CIL Label */ 
#line 585
    do_inet = 1;
#line 587
    do_inet6 = 1;
#line 589
    goto switch_break;
    case_2: /* CIL Label */ 
#line 591
    do_inet = 1;
#line 593
    do_inet6 = 0;
#line 595
    goto switch_break;
    case_10: /* CIL Label */ 
#line 598
    do_inet = 0;
#line 599
    do_inet6 = 1;
#line 600
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 603
    do_inet = 1;
    switch_break: /* CIL Label */ ;
    }
#line 607
    if (do_inet6) {
      {
#line 608
      create_listens((char *)"::0", port, 10);
      }
    }
#line 610
    if (do_inet) {
      {
#line 611
      create_listens((char *)"0.0.0.0", port, 2);
      }
    }
  } else {
    {
#line 614
    create_listens(name, port, af___0);
    }
  }
#line 617
  if (listen_list) {
    {
#line 618
    tmp___0 = inet_ftos(af___0);
    }
#line 618
    if (no_name) {
#line 618
      tmp___1 = "IN(6)ADDR_ANY";
    } else {
#line 618
      tmp___1 = (char const   *)name;
    }
    {
#line 618
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Starting netserver with host \'%s\' port \'%s\' and family %s\n",
            tmp___1, port, tmp___0);
#line 623
    fflush(stdout);
    }
  } else {
    {
#line 626
    tmp___2 = inet_ftos(af___0);
    }
#line 626
    if (no_name) {
#line 626
      tmp___3 = "IN(6)ADDR_ANY";
    } else {
#line 626
      tmp___3 = (char const   *)name;
    }
    {
#line 626
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to start netserver with  \'%s\' port \'%s\' and family %s\n",
            tmp___3, port, tmp___2);
#line 631
    fflush(stderr);
#line 632
    exit(1);
    }
  }
#line 634
  return;
}
}
#line 636 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
int set_fdset(struct listen_elt *list , fd_set *fdset ) 
{ 
  struct listen_elt *temp ;
  int max ;
  int __d0 ;
  int __d1 ;

  {
#line 640
  max = -1;
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 642
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset->__fds_bits[0]): "memory");
#line 642
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 644
  temp = list;
#line 646
  if (debug) {
    {
#line 647
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: enter list %p fd_set %p\n",
            "set_fdset", list, fdset);
#line 652
    fflush(where);
    }
  }
  {
#line 655
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 655
    if (! temp) {
#line 655
      goto while_break___0;
    }
#line 656
    if (temp->fd > max) {
#line 657
      max = temp->fd;
    }
#line 659
    if (debug) {
      {
#line 660
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"setting %d in fdset\n",
              temp->fd);
#line 663
      fflush(where);
      }
    }
#line 666
    fdset->__fds_bits[temp->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << temp->fd % (8 * (int )sizeof(__fd_mask ));
#line 668
    temp = temp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 671
  return (max);
}
}
#line 675 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
void close_listens(struct listen_elt *list ) 
{ 
  struct listen_elt *temp ;

  {
#line 679
  if (debug) {
    {
#line 680
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: enter\n",
            "close_listens");
#line 683
    fflush(where);
    }
  }
#line 686
  temp = list;
  {
#line 688
  while (1) {
    while_continue: /* CIL Label */ ;
#line 688
    if (! temp) {
#line 688
      goto while_break;
    }
    {
#line 689
    close(temp->fd);
#line 690
    temp = temp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 692
  return;
}
}
#line 694 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
static int recv_passphrase(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 699
  tmp = recv_request_timed_n(0, 20);
  }
#line 699
  if (tmp > 0) {
#line 699
    if (netperf_request.content.request_type == 6) {
      {
#line 699
      tmp___0 = strcmp((char const   *)passphrase, (char const   *)((char *)(netperf_request.content.test_specific_data)));
      }
#line 699
      if (! tmp___0) {
#line 704
        return (0);
      }
    }
  }
  {
#line 714
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Unable to match required passphrase.  Closing control connection\n");
#line 716
  fflush(where);
#line 718
  close(server_sock);
  }
#line 719
  return (-1);
}
}
#line 727 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
void process_requests(void) 
{ 
  float temp_rate ;
  int tmp ;
  int tmp___0 ;
  char *delims[4] ;
  int i ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 733
  if (debug) {
    {
#line 734
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: enter\n",
            "process_requests");
#line 737
    fflush(where);
    }
  }
#line 745
  if ((unsigned long )passphrase != (unsigned long )((void *)0)) {
    {
#line 745
    tmp = recv_passphrase();
    }
#line 745
    if (tmp) {
#line 746
      return;
    }
  }
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 750
    tmp___0 = recv_request();
    }
#line 750
    if (tmp___0 <= 0) {
      {
#line 751
      close(server_sock);
      }
#line 752
      return;
    }
    {
#line 757
    if (netperf_request.content.request_type == 1) {
#line 757
      goto case_1;
    }
#line 774
    if (netperf_request.content.request_type == 2) {
#line 774
      goto case_2;
    }
#line 785
    if (netperf_request.content.request_type == 600) {
#line 785
      goto case_600;
    }
#line 833
    if (netperf_request.content.request_type == 5) {
#line 833
      goto case_5;
    }
#line 862
    if (netperf_request.content.request_type == 10) {
#line 862
      goto case_10;
    }
#line 866
    if (netperf_request.content.request_type == 94) {
#line 866
      goto case_94;
    }
#line 870
    if (netperf_request.content.request_type == 13) {
#line 870
      goto case_13;
    }
#line 874
    if (netperf_request.content.request_type == 34) {
#line 874
      goto case_34;
    }
#line 878
    if (netperf_request.content.request_type == 300) {
#line 878
      goto case_300;
    }
#line 894
    if (netperf_request.content.request_type == 16) {
#line 894
      goto case_16;
    }
#line 898
    if (netperf_request.content.request_type == 19) {
#line 898
      goto case_19;
    }
#line 994
    if (netperf_request.content.request_type == 97) {
#line 994
      goto case_97;
    }
#line 999
    if (netperf_request.content.request_type == 6) {
#line 999
      goto case_6;
    }
#line 1006
    goto switch_default;
    case_1: /* CIL Label */ 
#line 758
    netperf_response.content.response_type = 3;
#line 759
    if (! suppress_debug) {
#line 760
      debug ++;
#line 762
      if (debug == 1) {
        {
#line 767
        dump_request();
        }
      }
    }
    {
#line 771
    send_response();
    }
#line 772
    goto switch_break;
    case_2: /* CIL Label */ 
#line 775
    if (debug) {
#line 776
      debug --;
    }
    {
#line 777
    netperf_response.content.response_type = 3;
#line 778
    send_response();
    }
#line 783
    goto switch_break;
    case_600: /* CIL Label */ 
    {
#line 789
    delims[0] = strdup("|");
#line 790
    delims[1] = strdup(",");
#line 791
    delims[2] = strdup("_");
#line 792
    delims[3] = strdup(";");
#line 794
    netperf_response.content.response_type = 601;
#line 795
    i = 0;
    }
    {
#line 795
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 795
      if (! (i < 4)) {
#line 795
        goto while_break___0;
      }
      {
#line 796
      tmp___1 = strstr((char const   *)local_sysname, (char const   *)delims[i]);
      }
#line 796
      if (! tmp___1) {
        {
#line 796
        tmp___2 = strstr((char const   *)local_release, (char const   *)delims[i]);
        }
#line 796
        if (! tmp___2) {
          {
#line 796
          tmp___3 = strstr((char const   *)local_machine, (char const   *)delims[i]);
          }
#line 796
          if (! tmp___3) {
            {
#line 796
            tmp___4 = strstr((char const   *)local_version, (char const   *)delims[i]);
            }
#line 796
            if (! tmp___4) {
              {
#line 800
              snprintf((char */* __restrict  */)((char *)(netperf_response.content.test_specific_data)),
                       sizeof(netperf_response.content.test_specific_data), (char const   */* __restrict  */)"%c%s%c%s%c%s%c%s",
                       (int )*(delims[i] + 0), local_sysname, (int )*(delims[i] + 0),
                       local_release, (int )*(delims[i] + 0), local_machine, (int )*(delims[i] + 0),
                       local_version);
              }
#line 811
              goto while_break___0;
            }
          }
        }
      }
#line 795
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 814
    if (i == 4) {
      {
#line 817
      i --;
#line 818
      snprintf((char */* __restrict  */)((char *)(netperf_response.content.test_specific_data)),
               sizeof(netperf_response.content.test_specific_data), (char const   */* __restrict  */)"%c%s%c%s%c%s%c%s",
               (int )*(delims[i] + 0), "NoDelimUnique", (int )*(delims[i] + 0), "NoDelimUnique",
               (int )*(delims[i] + 0), "NoDelimUnique", (int )*(delims[i] + 0), "NoDelimUnique");
      }
    }
    {
#line 830
    send_response_n(0);
    }
#line 831
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 834
    netperf_response.content.response_type = 5;
#line 835
    temp_rate = calibrate_local_cpu((float )0.0);
#line 836
    memcpy((void */* __restrict  */)((char *)(netperf_response.content.test_specific_data)),
           (void const   */* __restrict  */)((char *)(& temp_rate)), sizeof(temp_rate));
#line 839
    memcpy((void */* __restrict  */)((char *)(netperf_response.content.test_specific_data) + sizeof(temp_rate)),
           (void const   */* __restrict  */)((char *)(& lib_num_loc_cpus)), sizeof(lib_num_loc_cpus));
    }
#line 843
    if (debug) {
      {
#line 844
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netserver: sending CPU information: rate is %g num cpu %d\n",
              (double )temp_rate, lib_num_loc_cpus);
#line 848
      fflush(where);
      }
    }
    {
#line 859
    send_response();
    }
#line 860
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 863
    recv_tcp_stream();
    }
#line 864
    goto switch_break;
    case_94: /* CIL Label */ 
    {
#line 867
    recv_tcp_maerts();
    }
#line 868
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 871
    recv_tcp_rr();
    }
#line 872
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 875
    recv_tcp_conn_rr();
    }
#line 876
    goto switch_break;
    case_300: /* CIL Label */ 
    {
#line 879
    recv_tcp_cc();
    }
#line 880
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 895
    recv_udp_stream();
    }
#line 896
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 899
    recv_udp_rr();
    }
#line 900
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 995
    recv_omni();
    }
#line 996
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1000
    if (debug) {
      {
#line 1001
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Ignoring an unexpected passphrase control message\n");
#line 1002
      fflush(where);
      }
    }
#line 1004
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1007
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"unknown test number %d\n",
            netperf_request.content.request_type);
#line 1009
    fflush(where);
#line 1010
    netperf_response.content.serv_errno = 998;
#line 1011
    send_response();
    }
#line 1012
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1020 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
void spawn_child(void) 
{ 
  __pid_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 1025
  if (debug) {
    {
#line 1026
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: enter\n",
            "spawn_child");
#line 1029
    fflush(where);
    }
  }
  {
#line 1034
  fflush(stdin);
#line 1035
  fflush(stdout);
#line 1036
  fflush(stderr);
#line 1037
  fflush(where);
#line 1039
  signal(17, (void (*)(int  ))1);
#line 1041
  tmp = fork();
  }
  {
#line 1042
  if (tmp == -1) {
#line 1042
    goto case_neg_1;
  }
#line 1051
  if (tmp == 0) {
#line 1051
    goto case_0;
  }
#line 1065
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 1043
  tmp___0 = __errno_location();
#line 1043
  tmp___1 = __errno_location();
#line 1043
  tmp___2 = strerror(*tmp___1);
#line 1043
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: fork() error %s (errno %d)\n",
          "spawn_child", tmp___2, *tmp___0);
#line 1048
  fflush(where);
#line 1049
  exit(1);
  }
  case_0: /* CIL Label */ 
  {
#line 1056
  close_listens(listen_list);
#line 1057
  open_debug_file();
#line 1059
  child = 1;
#line 1060
  netperf_daemon = 0;
#line 1061
  process_requests();
#line 1062
  exit(0);
  }
#line 1063
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1078
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1181
  return;
}
}
#line 1183 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
void accept_connection(int listen_fd ) 
{ 
  struct sockaddr_storage peeraddr ;
  unsigned int peeraddrlen ;
  int on ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 1189
  on = 1;
#line 1192
  if (debug) {
    {
#line 1193
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: enter\n",
            "accept_connection");
#line 1196
    fflush(where);
    }
  }
  {
#line 1199
  peeraddrlen = (unsigned int )sizeof(peeraddr);
#line 1205
  server_control = listen_fd;
#line 1207
  server_sock = accept(listen_fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peeraddr)),
                       (socklen_t */* __restrict  */)(& peeraddrlen));
  }
#line 1207
  if (server_sock == -1) {
    {
#line 1210
    tmp = __errno_location();
#line 1210
    tmp___0 = __errno_location();
#line 1210
    tmp___1 = strerror(*tmp___0);
#line 1210
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: accept failure: %s (errno %d)\n",
            "accept_connection", tmp___1, *tmp);
#line 1215
    fflush(where);
#line 1216
    exit(1);
    }
  }
  {
#line 1222
  setsockopt(server_sock, 1, 9, (void const   *)((char const   *)(& on)), (socklen_t )sizeof(on));
  }
#line 1229
  if (spawn_on_accept) {
    {
#line 1230
    spawn_child();
#line 1232
    close(server_sock);
    }
  } else {
    {
#line 1235
    process_requests();
    }
  }
#line 1237
  return;
}
}
#line 1239 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
void accept_connections(void) 
{ 
  fd_set read_fds ;
  fd_set write_fds ;
  fd_set except_fds ;
  int high_fd ;
  int candidate ;
  int num_ready ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 1246
  if (debug) {
    {
#line 1247
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: enter\n",
            "accept_connections");
#line 1250
    fflush(where);
    }
  }
  {
#line 1253
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1255
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1255
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& write_fds.__fds_bits[0]): "memory");
#line 1255
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1256
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1256
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& except_fds.__fds_bits[0]): "memory");
#line 1256
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1257
    high_fd = set_fdset(listen_list, & read_fds);
#line 1260
    num_ready = select(high_fd + 1, (fd_set */* __restrict  */)(& read_fds), (fd_set */* __restrict  */)(& write_fds),
                       (fd_set */* __restrict  */)(& except_fds), (struct timeval */* __restrict  */)((void *)0));
    }
#line 1269
    if (num_ready < 0) {
      {
#line 1270
      tmp = __errno_location();
#line 1270
      tmp___0 = __errno_location();
#line 1270
      tmp___1 = strerror(*tmp___0);
#line 1270
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: select failure: %s (errno %d)\n",
              "accept_connections", tmp___1, *tmp);
#line 1275
      fflush(where);
#line 1276
      exit(1);
      }
    }
#line 1280
    candidate = 0;
    {
#line 1281
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1281
      if (num_ready) {
#line 1281
        if (! (candidate <= high_fd)) {
#line 1281
          goto while_break___2;
        }
      } else {
#line 1281
        goto while_break___2;
      }
#line 1282
      if ((read_fds.__fds_bits[candidate / (8 * (int )sizeof(__fd_mask ))] & (1L << candidate % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 1283
        accept_connection(candidate);
#line 1284
        read_fds.__fds_bits[candidate / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << candidate % (8 * (int )sizeof(__fd_mask )));
#line 1285
        num_ready --;
        }
      } else {
#line 1288
        candidate ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1299 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
void scan_netserver_args(int argc , char **argv ) 
{ 
  int c ;
  char arg1[8192] ;
  char arg2[8192] ;
  void *tmp ;

  {
#line 1305
  if (debug) {
    {
#line 1306
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: enter\n",
            "scan_netserver_args");
#line 1309
    fflush(where);
    }
  }
  {
#line 1312
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1312
    c = getopt(argc, (char * const  *)argv, "DdfhL:n:Np:v:VZ:46");
    }
#line 1312
    if (! (c != -1)) {
#line 1312
      goto while_break;
    }
    {
#line 1315
    if (c == 104) {
#line 1315
      goto case_104;
    }
#line 1315
    if (c == 63) {
#line 1315
      goto case_104;
    }
#line 1318
    if (c == 100) {
#line 1318
      goto case_100;
    }
#line 1322
    if (c == 68) {
#line 1322
      goto case_68;
    }
#line 1327
    if (c == 102) {
#line 1327
      goto case_102;
    }
#line 1338
    if (c == 76) {
#line 1338
      goto case_76;
    }
#line 1348
    if (c == 110) {
#line 1348
      goto case_110;
    }
#line 1359
    if (c == 78) {
#line 1359
      goto case_78;
    }
#line 1363
    if (c == 112) {
#line 1363
      goto case_112;
    }
#line 1368
    if (c == 90) {
#line 1368
      goto case_90;
    }
#line 1383
    if (c == 52) {
#line 1383
      goto case_52;
    }
#line 1386
    if (c == 54) {
#line 1386
      goto case_54;
    }
#line 1393
    if (c == 118) {
#line 1393
      goto case_118;
    }
#line 1397
    if (c == 86) {
#line 1397
      goto case_86;
    }
#line 1313
    goto switch_break;
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 1316
    print_netserver_usage();
#line 1317
    exit(1);
    }
    case_100: /* CIL Label */ 
#line 1319
    debug ++;
#line 1320
    suppress_debug = 0;
#line 1321
    goto switch_break;
    case_68: /* CIL Label */ 
#line 1324
    want_daemonize = 0;
#line 1325
    not_inetd = 1;
#line 1326
    goto switch_break;
    case_102: /* CIL Label */ 
#line 1328
    spawn_on_accept = 0;
#line 1329
    not_inetd = 1;
#line 1330
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 1339
    not_inetd = 1;
#line 1340
    break_args_explicit(optarg, arg1, arg2);
    }
#line 1341
    if (arg1[0]) {
      {
#line 1342
      strncpy((char */* __restrict  */)(local_host_name), (char const   */* __restrict  */)(arg1),
              sizeof(local_host_name));
      }
    }
#line 1344
    if (arg2[0]) {
      {
#line 1345
      local_address_family = parse_address_family(arg2);
      }
    }
#line 1347
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 1349
    shell_num_cpus = atoi((char const   *)optarg);
    }
#line 1350
    if (shell_num_cpus > 256) {
      {
#line 1351
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"netserver: This version can only support %d CPUs. Pleaseincrease MAXCPUS in netlib.h and recompile.\n",
              256);
#line 1355
      fflush(stderr);
#line 1356
      exit(1);
      }
    }
#line 1358
    goto switch_break;
    case_78: /* CIL Label */ 
#line 1360
    suppress_debug = 1;
#line 1361
    debug = 0;
#line 1362
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 1365
    strncpy((char */* __restrict  */)(listen_port), (char const   */* __restrict  */)optarg,
            sizeof(listen_port));
#line 1366
    not_inetd = 1;
    }
#line 1367
    goto switch_break;
    case_90: /* CIL Label */ 
#line 1376
    if ((unsigned long )passphrase == (unsigned long )((void *)0)) {
      {
#line 1377
      tmp = malloc(sizeof(netperf_request.content.test_specific_data));
#line 1377
      passphrase = (char *)tmp;
      }
    }
    {
#line 1378
    strncpy((char */* __restrict  */)passphrase, (char const   */* __restrict  */)optarg,
            sizeof(netperf_request.content.test_specific_data));
#line 1381
    *(passphrase + (sizeof(netperf_request.content.test_specific_data) - 1UL)) = (char )'\000';
    }
#line 1382
    goto switch_break;
    case_52: /* CIL Label */ 
#line 1384
    local_address_family = 2;
#line 1385
    goto switch_break;
    case_54: /* CIL Label */ 
#line 1388
    local_address_family = 10;
#line 1392
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 1395
    verbosity = atoi((char const   *)optarg);
    }
#line 1396
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 1398
    printf((char const   */* __restrict  */)"Netperf version %s\n", "2.6.0");
#line 1399
    exit(0);
    }
#line 1400
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1404
  return;
}
}
#line 1406 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
void daemonize(void) 
{ 
  __pid_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 1410
  if (debug) {
    {
#line 1411
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: enter\n",
            "daemonize");
#line 1414
    fflush(where);
    }
  }
  {
#line 1418
  fflush(stdin);
#line 1419
  fflush(stdout);
#line 1420
  fflush(stderr);
#line 1422
  tmp = fork();
  }
  {
#line 1423
  if (tmp == -1) {
#line 1423
    goto case_neg_1;
  }
#line 1431
  if (tmp == 0) {
#line 1431
    goto case_0;
  }
#line 1454
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 1424
  tmp___0 = __errno_location();
#line 1424
  tmp___1 = __errno_location();
#line 1424
  tmp___2 = strerror(*tmp___1);
#line 1424
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: fork() error %s (errno %d)\n",
          "daemonize", tmp___2, *tmp___0);
#line 1429
  fflush(stderr);
#line 1430
  exit(1);
  }
  case_0: /* CIL Label */ 
  {
#line 1436
  chdir("/var/log/");
#line 1441
  open_debug_file();
#line 1444
  setsid();
#line 1449
  signal(17, (void (*)(int  ))1);
#line 1452
  accept_connections();
  }
  switch_default: /* CIL Label */ 
  {
#line 1456
  exit(0);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1468 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
static void check_if_inetd(void) 
{ 
  struct sockaddr_storage name ;
  unsigned int namelen ;
  int tmp ;

  {
#line 1471
  if (debug) {
    {
#line 1472
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: enter\n",
            "check_if_inetd");
#line 1475
    fflush(where);
    }
  }
#line 1478
  if (not_inetd) {
#line 1479
    return;
  } else {
    {
#line 1486
    namelen = (unsigned int )sizeof(name);
#line 1487
    tmp = getsockname(0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& name)),
                      (socklen_t */* __restrict  */)(& namelen));
    }
#line 1487
    if (tmp == -1) {
#line 1490
      not_inetd = 1;
    } else {
#line 1493
      not_inetd = 0;
#line 1494
      child = 1;
    }
  }
#line 1498
  return;
}
}
#line 1533 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netserver.c"
int main(int argc , char **argv ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 1547
  tmp = strlen((char const   *)*(argv + 0));
#line 1547
  tmp___0 = malloc(tmp + 1UL);
#line 1547
  program = (char *)tmp___0;
  }
#line 1548
  if ((unsigned long )program == (unsigned long )((void *)0)) {
    {
#line 1549
    printf((char const   */* __restrict  */)"malloc for program name failed!\n");
    }
#line 1550
    return (-1);
  }
  {
#line 1552
  strcpy((char */* __restrict  */)program, (char const   */* __restrict  */)*(argv + 0));
#line 1554
  init_netserver_globals();
#line 1556
  netlib_init();
#line 1558
  strncpy((char */* __restrict  */)(local_host_name), (char const   */* __restrict  */)"",
          sizeof(local_host_name));
#line 1559
  local_address_family = 0;
#line 1560
  strncpy((char */* __restrict  */)(listen_port), (char const   */* __restrict  */)"12865",
          sizeof(listen_port));
#line 1562
  scan_netserver_args(argc, argv);
#line 1564
  check_if_inetd();
  }
#line 1566
  if (child) {
    {
#line 1572
    set_server_sock();
#line 1573
    open_debug_file();
#line 1574
    process_requests();
    }
  } else
#line 1576
  if (daemon_parent) {
    {
#line 1580
    accept_connections();
    }
  } else {
    {
#line 1585
    setup_listens(local_host_name, listen_port, local_address_family);
    }
#line 1586
    if (want_daemonize) {
      {
#line 1587
      daemonize();
      }
    }
    {
#line 1589
    accept_connections();
    }
  }
  {
#line 1592
  unlink_empty_debug_file();
  }
#line 1598
  return (0);
}
}
#line 6 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char nettest_omni_id[77]  = 
#line 6 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
  {      (char )'@',      (char )'(',      (char )'#',      (char )')', 
        (char )'n',      (char )'e',      (char )'t',      (char )'t', 
        (char )'e',      (char )'s',      (char )'t',      (char )'_', 
        (char )'o',      (char )'m',      (char )'n',      (char )'i', 
        (char )'.',      (char )'c',      (char )' ',      (char )'(', 
        (char )'c',      (char )')',      (char )' ',      (char )'C', 
        (char )'o',      (char )'p',      (char )'y',      (char )'r', 
        (char )'i',      (char )'g',      (char )'h',      (char )'t', 
        (char )' ',      (char )'2',      (char )'0',      (char )'0', 
        (char )'8',      (char )'-',      (char )'2',      (char )'0', 
        (char )'1',      (char )'2',      (char )' ',      (char )'H', 
        (char )'e',      (char )'w',      (char )'l',      (char )'e', 
        (char )'t',      (char )'t',      (char )'-',      (char )'P', 
        (char )'a',      (char )'c',      (char )'k',      (char )'a', 
        (char )'r',      (char )'d',      (char )' ',      (char )'C', 
        (char )'o',      (char )'.',      (char )' ',      (char )'V', 
        (char )'e',      (char )'r',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'2', 
        (char )'.',      (char )'6',      (char )'.',      (char )'0', 
        (char )'\000'};
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 137 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 219
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 357 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 454 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.h"
int local_proc_affinity ;
#line 454
int remote_proc_affinity ;
#line 458
char local_data_port[10] ;
#line 459
char remote_data_port[10] ;
#line 461
char *local_data_address ;
#line 462
char *remote_data_address ;
#line 464
char *remote_sysname ;
#line 465
char *remote_release ;
#line 466
char *remote_version ;
#line 467
char *remote_machine ;
#line 469
int local_data_family ;
#line 470
int remote_data_family ;
#line 479
double lib_local_peak_cpu_util ;
#line 480
int lib_local_peak_cpu_id ;
#line 481
double lib_remote_peak_cpu_util ;
#line 482
int lib_remote_peak_cpu_id ;
#line 484
char libfmt ;
#line 486
int cpu_method ;
#line 488
int lib_num_rem_cpus ;
#line 490
int times_up ;
#line 495
enum netperf_output_modes netperf_output_mode ;
#line 525
void init_stat(void) ;
#line 531
void send_request_n(int n ) ;
#line 532
void recv_response_n(int n ) ;
#line 535
void fixup_request_n(int n ) ;
#line 539
void start_timer(int time___0 ) ;
#line 540
void stop_timer(void) ;
#line 541
void cpu_start(int measure_cpu ) ;
#line 542
void cpu_stop(int measure_cpu , float *elapsed ) ;
#line 543
void calculate_confidence(int confidence_iterations___0 , float time___0 , double result ,
                          float loc_cpu , float rem_cpu , float loc_sd , float rem_sd ) ;
#line 550
void retrieve_confident_values(float *elapsed_time___0 , double *thruput___0 , float *local_cpu_utilization___0 ,
                               float *remote_cpu_utilization___0 , float *local_service_demand___0 ,
                               float *remote_service_demand___0 ) ;
#line 556
double get_result_confid(void) ;
#line 557
double get_loc_cpu_confid(void) ;
#line 558
double get_rem_cpu_confid(void) ;
#line 559
void display_confidence(void) ;
#line 560
void get_sock_buffer(int sd , enum sock_buffer which , int *effective_sizep ) ;
#line 567
char *format_units(void) ;
#line 569
void get_remote_system_info(void) ;
#line 574
char *nsec_enabled_to_str(int enabled ) ;
#line 575
char *nsec_type_to_str(int type ) ;
#line 579
void random_ip_address(struct addrinfo *res , int mask_len ) ;
#line 581
double calc_thruput(double units_received ) ;
#line 584
double calc_thruput_interval_omni(double units_received , double elapsed ) ;
#line 589
char *find_egress_interface(struct sockaddr *source , struct sockaddr *dest ) ;
#line 590
char *find_interface_slot(char *interface_name ) ;
#line 591
void find_interface_ids(char *interface_name , int *vendor , int *device , int *sub_vend ,
                        int *sub_dev ) ;
#line 592
void find_driver_info(char *ifname , char *driver , char *version , char *firmware ,
                      char *bus , int len ) ;
#line 593
void find_system_info(char **system_model , char **cpu_model , int *cpu_frequency ) ;
#line 594
int HIST_get_percentile(HIST h , double const   percentile ) ;
#line 595
void HIST_get_stats(HIST h , int *min , int *max , double *mean , double *stddev ) ;
#line 596
void find_security_info(int *enabled , int *type , char **specific ) ;
#line 607
float calc_cpu_util(float elapsed_time___0 ) ;
#line 613
float calc_service_demand_fmt(double units_sent , float elapsed_time___0 , float cpu_utilization ,
                              int num_cpus ) ;
#line 622
struct ring_elt *allocate_buffer_ring(int width , int buffer_size , int alignment ,
                                      int offset ) ;
#line 643
char format_cpu_method(int method ) ;
#line 644
unsigned int convert(char *string ) ;
#line 652
double confidence ;
#line 78 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.h"
char *command_line ;
#line 90
int parse_socket_type(char *socket_string ) ;
#line 91
int parse_protocol(char *protocol_string ) ;
#line 92
int parse_direction(char *direction_string ) ;
#line 96
void break_args(char *s , char *arg1 , char *arg2 ) ;
#line 98
void break_args_explicit_sep(char *s , int sep , char *arg1 , char *arg2 ) ;
#line 102
int print_headers ;
#line 102
int keep_histogram ;
#line 102
int keep_statistics ;
#line 111
int test_time ;
#line 111
int test_bytes ;
#line 111
int test_trans ;
#line 119
int wait_time_secs ;
#line 122
int local_recv_align ;
#line 122
int local_send_align ;
#line 122
int remote_recv_align ;
#line 122
int remote_send_align ;
#line 122
int local_send_offset ;
#line 122
int local_recv_offset ;
#line 122
int remote_send_offset ;
#line 122
int remote_recv_offset ;
#line 122
int remote_send_width ;
#line 122
int remote_recv_width ;
#line 137
int interval_usecs ;
#line 138
int interval_wate ;
#line 139
int interval_burst ;
#line 140
int remote_interval_usecs ;
#line 141
int remote_interval_burst ;
#line 153
int confidence_level ;
#line 154
int iteration_min ;
#line 155
int iteration_max ;
#line 157
double interval ;
#line 158
double interval_pct ;
#line 163
int send_width ;
#line 164
int recv_width ;
#line 167
int local_socket_prio ;
#line 168
int remote_socket_prio ;
#line 170
int local_socket_tos ;
#line 171
int remote_socket_tos ;
#line 177
int local_cpu_usage ;
#line 177
int remote_cpu_usage ;
#line 181
float local_cpu_rate ;
#line 181
float remote_cpu_rate ;
#line 188
char test_name[8192] ;
#line 191
char local_fill_file[8192] ;
#line 191
char remote_fill_file[32] ;
#line 195
char *result_brand ;
#line 198
int no_control ;
#line 552 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
int socket_type ;
#line 552
int rss_size_req ;
#line 552
int rsr_size_req ;
#line 552
int rss_size ;
#line 552
int rsr_size ;
#line 552
int rsr_size_end ;
#line 552
int rss_size_end ;
#line 552
int lss_size_req ;
#line 552
int lsr_size_req ;
#line 552
int lss_size ;
#line 552
int lsr_size ;
#line 552
int lss_size_end ;
#line 552
int lsr_size_end ;
#line 552
int req_size ;
#line 552
int rsp_size ;
#line 552
int send_size ;
#line 552
int recv_size ;
#line 552 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
int loc_nodelay  ;
#line 552 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
int rem_nodelay  ;
#line 552 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
int loc_sndavoid  ;
#line 552 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
int loc_rcvavoid  ;
#line 552 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
int rem_sndavoid  ;
#line 552 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
int rem_rcvavoid  ;
#line 552
int routing_allowed ;
#line 552
int multicast_ttl ;
#line 552
int want_keepalive ;
#line 552
int transport_mss_req ;
#line 582
void scan_omni_args(int argc , char **argv ) ;
#line 585
struct addrinfo *complete_addrinfo(char *controlhost , char *data_address , char *port ,
                                   int family , int type , int protocol___0 , int flags ) ;
#line 592
void complete_addrinfos(struct addrinfo **remote , struct addrinfo **local , char *remote_host ,
                        int type , int protocol___0 , int flags ) ;
#line 598
int af_to_nf(int af___0 ) ;
#line 599
int nf_to_af(int nf ) ;
#line 600
int nst_to_hst(int nst ) ;
#line 601
int hst_to_nst(int hst ) ;
#line 602
char *hst_to_str(int hst ) ;
#line 603
char *protocol_to_str(int protocol___0 ) ;
#line 604
void print_top_test_header(char *test_name___0 , struct addrinfo *source , struct addrinfo *destination ) ;
#line 607
void set_port_number(struct addrinfo *res , unsigned short port ) ;
#line 613
void set_sockaddr_family_addr_port(struct sockaddr_storage *sockaddr , int family ,
                                   void *addr , int port ) ;
#line 617
int get_sockaddr_family_addr_port(struct sockaddr_storage *sockaddr , int family ,
                                  void *addr , int *port ) ;
#line 622
void send_tcp_stream(char *remote_host ) ;
#line 623
void send_tcp_maerts(char *remote_host ) ;
#line 624
void send_tcp_rr(char *remote_host ) ;
#line 625
void send_tcp_conn_rr(char *remote_host ) ;
#line 627
void send_udp_stream(char *remote_host ) ;
#line 628
void send_udp_rr(char *remote_host ) ;
#line 630
void send_omni(char *remote_host ) ;
#line 631
void print_uuid(char *remote_host ) ;
#line 663
int create_data_socket(struct addrinfo *res ) ;
#line 97 "/home/wheatley/newnew/temp/netperf-2.6.0/src/hist.h"
HIST HIST_new_n(int max_outstanding ) ;
#line 111
void HIST_purge(HIST h ) ;
#line 145
void HIST_timestamp_start(HIST h ) ;
#line 152
void HIST_timestamp_stop_add(HIST h ) ;
#line 136 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static HIST time_hist  ;
#line 288
void get_uuid_string(char *uuid_str , size_t size ) ;
#line 291 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *output_selection_spec  =    (char *)((void *)0);
#line 293 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char test_uuid[38]  ;
#line 295 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double result_confid_pct  =    - 1.0;
#line 296 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double loc_cpu_confid_pct  =    - 1.0;
#line 297 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double rem_cpu_confid_pct  =    - 1.0;
#line 298 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double interval_pct  =    - 1.0;
#line 300 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int protocol  ;
#line 301 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int direction  ;
#line 302 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int remote_send_size  =    -1;
#line 303 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int remote_recv_size  =    -1;
#line 304 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int remote_send_size_req  =    -1;
#line 305 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int remote_recv_size_req  =    -1;
#line 306 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int remote_use_sendfile  ;
#line 312
int loc_dirty_count ;
#line 313
int loc_clean_count ;
#line 314
int rem_dirty_count ;
#line 315
int rem_clean_count ;
#line 316 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int remote_checksum_off  ;
#line 317 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int connection_test  ;
#line 318 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int need_to_connect  ;
#line 319 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int need_connection  ;
#line 320 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int bytes_to_send  ;
#line 321 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double bytes_per_send  ;
#line 322 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int failed_sends  ;
#line 323 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int bytes_to_recv  ;
#line 324 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double bytes_per_recv  ;
#line 325 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int null_message_ok  =    0;
#line 327 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int was_legacy  =    0;
#line 328 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int legacy  =    0;
#line 329 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int implicit_direction  =    0;
#line 330 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int explicit_data_address  =    0;
#line 332 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
uint64_t trans_completed  =    (uint64_t )0;
#line 333 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int64_t units_remaining  ;
#line 334 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
uint64_t bytes_sent  =    (uint64_t )0;
#line 335 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
uint64_t bytes_received  =    (uint64_t )0;
#line 336 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
uint64_t local_send_calls  =    (uint64_t )0;
#line 337 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
uint64_t local_receive_calls  =    (uint64_t )0;
#line 338 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
uint64_t remote_bytes_sent  ;
#line 339 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
uint64_t remote_bytes_received  ;
#line 340 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
uint64_t remote_send_calls  ;
#line 341 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
uint64_t remote_receive_calls  ;
#line 342 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double bytes_xferd  ;
#line 343 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double remote_bytes_xferd  ;
#line 344 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double remote_bytes_per_recv  ;
#line 345 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double remote_bytes_per_send  ;
#line 346 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
float elapsed_time  ;
#line 347 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
float local_cpu_utilization  ;
#line 348 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
float local_service_demand  ;
#line 349 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
float remote_cpu_utilization  ;
#line 350 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
float remote_service_demand  ;
#line 351 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double thruput  ;
#line 352 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double local_send_thruput  ;
#line 353 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double local_recv_thruput  ;
#line 354 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double remote_send_thruput  ;
#line 355 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double remote_recv_thruput  ;
#line 358 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double elapsed_time_double  ;
#line 359 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double local_cpu_utilization_double  ;
#line 360 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double local_service_demand_double  ;
#line 361 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double remote_cpu_utilization_double  ;
#line 362 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double remote_service_demand_double  ;
#line 363 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double transaction_rate  =    1.0;
#line 364 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double rtt_latency  =    - 1.0;
#line 365 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int32_t transport_mss  =    -2;
#line 366 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int32_t local_transport_retrans  =    -2;
#line 367 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int32_t remote_transport_retrans  =    -2;
#line 368 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *local_interface_name  =    (char *)((void *)0);
#line 369 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *remote_interface_name  =    (char *)((void *)0);
#line 370 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char local_driver_name[32]  = {      (char )'\000'};
#line 371 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char local_driver_version[32]  = {      (char )'\000'};
#line 372 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char local_driver_firmware[32]  = {      (char )'\000'};
#line 373 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char local_driver_bus[32]  = {      (char )'\000'};
#line 374 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char remote_driver_name[32]  = {      (char )'\000'};
#line 375 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char remote_driver_version[32]  = {      (char )'\000'};
#line 376 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char remote_driver_firmware[32]  = {      (char )'\000'};
#line 377 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char remote_driver_bus[32]  = {      (char )'\000'};
#line 378 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *local_interface_slot  =    (char *)((void *)0);
#line 379 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *remote_interface_slot  =    (char *)((void *)0);
#line 380 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int remote_interface_vendor  ;
#line 381 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int remote_interface_device  ;
#line 382 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int remote_interface_subvendor  ;
#line 383 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int remote_interface_subdevice  ;
#line 384 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int local_interface_vendor  ;
#line 385 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int local_interface_device  ;
#line 386 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int local_interface_subvendor  ;
#line 387 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int local_interface_subdevice  ;
#line 388 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *local_system_model  =    (char *)((void *)0);
#line 389 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *local_cpu_model  =    (char *)((void *)0);
#line 390 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int local_cpu_frequency  ;
#line 391 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *remote_system_model  =    (char *)((void *)0);
#line 392 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *remote_cpu_model  =    (char *)((void *)0);
#line 393 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int remote_cpu_frequency  ;
#line 395 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int local_security_type_id  ;
#line 396 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int local_security_enabled_num  ;
#line 397 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *local_security_type  =    (char *)((void *)0);
#line 398 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *local_security_enabled  =    (char *)((void *)0);
#line 399 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *local_security_specific  =    (char *)((void *)0);
#line 400 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int remote_security_type_id  ;
#line 401 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int remote_security_enabled_num  ;
#line 402 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *remote_security_enabled  =    (char *)((void *)0);
#line 403 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *remote_security_type  =    (char *)((void *)0);
#line 404 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *remote_security_specific  =    (char *)((void *)0);
#line 406 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char local_cong_control[16]  = {      (char )'\000'};
#line 407 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char remote_cong_control[16]  = {      (char )'\000'};
#line 408 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char local_cong_control_req[16]  = {      (char )'\000'};
#line 409 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char remote_cong_control_req[16]  = {      (char )'\000'};
#line 416 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int min_latency  =    -1;
#line 416 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int max_latency  =    -1;
#line 418 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int p50_latency  =    -1;
#line 418 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int p90_latency  =    -1;
#line 418 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int p99_latency  =    -1;
#line 421 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double mean_latency  =    - 1.0;
#line 421 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
double stddev_latency  =    - 1.0;
#line 424 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int local_mask_len  =    0;
#line 425 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int remote_mask_len  =    0;
#line 427 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int printing_initialized  =    0;
#line 429 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *sd_str  ;
#line 430 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *thruput_format_str  ;
#line 432 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *socket_type_str  ;
#line 433 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *protocol_str  ;
#line 434 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *direction_str  ;
#line 436
int first_burst_size ;
#line 442 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int confidence_iteration  ;
#line 444 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int local_cpu_method  ;
#line 445 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int remote_cpu_method  ;
#line 449 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int client_port_min  =    5000;
#line 450 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int client_port_max  =    65535;
#line 462
int loc_tcpcork ;
#line 462
int rem_tcpcork ;
#line 462
int local_connected ;
#line 462
int remote_connected ;
#line 667 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
unsigned int desired_output_groups  =    0U;
#line 682 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
netperf_output_elt_t netperf_output_source[166]  ;
#line 690 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
enum netperf_output_name output_list[4][166]  ;
#line 692 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *direction_to_str(int direction___0 ) 
{ 


  {
#line 693
  if (direction___0 & 4) {
#line 693
    if (! (direction___0 & 2)) {
#line 693
      return ((char *)"Receive");
    }
  }
#line 694
  if (direction___0 & 2) {
#line 694
    if (! (direction___0 & 4)) {
#line 694
      return ((char *)"Send");
    }
  }
#line 695
  if (! (direction___0 & 2)) {
#line 695
    if (! (direction___0 & 4)) {
#line 695
      return ((char *)"Connection");
    } else {
#line 695
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 696
  if (connection_test) {
#line 697
    return ((char *)"Connect|Send|Recv");
  } else {
#line 699
    return ((char *)"Send|Recv");
  }
}
}
#line 702 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static unsigned short get_port_number(struct addrinfo *res ) 
{ 
  struct sockaddr_in *foo ;
  uint16_t tmp ;
  struct sockaddr_in6 *foo___0 ;
  uint16_t tmp___0 ;

  {
  {
#line 706
  if (res->ai_family == 2) {
#line 706
    goto case_2;
  }
#line 712
  if (res->ai_family == 10) {
#line 712
    goto case_10;
  }
#line 718
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 707
  foo = (struct sockaddr_in *)res->ai_addr;
#line 708
  tmp = ntohs(foo->sin_port);
  }
#line 708
  return (tmp);
#line 709
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 713
  foo___0 = (struct sockaddr_in6 *)res->ai_addr;
#line 714
  tmp___0 = ntohs(foo___0->sin6_port);
  }
#line 714
  return (tmp___0);
#line 715
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 719
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Unexpected Address Family %u\n",
          res->ai_family);
#line 721
  fflush(where);
#line 722
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 724
  return ((unsigned short)0);
}
}
#line 729 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int is_multicast_addr(struct addrinfo *res ) 
{ 
  struct in_addr bar ;
  uint32_t tmp ;
  struct in6_addr *bar___0 ;

  {
  {
#line 732
  if (res->ai_family == 2) {
#line 732
    goto case_2;
  }
#line 742
  if (res->ai_family == 10) {
#line 742
    goto case_10;
  }
#line 747
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 736
  bar = ((struct sockaddr_in *)res->ai_addr)->sin_addr;
#line 739
  tmp = ntohl(bar.s_addr);
  }
#line 739
  return ((tmp & 4026531840U) == 3758096384U);
  case_10: /* CIL Label */ 
#line 743
  bar___0 = & ((struct sockaddr_in6 *)res->ai_addr)->sin6_addr;
#line 744
  return ((int const   )*((uint8_t const   *)bar___0 + 0) == 255);
  switch_default: /* CIL Label */ 
  {
#line 748
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Unexpected Address Family for Multicast Check %u\n",
          res->ai_family);
#line 751
  fflush(where);
  }
#line 752
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 756 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void set_multicast_ttl(int sock ) 
{ 
  int optlen ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 758
  optlen = (int )sizeof(int );
#line 761
  if (multicast_ttl >= 0) {
    {
#line 762
    tmp___0 = setsockopt(sock, 0, 2, (void const   *)((char const   *)(& multicast_ttl)),
                         (socklen_t )sizeof(multicast_ttl));
    }
#line 762
    if (tmp___0 == -1) {
      {
#line 767
      tmp = __errno_location();
#line 767
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"setsockopt(IP_TTL) failed errno %d\n",
              *tmp);
      }
    }
  }
  {
#line 772
  tmp___2 = getsockopt(sock, 0, 2, (void */* __restrict  */)((char *)(& multicast_ttl)),
                       (socklen_t */* __restrict  */)((unsigned int *)(& optlen)));
  }
#line 772
  if (tmp___2 < 0) {
    {
#line 777
    tmp___1 = __errno_location();
#line 777
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"getsockopt(IP_TTL) failed errno %d\n",
            *tmp___1);
#line 780
    multicast_ttl = -2;
    }
  }
#line 782
  return;
}
}
#line 786 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void join_multicast_addr(int sock , struct addrinfo *res ) 
{ 
  struct ip_mreq mreq ;
  struct in_addr bar ;
  int optlen ;
  int one ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 789
  if (res->ai_family == 2) {
#line 789
    goto case_2;
  }
#line 850
  if (res->ai_family == 10) {
#line 850
    goto case_10;
  }
#line 788
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 791
  bar = ((struct sockaddr_in *)res->ai_addr)->sin_addr;
#line 792
  optlen = (int )sizeof(int );
#line 793
  one = 1;
#line 795
  mreq.imr_multiaddr.s_addr = bar.s_addr;
#line 796
  mreq.imr_interface.s_addr = htonl((in_addr_t )0);
#line 797
  tmp___6 = setsockopt(sock, 0, 35, (void const   *)((char const   *)(& mreq)), (socklen_t )sizeof(mreq));
  }
#line 797
  if (tmp___6 == 0) {
    {
#line 804
    tmp___0 = setsockopt(sock, 1, 2, (void const   *)((char const   *)(& one)), (socklen_t )sizeof(one));
    }
#line 804
    if (tmp___0 == -1) {
#line 809
      if (debug) {
        {
#line 810
        tmp = __errno_location();
#line 810
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"join_multicast_addr SO_REUSADDR failed errno %d\n",
                *tmp);
#line 813
        fflush(where);
        }
      }
    }
#line 818
    if (multicast_ttl >= 0) {
      {
#line 819
      tmp___2 = setsockopt(sock, 0, 2, (void const   *)((char const   *)(& multicast_ttl)),
                           (socklen_t )sizeof(multicast_ttl));
      }
#line 819
      if (tmp___2 == -1) {
        {
#line 824
        tmp___1 = __errno_location();
#line 824
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"setsockopt(IP_TTL) failed errno %d\n",
                *tmp___1);
        }
      }
    }
    {
#line 829
    tmp___4 = getsockopt(sock, 0, 2, (void */* __restrict  */)((char *)(& multicast_ttl)),
                         (socklen_t */* __restrict  */)((unsigned int *)(& optlen)));
    }
#line 829
    if (tmp___4 == -1) {
      {
#line 834
      tmp___3 = __errno_location();
#line 834
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"getsockopt(IP_TTL) failed errno %d\n",
              *tmp___3);
#line 837
      multicast_ttl = -2;
      }
    }
  } else
#line 841
  if (debug) {
    {
#line 842
    tmp___5 = __errno_location();
#line 842
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"setsockopt(IP_ADD_MEMBERSHIP) failed errno %d\n",
            *tmp___5);
#line 845
    fflush(where);
    }
  }
#line 848
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 851
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"I do not know how to join an IPv6 multicast group\n");
  }
#line 852
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 856
  return;
}
}
#line 886
void pick_next_port_number(struct addrinfo *local_res , struct addrinfo *remote_res ) ;
#line 886 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int myport_init  =    0;
#line 887 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static unsigned short myport  =    (unsigned short)0;
#line 883 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void pick_next_port_number(struct addrinfo *local_res , struct addrinfo *remote_res ) 
{ 
  __pid_t tmp ;
  int tmp___0 ;
  unsigned short tmp___1 ;

  {
#line 889
  if (0 == myport_init) {
    {
#line 895
    tmp = getpid();
#line 895
    srand((unsigned int )tmp);
    }
#line 896
    if (client_port_max - client_port_min) {
      {
#line 897
      tmp___0 = rand();
#line 897
      myport = (unsigned short )(client_port_min + tmp___0 % (client_port_max - client_port_min));
      }
    } else {
#line 901
      myport = (unsigned short )client_port_min;
    }
#line 904
    myport = (unsigned short )((int )myport - 1);
#line 905
    myport_init = 1;
  }
  {
#line 910
  myport = (unsigned short )((int )myport + 1);
#line 920
  tmp___1 = get_port_number(remote_res);
  }
#line 920
  if ((int )myport == (int )tmp___1) {
#line 920
    myport = (unsigned short )((int )myport + 1);
  }
#line 927
  if ((int )myport >= client_port_max) {
#line 928
    myport = (unsigned short )client_port_min;
  }
  {
#line 932
  set_port_number(local_res, myport);
  }
#line 933
  return;
}
}
#line 936 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char *netperf_output_enum_to_str(enum netperf_output_name output_name ) 
{ 


  {
  {
#line 940
  if ((unsigned int )output_name == 1U) {
#line 940
    goto case_1;
  }
#line 942
  if ((unsigned int )output_name == 164U) {
#line 942
    goto case_164;
  }
#line 944
  if ((unsigned int )output_name == 148U) {
#line 944
    goto case_148;
  }
#line 946
  if ((unsigned int )output_name == 147U) {
#line 946
    goto case_147;
  }
#line 948
  if ((unsigned int )output_name == 2U) {
#line 948
    goto case_2;
  }
#line 950
  if ((unsigned int )output_name == 4U) {
#line 950
    goto case_4;
  }
#line 952
  if ((unsigned int )output_name == 3U) {
#line 952
    goto case_3;
  }
#line 954
  if ((unsigned int )output_name == 5U) {
#line 954
    goto case_5;
  }
#line 956
  if ((unsigned int )output_name == 61U) {
#line 956
    goto case_61;
  }
#line 958
  if ((unsigned int )output_name == 62U) {
#line 958
    goto case_62;
  }
#line 960
  if ((unsigned int )output_name == 63U) {
#line 960
    goto case_63;
  }
#line 962
  if ((unsigned int )output_name == 64U) {
#line 962
    goto case_64;
  }
#line 964
  if ((unsigned int )output_name == 65U) {
#line 964
    goto case_65;
  }
#line 966
  if ((unsigned int )output_name == 66U) {
#line 966
    goto case_66;
  }
#line 968
  if ((unsigned int )output_name == 6U) {
#line 968
    goto case_6;
  }
#line 970
  if ((unsigned int )output_name == 45U) {
#line 970
    goto case_45;
  }
#line 972
  if ((unsigned int )output_name == 46U) {
#line 972
    goto case_46;
  }
#line 974
  if ((unsigned int )output_name == 47U) {
#line 974
    goto case_47;
  }
#line 976
  if ((unsigned int )output_name == 48U) {
#line 976
    goto case_48;
  }
#line 978
  if ((unsigned int )output_name == 7U) {
#line 978
    goto case_7;
  }
#line 980
  if ((unsigned int )output_name == 33U) {
#line 980
    goto case_33;
  }
#line 982
  if ((unsigned int )output_name == 34U) {
#line 982
    goto case_34;
  }
#line 984
  if ((unsigned int )output_name == 35U) {
#line 984
    goto case_35;
  }
#line 986
  if ((unsigned int )output_name == 36U) {
#line 986
    goto case_36;
  }
#line 988
  if ((unsigned int )output_name == 37U) {
#line 988
    goto case_37;
  }
#line 990
  if ((unsigned int )output_name == 38U) {
#line 990
    goto case_38;
  }
#line 992
  if ((unsigned int )output_name == 40U) {
#line 992
    goto case_40;
  }
#line 994
  if ((unsigned int )output_name == 39U) {
#line 994
    goto case_39;
  }
#line 996
  if ((unsigned int )output_name == 41U) {
#line 996
    goto case_41;
  }
#line 998
  if ((unsigned int )output_name == 42U) {
#line 998
    goto case_42;
  }
#line 1000
  if ((unsigned int )output_name == 43U) {
#line 1000
    goto case_43;
  }
#line 1002
  if ((unsigned int )output_name == 44U) {
#line 1002
    goto case_44;
  }
#line 1004
  if ((unsigned int )output_name == 24U) {
#line 1004
    goto case_24;
  }
#line 1006
  if ((unsigned int )output_name == 25U) {
#line 1006
    goto case_25;
  }
#line 1008
  if ((unsigned int )output_name == 8U) {
#line 1008
    goto case_8;
  }
#line 1010
  if ((unsigned int )output_name == 9U) {
#line 1010
    goto case_9;
  }
#line 1012
  if ((unsigned int )output_name == 10U) {
#line 1012
    goto case_10;
  }
#line 1014
  if ((unsigned int )output_name == 11U) {
#line 1014
    goto case_11;
  }
#line 1016
  if ((unsigned int )output_name == 12U) {
#line 1016
    goto case_12;
  }
#line 1018
  if ((unsigned int )output_name == 13U) {
#line 1018
    goto case_13;
  }
#line 1020
  if ((unsigned int )output_name == 20U) {
#line 1020
    goto case_20;
  }
#line 1022
  if ((unsigned int )output_name == 21U) {
#line 1022
    goto case_21;
  }
#line 1024
  if ((unsigned int )output_name == 67U) {
#line 1024
    goto case_67;
  }
#line 1026
  if ((unsigned int )output_name == 68U) {
#line 1026
    goto case_68;
  }
#line 1028
  if ((unsigned int )output_name == 69U) {
#line 1028
    goto case_69;
  }
#line 1030
  if ((unsigned int )output_name == 70U) {
#line 1030
    goto case_70;
  }
#line 1032
  if ((unsigned int )output_name == 71U) {
#line 1032
    goto case_71;
  }
#line 1034
  if ((unsigned int )output_name == 72U) {
#line 1034
    goto case_72;
  }
#line 1036
  if ((unsigned int )output_name == 73U) {
#line 1036
    goto case_73;
  }
#line 1038
  if ((unsigned int )output_name == 74U) {
#line 1038
    goto case_74;
  }
#line 1040
  if ((unsigned int )output_name == 75U) {
#line 1040
    goto case_75;
  }
#line 1042
  if ((unsigned int )output_name == 77U) {
#line 1042
    goto case_77;
  }
#line 1044
  if ((unsigned int )output_name == 76U) {
#line 1044
    goto case_76;
  }
#line 1046
  if ((unsigned int )output_name == 78U) {
#line 1046
    goto case_78;
  }
#line 1048
  if ((unsigned int )output_name == 79U) {
#line 1048
    goto case_79;
  }
#line 1050
  if ((unsigned int )output_name == 80U) {
#line 1050
    goto case_80;
  }
#line 1052
  if ((unsigned int )output_name == 81U) {
#line 1052
    goto case_81;
  }
#line 1054
  if ((unsigned int )output_name == 82U) {
#line 1054
    goto case_82;
  }
#line 1056
  if ((unsigned int )output_name == 26U) {
#line 1056
    goto case_26;
  }
#line 1058
  if ((unsigned int )output_name == 49U) {
#line 1058
    goto case_49;
  }
#line 1060
  if ((unsigned int )output_name == 28U) {
#line 1060
    goto case_28;
  }
#line 1062
  if ((unsigned int )output_name == 32U) {
#line 1062
    goto case_32;
  }
#line 1064
  if ((unsigned int )output_name == 27U) {
#line 1064
    goto case_27;
  }
#line 1066
  if ((unsigned int )output_name == 50U) {
#line 1066
    goto case_50;
  }
#line 1068
  if ((unsigned int )output_name == 51U) {
#line 1068
    goto case_51;
  }
#line 1070
  if ((unsigned int )output_name == 52U) {
#line 1070
    goto case_52;
  }
#line 1072
  if ((unsigned int )output_name == 83U) {
#line 1072
    goto case_83;
  }
#line 1074
  if ((unsigned int )output_name == 84U) {
#line 1074
    goto case_84;
  }
#line 1076
  if ((unsigned int )output_name == 14U) {
#line 1076
    goto case_14;
  }
#line 1078
  if ((unsigned int )output_name == 15U) {
#line 1078
    goto case_15;
  }
#line 1080
  if ((unsigned int )output_name == 16U) {
#line 1080
    goto case_16;
  }
#line 1082
  if ((unsigned int )output_name == 17U) {
#line 1082
    goto case_17;
  }
#line 1084
  if ((unsigned int )output_name == 18U) {
#line 1084
    goto case_18;
  }
#line 1086
  if ((unsigned int )output_name == 19U) {
#line 1086
    goto case_19;
  }
#line 1088
  if ((unsigned int )output_name == 22U) {
#line 1088
    goto case_22;
  }
#line 1090
  if ((unsigned int )output_name == 23U) {
#line 1090
    goto case_23;
  }
#line 1092
  if ((unsigned int )output_name == 85U) {
#line 1092
    goto case_85;
  }
#line 1094
  if ((unsigned int )output_name == 86U) {
#line 1094
    goto case_86;
  }
#line 1096
  if ((unsigned int )output_name == 87U) {
#line 1096
    goto case_87;
  }
#line 1098
  if ((unsigned int )output_name == 88U) {
#line 1098
    goto case_88;
  }
#line 1100
  if ((unsigned int )output_name == 89U) {
#line 1100
    goto case_89;
  }
#line 1102
  if ((unsigned int )output_name == 90U) {
#line 1102
    goto case_90;
  }
#line 1104
  if ((unsigned int )output_name == 91U) {
#line 1104
    goto case_91;
  }
#line 1106
  if ((unsigned int )output_name == 92U) {
#line 1106
    goto case_92;
  }
#line 1108
  if ((unsigned int )output_name == 93U) {
#line 1108
    goto case_93;
  }
#line 1110
  if ((unsigned int )output_name == 95U) {
#line 1110
    goto case_95;
  }
#line 1112
  if ((unsigned int )output_name == 94U) {
#line 1112
    goto case_94;
  }
#line 1114
  if ((unsigned int )output_name == 96U) {
#line 1114
    goto case_96;
  }
#line 1116
  if ((unsigned int )output_name == 97U) {
#line 1116
    goto case_97;
  }
#line 1118
  if ((unsigned int )output_name == 98U) {
#line 1118
    goto case_98;
  }
#line 1120
  if ((unsigned int )output_name == 99U) {
#line 1120
    goto case_99;
  }
#line 1122
  if ((unsigned int )output_name == 100U) {
#line 1122
    goto case_100;
  }
#line 1124
  if ((unsigned int )output_name == 29U) {
#line 1124
    goto case_29;
  }
#line 1126
  if ((unsigned int )output_name == 55U) {
#line 1126
    goto case_55;
  }
#line 1128
  if ((unsigned int )output_name == 31U) {
#line 1128
    goto case_31;
  }
#line 1130
  if ((unsigned int )output_name == 30U) {
#line 1130
    goto case_30;
  }
#line 1132
  if ((unsigned int )output_name == 56U) {
#line 1132
    goto case_56;
  }
#line 1134
  if ((unsigned int )output_name == 57U) {
#line 1134
    goto case_57;
  }
#line 1136
  if ((unsigned int )output_name == 58U) {
#line 1136
    goto case_58;
  }
#line 1138
  if ((unsigned int )output_name == 101U) {
#line 1138
    goto case_101;
  }
#line 1140
  if ((unsigned int )output_name == 102U) {
#line 1140
    goto case_102;
  }
#line 1142
  if ((unsigned int )output_name == 122U) {
#line 1142
    goto case_122;
  }
#line 1144
  if ((unsigned int )output_name == 132U) {
#line 1144
    goto case_132;
  }
#line 1146
  if ((unsigned int )output_name == 127U) {
#line 1146
    goto case_127;
  }
#line 1148
  if ((unsigned int )output_name == 126U) {
#line 1148
    goto case_126;
  }
#line 1150
  if ((unsigned int )output_name == 125U) {
#line 1150
    goto case_125;
  }
#line 1152
  if ((unsigned int )output_name == 124U) {
#line 1152
    goto case_124;
  }
#line 1154
  if ((unsigned int )output_name == 117U) {
#line 1154
    goto case_117;
  }
#line 1156
  if ((unsigned int )output_name == 116U) {
#line 1156
    goto case_116;
  }
#line 1158
  if ((unsigned int )output_name == 115U) {
#line 1158
    goto case_115;
  }
#line 1160
  if ((unsigned int )output_name == 114U) {
#line 1160
    goto case_114;
  }
#line 1162
  if ((unsigned int )output_name == 113U) {
#line 1162
    goto case_113;
  }
#line 1164
  if ((unsigned int )output_name == 123U) {
#line 1164
    goto case_123;
  }
#line 1166
  if ((unsigned int )output_name == 128U) {
#line 1166
    goto case_128;
  }
#line 1168
  if ((unsigned int )output_name == 129U) {
#line 1168
    goto case_129;
  }
#line 1170
  if ((unsigned int )output_name == 130U) {
#line 1170
    goto case_130;
  }
#line 1172
  if ((unsigned int )output_name == 131U) {
#line 1172
    goto case_131;
  }
#line 1174
  if ((unsigned int )output_name == 118U) {
#line 1174
    goto case_118;
  }
#line 1176
  if ((unsigned int )output_name == 119U) {
#line 1176
    goto case_119;
  }
#line 1178
  if ((unsigned int )output_name == 120U) {
#line 1178
    goto case_120;
  }
#line 1180
  if ((unsigned int )output_name == 133U) {
#line 1180
    goto case_133;
  }
#line 1182
  if ((unsigned int )output_name == 134U) {
#line 1182
    goto case_134;
  }
#line 1184
  if ((unsigned int )output_name == 135U) {
#line 1184
    goto case_135;
  }
#line 1186
  if ((unsigned int )output_name == 136U) {
#line 1186
    goto case_136;
  }
#line 1188
  if ((unsigned int )output_name == 137U) {
#line 1188
    goto case_137;
  }
#line 1190
  if ((unsigned int )output_name == 139U) {
#line 1190
    goto case_139;
  }
#line 1192
  if ((unsigned int )output_name == 138U) {
#line 1192
    goto case_138;
  }
#line 1194
  if ((unsigned int )output_name == 140U) {
#line 1194
    goto case_140;
  }
#line 1196
  if ((unsigned int )output_name == 141U) {
#line 1196
    goto case_141;
  }
#line 1198
  if ((unsigned int )output_name == 142U) {
#line 1198
    goto case_142;
  }
#line 1200
  if ((unsigned int )output_name == 144U) {
#line 1200
    goto case_144;
  }
#line 1202
  if ((unsigned int )output_name == 143U) {
#line 1202
    goto case_143;
  }
#line 1204
  if ((unsigned int )output_name == 145U) {
#line 1204
    goto case_145;
  }
#line 1206
  if ((unsigned int )output_name == 146U) {
#line 1206
    goto case_146;
  }
#line 1208
  if ((unsigned int )output_name == 121U) {
#line 1208
    goto case_121;
  }
#line 1210
  if ((unsigned int )output_name == 108U) {
#line 1210
    goto case_108;
  }
#line 1212
  if ((unsigned int )output_name == 112U) {
#line 1212
    goto case_112;
  }
#line 1214
  if ((unsigned int )output_name == 111U) {
#line 1214
    goto case_111;
  }
#line 1216
  if ((unsigned int )output_name == 110U) {
#line 1216
    goto case_110;
  }
#line 1218
  if ((unsigned int )output_name == 103U) {
#line 1218
    goto case_103;
  }
#line 1220
  if ((unsigned int )output_name == 107U) {
#line 1220
    goto case_107;
  }
#line 1222
  if ((unsigned int )output_name == 106U) {
#line 1222
    goto case_106;
  }
#line 1224
  if ((unsigned int )output_name == 105U) {
#line 1224
    goto case_105;
  }
#line 1226
  if ((unsigned int )output_name == 59U) {
#line 1226
    goto case_59;
  }
#line 1228
  if ((unsigned int )output_name == 60U) {
#line 1228
    goto case_60;
  }
#line 1230
  if ((unsigned int )output_name == 109U) {
#line 1230
    goto case_109;
  }
#line 1232
  if ((unsigned int )output_name == 53U) {
#line 1232
    goto case_53;
  }
#line 1234
  if ((unsigned int )output_name == 54U) {
#line 1234
    goto case_54;
  }
#line 1236
  if ((unsigned int )output_name == 104U) {
#line 1236
    goto case_104;
  }
#line 1238
  if ((unsigned int )output_name == 149U) {
#line 1238
    goto case_149;
  }
#line 1240
  if ((unsigned int )output_name == 150U) {
#line 1240
    goto case_150;
  }
#line 1242
  if ((unsigned int )output_name == 151U) {
#line 1242
    goto case_151;
  }
#line 1244
  if ((unsigned int )output_name == 152U) {
#line 1244
    goto case_152;
  }
#line 1246
  if ((unsigned int )output_name == 153U) {
#line 1246
    goto case_153;
  }
#line 1248
  if ((unsigned int )output_name == 154U) {
#line 1248
    goto case_154;
  }
#line 1250
  if ((unsigned int )output_name == 155U) {
#line 1250
    goto case_155;
  }
#line 1252
  if ((unsigned int )output_name == 156U) {
#line 1252
    goto case_156;
  }
#line 1254
  if ((unsigned int )output_name == 157U) {
#line 1254
    goto case_157;
  }
#line 1256
  if ((unsigned int )output_name == 158U) {
#line 1256
    goto case_158;
  }
#line 1258
  if ((unsigned int )output_name == 159U) {
#line 1258
    goto case_159;
  }
#line 1260
  if ((unsigned int )output_name == 160U) {
#line 1260
    goto case_160;
  }
#line 1262
  if ((unsigned int )output_name == 161U) {
#line 1262
    goto case_161;
  }
#line 1264
  if ((unsigned int )output_name == 162U) {
#line 1264
    goto case_162;
  }
#line 1266
  if ((unsigned int )output_name == 163U) {
#line 1266
    goto case_163;
  }
#line 1268
  if ((unsigned int )output_name == 165U) {
#line 1268
    goto case_165;
  }
#line 1270
  goto switch_default;
  case_1: /* CIL Label */ 
#line 941
  return ((char *)"OUTPUT_NONE");
  case_164: /* CIL Label */ 
#line 943
  return ((char *)"COMMAND_LINE");
  case_148: /* CIL Label */ 
#line 945
  return ((char *)"UUID");
  case_147: /* CIL Label */ 
#line 947
  return ((char *)"RESULT_BRAND");
  case_2: /* CIL Label */ 
#line 949
  return ((char *)"SOCKET_TYPE");
  case_4: /* CIL Label */ 
#line 951
  return ((char *)"DIRECTION");
  case_3: /* CIL Label */ 
#line 953
  return ((char *)"PROTOCOL");
  case_5: /* CIL Label */ 
#line 955
  return ((char *)"ELAPSED_TIME");
  case_61: /* CIL Label */ 
#line 957
  return ((char *)"SOURCE_PORT");
  case_62: /* CIL Label */ 
#line 959
  return ((char *)"SOURCE_ADDR");
  case_63: /* CIL Label */ 
#line 961
  return ((char *)"SOURCE_FAMILY");
  case_64: /* CIL Label */ 
#line 963
  return ((char *)"DEST_PORT");
  case_65: /* CIL Label */ 
#line 965
  return ((char *)"DEST_ADDR");
  case_66: /* CIL Label */ 
#line 967
  return ((char *)"DEST_FAMILY");
  case_6: /* CIL Label */ 
#line 969
  return ((char *)"THROUGHPUT");
  case_45: /* CIL Label */ 
#line 971
  return ((char *)"LOCAL_SEND_THROUGHPUT");
  case_46: /* CIL Label */ 
#line 973
  return ((char *)"LOCAL_RECV_THROUGHPUT");
  case_47: /* CIL Label */ 
#line 975
  return ((char *)"REMOTE_SEND_THROUGHPUT");
  case_48: /* CIL Label */ 
#line 977
  return ((char *)"REMOTE_RECV_THROUGHPUT");
  case_7: /* CIL Label */ 
#line 979
  return ((char *)"THROUGHPUT_UNITS");
  case_33: /* CIL Label */ 
#line 981
  return ((char *)"CONFIDENCE_LEVEL");
  case_34: /* CIL Label */ 
#line 983
  return ((char *)"CONFIDENCE_INTERVAL");
  case_35: /* CIL Label */ 
#line 985
  return ((char *)"CONFIDENCE_ITERATION");
  case_36: /* CIL Label */ 
#line 987
  return ((char *)"THROUGHPUT_CONFID");
  case_37: /* CIL Label */ 
#line 989
  return ((char *)"LOCAL_CPU_CONFID");
  case_38: /* CIL Label */ 
#line 991
  return ((char *)"REMOTE_CPU_CONFID");
  case_40: /* CIL Label */ 
#line 993
  return ((char *)"RT_LATENCY");
  case_39: /* CIL Label */ 
#line 995
  return ((char *)"TRANSACTION_RATE");
  case_41: /* CIL Label */ 
#line 997
  return ((char *)"BURST_SIZE");
  case_42: /* CIL Label */ 
#line 999
  return ((char *)"LOCAL_TRANSPORT_RETRANS");
  case_43: /* CIL Label */ 
#line 1001
  return ((char *)"REMOTE_TRANSPORT_RETRANS");
  case_44: /* CIL Label */ 
#line 1003
  return ((char *)"TRANSPORT_MSS");
  case_24: /* CIL Label */ 
#line 1005
  return ((char *)"REQUEST_SIZE");
  case_25: /* CIL Label */ 
#line 1007
  return ((char *)"RESPONSE_SIZE");
  case_8: /* CIL Label */ 
#line 1009
  return ((char *)"LSS_SIZE_REQ");
  case_9: /* CIL Label */ 
#line 1011
  return ((char *)"LSS_SIZE");
  case_10: /* CIL Label */ 
#line 1013
  return ((char *)"LSS_SIZE_END");
  case_11: /* CIL Label */ 
#line 1015
  return ((char *)"LSR_SIZE_REQ");
  case_12: /* CIL Label */ 
#line 1017
  return ((char *)"LSR_SIZE");
  case_13: /* CIL Label */ 
#line 1019
  return ((char *)"LSR_SIZE_END");
  case_20: /* CIL Label */ 
#line 1021
  return ((char *)"LOCAL_SEND_SIZE");
  case_21: /* CIL Label */ 
#line 1023
  return ((char *)"LOCAL_RECV_SIZE");
  case_67: /* CIL Label */ 
#line 1025
  return ((char *)"LOCAL_SEND_CALLS");
  case_68: /* CIL Label */ 
#line 1027
  return ((char *)"LOCAL_RECV_CALLS");
  case_69: /* CIL Label */ 
#line 1029
  return ((char *)"LOCAL_BYTES_PER_RECV");
  case_70: /* CIL Label */ 
#line 1031
  return ((char *)"LOCAL_BYTES_PER_SEND");
  case_71: /* CIL Label */ 
#line 1033
  return ((char *)"LOCAL_BYTES_SENT");
  case_72: /* CIL Label */ 
#line 1035
  return ((char *)"LOCAL_BYTES_RECVD");
  case_73: /* CIL Label */ 
#line 1037
  return ((char *)"LOCAL_BYTES_XFERD");
  case_74: /* CIL Label */ 
#line 1039
  return ((char *)"LOCAL_SEND_OFFSET");
  case_75: /* CIL Label */ 
#line 1041
  return ((char *)"LOCAL_RECV_OFFSET");
  case_77: /* CIL Label */ 
#line 1043
  return ((char *)"LOCAL_RECV_ALIGN");
  case_76: /* CIL Label */ 
#line 1045
  return ((char *)"LOCAL_SEND_ALIGN");
  case_78: /* CIL Label */ 
#line 1047
  return ((char *)"LOCAL_SEND_WIDTH");
  case_79: /* CIL Label */ 
#line 1049
  return ((char *)"LOCAL_RECV_WIDTH");
  case_80: /* CIL Label */ 
#line 1051
  return ((char *)"LOCAL_SEND_DIRTY_COUNT");
  case_81: /* CIL Label */ 
#line 1053
  return ((char *)"LOCAL_RECV_DIRTY_COUNT");
  case_82: /* CIL Label */ 
#line 1055
  return ((char *)"LOCAL_RECV_CLEAN_COUNT");
  case_26: /* CIL Label */ 
#line 1057
  return ((char *)"LOCAL_CPU_UTIL");
  case_49: /* CIL Label */ 
#line 1059
  return ((char *)"LOCAL_CPU_BIND");
  case_28: /* CIL Label */ 
#line 1061
  return ((char *)"LOCAL_SD");
  case_32: /* CIL Label */ 
#line 1063
  return ((char *)"SD_UNITS");
  case_27: /* CIL Label */ 
#line 1065
  return ((char *)"LOCAL_CPU_METHOD");
  case_50: /* CIL Label */ 
#line 1067
  return ((char *)"LOCAL_CPU_COUNT");
  case_51: /* CIL Label */ 
#line 1069
  return ((char *)"LOCAL_CPU_PEAK_UTIL");
  case_52: /* CIL Label */ 
#line 1071
  return ((char *)"LOCAL_CPU_PEAK_ID");
  case_83: /* CIL Label */ 
#line 1073
  return ((char *)"LOCAL_NODELAY");
  case_84: /* CIL Label */ 
#line 1075
  return ((char *)"LOCAL_CORK");
  case_14: /* CIL Label */ 
#line 1077
  return ((char *)"RSS_SIZE_REQ");
  case_15: /* CIL Label */ 
#line 1079
  return ((char *)"RSS_SIZE");
  case_16: /* CIL Label */ 
#line 1081
  return ((char *)"RSS_SIZE_END");
  case_17: /* CIL Label */ 
#line 1083
  return ((char *)"RSR_SIZE_REQ");
  case_18: /* CIL Label */ 
#line 1085
  return ((char *)"RSR_SIZE");
  case_19: /* CIL Label */ 
#line 1087
  return ((char *)"RSR_SIZE_END");
  case_22: /* CIL Label */ 
#line 1089
  return ((char *)"REMOTE_SEND_SIZE");
  case_23: /* CIL Label */ 
#line 1091
  return ((char *)"REMOTE_RECV_SIZE");
  case_85: /* CIL Label */ 
#line 1093
  return ((char *)"REMOTE_SEND_CALLS");
  case_86: /* CIL Label */ 
#line 1095
  return ((char *)"REMOTE_RECV_CALLS");
  case_87: /* CIL Label */ 
#line 1097
  return ((char *)"REMOTE_BYTES_PER_RECV");
  case_88: /* CIL Label */ 
#line 1099
  return ((char *)"REMOTE_BYTES_PER_SEND");
  case_89: /* CIL Label */ 
#line 1101
  return ((char *)"REMOTE_BYTES_SENT");
  case_90: /* CIL Label */ 
#line 1103
  return ((char *)"REMOTE_BYTES_RECVD");
  case_91: /* CIL Label */ 
#line 1105
  return ((char *)"REMOTE_BYTES_XFERD");
  case_92: /* CIL Label */ 
#line 1107
  return ((char *)"REMOTE_SEND_OFFSET");
  case_93: /* CIL Label */ 
#line 1109
  return ((char *)"REMOTE_RECV_OFFSET");
  case_95: /* CIL Label */ 
#line 1111
  return ((char *)"REMOTE_RECV_ALIGN");
  case_94: /* CIL Label */ 
#line 1113
  return ((char *)"REMOTE_SEND_ALIGN");
  case_96: /* CIL Label */ 
#line 1115
  return ((char *)"REMOTE_SEND_WIDTH");
  case_97: /* CIL Label */ 
#line 1117
  return ((char *)"REMOTE_RECV_WIDTH");
  case_98: /* CIL Label */ 
#line 1119
  return ((char *)"REMOTE_SEND_DIRTY_COUNT");
  case_99: /* CIL Label */ 
#line 1121
  return ((char *)"REMOTE_RECV_DIRTY_COUNT");
  case_100: /* CIL Label */ 
#line 1123
  return ((char *)"REMOTE_RECV_CLEAN_COUNT");
  case_29: /* CIL Label */ 
#line 1125
  return ((char *)"REMOTE_CPU_UTIL");
  case_55: /* CIL Label */ 
#line 1127
  return ((char *)"REMOTE_CPU_BIND");
  case_31: /* CIL Label */ 
#line 1129
  return ((char *)"REMOTE_SD");
  case_30: /* CIL Label */ 
#line 1131
  return ((char *)"REMOTE_CPU_METHOD");
  case_56: /* CIL Label */ 
#line 1133
  return ((char *)"REMOTE_CPU_COUNT");
  case_57: /* CIL Label */ 
#line 1135
  return ((char *)"REMOTE_CPU_PEAK_UTIL");
  case_58: /* CIL Label */ 
#line 1137
  return ((char *)"REMOTE_CPU_PEAK_ID");
  case_101: /* CIL Label */ 
#line 1139
  return ((char *)"REMOTE_NODELAY");
  case_102: /* CIL Label */ 
#line 1141
  return ((char *)"REMOTE_CORK");
  case_122: /* CIL Label */ 
#line 1143
  return ((char *)"LOCAL_INTERFACE_SLOT");
  case_132: /* CIL Label */ 
#line 1145
  return ((char *)"REMOTE_INTERFACE_SLOT");
  case_127: /* CIL Label */ 
#line 1147
  return ((char *)"REMOTE_INTERFACE_SUBDEVICE");
  case_126: /* CIL Label */ 
#line 1149
  return ((char *)"REMOTE_INTERFACE_SUBVENDOR");
  case_125: /* CIL Label */ 
#line 1151
  return ((char *)"REMOTE_INTERFACE_DEVICE");
  case_124: /* CIL Label */ 
#line 1153
  return ((char *)"REMOTE_INTERFACE_VENDOR");
  case_117: /* CIL Label */ 
#line 1155
  return ((char *)"LOCAL_INTERFACE_SUBDEVICE");
  case_116: /* CIL Label */ 
#line 1157
  return ((char *)"LOCAL_INTERFACE_SUBVENDOR");
  case_115: /* CIL Label */ 
#line 1159
  return ((char *)"LOCAL_INTERFACE_DEVICE");
  case_114: /* CIL Label */ 
#line 1161
  return ((char *)"LOCAL_INTERFACE_VENDOR");
  case_113: /* CIL Label */ 
#line 1163
  return ((char *)"LOCAL_INTERFACE_NAME");
  case_123: /* CIL Label */ 
#line 1165
  return ((char *)"REMOTE_INTERFACE_NAME");
  case_128: /* CIL Label */ 
#line 1167
  return ((char *)"REMOTE_DRIVER_NAME");
  case_129: /* CIL Label */ 
#line 1169
  return ((char *)"REMOTE_DRIVER_VERSION");
  case_130: /* CIL Label */ 
#line 1171
  return ((char *)"REMOTE_DRIVER_FIRMWARE");
  case_131: /* CIL Label */ 
#line 1173
  return ((char *)"REMOTE_DRIVER_BUS");
  case_118: /* CIL Label */ 
#line 1175
  return ((char *)"LOCAL_DRIVER_NAME");
  case_119: /* CIL Label */ 
#line 1177
  return ((char *)"LOCAL_DRIVER_VERSION");
  case_120: /* CIL Label */ 
#line 1179
  return ((char *)"LOCAL_DRIVER_FIRMWARE");
  case_133: /* CIL Label */ 
#line 1181
  return ((char *)"LOCAL_INTERVAL_USECS");
  case_134: /* CIL Label */ 
#line 1183
  return ((char *)"LOCAL_INTERVAL_BURST");
  case_135: /* CIL Label */ 
#line 1185
  return ((char *)"REMOTE_INTERVAL_USECS");
  case_136: /* CIL Label */ 
#line 1187
  return ((char *)"REMOTE_INTERVAL_BURST");
  case_137: /* CIL Label */ 
#line 1189
  return ((char *)"LOCAL_SECURITY_TYPE_ID");
  case_139: /* CIL Label */ 
#line 1191
  return ((char *)"LOCAL_SECURITY_ENABLED_NUM");
  case_138: /* CIL Label */ 
#line 1193
  return ((char *)"LOCAL_SECURITY_TYPE");
  case_140: /* CIL Label */ 
#line 1195
  return ((char *)"LOCAL_SECURITY_ENABLED");
  case_141: /* CIL Label */ 
#line 1197
  return ((char *)"LOCAL_SECURITY_SPECIFIC");
  case_142: /* CIL Label */ 
#line 1199
  return ((char *)"REMOTE_SECURITY_TYPE_ID");
  case_144: /* CIL Label */ 
#line 1201
  return ((char *)"REMOTE_SECURITY_ENABLED_NUM");
  case_143: /* CIL Label */ 
#line 1203
  return ((char *)"REMOTE_SECURITY_TYPE");
  case_145: /* CIL Label */ 
#line 1205
  return ((char *)"REMOTE_SECURITY_ENABLED");
  case_146: /* CIL Label */ 
#line 1207
  return ((char *)"REMOTE_SECURITY_SPECIFIC");
  case_121: /* CIL Label */ 
#line 1209
  return ((char *)"LOCAL_DRIVER_BUS");
  case_108: /* CIL Label */ 
#line 1211
  return ((char *)"REMOTE_SYSNAME");
  case_112: /* CIL Label */ 
#line 1213
  return ((char *)"REMOTE_MACHINE");
  case_111: /* CIL Label */ 
#line 1215
  return ((char *)"REMOTE_VERSION");
  case_110: /* CIL Label */ 
#line 1217
  return ((char *)"REMOTE_RELEASE");
  case_103: /* CIL Label */ 
#line 1219
  return ((char *)"LOCAL_SYSNAME");
  case_107: /* CIL Label */ 
#line 1221
  return ((char *)"LOCAL_MACHINE");
  case_106: /* CIL Label */ 
#line 1223
  return ((char *)"LOCAL_VERSION");
  case_105: /* CIL Label */ 
#line 1225
  return ((char *)"LOCAL_RELEASE");
  case_59: /* CIL Label */ 
#line 1227
  return ((char *)"REMOTE_CPU_MODEL");
  case_60: /* CIL Label */ 
#line 1229
  return ((char *)"REMOTE_CPU_FREQUENCY");
  case_109: /* CIL Label */ 
#line 1231
  return ((char *)"REMOTE_SYSTEM_MODEL");
  case_53: /* CIL Label */ 
#line 1233
  return ((char *)"LOCAL_CPU_MODEL");
  case_54: /* CIL Label */ 
#line 1235
  return ((char *)"LOCAL_CPU_FREQUENCY");
  case_104: /* CIL Label */ 
#line 1237
  return ((char *)"LOCAL_SYSTEM_MODEL");
  case_149: /* CIL Label */ 
#line 1239
  return ((char *)"MIN_LATENCY");
  case_150: /* CIL Label */ 
#line 1241
  return ((char *)"MAX_LATENCY");
  case_151: /* CIL Label */ 
#line 1243
  return ((char *)"P50_LATENCY");
  case_152: /* CIL Label */ 
#line 1245
  return ((char *)"P90_LATENCY");
  case_153: /* CIL Label */ 
#line 1247
  return ((char *)"P99_LATENCY");
  case_154: /* CIL Label */ 
#line 1249
  return ((char *)"MEAN_LATENCY");
  case_155: /* CIL Label */ 
#line 1251
  return ((char *)"STDDEV_LATENCY");
  case_156: /* CIL Label */ 
#line 1253
  return ((char *)"LOCAL_SOCKET_PRIO");
  case_157: /* CIL Label */ 
#line 1255
  return ((char *)"REMOTE_SOCKET_PRIO");
  case_158: /* CIL Label */ 
#line 1257
  return ((char *)"LOCAL_SOCKET_TOS");
  case_159: /* CIL Label */ 
#line 1259
  return ((char *)"REMOTE_SOCKET_TOS");
  case_160: /* CIL Label */ 
#line 1261
  return ((char *)"LOCAL_CONG_CONTROL");
  case_161: /* CIL Label */ 
#line 1263
  return ((char *)"REMOTE_CONG_CONTROL");
  case_162: /* CIL Label */ 
#line 1265
  return ((char *)"LOCAL_FILL_FILE");
  case_163: /* CIL Label */ 
#line 1267
  return ((char *)"REMOTE_FILL_FILE");
  case_165: /* CIL Label */ 
#line 1269
  return ((char *)"OUTPUT_END");
  switch_default: /* CIL Label */ 
#line 1271
  return ((char *)"!UNKNOWN OUTPUT SELECTOR!");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1275 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void print_netperf_output_entry(FILE *where___0 , enum netperf_output_name what ) 
{ 


  {
#line 1278
  return;
}
}
#line 1280
void print_omni_init_list(void) ;
#line 1282 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void dump_netperf_output_list(FILE *where___0 ) 
{ 
  int i ;
  int j ;
  char *tmp ;

  {
#line 1287
  i = 0;
  {
#line 1287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1287
    if (! (i < 4)) {
#line 1287
      goto while_break;
    }
    {
#line 1288
    fprintf((FILE */* __restrict  */)where___0, (char const   */* __restrict  */)"Output Block %d\n",
            i + 1);
#line 1289
    j = 0;
    }
    {
#line 1289
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1289
      if (! (j < 166)) {
#line 1289
        goto while_break___0;
      }
      {
#line 1290
      tmp = netperf_output_enum_to_str(output_list[i][j]);
#line 1290
      fprintf((FILE */* __restrict  */)where___0, (char const   */* __restrict  */)"%s ",
              tmp);
#line 1289
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1292
    fprintf((FILE */* __restrict  */)where___0, (char const   */* __restrict  */)"\n");
#line 1287
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1294
  fflush(where___0);
  }
#line 1295
  return;
}
}
#line 1297 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void dump_netperf_output_choices(FILE *where___0 , int csv ) 
{ 
  int i ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 1301
  print_omni_init_list();
#line 1303
  i = 1;
  }
  {
#line 1303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1303
    if (! (i < 166)) {
#line 1303
      goto while_break;
    }
#line 1304
    if (1 != i) {
#line 1305
      if (csv) {
#line 1305
        tmp = ',';
      } else {
#line 1305
        tmp = '\n';
      }
      {
#line 1305
      fprintf((FILE */* __restrict  */)where___0, (char const   */* __restrict  */)"%c",
              tmp);
      }
    }
    {
#line 1307
    tmp___0 = netperf_output_enum_to_str(netperf_output_source[i].output_name);
#line 1307
    fprintf((FILE */* __restrict  */)where___0, (char const   */* __restrict  */)"%s",
            tmp___0);
#line 1303
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1311
  fprintf((FILE */* __restrict  */)where___0, (char const   */* __restrict  */)"\n");
#line 1312
  fflush(where___0);
  }
#line 1313
  return;
}
}
#line 1315 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void dump_netperf_output_source(FILE *where___0 ) 
{ 
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;

  {
#line 1321
  i = 1;
  {
#line 1321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1321
    if (! (i < 166)) {
#line 1321
      goto while_break;
    }
#line 1322
    if ((unsigned long )netperf_output_source[i].format == (unsigned long )((void *)0)) {
#line 1322
      tmp = "";
    } else {
#line 1322
      tmp = (char const   *)netperf_output_source[i].format;
    }
#line 1322
    if ((unsigned long )netperf_output_source[i].brief == (unsigned long )((void *)0)) {
#line 1322
      tmp___0 = "";
    } else {
#line 1322
      tmp___0 = (char const   *)netperf_output_source[i].brief;
    }
#line 1322
    if ((unsigned long )netperf_output_source[i].line[3] == (unsigned long )((void *)0)) {
#line 1322
      tmp___1 = "";
    } else {
#line 1322
      tmp___1 = (char const   *)netperf_output_source[i].line[3];
    }
#line 1322
    if ((unsigned long )netperf_output_source[i].line[2] == (unsigned long )((void *)0)) {
#line 1322
      tmp___2 = "";
    } else {
#line 1322
      tmp___2 = (char const   *)netperf_output_source[i].line[2];
    }
#line 1322
    if ((unsigned long )netperf_output_source[i].line[1] == (unsigned long )((void *)0)) {
#line 1322
      tmp___3 = "";
    } else {
#line 1322
      tmp___3 = (char const   *)netperf_output_source[i].line[1];
    }
#line 1322
    if ((unsigned long )netperf_output_source[i].line[0] == (unsigned long )((void *)0)) {
#line 1322
      tmp___4 = "";
    } else {
#line 1322
      tmp___4 = (char const   *)netperf_output_source[i].line[0];
    }
    {
#line 1322
    tmp___5 = netperf_output_enum_to_str(netperf_output_source[i].output_name);
#line 1322
    fprintf((FILE */* __restrict  */)where___0, (char const   */* __restrict  */)"Output Name: %s\n\tmax_line_len %d tot_line_len %d display_value %p\n\tline[0]: |%s|\n\tline[1]: |%s|\n\tline[2]: |%s|\n\tline[3]: |%s|\n\tbrief: |%s|\n\tformat: |%s|\n",
            tmp___5, netperf_output_source[i].max_line_len, netperf_output_source[i].tot_line_len,
            netperf_output_source[i].display_value, tmp___4, tmp___3, tmp___2, tmp___1,
            tmp___0, tmp);
#line 1321
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1348
  fflush(where___0);
  }
#line 1349
  return;
}
}
#line 1365 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
enum netperf_output_name match_string_to_output_mnenomic(char *candidate ) 
{ 
  enum netperf_output_name name ;
  char *tmp ;
  int tmp___0 ;

  {
#line 1369
  name = (enum netperf_output_name )1;
  {
#line 1369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1369
    if (! ((unsigned int )name < 166U)) {
#line 1369
      goto while_break;
    }
    {
#line 1370
    tmp = netperf_output_enum_to_str(name);
#line 1370
    tmp___0 = strcasecmp((char const   *)candidate, (char const   *)tmp);
    }
#line 1370
    if (! tmp___0) {
#line 1371
      return (name);
    }
#line 1369
    name = (enum netperf_output_name )((unsigned int )name + 1U);
  }
  while_break: /* CIL Label */ ;
  }
#line 1373
  return ((enum netperf_output_name )0);
}
}
#line 1376 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
enum netperf_output_name match_string_to_output(char *candidate ) 
{ 
  char *h1 ;
  char *temp ;
  enum netperf_output_name name ;
  int k ;
  int len ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1387
  name = (enum netperf_output_name )1;
  {
#line 1387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1387
    if (! ((unsigned int )name < 166U)) {
#line 1387
      goto while_break;
    }
    {
#line 1389
    tmp = netperf_output_enum_to_str(name);
#line 1389
    tmp___0 = strcasecmp((char const   *)candidate, (char const   *)tmp);
    }
#line 1389
    if (! tmp___0) {
#line 1390
      return (name);
    }
    {
#line 1393
    tmp___1 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1393
    tmp___2 = strlen((char const   *)netperf_output_source[name].line[1]);
#line 1393
    tmp___3 = strlen((char const   *)netperf_output_source[name].line[2]);
#line 1393
    tmp___4 = strlen((char const   *)netperf_output_source[name].line[3]);
#line 1393
    tmp___5 = malloc((((tmp___1 + tmp___2) + tmp___3) + tmp___4) + 4UL);
#line 1393
    temp = (char *)tmp___5;
#line 1394
    h1 = temp;
    }
#line 1395
    if ((unsigned long )h1 != (unsigned long )((void *)0)) {
#line 1396
      k = 0;
      {
#line 1396
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1396
        if (k < 4) {
#line 1396
          if ((unsigned long )((void *)0) != (unsigned long )netperf_output_source[name].line[k]) {
            {
#line 1396
            tmp___6 = strcmp("", (char const   *)netperf_output_source[name].line[k]);
            }
#line 1396
            if (! tmp___6) {
#line 1396
              goto while_break___0;
            }
          } else {
#line 1396
            goto while_break___0;
          }
        } else {
#line 1396
          goto while_break___0;
        }
        {
#line 1399
        len = sprintf((char */* __restrict  */)h1, (char const   */* __restrict  */)"%s",
                      netperf_output_source[name].line[k]);
#line 1402
        *(h1 + len) = (char )' ';
#line 1405
        h1 += len + 1;
#line 1396
        k ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1408
      *(h1 - 1) = (char)0;
#line 1409
      tmp___7 = strcasecmp((char const   *)candidate, (char const   *)temp);
      }
#line 1409
      if (tmp___7) {
        {
#line 1414
        free((void *)temp);
        }
      } else {
        {
#line 1410
        free((void *)temp);
        }
#line 1411
        return (name);
      }
    }
#line 1387
    name = (enum netperf_output_name )((unsigned int )name + 1U);
  }
  while_break: /* CIL Label */ ;
  }
#line 1418
  return ((enum netperf_output_name )1);
}
}
#line 1422 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void set_output_list_all(void) 
{ 
  int i ;
  int j ;
  enum netperf_output_name k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1429
  i = 0;
#line 1430
  j = 0;
#line 1431
  k = (enum netperf_output_name )2;
  {
#line 1431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1431
    if (! ((unsigned int )k <= 25U)) {
#line 1431
      goto while_break;
    }
#line 1432
    tmp = j;
#line 1432
    j ++;
#line 1432
    output_list[i][tmp] = k;
#line 1433
    desired_output_groups |= netperf_output_source[k].output_group;
#line 1431
    k = (enum netperf_output_name )((unsigned int )k + 1U);
  }
  while_break: /* CIL Label */ ;
  }
#line 1437
  i = 1;
#line 1438
  j = 0;
#line 1439
  k = (enum netperf_output_name )26;
  {
#line 1439
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1439
    if (! ((unsigned int )k <= 44U)) {
#line 1439
      goto while_break___0;
    }
#line 1440
    tmp___0 = j;
#line 1440
    j ++;
#line 1440
    output_list[i][tmp___0] = k;
#line 1441
    desired_output_groups |= netperf_output_source[k].output_group;
#line 1439
    k = (enum netperf_output_name )((unsigned int )k + 1U);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1445
  i = 2;
#line 1446
  j = 0;
#line 1447
  k = (enum netperf_output_name )45;
  {
#line 1447
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1447
    if (! ((unsigned int )k <= 102U)) {
#line 1447
      goto while_break___1;
    }
#line 1448
    tmp___1 = j;
#line 1448
    j ++;
#line 1448
    output_list[i][tmp___1] = k;
#line 1449
    desired_output_groups |= netperf_output_source[k].output_group;
#line 1447
    k = (enum netperf_output_name )((unsigned int )k + 1U);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1453
  i = 3;
#line 1454
  j = 0;
#line 1455
  k = (enum netperf_output_name )103;
  {
#line 1455
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1455
    if (! ((unsigned int )k <= 164U)) {
#line 1455
      goto while_break___2;
    }
#line 1456
    tmp___2 = j;
#line 1456
    j ++;
#line 1456
    output_list[i][tmp___2] = k;
#line 1457
    desired_output_groups |= netperf_output_source[k].output_group;
#line 1455
    k = (enum netperf_output_name )((unsigned int )k + 1U);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1460
  return;
}
}
#line 1462 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void parse_output_selection_file(char *selection_file ) 
{ 
  FILE *selections ;
  char name[81] ;
  int namepos ;
  int c ;
  int j ;
  int line ;
  int column ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 1471
  selections = fopen((char const   */* __restrict  */)selection_file, (char const   */* __restrict  */)"r");
  }
#line 1472
  if (! selections) {
    {
#line 1473
    tmp = __errno_location();
#line 1473
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Could not open output selection file \'%s\' errno %d\n",
            selection_file, *tmp);
#line 1477
    fflush(where);
#line 1478
    exit(-1);
    }
  }
#line 1481
  line = 0;
#line 1482
  column = 1;
#line 1483
  namepos = 0;
#line 1484
  name[0] = (char)0;
#line 1485
  name[80] = (char)0;
#line 1486
  j = 0;
  {
#line 1487
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1487
    c = fgetc(selections);
    }
#line 1487
    if (c != -1) {
#line 1487
      if (! (line < 4)) {
#line 1487
        goto while_break;
      }
    } else {
#line 1487
      goto while_break;
    }
#line 1488
    if (namepos == 80) {
      {
#line 1491
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Output selection starting column %d on line %d is too long\n",
              line + 1, column);
#line 1495
      fflush(where);
#line 1496
      exit(-1);
      }
    }
#line 1498
    if (c == 44) {
#line 1501
      if (j == 166) {
        {
#line 1502
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Too many output selectors on line %d\n",
                line);
#line 1503
        fflush(where);
#line 1504
        exit(-1);
        }
      }
      {
#line 1506
      name[namepos] = (char)0;
#line 1507
      tmp___0 = j;
#line 1507
      j ++;
#line 1507
      output_list[line][tmp___0] = match_string_to_output(name);
#line 1508
      namepos = 0;
      }
    } else
#line 1510
    if (c == 10) {
      {
#line 1512
      name[namepos] = (char)0;
#line 1513
      tmp___1 = line;
#line 1513
      line ++;
#line 1513
      tmp___2 = j;
#line 1513
      j ++;
#line 1513
      output_list[tmp___1][tmp___2] = match_string_to_output(name);
#line 1514
      namepos = 0;
#line 1515
      j = 0;
      }
    } else {
      {
#line 1517
      tmp___4 = __ctype_b_loc();
      }
#line 1517
      if ((int const   )*(*tmp___4 + c) & 16384) {
#line 1518
        tmp___3 = namepos;
#line 1518
        namepos ++;
#line 1518
        name[tmp___3] = (char )c;
      }
    }
#line 1520
    column ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1526
  if (c == -1) {
#line 1526
    if (namepos > 0) {
      {
#line 1527
      name[namepos] = (char)0;
#line 1528
      output_list[line][j] = match_string_to_output(name);
      }
    }
  }
#line 1531
  return;
}
}
#line 1533 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void parse_output_selection_line(int line , char *list ) 
{ 
  char *token ;
  int j ;
  enum netperf_output_name name ;

  {
#line 1541
  if (line < 0) {
    {
#line 1542
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"parse_output_selection_line called with negative line number %d\n",
            line);
#line 1544
    fflush(where);
#line 1545
    exit(-1);
    }
  }
#line 1549
  if (line >= 4) {
#line 1550
    if (debug) {
      {
#line 1551
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"There can be no more than %d output selection lines. Ignoring output selection line %d |%s|\n",
              4, line + 1, list);
#line 1557
      fflush(where);
      }
    }
#line 1559
    return;
  }
  {
#line 1563
  j = 0;
#line 1564
  token = strtok((char */* __restrict  */)list, (char const   */* __restrict  */)" ,");
  }
  {
#line 1565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1565
    if (token) {
#line 1565
      if (! (j < 166)) {
#line 1565
        goto while_break;
      }
    } else {
#line 1565
      goto while_break;
    }
    {
#line 1567
    name = match_string_to_output_mnenomic(token);
    }
#line 1569
    if ((unsigned int )name == 0U) {
#line 1569
      if (debug) {
        {
#line 1570
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Ignoring unknown output selector %d |%s| on line %d\n",
                j + 1, token, line + 1);
#line 1574
        fflush(where);
        }
      } else {
#line 1577
        output_list[line][j] = name;
#line 1578
        desired_output_groups |= netperf_output_source[name].output_group;
#line 1579
        j ++;
      }
    } else {
#line 1577
      output_list[line][j] = name;
#line 1578
      desired_output_groups |= netperf_output_source[name].output_group;
#line 1579
      j ++;
    }
    {
#line 1582
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ,");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1584
  if (token) {
#line 1584
    if (debug) {
      {
#line 1585
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"There can be no more than %d output selectors per line. Ignoring remaining selectors on line %d\n",
              166, line + 1);
#line 1589
      fflush(where);
      }
    }
  }
#line 1591
  return;
}
}
#line 1593 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void parse_output_selection_direct(char *output_selection ) 
{ 
  char *source ;
  char *line ;
  char *remainder ;
  char *temp ;
  char *f1 ;
  char *f2 ;
  char *f3 ;
  int i ;
  int len ;
  int done ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1600
  tmp = strlen((char const   *)output_selection);
#line 1600
  len = (int )tmp;
#line 1602
  source = strdup((char const   *)output_selection);
#line 1603
  tmp___0 = malloc((size_t )(len + 1));
#line 1603
  line = (char *)tmp___0;
#line 1604
  tmp___1 = malloc((size_t )(len + 1));
#line 1604
  remainder = (char *)tmp___1;
  }
#line 1606
  if ((unsigned long )((void *)0) == (unsigned long )source) {
    {
#line 1609
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Unable to malloc memory for output selection parsing\n");
#line 1610
    fflush(where);
#line 1611
    exit(-1);
    }
  } else
#line 1606
  if ((unsigned long )((void *)0) == (unsigned long )line) {
    {
#line 1609
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Unable to malloc memory for output selection parsing\n");
#line 1610
    fflush(where);
#line 1611
    exit(-1);
    }
  } else
#line 1606
  if ((unsigned long )((void *)0) == (unsigned long )remainder) {
    {
#line 1609
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Unable to malloc memory for output selection parsing\n");
#line 1610
    fflush(where);
#line 1611
    exit(-1);
    }
  }
#line 1614
  f1 = source;
#line 1615
  f2 = line;
#line 1616
  f3 = remainder;
#line 1618
  i = 0;
#line 1619
  done = 0;
  {
#line 1620
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1621
    break_args_explicit_sep(source, ';', line, remainder);
    }
#line 1622
    if (*(line + 0)) {
      {
#line 1623
      parse_output_selection_line(i, line);
      }
    }
#line 1625
    if (*(remainder + 0)) {
#line 1626
      temp = source;
#line 1627
      source = remainder;
#line 1628
      remainder = temp;
#line 1629
      i ++;
#line 1639
      goto __Cont;
    } else {
#line 1642
      done = 1;
    }
    __Cont: /* CIL Label */ 
#line 1620
    if (! (! done)) {
#line 1620
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1646
  free((void *)f1);
#line 1647
  free((void *)f2);
#line 1648
  free((void *)f3);
  }
#line 1650
  return;
}
}
#line 1659 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void set_output_list_by_test(void) 
{ 
  char *stream_no_cpu ;
  char *stream_cpu ;
  char *maerts_no_cpu ;
  char *maerts_cpu ;
  char *rr_no_cpu ;
  char *rr_cpu ;

  {
#line 1662
  stream_no_cpu = (char *)"LSS_SIZE_END,RSR_SIZE_END,LOCAL_SEND_SIZE,ELAPSED_TIME,THROUGHPUT,THROUGHPUT_UNITS";
#line 1663
  stream_cpu = (char *)"LSS_SIZE_END,RSR_SIZE_END,LOCAL_SEND_SIZE,ELAPSED_TIME,THROUGHPUT,THROUGHPUT_UNITS,LOCAL_CPU_UTIL,LOCAL_CPU_METHOD,REMOTE_CPU_UTIL,REMOTE_CPU_METHOD,LOCAL_SD,REMOTE_SD,SD_UNITS";
#line 1664
  maerts_no_cpu = (char *)"RSS_SIZE_END,LSR_SIZE_END,REMOTE_SEND_SIZE,ELAPSED_TIME,THROUGHPUT,THROUGHPUT_UNITS";
#line 1665
  maerts_cpu = (char *)"RSS_SIZE_END,LSR_SIZE_END,REMOTE_SEND_SIZE,ELAPSED_TIME,THROUGHPUT,THROUGHPUT_UNITS,LOCAL_CPU_UTIL,LOCAL_CPU_METHOD,REMOTE_CPU_UTIL,REMOTE_CPU_METHOD,LOCAL_SD,REMOTE_SD,SD_UNITS";
#line 1666
  rr_no_cpu = (char *)"LSS_SIZE_END,LSR_SIZE_END,RSR_SIZE_END,RSS_SIZE_END,REQUEST_SIZE,RESPONSE_SIZE,ELAPSED_TIME,THROUGHPUT,THROUGHPUT_UNITS";
#line 1667
  rr_cpu = (char *)"LSS_SIZE_END,LSR_SIZE_END,RSR_SIZE_END,RSS_SIZE_END,REQUEST_SIZE,RESPONSE_SIZE,ELAPSED_TIME,THROUGHPUT,THROUGHPUT_UNITS,LOCAL_CPU_UTIL,LOCAL_CPU_METHOD,REMOTE_CPU_UTIL,REMOTE_CPU_METHOD,LOCAL_SD,REMOTE_SD,SD_UNITS";
#line 1669
  if (debug) {
    {
#line 1670
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s setting the output list by test\n",
            "set_output_list_by_test");
#line 1672
    fflush(where);
    }
  }
#line 1675
  if (direction & 2) {
#line 1675
    if (! (direction & 4)) {
#line 1676
      if (local_cpu_usage) {
        {
#line 1679
        parse_output_selection_direct(stream_cpu);
        }
      } else
#line 1676
      if (remote_cpu_usage) {
        {
#line 1679
        parse_output_selection_direct(stream_cpu);
        }
      } else {
        {
#line 1677
        parse_output_selection_direct(stream_no_cpu);
        }
      }
    } else {
#line 1675
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 1681
  if (direction & 4) {
#line 1681
    if (! (direction & 2)) {
#line 1682
      if (local_cpu_usage) {
        {
#line 1685
        parse_output_selection_direct(maerts_cpu);
        }
      } else
#line 1682
      if (remote_cpu_usage) {
        {
#line 1685
        parse_output_selection_direct(maerts_cpu);
        }
      } else {
        {
#line 1683
        parse_output_selection_direct(maerts_no_cpu);
        }
      }
    } else {
#line 1681
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 1687
  if (! (direction & 2)) {
#line 1687
    if (! (direction & 4)) {
#line 1688
      if (local_cpu_usage) {
        {
#line 1691
        parse_output_selection_direct(rr_cpu);
        }
      } else
#line 1688
      if (remote_cpu_usage) {
        {
#line 1691
        parse_output_selection_direct(rr_cpu);
        }
      } else {
        {
#line 1689
        parse_output_selection_direct(rr_no_cpu);
        }
      }
    } else {
#line 1687
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1693
  if (direction & 2) {
#line 1693
    if (direction & 4) {
#line 1693
      goto _L;
    } else {
#line 1693
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1693
  if (direction & 2) {
#line 1693
    goto _L___0;
  } else
#line 1693
  if (direction & 4) {
    _L___0: /* CIL Label */ 
#line 1701
    if (debug) {
      {
#line 1702
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Cannot determine default test output, using mins\n");
#line 1703
      fflush(where);
      }
    }
    {
#line 1705
    parse_output_selection_direct((char *)"ELAPSED_TIME,THROUGHPUT,THROUGHPUT_UNITS,LOCAL_CPU_UTIL,LOCAL_CPU_METHOD,REMOTE_CPU_UTIL,REMOTE_CPU_METHOD,LOCAL_SD,REMOTE_SD,SD_UNITS");
    }
  } else
  _L: /* CIL Label */ 
#line 1694
  if (local_cpu_usage) {
    {
#line 1697
    parse_output_selection_direct(rr_cpu);
    }
  } else
#line 1694
  if (remote_cpu_usage) {
    {
#line 1697
    parse_output_selection_direct(rr_cpu);
    }
  } else {
    {
#line 1695
    parse_output_selection_direct(rr_no_cpu);
    }
  }
#line 1707
  return;
}
}
#line 1709 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void parse_output_selection(char *output_selection ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  enum netperf_output_name tmp___1 ;
  int tmp___2 ;

  {
#line 1712
  if (debug) {
    {
#line 1713
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s is parsing the output selection \'%s\'\n",
            "parse_output_selection", output_selection);
#line 1716
    fflush(where);
    }
  }
  {
#line 1720
  tmp___2 = strcasecmp((char const   *)output_selection, "all");
  }
#line 1720
  if (tmp___2 == 0) {
    {
#line 1721
    set_output_list_all();
    }
  } else {
    {
#line 1725
    tmp = strchr((char const   *)output_selection, ',');
    }
#line 1725
    if (tmp) {
      {
#line 1729
      parse_output_selection_direct(output_selection);
      }
    } else {
      {
#line 1725
      tmp___0 = strchr((char const   *)output_selection, ';');
      }
#line 1725
      if (tmp___0) {
        {
#line 1729
        parse_output_selection_direct(output_selection);
        }
      } else {
        {
#line 1725
        tmp___1 = match_string_to_output_mnenomic(output_selection);
        }
#line 1725
        if ((unsigned int )tmp___1 != 0U) {
          {
#line 1729
          parse_output_selection_direct(output_selection);
          }
        } else {
          {
#line 1732
          parse_output_selection_file(output_selection);
          }
        }
      }
    }
  }
#line 1734
  if (debug > 2) {
    {
#line 1735
    dump_netperf_output_list(stderr);
    }
  }
#line 1737
  return;
}
}
#line 1740 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void set_output_elt(enum netperf_output_name name , char *line0 , char *line1 ,
                           char *line2 , char *line3 , char *format , void *value ,
                           unsigned int out_default , unsigned int group , enum netperf_output_type type ) 
{ 
  size_t tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  size_t tmp___41 ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  size_t tmp___46 ;
  size_t tmp___47 ;
  size_t tmp___48 ;
  size_t tmp___49 ;
  size_t tmp___50 ;
  size_t tmp___61 ;
  size_t tmp___62 ;
  size_t tmp___63 ;
  size_t tmp___64 ;
  size_t tmp___65 ;
  size_t tmp___66 ;
  size_t tmp___67 ;
  size_t tmp___70 ;
  size_t tmp___71 ;
  size_t tmp___72 ;
  size_t tmp___73 ;
  size_t tmp___74 ;
  size_t tmp___75 ;
  size_t tmp___76 ;
  size_t tmp___77 ;
  size_t tmp___78 ;
  size_t tmp___79 ;
  size_t tmp___80 ;

  {
  {
#line 1749
  netperf_output_source[name].output_name = name;
#line 1750
  netperf_output_source[name].line[0] = line0;
#line 1751
  netperf_output_source[name].line[1] = line1;
#line 1752
  netperf_output_source[name].line[2] = line2;
#line 1753
  netperf_output_source[name].line[3] = line3;
#line 1754
  netperf_output_source[name].format = format;
#line 1755
  netperf_output_source[name].display_value = value;
#line 1756
  netperf_output_source[name].output_default = (int )out_default;
#line 1757
  netperf_output_source[name].output_group = group;
#line 1758
  tmp___73 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
  tmp___74 = strlen((char const   *)netperf_output_source[name].line[1]);
  }
#line 1758
  if (tmp___73 > tmp___74) {
    {
#line 1758
    tmp___70 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
    tmp___72 = tmp___70;
    }
  } else {
    {
#line 1758
    tmp___71 = strlen((char const   *)netperf_output_source[name].line[1]);
#line 1758
    tmp___72 = tmp___71;
    }
  }
  {
#line 1758
  tmp___75 = strlen((char const   *)netperf_output_source[name].line[2]);
  }
#line 1758
  if (tmp___72 > tmp___75) {
    {
#line 1758
    tmp___64 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
    tmp___65 = strlen((char const   *)netperf_output_source[name].line[1]);
    }
#line 1758
    if (tmp___64 > tmp___65) {
      {
#line 1758
      tmp___61 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
      tmp___63 = tmp___61;
      }
    } else {
      {
#line 1758
      tmp___62 = strlen((char const   *)netperf_output_source[name].line[1]);
#line 1758
      tmp___63 = tmp___62;
      }
    }
#line 1758
    tmp___67 = tmp___63;
  } else {
    {
#line 1758
    tmp___66 = strlen((char const   *)netperf_output_source[name].line[2]);
#line 1758
    tmp___67 = tmp___66;
    }
  }
  {
#line 1758
  tmp___76 = strlen((char const   *)netperf_output_source[name].line[3]);
  }
#line 1758
  if (tmp___67 > tmp___76) {
    {
#line 1758
    tmp___47 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
    tmp___48 = strlen((char const   *)netperf_output_source[name].line[1]);
    }
#line 1758
    if (tmp___47 > tmp___48) {
      {
#line 1758
      tmp___44 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
      tmp___46 = tmp___44;
      }
    } else {
      {
#line 1758
      tmp___45 = strlen((char const   *)netperf_output_source[name].line[1]);
#line 1758
      tmp___46 = tmp___45;
      }
    }
    {
#line 1758
    tmp___49 = strlen((char const   *)netperf_output_source[name].line[2]);
    }
#line 1758
    if (tmp___46 > tmp___49) {
      {
#line 1758
      tmp___38 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
      tmp___39 = strlen((char const   *)netperf_output_source[name].line[1]);
      }
#line 1758
      if (tmp___38 > tmp___39) {
        {
#line 1758
        tmp___35 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
        tmp___37 = tmp___35;
        }
      } else {
        {
#line 1758
        tmp___36 = strlen((char const   *)netperf_output_source[name].line[1]);
#line 1758
        tmp___37 = tmp___36;
        }
      }
#line 1758
      tmp___41 = tmp___37;
    } else {
      {
#line 1758
      tmp___40 = strlen((char const   *)netperf_output_source[name].line[2]);
#line 1758
      tmp___41 = tmp___40;
      }
    }
#line 1758
    netperf_output_source[name].max_line_len = (int )tmp___41;
  } else {
    {
#line 1758
    tmp___50 = strlen((char const   *)netperf_output_source[name].line[3]);
#line 1758
    netperf_output_source[name].max_line_len = (int )tmp___50;
    }
  }
  {
#line 1759
  tmp___77 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1759
  tmp___78 = strlen((char const   *)netperf_output_source[name].line[1]);
#line 1759
  tmp___79 = strlen((char const   *)netperf_output_source[name].line[2]);
#line 1759
  tmp___80 = strlen((char const   *)netperf_output_source[name].line[3]);
#line 1759
  netperf_output_source[name].tot_line_len = (int )((((tmp___77 + tmp___78) + tmp___79) + tmp___80) + 4UL);
#line 1760
  netperf_output_source[name].output_type = type;
  }
#line 1761
  return;
}
}
#line 1763 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void print_omni_init_list(void) 
{ 
  int i ;

  {
#line 1768
  if (debug) {
    {
#line 1769
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s called\n",
            "print_omni_init_list");
    }
  }
#line 1774
  i = 0;
  {
#line 1774
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1774
    if (! (i < 166)) {
#line 1774
      goto while_break;
    }
#line 1775
    netperf_output_source[i].output_name = (enum netperf_output_name )i;
#line 1776
    netperf_output_source[i].max_line_len = 0;
#line 1777
    netperf_output_source[i].tot_line_len = 0;
#line 1778
    netperf_output_source[i].line[0] = (char *)"";
#line 1779
    netperf_output_source[i].line[1] = (char *)"";
#line 1780
    netperf_output_source[i].line[2] = (char *)"";
#line 1781
    netperf_output_source[i].line[3] = (char *)"";
#line 1782
    netperf_output_source[i].brief = (char *)"";
#line 1783
    netperf_output_source[i].format = (char *)"";
#line 1784
    netperf_output_source[i].display_value = (void *)0;
#line 1785
    netperf_output_source[i].output_default = 1;
#line 1786
    netperf_output_source[i].output_group = 0U;
#line 1787
    netperf_output_source[i].output_type = (enum netperf_output_type )0;
#line 1774
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1790
  set_output_elt((enum netperf_output_name )1, (char *)" ", (char *)"", (char *)"",
                 (char *)"", (char *)"%s", (void *)" ", 1U, 0U, (enum netperf_output_type )5);
#line 1793
  set_output_elt((enum netperf_output_name )164, (char *)"Command", (char *)"Line",
                 (char *)"", (char *)"", (char *)"\"%s\"", (void *)command_line, 1U,
                 0U, (enum netperf_output_type )5);
#line 1796
  set_output_elt((enum netperf_output_name )148, (char *)"Test", (char *)"UUID", (char *)"",
                 (char *)"", (char *)"%s", (void *)(test_uuid), 1U, 0U, (enum netperf_output_type )5);
#line 1799
  set_output_elt((enum netperf_output_name )147, (char *)"Result", (char *)"Tag",
                 (char *)"", (char *)"", (char *)"\"%s\"", (void *)result_brand, 1U,
                 0U, (enum netperf_output_type )5);
#line 1802
  set_output_elt((enum netperf_output_name )2, (char *)"Socket", (char *)"Type", (char *)"",
                 (char *)"", (char *)"%s", (void *)socket_type_str, 1U, 0U, (enum netperf_output_type )5);
#line 1805
  set_output_elt((enum netperf_output_name )4, (char *)"Direction", (char *)"", (char *)"",
                 (char *)"", (char *)"%s", (void *)direction_str, 1U, 0U, (enum netperf_output_type )5);
#line 1808
  set_output_elt((enum netperf_output_name )3, (char *)"Protocol", (char *)"", (char *)"",
                 (char *)"", (char *)"%s", (void *)protocol_str, 1U, 0U, (enum netperf_output_type )5);
#line 1811
  set_output_elt((enum netperf_output_name )5, (char *)"Elapsed", (char *)"Time",
                 (char *)"(sec)", (char *)"", (char *)"%.2f", (void *)(& elapsed_time_double),
                 1U, 0U, (enum netperf_output_type )7);
#line 1814
  set_output_elt((enum netperf_output_name )61, (char *)"Source", (char *)"Port",
                 (char *)"", (char *)"", (char *)"%s", (void *)(local_data_port),
                 1U, 0U, (enum netperf_output_type )5);
#line 1817
  set_output_elt((enum netperf_output_name )62, (char *)"Source", (char *)"Address",
                 (char *)"", (char *)"", (char *)"%s", (void *)local_data_address,
                 1U, 0U, (enum netperf_output_type )5);
#line 1820
  set_output_elt((enum netperf_output_name )63, (char *)"Source", (char *)"Family",
                 (char *)"", (char *)"", (char *)"%d", (void *)(& local_data_family),
                 1U, 0U, (enum netperf_output_type )2);
#line 1823
  set_output_elt((enum netperf_output_name )64, (char *)"Destination", (char *)"Port",
                 (char *)"", (char *)"", (char *)"%s", (void *)(remote_data_port),
                 1U, 0U, (enum netperf_output_type )5);
#line 1826
  set_output_elt((enum netperf_output_name )65, (char *)"Destination", (char *)"Address",
                 (char *)"", (char *)"", (char *)"%s", (void *)remote_data_address,
                 1U, 0U, (enum netperf_output_type )5);
#line 1829
  set_output_elt((enum netperf_output_name )66, (char *)"Destination", (char *)"Family",
                 (char *)"", (char *)"", (char *)"%d", (void *)(& remote_data_family),
                 1U, 0U, (enum netperf_output_type )2);
#line 1832
  set_output_elt((enum netperf_output_name )6, (char *)"Throughput", (char *)"", (char *)"",
                 (char *)"", (char *)"%.2f", (void *)(& thruput), 1U, 0U, (enum netperf_output_type )7);
#line 1835
  set_output_elt((enum netperf_output_name )45, (char *)"Local", (char *)"Send", (char *)"Throughput",
                 (char *)"", (char *)"%.2f", (void *)(& local_send_thruput), 1U, 0U,
                 (enum netperf_output_type )7);
#line 1838
  set_output_elt((enum netperf_output_name )46, (char *)"Local", (char *)"Recv", (char *)"Throughput",
                 (char *)"", (char *)"%.2f", (void *)(& local_recv_thruput), 1U, 0U,
                 (enum netperf_output_type )7);
#line 1841
  set_output_elt((enum netperf_output_name )47, (char *)"Remote", (char *)"Send",
                 (char *)"Throughput", (char *)"", (char *)"%.2f", (void *)(& remote_send_thruput),
                 1U, 0U, (enum netperf_output_type )7);
#line 1844
  set_output_elt((enum netperf_output_name )48, (char *)"Remote", (char *)"Recv",
                 (char *)"Throughput", (char *)"", (char *)"%.2f", (void *)(& remote_recv_thruput),
                 1U, 0U, (enum netperf_output_type )7);
#line 1847
  set_output_elt((enum netperf_output_name )7, (char *)"Throughput", (char *)"Units",
                 (char *)"", (char *)"", (char *)"%s/s", (void *)thruput_format_str,
                 1U, 0U, (enum netperf_output_type )5);
#line 1850
  set_output_elt((enum netperf_output_name )33, (char *)"Confidence", (char *)"Level",
                 (char *)"Percent", (char *)"", (char *)"%d", (void *)(& confidence_level),
                 1U, 0U, (enum netperf_output_type )2);
#line 1853
  set_output_elt((enum netperf_output_name )34, (char *)"Confidence", (char *)"Width",
                 (char *)"Target", (char *)"", (char *)"%f", (void *)(& interval_pct),
                 1U, 0U, (enum netperf_output_type )7);
#line 1856
  set_output_elt((enum netperf_output_name )35, (char *)"Confidence", (char *)"Iterations",
                 (char *)"Run", (char *)"", (char *)"%d", (void *)(& confidence_iteration),
                 1U, 0U, (enum netperf_output_type )2);
#line 1859
  set_output_elt((enum netperf_output_name )36, (char *)"Throughput", (char *)"Confidence",
                 (char *)"Width (%)", (char *)"", (char *)"%.3f", (void *)(& result_confid_pct),
                 1U, 0U, (enum netperf_output_type )7);
#line 1862
  set_output_elt((enum netperf_output_name )37, (char *)"Local", (char *)"CPU", (char *)"Confidence",
                 (char *)"Width (%)", (char *)"%.3f", (void *)(& loc_cpu_confid_pct),
                 1U, 0U, (enum netperf_output_type )7);
#line 1865
  set_output_elt((enum netperf_output_name )38, (char *)"Remote", (char *)"CPU", (char *)"Confidence",
                 (char *)"Width (%)", (char *)"%.3f", (void *)(& rem_cpu_confid_pct),
                 1U, 0U, (enum netperf_output_type )7);
#line 1868
  set_output_elt((enum netperf_output_name )40, (char *)"Round", (char *)"Trip", (char *)"Latency",
                 (char *)"usec/tran", (char *)"%.3f", (void *)(& rtt_latency), 1U,
                 0U, (enum netperf_output_type )7);
#line 1871
  set_output_elt((enum netperf_output_name )39, (char *)"Transaction", (char *)"Rate",
                 (char *)"Tran/s", (char *)"", (char *)"%.3f", (void *)(& transaction_rate),
                 1U, 0U, (enum netperf_output_type )7);
#line 1874
  set_output_elt((enum netperf_output_name )44, (char *)"Transport", (char *)"MSS",
                 (char *)"bytes", (char *)"", (char *)"%d", (void *)(& transport_mss),
                 1U, 0U, (enum netperf_output_type )2);
#line 1877
  set_output_elt((enum netperf_output_name )42, (char *)"Local", (char *)"Transport",
                 (char *)"Retransmissions", (char *)"", (char *)"%d", (void *)(& local_transport_retrans),
                 1U, 0U, (enum netperf_output_type )2);
#line 1881
  set_output_elt((enum netperf_output_name )43, (char *)"Remote", (char *)"Transport",
                 (char *)"Retransmissions", (char *)"", (char *)"%d", (void *)(& remote_transport_retrans),
                 1U, 0U, (enum netperf_output_type )2);
#line 1885
  set_output_elt((enum netperf_output_name )24, (char *)"Request", (char *)"Size",
                 (char *)"Bytes", (char *)"", (char *)"%d", (void *)(& req_size),
                 1U, 0U, (enum netperf_output_type )2);
#line 1888
  set_output_elt((enum netperf_output_name )25, (char *)"Response", (char *)"Size",
                 (char *)"Bytes", (char *)"", (char *)"%d", (void *)(& rsp_size),
                 1U, 0U, (enum netperf_output_type )2);
#line 1891
  set_output_elt((enum netperf_output_name )41, (char *)"Initial", (char *)"Burst",
                 (char *)"Requests", (char *)"", (char *)"%d", (void *)(& first_burst_size),
                 1U, 0U, (enum netperf_output_type )2);
#line 1894
  set_output_elt((enum netperf_output_name )8, (char *)"Local", (char *)"Send Socket",
                 (char *)"Size", (char *)"Requested", (char *)"%d", (void *)(& lss_size_req),
                 1U, 0U, (enum netperf_output_type )2);
#line 1897
  set_output_elt((enum netperf_output_name )9, (char *)"Local", (char *)"Send Socket",
                 (char *)"Size", (char *)"Initial", (char *)"%d", (void *)(& lss_size),
                 1U, 0U, (enum netperf_output_type )2);
#line 1900
  set_output_elt((enum netperf_output_name )10, (char *)"Local", (char *)"Send Socket",
                 (char *)"Size", (char *)"Final", (char *)"%d", (void *)(& lss_size_end),
                 1U, 0U, (enum netperf_output_type )2);
#line 1903
  set_output_elt((enum netperf_output_name )11, (char *)"Local", (char *)"Recv Socket",
                 (char *)"Size", (char *)"Requested", (char *)"%d", (void *)(& lsr_size_req),
                 1U, 0U, (enum netperf_output_type )2);
#line 1906
  set_output_elt((enum netperf_output_name )12, (char *)"Local", (char *)"Recv Socket",
                 (char *)"Size", (char *)"Initial", (char *)"%d", (void *)(& lsr_size),
                 1U, 0U, (enum netperf_output_type )2);
#line 1909
  set_output_elt((enum netperf_output_name )13, (char *)"Local", (char *)"Recv Socket",
                 (char *)"Size", (char *)"Final", (char *)"%d", (void *)(& lsr_size_end),
                 1U, 0U, (enum netperf_output_type )2);
#line 1912
  set_output_elt((enum netperf_output_name )20, (char *)"Local", (char *)"Send", (char *)"Size",
                 (char *)"", (char *)"%d", (void *)(& send_size), 1U, 0U, (enum netperf_output_type )2);
#line 1915
  set_output_elt((enum netperf_output_name )21, (char *)"Local", (char *)"Recv", (char *)"Size",
                 (char *)"", (char *)"%d", (void *)(& recv_size), 1U, 0U, (enum netperf_output_type )2);
#line 1918
  set_output_elt((enum netperf_output_name )67, (char *)"Local", (char *)"Send", (char *)"Calls",
                 (char *)"", (char *)"%lu", (void *)(& local_send_calls), 1U, 0U,
                 (enum netperf_output_type )3);
#line 1921
  set_output_elt((enum netperf_output_name )68, (char *)"Local", (char *)"Recv", (char *)"Calls",
                 (char *)"", (char *)"%lu", (void *)(& local_receive_calls), 1U, 0U,
                 (enum netperf_output_type )3);
#line 1924
  set_output_elt((enum netperf_output_name )69, (char *)"Local", (char *)"Bytes",
                 (char *)"Per", (char *)"Recv", (char *)"%.2f", (void *)(& bytes_per_recv),
                 1U, 0U, (enum netperf_output_type )7);
#line 1927
  set_output_elt((enum netperf_output_name )70, (char *)"Local", (char *)"Bytes",
                 (char *)"Per", (char *)"Send", (char *)"%.2f", (void *)(& bytes_per_send),
                 1U, 0U, (enum netperf_output_type )7);
#line 1930
  set_output_elt((enum netperf_output_name )72, (char *)"Local", (char *)"Bytes",
                 (char *)"Received", (char *)"", (char *)"%lu", (void *)(& bytes_received),
                 1U, 0U, (enum netperf_output_type )3);
#line 1933
  set_output_elt((enum netperf_output_name )71, (char *)"Local", (char *)"Bytes",
                 (char *)"Sent", (char *)"", (char *)"%lu", (void *)(& bytes_sent),
                 1U, 0U, (enum netperf_output_type )3);
#line 1936
  set_output_elt((enum netperf_output_name )73, (char *)"Local", (char *)"Bytes",
                 (char *)"Xferred", (char *)"", (char *)"%.0f", (void *)(& bytes_xferd),
                 1U, 0U, (enum netperf_output_type )7);
#line 1939
  set_output_elt((enum netperf_output_name )78, (char *)"Local", (char *)"Send", (char *)"Width",
                 (char *)"", (char *)"%d", (void *)(& send_width), 1U, 0U, (enum netperf_output_type )2);
#line 1942
  set_output_elt((enum netperf_output_name )79, (char *)"Local", (char *)"Recv", (char *)"Width",
                 (char *)"", (char *)"%d", (void *)(& recv_width), 1U, 0U, (enum netperf_output_type )2);
#line 1945
  set_output_elt((enum netperf_output_name )74, (char *)"Local", (char *)"Send", (char *)"Offset",
                 (char *)"", (char *)"%d", (void *)(& local_send_offset), 1U, 0U,
                 (enum netperf_output_type )2);
#line 1948
  set_output_elt((enum netperf_output_name )75, (char *)"Local", (char *)"Recv", (char *)"Offset",
                 (char *)"", (char *)"%d", (void *)(& local_recv_offset), 1U, 0U,
                 (enum netperf_output_type )2);
#line 1951
  set_output_elt((enum netperf_output_name )77, (char *)"Local", (char *)"Recv", (char *)"Alignment",
                 (char *)"", (char *)"%d", (void *)(& local_recv_align), 1U, 0U, (enum netperf_output_type )2);
#line 1954
  set_output_elt((enum netperf_output_name )76, (char *)"Local", (char *)"Send", (char *)"Alignment",
                 (char *)"", (char *)"%d", (void *)(& local_send_align), 1U, 0U, (enum netperf_output_type )2);
#line 1957
  set_output_elt((enum netperf_output_name )80, (char *)"Local", (char *)"Send", (char *)"Dirty",
                 (char *)"Count", (char *)"%d", (void *)(& loc_dirty_count), 1U, 0U,
                 (enum netperf_output_type )2);
#line 1960
  set_output_elt((enum netperf_output_name )81, (char *)"Local", (char *)"Recv", (char *)"Dirty",
                 (char *)"Count", (char *)"%d", (void *)(& loc_dirty_count), 1U, 0U,
                 (enum netperf_output_type )2);
#line 1963
  set_output_elt((enum netperf_output_name )82, (char *)"Local", (char *)"Recv", (char *)"Clean",
                 (char *)"Count", (char *)"%d", (void *)(& loc_clean_count), 1U, 0U,
                 (enum netperf_output_type )2);
#line 1966
  set_output_elt((enum netperf_output_name )26, (char *)"Local", (char *)"CPU", (char *)"Util",
                 (char *)"%", (char *)"%.2f", (void *)(& local_cpu_utilization_double),
                 1U, 0U, (enum netperf_output_type )7);
#line 1969
  set_output_elt((enum netperf_output_name )51, (char *)"Local", (char *)"Peak", (char *)"Per CPU",
                 (char *)"Util %", (char *)"%.2f", (void *)(& lib_local_peak_cpu_util),
                 1U, 0U, (enum netperf_output_type )7);
#line 1972
  set_output_elt((enum netperf_output_name )52, (char *)"Local", (char *)"Peak", (char *)"Per CPU",
                 (char *)"ID", (char *)"%d", (void *)(& lib_local_peak_cpu_id), 1U,
                 0U, (enum netperf_output_type )2);
#line 1975
  set_output_elt((enum netperf_output_name )49, (char *)"Local", (char *)"CPU", (char *)"Bind",
                 (char *)"", (char *)"%d", (void *)(& local_proc_affinity), 1U, 0U,
                 (enum netperf_output_type )2);
#line 1978
  set_output_elt((enum netperf_output_name )28, (char *)"Local", (char *)"Service",
                 (char *)"Demand", (char *)"", (char *)"%.3f", (void *)(& local_service_demand_double),
                 1U, 0U, (enum netperf_output_type )7);
#line 1981
  set_output_elt((enum netperf_output_name )32, (char *)"Service", (char *)"Demand",
                 (char *)"Units", (char *)"", (char *)"%s", (void *)sd_str, 1U, 0U,
                 (enum netperf_output_type )5);
#line 1984
  set_output_elt((enum netperf_output_name )27, (char *)"Local", (char *)"CPU", (char *)"Util",
                 (char *)"Method", (char *)"%c", (void *)(& local_cpu_method), 1U,
                 0U, (enum netperf_output_type )2);
#line 1987
  set_output_elt((enum netperf_output_name )50, (char *)"Local", (char *)"CPU", (char *)"Count",
                 (char *)"", (char *)"%d", (void *)(& lib_num_loc_cpus), 1U, 0U, (enum netperf_output_type )2);
#line 1990
  set_output_elt((enum netperf_output_name )83, (char *)"Local", (char *)"NODELAY",
                 (char *)"", (char *)"", (char *)"%d", (void *)(& loc_nodelay), 1U,
                 0U, (enum netperf_output_type )2);
#line 1993
  set_output_elt((enum netperf_output_name )84, (char *)"Local", (char *)"Cork", (char *)"",
                 (char *)"", (char *)"%d", (void *)(& loc_tcpcork), 1U, 0U, (enum netperf_output_type )2);
#line 1996
  set_output_elt((enum netperf_output_name )14, (char *)"Remote", (char *)"Send Socket",
                 (char *)"Size", (char *)"Requested", (char *)"%d", (void *)(& rss_size_req),
                 1U, 0U, (enum netperf_output_type )2);
#line 1999
  set_output_elt((enum netperf_output_name )15, (char *)"Remote", (char *)"Send Socket",
                 (char *)"Size", (char *)"Initial", (char *)"%d", (void *)(& rss_size),
                 1U, 0U, (enum netperf_output_type )2);
#line 2002
  set_output_elt((enum netperf_output_name )16, (char *)"Remote", (char *)"Send Socket",
                 (char *)"Size", (char *)"Final", (char *)"%d", (void *)(& rss_size_end),
                 1U, 0U, (enum netperf_output_type )2);
#line 2005
  set_output_elt((enum netperf_output_name )17, (char *)"Remote", (char *)"Recv Socket",
                 (char *)"Size", (char *)"Requested", (char *)"%d", (void *)(& rsr_size_req),
                 1U, 0U, (enum netperf_output_type )2);
#line 2008
  set_output_elt((enum netperf_output_name )18, (char *)"Remote", (char *)"Recv Socket",
                 (char *)"Size", (char *)"Initial", (char *)"%d", (void *)(& rsr_size),
                 1U, 0U, (enum netperf_output_type )2);
#line 2011
  set_output_elt((enum netperf_output_name )19, (char *)"Remote", (char *)"Recv Socket",
                 (char *)"Size", (char *)"Final", (char *)"%d", (void *)(& rsr_size_end),
                 1U, 0U, (enum netperf_output_type )2);
#line 2014
  set_output_elt((enum netperf_output_name )22, (char *)"Remote", (char *)"Send",
                 (char *)"Size", (char *)"", (char *)"%d", (void *)(& remote_send_size),
                 1U, 0U, (enum netperf_output_type )2);
#line 2017
  set_output_elt((enum netperf_output_name )23, (char *)"Remote", (char *)"Recv",
                 (char *)"Size", (char *)"", (char *)"%d", (void *)(& remote_recv_size),
                 1U, 0U, (enum netperf_output_type )2);
#line 2020
  set_output_elt((enum netperf_output_name )85, (char *)"Remote", (char *)"Send",
                 (char *)"Calls", (char *)"", (char *)"%lu", (void *)(& remote_send_calls),
                 1U, 0U, (enum netperf_output_type )3);
#line 2023
  set_output_elt((enum netperf_output_name )86, (char *)"Remote", (char *)"Recv",
                 (char *)"Calls", (char *)"", (char *)"%lu", (void *)(& remote_receive_calls),
                 1U, 0U, (enum netperf_output_type )3);
#line 2026
  set_output_elt((enum netperf_output_name )87, (char *)"Remote", (char *)"Bytes",
                 (char *)"Per", (char *)"Recv", (char *)"%.2f", (void *)(& remote_bytes_per_recv),
                 1U, 0U, (enum netperf_output_type )7);
#line 2029
  set_output_elt((enum netperf_output_name )88, (char *)"Remote", (char *)"Bytes",
                 (char *)"Per", (char *)"Send", (char *)"%.2f", (void *)(& remote_bytes_per_send),
                 1U, 0U, (enum netperf_output_type )7);
#line 2032
  set_output_elt((enum netperf_output_name )90, (char *)"Remote", (char *)"Bytes",
                 (char *)"Received", (char *)"", (char *)"%lu", (void *)(& remote_bytes_received),
                 1U, 0U, (enum netperf_output_type )3);
#line 2035
  set_output_elt((enum netperf_output_name )89, (char *)"Remote", (char *)"Bytes",
                 (char *)"Sent", (char *)"", (char *)"%lu", (void *)(& remote_bytes_sent),
                 1U, 0U, (enum netperf_output_type )3);
#line 2038
  set_output_elt((enum netperf_output_name )91, (char *)"Remote", (char *)"Bytes",
                 (char *)"Xferred", (char *)"", (char *)"%.0f", (void *)(& remote_bytes_xferd),
                 1U, 0U, (enum netperf_output_type )7);
#line 2041
  set_output_elt((enum netperf_output_name )96, (char *)"Remote", (char *)"Send",
                 (char *)"Width", (char *)"", (char *)"%d", (void *)(& remote_send_width),
                 1U, 0U, (enum netperf_output_type )2);
#line 2044
  set_output_elt((enum netperf_output_name )97, (char *)"Remote", (char *)"Recv",
                 (char *)"Width", (char *)"", (char *)"%d", (void *)(& remote_recv_width),
                 1U, 0U, (enum netperf_output_type )2);
#line 2047
  set_output_elt((enum netperf_output_name )92, (char *)"Remote", (char *)"Send",
                 (char *)"Offset", (char *)"", (char *)"%d", (void *)(& remote_send_offset),
                 1U, 0U, (enum netperf_output_type )2);
#line 2050
  set_output_elt((enum netperf_output_name )93, (char *)"Remote", (char *)"Recv",
                 (char *)"Offset", (char *)"", (char *)"%d", (void *)(& remote_recv_offset),
                 1U, 0U, (enum netperf_output_type )2);
#line 2053
  set_output_elt((enum netperf_output_name )95, (char *)"Remote", (char *)"Recv",
                 (char *)"Alignment", (char *)"", (char *)"%d", (void *)(& remote_recv_align),
                 1U, 0U, (enum netperf_output_type )2);
#line 2056
  set_output_elt((enum netperf_output_name )94, (char *)"Remote", (char *)"Send",
                 (char *)"Alignment", (char *)"", (char *)"%d", (void *)(& remote_send_align),
                 1U, 0U, (enum netperf_output_type )2);
#line 2059
  set_output_elt((enum netperf_output_name )98, (char *)"Remote", (char *)"Send",
                 (char *)"Dirty", (char *)"Count", (char *)"%d", (void *)(& rem_dirty_count),
                 1U, 0U, (enum netperf_output_type )2);
#line 2062
  set_output_elt((enum netperf_output_name )99, (char *)"Remote", (char *)"Recv",
                 (char *)"Dirty", (char *)"Count", (char *)"%d", (void *)(& rem_dirty_count),
                 1U, 0U, (enum netperf_output_type )2);
#line 2065
  set_output_elt((enum netperf_output_name )100, (char *)"Remote", (char *)"Recv",
                 (char *)"Clean", (char *)"Count", (char *)"%d", (void *)(& rem_clean_count),
                 1U, 0U, (enum netperf_output_type )2);
#line 2068
  set_output_elt((enum netperf_output_name )29, (char *)"Remote", (char *)"CPU", (char *)"Util",
                 (char *)"%", (char *)"%.2f", (void *)(& remote_cpu_utilization_double),
                 1U, 0U, (enum netperf_output_type )7);
#line 2071
  set_output_elt((enum netperf_output_name )57, (char *)"Remote", (char *)"Peak",
                 (char *)"Per CPU", (char *)"Util %", (char *)"%.2f", (void *)(& lib_remote_peak_cpu_util),
                 1U, 0U, (enum netperf_output_type )7);
#line 2074
  set_output_elt((enum netperf_output_name )58, (char *)"Remote", (char *)"Peak",
                 (char *)"Per CPU", (char *)"ID", (char *)"%d", (void *)(& lib_remote_peak_cpu_id),
                 1U, 0U, (enum netperf_output_type )2);
#line 2077
  set_output_elt((enum netperf_output_name )55, (char *)"Remote", (char *)"CPU", (char *)"Bind",
                 (char *)"", (char *)"%d", (void *)(& remote_proc_affinity), 1U, 0U,
                 (enum netperf_output_type )2);
#line 2080
  set_output_elt((enum netperf_output_name )31, (char *)"Remote", (char *)"Service",
                 (char *)"Demand", (char *)"", (char *)"%.3f", (void *)(& remote_service_demand_double),
                 1U, 0U, (enum netperf_output_type )7);
#line 2083
  set_output_elt((enum netperf_output_name )30, (char *)"Remote", (char *)"CPU", (char *)"Util",
                 (char *)"Method", (char *)"%c", (void *)(& remote_cpu_method), 1U,
                 0U, (enum netperf_output_type )2);
#line 2086
  set_output_elt((enum netperf_output_name )56, (char *)"Remote", (char *)"CPU", (char *)"Count",
                 (char *)"", (char *)"%d", (void *)(& lib_num_rem_cpus), 1U, 0U, (enum netperf_output_type )2);
#line 2089
  set_output_elt((enum netperf_output_name )101, (char *)"Remote", (char *)"NODELAY",
                 (char *)"", (char *)"", (char *)"%d", (void *)(& rem_nodelay), 1U,
                 0U, (enum netperf_output_type )2);
#line 2092
  set_output_elt((enum netperf_output_name )102, (char *)"Remote", (char *)"Cork",
                 (char *)"", (char *)"", (char *)"%d", (void *)(& rem_tcpcork), 1U,
                 0U, (enum netperf_output_type )2);
#line 2095
  set_output_elt((enum netperf_output_name )118, (char *)"Local", (char *)"Driver",
                 (char *)"Name", (char *)"", (char *)"%s", (void *)(local_driver_name),
                 1U, 524288U, (enum netperf_output_type )5);
#line 2099
  set_output_elt((enum netperf_output_name )119, (char *)"Local", (char *)"Driver",
                 (char *)"Version", (char *)"", (char *)"%s", (void *)(local_driver_version),
                 1U, 524288U, (enum netperf_output_type )5);
#line 2103
  set_output_elt((enum netperf_output_name )120, (char *)"Local", (char *)"Driver",
                 (char *)"Firmware", (char *)"", (char *)"%s", (void *)(local_driver_firmware),
                 1U, 524288U, (enum netperf_output_type )5);
#line 2107
  set_output_elt((enum netperf_output_name )121, (char *)"Local", (char *)"Driver",
                 (char *)"Bus", (char *)"", (char *)"%s", (void *)(local_driver_bus),
                 1U, 524288U, (enum netperf_output_type )5);
#line 2110
  set_output_elt((enum netperf_output_name )128, (char *)"Remote", (char *)"Driver",
                 (char *)"Name", (char *)"", (char *)"%s", (void *)(remote_driver_name),
                 1U, 8U, (enum netperf_output_type )5);
#line 2114
  set_output_elt((enum netperf_output_name )129, (char *)"Remote", (char *)"Driver",
                 (char *)"Version", (char *)"", (char *)"%s", (void *)(remote_driver_version),
                 1U, 8U, (enum netperf_output_type )5);
#line 2118
  set_output_elt((enum netperf_output_name )130, (char *)"Remote", (char *)"Driver",
                 (char *)"Firmware", (char *)"", (char *)"%s", (void *)(remote_driver_firmware),
                 1U, 8U, (enum netperf_output_type )5);
#line 2122
  set_output_elt((enum netperf_output_name )131, (char *)"Remote", (char *)"Driver",
                 (char *)"Bus", (char *)"", (char *)"%s", (void *)(remote_driver_bus),
                 1U, 8U, (enum netperf_output_type )5);
#line 2126
  set_output_elt((enum netperf_output_name )117, (char *)"Local", (char *)"Interface",
                 (char *)"Subdevice", (char *)"", (char *)"0x%.4x", (void *)(& local_interface_subdevice),
                 1U, 262144U, (enum netperf_output_type )2);
#line 2130
  set_output_elt((enum netperf_output_name )115, (char *)"Local", (char *)"Interface",
                 (char *)"Device", (char *)"", (char *)"0x%.4x", (void *)(& local_interface_device),
                 1U, 262144U, (enum netperf_output_type )2);
#line 2134
  set_output_elt((enum netperf_output_name )116, (char *)"Local", (char *)"Interface",
                 (char *)"Subvendor", (char *)"", (char *)"0x%.4x", (void *)(& local_interface_subvendor),
                 1U, 262144U, (enum netperf_output_type )1);
#line 2138
  set_output_elt((enum netperf_output_name )114, (char *)"Local", (char *)"Interface",
                 (char *)"Vendor", (char *)"", (char *)"0x%.4x", (void *)(& local_interface_vendor),
                 1U, 262144U, (enum netperf_output_type )1);
#line 2142
  set_output_elt((enum netperf_output_name )127, (char *)"Remote", (char *)"Interface",
                 (char *)"Subdevice", (char *)"", (char *)"0x%.4x", (void *)(& remote_interface_subdevice),
                 1U, 4U, (enum netperf_output_type )1);
#line 2146
  set_output_elt((enum netperf_output_name )125, (char *)"Remote", (char *)"Interface",
                 (char *)"Device", (char *)"", (char *)"0x%.4x", (void *)(& remote_interface_device),
                 1U, 4U, (enum netperf_output_type )1);
#line 2150
  set_output_elt((enum netperf_output_name )126, (char *)"Remote", (char *)"Interface",
                 (char *)"Subvendor", (char *)"", (char *)"0x%.4x", (void *)(& remote_interface_subvendor),
                 1U, 4U, (enum netperf_output_type )1);
#line 2154
  set_output_elt((enum netperf_output_name )124, (char *)"Remote", (char *)"Interface",
                 (char *)"Vendor", (char *)"", (char *)"0x%.4x", (void *)(& remote_interface_vendor),
                 1U, 4U, (enum netperf_output_type )1);
#line 2158
  set_output_elt((enum netperf_output_name )113, (char *)"Local", (char *)"Interface",
                 (char *)"Name", (char *)"", (char *)"%s", (void *)local_interface_name,
                 1U, 65536U, (enum netperf_output_type )5);
#line 2162
  set_output_elt((enum netperf_output_name )123, (char *)"Remote", (char *)"Interface",
                 (char *)"Name", (char *)"", (char *)"%s", (void *)remote_interface_name,
                 1U, 1U, (enum netperf_output_type )5);
#line 2166
  set_output_elt((enum netperf_output_name )122, (char *)"Local", (char *)"Interface",
                 (char *)"Slot", (char *)"", (char *)"%s", (void *)local_interface_slot,
                 1U, 131072U, (enum netperf_output_type )5);
#line 2170
  set_output_elt((enum netperf_output_name )132, (char *)"Remote", (char *)"Interface",
                 (char *)"Slot", (char *)"", (char *)"%s", (void *)remote_interface_slot,
                 1U, 2U, (enum netperf_output_type )5);
#line 2174
  set_output_elt((enum netperf_output_name )112, (char *)"Remote", (char *)"Machine",
                 (char *)"", (char *)"", (char *)"%s", (void *)remote_machine, 1U,
                 0U, (enum netperf_output_type )5);
#line 2177
  set_output_elt((enum netperf_output_name )111, (char *)"Remote", (char *)"Version",
                 (char *)"", (char *)"", (char *)"%s", (void *)remote_version, 1U,
                 0U, (enum netperf_output_type )5);
#line 2180
  set_output_elt((enum netperf_output_name )110, (char *)"Remote", (char *)"Release",
                 (char *)"", (char *)"", (char *)"%s", (void *)remote_release, 1U,
                 0U, (enum netperf_output_type )5);
#line 2183
  set_output_elt((enum netperf_output_name )108, (char *)"Remote", (char *)"Sysname",
                 (char *)"", (char *)"", (char *)"%s", (void *)remote_sysname, 1U,
                 0U, (enum netperf_output_type )5);
#line 2186
  set_output_elt((enum netperf_output_name )107, (char *)"Local", (char *)"Machine",
                 (char *)"", (char *)"", (char *)"%s", (void *)local_machine, 1U,
                 0U, (enum netperf_output_type )5);
#line 2189
  set_output_elt((enum netperf_output_name )106, (char *)"Local", (char *)"Version",
                 (char *)"", (char *)"", (char *)"%s", (void *)local_version, 1U,
                 0U, (enum netperf_output_type )5);
#line 2192
  set_output_elt((enum netperf_output_name )105, (char *)"Local", (char *)"Release",
                 (char *)"", (char *)"", (char *)"%s", (void *)local_release, 1U,
                 0U, (enum netperf_output_type )5);
#line 2195
  set_output_elt((enum netperf_output_name )103, (char *)"Local", (char *)"Sysname",
                 (char *)"", (char *)"", (char *)"%s", (void *)local_sysname, 1U,
                 0U, (enum netperf_output_type )5);
#line 2198
  set_output_elt((enum netperf_output_name )135, (char *)"Remote", (char *)"Interval",
                 (char *)"Usecs", (char *)"", (char *)"%d", (void *)(& remote_interval_usecs),
                 1U, 0U, (enum netperf_output_type )2);
#line 2201
  set_output_elt((enum netperf_output_name )136, (char *)"Remote", (char *)"Interval",
                 (char *)"Burst", (char *)"", (char *)"%d", (void *)(& remote_interval_burst),
                 1U, 0U, (enum netperf_output_type )2);
#line 2204
  set_output_elt((enum netperf_output_name )140, (char *)"Local", (char *)"OS", (char *)"Security",
                 (char *)"Enabled", (char *)"%s", (void *)local_security_enabled,
                 1U, 0U, (enum netperf_output_type )5);
#line 2207
  set_output_elt((enum netperf_output_name )138, (char *)"Local", (char *)"OS", (char *)"Security",
                 (char *)"Type", (char *)"%s", (void *)local_security_type, 1U, 0U,
                 (enum netperf_output_type )5);
#line 2210
  set_output_elt((enum netperf_output_name )141, (char *)"Local", (char *)"OS", (char *)"Security",
                 (char *)"Specific", (char *)"%s", (void *)local_security_specific,
                 1U, 0U, (enum netperf_output_type )5);
#line 2214
  set_output_elt((enum netperf_output_name )139, (char *)"Local", (char *)"OS", (char *)"Security",
                 (char *)"Enabled Num", (char *)"%d", (void *)(& local_security_enabled_num),
                 1U, 0U, (enum netperf_output_type )2);
#line 2218
  set_output_elt((enum netperf_output_name )137, (char *)"Local", (char *)"OS", (char *)"Security",
                 (char *)"Type ID", (char *)"%d", (void *)(& local_security_type_id),
                 1U, 0U, (enum netperf_output_type )2);
#line 2221
  set_output_elt((enum netperf_output_name )145, (char *)"Remote", (char *)"OS", (char *)"Security",
                 (char *)"Enabled", (char *)"%s", (void *)remote_security_enabled,
                 1U, 0U, (enum netperf_output_type )5);
#line 2225
  set_output_elt((enum netperf_output_name )143, (char *)"Remote", (char *)"OS", (char *)"Security",
                 (char *)"Type", (char *)"%s", (void *)remote_security_type, 1U, 0U,
                 (enum netperf_output_type )5);
#line 2228
  set_output_elt((enum netperf_output_name )146, (char *)"Remote", (char *)"OS", (char *)"Security",
                 (char *)"Specific", (char *)"%s", (void *)remote_security_specific,
                 1U, 0U, (enum netperf_output_type )5);
#line 2232
  set_output_elt((enum netperf_output_name )144, (char *)"Remote", (char *)"OS", (char *)"Security",
                 (char *)"Enabled", (char *)"%d", (void *)(& remote_security_enabled_num),
                 1U, 0U, (enum netperf_output_type )2);
#line 2236
  set_output_elt((enum netperf_output_name )142, (char *)"Remote", (char *)"OS", (char *)"Security",
                 (char *)"Type", (char *)"%d", (void *)(& remote_security_type_id),
                 1U, 0U, (enum netperf_output_type )2);
#line 2239
  set_output_elt((enum netperf_output_name )133, (char *)"Local", (char *)"Interval",
                 (char *)"Usecs", (char *)"", (char *)"%d", (void *)(& interval_usecs),
                 1U, 0U, (enum netperf_output_type )2);
#line 2242
  set_output_elt((enum netperf_output_name )134, (char *)"Local", (char *)"Interval",
                 (char *)"Burst", (char *)"", (char *)"%d", (void *)(& interval_burst),
                 1U, 0U, (enum netperf_output_type )2);
#line 2245
  set_output_elt((enum netperf_output_name )109, (char *)"Remote", (char *)"System",
                 (char *)"Model", (char *)"", (char *)"%s", (void *)remote_system_model,
                 1U, 0U, (enum netperf_output_type )5);
#line 2248
  set_output_elt((enum netperf_output_name )59, (char *)"Remote", (char *)"CPU", (char *)"Model",
                 (char *)"", (char *)"%s", (void *)remote_cpu_model, 1U, 0U, (enum netperf_output_type )5);
#line 2251
  set_output_elt((enum netperf_output_name )60, (char *)"Remote", (char *)"CPU", (char *)"Frequency",
                 (char *)"MHz", (char *)"%d", (void *)(& remote_cpu_frequency), 1U,
                 0U, (enum netperf_output_type )2);
#line 2254
  set_output_elt((enum netperf_output_name )104, (char *)"Local", (char *)"System",
                 (char *)"Model", (char *)"", (char *)"%s", (void *)local_system_model,
                 1U, 0U, (enum netperf_output_type )5);
#line 2257
  set_output_elt((enum netperf_output_name )53, (char *)"Local", (char *)"CPU", (char *)"Model",
                 (char *)"", (char *)"%s", (void *)local_cpu_model, 1U, 0U, (enum netperf_output_type )5);
#line 2260
  set_output_elt((enum netperf_output_name )54, (char *)"Local", (char *)"CPU", (char *)"Frequency",
                 (char *)"MHz", (char *)"%d", (void *)(& local_cpu_frequency), 1U,
                 0U, (enum netperf_output_type )2);
#line 2263
  set_output_elt((enum netperf_output_name )149, (char *)"Minimum", (char *)"Latency",
                 (char *)"Microseconds", (char *)"", (char *)"%d", (void *)(& min_latency),
                 0U, 1048592U, (enum netperf_output_type )2);
#line 2266
  set_output_elt((enum netperf_output_name )150, (char *)"Maximum", (char *)"Latency",
                 (char *)"Microseconds", (char *)"", (char *)"%d", (void *)(& max_latency),
                 0U, 1048592U, (enum netperf_output_type )2);
#line 2269
  set_output_elt((enum netperf_output_name )151, (char *)"50th", (char *)"Percentile",
                 (char *)"Latency", (char *)"Microseconds", (char *)"%d", (void *)(& p50_latency),
                 0U, 1048592U, (enum netperf_output_type )2);
#line 2272
  set_output_elt((enum netperf_output_name )152, (char *)"90th", (char *)"Percentile",
                 (char *)"Latency", (char *)"Microseconds", (char *)"%d", (void *)(& p90_latency),
                 0U, 1048592U, (enum netperf_output_type )2);
#line 2275
  set_output_elt((enum netperf_output_name )153, (char *)"99th", (char *)"Percentile",
                 (char *)"Latency", (char *)"Microseconds", (char *)"%d", (void *)(& p99_latency),
                 0U, 1048592U, (enum netperf_output_type )2);
#line 2278
  set_output_elt((enum netperf_output_name )154, (char *)"Mean", (char *)"Latency",
                 (char *)"Microseconds", (char *)"", (char *)"%.2f", (void *)(& mean_latency),
                 0U, 1048592U, (enum netperf_output_type )7);
#line 2281
  set_output_elt((enum netperf_output_name )155, (char *)"Stddev", (char *)"Latency",
                 (char *)"Microseconds", (char *)"", (char *)"%.2f", (void *)(& stddev_latency),
                 0U, 1048592U, (enum netperf_output_type )7);
#line 2284
  set_output_elt((enum netperf_output_name )156, (char *)"Local", (char *)"Socket",
                 (char *)"Priority", (char *)"", (char *)"%d", (void *)(& local_socket_prio),
                 1U, 0U, (enum netperf_output_type )2);
#line 2287
  set_output_elt((enum netperf_output_name )157, (char *)"Remote", (char *)"Socket",
                 (char *)"Priority", (char *)"", (char *)"%d", (void *)(& remote_socket_prio),
                 1U, 0U, (enum netperf_output_type )2);
#line 2290
  set_output_elt((enum netperf_output_name )158, (char *)"Local", (char *)"Socket",
                 (char *)"TOS", (char *)"", (char *)"0x%.2x", (void *)(& local_socket_tos),
                 1U, 0U, (enum netperf_output_type )2);
#line 2293
  set_output_elt((enum netperf_output_name )159, (char *)"Remote", (char *)"Socket",
                 (char *)"TOS", (char *)"", (char *)"0x%.2x", (void *)(& remote_socket_tos),
                 1U, 0U, (enum netperf_output_type )2);
#line 2296
  set_output_elt((enum netperf_output_name )160, (char *)"Local", (char *)"Congestion",
                 (char *)"Control", (char *)"Algorithm", (char *)"%s", (void *)(local_cong_control),
                 0U, 2097152U, (enum netperf_output_type )5);
#line 2300
  set_output_elt((enum netperf_output_name )161, (char *)"Remote", (char *)"Congestion",
                 (char *)"Control", (char *)"Algorithm", (char *)"%s", (void *)(remote_cong_control),
                 0U, 32U, (enum netperf_output_type )5);
#line 2304
  set_output_elt((enum netperf_output_name )162, (char *)"Local", (char *)"Fill",
                 (char *)"File", (char *)"", (char *)"%s", (void *)(local_fill_file),
                 0U, 0U, (enum netperf_output_type )5);
#line 2307
  set_output_elt((enum netperf_output_name )163, (char *)"Remote", (char *)"Fill",
                 (char *)"File", (char *)"", (char *)"%s", (void *)(remote_fill_file),
                 0U, 0U, (enum netperf_output_type )5);
#line 2310
  set_output_elt((enum netperf_output_name )165, (char *)"This", (char *)"Is", (char *)"The",
                 (char *)"End", (char *)"%s", (void *)0, 0U, 0U, (enum netperf_output_type )5);
  }
#line 2313
  return;
}
}
#line 2315 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void print_omni_init(void) 
{ 
  int i ;
  int j ;

  {
#line 2320
  if (debug) {
    {
#line 2321
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s entered\n",
            "print_omni_init");
#line 2323
    fflush(where);
    }
  }
  {
#line 2333
  print_omni_init_list();
  }
#line 2335
  if (printing_initialized) {
#line 2335
    return;
  }
#line 2337
  printing_initialized = 1;
#line 2341
  j = 0;
  {
#line 2341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2341
    if (! (j < 4)) {
#line 2341
      goto while_break;
    }
#line 2342
    i = 0;
    {
#line 2342
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2342
      if (! (i < 166)) {
#line 2342
        goto while_break___0;
      }
#line 2343
      output_list[j][i] = (enum netperf_output_name )165;
#line 2342
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2341
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2346
  if (output_selection_spec) {
    {
#line 2347
    parse_output_selection(output_selection_spec);
    }
  } else {
    {
#line 2350
    set_output_list_by_test();
    }
  }
#line 2353
  return;
}
}
#line 2431 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int my_snprintf(char *buffer , size_t size , netperf_output_elt_t *output_elt ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 2435
  if ((unsigned int )output_elt->output_type == 5U) {
#line 2435
    goto case_5;
  }
#line 2440
  if ((unsigned int )output_elt->output_type == 2U) {
#line 2440
    goto case_2;
  }
#line 2445
  if ((unsigned int )output_elt->output_type == 1U) {
#line 2445
    goto case_1;
  }
#line 2450
  if ((unsigned int )output_elt->output_type == 4U) {
#line 2450
    goto case_4;
  }
#line 2455
  if ((unsigned int )output_elt->output_type == 3U) {
#line 2455
    goto case_3;
  }
#line 2460
  if ((unsigned int )output_elt->output_type == 7U) {
#line 2460
    goto case_7;
  }
#line 2465
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 2436
  tmp = snprintf((char */* __restrict  */)buffer, size, (char const   */* __restrict  */)output_elt->format,
                 (char *)output_elt->display_value);
  }
#line 2436
  return (tmp);
#line 2439
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2441
  tmp___0 = snprintf((char */* __restrict  */)buffer, size, (char const   */* __restrict  */)output_elt->format,
                     *((int *)output_elt->display_value));
  }
#line 2441
  return (tmp___0);
#line 2444
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 2446
  tmp___1 = snprintf((char */* __restrict  */)buffer, size, (char const   */* __restrict  */)output_elt->format,
                     *((unsigned int *)output_elt->display_value));
  }
#line 2446
  return (tmp___1);
#line 2449
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2451
  tmp___2 = snprintf((char */* __restrict  */)buffer, size, (char const   */* __restrict  */)output_elt->format,
                     *((long long *)output_elt->display_value));
  }
#line 2451
  return (tmp___2);
#line 2454
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2456
  tmp___3 = snprintf((char */* __restrict  */)buffer, size, (char const   */* __restrict  */)output_elt->format,
                     *((unsigned long long *)output_elt->display_value));
  }
#line 2456
  return (tmp___3);
#line 2459
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 2461
  tmp___4 = snprintf((char */* __restrict  */)buffer, size, (char const   */* __restrict  */)output_elt->format,
                     *((double *)output_elt->display_value));
  }
#line 2461
  return (tmp___4);
#line 2464
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2466
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown/unsupported output_elt output_type of %d\n",
          (unsigned int )output_elt->output_type);
#line 2469
  fflush(stderr);
#line 2470
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 2472
  return (0);
}
}
#line 2473 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void print_omni_csv(void) 
{ 
  int i ;
  int j ;
  int k ;
  int buflen ;
  int vallen ;
  char *hdr1 ;
  char *val1 ;
  char *h1 ;
  char *v1 ;
  char tmpval[1024] ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int len ;
  int tmp___2 ;

  {
#line 2479
  hdr1 = (char *)((void *)0);
#line 2480
  val1 = (char *)((void *)0);
#line 2481
  h1 = (char *)((void *)0);
#line 2482
  v1 = (char *)((void *)0);
#line 2485
  buflen = 0;
#line 2486
  i = 0;
  {
#line 2486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2486
    if (! (i < 4)) {
#line 2486
      goto while_break;
    }
#line 2487
    j = 0;
    {
#line 2487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2487
      if (j < 166) {
#line 2487
        if (! ((unsigned int )output_list[i][j] != 165U)) {
#line 2487
          goto while_break___0;
        }
      } else {
#line 2487
        goto while_break___0;
      }
#line 2491
      if ((unsigned long )netperf_output_source[output_list[i][j]].format != (unsigned long )((void *)0)) {
#line 2491
        if ((unsigned long )netperf_output_source[output_list[i][j]].display_value != (unsigned long )((void *)0)) {
          {
#line 2493
          vallen = my_snprintf(tmpval, (size_t )1024, & netperf_output_source[output_list[i][j]]);
          }
#line 2497
          if (vallen == -1) {
            {
#line 2498
            tmp = netperf_output_enum_to_str((enum netperf_output_name )j);
#line 2498
            fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"my_snprintf failed on %s with format %s\n",
                    tmp, netperf_output_source[output_list[i][j]].format);
#line 2501
            fflush(where);
            }
          }
#line 2503
          vallen ++;
        } else {
#line 2506
          vallen = 0;
        }
      } else {
#line 2506
        vallen = 0;
      }
#line 2508
      if (vallen > netperf_output_source[output_list[i][j]].tot_line_len) {
#line 2510
        netperf_output_source[output_list[i][j]].tot_line_len = vallen;
      }
#line 2512
      buflen += netperf_output_source[output_list[i][j]].tot_line_len;
#line 2487
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2486
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2517
  if (print_headers) {
    {
#line 2517
    tmp___0 = malloc((size_t )(buflen + 1));
#line 2517
    hdr1 = (char *)tmp___0;
    }
  }
  {
#line 2518
  tmp___1 = malloc((size_t )(buflen + 1));
#line 2518
  val1 = (char *)tmp___1;
  }
#line 2520
  if ((unsigned long )hdr1 == (unsigned long )((void *)0)) {
#line 2520
    if (print_headers) {
      {
#line 2522
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"unable to allocate output buffers\n");
#line 2523
      fflush(where);
#line 2524
      exit(-1);
      }
    } else {
#line 2520
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2520
  if ((unsigned long )val1 == (unsigned long )((void *)0)) {
    {
#line 2522
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"unable to allocate output buffers\n");
#line 2523
    fflush(where);
#line 2524
    exit(-1);
    }
  }
#line 2527
  if (print_headers) {
    {
#line 2527
    memset((void *)hdr1, ' ', (size_t )(buflen + 1));
    }
  }
  {
#line 2528
  memset((void *)val1, ' ', (size_t )(buflen + 1));
#line 2532
  h1 = hdr1;
#line 2533
  v1 = val1;
#line 2534
  i = 0;
  }
  {
#line 2534
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2534
    if (! (i < 4)) {
#line 2534
      goto while_break___1;
    }
#line 2535
    j = 0;
    {
#line 2535
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2535
      if (j < 166) {
#line 2535
        if (! ((unsigned int )output_list[i][j] != 165U)) {
#line 2535
          goto while_break___2;
        }
      } else {
#line 2535
        goto while_break___2;
      }
#line 2540
      len = 0;
#line 2541
      if (print_headers) {
#line 2542
        k = 0;
        {
#line 2542
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2542
          if (k < 4) {
#line 2542
            if ((unsigned long )((void *)0) != (unsigned long )netperf_output_source[output_list[i][j]].line[k]) {
              {
#line 2542
              tmp___2 = strcmp("", (char const   *)netperf_output_source[output_list[i][j]].line[k]);
              }
#line 2542
              if (! tmp___2) {
#line 2542
                goto while_break___3;
              }
            } else {
#line 2542
              goto while_break___3;
            }
          } else {
#line 2542
            goto while_break___3;
          }
          {
#line 2547
          len = sprintf((char */* __restrict  */)h1, (char const   */* __restrict  */)"%s",
                        netperf_output_source[output_list[i][j]].line[k]);
#line 2550
          *(h1 + len) = (char )' ';
#line 2553
          h1 += len + 1;
#line 2542
          k ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 2555
        *(h1 - 1) = (char )',';
      }
#line 2557
      if ((unsigned long )netperf_output_source[output_list[i][j]].format != (unsigned long )((void *)0)) {
#line 2557
        if ((unsigned long )netperf_output_source[output_list[i][j]].display_value != (unsigned long )((void *)0)) {
          {
#line 2560
          len = my_snprintf(v1, (size_t )netperf_output_source[output_list[i][j]].tot_line_len,
                            & netperf_output_source[output_list[i][j]]);
#line 2565
          *(v1 + len) = (char )',';
#line 2566
          v1 += len + 1;
          }
        } else {
#line 2570
          *v1 = (char )',';
#line 2571
          v1 += 2;
        }
      } else {
#line 2570
        *v1 = (char )',';
#line 2571
        v1 += 2;
      }
#line 2535
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2534
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2578
  if (print_headers) {
#line 2578
    *(h1 - 1) = (char)0;
  }
#line 2579
  *(v1 - 1) = (char)0;
#line 2582
  if ((unsigned int )output_list[0][0] != 165U) {
#line 2583
    if (print_headers) {
      {
#line 2583
      printf((char const   */* __restrict  */)"%s\n", hdr1);
      }
    }
    {
#line 2584
    printf((char const   */* __restrict  */)"%s\n", val1);
    }
  }
#line 2587
  if ((unsigned long )hdr1 != (unsigned long )((void *)0)) {
    {
#line 2587
    free((void *)hdr1);
    }
  }
#line 2588
  if ((unsigned long )val1 != (unsigned long )((void *)0)) {
    {
#line 2588
    free((void *)val1);
    }
  }
#line 2590
  return;
}
}
#line 2592 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void print_omni_keyword(void) 
{ 
  int i ;
  int j ;
  char tmpval[1024] ;
  int vallen ;
  char *tmp ;

  {
#line 2602
  i = 0;
  {
#line 2602
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2602
    if (! (i < 4)) {
#line 2602
      goto while_break;
    }
#line 2603
    j = 0;
    {
#line 2603
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2603
      if (j < 166) {
#line 2603
        if (! ((unsigned int )output_list[i][j] != 165U)) {
#line 2603
          goto while_break___0;
        }
      } else {
#line 2603
        goto while_break___0;
      }
#line 2607
      if ((unsigned long )netperf_output_source[output_list[i][j]].format != (unsigned long )((void *)0)) {
#line 2607
        if ((unsigned long )netperf_output_source[output_list[i][j]].display_value != (unsigned long )((void *)0)) {
          {
#line 2609
          vallen = my_snprintf(tmpval, (size_t )1024, & netperf_output_source[output_list[i][j]]);
          }
#line 2613
          if (vallen == -1) {
            {
#line 2614
            snprintf((char */* __restrict  */)(tmpval), (size_t )1024, (char const   */* __restrict  */)"my_snprintf failed with format %s\n",
                     netperf_output_source[output_list[i][j]].format);
            }
          }
          {
#line 2619
          tmp = netperf_output_enum_to_str(output_list[i][j]);
#line 2619
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s=%s\n",
                  tmp, tmpval);
          }
        }
      }
#line 2603
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2602
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2625
  fflush(where);
  }
#line 2626
  return;
}
}
#line 2628 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void print_omni_human(void) 
{ 
  int i ;
  int j ;
  int k ;
  int buflen ;
  int buflen_max ;
  char *hdr[4] ;
  char *val1 ;
  char tmpval[1024] ;
  int vallen ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *h[4] ;
  char *v1 ;
  size_t tmp___2 ;
  int len ;

  {
#line 2635
  val1 = (char *)((void *)0);
#line 2639
  k = 0;
  {
#line 2639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2639
    if (! (k < 4)) {
#line 2639
      goto while_break;
    }
#line 2640
    hdr[k] = (char *)((void *)0);
#line 2639
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2649
  buflen_max = 0;
#line 2650
  i = 0;
  {
#line 2650
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2650
    if (! (i < 4)) {
#line 2650
      goto while_break___0;
    }
#line 2651
    buflen = 0;
#line 2652
    j = 0;
    {
#line 2652
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2652
      if (j < 166) {
#line 2652
        if (! ((unsigned int )output_list[i][j] != 165U)) {
#line 2652
          goto while_break___1;
        }
      } else {
#line 2652
        goto while_break___1;
      }
#line 2656
      if ((unsigned long )netperf_output_source[output_list[i][j]].format != (unsigned long )((void *)0)) {
#line 2656
        if ((unsigned long )netperf_output_source[output_list[i][j]].display_value != (unsigned long )((void *)0)) {
          {
#line 2660
          tmp = my_snprintf(tmpval, (size_t )1024, & netperf_output_source[output_list[i][j]]);
#line 2660
          vallen = tmp + 1;
          }
        } else {
#line 2664
          vallen = 0;
        }
      } else {
#line 2664
        vallen = 0;
      }
#line 2666
      if (vallen > netperf_output_source[output_list[i][j]].max_line_len) {
#line 2668
        netperf_output_source[output_list[i][j]].max_line_len = vallen;
      }
#line 2670
      buflen += netperf_output_source[output_list[i][j]].max_line_len + 1;
#line 2652
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2674
    if (buflen > buflen_max) {
#line 2675
      buflen_max = buflen;
    }
#line 2650
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2679
  k = 0;
  {
#line 2679
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2679
    if (k < 4) {
#line 2679
      if (! print_headers) {
#line 2679
        goto while_break___2;
      }
    } else {
#line 2679
      goto while_break___2;
    }
    {
#line 2680
    tmp___0 = malloc((size_t )(buflen_max + 1));
#line 2680
    hdr[k] = (char *)tmp___0;
#line 2679
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2682
  tmp___1 = malloc((size_t )(buflen_max + 1));
#line 2682
  val1 = (char *)tmp___1;
#line 2686
  k = 0;
  }
  {
#line 2686
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2686
    if (k < 4) {
#line 2686
      if (! print_headers) {
#line 2686
        goto while_break___3;
      }
    } else {
#line 2686
      goto while_break___3;
    }
#line 2687
    if ((unsigned long )hdr[k] == (unsigned long )((void *)0)) {
      {
#line 2688
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Unable to allocate output buffers\n");
#line 2689
      fflush(where);
#line 2690
      exit(-1);
      }
    }
#line 2686
    k ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2696
  i = 0;
  {
#line 2696
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2696
    if (! (i < 4)) {
#line 2696
      goto while_break___4;
    }
#line 2698
    v1 = val1;
#line 2700
    k = 0;
    {
#line 2700
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2700
      if (! (k < 4)) {
#line 2700
        goto while_break___5;
      }
#line 2700
      h[k] = hdr[k];
#line 2700
      k ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2703
    k = 0;
    {
#line 2703
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2703
      if (k < 4) {
#line 2703
        if (! print_headers) {
#line 2703
          goto while_break___6;
        }
      } else {
#line 2703
        goto while_break___6;
      }
      {
#line 2704
      memset((void *)hdr[k], ' ', (size_t )(buflen_max + 1));
#line 2703
      k ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 2706
    memset((void *)val1, ' ', (size_t )(buflen_max + 1));
#line 2709
    j = 0;
    }
    {
#line 2709
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2709
      if (j < 166) {
#line 2709
        if (! ((unsigned int )output_list[i][j] != 165U)) {
#line 2709
          goto while_break___7;
        }
      } else {
#line 2709
        goto while_break___7;
      }
#line 2713
      if (print_headers) {
#line 2714
        k = 0;
        {
#line 2714
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2714
          if (! (k < 4)) {
#line 2714
            goto while_break___8;
          }
          {
#line 2715
          tmp___2 = strlen((char const   *)netperf_output_source[output_list[i][j]].line[k]);
#line 2715
          memcpy((void */* __restrict  */)h[k], (void const   */* __restrict  */)netperf_output_source[output_list[i][j]].line[k],
                 tmp___2);
#line 2714
          k ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 2720
      if ((unsigned long )netperf_output_source[output_list[i][j]].format != (unsigned long )((void *)0)) {
#line 2720
        if ((unsigned long )netperf_output_source[output_list[i][j]].display_value != (unsigned long )((void *)0)) {
          {
#line 2723
          len = my_snprintf(v1, (size_t )netperf_output_source[output_list[i][j]].max_line_len,
                            & netperf_output_source[output_list[i][j]]);
#line 2727
          *(v1 + len) = (char )' ';
          }
        }
      }
#line 2730
      k = 0;
      {
#line 2730
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 2730
        if (k < 4) {
#line 2730
          if (! print_headers) {
#line 2730
            goto while_break___9;
          }
        } else {
#line 2730
          goto while_break___9;
        }
#line 2731
        h[k] += netperf_output_source[output_list[i][j]].max_line_len + 1;
#line 2730
        k ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 2734
      v1 += netperf_output_source[output_list[i][j]].max_line_len + 1;
#line 2709
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2737
    k = 0;
    {
#line 2737
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 2737
      if (k < 4) {
#line 2737
        if (! print_headers) {
#line 2737
          goto while_break___10;
        }
      } else {
#line 2737
        goto while_break___10;
      }
#line 2738
      *(h[k]) = (char)0;
#line 2737
      k ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 2740
    *v1 = (char)0;
#line 2745
    if ((unsigned int )output_list[i][0] != 165U) {
#line 2746
      if (i > 0) {
        {
#line 2746
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 2747
      k = 0;
      {
#line 2747
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 2747
        if (k < 4) {
#line 2747
          if (! print_headers) {
#line 2747
            goto while_break___11;
          }
        } else {
#line 2747
          goto while_break___11;
        }
        {
#line 2748
        printf((char const   */* __restrict  */)"%s\n", hdr[k]);
#line 2747
        k ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 2750
      printf((char const   */* __restrict  */)"%s\n", val1);
      }
    }
#line 2696
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2753
  k = 0;
  {
#line 2753
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 2753
    if (! (k < 4)) {
#line 2753
      goto while_break___12;
    }
#line 2754
    if ((unsigned long )hdr[k] != (unsigned long )((void *)0)) {
      {
#line 2754
      free((void *)hdr[k]);
      }
    }
#line 2753
    k ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 2756
  return;
}
}
#line 2758 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void print_omni(void) 
{ 


  {
  {
#line 2762
  print_omni_init();
  }
#line 2764
  if (debug > 2) {
    {
#line 2765
    dump_netperf_output_source(where);
    }
  }
  {
#line 2768
  if ((unsigned int )netperf_output_mode == 1U) {
#line 2768
    goto case_1;
  }
#line 2771
  if ((unsigned int )netperf_output_mode == 2U) {
#line 2771
    goto case_2;
  }
#line 2774
  if ((unsigned int )netperf_output_mode == 0U) {
#line 2774
    goto case_0;
  }
#line 2777
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2769
  print_omni_csv();
  }
#line 2770
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2772
  print_omni_keyword();
  }
#line 2773
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 2775
  print_omni_human();
  }
#line 2776
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2778
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Yo Rick! There is a bug in netperf_output_mode!\n");
#line 2779
  fflush(where);
#line 2780
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 2783
  return;
}
}
#line 2793 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int connect_data_socket(int send_socket , struct addrinfo *remote_res ) 
{ 
  int ret ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 2799
  ret = connect(send_socket, (struct sockaddr  const  *)remote_res->ai_addr, remote_res->ai_addrlen);
  }
#line 2799
  if (ret == -1) {
    {
#line 2802
    tmp = __errno_location();
    }
#line 2802
    if (*tmp == 4) {
#line 2805
      return (-1);
    }
    {
#line 2807
    tmp___0 = __errno_location();
    }
#line 2807
    if (*tmp___0 == 98) {
#line 2815
      return (-2);
    } else {
      {
#line 2807
      tmp___1 = __errno_location();
      }
#line 2807
      if (*tmp___1 == 99) {
#line 2815
        return (-2);
      } else {
#line 2819
        return (-3);
      }
    }
  }
#line 2821
  return (0);
}
}
#line 2824 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int send_data(int data_socket , struct ring_elt *send_ring , uint32_t bytes_to_send___0 ,
              struct sockaddr *destination , int destlen ) 
{ 
  int len ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 2833
  if (debug > 2) {
    {
#line 2834
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s sock %d, ring elt %p, bytes %d, dest %p, len %d\n",
            "send_data", data_socket, send_ring, bytes_to_send___0, destination, destlen);
#line 2842
    fflush(where);
    }
  }
#line 2845
  if (destination) {
    {
#line 2846
    tmp = sendto(data_socket, (void const   *)send_ring->buffer_ptr, (size_t )bytes_to_send___0,
                 0, (struct sockaddr  const  *)destination, (socklen_t )destlen);
#line 2846
    len = (int )tmp;
    }
  } else {
    {
#line 2854
    tmp___0 = send(data_socket, (void const   *)send_ring->buffer_ptr, (size_t )bytes_to_send___0,
                   0);
#line 2854
    len = (int )tmp___0;
    }
  }
#line 2859
  if ((uint32_t )len != bytes_to_send___0) {
    {
#line 2862
    tmp___1 = __errno_location();
    }
#line 2862
    if (*tmp___1 == 4) {
#line 2865
      return (-1);
    } else
#line 2862
    if (len >= 0) {
#line 2865
      return (-1);
    }
    {
#line 2877
    tmp___3 = __errno_location();
    }
#line 2877
    if (*tmp___3 == 105) {
#line 2878
      return (-2);
    } else {
      {
#line 2880
      tmp___2 = __errno_location();
#line 2880
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: data send error: errno %d\n",
              "send_data", *tmp___2);
      }
#line 2881
      return (-3);
    }
  }
#line 2884
  return (len);
}
}
#line 2892
static int recv_data_no_copy(int data_socket , struct ring_elt *recv_ring , uint32_t bytes_to_recv___0 ,
                             struct sockaddr *source , unsigned int *sourcelen , uint32_t flags ,
                             uint32_t *num_receives ) ;
#line 2892 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int pfd[2]  = {      -1,      -1};
#line 2893 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int fdnull  =    -1;
#line 2943
extern int ( /* missing proto */  splice)() ;
#line 2888 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int recv_data_no_copy(int data_socket , struct ring_elt *recv_ring , uint32_t bytes_to_recv___0 ,
                             struct sockaddr *source , unsigned int *sourcelen , uint32_t flags ,
                             uint32_t *num_receives ) 
{ 
  int bytes_left ;
  int bytes_recvd ;
  int my_recvs ;
  int my_flags ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;

  {
#line 2900
  my_flags = 0;
#line 2903
  if (pfd[0] == -1) {
    {
#line 2904
    tmp___2 = pipe((int *)(pfd));
    }
#line 2904
    if (tmp___2) {
      {
#line 2905
      tmp = __errno_location();
#line 2905
      tmp___0 = strerror(*tmp);
#line 2905
      tmp___1 = __errno_location();
#line 2905
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s pipe call failed with errno %d \'%s\'\n",
              "recv_data_no_copy", *tmp___1, tmp___0);
      }
#line 2910
      return (-4);
    }
    {
#line 2913
    fdnull = open("/dev/null", 1);
    }
#line 2913
    if (fdnull == -1) {
      {
#line 2914
      tmp___3 = __errno_location();
#line 2914
      tmp___4 = strerror(*tmp___3);
#line 2914
      tmp___5 = __errno_location();
#line 2914
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s open call failed with errno %d \'%s\'\n",
              "recv_data_no_copy", *tmp___5, tmp___4);
      }
#line 2919
      return (-4);
    }
  }
#line 2925
  my_recvs = 0;
#line 2926
  bytes_left = (int )bytes_to_recv___0;
#line 2928
  if (debug > 1) {
#line 2929
    if ((unsigned long )source != (unsigned long )((void *)0)) {
#line 2929
      tmp___6 = *sourcelen;
    } else {
#line 2929
      tmp___6 = 4294967295U;
    }
    {
#line 2929
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s sock %d, ring elt %p, bytes %d, source %p, srclen %d, flags %x, num_recv %p\n",
            "recv_data_no_copy", data_socket, recv_ring, bytes_to_recv___0, source,
            tmp___6, flags, num_receives);
#line 2939
    fflush(where);
    }
  }
  {
#line 2941
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2943
    bytes_recvd = splice(data_socket, (void *)0, pfd[1], (void *)0, bytes_left, my_flags);
    }
#line 2951
    if (bytes_recvd > 0) {
      {
#line 2952
      tmp___7 = splice(pfd[0], (void *)0, fdnull, (void *)0, bytes_recvd, my_flags);
      }
#line 2952
      if (tmp___7 != bytes_recvd) {
#line 2958
        return (-3);
      }
#line 2960
      bytes_left -= bytes_recvd;
    } else {
#line 2963
      goto while_break;
    }
#line 2965
    my_recvs ++;
#line 2941
    if (bytes_left > 0) {
#line 2941
      if (! (flags & 1U)) {
#line 2941
        goto while_break;
      }
    } else {
#line 2941
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2968
  *num_receives = (uint32_t )my_recvs;
#line 2971
  if (bytes_recvd < 0) {
    {
#line 2973
    tmp___8 = __errno_location();
    }
#line 2973
    if (*tmp___8 == 4) {
#line 2976
      return (-1);
    }
#line 2979
    return (-3);
  }
#line 2989
  if (bytes_left) {
#line 2990
    return (bytes_recvd);
  } else {
#line 2992
    return ((int )bytes_to_recv___0);
  }
}
}
#line 2997 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int recv_data(int data_socket , struct ring_elt *recv_ring , uint32_t bytes_to_recv___0 ,
              struct sockaddr *source , unsigned int *sourcelen , uint32_t flags ,
              uint32_t *num_receives ) 
{ 
  char *temp_message_ptr ;
  int bytes_left ;
  int bytes_recvd ;
  int my_recvs ;
  int my_flags ;
  int ret ;
  unsigned int tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;

  {
#line 3004
  my_flags = 0;
#line 3008
  if (loc_rcvavoid == 1) {
    {
#line 3009
    ret = recv_data_no_copy(data_socket, recv_ring, bytes_to_recv___0, source, sourcelen,
                            flags, num_receives);
    }
#line 3010
    if (ret != -4) {
#line 3011
      return (ret);
    } else {
#line 3013
      loc_rcvavoid = 0;
    }
  }
#line 3019
  my_recvs = 0;
#line 3020
  bytes_left = (int )bytes_to_recv___0;
#line 3021
  temp_message_ptr = recv_ring->buffer_ptr;
#line 3023
  if (debug > 1) {
#line 3024
    if ((unsigned long )source != (unsigned long )((void *)0)) {
#line 3024
      tmp = *sourcelen;
    } else {
#line 3024
      tmp = 4294967295U;
    }
    {
#line 3024
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s sock %d, ring elt %p, bytes %d, source %p, srclen %d, flags %x, num_recv %p\n",
            "recv_data", data_socket, recv_ring, bytes_to_recv___0, source, tmp, flags,
            num_receives);
#line 3034
    fflush(where);
    }
  }
  {
#line 3036
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3037
    if (source) {
      {
#line 3045
      tmp___0 = recvfrom(data_socket, (void */* __restrict  */)temp_message_ptr, (size_t )bytes_left,
                         my_flags, (struct sockaddr */* __restrict  */)source, (socklen_t */* __restrict  */)sourcelen);
#line 3045
      bytes_recvd = (int )tmp___0;
      }
    } else {
      {
#line 3054
      tmp___1 = recv(data_socket, (void *)temp_message_ptr, (size_t )bytes_left, my_flags);
#line 3054
      bytes_recvd = (int )tmp___1;
      }
    }
#line 3059
    if (bytes_recvd > 0) {
#line 3060
      bytes_left -= bytes_recvd;
#line 3061
      temp_message_ptr += bytes_recvd;
    } else {
#line 3064
      goto while_break;
    }
#line 3066
    my_recvs ++;
#line 3036
    if (bytes_left > 0) {
#line 3036
      if (! (flags & 1U)) {
#line 3036
        goto while_break;
      }
    } else {
#line 3036
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3069
  *num_receives = (uint32_t )my_recvs;
#line 3072
  if (bytes_recvd < 0) {
    {
#line 3074
    tmp___2 = __errno_location();
    }
#line 3074
    if (*tmp___2 == 4) {
#line 3077
      return (-1);
    }
#line 3080
    return (-3);
  }
#line 3090
  if (bytes_left) {
#line 3091
    return (bytes_recvd);
  } else {
#line 3093
    return ((int )bytes_to_recv___0);
  }
}
}
#line 3098 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int close_data_socket(int data_socket , struct sockaddr *peer , int peerlen , int protocol___0 ) 
{ 
  int ret ;
  char buffer[4] ;
  int i ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 3105
  if (debug) {
    {
#line 3106
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s sock %d peer %p peerlen %d protocol %d\n",
            "close_data_socket", data_socket, peer, peerlen, protocol___0);
#line 3113
    fflush(where);
    }
  }
#line 3116
  if (protocol___0 == 17) {
#line 3121
    i = 0;
    {
#line 3121
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3121
      if (! (i < 3)) {
#line 3121
        goto while_break;
      }
#line 3122
      if (peer) {
        {
#line 3123
        tmp = sendto(data_socket, (void const   *)(buffer), (size_t )0, 0, (struct sockaddr  const  *)peer,
                     (socklen_t )peerlen);
#line 3123
        ret = (int )tmp;
        }
      } else {
        {
#line 3130
        tmp___0 = send(data_socket, (void const   *)(buffer), (size_t )0, 0);
#line 3130
        ret = (int )tmp___0;
        }
      }
      {
#line 3134
      tmp___1 = __errno_location();
      }
#line 3134
      if (*tmp___1 == 4) {
        {
#line 3135
        close(data_socket);
        }
#line 3136
        return (-1);
      }
#line 3121
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 3140
  ret = close(data_socket);
#line 3142
  tmp___2 = __errno_location();
  }
#line 3142
  if (*tmp___2 == 4) {
#line 3144
    return (-1);
  } else
#line 3146
  if (ret == 0) {
#line 3147
    return (ret);
  } else {
#line 3150
    return (-3);
  }
}
}
#line 3154 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
int disconnect_data_socket(int data_socket , int initiate , int do_close , struct sockaddr *peer ,
                           int peerlen ) 
{ 
  char buffer[4] ;
  int bytes_recvd ;
  ssize_t tmp ;
  int *tmp___0 ;
  int i ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;

  {
#line 3161
  if (debug) {
    {
#line 3162
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s sock %d init %d do_close %d protocol %d\n",
            "disconnect_data_socket", data_socket, initiate, do_close, protocol);
#line 3169
    fflush(where);
    }
  }
#line 3182
  if (protocol != 17) {
#line 3183
    if (initiate) {
      {
#line 3184
      shutdown(data_socket, 1);
      }
    }
    {
#line 3191
    tmp = recv(data_socket, (void *)(buffer), (size_t )1, 0);
#line 3191
    bytes_recvd = (int )tmp;
    }
#line 3196
    if (bytes_recvd != 0) {
      {
#line 3199
      tmp___0 = __errno_location();
      }
#line 3199
      if (*tmp___0 == 4) {
#line 3202
        return (-1);
      }
#line 3204
      return (-3);
    }
  } else {
#line 3209
    i = 0;
    {
#line 3209
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3209
      if (! (i < 3)) {
#line 3209
        goto while_break;
      }
#line 3210
      if (peer) {
        {
#line 3211
        tmp___1 = sendto(data_socket, (void const   *)(buffer), (size_t )0, 0, (struct sockaddr  const  *)peer,
                         (socklen_t )peerlen);
#line 3211
        bytes_recvd = (int )tmp___1;
        }
      } else {
        {
#line 3218
        tmp___2 = send(data_socket, (void const   *)(buffer), (size_t )0, 0);
#line 3218
        bytes_recvd = (int )tmp___2;
        }
      }
      {
#line 3223
      tmp___3 = __errno_location();
      }
#line 3223
      if (*tmp___3 == 4) {
#line 3224
        if (do_close) {
          {
#line 3225
          close(data_socket);
          }
        }
#line 3226
        return (-1);
      }
#line 3209
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3231
  if (do_close) {
    {
#line 3232
    close(data_socket);
    }
  }
#line 3234
  return (0);
}
}
#line 3238 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void dump_tcp_info(struct tcp_info *tcp_info ) 
{ 


  {
  {
#line 3242
  printf((char const   */* __restrict  */)"tcpi_rto %d tcpi_ato %d tcpi_pmtu %d tcpi_rcv_ssthresh %d\ntcpi_rtt %d tcpi_rttvar %d tcpi_snd_ssthresh %d tpci_snd_cwnd %d\ntcpi_reordering %d tcpi_total_retrans %d\n",
         tcp_info->tcpi_rto, tcp_info->tcpi_ato, tcp_info->tcpi_pmtu, tcp_info->tcpi_rcv_ssthresh,
         tcp_info->tcpi_rtt, tcp_info->tcpi_rttvar, tcp_info->tcpi_snd_ssthresh, tcp_info->tcpi_snd_cwnd,
         tcp_info->tcpi_reordering, tcp_info->tcpi_total_retrans);
  }
#line 3256
  return;
}
}
#line 3261 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int get_transport_retrans(int socket___0 , int protocol___0 ) 
{ 
  struct tcp_info tcp_info ;
  int ret ;
  unsigned int infosize ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
#line 3270
  if (protocol___0 != 6) {
#line 3271
    return (-1);
  }
  {
#line 3273
  infosize = (unsigned int )sizeof(struct tcp_info );
#line 3275
  ret = getsockopt(socket___0, protocol___0, 11, (void */* __restrict  */)(& tcp_info),
                   (socklen_t */* __restrict  */)(& infosize));
  }
#line 3275
  if (ret < 0) {
#line 3276
    if (debug) {
      {
#line 3277
      tmp = __errno_location();
#line 3277
      tmp___0 = strerror(*tmp);
#line 3277
      tmp___1 = __errno_location();
#line 3277
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: getsockopt errno %d %s\n",
              "get_transport_retrans", *tmp___1, tmp___0);
#line 3282
      fflush(where);
      }
    }
#line 3284
    return (-1);
  } else {
#line 3288
    if (debug > 1) {
      {
#line 3289
      dump_tcp_info(& tcp_info);
      }
    }
#line 3291
    return ((int )tcp_info.tcpi_total_retrans);
  }
}
}
#line 3301 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void get_transport_info(int socket___0 , int *mss , int protocol___0 ) 
{ 
  unsigned int sock_opt_len ;
  int option ;
  int *tmp ;
  int tmp___0 ;

  {
#line 3307
  sock_opt_len = (unsigned int )sizeof(unsigned int );
  {
#line 3311
  if (protocol___0 == 6) {
#line 3311
    goto case_6;
  }
#line 3321
  goto switch_default;
  case_6: /* CIL Label */ 
#line 3312
  option = 2;
#line 3313
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3322
  *mss = -1;
#line 3323
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 3326
  tmp___0 = getsockopt(socket___0, protocol___0, option, (void */* __restrict  */)((char *)mss),
                       (socklen_t */* __restrict  */)(& sock_opt_len));
  }
#line 3326
  if (tmp___0 == -1) {
    {
#line 3331
    tmp = __errno_location();
#line 3331
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: getsockopt: errno %d\n",
            "get_transport_info", *tmp);
#line 3335
    fflush(where);
#line 3336
    *mss = -1;
    }
  }
#line 3339
  return;
}
}
#line 3347 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void get_transport_cong_control(int socket___0 , int protocol___0 , char *cong_control ,
                                       int len ) 
{ 
  int my_len ;
  int *tmp ;
  int tmp___0 ;

  {
#line 3351
  my_len = len;
#line 3352
  if (protocol___0 != 6) {
    {
#line 3353
    strncpy((char */* __restrict  */)cong_control, (char const   */* __restrict  */)"TCP Only",
            (size_t )len);
    }
  } else {
    {
#line 3355
    tmp___0 = getsockopt(socket___0, protocol___0, 13, (void */* __restrict  */)cong_control,
                         (socklen_t */* __restrict  */)(& my_len));
    }
#line 3355
    if (tmp___0 == -1) {
      {
#line 3358
      tmp = __errno_location();
#line 3358
      snprintf((char */* __restrict  */)cong_control, (size_t )len, (char const   */* __restrict  */)"%d errno",
               *tmp);
      }
    }
  }
#line 3363
  *(cong_control + (len - 1)) = (char )'\000';
#line 3364
  return;
}
}
#line 3366 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void set_transport_cong_control(int socket___0 , int protocol___0 , char *cong_control ,
                                       int len ) 
{ 


  {
#line 3370
  if (protocol___0 == 6) {
    {
#line 3372
    setsockopt(socket___0, protocol___0, 13, (void const   *)cong_control, (socklen_t )len);
    }
  }
#line 3375
  return;
}
}
#line 3377 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int omni_create_data_socket(struct addrinfo *res ) 
{ 
  int temp_socket ;

  {
  {
#line 3382
  temp_socket = create_data_socket(res);
  }
#line 3384
  if (temp_socket != -1) {
#line 3385
    if ((int )local_cong_control_req[0] != 0) {
      {
#line 3386
      set_transport_cong_control(temp_socket, res->ai_protocol, local_cong_control_req,
                                 (int )sizeof(local_cong_control_req));
      }
    }
  }
#line 3392
  return (temp_socket);
}
}
#line 3399 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int choose_send_size(int lss , int protocol___0 ) 
{ 
  int send_size___0 ;

  {
#line 3404
  if (lss > 0) {
#line 3405
    send_size___0 = lss_size;
#line 3409
    if (protocol___0 == 17) {
#line 3409
      if (send_size___0 > 65507) {
#line 3410
        send_size___0 = 65507;
      }
    }
  } else {
#line 3414
    send_size___0 = 4096;
  }
#line 3416
  return (send_size___0);
}
}
#line 3424 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void print_uuid(char *remote_host ) 
{ 


  {
  {
#line 3427
  printf((char const   */* __restrict  */)"%s", test_uuid);
  }
#line 3428
  return;
}
}
#line 3440 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void enable_enobufs(int s ) 
{ 
  struct protoent *pr ;
  int on ;
  int tmp ;

  {
  {
#line 3444
  on = 1;
#line 3446
  pr = getprotobyname("ip");
  }
#line 3446
  if ((unsigned long )pr == (unsigned long )((void *)0)) {
    {
#line 3447
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s failed: getprotobyname\n",
            "enable_enobufs");
#line 3448
    fflush(where);
    }
#line 3449
    return;
  }
  {
#line 3451
  tmp = setsockopt(s, pr->p_proto, 11, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
  }
#line 3451
  if (tmp < 0) {
    {
#line 3452
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s failed: setsockopt\n",
            "enable_enobufs");
#line 3453
    fflush(where);
    }
#line 3454
    return;
  }
#line 3456
  return;
}
}
#line 3466 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void send_omni_inner(char *remote_host , unsigned int legacy_caller , char *header_str ) 
{ 
  int ret ;
  int rret ;
  int connected ;
  int timed_out ;
  int pad_time ;
  struct ring_elt *send_ring ;
  struct ring_elt *recv_ring ;
  struct sockaddr_storage remote_addr ;
  struct sockaddr_storage my_addr ;
  int remote_addr_len ;
  unsigned int my_addr_len ;
  int data_socket ;
  int need_socket ;
  uint32_t temp_recvs ;
  char tmpfmt ;
  struct addrinfo *local_res ;
  struct addrinfo *remote_res ;
  struct omni_request_struct *omni_request ;
  struct omni_response_struct *omni_response ;
  struct omni_results_struct *omni_result ;
  int requests_outstanding ;
  int requests_this_cwnd ;
  int request_cwnd_initial ;
  int request_cwnd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned short tmp___6 ;
  int *tmp___7 ;
  struct sockaddr *tmp___8 ;
  struct sockaddr *tmp___9 ;
  int tmp___10 ;
  struct sockaddr *tmp___11 ;
  int tmp___12 ;
  char tmp___13 ;
  int *tmp___14 ;
  char tmp___15 ;
  float rtt_elapsed_time ;
  int tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  int tmp___19 ;

  {
#line 3471
  connected = 0;
#line 3472
  timed_out = 0;
#line 3473
  pad_time = 0;
#line 3480
  remote_addr_len = (int )sizeof(remote_addr);
#line 3481
  my_addr_len = (unsigned int )sizeof(my_addr);
#line 3507
  requests_outstanding = 0;
#line 3508
  requests_this_cwnd = 0;
#line 3509
  request_cwnd_initial = 2;
#line 3510
  request_cwnd = 2;
#line 3525
  if (first_burst_size < 0) {
#line 3526
    first_burst_size *= -1;
#line 3527
    request_cwnd_initial = first_burst_size;
  } else {
#line 3530
    request_cwnd_initial = 2;
  }
#line 3535
  omni_request = (struct omni_request_struct *)(netperf_request.content.test_specific_data);
#line 3537
  omni_response = (struct omni_response_struct *)(netperf_response.content.test_specific_data);
#line 3539
  omni_result = (struct omni_results_struct *)(netperf_response.content.test_specific_data);
#line 3548
  if (! no_control) {
    {
#line 3549
    get_remote_system_info();
    }
  }
#line 3552
  if (keep_histogram) {
#line 3553
    if (first_burst_size > 0) {
      {
#line 3554
      time_hist = HIST_new_n(first_burst_size + 1);
      }
    } else {
      {
#line 3556
      time_hist = HIST_new_n(1);
      }
    }
  }
  {
#line 3564
  complete_addrinfos(& remote_res, & local_res, remote_host, socket_type, protocol,
                     0);
  }
#line 3571
  if (print_headers) {
    {
#line 3572
    print_top_test_header(header_str, local_res, remote_res);
    }
  }
#line 3577
  need_socket = 1;
#line 3579
  if (connection_test) {
    {
#line 3580
    pick_next_port_number(local_res, remote_res);
    }
  }
#line 3590
  if (local_cpu_usage) {
    {
#line 3591
    local_cpu_rate = calibrate_local_cpu(local_cpu_rate);
    }
  }
  {
#line 3594
  confidence_iteration = 1;
#line 3595
  init_stat();
#line 3597
  send_ring = (struct ring_elt *)((void *)0);
#line 3598
  recv_ring = (struct ring_elt *)((void *)0);
  }
  {
#line 3601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3601
    if (confidence < (double )0) {
#line 3601
      if (! (confidence_iteration <= iteration_max)) {
#line 3601
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 3601
    if (! (confidence_iteration <= iteration_min)) {
#line 3601
      goto while_break;
    }
#line 3604
    trans_completed = (uint64_t )0;
#line 3605
    bytes_xferd = 0.0;
#line 3606
    remote_bytes_xferd = 0.0;
#line 3607
    times_up = 0;
#line 3608
    bytes_sent = (uint64_t )0;
#line 3609
    bytes_received = (uint64_t )0;
#line 3610
    local_send_calls = (uint64_t )0;
#line 3611
    local_receive_calls = (uint64_t )0;
#line 3618
    if (keep_histogram) {
      {
#line 3619
      HIST_purge(time_hist);
      }
    }
#line 3626
    requests_outstanding = 0;
#line 3627
    requests_this_cwnd = 0;
#line 3628
    request_cwnd = request_cwnd_initial;
#line 3634
    if (local_mask_len) {
      {
#line 3635
      random_ip_address(local_res, local_mask_len);
      }
    }
#line 3636
    if (remote_mask_len) {
      {
#line 3637
      random_ip_address(remote_res, remote_mask_len);
      }
    }
    {
#line 3639
    data_socket = omni_create_data_socket(local_res);
    }
#line 3641
    if (data_socket == -1) {
      {
#line 3642
      perror("netperf: send_omni: unable to create data socket");
#line 3643
      exit(1);
      }
    }
    {
#line 3646
    enable_enobufs(data_socket);
#line 3648
    need_socket = 0;
    }
#line 3655
    if (direction & 2) {
      {
#line 3656
      tmp = is_multicast_addr(remote_res);
      }
#line 3656
      if (tmp) {
        {
#line 3657
        set_multicast_ttl(data_socket);
        }
      }
#line 3660
      if ((unsigned long )((void *)0) == (unsigned long )send_ring) {
#line 3661
        if (req_size > 0) {
#line 3663
          if (send_width == 0) {
#line 3663
            send_width = 1;
          }
#line 3664
          bytes_to_send = req_size;
        } else {
#line 3668
          if (send_size == 0) {
            {
#line 3669
            send_size = choose_send_size(lss_size, protocol);
            }
          }
#line 3671
          if (send_width == 0) {
#line 3672
            send_width = lss_size / send_size + 1;
          }
#line 3673
          if (send_width == 1) {
#line 3673
            send_width ++;
          }
#line 3674
          bytes_to_send = send_size;
        }
        {
#line 3677
        send_ring = allocate_buffer_ring(send_width, bytes_to_send, local_send_align,
                                         local_send_offset);
        }
#line 3681
        if (debug) {
          {
#line 3682
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: %d entry send_ring obtained...\n",
                  "send_omni_inner", send_width);
          }
        }
      }
    }
#line 3690
    if (direction & 4) {
      {
#line 3692
      tmp___0 = is_multicast_addr(local_res);
      }
#line 3692
      if (tmp___0) {
        {
#line 3693
        join_multicast_addr(data_socket, local_res);
        }
      }
#line 3697
      if ((unsigned long )((void *)0) == (unsigned long )recv_ring) {
#line 3698
        if (rsp_size > 0) {
#line 3699
          if (recv_width == 0) {
#line 3699
            recv_width = 1;
          }
#line 3700
          bytes_to_recv = rsp_size;
        } else {
#line 3704
          if (recv_size == 0) {
#line 3705
            if (lsr_size > 0) {
#line 3706
              recv_size = lsr_size;
            } else {
#line 3709
              recv_size = 4096;
            }
          }
#line 3712
          if (recv_width == 0) {
#line 3713
            recv_width = lsr_size / recv_size + 1;
#line 3714
            if (recv_width == 1) {
#line 3714
              recv_width ++;
            }
          }
#line 3716
          bytes_to_recv = recv_size;
        }
        {
#line 3719
        recv_ring = allocate_buffer_ring(recv_width, bytes_to_recv, local_recv_align,
                                         local_recv_offset);
        }
#line 3723
        if (debug) {
          {
#line 3724
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: %d entry recv_ring obtained...\n",
                  "send_omni_inner", recv_width);
          }
        }
      }
    }
#line 3732
    if (! no_control) {
#line 3744
      netperf_request.content.request_type = 97;
#line 3745
      omni_request->flags = (uint32_t )0;
#line 3746
      omni_request->send_buf_size = rss_size_req;
#line 3747
      omni_request->send_size = (uint32_t )remote_send_size_req;
#line 3748
      omni_request->send_alignment = (uint32_t )remote_send_align;
#line 3749
      omni_request->send_offset = (uint32_t )remote_send_offset;
#line 3750
      omni_request->send_width = (uint32_t )send_width;
#line 3751
      omni_request->request_size = req_size;
#line 3753
      omni_request->recv_buf_size = rsr_size_req;
#line 3754
      omni_request->receive_size = (uint32_t )remote_recv_size_req;
#line 3755
      omni_request->recv_alignment = (uint32_t )remote_recv_align;
#line 3756
      omni_request->recv_offset = (uint32_t )remote_recv_offset;
#line 3757
      omni_request->recv_width = (uint32_t )recv_width;
#line 3758
      omni_request->response_size = rsp_size;
#line 3759
      omni_request->socket_prio = remote_socket_prio;
#line 3760
      omni_request->socket_tos = remote_socket_tos;
#line 3764
      if (rem_nodelay) {
#line 3765
        omni_request->flags |= 1U;
      }
#line 3767
      if (remote_use_sendfile) {
#line 3768
        omni_request->flags |= 2U;
      }
#line 3770
      if (connection_test) {
#line 3771
        omni_request->flags |= 4U;
      }
#line 3773
      if (remote_checksum_off) {
#line 3774
        omni_request->flags |= 16U;
      }
#line 3776
      if (remote_cpu_usage) {
#line 3777
        omni_request->flags |= 8U;
      }
#line 3779
      if (routing_allowed) {
#line 3780
        omni_request->flags |= 32U;
      }
#line 3782
      if (desired_output_groups & 1U) {
#line 3783
        omni_request->flags |= 64U;
      }
#line 3785
      if (desired_output_groups & 2U) {
#line 3786
        omni_request->flags |= 128U;
      }
#line 3788
      if (desired_output_groups & 4U) {
#line 3789
        omni_request->flags |= 256U;
      }
#line 3791
      if (desired_output_groups & 8U) {
#line 3792
        omni_request->flags |= 512U;
      }
#line 3794
      if (desired_output_groups & 32U) {
#line 3795
        omni_request->flags |= 32U;
      }
      {
#line 3799
      strncpy((char */* __restrict  */)(omni_request->cong_control), (char const   */* __restrict  */)(remote_cong_control_req),
              sizeof(omni_request->cong_control));
#line 3802
      omni_request->cong_control[sizeof(omni_request->cong_control) - 1UL] = (char )'\000';
      }
#line 3805
      if (want_keepalive) {
#line 3806
        omni_request->flags |= 2147483648U;
      }
#line 3808
      omni_request->cpu_rate = remote_cpu_rate;
#line 3809
      if (test_time) {
#line 3810
        omni_request->test_length = test_time;
      } else {
#line 3812
        omni_request->test_length = test_trans * -1;
      }
      {
#line 3813
      omni_request->so_rcvavoid = (uint32_t )rem_rcvavoid;
#line 3814
      omni_request->so_sndavoid = (uint32_t )rem_sndavoid;
#line 3815
      omni_request->send_dirty_count = (uint32_t )rem_dirty_count;
#line 3816
      omni_request->recv_dirty_count = (uint32_t )rem_dirty_count;
#line 3817
      omni_request->recv_clean_count = (uint32_t )rem_clean_count;
#line 3819
      tmp___1 = atoi((char const   *)(remote_data_port));
#line 3819
      omni_request->data_port = (uint32_t )tmp___1;
#line 3820
      tmp___2 = af_to_nf(remote_res->ai_family);
#line 3820
      omni_request->ipfamily = (uint32_t )tmp___2;
#line 3821
      tmp___3 = hst_to_nst(socket_type);
#line 3821
      omni_request->socket_type = (uint32_t )tmp___3;
#line 3822
      omni_request->protocol = (uint32_t )protocol;
#line 3824
      omni_request->interval_burst = (uint32_t )remote_interval_burst;
#line 3825
      omni_request->interval_usecs = (uint32_t )remote_interval_usecs;
#line 3827
      omni_request->direction = (uint32_t )0;
      }
#line 3830
      if (direction & 2) {
#line 3831
        omni_request->direction |= 4U;
      }
#line 3832
      if (direction & 4) {
#line 3833
        omni_request->direction |= 2U;
      }
      {
#line 3838
      getsockname(data_socket, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& my_addr)),
                  (socklen_t */* __restrict  */)(& my_addr_len));
#line 3840
      tmp___4 = nf_to_af((int )omni_request->ipfamily);
#line 3840
      ret = get_sockaddr_family_addr_port(& my_addr, tmp___4, (void *)(omni_request->netperf_ip),
                                          (int *)(& omni_request->netperf_port));
#line 3844
      tmp___5 = nf_to_af((int )omni_request->ipfamily);
#line 3844
      ret = get_sockaddr_family_addr_port((struct sockaddr_storage *)remote_res->ai_addr,
                                          tmp___5, (void *)(omni_request->netserver_ip),
                                          (int *)(& omni_request->data_port));
      }
#line 3852
      if (! explicit_data_address) {
#line 3853
        omni_request->netserver_ip[0] = (uint32_t )0;
#line 3854
        omni_request->netserver_ip[1] = (uint32_t )0;
#line 3855
        omni_request->netserver_ip[2] = (uint32_t )0;
#line 3856
        omni_request->netserver_ip[3] = (uint32_t )0;
      }
#line 3858
      if (debug > 1) {
        {
#line 3859
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: %s: requesting OMNI test\n",
                "send_omni_inner");
        }
      }
      {
#line 3862
      strncpy((char */* __restrict  */)(omni_request->fill_file), (char const   */* __restrict  */)(remote_fill_file),
              sizeof(omni_request->fill_file));
#line 3866
      send_request_n(38);
#line 3874
      recv_response_n(18);
      }
#line 3876
      if (! netperf_response.content.serv_errno) {
        {
#line 3877
        rsr_size = omni_response->recv_buf_size;
#line 3878
        remote_recv_size = (int )omni_response->receive_size;
#line 3879
        rss_size = omni_response->send_buf_size;
#line 3880
        remote_send_size = (int )omni_response->send_size;
#line 3881
        rem_nodelay = (int )(omni_response->flags & 1U);
#line 3882
        remote_use_sendfile = (int )(omni_response->flags & 2U);
#line 3883
        remote_cpu_usage = (int )(omni_response->flags & 8U);
#line 3884
        remote_cpu_rate = omni_response->cpu_rate;
#line 3885
        remote_send_width = omni_response->send_width;
#line 3886
        remote_recv_width = omni_response->recv_width;
#line 3887
        remote_socket_prio = omni_response->socket_prio;
#line 3888
        remote_socket_tos = omni_response->socket_tos;
#line 3892
        set_port_number(remote_res, (unsigned short )omni_response->data_port);
        }
#line 3895
        if (debug) {
          {
#line 3896
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"remote listen done.\n");
#line 3897
          tmp___6 = get_port_number(remote_res);
#line 3897
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"remote port is %u\n",
                  (int )tmp___6);
#line 3898
          fflush(where);
          }
        }
#line 3901
        if ((unsigned long )((void *)0) == (unsigned long )remote_system_model) {
          {
#line 3902
          omni_response->system_model[sizeof(omni_response->system_model) - 1UL] = (char)0;
#line 3904
          remote_system_model = strdup((char const   *)(omni_response->system_model));
          }
        }
#line 3906
        if ((unsigned long )((void *)0) == (unsigned long )remote_cpu_model) {
          {
#line 3907
          omni_response->cpu_model[sizeof(omni_response->cpu_model) - 1UL] = (char)0;
#line 3908
          remote_cpu_model = strdup((char const   *)(omni_response->cpu_model));
          }
        }
#line 3910
        remote_cpu_frequency = (int )omni_response->cpu_frequency;
#line 3912
        if ((unsigned long )((void *)0) == (unsigned long )remote_security_specific) {
          {
#line 3913
          omni_response->security_string[sizeof(omni_response->security_string) - 1UL] = (char)0;
#line 3914
          remote_security_specific = strdup((char const   *)(omni_response->security_string));
          }
        }
        {
#line 3917
        remote_security_type_id = (int )omni_response->security_info >> 16;
#line 3918
        remote_security_enabled_num = (int )((short )omni_response->security_info);
#line 3919
        remote_security_type = nsec_type_to_str(remote_security_type_id);
#line 3920
        remote_security_enabled = nsec_enabled_to_str(remote_security_enabled_num);
        }
      } else {
        {
#line 3924
        tmp___7 = __errno_location();
#line 3924
        *tmp___7 = netperf_response.content.serv_errno;
#line 3925
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: remote error %d",
                netperf_response.content.serv_errno);
#line 3928
        perror("");
#line 3929
        fflush(where);
#line 3930
        exit(-1);
        }
      }
    } else {
#line 3937
      if ((unsigned long )((void *)0) == (unsigned long )remote_system_model) {
        {
#line 3938
        remote_system_model = strdup("Unknown System Model");
        }
      }
#line 3939
      if ((unsigned long )((void *)0) == (unsigned long )remote_cpu_model) {
        {
#line 3940
        remote_cpu_model = strdup("Unknown CPU Model");
        }
      }
#line 3941
      remote_cpu_frequency = -1;
    }
#line 3954
    need_to_connect = protocol != 17;
#line 3959
    if (wait_time_secs) {
      {
#line 3959
      sleep((unsigned int )wait_time_secs);
      }
    }
#line 3971
    if (test_time) {
#line 3971
      goto _L___0;
    } else
#line 3971
    if (test_trans == 0) {
#line 3971
      if (test_bytes == 0) {
        _L___0: /* CIL Label */ 
#line 3978
        times_up = 0;
#line 3979
        units_remaining = (int64_t )0;
#line 3980
        if (! no_control) {
#line 3980
          if (direction & 4) {
#line 3980
            if (! (direction & 2)) {
#line 3980
              if (test_trans == 0) {
#line 3980
                if (test_bytes == 0) {
#line 3983
                  pad_time = 0;
                }
              }
            }
          }
        }
        {
#line 3984
        start_timer(test_time + pad_time);
        }
      } else {
#line 3971
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 3989
      if (direction & 2) {
#line 3989
        if (direction & 4) {
#line 3990
          units_remaining = (int64_t )test_trans;
        } else {
#line 3989
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 3989
      if (direction & 2) {
#line 3992
        units_remaining = (int64_t )test_bytes;
      } else
#line 3989
      if (direction & 4) {
#line 3992
        units_remaining = (int64_t )test_bytes;
      } else {
#line 3990
        units_remaining = (int64_t )test_trans;
      }
#line 3993
      times_up = 1;
    }
    {
#line 3998
    cpu_start(local_cpu_usage);
    }
    {
#line 4018
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4018
      if (! (! times_up)) {
#line 4018
        if (! (units_remaining > 0L)) {
#line 4018
          goto while_break___0;
        }
      }
#line 4025
      if (keep_histogram) {
        {
#line 4026
        HIST_timestamp_start(time_hist);
        }
      }
      again: 
#line 4032
      if (need_socket) {
#line 4033
        if (connection_test) {
          {
#line 4035
          pick_next_port_number(local_res, remote_res);
          }
        }
        {
#line 4037
        data_socket = omni_create_data_socket(local_res);
        }
#line 4039
        if (data_socket == -1) {
          {
#line 4040
          perror("netperf: send_omni: unable to create data socket");
#line 4041
          exit(1);
          }
        }
        {
#line 4043
        need_socket = 0;
#line 4045
        enable_enobufs(data_socket);
        }
      }
#line 4050
      if (need_to_connect) {
        {
#line 4053
        ret = connect_data_socket(data_socket, remote_res);
        }
#line 4054
        if (ret == 0) {
#line 4055
          connected = 1;
#line 4056
          need_to_connect = 0;
        } else
#line 4058
        if (ret == -1) {
#line 4059
          times_up = 1;
#line 4060
          timed_out = 1;
#line 4061
          goto while_break___0;
        } else
#line 4063
        if (ret == -2) {
#line 4063
          if (connection_test) {
#line 4066
            if (debug) {
              {
#line 4067
              fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"transient! transient! torpedo in the water!\n");
#line 4068
              fflush(where);
              }
            }
            {
#line 4070
            close(data_socket);
#line 4071
            connected = 0;
#line 4072
            need_socket = 1;
#line 4073
            need_to_connect = 1;
#line 4078
            pick_next_port_number(local_res, remote_res);
            }
#line 4081
            goto again;
          } else {
            {
#line 4086
            perror("netperf: send_omni: connect_data_socket failed");
#line 4087
            exit(1);
            }
          }
        } else {
          {
#line 4086
          perror("netperf: send_omni: connect_data_socket failed");
#line 4087
          exit(1);
          }
        }
      }
      {
#line 4105
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4105
        if (first_burst_size > 0) {
#line 4105
          if (requests_outstanding < request_cwnd) {
#line 4105
            if (requests_outstanding < first_burst_size) {
#line 4105
              if (direction & 2) {
#line 4105
                if (direction & 4) {
#line 4105
                  goto _L___2;
                } else {
#line 4105
                  goto _L___3;
                }
              } else
              _L___3: /* CIL Label */ 
#line 4105
              if (direction & 2) {
#line 4105
                goto while_break___1;
              } else
#line 4105
              if (direction & 4) {
#line 4105
                goto while_break___1;
              } else
              _L___2: /* CIL Label */ 
#line 4105
              if (! (! connection_test)) {
#line 4105
                goto while_break___1;
              }
            } else {
#line 4105
              goto while_break___1;
            }
          } else {
#line 4105
            goto while_break___1;
          }
        } else {
#line 4105
          goto while_break___1;
        }
#line 4110
        if (debug > 1) {
          {
#line 4111
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"injecting, req_outstanding %d req_cwnd %d burst %d\n",
                  requests_outstanding, request_cwnd, first_burst_size);
          }
        }
#line 4118
        if (connected) {
#line 4118
          tmp___8 = (struct sockaddr *)((void *)0);
        } else {
#line 4118
          tmp___8 = remote_res->ai_addr;
        }
        {
#line 4118
        ret = send_data(data_socket, send_ring, (uint32_t )bytes_to_send, tmp___8,
                        (int )remote_res->ai_addrlen);
        }
#line 4118
        if (ret != bytes_to_send) {
          {
#line 4125
          perror("send_omni: initial burst data send error");
#line 4126
          exit(-1);
          }
        }
#line 4128
        local_send_calls ++;
#line 4129
        requests_outstanding ++;
#line 4138
        if (keep_histogram) {
          {
#line 4139
          HIST_timestamp_start(time_hist);
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 4147
      if (direction & 2) {
#line 4149
        if (connected) {
#line 4149
          tmp___9 = (struct sockaddr *)((void *)0);
        } else {
#line 4149
          tmp___9 = remote_res->ai_addr;
        }
        {
#line 4149
        ret = send_data(data_socket, send_ring, (uint32_t )bytes_to_send, tmp___9,
                        (int )remote_res->ai_addrlen);
        }
#line 4158
        if (ret == bytes_to_send) {
#line 4161
          if (! (direction & 4)) {
#line 4161
            if (units_remaining > 0L) {
#line 4162
              units_remaining -= (int64_t )ret;
            }
          }
#line 4164
          bytes_sent += (uint64_t )ret;
#line 4165
          send_ring = send_ring->next;
#line 4166
          local_send_calls ++;
        } else
#line 4168
        if (ret == -2) {
#line 4179
          failed_sends ++;
        } else
#line 4181
        if (ret == 0) {
          {
#line 4185
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"HOW DID I GET HERE?\n");
#line 4186
          fflush(where);
          }
        } else
#line 4188
        if (ret == -1) {
#line 4189
          times_up = 1;
#line 4190
          timed_out = 1;
#line 4191
          goto while_break___0;
        } else {
          {
#line 4194
          perror("netperf: send_omni: send_data failed");
#line 4195
          exit(1);
          }
        }
      }
#line 4205
      requests_outstanding ++;
#line 4218
      if (direction & 4) {
#line 4219
        if (direction & 2) {
#line 4219
          tmp___10 = 1;
        } else {
#line 4219
          tmp___10 = 0;
        }
#line 4219
        if (connected) {
#line 4219
          tmp___11 = (struct sockaddr *)((void *)0);
        } else {
#line 4219
          tmp___11 = (struct sockaddr *)(& remote_addr);
        }
        {
#line 4219
        rret = recv_data(data_socket, recv_ring, (uint32_t )bytes_to_recv, tmp___11,
                         (unsigned int *)(& remote_addr_len), (uint32_t )tmp___10,
                         & temp_recvs);
        }
#line 4228
        if (rret > 0) {
#line 4231
          if (! (direction & 2)) {
#line 4231
            if (units_remaining > 0L) {
#line 4232
              units_remaining -= (int64_t )rret;
            }
          }
#line 4234
          bytes_received += (uint64_t )rret;
#line 4235
          local_receive_calls += (uint64_t )temp_recvs;
        } else
#line 4237
        if (rret == 0) {
#line 4242
          if (! connection_test) {
#line 4242
            if (! null_message_ok) {
#line 4245
              times_up = 1;
#line 4246
              goto while_break___0;
            }
          }
#line 4248
          local_receive_calls += (uint64_t )temp_recvs;
        } else
#line 4250
        if (rret == -1) {
#line 4252
          times_up = 1;
#line 4253
          timed_out = 1;
#line 4254
          goto while_break___0;
        } else {
          {
#line 4258
          perror("netperf: send_omni: recv_data failed");
#line 4259
          exit(1);
          }
        }
#line 4261
        recv_ring = recv_ring->next;
#line 4268
        requests_outstanding --;
#line 4269
        if (request_cwnd < first_burst_size) {
#line 4269
          if (direction & 2) {
#line 4269
            if (direction & 4) {
#line 4269
              goto _L___4;
            } else {
#line 4269
              goto _L___5;
            }
          } else
          _L___5: /* CIL Label */ 
#line 4269
          if (! (direction & 2)) {
#line 4269
            if (! (direction & 4)) {
              _L___4: /* CIL Label */ 
#line 4269
              requests_this_cwnd ++;
#line 4269
              if (requests_this_cwnd == request_cwnd) {
#line 4272
                request_cwnd ++;
#line 4273
                requests_this_cwnd = 0;
#line 4274
                if (debug > 1) {
                  {
#line 4275
                  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"incr req_cwnd to %d first_burst %d reqs_outstanding %d trans %lu\n",
                          request_cwnd, first_burst_size, requests_outstanding, trans_completed + 1UL);
                  }
                }
              }
            }
          }
        }
      }
#line 4289
      if (connection_test) {
#line 4301
        if (lsr_size_req < 0) {
#line 4301
          if (-1 == lsr_size_end) {
            {
#line 4302
            get_sock_buffer(data_socket, (enum sock_buffer )1, & lsr_size_end);
            }
          } else {
#line 4304
            lsr_size_end = lsr_size;
          }
        } else {
#line 4304
          lsr_size_end = lsr_size;
        }
#line 4305
        if (lss_size_req < 0) {
#line 4305
          if (-1 == lss_size_end) {
            {
#line 4306
            get_sock_buffer(data_socket, (enum sock_buffer )0, & lss_size_end);
            }
          } else {
#line 4308
            lss_size_end = lss_size;
          }
        } else {
#line 4308
          lss_size_end = lss_size;
        }
#line 4318
        if (transport_mss == -2) {
          {
#line 4319
          get_transport_info(data_socket, & transport_mss, local_res->ai_protocol);
          }
        }
#line 4324
        if (no_control) {
#line 4324
          tmp___12 = 1;
        } else {
#line 4324
          tmp___12 = 0;
        }
        {
#line 4324
        ret = disconnect_data_socket(data_socket, tmp___12, 1, (struct sockaddr *)((void *)0),
                                     0);
        }
#line 4329
        if (ret == 0) {
          {
#line 4332
          need_to_connect = 1;
#line 4333
          connected = 0;
#line 4334
          need_socket = 1;
#line 4335
          pick_next_port_number(local_res, remote_res);
          }
        } else
#line 4337
        if (ret == -1) {
#line 4338
          times_up = 1;
#line 4339
          timed_out = 1;
#line 4340
          goto while_break___0;
        } else {
          {
#line 4343
          perror("netperf: send_omni: disconnect_data_socket failed");
#line 4344
          exit(1);
          }
        }
      }
#line 4349
      if (keep_histogram) {
        {
#line 4350
        HIST_timestamp_stop_add(time_hist);
        }
      }
#line 4376
      if (direction & 2) {
#line 4376
        if (direction & 4) {
#line 4376
          goto _L___6;
        } else {
#line 4376
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 4376
      if (! (direction & 2)) {
#line 4376
        if (! (direction & 4)) {
          _L___6: /* CIL Label */ 
#line 4377
          trans_completed ++;
#line 4378
          if (units_remaining) {
#line 4379
            units_remaining --;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4394
    if (transport_mss == -2) {
      {
#line 4395
      get_transport_info(data_socket, & transport_mss, local_res->ai_protocol);
      }
    }
    {
#line 4398
    local_transport_retrans = get_transport_retrans(data_socket, local_res->ai_protocol);
#line 4402
    find_security_info(& local_security_enabled_num, & local_security_type_id, & local_security_specific);
#line 4405
    local_security_enabled = nsec_enabled_to_str(local_security_enabled_num);
#line 4406
    local_security_type = nsec_type_to_str(local_security_type_id);
    }
#line 4412
    if (connected) {
#line 4420
      if (lsr_size_req < 0) {
        {
#line 4421
        get_sock_buffer(data_socket, (enum sock_buffer )1, & lsr_size_end);
        }
      } else {
#line 4423
        lsr_size_end = lsr_size;
      }
#line 4424
      if (lss_size_req < 0) {
        {
#line 4425
        get_sock_buffer(data_socket, (enum sock_buffer )0, & lss_size_end);
        }
      } else {
#line 4427
        lss_size_end = lss_size;
      }
#line 4432
      if (desired_output_groups & 2097152U) {
#line 4432
        if ((int )local_cong_control[0] == 0) {
          {
#line 4434
          get_transport_cong_control(data_socket, local_res->ai_protocol, local_cong_control,
                                     (int )sizeof(local_cong_control));
          }
        }
      }
      {
#line 4441
      ret = disconnect_data_socket(data_socket, 1, 1, (struct sockaddr *)((void *)0),
                                   0);
#line 4446
      connected = 0;
#line 4447
      need_socket = 1;
      }
    } else {
      {
#line 4452
      ret = disconnect_data_socket(data_socket, 1, 1, remote_res->ai_addr, (int )remote_res->ai_addrlen);
#line 4457
      need_socket = 1;
#line 4458
      lsr_size_end = lsr_size;
#line 4459
      lss_size_end = lss_size;
      }
    }
    {
#line 4465
    cpu_stop(local_cpu_usage, & elapsed_time);
    }
#line 4469
    if (! legacy) {
      {
#line 4474
      find_system_info(& local_system_model, & local_cpu_model, & local_cpu_frequency);
      }
#line 4478
      if (desired_output_groups & 65536U) {
        {
#line 4482
        local_interface_name = find_egress_interface(local_res->ai_addr, remote_res->ai_addr);
        }
      } else
#line 4478
      if (desired_output_groups & 524288U) {
        {
#line 4482
        local_interface_name = find_egress_interface(local_res->ai_addr, remote_res->ai_addr);
        }
      } else
#line 4478
      if (desired_output_groups & 131072U) {
        {
#line 4482
        local_interface_name = find_egress_interface(local_res->ai_addr, remote_res->ai_addr);
        }
      } else
#line 4478
      if (desired_output_groups & 262144U) {
        {
#line 4482
        local_interface_name = find_egress_interface(local_res->ai_addr, remote_res->ai_addr);
        }
      } else {
        {
#line 4486
        local_interface_name = strdup("Bug If Seen IFNAME");
        }
      }
#line 4489
      if (desired_output_groups & 524288U) {
        {
#line 4490
        find_driver_info(local_interface_name, local_driver_name, local_driver_version,
                         local_driver_firmware, local_driver_bus, 32);
        }
      } else {
        {
#line 4495
        strncpy((char */* __restrict  */)(local_driver_name), (char const   */* __restrict  */)"Bug If Seen DRVINFO",
                (size_t )32);
#line 4496
        strncpy((char */* __restrict  */)(local_driver_version), (char const   */* __restrict  */)"Bug If Seen DRVINFO",
                (size_t )32);
#line 4497
        strncpy((char */* __restrict  */)(local_driver_firmware), (char const   */* __restrict  */)"Bug If Seen DRVINFO",
                (size_t )32);
#line 4498
        strncpy((char */* __restrict  */)(local_driver_bus), (char const   */* __restrict  */)"Bug If Seen DRVINFO",
                (size_t )32);
        }
      }
#line 4501
      if (desired_output_groups & 131072U) {
        {
#line 4502
        local_interface_slot = find_interface_slot(local_interface_name);
        }
      } else {
        {
#line 4505
        local_interface_slot = strdup("Bug If Seen IFSLOT");
        }
      }
#line 4508
      if (desired_output_groups & 262144U) {
        {
#line 4509
        find_interface_ids(local_interface_name, & local_interface_vendor, & local_interface_device,
                           & local_interface_subvendor, & local_interface_subdevice);
        }
      } else {
#line 4516
        local_interface_vendor = -2;
#line 4517
        local_interface_device = -2;
#line 4518
        local_interface_subvendor = -2;
#line 4519
        local_interface_subdevice = -2;
      }
    }
#line 4529
    if (timed_out) {
#line 4530
      if (debug) {
        {
#line 4531
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Adjusting elapsed_time by %d seconds\n",
                pad_time);
#line 4532
        fflush(where);
        }
      }
#line 4534
      elapsed_time -= (float )pad_time;
    } else {
      {
#line 4537
      stop_timer();
      }
    }
#line 4540
    if (! no_control) {
      {
#line 4545
      recv_response_n(22);
      }
#line 4546
      if (! netperf_response.content.serv_errno) {
#line 4547
        if (debug) {
          {
#line 4548
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"remote results obtained\n");
          }
        }
        {
#line 4549
        tmp___13 = format_cpu_method((int )omni_result->cpu_method);
#line 4549
        remote_cpu_method = (int )tmp___13;
#line 4550
        lib_num_rem_cpus = (int )omni_result->num_cpus;
#line 4551
        lib_remote_peak_cpu_util = (double )omni_result->peak_cpu_util;
#line 4552
        lib_remote_peak_cpu_id = omni_result->peak_cpu_id;
#line 4558
        rsr_size_end = omni_result->recv_buf_size;
#line 4559
        rss_size_end = omni_result->send_buf_size;
#line 4560
        remote_bytes_sent = (uint64_t )omni_result->bytes_sent_hi << 32;
#line 4561
        remote_bytes_sent += (uint64_t )omni_result->bytes_sent_lo;
#line 4562
        remote_send_calls = (uint64_t )omni_result->send_calls;
#line 4563
        remote_bytes_received = (uint64_t )omni_result->bytes_received_hi << 32;
#line 4564
        remote_bytes_received += (uint64_t )omni_result->bytes_received_lo;
#line 4565
        remote_receive_calls = (uint64_t )omni_result->recv_calls;
#line 4566
        remote_bytes_xferd = (double )remote_bytes_received + (double )remote_bytes_sent;
        }
#line 4568
        if (omni_result->recv_calls > 0U) {
#line 4569
          remote_bytes_per_recv = (double )remote_bytes_received / (double )omni_result->recv_calls;
        } else {
#line 4572
          remote_bytes_per_recv = 0.0;
        }
#line 4573
        if (omni_result->send_calls > 0U) {
#line 4574
          remote_bytes_per_send = (double )remote_bytes_sent / (double )omni_result->send_calls;
        } else {
#line 4577
          remote_bytes_per_send = 0.0;
        }
        {
#line 4578
        omni_result->ifname[15] = (char)0;
#line 4579
        remote_interface_name = strdup((char const   *)(omni_result->ifname));
#line 4580
        remote_interface_slot = strdup((char const   *)(omni_result->ifslot));
#line 4581
        strncpy((char */* __restrict  */)(remote_driver_name), (char const   */* __restrict  */)(omni_result->driver),
                (size_t )32);
#line 4582
        strncpy((char */* __restrict  */)(remote_driver_version), (char const   */* __restrict  */)(omni_result->version),
                (size_t )32);
#line 4583
        strncpy((char */* __restrict  */)(remote_driver_firmware), (char const   */* __restrict  */)(omni_result->firmware),
                (size_t )32);
#line 4584
        strncpy((char */* __restrict  */)(remote_driver_bus), (char const   */* __restrict  */)(omni_result->bus),
                (size_t )32);
#line 4585
        remote_driver_name[31] = (char)0;
#line 4586
        remote_driver_version[31] = (char)0;
#line 4587
        remote_driver_firmware[31] = (char)0;
#line 4588
        remote_driver_bus[31] = (char)0;
#line 4589
        remote_interface_vendor = omni_result->vendor;
#line 4590
        remote_interface_device = omni_result->device;
#line 4591
        remote_interface_subvendor = omni_result->subvendor;
#line 4592
        remote_interface_subdevice = omni_result->subdevice;
#line 4593
        remote_transport_retrans = omni_result->transport_retrans;
        }
#line 4595
        if (desired_output_groups & 32U) {
          {
#line 4596
          strncpy((char */* __restrict  */)(remote_cong_control), (char const   */* __restrict  */)(omni_result->cong_control),
                  sizeof(remote_cong_control));
#line 4599
          remote_cong_control[sizeof(remote_cong_control) - 1UL] = (char )'\000';
          }
        }
      } else {
        {
#line 4603
        tmp___14 = __errno_location();
#line 4603
        *tmp___14 = netperf_response.content.serv_errno;
#line 4604
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: remote error %d",
                netperf_response.content.serv_errno);
#line 4607
        perror("");
#line 4608
        fflush(where);
#line 4610
        exit(-1);
        }
      }
    } else {
#line 4617
      remote_bytes_xferd = (double )bytes_sent;
    }
    {
#line 4621
    tmp___15 = format_cpu_method(cpu_method);
#line 4621
    local_cpu_method = (int )tmp___15;
    }
#line 4623
    if (local_send_calls > 0UL) {
#line 4624
      bytes_per_send = (double )bytes_sent / (double )local_send_calls;
    } else {
#line 4625
      bytes_per_send = 0.0;
    }
#line 4627
    if (local_receive_calls > 0UL) {
#line 4628
      bytes_per_recv = (double )bytes_received / (double )local_receive_calls;
    } else {
#line 4630
      bytes_per_recv = 0.0;
    }
#line 4632
    bytes_xferd = (double )bytes_sent + (double )bytes_received;
#line 4641
    if (120 == (int )libfmt) {
      {
#line 4643
      thruput = calc_thruput((double )trans_completed);
      }
    } else
#line 4644
    if (direction & 4) {
#line 4644
      if (! (direction & 2)) {
        {
#line 4645
        thruput = calc_thruput(bytes_xferd);
        }
      } else {
        {
#line 4647
        thruput = calc_thruput(remote_bytes_xferd);
        }
      }
    } else {
      {
#line 4647
      thruput = calc_thruput(remote_bytes_xferd);
      }
    }
#line 4649
    if (direction & 2) {
#line 4649
      if (direction & 4) {
#line 4649
        goto _L___8;
      } else {
#line 4649
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 4649
    if (! (direction & 2)) {
#line 4649
      if (! (direction & 4)) {
        _L___8: /* CIL Label */ 
#line 4650
        rtt_elapsed_time = elapsed_time;
#line 4665
        if (! connection_test) {
#line 4670
          if (first_burst_size > 0) {
#line 4670
            tmp___16 = first_burst_size;
          } else {
#line 4670
            tmp___16 = 0;
          }
#line 4670
          rtt_latency = ((1.0 / (double )((float )trans_completed / rtt_elapsed_time)) * 1000000.0) * (double )(1 + tmp___16);
        } else {
#line 4676
          rtt_latency = (1.0 / (double )((float )trans_completed / rtt_elapsed_time)) * 1000000.0;
        }
        {
#line 4679
        tmpfmt = libfmt;
#line 4680
        libfmt = (char )'x';
#line 4681
        transaction_rate = calc_thruput((double )trans_completed);
#line 4682
        libfmt = tmpfmt;
        }
      }
    }
#line 4686
    if (local_cpu_usage) {
      {
#line 4688
      local_cpu_utilization = calc_cpu_util(elapsed_time);
      }
#line 4695
      if (120 == (int )libfmt) {
#line 4695
        tmp___17 = (double )trans_completed;
      } else {
#line 4695
        tmp___17 = bytes_xferd;
      }
      {
#line 4695
      local_service_demand = calc_service_demand_fmt(tmp___17, (float )0.0, (float )0.0,
                                                     0);
      }
    } else {
#line 4702
      local_cpu_utilization = (float )(- 1.0);
#line 4703
      local_service_demand = (float )(- 1.0);
    }
#line 4706
    if (remote_cpu_usage) {
#line 4708
      remote_cpu_utilization = omni_result->cpu_util;
#line 4710
      if (120 == (int )libfmt) {
#line 4710
        tmp___18 = (double )trans_completed;
      } else {
#line 4710
        tmp___18 = bytes_xferd;
      }
      {
#line 4710
      remote_service_demand = calc_service_demand_fmt(tmp___18, (float )0.0, remote_cpu_utilization,
                                                      (int )omni_result->num_cpus);
      }
    } else {
#line 4717
      remote_cpu_utilization = (float )(- 1.0);
#line 4718
      remote_service_demand = (float )(- 1.0);
    }
    {
#line 4722
    calculate_confidence(confidence_iteration, elapsed_time, thruput, local_cpu_utilization,
                         remote_cpu_utilization, local_service_demand, remote_service_demand);
#line 4731
    confidence_iteration ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4737
  confidence_iteration --;
#line 4747
  retrieve_confident_values(& elapsed_time, & thruput, & local_cpu_utilization, & remote_cpu_utilization,
                            & local_service_demand, & remote_service_demand);
#line 4759
  elapsed_time_double = (double )elapsed_time;
#line 4760
  local_cpu_utilization_double = (double )local_cpu_utilization;
#line 4761
  local_service_demand_double = (double )local_service_demand;
#line 4762
  remote_cpu_utilization_double = (double )remote_cpu_utilization;
#line 4763
  remote_service_demand_double = (double )remote_service_demand;
  }
#line 4765
  if (120 == (int )libfmt) {
#line 4765
    sd_str = (char *)"usec/Tran";
  } else {
#line 4766
    sd_str = (char *)"usec/KB";
  }
#line 4768
  if (iteration_max > 1) {
    {
#line 4769
    result_confid_pct = get_result_confid();
#line 4770
    loc_cpu_confid_pct = get_loc_cpu_confid();
#line 4771
    rem_cpu_confid_pct = get_rem_cpu_confid();
#line 4772
    interval_pct = interval * 100.0;
    }
  }
#line 4778
  tmpfmt = libfmt;
#line 4779
  if (120 == (int )libfmt) {
#line 4780
    libfmt = (char )'m';
  }
  {
#line 4782
  local_send_thruput = calc_thruput((double )bytes_sent);
#line 4783
  local_recv_thruput = calc_thruput((double )bytes_received);
#line 4784
  remote_send_thruput = calc_thruput((double )remote_bytes_sent);
#line 4785
  remote_recv_thruput = calc_thruput((double )remote_bytes_received);
#line 4787
  libfmt = tmpfmt;
  }
#line 4790
  if (keep_statistics) {
    {
#line 4791
    HIST_get_stats(time_hist, & min_latency, & max_latency, & mean_latency, & stddev_latency);
#line 4796
    p50_latency = HIST_get_percentile(time_hist, 0.50);
#line 4797
    p90_latency = HIST_get_percentile(time_hist, 0.90);
#line 4798
    p99_latency = HIST_get_percentile(time_hist, 0.99);
    }
  }
#line 4804
  if (! legacy) {
    {
#line 4805
    print_omni();
    }
  }
#line 4823
  if (verbosity > 1) {
#line 4823
    if (! legacy) {
#line 4823
      tmp___19 = 1;
    } else {
#line 4823
      tmp___19 = 0;
    }
  } else {
#line 4823
    tmp___19 = 0;
  }
#line 4851
  return;
}
}
#line 4853 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void send_omni(char *remote_host ) 
{ 
  char name_buf[32] ;

  {
  {
#line 4857
  snprintf((char */* __restrict  */)(name_buf), sizeof(name_buf), (char const   */* __restrict  */)"OMNI %s TEST",
           direction_str);
#line 4858
  name_buf[31] = (char )'\000';
#line 4859
  send_omni_inner(remote_host, 0U, name_buf);
  }
#line 4860
  return;
}
}
#line 4870 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void set_hostname_and_port_2(void *addr , char *hostname , char *portstr ,
                                    int family , int port ) 
{ 


  {
  {
#line 4874
  inet_ntop(family, (void const   */* __restrict  */)addr, (char */* __restrict  */)hostname,
            (socklen_t )8192);
#line 4876
  sprintf((char */* __restrict  */)portstr, (char const   */* __restrict  */)"%u",
          port);
  }
#line 4878
  return;
}
}
#line 4885 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void recv_omni(void) 
{ 
  struct addrinfo *local_res ;
  char local_name[8192] ;
  char port_buffer[10] ;
  struct sockaddr_storage myaddr_in ;
  struct sockaddr_storage peeraddr_in ;
  int peeraddr_set ;
  int s_listen ;
  int data_socket ;
  unsigned int addrlen ;
  struct ring_elt *send_ring ;
  struct ring_elt *recv_ring ;
  int timed_out ;
  int pad_time ;
  int need_to_connect___0 ;
  int need_to_accept ;
  int connected ;
  int ret ;
  uint32_t temp_recvs ;
  struct omni_request_struct *omni_request ;
  struct omni_response_struct *omni_response ;
  struct omni_results_struct *omni_results ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  uint16_t tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  struct sockaddr *tmp___15 ;
  int *tmp___16 ;
  struct sockaddr *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;

  {
#line 4894
  peeraddr_set = 0;
#line 4901
  timed_out = 0;
#line 4902
  pad_time = 0;
#line 4903
  need_to_connect___0 = 0;
#line 4913
  omni_request = (struct omni_request_struct *)(netperf_request.content.test_specific_data);
#line 4915
  omni_response = (struct omni_response_struct *)(netperf_response.content.test_specific_data);
#line 4917
  omni_results = (struct omni_results_struct *)(netperf_response.content.test_specific_data);
#line 4920
  if (debug) {
    {
#line 4921
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netserver: %s: entered...\n",
            "recv_omni");
#line 4922
    fflush(where);
    }
  }
  {
#line 4927
  fixup_request_n(38);
#line 4931
  strncpy((char */* __restrict  */)(local_cong_control_req), (char const   */* __restrict  */)(omni_request->cong_control),
          sizeof(local_cong_control_req));
  }
#line 4939
  if (debug) {
    {
#line 4940
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: setting the response type...\n",
            "recv_omni");
#line 4941
    fflush(where);
    }
  }
#line 4944
  netperf_response.content.response_type = 98;
#line 4946
  if (debug) {
    {
#line 4947
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: the response type is set...\n",
            "recv_omni");
#line 4948
    fflush(where);
    }
  }
#line 4953
  if (debug) {
    {
#line 4954
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: grabbing a socket...\n",
            "recv_omni");
#line 4955
    fflush(where);
    }
  }
  {
#line 4962
  lss_size_req = omni_request->send_buf_size;
#line 4963
  lsr_size_req = omni_request->recv_buf_size;
#line 4964
  loc_nodelay = (int )(omni_request->flags & 1U);
#line 4965
  loc_rcvavoid = (int )omni_request->so_rcvavoid;
#line 4966
  loc_sndavoid = (int )omni_request->so_sndavoid;
#line 4967
  routing_allowed = (int )(omni_request->flags & 32U);
#line 4968
  want_keepalive = (int )(omni_request->flags & 2147483648U);
#line 4969
  local_socket_prio = omni_request->socket_prio;
#line 4970
  local_socket_tos = omni_request->socket_tos;
#line 4977
  interval_usecs = 0;
#line 4978
  interval_wate = 1;
#line 4979
  interval_burst = 0;
#line 4982
  connection_test = (int )(omni_request->flags & 4U);
#line 4983
  direction = (int )omni_request->direction;
#line 4986
  omni_request->fill_file[sizeof(omni_request->fill_file) - 1UL] = (char )'\000';
#line 4987
  strncpy((char */* __restrict  */)(local_fill_file), (char const   */* __restrict  */)(omni_request->fill_file),
          sizeof(local_fill_file));
#line 4994
  tmp = nf_to_af((int )omni_request->ipfamily);
  }
  {
#line 4995
  if (tmp == 10) {
#line 4995
    goto case_10;
  }
#line 4999
  goto switch_default;
  case_10: /* CIL Label */ 
#line 4997
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 5000
  ret = 0;
  {
#line 5000
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5000
    if (! (ret < 4)) {
#line 5000
      goto while_break;
    }
    {
#line 5001
    omni_request->netserver_ip[ret] = htonl(omni_request->netserver_ip[ret]);
#line 5002
    omni_request->netperf_ip[ret] = htonl(omni_request->netperf_ip[ret]);
#line 5000
    ret ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5004
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 5007
  tmp___0 = nf_to_af((int )omni_request->ipfamily);
#line 5007
  set_hostname_and_port_2((void *)(omni_request->netserver_ip), local_name, port_buffer,
                          tmp___0, (int )omni_request->data_port);
#line 5013
  tmp___1 = nst_to_hst((int )omni_request->socket_type);
#line 5013
  tmp___2 = nf_to_af((int )omni_request->ipfamily);
#line 5013
  local_res = complete_addrinfo(local_name, local_name, port_buffer, tmp___2, tmp___1,
                                (int )omni_request->protocol, 0);
#line 5021
  s_listen = omni_create_data_socket(local_res);
  }
#line 5023
  if (s_listen == -1) {
    {
#line 5024
    tmp___3 = __errno_location();
#line 5024
    netperf_response.content.serv_errno = *tmp___3;
#line 5025
    send_response();
    }
#line 5026
    if (debug) {
      {
#line 5027
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"could not create data socket\n");
#line 5028
      fflush(where);
      }
    }
    {
#line 5030
    exit(-1);
    }
  }
#line 5036
  if (debug) {
    {
#line 5037
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_omni: requested recv alignment of %d offset %d\nrecv_omni: requested send alignment of %d offset %d\n",
            omni_request->recv_alignment, omni_request->recv_offset, omni_request->send_alignment,
            omni_request->send_offset);
#line 5044
    fflush(where);
    }
  }
#line 5047
  omni_response->send_size = omni_request->send_size;
#line 5048
  omni_response->send_width = (int32_t )omni_request->send_width;
#line 5049
  omni_response->socket_prio = local_socket_prio;
#line 5050
  omni_response->socket_tos = local_socket_tos;
#line 5052
  if (omni_request->direction & 2U) {
#line 5062
    if (omni_request->response_size > 0) {
#line 5064
      bytes_to_send = omni_request->response_size;
#line 5065
      if (omni_request->send_width == 0U) {
#line 5065
        send_width = 1;
      } else {
#line 5066
        send_width = (int )omni_request->send_width;
      }
    } else {
#line 5069
      if (omni_request->send_size == 4294967295U) {
        {
#line 5070
        bytes_to_send = choose_send_size(lss_size, (int )omni_request->protocol);
        }
      } else {
#line 5072
        bytes_to_send = (int )omni_request->send_size;
      }
#line 5074
      if (omni_request->send_width == 0U) {
#line 5075
        send_width = lss_size / bytes_to_send + 1;
#line 5076
        if (send_width == 1) {
#line 5076
          send_width ++;
        }
      } else {
#line 5079
        send_width = (int )omni_request->send_width;
      }
    }
    {
#line 5081
    send_ring = allocate_buffer_ring(send_width, bytes_to_send, omni_request->send_alignment,
                                     omni_request->send_offset);
#line 5086
    omni_response->send_width = send_width;
#line 5087
    omni_response->send_size = (uint32_t )bytes_to_send;
    }
  }
#line 5090
  omni_response->receive_size = omni_request->receive_size;
#line 5091
  omni_response->recv_width = (int32_t )omni_request->recv_width;
#line 5092
  if (omni_request->direction & 4U) {
    {
#line 5095
    tmp___4 = is_multicast_addr(local_res);
    }
#line 5095
    if (tmp___4) {
      {
#line 5098
      join_multicast_addr(s_listen, local_res);
      }
    }
#line 5101
    if (omni_request->request_size > 0) {
#line 5103
      bytes_to_recv = omni_request->request_size;
#line 5104
      if (omni_request->recv_width == 0U) {
#line 5104
        recv_width = 1;
      } else {
#line 5105
        recv_width = (int )omni_request->recv_width;
      }
    } else {
#line 5108
      if (omni_request->receive_size == 4294967295U) {
#line 5109
        if (lsr_size > 0) {
#line 5109
          bytes_to_recv = lsr_size;
        } else {
#line 5110
          bytes_to_recv = 4096;
        }
      } else {
#line 5113
        bytes_to_recv = (int )omni_request->receive_size;
      }
#line 5116
      if (omni_request->recv_width == 0U) {
#line 5117
        recv_width = lsr_size / bytes_to_recv + 1;
#line 5118
        if (recv_width == 1) {
#line 5118
          recv_width ++;
        }
      } else {
#line 5121
        recv_width = (int )omni_request->recv_width;
      }
    }
    {
#line 5123
    recv_ring = allocate_buffer_ring(recv_width, bytes_to_recv, omni_request->recv_alignment,
                                     omni_request->recv_offset);
#line 5128
    omni_response->receive_size = (uint32_t )bytes_to_recv;
#line 5129
    omni_response->recv_width = recv_width;
    }
  }
#line 5139
  need_to_accept = omni_request->protocol != 17U;
#line 5144
  if (need_to_accept) {
    {
#line 5145
    tmp___6 = listen(s_listen, 5);
    }
#line 5145
    if (tmp___6 == -1) {
      {
#line 5146
      tmp___5 = __errno_location();
#line 5146
      netperf_response.content.serv_errno = *tmp___5;
#line 5147
      close(s_listen);
#line 5148
      send_response();
      }
#line 5149
      if (debug) {
        {
#line 5150
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"could not listen\n");
#line 5151
        fflush(where);
        }
      }
      {
#line 5153
      exit(1);
      }
    }
  }
  {
#line 5158
  addrlen = (unsigned int )sizeof(myaddr_in);
#line 5159
  tmp___8 = getsockname(s_listen, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& myaddr_in)),
                        (socklen_t */* __restrict  */)(& addrlen));
  }
#line 5159
  if (tmp___8 == -1) {
    {
#line 5162
    tmp___7 = __errno_location();
#line 5162
    netperf_response.content.serv_errno = *tmp___7;
#line 5163
    close(s_listen);
#line 5164
    send_response();
    }
#line 5165
    if (debug) {
      {
#line 5166
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"could not getsockname\n");
#line 5167
      fflush(where);
      }
    }
    {
#line 5169
    exit(-1);
    }
  }
  {
#line 5180
  tmp___9 = ntohs(((struct sockaddr_in *)(& myaddr_in))->sin_port);
#line 5180
  omni_response->data_port = (uint32_t )((int )tmp___9);
  }
#line 5182
  if (debug) {
    {
#line 5183
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"telling the remote to call me at %d\n",
            omni_response->data_port);
#line 5185
    fflush(where);
    }
  }
#line 5187
  netperf_response.content.serv_errno = 0;
#line 5195
  omni_response->cpu_rate = (float )0.0;
#line 5196
  omni_response->flags &= 4294967287U;
#line 5197
  if (omni_request->flags & 8U) {
    {
#line 5198
    omni_response->flags |= 8U;
#line 5199
    omni_response->cpu_rate = calibrate_local_cpu(omni_request->cpu_rate);
    }
  }
#line 5205
  omni_response->send_buf_size = lss_size;
#line 5206
  omni_response->recv_buf_size = lsr_size;
#line 5207
  if (loc_nodelay) {
#line 5208
    omni_response->flags |= 1U;
  } else {
#line 5210
    omni_response->flags &= 4294967294U;
  }
  {
#line 5212
  omni_response->so_rcvavoid = (uint32_t )loc_rcvavoid;
#line 5213
  omni_response->so_sndavoid = (uint32_t )loc_sndavoid;
#line 5214
  omni_response->interval_usecs = (uint32_t )interval_usecs;
#line 5215
  omni_response->interval_burst = (uint32_t )interval_burst;
#line 5217
  find_system_info(& local_system_model, & local_cpu_model, & local_cpu_frequency);
#line 5218
  strncpy((char */* __restrict  */)(omni_response->system_model), (char const   */* __restrict  */)local_system_model,
          sizeof(omni_response->system_model));
#line 5219
  omni_response->system_model[sizeof(omni_response->system_model) - 1UL] = (char)0;
#line 5220
  strncpy((char */* __restrict  */)(omni_response->cpu_model), (char const   */* __restrict  */)local_cpu_model,
          sizeof(omni_response->cpu_model));
#line 5221
  omni_response->cpu_model[sizeof(omni_response->cpu_model) - 1UL] = (char)0;
#line 5222
  omni_response->cpu_frequency = (uint32_t )local_cpu_frequency;
#line 5224
  find_security_info(& local_security_enabled_num, & local_security_type_id, & local_security_specific);
#line 5228
  omni_response->security_info = (uint32_t )(local_security_type_id << 16);
#line 5229
  omni_response->security_info += (uint32_t )(local_security_enabled_num & 65535);
#line 5230
  strncpy((char */* __restrict  */)(omni_response->security_string), (char const   */* __restrict  */)local_security_specific,
          sizeof(omni_response->security_string));
#line 5233
  omni_response->security_string[sizeof(omni_response->security_string) - 1UL] = (char)0;
#line 5235
  send_response_n(18);
#line 5237
  local_send_calls = (uint64_t )0;
#line 5238
  local_receive_calls = (uint64_t )0;
#line 5240
  addrlen = (unsigned int )sizeof(peeraddr_in);
#line 5241
  memset((void *)(& peeraddr_in), 0, sizeof(peeraddr_in));
#line 5246
  cpu_start((int )(omni_request->flags & 8U));
  }
#line 5254
  if (omni_request->test_length >= 0) {
#line 5255
    times_up = 0;
#line 5256
    units_remaining = (int64_t )0;
#line 5257
    test_time = omni_request->test_length;
#line 5260
    if (omni_request->direction & 2U) {
#line 5260
      if (! (! (omni_request->direction & 4U))) {
#line 5260
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 5260
    if (omni_request->test_length > 0) {
#line 5262
      pad_time = 4;
    }
    {
#line 5263
    start_timer(omni_request->test_length + pad_time);
    }
  } else {
#line 5266
    times_up = 1;
#line 5267
    units_remaining = (int64_t )(omni_request->test_length * -1);
  }
#line 5275
  trans_completed = (uint64_t )0;
#line 5276
  bytes_sent = (uint64_t )0;
#line 5277
  bytes_received = (uint64_t )0;
#line 5278
  connected = 0;
  {
#line 5280
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5280
    if (! (! times_up)) {
#line 5280
      if (! (units_remaining > 0L)) {
#line 5280
        goto while_break___0;
      }
    }
#line 5282
    if (need_to_accept) {
      {
#line 5290
      data_socket = accept(s_listen, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peeraddr_in)),
                           (socklen_t */* __restrict  */)(& addrlen));
      }
#line 5290
      if (data_socket == -1) {
        {
#line 5293
        tmp___10 = __errno_location();
        }
#line 5293
        if (*tmp___10 == 4) {
#line 5295
          times_up = 1;
#line 5296
          timed_out = 1;
#line 5297
          goto while_break___0;
        }
        {
#line 5299
        tmp___11 = __errno_location();
#line 5299
        netperf_response.content.serv_errno = *tmp___11;
#line 5300
        send_response();
#line 5301
        tmp___12 = __errno_location();
#line 5301
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: accept: errno = %d\n",
                "recv_omni", *tmp___12);
#line 5302
        fflush(where);
#line 5303
        close(s_listen);
#line 5305
        exit(-1);
        }
      }
#line 5308
      if (debug) {
        {
#line 5309
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: accepted data connection.\n",
                "recv_omni");
#line 5310
        fflush(where);
        }
      }
#line 5312
      need_to_accept = 0;
#line 5313
      connected = 1;
    } else
#line 5330
    if (omni_request->protocol == 17U) {
#line 5330
      if (! peeraddr_set) {
        {
#line 5332
        peeraddr_set = 1;
#line 5333
        data_socket = s_listen;
#line 5334
        tmp___13 = nf_to_af((int )omni_request->ipfamily);
#line 5334
        set_sockaddr_family_addr_port(& peeraddr_in, tmp___13, (void *)(omni_request->netperf_ip),
                                      (int )omni_request->netperf_port);
        }
      }
    }
#line 5361
    if (omni_request->direction & 4U) {
#line 5361
      if (! times_up) {
#line 5361
        goto _L___0;
      } else
#line 5361
      if (units_remaining > 0L) {
        _L___0: /* CIL Label */ 
#line 5363
        if (direction & 2) {
#line 5363
          tmp___14 = 1;
        } else {
#line 5363
          tmp___14 = 0;
        }
#line 5363
        if (connected) {
#line 5363
          tmp___15 = (struct sockaddr *)((void *)0);
        } else {
#line 5363
          tmp___15 = (struct sockaddr *)(& peeraddr_in);
        }
        {
#line 5363
        ret = recv_data(data_socket, recv_ring, (uint32_t )bytes_to_recv, tmp___15,
                        & addrlen, (uint32_t )tmp___14, & temp_recvs);
        }
#line 5371
        if (ret > 0) {
#line 5374
          if (! (direction & 2)) {
#line 5374
            if (units_remaining > 0L) {
#line 5375
              units_remaining -= (int64_t )ret;
            }
          }
#line 5377
          bytes_received += (uint64_t )ret;
#line 5378
          local_receive_calls += (uint64_t )temp_recvs;
        } else
#line 5380
        if (ret == 0) {
#line 5385
          if (! connection_test) {
#line 5385
            if (! null_message_ok) {
#line 5388
              times_up = 1;
#line 5389
              goto while_break___0;
            }
          }
#line 5391
          local_receive_calls += (uint64_t )temp_recvs;
        } else
#line 5393
        if (ret == -1) {
          {
#line 5395
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"YO! TIMESUP!\n");
#line 5396
          fflush(where);
#line 5397
          times_up = 1;
#line 5398
          timed_out = 1;
          }
#line 5399
          goto while_break___0;
        } else {
          {
#line 5405
          tmp___16 = __errno_location();
#line 5405
          netperf_response.content.serv_errno = *tmp___16;
#line 5406
          send_response();
#line 5407
          exit(-1);
          }
        }
#line 5409
        recv_ring = recv_ring->next;
      }
    }
#line 5414
    if (omni_request->direction & 2U) {
#line 5414
      if (! times_up) {
#line 5414
        goto _L___1;
      } else
#line 5414
      if (units_remaining > 0L) {
        _L___1: /* CIL Label */ 
#line 5416
        if (connected) {
#line 5416
          tmp___17 = (struct sockaddr *)((void *)0);
        } else {
#line 5416
          tmp___17 = (struct sockaddr *)(& peeraddr_in);
        }
        {
#line 5416
        ret = send_data(data_socket, send_ring, (uint32_t )bytes_to_send, tmp___17,
                        (int )addrlen);
        }
#line 5425
        if (ret == bytes_to_send) {
#line 5428
          if (! (direction & 4)) {
#line 5428
            if (units_remaining > 0L) {
#line 5429
              units_remaining -= (int64_t )ret;
            }
          }
#line 5431
          bytes_sent += (uint64_t )ret;
#line 5432
          send_ring = send_ring->next;
#line 5433
          local_send_calls ++;
        } else
#line 5435
        if (ret == -2) {
#line 5446
          failed_sends ++;
        } else
#line 5448
        if (! (ret == 0)) {
#line 5453
          if (ret == -1) {
#line 5454
            times_up = 1;
#line 5455
            timed_out = 1;
#line 5456
            goto while_break___0;
          } else {
            {
#line 5462
            tmp___18 = __errno_location();
#line 5462
            netperf_response.content.serv_errno = *tmp___18;
#line 5463
            send_response();
#line 5464
            exit(-1);
            }
          }
        }
      }
    }
#line 5469
    if (connection_test) {
#line 5480
      if (lsr_size_req < 0) {
#line 5480
        if (-1 == lsr_size_end) {
          {
#line 5481
          get_sock_buffer(data_socket, (enum sock_buffer )1, & lsr_size_end);
          }
        } else {
#line 5483
          lsr_size_end = lsr_size;
        }
      } else {
#line 5483
        lsr_size_end = lsr_size;
      }
#line 5484
      if (lss_size_req < 0) {
#line 5484
        if (-1 == lss_size_end) {
          {
#line 5485
          get_sock_buffer(data_socket, (enum sock_buffer )0, & lss_size_end);
          }
        } else {
#line 5487
          lss_size_end = lss_size;
        }
      } else {
#line 5487
        lss_size_end = lss_size;
      }
      {
#line 5492
      ret = close_data_socket(data_socket, (struct sockaddr *)((void *)0), 0, (int )omni_request->protocol);
      }
#line 5493
      if (ret == -1) {
#line 5494
        times_up = 1;
#line 5495
        timed_out = 1;
#line 5496
        goto while_break___0;
      } else
#line 5498
      if (ret < 0) {
        {
#line 5499
        tmp___19 = __errno_location();
#line 5499
        netperf_response.content.serv_errno = *tmp___19;
#line 5500
        send_response();
#line 5501
        perror("netperf: recv_omni: close_data_socket failed");
#line 5502
        fflush(where);
#line 5503
        exit(-1);
        }
      }
#line 5506
      need_to_accept = 1;
#line 5507
      connected = 0;
    }
#line 5517
    if (omni_request->direction & 2U) {
#line 5517
      if (omni_request->direction & 4U) {
#line 5517
        goto _L___2;
      } else {
#line 5517
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 5517
    if (! (omni_request->direction & 2U)) {
#line 5517
      if (! (omni_request->direction & 4U)) {
        _L___2: /* CIL Label */ 
#line 5518
        trans_completed ++;
#line 5519
        if (units_remaining) {
#line 5520
          units_remaining --;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5527
  stop_timer();
#line 5528
  cpu_stop((int )(omni_request->flags & 8U), & elapsed_time);
#line 5529
  close(s_listen);
  }
#line 5537
  if (timed_out) {
#line 5542
    if (debug) {
      {
#line 5543
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Adjusting elapsed time by %d seconds\n",
              pad_time);
#line 5544
      fflush(where);
      }
    }
#line 5546
    elapsed_time -= (float )pad_time;
  }
  {
#line 5549
  remote_transport_retrans = get_transport_retrans(data_socket, (int )omni_request->protocol);
  }
#line 5552
  if (connected) {
#line 5559
    if (lsr_size_req < 0) {
      {
#line 5560
      get_sock_buffer(data_socket, (enum sock_buffer )1, & lsr_size_end);
      }
    } else {
#line 5562
      lsr_size_end = lsr_size;
    }
#line 5563
    if (lss_size_req < 0) {
      {
#line 5564
      get_sock_buffer(data_socket, (enum sock_buffer )0, & lss_size_end);
      }
    } else {
#line 5566
      lss_size_end = lss_size;
    }
#line 5571
    if (omni_request->flags & 32U) {
      {
#line 5572
      get_transport_cong_control(data_socket, local_res->ai_protocol, omni_results->cong_control,
                                 (int )sizeof(omni_results->cong_control));
      }
    } else {
      {
#line 5578
      strncpy((char */* __restrict  */)(omni_results->cong_control), (char const   */* __restrict  */)"",
              sizeof(omni_results->cong_control));
      }
    }
    {
#line 5582
    close_data_socket(data_socket, (struct sockaddr *)((void *)0), 0, (int )omni_request->protocol);
    }
  } else {
    {
#line 5585
    close_data_socket(data_socket, (struct sockaddr *)(& peeraddr_in), (int )addrlen,
                      (int )omni_request->protocol);
#line 5586
    lsr_size_end = lsr_size;
#line 5587
    lss_size_end = lss_size;
    }
  }
#line 5592
  omni_results->send_calls = (uint32_t )local_send_calls;
#line 5593
  omni_results->bytes_received_lo = (uint32_t )((unsigned long long )bytes_received & 4294967295ULL);
#line 5594
  omni_results->bytes_received_hi = (uint32_t )(((unsigned long long )bytes_received & 0xffffffff00000000ULL) >> 32);
#line 5595
  omni_results->recv_buf_size = lsr_size_end;
#line 5596
  omni_results->recv_calls = (uint32_t )local_receive_calls;
#line 5597
  omni_results->bytes_sent_lo = (uint32_t )((unsigned long long )bytes_sent & 4294967295ULL);
#line 5598
  omni_results->bytes_sent_hi = (uint32_t )(((unsigned long long )bytes_sent & 0xffffffff00000000ULL) >> 32);
#line 5599
  omni_results->send_buf_size = lss_size_end;
#line 5600
  omni_results->trans_received = (uint32_t )trans_completed;
#line 5601
  omni_results->elapsed_time = elapsed_time;
#line 5602
  omni_results->transport_retrans = remote_transport_retrans;
#line 5603
  omni_results->cpu_method = (uint32_t )cpu_method;
#line 5604
  omni_results->num_cpus = (uint32_t )lib_num_loc_cpus;
#line 5605
  if (omni_request->flags & 8U) {
    {
#line 5606
    omni_results->cpu_util = calc_cpu_util(elapsed_time);
    }
  }
#line 5608
  omni_results->peak_cpu_util = (float )lib_local_peak_cpu_util;
#line 5609
  omni_results->peak_cpu_id = lib_local_peak_cpu_id;
#line 5610
  if (omni_request->flags & 64U) {
    {
#line 5614
    local_interface_name = find_egress_interface(local_res->ai_addr, (struct sockaddr *)(& peeraddr_in));
#line 5616
    strncpy((char */* __restrict  */)(omni_results->ifname), (char const   */* __restrict  */)local_interface_name,
            (size_t )16);
#line 5617
    omni_results->ifname[15] = (char)0;
    }
  } else
#line 5610
  if (omni_request->flags & 128U) {
    {
#line 5614
    local_interface_name = find_egress_interface(local_res->ai_addr, (struct sockaddr *)(& peeraddr_in));
#line 5616
    strncpy((char */* __restrict  */)(omni_results->ifname), (char const   */* __restrict  */)local_interface_name,
            (size_t )16);
#line 5617
    omni_results->ifname[15] = (char)0;
    }
  } else
#line 5610
  if (omni_request->flags & 256U) {
    {
#line 5614
    local_interface_name = find_egress_interface(local_res->ai_addr, (struct sockaddr *)(& peeraddr_in));
#line 5616
    strncpy((char */* __restrict  */)(omni_results->ifname), (char const   */* __restrict  */)local_interface_name,
            (size_t )16);
#line 5617
    omni_results->ifname[15] = (char)0;
    }
  } else
#line 5610
  if (omni_request->flags & 512U) {
    {
#line 5614
    local_interface_name = find_egress_interface(local_res->ai_addr, (struct sockaddr *)(& peeraddr_in));
#line 5616
    strncpy((char */* __restrict  */)(omni_results->ifname), (char const   */* __restrict  */)local_interface_name,
            (size_t )16);
#line 5617
    omni_results->ifname[15] = (char)0;
    }
  } else {
    {
#line 5620
    strncpy((char */* __restrict  */)(omni_results->ifname), (char const   */* __restrict  */)"Bug If Seen IFNAME",
            (size_t )16);
    }
  }
#line 5622
  if (omni_request->flags & 128U) {
    {
#line 5623
    local_interface_slot = find_interface_slot(local_interface_name);
#line 5624
    strncpy((char */* __restrict  */)(omni_results->ifslot), (char const   */* __restrict  */)local_interface_slot,
            (size_t )16);
#line 5625
    omni_results->ifslot[15] = (char)0;
    }
  } else {
    {
#line 5628
    strncpy((char */* __restrict  */)(omni_results->ifslot), (char const   */* __restrict  */)"Bug If Seen IFSLOT",
            (size_t )16);
    }
  }
#line 5630
  if (omni_request->flags & 256U) {
    {
#line 5631
    find_interface_ids(local_interface_name, & omni_results->vendor, & omni_results->device,
                       & omni_results->subvendor, & omni_results->subdevice);
    }
  } else {
#line 5638
    omni_results->vendor = -2;
#line 5639
    omni_results->device = -2;
#line 5640
    omni_results->subvendor = -2;
#line 5641
    omni_results->subdevice = -2;
  }
#line 5643
  if (omni_request->flags & 512U) {
    {
#line 5644
    find_driver_info(local_interface_name, omni_results->driver, omni_results->version,
                     omni_results->firmware, omni_results->bus, 32);
    }
  } else {
    {
#line 5652
    strncpy((char */* __restrict  */)(omni_results->driver), (char const   */* __restrict  */)"Bug If Seen DRVINFO",
            (size_t )32);
#line 5653
    strncpy((char */* __restrict  */)(omni_results->version), (char const   */* __restrict  */)"Bug If Seen DRVINFO",
            (size_t )32);
#line 5654
    strncpy((char */* __restrict  */)(omni_results->firmware), (char const   */* __restrict  */)"Bug If Seen DRVINFO",
            (size_t )32);
#line 5655
    strncpy((char */* __restrict  */)(omni_results->bus), (char const   */* __restrict  */)"Bug If Seen DRVINFO",
            (size_t )32);
    }
  }
#line 5664
  if (debug) {
    {
#line 5665
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: test complete, sending results.\n",
            "recv_omni");
#line 5668
    fflush(where);
    }
  }
  {
#line 5671
  send_response_n(22);
  }
#line 5673
  return;
}
}
#line 5677 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void send_tcp_stream(char *remote_host ) 
{ 
  char *tput_title ;
  char *tput_fmt_0 ;
  char *tput_fmt_1 ;
  char *cpu_title ;
  char *cpu_fmt_0 ;
  char *cpu_fmt_1 ;
  char *ksink_fmt ;
  char *ksink_fmt2 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 5681
  tput_title = (char *)"Recv   Send    Send                          \nSocket Socket  Message  Elapsed              \nSize   Size    Size     Time     Throughput  \nbytes  bytes   bytes    secs.    %s/sec  \n\n";
#line 5687
  tput_fmt_0 = (char *)"%7.2f %s\n";
#line 5690
  tput_fmt_1 = (char *)"%6d %6d %6d    %-6.2f   %7.2f   %s\n";
#line 5693
  cpu_title = (char *)"Recv   Send    Send                          Utilization       Service Demand\nSocket Socket  Message  Elapsed              Send     Recv     Send    Recv\nSize   Size    Size     Time     Throughput  local    remote   local   remote\nbytes  bytes   bytes    secs.    %-8.8s/s  %% %c      %% %c      us/KB   us/KB\n\n";
#line 5699
  cpu_fmt_0 = (char *)"%6.3f %c %s\n";
#line 5702
  cpu_fmt_1 = (char *)"%6d %6d %6d    %-6.2f     %7.2f   %-6.2f   %-6.2f   %-6.3f  %-6.3f %s\n";
#line 5705
  ksink_fmt = (char *)"\nAlignment      Offset         %-8.8s %-8.8s    Sends   %-8.8s Recvs\nLocal  Remote  Local  Remote  Xfered   Per                 Per\nSend   Recv    Send   Recv             Send (avg)          Recv (avg)\n%5d   %5d  %5d   %5d %6ld  %6.2f    %6ld   %6.2f %6ld\n";
#line 5711
  ksink_fmt2 = (char *)"\nMaximum\nSegment\nSize (bytes)\n%6d\n";
#line 5717
  send_omni_inner(remote_host, (unsigned int )legacy, (char *)"MIGRATED TCP STREAM TEST");
  }
#line 5720
  if (legacy) {
#line 5732
    if (confidence < (double )0) {
#line 5734
      if (iteration_max > 1) {
        {
#line 5735
        display_confidence();
        }
      }
    }
#line 5739
    if (local_cpu_usage) {
#line 5739
      goto _L;
    } else
#line 5739
    if (remote_cpu_usage) {
      _L: /* CIL Label */ 
      {
#line 5742
      if (verbosity == 0) {
#line 5742
        goto case_0;
      }
#line 5761
      if (verbosity == 2) {
#line 5761
        goto case_2;
      }
#line 5761
      if (verbosity == 1) {
#line 5761
        goto case_2;
      }
#line 5741
      goto switch_break;
      case_0: /* CIL Label */ 
#line 5743
      if (local_cpu_usage) {
#line 5744
        if (print_headers) {
#line 5744
          tmp = "";
        } else
#line 5744
        if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 5744
          tmp = "";
        } else {
#line 5744
          tmp = (char const   *)result_brand;
        }
        {
#line 5744
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
                (double )local_service_demand, local_cpu_method, tmp);
        }
      } else {
#line 5752
        if (print_headers) {
#line 5752
          tmp___0 = "";
        } else
#line 5752
        if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 5752
          tmp___0 = "";
        } else {
#line 5752
          tmp___0 = (char const   *)result_brand;
        }
        {
#line 5752
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
                (double )remote_service_demand, remote_cpu_method, tmp___0);
        }
      }
#line 5759
      goto switch_break;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
#line 5762
      if (print_headers) {
        {
#line 5763
        tmp___1 = format_units();
#line 5763
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_title,
                tmp___1, local_cpu_method, remote_cpu_method);
        }
      }
#line 5770
      if (print_headers) {
#line 5770
        tmp___2 = "";
      } else
#line 5770
      if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 5770
        tmp___2 = "";
      } else {
#line 5770
        tmp___2 = (char const   *)result_brand;
      }
      {
#line 5770
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_1,
              rsr_size, lss_size, send_size, (double )elapsed_time, thruput, (double )local_cpu_utilization,
              (double )remote_cpu_utilization, (double )local_service_demand, (double )remote_service_demand,
              tmp___2);
      }
#line 5783
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 5790
      if (verbosity == 0) {
#line 5790
        goto case_0___0;
      }
#line 5798
      if (verbosity == 2) {
#line 5798
        goto case_2___0;
      }
#line 5798
      if (verbosity == 1) {
#line 5798
        goto case_2___0;
      }
#line 5789
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 5791
      if (print_headers) {
#line 5791
        tmp___3 = "";
      } else
#line 5791
      if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 5791
        tmp___3 = "";
      } else {
#line 5791
        tmp___3 = (char const   *)result_brand;
      }
      {
#line 5791
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_0,
              thruput, tmp___3);
      }
#line 5796
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
#line 5799
      if (print_headers) {
        {
#line 5800
        tmp___4 = format_units();
#line 5800
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_title,
                tmp___4);
        }
      }
#line 5802
      if (print_headers) {
#line 5802
        tmp___5 = "";
      } else
#line 5802
      if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 5802
        tmp___5 = "";
      } else {
#line 5802
        tmp___5 = (char const   *)result_brand;
      }
      {
#line 5802
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_1,
              rsr_size, lss_size, send_size, (double )elapsed_time, thruput, tmp___5);
      }
#line 5811
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 5821
    if (verbosity > 1) {
      {
#line 5830
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)ksink_fmt,
              "Bytes", "Bytes", "Bytes", local_send_align, remote_recv_align, local_send_offset,
              remote_recv_offset, bytes_sent, (double )bytes_sent / (double )local_send_calls,
              local_send_calls, (double )bytes_sent / (double )remote_receive_calls,
              remote_receive_calls);
#line 5844
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)ksink_fmt2,
              transport_mss);
#line 5851
      fflush(where);
      }
    }
  }
#line 5855
  return;
}
}
#line 5857 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void send_tcp_maerts(char *remote_host ) 
{ 
  char *tput_title ;
  char *tput_fmt_0 ;
  char *tput_fmt_1 ;
  char *cpu_title ;
  char *cpu_fmt_0 ;
  char *cpu_fmt_1 ;
  char *ksink_fmt ;
  char *ksink_fmt2 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 5861
  tput_title = (char *)"Recv   Send    Send                          \nSocket Socket  Message  Elapsed              \nSize   Size    Size     Time     Throughput  \nbytes  bytes   bytes    secs.    %s/sec  \n\n";
#line 5867
  tput_fmt_0 = (char *)"%7.2f %s\n";
#line 5870
  tput_fmt_1 = (char *)"%6d %6d %6d    %-6.2f   %7.2f   %s\n";
#line 5873
  cpu_title = (char *)"Recv   Send    Send                          Utilization       Service Demand\nSocket Socket  Message  Elapsed              Recv     Send     Recv    Send\nSize   Size    Size     Time     Throughput  local    remote   local   remote\nbytes  bytes   bytes    secs.    %-8.8s/s  %% %c      %% %c      us/KB   us/KB\n\n";
#line 5879
  cpu_fmt_0 = (char *)"%6.3f %c %s\n";
#line 5882
  cpu_fmt_1 = (char *)"%6d %6d %6d    %-6.2f     %7.2f   %-6.2f   %-6.2f   %-6.3f  %-6.3f %s\n";
#line 5885
  ksink_fmt = (char *)"\nAlignment      Offset         %-8.8s %-8.8s    Recvs   %-8.8s Sends\nLocal  Remote  Local  Remote  Xfered   Per                 Per\nRecv   Send    Recv   Send             Recv (avg)          Send (avg)\n%5d   %5d  %5d   %5d %6ld  %6.2f    %6d   %6.2f %6d\n";
#line 5891
  ksink_fmt2 = (char *)"\nMaximum\nSegment\nSize (bytes)\n%6d\n";
#line 5897
  send_omni_inner(remote_host, (unsigned int )legacy, (char *)"MIGRATED TCP MAERTS TEST");
  }
#line 5910
  if (legacy) {
#line 5912
    if (confidence < (double )0) {
#line 5914
      if (iteration_max > 1) {
        {
#line 5915
        display_confidence();
        }
      }
    }
#line 5919
    if (local_cpu_usage) {
#line 5919
      goto _L;
    } else
#line 5919
    if (remote_cpu_usage) {
      _L: /* CIL Label */ 
      {
#line 5922
      if (verbosity == 0) {
#line 5922
        goto case_0;
      }
#line 5941
      if (verbosity == 2) {
#line 5941
        goto case_2;
      }
#line 5941
      if (verbosity == 1) {
#line 5941
        goto case_2;
      }
#line 5921
      goto switch_break;
      case_0: /* CIL Label */ 
#line 5923
      if (local_cpu_usage) {
#line 5924
        if (print_headers) {
#line 5924
          tmp = "";
        } else
#line 5924
        if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 5924
          tmp = "";
        } else {
#line 5924
          tmp = (char const   *)result_brand;
        }
        {
#line 5924
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
                (double )local_service_demand, local_cpu_method, tmp);
        }
      } else {
#line 5932
        if (print_headers) {
#line 5932
          tmp___0 = "";
        } else
#line 5932
        if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 5932
          tmp___0 = "";
        } else {
#line 5932
          tmp___0 = (char const   *)result_brand;
        }
        {
#line 5932
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
                (double )remote_service_demand, remote_cpu_method, tmp___0);
        }
      }
#line 5939
      goto switch_break;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
#line 5942
      if (print_headers) {
        {
#line 5943
        tmp___1 = format_units();
#line 5943
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_title,
                tmp___1, local_cpu_method, remote_cpu_method);
        }
      }
#line 5950
      if (print_headers) {
#line 5950
        tmp___2 = "";
      } else
#line 5950
      if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 5950
        tmp___2 = "";
      } else {
#line 5950
        tmp___2 = (char const   *)result_brand;
      }
      {
#line 5950
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_1,
              rsr_size, lss_size, send_size, (double )elapsed_time, thruput, (double )local_cpu_utilization,
              (double )remote_cpu_utilization, (double )local_service_demand, (double )remote_service_demand,
              tmp___2);
      }
#line 5963
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 5970
      if (verbosity == 0) {
#line 5970
        goto case_0___0;
      }
#line 5978
      if (verbosity == 2) {
#line 5978
        goto case_2___0;
      }
#line 5978
      if (verbosity == 1) {
#line 5978
        goto case_2___0;
      }
#line 5969
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 5971
      if (print_headers) {
#line 5971
        tmp___3 = "";
      } else
#line 5971
      if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 5971
        tmp___3 = "";
      } else {
#line 5971
        tmp___3 = (char const   *)result_brand;
      }
      {
#line 5971
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_0,
              thruput, tmp___3);
      }
#line 5976
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
#line 5979
      if (print_headers) {
        {
#line 5980
        tmp___4 = format_units();
#line 5980
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_title,
                tmp___4);
        }
      }
#line 5982
      if (print_headers) {
#line 5982
        tmp___5 = "";
      } else
#line 5982
      if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 5982
        tmp___5 = "";
      } else {
#line 5982
        tmp___5 = (char const   *)result_brand;
      }
      {
#line 5982
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_1,
              lsr_size, rss_size, remote_send_size, (double )elapsed_time, thruput,
              tmp___5);
      }
#line 5991
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 6001
    if (verbosity > 1) {
      {
#line 6010
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)ksink_fmt,
              "Bytes", "Bytes", "Bytes", local_recv_align, remote_recv_align, local_recv_offset,
              remote_recv_offset, bytes_received, (double )bytes_received / (double )local_receive_calls,
              local_receive_calls, (double )remote_bytes_sent / (double )remote_send_calls,
              remote_send_calls);
#line 6024
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)ksink_fmt2,
              transport_mss);
#line 6032
      fflush(where);
      }
    }
  }
#line 6035
  return;
}
}
#line 6038 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void send_tcp_rr(char *remote_host ) 
{ 
  char *tput_title ;
  char *tput_title_band ;
  char *tput_fmt_0 ;
  char *tput_fmt_1_line_1 ;
  char *tput_fmt_1_line_2 ;
  char *cpu_title ;
  char *cpu_title_tput ;
  char *cpu_title_latency ;
  char *cpu_fmt_0 ;
  char *cpu_fmt_1_line_1 ;
  char *cpu_fmt_1_line_2 ;
  char *ksink_fmt ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 6041
  tput_title = (char *)"Local /Remote\nSocket Size   Request  Resp.   Elapsed  Trans.\nSend   Recv   Size     Size    Time     Rate         \nbytes  Bytes  bytes    bytes   secs.    per sec   \n\n";
#line 6047
  tput_title_band = (char *)"Local /Remote\nSocket Size   Request  Resp.   Elapsed  \nSend   Recv   Size     Size    Time     Throughput \nbytes  Bytes  bytes    bytes   secs.    %s/sec   \n\n";
#line 6053
  tput_fmt_0 = (char *)"%7.2f %s\n";
#line 6056
  tput_fmt_1_line_1 = (char *)"%-6d %-6d %-6d   %-6d  %-6.2f   %7.2f   %s\n";
#line 6058
  tput_fmt_1_line_2 = (char *)"%-6d %-6d\n";
#line 6061
  cpu_title = (char *)"Local /Remote\nSocket Size   Request Resp.  Elapsed Trans.   CPU    CPU    S.dem   S.dem\nSend   Recv   Size    Size   Time    Rate     local  remote local   remote\nbytes  bytes  bytes   bytes  secs.   per sec  %% %c    %% %c    us/Tr   us/Tr\n\n";
#line 6067
  cpu_title_tput = (char *)"Local /Remote\nSocket Size   Request Resp.  Elapsed Tput     CPU    CPU    S.dem   S.dem\nSend   Recv   Size    Size   Time    %-8.8s local  remote local   remote\nbytes  bytes  bytes   bytes  secs.   per sec  %% %c    %% %c    us/KB   us/KB\n\n";
#line 6073
  cpu_title_latency = (char *)"Local /Remote\nSocket Size   Request Resp.  Elapsed Latency  CPU    CPU    S.dem   S.dem\nSend   Recv   Size    Size   Time    usecs    local  remote local   remote\nbytes  bytes  bytes   bytes  secs.   per tran %% %c    %% %c    us/Tr   us/Tr\n\n";
#line 6079
  cpu_fmt_0 = (char *)"%6.3f %c %s\n";
#line 6082
  cpu_fmt_1_line_1 = (char *)"%-6d %-6d %-6d  %-6d %-6.2f  %-6.2f  %-6.2f %-6.2f %-6.3f  %-6.3f %s\n";
#line 6085
  cpu_fmt_1_line_2 = (char *)"%-6d %-6d\n";
#line 6088
  ksink_fmt = (char *)"Alignment      Offset         RoundTrip  Trans    Throughput\nLocal  Remote  Local  Remote  Latency    Rate     %-8.8s/s\nSend   Recv    Send   Recv    usec/Tran  per sec  Outbound   Inbound\n%5d  %5d   %5d  %5d   %-6.3f   %-6.3f %-6.3f    %-6.3f\n";
#line 6094
  send_omni_inner(remote_host, (unsigned int )legacy, (char *)"MIGRATED TCP REQUEST/RESPONSE TEST");
  }
#line 6096
  if (legacy) {
#line 6106
    if (confidence < (double )0) {
#line 6108
      if (iteration_max > 1) {
        {
#line 6109
        display_confidence();
        }
      }
    }
#line 6113
    if (local_cpu_usage) {
#line 6113
      goto _L;
    } else
#line 6113
    if (remote_cpu_usage) {
      _L: /* CIL Label */ 
      {
#line 6116
      if (verbosity == 0) {
#line 6116
        goto case_0;
      }
#line 6135
      if (verbosity == 2) {
#line 6135
        goto case_2;
      }
#line 6135
      if (verbosity == 1) {
#line 6135
        goto case_2;
      }
#line 6115
      goto switch_break;
      case_0: /* CIL Label */ 
#line 6117
      if (local_cpu_usage) {
#line 6118
        if (print_headers) {
#line 6118
          tmp = "";
        } else
#line 6118
        if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 6118
          tmp = "";
        } else {
#line 6118
          tmp = (char const   *)result_brand;
        }
        {
#line 6118
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
                (double )local_service_demand, local_cpu_method, tmp);
        }
      } else {
#line 6126
        if (print_headers) {
#line 6126
          tmp___0 = "";
        } else
#line 6126
        if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 6126
          tmp___0 = "";
        } else {
#line 6126
          tmp___0 = (char const   *)result_brand;
        }
        {
#line 6126
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
                (double )remote_service_demand, remote_cpu_method, tmp___0);
        }
      }
#line 6133
      goto switch_break;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
#line 6136
      if (print_headers) {
#line 6137
        if (120 == (int )libfmt) {
          {
#line 6138
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_title,
                  local_cpu_method, remote_cpu_method);
          }
        } else {
          {
#line 6144
          tmp___1 = format_units();
#line 6144
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_title_tput,
                  tmp___1, local_cpu_method, remote_cpu_method);
          }
        }
      }
#line 6152
      if (print_headers) {
#line 6152
        tmp___2 = "";
      } else
#line 6152
      if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 6152
        tmp___2 = "";
      } else {
#line 6152
        tmp___2 = (char const   *)result_brand;
      }
      {
#line 6152
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_1_line_1,
              lss_size, lsr_size, req_size, rsp_size, (double )elapsed_time, thruput,
              (double )local_cpu_utilization, (double )remote_cpu_utilization, (double )local_service_demand,
              (double )remote_service_demand, tmp___2);
#line 6166
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_1_line_2,
              rss_size, rsr_size);
      }
#line 6170
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 6177
      if (verbosity == 0) {
#line 6177
        goto case_0___0;
      }
#line 6185
      if (verbosity == 2) {
#line 6185
        goto case_2___0;
      }
#line 6185
      if (verbosity == 1) {
#line 6185
        goto case_2___0;
      }
#line 6176
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 6178
      if (print_headers) {
#line 6178
        tmp___3 = "";
      } else
#line 6178
      if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 6178
        tmp___3 = "";
      } else {
#line 6178
        tmp___3 = (char const   *)result_brand;
      }
      {
#line 6178
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_0,
              thruput, tmp___3);
      }
#line 6183
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
#line 6186
      if (print_headers) {
        {
#line 6187
        tmp___4 = format_units();
        }
#line 6187
        if (120 == (int )libfmt) {
#line 6187
          tmp___5 = tput_title;
        } else {
#line 6187
          tmp___5 = tput_title_band;
        }
        {
#line 6187
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tmp___5,
                tmp___4);
        }
      }
#line 6192
      if (print_headers) {
#line 6192
        tmp___6 = "";
      } else
#line 6192
      if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 6192
        tmp___6 = "";
      } else {
#line 6192
        tmp___6 = (char const   *)result_brand;
      }
      {
#line 6192
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_1_line_1,
              lss_size, lsr_size, req_size, rsp_size, (double )elapsed_time, thruput,
              tmp___6);
#line 6210
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_1_line_2,
              rss_size, rsr_size);
      }
#line 6215
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 6227
    if (verbosity > 1) {
#line 6240
      if (120 == (int )libfmt) {
#line 6241
        libfmt = (char )'m';
      }
      {
#line 6244
      tmp___7 = calc_thruput_interval_omni(transaction_rate * (double )rsp_size, 1.0);
#line 6244
      tmp___8 = calc_thruput_interval_omni(transaction_rate * (double )req_size, 1.0);
      }
#line 6244
      if (first_burst_size > 0) {
#line 6244
        tmp___9 = first_burst_size;
      } else {
#line 6244
        tmp___9 = 0;
      }
      {
#line 6244
      tmp___10 = format_units();
#line 6244
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)ksink_fmt,
              tmp___10, local_send_align, remote_recv_offset, local_send_offset, remote_recv_offset,
              ((1.0 / transaction_rate) * 1000000.0) * (double )(1 + tmp___9), transaction_rate,
              tmp___8, tmp___7);
#line 6268
      fflush(where);
      }
    }
  }
#line 6271
  return;
}
}
#line 6274 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void send_tcp_conn_rr(char *remote_host ) 
{ 
  char *tput_title ;
  char *tput_fmt_0 ;
  char *tput_fmt_1_line_1 ;
  char *tput_fmt_1_line_2 ;
  char *cpu_title ;
  char *cpu_fmt_0 ;
  char *cpu_fmt_1_line_1 ;
  char *cpu_fmt_1_line_2 ;
  char *ksink_fmt ;
  char *tmp ;

  {
  {
#line 6278
  tput_title = (char *)"Local /Remote\nSocket Size   Request  Resp.   Elapsed  Trans.\nSend   Recv   Size     Size    Time     Rate         \nbytes  Bytes  bytes    bytes   secs.    per sec   \n\n";
#line 6284
  tput_fmt_0 = (char *)"%7.2f\n";
#line 6287
  tput_fmt_1_line_1 = (char *)"%-6d %-6d %-6d   %-6d  %-6.2f   %7.2f   \n";
#line 6289
  tput_fmt_1_line_2 = (char *)"%-6d %-6d\n";
#line 6292
  cpu_title = (char *)"Local /Remote\nSocket Size   Request Resp.  Elapsed Trans.   CPU    CPU    S.dem   S.dem\nSend   Recv   Size    Size   Time    Rate     local  remote local   remote\nbytes  bytes  bytes   bytes  secs.   per sec  %%      %%      us/Tr   us/Tr\n\n";
#line 6298
  cpu_fmt_0 = (char *)"%6.3f\n";
#line 6301
  cpu_fmt_1_line_1 = (char *)"%-6d %-6d %-6d  %-6d %-6.2f  %-6.2f   %-6.2f %-6.2f %-6.3f  %-6.3f\n";
#line 6304
  cpu_fmt_1_line_2 = (char *)"%-6d %-6d\n";
#line 6307
  ksink_fmt = (char *)"\nAlignment      Offset\nLocal  Remote  Local  Remote\nSend   Recv    Send   Recv\n%5d  %5d   %5d  %5d\n";
#line 6313
  send_omni_inner(remote_host, (unsigned int )legacy, (char *)"MIGRATED TCP Connect/Request/Response TEST");
  }
#line 6326
  if (legacy) {
#line 6327
    if (confidence < (double )0) {
#line 6329
      if (iteration_max > 1) {
        {
#line 6330
        display_confidence();
        }
      }
    }
#line 6334
    if (local_cpu_usage) {
#line 6334
      goto _L;
    } else
#line 6334
    if (remote_cpu_usage) {
      _L: /* CIL Label */ 
      {
#line 6337
      if (verbosity == 0) {
#line 6337
        goto case_0;
      }
#line 6352
      if (verbosity == 2) {
#line 6352
        goto case_2;
      }
#line 6352
      if (verbosity == 1) {
#line 6352
        goto case_2;
      }
#line 6336
      goto switch_break;
      case_0: /* CIL Label */ 
#line 6338
      if (local_cpu_usage) {
        {
#line 6339
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
                (double )local_service_demand, local_cpu_method);
        }
      } else {
        {
#line 6345
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
                (double )remote_service_demand, remote_cpu_method);
        }
      }
#line 6350
      goto switch_break;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
#line 6353
      if (print_headers) {
        {
#line 6354
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_title,
                local_cpu_method, remote_cpu_method);
        }
      }
      {
#line 6360
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_1_line_1,
              lss_size, lsr_size, req_size, rsp_size, (double )elapsed_time, thruput,
              (double )local_cpu_utilization, (double )remote_cpu_utilization, (double )local_service_demand,
              (double )remote_service_demand);
#line 6372
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_1_line_2,
              rss_size, rsr_size);
      }
#line 6376
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 6383
      if (verbosity == 0) {
#line 6383
        goto case_0___0;
      }
#line 6389
      if (verbosity == 2) {
#line 6389
        goto case_2___0;
      }
#line 6389
      if (verbosity == 1) {
#line 6389
        goto case_2___0;
      }
#line 6382
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 6384
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_0,
              thruput);
      }
#line 6387
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
#line 6390
      if (print_headers) {
        {
#line 6391
        tmp = format_units();
#line 6391
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_title,
                tmp);
        }
      }
      {
#line 6394
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_1_line_1,
              lss_size, lsr_size, req_size, rsp_size, (double )elapsed_time, thruput);
#line 6402
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_1_line_2,
              rss_size, rsr_size);
      }
#line 6407
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 6419
    if (verbosity > 1) {
      {
#line 6425
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)ksink_fmt,
              local_send_align, remote_recv_align, local_send_offset, remote_recv_offset);
#line 6436
      fflush(where);
      }
    }
  }
#line 6439
  return;
}
}
#line 6441 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void send_udp_stream(char *remote_host ) 
{ 
  char *tput_title ;
  char *tput_fmt_0 ;
  char *tput_fmt_1 ;
  char *cpu_title ;
  char *cpu_fmt_0 ;
  char *cpu_fmt_1 ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 6450
  tput_title = (char *)"Socket  Message  Elapsed      Messages                \nSize    Size     Time         Okay Errors   Throughput\nbytes   bytes    secs            #      #   %s/sec\n\n";
#line 6455
  tput_fmt_0 = (char *)"%7.2f\n";
#line 6458
  tput_fmt_1 = (char *)"%6d  %6d   %-7.2f   %7lu %6d    %7.2f\n%6d           %-7.2f   %7lu           %7.2f\n\n";
#line 6463
  cpu_title = (char *)"Socket  Message  Elapsed      Messages                   CPU      Service\nSize    Size     Time         Okay Errors   Throughput   Util     Demand\nbytes   bytes    secs            #      #   %s/sec %% %c%c     us/KB\n\n";
#line 6468
  cpu_fmt_0 = (char *)"%6.2f %c\n";
#line 6471
  cpu_fmt_1 = (char *)"%6d  %6d   %-7.2f   %7lu %6d    %7.1f     %-6.2f   %-6.3f\n%6d           %-7.2f   %7lu           %7.1f     %-6.2f   %-6.3f\n\n";
#line 6476
  send_omni_inner(remote_host, (unsigned int )legacy, (char *)"MIGRATED UDP STREAM TEST");
  }
#line 6478
  if (legacy) {
#line 6489
    if (confidence < (double )0) {
#line 6491
      if (iteration_max > 1) {
        {
#line 6492
        display_confidence();
        }
      }
    }
#line 6496
    if (local_cpu_usage) {
#line 6496
      goto _L;
    } else
#line 6496
    if (remote_cpu_usage) {
      _L: /* CIL Label */ 
      {
#line 6499
      if (verbosity == 0) {
#line 6499
        goto case_0;
      }
#line 6514
      if (verbosity == 2) {
#line 6514
        goto case_2;
      }
#line 6514
      if (verbosity == 1) {
#line 6514
        goto case_2;
      }
#line 6498
      goto switch_break;
      case_0: /* CIL Label */ 
#line 6500
      if (local_cpu_usage) {
        {
#line 6501
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
                (double )local_service_demand, local_cpu_method);
        }
      } else {
        {
#line 6507
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
                (double )remote_service_demand, local_cpu_method);
        }
      }
#line 6512
      goto switch_break;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
#line 6515
      if (print_headers) {
        {
#line 6516
        tmp = format_units();
#line 6516
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_title,
                tmp, local_cpu_method, remote_cpu_method);
        }
      }
      {
#line 6523
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_1,
              lss_size, send_size, (double )elapsed_time, local_send_calls, failed_sends,
              local_send_thruput, (double )local_cpu_utilization, (double )local_service_demand,
              rsr_size, (double )elapsed_time, remote_receive_calls, remote_recv_thruput,
              (double )remote_cpu_utilization, (double )remote_service_demand);
      }
#line 6539
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 6545
      if (verbosity == 0) {
#line 6545
        goto case_0___0;
      }
#line 6551
      if (verbosity == 2) {
#line 6551
        goto case_2___0;
      }
#line 6551
      if (verbosity == 1) {
#line 6551
        goto case_2___0;
      }
#line 6544
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 6546
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_0,
              local_send_thruput);
      }
#line 6549
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
#line 6552
      if (print_headers) {
        {
#line 6553
        tmp___0 = format_units();
#line 6553
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_title,
                tmp___0);
        }
      }
      {
#line 6555
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_1,
              lss_size, send_size, (double )elapsed_time, local_send_calls, failed_sends,
              local_send_thruput, rsr_size, (double )elapsed_time, remote_receive_calls,
              remote_recv_thruput);
      }
#line 6567
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    {
#line 6577
    fflush(where);
    }
  }
#line 6579
  return;
}
}
#line 6581 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void send_udp_rr(char *remote_host ) 
{ 
  char *tput_title ;
  char *tput_title_band ;
  char *tput_fmt_0 ;
  char *tput_fmt_1_line_1 ;
  char *tput_fmt_1_line_2 ;
  char *cpu_title ;
  char *cpu_title_tput ;
  char *cpu_fmt_0 ;
  char *cpu_fmt_1_line_1 ;
  char *cpu_fmt_1_line_2 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 6585
  tput_title = (char *)"Local /Remote\nSocket Size   Request  Resp.   Elapsed  Trans.\nSend   Recv   Size     Size    Time     Rate         \nbytes  Bytes  bytes    bytes   secs.    per sec   \n\n";
#line 6591
  tput_title_band = (char *)"Local /Remote\nSocket Size   Request  Resp.   Elapsed  \nSend   Recv   Size     Size    Time     Throughput \nbytes  Bytes  bytes    bytes   secs.    %s/sec   \n\n";
#line 6597
  tput_fmt_0 = (char *)"%7.2f %s\n";
#line 6600
  tput_fmt_1_line_1 = (char *)"%-6d %-6d %-6d   %-6d  %-6.2f   %7.2f   %s\n";
#line 6603
  tput_fmt_1_line_2 = (char *)"%-6d %-6d\n";
#line 6606
  cpu_title = (char *)"Local /Remote\nSocket Size   Request Resp.  Elapsed Trans.   CPU    CPU    S.dem   S.dem\nSend   Recv   Size    Size   Time    Rate     local  remote local   remote\nbytes  bytes  bytes   bytes  secs.   per sec  %% %c    %% %c    us/Tr   us/Tr\n\n";
#line 6612
  cpu_title_tput = (char *)"Local /Remote\nSocket Size   Request Resp.  Elapsed Tput     CPU    CPU    S.dem   S.dem\nSend   Recv   Size    Size   Time    %-8.8s local  remote local   remote\nbytes  bytes  bytes   bytes  secs.   per sec  %% %c    %% %c    us/KB   us/KB\n\n";
#line 6618
  cpu_fmt_0 = (char *)"%6.3f %c %s\n";
#line 6621
  cpu_fmt_1_line_1 = (char *)"%-6d %-6d %-6d  %-6d %-6.2f  %-6.2f   %-6.2f %-6.2f %-6.3f  %-6.3f %s\n";
#line 6624
  cpu_fmt_1_line_2 = (char *)"%-6d %-6d\n";
#line 6627
  send_omni_inner(remote_host, (unsigned int )legacy, (char *)"MIGRATED UDP REQUEST/RESPONSE TEST");
  }
#line 6629
  if (legacy) {
#line 6639
    if (confidence < (double )0) {
#line 6641
      if (iteration_max > 1) {
        {
#line 6642
        display_confidence();
        }
      }
    }
#line 6646
    if (local_cpu_usage) {
#line 6646
      goto _L;
    } else
#line 6646
    if (remote_cpu_usage) {
      _L: /* CIL Label */ 
      {
#line 6649
      if (verbosity == 0) {
#line 6649
        goto case_0;
      }
#line 6670
      if (verbosity == 2) {
#line 6670
        goto case_2;
      }
#line 6670
      if (verbosity == 1) {
#line 6670
        goto case_2;
      }
#line 6648
      goto switch_break;
      case_0: /* CIL Label */ 
#line 6650
      if (local_cpu_usage) {
#line 6651
        if (print_headers) {
#line 6651
          tmp = "";
        } else
#line 6651
        if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 6651
          tmp = "";
        } else {
#line 6651
          tmp = (char const   *)result_brand;
        }
        {
#line 6651
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
                (double )local_service_demand, local_cpu_method, tmp);
        }
      } else {
#line 6660
        if (print_headers) {
#line 6660
          tmp___0 = "";
        } else
#line 6660
        if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 6660
          tmp___0 = "";
        } else {
#line 6660
          tmp___0 = (char const   *)result_brand;
        }
        {
#line 6660
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
                (double )remote_service_demand, remote_cpu_method, tmp___0);
        }
      }
#line 6668
      goto switch_break;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
#line 6671
      if (print_headers) {
#line 6672
        if (120 == (int )libfmt) {
          {
#line 6673
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_title,
                  local_cpu_method, remote_cpu_method);
          }
        } else {
          {
#line 6679
          tmp___1 = format_units();
#line 6679
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_title_tput,
                  tmp___1, local_cpu_method, remote_cpu_method);
          }
        }
      }
#line 6687
      if (print_headers) {
#line 6687
        tmp___2 = "";
      } else
#line 6687
      if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 6687
        tmp___2 = "";
      } else {
#line 6687
        tmp___2 = (char const   *)result_brand;
      }
      {
#line 6687
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_1_line_1,
              lss_size, lsr_size, req_size, rsp_size, (double )elapsed_time, thruput,
              (double )local_cpu_utilization, (double )remote_cpu_utilization, (double )local_service_demand,
              (double )remote_service_demand, tmp___2);
#line 6701
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_1_line_2,
              rss_size, rsr_size);
      }
#line 6705
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 6711
      if (verbosity == 0) {
#line 6711
        goto case_0___0;
      }
#line 6719
      if (verbosity == 2) {
#line 6719
        goto case_2___0;
      }
#line 6719
      if (verbosity == 1) {
#line 6719
        goto case_2___0;
      }
#line 6710
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 6712
      if (print_headers) {
#line 6712
        tmp___3 = "";
      } else
#line 6712
      if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 6712
        tmp___3 = "";
      } else {
#line 6712
        tmp___3 = (char const   *)result_brand;
      }
      {
#line 6712
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_0,
              thruput, tmp___3);
      }
#line 6717
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
#line 6720
      if (print_headers) {
        {
#line 6721
        tmp___4 = format_units();
        }
#line 6721
        if (120 == (int )libfmt) {
#line 6721
          tmp___5 = tput_title;
        } else {
#line 6721
          tmp___5 = tput_title_band;
        }
        {
#line 6721
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tmp___5,
                tmp___4);
        }
      }
#line 6726
      if (print_headers) {
#line 6726
        tmp___6 = "";
      } else
#line 6726
      if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 6726
        tmp___6 = "";
      } else {
#line 6726
        tmp___6 = (char const   *)result_brand;
      }
      {
#line 6726
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_1_line_1,
              lss_size, lsr_size, req_size, rsp_size, (double )elapsed_time, thruput,
              tmp___6);
#line 6736
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_1_line_2,
              rss_size, rsr_size);
      }
#line 6741
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    {
#line 6765
    fflush(where);
    }
  }
#line 6767
  return;
}
}
#line 6775 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void set_omni_defaults_by_legacy_testname(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 6779
  protocol = 6;
#line 6780
  socket_type = 1;
#line 6781
  connection_test = 0;
#line 6782
  rsp_size = -1;
#line 6782
  req_size = rsp_size;
#line 6783
  was_legacy = 1;
#line 6784
  legacy = 1;
#line 6785
  implicit_direction = 0;
#line 6787
  tmp___6 = strcasecmp((char const   *)(test_name), "TCP_STREAM");
  }
#line 6787
  if (tmp___6 == 0) {
#line 6788
    direction = 2;
  } else {
    {
#line 6790
    tmp___5 = strcasecmp((char const   *)(test_name), "TCP_MAERTS");
    }
#line 6790
    if (tmp___5 == 0) {
#line 6791
      direction = 4;
    } else {
      {
#line 6793
      tmp___4 = strcasecmp((char const   *)(test_name), "TCP_RR");
      }
#line 6793
      if (tmp___4 == 0) {
#line 6794
        rsp_size = 1;
#line 6794
        req_size = rsp_size;
#line 6795
        direction = 0;
#line 6796
        direction |= 2;
#line 6797
        direction |= 4;
      } else {
        {
#line 6799
        tmp___3 = strcasecmp((char const   *)(test_name), "UDP_STREAM");
        }
#line 6799
        if (tmp___3 == 0) {
#line 6800
          protocol = 17;
#line 6801
          socket_type = 2;
        } else {
          {
#line 6803
          tmp___2 = strcasecmp((char const   *)(test_name), "UDP_RR");
          }
#line 6803
          if (tmp___2 == 0) {
#line 6804
            protocol = 17;
#line 6805
            socket_type = 2;
#line 6806
            direction = 0;
#line 6807
            direction |= 2;
#line 6808
            direction |= 4;
#line 6809
            rsp_size = 1;
#line 6809
            req_size = rsp_size;
          } else {
            {
#line 6811
            tmp___1 = strcasecmp((char const   *)(test_name), "TCP_CC");
            }
#line 6811
            if (tmp___1 == 0) {
#line 6812
              direction = 0;
#line 6813
              connection_test = 1;
            } else {
              {
#line 6815
              tmp___0 = strcasecmp((char const   *)(test_name), "TCP_CRR");
              }
#line 6815
              if (tmp___0 == 0) {
#line 6816
                direction = 0;
#line 6817
                direction |= 2;
#line 6818
                direction |= 4;
#line 6819
                rsp_size = 1;
#line 6819
                req_size = rsp_size;
#line 6820
                connection_test = 1;
              } else {
                {
#line 6822
                tmp = strcasecmp((char const   *)(test_name), "omni");
                }
#line 6822
                if (tmp == 0) {
#line 6824
                  was_legacy = 0;
#line 6825
                  legacy = 0;
#line 6826
                  implicit_direction = 1;
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 6828
  socket_type_str = hst_to_str(socket_type);
  }
#line 6829
  return;
}
}
#line 6831 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
char omni_usage[3053]  = 
#line 6831
  {      (char )'\n',      (char )'U',      (char )'s',      (char )'a', 
        (char )'g',      (char )'e',      (char )':',      (char )' ', 
        (char )'n',      (char )'e',      (char )'t',      (char )'p', 
        (char )'e',      (char )'r',      (char )'f',      (char )' ', 
        (char )'[',      (char )'g',      (char )'l',      (char )'o', 
        (char )'b',      (char )'a',      (char )'l',      (char )' ', 
        (char )'o',      (char )'p',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'s',      (char )']', 
        (char )' ',      (char )'-',      (char )'-',      (char )' ', 
        (char )'[',      (char )'t',      (char )'e',      (char )'s', 
        (char )'t',      (char )' ',      (char )'o',      (char )'p', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'s',      (char )']',      (char )' ',      (char )'\n', 
        (char )'\n',      (char )'O',      (char )'M',      (char )'N', 
        (char )'I',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'M',      (char )'i', 
        (char )'g',      (char )'r',      (char )'a',      (char )'t', 
        (char )'e',      (char )'d',      (char )' ',      (char )'B', 
        (char )'S',      (char )'D',      (char )' ',      (char )'S', 
        (char )'o',      (char )'c',      (char )'k',      (char )'e', 
        (char )'t',      (char )'s',      (char )' ',      (char )'T', 
        (char )'e',      (char )'s',      (char )'t',      (char )' ', 
        (char )'O',      (char )'p',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'s',      (char )':', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'b',      (char )' ', 
        (char )'n',      (char )'u',      (char )'m',      (char )'b', 
        (char )'e',      (char )'r',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'S', 
        (char )'e',      (char )'n',      (char )'d',      (char )' ', 
        (char )'n',      (char )'u',      (char )'m',      (char )'b', 
        (char )'e',      (char )'r',      (char )' ',      (char )'r', 
        (char )'e',      (char )'q',      (char )'u',      (char )'e', 
        (char )'s',      (char )'t',      (char )'s',      (char )' ', 
        (char )'a',      (char )'t',      (char )' ',      (char )'s', 
        (char )'t',      (char )'a',      (char )'r',      (char )'t', 
        (char )' ',      (char )'o',      (char )'f',      (char )' ', 
        (char )'_',      (char )'R',      (char )'R',      (char )' ', 
        (char )'t',      (char )'e',      (char )'s',      (char )'t', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'c', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'E',      (char )'x',      (char )'p',      (char )'l', 
        (char )'i',      (char )'c',      (char )'i',      (char )'t', 
        (char )'l',      (char )'y',      (char )' ',      (char )'d', 
        (char )'e',      (char )'c',      (char )'l',      (char )'a', 
        (char )'r',      (char )'e',      (char )' ',      (char )'t', 
        (char )'h',      (char )'i',      (char )'s',      (char )' ', 
        (char )'a',      (char )' ',      (char )'c',      (char )'o', 
        (char )'n',      (char )'n',      (char )'e',      (char )'c', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'t',      (char )'e',      (char )'s', 
        (char )'t',      (char )' ',      (char )'s',      (char )'u', 
        (char )'c',      (char )'h',      (char )' ',      (char )'a', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'T',      (char )'C',      (char )'P',      (char )'_', 
        (char )'C',      (char )'R',      (char )'R',      (char )' ', 
        (char )'o',      (char )'r',      (char )' ',      (char )'T', 
        (char )'C',      (char )'P',      (char )'_',      (char )'C', 
        (char )'C',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'C', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'S',      (char )'e',      (char )'t',      (char )' ', 
        (char )'T',      (char )'C',      (char )'P',      (char )'_', 
        (char )'C',      (char )'O',      (char )'R',      (char )'K', 
        (char )' ',      (char )'w',      (char )'h',      (char )'e', 
        (char )'n',      (char )' ',      (char )'a',      (char )'v', 
        (char )'a',      (char )'i',      (char )'l',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'d',      (char )' ',      (char )'d', 
        (char )'i',      (char )'r',      (char )'e',      (char )'c', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'E',      (char )'x', 
        (char )'p',      (char )'l',      (char )'i',      (char )'c', 
        (char )'i',      (char )'t',      (char )'l',      (char )'y', 
        (char )' ',      (char )'s',      (char )'e',      (char )'t', 
        (char )' ',      (char )'t',      (char )'e',      (char )'s', 
        (char )'t',      (char )' ',      (char )'d',      (char )'i', 
        (char )'r',      (char )'e',      (char )'c',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )' ', 
        (char )'b',      (char )'a',      (char )'s',      (char )'e', 
        (char )'d',      (char )' ',      (char )'o',      (char )'n', 
        (char )' ',      (char )'b',      (char )'i',      (char )'t', 
        (char )'w',      (char )'i',      (char )'s',      (char )'e', 
        (char )' ',      (char )'O',      (char )'R',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'0',      (char )'x',      (char )'2', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )' ',      (char )'t',      (char )'r',      (char )'a', 
        (char )'n',      (char )'s',      (char )'m',      (char )'i', 
        (char )'t',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'0',      (char )'x', 
        (char )'4',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )' ',      (char )'r',      (char )'e', 
        (char )'c',      (char )'e',      (char )'i',      (char )'v', 
        (char )'e',      (char )'.',      (char )' ',      (char )'D', 
        (char )'e',      (char )'f',      (char )'a',      (char )'u', 
        (char )'l',      (char )'t',      (char )':',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'b',      (char )'a', 
        (char )'s',      (char )'e',      (char )'d',      (char )' ', 
        (char )'o',      (char )'n',      (char )' ',      (char )'t', 
        (char )'e',      (char )'s',      (char )'t',      (char )' ', 
        (char )'t',      (char )'y',      (char )'p',      (char )'e', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'D',      (char )' ', 
        (char )'[',      (char )'L',      (char )']',      (char )'[', 
        (char )',',      (char )'R',      (char )']',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'S', 
        (char )'e',      (char )'t',      (char )' ',      (char )'T', 
        (char )'C',      (char )'P',      (char )'_',      (char )'N', 
        (char )'O',      (char )'D',      (char )'E',      (char )'L', 
        (char )'A',      (char )'Y',      (char )' ',      (char )'l', 
        (char )'o',      (char )'c',      (char )'a',      (char )'l', 
        (char )'l',      (char )'y',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )'/',      (char )'o', 
        (char )'r',      (char )' ',      (char )'r',      (char )'e', 
        (char )'m',      (char )'o',      (char )'t',      (char )'e', 
        (char )'l',      (char )'y',      (char )' ',      (char )'(', 
        (char )'T',      (char )'C',      (char )'P',      (char )'_', 
        (char )'*',      (char )')',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'h',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'D',      (char )'i',      (char )'s', 
        (char )'p',      (char )'l',      (char )'a',      (char )'y', 
        (char )' ',      (char )'t',      (char )'h',      (char )'i', 
        (char )'s',      (char )' ',      (char )'t',      (char )'e', 
        (char )'x',      (char )'t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'H',      (char )' ',      (char )'n',      (char )'a', 
        (char )'m',      (char )'e',      (char )'[',      (char )'/', 
        (char )'m',      (char )'a',      (char )'s',      (char )'k', 
        (char )']',      (char )',',      (char )'f',      (char )'a', 
        (char )'m',      (char )' ',      (char )' ',      (char )'U', 
        (char )'s',      (char )'e',      (char )' ',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )' ', 
        (char )'(',      (char )'o',      (char )'r',      (char )' ', 
        (char )'I',      (char )'P',      (char )')',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'f',      (char )'a',      (char )'m',      (char )'i', 
        (char )'l',      (char )'y',      (char )' ',      (char )'a', 
        (char )'s',      (char )' ',      (char )'t',      (char )'a', 
        (char )'r',      (char )'g',      (char )'e',      (char )'t', 
        (char )' ',      (char )'o',      (char )'f',      (char )' ', 
        (char )'d',      (char )'a',      (char )'t',      (char )'a', 
        (char )' ',      (char )'c',      (char )'o',      (char )'n', 
        (char )'n',      (char )'e',      (char )'c',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'A',      (char )' ', 
        (char )'m',      (char )'a',      (char )'s',      (char )'k', 
        (char )' ',      (char )'v',      (char )'a',      (char )'l', 
        (char )'u',      (char )'e',      (char )' ',      (char )'w', 
        (char )'i',      (char )'l',      (char )'l',      (char )' ', 
        (char )'c',      (char )'a',      (char )'u',      (char )'s', 
        (char )'e',      (char )' ',      (char )'r',      (char )'a', 
        (char )'n',      (char )'d',      (char )'o',      (char )'m', 
        (char )'i',      (char )'z',      (char )'a',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'I', 
        (char )'P',      (char )' ',      (char )'u',      (char )'s', 
        (char )'e',      (char )'d',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'k',      (char )' ',      (char )'[',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )']', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'G',      (char )'e',      (char )'n', 
        (char )'e',      (char )'r',      (char )'a',      (char )'t', 
        (char )'e',      (char )' ',      (char )'k',      (char )'e', 
        (char )'y',      (char )'v',      (char )'a',      (char )'l', 
        (char )' ',      (char )'o',      (char )'u',      (char )'t', 
        (char )'p',      (char )'u',      (char )'t',      (char )' ', 
        (char )'o',      (char )'p',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'a',      (char )'l', 
        (char )'l',      (char )'y',      (char )' ',      (char )'b', 
        (char )'a',      (char )'s',      (char )'e',      (char )'d', 
        (char )' ',      (char )'o',      (char )'n',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'U', 
        (char )'s',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'\'', 
        (char )'?',      (char )'\'',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'g',      (char )'e', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'l',      (char )'i', 
        (char )'s',      (char )'t',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'c',      (char )'h', 
        (char )'o',      (char )'i',      (char )'c',      (char )'e', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'K', 
        (char )' ',      (char )'l',      (char )'o',      (char )'c', 
        (char )'[',      (char )',',      (char )'r',      (char )'e', 
        (char )'m',      (char )']',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'S',      (char )'e',      (char )'t',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'l',      (char )'o',      (char )'c',      (char )'a', 
        (char )'l',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )'/',      (char )'o',      (char )'r', 
        (char )' ',      (char )'r',      (char )'e',      (char )'m', 
        (char )'o',      (char )'t',      (char )'e',      (char )' ', 
        (char )'c',      (char )'o',      (char )'n',      (char )'g', 
        (char )'e',      (char )'s',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'c', 
        (char )'o',      (char )'n',      (char )'t',      (char )'r', 
        (char )'o',      (char )'l',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'a',      (char )'l',      (char )'g', 
        (char )'o',      (char )'r',      (char )'i',      (char )'t', 
        (char )'h',      (char )'m',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'u',      (char )'s', 
        (char )'e',      (char )' ',      (char )'o',      (char )'n', 
        (char )' ',      (char )'t',      (char )'h',      (char )'o', 
        (char )'s',      (char )'e',      (char )' ',      (char )'p', 
        (char )'l',      (char )'a',      (char )'t',      (char )'f', 
        (char )'o',      (char )'r',      (char )'m',      (char )'s', 
        (char )' ',      (char )'w',      (char )'h',      (char )'e', 
        (char )'r',      (char )'e',      (char )' ',      (char )'i', 
        (char )'t',      (char )' ',      (char )'c',      (char )'a', 
        (char )'n',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'b',      (char )'e',      (char )' ',      (char )'s', 
        (char )'e',      (char )'t',      (char )'.',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'L',      (char )' ',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'[', 
        (char )'/',      (char )'m',      (char )'a',      (char )'s', 
        (char )'k',      (char )']',      (char )',',      (char )'f', 
        (char )'a',      (char )'m',      (char )' ',      (char )' ', 
        (char )'U',      (char )'s',      (char )'e',      (char )' ', 
        (char )'n',      (char )'a',      (char )'m',      (char )'e', 
        (char )' ',      (char )'(',      (char )'o',      (char )'r', 
        (char )' ',      (char )'I',      (char )'P',      (char )')', 
        (char )' ',      (char )'a',      (char )'n',      (char )'d', 
        (char )' ',      (char )'f',      (char )'a',      (char )'m', 
        (char )'i',      (char )'l',      (char )'y',      (char )' ', 
        (char )'a',      (char )'s',      (char )' ',      (char )'s', 
        (char )'o',      (char )'u',      (char )'r',      (char )'c', 
        (char )'e',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'d',      (char )'a',      (char )'t', 
        (char )'a',      (char )' ',      (char )'c',      (char )'o', 
        (char )'n',      (char )'n',      (char )'e',      (char )'c', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'A', 
        (char )' ',      (char )'m',      (char )'a',      (char )'s', 
        (char )'k',      (char )' ',      (char )'v',      (char )'a', 
        (char )'l',      (char )'u',      (char )'e',      (char )' ', 
        (char )'w',      (char )'i',      (char )'l',      (char )'l', 
        (char )' ',      (char )'c',      (char )'a',      (char )'u', 
        (char )'s',      (char )'e',      (char )' ',      (char )'r', 
        (char )'a',      (char )'n',      (char )'d',      (char )'o', 
        (char )'m',      (char )'i',      (char )'z',      (char )'a', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'o',      (char )'f',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'I',      (char )'P',      (char )' ',      (char )'u', 
        (char )'s',      (char )'e',      (char )'d',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'m',      (char )' ',      (char )'b', 
        (char )'y',      (char )'t',      (char )'e',      (char )'s', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'S',      (char )'e', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'s',      (char )'e', 
        (char )'n',      (char )'d',      (char )' ',      (char )'s', 
        (char )'i',      (char )'z',      (char )'e',      (char )' ', 
        (char )'(',      (char )'T',      (char )'C',      (char )'P', 
        (char )'_',      (char )'S',      (char )'T',      (char )'R', 
        (char )'E',      (char )'A',      (char )'M',      (char )',', 
        (char )' ',      (char )'U',      (char )'D',      (char )'P', 
        (char )'_',      (char )'S',      (char )'T',      (char )'R', 
        (char )'E',      (char )'A',      (char )'M',      (char )')', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'M',      (char )' ', 
        (char )'b',      (char )'y',      (char )'t',      (char )'e', 
        (char )'s',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'S', 
        (char )'e',      (char )'t',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'r', 
        (char )'e',      (char )'c',      (char )'v',      (char )' ', 
        (char )'s',      (char )'i',      (char )'z',      (char )'e', 
        (char )' ',      (char )'(',      (char )'T',      (char )'C', 
        (char )'P',      (char )'_',      (char )'S',      (char )'T', 
        (char )'R',      (char )'E',      (char )'A',      (char )'M', 
        (char )',',      (char )' ',      (char )'U',      (char )'D', 
        (char )'P',      (char )'_',      (char )'S',      (char )'T', 
        (char )'R',      (char )'E',      (char )'A',      (char )'M', 
        (char )')',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'U',      (char )'s',      (char )'e',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'c',      (char )'o',      (char )'n',      (char )'n', 
        (char )'e',      (char )'c',      (char )'t',      (char )'e', 
        (char )'d',      (char )' ',      (char )'s',      (char )'o', 
        (char )'c',      (char )'k',      (char )'e',      (char )'t', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )' ',      (char )'U',      (char )'D',      (char )'P', 
        (char )' ',      (char )'l',      (char )'o',      (char )'c', 
        (char )'a',      (char )'l',      (char )'l',      (char )'y', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'N',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'U', 
        (char )'s',      (char )'e',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'c', 
        (char )'o',      (char )'n',      (char )'n',      (char )'e', 
        (char )'c',      (char )'t',      (char )'e',      (char )'d', 
        (char )' ',      (char )'s',      (char )'o',      (char )'c', 
        (char )'k',      (char )'e',      (char )'t',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )' ', 
        (char )'U',      (char )'D',      (char )'P',      (char )' ', 
        (char )'r',      (char )'e',      (char )'m',      (char )'o', 
        (char )'t',      (char )'e',      (char )'l',      (char )'y', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'o',      (char )' ', 
        (char )'[',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )']',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'G', 
        (char )'e',      (char )'n',      (char )'e',      (char )'r', 
        (char )'a',      (char )'t',      (char )'e',      (char )' ', 
        (char )'C',      (char )'S',      (char )'V',      (char )' ', 
        (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )' ',      (char )'o', 
        (char )'p',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )'a',      (char )'l',      (char )'l', 
        (char )'y',      (char )' ',      (char )'b',      (char )'a', 
        (char )'s',      (char )'e',      (char )'d',      (char )' ', 
        (char )'o',      (char )'n',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'U',      (char )'s', 
        (char )'e',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'n',      (char )'a', 
        (char )'m',      (char )'e',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'\'',      (char )'?', 
        (char )'\'',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'g',      (char )'e',      (char )'t', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'l',      (char )'i',      (char )'s', 
        (char )'t',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'c',      (char )'h',      (char )'o', 
        (char )'i',      (char )'c',      (char )'e',      (char )'s', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'O',      (char )' ', 
        (char )'[',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )']',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'G', 
        (char )'e',      (char )'n',      (char )'e',      (char )'r', 
        (char )'a',      (char )'t',      (char )'e',      (char )' ', 
        (char )'c',      (char )'l',      (char )'a',      (char )'s', 
        (char )'s',      (char )'i',      (char )'c',      (char )'-', 
        (char )'s',      (char )'t',      (char )'y',      (char )'l', 
        (char )'e',      (char )' ',      (char )'o',      (char )'u', 
        (char )'t',      (char )'p',      (char )'u',      (char )'t', 
        (char )' ',      (char )'b',      (char )'a',      (char )'s', 
        (char )'e',      (char )'d',      (char )' ',      (char )'o', 
        (char )'n',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'U',      (char )'s',      (char )'e', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'\'',      (char )'?',      (char )'\'', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'g',      (char )'e',      (char )'t',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )' ',      (char )'o',      (char )'f',      (char )' ', 
        (char )'c',      (char )'h',      (char )'o',      (char )'i', 
        (char )'c',      (char )'e',      (char )'s',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'p',      (char )' ',      (char )'m', 
        (char )'i',      (char )'n',      (char )'[',      (char )',', 
        (char )'m',      (char )'a',      (char )'x',      (char )']', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'S',      (char )'e', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'m',      (char )'i', 
        (char )'n',      (char )'/',      (char )'m',      (char )'a', 
        (char )'x',      (char )' ',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )' ',      (char )'n', 
        (char )'u',      (char )'m',      (char )'b',      (char )'e', 
        (char )'r',      (char )'s',      (char )' ',      (char )'f', 
        (char )'o',      (char )'r',      (char )' ',      (char )'T', 
        (char )'C',      (char )'P',      (char )'_',      (char )'C', 
        (char )'R',      (char )'R',      (char )',',      (char )' ', 
        (char )'T',      (char )'C',      (char )'P',      (char )'_', 
        (char )'T',      (char )'R',      (char )'R',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'P',      (char )' ',      (char )'l', 
        (char )'o',      (char )'c',      (char )'a',      (char )'l', 
        (char )'[',      (char )',',      (char )'r',      (char )'e', 
        (char )'m',      (char )'o',      (char )'t',      (char )'e', 
        (char )']',      (char )' ',      (char )'S',      (char )'e', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'l',      (char )'o', 
        (char )'c',      (char )'a',      (char )'l',      (char )'/', 
        (char )'r',      (char )'e',      (char )'m',      (char )'o', 
        (char )'t',      (char )'e',      (char )' ',      (char )'p', 
        (char )'o',      (char )'r',      (char )'t',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'d',      (char )'a',      (char )'t',      (char )'a', 
        (char )' ',      (char )'s',      (char )'o',      (char )'c', 
        (char )'k',      (char )'e',      (char )'t',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'r',      (char )' ',      (char )'r', 
        (char )'e',      (char )'q',      (char )',',      (char )'[', 
        (char )'r',      (char )'s',      (char )'p',      (char )']', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'S',      (char )'e', 
        (char )'t',      (char )' ',      (char )'r',      (char )'e', 
        (char )'q',      (char )'u',      (char )'e',      (char )'s', 
        (char )'t',      (char )'/',      (char )'r',      (char )'e', 
        (char )'s',      (char )'p',      (char )'o',      (char )'n', 
        (char )'s',      (char )'e',      (char )' ',      (char )'s', 
        (char )'i',      (char )'z',      (char )'e',      (char )'s', 
        (char )' ',      (char )'(',      (char )'T',      (char )'C', 
        (char )'P',      (char )'_',      (char )'R',      (char )'R', 
        (char )',',      (char )' ',      (char )'U',      (char )'D', 
        (char )'P',      (char )'_',      (char )'R',      (char )'R', 
        (char )')',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'R', 
        (char )' ',      (char )'0',      (char )'/',      (char )'1', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'A',      (char )'l',      (char )'l',      (char )'o', 
        (char )'w',      (char )' ',      (char )'r',      (char )'o', 
        (char )'u',      (char )'t',      (char )'i',      (char )'n', 
        (char )'g',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'t',      (char )'r',      (char )'a', 
        (char )'f',      (char )'f',      (char )'i',      (char )'c', 
        (char )' ',      (char )'o',      (char )'n',      (char )' ', 
        (char )'d',      (char )'a',      (char )'t',      (char )'a', 
        (char )' ',      (char )'c',      (char )'o',      (char )'n', 
        (char )'n',      (char )'e',      (char )'c',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )'.', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'D', 
        (char )'e',      (char )'f',      (char )'a',      (char )'u', 
        (char )'l',      (char )'t',      (char )':',      (char )' ', 
        (char )'0',      (char )' ',      (char )'(',      (char )'o', 
        (char )'f',      (char )'f',      (char )')',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )' ', 
        (char )'U',      (char )'D',      (char )'P',      (char )'_', 
        (char )'S',      (char )'T',      (char )'R',      (char )'E', 
        (char )'A',      (char )'M',      (char )',',      (char )' ', 
        (char )'1',      (char )' ',      (char )'(',      (char )'o', 
        (char )'n',      (char )')',      (char )' ',      (char )'o', 
        (char )'t',      (char )'h',      (char )'e',      (char )'r', 
        (char )'w',      (char )'i',      (char )'s',      (char )'e', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'s',      (char )' ', 
        (char )'s',      (char )'e',      (char )'n',      (char )'d', 
        (char )'[',      (char )',',      (char )'r',      (char )'e', 
        (char )'c',      (char )'v',      (char )']',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'S', 
        (char )'e',      (char )'t',      (char )' ',      (char )'l', 
        (char )'o',      (char )'c',      (char )'a',      (char )'l', 
        (char )' ',      (char )'s',      (char )'o',      (char )'c', 
        (char )'k',      (char )'e',      (char )'t',      (char )' ', 
        (char )'s',      (char )'e',      (char )'n',      (char )'d', 
        (char )'/',      (char )'r',      (char )'e',      (char )'c', 
        (char )'v',      (char )' ',      (char )'b',      (char )'u', 
        (char )'f',      (char )'f',      (char )'e',      (char )'r', 
        (char )' ',      (char )'s',      (char )'i',      (char )'z', 
        (char )'e',      (char )'s',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'S',      (char )' ',      (char )'s',      (char )'e', 
        (char )'n',      (char )'d',      (char )'[',      (char )',', 
        (char )'r',      (char )'e',      (char )'c',      (char )'v', 
        (char )']',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'S',      (char )'e',      (char )'t', 
        (char )' ',      (char )'r',      (char )'e',      (char )'m', 
        (char )'o',      (char )'t',      (char )'e',      (char )' ', 
        (char )'s',      (char )'o',      (char )'c',      (char )'k', 
        (char )'e',      (char )'t',      (char )' ',      (char )'s', 
        (char )'e',      (char )'n',      (char )'d',      (char )'/', 
        (char )'r',      (char )'e',      (char )'c',      (char )'v', 
        (char )' ',      (char )'b',      (char )'u',      (char )'f', 
        (char )'f',      (char )'e',      (char )'r',      (char )' ', 
        (char )'s',      (char )'i',      (char )'z',      (char )'e', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'t', 
        (char )' ',      (char )'t',      (char )'y',      (char )'p', 
        (char )'e',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'E',      (char )'x',      (char )'p',      (char )'l', 
        (char )'i',      (char )'c',      (char )'i',      (char )'t', 
        (char )'l',      (char )'y',      (char )' ',      (char )'s', 
        (char )'e',      (char )'t',      (char )' ',      (char )'s', 
        (char )'o',      (char )'c',      (char )'k',      (char )'e', 
        (char )'t',      (char )' ',      (char )'t',      (char )'y', 
        (char )'p',      (char )'e',      (char )'.',      (char )' ', 
        (char )'D',      (char )'e',      (char )'f',      (char )'a', 
        (char )'u',      (char )'l',      (char )'t',      (char )' ', 
        (char )'i',      (char )'s',      (char )' ',      (char )'i', 
        (char )'m',      (char )'p',      (char )'l',      (char )'i', 
        (char )'c',      (char )'i',      (char )'t',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'b',      (char )'a', 
        (char )'s',      (char )'e',      (char )'d',      (char )' ', 
        (char )'o',      (char )'n',      (char )' ',      (char )'o', 
        (char )'t',      (char )'h',      (char )'e',      (char )'r', 
        (char )' ',      (char )'s',      (char )'e',      (char )'t', 
        (char )'t',      (char )'i',      (char )'n',      (char )'g', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'T', 
        (char )' ',      (char )'p',      (char )'r',      (char )'o', 
        (char )'t',      (char )'o',      (char )'c',      (char )'o', 
        (char )'l',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'E',      (char )'x',      (char )'p',      (char )'l', 
        (char )'i',      (char )'c',      (char )'i',      (char )'t', 
        (char )'l',      (char )'y',      (char )' ',      (char )'s', 
        (char )'e',      (char )'t',      (char )' ',      (char )'d', 
        (char )'a',      (char )'t',      (char )'a',      (char )' ', 
        (char )'c',      (char )'o',      (char )'n',      (char )'n', 
        (char )'e',      (char )'c',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'p', 
        (char )'r',      (char )'o',      (char )'t',      (char )'o', 
        (char )'c',      (char )'o',      (char )'l',      (char )'.', 
        (char )' ',      (char )'D',      (char )'e',      (char )'f', 
        (char )'a',      (char )'u',      (char )'l',      (char )'t', 
        (char )' ',      (char )'i',      (char )'s',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'i',      (char )'m', 
        (char )'p',      (char )'l',      (char )'i',      (char )'c', 
        (char )'i',      (char )'t',      (char )' ',      (char )'b', 
        (char )'a',      (char )'s',      (char )'e',      (char )'d', 
        (char )' ',      (char )'o',      (char )'n',      (char )' ', 
        (char )'o',      (char )'t',      (char )'h',      (char )'e', 
        (char )'r',      (char )' ',      (char )'s',      (char )'e', 
        (char )'t',      (char )'t',      (char )'i',      (char )'n', 
        (char )'g',      (char )'s',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'u',      (char )' ',      (char )'u',      (char )'u', 
        (char )'i',      (char )'d',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'U',      (char )'s',      (char )'e', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'s',      (char )'u',      (char )'p', 
        (char )'p',      (char )'l',      (char )'i',      (char )'e', 
        (char )'d',      (char )' ',      (char )'s',      (char )'t', 
        (char )'r',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'a',      (char )'s',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'U',      (char )'U',      (char )'I',      (char )'D', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )' ',      (char )'t',      (char )'h',      (char )'i', 
        (char )'s',      (char )' ',      (char )'t',      (char )'e', 
        (char )'s',      (char )'t',      (char )'.',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'4',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'U',      (char )'s', 
        (char )'e',      (char )' ',      (char )'A',      (char )'F', 
        (char )'_',      (char )'I',      (char )'N',      (char )'E', 
        (char )'T',      (char )' ',      (char )'(',      (char )'e', 
        (char )'g',      (char )' ',      (char )'I',      (char )'P', 
        (char )'v',      (char )'4',      (char )')',      (char )' ', 
        (char )'o',      (char )'n',      (char )' ',      (char )'b', 
        (char )'o',      (char )'t',      (char )'h',      (char )' ', 
        (char )'e',      (char )'n',      (char )'d',      (char )'s', 
        (char )' ',      (char )'o',      (char )'f',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'d',      (char )'a',      (char )'t',      (char )'a', 
        (char )' ',      (char )'c',      (char )'o',      (char )'n', 
        (char )'n',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'6', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'U',      (char )'s',      (char )'e',      (char )' ', 
        (char )'A',      (char )'F',      (char )'_',      (char )'I', 
        (char )'N',      (char )'E',      (char )'T',      (char )'6', 
        (char )' ',      (char )'(',      (char )'e',      (char )'g', 
        (char )' ',      (char )'I',      (char )'P',      (char )'v', 
        (char )'6',      (char )')',      (char )' ',      (char )'o', 
        (char )'n',      (char )' ',      (char )'b',      (char )'o', 
        (char )'t',      (char )'h',      (char )' ',      (char )'e', 
        (char )'n',      (char )'d',      (char )'s',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'d', 
        (char )'a',      (char )'t',      (char )'a',      (char )' ', 
        (char )'c',      (char )'o',      (char )'n',      (char )'n', 
        (char )'\n',      (char )'\n',      (char )'F',      (char )'o', 
        (char )'r',      (char )' ',      (char )'t',      (char )'h', 
        (char )'o',      (char )'s',      (char )'e',      (char )' ', 
        (char )'o',      (char )'p',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'s',      (char )' ', 
        (char )'t',      (char )'a',      (char )'k',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'t', 
        (char )'w',      (char )'o',      (char )' ',      (char )'p', 
        (char )'a',      (char )'r',      (char )'m',      (char )'s', 
        (char )',',      (char )' ',      (char )'a',      (char )'t', 
        (char )' ',      (char )'l',      (char )'e',      (char )'a', 
        (char )'s',      (char )'t',      (char )' ',      (char )'o', 
        (char )'n',      (char )'e',      (char )' ',      (char )'m', 
        (char )'u',      (char )'s',      (char )'t',      (char )' ', 
        (char )'b',      (char )'e',      (char )' ',      (char )'s', 
        (char )'p',      (char )'e',      (char )'c',      (char )'i', 
        (char )'f',      (char )'i',      (char )'e',      (char )'d', 
        (char )';',      (char )'\n',      (char )'s',      (char )'p', 
        (char )'e',      (char )'c',      (char )'i',      (char )'f', 
        (char )'y',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'o',      (char )'n',      (char )'e', 
        (char )' ',      (char )'v',      (char )'a',      (char )'l', 
        (char )'u',      (char )'e',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )'o', 
        (char )'u',      (char )'t',      (char )' ',      (char )'a', 
        (char )' ',      (char )'c',      (char )'o',      (char )'m', 
        (char )'m',      (char )'a',      (char )' ',      (char )'w', 
        (char )'i',      (char )'l',      (char )'l',      (char )' ', 
        (char )'s',      (char )'e',      (char )'t',      (char )' ', 
        (char )'b',      (char )'o',      (char )'t',      (char )'h', 
        (char )' ',      (char )'p',      (char )'a',      (char )'r', 
        (char )'m',      (char )'s',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'t',      (char )'h', 
        (char )'a',      (char )'t',      (char )'\n',      (char )'v', 
        (char )'a',      (char )'l',      (char )'u',      (char )'e', 
        (char )',',      (char )' ',      (char )'s',      (char )'p', 
        (char )'e',      (char )'c',      (char )'i',      (char )'f', 
        (char )'y',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'a',      (char )' ',      (char )'v', 
        (char )'a',      (char )'l',      (char )'u',      (char )'e', 
        (char )' ',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )' ',      (char )'a',      (char )' ', 
        (char )'l',      (char )'e',      (char )'a',      (char )'d', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'c',      (char )'o',      (char )'m',      (char )'m', 
        (char )'a',      (char )' ',      (char )'w',      (char )'i', 
        (char )'l',      (char )'l',      (char )' ',      (char )'s', 
        (char )'e',      (char )'t',      (char )' ',      (char )'j', 
        (char )'u',      (char )'s',      (char )'t',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'s',      (char )'e',      (char )'c',      (char )'o', 
        (char )'n',      (char )'d',      (char )'\n',      (char )'p', 
        (char )'a',      (char )'r',      (char )'m',      (char )',', 
        (char )' ',      (char )'a',      (char )' ',      (char )'v', 
        (char )'a',      (char )'l',      (char )'u',      (char )'e', 
        (char )' ',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )' ',      (char )'a',      (char )' ', 
        (char )'t',      (char )'r',      (char )'a',      (char )'i', 
        (char )'l',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'c',      (char )'o',      (char )'m', 
        (char )'m',      (char )'a',      (char )' ',      (char )'w', 
        (char )'i',      (char )'l',      (char )'l',      (char )' ', 
        (char )'s',      (char )'e',      (char )'t',      (char )' ', 
        (char )'j',      (char )'u',      (char )'s',      (char )'t', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'f',      (char )'i',      (char )'r', 
        (char )'s',      (char )'t',      (char )'.',      (char )' ', 
        (char )'T',      (char )'o',      (char )' ',      (char )'s', 
        (char )'e',      (char )'t',      (char )'\n',      (char )'e', 
        (char )'a',      (char )'c',      (char )'h',      (char )' ', 
        (char )'p',      (char )'a',      (char )'r',      (char )'m', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'u',      (char )'n',      (char )'i',      (char )'q', 
        (char )'u',      (char )'e',      (char )' ',      (char )'v', 
        (char )'a',      (char )'l',      (char )'u',      (char )'e', 
        (char )'s',      (char )',',      (char )' ',      (char )'s', 
        (char )'p',      (char )'e',      (char )'c',      (char )'i', 
        (char )'f',      (char )'y',      (char )' ',      (char )'b', 
        (char )'o',      (char )'t',      (char )'h',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'s',      (char )'e',      (char )'p',      (char )'a', 
        (char )'r',      (char )'a',      (char )'t',      (char )'e', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )'m',      (char )' ',      (char )'w',      (char )'i', 
        (char )'t',      (char )'h',      (char )' ',      (char )'a', 
        (char )'\n',      (char )'c',      (char )'o',      (char )'m', 
        (char )'m',      (char )'a',      (char )'.',      (char )'\n', 
        (char )'\000'};
#line 6883 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void print_omni_usage(void) 
{ 
  size_t tmp ;

  {
  {
#line 6887
  tmp = strlen((char const   *)(omni_usage));
#line 6887
  fwrite((void const   */* __restrict  */)(omni_usage), sizeof(char ), tmp, (FILE */* __restrict  */)stdout);
#line 6888
  exit(1);
  }
}
}
#line 6893 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
void scan_omni_args(int argc , char **argv ) 
{ 
  int c ;
  int have_uuid ;
  int have_R_option ;
  char arg1[8192] ;
  char arg2[8192] ;
  char arg3[8192] ;
  int i ;
  size_t tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;

  {
#line 6903
  have_uuid = 0;
#line 6904
  have_R_option = 0;
#line 6911
  if (debug) {
    {
#line 6913
    printf((char const   */* __restrict  */)"%s called with the following argument vector\n",
           "scan_omni_args");
#line 6915
    i = 0;
    }
    {
#line 6915
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6915
      if (! (i < argc)) {
#line 6915
        goto while_break;
      }
      {
#line 6916
      printf((char const   */* __restrict  */)"%s ", *(argv + i));
#line 6915
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 6918
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 6921
  strncpy((char */* __restrict  */)(local_data_port), (char const   */* __restrict  */)"0",
          sizeof(local_data_port));
#line 6922
  strncpy((char */* __restrict  */)(remote_data_port), (char const   */* __restrict  */)"0",
          sizeof(remote_data_port));
#line 6925
  set_omni_defaults_by_legacy_testname();
  }
  {
#line 6933
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 6933
    c = getopt(argc, (char * const  *)argv, "b:cCd:DG:hH:kK:l:L:m:M:nNoOp:P:r:R:s:S:t:T:u:Vw:W:46");
    }
#line 6933
    if (! (c != -1)) {
#line 6933
      goto while_break___0;
    }
    {
#line 6936
    if (c == 52) {
#line 6936
      goto case_52;
    }
#line 6936
    if (c == 63) {
#line 6936
      goto case_52;
    }
#line 6940
    if (c == 54) {
#line 6940
      goto case_54;
    }
#line 6951
    if (c == 104) {
#line 6951
      goto case_104;
    }
#line 6954
    if (c == 98) {
#line 6954
      goto case_98;
    }
#line 6961
    if (c == 99) {
#line 6961
      goto case_99;
    }
#line 6965
    if (c == 67) {
#line 6965
      goto case_67;
    }
#line 6974
    if (c == 100) {
#line 6974
      goto case_100;
    }
#line 6983
    if (c == 68) {
#line 6983
      goto case_68;
    }
#line 6988
    if (c == 71) {
#line 6988
      goto case_71;
    }
#line 6992
    if (c == 72) {
#line 6992
      goto case_72;
    }
#line 7014
    if (c == 107) {
#line 7014
      goto case_107;
    }
#line 7035
    if (c == 75) {
#line 7035
      goto case_75;
    }
#line 7043
    if (c == 108) {
#line 7043
      goto case_108;
    }
#line 7046
    if (c == 76) {
#line 7046
      goto case_76;
    }
#line 7067
    if (c == 109) {
#line 7067
      goto case_109;
    }
#line 7084
    if (c == 77) {
#line 7084
      goto case_77;
    }
#line 7100
    if (c == 110) {
#line 7100
      goto case_110;
    }
#line 7104
    if (c == 78) {
#line 7104
      goto case_78;
    }
#line 7108
    if (c == 111) {
#line 7108
      goto case_111;
    }
#line 7133
    if (c == 79) {
#line 7133
      goto case_79;
    }
#line 7152
    if (c == 112) {
#line 7152
      goto case_112;
    }
#line 7161
    if (c == 80) {
#line 7161
      goto case_80;
    }
#line 7171
    if (c == 114) {
#line 7171
      goto case_114;
    }
#line 7184
    if (c == 82) {
#line 7184
      goto case_82;
    }
#line 7188
    if (c == 115) {
#line 7188
      goto case_115;
    }
#line 7196
    if (c == 83) {
#line 7196
      goto case_83;
    }
#line 7204
    if (c == 116) {
#line 7204
      goto case_116;
    }
#line 7208
    if (c == 84) {
#line 7208
      goto case_84;
    }
#line 7212
    if (c == 117) {
#line 7212
      goto case_117;
    }
#line 7221
    if (c == 87) {
#line 7221
      goto case_87;
    }
#line 7230
    if (c == 86) {
#line 7230
      goto case_86;
    }
#line 6934
    goto switch_break;
    case_52: /* CIL Label */ 
    case_63: /* CIL Label */ 
#line 6937
    remote_data_family = 2;
#line 6938
    local_data_family = 2;
#line 6939
    goto switch_break;
    case_54: /* CIL Label */ 
#line 6942
    remote_data_family = 10;
#line 6943
    local_data_family = 10;
#line 6950
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 6952
    print_omni_usage();
#line 6953
    exit(1);
    }
    case_98: /* CIL Label */ 
    {
#line 6956
    first_burst_size = atoi((char const   *)optarg);
    }
#line 6960
    goto switch_break;
    case_99: /* CIL Label */ 
#line 6963
    connection_test = 1;
#line 6964
    goto switch_break;
    case_67: /* CIL Label */ 
#line 6968
    loc_tcpcork = 1;
#line 6969
    rem_tcpcork = 1;
#line 6973
    goto switch_break;
    case_100: /* CIL Label */ 
#line 6978
    if (! was_legacy) {
      {
#line 6979
      direction = parse_direction(optarg);
#line 6980
      implicit_direction = 0;
      }
    }
#line 6982
    goto switch_break;
    case_68: /* CIL Label */ 
#line 6985
    loc_nodelay = 1;
#line 6986
    rem_nodelay = 1;
#line 6987
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 6990
    transport_mss_req = atoi((char const   *)optarg);
    }
#line 6991
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 6993
    break_args_explicit_sep(optarg, ',', arg1, arg2);
    }
#line 6994
    if (arg1[0]) {
      {
#line 7000
      break_args_explicit_sep(optarg, '/', arg1, arg3);
      }
#line 7001
      if (arg1[0]) {
        {
#line 7002
        tmp = strlen((char const   *)(arg1));
#line 7002
        tmp___0 = malloc(tmp + 1UL);
#line 7002
        remote_data_address = (char *)tmp___0;
#line 7003
        strcpy((char */* __restrict  */)remote_data_address, (char const   */* __restrict  */)(arg1));
#line 7004
        explicit_data_address = 1;
        }
      }
#line 7006
      if (arg3[0]) {
        {
#line 7007
        tmp___1 = convert(arg3);
#line 7007
        remote_mask_len = (int )tmp___1;
        }
      }
    }
#line 7010
    if (arg2[0]) {
      {
#line 7011
      remote_data_family = parse_address_family(arg2);
      }
    }
#line 7013
    goto switch_break;
    case_107: /* CIL Label */ 
#line 7015
    netperf_output_mode = (enum netperf_output_modes )2;
#line 7016
    legacy = 0;
#line 7018
    if (output_selection_spec) {
      {
#line 7019
      free((void *)output_selection_spec);
#line 7020
      output_selection_spec = (char *)((void *)0);
      }
    }
#line 7022
    if (*(argv + optind)) {
#line 7022
      if ((int )((unsigned char )*(*(argv + optind) + 0)) != 45) {
        {
#line 7025
        output_selection_spec = strdup((char const   *)*(argv + optind));
#line 7026
        optind ++;
#line 7029
        tmp___2 = strcmp((char const   *)output_selection_spec, "?");
        }
#line 7029
        if (tmp___2 == 0) {
          {
#line 7030
          dump_netperf_output_choices(stdout, 1);
#line 7031
          exit(1);
          }
        }
      }
    }
#line 7034
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 7037
    break_args(optarg, arg1, arg2);
    }
#line 7038
    if (arg1[0]) {
      {
#line 7039
      strncpy((char */* __restrict  */)(local_cong_control_req), (char const   */* __restrict  */)(arg1),
              sizeof(local_cong_control_req));
      }
    }
#line 7040
    if (arg2[2]) {
      {
#line 7041
      strncpy((char */* __restrict  */)(remote_cong_control_req), (char const   */* __restrict  */)(arg2),
              sizeof(remote_cong_control_req));
      }
    }
#line 7042
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 7044
    multicast_ttl = atoi((char const   *)optarg);
    }
#line 7045
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 7047
    break_args_explicit_sep(optarg, ',', arg1, arg2);
    }
#line 7048
    if (arg1[0]) {
      {
#line 7054
      break_args_explicit_sep(optarg, '/', arg1, arg3);
      }
#line 7055
      if (arg1[0]) {
        {
#line 7056
        tmp___3 = strlen((char const   *)(arg1));
#line 7056
        tmp___4 = malloc(tmp___3 + 1UL);
#line 7056
        local_data_address = (char *)tmp___4;
#line 7057
        strcpy((char */* __restrict  */)local_data_address, (char const   */* __restrict  */)(arg1));
        }
      }
#line 7059
      if (arg3[0]) {
        {
#line 7060
        tmp___5 = convert(arg3);
#line 7060
        local_mask_len = (int )tmp___5;
        }
      }
    }
#line 7063
    if (arg2[0]) {
      {
#line 7064
      local_data_family = parse_address_family(arg2);
      }
    }
#line 7066
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 7072
    break_args_explicit(optarg, arg1, arg2);
    }
#line 7073
    if (arg1[0]) {
      {
#line 7074
      tmp___6 = convert(arg1);
#line 7074
      send_size = (int )tmp___6;
      }
#line 7075
      if (implicit_direction) {
#line 7076
        direction |= 2;
      }
    }
#line 7078
    if (arg2[0]) {
      {
#line 7079
      tmp___7 = convert(arg2);
#line 7079
      remote_send_size_req = (int )tmp___7;
      }
#line 7080
      if (implicit_direction) {
#line 7081
        direction |= 4;
      }
    }
#line 7083
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 7088
    break_args_explicit(optarg, arg1, arg2);
    }
#line 7089
    if (arg1[0]) {
      {
#line 7090
      tmp___8 = convert(arg1);
#line 7090
      remote_recv_size_req = (int )tmp___8;
      }
#line 7091
      if (implicit_direction) {
#line 7092
        direction |= 2;
      }
    }
#line 7094
    if (arg2[0]) {
      {
#line 7095
      tmp___9 = convert(arg2);
#line 7095
      recv_size = (int )tmp___9;
      }
#line 7096
      if (implicit_direction) {
#line 7097
        direction |= 4;
      }
    }
#line 7099
    goto switch_break;
    case_110: /* CIL Label */ 
#line 7102
    local_connected = 1;
#line 7103
    goto switch_break;
    case_78: /* CIL Label */ 
#line 7106
    remote_connected = 1;
#line 7107
    goto switch_break;
    case_111: /* CIL Label */ 
#line 7109
    netperf_output_mode = (enum netperf_output_modes )1;
#line 7110
    legacy = 0;
#line 7112
    if (output_selection_spec) {
      {
#line 7113
      free((void *)output_selection_spec);
#line 7114
      output_selection_spec = (char *)((void *)0);
      }
    }
#line 7116
    if (output_selection_spec) {
      {
#line 7117
      free((void *)output_selection_spec);
#line 7118
      output_selection_spec = (char *)((void *)0);
      }
    }
#line 7120
    if (*(argv + optind)) {
#line 7120
      if ((int )((unsigned char )*(*(argv + optind) + 0)) != 45) {
        {
#line 7123
        output_selection_spec = strdup((char const   *)*(argv + optind));
#line 7124
        optind ++;
#line 7127
        tmp___10 = strcmp((char const   *)output_selection_spec, "?");
        }
#line 7127
        if (tmp___10 == 0) {
          {
#line 7128
          dump_netperf_output_choices(stdout, 1);
#line 7129
          exit(1);
          }
        }
      }
    }
#line 7132
    goto switch_break;
    case_79: /* CIL Label */ 
#line 7134
    netperf_output_mode = (enum netperf_output_modes )0;
#line 7135
    legacy = 0;
#line 7137
    if (output_selection_spec) {
      {
#line 7138
      free((void *)output_selection_spec);
#line 7139
      output_selection_spec = (char *)((void *)0);
      }
    }
#line 7141
    if (*(argv + optind)) {
#line 7141
      if ((int )((unsigned char )*(*(argv + optind) + 0)) != 45) {
        {
#line 7144
        output_selection_spec = strdup((char const   *)*(argv + optind));
#line 7145
        optind ++;
#line 7146
        tmp___11 = strcmp((char const   *)output_selection_spec, "?");
        }
#line 7146
        if (tmp___11 == 0) {
          {
#line 7147
          dump_netperf_output_choices(stdout, 0);
#line 7148
          exit(1);
          }
        }
      }
    }
#line 7151
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 7155
    break_args(optarg, arg1, arg2);
    }
#line 7156
    if (arg1[0]) {
      {
#line 7157
      client_port_min = atoi((char const   *)(arg1));
      }
    }
#line 7158
    if (arg2[0]) {
      {
#line 7159
      client_port_max = atoi((char const   *)(arg2));
      }
    }
#line 7160
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 7165
    break_args(optarg, arg1, arg2);
    }
#line 7166
    if (arg1[0]) {
      {
#line 7167
      strncpy((char */* __restrict  */)(local_data_port), (char const   */* __restrict  */)(arg1),
              sizeof(local_data_port));
      }
    }
#line 7168
    if (arg2[0]) {
      {
#line 7169
      strncpy((char */* __restrict  */)(remote_data_port), (char const   */* __restrict  */)(arg2),
              sizeof(remote_data_port));
      }
    }
#line 7170
    goto switch_break;
    case_114: /* CIL Label */ 
#line 7174
    if (implicit_direction) {
#line 7175
      direction |= 2;
#line 7176
      direction |= 4;
    }
    {
#line 7178
    break_args(optarg, arg1, arg2);
    }
#line 7179
    if (arg1[0]) {
      {
#line 7180
      tmp___12 = convert(arg1);
#line 7180
      req_size = (int )tmp___12;
      }
    }
#line 7181
    if (arg2[0]) {
      {
#line 7182
      tmp___13 = convert(arg2);
#line 7182
      rsp_size = (int )tmp___13;
      }
    }
#line 7183
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 7185
    routing_allowed = atoi((char const   *)optarg);
#line 7186
    have_R_option = 1;
    }
#line 7187
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 7190
    break_args(optarg, arg1, arg2);
    }
#line 7191
    if (arg1[0]) {
      {
#line 7192
      tmp___14 = convert(arg1);
#line 7192
      lss_size_req = (int )tmp___14;
      }
    }
#line 7193
    if (arg2[0]) {
      {
#line 7194
      tmp___15 = convert(arg2);
#line 7194
      lsr_size_req = (int )tmp___15;
      }
    }
#line 7195
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 7198
    break_args(optarg, arg1, arg2);
    }
#line 7199
    if (arg1[0]) {
      {
#line 7200
      tmp___16 = convert(arg1);
#line 7200
      rss_size_req = (int )tmp___16;
      }
    }
#line 7201
    if (arg2[0]) {
      {
#line 7202
      tmp___17 = convert(arg2);
#line 7202
      rsr_size_req = (int )tmp___17;
      }
    }
#line 7203
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 7206
    socket_type = parse_socket_type(optarg);
    }
#line 7207
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 7210
    protocol = parse_protocol(optarg);
    }
#line 7211
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 7216
    strncpy((char */* __restrict  */)(test_uuid), (char const   */* __restrict  */)optarg,
            sizeof(test_uuid));
#line 7218
    test_uuid[sizeof(test_uuid) - 1UL] = (char)0;
#line 7219
    have_uuid = 1;
    }
#line 7220
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 7228
    tmp___18 = convert(optarg);
#line 7228
    send_width = (int )tmp___18;
    }
#line 7229
    goto switch_break;
    case_86: /* CIL Label */ 
#line 7235
    loc_sndavoid = 1;
#line 7236
    loc_rcvavoid = 1;
#line 7237
    rem_sndavoid = 1;
#line 7238
    rem_rcvavoid = 1;
#line 7239
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 7244
  if (! have_uuid) {
    {
#line 7245
    get_uuid_string(test_uuid, sizeof(test_uuid));
    }
  }
  {
#line 7247
  protocol_str = protocol_to_str(protocol);
  }
#line 7250
  if (0 == direction) {
#line 7250
    if (! connection_test) {
#line 7250
      direction = 2;
    }
  }
  {
#line 7251
  direction_str = direction_to_str(direction);
  }
#line 7259
  if (! have_R_option) {
#line 7259
    if (protocol == 17) {
#line 7259
      if (direction & 2) {
#line 7259
        if (! (direction & 4)) {
#line 7259
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 7259
      if (direction & 2) {
#line 7262
        routing_allowed = 0;
      } else
#line 7259
      if (direction & 4) {
#line 7262
        routing_allowed = 0;
      }
    }
  }
#line 7277
  if (direction & 2) {
#line 7277
    if (direction & 4) {
#line 7277
      goto _L___1;
    } else {
#line 7277
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 7277
  if (! (direction & 2)) {
#line 7277
    if (! (direction & 4)) {
      _L___1: /* CIL Label */ 
#line 7277
      if (! (direction & 2)) {
#line 7277
        if (! (! (direction & 4))) {
#line 7277
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 7278
        if (req_size == -1) {
#line 7279
          req_size = 1;
        }
#line 7280
        if (rsp_size == -1) {
#line 7281
          rsp_size = 1;
        }
      }
    }
  }
#line 7285
  if (63 == (int )libfmt) {
#line 7287
    if (direction & 2) {
#line 7287
      if (direction & 4) {
#line 7288
        libfmt = (char )'x';
      } else {
#line 7287
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 7287
    if (direction & 2) {
#line 7291
      libfmt = (char )'m';
    } else
#line 7287
    if (direction & 4) {
#line 7291
      libfmt = (char )'m';
    } else {
#line 7288
      libfmt = (char )'x';
    }
  } else
#line 7294
  if (120 == (int )libfmt) {
#line 7298
    if (direction & 2) {
#line 7298
      if (! (direction & 4)) {
#line 7298
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 7298
    if (direction & 2) {
#line 7299
      libfmt = (char )'m';
    } else
#line 7298
    if (direction & 4) {
#line 7299
      libfmt = (char )'m';
    }
  }
  {
#line 7304
  tmp___19 = format_units();
#line 7304
  thruput_format_str = strdup((char const   *)tmp___19);
  }
#line 7309
  if (no_control) {
    {
#line 7310
    tmp___20 = strcmp((char const   *)(remote_data_port), "0");
    }
#line 7310
    if (tmp___20 == 0) {
#line 7314
      if (direction & 2) {
#line 7314
        if (! (direction & 4)) {
          {
#line 7315
          strncpy((char */* __restrict  */)(remote_data_port), (char const   */* __restrict  */)"discard",
                  sizeof(remote_data_port));
#line 7316
          recv_size = -1;
          }
        } else {
#line 7314
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 7318
      if (direction & 4) {
#line 7318
        if (! (direction & 2)) {
          {
#line 7319
          strncpy((char */* __restrict  */)(remote_data_port), (char const   */* __restrict  */)"chargen",
                  sizeof(remote_data_port));
#line 7320
          send_size = -1;
          }
        } else {
#line 7318
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 7322
      if (direction & 2) {
#line 7322
        if (direction & 4) {
          {
#line 7323
          strncpy((char */* __restrict  */)(remote_data_port), (char const   */* __restrict  */)"echo",
                  sizeof(remote_data_port));
#line 7324
          rsp_size = req_size;
          }
        } else {
#line 7322
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 7322
      if (direction & 2) {
#line 7322
        goto _L___5;
      } else
#line 7322
      if (direction & 4) {
        _L___5: /* CIL Label */ 
#line 7322
        if (! (direction & 2)) {
#line 7322
          if (! (direction & 4)) {
            {
#line 7323
            strncpy((char */* __restrict  */)(remote_data_port), (char const   */* __restrict  */)"echo",
                    sizeof(remote_data_port));
#line 7324
            rsp_size = req_size;
            }
          } else {
            {
#line 7327
            printf((char const   */* __restrict  */)"No default port known for the %s test, please set one yourself\n",
                   test_name);
#line 7328
            exit(-1);
            }
          }
        } else {
          {
#line 7327
          printf((char const   */* __restrict  */)"No default port known for the %s test, please set one yourself\n",
                 test_name);
#line 7328
          exit(-1);
          }
        }
      } else {
        {
#line 7323
        strncpy((char */* __restrict  */)(remote_data_port), (char const   */* __restrict  */)"echo",
                sizeof(remote_data_port));
#line 7324
        rsp_size = req_size;
        }
      }
    }
#line 7331
    remote_data_port[sizeof(remote_data_port) - 1UL] = (char )'\000';
#line 7337
    rem_rcvavoid = -1;
#line 7338
    rem_sndavoid = -1;
#line 7339
    rss_size_req = -1;
#line 7340
    rsr_size_req = -1;
#line 7341
    rem_nodelay = -1;
  }
#line 7345
  if (! legacy) {
    {
#line 7346
    print_omni_init();
    }
  }
#line 7348
  if (desired_output_groups & 1048592U) {
#line 7349
    keep_statistics = 1;
#line 7350
    keep_histogram = 1;
  }
#line 7353
  return;
}
}
#line 3 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
char netsh_id[75]  = 
#line 3 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
  {      (char )'@',      (char )'(',      (char )'#',      (char )')', 
        (char )'n',      (char )'e',      (char )'t',      (char )'s', 
        (char )'h',      (char )'.',      (char )'c',      (char )' ', 
        (char )'(',      (char )'c',      (char )')',      (char )' ', 
        (char )'C',      (char )'o',      (char )'p',      (char )'y', 
        (char )'r',      (char )'i',      (char )'g',      (char )'h', 
        (char )'t',      (char )' ',      (char )'1',      (char )'9', 
        (char )'9',      (char )'3',      (char )'-',      (char )'2', 
        (char )'0',      (char )'1',      (char )'2',      (char )' ', 
        (char )'H',      (char )'e',      (char )'w',      (char )'l', 
        (char )'e',      (char )'t',      (char )'t',      (char )'-', 
        (char )'P',      (char )'a',      (char )'c',      (char )'k', 
        (char )'a',      (char )'r',      (char )'d',      (char )' ', 
        (char )'C',      (char )'o',      (char )'m',      (char )'p', 
        (char )'a',      (char )'n',      (char )'y',      (char )'.', 
        (char )' ',      (char )'V',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'2',      (char )'.',      (char )'6', 
        (char )'.',      (char )'0',      (char )'\000'};
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 164
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 668 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 214 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.h"
int parse_ipqos(char const   *cp ) ;
#line 215
char const   *iptos2str(int iptos ) ;
#line 515 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.h"
struct addrinfo *resolve_host(char *hostname , char *port , int family ) ;
#line 587
void bind_to_specific_processor(int processor_affinity , int use_cpu_map ) ;
#line 645
unsigned int convert_timespec(char *string ) ;
#line 584 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
void scan_sockets_args(int argc , char **argv ) ;
#line 99 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
char *program  ;
#line 100 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
char *command_line  ;
#line 103 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
char host_name[255]  = {      (char )'\000'};
#line 103 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
char local_host_name[255]  = {      (char )'\000'};
#line 103 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
char test_name[8192]  = 
#line 103
  {      (char )'T',      (char )'C',      (char )'P',      (char )'_', 
        (char )'S',      (char )'T',      (char )'R',      (char )'E', 
        (char )'A',      (char )'M',      (char )'\000'};
#line 103 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
char test_port[10]  = {      (char )'1',      (char )'2',      (char )'8',      (char )'6', 
        (char )'5',      (char )'\000'};
#line 103 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
char local_test_port[10]  = {      (char )'0',      (char )'\000'};
#line 110 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int address_family  =    0;
#line 110 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int local_address_family  =    0;
#line 115 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
char local_fill_file[8192]  = {      (char )'\000'};
#line 116 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
char remote_fill_file[32]  = {      (char )'\000'};
#line 119 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int debug  =    0;
#line 119 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int print_headers  =    1;
#line 119 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int verbosity  =    1;
#line 119 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int keep_histogram  =    0;
#line 119 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int keep_statistics  =    0;
#line 130 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
char *result_brand  =    (char *)((void *)0);
#line 133 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int local_cpu_usage  =    0;
#line 133 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int remote_cpu_usage  =    0;
#line 137 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
float local_cpu_rate  =    0.0F;
#line 137 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
float remote_cpu_rate  =    0.0F;
#line 141 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int shell_num_cpus  =    1;
#line 147 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int test_time  =    10;
#line 147 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int test_len_ticks  ;
#line 147 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int test_bytes  =    0;
#line 147 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int test_trans  =    0;
#line 155 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int local_recv_align  =    8;
#line 155 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int local_send_align  =    8;
#line 155 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int local_send_offset  =    0;
#line 155 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int local_recv_offset  =    0;
#line 155 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int remote_recv_align  =    8;
#line 155 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int remote_send_align  =    8;
#line 155 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int remote_send_offset  =    0;
#line 155 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int remote_recv_offset  =    0;
#line 155 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int remote_send_width  =    0;
#line 155 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int remote_recv_width  =    0;
#line 168 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int interval_usecs  =    0;
#line 168 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int interval_wate  =    0;
#line 168 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int interval_burst  =    0;
#line 168 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int remote_interval_usecs  =    0;
#line 168 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int remote_interval_burst  =    0;
#line 177 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int wait_time_secs  =    0;
#line 186 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int loc_dirty_count  =    -1;
#line 186 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int loc_clean_count  =    -1;
#line 186 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int rem_dirty_count  =    -1;
#line 186 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int rem_clean_count  =    -1;
#line 194 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int confidence_level  =    0;
#line 195 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int iteration_min  =    1;
#line 196 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int iteration_max  =    1;
#line 197 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int result_confidence_only  =    0;
#line 198 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
double interval  =    0.0;
#line 202 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int send_width  ;
#line 203 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int recv_width  ;
#line 206 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int af  =    2;
#line 209 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int local_socket_prio  =    -1;
#line 210 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int remote_socket_prio  =    -1;
#line 213 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int local_socket_tos  =    -1;
#line 214 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int remote_socket_tos  =    -1;
#line 217 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int cpu_binding_requested  =    0;
#line 220 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int no_control  =    0;
#line 223 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
char *passphrase  =    (char *)((void *)0);
#line 225 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
char netserver_usage[678]  = 
#line 225
  {      (char )'\n',      (char )'U',      (char )'s',      (char )'a', 
        (char )'g',      (char )'e',      (char )':',      (char )' ', 
        (char )'n',      (char )'e',      (char )'t',      (char )'s', 
        (char )'e',      (char )'r',      (char )'v',      (char )'e', 
        (char )'r',      (char )' ',      (char )'[',      (char )'o', 
        (char )'p',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )'s',      (char )']',      (char )' ', 
        (char )'\n',      (char )'\n',      (char )'O',      (char )'p', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'s',      (char )':',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'h',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'D',      (char )'i',      (char )'s', 
        (char )'p',      (char )'l',      (char )'a',      (char )'y', 
        (char )' ',      (char )'t',      (char )'h',      (char )'i', 
        (char )'s',      (char )' ',      (char )'t',      (char )'e', 
        (char )'x',      (char )'t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'D',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'D',      (char )'o',      (char )' ', 
        (char )'n',      (char )'o',      (char )'t',      (char )' ', 
        (char )'d',      (char )'a',      (char )'e',      (char )'m', 
        (char )'o',      (char )'n',      (char )'i',      (char )'z', 
        (char )'e',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'d', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'I',      (char )'n',      (char )'c',      (char )'r', 
        (char )'e',      (char )'a',      (char )'s',      (char )'e', 
        (char )' ',      (char )'d',      (char )'e',      (char )'b', 
        (char )'u',      (char )'g',      (char )'g',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'o', 
        (char )'u',      (char )'t',      (char )'p',      (char )'u', 
        (char )'t',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'f', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'D',      (char )'o',      (char )' ',      (char )'n', 
        (char )'o',      (char )'t',      (char )' ',      (char )'s', 
        (char )'p',      (char )'a',      (char )'w',      (char )'n', 
        (char )' ',      (char )'c',      (char )'h',      (char )'i', 
        (char )'l',      (char )'r',      (char )'e',      (char )'n', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )' ',      (char )'e',      (char )'a',      (char )'c', 
        (char )'h',      (char )' ',      (char )'t',      (char )'e', 
        (char )'s',      (char )'t',      (char )',',      (char )' ', 
        (char )'r',      (char )'u',      (char )'n',      (char )' ', 
        (char )'s',      (char )'e',      (char )'r',      (char )'i', 
        (char )'a',      (char )'l',      (char )'l',      (char )'y', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'L',      (char )' ', 
        (char )'n',      (char )'a',      (char )'m',      (char )'e', 
        (char )',',      (char )'f',      (char )'a',      (char )'m', 
        (char )'i',      (char )'l',      (char )'y',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'U', 
        (char )'s',      (char )'e',      (char )' ',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'p', 
        (char )'i',      (char )'c',      (char )'k',      (char )' ', 
        (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'e',      (char )'n',      (char )' ',      (char )'a', 
        (char )'d',      (char )'d',      (char )'r',      (char )'e', 
        (char )'s',      (char )'s',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'f', 
        (char )'a',      (char )'m',      (char )'i',      (char )'l', 
        (char )'y',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )' ',      (char )'f',      (char )'a', 
        (char )'m',      (char )'i',      (char )'l',      (char )'y', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'N',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'N', 
        (char )'o',      (char )' ',      (char )'d',      (char )'e', 
        (char )'b',      (char )'u',      (char )'g',      (char )'g', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )',',      (char )' ', 
        (char )'e',      (char )'v',      (char )'e',      (char )'n', 
        (char )' ',      (char )'i',      (char )'f',      (char )' ', 
        (char )'n',      (char )'e',      (char )'t',      (char )'p', 
        (char )'e',      (char )'r',      (char )'f',      (char )' ', 
        (char )'a',      (char )'s',      (char )'k',      (char )'s', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'p',      (char )' ', 
        (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )'n',      (char )'u',      (char )'m',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'L', 
        (char )'i',      (char )'s',      (char )'t',      (char )'e', 
        (char )'n',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )' ',      (char )'c',      (char )'o', 
        (char )'n',      (char )'n',      (char )'e',      (char )'c', 
        (char )'t',      (char )' ',      (char )'r',      (char )'e', 
        (char )'q',      (char )'u',      (char )'e',      (char )'s', 
        (char )'t',      (char )'s',      (char )' ',      (char )'o', 
        (char )'n',      (char )' ',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'n',      (char )'u', 
        (char )'m',      (char )'.',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'4',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'D',      (char )'o',      (char )' ', 
        (char )'I',      (char )'P',      (char )'v',      (char )'4', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'6',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'D', 
        (char )'o',      (char )' ',      (char )'I',      (char )'P', 
        (char )'v',      (char )'6',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'v',      (char )' ',      (char )'v',      (char )'e', 
        (char )'r',      (char )'b',      (char )'o',      (char )'s', 
        (char )'i',      (char )'t',      (char )'y',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'S',      (char )'p',      (char )'e', 
        (char )'c',      (char )'i',      (char )'f',      (char )'y', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'v',      (char )'e',      (char )'r', 
        (char )'b',      (char )'o',      (char )'s',      (char )'i', 
        (char )'t',      (char )'y',      (char )' ',      (char )'l', 
        (char )'e',      (char )'v',      (char )'e',      (char )'l', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'V',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'D', 
        (char )'i',      (char )'s',      (char )'p',      (char )'l', 
        (char )'a',      (char )'y',      (char )' ',      (char )'v', 
        (char )'e',      (char )'r',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'i', 
        (char )'n',      (char )'f',      (char )'o',      (char )'r', 
        (char )'m',      (char )'a',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'e', 
        (char )'x',      (char )'i',      (char )'t',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'Z',      (char )' ',      (char )'p', 
        (char )'a',      (char )'s',      (char )'s',      (char )'p', 
        (char )'h',      (char )'r',      (char )'a',      (char )'s', 
        (char )'e',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'E',      (char )'x', 
        (char )'p',      (char )'e',      (char )'c',      (char )'t', 
        (char )' ',      (char )'p',      (char )'a',      (char )'s', 
        (char )'s',      (char )'p',      (char )'h',      (char )'r', 
        (char )'a',      (char )'s',      (char )'e',      (char )' ', 
        (char )'a',      (char )'s',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'r',      (char )'s',      (char )'t', 
        (char )' ',      (char )'t',      (char )'h',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'r', 
        (char )'e',      (char )'c',      (char )'e',      (char )'i', 
        (char )'v',      (char )'e',      (char )'d',      (char )'\n', 
        (char )'\n',      (char )'\000'};
#line 247 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
char netperf_usage1[2411]  = 
#line 247
  {      (char )'\n',      (char )'U',      (char )'s',      (char )'a', 
        (char )'g',      (char )'e',      (char )':',      (char )' ', 
        (char )'n',      (char )'e',      (char )'t',      (char )'p', 
        (char )'e',      (char )'r',      (char )'f',      (char )' ', 
        (char )'[',      (char )'g',      (char )'l',      (char )'o', 
        (char )'b',      (char )'a',      (char )'l',      (char )' ', 
        (char )'o',      (char )'p',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'s',      (char )']', 
        (char )' ',      (char )'-',      (char )'-',      (char )' ', 
        (char )'[',      (char )'t',      (char )'e',      (char )'s', 
        (char )'t',      (char )' ',      (char )'o',      (char )'p', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'s',      (char )']',      (char )' ',      (char )'\n', 
        (char )'\n',      (char )'G',      (char )'l',      (char )'o', 
        (char )'b',      (char )'a',      (char )'l',      (char )' ', 
        (char )'o',      (char )'p',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'s',      (char )':', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'a',      (char )' ', 
        (char )'s',      (char )'e',      (char )'n',      (char )'d', 
        (char )',',      (char )'r',      (char )'e',      (char )'c', 
        (char )'v',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'S', 
        (char )'e',      (char )'t',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'l', 
        (char )'o',      (char )'c',      (char )'a',      (char )'l', 
        (char )' ',      (char )'s',      (char )'e',      (char )'n', 
        (char )'d',      (char )',',      (char )'r',      (char )'e', 
        (char )'c',      (char )'v',      (char )' ',      (char )'b', 
        (char )'u',      (char )'f',      (char )'f',      (char )'e', 
        (char )'r',      (char )' ',      (char )'a',      (char )'l', 
        (char )'i',      (char )'g',      (char )'n',      (char )'m', 
        (char )'e',      (char )'n',      (char )'t',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'A',      (char )' ',      (char )'s', 
        (char )'e',      (char )'n',      (char )'d',      (char )',', 
        (char )'r',      (char )'e',      (char )'c',      (char )'v', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'S',      (char )'e', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'r',      (char )'e', 
        (char )'m',      (char )'o',      (char )'t',      (char )'e', 
        (char )' ',      (char )'s',      (char )'e',      (char )'n', 
        (char )'d',      (char )',',      (char )'r',      (char )'e', 
        (char )'c',      (char )'v',      (char )' ',      (char )'b', 
        (char )'u',      (char )'f',      (char )'f',      (char )'e', 
        (char )'r',      (char )' ',      (char )'a',      (char )'l', 
        (char )'i',      (char )'g',      (char )'n',      (char )'m', 
        (char )'e',      (char )'n',      (char )'t',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'B',      (char )' ',      (char )'b', 
        (char )'r',      (char )'a',      (char )'n',      (char )'d', 
        (char )'s',      (char )'t',      (char )'r',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'S',      (char )'p', 
        (char )'e',      (char )'c',      (char )'i',      (char )'f', 
        (char )'y',      (char )' ',      (char )'a',      (char )' ', 
        (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'b',      (char )'e', 
        (char )' ',      (char )'e',      (char )'m',      (char )'i', 
        (char )'t',      (char )'t',      (char )'e',      (char )'d', 
        (char )' ',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )' ',      (char )'b',      (char )'r', 
        (char )'i',      (char )'e',      (char )'f',      (char )' ', 
        (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'c',      (char )' ',      (char )'[',      (char )'c', 
        (char )'p',      (char )'u',      (char )'_',      (char )'r', 
        (char )'a',      (char )'t',      (char )'e',      (char )']', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'R',      (char )'e',      (char )'p', 
        (char )'o',      (char )'r',      (char )'t',      (char )' ', 
        (char )'l',      (char )'o',      (char )'c',      (char )'a', 
        (char )'l',      (char )' ',      (char )'C',      (char )'P', 
        (char )'U',      (char )' ',      (char )'u',      (char )'s', 
        (char )'a',      (char )'g',      (char )'e',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'C',      (char )' ',      (char )'[', 
        (char )'c',      (char )'p',      (char )'u',      (char )'_', 
        (char )'r',      (char )'a',      (char )'t',      (char )'e', 
        (char )']',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'R',      (char )'e', 
        (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )' ',      (char )'r',      (char )'e',      (char )'m', 
        (char )'o',      (char )'t',      (char )'e',      (char )' ', 
        (char )'C',      (char )'P',      (char )'U',      (char )' ', 
        (char )'u',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'d', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'I',      (char )'n',      (char )'c',      (char )'r', 
        (char )'e',      (char )'a',      (char )'s',      (char )'e', 
        (char )' ',      (char )'d',      (char )'e',      (char )'b', 
        (char )'u',      (char )'g',      (char )'g',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'o', 
        (char )'u',      (char )'t',      (char )'p',      (char )'u', 
        (char )'t',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'D', 
        (char )' ',      (char )'t',      (char )'i',      (char )'m', 
        (char )'e',      (char )',',      (char )'[',      (char )'u', 
        (char )'n',      (char )'i',      (char )'t',      (char )'s', 
        (char )']',      (char )' ',      (char )'*',      (char )' ', 
        (char )'D',      (char )'i',      (char )'s',      (char )'p', 
        (char )'l',      (char )'a',      (char )'y',      (char )' ', 
        (char )'i',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'i',      (char )'m',      (char )' ', 
        (char )'r',      (char )'e',      (char )'s',      (char )'u', 
        (char )'l',      (char )'t',      (char )'s',      (char )' ', 
        (char )'a',      (char )'t',      (char )' ',      (char )'l', 
        (char )'e',      (char )'a',      (char )'s',      (char )'t', 
        (char )' ',      (char )'e',      (char )'v',      (char )'e', 
        (char )'r',      (char )'y',      (char )' ',      (char )'t', 
        (char )'i',      (char )'m',      (char )'e',      (char )' ', 
        (char )'i',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'v',      (char )'a',      (char )'l', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'u', 
        (char )'s',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'u',      (char )'n',      (char )'i', 
        (char )'t',      (char )'s',      (char )' ',      (char )'a', 
        (char )'s',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'i',      (char )'n', 
        (char )'i',      (char )'t',      (char )'i',      (char )'a', 
        (char )'l',      (char )' ',      (char )'g',      (char )'u', 
        (char )'e',      (char )'s',      (char )'s',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )' ', 
        (char )'u',      (char )'n',      (char )'i',      (char )'t', 
        (char )'s',      (char )' ',      (char )'p',      (char )'e', 
        (char )'r',      (char )' ',      (char )'s',      (char )'e', 
        (char )'c',      (char )'o',      (char )'n',      (char )'d', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'A', 
        (char )' ',      (char )'n',      (char )'e',      (char )'g', 
        (char )'a',      (char )'t',      (char )'i',      (char )'v', 
        (char )'e',      (char )' ',      (char )'v',      (char )'a', 
        (char )'l',      (char )'u',      (char )'e',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )' ', 
        (char )'t',      (char )'i',      (char )'m',      (char )'e', 
        (char )' ',      (char )'w',      (char )'i',      (char )'l', 
        (char )'l',      (char )' ',      (char )'m',      (char )'a', 
        (char )'k',      (char )'e',      (char )' ',      (char )'h', 
        (char )'e',      (char )'a',      (char )'v',      (char )'y', 
        (char )' ',      (char )'u',      (char )'s',      (char )'e', 
        (char )' ',      (char )'o',      (char )'f',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'s',      (char )'y', 
        (char )'s',      (char )'t',      (char )'e',      (char )'m', 
        (char )'\'',      (char )'s',      (char )' ',      (char )'t', 
        (char )'i',      (char )'m',      (char )'e',      (char )'s', 
        (char )'t',      (char )'a',      (char )'m',      (char )'p', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'f',      (char )'u',      (char )'n',      (char )'c', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'a',      (char )'l',      (char )'i',      (char )'t', 
        (char )'y',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'f', 
        (char )' ',      (char )'G',      (char )'|',      (char )'M', 
        (char )'|',      (char )'K',      (char )'|',      (char )'g', 
        (char )'|',      (char )'m',      (char )'|',      (char )'k', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'S',      (char )'e',      (char )'t',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )' ',      (char )'u', 
        (char )'n',      (char )'i',      (char )'t',      (char )'s', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'F',      (char )' ', 
        (char )'l',      (char )'f',      (char )'i',      (char )'l', 
        (char )'l',      (char )'[',      (char )',',      (char )'r', 
        (char )'f',      (char )'i',      (char )'l',      (char )'l', 
        (char )']',      (char )'*',      (char )' ',      (char )'P', 
        (char )'r',      (char )'e',      (char )'-',      (char )'f', 
        (char )'i',      (char )'l',      (char )'l',      (char )' ', 
        (char )'b',      (char )'u',      (char )'f',      (char )'f', 
        (char )'e',      (char )'r',      (char )'s',      (char )' ', 
        (char )'w',      (char )'i',      (char )'t',      (char )'h', 
        (char )' ',      (char )'d',      (char )'a',      (char )'t', 
        (char )'a',      (char )' ',      (char )'f',      (char )'r', 
        (char )'o',      (char )'m',      (char )' ',      (char )'s', 
        (char )'p',      (char )'e',      (char )'c',      (char )'i', 
        (char )'f',      (char )'i',      (char )'e',      (char )'d', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'h', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'D',      (char )'i',      (char )'s',      (char )'p', 
        (char )'l',      (char )'a',      (char )'y',      (char )' ', 
        (char )'t',      (char )'h',      (char )'i',      (char )'s', 
        (char )' ',      (char )'t',      (char )'e',      (char )'x', 
        (char )'t',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'H', 
        (char )' ',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )'|',      (char )'i',      (char )'p', 
        (char )',',      (char )'f',      (char )'a',      (char )'m', 
        (char )' ',      (char )'*',      (char )' ',      (char )' ', 
        (char )'S',      (char )'p',      (char )'e',      (char )'c', 
        (char )'i',      (char )'f',      (char )'y',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'t',      (char )'a',      (char )'r',      (char )'g', 
        (char )'e',      (char )'t',      (char )' ',      (char )'m', 
        (char )'a',      (char )'c',      (char )'h',      (char )'i', 
        (char )'n',      (char )'e',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )'/',      (char )'o', 
        (char )'r',      (char )' ',      (char )'l',      (char )'o', 
        (char )'c',      (char )'a',      (char )'l',      (char )' ', 
        (char )'i',      (char )'p',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'f', 
        (char )'a',      (char )'m',      (char )'i',      (char )'l', 
        (char )'y',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'i', 
        (char )' ',      (char )'m',      (char )'a',      (char )'x', 
        (char )',',      (char )'m',      (char )'i',      (char )'n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'S',      (char )'p',      (char )'e',      (char )'c', 
        (char )'i',      (char )'f',      (char )'y',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'m',      (char )'a',      (char )'x',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'m',      (char )'i',      (char )'n',      (char )' ', 
        (char )'n',      (char )'u',      (char )'m',      (char )'b', 
        (char )'e',      (char )'r',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'i',      (char )'t', 
        (char )'e',      (char )'r',      (char )'a',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )'s', 
        (char )' ',      (char )'(',      (char )'1',      (char )'5', 
        (char )',',      (char )'1',      (char )')',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'I',      (char )' ',      (char )'l', 
        (char )'v',      (char )'l',      (char )'[',      (char )',', 
        (char )'i',      (char )'n',      (char )'t',      (char )'v', 
        (char )'l',      (char )']',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'S',      (char )'p', 
        (char )'e',      (char )'c',      (char )'i',      (char )'f', 
        (char )'y',      (char )' ',      (char )'c',      (char )'o', 
        (char )'n',      (char )'f',      (char )'i',      (char )'d', 
        (char )'e',      (char )'n',      (char )'c',      (char )'e', 
        (char )' ',      (char )'l',      (char )'e',      (char )'v', 
        (char )'e',      (char )'l',      (char )' ',      (char )'(', 
        (char )'9',      (char )'5',      (char )' ',      (char )'o', 
        (char )'r',      (char )' ',      (char )'9',      (char )'9', 
        (char )')',      (char )' ',      (char )'(',      (char )'9', 
        (char )'9',      (char )')',      (char )' ',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'c',      (char )'o', 
        (char )'n',      (char )'f',      (char )'i',      (char )'d', 
        (char )'e',      (char )'n',      (char )'c',      (char )'e', 
        (char )' ',      (char )'i',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'v',      (char )'a', 
        (char )'l',      (char )' ',      (char )'i',      (char )'n', 
        (char )' ',      (char )'p',      (char )'e',      (char )'r', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'a',      (char )'g',      (char )'e',      (char )' ', 
        (char )'(',      (char )'1',      (char )'0',      (char )')', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'j',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'K', 
        (char )'e',      (char )'e',      (char )'p',      (char )' ', 
        (char )'a',      (char )'d',      (char )'d',      (char )'i', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'a',      (char )'l',      (char )' ',      (char )'t', 
        (char )'i',      (char )'m',      (char )'i',      (char )'n', 
        (char )'g',      (char )' ',      (char )'s',      (char )'t', 
        (char )'a',      (char )'t',      (char )'i',      (char )'s', 
        (char )'t',      (char )'i',      (char )'c',      (char )'s', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'l',      (char )' ', 
        (char )'t',      (char )'e',      (char )'s',      (char )'t', 
        (char )'l',      (char )'e',      (char )'n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'S', 
        (char )'p',      (char )'e',      (char )'c',      (char )'i', 
        (char )'f',      (char )'y',      (char )' ',      (char )'t', 
        (char )'e',      (char )'s',      (char )'t',      (char )' ', 
        (char )'d',      (char )'u',      (char )'r',      (char )'a', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'(',      (char )'>',      (char )'0', 
        (char )' ',      (char )'s',      (char )'e',      (char )'c', 
        (char )'s',      (char )')',      (char )' ',      (char )'(', 
        (char )'<',      (char )'0',      (char )' ',      (char )'b', 
        (char )'y',      (char )'t',      (char )'e',      (char )'s', 
        (char )'|',      (char )'t',      (char )'r',      (char )'a', 
        (char )'n',      (char )'s',      (char )')',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'L',      (char )' ',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'|', 
        (char )'i',      (char )'p',      (char )',',      (char )'f', 
        (char )'a',      (char )'m',      (char )' ',      (char )'*', 
        (char )' ',      (char )' ',      (char )'S',      (char )'p', 
        (char )'e',      (char )'c',      (char )'i',      (char )'f', 
        (char )'y',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'l',      (char )'o', 
        (char )'c',      (char )'a',      (char )'l',      (char )' ', 
        (char )'i',      (char )'p',      (char )'|',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'a',      (char )'d',      (char )'d',      (char )'r', 
        (char )'e',      (char )'s',      (char )'s',      (char )' ', 
        (char )'f',      (char )'a',      (char )'m',      (char )'i', 
        (char )'l',      (char )'y',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'o',      (char )' ',      (char )'s',      (char )'e', 
        (char )'n',      (char )'d',      (char )',',      (char )'r', 
        (char )'e',      (char )'c',      (char )'v',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'S',      (char )'e',      (char )'t', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'l',      (char )'o',      (char )'c', 
        (char )'a',      (char )'l',      (char )' ',      (char )'s', 
        (char )'e',      (char )'n',      (char )'d',      (char )',', 
        (char )'r',      (char )'e',      (char )'c',      (char )'v', 
        (char )' ',      (char )'b',      (char )'u',      (char )'f', 
        (char )'f',      (char )'e',      (char )'r',      (char )' ', 
        (char )'o',      (char )'f',      (char )'f',      (char )'s', 
        (char )'e',      (char )'t',      (char )'s',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'O',      (char )' ',      (char )'s', 
        (char )'e',      (char )'n',      (char )'d',      (char )',', 
        (char )'r',      (char )'e',      (char )'c',      (char )'v', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'S',      (char )'e', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'r',      (char )'e', 
        (char )'m',      (char )'o',      (char )'t',      (char )'e', 
        (char )' ',      (char )'s',      (char )'e',      (char )'n', 
        (char )'d',      (char )',',      (char )'r',      (char )'e', 
        (char )'c',      (char )'v',      (char )' ',      (char )'b', 
        (char )'u',      (char )'f',      (char )'f',      (char )'e', 
        (char )'r',      (char )' ',      (char )'o',      (char )'f', 
        (char )'f',      (char )'s',      (char )'e',      (char )'t', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'n',      (char )' ', 
        (char )'n',      (char )'u',      (char )'m',      (char )'c', 
        (char )'p',      (char )'u',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'S', 
        (char )'e',      (char )'t',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'n', 
        (char )'u',      (char )'m',      (char )'b',      (char )'e', 
        (char )'r',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'p',      (char )'r',      (char )'o', 
        (char )'c',      (char )'e',      (char )'s',      (char )'s', 
        (char )'o',      (char )'r',      (char )'s',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )' ', 
        (char )'C',      (char )'P',      (char )'U',      (char )' ', 
        (char )'u',      (char )'t',      (char )'i',      (char )'l', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'N',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'E', 
        (char )'s',      (char )'t',      (char )'a',      (char )'b', 
        (char )'l',      (char )'i',      (char )'s',      (char )'h', 
        (char )' ',      (char )'n',      (char )'o',      (char )' ', 
        (char )'c',      (char )'o',      (char )'n',      (char )'t', 
        (char )'r',      (char )'o',      (char )'l',      (char )' ', 
        (char )'c',      (char )'o',      (char )'n',      (char )'n', 
        (char )'e',      (char )'c',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )',',      (char )' ', 
        (char )'d',      (char )'o',      (char )' ',      (char )'\'', 
        (char )'s',      (char )'e',      (char )'n',      (char )'d', 
        (char )'\'',      (char )' ',      (char )'s',      (char )'i', 
        (char )'d',      (char )'e',      (char )' ',      (char )'o', 
        (char )'n',      (char )'l',      (char )'y',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'p',      (char )' ',      (char )'p', 
        (char )'o',      (char )'r',      (char )'t',      (char )',', 
        (char )'l',      (char )'p',      (char )'o',      (char )'r', 
        (char )'t',      (char )'*',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'S',      (char )'p', 
        (char )'e',      (char )'c',      (char )'i',      (char )'f', 
        (char )'y',      (char )' ',      (char )'n',      (char )'e', 
        (char )'t',      (char )'s',      (char )'e',      (char )'r', 
        (char )'v',      (char )'e',      (char )'r',      (char )' ', 
        (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )' ',      (char )'n',      (char )'u',      (char )'m', 
        (char )'b',      (char )'e',      (char )'r',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )'/', 
        (char )'o',      (char )'r',      (char )' ',      (char )'l', 
        (char )'o',      (char )'c',      (char )'a',      (char )'l', 
        (char )' ',      (char )'p',      (char )'o',      (char )'r', 
        (char )'t',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'P', 
        (char )' ',      (char )'0',      (char )'|',      (char )'1', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'D',      (char )'o',      (char )'n',      (char )'\'', 
        (char )'t',      (char )'/',      (char )'D',      (char )'o', 
        (char )' ',      (char )'d',      (char )'i',      (char )'s', 
        (char )'p',      (char )'l',      (char )'a',      (char )'y', 
        (char )' ',      (char )'t',      (char )'e',      (char )'s', 
        (char )'t',      (char )' ',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'e',      (char )'r', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'r', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'A',      (char )'l',      (char )'l',      (char )'o', 
        (char )'w',      (char )' ',      (char )'c',      (char )'o', 
        (char )'n',      (char )'f',      (char )'i',      (char )'d', 
        (char )'e',      (char )'n',      (char )'c',      (char )'e', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'b',      (char )'e',      (char )' ',      (char )'h', 
        (char )'i',      (char )'t',      (char )' ',      (char )'o', 
        (char )'n',      (char )' ',      (char )'r',      (char )'e', 
        (char )'s',      (char )'u',      (char )'l',      (char )'t', 
        (char )' ',      (char )'o',      (char )'n',      (char )'l', 
        (char )'y',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'s', 
        (char )' ',      (char )'s',      (char )'e',      (char )'c', 
        (char )'o',      (char )'n',      (char )'d',      (char )'s', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'W',      (char )'a',      (char )'i',      (char )'t', 
        (char )' ',      (char )'s',      (char )'e',      (char )'c', 
        (char )'o',      (char )'n',      (char )'d',      (char )'s', 
        (char )' ',      (char )'b',      (char )'e',      (char )'t', 
        (char )'w',      (char )'e',      (char )'e',      (char )'n', 
        (char )' ',      (char )'t',      (char )'e',      (char )'s', 
        (char )'t',      (char )' ',      (char )'s',      (char )'e', 
        (char )'t',      (char )'u',      (char )'p',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'t',      (char )'e',      (char )'s',      (char )'t', 
        (char )' ',      (char )'s',      (char )'t',      (char )'a', 
        (char )'r',      (char )'t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'S',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'S',      (char )'e',      (char )'t', 
        (char )' ',      (char )'S',      (char )'O',      (char )'_', 
        (char )'K',      (char )'E',      (char )'E',      (char )'P', 
        (char )'A',      (char )'L',      (char )'I',      (char )'V', 
        (char )'E',      (char )' ',      (char )'o',      (char )'n', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'d',      (char )'a',      (char )'t', 
        (char )'a',      (char )' ',      (char )'c',      (char )'o', 
        (char )'n',      (char )'n',      (char )'e',      (char )'c', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'t',      (char )' ', 
        (char )'t',      (char )'e',      (char )'s',      (char )'t', 
        (char )'n',      (char )'a',      (char )'m',      (char )'e', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'S', 
        (char )'p',      (char )'e',      (char )'c',      (char )'i', 
        (char )'f',      (char )'y',      (char )' ',      (char )'t', 
        (char )'e',      (char )'s',      (char )'t',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'p', 
        (char )'e',      (char )'r',      (char )'f',      (char )'o', 
        (char )'r',      (char )'m',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'T',      (char )' ',      (char )'l',      (char )'c', 
        (char )'p',      (char )'u',      (char )',',      (char )'r', 
        (char )'c',      (char )'p',      (char )'u',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )' ',      (char )'n',      (char )'e',      (char )'t', 
        (char )'p',      (char )'e',      (char )'r',      (char )'f', 
        (char )'/',      (char )'n',      (char )'e',      (char )'t', 
        (char )'s',      (char )'e',      (char )'r',      (char )'v', 
        (char )'e',      (char )'r',      (char )' ',      (char )'b', 
        (char )'e',      (char )' ',      (char )'b',      (char )'o', 
        (char )'u',      (char )'n',      (char )'d',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'l', 
        (char )'o',      (char )'c',      (char )'a',      (char )'l', 
        (char )'/',      (char )'r',      (char )'e',      (char )'m', 
        (char )'o',      (char )'t',      (char )'e',      (char )' ', 
        (char )'c',      (char )'p',      (char )'u',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'v',      (char )' ',      (char )'v', 
        (char )'e',      (char )'r',      (char )'b',      (char )'o', 
        (char )'s',      (char )'i',      (char )'t',      (char )'y', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'S',      (char )'p', 
        (char )'e',      (char )'c',      (char )'i',      (char )'f', 
        (char )'y',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'v',      (char )'e', 
        (char )'r',      (char )'b',      (char )'o',      (char )'s', 
        (char )'i',      (char )'t',      (char )'y',      (char )' ', 
        (char )'l',      (char )'e',      (char )'v',      (char )'e', 
        (char )'l',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'W', 
        (char )' ',      (char )'s',      (char )'e',      (char )'n', 
        (char )'d',      (char )',',      (char )'r',      (char )'e', 
        (char )'c',      (char )'v',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'S',      (char )'e',      (char )'t',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'n',      (char )'u',      (char )'m',      (char )'b', 
        (char )'e',      (char )'r',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'s',      (char )'e', 
        (char )'n',      (char )'d',      (char )',',      (char )'r', 
        (char )'e',      (char )'c',      (char )'v',      (char )' ', 
        (char )'b',      (char )'u',      (char )'f',      (char )'f', 
        (char )'e',      (char )'r',      (char )'s',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'v',      (char )' ',      (char )'l', 
        (char )'e',      (char )'v',      (char )'e',      (char )'l', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'S',      (char )'e', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'v',      (char )'e', 
        (char )'r',      (char )'b',      (char )'o',      (char )'s', 
        (char )'i',      (char )'t',      (char )'y',      (char )' ', 
        (char )'l',      (char )'e',      (char )'v',      (char )'e', 
        (char )'l',      (char )' ',      (char )'(',      (char )'d', 
        (char )'e',      (char )'f',      (char )'a',      (char )'u', 
        (char )'l',      (char )'t',      (char )' ',      (char )'1', 
        (char )',',      (char )' ',      (char )'m',      (char )'i', 
        (char )'n',      (char )' ',      (char )'0',      (char )')', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'V',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'D', 
        (char )'i',      (char )'s',      (char )'p',      (char )'l', 
        (char )'a',      (char )'y',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'n', 
        (char )'e',      (char )'t',      (char )'p',      (char )'e', 
        (char )'r',      (char )'f',      (char )' ',      (char )'v', 
        (char )'e',      (char )'r',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'e', 
        (char )'x',      (char )'i',      (char )'t',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'y',      (char )' ',      (char )'l', 
        (char )'o',      (char )'c',      (char )'a',      (char )'l', 
        (char )',',      (char )'r',      (char )'e',      (char )'m', 
        (char )'o',      (char )'t',      (char )'e',      (char )' ', 
        (char )' ',      (char )' ',      (char )'S',      (char )'e', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'s',      (char )'o', 
        (char )'c',      (char )'k',      (char )'e',      (char )'t', 
        (char )' ',      (char )'p',      (char )'r',      (char )'i', 
        (char )'o',      (char )'r',      (char )'i',      (char )'t', 
        (char )'y',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'Y', 
        (char )' ',      (char )'l',      (char )'o',      (char )'c', 
        (char )'a',      (char )'l',      (char )',',      (char )'r', 
        (char )'e',      (char )'m',      (char )'o',      (char )'t', 
        (char )'e',      (char )' ',      (char )' ',      (char )' ', 
        (char )'S',      (char )'e',      (char )'t',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'I',      (char )'P',      (char )'_',      (char )'T', 
        (char )'O',      (char )'S',      (char )'.',      (char )' ', 
        (char )'U',      (char )'s',      (char )'e',      (char )' ', 
        (char )'h',      (char )'e',      (char )'x',      (char )'a', 
        (char )'d',      (char )'e',      (char )'c',      (char )'i', 
        (char )'m',      (char )'a',      (char )'l',      (char )'.', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'Z',      (char )' ', 
        (char )'p',      (char )'a',      (char )'s',      (char )'s', 
        (char )'p',      (char )'h',      (char )'r',      (char )'a', 
        (char )'s',      (char )'e',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'S', 
        (char )'e',      (char )'t',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'p', 
        (char )'a',      (char )'s',      (char )'s',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'n', 
        (char )'e',      (char )'t',      (char )'s',      (char )'e', 
        (char )'r',      (char )'v',      (char )'e',      (char )'r', 
        (char )' ',      (char )'a',      (char )' ',      (char )'p', 
        (char )'a',      (char )'s',      (char )'s',      (char )'p', 
        (char )'h',      (char )'r',      (char )'a',      (char )'s', 
        (char )'e',      (char )'\n',      (char )'\000'};
#line 290 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
char netperf_usage2[633]  = 
#line 290
  {      (char )'\n',      (char )'F',      (char )'o',      (char )'r', 
        (char )' ',      (char )'t',      (char )'h',      (char )'o', 
        (char )'s',      (char )'e',      (char )' ',      (char )'o', 
        (char )'p',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )'s',      (char )' ',      (char )'t', 
        (char )'a',      (char )'k',      (char )'i',      (char )'n', 
        (char )'g',      (char )' ',      (char )'t',      (char )'w', 
        (char )'o',      (char )' ',      (char )'p',      (char )'a', 
        (char )'r',      (char )'m',      (char )'s',      (char )',', 
        (char )' ',      (char )'a',      (char )'t',      (char )' ', 
        (char )'l',      (char )'e',      (char )'a',      (char )'s', 
        (char )'t',      (char )' ',      (char )'o',      (char )'n', 
        (char )'e',      (char )' ',      (char )'m',      (char )'u', 
        (char )'s',      (char )'t',      (char )' ',      (char )'b', 
        (char )'e',      (char )' ',      (char )'s',      (char )'p', 
        (char )'e',      (char )'c',      (char )'i',      (char )'f', 
        (char )'i',      (char )'e',      (char )'d',      (char )';', 
        (char )'\n',      (char )'s',      (char )'p',      (char )'e', 
        (char )'c',      (char )'i',      (char )'f',      (char )'y', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'o',      (char )'n',      (char )'e',      (char )' ', 
        (char )'v',      (char )'a',      (char )'l',      (char )'u', 
        (char )'e',      (char )' ',      (char )'w',      (char )'i', 
        (char )'t',      (char )'h',      (char )'o',      (char )'u', 
        (char )'t',      (char )' ',      (char )'a',      (char )' ', 
        (char )'c',      (char )'o',      (char )'m',      (char )'m', 
        (char )'a',      (char )' ',      (char )'w',      (char )'i', 
        (char )'l',      (char )'l',      (char )' ',      (char )'s', 
        (char )'e',      (char )'t',      (char )' ',      (char )'b', 
        (char )'o',      (char )'t',      (char )'h',      (char )' ', 
        (char )'p',      (char )'a',      (char )'r',      (char )'m', 
        (char )'s',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'t',      (char )'h',      (char )'a', 
        (char )'t',      (char )'\n',      (char )'v',      (char )'a', 
        (char )'l',      (char )'u',      (char )'e',      (char )',', 
        (char )' ',      (char )'s',      (char )'p',      (char )'e', 
        (char )'c',      (char )'i',      (char )'f',      (char )'y', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'a',      (char )' ',      (char )'v',      (char )'a', 
        (char )'l',      (char )'u',      (char )'e',      (char )' ', 
        (char )'w',      (char )'i',      (char )'t',      (char )'h', 
        (char )' ',      (char )'a',      (char )' ',      (char )'l', 
        (char )'e',      (char )'a',      (char )'d',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'c', 
        (char )'o',      (char )'m',      (char )'m',      (char )'a', 
        (char )' ',      (char )'w',      (char )'i',      (char )'l', 
        (char )'l',      (char )' ',      (char )'s',      (char )'e', 
        (char )'t',      (char )' ',      (char )'j',      (char )'u', 
        (char )'s',      (char )'t',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'s', 
        (char )'e',      (char )'c',      (char )'o',      (char )'n', 
        (char )'d',      (char )'\n',      (char )'p',      (char )'a', 
        (char )'r',      (char )'m',      (char )',',      (char )' ', 
        (char )'a',      (char )' ',      (char )'v',      (char )'a', 
        (char )'l',      (char )'u',      (char )'e',      (char )' ', 
        (char )'w',      (char )'i',      (char )'t',      (char )'h', 
        (char )' ',      (char )'a',      (char )' ',      (char )'t', 
        (char )'r',      (char )'a',      (char )'i',      (char )'l', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'c',      (char )'o',      (char )'m',      (char )'m', 
        (char )'a',      (char )' ',      (char )'w',      (char )'i', 
        (char )'l',      (char )'l',      (char )' ',      (char )'s', 
        (char )'e',      (char )'t',      (char )' ',      (char )'j', 
        (char )'u',      (char )'s',      (char )'t',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'f',      (char )'i',      (char )'r',      (char )'s', 
        (char )'t',      (char )'.',      (char )' ',      (char )'T', 
        (char )'o',      (char )' ',      (char )'s',      (char )'e', 
        (char )'t',      (char )'\n',      (char )'e',      (char )'a', 
        (char )'c',      (char )'h',      (char )' ',      (char )'p', 
        (char )'a',      (char )'r',      (char )'m',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'u', 
        (char )'n',      (char )'i',      (char )'q',      (char )'u', 
        (char )'e',      (char )' ',      (char )'v',      (char )'a', 
        (char )'l',      (char )'u',      (char )'e',      (char )'s', 
        (char )',',      (char )' ',      (char )'s',      (char )'p', 
        (char )'e',      (char )'c',      (char )'i',      (char )'f', 
        (char )'y',      (char )' ',      (char )'b',      (char )'o', 
        (char )'t',      (char )'h',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'s', 
        (char )'e',      (char )'p',      (char )'a',      (char )'r', 
        (char )'a',      (char )'t',      (char )'e',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )'m', 
        (char )' ',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )' ',      (char )'a',      (char )'\n', 
        (char )'c',      (char )'o',      (char )'m',      (char )'m', 
        (char )'a',      (char )'.',      (char )'\n',      (char )'\n', 
        (char )'*',      (char )' ',      (char )'F',      (char )'o', 
        (char )'r',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )'s',      (char )'e',      (char )' ', 
        (char )'o',      (char )'p',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'s',      (char )' ', 
        (char )'t',      (char )'a',      (char )'k',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'t', 
        (char )'w',      (char )'o',      (char )' ',      (char )'p', 
        (char )'a',      (char )'r',      (char )'m',      (char )'s', 
        (char )',',      (char )' ',      (char )'s',      (char )'p', 
        (char )'e',      (char )'c',      (char )'i',      (char )'f', 
        (char )'y',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'o',      (char )'n',      (char )'e', 
        (char )' ',      (char )'v',      (char )'a',      (char )'l', 
        (char )'u',      (char )'e',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )' ', 
        (char )'n',      (char )'o',      (char )' ',      (char )'c', 
        (char )'o',      (char )'m',      (char )'m',      (char )'a', 
        (char )'\n',      (char )'w',      (char )'i',      (char )'l', 
        (char )'l',      (char )' ',      (char )'o',      (char )'n', 
        (char )'l',      (char )'y',      (char )' ',      (char )'s', 
        (char )'e',      (char )'t',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'r',      (char )'s',      (char )'t', 
        (char )' ',      (char )'p',      (char )'a',      (char )'r', 
        (char )'m',      (char )'s',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'w', 
        (char )'i',      (char )'l',      (char )'l',      (char )' ', 
        (char )'l',      (char )'e',      (char )'a',      (char )'v', 
        (char )'e',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'s',      (char )'e', 
        (char )'c',      (char )'o',      (char )'n',      (char )'d', 
        (char )' ',      (char )'a',      (char )'t',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'d',      (char )'e',      (char )'f',      (char )'a', 
        (char )'u',      (char )'l',      (char )'t',      (char )'\n', 
        (char )'v',      (char )'a',      (char )'l',      (char )'u', 
        (char )'e',      (char )'.',      (char )' ',      (char )'T', 
        (char )'o',      (char )' ',      (char )'s',      (char )'e', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'s',      (char )'e', 
        (char )'c',      (char )'o',      (char )'n',      (char )'d', 
        (char )' ',      (char )'v',      (char )'a',      (char )'l', 
        (char )'u',      (char )'e',      (char )' ',      (char )'i', 
        (char )'t',      (char )' ',      (char )'m',      (char )'u', 
        (char )'s',      (char )'t',      (char )' ',      (char )'b', 
        (char )'e',      (char )' ',      (char )'p',      (char )'r', 
        (char )'e',      (char )'c',      (char )'e',      (char )'d', 
        (char )'e',      (char )'d',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )' ', 
        (char )'a',      (char )' ',      (char )'c',      (char )'o', 
        (char )'m',      (char )'m',      (char )'a',      (char )' ', 
        (char )'o',      (char )'r',      (char )' ',      (char )'b', 
        (char )'e',      (char )' ',      (char )'a',      (char )'\n', 
        (char )'c',      (char )'o',      (char )'m',      (char )'m', 
        (char )'a',      (char )'-',      (char )'s',      (char )'e', 
        (char )'p',      (char )'a',      (char )'r',      (char )'a', 
        (char )'t',      (char )'e',      (char )'d',      (char )' ', 
        (char )'p',      (char )'a',      (char )'i',      (char )'r', 
        (char )'.',      (char )' ',      (char )'T',      (char )'h', 
        (char )'i',      (char )'s',      (char )' ',      (char )'i', 
        (char )'s',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'r',      (char )'e',      (char )'t', 
        (char )'a',      (char )'i',      (char )'n',      (char )' ', 
        (char )'p',      (char )'r',      (char )'e',      (char )'v', 
        (char )'i',      (char )'o',      (char )'u',      (char )'s', 
        (char )' ',      (char )'n',      (char )'e',      (char )'t', 
        (char )'p',      (char )'e',      (char )'r',      (char )'f', 
        (char )' ',      (char )'b',      (char )'e',      (char )'h', 
        (char )'a',      (char )'v',      (char )'i',      (char )'o', 
        (char )'u',      (char )'r',      (char )'.',      (char )'\n', 
        (char )'\000'};
#line 309 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
void break_args(char *s , char *arg1 , char *arg2 ) 
{ 
  char *ns ;
  char *tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 314
  ns = strchr((char const   *)s, ',');
  }
#line 315
  if (ns) {
#line 317
    tmp = ns;
#line 317
    ns ++;
#line 317
    *tmp = (char )'\000';
    {
#line 318
    while (1) {
      while_continue: /* CIL Label */ ;
#line 318
      tmp___0 = arg2;
#line 318
      arg2 ++;
#line 318
      tmp___2 = ns;
#line 318
      ns ++;
#line 318
      tmp___1 = *tmp___2;
#line 318
      *tmp___0 = tmp___1;
#line 318
      if (! ((int )tmp___1 != 0)) {
#line 318
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 323
    ns = s;
    {
#line 324
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 324
      tmp___3 = arg2;
#line 324
      arg2 ++;
#line 324
      tmp___5 = ns;
#line 324
      ns ++;
#line 324
      tmp___4 = *tmp___5;
#line 324
      *tmp___3 = tmp___4;
#line 324
      if (! ((int )tmp___4 != 0)) {
#line 324
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 326
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 326
    tmp___6 = arg1;
#line 326
    arg1 ++;
#line 326
    tmp___8 = s;
#line 326
    s ++;
#line 326
    tmp___7 = *tmp___8;
#line 326
    *tmp___6 = tmp___7;
#line 326
    if (! ((int )tmp___7 != 0)) {
#line 326
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 327
  return;
}
}
#line 336 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
void break_args_explicit_sep(char *s , int sep , char *arg1 , char *arg2 ) 
{ 
  char *ns ;
  char *tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 341
  ns = strchr((char const   *)s, sep);
  }
#line 342
  if (ns) {
#line 344
    tmp = ns;
#line 344
    ns ++;
#line 344
    *tmp = (char )'\000';
    {
#line 345
    while (1) {
      while_continue: /* CIL Label */ ;
#line 345
      tmp___0 = arg2;
#line 345
      arg2 ++;
#line 345
      tmp___2 = ns;
#line 345
      ns ++;
#line 345
      tmp___1 = *tmp___2;
#line 345
      *tmp___0 = tmp___1;
#line 345
      if (! ((int )tmp___1 != 0)) {
#line 345
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 350
    *arg2 = (char )'\000';
  }
  {
#line 352
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 352
    tmp___3 = arg1;
#line 352
    arg1 ++;
#line 352
    tmp___5 = s;
#line 352
    s ++;
#line 352
    tmp___4 = *tmp___5;
#line 352
    *tmp___3 = tmp___4;
#line 352
    if (! ((int )tmp___4 != 0)) {
#line 352
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 354
  return;
}
}
#line 360 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
void break_args_explicit(char *s , char *arg1 , char *arg2 ) 
{ 


  {
  {
#line 364
  break_args_explicit_sep(s, ',', arg1, arg2);
  }
#line 365
  return;
}
}
#line 373 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int parse_address_family(char *family_string ) 
{ 
  char temp[10] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 379
  strncpy((char */* __restrict  */)(temp), (char const   */* __restrict  */)family_string,
          (size_t )10);
  }
#line 381
  if (debug) {
    {
#line 382
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Attempting to parse address family from %s derived from %s\n",
            temp, family_string);
    }
  }
  {
#line 388
  tmp = strstr((char const   *)(temp), "6");
  }
#line 388
  if (tmp) {
#line 389
    return (10);
  }
  {
#line 392
  tmp___0 = strstr((char const   *)(temp), "inet");
  }
#line 392
  if (tmp___0) {
#line 394
    return (2);
  } else {
    {
#line 392
    tmp___1 = strstr((char const   *)(temp), "4");
    }
#line 392
    if (tmp___1) {
#line 394
      return (2);
    }
  }
  {
#line 397
  tmp___2 = strstr((char const   *)(temp), "af_rds");
  }
#line 397
  if (tmp___2) {
#line 399
    return (21);
  } else {
    {
#line 397
    tmp___3 = strstr((char const   *)(temp), "32");
    }
#line 397
    if (tmp___3) {
#line 399
      return (21);
    }
  }
  {
#line 402
  tmp___4 = strstr((char const   *)(temp), "unspec");
  }
#line 402
  if (tmp___4) {
#line 404
    return (0);
  } else {
    {
#line 402
    tmp___5 = strstr((char const   *)(temp), "0");
    }
#line 402
    if (tmp___5) {
#line 404
      return (0);
    }
  }
  {
#line 406
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"WARNING! %s not recognized as an address family, using AF_UNPSEC\nAre you sure netperf was configured for that address family?\n",
          family_string);
#line 410
  fflush(where);
  }
#line 411
  return (0);
}
}
#line 414 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int parse_socket_type(char *socket_string ) 
{ 
  char temp[10] ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 419
  strncpy((char */* __restrict  */)(temp), (char const   */* __restrict  */)socket_string,
          (size_t )10);
  }
#line 421
  if (debug) {
    {
#line 422
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Attempting to parse socket type from %s derived from %s\n",
            temp, socket_string);
    }
  }
  {
#line 429
  tmp = strstr((char const   *)(temp), "stream");
  }
#line 429
  if (tmp) {
#line 430
    return (1);
  }
  {
#line 433
  tmp___0 = strstr((char const   *)(temp), "dgram");
  }
#line 433
  if (tmp___0) {
#line 434
    return (2);
  }
#line 436
  return (-1);
}
}
#line 440 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int parse_direction(char *direction_string ) 
{ 
  char arg1[8192] ;
  char arg2[8192] ;
  int left ;
  int right ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 446
  if ((unsigned long )((void *)0) == (unsigned long )direction_string) {
#line 447
    return (0);
  }
#line 450
  if ((int )*(direction_string + 0) == 0) {
#line 451
    return (0);
  }
  {
#line 457
  break_args_explicit_sep(direction_string, '|', arg1, arg2);
#line 460
  right = parse_direction(arg2);
  }
#line 463
  if ((int )arg1[0] == 0) {
#line 464
    left = 0;
  } else {
    {
#line 466
    tmp___4 = strcasecmp((char const   *)(arg1), "xmit");
    }
#line 466
    if (tmp___4 == 0) {
#line 470
      left = 2;
    } else {
      {
#line 466
      tmp___5 = strcasecmp((char const   *)(arg1), "send");
      }
#line 466
      if (tmp___5 == 0) {
#line 470
        left = 2;
      } else {
        {
#line 466
        tmp___6 = strcasecmp((char const   *)(arg1), "stream");
        }
#line 466
        if (tmp___6 == 0) {
#line 470
          left = 2;
        } else {
          {
#line 466
          tmp___7 = strcasecmp((char const   *)(arg1), "transmit");
          }
#line 466
          if (tmp___7 == 0) {
#line 470
            left = 2;
          } else {
            {
#line 472
            tmp___1 = strcasecmp((char const   *)(arg1), "recv");
            }
#line 472
            if (tmp___1 == 0) {
#line 476
              left = 4;
            } else {
              {
#line 472
              tmp___2 = strcasecmp((char const   *)(arg1), "receive");
              }
#line 472
              if (tmp___2 == 0) {
#line 476
                left = 4;
              } else {
                {
#line 472
                tmp___3 = strcasecmp((char const   *)(arg1), "maerts");
                }
#line 472
                if (tmp___3 == 0) {
#line 476
                  left = 4;
                } else {
                  {
#line 478
                  tmp___0 = strcasecmp((char const   *)(arg1), "rr");
                  }
#line 478
                  if (tmp___0 == 0) {
#line 479
                    left = 6;
                  } else {
                    {
#line 484
                    tmp = strtol((char const   */* __restrict  */)(arg1), (char **/* __restrict  */)((void *)0),
                                 0);
#line 484
                    left = (int )tmp;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 487
  return (left | right);
}
}
#line 491 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
int parse_protocol(char *protocol_string ) 
{ 
  char temp[10] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 496
  strncpy((char */* __restrict  */)(temp), (char const   */* __restrict  */)protocol_string,
          (size_t )10);
  }
#line 498
  if (debug) {
    {
#line 499
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Attempting to parse protocol from %s derived from %s\n",
            temp, protocol_string);
    }
  }
  {
#line 508
  tmp = strcasecmp((char const   *)(temp), "tcp");
  }
#line 508
  if (! tmp) {
#line 509
    socket_type = 1;
#line 510
    return (6);
  }
  {
#line 513
  tmp___0 = strcasecmp((char const   *)(temp), "udp");
  }
#line 513
  if (! tmp___0) {
#line 514
    socket_type = 2;
#line 515
    return (17);
  }
  {
#line 521
  tmp___1 = strcasecmp((char const   *)(temp), "sctp");
  }
#line 521
  if (! tmp___1) {
#line 523
    return (132);
  }
  {
#line 533
  tmp___2 = strcasecmp((char const   *)(temp), "dccp");
  }
#line 533
  if (! tmp___2) {
#line 534
    socket_type = 6;
#line 535
    return (33);
  }
  {
#line 539
  tmp___3 = strcasecmp((char const   *)(temp), "udplite");
  }
#line 539
  if (! tmp___3) {
#line 540
    socket_type = 2;
#line 541
    return (136);
  }
#line 544
  return (0);
}
}
#line 548 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
void print_netserver_usage(void) 
{ 


  {
  {
#line 551
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          netserver_usage);
  }
#line 552
  return;
}
}
#line 555 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
void print_netperf_usage(void) 
{ 


  {
  {
#line 558
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s",
          netperf_usage1, netperf_usage2);
  }
#line 559
  return;
}
}
#line 562 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
static void convert_to_upper(char *source ) 
{ 
  int i ;
  int length ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 568
  tmp = strlen((char const   *)source);
#line 568
  length = (int )tmp;
#line 570
  i = 0;
  }
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
#line 570
    if (! (i < length)) {
#line 570
      goto while_break;
    }
    {
#line 571
    tmp___0 = toupper((int )*(source + i));
#line 571
    *(source + i) = (char )tmp___0;
#line 570
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 574
  return;
}
}
#line 578 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
void scan_cmd_line(int argc , char **argv ) 
{ 
  int cmnd_len ;
  char *p ;
  int c ;
  char arg1[8192] ;
  char arg2[8192] ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  double tmp___9 ;
  unsigned short const   **tmp___10 ;
  double tmp___11 ;
  unsigned short const   **tmp___12 ;
  size_t tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  double tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  void *tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  size_t tmp___35 ;
  void *tmp___36 ;
  struct addrinfo *ai ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  int tmp___56 ;

  {
  {
#line 592
  tmp = strlen((char const   *)*(argv + 0));
#line 592
  tmp___0 = malloc(tmp + 1UL);
#line 592
  program = (char *)tmp___0;
  }
#line 593
  if ((unsigned long )program == (unsigned long )((void *)0)) {
    {
#line 594
    printf((char const   */* __restrict  */)"malloc() to store program name failed!\n");
#line 595
    exit(-1);
    }
  }
  {
#line 597
  strcpy((char */* __restrict  */)program, (char const   */* __restrict  */)*(argv + 0));
#line 600
  command_line = (char *)((void *)0);
#line 601
  cmnd_len = 0;
#line 602
  c = 0;
  }
  {
#line 602
  while (1) {
    while_continue: /* CIL Label */ ;
#line 602
    if (! (c < argc)) {
#line 602
      goto while_break;
    }
    {
#line 603
    tmp___1 = strlen((char const   *)*(argv + c));
#line 603
    cmnd_len = (int )((size_t )cmnd_len + tmp___1);
#line 602
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 605
  cmnd_len += argc;
#line 606
  tmp___2 = malloc((size_t )(cmnd_len + 1));
#line 606
  command_line = (char *)tmp___2;
  }
#line 608
  if ((unsigned long )command_line == (unsigned long )((void *)0)) {
    {
#line 609
    printf((char const   */* __restrict  */)"malloc(%d) failed!\n", cmnd_len);
#line 610
    exit(-1);
    }
  }
#line 612
  p = command_line;
#line 613
  c = 0;
  {
#line 613
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 613
    if (! (c < argc)) {
#line 613
      goto while_break___0;
    }
    {
#line 614
    tmp___3 = strlen((char const   *)*(argv + c));
#line 614
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)*(argv + c),
           tmp___3);
#line 615
    tmp___4 = strlen((char const   *)*(argv + c));
#line 615
    p += tmp___4;
#line 616
    *p = (char )' ';
#line 617
    p ++;
#line 613
    c ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 619
  p --;
#line 619
  *p = (char)0;
  {
#line 627
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 627
    c = getopt(argc, (char * const  *)argv, "A:a:b:B:CcdD:f:F:H:hi:I:jk:K:l:L:n:NO:o:P:p:rSs:t:T:v:VW:w:y:Y:Z:46");
    }
#line 627
    if (! (c != -1)) {
#line 627
      goto while_break___1;
    }
    {
#line 630
    if (c == 104) {
#line 630
      goto case_104;
    }
#line 630
    if (c == 63) {
#line 630
      goto case_104;
    }
#line 633
    if (c == 97) {
#line 633
      goto case_97;
    }
#line 642
    if (c == 65) {
#line 642
      goto case_65;
    }
#line 651
    if (c == 99) {
#line 651
      goto case_99;
    }
#line 661
    if (c == 67) {
#line 661
      goto case_67;
    }
#line 670
    if (c == 100) {
#line 670
      goto case_100;
    }
#line 673
    if (c == 68) {
#line 673
      goto case_68;
    }
#line 693
    if (c == 102) {
#line 693
      goto case_102;
    }
#line 697
    if (c == 70) {
#line 697
      goto case_70;
    }
#line 720
    if (c == 105) {
#line 720
      goto case_105;
    }
#line 741
    if (c == 73) {
#line 741
      goto case_73;
    }
#line 766
    if (c == 106) {
#line 766
      goto case_106;
    }
#line 770
    if (c == 107) {
#line 770
      goto case_107;
    }
#line 784
    if (c == 75) {
#line 784
      goto case_75;
    }
#line 798
    if (c == 110) {
#line 798
      goto case_110;
    }
#line 801
    if (c == 78) {
#line 801
      goto case_78;
    }
#line 804
    if (c == 111) {
#line 804
      goto case_111;
    }
#line 812
    if (c == 79) {
#line 812
      goto case_79;
    }
#line 820
    if (c == 80) {
#line 820
      goto case_80;
    }
#line 825
    if (c == 114) {
#line 825
      goto case_114;
    }
#line 831
    if (c == 83) {
#line 831
      goto case_83;
    }
#line 835
    if (c == 115) {
#line 835
      goto case_115;
    }
#line 840
    if (c == 116) {
#line 840
      goto case_116;
    }
#line 846
    if (c == 84) {
#line 846
      goto case_84;
    }
#line 859
    if (c == 87) {
#line 859
      goto case_87;
    }
#line 868
    if (c == 121) {
#line 868
      goto case_121;
    }
#line 884
    if (c == 89) {
#line 884
      goto case_89;
    }
#line 907
    if (c == 90) {
#line 907
      goto case_90;
    }
#line 922
    if (c == 108) {
#line 922
      goto case_108;
    }
#line 933
    if (c == 118) {
#line 933
      goto case_118;
    }
#line 937
    if (c == 112) {
#line 937
      goto case_112;
    }
#line 948
    if (c == 72) {
#line 948
      goto case_72;
    }
#line 958
    if (c == 76) {
#line 958
      goto case_76;
    }
#line 968
    if (c == 119) {
#line 968
      goto case_119;
    }
#line 991
    if (c == 98) {
#line 991
      goto case_98;
    }
#line 1020
    if (c == 66) {
#line 1020
      goto case_66;
    }
#line 1030
    if (c == 52) {
#line 1030
      goto case_52;
    }
#line 1034
    if (c == 54) {
#line 1034
      goto case_54;
    }
#line 1043
    if (c == 86) {
#line 1043
      goto case_86;
    }
#line 628
    goto switch_break;
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 631
    print_netperf_usage();
#line 632
    exit(1);
    }
    case_97: /* CIL Label */ 
    {
#line 635
    break_args(optarg, arg1, arg2);
    }
#line 636
    if (arg1[0]) {
      {
#line 637
      tmp___5 = convert(arg1);
#line 637
      local_send_align = (int )tmp___5;
      }
    }
#line 639
    if (arg2[0]) {
      {
#line 640
      tmp___6 = convert(arg2);
#line 640
      local_recv_align = (int )tmp___6;
      }
    }
#line 641
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 644
    break_args(optarg, arg1, arg2);
    }
#line 645
    if (arg1[0]) {
      {
#line 646
      tmp___7 = convert(arg1);
#line 646
      remote_send_align = (int )tmp___7;
      }
    }
#line 648
    if (arg2[0]) {
      {
#line 649
      tmp___8 = convert(arg2);
#line 649
      remote_recv_align = (int )tmp___8;
      }
    }
#line 650
    goto switch_break;
    case_99: /* CIL Label */ 
#line 654
    if (*(argv + optind)) {
      {
#line 654
      tmp___10 = __ctype_b_loc();
      }
#line 654
      if ((int const   )*(*tmp___10 + (int )((unsigned char )*(*(argv + optind) + 0))) & 2048) {
        {
#line 656
        tmp___9 = atof((char const   *)*(argv + optind));
#line 656
        local_cpu_rate = (float )tmp___9;
#line 657
        optind ++;
        }
      }
    }
#line 659
    local_cpu_usage ++;
#line 660
    goto switch_break;
    case_67: /* CIL Label */ 
#line 663
    if (*(argv + optind)) {
      {
#line 663
      tmp___12 = __ctype_b_loc();
      }
#line 663
      if ((int const   )*(*tmp___12 + (int )((unsigned char )*(*(argv + optind) + 0))) & 2048) {
        {
#line 665
        tmp___11 = atof((char const   *)*(argv + optind));
#line 665
        remote_cpu_rate = (float )tmp___11;
#line 666
        optind ++;
        }
      }
    }
#line 668
    remote_cpu_usage ++;
#line 669
    goto switch_break;
    case_100: /* CIL Label */ 
#line 671
    debug ++;
#line 672
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 688
    printf((char const   */* __restrict  */)"Sorry, Demo Mode not configured into this netperf.\nPlease consider reconfiguring netperf with\n--enable-demo=yes and recompiling\n");
    }
#line 692
    goto switch_break;
    case_102: /* CIL Label */ 
#line 695
    libfmt = *optarg;
#line 696
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 702
    break_args_explicit(optarg, arg1, arg2);
    }
#line 703
    if (arg1[0]) {
      {
#line 704
      strncpy((char */* __restrict  */)(local_fill_file), (char const   */* __restrict  */)(arg1),
              sizeof(local_fill_file));
#line 705
      local_fill_file[sizeof(local_fill_file) - 1UL] = (char )'\000';
      }
    }
#line 707
    if (arg2[0]) {
      {
#line 708
      tmp___13 = strlen((char const   *)(arg2));
      }
#line 708
      if (tmp___13 > sizeof(remote_fill_file) - 1UL) {
        {
#line 709
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Remote fill file name must be less than %d characters\n",
                (int )sizeof(remote_fill_file));
#line 712
        fflush(stderr);
#line 713
        exit(-1);
        }
      }
      {
#line 716
      strncpy((char */* __restrict  */)(remote_fill_file), (char const   */* __restrict  */)(arg2),
              sizeof(remote_fill_file));
#line 717
      remote_fill_file[sizeof(remote_fill_file) - 1UL] = (char )'\000';
      }
    }
#line 719
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 722
    break_args(optarg, arg1, arg2);
    }
#line 723
    if (arg1[0]) {
      {
#line 724
      tmp___14 = convert(arg1);
#line 724
      iteration_max = (int )tmp___14;
      }
    }
#line 726
    if (arg2[0]) {
      {
#line 727
      tmp___15 = convert(arg2);
#line 727
      iteration_min = (int )tmp___15;
      }
    }
#line 731
    if (iteration_max < iteration_min) {
#line 731
      iteration_max = iteration_min;
    }
#line 733
    if (iteration_max < 3) {
#line 733
      iteration_max = 3;
    }
#line 734
    if (iteration_min < 3) {
#line 734
      iteration_min = 3;
    }
#line 736
    if (iteration_max > 30) {
#line 736
      iteration_max = 30;
    }
#line 737
    if (iteration_min > 30) {
#line 737
      iteration_min = 30;
    }
#line 738
    if (confidence_level == 0) {
#line 738
      confidence_level = 99;
    }
#line 739
    if (interval == 0.0) {
#line 739
      interval = 0.05;
    }
#line 740
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 743
    break_args(optarg, arg1, arg2);
    }
#line 744
    if (arg1[0]) {
      {
#line 745
      tmp___16 = convert(arg1);
#line 745
      confidence_level = (int )tmp___16;
      }
    }
#line 747
    if (confidence_level != 95) {
#line 747
      if (confidence_level != 99) {
        {
#line 748
        printf((char const   */* __restrict  */)"Only 95%% and 99%% confidence level is supported\n");
#line 749
        exit(-1);
        }
      }
    }
#line 751
    if (arg2[0]) {
      {
#line 754
      tmp___17 = strtod((char const   */* __restrict  */)(arg2), (char **/* __restrict  */)((void *)0));
#line 754
      interval = tmp___17 / 100.0;
      }
    }
#line 760
    if (iteration_min == 1) {
#line 760
      iteration_min = 3;
    }
#line 761
    if (iteration_max == 1) {
#line 761
      iteration_max = 10;
    }
#line 764
    if (interval == 0.0) {
#line 764
      interval = 0.05;
    }
#line 765
    goto switch_break;
    case_106: /* CIL Label */ 
#line 767
    keep_histogram = 1;
#line 768
    keep_statistics = 1;
#line 769
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 781
    printf((char const   */* __restrict  */)"I don\'t know how to get dirty.\n");
    }
#line 783
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 795
    printf((char const   */* __restrict  */)"I don\'t know how to get dirty.\n");
    }
#line 797
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 799
    shell_num_cpus = atoi((char const   *)optarg);
    }
#line 800
    goto switch_break;
    case_78: /* CIL Label */ 
#line 802
    no_control = 1;
#line 803
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 806
    break_args(optarg, arg1, arg2);
    }
#line 807
    if (arg1[0]) {
      {
#line 808
      tmp___18 = convert(arg1);
#line 808
      local_send_offset = (int )tmp___18;
      }
    }
#line 809
    if (arg2[0]) {
      {
#line 810
      tmp___19 = convert(arg2);
#line 810
      local_recv_offset = (int )tmp___19;
      }
    }
#line 811
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 814
    break_args(optarg, arg1, arg2);
    }
#line 815
    if (arg1[0]) {
      {
#line 816
      tmp___20 = convert(arg1);
#line 816
      remote_send_offset = (int )tmp___20;
      }
    }
#line 817
    if (arg2[0]) {
      {
#line 818
      tmp___21 = convert(arg2);
#line 818
      remote_recv_offset = (int )tmp___21;
      }
    }
#line 819
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 823
    tmp___22 = convert(optarg);
#line 823
    print_headers = (int )tmp___22;
    }
#line 824
    goto switch_break;
    case_114: /* CIL Label */ 
#line 829
    result_confidence_only = 1;
#line 830
    goto switch_break;
    case_83: /* CIL Label */ 
#line 833
    want_keepalive = 1;
#line 834
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 838
    tmp___23 = convert(optarg);
#line 838
    wait_time_secs = (int )tmp___23;
    }
#line 839
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 843
    strncpy((char */* __restrict  */)(test_name), (char const   */* __restrict  */)optarg,
            sizeof(test_name) - 1UL);
#line 844
    convert_to_upper(test_name);
    }
#line 845
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 849
    break_args(optarg, arg1, arg2);
    }
#line 850
    if (arg1[0]) {
      {
#line 851
      tmp___24 = convert(arg1);
#line 851
      local_proc_affinity = (int )tmp___24;
#line 852
      bind_to_specific_processor(local_proc_affinity, 0);
      }
    }
#line 854
    if (arg2[0]) {
      {
#line 855
      tmp___25 = convert(arg2);
#line 855
      remote_proc_affinity = (int )tmp___25;
      }
    }
#line 857
    cpu_binding_requested = 1;
#line 858
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 862
    break_args(optarg, arg1, arg2);
    }
#line 863
    if (arg1[0]) {
      {
#line 864
      tmp___26 = convert(arg1);
#line 864
      send_width = (int )tmp___26;
      }
    }
#line 865
    if (arg2[0]) {
      {
#line 866
      tmp___27 = convert(arg2);
#line 866
      recv_width = (int )tmp___27;
      }
    }
#line 867
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 869
    break_args(optarg, arg1, arg2);
    }
#line 871
    if (arg1[0]) {
      {
#line 872
      tmp___28 = convert(arg1);
#line 872
      local_socket_prio = (int )tmp___28;
      }
    }
#line 881
    if (arg2[0]) {
      {
#line 882
      tmp___29 = convert(arg2);
#line 882
      remote_socket_prio = (int )tmp___29;
      }
    }
#line 883
    goto switch_break;
    case_89: /* CIL Label */ 
    {
#line 885
    break_args(optarg, arg1, arg2);
    }
#line 887
    if (arg1[0]) {
      {
#line 888
      local_socket_tos = parse_ipqos((char const   *)(arg1));
      }
    }
#line 897
    if (arg2[0]) {
      {
#line 898
      remote_socket_tos = parse_ipqos((char const   *)(arg2));
      }
#line 899
      if (debug) {
        {
#line 900
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Setting remote_socket_tos to 0x%x\n",
                remote_socket_tos);
#line 903
        fflush(where);
        }
      }
    }
#line 906
    goto switch_break;
    case_90: /* CIL Label */ 
#line 915
    if ((unsigned long )passphrase == (unsigned long )((void *)0)) {
      {
#line 916
      tmp___30 = malloc(sizeof(netperf_request.content.test_specific_data));
#line 916
      passphrase = (char *)tmp___30;
      }
    }
    {
#line 917
    strncpy((char */* __restrict  */)passphrase, (char const   */* __restrict  */)optarg,
            sizeof(netperf_request.content.test_specific_data));
#line 920
    *(passphrase + (sizeof(netperf_request.content.test_specific_data) - 1UL)) = (char )'\000';
    }
#line 921
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 925
    tmp___31 = convert(optarg);
#line 925
    test_time = (int )tmp___31;
#line 926
    test_trans = 0;
#line 926
    test_bytes = test_trans;
    }
#line 927
    if (test_time < 0) {
#line 928
      test_bytes = -1 * test_time;
#line 929
      test_trans = test_bytes;
#line 930
      test_time = 0;
    }
#line 932
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 935
    tmp___32 = convert(optarg);
#line 935
    verbosity = (int )tmp___32;
    }
#line 936
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 942
    break_args_explicit(optarg, arg1, arg2);
    }
#line 943
    if (arg1[0]) {
      {
#line 944
      strncpy((char */* __restrict  */)(test_port), (char const   */* __restrict  */)(arg1),
              (size_t )10);
      }
    }
#line 945
    if (arg2[0]) {
      {
#line 946
      strncpy((char */* __restrict  */)(local_test_port), (char const   */* __restrict  */)(arg2),
              (size_t )10);
      }
    }
#line 947
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 952
    break_args_explicit(optarg, arg1, arg2);
    }
#line 953
    if (arg1[0]) {
      {
#line 954
      strncpy((char */* __restrict  */)(host_name), (char const   */* __restrict  */)(arg1),
              sizeof(host_name));
      }
    }
#line 955
    if (arg2[0]) {
      {
#line 956
      address_family = parse_address_family(arg2);
      }
    }
#line 957
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 962
    break_args_explicit(optarg, arg1, arg2);
    }
#line 963
    if (arg1[0]) {
      {
#line 964
      strncpy((char */* __restrict  */)(local_host_name), (char const   */* __restrict  */)(arg1),
              sizeof(local_host_name));
      }
    }
#line 965
    if (arg2[0]) {
      {
#line 966
      local_address_family = parse_address_family(arg2);
      }
    }
#line 967
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 974
    break_args_explicit(optarg, arg1, arg2);
    }
#line 975
    if (arg1[0]) {
      {
#line 980
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Packet rate control is not compiled in.\n");
      }
    }
#line 984
    if (arg2[0]) {
      {
#line 988
      tmp___33 = convert_timespec(arg2);
#line 988
      remote_interval_usecs = (int )tmp___33;
      }
    }
#line 990
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 994
    break_args_explicit(optarg, arg1, arg2);
    }
#line 995
    if (arg1[0]) {
      {
#line 1005
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Packet burst size is not compiled in. \n");
      }
    }
#line 1013
    if (arg2[0]) {
      {
#line 1014
      tmp___34 = convert(arg2);
#line 1014
      remote_interval_burst = (int )tmp___34;
      }
#line 1015
      if (remote_interval_usecs == 0) {
#line 1016
        remote_interval_usecs = 1000;
      }
    }
#line 1019
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 1021
    tmp___35 = strlen((char const   *)optarg);
#line 1021
    tmp___36 = malloc(tmp___35 + 1UL);
#line 1021
    result_brand = (char *)tmp___36;
    }
#line 1022
    if ((unsigned long )((void *)0) != (unsigned long )result_brand) {
      {
#line 1023
      strcpy((char */* __restrict  */)result_brand, (char const   */* __restrict  */)optarg);
      }
    } else {
      {
#line 1026
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Unable to malloc space for result brand\n");
      }
    }
#line 1029
    goto switch_break;
    case_52: /* CIL Label */ 
#line 1031
    address_family = 2;
#line 1032
    local_address_family = 2;
#line 1033
    goto switch_break;
    case_54: /* CIL Label */ 
#line 1036
    address_family = 10;
#line 1037
    local_address_family = 10;
#line 1042
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 1044
    printf((char const   */* __restrict  */)"Netperf version %s\n", "2.6.0");
#line 1045
    exit(0);
    }
#line 1046
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1052
  if (0 == (int )host_name[0]) {
    {
#line 1057
    if (address_family == 21) {
#line 1057
      goto case_21;
    }
#line 1057
    if (address_family == 2) {
#line 1057
      goto case_21;
    }
#line 1061
    if (address_family == 0) {
#line 1061
      goto case_0;
    }
#line 1084
    if (address_family == 10) {
#line 1084
      goto case_10___0;
    }
#line 1088
    goto switch_default___0;
    case_21: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 1059
    strcpy((char */* __restrict  */)(host_name), (char const   */* __restrict  */)"localhost");
    }
#line 1060
    goto switch_break___0;
    case_0: /* CIL Label */ 
    {
#line 1068
    if (local_address_family == 21) {
#line 1068
      goto case_21___0;
    }
#line 1068
    if (local_address_family == 0) {
#line 1068
      goto case_21___0;
    }
#line 1068
    if (local_address_family == 2) {
#line 1068
      goto case_21___0;
    }
#line 1073
    if (local_address_family == 10) {
#line 1073
      goto case_10;
    }
#line 1077
    goto switch_default;
    case_21___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    {
#line 1070
    strcpy((char */* __restrict  */)(host_name), (char const   */* __restrict  */)"localhost");
    }
#line 1071
    goto switch_break___1;
    case_10: /* CIL Label */ 
    {
#line 1074
    strcpy((char */* __restrict  */)(host_name), (char const   */* __restrict  */)"::1");
    }
#line 1075
    goto switch_break___1;
    switch_default: /* CIL Label */ 
    {
#line 1078
    printf((char const   */* __restrict  */)"Netperf does not understand %d as an address family\n",
           address_family);
#line 1080
    exit(-1);
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 1082
    goto switch_break___0;
    case_10___0: /* CIL Label */ 
    {
#line 1085
    strcpy((char */* __restrict  */)(host_name), (char const   */* __restrict  */)"::1");
    }
#line 1086
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 1089
    printf((char const   */* __restrict  */)"Netperf does not understand %d as an address family\n",
           address_family);
#line 1091
    exit(-1);
    }
    switch_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1098
    ai = resolve_host(host_name, (char *)((void *)0), address_family);
    }
#line 1099
    if (! ai) {
      {
#line 1100
      printf((char const   */* __restrict  */)"Netperf could not resolve %s as a host name\n",
             host_name);
#line 1101
      exit(-1);
      }
    }
    {
#line 1103
    address_family = ai->ai_family;
#line 1104
    freeaddrinfo(ai);
    }
  }
#line 1110
  if (0 == (int )local_host_name[0]) {
    {
#line 1114
    if (local_address_family == 21) {
#line 1114
      goto case_21___1;
    }
#line 1114
    if (local_address_family == 2) {
#line 1114
      goto case_21___1;
    }
#line 1118
    if (local_address_family == 0) {
#line 1118
      goto case_0___1;
    }
#line 1139
    if (local_address_family == 10) {
#line 1139
      goto case_10___2;
    }
#line 1143
    goto switch_default___2;
    case_21___1: /* CIL Label */ 
    case_2___1: /* CIL Label */ 
    {
#line 1116
    strcpy((char */* __restrict  */)(local_host_name), (char const   */* __restrict  */)"0.0.0.0");
    }
#line 1117
    goto switch_break___2;
    case_0___1: /* CIL Label */ 
    {
#line 1123
    if (address_family == 21) {
#line 1123
      goto case_21___2;
    }
#line 1123
    if (address_family == 0) {
#line 1123
      goto case_21___2;
    }
#line 1123
    if (address_family == 2) {
#line 1123
      goto case_21___2;
    }
#line 1128
    if (address_family == 10) {
#line 1128
      goto case_10___1;
    }
#line 1132
    goto switch_default___1;
    case_21___2: /* CIL Label */ 
    case_0___2: /* CIL Label */ 
    case_2___2: /* CIL Label */ 
    {
#line 1125
    strcpy((char */* __restrict  */)(local_host_name), (char const   */* __restrict  */)"0.0.0.0");
    }
#line 1126
    goto switch_break___3;
    case_10___1: /* CIL Label */ 
    {
#line 1129
    strcpy((char */* __restrict  */)(local_host_name), (char const   */* __restrict  */)"::0");
    }
#line 1130
    goto switch_break___3;
    switch_default___1: /* CIL Label */ 
    {
#line 1133
    printf((char const   */* __restrict  */)"Netperf does not understand %d as an address family\n",
           address_family);
#line 1135
    exit(-1);
    }
    switch_break___3: /* CIL Label */ ;
    }
#line 1137
    goto switch_break___2;
    case_10___2: /* CIL Label */ 
    {
#line 1140
    strcpy((char */* __restrict  */)(local_host_name), (char const   */* __restrict  */)"::0");
    }
#line 1141
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
    {
#line 1144
    printf((char const   */* __restrict  */)"Netperf does not understand %d as an address family\n",
           address_family);
#line 1146
    exit(-1);
    }
    switch_break___2: /* CIL Label */ ;
    }
  }
#line 1153
  if (no_control) {
#line 1154
    remote_socket_prio = -1;
#line 1155
    remote_socket_tos = -1;
#line 1156
    remote_recv_align = -1;
#line 1157
    remote_send_align = -1;
#line 1158
    remote_send_offset = -1;
#line 1159
    remote_recv_offset = -1;
#line 1160
    remote_cpu_rate = (float )(- 1.0);
#line 1161
    remote_cpu_usage = 0;
  }
  {
#line 1172
  tmp___45 = strcasecmp((char const   *)(test_name), "TCP_SENDFILE");
  }
#line 1172
  if (tmp___45 == 0) {
    {
#line 1197
    scan_sockets_args(argc, argv);
    }
  } else {
    {
#line 1172
    tmp___46 = strcasecmp((char const   *)(test_name), "TCP_CC");
    }
#line 1172
    if (tmp___46 == 0) {
      {
#line 1197
      scan_sockets_args(argc, argv);
      }
    } else {
      {
#line 1172
      tmp___47 = strcasecmp((char const   *)(test_name), "TCP_MSS");
      }
#line 1172
      if (tmp___47 == 0) {
        {
#line 1197
        scan_sockets_args(argc, argv);
        }
      } else {
        {
#line 1250
        tmp___37 = strcasecmp((char const   *)(test_name), "OMNI");
        }
#line 1250
        if (tmp___37 == 0) {
          {
#line 1260
          scan_omni_args(argc, argv);
          }
        } else {
          {
#line 1250
          tmp___38 = strcasecmp((char const   *)(test_name), "TCP_STREAM");
          }
#line 1250
          if (tmp___38 == 0) {
            {
#line 1260
            scan_omni_args(argc, argv);
            }
          } else {
            {
#line 1250
            tmp___39 = strcasecmp((char const   *)(test_name), "TCP_MAERTS");
            }
#line 1250
            if (tmp___39 == 0) {
              {
#line 1260
              scan_omni_args(argc, argv);
              }
            } else {
              {
#line 1250
              tmp___40 = strcasecmp((char const   *)(test_name), "TCP_RR");
              }
#line 1250
              if (tmp___40 == 0) {
                {
#line 1260
                scan_omni_args(argc, argv);
                }
              } else {
                {
#line 1250
                tmp___41 = strcasecmp((char const   *)(test_name), "TCP_CRR");
                }
#line 1250
                if (tmp___41 == 0) {
                  {
#line 1260
                  scan_omni_args(argc, argv);
                  }
                } else {
                  {
#line 1250
                  tmp___42 = strcasecmp((char const   *)(test_name), "UDP_STREAM");
                  }
#line 1250
                  if (tmp___42 == 0) {
                    {
#line 1260
                    scan_omni_args(argc, argv);
                    }
                  } else {
                    {
#line 1250
                    tmp___43 = strcasecmp((char const   *)(test_name), "UDP_RR");
                    }
#line 1250
                    if (tmp___43 == 0) {
                      {
#line 1260
                      scan_omni_args(argc, argv);
                      }
                    } else {
                      {
#line 1250
                      tmp___44 = strcasecmp((char const   *)(test_name), "UUID");
                      }
#line 1250
                      if (tmp___44 == 0) {
                        {
#line 1260
                        scan_omni_args(argc, argv);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 1270
  tmp___56 = strcasecmp((char const   *)(test_name), "omni");
  }
#line 1270
  if (tmp___56) {
#line 1271
    if (63 == (int )libfmt) {
      {
#line 1274
      tmp___48 = strstr((char const   *)(test_name), "RR");
      }
#line 1274
      if (tmp___48) {
#line 1278
        libfmt = (char )'x';
      } else {
        {
#line 1274
        tmp___49 = strstr((char const   *)(test_name), "rr");
        }
#line 1274
        if (tmp___49) {
#line 1278
          libfmt = (char )'x';
        } else {
          {
#line 1274
          tmp___50 = strstr((char const   *)(test_name), "Rr");
          }
#line 1274
          if (tmp___50) {
#line 1278
            libfmt = (char )'x';
          } else {
            {
#line 1274
            tmp___51 = strstr((char const   *)(test_name), "rR");
            }
#line 1274
            if (tmp___51) {
#line 1278
              libfmt = (char )'x';
            } else {
#line 1281
              libfmt = (char )'m';
            }
          }
        }
      }
    } else
#line 1284
    if (120 == (int )libfmt) {
      {
#line 1288
      tmp___52 = strstr((char const   *)(test_name), "RR");
      }
#line 1288
      if ((unsigned long )tmp___52 == (unsigned long )((void *)0)) {
        {
#line 1288
        tmp___53 = strstr((char const   *)(test_name), "rr");
        }
#line 1288
        if ((unsigned long )tmp___53 == (unsigned long )((void *)0)) {
          {
#line 1288
          tmp___54 = strstr((char const   *)(test_name), "Rr");
          }
#line 1288
          if ((unsigned long )tmp___54 == (unsigned long )((void *)0)) {
            {
#line 1288
            tmp___55 = strstr((char const   *)(test_name), "rR");
            }
#line 1288
            if ((unsigned long )tmp___55 == (unsigned long )((void *)0)) {
#line 1292
              libfmt = (char )'m';
            }
          }
        }
      }
    }
  }
#line 1296
  return;
}
}
#line 1299 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
void dump_globals(void) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 1302
  printf((char const   */* __restrict  */)"Program name: %s\n", program);
#line 1303
  printf((char const   */* __restrict  */)"Local send alignment: %d\n", local_send_align);
#line 1304
  printf((char const   */* __restrict  */)"Local recv alignment: %d\n", local_recv_align);
#line 1305
  printf((char const   */* __restrict  */)"Remote send alignment: %d\n", remote_send_align);
#line 1306
  printf((char const   */* __restrict  */)"Remote recv alignment: %d\n", remote_recv_align);
#line 1307
  printf((char const   */* __restrict  */)"Local socket priority: %d\n", local_socket_prio);
#line 1308
  printf((char const   */* __restrict  */)"Remote socket priority: %d\n", remote_socket_prio);
#line 1309
  tmp = iptos2str(local_socket_tos);
#line 1309
  printf((char const   */* __restrict  */)"Local socket TOS: %s\n", tmp);
#line 1310
  tmp___0 = iptos2str(remote_socket_tos);
#line 1310
  printf((char const   */* __restrict  */)"Remote socket TOS: %s\n", tmp___0);
#line 1311
  printf((char const   */* __restrict  */)"Report local CPU %d\n", local_cpu_usage);
#line 1312
  printf((char const   */* __restrict  */)"Report remote CPU %d\n", remote_cpu_usage);
#line 1313
  printf((char const   */* __restrict  */)"Verbosity: %d\n", verbosity);
#line 1314
  printf((char const   */* __restrict  */)"Debug: %d\n", debug);
#line 1315
  printf((char const   */* __restrict  */)"Port: %s\n", test_port);
#line 1316
  printf((char const   */* __restrict  */)"Test name: %s\n", test_name);
#line 1317
  printf((char const   */* __restrict  */)"Test bytes: %d Test time: %d Test trans: %d\n",
         test_bytes, test_time, test_trans);
#line 1321
  printf((char const   */* __restrict  */)"Host name: %s\n", host_name);
#line 1322
  printf((char const   */* __restrict  */)"\n");
  }
#line 1323
  return;
}
}
#line 100 "/home/wheatley/newnew/temp/netperf-2.6.0/src/dscp.c"
static struct __anonstruct_ipqos_32  const  ipqos[25]  = 
#line 100 "/home/wheatley/newnew/temp/netperf-2.6.0/src/dscp.c"
  {      {"af11", 40}, 
        {"af12", 48}, 
        {"af13", 56}, 
        {"af21", 72}, 
        {"af22", 80}, 
        {"af23", 88}, 
        {"af31", 104}, 
        {"af32", 112}, 
        {"af33", 120}, 
        {"af41", 136}, 
        {"af42", 144}, 
        {"af43", 152}, 
        {"cs0", 0}, 
        {"cs1", 32}, 
        {"cs2", 64}, 
        {"cs3", 96}, 
        {"cs4", 128}, 
        {"cs5", 160}, 
        {"cs6", 192}, 
        {"cs7", 224}, 
        {"ef", 184}, 
        {"lowdelay", 16}, 
        {"throughput", 8}, 
        {"reliability", 4}, 
        {(char const   *)((void *)0), -1}};
#line 131 "/home/wheatley/newnew/temp/netperf-2.6.0/src/dscp.c"
int parse_ipqos(char const   *cp ) 
{ 
  unsigned int i ;
  char *ep ;
  long val ;
  int tmp ;

  {
#line 135
  ep = (char *)((void *)0);
#line 138
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 139
    return (-1);
  }
#line 140
  i = 0U;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! ((unsigned long )ipqos[i].name != (unsigned long )((void *)0))) {
#line 140
      goto while_break;
    }
    {
#line 141
    tmp = strcasecmp(cp, (char const   *)ipqos[i].name);
    }
#line 141
    if (tmp == 0) {
#line 142
      return ((int )ipqos[i].value);
    }
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  val = strtol((char const   */* __restrict  */)cp, (char **/* __restrict  */)(& ep),
               0);
  }
#line 146
  if ((int const   )*cp == 0) {
#line 147
    return (-1);
  } else
#line 146
  if ((int )*ep != 0) {
#line 147
    return (-1);
  } else
#line 146
  if (val < 0L) {
#line 147
    return (-1);
  } else
#line 146
  if (val > 255L) {
#line 147
    return (-1);
  }
#line 148
  return ((int )val);
}
}
#line 155 "/home/wheatley/newnew/temp/netperf-2.6.0/src/dscp.c"
static char iptos_str[5UL]  ;
#line 151 "/home/wheatley/newnew/temp/netperf-2.6.0/src/dscp.c"
char const   *iptos2str(int iptos ) 
{ 
  int i ;

  {
#line 156
  if (iptos < 0) {
#line 156
    iptos = 0;
  } else
#line 156
  if (iptos > 64) {
#line 156
    iptos = 0;
  }
#line 157
  i = 0;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! ((unsigned long )ipqos[i].name != (unsigned long )((void *)0))) {
#line 157
      goto while_break;
    }
#line 158
    if (ipqos[i].value == (int const   )iptos) {
#line 159
      return ((char const   *)ipqos[i].name);
    }
#line 157
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 161
  snprintf((char */* __restrict  */)(iptos_str), sizeof(iptos_str), (char const   */* __restrict  */)"0x%02x",
           iptos);
  }
#line 162
  return ((char const   *)(iptos_str));
}
}
#line 158 "/usr/include/ftw.h"
extern int ( __attribute__((__nonnull__(1,2))) nftw)(char const   *__dir , int (*__func)(char const   *__filename ,
                                                                                         struct stat___0  const  *__status ,
                                                                                         int __flag ,
                                                                                         struct FTW *__info ) ,
                                                     int __descriptors , int __flag ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 7 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netslot_linux.c"
static char interface_match[32]  ;
#line 8 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netslot_linux.c"
static char interface_address[13]  ;
#line 9 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netslot_linux.c"
static char interface_slot[13]  = 
#line 9
  {      (char )'n',      (char )'o',      (char )'t',      (char )' ', 
        (char )'f',      (char )'o',      (char )'u',      (char )'n', 
        (char )'d',      (char )'\000'};
#line 11 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netslot_linux.c"
static int find_slot(char const   *fpath , struct stat___0  const  *sb , int tflag ,
                     struct FTW *ftwbuf ) 
{ 
  char slot_address[11] ;
  int ret ;
  FILE *address_file ;
  char *myfpath ;
  char *this_tok ;
  char *last_tok ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 20
  last_tok = (char *)((void *)0);
#line 24
  tmp___2 = strcmp("address", fpath + ftwbuf->base);
  }
#line 24
  if (tmp___2 == 0) {
    {
#line 25
    address_file = fopen((char const   */* __restrict  */)fpath, (char const   */* __restrict  */)"r");
    }
#line 26
    if ((unsigned long )address_file == (unsigned long )((void *)0)) {
      {
#line 27
      strcpy((char */* __restrict  */)(interface_slot), (char const   */* __restrict  */)"fopen");
      }
#line 28
      return (0);
    }
    {
#line 33
    tmp = fread((void */* __restrict  */)(slot_address), (size_t )1, (size_t )10,
                (FILE */* __restrict  */)address_file);
#line 33
    ret = (int )tmp;
    }
#line 34
    if (ret != 10) {
      {
#line 35
      strcpy((char */* __restrict  */)(interface_slot), (char const   */* __restrict  */)"fread");
#line 36
      fclose(address_file);
      }
#line 37
      return (0);
    }
    {
#line 39
    slot_address[ret] = (char)0;
#line 42
    tmp___1 = strstr((char const   *)(interface_address), (char const   *)(slot_address));
    }
#line 42
    if (tmp___1) {
      {
#line 43
      myfpath = strdup(fpath);
      }
#line 44
      if ((unsigned long )myfpath == (unsigned long )((void *)0)) {
        {
#line 45
        strcpy((char */* __restrict  */)(interface_slot), (char const   */* __restrict  */)"strcpy");
        }
#line 46
        return (1);
      }
      {
#line 49
      this_tok = strtok((char */* __restrict  */)myfpath, (char const   */* __restrict  */)"/");
      }
      {
#line 50
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 50
        tmp___0 = strcmp((char const   *)this_tok, "address");
        }
#line 50
        if (! tmp___0) {
#line 50
          goto while_break;
        }
        {
#line 51
        last_tok = this_tok;
#line 52
        this_tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"/");
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 54
      if ((unsigned long )last_tok != (unsigned long )((void *)0)) {
        {
#line 55
        strcpy((char */* __restrict  */)(interface_slot), (char const   */* __restrict  */)last_tok);
        }
      } else {
        {
#line 57
        strcpy((char */* __restrict  */)(interface_slot), (char const   */* __restrict  */)"last_tok");
        }
      }
      {
#line 58
      free((void *)myfpath);
#line 59
      fclose(address_file);
      }
#line 60
      return (1);
    }
    {
#line 62
    fclose(address_file);
    }
  }
#line 64
  return (0);
}
}
#line 67 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netslot_linux.c"
static int find_interface(char const   *fpath , struct stat___0  const  *sb , int tflag ,
                          struct FTW *ftwbuf ) 
{ 
  char *myfpath ;
  char *this_tok ;
  char *last_tok ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 73
  last_tok = (char *)((void *)0);
#line 75
  tmp___0 = strcmp((char const   *)(interface_match), fpath + ftwbuf->base);
  }
#line 75
  if (tmp___0 == 0) {
    {
#line 76
    myfpath = strdup(fpath);
    }
#line 77
    if ((unsigned long )myfpath == (unsigned long )((void *)0)) {
      {
#line 78
      strcpy((char */* __restrict  */)(interface_address), (char const   */* __restrict  */)"strcpy");
      }
#line 79
      return (1);
    }
    {
#line 81
    this_tok = strtok((char */* __restrict  */)myfpath, (char const   */* __restrict  */)"/");
    }
    {
#line 82
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 82
      tmp = strcmp((char const   *)this_tok, (char const   *)(interface_match));
      }
#line 82
      if (! tmp) {
#line 82
        goto while_break;
      }
      {
#line 83
      last_tok = this_tok;
#line 84
      this_tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"/");
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 86
    if ((unsigned long )last_tok != (unsigned long )((void *)0)) {
      {
#line 87
      strcpy((char */* __restrict  */)(interface_address), (char const   */* __restrict  */)last_tok);
      }
    } else {
      {
#line 89
      strcpy((char */* __restrict  */)(interface_address), (char const   */* __restrict  */)"last_tok");
      }
    }
    {
#line 90
    free((void *)myfpath);
    }
#line 91
    return (1);
  }
#line 93
  return (0);
}
}
#line 96 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netslot_linux.c"
char *find_interface_slot(char *interface_name ) 
{ 
  int flags ;
  int ret ;
  char *tmp ;

  {
  {
#line 99
  flags = 0;
#line 102
  flags |= 1;
#line 104
  ret = snprintf((char */* __restrict  */)(interface_match), (size_t )31, (char const   */* __restrict  */)"net:%s",
                 interface_name);
#line 105
  interface_match[31] = (char)0;
#line 108
  nftw("/sys/devices", & find_interface, 20, flags);
#line 111
  nftw("/sys/bus/pci/slots", & find_slot, 20, flags);
#line 112
  tmp = strdup((char const   *)(interface_slot));
  }
#line 112
  return (tmp);
}
}
#line 115 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netslot_linux.c"
static int get_val_from_file(char *valsource ) 
{ 
  FILE *valfile ;
  char buffer[6] ;
  int ret ;
  size_t tmp ;
  long tmp___0 ;

  {
  {
#line 121
  valfile = fopen((char const   */* __restrict  */)valsource, (char const   */* __restrict  */)"r");
  }
#line 122
  if ((unsigned long )valfile == (unsigned long )((void *)0)) {
#line 122
    return (-1);
  }
  {
#line 124
  tmp = fread((void */* __restrict  */)(buffer), (size_t )1, sizeof(buffer), (FILE */* __restrict  */)valfile);
#line 124
  ret = (int )tmp;
  }
#line 125
  if ((unsigned long )ret != sizeof(buffer)) {
    {
#line 126
    fclose(valfile);
    }
#line 127
    return (-1);
  }
  {
#line 130
  tmp___0 = strtol((char const   */* __restrict  */)(buffer), (char **/* __restrict  */)((void *)0),
                   0);
#line 130
  ret = (int )tmp___0;
#line 132
  fclose(valfile);
  }
#line 133
  return (ret);
}
}
#line 137 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netslot_linux.c"
void find_interface_ids(char *interface_name , int *vendor , int *device , int *sub_vend ,
                        int *sub_dev ) 
{ 
  int ret ;
  char sysfile[128] ;

  {
  {
#line 145
  ret = snprintf((char */* __restrict  */)(sysfile), (size_t )128, (char const   */* __restrict  */)"/sys/class/net/%s/device/vendor",
                 interface_name);
#line 146
  *vendor = get_val_from_file(sysfile);
#line 149
  ret = snprintf((char */* __restrict  */)(sysfile), (size_t )128, (char const   */* __restrict  */)"/sys/class/net/%s/device/device",
                 interface_name);
#line 150
  *device = get_val_from_file(sysfile);
#line 153
  ret = snprintf((char */* __restrict  */)(sysfile), (size_t )128, (char const   */* __restrict  */)"/sys/class/net/%s/device/subsystem_vendor",
                 interface_name);
#line 154
  *sub_vend = get_val_from_file(sysfile);
#line 157
  ret = snprintf((char */* __restrict  */)(sysfile), (size_t )128, (char const   */* __restrict  */)"/sys/class/net/%s/device/subsystem_device",
                 interface_name);
#line 158
  *sub_dev = get_val_from_file(sysfile);
  }
#line 160
  return;
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 32 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netdrv_ethtool.c"
void find_driver_info(char *ifname , char *driver , char *version , char *firmware ,
                      char *bus , int len ) 
{ 
  int s ;
  int ret ;
  struct ifreq ifr ;
  struct ethtool_drvinfo drvinfo ;
  int tmp ;

  {
#line 40
  if (len < 32) {
#line 40
    return;
  }
  {
#line 42
  tmp = strcmp((char const   *)ifname, "lo");
  }
#line 42
  if (! tmp) {
    {
#line 44
    strncpy((char */* __restrict  */)driver, (char const   */* __restrict  */)"loopback",
            (size_t )len);
#line 45
    strncpy((char */* __restrict  */)version, (char const   */* __restrict  */)"system",
            (size_t )len);
#line 46
    strncpy((char */* __restrict  */)firmware, (char const   */* __restrict  */)"N/A",
            (size_t )len);
#line 47
    strncpy((char */* __restrict  */)bus, (char const   */* __restrict  */)"N/A",
            (size_t )len);
#line 48
    *(driver + (len - 1)) = (char)0;
#line 49
    *(version + (len - 1)) = (char)0;
#line 50
    *(firmware + (len - 1)) = (char)0;
#line 51
    *(bus + (len - 1)) = (char)0;
    }
#line 52
    return;
  }
  {
#line 55
  s = socket(2, 2, 0);
  }
#line 57
  if (s < 0) {
    {
#line 58
    strncpy((char */* __restrict  */)driver, (char const   */* __restrict  */)"SocketFailure",
            (size_t )len);
#line 59
    strncpy((char */* __restrict  */)version, (char const   */* __restrict  */)"SocketFailure",
            (size_t )len);
#line 60
    strncpy((char */* __restrict  */)firmware, (char const   */* __restrict  */)"SocketFailure",
            (size_t )len);
#line 61
    strncpy((char */* __restrict  */)bus, (char const   */* __restrict  */)"SocketFailure",
            (size_t )len);
#line 62
    *(driver + (len - 1)) = (char)0;
#line 63
    *(version + (len - 1)) = (char)0;
#line 64
    *(firmware + (len - 1)) = (char)0;
#line 65
    *(bus + (len - 1)) = (char)0;
    }
#line 66
    return;
  }
  {
#line 69
  memset((void *)(& ifr), 0, sizeof(ifr));
#line 70
  drvinfo.cmd = (__u32 )3;
#line 71
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          sizeof(ifr.ifr_ifrn.ifrn_name) - 1UL);
#line 72
  ifr.ifr_ifru.ifru_data = (caddr_t )(& drvinfo);
#line 74
  ret = ioctl(s, 35142UL, & ifr);
  }
#line 76
  if (ret == -1) {
    {
#line 77
    strncpy((char */* __restrict  */)driver, (char const   */* __restrict  */)"IoctlFailure",
            (size_t )len);
#line 78
    strncpy((char */* __restrict  */)version, (char const   */* __restrict  */)"IoctlFailure",
            (size_t )len);
#line 79
    strncpy((char */* __restrict  */)firmware, (char const   */* __restrict  */)"IoctlFailure",
            (size_t )len);
#line 80
    strncpy((char */* __restrict  */)bus, (char const   */* __restrict  */)"IoctlFailure",
            (size_t )len);
#line 81
    *(driver + (len - 1)) = (char)0;
#line 82
    *(version + (len - 1)) = (char)0;
#line 83
    *(firmware + (len - 1)) = (char)0;
#line 84
    *(bus + (len - 1)) = (char)0;
#line 85
    close(s);
    }
#line 86
    return;
  }
  {
#line 88
  strncpy((char */* __restrict  */)driver, (char const   */* __restrict  */)(drvinfo.driver),
          (size_t )len);
#line 89
  strncpy((char */* __restrict  */)version, (char const   */* __restrict  */)(drvinfo.version),
          (size_t )len);
#line 90
  strncpy((char */* __restrict  */)firmware, (char const   */* __restrict  */)(drvinfo.fw_version),
          (size_t )len);
#line 91
  strncpy((char */* __restrict  */)bus, (char const   */* __restrict  */)(drvinfo.bus_info),
          (size_t )len);
#line 92
  *(driver + (len - 1)) = (char)0;
#line 93
  *(version + (len - 1)) = (char)0;
#line 94
  *(firmware + (len - 1)) = (char)0;
#line 95
  *(bus + (len - 1)) = (char)0;
#line 97
  close(s);
  }
#line 99
  return;
}
}
#line 184 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 194 "/usr/include/net/if.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) if_indextoname)(unsigned int __ifindex ,
                                                                                       char *__ifname ) ;
#line 19 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netrt_rtnetlink.c"
char *find_egress_interface(struct sockaddr *source , struct sockaddr *dest ) 
{ 
  struct sockaddr_nl me ;
  struct sockaddr_nl them ;
  struct sockaddr_in *in4 ;
  struct sockaddr_in6 *in6 ;
  int interface_index ;
  char interface_name[16] ;
  int s ;
  struct msghdr msg ;
  struct iovec iov ;
  struct __anonstruct_request_77 request ;
  char reply[1024] ;
  struct nlmsghdr *nlp ;
  struct rtmsg *rtp ;
  struct rtattr *rtap ;
  int nll ;
  int rtl ;
  int ret ;
  __pid_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 26
  interface_index = -1;
#line 60
  s = socket(16, 3, 0);
#line 62
  memset((void *)(& me), 0, sizeof(me));
#line 63
  me.nl_family = (__kernel_sa_family_t )16;
#line 64
  tmp = getpid();
#line 64
  me.nl_pid = (__u32 )tmp;
#line 67
  bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& me)), (socklen_t )sizeof(me));
#line 71
  memset((void *)(& request), 0, sizeof(request));
#line 72
  request.nl.nlmsg_len = (__u32 )(sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 73
  request.nl.nlmsg_flags = (__u16 )1;
#line 74
  request.nl.nlmsg_type = (__u16 )26;
  }
#line 77
  if (dest) {
#line 78
    in4 = (struct sockaddr_in *)dest;
#line 79
    in6 = (struct sockaddr_in6 *)dest;
#line 80
    request.rt.rtm_family = (unsigned char )in4->sin_family;
#line 81
    rtap = (struct rtattr *)(request.buf);
#line 82
    rtap->rta_type = (unsigned short)1;
#line 83
    if (2 == (int )in4->sin_family) {
      {
#line 87
      rtap->rta_len = (unsigned short )(((((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + sizeof(in4->sin_addr)) + 4UL) - 1UL) & 0xfffffffffffffffcUL);
#line 88
      memcpy((void */* __restrict  */)((void *)((char *)rtap + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             (void const   */* __restrict  */)(& in4->sin_addr), sizeof(in4->sin_addr));
      }
    } else
#line 90
    if (10 == (int )in6->sin6_family) {
      {
#line 91
      rtap->rta_len = (unsigned short )(((((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + sizeof(in6->sin6_addr)) + 4UL) - 1UL) & 0xfffffffffffffffcUL);
#line 92
      memcpy((void */* __restrict  */)((void *)((char *)rtap + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             (void const   */* __restrict  */)(& in6->sin6_addr), sizeof(in6->sin6_addr));
      }
    } else {
      {
#line 95
      close(s);
#line 96
      tmp___0 = strdup("UnknownAddressFamily");
      }
#line 96
      return (tmp___0);
    }
  } else {
    {
#line 101
    printf((char const   */* __restrict  */)"No destination specified.\n");
#line 102
    close(s);
#line 103
    tmp___1 = strdup("NoDestination");
    }
#line 103
    return (tmp___1);
  }
#line 108
  request.nl.nlmsg_len += (__u32 )rtap->rta_len;
#line 111
  if (source) {
#line 114
    in4 = (struct sockaddr_in *)source;
#line 115
    in6 = (struct sockaddr_in6 *)source;
#line 120
    rtap = (struct rtattr *)((char *)rtap + (int )rtap->rta_len);
#line 121
    rtap->rta_type = (unsigned short)2;
#line 122
    if (2 == (int )in4->sin_family) {
      {
#line 123
      rtap->rta_len = (unsigned short )(((((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + sizeof(in4->sin_addr)) + 4UL) - 1UL) & 0xfffffffffffffffcUL);
#line 124
      memcpy((void */* __restrict  */)((void *)((char *)rtap + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             (void const   */* __restrict  */)(& in4->sin_addr), sizeof(in4->sin_addr));
      }
    } else
#line 126
    if (10 == (int )in6->sin6_family) {
      {
#line 127
      rtap->rta_len = (unsigned short )(((((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + sizeof(in6->sin6_addr)) + 4UL) - 1UL) & 0xfffffffffffffffcUL);
#line 128
      memcpy((void */* __restrict  */)((void *)((char *)rtap + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
             (void const   */* __restrict  */)(& in6->sin6_addr), sizeof(in6->sin6_addr));
      }
    } else {
      {
#line 131
      close(s);
#line 132
      tmp___2 = strdup("UnknownAddressFamily");
      }
#line 132
      return (tmp___2);
    }
#line 139
    request.nl.nlmsg_len += (__u32 )rtap->rta_len;
  }
  {
#line 143
  memset((void *)(& them), 0, sizeof(them));
#line 144
  them.nl_family = (__kernel_sa_family_t )16;
#line 146
  memset((void *)(& msg), 0, sizeof(msg));
#line 147
  msg.msg_name = (void *)(& them);
#line 148
  msg.msg_namelen = (socklen_t )sizeof(them);
#line 150
  iov.iov_base = (void *)(& request.nl);
#line 151
  iov.iov_len = (size_t )request.nl.nlmsg_len;
#line 153
  msg.msg_iov = & iov;
#line 154
  msg.msg_iovlen = (size_t )1;
#line 157
  tmp___3 = sendmsg(s, (struct msghdr  const  *)(& msg), 0);
#line 157
  ret = (int )tmp___3;
  }
#line 159
  if (ret < 0) {
    {
#line 160
    close(s);
#line 161
    tmp___4 = strdup("SendmsgFailure");
    }
#line 161
    return (tmp___4);
  }
  {
#line 164
  memset((void *)(reply), 0, sizeof(reply));
#line 165
  tmp___5 = recv(s, (void *)(reply), sizeof(reply), 0);
#line 165
  ret = (int )tmp___5;
  }
#line 167
  if (ret < 0) {
    {
#line 168
    close(s);
#line 169
    tmp___6 = strdup("RecvmsgFailure");
    }
#line 169
    return (tmp___6);
  }
#line 172
  nll = ret;
#line 179
  nlp = (struct nlmsghdr *)(reply);
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (nll >= (int )sizeof(struct nlmsghdr )) {
#line 179
      if ((unsigned long )nlp->nlmsg_len >= sizeof(struct nlmsghdr )) {
#line 179
        if (! (nlp->nlmsg_len <= (__u32 )nll)) {
#line 179
          goto while_break;
        }
      } else {
#line 179
        goto while_break;
      }
    } else {
#line 179
      goto while_break;
    }
#line 183
    rtp = (struct rtmsg *)((void *)((char *)nlp + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 194
    rtap = (struct rtattr *)((char *)rtp + (((sizeof(struct rtmsg ) + 4UL) - 1UL) & 4294967292UL));
#line 194
    rtl = (int )((unsigned long )nlp->nlmsg_len - ((((sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))) + 4UL) - 1UL) & 4294967292UL));
    {
#line 194
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 194
      if (rtl >= (int )sizeof(struct rtattr )) {
#line 194
        if ((unsigned long )rtap->rta_len >= sizeof(struct rtattr )) {
#line 194
          if (! ((int )rtap->rta_len <= rtl)) {
#line 194
            goto while_break___0;
          }
        } else {
#line 194
          goto while_break___0;
        }
      } else {
#line 194
        goto while_break___0;
      }
#line 197
      if (4 == (int )rtap->rta_type) {
#line 198
        if (-1 == interface_index) {
#line 199
          interface_index = *((int *)((void *)((char *)rtap + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))));
        } else {
          {
#line 202
          close(s);
#line 203
          tmp___7 = strdup("MultipleInterfacesFound");
          }
#line 203
          return (tmp___7);
        }
      }
#line 194
      rtl -= (((int )rtap->rta_len + 4) - 1) & -4;
#line 194
      rtap = (struct rtattr *)((char *)rtap + ((((int )rtap->rta_len + 4) - 1) & -4));
    }
    while_break___0: /* CIL Label */ ;
    }
#line 179
    nll = (int )((unsigned int )nll - (((nlp->nlmsg_len + 4U) - 1U) & 4294967292U));
#line 179
    nlp = (struct nlmsghdr *)((char *)nlp + (((nlp->nlmsg_len + 4U) - 1U) & 4294967292U));
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  if (interface_index == -1) {
    {
#line 211
    tmp___8 = strdup("InterfaceNotFound");
    }
#line 211
    return (tmp___8);
  } else {
    {
#line 214
    tmp___11 = if_indextoname((unsigned int )interface_index, interface_name);
    }
#line 214
    if ((unsigned long )((void *)0) == (unsigned long )tmp___11) {
      {
#line 215
      close(s);
#line 216
      tmp___9 = strdup("IfIndexToNameFailure");
      }
#line 216
      return (tmp___9);
    } else {
      {
#line 219
      close(s);
#line 220
      tmp___10 = strdup((char const   *)(interface_name));
      }
#line 220
      return (tmp___10);
    }
  }
}
}
#line 2 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_sctp.c"
char nettest_sctp[77]  = 
#line 2 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_sctp.c"
  {      (char )'@',      (char )'(',      (char )'#',      (char )')', 
        (char )'n',      (char )'e',      (char )'t',      (char )'t', 
        (char )'e',      (char )'s',      (char )'t',      (char )'_', 
        (char )'s',      (char )'c',      (char )'t',      (char )'p', 
        (char )'.',      (char )'c',      (char )' ',      (char )'(', 
        (char )'c',      (char )')',      (char )' ',      (char )'C', 
        (char )'o',      (char )'p',      (char )'y',      (char )'r', 
        (char )'i',      (char )'g',      (char )'h',      (char )'t', 
        (char )' ',      (char )'2',      (char )'0',      (char )'0', 
        (char )'5',      (char )'-',      (char )'2',      (char )'0', 
        (char )'1',      (char )'2',      (char )' ',      (char )'H', 
        (char )'e',      (char )'w',      (char )'l',      (char )'e', 
        (char )'t',      (char )'t',      (char )'-',      (char )'P', 
        (char )'a',      (char )'c',      (char )'k',      (char )'a', 
        (char )'r',      (char )'d',      (char )' ',      (char )'C', 
        (char )'o',      (char )'.',      (char )' ',      (char )'V', 
        (char )'e',      (char )'r',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'2', 
        (char )'.',      (char )'6',      (char )'.',      (char )'0', 
        (char )'\000'};
#line 2 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
char nettest_id[76]  = 
#line 2 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
  {      (char )'@',      (char )'(',      (char )'#',      (char )')', 
        (char )'n',      (char )'e',      (char )'t',      (char )'t', 
        (char )'e',      (char )'s',      (char )'t',      (char )'_', 
        (char )'b',      (char )'s',      (char )'d',      (char )'.', 
        (char )'c',      (char )' ',      (char )'(',      (char )'c', 
        (char )')',      (char )' ',      (char )'C',      (char )'o', 
        (char )'p',      (char )'y',      (char )'r',      (char )'i', 
        (char )'g',      (char )'h',      (char )'t',      (char )' ', 
        (char )'1',      (char )'9',      (char )'9',      (char )'3', 
        (char )'-',      (char )'2',      (char )'0',      (char )'1', 
        (char )'2',      (char )' ',      (char )'H',      (char )'e', 
        (char )'w',      (char )'l',      (char )'e',      (char )'t', 
        (char )'t',      (char )'-',      (char )'P',      (char )'a', 
        (char )'c',      (char )'k',      (char )'a',      (char )'r', 
        (char )'d',      (char )' ',      (char )'C',      (char )'o', 
        (char )'.',      (char )' ',      (char )'V',      (char )'e', 
        (char )'r',      (char )'s',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'2',      (char )'.', 
        (char )'6',      (char )'.',      (char )'0',      (char )'\000'};
#line 459 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 471 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.h"
int control_family ;
#line 526
void send_request(void) ;
#line 527
void recv_response(void) ;
#line 563
void set_sock_buffer(int sd , enum sock_buffer which , int requested_size , int *effective_sizep ) ;
#line 572
char *inet_ttos(int type ) ;
#line 573
char *inet_ptos(int protocol___0 ) ;
#line 576
double ntohd(double net_double ) ;
#line 577
double htond(double host_double ) ;
#line 586
float calibrate_remote_cpu(void) ;
#line 608
float calc_service_demand(double units_sent , float elapsed_time___0 , float cpu_utilization ,
                          int num_cpus ) ;
#line 632
struct sendfile_ring_elt *alloc_sendfile_buf_ring(int width , int buffer_size , int alignment ,
                                                  int offset ) ;
#line 552 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
int socket_type  ;
#line 552 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
int rss_size  ;
#line 552 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
int rsr_size  ;
#line 552 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
int lss_size  ;
#line 552 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
int lsr_size  ;
#line 552 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
int send_size  ;
#line 552 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.h"
int recv_size  ;
#line 609
void set_hostname_and_port(char *hostname , char *portstr , int family , int port ) ;
#line 621
void send_tcp_mss(char *remote_host ) ;
#line 626
void send_tcp_cc(char *remote_host ) ;
#line 642
void loc_cpu_rate(void) ;
#line 643
void rem_cpu_rate(void) ;
#line 650
void sendfile_tcp_stream(char *remote_host ) ;
#line 159 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int first_burst_size  =    0;
#line 33 "/usr/include/x86_64-linux-gnu/sys/sendfile.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__leaf__)) sendfile)(int __out_fd ,
                                                                                   int __in_fd ,
                                                                                   off_t *__offset ,
                                                                                   size_t __count ) ;
#line 174 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int rss_size_req  =    -1;
#line 174 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int rsr_size_req  =    -1;
#line 174 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int rss_size_end  =    -1;
#line 174 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int rsr_size_end  =    -1;
#line 174 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int lss_size_req  =    -1;
#line 174 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int lsr_size_req  =    -1;
#line 174 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int lss_size_end  =    -1;
#line 174 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int lsr_size_end  =    -1;
#line 174 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int req_size  =    1;
#line 174 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int rsp_size  =    1;
#line 174 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int transport_mss_req  =    -1;
#line 194 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static int confidence_iteration___0  ;
#line 195 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static char local_cpu_method___0  ;
#line 196 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static char remote_cpu_method___0  ;
#line 200 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static int client_port_min___0  =    5000;
#line 201 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static int client_port_max___0  =    65535;
#line 205 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int loc_tcpcork  =    0;
#line 205 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int rem_tcpcork  =    0;
#line 205 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int local_connected  =    0;
#line 205 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int remote_connected  =    0;
#line 205 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int routing_allowed  =    1;
#line 223 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int multicast_ttl  =    -1;
#line 225 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int want_keepalive  =    0;
#line 370 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
char sockets_usage[1555]  = 
#line 370
  {      (char )'\n',      (char )'U',      (char )'s',      (char )'a', 
        (char )'g',      (char )'e',      (char )':',      (char )' ', 
        (char )'n',      (char )'e',      (char )'t',      (char )'p', 
        (char )'e',      (char )'r',      (char )'f',      (char )' ', 
        (char )'[',      (char )'g',      (char )'l',      (char )'o', 
        (char )'b',      (char )'a',      (char )'l',      (char )' ', 
        (char )'o',      (char )'p',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'s',      (char )']', 
        (char )' ',      (char )'-',      (char )'-',      (char )' ', 
        (char )'[',      (char )'t',      (char )'e',      (char )'s', 
        (char )'t',      (char )' ',      (char )'o',      (char )'p', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'s',      (char )']',      (char )' ',      (char )'\n', 
        (char )'\n',      (char )'T',      (char )'C',      (char )'P', 
        (char )'/',      (char )'U',      (char )'D',      (char )'P', 
        (char )' ',      (char )'B',      (char )'S',      (char )'D', 
        (char )' ',      (char )'S',      (char )'o',      (char )'c', 
        (char )'k',      (char )'e',      (char )'t',      (char )'s', 
        (char )' ',      (char )'T',      (char )'e',      (char )'s', 
        (char )'t',      (char )' ',      (char )'O',      (char )'p', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'s',      (char )':',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'b',      (char )' ',      (char )'n',      (char )'u', 
        (char )'m',      (char )'b',      (char )'e',      (char )'r', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'S',      (char )'e',      (char )'n', 
        (char )'d',      (char )' ',      (char )'n',      (char )'u', 
        (char )'m',      (char )'b',      (char )'e',      (char )'r', 
        (char )' ',      (char )'r',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'s',      (char )' ',      (char )'a',      (char )'t', 
        (char )' ',      (char )'s',      (char )'t',      (char )'a', 
        (char )'r',      (char )'t',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'_',      (char )'R', 
        (char )'R',      (char )' ',      (char )'t',      (char )'e', 
        (char )'s',      (char )'t',      (char )'s',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'C',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'S',      (char )'e', 
        (char )'t',      (char )' ',      (char )'T',      (char )'C', 
        (char )'P',      (char )'_',      (char )'C',      (char )'O', 
        (char )'R',      (char )'K',      (char )' ',      (char )'w', 
        (char )'h',      (char )'e',      (char )'n',      (char )' ', 
        (char )'a',      (char )'v',      (char )'a',      (char )'i', 
        (char )'l',      (char )'a',      (char )'b',      (char )'l', 
        (char )'e',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'D', 
        (char )' ',      (char )'[',      (char )'L',      (char )']', 
        (char )'[',      (char )',',      (char )'R',      (char )']', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'S',      (char )'e',      (char )'t',      (char )' ', 
        (char )'T',      (char )'C',      (char )'P',      (char )'_', 
        (char )'N',      (char )'O',      (char )'D',      (char )'E', 
        (char )'L',      (char )'A',      (char )'Y',      (char )' ', 
        (char )'l',      (char )'o',      (char )'c',      (char )'a', 
        (char )'l',      (char )'l',      (char )'y',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )'/', 
        (char )'o',      (char )'r',      (char )' ',      (char )'r', 
        (char )'e',      (char )'m',      (char )'o',      (char )'t', 
        (char )'e',      (char )'l',      (char )'y',      (char )' ', 
        (char )'(',      (char )'T',      (char )'C',      (char )'P', 
        (char )'_',      (char )'*',      (char )')',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'h',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'D',      (char )'i', 
        (char )'s',      (char )'p',      (char )'l',      (char )'a', 
        (char )'y',      (char )' ',      (char )'t',      (char )'h', 
        (char )'i',      (char )'s',      (char )' ',      (char )'t', 
        (char )'e',      (char )'x',      (char )'t',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'H',      (char )' ',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )',', 
        (char )'f',      (char )'a',      (char )'m',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'U',      (char )'s', 
        (char )'e',      (char )' ',      (char )'n',      (char )'a', 
        (char )'m',      (char )'e',      (char )' ',      (char )'(', 
        (char )'o',      (char )'r',      (char )' ',      (char )'I', 
        (char )'P',      (char )')',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'f', 
        (char )'a',      (char )'m',      (char )'i',      (char )'l', 
        (char )'y',      (char )' ',      (char )'a',      (char )'s', 
        (char )' ',      (char )'t',      (char )'a',      (char )'r', 
        (char )'g',      (char )'e',      (char )'t',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'d', 
        (char )'a',      (char )'t',      (char )'a',      (char )' ', 
        (char )'c',      (char )'o',      (char )'n',      (char )'n', 
        (char )'e',      (char )'c',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'L',      (char )' ',      (char )'n',      (char )'a', 
        (char )'m',      (char )'e',      (char )',',      (char )'f', 
        (char )'a',      (char )'m',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'U',      (char )'s',      (char )'e', 
        (char )' ',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )' ',      (char )'(',      (char )'o', 
        (char )'r',      (char )' ',      (char )'I',      (char )'P', 
        (char )')',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'f',      (char )'a', 
        (char )'m',      (char )'i',      (char )'l',      (char )'y', 
        (char )' ',      (char )'a',      (char )'s',      (char )' ', 
        (char )'s',      (char )'o',      (char )'u',      (char )'r', 
        (char )'c',      (char )'e',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'d',      (char )'a', 
        (char )'t',      (char )'a',      (char )' ',      (char )'c', 
        (char )'o',      (char )'n',      (char )'n',      (char )'e', 
        (char )'c',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'m', 
        (char )' ',      (char )'b',      (char )'y',      (char )'t', 
        (char )'e',      (char )'s',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'S',      (char )'e',      (char )'t',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'s',      (char )'e',      (char )'n',      (char )'d', 
        (char )' ',      (char )'s',      (char )'i',      (char )'z', 
        (char )'e',      (char )' ',      (char )'(',      (char )'T', 
        (char )'C',      (char )'P',      (char )'_',      (char )'S', 
        (char )'T',      (char )'R',      (char )'E',      (char )'A', 
        (char )'M',      (char )',',      (char )' ',      (char )'U', 
        (char )'D',      (char )'P',      (char )'_',      (char )'S', 
        (char )'T',      (char )'R',      (char )'E',      (char )'A', 
        (char )'M',      (char )')',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'M',      (char )' ',      (char )'b',      (char )'y', 
        (char )'t',      (char )'e',      (char )'s',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'S',      (char )'e',      (char )'t', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'r',      (char )'e',      (char )'c', 
        (char )'v',      (char )' ',      (char )'s',      (char )'i', 
        (char )'z',      (char )'e',      (char )' ',      (char )'(', 
        (char )'T',      (char )'C',      (char )'P',      (char )'_', 
        (char )'S',      (char )'T',      (char )'R',      (char )'E', 
        (char )'A',      (char )'M',      (char )',',      (char )' ', 
        (char )'U',      (char )'D',      (char )'P',      (char )'_', 
        (char )'S',      (char )'T',      (char )'R',      (char )'E', 
        (char )'A',      (char )'M',      (char )')',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'U',      (char )'s', 
        (char )'e',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'c',      (char )'o', 
        (char )'n',      (char )'n',      (char )'e',      (char )'c', 
        (char )'t',      (char )'e',      (char )'d',      (char )' ', 
        (char )'s',      (char )'o',      (char )'c',      (char )'k', 
        (char )'e',      (char )'t',      (char )' ',      (char )'f', 
        (char )'o',      (char )'r',      (char )' ',      (char )'U', 
        (char )'D',      (char )'P',      (char )' ',      (char )'l', 
        (char )'o',      (char )'c',      (char )'a',      (char )'l', 
        (char )'l',      (char )'y',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'N',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'U',      (char )'s',      (char )'e', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'c',      (char )'o',      (char )'n', 
        (char )'n',      (char )'e',      (char )'c',      (char )'t', 
        (char )'e',      (char )'d',      (char )' ',      (char )'s', 
        (char )'o',      (char )'c',      (char )'k',      (char )'e', 
        (char )'t',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )' ',      (char )'U',      (char )'D', 
        (char )'P',      (char )' ',      (char )'r',      (char )'e', 
        (char )'m',      (char )'o',      (char )'t',      (char )'e', 
        (char )'l',      (char )'y',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'p',      (char )' ',      (char )'m',      (char )'i', 
        (char )'n',      (char )'[',      (char )',',      (char )'m', 
        (char )'a',      (char )'x',      (char )']',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'S',      (char )'e',      (char )'t', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'m',      (char )'i',      (char )'n', 
        (char )'/',      (char )'m',      (char )'a',      (char )'x', 
        (char )' ',      (char )'p',      (char )'o',      (char )'r', 
        (char )'t',      (char )' ',      (char )'n',      (char )'u', 
        (char )'m',      (char )'b',      (char )'e',      (char )'r', 
        (char )'s',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )' ',      (char )'T',      (char )'C', 
        (char )'P',      (char )'_',      (char )'C',      (char )'R', 
        (char )'R',      (char )',',      (char )' ',      (char )'T', 
        (char )'C',      (char )'P',      (char )'_',      (char )'T', 
        (char )'R',      (char )'R',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'P',      (char )' ',      (char )'l',      (char )'o', 
        (char )'c',      (char )'a',      (char )'l',      (char )'[', 
        (char )',',      (char )'r',      (char )'e',      (char )'m', 
        (char )'o',      (char )'t',      (char )'e',      (char )']', 
        (char )' ',      (char )'S',      (char )'e',      (char )'t', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'l',      (char )'o',      (char )'c', 
        (char )'a',      (char )'l',      (char )'/',      (char )'r', 
        (char )'e',      (char )'m',      (char )'o',      (char )'t', 
        (char )'e',      (char )' ',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )' ',      (char )'f', 
        (char )'o',      (char )'r',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'d', 
        (char )'a',      (char )'t',      (char )'a',      (char )' ', 
        (char )'s',      (char )'o',      (char )'c',      (char )'k', 
        (char )'e',      (char )'t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'r',      (char )' ',      (char )'r',      (char )'e', 
        (char )'q',      (char )',',      (char )'[',      (char )'r', 
        (char )'s',      (char )'p',      (char )']',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'S',      (char )'e',      (char )'t', 
        (char )' ',      (char )'r',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'/',      (char )'r',      (char )'e',      (char )'s', 
        (char )'p',      (char )'o',      (char )'n',      (char )'s', 
        (char )'e',      (char )' ',      (char )'s',      (char )'i', 
        (char )'z',      (char )'e',      (char )'s',      (char )' ', 
        (char )'(',      (char )'T',      (char )'C',      (char )'P', 
        (char )'_',      (char )'R',      (char )'R',      (char )',', 
        (char )' ',      (char )'U',      (char )'D',      (char )'P', 
        (char )'_',      (char )'R',      (char )'R',      (char )')', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'s',      (char )' ', 
        (char )'s',      (char )'e',      (char )'n',      (char )'d', 
        (char )'[',      (char )',',      (char )'r',      (char )'e', 
        (char )'c',      (char )'v',      (char )']',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'S', 
        (char )'e',      (char )'t',      (char )' ',      (char )'l', 
        (char )'o',      (char )'c',      (char )'a',      (char )'l', 
        (char )' ',      (char )'s',      (char )'o',      (char )'c', 
        (char )'k',      (char )'e',      (char )'t',      (char )' ', 
        (char )'s',      (char )'e',      (char )'n',      (char )'d', 
        (char )'/',      (char )'r',      (char )'e',      (char )'c', 
        (char )'v',      (char )' ',      (char )'b',      (char )'u', 
        (char )'f',      (char )'f',      (char )'e',      (char )'r', 
        (char )' ',      (char )'s',      (char )'i',      (char )'z', 
        (char )'e',      (char )'s',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'S',      (char )' ',      (char )'s',      (char )'e', 
        (char )'n',      (char )'d',      (char )'[',      (char )',', 
        (char )'r',      (char )'e',      (char )'c',      (char )'v', 
        (char )']',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'S',      (char )'e',      (char )'t', 
        (char )' ',      (char )'r',      (char )'e',      (char )'m', 
        (char )'o',      (char )'t',      (char )'e',      (char )' ', 
        (char )'s',      (char )'o',      (char )'c',      (char )'k', 
        (char )'e',      (char )'t',      (char )' ',      (char )'s', 
        (char )'e',      (char )'n',      (char )'d',      (char )'/', 
        (char )'r',      (char )'e',      (char )'c',      (char )'v', 
        (char )' ',      (char )'b',      (char )'u',      (char )'f', 
        (char )'f',      (char )'e',      (char )'r',      (char )' ', 
        (char )'s',      (char )'i',      (char )'z',      (char )'e', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'4', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'U',      (char )'s',      (char )'e',      (char )' ', 
        (char )'A',      (char )'F',      (char )'_',      (char )'I', 
        (char )'N',      (char )'E',      (char )'T',      (char )' ', 
        (char )'(',      (char )'e',      (char )'g',      (char )' ', 
        (char )'I',      (char )'P',      (char )'v',      (char )'4', 
        (char )')',      (char )' ',      (char )'o',      (char )'n', 
        (char )' ',      (char )'b',      (char )'o',      (char )'t', 
        (char )'h',      (char )' ',      (char )'e',      (char )'n', 
        (char )'d',      (char )'s',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'d',      (char )'a', 
        (char )'t',      (char )'a',      (char )' ',      (char )'c', 
        (char )'o',      (char )'n',      (char )'n',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'6',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'U',      (char )'s', 
        (char )'e',      (char )' ',      (char )'A',      (char )'F', 
        (char )'_',      (char )'I',      (char )'N',      (char )'E', 
        (char )'T',      (char )'6',      (char )' ',      (char )'(', 
        (char )'e',      (char )'g',      (char )' ',      (char )'I', 
        (char )'P',      (char )'v',      (char )'6',      (char )')', 
        (char )' ',      (char )'o',      (char )'n',      (char )' ', 
        (char )'b',      (char )'o',      (char )'t',      (char )'h', 
        (char )' ',      (char )'e',      (char )'n',      (char )'d', 
        (char )'s',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'d',      (char )'a',      (char )'t', 
        (char )'a',      (char )' ',      (char )'c',      (char )'o', 
        (char )'n',      (char )'n',      (char )'\n',      (char )'\n', 
        (char )'F',      (char )'o',      (char )'r',      (char )' ', 
        (char )'t',      (char )'h',      (char )'o',      (char )'s', 
        (char )'e',      (char )' ',      (char )'o',      (char )'p', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'s',      (char )' ',      (char )'t',      (char )'a', 
        (char )'k',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'t',      (char )'w',      (char )'o', 
        (char )' ',      (char )'p',      (char )'a',      (char )'r', 
        (char )'m',      (char )'s',      (char )',',      (char )' ', 
        (char )'a',      (char )'t',      (char )' ',      (char )'l', 
        (char )'e',      (char )'a',      (char )'s',      (char )'t', 
        (char )' ',      (char )'o',      (char )'n',      (char )'e', 
        (char )' ',      (char )'m',      (char )'u',      (char )'s', 
        (char )'t',      (char )' ',      (char )'b',      (char )'e', 
        (char )' ',      (char )'s',      (char )'p',      (char )'e', 
        (char )'c',      (char )'i',      (char )'f',      (char )'i', 
        (char )'e',      (char )'d',      (char )';',      (char )'\n', 
        (char )'s',      (char )'p',      (char )'e',      (char )'c', 
        (char )'i',      (char )'f',      (char )'y',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'o', 
        (char )'n',      (char )'e',      (char )' ',      (char )'v', 
        (char )'a',      (char )'l',      (char )'u',      (char )'e', 
        (char )' ',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )'o',      (char )'u',      (char )'t', 
        (char )' ',      (char )'a',      (char )' ',      (char )'c', 
        (char )'o',      (char )'m',      (char )'m',      (char )'a', 
        (char )' ',      (char )'w',      (char )'i',      (char )'l', 
        (char )'l',      (char )' ',      (char )'s',      (char )'e', 
        (char )'t',      (char )' ',      (char )'b',      (char )'o', 
        (char )'t',      (char )'h',      (char )' ',      (char )'p', 
        (char )'a',      (char )'r',      (char )'m',      (char )'s', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'t',      (char )'h',      (char )'a',      (char )'t', 
        (char )'\n',      (char )'v',      (char )'a',      (char )'l', 
        (char )'u',      (char )'e',      (char )',',      (char )' ', 
        (char )'s',      (char )'p',      (char )'e',      (char )'c', 
        (char )'i',      (char )'f',      (char )'y',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'a', 
        (char )' ',      (char )'v',      (char )'a',      (char )'l', 
        (char )'u',      (char )'e',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )' ', 
        (char )'a',      (char )' ',      (char )'l',      (char )'e', 
        (char )'a',      (char )'d',      (char )'i',      (char )'n', 
        (char )'g',      (char )' ',      (char )'c',      (char )'o', 
        (char )'m',      (char )'m',      (char )'a',      (char )' ', 
        (char )'w',      (char )'i',      (char )'l',      (char )'l', 
        (char )' ',      (char )'s',      (char )'e',      (char )'t', 
        (char )' ',      (char )'j',      (char )'u',      (char )'s', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'s',      (char )'e', 
        (char )'c',      (char )'o',      (char )'n',      (char )'d', 
        (char )'\n',      (char )'p',      (char )'a',      (char )'r', 
        (char )'m',      (char )',',      (char )' ',      (char )'a', 
        (char )' ',      (char )'v',      (char )'a',      (char )'l', 
        (char )'u',      (char )'e',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )' ', 
        (char )'a',      (char )' ',      (char )'t',      (char )'r', 
        (char )'a',      (char )'i',      (char )'l',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'c', 
        (char )'o',      (char )'m',      (char )'m',      (char )'a', 
        (char )' ',      (char )'w',      (char )'i',      (char )'l', 
        (char )'l',      (char )' ',      (char )'s',      (char )'e', 
        (char )'t',      (char )' ',      (char )'j',      (char )'u', 
        (char )'s',      (char )'t',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'r',      (char )'s',      (char )'t', 
        (char )'.',      (char )' ',      (char )'T',      (char )'o', 
        (char )' ',      (char )'s',      (char )'e',      (char )'t', 
        (char )'\n',      (char )'e',      (char )'a',      (char )'c', 
        (char )'h',      (char )' ',      (char )'p',      (char )'a', 
        (char )'r',      (char )'m',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'u',      (char )'n', 
        (char )'i',      (char )'q',      (char )'u',      (char )'e', 
        (char )' ',      (char )'v',      (char )'a',      (char )'l', 
        (char )'u',      (char )'e',      (char )'s',      (char )',', 
        (char )' ',      (char )'s',      (char )'p',      (char )'e', 
        (char )'c',      (char )'i',      (char )'f',      (char )'y', 
        (char )' ',      (char )'b',      (char )'o',      (char )'t', 
        (char )'h',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'s',      (char )'e', 
        (char )'p',      (char )'a',      (char )'r',      (char )'a', 
        (char )'t',      (char )'e',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )'m',      (char )' ', 
        (char )'w',      (char )'i',      (char )'t',      (char )'h', 
        (char )' ',      (char )'a',      (char )'\n',      (char )'c', 
        (char )'o',      (char )'m',      (char )'m',      (char )'a', 
        (char )'.',      (char )'\n',      (char )'\000'};
#line 405 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int nf_to_af(int nf ) 
{ 


  {
  {
#line 408
  if (nf == 4) {
#line 408
    goto case_4;
  }
#line 410
  if (nf == 0) {
#line 410
    goto case_0;
  }
#line 412
  if (nf == 6) {
#line 412
    goto case_6;
  }
#line 418
  if (nf == 7) {
#line 418
    goto case_7;
  }
#line 424
  goto switch_default;
  case_4: /* CIL Label */ 
#line 409
  return (2);
  case_0: /* CIL Label */ 
#line 411
  return (0);
  case_6: /* CIL Label */ 
#line 414
  return (10);
  case_7: /* CIL Label */ 
#line 420
  return (21);
  switch_default: /* CIL Label */ 
#line 425
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 429 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int af_to_nf(int af___0 ) 
{ 


  {
  {
#line 433
  if (af___0 == 2) {
#line 433
    goto case_2;
  }
#line 435
  if (af___0 == 0) {
#line 435
    goto case_0;
  }
#line 438
  if (af___0 == 10) {
#line 438
    goto case_10;
  }
#line 442
  if (af___0 == 21) {
#line 442
    goto case_21;
  }
#line 445
  goto switch_default;
  case_2: /* CIL Label */ 
#line 434
  return (4);
  case_0: /* CIL Label */ 
#line 436
  return (0);
  case_10: /* CIL Label */ 
#line 439
  return (6);
  case_21: /* CIL Label */ 
#line 443
  return (7);
  switch_default: /* CIL Label */ 
#line 446
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 456 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int nst_to_hst(int nst ) 
{ 


  {
  {
#line 460
  if (nst == 1) {
#line 460
    goto case_1;
  }
#line 465
  if (nst == 2) {
#line 465
    goto case_2;
  }
#line 470
  if (nst == 3) {
#line 470
    goto case_3;
  }
#line 475
  if (nst == 4) {
#line 475
    goto case_4;
  }
#line 478
  goto switch_default;
  case_1: /* CIL Label */ 
#line 461
  return (1);
#line 462
  goto switch_break;
  case_2: /* CIL Label */ 
#line 466
  return (2);
#line 467
  goto switch_break;
  case_3: /* CIL Label */ 
#line 471
  return (6);
#line 472
  goto switch_break;
  case_4: /* CIL Label */ 
#line 476
  return (4);
  switch_default: /* CIL Label */ 
#line 479
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 481
  return (0);
}
}
#line 483 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int hst_to_nst(int hst ) 
{ 


  {
  {
#line 488
  if (hst == 1) {
#line 488
    goto case_1;
  }
#line 493
  if (hst == 2) {
#line 493
    goto case_2;
  }
#line 498
  if (hst == 6) {
#line 498
    goto case_6;
  }
#line 503
  if (hst == 5) {
#line 503
    goto case_5;
  }
#line 506
  goto switch_default;
  case_1: /* CIL Label */ 
#line 489
  return (1);
#line 490
  goto switch_break;
  case_2: /* CIL Label */ 
#line 494
  return (2);
#line 495
  goto switch_break;
  case_6: /* CIL Label */ 
#line 499
  return (3);
#line 500
  goto switch_break;
  case_5: /* CIL Label */ 
#line 504
  return (4);
  switch_default: /* CIL Label */ 
#line 507
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 509
  return (0);
}
}
#line 510 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
char *hst_to_str(int hst ) 
{ 


  {
  {
#line 515
  if (hst == 1) {
#line 515
    goto case_1;
  }
#line 520
  if (hst == 2) {
#line 520
    goto case_2;
  }
#line 525
  if (hst == 6) {
#line 525
    goto case_6;
  }
#line 530
  if (hst == 5) {
#line 530
    goto case_5;
  }
#line 533
  goto switch_default;
  case_1: /* CIL Label */ 
#line 516
  return ((char *)"Stream");
#line 517
  goto switch_break;
  case_2: /* CIL Label */ 
#line 521
  return ((char *)"Datagram");
#line 522
  goto switch_break;
  case_6: /* CIL Label */ 
#line 526
  return ((char *)"DCCP");
#line 527
  goto switch_break;
  case_5: /* CIL Label */ 
#line 531
  return ((char *)"Seqpacket");
  switch_default: /* CIL Label */ 
#line 534
  return ((char *)"Unknown");
  switch_break: /* CIL Label */ ;
  }
#line 536
  return ((char *)0);
}
}
#line 538 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
char *protocol_to_str(int protocol___0 ) 
{ 


  {
  {
#line 542
  if (protocol___0 == 6) {
#line 542
    goto case_6;
  }
#line 544
  if (protocol___0 == 17) {
#line 544
    goto case_17;
  }
#line 548
  if (protocol___0 == 136) {
#line 548
    goto case_136;
  }
#line 552
  if (protocol___0 == 132) {
#line 552
    goto case_132;
  }
#line 556
  if (protocol___0 == 33) {
#line 556
    goto case_33;
  }
#line 564
  if (protocol___0 == 0) {
#line 564
    goto case_0;
  }
#line 567
  goto switch_default;
  case_6: /* CIL Label */ 
#line 543
  return ((char *)"TCP");
  case_17: /* CIL Label */ 
#line 545
  return ((char *)"UDP");
  case_136: /* CIL Label */ 
#line 549
  return ((char *)"UDPLite");
  case_132: /* CIL Label */ 
#line 553
  return ((char *)"SCTP");
  case_33: /* CIL Label */ 
#line 557
  return ((char *)"DCCP");
  case_0: /* CIL Label */ 
#line 565
  return ((char *)"IP Default");
  switch_default: /* CIL Label */ 
#line 568
  return ((char *)"Unknown Protocol");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 580 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static void get_tcp_info(int socket___0 , int *mss ) 
{ 
  unsigned int sock_opt_len ;
  int *tmp ;
  struct protoent *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 588
  sock_opt_len = (unsigned int )sizeof(int );
#line 589
  tmp___0 = getprotobyname("tcp");
#line 589
  tmp___1 = getsockopt(socket___0, tmp___0->p_proto, 2, (void */* __restrict  */)((char *)mss),
                       (socklen_t */* __restrict  */)(& sock_opt_len));
  }
#line 589
  if (tmp___1 == -1) {
    {
#line 594
    tmp = __errno_location();
#line 594
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: get_tcp_info: getsockopt TCP_MAXSEG: errno %d\n",
            *tmp);
#line 597
    fflush(where);
#line 598
    *mss = -1;
    }
  }
#line 603
  return;
}
}
#line 605 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static void set_tcp_mss(int socket___0 , int mss ) 
{ 
  unsigned int sock_opt_len ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  struct protoent *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 611
  sock_opt_len = (unsigned int )sizeof(int );
#line 612
  tmp___2 = getprotobyname("tcp");
#line 612
  tmp___3 = setsockopt(socket___0, tmp___2->p_proto, 2, (void const   *)((char const   *)(& mss)),
                       sock_opt_len);
  }
#line 612
  if (tmp___3 == -1) {
#line 612
    if (debug) {
      {
#line 617
      tmp = __errno_location();
#line 617
      tmp___0 = __errno_location();
#line 617
      tmp___1 = strerror(*tmp___0);
#line 617
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: %s: setsockopt TCP_MAXSEG: %s (errno %d)\n",
              "set_tcp_mss", tmp___1, *tmp);
#line 622
      fflush(where);
      }
    }
  }
#line 633
  return;
}
}
#line 655 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static int change_warning_displayed  =    0;
#line 641 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
struct addrinfo *complete_addrinfo(char *controlhost , char *data_address , char *port ,
                                   int family , int type , int protocol___0 , int flags ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *res ;
  struct addrinfo *temp_res ;
  int change_info ;
  int count ;
  int error ;
  char *hostname ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 654
  change_info = 0;
#line 657
  count = 0;
#line 658
  error = 0;
#line 663
  if (data_address) {
#line 664
    hostname = data_address;
  } else {
#line 666
    hostname = controlhost;
  }
#line 668
  if (debug) {
    {
#line 669
    tmp = inet_ptos(protocol___0);
#line 669
    tmp___0 = inet_ttos(type);
#line 669
    tmp___1 = inet_ftos(family);
#line 669
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"complete_addrinfo using hostname %s port %s family %s type %s prot %s flags 0x%x\n",
            hostname, port, tmp___1, tmp___0, tmp, flags);
#line 677
    fflush(where);
    }
  }
  {
#line 680
  memset((void *)(& hints), 0, sizeof(hints));
#line 681
  hints.ai_family = family;
#line 682
  hints.ai_socktype = type;
#line 683
  hints.ai_protocol = protocol___0;
#line 684
  hints.ai_flags = (flags | 2) | 32;
#line 686
  count = 0;
  }
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 688
    error = getaddrinfo((char const   */* __restrict  */)hostname, (char const   */* __restrict  */)port,
                        (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
#line 692
    count ++;
    }
#line 693
    if (error == -3) {
#line 694
      if (debug) {
        {
#line 695
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Sleeping on getaddrinfo EAI_AGAIN\n");
#line 696
        fflush(where);
        }
      }
      {
#line 698
      sleep(1U);
      }
    }
#line 712
    if (-7 == error) {
#line 725
      if (hints.ai_socktype == 6) {
#line 725
        if (hints.ai_protocol == 0) {
#line 727
          change_info |= 16;
#line 728
          hints.ai_socktype = 0;
#line 732
          hints.ai_protocol = 6;
        }
      }
#line 735
      if (hints.ai_protocol == 33) {
#line 736
        change_info |= 8;
#line 737
        hints.ai_protocol = 0;
      }
#line 742
      if (hints.ai_protocol == 132) {
#line 743
        change_info |= 4;
#line 744
        hints.ai_protocol = 0;
      }
#line 748
      error = -3;
#line 749
      count --;
    }
#line 687
    if (error == -3) {
#line 687
      if (! (count <= 5)) {
#line 687
        goto while_break;
      }
    } else {
#line 687
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 754
  if (error) {
    {
#line 755
    tmp___2 = gai_strerror(error);
#line 755
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"complete_addrinfo: could not resolve \'%s\' port \'%s\' af %d\n\tgetaddrinfo returned %d %s\n",
            hostname, port, family, error, tmp___2);
#line 763
    fflush(where);
#line 764
    exit(-1);
    }
  }
#line 775
  temp_res = res;
  {
#line 777
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 777
    if (! temp_res) {
#line 777
      goto while_break___0;
    }
#line 779
    if (type) {
#line 779
      if (temp_res->ai_socktype != type) {
#line 781
        change_info |= 1;
#line 782
        if (debug) {
          {
#line 783
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"WARNING! Changed bogus getaddrinfo socket type %d to %d\n",
                  temp_res->ai_socktype, type);
#line 787
          fflush(where);
          }
        }
#line 789
        temp_res->ai_socktype = type;
      }
    }
#line 792
    if (protocol___0) {
#line 792
      if (temp_res->ai_protocol != protocol___0) {
#line 794
        change_info |= 2;
#line 795
        if (debug) {
          {
#line 796
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"WARNING! Changed bogus getaddrinfo protocol %d to %d\n",
                  temp_res->ai_protocol, protocol___0);
#line 800
          fflush(where);
          }
        }
#line 802
        temp_res->ai_protocol = protocol___0;
      }
    }
#line 804
    temp_res = temp_res->ai_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 807
  if (change_info & 1) {
#line 807
    if (! (change_warning_displayed & 1)) {
      {
#line 809
      change_warning_displayed |= 1;
#line 810
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"WARNING! getaddrinfo returned a socket type which did not\nmatch the requested type.  Please contact your vendor for\na fix to this bug in getaddrinfo()\n");
#line 814
      fflush(where);
      }
    }
  }
#line 828
  if (change_info & 2) {
#line 828
    if (! (change_warning_displayed & 2)) {
#line 828
      if (hints.ai_protocol != 0) {
        {
#line 831
        change_warning_displayed |= 2;
#line 832
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"WARNING! getaddrinfo returned a protocol other than the\nrequested protocol.  Please contact your vendor for\na fix to this bug in getaddrinfo()\n");
#line 836
        fflush(where);
        }
      }
    }
  }
#line 839
  if (change_info & 4) {
#line 839
    if (! (change_warning_displayed & 4)) {
      {
#line 841
      change_warning_displayed |= 4;
#line 842
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"WARNING! getaddrinfo on this platform does not accept IPPROTO_SCTP!\nPlease contact your vendor for a fix to this bug in getaddrinfo().\n");
#line 845
      fflush(where);
      }
    }
  }
#line 848
  if (change_info & 8) {
#line 848
    if (! (change_warning_displayed & 8)) {
      {
#line 850
      change_warning_displayed |= 8;
#line 851
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"WARNING! getaddrinfo on this platform does not accept IPPROTO_DCCP!\nPlease contact your vendor for a fix to this bug in getaddrinfo().\n");
#line 854
      fflush(where);
      }
    }
  }
#line 858
  if (debug) {
    {
#line 859
    dump_addrinfo(where, res, hostname, port, family);
    }
  }
#line 862
  return (res);
}
}
#line 865 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void complete_addrinfos(struct addrinfo **remote , struct addrinfo **local , char *remote_host ,
                        int type , int protocol___0 , int flags ) 
{ 
  void *tmp ;

  {
#line 868
  if (remote_data_family == 0) {
#line 869
    remote_data_family = control_family;
  }
  {
#line 872
  *remote = complete_addrinfo(remote_host, remote_data_address, remote_data_port,
                              remote_data_family, type, protocol___0, flags);
  }
#line 887
  if ((unsigned long )((void *)0) == (unsigned long )local_data_address) {
    {
#line 888
    tmp = malloc((size_t )255);
#line 888
    local_data_address = (char *)tmp;
    }
#line 889
    if ((unsigned long )((void *)0) == (unsigned long )remote_data_address) {
#line 890
      if (debug) {
        {
#line 891
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"local_data_address not set, using local_host_name of \'%s\'\n",
                local_host_name);
#line 894
        fflush(where);
        }
      }
      {
#line 896
      strcpy((char */* __restrict  */)local_data_address, (char const   */* __restrict  */)(local_host_name));
      }
    } else {
#line 899
      if (debug) {
        {
#line 900
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"local_data_address not set, using address family info\n");
#line 902
        fflush(where);
        }
      }
      {
#line 905
      strcpy((char */* __restrict  */)local_data_address, (char const   */* __restrict  */)"0.0.0.0");
      }
#line 907
      if (10 == local_data_family) {
        {
#line 912
        strcpy((char */* __restrict  */)local_data_address, (char const   */* __restrict  */)"::0");
        }
      } else
#line 907
      if (0 == local_data_family) {
#line 907
        if (10 == remote_data_family) {
          {
#line 912
          strcpy((char */* __restrict  */)local_data_address, (char const   */* __restrict  */)"::0");
          }
        } else {
#line 907
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 907
      if (0 == local_data_family) {
#line 907
        if (10 == (*remote)->ai_family) {
          {
#line 912
          strcpy((char */* __restrict  */)local_data_address, (char const   */* __restrict  */)"::0");
          }
        }
      }
    }
  }
  {
#line 918
  *local = complete_addrinfo((char *)"what to put here?", local_data_address, local_data_port,
                             local_data_family, type, protocol___0, flags | 1);
  }
#line 934
  if ((unsigned long )remote_data_address == (unsigned long )((void *)0)) {
#line 935
    remote_data_address = remote_host;
  }
#line 936
  return;
}
}
#line 938 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void set_hostname_and_port(char *hostname , char *portstr , int family , int port ) 
{ 


  {
  {
#line 941
  strcpy((char */* __restrict  */)hostname, (char const   */* __restrict  */)"0.0.0.0");
  }
#line 943
  if (10 == family) {
    {
#line 944
    strcpy((char */* __restrict  */)hostname, (char const   */* __restrict  */)"::0");
    }
  }
  {
#line 948
  sprintf((char */* __restrict  */)portstr, (char const   */* __restrict  */)"%u",
          port);
  }
#line 950
  return;
}
}
#line 952 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static unsigned short get_port_number___0(struct addrinfo *res ) 
{ 
  struct sockaddr_in *foo ;
  uint16_t tmp ;
  struct sockaddr_in6 *foo___0 ;
  uint16_t tmp___0 ;

  {
  {
#line 956
  if (res->ai_family == 2) {
#line 956
    goto case_2;
  }
#line 962
  if (res->ai_family == 10) {
#line 962
    goto case_10;
  }
#line 968
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 957
  foo = (struct sockaddr_in *)res->ai_addr;
#line 958
  tmp = ntohs(foo->sin_port);
  }
#line 958
  return (tmp);
#line 959
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 963
  foo___0 = (struct sockaddr_in6 *)res->ai_addr;
#line 964
  tmp___0 = ntohs(foo___0->sin6_port);
  }
#line 964
  return (tmp___0);
#line 965
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 969
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Given Unexpected Address Family of %u\n",
          res->ai_family);
#line 971
  fflush(where);
#line 972
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 974
  return ((unsigned short)0);
}
}
#line 1002 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void set_port_number(struct addrinfo *res , unsigned short port ) 
{ 
  struct sockaddr_in *foo ;
  struct sockaddr_in6 *foo___0 ;

  {
  {
#line 1008
  if (res->ai_family == 21) {
#line 1008
    goto case_21;
  }
#line 1008
  if (res->ai_family == 2) {
#line 1008
    goto case_21;
  }
#line 1016
  if (res->ai_family == 10) {
#line 1016
    goto case_10;
  }
#line 1022
  goto switch_default;
  case_21: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 1011
  foo = (struct sockaddr_in *)res->ai_addr;
#line 1012
  foo->sin_port = htons(port);
  }
#line 1013
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1017
  foo___0 = (struct sockaddr_in6 *)res->ai_addr;
#line 1018
  foo___0->sin6_port = htons(port);
  }
#line 1019
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1023
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"set_port_number Unexpected Address Family of %u\n",
          res->ai_family);
#line 1025
  fflush(where);
#line 1026
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1028
  return;
}
}
#line 1033 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void set_sockaddr_family_addr_port(struct sockaddr_storage *sockaddr , int family ,
                                   void *addr , int port ) 
{ 
  struct sockaddr_in *foo ;
  uint32_t tmp ;
  struct sockaddr_in6 *foo___0 ;

  {
  {
#line 1036
  memset((void *)sockaddr, 0, sizeof(struct sockaddr_storage ));
  }
  {
#line 1042
  if (family == 2) {
#line 1042
    goto case_2;
  }
#line 1042
  if (family == 21) {
#line 1042
    goto case_2;
  }
#line 1051
  if (family == 10) {
#line 1051
    goto case_10;
  }
#line 1059
  goto switch_default;
  case_2: /* CIL Label */ 
  case_21: /* CIL Label */ 
  {
#line 1043
  foo = (struct sockaddr_in *)sockaddr;
#line 1044
  foo->sin_port = htons((unsigned short )port);
#line 1045
  foo->sin_family = (unsigned short )family;
#line 1046
  memcpy((void */* __restrict  */)(& foo->sin_addr), (void const   */* __restrict  */)addr,
         sizeof(foo->sin_addr));
#line 1047
  tmp = htonl((uint32_t )*((int *)addr));
#line 1047
  *((int *)addr) = (int )tmp;
  }
#line 1048
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1052
  foo___0 = (struct sockaddr_in6 *)sockaddr;
#line 1053
  foo___0->sin6_port = htons((unsigned short )port);
#line 1054
  foo___0->sin6_family = (unsigned short )family;
#line 1055
  memcpy((void */* __restrict  */)(& foo___0->sin6_addr), (void const   */* __restrict  */)addr,
         sizeof(foo___0->sin6_addr));
  }
#line 1056
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1060
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"set_sockaddr_family_addr_port Unexpected Address Family of %u\n",
          family);
#line 1062
  fflush(where);
#line 1063
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1065
  return;
}
}
#line 1068 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int get_sockaddr_family_addr_port(struct sockaddr_storage *sockaddr , int family ,
                                  void *addr , int *port ) 
{ 
  struct sockaddr_in *sin ;
  int ret ;
  uint16_t tmp ;
  uint32_t tmp___0 ;
  int i ;
  struct sockaddr_in6 *sin6 ;
  uint16_t tmp___1 ;

  {
#line 1071
  sin = (struct sockaddr_in *)sockaddr;
#line 1073
  ret = 0;
#line 1074
  if ((int )sin->sin_family != family) {
    {
#line 1075
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"get_sockaddr_family_addr_port family mismatch %d vs %d\n",
            (int )sin->sin_family, family);
#line 1079
    fflush(where);
    }
#line 1080
    return (-1);
  }
  {
#line 1087
  if (family == 2) {
#line 1087
    goto case_2;
  }
#line 1087
  if (family == 21) {
#line 1087
    goto case_2;
  }
#line 1095
  if (family == 10) {
#line 1095
    goto case_10;
  }
#line 1106
  goto switch_default;
  case_2: /* CIL Label */ 
  case_21: /* CIL Label */ 
  {
#line 1088
  tmp = ntohs(sin->sin_port);
#line 1088
  *port = (int )tmp;
#line 1089
  memcpy((void */* __restrict  */)addr, (void const   */* __restrict  */)(& sin->sin_addr),
         sizeof(sin->sin_addr));
  }
#line 1090
  if ((in_addr_t )*((int *)addr) == 0U) {
#line 1090
    ret = 1;
  }
  {
#line 1091
  tmp___0 = ntohl((uint32_t )*((int *)addr));
#line 1091
  *((int *)addr) = (int )tmp___0;
  }
#line 1092
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1097
  sin6 = (struct sockaddr_in6 *)sockaddr;
#line 1098
  tmp___1 = ntohs(sin6->sin6_port);
#line 1098
  *port = (int )tmp___1;
#line 1099
  ret = 1;
#line 1100
  i = 0;
  }
  {
#line 1100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1100
    if (! ((unsigned long )i < sizeof(struct in6_addr ))) {
#line 1100
      goto while_break;
    }
#line 1101
    if ((int )sin6->sin6_addr.__in6_u.__u6_addr8[i] != 0) {
#line 1101
      ret = 0;
    }
#line 1100
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1102
  memcpy((void */* __restrict  */)addr, (void const   */* __restrict  */)(& sin6->sin6_addr),
         sizeof(sin6->sin6_addr));
  }
#line 1103
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1107
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"get_sockaddr_family_addr_port: Unexpected Address Family of %u\n",
          family);
#line 1109
  fflush(where);
#line 1110
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1112
  return (ret);
}
}
#line 1116 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int set_socket_tos(int sock , int family , int socket_tos ) 
{ 
  int my_tos ;
  unsigned int sock_opt_len ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 1119
  my_tos = -3;
  {
#line 1124
  if (family == 2) {
#line 1124
    goto case_2;
  }
#line 1150
  if (family == 10) {
#line 1150
    goto case_10;
  }
#line 1122
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1126
  my_tos = socket_tos;
#line 1127
  tmp___2 = setsockopt(sock, 0, 1, (void const   *)((char const   *)(& my_tos)), (socklen_t )sizeof(my_tos));
  }
#line 1127
  if (tmp___2 == -1) {
    {
#line 1131
    tmp = __errno_location();
#line 1131
    tmp___0 = __errno_location();
#line 1131
    tmp___1 = strerror(*tmp___0);
#line 1131
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s ip_tos failed with %s (errno %d)\n",
            "set_socket_tos", tmp___1, *tmp);
#line 1136
    fflush(where);
#line 1137
    my_tos = -2;
    }
  } else {
    {
#line 1140
    sock_opt_len = (unsigned int )sizeof(my_tos);
#line 1141
    getsockopt(sock, 0, 1, (void */* __restrict  */)((char *)(& my_tos)), (socklen_t */* __restrict  */)(& sock_opt_len));
    }
  }
#line 1147
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1152
  my_tos = socket_tos;
#line 1153
  tmp___6 = setsockopt(sock, 41, 67, (void const   *)((char const   *)(& my_tos)),
                       (socklen_t )sizeof(my_tos));
  }
#line 1153
  if (tmp___6 == -1) {
    {
#line 1157
    tmp___3 = __errno_location();
#line 1157
    tmp___4 = __errno_location();
#line 1157
    tmp___5 = strerror(*tmp___4);
#line 1157
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s ip_tos failed with %s (errno %d)\n",
            "set_socket_tos", tmp___5, *tmp___3);
#line 1162
    fflush(where);
#line 1163
    my_tos = -2;
    }
  } else {
    {
#line 1166
    sock_opt_len = (unsigned int )sizeof(my_tos);
#line 1167
    getsockopt(sock, 41, 67, (void */* __restrict  */)((char *)(& my_tos)), (socklen_t */* __restrict  */)(& sock_opt_len));
    }
  }
#line 1173
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1176
  return (my_tos);
}
}
#line 1191 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
int create_data_socket(struct addrinfo *res ) 
{ 
  int temp_socket ;
  int one ;
  int on ;
  unsigned int sock_opt_len ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int option ;
  int *tmp___5 ;
  int tmp___6 ;
  struct protoent *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  unsigned short tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  int tmp___24 ;

  {
  {
#line 1196
  one = 1;
#line 1197
  on = 1;
#line 1201
  temp_socket = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  }
#line 1205
  if (temp_socket == -1) {
    {
#line 1206
    tmp = __errno_location();
#line 1206
    tmp___0 = strerror(*tmp);
#line 1206
    tmp___1 = inet_ptos(res->ai_protocol);
#line 1206
    tmp___2 = inet_ttos(res->ai_socktype);
#line 1206
    tmp___3 = inet_ftos(res->ai_family);
#line 1206
    tmp___4 = __errno_location();
#line 1206
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: create_data_socket: socket: errno %d fam %s type %s prot %s errmsg %s\n",
            *tmp___4, tmp___3, tmp___2, tmp___1, tmp___0);
#line 1213
    fflush(where);
#line 1214
    exit(1);
    }
  }
#line 1217
  if (debug) {
    {
#line 1218
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"create_data_socket: socket %d obtained...\n",
            temp_socket);
#line 1219
    fflush(where);
    }
  }
  {
#line 1239
  set_sock_buffer(temp_socket, (enum sock_buffer )0, lss_size_req, & lss_size);
#line 1240
  set_sock_buffer(temp_socket, (enum sock_buffer )1, lsr_size_req, & lsr_size);
  }
#line 1299
  if (loc_nodelay) {
#line 1299
    if (res->ai_protocol != 17) {
      {
#line 1307
      option = 1;
#line 1322
      one = 1;
#line 1323
      tmp___6 = setsockopt(temp_socket, res->ai_protocol, option, (void const   *)((char *)(& one)),
                           (socklen_t )sizeof(one));
      }
#line 1323
      if (tmp___6 == -1) {
        {
#line 1328
        tmp___5 = __errno_location();
#line 1328
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: create_data_socket: nodelay: errno %d\n",
                *tmp___5);
#line 1331
        fflush(where);
        }
      }
#line 1334
      if (debug > 1) {
        {
#line 1335
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: create_data_socket: [TCP|SCTP]_NODELAY requested...\n");
#line 1337
        fflush(where);
        }
      }
    }
  }
#line 1346
  if (transport_mss_req != -1) {
#line 1346
    if (6 == res->ai_protocol) {
      {
#line 1347
      set_tcp_mss(temp_socket, transport_mss_req);
      }
    }
  }
#line 1352
  if (loc_tcpcork > 0) {
    {
#line 1354
    tmp___7 = getprotobyname("tcp");
#line 1354
    tmp___8 = setsockopt(temp_socket, tmp___7->p_proto, 3, (void const   *)((char *)(& one)),
                         (socklen_t )sizeof(one));
    }
#line 1354
    if (tmp___8 == -1) {
      {
#line 1359
      perror("netperf: create_data_socket: tcp_cork");
#line 1360
      exit(1);
      }
    }
#line 1362
    if (debug) {
      {
#line 1363
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"create_data_socket: tcp_cork...\n");
      }
    }
  }
#line 1378
  if (want_keepalive) {
    {
#line 1379
    tmp___12 = setsockopt(temp_socket, 1, 9, (void const   *)((char const   *)(& on)),
                          (socklen_t )sizeof(on));
    }
#line 1379
    if (tmp___12 < 0) {
#line 1384
      if (debug) {
        {
#line 1385
        tmp___9 = __errno_location();
#line 1385
        tmp___10 = __errno_location();
#line 1385
        tmp___11 = strerror(*tmp___10);
#line 1385
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: unable to set SO_KEEPALIVE on data socket: %s (errno %d)\n",
                "create_data_socket", tmp___11, *tmp___9);
#line 1390
        fflush(where);
        }
      }
    }
  }
#line 1402
  if (res->ai_protocol == 33) {
#line 1402
    tmp___14 = 1;
  } else {
#line 1402
    tmp___14 = 1;
  }
  {
#line 1402
  tmp___15 = setsockopt(temp_socket, tmp___14, 2, (void const   *)((char const   *)(& on)),
                        (socklen_t )sizeof(on));
  }
#line 1402
  if (tmp___15 < 0) {
    {
#line 1425
    tmp___13 = __errno_location();
#line 1425
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: create_data_socket: SO_REUSEADDR failed %d\n",
            *tmp___13);
#line 1428
    fflush(where);
    }
  }
  {
#line 1431
  tmp___20 = bind(temp_socket, (struct sockaddr  const  *)res->ai_addr, res->ai_addrlen);
  }
#line 1431
  if (tmp___20 < 0) {
#line 1434
    if (debug) {
      {
#line 1435
      tmp___16 = __errno_location();
#line 1435
      tmp___17 = __errno_location();
#line 1435
      tmp___18 = strerror(*tmp___17);
#line 1435
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: create_data_socket: data socket bind failed: %s (errno %d)\n",
              tmp___18, *tmp___16);
#line 1439
      tmp___19 = get_port_number___0(res);
#line 1439
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)" port: %d\n",
              (int )tmp___19);
#line 1440
      fflush(where);
      }
    }
  }
#line 1455
  if (! routing_allowed) {
    {
#line 1456
    tmp___22 = setsockopt(temp_socket, 1, 5, (void const   *)((char *)(& one)), (socklen_t )sizeof(one));
    }
#line 1456
    if (tmp___22 == -1) {
      {
#line 1461
      tmp___21 = __errno_location();
#line 1461
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: create_data_socket: so_dontroute: errno %d\n",
              *tmp___21);
#line 1464
      fflush(where);
      }
    }
  }
#line 1470
  if (local_socket_prio >= 0) {
    {
#line 1471
    tmp___24 = setsockopt(temp_socket, 1, 12, (void const   *)(& local_socket_prio),
                          (socklen_t )sizeof(int ));
    }
#line 1471
    if (tmp___24 == -1) {
      {
#line 1476
      tmp___23 = __errno_location();
#line 1476
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: create_data_socket: so_priority: errno %d\n",
              *tmp___23);
#line 1479
      fflush(where);
#line 1480
      local_socket_prio = -2;
      }
    } else {
      {
#line 1483
      sock_opt_len = 4U;
#line 1484
      getsockopt(temp_socket, 1, 12, (void */* __restrict  */)(& local_socket_prio),
                 (socklen_t */* __restrict  */)(& sock_opt_len));
      }
    }
  }
#line 1496
  if (local_socket_tos > 0) {
    {
#line 1497
    local_socket_tos = set_socket_tos(temp_socket, res->ai_family, local_socket_tos);
    }
  }
#line 1500
  return (temp_socket);
}
}
#line 1560 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static void *get_address_address(struct addrinfo *info ) 
{ 
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;

  {
  {
#line 1569
  if (info->ai_family == 2) {
#line 1569
    goto case_2;
  }
#line 1574
  if (info->ai_family == 10) {
#line 1574
    goto case_10;
  }
#line 1579
  goto switch_default;
  case_2: /* CIL Label */ 
#line 1570
  sin = (struct sockaddr_in *)info->ai_addr;
#line 1571
  return ((void *)(& sin->sin_addr));
#line 1572
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1575
  sin6 = (struct sockaddr_in6 *)info->ai_addr;
#line 1576
  return ((void *)(& sin6->sin6_addr));
#line 1577
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1580
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"we never expected to get here in get_address_address\n");
#line 1581
  fflush(stderr);
#line 1582
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1584
  return ((void *)0);
}
}
#line 1595 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void print_top_test_header(char *test_name___0 , struct addrinfo *source , struct addrinfo *destination ) 
{ 
  char *address_buf ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  unsigned short tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  unsigned short tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 1602
  tmp = malloc((size_t )46);
#line 1602
  address_buf = (char *)tmp;
  }
#line 1607
  if ((unsigned long )address_buf == (unsigned long )((void *)0)) {
    {
#line 1608
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Unable to allocate address_buf\n");
#line 1609
    fflush(where);
#line 1610
    exit(1);
    }
  }
  {
#line 1617
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s", test_name___0);
#line 1619
  *(address_buf + 0) = (char )'\000';
#line 1620
  tmp___0 = get_address_address(source);
#line 1620
  inet_ntop(source->ai_family, (void const   */* __restrict  */)tmp___0, (char */* __restrict  */)address_buf,
            (socklen_t )sizeof(address_buf));
#line 1621
  tmp___1 = inet_ftos(source->ai_family);
#line 1621
  tmp___2 = get_port_number___0(source);
#line 1621
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)" from %s (%s) port %u %s",
          source->ai_canonname, address_buf, (int )tmp___2, tmp___1);
#line 1628
  *(address_buf + 0) = (char )'\000';
#line 1629
  tmp___3 = get_address_address(destination);
#line 1629
  inet_ntop(destination->ai_family, (void const   */* __restrict  */)tmp___3, (char */* __restrict  */)address_buf,
            (socklen_t )sizeof(address_buf));
#line 1630
  tmp___4 = inet_ftos(destination->ai_family);
#line 1630
  tmp___5 = get_port_number___0(destination);
#line 1630
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)" to %s (%s) port %u %s",
          destination->ai_canonname, address_buf, (int )tmp___5, tmp___4);
  }
#line 1637
  if (iteration_max > 1) {
#line 1638
    if (result_confidence_only) {
#line 1638
      tmp___6 = " on result only";
    } else {
#line 1638
      tmp___6 = "";
    }
    {
#line 1638
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)" : +/-%.3f%% @ %2d%% conf. %s",
            interval / 0.02, confidence_level, tmp___6);
    }
  }
#line 1644
  if (loc_nodelay > 0) {
    {
#line 1645
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)" : nodelay");
    }
  } else
#line 1644
  if (rem_nodelay > 0) {
    {
#line 1645
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)" : nodelay");
    }
  }
#line 1647
  if (loc_sndavoid > 0) {
    {
#line 1651
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)" : copy avoidance");
    }
  } else
#line 1647
  if (loc_rcvavoid > 0) {
    {
#line 1651
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)" : copy avoidance");
    }
  } else
#line 1647
  if (rem_sndavoid > 0) {
    {
#line 1651
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)" : copy avoidance");
    }
  } else
#line 1647
  if (rem_rcvavoid > 0) {
    {
#line 1651
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)" : copy avoidance");
    }
  }
#line 1654
  if (no_control) {
    {
#line 1655
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)" : no control");
    }
  }
  {
#line 1680
  tmp___7 = strstr((char const   *)test_name___0, "REQUEST/RESPONSE");
  }
#line 1680
  if (tmp___7) {
    {
#line 1681
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)" : first burst %d",
            first_burst_size);
    }
  }
#line 1684
  if (cpu_binding_requested) {
    {
#line 1685
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)" : cpu bind");
    }
  }
  {
#line 1687
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"\n");
#line 1689
  free((void *)address_buf);
  }
#line 1690
  return;
}
}
#line 3145 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void send_tcp_mss(char *remote_host ) 
{ 
  char *mss_title ;
  char *mss_fmt_0 ;
  int send_socket ;
  int tcp_mss ;
  struct addrinfo *remote_res ;
  struct addrinfo *local_res ;
  struct tcp_stream_request_struct *tcp_stream_request ;
  struct tcp_stream_response_struct *tcp_stream_response ;
  struct tcp_stream_results_struct *tcp_stream_result ;
  int *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 3149
  mss_title = (char *)"Maximum\nSegment\nSize (bytes)\n\n";
#line 3154
  mss_fmt_0 = (char *)"%d %s\n";
#line 3158
  tcp_mss = -1;
#line 3167
  tcp_stream_request = (struct tcp_stream_request_struct *)(netperf_request.content.test_specific_data);
#line 3169
  tcp_stream_response = (struct tcp_stream_response_struct *)(netperf_response.content.test_specific_data);
#line 3171
  tcp_stream_result = (struct tcp_stream_results_struct *)(netperf_response.content.test_specific_data);
#line 3180
  complete_addrinfos(& remote_res, & local_res, remote_host, 1, 6, 0);
  }
#line 3187
  if (print_headers) {
    {
#line 3188
    print_top_test_header((char *)"TCP MSS TEST", local_res, remote_res);
    }
  }
  {
#line 3192
  send_socket = create_data_socket(local_res);
  }
#line 3194
  if (send_socket == -1) {
    {
#line 3195
    perror("netperf: send_tcp_stream: tcp stream data socket");
#line 3196
    exit(1);
    }
  }
#line 3199
  if (debug) {
    {
#line 3200
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"send_tcp_stream: send_socket obtained...\n");
    }
  }
#line 3204
  if (! no_control) {
#line 3214
    netperf_request.content.request_type = 10;
#line 3215
    tcp_stream_request->send_buf_size = rss_size_req;
#line 3216
    tcp_stream_request->recv_buf_size = rsr_size_req;
#line 3217
    tcp_stream_request->receive_size = recv_size;
#line 3218
    tcp_stream_request->no_delay = rem_nodelay;
#line 3219
    tcp_stream_request->recv_alignment = remote_recv_align;
#line 3220
    tcp_stream_request->recv_offset = remote_recv_offset;
#line 3221
    tcp_stream_request->measure_cpu = remote_cpu_usage;
#line 3222
    tcp_stream_request->cpu_rate = remote_cpu_rate;
#line 3223
    if (test_time) {
#line 3224
      tcp_stream_request->test_length = test_time;
    } else {
#line 3227
      tcp_stream_request->test_length = test_bytes;
    }
    {
#line 3229
    tcp_stream_request->so_rcvavoid = rem_rcvavoid;
#line 3230
    tcp_stream_request->so_sndavoid = rem_sndavoid;
#line 3235
    tcp_stream_request->port = atoi((char const   *)(remote_data_port));
#line 3236
    tcp_stream_request->ipfamily = af_to_nf(remote_res->ai_family);
    }
#line 3237
    if (debug > 1) {
      {
#line 3238
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: send_tcp_mss: requesting TCP stream test\n");
      }
    }
    {
#line 3242
    send_request();
#line 3255
    recv_response();
    }
#line 3257
    if (! netperf_response.content.serv_errno) {
#line 3258
      if (debug) {
        {
#line 3259
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"remote listen done.\n");
        }
      }
      {
#line 3260
      rsr_size = tcp_stream_response->recv_buf_size;
#line 3261
      rss_size = tcp_stream_response->send_buf_size;
#line 3262
      rem_nodelay = tcp_stream_response->no_delay;
#line 3263
      remote_cpu_usage = tcp_stream_response->measure_cpu;
#line 3264
      remote_cpu_rate = tcp_stream_response->cpu_rate;
#line 3268
      set_port_number(remote_res, (unsigned short )((short )tcp_stream_response->data_port_number));
#line 3271
      rem_rcvavoid = tcp_stream_response->so_rcvavoid;
#line 3272
      rem_sndavoid = tcp_stream_response->so_sndavoid;
      }
    } else {
      {
#line 3275
      tmp = __errno_location();
#line 3275
      *tmp = netperf_response.content.serv_errno;
#line 3276
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: remote error %d",
              netperf_response.content.serv_errno);
#line 3279
      perror("");
#line 3280
      fflush(where);
#line 3282
      exit(1);
      }
    }
  }
  {
#line 3287
  tmp___0 = connect(send_socket, (struct sockaddr  const  *)remote_res->ai_addr, remote_res->ai_addrlen);
  }
#line 3287
  if (tmp___0 == -1) {
    {
#line 3290
    perror("netperf: send_tcp_mss: data socket connect failed");
#line 3291
    exit(1);
    }
  }
  {
#line 3296
  tcp_mss = -1;
#line 3297
  get_tcp_info(send_socket, & tcp_mss);
#line 3301
  close(send_socket);
  }
  {
#line 3307
  if (verbosity == 0) {
#line 3307
    goto case_0;
  }
#line 3315
  if (verbosity == 2) {
#line 3315
    goto case_2;
  }
#line 3315
  if (verbosity == 1) {
#line 3315
    goto case_2;
  }
#line 3306
  goto switch_break;
  case_0: /* CIL Label */ 
#line 3308
  if (print_headers) {
#line 3308
    tmp___1 = "";
  } else
#line 3308
  if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 3308
    tmp___1 = "";
  } else {
#line 3308
    tmp___1 = (char const   *)result_brand;
  }
  {
#line 3308
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)mss_fmt_0,
          tcp_mss, tmp___1);
  }
#line 3313
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 3316
  if (print_headers) {
    {
#line 3317
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s",
            mss_title);
    }
  }
#line 3319
  if (print_headers) {
#line 3319
    tmp___2 = "";
  } else
#line 3319
  if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 3319
    tmp___2 = "";
  } else {
#line 3319
    tmp___2 = (char const   *)result_brand;
  }
  {
#line 3319
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)mss_fmt_0,
          tcp_mss, tmp___2);
  }
#line 3324
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3328
  return;
}
}
#line 4120 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void sendfile_tcp_stream(char *remote_host ) 
{ 
  char *tput_title ;
  char *tput_fmt_0 ;
  char *tput_fmt_1 ;
  char *cpu_title ;
  char *cpu_fmt_0 ;
  char *cpu_fmt_1 ;
  char *ksink_fmt ;
  char *ksink_fmt2 ;
  float elapsed_time___0 ;
  struct sendfile_ring_elt *send_ring ;
  int len ;
  unsigned int nummessages ;
  int send_socket ;
  int bytes_remaining ;
  int tcp_mss ;
  double bytes_sent___0 ;
  float local_cpu_utilization___0 ;
  float local_service_demand___0 ;
  float remote_cpu_utilization___0 ;
  float remote_service_demand___0 ;
  double thruput___0 ;
  struct addrinfo *remote_res ;
  struct addrinfo *local_res ;
  struct sockaddr_in server ;
  off_t scratch_offset ;
  struct tcp_stream_request_struct *tcp_stream_request ;
  struct tcp_stream_response_struct *tcp_stream_response ;
  struct tcp_stream_results_struct *tcp_stream_result ;
  int one ;
  struct protoent *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  uint16_t tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;

  {
  {
#line 4125
  tput_title = (char *)"Recv   Send    Send                          \nSocket Socket  Message  Elapsed              \nSize   Size    Size     Time     Throughput  \nbytes  bytes   bytes    secs.    %s/sec  \n\n";
#line 4131
  tput_fmt_0 = (char *)"%7.2f %s\n";
#line 4134
  tput_fmt_1 = (char *)"%6d %6d %6d    %-6.2f   %7.2f   %s\n";
#line 4137
  cpu_title = (char *)"Recv   Send    Send                          Utilization       Service Demand\nSocket Socket  Message  Elapsed              Send     Recv     Send    Recv\nSize   Size    Size     Time     Throughput  local    remote   local   remote\nbytes  bytes   bytes    secs.    %-8.8s/s  %% %c      %% %c      us/KB   us/KB\n\n";
#line 4143
  cpu_fmt_0 = (char *)"%6.3f %c %s\n";
#line 4145
  cpu_fmt_1 = (char *)"%6d %6d %6d    %-6.2f     %7.2f   %-6.2f   %-6.2f   %-6.3f  %-6.3f %s\n";
#line 4148
  ksink_fmt = (char *)"\nAlignment      Offset         %-8.8s %-8.8s    Sends   %-8.8s Recvs\nLocal  Remote  Local  Remote  Xfered   Per                 Per\nSend   Recv    Send   Recv             Send (avg)          Recv (avg)\n%5d   %5d  %5d   %5d %6.4g  %6.2f    %6d   %6.2f %6d\n";
#line 4154
  ksink_fmt2 = (char *)"\nMaximum\nSegment\nSize (bytes)\n%6d\n";
#line 4172
  nummessages = 0U;
#line 4175
  tcp_mss = -1;
#line 4180
  bytes_sent___0 = 0.0;
#line 4214
  tcp_stream_request = (struct tcp_stream_request_struct *)(netperf_request.content.test_specific_data);
#line 4216
  tcp_stream_response = (struct tcp_stream_response_struct *)(netperf_response.content.test_specific_data);
#line 4218
  tcp_stream_result = (struct tcp_stream_results_struct *)(netperf_response.content.test_specific_data);
#line 4232
  bzero((void *)((char *)(& server)), sizeof(server));
#line 4235
  complete_addrinfos(& remote_res, & local_res, remote_host, 1, 6, 0);
  }
#line 4242
  if (print_headers) {
    {
#line 4250
    print_top_test_header((char *)"TCP SENDFILE TEST", local_res, remote_res);
    }
  }
  {
#line 4253
  send_ring = (struct sendfile_ring_elt *)((void *)0);
#line 4254
  confidence_iteration___0 = 1;
#line 4255
  init_stat();
  }
  {
#line 4264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4264
    if (confidence < (double )0) {
#line 4264
      if (! (confidence_iteration___0 < iteration_max)) {
#line 4264
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 4264
    if (! (confidence_iteration___0 <= iteration_min)) {
#line 4264
      goto while_break;
    }
    {
#line 4270
    nummessages = 0U;
#line 4271
    bytes_sent___0 = 0.0;
#line 4272
    times_up = 0;
#line 4275
    send_socket = create_data_socket(local_res);
    }
#line 4277
    if (send_socket == -1) {
      {
#line 4278
      perror("netperf: sendfile_tcp_stream: tcp stream data socket");
#line 4279
      exit(1);
      }
    }
#line 4282
    if (debug) {
      {
#line 4283
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"sendfile_tcp_stream: send_socket obtained...\n");
      }
    }
#line 4288
    if (loc_tcpcork > 0) {
      {
#line 4290
      one = 1;
#line 4291
      tmp = getprotobyname("tcp");
#line 4291
      tmp___0 = setsockopt(send_socket, tmp->p_proto, 3, (void const   *)((char *)(& one)),
                           (socklen_t )sizeof(one));
      }
#line 4291
      if (tmp___0 == -1) {
        {
#line 4296
        perror("netperf: sendfile_tcp_stream: tcp_cork");
#line 4297
        exit(1);
        }
      }
#line 4299
      if (debug) {
        {
#line 4300
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"sendfile_tcp_stream: tcp_cork...\n");
        }
      }
    }
#line 4315
    if (send_size == 0) {
#line 4316
      if (lss_size > 0) {
#line 4317
        send_size = lss_size;
      } else {
#line 4320
        send_size = 4096;
      }
    }
#line 4336
    if (send_width == 0) {
#line 4337
      send_width = lss_size / send_size + 1;
#line 4338
      if (send_width == 1) {
#line 4338
        send_width ++;
      }
    }
#line 4341
    if ((unsigned long )send_ring == (unsigned long )((void *)0)) {
      {
#line 4348
      send_ring = alloc_sendfile_buf_ring(send_width, send_size, local_send_align,
                                          local_send_offset);
      }
    }
#line 4362
    if (local_cpu_usage) {
      {
#line 4363
      local_cpu_rate = calibrate_local_cpu(local_cpu_rate);
      }
    }
#line 4375
    netperf_request.content.request_type = 10;
#line 4376
    tcp_stream_request->send_buf_size = rss_size_req;
#line 4377
    tcp_stream_request->recv_buf_size = rsr_size_req;
#line 4378
    tcp_stream_request->receive_size = recv_size;
#line 4379
    tcp_stream_request->no_delay = rem_nodelay;
#line 4380
    tcp_stream_request->recv_alignment = remote_recv_align;
#line 4381
    tcp_stream_request->recv_offset = remote_recv_offset;
#line 4382
    tcp_stream_request->measure_cpu = remote_cpu_usage;
#line 4383
    tcp_stream_request->cpu_rate = remote_cpu_rate;
#line 4385
    if (test_time) {
#line 4386
      tcp_stream_request->test_length = test_time;
    } else {
#line 4389
      tcp_stream_request->test_length = test_bytes;
    }
    {
#line 4392
    tcp_stream_request->so_rcvavoid = rem_rcvavoid;
#line 4393
    tcp_stream_request->so_sndavoid = rem_sndavoid;
#line 4399
    tcp_stream_request->port = atoi((char const   *)(remote_data_port));
#line 4400
    tcp_stream_request->ipfamily = af_to_nf(remote_res->ai_family);
    }
#line 4402
    if (debug > 1) {
      {
#line 4403
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: send_tcp_stream: requesting TCP stream test\n");
      }
    }
    {
#line 4407
    send_request();
#line 4419
    recv_response();
    }
#line 4421
    if (! netperf_response.content.serv_errno) {
#line 4422
      if (debug) {
        {
#line 4423
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"remote listen done.\n");
        }
      }
      {
#line 4424
      rsr_size = tcp_stream_response->recv_buf_size;
#line 4425
      rss_size = tcp_stream_response->send_buf_size;
#line 4426
      rem_nodelay = tcp_stream_response->no_delay;
#line 4427
      remote_cpu_usage = tcp_stream_response->measure_cpu;
#line 4428
      remote_cpu_rate = tcp_stream_response->cpu_rate;
#line 4432
      set_port_number(remote_res, (unsigned short )((short )tcp_stream_response->data_port_number));
#line 4433
      rem_rcvavoid = tcp_stream_response->so_rcvavoid;
#line 4434
      rem_sndavoid = tcp_stream_response->so_sndavoid;
      }
    } else {
      {
#line 4437
      tmp___1 = __errno_location();
#line 4437
      *tmp___1 = netperf_response.content.serv_errno;
#line 4438
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: remote error %d",
              netperf_response.content.serv_errno);
#line 4441
      perror("");
#line 4442
      fflush(where);
#line 4444
      exit(1);
      }
    }
    {
#line 4452
    tmp___3 = connect(send_socket, (struct sockaddr  const  *)remote_res->ai_addr,
                      remote_res->ai_addrlen);
    }
#line 4452
    if (tmp___3 == -1) {
      {
#line 4455
      perror("netperf: send_tcp_stream: data socket connect failed");
#line 4456
      tmp___2 = ntohs(server.sin_port);
#line 4456
      printf((char const   */* __restrict  */)" port: %d\n", (int )tmp___2);
#line 4457
      exit(1);
      }
    }
#line 4480
    if (test_time) {
      {
#line 4482
      times_up = 0;
#line 4483
      bytes_remaining = 0;
#line 4492
      start_timer(test_time);
      }
    } else {
#line 4496
      bytes_remaining = test_bytes;
#line 4497
      times_up = 1;
    }
    {
#line 4504
    cpu_start(local_cpu_usage);
    }
    {
#line 4525
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4525
      if (! (! times_up)) {
#line 4525
        if (! (bytes_remaining > 0)) {
#line 4525
          goto while_break___0;
        }
      }
      {
#line 4549
      scratch_offset = send_ring->offset;
#line 4550
      tmp___5 = sendfile(send_socket, send_ring->fildes, & scratch_offset, send_ring->length);
#line 4550
      len = (int )tmp___5;
      }
#line 4550
      if (len != send_size) {
#line 4594
        if (len >= 0) {
#line 4595
          goto while_break___0;
        } else {
          {
#line 4594
          tmp___4 = __errno_location();
          }
#line 4594
          if (*tmp___4 == 4) {
#line 4595
            goto while_break___0;
          }
        }
        {
#line 4597
        perror("netperf: data send error: sendfile");
#line 4598
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"len was %d send_size was %d\n",
                len, send_size);
#line 4602
        fflush(stderr);
#line 4603
        exit(1);
        }
      }
#line 4632
      nummessages ++;
#line 4633
      send_ring = send_ring->next;
#line 4634
      if (bytes_remaining) {
#line 4635
        bytes_remaining -= send_size;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4645
    if (verbosity > 1) {
      {
#line 4646
      tcp_mss = -1;
#line 4647
      get_tcp_info(send_socket, & tcp_mss);
      }
    }
    {
#line 4650
    tmp___6 = shutdown(send_socket, 1);
    }
#line 4650
    if (tmp___6 == -1) {
      {
#line 4651
      perror("netperf: cannot shutdown tcp stream socket");
#line 4652
      exit(1);
      }
    }
    {
#line 4667
    recv(send_socket, (void *)(& send_ring->flags), sizeof(send_ring->flags), 0);
#line 4675
    cpu_stop(local_cpu_usage, & elapsed_time___0);
#line 4683
    close(send_socket);
#line 4695
    recv_response();
    }
#line 4697
    if (! netperf_response.content.serv_errno) {
#line 4698
      if (debug) {
        {
#line 4699
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"remote results obtained\n");
        }
      }
    } else {
      {
#line 4703
      tmp___7 = __errno_location();
#line 4703
      *tmp___7 = netperf_response.content.serv_errno;
#line 4704
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: remote error %d",
              netperf_response.content.serv_errno);
#line 4707
      perror("");
#line 4708
      fflush(where);
#line 4710
      exit(1);
      }
    }
    {
#line 4722
    bytes_sent___0 = ntohd(tcp_stream_result->bytes_received);
#line 4724
    thruput___0 = calc_thruput(bytes_sent___0);
    }
#line 4726
    if (local_cpu_usage) {
#line 4726
      goto _L;
    } else
#line 4726
    if (remote_cpu_usage) {
      _L: /* CIL Label */ 
#line 4733
      if (local_cpu_usage) {
        {
#line 4735
        local_cpu_utilization___0 = calc_cpu_util((float )0.0);
#line 4736
        local_service_demand___0 = calc_service_demand(bytes_sent___0, (float )0.0,
                                                       (float )0.0, 0);
        }
      } else {
#line 4742
        local_cpu_utilization___0 = (float )(- 1.0);
#line 4743
        local_service_demand___0 = (float )(- 1.0);
      }
#line 4746
      if (remote_cpu_usage) {
        {
#line 4748
        remote_cpu_utilization___0 = tcp_stream_result->cpu_util;
#line 4749
        remote_service_demand___0 = calc_service_demand(bytes_sent___0, (float )0.0,
                                                        remote_cpu_utilization___0,
                                                        tcp_stream_result->num_cpus);
        }
      } else {
#line 4755
        remote_cpu_utilization___0 = (float )(- 1.0);
#line 4756
        remote_service_demand___0 = (float )(- 1.0);
      }
    } else {
#line 4762
      local_cpu_utilization___0 = (float )(- 1.0);
#line 4763
      local_service_demand___0 = (float )(- 1.0);
#line 4764
      remote_cpu_utilization___0 = (float )(- 1.0);
#line 4765
      remote_service_demand___0 = (float )(- 1.0);
    }
    {
#line 4772
    calculate_confidence(confidence_iteration___0, elapsed_time___0, thruput___0,
                         local_cpu_utilization___0, remote_cpu_utilization___0, local_service_demand___0,
                         remote_service_demand___0);
#line 4780
    confidence_iteration___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4791
  retrieve_confident_values(& elapsed_time___0, & thruput___0, & local_cpu_utilization___0,
                            & remote_cpu_utilization___0, & local_service_demand___0,
                            & remote_service_demand___0);
  }
#line 4807
  if (confidence < (double )0) {
#line 4809
    if (iteration_max > 1) {
      {
#line 4810
      display_confidence();
      }
    }
  }
#line 4814
  if (local_cpu_usage) {
#line 4814
    goto _L___1;
  } else
#line 4814
  if (remote_cpu_usage) {
    _L___1: /* CIL Label */ 
    {
#line 4815
    local_cpu_method___0 = format_cpu_method(cpu_method);
#line 4816
    remote_cpu_method___0 = format_cpu_method(tcp_stream_result->cpu_method);
    }
    {
#line 4819
    if (verbosity == 0) {
#line 4819
      goto case_0;
    }
#line 4842
    if (verbosity == 2) {
#line 4842
      goto case_2;
    }
#line 4842
    if (verbosity == 1) {
#line 4842
      goto case_2;
    }
#line 4818
    goto switch_break;
    case_0: /* CIL Label */ 
#line 4821
    if (local_cpu_usage) {
#line 4822
      if (print_headers) {
#line 4822
        tmp___8 = "";
      } else
#line 4822
      if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 4822
        tmp___8 = "";
      } else {
#line 4822
        tmp___8 = (char const   *)result_brand;
      }
      {
#line 4822
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
              (double )local_service_demand___0, (int )local_cpu_method___0, tmp___8);
      }
    } else {
#line 4831
      if (print_headers) {
#line 4831
        tmp___9 = "";
      } else
#line 4831
      if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 4831
        tmp___9 = "";
      } else {
#line 4831
        tmp___9 = (char const   *)result_brand;
      }
      {
#line 4831
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
              (double )remote_service_demand___0, (int )remote_cpu_method___0, tmp___9);
      }
    }
#line 4839
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 4843
    if (print_headers) {
      {
#line 4844
      tmp___10 = format_units();
#line 4844
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_title,
              tmp___10, (int )local_cpu_method___0, (int )remote_cpu_method___0);
      }
    }
#line 4851
    if (print_headers) {
#line 4851
      tmp___11 = "";
    } else
#line 4851
    if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 4851
      tmp___11 = "";
    } else {
#line 4851
      tmp___11 = (char const   *)result_brand;
    }
    {
#line 4851
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_1,
            rsr_size, lss_size, send_size, (double )elapsed_time___0, thruput___0,
            (double )local_cpu_utilization___0, (double )remote_cpu_utilization___0,
            (double )local_service_demand___0, (double )remote_service_demand___0,
            tmp___11);
    }
#line 4864
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 4874
    if (verbosity == 0) {
#line 4874
      goto case_0___0;
    }
#line 4884
    if (verbosity == 2) {
#line 4884
      goto case_2___0;
    }
#line 4884
    if (verbosity == 1) {
#line 4884
      goto case_2___0;
    }
#line 4872
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 4876
    if (print_headers) {
#line 4876
      tmp___12 = "";
    } else
#line 4876
    if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 4876
      tmp___12 = "";
    } else {
#line 4876
      tmp___12 = (char const   *)result_brand;
    }
    {
#line 4876
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_0,
            thruput___0, tmp___12);
    }
#line 4881
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
#line 4886
    if (print_headers) {
      {
#line 4887
      tmp___13 = format_units();
#line 4887
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_title,
              tmp___13);
      }
    }
#line 4890
    if (print_headers) {
#line 4890
      tmp___14 = "";
    } else
#line 4890
    if ((unsigned long )result_brand == (unsigned long )((void *)0)) {
#line 4890
      tmp___14 = "";
    } else {
#line 4890
      tmp___14 = (char const   *)result_brand;
    }
    {
#line 4890
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_1,
            rsr_size, lss_size, send_size, (double )elapsed_time___0, thruput___0,
            tmp___14);
    }
#line 4899
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 4909
  if (verbosity > 1) {
    {
#line 4919
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)ksink_fmt,
            "Bytes", "Bytes", "Bytes", local_send_align, remote_recv_align, local_send_offset,
            remote_recv_offset, bytes_sent___0, bytes_sent___0 / (double )nummessages,
            nummessages, bytes_sent___0 / (double )tcp_stream_result->recv_calls,
            tcp_stream_result->recv_calls);
#line 4934
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)ksink_fmt2,
            tcp_mss);
#line 4938
    fflush(where);
    }
  }
#line 4947
  return;
}
}
#line 4955 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void recv_tcp_stream(void) 
{ 
  struct sockaddr_storage myaddr_in ;
  struct sockaddr_storage peeraddr_in ;
  int s_listen ;
  int s_data ;
  unsigned int addrlen ;
  int len ;
  unsigned int receive_calls ;
  float elapsed_time___0 ;
  double bytes_received___0 ;
  struct ring_elt *recv_ring ;
  struct addrinfo *local_res ;
  char local_name[8192] ;
  char port_buffer[10] ;
  struct tcp_stream_request_struct *tcp_stream_request ;
  struct tcp_stream_response_struct *tcp_stream_response ;
  struct tcp_stream_results_struct *tcp_stream_results ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  uint16_t tmp___6 ;
  int *tmp___7 ;
  ssize_t tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;

  {
#line 4988
  tcp_stream_request = (struct tcp_stream_request_struct *)(netperf_request.content.test_specific_data);
#line 4990
  tcp_stream_response = (struct tcp_stream_response_struct *)(netperf_response.content.test_specific_data);
#line 4992
  tcp_stream_results = (struct tcp_stream_results_struct *)(netperf_response.content.test_specific_data);
#line 4995
  if (debug) {
    {
#line 4996
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netserver: recv_tcp_stream: entered...\n");
#line 4997
    fflush(where);
    }
  }
#line 5013
  if (debug) {
    {
#line 5014
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_stream: setting the response type...\n");
#line 5015
    fflush(where);
    }
  }
#line 5018
  netperf_response.content.response_type = 11;
#line 5020
  if (debug) {
    {
#line 5021
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_stream: the response type is set...\n");
#line 5022
    fflush(where);
    }
  }
#line 5028
  if (debug) {
    {
#line 5029
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_stream: requested alignment of %d\n",
            tcp_stream_request->recv_alignment);
#line 5031
    fflush(where);
    }
  }
  {
#line 5038
  lss_size_req = tcp_stream_request->send_buf_size;
#line 5039
  lsr_size_req = tcp_stream_request->recv_buf_size;
#line 5040
  loc_nodelay = tcp_stream_request->no_delay;
#line 5041
  loc_rcvavoid = tcp_stream_request->so_rcvavoid;
#line 5042
  loc_sndavoid = tcp_stream_request->so_sndavoid;
#line 5044
  tmp = nf_to_af(tcp_stream_request->ipfamily);
#line 5044
  set_hostname_and_port(local_name, port_buffer, tmp, tcp_stream_request->port);
#line 5049
  tmp___0 = nf_to_af(tcp_stream_request->ipfamily);
#line 5049
  local_res = complete_addrinfo(local_name, local_name, port_buffer, tmp___0, 1, 6,
                                0);
#line 5057
  s_listen = create_data_socket(local_res);
  }
#line 5059
  if (s_listen == -1) {
    {
#line 5060
    tmp___1 = __errno_location();
#line 5060
    netperf_response.content.serv_errno = *tmp___1;
#line 5061
    send_response();
#line 5062
    exit(1);
    }
  }
#line 5073
  if (tcp_stream_request->receive_size == 0) {
#line 5074
    if (lsr_size > 0) {
#line 5075
      recv_size = lsr_size;
    } else {
#line 5078
      recv_size = 4096;
    }
  } else {
#line 5082
    recv_size = tcp_stream_request->receive_size;
  }
#line 5092
  if (recv_width == 0) {
#line 5093
    recv_width = lsr_size / recv_size + 1;
#line 5094
    if (recv_width == 1) {
#line 5094
      recv_width ++;
    }
  }
  {
#line 5097
  recv_ring = allocate_buffer_ring(recv_width, recv_size, tcp_stream_request->recv_alignment,
                                   tcp_stream_request->recv_offset);
  }
#line 5102
  if (debug) {
    {
#line 5103
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_stream: receive alignment and offset set...\n");
#line 5104
    fflush(where);
    }
  }
  {
#line 5108
  tmp___3 = listen(s_listen, 5);
  }
#line 5108
  if (tmp___3 == -1) {
    {
#line 5109
    tmp___2 = __errno_location();
#line 5109
    netperf_response.content.serv_errno = *tmp___2;
#line 5110
    close(s_listen);
#line 5111
    send_response();
#line 5113
    exit(1);
    }
  }
  {
#line 5118
  addrlen = (unsigned int )sizeof(myaddr_in);
#line 5119
  tmp___5 = getsockname(s_listen, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& myaddr_in)),
                        (socklen_t */* __restrict  */)(& addrlen));
  }
#line 5119
  if (tmp___5 == -1) {
    {
#line 5122
    tmp___4 = __errno_location();
#line 5122
    netperf_response.content.serv_errno = *tmp___4;
#line 5123
    close(s_listen);
#line 5124
    send_response();
#line 5126
    exit(1);
    }
  }
  {
#line 5133
  tmp___6 = ntohs(((struct sockaddr_in *)(& myaddr_in))->sin_port);
#line 5133
  tcp_stream_response->data_port_number = (int )tmp___6;
#line 5135
  netperf_response.content.serv_errno = 0;
#line 5143
  tcp_stream_response->cpu_rate = (float )0.0;
  }
#line 5144
  if (tcp_stream_request->measure_cpu) {
    {
#line 5145
    tcp_stream_response->measure_cpu = 1;
#line 5146
    tcp_stream_response->cpu_rate = calibrate_local_cpu(tcp_stream_request->cpu_rate);
    }
  } else {
#line 5150
    tcp_stream_response->measure_cpu = 0;
  }
  {
#line 5155
  tcp_stream_response->send_buf_size = lss_size;
#line 5156
  tcp_stream_response->recv_buf_size = lsr_size;
#line 5157
  tcp_stream_response->no_delay = loc_nodelay;
#line 5158
  tcp_stream_response->so_rcvavoid = loc_rcvavoid;
#line 5159
  tcp_stream_response->so_sndavoid = loc_sndavoid;
#line 5160
  tcp_stream_response->receive_size = recv_size;
#line 5162
  send_response();
#line 5164
  addrlen = (unsigned int )sizeof(peeraddr_in);
#line 5166
  s_data = accept(s_listen, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peeraddr_in)),
                  (socklen_t */* __restrict  */)(& addrlen));
  }
#line 5166
  if (s_data == -1) {
    {
#line 5170
    close(s_listen);
#line 5171
    exit(1);
    }
  }
  {
#line 5185
  times_up = 0;
#line 5187
  start_timer(tcp_stream_request->test_length + 4);
#line 5201
  cpu_start(tcp_stream_request->measure_cpu);
#line 5212
  bytes_received___0 = (double )0;
#line 5213
  receive_calls = 0U;
  }
  {
#line 5215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5215
    if (! times_up) {
      {
#line 5215
      tmp___8 = recv(s_data, (void *)recv_ring->buffer_ptr, (size_t )recv_size, 0);
#line 5215
      len = (int )tmp___8;
      }
#line 5215
      if (! (len != 0)) {
#line 5215
        goto while_break;
      }
    } else {
#line 5215
      goto while_break;
    }
#line 5216
    if (len == -1) {
#line 5217
      if (times_up) {
#line 5218
        goto while_break;
      }
      {
#line 5220
      tmp___7 = __errno_location();
#line 5220
      netperf_response.content.serv_errno = *tmp___7;
#line 5221
      send_response();
#line 5222
      exit(1);
      }
    }
#line 5224
    bytes_received___0 += (double )len;
#line 5225
    receive_calls ++;
#line 5237
    recv_ring = recv_ring->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5253
  tmp___10 = shutdown(s_data, 1);
  }
#line 5253
  if (tmp___10 == -1) {
#line 5253
    if (! times_up) {
      {
#line 5254
      tmp___9 = __errno_location();
#line 5254
      netperf_response.content.serv_errno = *tmp___9;
#line 5255
      send_response();
#line 5256
      exit(1);
      }
    }
  }
  {
#line 5259
  cpu_stop(tcp_stream_request->measure_cpu, & elapsed_time___0);
  }
#line 5263
  if (debug) {
    {
#line 5264
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_stream: got %g bytes\n",
            bytes_received___0);
#line 5267
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_stream: got %d recvs\n",
            receive_calls);
#line 5270
    fflush(where);
    }
  }
  {
#line 5273
  tcp_stream_results->bytes_received = htond(bytes_received___0);
#line 5274
  tcp_stream_results->elapsed_time = elapsed_time___0;
#line 5275
  tcp_stream_results->recv_calls = receive_calls;
#line 5277
  tcp_stream_results->cpu_method = cpu_method;
#line 5278
  tcp_stream_results->num_cpus = lib_num_loc_cpus;
  }
#line 5280
  if (tcp_stream_request->measure_cpu) {
    {
#line 5281
    tcp_stream_results->cpu_util = calc_cpu_util((float )0.0);
    }
  }
#line 5284
  if (debug) {
    {
#line 5285
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_stream: test complete, sending results.\n");
#line 5287
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"                 bytes_received %g receive_calls %d\n",
            bytes_received___0, receive_calls);
#line 5291
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"                 len %d\n",
            len);
#line 5294
    fflush(where);
    }
  }
  {
#line 5297
  send_response();
#line 5300
  close(s_data);
#line 5301
  close(s_listen);
  }
#line 5303
  return;
}
}
#line 5309 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void recv_tcp_maerts(void) 
{ 
  struct sockaddr_storage myaddr_in ;
  struct sockaddr_storage peeraddr_in ;
  struct addrinfo *local_res ;
  char local_name[8192] ;
  char port_buffer[10] ;
  int s_listen ;
  int s_data ;
  unsigned int addrlen ;
  int len ;
  unsigned int send_calls ;
  float elapsed_time___0 ;
  double bytes_sent___0 ;
  struct ring_elt *send_ring ;
  struct tcp_maerts_request_struct *tcp_maerts_request ;
  struct tcp_maerts_response_struct *tcp_maerts_response ;
  struct tcp_maerts_results_struct *tcp_maerts_results ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  uint16_t tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  ssize_t tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;

  {
#line 5323
  bytes_sent___0 = 0.0;
#line 5331
  tcp_maerts_request = (struct tcp_maerts_request_struct *)(netperf_request.content.test_specific_data);
#line 5333
  tcp_maerts_response = (struct tcp_maerts_response_struct *)(netperf_response.content.test_specific_data);
#line 5335
  tcp_maerts_results = (struct tcp_maerts_results_struct *)(netperf_response.content.test_specific_data);
#line 5338
  if (debug) {
    {
#line 5339
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netserver: recv_tcp_maerts: entered...\n");
#line 5340
    fflush(where);
    }
  }
#line 5356
  if (debug) {
    {
#line 5357
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_maerts: setting the response type...\n");
#line 5358
    fflush(where);
    }
  }
#line 5361
  netperf_response.content.response_type = 95;
#line 5363
  if (debug) {
    {
#line 5364
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_maerts: the response type is set...\n");
#line 5365
    fflush(where);
    }
  }
#line 5371
  if (debug) {
    {
#line 5372
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_maerts: requested alignment of %d\n",
            tcp_maerts_request->send_alignment);
#line 5374
    fflush(where);
    }
  }
#line 5379
  if (debug) {
    {
#line 5380
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_maerts: grabbing a socket...\n");
#line 5381
    fflush(where);
    }
  }
  {
#line 5388
  lss_size_req = tcp_maerts_request->send_buf_size;
#line 5389
  lsr_size_req = tcp_maerts_request->recv_buf_size;
#line 5390
  loc_nodelay = tcp_maerts_request->no_delay;
#line 5391
  loc_rcvavoid = tcp_maerts_request->so_rcvavoid;
#line 5392
  loc_sndavoid = tcp_maerts_request->so_sndavoid;
#line 5394
  tmp = nf_to_af(tcp_maerts_request->ipfamily);
#line 5394
  set_hostname_and_port(local_name, port_buffer, tmp, tcp_maerts_request->port);
#line 5399
  tmp___0 = nf_to_af(tcp_maerts_request->ipfamily);
#line 5399
  local_res = complete_addrinfo(local_name, local_name, port_buffer, tmp___0, 1, 6,
                                0);
#line 5407
  s_listen = create_data_socket(local_res);
  }
#line 5409
  if (s_listen == -1) {
    {
#line 5410
    tmp___1 = __errno_location();
#line 5410
    netperf_response.content.serv_errno = *tmp___1;
#line 5411
    send_response();
#line 5412
    exit(1);
    }
  }
#line 5424
  if (tcp_maerts_request->send_size == 0) {
#line 5425
    if (lss_size > 0) {
#line 5426
      send_size = lss_size;
    } else {
#line 5429
      send_size = 4096;
    }
  } else {
#line 5433
    send_size = tcp_maerts_request->send_size;
  }
#line 5443
  if (send_width == 0) {
#line 5444
    send_width = lsr_size / send_size + 1;
#line 5445
    if (send_width == 1) {
#line 5445
      send_width ++;
    }
  }
  {
#line 5448
  send_ring = allocate_buffer_ring(send_width, send_size, tcp_maerts_request->send_alignment,
                                   tcp_maerts_request->send_offset);
  }
#line 5453
  if (debug) {
    {
#line 5454
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_maerts: receive alignment and offset set...\n");
#line 5455
    fflush(where);
    }
  }
  {
#line 5459
  tmp___3 = listen(s_listen, 5);
  }
#line 5459
  if (tmp___3 == -1) {
    {
#line 5460
    tmp___2 = __errno_location();
#line 5460
    netperf_response.content.serv_errno = *tmp___2;
#line 5461
    close(s_listen);
#line 5462
    send_response();
#line 5464
    exit(1);
    }
  }
  {
#line 5469
  addrlen = (unsigned int )sizeof(myaddr_in);
#line 5470
  tmp___5 = getsockname(s_listen, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& myaddr_in)),
                        (socklen_t */* __restrict  */)(& addrlen));
  }
#line 5470
  if (tmp___5 == -1) {
    {
#line 5473
    tmp___4 = __errno_location();
#line 5473
    netperf_response.content.serv_errno = *tmp___4;
#line 5474
    close(s_listen);
#line 5475
    send_response();
#line 5477
    exit(1);
    }
  }
  {
#line 5484
  tmp___6 = ntohs(((struct sockaddr_in *)(& myaddr_in))->sin_port);
#line 5484
  tcp_maerts_response->data_port_number = (int )tmp___6;
#line 5486
  netperf_response.content.serv_errno = 0;
#line 5494
  tcp_maerts_response->cpu_rate = (float )0.0;
  }
#line 5495
  if (tcp_maerts_request->measure_cpu) {
    {
#line 5496
    tcp_maerts_response->measure_cpu = 1;
#line 5497
    tcp_maerts_response->cpu_rate = calibrate_local_cpu(tcp_maerts_request->cpu_rate);
    }
  } else {
#line 5501
    tcp_maerts_response->measure_cpu = 0;
  }
  {
#line 5506
  tcp_maerts_response->send_buf_size = lss_size;
#line 5507
  tcp_maerts_response->recv_buf_size = lsr_size;
#line 5508
  tcp_maerts_response->no_delay = loc_nodelay;
#line 5509
  tcp_maerts_response->so_rcvavoid = loc_rcvavoid;
#line 5510
  tcp_maerts_response->so_sndavoid = loc_sndavoid;
#line 5511
  tcp_maerts_response->send_size = send_size;
#line 5513
  send_response();
#line 5515
  addrlen = (unsigned int )sizeof(peeraddr_in);
#line 5521
  start_timer(tcp_maerts_request->test_length);
#line 5526
  cpu_start(tcp_maerts_request->measure_cpu);
#line 5529
  s_data = accept(s_listen, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peeraddr_in)),
                  (socklen_t */* __restrict  */)(& addrlen));
  }
#line 5529
  if (s_data == -1) {
    {
#line 5533
    close(s_listen);
#line 5534
    exit(1);
    }
  }
#line 5561
  bytes_sent___0 = 0.0;
#line 5562
  send_calls = 0U;
#line 5564
  len = 0;
#line 5566
  times_up = 0;
  {
#line 5567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5567
    if (! (! times_up)) {
#line 5567
      goto while_break;
    }
    {
#line 5582
    tmp___9 = send(s_data, (void const   *)send_ring->buffer_ptr, (size_t )send_size,
                   0);
#line 5582
    len = (int )tmp___9;
    }
#line 5582
    if (len != send_size) {
#line 5586
      if (len >= 0) {
#line 5588
        goto while_break;
      } else {
        {
#line 5586
        tmp___7 = __errno_location();
        }
#line 5586
        if (*tmp___7 == 4) {
#line 5588
          goto while_break;
        }
      }
      {
#line 5590
      tmp___8 = __errno_location();
#line 5590
      netperf_response.content.serv_errno = *tmp___8;
#line 5591
      send_response();
#line 5592
      exit(1);
      }
    }
#line 5595
    bytes_sent___0 += (double )len;
#line 5596
    send_calls ++;
#line 5599
    send_ring = send_ring->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5606
  tmp___11 = shutdown(s_data, 1);
  }
#line 5606
  if (tmp___11 == -1) {
    {
#line 5607
    tmp___10 = __errno_location();
#line 5607
    netperf_response.content.serv_errno = *tmp___10;
#line 5608
    send_response();
#line 5609
    exit(1);
    }
  }
  {
#line 5617
  recv(s_data, (void *)send_ring->buffer_ptr, (size_t )send_size, 0);
#line 5620
  cpu_stop(tcp_maerts_request->measure_cpu, & elapsed_time___0);
  }
#line 5624
  if (debug) {
    {
#line 5625
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_maerts: got %g bytes\n",
            bytes_sent___0);
#line 5628
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_maerts: got %d sends\n",
            send_calls);
#line 5631
    fflush(where);
    }
  }
  {
#line 5634
  tcp_maerts_results->bytes_sent = htond(bytes_sent___0);
#line 5635
  tcp_maerts_results->elapsed_time = elapsed_time___0;
#line 5636
  tcp_maerts_results->send_calls = send_calls;
  }
#line 5638
  if (tcp_maerts_request->measure_cpu) {
    {
#line 5639
    tcp_maerts_results->cpu_util = calc_cpu_util((float )0.0);
    }
  }
#line 5642
  if (debug) {
    {
#line 5643
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_maerts: test complete, sending results.\n");
#line 5645
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"                 bytes_sent %g send_calls %d\n",
            bytes_sent___0, send_calls);
#line 5649
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"                 len %d\n",
            len);
#line 5652
    fflush(where);
    }
  }
  {
#line 5655
  tcp_maerts_results->cpu_method = cpu_method;
#line 5656
  tcp_maerts_results->num_cpus = lib_num_loc_cpus;
#line 5657
  send_response();
#line 5660
  close(s_data);
#line 5661
  close(s_listen);
  }
#line 5663
  return;
}
}
#line 7103 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void recv_udp_stream(void) 
{ 
  struct ring_elt *recv_ring ;
  struct addrinfo *local_res ;
  char local_name[8192] ;
  char port_buffer[10] ;
  struct sockaddr_storage myaddr_in ;
  int s_data ;
  unsigned int addrlen ;
  struct sockaddr_storage remote_addr ;
  unsigned int remote_addrlen ;
  int len ;
  unsigned int bytes_received___0 ;
  float elapsed_time___0 ;
  int message_size ;
  unsigned int messages_recvd ;
  struct udp_stream_request_struct *udp_stream_request ;
  struct udp_stream_response_struct *udp_stream_response ;
  struct udp_stream_results_struct *udp_stream_results ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  uint16_t tmp___4 ;
  ssize_t tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  ssize_t tmp___10 ;
  ssize_t tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;

  {
#line 7117
  len = 0;
#line 7118
  bytes_received___0 = 0U;
#line 7122
  messages_recvd = 0U;
#line 7128
  udp_stream_request = (struct udp_stream_request_struct *)(netperf_request.content.test_specific_data);
#line 7130
  udp_stream_response = (struct udp_stream_response_struct *)(netperf_response.content.test_specific_data);
#line 7132
  udp_stream_results = (struct udp_stream_results_struct *)(netperf_response.content.test_specific_data);
#line 7135
  if (debug) {
    {
#line 7136
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netserver: recv_udp_stream: entered...\n");
#line 7137
    fflush(where);
    }
  }
#line 7153
  if (debug > 1) {
    {
#line 7154
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_stream: setting the response type...\n");
#line 7155
    fflush(where);
    }
  }
#line 7158
  netperf_response.content.response_type = 17;
#line 7160
  if (debug > 2) {
    {
#line 7161
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_stream: the response type is set...\n");
#line 7162
    fflush(where);
    }
  }
#line 7168
  if (debug > 1) {
    {
#line 7169
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_stream: requested alignment of %d\n",
            udp_stream_request->recv_alignment);
#line 7171
    fflush(where);
    }
  }
#line 7174
  if (recv_width == 0) {
#line 7174
    recv_width = 1;
  }
  {
#line 7176
  recv_ring = allocate_buffer_ring(recv_width, udp_stream_request->message_size, udp_stream_request->recv_alignment,
                                   udp_stream_request->recv_offset);
  }
#line 7181
  if (debug > 1) {
    {
#line 7182
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_stream: receive alignment and offset set...\n");
#line 7183
    fflush(where);
    }
  }
#line 7188
  if (debug > 1) {
    {
#line 7189
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_stream: grabbing a socket...\n");
#line 7190
    fflush(where);
    }
  }
  {
#line 7197
  lsr_size_req = udp_stream_request->recv_buf_size;
#line 7198
  loc_rcvavoid = udp_stream_request->so_rcvavoid;
#line 7199
  loc_sndavoid = udp_stream_request->so_sndavoid;
#line 7200
  local_connected = udp_stream_request->recv_connected;
#line 7202
  tmp = nf_to_af(udp_stream_request->ipfamily);
#line 7202
  set_hostname_and_port(local_name, port_buffer, tmp, udp_stream_request->port);
#line 7207
  tmp___0 = nf_to_af(udp_stream_request->ipfamily);
#line 7207
  local_res = complete_addrinfo(local_name, local_name, port_buffer, tmp___0, 2, 17,
                                0);
#line 7215
  s_data = create_data_socket(local_res);
  }
#line 7217
  if (s_data == -1) {
    {
#line 7218
    tmp___1 = __errno_location();
#line 7218
    netperf_response.content.serv_errno = *tmp___1;
#line 7219
    send_response();
#line 7220
    exit(1);
    }
  }
  {
#line 7223
  udp_stream_response->test_length = udp_stream_request->test_length;
#line 7226
  addrlen = (unsigned int )sizeof(myaddr_in);
#line 7227
  tmp___3 = getsockname(s_data, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& myaddr_in)),
                        (socklen_t */* __restrict  */)(& addrlen));
  }
#line 7227
  if (tmp___3 == -1) {
    {
#line 7230
    tmp___2 = __errno_location();
#line 7230
    netperf_response.content.serv_errno = *tmp___2;
#line 7231
    close(s_data);
#line 7232
    send_response();
#line 7234
    exit(1);
    }
  }
  {
#line 7241
  tmp___4 = ntohs(((struct sockaddr_in *)(& myaddr_in))->sin_port);
#line 7241
  udp_stream_response->data_port_number = (int )tmp___4;
#line 7243
  netperf_response.content.serv_errno = 0;
#line 7251
  udp_stream_response->cpu_rate = (float )0.0;
#line 7252
  udp_stream_response->measure_cpu = 0;
  }
#line 7253
  if (udp_stream_request->measure_cpu) {
    {
#line 7258
    udp_stream_response->measure_cpu = 1;
#line 7259
    udp_stream_response->cpu_rate = calibrate_local_cpu(udp_stream_request->cpu_rate);
    }
  }
  {
#line 7263
  message_size = udp_stream_request->message_size;
#line 7264
  test_time = udp_stream_request->test_length;
#line 7268
  udp_stream_response->send_buf_size = lss_size;
#line 7269
  udp_stream_response->recv_buf_size = lsr_size;
#line 7270
  udp_stream_response->so_rcvavoid = loc_rcvavoid;
#line 7271
  udp_stream_response->so_sndavoid = loc_sndavoid;
#line 7273
  send_response();
#line 7278
  cpu_start(udp_stream_request->measure_cpu);
#line 7293
  times_up = 0;
#line 7295
  start_timer(test_time + 4);
  }
#line 7297
  if (debug) {
    {
#line 7298
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_stream: about to enter inner sanctum.\n");
#line 7299
    fflush(where);
    }
  }
#line 7306
  if (local_connected) {
    {
#line 7309
    remote_addrlen = (unsigned int )sizeof(remote_addr);
#line 7310
    tmp___5 = recvfrom(s_data, (void */* __restrict  */)recv_ring->buffer_ptr, (size_t )message_size,
                       0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& remote_addr)),
                       (socklen_t */* __restrict  */)(& remote_addrlen));
#line 7310
    len = (int )tmp___5;
    }
#line 7313
    if (len != message_size) {
#line 7314
      if (len == -1) {
        {
#line 7314
        tmp___7 = __errno_location();
        }
#line 7314
        if (! (*tmp___7 == 4)) {
          {
#line 7315
          tmp___6 = __errno_location();
#line 7315
          netperf_response.content.serv_errno = *tmp___6;
#line 7316
          send_response();
#line 7317
          exit(1);
          }
        }
      }
    }
    {
#line 7320
    messages_recvd ++;
#line 7321
    recv_ring = recv_ring->next;
#line 7325
    tmp___9 = connect(s_data, (struct sockaddr  const  *)((struct sockaddr *)(& remote_addr)),
                      remote_addrlen);
    }
#line 7325
    if (tmp___9 == -1) {
      {
#line 7328
      tmp___8 = __errno_location();
#line 7328
      netperf_response.content.serv_errno = *tmp___8;
#line 7329
      close(s_data);
#line 7330
      send_response();
#line 7331
      exit(1);
      }
    }
#line 7334
    if (debug) {
      {
#line 7335
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_stream: connected data socket\n");
#line 7336
      fflush(where);
      }
    }
  }
  {
#line 7340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7340
    if (! (! times_up)) {
#line 7340
      goto while_break;
    }
#line 7341
    if (local_connected) {
      {
#line 7342
      tmp___10 = recv(s_data, (void *)recv_ring->buffer_ptr, (size_t )message_size,
                      0);
#line 7342
      len = (int )tmp___10;
      }
    } else {
      {
#line 7347
      tmp___11 = recvfrom(s_data, (void */* __restrict  */)recv_ring->buffer_ptr,
                          (size_t )message_size, 0, (struct sockaddr */* __restrict  */)0,
                          (socklen_t */* __restrict  */)0);
#line 7347
      len = (int )tmp___11;
      }
    }
#line 7353
    if (len != message_size) {
#line 7354
      if (len == -1) {
        {
#line 7354
        tmp___13 = __errno_location();
        }
#line 7354
        if (! (*tmp___13 == 4)) {
          {
#line 7355
          tmp___12 = __errno_location();
#line 7355
          netperf_response.content.serv_errno = *tmp___12;
#line 7356
          send_response();
#line 7357
          exit(1);
          }
        }
      }
#line 7359
      goto while_break;
    }
#line 7361
    messages_recvd ++;
#line 7362
    recv_ring = recv_ring->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 7365
  if (debug) {
    {
#line 7366
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_stream: got %d messages.\n",
            messages_recvd);
#line 7367
    fflush(where);
    }
  }
  {
#line 7375
  cpu_stop(udp_stream_request->measure_cpu, & elapsed_time___0);
  }
#line 7377
  if (times_up) {
#line 7379
    elapsed_time___0 -= (float )4;
  } else {
    {
#line 7382
    stop_timer();
    }
  }
#line 7385
  if (debug) {
    {
#line 7386
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_stream: test ended in %f seconds.\n",
            (double )elapsed_time___0);
#line 7387
    fflush(where);
    }
  }
#line 7392
  bytes_received___0 = messages_recvd * (unsigned int )message_size + (unsigned int )len;
#line 7396
  if (debug) {
    {
#line 7397
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_stream: got %d bytes\n",
            bytes_received___0);
#line 7400
    fflush(where);
    }
  }
#line 7403
  netperf_response.content.response_type = 18;
#line 7404
  udp_stream_results->bytes_received = bytes_received___0;
#line 7405
  udp_stream_results->messages_recvd = messages_recvd;
#line 7406
  udp_stream_results->elapsed_time = elapsed_time___0;
#line 7407
  udp_stream_results->cpu_method = cpu_method;
#line 7408
  udp_stream_results->num_cpus = lib_num_loc_cpus;
#line 7409
  if (udp_stream_request->measure_cpu) {
    {
#line 7410
    udp_stream_results->cpu_util = calc_cpu_util(elapsed_time___0);
    }
  } else {
#line 7413
    udp_stream_results->cpu_util = (float )(- 1.0);
  }
#line 7416
  if (debug > 1) {
    {
#line 7417
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_stream: test complete, sending results.\n");
#line 7419
    fflush(where);
    }
  }
  {
#line 7422
  send_response();
#line 7424
  close(s_data);
  }
#line 7426
  return;
}
}
#line 8113 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void recv_udp_rr(void) 
{ 
  struct ring_elt *recv_ring ;
  struct ring_elt *send_ring ;
  struct addrinfo *local_res ;
  char local_name[8192] ;
  char port_buffer[10] ;
  struct sockaddr_storage myaddr_in ;
  struct sockaddr_storage peeraddr ;
  int s_data ;
  unsigned int addrlen ;
  int trans_received ;
  int trans_remaining ;
  int request_bytes_recvd ;
  int response_bytes_sent ;
  float elapsed_time___0 ;
  struct udp_rr_request_struct *udp_rr_request ;
  struct udp_rr_response_struct *udp_rr_response ;
  struct udp_rr_results_struct *udp_rr_results ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  uint16_t tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  ssize_t tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  ssize_t tmp___10 ;

  {
#line 8138
  udp_rr_request = (struct udp_rr_request_struct *)(netperf_request.content.test_specific_data);
#line 8140
  udp_rr_response = (struct udp_rr_response_struct *)(netperf_response.content.test_specific_data);
#line 8142
  udp_rr_results = (struct udp_rr_results_struct *)(netperf_response.content.test_specific_data);
#line 8145
  if (debug) {
    {
#line 8146
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netserver: recv_udp_rr: entered...\n");
#line 8147
    fflush(where);
    }
  }
#line 8163
  if (debug) {
    {
#line 8164
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_rr: setting the response type...\n");
#line 8165
    fflush(where);
    }
  }
#line 8168
  netperf_response.content.response_type = 20;
#line 8170
  if (debug) {
    {
#line 8171
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_rr: the response type is set...\n");
#line 8172
    fflush(where);
    }
  }
#line 8178
  if (debug) {
    {
#line 8179
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_rr: requested recv alignment of %d offset %d\n",
            udp_rr_request->recv_alignment, udp_rr_request->recv_offset);
#line 8182
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_rr: requested send alignment of %d offset %d\n",
            udp_rr_request->send_alignment, udp_rr_request->send_offset);
#line 8185
    fflush(where);
    }
  }
#line 8188
  if (send_width == 0) {
#line 8188
    send_width = 1;
  }
#line 8189
  if (recv_width == 0) {
#line 8189
    recv_width = 1;
  }
  {
#line 8191
  recv_ring = allocate_buffer_ring(recv_width, udp_rr_request->request_size, udp_rr_request->recv_alignment,
                                   udp_rr_request->recv_offset);
#line 8196
  send_ring = allocate_buffer_ring(send_width, udp_rr_request->response_size, udp_rr_request->send_alignment,
                                   udp_rr_request->send_offset);
  }
#line 8201
  if (debug) {
    {
#line 8202
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_rr: receive alignment and offset set...\n");
#line 8203
    fflush(where);
    }
  }
#line 8208
  if (debug) {
    {
#line 8209
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_rr: grabbing a socket...\n");
#line 8210
    fflush(where);
    }
  }
  {
#line 8218
  lss_size_req = udp_rr_request->send_buf_size;
#line 8219
  lsr_size_req = udp_rr_request->recv_buf_size;
#line 8220
  loc_rcvavoid = udp_rr_request->so_rcvavoid;
#line 8221
  loc_sndavoid = udp_rr_request->so_sndavoid;
#line 8223
  tmp = nf_to_af(udp_rr_request->ipfamily);
#line 8223
  set_hostname_and_port(local_name, port_buffer, tmp, udp_rr_request->port);
#line 8228
  tmp___0 = nf_to_af(udp_rr_request->ipfamily);
#line 8228
  local_res = complete_addrinfo(local_name, local_name, port_buffer, tmp___0, 2, 17,
                                0);
#line 8236
  s_data = create_data_socket(local_res);
  }
#line 8238
  if (s_data == -1) {
    {
#line 8239
    tmp___1 = __errno_location();
#line 8239
    netperf_response.content.serv_errno = *tmp___1;
#line 8240
    send_response();
#line 8242
    exit(1);
    }
  }
  {
#line 8246
  addrlen = (unsigned int )sizeof(myaddr_in);
#line 8247
  tmp___3 = getsockname(s_data, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& myaddr_in)),
                        (socklen_t */* __restrict  */)(& addrlen));
  }
#line 8247
  if (tmp___3 == -1) {
    {
#line 8250
    tmp___2 = __errno_location();
#line 8250
    netperf_response.content.serv_errno = *tmp___2;
#line 8251
    close(s_data);
#line 8252
    send_response();
#line 8254
    exit(1);
    }
  }
  {
#line 8261
  tmp___4 = ntohs(((struct sockaddr_in *)(& myaddr_in))->sin_port);
#line 8261
  udp_rr_response->data_port_number = (int )tmp___4;
#line 8263
  netperf_response.content.serv_errno = 0;
  }
#line 8265
  if (debug) {
    {
#line 8266
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv port number %d\n",
            (int )((struct sockaddr_in *)(& myaddr_in))->sin_port);
#line 8269
    fflush(where);
    }
  }
#line 8278
  udp_rr_response->cpu_rate = (float )0.0;
#line 8279
  udp_rr_response->measure_cpu = 0;
#line 8280
  if (udp_rr_request->measure_cpu) {
    {
#line 8281
    udp_rr_response->measure_cpu = 1;
#line 8282
    udp_rr_response->cpu_rate = calibrate_local_cpu(udp_rr_request->cpu_rate);
    }
  }
  {
#line 8287
  udp_rr_response->send_buf_size = lss_size;
#line 8288
  udp_rr_response->recv_buf_size = lsr_size;
#line 8289
  udp_rr_response->so_rcvavoid = loc_rcvavoid;
#line 8290
  udp_rr_response->so_sndavoid = loc_sndavoid;
#line 8292
  send_response();
#line 8298
  cpu_start(udp_rr_request->measure_cpu);
  }
#line 8310
  if (udp_rr_request->test_length > 0) {
    {
#line 8311
    times_up = 0;
#line 8312
    trans_remaining = 0;
#line 8313
    start_timer(udp_rr_request->test_length + 4);
    }
  } else {
#line 8316
    times_up = 1;
#line 8317
    trans_remaining = udp_rr_request->test_length * -1;
  }
  {
#line 8320
  addrlen = (unsigned int )sizeof(peeraddr);
#line 8321
  bzero((void *)((char *)(& peeraddr)), (size_t )addrlen);
#line 8323
  trans_received = 0;
  }
  {
#line 8325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8325
    if (! (! times_up)) {
#line 8325
      if (! (trans_remaining > 0)) {
#line 8325
        goto while_break;
      }
    }
    {
#line 8328
    tmp___7 = recvfrom(s_data, (void */* __restrict  */)recv_ring->buffer_ptr, (size_t )udp_rr_request->request_size,
                       0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peeraddr)),
                       (socklen_t */* __restrict  */)(& addrlen));
#line 8328
    request_bytes_recvd = (int )tmp___7;
    }
#line 8328
    if (request_bytes_recvd != udp_rr_request->request_size) {
      {
#line 8334
      tmp___5 = __errno_location();
      }
#line 8334
      if (*tmp___5 == 4) {
#line 8337
        goto while_break;
      }
      {
#line 8339
      tmp___6 = __errno_location();
#line 8339
      netperf_response.content.serv_errno = *tmp___6;
#line 8340
      send_response();
#line 8341
      exit(1);
      }
    }
    {
#line 8343
    recv_ring = recv_ring->next;
#line 8346
    tmp___10 = sendto(s_data, (void const   *)send_ring->buffer_ptr, (size_t )udp_rr_request->response_size,
                      0, (struct sockaddr  const  *)((struct sockaddr *)(& peeraddr)),
                      addrlen);
#line 8346
    response_bytes_sent = (int )tmp___10;
    }
#line 8346
    if (response_bytes_sent != udp_rr_request->response_size) {
      {
#line 8353
      tmp___8 = __errno_location();
      }
#line 8353
      if (*tmp___8 == 4) {
#line 8356
        goto while_break;
      }
      {
#line 8358
      tmp___9 = __errno_location();
#line 8358
      netperf_response.content.serv_errno = *tmp___9;
#line 8359
      send_response();
#line 8360
      exit(1);
      }
    }
#line 8362
    send_ring = send_ring->next;
#line 8364
    trans_received ++;
#line 8365
    if (trans_remaining) {
#line 8366
      trans_remaining --;
    }
#line 8369
    if (debug) {
      {
#line 8370
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_rr: Transaction %d complete.\n",
              trans_received);
#line 8373
      fflush(where);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 8382
  cpu_stop(udp_rr_request->measure_cpu, & elapsed_time___0);
  }
#line 8384
  if (times_up) {
#line 8388
    elapsed_time___0 -= (float )4;
  }
#line 8392
  if (debug) {
    {
#line 8393
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_rr: got %d transactions\n",
            trans_received);
#line 8396
    fflush(where);
    }
  }
#line 8399
  udp_rr_results->bytes_received = (unsigned int )(trans_received * (udp_rr_request->request_size + udp_rr_request->response_size));
#line 8402
  udp_rr_results->trans_received = (unsigned int )trans_received;
#line 8403
  udp_rr_results->elapsed_time = elapsed_time___0;
#line 8404
  udp_rr_results->cpu_method = cpu_method;
#line 8405
  udp_rr_results->num_cpus = lib_num_loc_cpus;
#line 8406
  if (udp_rr_request->measure_cpu) {
    {
#line 8407
    udp_rr_results->cpu_util = calc_cpu_util(elapsed_time___0);
    }
  }
#line 8410
  if (debug) {
    {
#line 8411
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_udp_rr: test complete, sending results.\n");
#line 8413
    fflush(where);
    }
  }
  {
#line 8416
  send_response();
#line 8419
  close(s_data);
  }
#line 8421
  return;
}
}
#line 8426 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void recv_tcp_rr(void) 
{ 
  struct ring_elt *send_ring ;
  struct ring_elt *recv_ring ;
  struct addrinfo *local_res ;
  char local_name[8192] ;
  char port_buffer[10] ;
  struct sockaddr_storage myaddr_in ;
  struct sockaddr_storage peeraddr_in ;
  int s_listen ;
  int s_data ;
  unsigned int addrlen ;
  char *temp_message_ptr ;
  int trans_received ;
  int trans_remaining ;
  int bytes_sent___0 ;
  int request_bytes_recvd ;
  int request_bytes_remaining ;
  int timed_out ;
  int sock_closed ;
  float elapsed_time___0 ;
  struct tcp_rr_request_struct *tcp_rr_request ;
  struct tcp_rr_response_struct *tcp_rr_response ;
  struct tcp_rr_results_struct *tcp_rr_results ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  uint16_t tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  ssize_t tmp___9 ;
  int *tmp___10 ;
  ssize_t tmp___11 ;

  {
#line 8447
  timed_out = 0;
#line 8448
  sock_closed = 0;
#line 8455
  tcp_rr_request = (struct tcp_rr_request_struct *)(netperf_request.content.test_specific_data);
#line 8457
  tcp_rr_response = (struct tcp_rr_response_struct *)(netperf_response.content.test_specific_data);
#line 8459
  tcp_rr_results = (struct tcp_rr_results_struct *)(netperf_response.content.test_specific_data);
#line 8462
  if (debug) {
    {
#line 8463
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netserver: recv_tcp_rr: entered...\n");
#line 8464
    fflush(where);
    }
  }
#line 8480
  if (debug) {
    {
#line 8481
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_rr: setting the response type...\n");
#line 8482
    fflush(where);
    }
  }
#line 8485
  netperf_response.content.response_type = 14;
#line 8487
  if (debug) {
    {
#line 8488
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_rr: the response type is set...\n");
#line 8489
    fflush(where);
    }
  }
#line 8494
  if (debug) {
    {
#line 8495
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_rr: requested recv alignment of %d offset %d\n",
            tcp_rr_request->recv_alignment, tcp_rr_request->recv_offset);
#line 8498
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_rr: requested send alignment of %d offset %d\n",
            tcp_rr_request->send_alignment, tcp_rr_request->send_offset);
#line 8501
    fflush(where);
    }
  }
#line 8505
  if (send_width == 0) {
#line 8505
    send_width = 1;
  }
#line 8506
  if (recv_width == 0) {
#line 8506
    recv_width = 1;
  }
  {
#line 8508
  send_ring = allocate_buffer_ring(send_width, tcp_rr_request->response_size, tcp_rr_request->send_alignment,
                                   tcp_rr_request->send_offset);
#line 8513
  recv_ring = allocate_buffer_ring(recv_width, tcp_rr_request->request_size, tcp_rr_request->recv_alignment,
                                   tcp_rr_request->recv_offset);
  }
#line 8521
  if (debug) {
    {
#line 8522
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_rr: grabbing a socket...\n");
#line 8523
    fflush(where);
    }
  }
  {
#line 8530
  lss_size_req = tcp_rr_request->send_buf_size;
#line 8531
  lsr_size_req = tcp_rr_request->recv_buf_size;
#line 8532
  loc_nodelay = tcp_rr_request->no_delay;
#line 8533
  loc_rcvavoid = tcp_rr_request->so_rcvavoid;
#line 8534
  loc_sndavoid = tcp_rr_request->so_sndavoid;
#line 8536
  tmp = nf_to_af(tcp_rr_request->ipfamily);
#line 8536
  set_hostname_and_port(local_name, port_buffer, tmp, tcp_rr_request->port);
#line 8541
  tmp___0 = nf_to_af(tcp_rr_request->ipfamily);
#line 8541
  local_res = complete_addrinfo(local_name, local_name, port_buffer, tmp___0, 1, 6,
                                0);
#line 8549
  s_listen = create_data_socket(local_res);
  }
#line 8551
  if (s_listen == -1) {
    {
#line 8552
    tmp___1 = __errno_location();
#line 8552
    netperf_response.content.serv_errno = *tmp___1;
#line 8553
    send_response();
#line 8555
    exit(1);
    }
  }
  {
#line 8568
  tmp___3 = listen(s_listen, 5);
  }
#line 8568
  if (tmp___3 == -1) {
    {
#line 8569
    tmp___2 = __errno_location();
#line 8569
    netperf_response.content.serv_errno = *tmp___2;
#line 8570
    close(s_listen);
#line 8571
    send_response();
#line 8573
    exit(1);
    }
  }
  {
#line 8578
  addrlen = (unsigned int )sizeof(myaddr_in);
#line 8579
  tmp___5 = getsockname(s_listen, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& myaddr_in)),
                        (socklen_t */* __restrict  */)(& addrlen));
  }
#line 8579
  if (tmp___5 == -1) {
    {
#line 8582
    tmp___4 = __errno_location();
#line 8582
    netperf_response.content.serv_errno = *tmp___4;
#line 8583
    close(s_listen);
#line 8584
    send_response();
#line 8586
    exit(1);
    }
  }
  {
#line 8593
  tmp___6 = ntohs(((struct sockaddr_in *)(& myaddr_in))->sin_port);
#line 8593
  tcp_rr_response->data_port_number = (int )tmp___6;
#line 8595
  netperf_response.content.serv_errno = 0;
#line 8603
  tcp_rr_response->cpu_rate = (float )0.0;
#line 8604
  tcp_rr_response->measure_cpu = 0;
  }
#line 8606
  if (tcp_rr_request->measure_cpu) {
    {
#line 8607
    tcp_rr_response->measure_cpu = 1;
#line 8608
    tcp_rr_response->cpu_rate = calibrate_local_cpu(tcp_rr_request->cpu_rate);
    }
  }
  {
#line 8614
  tcp_rr_response->send_buf_size = lss_size;
#line 8615
  tcp_rr_response->recv_buf_size = lsr_size;
#line 8616
  tcp_rr_response->no_delay = loc_nodelay;
#line 8617
  tcp_rr_response->so_rcvavoid = loc_rcvavoid;
#line 8618
  tcp_rr_response->so_sndavoid = loc_sndavoid;
#line 8619
  tcp_rr_response->test_length = tcp_rr_request->test_length;
#line 8620
  send_response();
#line 8622
  addrlen = (unsigned int )sizeof(peeraddr_in);
#line 8624
  s_data = accept(s_listen, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peeraddr_in)),
                  (socklen_t */* __restrict  */)(& addrlen));
  }
#line 8624
  if (s_data == -1) {
    {
#line 8628
    close(s_listen);
#line 8630
    exit(1);
    }
  }
#line 8653
  if (debug) {
    {
#line 8654
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_rr: accept completes on the data connection.\n");
#line 8655
    fflush(where);
    }
  }
  {
#line 8661
  cpu_start(tcp_rr_request->measure_cpu);
  }
#line 8666
  if (tcp_rr_request->test_length > 0) {
    {
#line 8667
    times_up = 0;
#line 8668
    trans_remaining = 0;
#line 8669
    start_timer(tcp_rr_request->test_length + 4);
    }
  } else {
#line 8672
    times_up = 1;
#line 8673
    trans_remaining = tcp_rr_request->test_length * -1;
  }
#line 8676
  trans_received = 0;
  {
#line 8678
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8678
    if (! (! times_up)) {
#line 8678
      if (! (trans_remaining > 0)) {
#line 8678
        goto while_break;
      }
    }
#line 8679
    temp_message_ptr = recv_ring->buffer_ptr;
#line 8680
    request_bytes_remaining = tcp_rr_request->request_size;
    {
#line 8681
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 8681
      if (! (request_bytes_remaining > 0)) {
#line 8681
        goto while_break___0;
      }
      {
#line 8682
      tmp___9 = recv(s_data, (void *)temp_message_ptr, (size_t )request_bytes_remaining,
                     0);
#line 8682
      request_bytes_recvd = (int )tmp___9;
      }
#line 8682
      if (request_bytes_recvd == -1) {
        {
#line 8686
        tmp___7 = __errno_location();
        }
#line 8686
        if (*tmp___7 == 4) {
#line 8688
          timed_out = 1;
#line 8689
          goto while_break___0;
        }
        {
#line 8692
        tmp___8 = __errno_location();
#line 8692
        netperf_response.content.serv_errno = *tmp___8;
#line 8693
        send_response();
#line 8694
        exit(1);
        }
      } else
#line 8696
      if (request_bytes_recvd == 0) {
#line 8697
        if (debug) {
          {
#line 8698
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"zero is my hero\n");
#line 8699
          fflush(where);
          }
        }
#line 8701
        sock_closed = 1;
#line 8702
        goto while_break___0;
      } else {
#line 8705
        request_bytes_remaining -= request_bytes_recvd;
#line 8706
        temp_message_ptr += request_bytes_recvd;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 8710
    recv_ring = recv_ring->next;
#line 8712
    if (timed_out) {
#line 8712
      goto _L;
    } else
#line 8712
    if (sock_closed) {
      _L: /* CIL Label */ 
#line 8715
      if (debug) {
        {
#line 8716
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"yo5\n");
#line 8717
        fflush(where);
        }
      }
#line 8719
      goto while_break;
    }
    {
#line 8723
    tmp___11 = send(s_data, (void const   *)send_ring->buffer_ptr, (size_t )tcp_rr_request->response_size,
                    0);
#line 8723
    bytes_sent___0 = (int )tmp___11;
    }
#line 8723
    if (bytes_sent___0 == -1) {
      {
#line 8727
      tmp___10 = __errno_location();
      }
#line 8727
      if (*tmp___10 == 4) {
        {
#line 8729
        timed_out = 1;
#line 8730
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"yo6\n");
#line 8731
        fflush(where);
        }
#line 8732
        goto while_break;
      }
      {
#line 8734
      netperf_response.content.serv_errno = 992;
#line 8735
      send_response();
#line 8736
      exit(1);
      }
    }
#line 8739
    send_ring = send_ring->next;
#line 8741
    trans_received ++;
#line 8742
    if (trans_remaining) {
#line 8743
      trans_remaining --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 8751
  cpu_stop(tcp_rr_request->measure_cpu, & elapsed_time___0);
#line 8753
  stop_timer();
  }
#line 8755
  if (timed_out) {
#line 8759
    elapsed_time___0 -= (float )4;
  }
#line 8764
  if (debug) {
    {
#line 8765
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_rr: got %d transactions\n",
            trans_received);
#line 8768
    fflush(where);
    }
  }
#line 8771
  tcp_rr_results->bytes_received = (unsigned int )(trans_received * (tcp_rr_request->request_size + tcp_rr_request->response_size));
#line 8774
  tcp_rr_results->trans_received = (unsigned int )trans_received;
#line 8775
  tcp_rr_results->elapsed_time = elapsed_time___0;
#line 8776
  tcp_rr_results->cpu_method = cpu_method;
#line 8777
  tcp_rr_results->num_cpus = lib_num_loc_cpus;
#line 8778
  if (tcp_rr_request->measure_cpu) {
    {
#line 8779
    tcp_rr_results->cpu_util = calc_cpu_util(elapsed_time___0);
    }
  }
#line 8782
  if (debug) {
    {
#line 8783
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_rr: test complete, sending results.\n");
#line 8785
    fflush(where);
    }
  }
  {
#line 8789
  close(s_data);
#line 8790
  close(s_listen);
#line 8792
  send_response();
  }
#line 8794
  return;
}
}
#line 8797 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void loc_cpu_rate(void) 
{ 
  float tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 8811
  tmp = calibrate_local_cpu((float )0.0);
#line 8811
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%g", (double )tmp);
  }
#line 8815
  if (verbosity > 1) {
#line 8816
    if (lib_num_loc_cpus > 1) {
#line 8816
      tmp___0 = "cpus";
    } else {
#line 8816
      tmp___0 = "cpu";
    }
#line 8816
    if (lib_num_loc_cpus > 1) {
#line 8816
      tmp___1 = "are";
    } else {
#line 8816
      tmp___1 = "is";
    }
    {
#line 8816
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"\nThere %s %d local %s\n",
            tmp___1, lib_num_loc_cpus, tmp___0);
    }
  }
#line 8830
  return;
}
}
#line 8832 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void rem_cpu_rate(void) 
{ 
  float tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 8839
  tmp = calibrate_remote_cpu();
#line 8839
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%g", (double )tmp);
  }
#line 8843
  if (verbosity > 1) {
#line 8844
    if (lib_num_rem_cpus > 1) {
#line 8844
      tmp___0 = "cpus";
    } else {
#line 8844
      tmp___0 = "cpu";
    }
#line 8844
    if (lib_num_rem_cpus > 1) {
#line 8844
      tmp___1 = "are";
    } else {
#line 8844
      tmp___1 = "is";
    }
    {
#line 8844
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"\nThere %s %d remote %s\n",
            tmp___1, lib_num_rem_cpus, tmp___0);
    }
  }
#line 8850
  return;
}
}
#line 9538 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void recv_tcp_conn_rr(void) 
{ 
  char *message ;
  struct addrinfo *local_res ;
  char local_name[8192] ;
  char port_buffer[10] ;
  struct sockaddr_storage myaddr_in ;
  struct sockaddr_storage peeraddr_in ;
  int s_listen ;
  int s_data ;
  unsigned int addrlen ;
  char *recv_message_ptr ;
  char *send_message_ptr ;
  char *temp_message_ptr ;
  int trans_received ;
  int trans_remaining ;
  int bytes_sent___0 ;
  int request_bytes_recvd ;
  int request_bytes_remaining ;
  int timed_out ;
  float elapsed_time___0 ;
  struct tcp_conn_rr_request_struct *tcp_conn_rr_request ;
  struct tcp_conn_rr_response_struct *tcp_conn_rr_response ;
  struct tcp_conn_rr_results_struct *tcp_conn_rr_results ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  uint16_t tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  ssize_t tmp___12 ;
  int *tmp___13 ;
  ssize_t tmp___14 ;

  {
#line 9558
  timed_out = 0;
#line 9565
  tcp_conn_rr_request = (struct tcp_conn_rr_request_struct *)(netperf_request.content.test_specific_data);
#line 9567
  tcp_conn_rr_response = (struct tcp_conn_rr_response_struct *)(netperf_response.content.test_specific_data);
#line 9569
  tcp_conn_rr_results = (struct tcp_conn_rr_results_struct *)(netperf_response.content.test_specific_data);
#line 9572
  if (debug) {
    {
#line 9573
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netserver: recv_tcp_conn_rr: entered...\n");
#line 9574
    fflush(where);
    }
  }
#line 9590
  if (debug) {
    {
#line 9591
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_conn_rr: setting the response type...\n");
#line 9592
    fflush(where);
    }
  }
#line 9595
  netperf_response.content.response_type = 35;
#line 9597
  if (debug) {
    {
#line 9598
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_conn_rr: the response type is set...\n");
#line 9599
    fflush(where);
    }
  }
  {
#line 9603
  tmp = malloc((size_t )86016);
#line 9603
  message = (char *)tmp;
  }
#line 9604
  if ((unsigned long )message == (unsigned long )((void *)0)) {
    {
#line 9605
    printf((char const   */* __restrict  */)"malloc(%d) failed!\n", 86016);
#line 9606
    exit(1);
    }
  }
#line 9612
  if (debug) {
    {
#line 9613
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_conn_rr: requested recv alignment of %d offset %d\n",
            tcp_conn_rr_request->recv_alignment, tcp_conn_rr_request->recv_offset);
#line 9617
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_conn_rr: requested send alignment of %d offset %d\n",
            tcp_conn_rr_request->send_alignment, tcp_conn_rr_request->send_offset);
#line 9621
    fflush(where);
    }
  }
#line 9624
  recv_message_ptr = (char *)((((unsigned long )message + (unsigned long )tcp_conn_rr_request->recv_alignment) - 1UL) & ~ ((unsigned long )tcp_conn_rr_request->recv_alignment - 1UL)) + (unsigned long )tcp_conn_rr_request->recv_offset;
#line 9626
  send_message_ptr = (char *)((((unsigned long )message + (unsigned long )tcp_conn_rr_request->send_alignment) - 1UL) & ~ ((unsigned long )tcp_conn_rr_request->send_alignment - 1UL)) + (unsigned long )tcp_conn_rr_request->send_offset;
#line 9628
  if (debug) {
    {
#line 9629
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_conn_rr: receive alignment and offset set...\n");
#line 9630
    fflush(where);
    }
  }
#line 9635
  if (debug) {
    {
#line 9636
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_conn_rr: grabbing a socket...\n");
#line 9637
    fflush(where);
    }
  }
  {
#line 9644
  lss_size_req = tcp_conn_rr_request->send_buf_size;
#line 9645
  lsr_size_req = tcp_conn_rr_request->recv_buf_size;
#line 9646
  loc_nodelay = tcp_conn_rr_request->no_delay;
#line 9647
  loc_rcvavoid = tcp_conn_rr_request->so_rcvavoid;
#line 9648
  loc_sndavoid = tcp_conn_rr_request->so_sndavoid;
#line 9650
  tmp___0 = nf_to_af(tcp_conn_rr_request->ipfamily);
#line 9650
  set_hostname_and_port(local_name, port_buffer, tmp___0, tcp_conn_rr_request->port);
#line 9655
  tmp___1 = nf_to_af(tcp_conn_rr_request->ipfamily);
#line 9655
  local_res = complete_addrinfo(local_name, local_name, port_buffer, tmp___1, 1, 6,
                                0);
#line 9663
  s_listen = create_data_socket(local_res);
  }
#line 9665
  if (s_listen == -1) {
    {
#line 9666
    tmp___2 = __errno_location();
#line 9666
    netperf_response.content.serv_errno = *tmp___2;
#line 9667
    send_response();
    }
#line 9668
    if (debug) {
      {
#line 9669
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"could not create data socket\n");
#line 9670
      fflush(where);
      }
    }
    {
#line 9672
    exit(1);
    }
  }
  {
#line 9684
  tmp___4 = listen(s_listen, 128);
  }
#line 9684
  if (tmp___4 == -1) {
    {
#line 9685
    tmp___3 = __errno_location();
#line 9685
    netperf_response.content.serv_errno = *tmp___3;
#line 9686
    close(s_listen);
#line 9687
    send_response();
    }
#line 9688
    if (debug) {
      {
#line 9689
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"could not listen\n");
#line 9690
      fflush(where);
      }
    }
    {
#line 9692
    exit(1);
    }
  }
  {
#line 9696
  addrlen = (unsigned int )sizeof(myaddr_in);
#line 9697
  tmp___6 = getsockname(s_listen, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& myaddr_in)),
                        (socklen_t */* __restrict  */)(& addrlen));
  }
#line 9697
  if (tmp___6 == -1) {
    {
#line 9700
    tmp___5 = __errno_location();
#line 9700
    netperf_response.content.serv_errno = *tmp___5;
#line 9701
    close(s_listen);
#line 9702
    send_response();
    }
#line 9703
    if (debug) {
      {
#line 9704
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"could not getsockname\n");
#line 9705
      fflush(where);
      }
    }
    {
#line 9707
    exit(1);
    }
  }
  {
#line 9714
  tmp___7 = ntohs(((struct sockaddr_in *)(& myaddr_in))->sin_port);
#line 9714
  tcp_conn_rr_response->data_port_number = (int )tmp___7;
  }
#line 9716
  if (debug) {
    {
#line 9717
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"telling the remote to call me at %d\n",
            tcp_conn_rr_response->data_port_number);
#line 9719
    fflush(where);
    }
  }
#line 9721
  netperf_response.content.serv_errno = 0;
#line 9729
  tcp_conn_rr_response->cpu_rate = (float )0.0;
#line 9730
  if (tcp_conn_rr_request->measure_cpu) {
    {
#line 9731
    tcp_conn_rr_response->measure_cpu = 1;
#line 9732
    tcp_conn_rr_response->cpu_rate = calibrate_local_cpu(tcp_conn_rr_request->cpu_rate);
    }
  }
  {
#line 9740
  tcp_conn_rr_response->send_buf_size = lss_size;
#line 9741
  tcp_conn_rr_response->recv_buf_size = lsr_size;
#line 9742
  tcp_conn_rr_response->no_delay = loc_nodelay;
#line 9743
  tcp_conn_rr_response->so_rcvavoid = loc_rcvavoid;
#line 9744
  tcp_conn_rr_response->so_sndavoid = loc_sndavoid;
#line 9746
  send_response();
#line 9748
  addrlen = (unsigned int )sizeof(peeraddr_in);
#line 9753
  cpu_start(tcp_conn_rr_request->measure_cpu);
  }
#line 9758
  if (tcp_conn_rr_request->test_length > 0) {
    {
#line 9759
    times_up = 0;
#line 9760
    trans_remaining = 0;
#line 9761
    start_timer(tcp_conn_rr_request->test_length + 4);
    }
  } else {
#line 9764
    times_up = 1;
#line 9765
    trans_remaining = tcp_conn_rr_request->test_length * -1;
  }
#line 9768
  trans_received = 0;
  {
#line 9770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9770
    if (! (! times_up)) {
#line 9770
      if (! (trans_remaining > 0)) {
#line 9770
        goto while_break;
      }
    }
    {
#line 9779
    s_data = accept(s_listen, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peeraddr_in)),
                    (socklen_t */* __restrict  */)(& addrlen));
    }
#line 9779
    if (s_data == -1) {
      {
#line 9782
      tmp___8 = __errno_location();
      }
#line 9782
      if (*tmp___8 == 4) {
#line 9784
        timed_out = 1;
#line 9785
        goto while_break;
      }
      {
#line 9787
      tmp___9 = __errno_location();
#line 9787
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_conn_rr: accept: errno = %d\n",
              *tmp___9);
#line 9788
      fflush(where);
#line 9789
      close(s_listen);
#line 9791
      exit(1);
      }
    }
#line 9794
    if (debug) {
      {
#line 9795
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_conn_rr: accepted data connection.\n");
#line 9796
      fflush(where);
      }
    }
#line 9818
    temp_message_ptr = recv_message_ptr;
#line 9819
    request_bytes_remaining = tcp_conn_rr_request->request_size;
    {
#line 9822
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 9822
      if (! times_up) {
#line 9822
        if (! (request_bytes_remaining > 0)) {
#line 9822
          goto while_break___0;
        }
      } else {
#line 9822
        goto while_break___0;
      }
      {
#line 9823
      tmp___12 = recv(s_data, (void *)temp_message_ptr, (size_t )request_bytes_remaining,
                      0);
#line 9823
      request_bytes_recvd = (int )tmp___12;
      }
#line 9823
      if (request_bytes_recvd == -1) {
        {
#line 9827
        tmp___10 = __errno_location();
        }
#line 9827
        if (*tmp___10 == 4) {
#line 9830
          timed_out = 1;
#line 9831
          goto while_break___0;
        }
        {
#line 9833
        tmp___11 = __errno_location();
#line 9833
        netperf_response.content.serv_errno = *tmp___11;
#line 9834
        send_response();
#line 9835
        exit(1);
        }
      } else
#line 9837
      if (request_bytes_recvd > 0) {
#line 9838
        request_bytes_remaining -= request_bytes_recvd;
#line 9839
        temp_message_ptr += request_bytes_recvd;
      } else {
#line 9846
        goto bail;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 9850
    if (timed_out) {
      {
#line 9853
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"yo5\n");
#line 9854
      fflush(where);
      }
#line 9855
      goto while_break;
    }
    {
#line 9859
    tmp___14 = send(s_data, (void const   *)send_message_ptr, (size_t )tcp_conn_rr_request->response_size,
                    0);
#line 9859
    bytes_sent___0 = (int )tmp___14;
    }
#line 9859
    if (bytes_sent___0 == -1) {
      {
#line 9863
      tmp___13 = __errno_location();
      }
#line 9863
      if (*tmp___13 == 4) {
        {
#line 9865
        timed_out = 1;
#line 9866
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"yo6\n");
#line 9867
        fflush(where);
        }
#line 9868
        goto while_break;
      }
      {
#line 9870
      netperf_response.content.serv_errno = 99;
#line 9871
      send_response();
#line 9872
      exit(1);
      }
    }
#line 9875
    trans_received ++;
#line 9876
    if (trans_remaining) {
#line 9877
      trans_remaining --;
    }
#line 9880
    if (debug) {
      {
#line 9881
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_conn_rr: Transaction %d complete\n",
              trans_received);
#line 9884
      fflush(where);
      }
    }
    bail: 
    {
#line 9903
    close(s_data);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 9912
  cpu_stop(tcp_conn_rr_request->measure_cpu, & elapsed_time___0);
  }
#line 9914
  if (timed_out) {
#line 9918
    elapsed_time___0 -= (float )4;
  }
#line 9922
  if (debug) {
    {
#line 9923
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_conn_rr: got %d transactions\n",
            trans_received);
#line 9926
    fflush(where);
    }
  }
#line 9929
  tcp_conn_rr_results->bytes_received = (unsigned int )(trans_received * (tcp_conn_rr_request->request_size + tcp_conn_rr_request->response_size));
#line 9932
  tcp_conn_rr_results->trans_received = (unsigned int )trans_received;
#line 9933
  tcp_conn_rr_results->elapsed_time = elapsed_time___0;
#line 9934
  if (tcp_conn_rr_request->measure_cpu) {
    {
#line 9935
    tcp_conn_rr_results->cpu_util = calc_cpu_util(elapsed_time___0);
    }
  }
#line 9938
  if (debug) {
    {
#line 9939
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_conn_rr: test complete, sending results.\n");
#line 9941
    fflush(where);
    }
  }
  {
#line 9944
  send_response();
  }
#line 9946
  return;
}
}
#line 12077 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void send_tcp_cc(char *remote_host ) 
{ 
  char *tput_title ;
  char *tput_fmt_0 ;
  char *tput_fmt_1_line_1 ;
  char *tput_fmt_1_line_2 ;
  char *cpu_title ;
  char *cpu_fmt_0 ;
  char *cpu_fmt_1_line_1 ;
  char *cpu_fmt_1_line_2 ;
  char *ksink_fmt ;
  int timed_out ;
  float elapsed_time___0 ;
  char temp_message_ptr[1] ;
  int nummessages ;
  int send_socket ;
  int trans_remaining ;
  double bytes_xferd___0 ;
  int rsp_bytes_left ;
  int rsp_bytes_recvd ;
  float local_cpu_utilization___0 ;
  float local_service_demand___0 ;
  float remote_cpu_utilization___0 ;
  float remote_service_demand___0 ;
  double thruput___0 ;
  struct addrinfo *local_res ;
  struct addrinfo *remote_res ;
  int myport___1 ;
  int ret ;
  struct tcp_cc_request_struct *tcp_cc_request ;
  struct tcp_cc_response_struct *tcp_cc_response ;
  struct tcp_cc_results_struct *tcp_cc_result ;
  unsigned short tmp ;
  int *tmp___0 ;
  __pid_t tmp___1 ;
  int tmp___2 ;
  unsigned short tmp___3 ;
  int *tmp___4 ;
  unsigned short tmp___5 ;
  unsigned short tmp___6 ;
  ssize_t tmp___7 ;
  unsigned short tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 12081
  tput_title = (char *)"Local /Remote\nSocket Size   Request  Resp.   Elapsed  Trans.\nSend   Recv   Size     Size    Time     Rate         \nbytes  Bytes  bytes    bytes   secs.    per sec   \n\n";
#line 12087
  tput_fmt_0 = (char *)"%7.2f\n";
#line 12090
  tput_fmt_1_line_1 = (char *)"%-6d %-6d %-6d   %-6d  %-6.2f   %7.2f   \n";
#line 12092
  tput_fmt_1_line_2 = (char *)"%-6d %-6d\n";
#line 12095
  cpu_title = (char *)"Local /Remote\nSocket Size   Request Resp.  Elapsed Trans.   CPU    CPU    S.dem   S.dem\nSend   Recv   Size    Size   Time    Rate     local  remote local   remote\nbytes  bytes  bytes   bytes  secs.   per sec  %%      %%      us/Tr   us/Tr\n\n";
#line 12101
  cpu_fmt_0 = (char *)"%6.3f\n";
#line 12104
  cpu_fmt_1_line_1 = (char *)"%-6d %-6d %-6d  %-6d %-6.2f  %-6.2f   %-6.2f %-6.2f %-6.3f  %-6.3f\n";
#line 12107
  cpu_fmt_1_line_2 = (char *)"%-6d %-6d\n";
#line 12110
  ksink_fmt = (char *)"\nAlignment      Offset\nLocal  Remote  Local  Remote\nSend   Recv    Send   Recv\n%5d  %5d   %5d  %5d\n";
#line 12117
  timed_out = 0;
#line 12125
  rsp_bytes_left = 1;
#line 12144
  tcp_cc_request = (struct tcp_cc_request_struct *)(netperf_request.content.test_specific_data);
#line 12146
  tcp_cc_response = (struct tcp_cc_response_struct *)(netperf_response.content.test_specific_data);
#line 12148
  tcp_cc_result = (struct tcp_cc_results_struct *)(netperf_response.content.test_specific_data);
#line 12163
  complete_addrinfos(& remote_res, & local_res, remote_host, 1, 6, 0);
  }
#line 12170
  if (print_headers) {
    {
#line 12171
    print_top_test_header((char *)"TCP Connect/Close TEST", local_res, remote_res);
    }
  }
#line 12176
  nummessages = 0;
#line 12177
  bytes_xferd___0 = 0.0;
#line 12178
  times_up = 0;
#line 12183
  if (debug) {
    {
#line 12184
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"send_tcp_cc: send_socket obtained...\n");
    }
  }
#line 12194
  if (local_cpu_usage) {
    {
#line 12195
    local_cpu_rate = calibrate_local_cpu(local_cpu_rate);
    }
  }
#line 12206
  netperf_request.content.request_type = 300;
#line 12207
  tcp_cc_request->recv_buf_size = rsr_size_req;
#line 12208
  tcp_cc_request->send_buf_size = rss_size_req;
#line 12209
  tcp_cc_request->recv_alignment = remote_recv_align;
#line 12210
  tcp_cc_request->recv_offset = remote_recv_offset;
#line 12211
  tcp_cc_request->send_alignment = remote_send_align;
#line 12212
  tcp_cc_request->send_offset = remote_send_offset;
#line 12213
  tcp_cc_request->request_size = req_size;
#line 12214
  tcp_cc_request->response_size = rsp_size;
#line 12215
  tcp_cc_request->no_delay = rem_nodelay;
#line 12216
  tcp_cc_request->measure_cpu = remote_cpu_usage;
#line 12217
  tcp_cc_request->cpu_rate = remote_cpu_rate;
#line 12218
  tcp_cc_request->so_rcvavoid = rem_rcvavoid;
#line 12219
  tcp_cc_request->so_sndavoid = rem_sndavoid;
#line 12220
  if (test_time) {
#line 12221
    tcp_cc_request->test_length = test_time;
  } else {
#line 12224
    tcp_cc_request->test_length = test_trans * -1;
  }
  {
#line 12226
  tcp_cc_request->port = atoi((char const   *)(remote_data_port));
#line 12227
  tcp_cc_request->ipfamily = af_to_nf(remote_res->ai_family);
  }
#line 12229
  if (debug > 1) {
    {
#line 12230
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: send_tcp_cc: requesting TCP crr test\n");
    }
  }
  {
#line 12233
  send_request();
#line 12245
  recv_response();
  }
#line 12247
  if (! netperf_response.content.serv_errno) {
    {
#line 12248
    rsr_size = tcp_cc_response->recv_buf_size;
#line 12249
    rss_size = tcp_cc_response->send_buf_size;
#line 12250
    rem_nodelay = tcp_cc_response->no_delay;
#line 12251
    remote_cpu_usage = tcp_cc_response->measure_cpu;
#line 12252
    remote_cpu_rate = tcp_cc_response->cpu_rate;
#line 12254
    set_port_number(remote_res, (unsigned short )tcp_cc_response->data_port_number);
    }
#line 12256
    if (debug) {
      {
#line 12257
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"remote listen done.\n");
#line 12258
      tmp = get_port_number___0(remote_res);
#line 12258
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"remote port is %d\n",
              (int )tmp);
#line 12259
      fflush(where);
      }
    }
  } else {
    {
#line 12263
    tmp___0 = __errno_location();
#line 12263
    *tmp___0 = netperf_response.content.serv_errno;
#line 12264
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: remote error %d",
            netperf_response.content.serv_errno);
#line 12267
    perror("");
#line 12268
    fflush(where);
#line 12269
    exit(1);
    }
  }
  {
#line 12278
  tmp___1 = getpid();
#line 12278
  srand((unsigned int )tmp___1);
  }
#line 12279
  if (client_port_max___0 - client_port_min___0) {
    {
#line 12280
    tmp___2 = rand();
#line 12280
    myport___1 = client_port_min___0 + tmp___2 % (client_port_max___0 - client_port_min___0);
    }
  } else {
#line 12284
    myport___1 = client_port_min___0;
  }
#line 12287
  myport___1 --;
#line 12292
  if (test_time) {
    {
#line 12294
    times_up = 0;
#line 12295
    trans_remaining = 0;
#line 12296
    start_timer(test_time);
    }
  } else {
#line 12300
    trans_remaining = test_bytes;
#line 12301
    times_up = 1;
  }
  {
#line 12308
  cpu_start(local_cpu_usage);
  }
  {
#line 12325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12325
    if (! (! times_up)) {
#line 12325
      if (! (trans_remaining > 0)) {
#line 12325
        goto while_break;
      }
    }
#line 12338
    myport___1 ++;
#line 12345
    if (myport___1 >= client_port_max___0) {
#line 12346
      myport___1 = client_port_min___0;
    }
    {
#line 12356
    tmp___3 = get_port_number___0(remote_res);
    }
#line 12356
    if (myport___1 == (int )tmp___3) {
#line 12356
      myport___1 ++;
    }
#line 12358
    if (debug) {
#line 12359
      if (nummessages % 100 == 0) {
        {
#line 12360
        printf((char const   */* __restrict  */)"port %d\n", myport___1);
        }
      }
    }
    {
#line 12363
    set_port_number(local_res, (unsigned short )myport___1);
#line 12364
    send_socket = create_data_socket(local_res);
    }
#line 12366
    if (send_socket == -1) {
      {
#line 12367
      perror("netperf: send_tcp_cc: tcp stream data socket");
#line 12368
      exit(1);
      }
    }
    {
#line 12385
    ret = connect(send_socket, (struct sockaddr  const  *)remote_res->ai_addr, remote_res->ai_addrlen);
    }
#line 12385
    if (ret == -1) {
      {
#line 12388
      tmp___4 = __errno_location();
      }
#line 12388
      if (*tmp___4 == 4) {
#line 12392
        timed_out = 1;
#line 12393
        goto while_break;
      }
      {
#line 12395
      perror("netperf: data socket connect failed");
#line 12396
      tmp___5 = get_port_number___0(remote_res);
#line 12396
      printf((char const   */* __restrict  */)"\tattempted to connect on socket %d to port %d",
             send_socket, (int )tmp___5);
#line 12399
      tmp___6 = get_port_number___0(local_res);
#line 12399
      printf((char const   */* __restrict  */)" from port %u \n", (int )tmp___6);
#line 12400
      exit(1);
      }
    }
    {
#line 12405
    tmp___7 = recv(send_socket, (void *)(temp_message_ptr), (size_t )rsp_bytes_left,
                   0);
#line 12405
    rsp_bytes_recvd = (int )tmp___7;
    }
#line 12411
    if (rsp_bytes_recvd == 0) {
#line 12426
      nummessages ++;
#line 12427
      if (trans_remaining) {
#line 12428
        trans_remaining --;
      }
#line 12431
      if (debug > 3) {
        {
#line 12432
        tmp___8 = get_port_number___0(local_res);
#line 12432
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Transaction %d completed on local port %u\n",
                nummessages, (int )tmp___8);
#line 12436
        fflush(where);
        }
      }
      {
#line 12439
      close(send_socket);
      }
    } else {
      {
#line 12444
      tmp___9 = __errno_location();
      }
#line 12444
      if (*tmp___9 == 4) {
#line 12447
        timed_out = 1;
#line 12448
        goto while_break;
      }
      {
#line 12450
      perror("send_tcp_cc: data recv error");
#line 12451
      exit(1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 12460
  cpu_stop(local_cpu_usage, & elapsed_time___0);
#line 12467
  recv_response();
  }
#line 12468
  if (! netperf_response.content.serv_errno) {
#line 12469
    if (debug) {
      {
#line 12470
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"remote results obtained\n");
      }
    }
  } else {
    {
#line 12473
    tmp___10 = __errno_location();
#line 12473
    *tmp___10 = netperf_response.content.serv_errno;
#line 12474
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: remote error %d",
            netperf_response.content.serv_errno);
#line 12477
    perror("");
#line 12478
    fflush(where);
#line 12480
    exit(1);
    }
  }
  {
#line 12495
  bytes_xferd___0 = (double )(req_size * nummessages + rsp_size * nummessages);
#line 12496
  thruput___0 = calc_thruput(bytes_xferd___0);
  }
#line 12498
  if (local_cpu_usage) {
#line 12498
    goto _L;
  } else
#line 12498
  if (remote_cpu_usage) {
    _L: /* CIL Label */ 
#line 12504
    if (local_cpu_usage) {
#line 12505
      if ((double )local_cpu_rate == 0.0) {
        {
#line 12506
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"WARNING WARNING WARNING  WARNING WARNING WARNING  WARNING!\n");
#line 12507
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Local CPU usage numbers based on process information only!\n");
#line 12508
        fflush(where);
        }
      }
      {
#line 12510
      local_cpu_utilization___0 = calc_cpu_util((float )0.0);
#line 12514
      local_service_demand___0 = calc_service_demand((double )nummessages * (double )1024,
                                                     (float )0.0, (float )0.0, 0);
      }
    } else {
#line 12520
      local_cpu_utilization___0 = (float )(- 1.0);
#line 12521
      local_service_demand___0 = (float )(- 1.0);
    }
#line 12524
    if (remote_cpu_usage) {
#line 12525
      if ((double )remote_cpu_rate == 0.0) {
        {
#line 12526
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"DANGER  DANGER  DANGER    DANGER  DANGER  DANGER    DANGER!\n");
#line 12527
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Remote CPU usage numbers based on process information only!\n");
#line 12528
        fflush(where);
        }
      }
      {
#line 12530
      remote_cpu_utilization___0 = tcp_cc_result->cpu_util;
#line 12534
      remote_service_demand___0 = calc_service_demand((double )nummessages * (double )1024,
                                                      (float )0.0, remote_cpu_utilization___0,
                                                      tcp_cc_result->num_cpus);
      }
    } else {
#line 12540
      remote_cpu_utilization___0 = (float )(- 1.0);
#line 12541
      remote_service_demand___0 = (float )(- 1.0);
    }
    {
#line 12554
    if (verbosity == 0) {
#line 12554
      goto case_0;
    }
#line 12567
    if (verbosity == 2) {
#line 12567
      goto case_2;
    }
#line 12567
    if (verbosity == 1) {
#line 12567
      goto case_2;
    }
#line 12553
    goto switch_break;
    case_0: /* CIL Label */ 
#line 12555
    if (local_cpu_usage) {
      {
#line 12556
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
              (double )local_service_demand___0);
      }
    } else {
      {
#line 12561
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_0,
              (double )remote_service_demand___0);
      }
    }
#line 12565
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 12569
    if (print_headers) {
      {
#line 12570
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_title,
              (int )local_cpu_method___0, (int )remote_cpu_method___0);
      }
    }
    {
#line 12576
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_1_line_1,
            lss_size, lsr_size, req_size, rsp_size, (double )elapsed_time___0, (double )((float )nummessages / elapsed_time___0),
            (double )local_cpu_utilization___0, (double )remote_cpu_utilization___0,
            (double )local_service_demand___0, (double )remote_service_demand___0);
#line 12588
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)cpu_fmt_1_line_2,
            rss_size, rsr_size);
    }
#line 12592
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 12598
    if (verbosity == 0) {
#line 12598
      goto case_0___0;
    }
#line 12604
    if (verbosity == 2) {
#line 12604
      goto case_2___0;
    }
#line 12604
    if (verbosity == 1) {
#line 12604
      goto case_2___0;
    }
#line 12597
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 12599
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_0,
            (double )((float )nummessages / elapsed_time___0));
    }
#line 12602
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
#line 12605
    if (print_headers) {
      {
#line 12606
      tmp___11 = format_units();
#line 12606
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_title,
              tmp___11);
      }
    }
    {
#line 12609
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_1_line_1,
            lss_size, lsr_size, req_size, rsp_size, (double )elapsed_time___0, (double )((float )nummessages / elapsed_time___0));
#line 12617
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tput_fmt_1_line_2,
            rss_size, rsr_size);
    }
#line 12622
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 12632
  if (verbosity > 1) {
    {
#line 12638
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)ksink_fmt,
            local_send_align, remote_recv_offset, local_send_offset, remote_recv_offset);
    }
  }
#line 12653
  return;
}
}
#line 12656 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void recv_tcp_cc(void) 
{ 
  char *message ;
  struct addrinfo *local_res ;
  char local_name[8192] ;
  char port_buffer[10] ;
  struct sockaddr_storage myaddr_in ;
  struct sockaddr_storage peeraddr_in ;
  int s_listen ;
  int s_data ;
  unsigned int addrlen ;
  char *recv_message_ptr ;
  char *send_message_ptr ;
  int trans_received ;
  int trans_remaining ;
  int timed_out ;
  float elapsed_time___0 ;
  struct tcp_cc_request_struct *tcp_cc_request ;
  struct tcp_cc_response_struct *tcp_cc_response ;
  struct tcp_cc_results_struct *tcp_cc_results ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  uint16_t tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 12673
  timed_out = 0;
#line 12680
  tcp_cc_request = (struct tcp_cc_request_struct *)(netperf_request.content.test_specific_data);
#line 12682
  tcp_cc_response = (struct tcp_cc_response_struct *)(netperf_response.content.test_specific_data);
#line 12684
  tcp_cc_results = (struct tcp_cc_results_struct *)(netperf_response.content.test_specific_data);
#line 12687
  if (debug) {
    {
#line 12688
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netserver: recv_tcp_cc: entered...\n");
#line 12689
    fflush(where);
    }
  }
#line 12705
  if (debug) {
    {
#line 12706
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_cc: setting the response type...\n");
#line 12707
    fflush(where);
    }
  }
#line 12710
  netperf_response.content.response_type = 301;
#line 12712
  if (debug) {
    {
#line 12713
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_cc: the response type is set...\n");
#line 12714
    fflush(where);
    }
  }
  {
#line 12718
  tmp = malloc((size_t )86016);
#line 12718
  message = (char *)tmp;
  }
#line 12719
  if ((unsigned long )message == (unsigned long )((void *)0)) {
    {
#line 12720
    printf((char const   */* __restrict  */)"malloc(%d) failed!\n", 86016);
#line 12721
    exit(1);
    }
  }
#line 12727
  if (debug) {
    {
#line 12728
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_cc: requested recv alignment of %d offset %d\n",
            tcp_cc_request->recv_alignment, tcp_cc_request->recv_offset);
#line 12732
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_cc: requested send alignment of %d offset %d\n",
            tcp_cc_request->send_alignment, tcp_cc_request->send_offset);
#line 12736
    fflush(where);
    }
  }
#line 12739
  recv_message_ptr = (char *)((((unsigned long )message + (unsigned long )tcp_cc_request->recv_alignment) - 1UL) & ~ ((unsigned long )tcp_cc_request->recv_alignment - 1UL)) + (unsigned long )tcp_cc_request->recv_offset;
#line 12741
  send_message_ptr = (char *)((((unsigned long )message + (unsigned long )tcp_cc_request->send_alignment) - 1UL) & ~ ((unsigned long )tcp_cc_request->send_alignment - 1UL)) + (unsigned long )tcp_cc_request->send_offset;
#line 12743
  if (debug) {
    {
#line 12744
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_cc: receive alignment and offset set...\n");
#line 12745
    fflush(where);
    }
  }
#line 12750
  if (debug) {
    {
#line 12751
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_cc: grabbing a socket...\n");
#line 12752
    fflush(where);
    }
  }
  {
#line 12759
  lss_size_req = tcp_cc_request->send_buf_size;
#line 12760
  lsr_size_req = tcp_cc_request->recv_buf_size;
#line 12761
  loc_nodelay = tcp_cc_request->no_delay;
#line 12762
  loc_rcvavoid = tcp_cc_request->so_rcvavoid;
#line 12763
  loc_sndavoid = tcp_cc_request->so_sndavoid;
#line 12765
  tmp___0 = nf_to_af(tcp_cc_request->ipfamily);
#line 12765
  set_hostname_and_port(local_name, port_buffer, tmp___0, tcp_cc_request->port);
#line 12770
  tmp___1 = nf_to_af(tcp_cc_request->ipfamily);
#line 12770
  local_res = complete_addrinfo(local_name, local_name, port_buffer, tmp___1, 1, 6,
                                0);
#line 12778
  s_listen = create_data_socket(local_res);
  }
#line 12780
  if (s_listen == -1) {
    {
#line 12781
    tmp___2 = __errno_location();
#line 12781
    netperf_response.content.serv_errno = *tmp___2;
#line 12782
    send_response();
    }
#line 12783
    if (debug) {
      {
#line 12784
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"could not create data socket\n");
#line 12785
      fflush(where);
      }
    }
    {
#line 12787
    exit(1);
    }
  }
  {
#line 12799
  tmp___4 = listen(s_listen, 5);
  }
#line 12799
  if (tmp___4 == -1) {
    {
#line 12800
    tmp___3 = __errno_location();
#line 12800
    netperf_response.content.serv_errno = *tmp___3;
#line 12801
    close(s_listen);
#line 12802
    send_response();
    }
#line 12803
    if (debug) {
      {
#line 12804
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"could not listen\n");
#line 12805
      fflush(where);
      }
    }
    {
#line 12807
    exit(1);
    }
  }
  {
#line 12811
  addrlen = (unsigned int )sizeof(myaddr_in);
#line 12812
  tmp___6 = getsockname(s_listen, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& myaddr_in)),
                        (socklen_t */* __restrict  */)(& addrlen));
  }
#line 12812
  if (tmp___6 == -1) {
    {
#line 12815
    tmp___5 = __errno_location();
#line 12815
    netperf_response.content.serv_errno = *tmp___5;
#line 12816
    close(s_listen);
#line 12817
    send_response();
    }
#line 12818
    if (debug) {
      {
#line 12819
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"could not geetsockname\n");
#line 12820
      fflush(where);
      }
    }
    {
#line 12822
    exit(1);
    }
  }
  {
#line 12829
  tmp___7 = ntohs(((struct sockaddr_in *)(& myaddr_in))->sin_port);
#line 12829
  tcp_cc_response->data_port_number = (int )tmp___7;
  }
#line 12831
  if (debug) {
    {
#line 12832
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"telling the remote to call me at %d\n",
            tcp_cc_response->data_port_number);
#line 12834
    fflush(where);
    }
  }
#line 12836
  netperf_response.content.serv_errno = 0;
#line 12844
  tcp_cc_response->cpu_rate = (float )0.0;
#line 12845
  if (tcp_cc_request->measure_cpu) {
    {
#line 12846
    tcp_cc_response->measure_cpu = 1;
#line 12847
    tcp_cc_response->cpu_rate = calibrate_local_cpu(tcp_cc_request->cpu_rate);
    }
  }
  {
#line 12855
  tcp_cc_response->send_buf_size = lss_size;
#line 12856
  tcp_cc_response->recv_buf_size = lsr_size;
#line 12857
  tcp_cc_response->no_delay = loc_nodelay;
#line 12858
  tcp_cc_response->so_rcvavoid = loc_rcvavoid;
#line 12859
  tcp_cc_response->so_sndavoid = loc_sndavoid;
#line 12861
  send_response();
#line 12863
  addrlen = (unsigned int )sizeof(peeraddr_in);
#line 12868
  cpu_start(tcp_cc_request->measure_cpu);
  }
#line 12873
  if (tcp_cc_request->test_length > 0) {
    {
#line 12874
    times_up = 0;
#line 12875
    trans_remaining = 0;
#line 12876
    start_timer(tcp_cc_request->test_length + 4);
    }
  } else {
#line 12879
    times_up = 1;
#line 12880
    trans_remaining = tcp_cc_request->test_length * -1;
  }
#line 12883
  trans_received = 0;
  {
#line 12885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12885
    if (! (! times_up)) {
#line 12885
      if (! (trans_remaining > 0)) {
#line 12885
        goto while_break;
      }
    }
    {
#line 12893
    s_data = accept(s_listen, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peeraddr_in)),
                    (socklen_t */* __restrict  */)(& addrlen));
    }
#line 12893
    if (s_data == -1) {
      {
#line 12896
      tmp___8 = __errno_location();
      }
#line 12896
      if (*tmp___8 == 4) {
#line 12898
        timed_out = 1;
#line 12899
        goto while_break;
      }
      {
#line 12901
      tmp___9 = __errno_location();
#line 12901
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_cc: accept: errno = %d\n",
              *tmp___9);
#line 12902
      fflush(where);
#line 12903
      close(s_listen);
#line 12905
      exit(1);
      }
    }
#line 12927
    if (debug) {
      {
#line 12928
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_cc: accepted data connection.\n");
#line 12929
      fflush(where);
      }
    }
    {
#line 12939
    close(s_data);
#line 12941
    trans_received ++;
    }
#line 12942
    if (trans_remaining) {
#line 12943
      trans_remaining --;
    }
#line 12946
    if (debug) {
      {
#line 12947
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_cc: Transaction %d complete\n",
              trans_received);
#line 12950
      fflush(where);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 12959
  cpu_stop(tcp_cc_request->measure_cpu, & elapsed_time___0);
  }
#line 12961
  if (timed_out) {
#line 12965
    elapsed_time___0 -= (float )4;
  }
#line 12969
  if (debug) {
    {
#line 12970
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_cc: got %d transactions\n",
            trans_received);
#line 12973
    fflush(where);
    }
  }
#line 12976
  tcp_cc_results->bytes_received = (unsigned int )(trans_received * (tcp_cc_request->request_size + tcp_cc_request->response_size));
#line 12979
  tcp_cc_results->trans_received = (unsigned int )trans_received;
#line 12980
  tcp_cc_results->elapsed_time = elapsed_time___0;
#line 12981
  tcp_cc_results->num_cpus = lib_num_loc_cpus;
#line 12982
  if (tcp_cc_request->measure_cpu) {
    {
#line 12983
    tcp_cc_results->cpu_util = calc_cpu_util(elapsed_time___0);
    }
  }
#line 12986
  if (debug) {
    {
#line 12987
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_tcp_cc: test complete, sending results.\n");
#line 12989
    fflush(where);
    }
  }
  {
#line 12992
  send_response();
  }
#line 12994
  return;
}
}
#line 12996 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void print_sockets_usage(void) 
{ 
  size_t tmp ;

  {
  {
#line 13000
  tmp = strlen((char const   *)(sockets_usage));
#line 13000
  fwrite((void const   */* __restrict  */)(sockets_usage), sizeof(char ), tmp, (FILE */* __restrict  */)stdout);
#line 13001
  exit(1);
  }
}
}
#line 13005 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
void scan_sockets_args(int argc , char **argv ) 
{ 
  int c ;
  char arg1[8192] ;
  char arg2[8192] ;
  int i ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;

  {
#line 13020
  if (debug) {
    {
#line 13022
    printf((char const   */* __restrict  */)"%s called with the following argument vector\n",
           "scan_sockets_args");
#line 13028
    i = 0;
    }
    {
#line 13028
    while (1) {
      while_continue: /* CIL Label */ ;
#line 13028
      if (! (i < argc)) {
#line 13028
        goto while_break;
      }
      {
#line 13029
      printf((char const   */* __restrict  */)"%s ", *(argv + i));
#line 13028
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 13031
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 13034
  strncpy((char */* __restrict  */)(local_data_port), (char const   */* __restrict  */)"0",
          sizeof(local_data_port));
#line 13035
  strncpy((char */* __restrict  */)(remote_data_port), (char const   */* __restrict  */)"0",
          sizeof(remote_data_port));
#line 13039
  tmp = strcasecmp((char const   *)(test_name), "UDP_STREAM");
  }
#line 13039
  if (tmp == 0) {
#line 13040
    routing_allowed = 0;
  }
  {
#line 13049
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 13049
    c = getopt(argc, (char * const  *)argv, "b:CDnNhH:L:m:M:p:P:r:R:s:S:T:Vw:W:z46");
    }
#line 13049
    if (! (c != -1)) {
#line 13049
      goto while_break___0;
    }
    {
#line 13052
    if (c == 52) {
#line 13052
      goto case_52;
    }
#line 13052
    if (c == 63) {
#line 13052
      goto case_52;
    }
#line 13056
    if (c == 54) {
#line 13056
      goto case_54;
    }
#line 13067
    if (c == 104) {
#line 13067
      goto case_104;
    }
#line 13070
    if (c == 98) {
#line 13070
      goto case_98;
    }
#line 13077
    if (c == 67) {
#line 13077
      goto case_67;
    }
#line 13086
    if (c == 68) {
#line 13086
      goto case_68;
    }
#line 13091
    if (c == 72) {
#line 13091
      goto case_72;
    }
#line 13102
    if (c == 76) {
#line 13102
      goto case_76;
    }
#line 13113
    if (c == 115) {
#line 13113
      goto case_115;
    }
#line 13121
    if (c == 83) {
#line 13121
      goto case_83;
    }
#line 13129
    if (c == 114) {
#line 13129
      goto case_114;
    }
#line 13137
    if (c == 82) {
#line 13137
      goto case_82;
    }
#line 13141
    if (c == 109) {
#line 13141
      goto case_109;
    }
#line 13145
    if (c == 77) {
#line 13145
      goto case_77;
    }
#line 13149
    if (c == 110) {
#line 13149
      goto case_110;
    }
#line 13153
    if (c == 78) {
#line 13153
      goto case_78;
    }
#line 13157
    if (c == 112) {
#line 13157
      goto case_112;
    }
#line 13166
    if (c == 80) {
#line 13166
      goto case_80;
    }
#line 13176
    if (c == 116) {
#line 13176
      goto case_116;
    }
#line 13180
    if (c == 87) {
#line 13180
      goto case_87;
    }
#line 13189
    if (c == 86) {
#line 13189
      goto case_86;
    }
#line 13050
    goto switch_break;
    case_52: /* CIL Label */ 
    case_63: /* CIL Label */ 
#line 13053
    remote_data_family = 2;
#line 13054
    local_data_family = 2;
#line 13055
    goto switch_break;
    case_54: /* CIL Label */ 
#line 13058
    remote_data_family = 10;
#line 13059
    local_data_family = 10;
#line 13066
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 13068
    print_sockets_usage();
#line 13069
    exit(1);
    }
    case_98: /* CIL Label */ 
    {
#line 13072
    first_burst_size = atoi((char const   *)optarg);
    }
#line 13076
    goto switch_break;
    case_67: /* CIL Label */ 
#line 13080
    loc_tcpcork = 1;
#line 13081
    rem_tcpcork = 1;
#line 13085
    goto switch_break;
    case_68: /* CIL Label */ 
#line 13088
    loc_nodelay = 1;
#line 13089
    rem_nodelay = 1;
#line 13090
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 13092
    break_args_explicit(optarg, arg1, arg2);
    }
#line 13093
    if (arg1[0]) {
      {
#line 13096
      tmp___0 = strlen((char const   *)(arg1));
#line 13096
      tmp___1 = malloc(tmp___0 + 1UL);
#line 13096
      remote_data_address = (char *)tmp___1;
#line 13097
      tmp___2 = strlen((char const   *)(arg1));
#line 13097
      strncpy((char */* __restrict  */)remote_data_address, (char const   */* __restrict  */)(arg1),
              tmp___2);
      }
    }
#line 13099
    if (arg2[0]) {
      {
#line 13100
      remote_data_family = parse_address_family(arg2);
      }
    }
#line 13101
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 13103
    break_args_explicit(optarg, arg1, arg2);
    }
#line 13104
    if (arg1[0]) {
      {
#line 13107
      tmp___3 = strlen((char const   *)(arg1));
#line 13107
      tmp___4 = malloc(tmp___3 + 1UL);
#line 13107
      local_data_address = (char *)tmp___4;
#line 13108
      tmp___5 = strlen((char const   *)(arg1));
#line 13108
      strncpy((char */* __restrict  */)local_data_address, (char const   */* __restrict  */)(arg1),
              tmp___5);
      }
    }
#line 13110
    if (arg2[0]) {
      {
#line 13111
      local_data_family = parse_address_family(arg2);
      }
    }
#line 13112
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 13115
    break_args(optarg, arg1, arg2);
    }
#line 13116
    if (arg1[0]) {
      {
#line 13117
      tmp___6 = convert(arg1);
#line 13117
      lss_size_req = (int )tmp___6;
      }
    }
#line 13118
    if (arg2[0]) {
      {
#line 13119
      tmp___7 = convert(arg2);
#line 13119
      lsr_size_req = (int )tmp___7;
      }
    }
#line 13120
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 13123
    break_args(optarg, arg1, arg2);
    }
#line 13124
    if (arg1[0]) {
      {
#line 13125
      tmp___8 = convert(arg1);
#line 13125
      rss_size_req = (int )tmp___8;
      }
    }
#line 13126
    if (arg2[0]) {
      {
#line 13127
      tmp___9 = convert(arg2);
#line 13127
      rsr_size_req = (int )tmp___9;
      }
    }
#line 13128
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 13131
    break_args(optarg, arg1, arg2);
    }
#line 13132
    if (arg1[0]) {
      {
#line 13133
      tmp___10 = convert(arg1);
#line 13133
      req_size = (int )tmp___10;
      }
    }
#line 13134
    if (arg2[0]) {
      {
#line 13135
      tmp___11 = convert(arg2);
#line 13135
      rsp_size = (int )tmp___11;
      }
    }
#line 13136
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 13139
    routing_allowed = atoi((char const   *)optarg);
    }
#line 13140
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 13143
    tmp___12 = convert(optarg);
#line 13143
    send_size = (int )tmp___12;
    }
#line 13144
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 13147
    tmp___13 = convert(optarg);
#line 13147
    recv_size = (int )tmp___13;
    }
#line 13148
    goto switch_break;
    case_110: /* CIL Label */ 
#line 13151
    local_connected = 1;
#line 13152
    goto switch_break;
    case_78: /* CIL Label */ 
#line 13155
    remote_connected = 1;
#line 13156
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 13160
    break_args(optarg, arg1, arg2);
    }
#line 13161
    if (arg1[0]) {
      {
#line 13162
      client_port_min___0 = atoi((char const   *)(arg1));
      }
    }
#line 13163
    if (arg2[0]) {
      {
#line 13164
      client_port_max___0 = atoi((char const   *)(arg2));
      }
    }
#line 13165
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 13170
    break_args(optarg, arg1, arg2);
    }
#line 13171
    if (arg1[0]) {
      {
#line 13172
      strncpy((char */* __restrict  */)(local_data_port), (char const   */* __restrict  */)(arg1),
              sizeof(local_data_port));
      }
    }
#line 13173
    if (arg2[0]) {
      {
#line 13174
      strncpy((char */* __restrict  */)(remote_data_port), (char const   */* __restrict  */)(arg2),
              sizeof(remote_data_port));
      }
    }
#line 13175
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 13178
    strcpy((char */* __restrict  */)(test_name), (char const   */* __restrict  */)optarg);
    }
#line 13179
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 13187
    tmp___14 = convert(optarg);
#line 13187
    send_width = (int )tmp___14;
    }
#line 13188
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 13197
    loc_sndavoid = 0;
#line 13198
    printf((char const   */* __restrict  */)"Local send copy avoidance not available.\n");
#line 13203
    loc_rcvavoid = 0;
#line 13204
    printf((char const   */* __restrict  */)"Local recv copy avoidance not available.\n");
#line 13206
    rem_sndavoid = 1;
#line 13207
    rem_rcvavoid = 1;
    }
#line 13208
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 13234
  if (no_control) {
    {
#line 13236
    tmp___19 = strcmp((char const   *)(remote_data_port), "0");
    }
#line 13236
    if (tmp___19 == 0) {
      {
#line 13239
      tmp___17 = strstr((char const   *)(test_name), "STREAM");
      }
#line 13239
      if (tmp___17) {
        {
#line 13241
        strncpy((char */* __restrict  */)(remote_data_port), (char const   */* __restrict  */)"discard",
                sizeof(remote_data_port));
        }
      } else {
        {
#line 13239
        tmp___18 = strstr((char const   *)(test_name), "SENDFILE");
        }
#line 13239
        if (tmp___18) {
          {
#line 13241
          strncpy((char */* __restrict  */)(remote_data_port), (char const   */* __restrict  */)"discard",
                  sizeof(remote_data_port));
          }
        } else {
          {
#line 13243
          tmp___16 = strstr((char const   *)(test_name), "RR");
          }
#line 13243
          if (tmp___16) {
            {
#line 13244
            strncpy((char */* __restrict  */)(remote_data_port), (char const   */* __restrict  */)"echo",
                    sizeof(remote_data_port));
            }
          } else {
            {
#line 13246
            tmp___15 = strstr((char const   *)(test_name), "MAERTS");
            }
#line 13246
            if (tmp___15) {
              {
#line 13247
              strncpy((char */* __restrict  */)(remote_data_port), (char const   */* __restrict  */)"chargen",
                      sizeof(remote_data_port));
              }
            } else {
              {
#line 13250
              printf((char const   */* __restrict  */)"No default port known for the %s test, please set one yourself\n",
                     test_name);
#line 13251
              exit(-1);
              }
            }
          }
        }
      }
    }
    {
#line 13254
    remote_data_port[sizeof(remote_data_port) - 1UL] = (char )'\000';
#line 13260
    rem_rcvavoid = -1;
#line 13261
    rem_sndavoid = -1;
#line 13262
    rss_size_req = -1;
#line 13263
    rsr_size_req = -1;
#line 13264
    rem_nodelay = -1;
#line 13266
    tmp___21 = strstr((char const   *)(test_name), "STREAM");
    }
#line 13266
    if (tmp___21) {
#line 13268
      recv_size = -1;
    } else {
      {
#line 13266
      tmp___22 = strstr((char const   *)(test_name), "SENDFILE");
      }
#line 13266
      if (tmp___22) {
#line 13268
        recv_size = -1;
      } else {
        {
#line 13270
        tmp___20 = strstr((char const   *)(test_name), "MAERTS");
        }
#line 13270
        if (tmp___20) {
#line 13271
          send_size = -1;
        }
      }
    }
  }
#line 13274
  return;
}
}
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 91 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static uint16_t true_random(void) ;
#line 131 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static void get_system_time(uuid_time_t *uuid_time ) 
{ 
  struct timeval tp ;

  {
  {
#line 135
  gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((struct timezone *)0));
#line 140
  *uuid_time = (uuid_time_t )((long long )((uint64_t )tp.tv_sec * 10000000UL + (uint64_t )tp.tv_usec * 10UL) + 122192928000000000LL);
  }
#line 143
  return;
}
}
#line 146 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static void get_random_info(char *seed ) 
{ 
  FILE *fp ;
  uint16_t myrand ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 154
  fp = fopen((char const   */* __restrict  */)"/dev/urandom", (char const   */* __restrict  */)"rb");
  }
#line 156
  if ((unsigned long )((void *)0) != (unsigned long )fp) {
    {
#line 157
    fread((void */* __restrict  */)seed, sizeof(char ), (size_t )16, (FILE */* __restrict  */)fp);
#line 158
    fclose(fp);
    }
#line 159
    return;
  }
#line 164
  i = 0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 166
    myrand = true_random();
#line 167
    tmp = i;
#line 167
    i ++;
#line 167
    *(seed + tmp) = (char )((int )myrand & 255);
#line 168
    tmp___0 = i;
#line 168
    i ++;
#line 168
    *(seed + tmp___0) = (char )((int )myrand >> 8);
    }
#line 165
    if (! (i < 14)) {
#line 165
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  fclose(fp);
  }
#line 172
  return;
}
}
#line 181 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static int inited  =    0;
#line 179 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static uint16_t true_random(void) 
{ 
  uuid_time_t time_now ;
  int tmp ;

  {
#line 184
  if (! inited) {
    {
#line 185
    get_system_time(& time_now);
#line 186
    time_now /= 1024UL;
#line 187
    srand((unsigned int )(((time_now >> 32) ^ time_now) & 4294967295UL));
#line 189
    inited = 1;
    }
  }
  {
#line 192
  tmp = rand();
  }
#line 192
  return ((uint16_t )tmp);
}
}
#line 196 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
void puid(uuid_t u ) 
{ 
  int i ;

  {
  {
#line 200
  printf((char const   */* __restrict  */)"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-", u.time_low,
         (int )u.time_mid, (int )u.time_hi_and_version, (int )u.clock_seq_hi_and_reserved,
         (int )u.clock_seq_low);
#line 203
  i = 0;
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (i < 6)) {
#line 203
      goto while_break;
    }
    {
#line 204
    printf((char const   */* __restrict  */)"%2.2x", (int )u.node[i]);
#line 203
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 205
  printf((char const   */* __restrict  */)"\n");
  }
#line 206
  return;
}
}
#line 209 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
void snpuid(char *str , size_t size , uuid_t u ) 
{ 
  int i ;
  char *tmp ;

  {
#line 211
  tmp = str;
#line 213
  if (size < 38UL) {
    {
#line 214
    snprintf((char */* __restrict  */)tmp, size, (char const   */* __restrict  */)"%s",
             "uuid string too small");
    }
#line 215
    return;
  }
  {
#line 219
  sprintf((char */* __restrict  */)tmp, (char const   */* __restrict  */)"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-",
          u.time_low, (int )u.time_mid, (int )u.time_hi_and_version, (int )u.clock_seq_hi_and_reserved,
          (int )u.clock_seq_low);
#line 226
  tmp += 24;
#line 227
  i = 0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (i < 6)) {
#line 227
      goto while_break;
    }
    {
#line 228
    sprintf((char */* __restrict  */)tmp, (char const   */* __restrict  */)"%2.2x",
            (int )u.node[i]);
#line 229
    tmp += 2;
#line 227
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  *tmp = (char)0;
#line 233
  return;
}
}
#line 240
static void get_current_time(uuid_time_t *timestamp ) ;
#line 240 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static int inited___0  =    0;
#line 241 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static uuid_time_t time_last  ;
#line 242 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static uint16_t uuids_this_tick  ;
#line 238 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static void get_current_time(uuid_time_t *timestamp ) 
{ 
  uuid_time_t time_now ;

  {
#line 245
  if (! inited___0) {
    {
#line 246
    get_system_time(& time_now);
#line 247
    uuids_this_tick = (uint16_t )1024;
#line 248
    inited___0 = 1;
    }
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 252
    get_system_time(& time_now);
    }
#line 255
    if (time_last != time_now) {
#line 257
      uuids_this_tick = (uint16_t )0;
#line 258
      time_last = time_now;
#line 259
      goto while_break;
    }
#line 261
    if ((int )uuids_this_tick < 1024) {
#line 262
      uuids_this_tick = (uint16_t )((int )uuids_this_tick + 1);
#line 263
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  *timestamp = time_now + (uuid_time_t )uuids_this_tick;
#line 269
  return;
}
}
#line 277
static void get_ieee_node_identifier(uuid_node_t *node ) ;
#line 277 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static int inited___1  =    0;
#line 278 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static uuid_node_t saved_node  ;
#line 275 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static void get_ieee_node_identifier(uuid_node_t *node ) 
{ 
  char seed[16] ;

  {
#line 281
  if (! inited___1) {
    {
#line 282
    get_random_info((char *)(seed));
#line 283
    seed[0] = (char )((int )seed[0] | 1);
#line 284
    memcpy((void */* __restrict  */)(& saved_node), (void const   */* __restrict  */)(seed),
           sizeof(saved_node));
    }
  }
#line 286
  inited___1 = 1;
#line 288
  *node = saved_node;
#line 289
  return;
}
}
#line 294 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static void format_uuid_v1(uuid_t *uuid , uint16_t clock_seq , uuid_time_t timestamp ,
                           uuid_node_t node ) 
{ 


  {
  {
#line 299
  uuid->time_low = (uint32_t )(timestamp & 4294967295UL);
#line 300
  uuid->time_mid = (unsigned short )((timestamp >> 32) & 65535UL);
#line 301
  uuid->time_hi_and_version = (unsigned short )((timestamp >> 48) & 4095UL);
#line 303
  uuid->time_hi_and_version = (uint16_t )((int )uuid->time_hi_and_version | (1 << 12));
#line 304
  uuid->clock_seq_low = (uint8_t )((int )clock_seq & 255);
#line 305
  uuid->clock_seq_hi_and_reserved = (uint8_t )(((int )clock_seq & 16128) >> 8);
#line 306
  uuid->clock_seq_hi_and_reserved = (uint8_t )((int )uuid->clock_seq_hi_and_reserved | 128);
#line 307
  memcpy((void */* __restrict  */)(& uuid->node), (void const   */* __restrict  */)(& node),
         sizeof(uuid->node));
  }
#line 308
  return;
}
}
#line 311 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
int uuid_create(uuid_t *uuid ) 
{ 
  uuid_time_t timestamp ;
  uint16_t clockseq ;
  uuid_node_t node ;

  {
  {
#line 318
  get_current_time(& timestamp);
#line 319
  get_ieee_node_identifier(& node);
#line 322
  clockseq = true_random();
#line 325
  format_uuid_v1(uuid, clockseq, timestamp, node);
  }
#line 326
  return (1);
}
}
#line 329 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
void get_uuid_string(char *uuid_str , size_t size ) 
{ 
  uuid_t u ;

  {
  {
#line 332
  uuid_create(& u);
#line 333
  snpuid(uuid_str, size, u);
  }
#line 335
  return;
}
}
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
#line 1 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char netlib_id[76]  = 
#line 1 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
  {      (char )'@',      (char )'(',      (char )'#',      (char )')', 
        (char )'n',      (char )'e',      (char )'t',      (char )'l', 
        (char )'i',      (char )'b',      (char )'.',      (char )'c', 
        (char )' ',      (char )'(',      (char )'c',      (char )')', 
        (char )' ',      (char )'C',      (char )'o',      (char )'p', 
        (char )'y',      (char )'r',      (char )'i',      (char )'g', 
        (char )'h',      (char )'t',      (char )' ',      (char )'1', 
        (char )'9',      (char )'9',      (char )'3',      (char )'-', 
        (char )'2',      (char )'0',      (char )'1',      (char )'2', 
        (char )' ',      (char )'H',      (char )'e',      (char )'w', 
        (char )'l',      (char )'e',      (char )'t',      (char )'t', 
        (char )'-',      (char )'P',      (char )'a',      (char )'c', 
        (char )'k',      (char )'a',      (char )'r',      (char )'d', 
        (char )' ',      (char )'C',      (char )'o',      (char )'m', 
        (char )'p',      (char )'a',      (char )'n',      (char )'y', 
        (char )'.',      (char )' ',      (char )'V',      (char )'e', 
        (char )'r',      (char )'s',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'2',      (char )'.', 
        (char )'6',      (char )'.',      (char )'0',      (char )'\000'};
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 759 "/usr/include/stdio.h"
extern void rewind(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 620 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 90 "/home/wheatley/newnew/temp/netperf-2.6.0/src/hist.h"
HIST HIST_new(void) ;
#line 104
void HIST_clear(HIST h ) ;
#line 118
void HIST_add(HIST h , int time_delta ) ;
#line 125
void HIST_report(HIST h ) ;
#line 138
void HIST_timestamp(struct timeval *timestamp ) ;
#line 165
int delta_micro(struct timeval *begin , struct timeval *end ) ;
#line 4 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu.h"
void cpu_util_init(void) ;
#line 5
void cpu_util_terminate(void) ;
#line 6
int get_cpu_method(void) ;
#line 15
float calibrate_idle_rate(int iterations , int interval___0 ) ;
#line 16
float calc_cpu_util_internal(float elapsed_time___0 ) ;
#line 17
void cpu_start_internal(void) ;
#line 18
void cpu_stop_internal(void) ;
#line 194 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int lib_num_loc_cpus  ;
#line 194 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int lib_num_rem_cpus  ;
#line 198 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int lib_local_peak_cpu_id  ;
#line 198 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int lib_remote_peak_cpu_id  ;
#line 201 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double lib_local_peak_cpu_util  ;
#line 201 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double lib_remote_peak_cpu_util  ;
#line 207 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int lib_use_idle  ;
#line 208 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int cpu_method  ;
#line 210 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
struct timeval time1  ;
#line 210 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
struct timeval time2  ;
#line 211 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
struct timezone tz  ;
#line 212 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
float lib_elapsed  ;
#line 212 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
float lib_local_maxrate  ;
#line 212 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
float lib_remote_maxrate  ;
#line 212 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
float lib_local_cpu_util  ;
#line 212 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
float lib_remote_cpu_util  ;
#line 218 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
float lib_local_per_cpu_util[256]  ;
#line 219 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int lib_cpu_map[256]  ;
#line 221 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int *request_array  ;
#line 222 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int *response_array  ;
#line 225 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int netlib_control  =    -1;
#line 226 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int server_sock  =    -1;
#line 227 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int control_family  =    0;
#line 230 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int local_proc_affinity  =    -1;
#line 230 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int remote_proc_affinity  =    -1;
#line 234 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char local_data_port[10]  ;
#line 235 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char remote_data_port[10]  ;
#line 237 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *local_data_address  =    (char *)((void *)0);
#line 238 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *remote_data_address  =    (char *)((void *)0);
#line 240 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *local_sysname  ;
#line 240 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *remote_sysname  ;
#line 241 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *local_release  ;
#line 241 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *remote_release  ;
#line 242 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *local_version  ;
#line 242 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *remote_version  ;
#line 243 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *local_machine  ;
#line 243 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *remote_machine  ;
#line 245 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int local_data_family  =    0;
#line 246 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int remote_data_family  =    0;
#line 248 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *netperf_version  ;
#line 250 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
enum netperf_output_modes netperf_output_mode  =    (enum netperf_output_modes )0;
#line 258 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
union netperf_request_struct netperf_request  ;
#line 259 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
union netperf_response_struct netperf_response  ;
#line 261 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
FILE *where  ;
#line 263 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char libfmt  =    (char )'?';
#line 270 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int times_up  ;
#line 288 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
static int measuring_cpu  ;
#line 289 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int netlib_get_page_size(void) 
{ 
  long tmp ;

  {
  {
#line 311
  tmp = sysconf(30);
  }
#line 311
  return ((int )tmp);
}
}
#line 454 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *nsec_enabled_to_str(int enabled ) 
{ 


  {
  {
#line 457
  if (enabled == -1) {
#line 457
    goto case_neg_1;
  }
#line 459
  if (enabled == 0) {
#line 459
    goto case_0;
  }
#line 461
  if (enabled == 1) {
#line 461
    goto case_1;
  }
#line 463
  if (enabled == 2) {
#line 463
    goto case_2;
  }
#line 465
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 458
  return ((char *)"Unknown");
  case_0: /* CIL Label */ 
#line 460
  return ((char *)"Disabled");
  case_1: /* CIL Label */ 
#line 462
  return ((char *)"Permissive");
  case_2: /* CIL Label */ 
#line 464
  return ((char *)"Enforcing");
  switch_default: /* CIL Label */ 
#line 466
  return ((char *)"UNKNOWN MODE");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 470 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *nsec_type_to_str(int type ) 
{ 


  {
  {
#line 472
  if (type == -1) {
#line 472
    goto case_neg_1;
  }
#line 474
  if (type == 1) {
#line 474
    goto case_1;
  }
#line 476
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 473
  return ((char *)"Unknown");
  case_1: /* CIL Label */ 
#line 475
  return ((char *)"SELinux");
  switch_default: /* CIL Label */ 
#line 477
  return ((char *)"UNKNOWN TYPE");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 482 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *inet_ttos(int type ) 
{ 


  {
  {
#line 486
  if (type == 2) {
#line 486
    goto case_2;
  }
#line 489
  if (type == 1) {
#line 489
    goto case_1;
  }
#line 493
  if (type == 6) {
#line 493
    goto case_6;
  }
#line 497
  if (type == 5) {
#line 497
    goto case_5;
  }
#line 500
  goto switch_default;
  case_2: /* CIL Label */ 
#line 487
  return ((char *)"SOCK_DGRAM");
#line 488
  goto switch_break;
  case_1: /* CIL Label */ 
#line 490
  return ((char *)"SOCK_STREAM");
#line 491
  goto switch_break;
  case_6: /* CIL Label */ 
#line 494
  return ((char *)"SOCK_DCCP");
  case_5: /* CIL Label */ 
#line 498
  return ((char *)"SOCK_SEQPACKET");
  switch_default: /* CIL Label */ 
#line 501
  return ((char *)"SOCK_UNKNOWN");
  switch_break: /* CIL Label */ ;
  }
#line 503
  return ((char *)0);
}
}
#line 508 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char unknown[32]  ;
#line 510 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *inet_ptos(int protocol___0 ) 
{ 


  {
  {
#line 513
  if (protocol___0 == 6) {
#line 513
    goto case_6;
  }
#line 516
  if (protocol___0 == 17) {
#line 516
    goto case_17;
  }
#line 520
  if (protocol___0 == 132) {
#line 520
    goto case_132;
  }
#line 525
  if (protocol___0 == 33) {
#line 525
    goto case_33;
  }
#line 530
  if (protocol___0 == 136) {
#line 530
    goto case_136;
  }
#line 534
  goto switch_default;
  case_6: /* CIL Label */ 
#line 514
  return ((char *)"IPPROTO_TCP");
#line 515
  goto switch_break;
  case_17: /* CIL Label */ 
#line 517
  return ((char *)"IPPROTO_UDP");
#line 518
  goto switch_break;
  case_132: /* CIL Label */ 
#line 521
  return ((char *)"IPPROTO_SCTP");
#line 522
  goto switch_break;
  case_33: /* CIL Label */ 
#line 526
  return ((char *)"IPPROTO_DCCP");
#line 527
  goto switch_break;
  case_136: /* CIL Label */ 
#line 531
  return ((char *)"IPPROTO_UDPLITE");
#line 532
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 535
  snprintf((char */* __restrict  */)(unknown), sizeof(unknown), (char const   */* __restrict  */)"IPPROTO_UNKNOWN(%d)",
           protocol___0);
  }
#line 536
  return (unknown);
  switch_break: /* CIL Label */ ;
  }
#line 538
  return ((char *)0);
}
}
#line 546 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *inet_ftos(int family ) 
{ 


  {
  {
#line 550
  if (family == 2) {
#line 550
    goto case_2;
  }
#line 553
  if (family == 10) {
#line 553
    goto case_10;
  }
#line 557
  if (family == 27) {
#line 557
    goto case_27;
  }
#line 561
  if (family == 21) {
#line 561
    goto case_21;
  }
#line 564
  goto switch_default;
  case_2: /* CIL Label */ 
#line 551
  return ((char *)"AF_INET");
  case_10: /* CIL Label */ 
#line 554
  return ((char *)"AF_INET6");
  case_27: /* CIL Label */ 
#line 558
  return ((char *)"AF_INET_SDP");
  case_21: /* CIL Label */ 
#line 562
  return ((char *)"AF_RDS");
  switch_default: /* CIL Label */ 
#line 565
  return ((char *)"AF_UNSPEC");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 569 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int inet_nton(int af___0 , void const   *src , char *dst , int cnt ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 575
  if (af___0 == 2) {
#line 575
    goto case_2;
  }
#line 587
  if (af___0 == 10) {
#line 587
    goto case_10;
  }
#line 599
  if (af___0 == 21) {
#line 599
    goto case_21;
  }
#line 605
  goto switch_default;
  case_2: /* CIL Label */ 
#line 577
  if (cnt >= 4) {
    {
#line 578
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, (size_t )4);
    }
#line 579
    return (4);
  } else {
    {
#line 582
    tmp = __errno_location();
#line 582
    *tmp = 28;
    }
#line 583
    return (-1);
  }
#line 585
  goto switch_break;
  case_10: /* CIL Label */ 
#line 588
  if (cnt >= 16) {
    {
#line 589
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, (size_t )16);
    }
#line 590
    return (16);
  } else {
    {
#line 593
    tmp___0 = __errno_location();
#line 593
    *tmp___0 = 28;
    }
#line 594
    return (-1);
  }
#line 596
  goto switch_break;
  case_21: /* CIL Label */ 
#line 600
  if (cnt >= 4) {
    {
#line 601
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, (size_t )4);
    }
#line 602
    return (4);
  }
  switch_default: /* CIL Label */ 
  {
#line 606
  tmp___1 = __errno_location();
#line 606
  *tmp___1 = 97;
  }
#line 607
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 609
  return (0);
}
}
#line 611 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double ntohd(double net_double ) 
{ 
  union __anonunion_conv_rec_64 conv_rec ;
  unsigned char scratch ;
  int i ;
  uint32_t tmp ;

  {
  {
#line 628
  tmp = ntohl((uint32_t )1L);
  }
#line 628
  if ((long )tmp == 1L) {
#line 629
    return (net_double);
  }
  {
#line 632
  conv_rec.whole_thing = net_double;
#line 637
  conv_rec.words[0] = htonl(conv_rec.words[0]);
#line 638
  conv_rec.words[1] = htonl(conv_rec.words[1]);
#line 641
  i = 0;
  }
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 641
    if (! (i <= 3)) {
#line 641
      goto while_break;
    }
#line 642
    scratch = conv_rec.bytes[i];
#line 643
    conv_rec.bytes[i] = conv_rec.bytes[7 - i];
#line 644
    conv_rec.bytes[7 - i] = scratch;
#line 641
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 656
  return (conv_rec.whole_thing);
}
}
#line 660 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double htond(double host_double ) 
{ 
  union __anonunion_conv_rec_65 conv_rec ;
  unsigned char scratch ;
  int i ;
  uint32_t tmp ;

  {
  {
#line 677
  tmp = ntohl((uint32_t )1L);
  }
#line 677
  if ((long )tmp == 1L) {
#line 678
    return (host_double);
  }
#line 681
  conv_rec.whole_thing = host_double;
#line 684
  i = 0;
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (! (i <= 3)) {
#line 684
      goto while_break;
    }
#line 685
    scratch = conv_rec.bytes[i];
#line 686
    conv_rec.bytes[i] = conv_rec.bytes[7 - i];
#line 687
    conv_rec.bytes[7 - i] = scratch;
#line 684
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 702
  conv_rec.words[0] = htonl(conv_rec.words[0]);
#line 703
  conv_rec.words[1] = htonl(conv_rec.words[1]);
  }
#line 705
  return (conv_rec.whole_thing);
}
}
#line 718 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
unsigned int rand32(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 720
  tmp = rand();
#line 720
  tmp___0 = rand();
  }
#line 720
  return ((unsigned int )tmp * 2U + (unsigned int )(tmp___0 % 2));
}
}
#line 728 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void random_ip_address(struct addrinfo *res , int mask_len ) 
{ 
  struct sockaddr_in *foo ;
  unsigned int addr ;
  uint32_t tmp ;
  unsigned int mask ;
  unsigned int tmp___0 ;
  struct sockaddr_in6 *foo___0 ;
  unsigned int i ;
  unsigned int len ;
  unsigned int *addr___0 ;
  unsigned int mask___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 732
  if (res->ai_family == 2) {
#line 732
    goto case_2;
  }
#line 752
  if (res->ai_family == 10) {
#line 752
    goto case_10;
  }
#line 778
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 733
  foo = (struct sockaddr_in *)res->ai_addr;
#line 734
  tmp = ntohl(foo->sin_addr.s_addr);
#line 734
  addr = tmp;
#line 735
  mask = (1U << (32 - mask_len)) - 1U;
  }
#line 737
  if (mask_len < 0) {
    {
#line 738
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Mask length must be between 0 and 32 inclusive for AF_INET\n");
#line 740
    fflush(where);
#line 741
    exit(-1);
    }
  } else
#line 737
  if (mask_len > 32) {
    {
#line 738
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Mask length must be between 0 and 32 inclusive for AF_INET\n");
#line 740
    fflush(where);
#line 741
    exit(-1);
    }
  }
  {
#line 744
  addr = ntohl(foo->sin_addr.s_addr);
  }
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 746
    tmp___0 = rand32();
#line 746
    addr = (addr & ~ mask) | (tmp___0 & mask);
    }
#line 745
    if (! ((addr & 255U) == 255U)) {
#line 745
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 748
  foo->sin_addr.s_addr = htonl(addr);
  }
#line 749
  goto switch_break;
  case_10: /* CIL Label */ 
#line 753
  foo___0 = (struct sockaddr_in6 *)res->ai_addr;
#line 756
  addr___0 = (unsigned int *)(& foo___0->sin6_addr.__in6_u.__u6_addr8);
#line 759
  if (mask_len < 0) {
    {
#line 760
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Mask length must be between 0 and 128 inclusive for AF_INET\n");
#line 762
    fflush(where);
#line 763
    exit(-1);
    }
  } else
#line 759
  if (mask_len > 128) {
    {
#line 760
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Mask length must be between 0 and 128 inclusive for AF_INET\n");
#line 762
    fflush(where);
#line 763
    exit(-1);
    }
  }
#line 766
  i = 0U;
  {
#line 766
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 766
    if (! (i < 4U)) {
#line 766
      goto while_break___0;
    }
    {
#line 767
    *(addr___0 + i) = ntohl(*(addr___0 + i));
#line 768
    len = (unsigned int )mask_len - i * 32U;
    }
#line 769
    if (len < 32U) {
#line 769
      len = len;
    } else {
#line 769
      len = 32U;
    }
#line 770
    if (len > 0U) {
#line 770
      len = len;
    } else {
#line 770
      len = 0U;
    }
    {
#line 771
    mask___0 = (1U << (32U - len)) - 1U;
#line 772
    tmp___1 = rand32();
#line 772
    *(addr___0 + i) = (*(addr___0 + i) & ~ mask___0) | (tmp___1 & mask___0);
#line 773
    *(addr___0 + i) = htonl(*(addr___0 + i));
#line 766
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 775
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 779
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Unexpected Address Family of %u\n",
          res->ai_family);
#line 781
  fflush(where);
#line 782
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 784
  return;
}
}
#line 789 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int get_num_cpus(void) 
{ 
  int temp_cpus ;
  long tmp ;

  {
  {
#line 816
  tmp = sysconf(84);
#line 816
  temp_cpus = (int )tmp;
  }
#line 837
  if (temp_cpus > 256) {
    {
#line 838
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Sorry, this system has more CPUs (%d) than I can handle (%d).\nPlease alter MAXCPUS in netlib.h and recompile.\n",
            temp_cpus, 256);
#line 843
    fflush(where);
#line 844
    exit(1);
    }
  }
#line 847
  return (temp_cpus);
}
}
#line 887 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void stop_timer(void) 
{ 


  {
  {
#line 891
  alarm(0U);
  }
#line 899
  return;
}
}
#line 909 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void catcher(int sig ) 
{ 


  {
  {
#line 936
  if (sig == 2) {
#line 936
    goto case_2;
  }
#line 939
  if (sig == 14) {
#line 939
    goto case_14;
  }
#line 934
  goto switch_break;
  case_2: /* CIL Label */ 
#line 937
  times_up = 1;
#line 938
  goto switch_break;
  case_14: /* CIL Label */ 
#line 940
  test_len_ticks --;
#line 940
  if (test_len_ticks == 0) {
#line 942
    if (times_up != 0) {
      {
#line 943
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"catcher: timer popped with times_up != 0\n");
#line 944
      fflush(where);
      }
    }
#line 946
    times_up = 1;
#line 954
    goto switch_break;
  } else {
    {
#line 975
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"catcher: interval timer running unexpectedly!\n");
#line 977
    fflush(where);
#line 978
    times_up = 1;
    }
#line 980
    goto switch_break;
  }
  switch_break: /* CIL Label */ ;
  }
#line 983
  return;
}
}
#line 987 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void install_signal_catchers(void) 
{ 
  struct sigaction action ;
  int i ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 997
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"installing catcher for all signals\n");
#line 998
  fflush(where);
#line 1000
  sigemptyset(& action.sa_mask);
#line 1001
  action.__sigaction_handler.sa_handler = & catcher;
#line 1004
  action.sa_flags = 536870912;
#line 1010
  i = 1;
  }
  {
#line 1010
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1010
    if (! (i <= 65)) {
#line 1010
      goto while_break;
    }
    {
#line 1015
    if (i == 9) {
#line 1015
      goto case_9;
    }
#line 1015
    if (i == 19) {
#line 1015
      goto case_9;
    }
#line 1015
    if (i == 27) {
#line 1015
      goto case_9;
    }
#line 1015
    if (i == 14) {
#line 1015
      goto case_9;
    }
#line 1017
    goto switch_default;
    case_9: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_14: /* CIL Label */ 
#line 1016
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1018
    tmp___0 = sigaction(i, (struct sigaction  const  */* __restrict  */)(& action),
                        (struct sigaction */* __restrict  */)((void *)0));
    }
#line 1018
    if (tmp___0 != 0) {
      {
#line 1019
      tmp = __errno_location();
#line 1019
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Could not install signal catcher for sig %d, errno %d\n",
              i, *tmp);
#line 1023
      fflush(where);
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 1010
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1031
  return;
}
}
#line 1094 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void start_timer(int time___0 ) 
{ 
  struct sigaction action ;
  int ret ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int *tmp___4 ;

  {
#line 1138
  if (debug) {
    {
#line 1139
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"About to start a timer for %d seconds.\n",
            time___0);
#line 1140
    fflush(where);
    }
  }
  {
#line 1143
  action.__sigaction_handler.sa_handler = & catcher;
#line 1148
  action.sa_flags = 536870912;
#line 1153
  sigemptyset(& action.sa_mask);
#line 1154
  sigaddset(& action.sa_mask, 14);
#line 1155
  tmp___0 = sigaction(14, (struct sigaction  const  */* __restrict  */)(& action),
                      (struct sigaction */* __restrict  */)((void *)0));
  }
#line 1155
  if (tmp___0 < 0) {
    {
#line 1156
    tmp = __errno_location();
#line 1156
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"start_timer: error installing alarm handler errno %d\n",
            *tmp);
#line 1159
    fflush(where);
#line 1160
    exit(-1);
    }
  }
  {
#line 1163
  sigemptyset(& action.sa_mask);
#line 1164
  sigaddset(& action.sa_mask, 2);
#line 1165
  tmp___2 = sigaction(2, (struct sigaction  const  */* __restrict  */)(& action),
                      (struct sigaction */* __restrict  */)((void *)0));
  }
#line 1165
  if (tmp___2 < 0) {
    {
#line 1166
    tmp___1 = __errno_location();
#line 1166
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"start_timer: error installing SIGINT handler errno %d\n",
            *tmp___1);
#line 1169
    fflush(where);
#line 1170
    exit(-1);
    }
  }
  {
#line 1174
  tmp___3 = alarm((unsigned int )time___0);
#line 1174
  ret = (int )tmp___3;
  }
#line 1175
  if (ret != 0) {
    {
#line 1176
    tmp___4 = __errno_location();
#line 1176
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"error starting alarm timer, ret %d errno %d\n",
            ret, *tmp___4);
#line 1180
    fflush(where);
#line 1181
    exit(-1);
    }
  }
#line 1185
  test_len_ticks = 1;
#line 1187
  return;
}
}
#line 1291 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void netlib_init_cpu_map(void) 
{ 
  int i ;

  {
#line 1315
  i = 0;
  {
#line 1315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1315
    if (! (i < 256)) {
#line 1315
      goto while_break;
    }
#line 1316
    lib_cpu_map[i] = i;
#line 1315
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1319
  return;
}
}
#line 1321 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void get_local_system_info(void) 
{ 
  struct utsname buf ;
  int tmp ;

  {
  {
#line 1329
  tmp = uname(& buf);
  }
#line 1329
  if (tmp != -1) {
    {
#line 1330
    local_sysname = strdup((char const   *)(buf.sysname));
#line 1331
    local_release = strdup((char const   *)(buf.release));
#line 1332
    local_version = strdup((char const   *)(buf.version));
#line 1333
    local_machine = strdup((char const   *)(buf.machine));
    }
  } else {
    {
#line 1336
    local_sysname = strdup("UnknownSystem");
#line 1337
    local_release = strdup("UnknownRelease");
#line 1338
    local_version = strdup("UnknownVersion");
#line 1339
    local_machine = strdup("UnknownMachine");
    }
  }
#line 1352
  return;
}
}
#line 1363 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void netlib_init(void) 
{ 
  int i ;
  __pid_t tmp ;

  {
#line 1368
  where = stdout;
#line 1370
  request_array = (int *)(& netperf_request);
#line 1371
  response_array = (int *)(& netperf_response);
#line 1373
  i = 0;
  {
#line 1373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1373
    if (! (i < 256)) {
#line 1373
      goto while_break;
    }
#line 1374
    lib_local_per_cpu_util[i] = (float )(- 1.0);
#line 1373
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1377
  lib_local_peak_cpu_id = -1;
#line 1378
  lib_local_peak_cpu_util = - 1.0;
#line 1379
  lib_remote_peak_cpu_id = -1;
#line 1380
  lib_remote_peak_cpu_util = - 1.0;
#line 1382
  netperf_version = strdup("2.6.0");
#line 1385
  get_local_system_info();
#line 1395
  netlib_init_cpu_map();
  }
#line 1397
  if (debug) {
    {
#line 1398
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netlib_init: request_array at %p\nnetlib_init: response_array at %p\n",
            request_array, response_array);
#line 1403
    fflush(where);
    }
  }
  {
#line 1408
  tmp = getpid();
#line 1408
  srand((unsigned int )tmp);
  }
#line 1410
  return;
}
}
#line 1417 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
unsigned int convert(char *string ) 
{ 
  unsigned int base ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 1422
  tmp = atoi((char const   *)string);
#line 1422
  base = (unsigned int )tmp;
#line 1423
  tmp___0 = strstr((char const   *)string, "K");
  }
#line 1423
  if (tmp___0) {
#line 1424
    base *= 1024U;
  }
  {
#line 1426
  tmp___1 = strstr((char const   *)string, "M");
  }
#line 1426
  if (tmp___1) {
#line 1427
    base *= 1048576U;
  }
  {
#line 1429
  tmp___2 = strstr((char const   *)string, "G");
  }
#line 1429
  if (tmp___2) {
#line 1430
    base *= 1073741824U;
  }
  {
#line 1432
  tmp___3 = strstr((char const   *)string, "k");
  }
#line 1432
  if (tmp___3) {
#line 1433
    base *= 1000U;
  }
  {
#line 1435
  tmp___4 = strstr((char const   *)string, "m");
  }
#line 1435
  if (tmp___4) {
#line 1436
    base *= 1000000U;
  }
  {
#line 1438
  tmp___5 = strstr((char const   *)string, "g");
  }
#line 1438
  if (tmp___5) {
#line 1439
    base *= 1000000000U;
  }
#line 1441
  return (base);
}
}
#line 1456 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
unsigned int convert_timespec(char *string ) 
{ 
  unsigned int base ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1460
  tmp = atoi((char const   *)string);
#line 1460
  base = (unsigned int )tmp;
#line 1461
  tmp___2 = strstr((char const   *)string, "m");
  }
#line 1461
  if (tmp___2) {
#line 1462
    base *= 1000U;
  } else {
    {
#line 1464
    tmp___1 = strstr((char const   *)string, "u");
    }
#line 1464
    if (tmp___1) {
#line 1465
      base = base;
    } else {
      {
#line 1467
      tmp___0 = strstr((char const   *)string, "s");
      }
#line 1467
      if (tmp___0) {
#line 1468
        base *= 1000000U;
      } else {
#line 1471
        base *= 1000U;
      }
    }
  }
#line 1473
  return (base);
}
}
#line 1486 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
struct ring_elt *allocate_buffer_ring(int width , int buffer_size , int alignment ,
                                      int offset ) 
{ 
  struct ring_elt *first_link ;
  struct ring_elt *temp_link ;
  struct ring_elt *prev_link ;
  int i ;
  int malloc_size ;
  int bytes_left ;
  int bytes_read ;
  int do_fill ;
  FILE *fill_source ;
  char default_fill[8] ;
  int fill_cursor ;
  FILE *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *bufptr ;
  size_t tmp___5 ;
  int tmp___6 ;
  int j ;
  char *bufptr___0 ;
  size_t tmp___7 ;

  {
  {
#line 1490
  first_link = (struct ring_elt *)((void *)0);
#line 1491
  temp_link = (struct ring_elt *)((void *)0);
#line 1501
  default_fill[0] = (char )'n';
#line 1501
  default_fill[1] = (char )'e';
#line 1501
  default_fill[2] = (char )'t';
#line 1501
  default_fill[3] = (char )'p';
#line 1501
  default_fill[4] = (char )'e';
#line 1501
  default_fill[5] = (char )'r';
#line 1501
  default_fill[6] = (char )'f';
#line 1501
  default_fill[7] = (char )'\000';
#line 1502
  fill_cursor = 0;
#line 1504
  malloc_size = (buffer_size + alignment) + offset;
#line 1508
  tmp___2 = strcmp((char const   *)(local_fill_file), "");
  }
#line 1508
  if (tmp___2 == 0) {
#line 1509
    do_fill = 0;
#line 1510
    fill_source = (FILE *)((void *)0);
  } else {
    {
#line 1513
    do_fill = 1;
#line 1514
    tmp = fopen((char const   */* __restrict  */)(local_fill_file), (char const   */* __restrict  */)"r");
#line 1514
    fill_source = tmp;
    }
#line 1515
    if ((unsigned long )fill_source == (unsigned long )((FILE *)((void *)0))) {
      {
#line 1516
      tmp___0 = __errno_location();
#line 1516
      tmp___1 = strerror(*tmp___0);
#line 1516
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Could not open requested fill file: %s\n",
              tmp___1);
#line 1518
      fflush(where);
      }
    }
  }
#line 1522
  if (! (width >= 1)) {
    {
#line 1522
    __assert_fail("width >= 1", "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c",
                  1522U, "allocate_buffer_ring");
    }
  }
#line 1524
  prev_link = (struct ring_elt *)((void *)0);
#line 1525
  i = 1;
  {
#line 1525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1525
    if (! (i <= width)) {
#line 1525
      goto while_break;
    }
    {
#line 1527
    tmp___3 = malloc(sizeof(struct ring_elt ));
#line 1527
    temp_link = (struct ring_elt *)tmp___3;
    }
#line 1528
    if ((unsigned long )temp_link == (unsigned long )((void *)0)) {
      {
#line 1529
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"malloc(%u) failed!\n",
              (unsigned int )sizeof(struct ring_elt ));
#line 1532
      exit(-1);
      }
    }
#line 1534
    temp_link->completion_ptr = (void *)0;
#line 1536
    if (i == 1) {
#line 1537
      first_link = temp_link;
    }
    {
#line 1539
    tmp___4 = malloc((size_t )malloc_size);
#line 1539
    temp_link->buffer_base = (char *)tmp___4;
    }
#line 1540
    if ((unsigned long )temp_link == (unsigned long )((void *)0)) {
      {
#line 1541
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"malloc(%d) failed!\n",
              malloc_size);
#line 1544
      exit(-1);
      }
    }
#line 1548
    temp_link->buffer_ptr = (char *)((((long )temp_link->buffer_base + (long )alignment) - 1L) & ~ ((long )alignment - 1L));
#line 1556
    temp_link->buffer_ptr += offset;
#line 1558
    if (do_fill) {
#line 1559
      bufptr = temp_link->buffer_ptr;
#line 1560
      bytes_left = buffer_size;
      {
#line 1561
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1561
        if (! bytes_left) {
#line 1561
          goto while_break___0;
        }
        {
#line 1562
        tmp___5 = fread((void */* __restrict  */)bufptr, (size_t )1, (size_t )bytes_left,
                        (FILE */* __restrict  */)fill_source);
#line 1562
        bytes_read = (int )tmp___5;
        }
#line 1562
        if (bytes_read == 0) {
          {
#line 1562
          tmp___6 = feof(fill_source);
          }
#line 1562
          if (tmp___6) {
            {
#line 1567
            rewind(fill_source);
            }
          }
        }
#line 1569
        bufptr += bytes_read;
#line 1570
        bytes_left -= bytes_read;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 1577
      bufptr___0 = temp_link->buffer_ptr;
#line 1578
      j = 0;
      {
#line 1578
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1578
        if (! (j < buffer_size)) {
#line 1578
          goto while_break___1;
        }
        {
#line 1579
        *(bufptr___0 + j) = default_fill[fill_cursor];
#line 1580
        fill_cursor ++;
#line 1583
        tmp___7 = strlen((char const   *)(default_fill));
        }
#line 1583
        if (fill_cursor > (int )tmp___7) {
#line 1584
          fill_cursor = 0;
        }
#line 1578
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1589
    temp_link->next = prev_link;
#line 1590
    prev_link = temp_link;
#line 1525
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1592
  if (first_link) {
#line 1593
    first_link->next = temp_link;
  }
#line 1596
  return (first_link);
}
}
#line 1605 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void access_buffer(char *buffer_ptr , int length , int dirty_count , int clean_count ) 
{ 
  char *temp_buffer ;
  char *limit ;
  int i ;
  int dirty_totals ;

  {
#line 1612
  temp_buffer = buffer_ptr;
#line 1613
  limit = temp_buffer + length;
#line 1614
  dirty_totals = 0;
#line 1616
  i = 0;
  {
#line 1616
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1616
    if (i < dirty_count) {
#line 1616
      if (! ((unsigned long )temp_buffer < (unsigned long )limit)) {
#line 1616
        goto while_break;
      }
    } else {
#line 1616
      goto while_break;
    }
#line 1619
    *temp_buffer = (char )((int )*temp_buffer + (int )((char )i));
#line 1620
    dirty_totals += (int )*temp_buffer;
#line 1621
    temp_buffer ++;
#line 1616
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1624
  i = 0;
  {
#line 1624
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1624
    if (i < clean_count) {
#line 1624
      if (! ((unsigned long )temp_buffer < (unsigned long )limit)) {
#line 1624
        goto while_break___0;
      }
    } else {
#line 1624
      goto while_break___0;
    }
#line 1627
    dirty_totals += (int )*temp_buffer;
#line 1628
    temp_buffer ++;
#line 1624
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1631
  if (debug > 100) {
    {
#line 1632
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"This was here to try to avoid dead-code elimination %d\n",
            dirty_totals);
#line 1635
    fflush(where);
    }
  }
#line 1637
  return;
}
}
#line 1793 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
struct sendfile_ring_elt *alloc_sendfile_buf_ring(int width , int buffer_size , int alignment ,
                                                  int offset ) 
{ 
  struct sendfile_ring_elt *first_link ;
  struct sendfile_ring_elt *temp_link ;
  struct sendfile_ring_elt *prev_link ;
  int i ;
  int fildes ;
  struct stat statbuf ;
  char temp_file[15] ;
  int *temp_buffer ;
  void *tmp ;
  int count ;
  int *int_ptr ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 1801
  first_link = (struct sendfile_ring_elt *)((void *)0);
#line 1802
  temp_link = (struct sendfile_ring_elt *)((void *)0);
#line 1812
  tmp___2 = strcmp((char const   *)(local_fill_file), "");
  }
#line 1812
  if (tmp___2 == 0) {
    {
#line 1814
    temp_file[0] = (char )'n';
#line 1814
    temp_file[1] = (char )'e';
#line 1814
    temp_file[2] = (char )'t';
#line 1814
    temp_file[3] = (char )'p';
#line 1814
    temp_file[4] = (char )'e';
#line 1814
    temp_file[5] = (char )'r';
#line 1814
    temp_file[6] = (char )'f';
#line 1814
    temp_file[7] = (char )'X';
#line 1814
    temp_file[8] = (char )'X';
#line 1814
    temp_file[9] = (char )'X';
#line 1814
    temp_file[10] = (char )'X';
#line 1814
    temp_file[11] = (char )'X';
#line 1814
    temp_file[12] = (char )'X';
#line 1814
    temp_file[13] = (char )'\000';
#line 1814
    temp_file[14] = (char )'\000';
#line 1821
    tmp = malloc((unsigned long )buffer_size + sizeof(int ));
#line 1821
    temp_buffer = (int *)tmp;
    }
#line 1822
    if (temp_buffer) {
      {
#line 1825
      fildes = mkstemp(temp_file);
      }
#line 1827
      if (-1 != fildes) {
        {
#line 1837
        unlink((char const   *)(temp_file));
#line 1840
        count = 0;
        }
        {
#line 1840
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1840
          if (! (count < width)) {
#line 1840
            goto while_break;
          }
#line 1845
          int_ptr = temp_buffer;
#line 1846
          i = 0;
          {
#line 1846
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1846
            if (! ((unsigned long )i <= (unsigned long )buffer_size / sizeof(int ))) {
#line 1846
              goto while_break___0;
            }
            {
#line 1847
            *int_ptr = rand();
#line 1848
            int_ptr ++;
#line 1846
            i ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 1850
          tmp___0 = write(fildes, (void const   *)temp_buffer, (unsigned long )buffer_size + sizeof(int ));
          }
#line 1850
          if ((unsigned long )tmp___0 != (unsigned long )buffer_size + sizeof(int )) {
            {
#line 1852
            perror("allocate_sendfile_buf_ring: incomplete write");
#line 1853
            exit(-1);
            }
          }
#line 1840
          count ++;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
        {
#line 1858
        perror("alloc_sendfile_buf_ring: could not allocate temp name");
#line 1859
        exit(-1);
        }
      }
    } else {
      {
#line 1863
      perror("alloc_sendfile_buf_ring: could not allocate buffer for file");
#line 1864
      exit(-1);
      }
    }
  } else {
    {
#line 1869
    fildes = open((char const   *)(local_fill_file), 0);
    }
#line 1870
    if (fildes == -1) {
      {
#line 1871
      perror("alloc_sendfile_buf_ring: Could not open requested file");
#line 1872
      exit(1);
      }
    }
    {
#line 1878
    tmp___1 = stat((char const   */* __restrict  */)(local_fill_file), (struct stat */* __restrict  */)(& statbuf));
    }
#line 1878
    if (tmp___1 != 0) {
      {
#line 1879
      perror("alloc_sendfile_buf_ring: could not stat file");
#line 1880
      exit(1);
      }
    }
#line 1882
    if (statbuf.st_size < (__off_t )(width * buffer_size)) {
      {
#line 1884
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"alloc_sendfile_buf_ring: specified file too small.\nfile must be larger than send_width * send_size\n");
#line 1887
      fflush(stderr);
#line 1888
      exit(1);
      }
    }
  }
#line 1896
  prev_link = (struct sendfile_ring_elt *)((void *)0);
#line 1897
  i = 1;
  {
#line 1897
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1897
    if (! (i <= width)) {
#line 1897
      goto while_break___1;
    }
    {
#line 1902
    tmp___3 = malloc(sizeof(struct sendfile_ring_elt ));
#line 1902
    temp_link = (struct sendfile_ring_elt *)tmp___3;
    }
#line 1904
    if ((unsigned long )temp_link == (unsigned long )((void *)0)) {
      {
#line 1905
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"malloc(%u) failed!\n",
              (unsigned int )sizeof(struct sendfile_ring_elt ));
#line 1908
      exit(1);
      }
    }
#line 1913
    if (i == 1) {
#line 1914
      first_link = temp_link;
    }
#line 1922
    temp_link->fildes = fildes;
#line 1923
    temp_link->offset = (off_t )offset;
#line 1924
    offset += buffer_size;
#line 1925
    temp_link->length = (size_t )buffer_size;
#line 1926
    temp_link->hdtrl = (struct iovec *)((void *)0);
#line 1927
    temp_link->flags = 0;
#line 1931
    temp_link->next = prev_link;
#line 1932
    prev_link = temp_link;
#line 1897
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1935
  first_link->next = temp_link;
#line 1937
  return (first_link);
}
}
#line 1953 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void dump_request(void) 
{ 
  int counter ;

  {
  {
#line 1956
  counter = 0;
#line 1957
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"request contents:\n");
#line 1958
  counter = 0;
  }
  {
#line 1958
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1958
    if (! ((unsigned long )counter < sizeof(netperf_request) / 4UL - 3UL)) {
#line 1958
      goto while_break;
    }
    {
#line 1959
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%d:\t%8x %8x %8x %8x \t|%4.4s| |%4.4s| |%4.4s| |%4.4s|\n",
            counter, *(request_array + counter), *(request_array + (counter + 1)),
            *(request_array + (counter + 2)), *(request_array + (counter + 3)), (char *)(request_array + counter),
            (char *)(request_array + (counter + 1)), (char *)(request_array + (counter + 2)),
            (char *)(request_array + (counter + 3)));
#line 1958
    counter += 4;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1970
  fflush(where);
  }
#line 1971
  return;
}
}
#line 1984 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void dump_response(void) 
{ 
  int counter ;

  {
  {
#line 1987
  counter = 0;
#line 1989
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"response contents\n");
#line 1990
  counter = 0;
  }
  {
#line 1990
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1990
    if (! ((unsigned long )counter < sizeof(netperf_response) / 4UL - 3UL)) {
#line 1990
      goto while_break;
    }
    {
#line 1991
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%d:\t%8x %8x %8x %8x \t>%4.4s< >%4.4s< >%4.4s< >%4.4s<\n",
            counter, *(response_array + counter), *(response_array + (counter + 1)),
            *(response_array + (counter + 2)), *(response_array + (counter + 3)),
            (char *)(response_array + counter), (char *)(response_array + (counter + 1)),
            (char *)(response_array + (counter + 2)), (char *)(response_array + (counter + 3)));
#line 1990
    counter += 4;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2002
  fflush(where);
  }
#line 2003
  return;
}
}
#line 2027 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
static char fmtbuf[64]  ;
#line 2024 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *format_number(double number ) 
{ 


  {
  {
#line 2030
  if ((int )libfmt == 75) {
#line 2030
    goto case_75;
  }
#line 2033
  if ((int )libfmt == 77) {
#line 2033
    goto case_77;
  }
#line 2036
  if ((int )libfmt == 71) {
#line 2036
    goto case_71;
  }
#line 2039
  if ((int )libfmt == 107) {
#line 2039
    goto case_107;
  }
#line 2042
  if ((int )libfmt == 109) {
#line 2042
    goto case_109;
  }
#line 2045
  if ((int )libfmt == 103) {
#line 2045
    goto case_103;
  }
#line 2048
  if ((int )libfmt == 120) {
#line 2048
    goto case_120;
  }
#line 2051
  goto switch_default;
  case_75: /* CIL Label */ 
  {
#line 2031
  snprintf((char */* __restrict  */)(fmtbuf), sizeof(fmtbuf), (char const   */* __restrict  */)"%-7.2f",
           number / 1024.0);
  }
#line 2032
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 2034
  snprintf((char */* __restrict  */)(fmtbuf), sizeof(fmtbuf), (char const   */* __restrict  */)"%-7.2f",
           (number / 1024.0) / 1024.0);
  }
#line 2035
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 2037
  snprintf((char */* __restrict  */)(fmtbuf), sizeof(fmtbuf), (char const   */* __restrict  */)"%-7.2f",
           ((number / 1024.0) / 1024.0) / 1024.0);
  }
#line 2038
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 2040
  snprintf((char */* __restrict  */)(fmtbuf), sizeof(fmtbuf), (char const   */* __restrict  */)"%-7.2f",
           (number * (double )8) / 1000.0);
  }
#line 2041
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 2043
  snprintf((char */* __restrict  */)(fmtbuf), sizeof(fmtbuf), (char const   */* __restrict  */)"%-7.2f",
           ((number * (double )8) / 1000.0) / 1000.0);
  }
#line 2044
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 2046
  snprintf((char */* __restrict  */)(fmtbuf), sizeof(fmtbuf), (char const   */* __restrict  */)"%-7.2f",
           (((number * (double )8) / 1000.0) / 1000.0) / 1000.0);
  }
#line 2047
  goto switch_break;
  case_120: /* CIL Label */ 
  {
#line 2049
  snprintf((char */* __restrict  */)(fmtbuf), sizeof(fmtbuf), (char const   */* __restrict  */)"%-7.2f",
           number);
  }
#line 2050
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2052
  snprintf((char */* __restrict  */)(fmtbuf), sizeof(fmtbuf), (char const   */* __restrict  */)"%-7.2f",
           number / 1024.0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 2055
  return (fmtbuf);
}
}
#line 2058 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char format_cpu_method(int method ) 
{ 
  char method_char ;

  {
  {
#line 2065
  if (method == 0) {
#line 2065
    goto case_0;
  }
#line 2068
  if (method == 1) {
#line 2068
    goto case_1;
  }
#line 2071
  if (method == 2) {
#line 2071
    goto case_2;
  }
#line 2074
  if (method == 7) {
#line 2074
    goto case_7;
  }
#line 2077
  if (method == 11) {
#line 2077
    goto case_11;
  }
#line 2080
  if (method == 10) {
#line 2080
    goto case_10;
  }
#line 2083
  if (method == 3) {
#line 2083
    goto case_3;
  }
#line 2087
  if (method == 5) {
#line 2087
    goto case_5;
  }
#line 2091
  if (method == 4) {
#line 2091
    goto case_4;
  }
#line 2094
  if (method == 6) {
#line 2094
    goto case_6;
  }
#line 2097
  if (method == 8) {
#line 2097
    goto case_8;
  }
#line 2100
  if (method == 9) {
#line 2100
    goto case_9;
  }
#line 2103
  if (method == 12) {
#line 2103
    goto case_12;
  }
#line 2106
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2066
  method_char = (char )'U';
#line 2067
  goto switch_break;
  case_1: /* CIL Label */ 
#line 2069
  method_char = (char )'I';
#line 2070
  goto switch_break;
  case_2: /* CIL Label */ 
#line 2072
  method_char = (char )'P';
#line 2073
  goto switch_break;
  case_7: /* CIL Label */ 
#line 2075
  method_char = (char )'K';
#line 2076
  goto switch_break;
  case_11: /* CIL Label */ 
#line 2078
  method_char = (char )'M';
#line 2079
  goto switch_break;
  case_10: /* CIL Label */ 
#line 2081
  method_char = (char )'E';
#line 2082
  goto switch_break;
  case_3: /* CIL Label */ 
#line 2085
  method_char = (char )'T';
#line 2086
  goto switch_break;
  case_5: /* CIL Label */ 
#line 2089
  method_char = (char )'R';
#line 2090
  goto switch_break;
  case_4: /* CIL Label */ 
#line 2092
  method_char = (char )'L';
#line 2093
  goto switch_break;
  case_6: /* CIL Label */ 
#line 2095
  method_char = (char )'N';
#line 2096
  goto switch_break;
  case_8: /* CIL Label */ 
#line 2098
  method_char = (char )'S';
#line 2099
  goto switch_break;
  case_9: /* CIL Label */ 
#line 2101
  method_char = (char )'C';
#line 2102
  goto switch_break;
  case_12: /* CIL Label */ 
#line 2104
  method_char = (char )'O';
#line 2105
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2107
  method_char = (char )'?';
  switch_break: /* CIL Label */ ;
  }
#line 2110
  return (method_char);
}
}
#line 2117 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
static char unitbuf[64]  ;
#line 2114 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *format_units(void) 
{ 


  {
  {
#line 2120
  if ((int )libfmt == 75) {
#line 2120
    goto case_75;
  }
#line 2123
  if ((int )libfmt == 77) {
#line 2123
    goto case_77;
  }
#line 2126
  if ((int )libfmt == 71) {
#line 2126
    goto case_71;
  }
#line 2129
  if ((int )libfmt == 107) {
#line 2129
    goto case_107;
  }
#line 2132
  if ((int )libfmt == 109) {
#line 2132
    goto case_109;
  }
#line 2135
  if ((int )libfmt == 103) {
#line 2135
    goto case_103;
  }
#line 2138
  if ((int )libfmt == 120) {
#line 2138
    goto case_120;
  }
#line 2142
  goto switch_default;
  case_75: /* CIL Label */ 
  {
#line 2121
  strcpy((char */* __restrict  */)(unitbuf), (char const   */* __restrict  */)"KBytes");
  }
#line 2122
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 2124
  strcpy((char */* __restrict  */)(unitbuf), (char const   */* __restrict  */)"MBytes");
  }
#line 2125
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 2127
  strcpy((char */* __restrict  */)(unitbuf), (char const   */* __restrict  */)"GBytes");
  }
#line 2128
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 2130
  strcpy((char */* __restrict  */)(unitbuf), (char const   */* __restrict  */)"10^3bits");
  }
#line 2131
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 2133
  strcpy((char */* __restrict  */)(unitbuf), (char const   */* __restrict  */)"10^6bits");
  }
#line 2134
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 2136
  strcpy((char */* __restrict  */)(unitbuf), (char const   */* __restrict  */)"10^9bits");
  }
#line 2137
  goto switch_break;
  case_120: /* CIL Label */ 
  {
#line 2139
  strcpy((char */* __restrict  */)(unitbuf), (char const   */* __restrict  */)"Trans");
  }
#line 2140
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2143
  strcpy((char */* __restrict  */)(unitbuf), (char const   */* __restrict  */)"KBytes");
  }
  switch_break: /* CIL Label */ ;
  }
#line 2146
  return (unitbuf);
}
}
#line 2157 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void shutdown_control(void) 
{ 
  char *buf ;
  int buflen ;
  fd_set readfds ;
  struct timeval timeout ;
  int *tmp ;
  int tmp___0 ;
  int __d0 ;
  int __d1 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 2161
  buf = (char *)(& netperf_response);
#line 2162
  buflen = (int )sizeof(netperf_response);
#line 2168
  if (debug) {
    {
#line 2169
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"shutdown_control: shutdown of control connection requested.\n");
#line 2171
    fflush(where);
    }
  }
  {
#line 2176
  tmp___0 = shutdown(netlib_control, 1);
  }
#line 2176
  if (tmp___0 == -1) {
    {
#line 2177
    tmp = __errno_location();
#line 2177
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s  errno %d\n",
            "shutdown_control: error in shutdown", *tmp);
#line 2179
    fflush(where);
#line 2180
    exit(1);
    }
  }
  {
#line 2191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2191
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readfds.__fds_bits[0]): "memory");
#line 2191
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2192
  readfds.__fds_bits[netlib_control / (8 * (int )sizeof(__fd_mask ))] |= 1L << netlib_control % (8 * (int )sizeof(__fd_mask ));
#line 2193
  timeout.tv_sec = (__time_t )60;
#line 2194
  timeout.tv_usec = (__suseconds_t )0;
#line 2198
  tmp___2 = select(1024, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)0,
                   (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& timeout));
  }
#line 2198
  if (tmp___2 != 1) {
    {
#line 2203
    tmp___1 = __errno_location();
#line 2203
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s  errno %d\n",
            "shutdown_control: no response received", *tmp___1);
#line 2205
    fflush(where);
#line 2206
    exit(1);
    }
  }
  {
#line 2210
  recv(netlib_control, (void *)buf, (size_t )buflen, 0);
  }
#line 2212
  return;
}
}
#line 2292
extern int ( /* missing proto */  sched_setaffinity)() ;
#line 2221 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void bind_to_specific_processor(int processor_affinity , int use_cpu_map ) 
{ 
  int mapped_affinity ;
  netperf_cpu_set_t netperf_cpu_set ;
  unsigned int len ;
  size_t __cpu ;
  int *tmp ;
  __pid_t tmp___0 ;
  __pid_t tmp___1 ;
  int tmp___2 ;

  {
#line 2232
  if (use_cpu_map) {
#line 2233
    mapped_affinity = lib_cpu_map[processor_affinity];
  } else {
#line 2236
    mapped_affinity = processor_affinity;
  }
#line 2286
  len = (unsigned int )sizeof(netperf_cpu_set);
#line 2288
  if ((unsigned long )mapped_affinity < 8UL * sizeof(netperf_cpu_set)) {
    {
#line 2289
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2289
      __builtin_memset((void *)(& netperf_cpu_set), '\000', (int )sizeof(cpu_set_t ));
      }
#line 2289
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 2290
    __cpu = (size_t )mapped_affinity;
#line 2290
    if (__cpu / 8UL < sizeof(cpu_set_t )) {
#line 2290
      netperf_cpu_set.__bits[__cpu / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu % (8UL * sizeof(__cpu_mask ));
    }
    {
#line 2292
    tmp___1 = getpid();
#line 2292
    tmp___2 = sched_setaffinity(tmp___1, len, & netperf_cpu_set);
    }
#line 2292
    if (tmp___2) {
#line 2293
      if (debug) {
        {
#line 2294
        tmp = __errno_location();
#line 2294
        tmp___0 = getpid();
#line 2294
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to set PID %d\'s CPU affinity errno %d\n",
                tmp___0, *tmp);
#line 2296
        fflush(stderr);
        }
      }
    }
  } else
#line 2301
  if (debug) {
    {
#line 2302
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CPU number larger than pre-compiled limits. Consider a recompile.\n");
#line 2304
    fflush(stderr);
    }
  }
#line 2364
  return;
}
}
#line 2370 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int set_nonblock(int sock ) 
{ 
  int tmp ;

  {
  {
#line 2377
  tmp = fcntl(sock, 4, 2048);
  }
#line 2377
  return (tmp != -1);
}
}
#line 2388 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void send_request_n(int n ) 
{ 
  int counter ;
  int count ;
  uint32_t tmp ;
  ssize_t tmp___0 ;

  {
#line 2394
  if (n < 0) {
#line 2394
    count = (int )(sizeof(netperf_request) / 4UL);
  } else {
#line 2395
    count = 2 + n;
  }
#line 2398
  if ((unsigned long )count > sizeof(netperf_request) / 4UL) {
#line 2399
    if (debug > 1) {
      {
#line 2400
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"WARNING, htonl conversion count of %d was larger than netperf_request\n",
              count - 2);
#line 2403
      fflush(where);
      }
    }
#line 2405
    count = (int )(sizeof(netperf_request) / 4UL);
  }
#line 2411
  if (debug > 1) {
    {
#line 2412
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"entered send_request_n...contents before %d htonls:\n",
            count);
#line 2415
    dump_request();
    }
  }
#line 2423
  netperf_request.content.dummy = remote_proc_affinity;
#line 2431
  counter = 0;
  {
#line 2431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2431
    if (! (counter < count)) {
#line 2431
      goto while_break;
    }
    {
#line 2432
    tmp = htonl((uint32_t )*(request_array + counter));
#line 2432
    *(request_array + counter) = (int )tmp;
#line 2431
    counter ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2435
  if (debug > 1) {
    {
#line 2436
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"send_request_n...contents after %d htonls:\n",
            count);
#line 2438
    dump_request();
#line 2440
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"\nsend_request: about to send %u bytes from %p\n",
            (unsigned int )sizeof(netperf_request), & netperf_request);
#line 2444
    fflush(where);
    }
  }
  {
#line 2447
  tmp___0 = send(netlib_control, (void const   *)((char *)(& netperf_request)), sizeof(netperf_request),
                 0);
  }
#line 2447
  if ((unsigned long )tmp___0 != sizeof(netperf_request)) {
    {
#line 2451
    perror("send_request: send call failure");
#line 2453
    exit(1);
    }
  }
#line 2455
  return;
}
}
#line 2469 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void send_request(void) 
{ 


  {
  {
#line 2476
  netperf_request.content.dummy = remote_proc_affinity;
#line 2480
  send_request_n(-1);
  }
#line 2482
  return;
}
}
#line 2489 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void send_response_n(int n ) 
{ 
  int counter ;
  int count ;
  int bytes_sent___0 ;
  uint32_t tmp ;
  ssize_t tmp___0 ;

  {
#line 2495
  if (n < 0) {
#line 2495
    count = (int )(sizeof(netperf_request) / 4UL);
  } else {
#line 2496
    count = 2 + n;
  }
#line 2499
  if ((unsigned long )count > sizeof(netperf_request) / 4UL) {
#line 2500
    if (debug > 1) {
      {
#line 2501
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"WARNING, htonl conversion count of %d was larger than netperf_request\n",
              count - 2);
#line 2504
      fflush(where);
      }
    }
#line 2506
    count = (int )(sizeof(netperf_request) / 4UL);
  }
#line 2512
  if (debug > 1) {
    {
#line 2513
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"send_response_n: contents of %u ints before %d htonl,\n",
            (unsigned int )sizeof(netperf_response) / 4U, count);
#line 2517
    dump_response();
    }
  }
#line 2526
  counter = 0;
  {
#line 2526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2526
    if (! (counter < count)) {
#line 2526
      goto while_break;
    }
    {
#line 2527
    tmp = htonl((uint32_t )*(response_array + counter));
#line 2527
    *(response_array + counter) = (int )tmp;
#line 2526
    counter ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2530
  if (debug > 1) {
    {
#line 2531
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"send_response_n: contents after htonl\n");
#line 2533
    dump_response();
#line 2534
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"about to send %u bytes from %p\n",
            (unsigned int )sizeof(netperf_response), & netperf_response);
#line 2538
    fflush(where);
    }
  }
  {
#line 2542
  tmp___0 = send(server_sock, (void const   *)((char *)(& netperf_response)), sizeof(netperf_response),
                 0);
#line 2542
  bytes_sent___0 = (int )tmp___0;
  }
#line 2542
  if ((unsigned long )bytes_sent___0 != sizeof(netperf_response)) {
    {
#line 2546
    perror("send_response_n: send call failure");
#line 2547
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"BytesSent: %d\n",
            bytes_sent___0);
#line 2548
    exit(1);
    }
  }
#line 2551
  return;
}
}
#line 2565 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void send_response(void) 
{ 


  {
  {
#line 2569
  send_response_n(-1);
  }
#line 2571
  return;
}
}
#line 2575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void fixup_request_n(int n ) 
{ 
  int i ;
  int limit ;
  uint32_t tmp ;

  {
#line 2581
  limit = (int )(sizeof(netperf_request) / 4UL);
#line 2585
  i = n + 2;
  {
#line 2585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2585
    if (! (i < limit)) {
#line 2585
      goto while_break;
    }
    {
#line 2586
    tmp = htonl((uint32_t )*(request_array + i));
#line 2586
    *(request_array + i) = (int )tmp;
#line 2585
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2588
  if (debug > 1) {
    {
#line 2589
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: request contents after fixup at the %d th int\n",
            "fixup_request_n", n);
#line 2593
    dump_request();
#line 2594
    fflush(where);
    }
  }
#line 2596
  return;
}
}
#line 2603 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int recv_request_timed_n(int n , int seconds ) 
{ 
  int tot_bytes_recvd ;
  int bytes_recvd ;
  int bytes_left ;
  char *buf ;
  int buflen ;
  int counter ;
  int count ;
  fd_set readfds ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  struct timeval *tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  uint32_t tmp___5 ;
  int *tmp___6 ;

  {
#line 2609
  buf = (char *)(& netperf_request);
#line 2610
  buflen = (int )sizeof(netperf_request);
#line 2616
  if (n < 0) {
#line 2616
    count = (int )(sizeof(netperf_request) / 4UL);
  } else {
#line 2617
    count = 2 + n;
  }
#line 2620
  if ((unsigned long )count > sizeof(netperf_request) / 4UL) {
#line 2621
    if (debug > 1) {
      {
#line 2622
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"WARNING, htonl conversion count of %d was larger than netperf_request\n",
              count - 2);
#line 2625
      fflush(where);
      }
    }
#line 2627
    count = (int )(sizeof(netperf_request) / 4UL);
  }
#line 2634
  tot_bytes_recvd = 0;
#line 2635
  bytes_recvd = 0;
#line 2636
  bytes_left = buflen;
#line 2637
  timeout.tv_sec = (__time_t )seconds;
#line 2638
  timeout.tv_usec = (__suseconds_t )0;
  {
#line 2639
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2640
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2640
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 2640
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2641
    readfds.__fds_bits[server_sock / (8 * (int )sizeof(__fd_mask ))] |= 1L << server_sock % (8 * (int )sizeof(__fd_mask ));
#line 2642
    if (seconds > 0) {
#line 2642
      tmp___2 = & timeout;
    } else {
#line 2642
      tmp___2 = (struct timeval *)((void *)0);
    }
    {
#line 2642
    tmp___3 = select(1024, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)tmp___2);
    }
#line 2642
    if (tmp___3 != 1) {
      {
#line 2647
      tmp = __errno_location();
#line 2647
      tmp___0 = strerror(*tmp);
#line 2647
      tmp___1 = __errno_location();
#line 2647
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Issue receiving request on control connection. Errno %d (%s)\n",
              *tmp___1, tmp___0);
#line 2651
      fflush(where);
#line 2652
      close(server_sock);
      }
#line 2653
      return (-1);
    }
    {
#line 2656
    tmp___4 = recv(server_sock, (void *)buf, (size_t )bytes_left, 0);
#line 2656
    bytes_recvd = (int )tmp___4;
    }
#line 2656
    if (bytes_recvd > 0) {
#line 2657
      tot_bytes_recvd += bytes_recvd;
#line 2658
      buf += bytes_recvd;
#line 2659
      bytes_left -= bytes_recvd;
    }
#line 2639
    if (tot_bytes_recvd != buflen) {
#line 2639
      if (! (bytes_recvd > 0)) {
#line 2639
        goto while_break;
      }
    } else {
#line 2639
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2666
  counter = 0;
  {
#line 2666
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2666
    if (! (counter < count)) {
#line 2666
      goto while_break___1;
    }
    {
#line 2667
    tmp___5 = ntohl((uint32_t )*(request_array + counter));
#line 2667
    *(request_array + counter) = (int )tmp___5;
#line 2666
    counter ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2670
  if (debug) {
    {
#line 2671
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_request: received %d bytes of request.\n",
            tot_bytes_recvd);
#line 2674
    fflush(where);
    }
  }
#line 2677
  if (bytes_recvd == -1) {
    {
#line 2678
    tmp___6 = __errno_location();
#line 2678
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s  errno %d\n",
            "recv_request: error on recv", *tmp___6);
#line 2680
    fflush(where);
#line 2681
    close(server_sock);
    }
#line 2682
    return (-1);
  }
#line 2685
  if (bytes_recvd == 0) {
#line 2688
    if (debug) {
      {
#line 2689
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_request: remote requested shutdown of control\n");
#line 2691
      fflush(where);
      }
    }
    {
#line 2694
    close(server_sock);
    }
#line 2695
    return (0);
  }
#line 2698
  if (tot_bytes_recvd < buflen) {
#line 2699
    if (debug > 1) {
      {
#line 2700
      dump_request();
      }
    }
    {
#line 2702
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_request: partial request received of %d bytes\n",
            tot_bytes_recvd);
#line 2705
    fflush(where);
#line 2706
    close(server_sock);
    }
#line 2707
    return (-1);
  }
#line 2710
  if (debug > 1) {
    {
#line 2711
    dump_request();
    }
  }
#line 2717
  local_proc_affinity = netperf_request.content.dummy;
#line 2719
  if (local_proc_affinity != -1) {
    {
#line 2720
    bind_to_specific_processor(local_proc_affinity, 0);
    }
  }
#line 2723
  return (buflen);
}
}
#line 2731 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int recv_request_n(int n ) 
{ 
  int tmp ;

  {
  {
#line 2735
  tmp = recv_request_timed_n(n, 0);
  }
#line 2735
  return (tmp);
}
}
#line 2751 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int recv_request(void) 
{ 
  int tmp ;

  {
  {
#line 2755
  tmp = recv_request_n(-1);
  }
#line 2755
  return (tmp);
}
}
#line 2759 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void recv_response_timed_n(int addl_time , int n ) 
{ 
  int tot_bytes_recvd ;
  int bytes_recvd ;
  int bytes_left ;
  char *buf ;
  int buflen ;
  int counter ;
  int count ;
  fd_set readfds ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  ssize_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 2762
  bytes_recvd = 0;
#line 2765
  buf = (char *)(& netperf_response);
#line 2766
  buflen = (int )sizeof(netperf_response);
#line 2773
  tot_bytes_recvd = 0;
#line 2774
  bytes_left = buflen;
#line 2776
  if (n < 0) {
#line 2776
    count = (int )(sizeof(netperf_request) / 4UL);
  } else {
#line 2777
    count = 2 + n;
  }
#line 2780
  if ((unsigned long )count > sizeof(netperf_request) / 4UL) {
#line 2781
    if (debug > 1) {
      {
#line 2782
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"WARNING, htonl conversion count of %d was larger than netperf_response\n",
              count - 2);
#line 2785
      fflush(where);
      }
    }
#line 2787
    count = (int )(sizeof(netperf_request) / 4UL);
  }
#line 2793
  counter = 0;
  {
#line 2793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2793
    if (! ((unsigned long )counter < sizeof(netperf_response) / sizeof(int ))) {
#line 2793
      goto while_break;
    }
#line 2796
    *(response_array + counter) = 0;
#line 2793
    counter ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2803
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2803
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readfds.__fds_bits[0]): "memory");
#line 2803
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2804
  readfds.__fds_bits[netlib_control / (8 * (int )sizeof(__fd_mask ))] |= 1L << netlib_control % (8 * (int )sizeof(__fd_mask ));
#line 2805
  timeout.tv_sec = (__time_t )(120 + addl_time);
#line 2813
  timeout.tv_usec = (__suseconds_t )0;
#line 2818
  counter = select(1024, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)0,
                   (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& timeout));
  }
#line 2818
  if (counter != 1) {
    {
#line 2823
    tmp = __errno_location();
#line 2823
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: no response received. errno %d counter %d\n",
            "recv_response_timed_n", *tmp, counter);
#line 2828
    exit(1);
    }
  }
  {
#line 2831
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2831
    if (tot_bytes_recvd != buflen) {
      {
#line 2831
      tmp___0 = recv(netlib_control, (void *)buf, (size_t )bytes_left, 0);
#line 2831
      bytes_recvd = (int )tmp___0;
      }
#line 2831
      if (! (bytes_recvd > 0)) {
#line 2831
        goto while_break___1;
      }
    } else {
#line 2831
      goto while_break___1;
    }
#line 2833
    tot_bytes_recvd += bytes_recvd;
#line 2834
    buf += bytes_recvd;
#line 2835
    bytes_left -= bytes_recvd;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2838
  if (debug) {
    {
#line 2839
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"recv_response: received a %d byte response\n",
            tot_bytes_recvd);
#line 2841
    fflush(where);
    }
  }
#line 2846
  counter = 0;
  {
#line 2846
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2846
    if (! (counter < count)) {
#line 2846
      goto while_break___2;
    }
    {
#line 2847
    tmp___1 = ntohl((uint32_t )*(response_array + counter));
#line 2847
    *(response_array + counter) = (int )tmp___1;
#line 2846
    counter ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2850
  if (bytes_recvd == -1) {
    {
#line 2851
    perror("recv_response");
#line 2852
    exit(1);
    }
  }
#line 2854
  if (tot_bytes_recvd < buflen) {
    {
#line 2855
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"recv_response: partial response received: %d bytes\n",
            tot_bytes_recvd);
#line 2858
    fflush(stderr);
    }
#line 2859
    if (debug > 1) {
      {
#line 2860
      dump_response();
      }
    }
    {
#line 2861
    exit(1);
    }
  }
#line 2863
  if (debug > 1) {
    {
#line 2864
    dump_response();
    }
  }
#line 2866
  return;
}
}
#line 2898 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void recv_response_timed(int addl_time ) 
{ 


  {
  {
#line 2903
  recv_response_timed_n(addl_time, -1);
  }
#line 2905
  return;
}
}
#line 2907 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void recv_response(void) 
{ 


  {
  {
#line 2911
  recv_response_timed_n(0, -1);
  }
#line 2912
  return;
}
}
#line 2914 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void recv_response_n(int n ) 
{ 


  {
  {
#line 2917
  recv_response_timed_n(0, n);
  }
#line 2918
  return;
}
}
#line 2920 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void get_remote_system_info(void) 
{ 
  char delim[2] ;
  char *token ;

  {
  {
#line 2926
  netperf_request.content.request_type = 600;
#line 2927
  send_request();
#line 2928
  recv_response_n(0);
  }
#line 2929
  if (! netperf_response.content.serv_errno) {
    {
#line 2930
    delim[1] = (char )'\000';
#line 2931
    delim[0] = *((char *)(netperf_response.content.test_specific_data));
#line 2938
    token = strtok((char */* __restrict  */)((char *)(netperf_response.content.test_specific_data)),
                   (char const   */* __restrict  */)(delim));
    }
#line 2939
    if (token) {
      {
#line 2939
      remote_sysname = strdup((char const   *)token);
      }
    } else {
      {
#line 2940
      remote_sysname = strdup("UnknownRemoteSysname");
      }
    }
    {
#line 2941
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)(delim));
    }
#line 2942
    if (token) {
      {
#line 2942
      remote_release = strdup((char const   *)token);
      }
    } else {
      {
#line 2943
      remote_release = strdup("UnknownRemoteRelease");
      }
    }
    {
#line 2944
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)(delim));
    }
#line 2945
    if (token) {
      {
#line 2945
      remote_machine = strdup((char const   *)token);
      }
    } else {
      {
#line 2946
      remote_machine = strdup("UnknownRemoteMachine");
      }
    }
    {
#line 2947
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)(delim));
    }
#line 2948
    if (token) {
      {
#line 2948
      remote_version = strdup((char const   *)token);
      }
    } else {
      {
#line 2949
      remote_version = strdup("UnknownRemoteVersion");
      }
    }
  } else {
    {
#line 2952
    remote_sysname = strdup("UnknownRemoteSysname");
#line 2953
    remote_release = strdup("UnknownRemoteRelease");
#line 2954
    remote_machine = strdup("UnknownRemoteMachine");
#line 2955
    remote_version = strdup("UnknownRemoteVersion");
    }
  }
#line 2958
  return;
}
}
#line 3008 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void libmain(void) 
{ 


  {
  {
#line 3010
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"hello world\n");
#line 3011
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"debug: %d\n",
          debug);
  }
#line 3012
  return;
}
}
#line 3015 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void get_sock_buffer(int sd , enum sock_buffer which , int *effective_sizep ) 
{ 
  int optname ;
  int tmp ;
  unsigned int sock_opt_len ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 3019
  if ((unsigned int )which == 0U) {
#line 3019
    tmp = 7;
  } else {
#line 3019
    tmp = 8;
  }
  {
#line 3019
  optname = tmp;
#line 3022
  sock_opt_len = (unsigned int )sizeof(*effective_sizep);
#line 3023
  tmp___2 = getsockopt(sd, 1, optname, (void */* __restrict  */)((char *)effective_sizep),
                       (socklen_t */* __restrict  */)(& sock_opt_len));
  }
#line 3023
  if (tmp___2 < 0) {
    {
#line 3025
    tmp___0 = __errno_location();
    }
#line 3025
    if ((unsigned int )which == 0U) {
#line 3025
      tmp___1 = "SO_SNDBUF";
    } else {
#line 3025
      tmp___1 = "SO_RCVBUF";
    }
    {
#line 3025
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: get_sock_buffer: getsockopt %s: errno %d\n",
            tmp___1, *tmp___0);
#line 3027
    fflush(where);
#line 3028
    *effective_sizep = -1;
    }
  }
#line 3031
  if (debug) {
#line 3032
    if ((unsigned int )which == 0U) {
#line 3032
      tmp___3 = "send";
    } else {
#line 3032
      tmp___3 = "receive";
    }
    {
#line 3032
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: get_sock_buffer: %s socket size determined to be %d\n",
            tmp___3, *effective_sizep);
#line 3035
    fflush(where);
    }
  }
#line 3041
  return;
}
}
#line 3043 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void set_sock_buffer(int sd , enum sock_buffer which , int requested_size , int *effective_sizep ) 
{ 
  int optname ;
  int tmp ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 3047
  if ((unsigned int )which == 0U) {
#line 3047
    tmp = 7;
  } else {
#line 3047
    tmp = 8;
  }
#line 3047
  optname = tmp;
#line 3055
  if (requested_size >= 0) {
    {
#line 3056
    tmp___2 = setsockopt(sd, 1, optname, (void const   *)((char *)(& requested_size)),
                         (socklen_t )sizeof(int ));
    }
#line 3056
    if (tmp___2 < 0) {
      {
#line 3058
      tmp___0 = __errno_location();
      }
#line 3058
      if ((unsigned int )which == 0U) {
#line 3058
        tmp___1 = "SO_SNDBUF";
      } else {
#line 3058
        tmp___1 = "SO_RCVBUF";
      }
      {
#line 3058
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: set_sock_buffer: %s option: errno %d\n",
              tmp___1, *tmp___0);
#line 3061
      fflush(where);
#line 3062
      exit(1);
      }
    }
#line 3064
    if (debug > 1) {
#line 3065
      if ((unsigned int )which == 0U) {
#line 3065
        tmp___3 = "SO_SNDBUF";
      } else {
#line 3065
        tmp___3 = "SO_RCVBUF";
      }
      {
#line 3065
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: set_sock_buffer: %s of %d requested.\n",
              tmp___3, requested_size);
#line 3068
      fflush(where);
      }
    }
  }
  {
#line 3077
  get_sock_buffer(sd, which, effective_sizep);
  }
#line 3082
  return;
}
}
#line 3084 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void dump_addrinfo(FILE *dumploc , struct addrinfo *info , char const   *host , char *port ,
                   int family ) 
{ 
  struct sockaddr *ai_addr ;
  struct addrinfo *temp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int i ;
  char *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 3090
  temp = info;
#line 3092
  tmp = inet_ftos(family);
#line 3092
  fprintf((FILE */* __restrict  */)dumploc, (char const   */* __restrict  */)"getaddrinfo returned the following for host \'%s\' port \'%s\'  family %s\n",
          host, port, tmp);
  }
  {
#line 3099
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3099
    if (! temp) {
#line 3099
      goto while_break;
    }
    {
#line 3105
    tmp___0 = inet_ptos(temp->ai_protocol);
#line 3105
    tmp___1 = inet_ttos(temp->ai_socktype);
#line 3105
    tmp___2 = inet_ftos(temp->ai_family);
    }
#line 3105
    if (temp->ai_canonname) {
#line 3105
      tmp___3 = (char const   *)temp->ai_canonname;
    } else {
#line 3105
      tmp___3 = "(nil)";
    }
    {
#line 3105
    fprintf((FILE */* __restrict  */)dumploc, (char const   */* __restrict  */)"\tcannonical name: \'%s\'\n\tflags: %x family: %s: socktype: %s protocol %s addrlen %d\n",
            tmp___3, temp->ai_flags, tmp___2, tmp___1, tmp___0, temp->ai_addrlen);
#line 3114
    ai_addr = temp->ai_addr;
    }
#line 3115
    if ((unsigned long )ai_addr != (unsigned long )((void *)0)) {
      {
#line 3117
      tmp___4 = inet_ftos((int )ai_addr->sa_family);
#line 3117
      fprintf((FILE */* __restrict  */)dumploc, (char const   */* __restrict  */)"\tsa_family: %s sadata:",
              tmp___4);
#line 3120
      i = 0;
      }
      {
#line 3120
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3120
        if (! (i < (int )temp->ai_addrlen)) {
#line 3120
          goto while_break___0;
        }
#line 3121
        if (temp->ai_family == 2) {
#line 3121
          tmp___5 = " %d";
        } else {
#line 3121
          tmp___5 = " %.2x";
        }
        {
#line 3121
        fprintf((FILE */* __restrict  */)dumploc, (char const   */* __restrict  */)tmp___5,
                (int )((u_char )ai_addr->sa_data[i]));
#line 3120
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 3125
      fprintf((FILE */* __restrict  */)dumploc, (char const   */* __restrict  */)"\n");
      }
    }
#line 3127
    temp = temp->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3129
  fflush(dumploc);
  }
#line 3130
  return;
}
}
#line 3132 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
struct addrinfo *resolve_host(char *hostname , char *port , int family ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *ai ;
  int count ;
  int error ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
#line 3142
  if (debug) {
    {
#line 3143
    tmp = inet_ftos(family);
#line 3143
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"resolve_host called with host \'%s\' port \'%s\' family %s\n",
            hostname, port, tmp);
#line 3148
    fflush(where);
    }
  }
  {
#line 3151
  memset((void *)(& hints), 0, sizeof(hints));
#line 3152
  hints.ai_family = family;
#line 3153
  hints.ai_socktype = 1;
#line 3154
  hints.ai_protocol = 6;
#line 3155
  hints.ai_flags = 34;
#line 3156
  count = 0;
  }
  {
#line 3157
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3158
    error = getaddrinfo((char const   */* __restrict  */)hostname, (char const   */* __restrict  */)port,
                        (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& ai));
#line 3162
    count ++;
    }
#line 3163
    if (error == -3) {
#line 3164
      if (debug) {
        {
#line 3165
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Sleeping on getaddrinfo EAI_AGAIN\n");
#line 3166
        fflush(where);
        }
      }
      {
#line 3168
      sleep(1U);
      }
    }
#line 3157
    if (error == -3) {
#line 3157
      if (! (count <= 5)) {
#line 3157
        goto while_break;
      }
    } else {
#line 3157
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3172
  if (error) {
    {
#line 3173
    tmp___0 = gai_strerror(error);
#line 3173
    tmp___1 = inet_ftos(family);
#line 3173
    printf((char const   */* __restrict  */)"%s: could not resolve host \'%s\' port \'%s\' af %s\n\tgetaddrinfo returned %d %s\n",
           "resolve_host", hostname, port, tmp___1, error, tmp___0);
    }
#line 3181
    return ((struct addrinfo *)((void *)0));
  }
#line 3184
  if (debug) {
    {
#line 3185
    dump_addrinfo(where, ai, (char const   *)hostname, port, family);
    }
  }
#line 3188
  return (ai);
}
}
#line 3213 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int establish_control_internal(char *hostname , char *port , int remfam , char *localhost ,
                               char *localport , int locfam ) 
{ 
  int not_connected ;
  int control_sock ;
  struct addrinfo *local_res ;
  struct addrinfo *remote_res ;
  struct addrinfo *local_res_temp ;
  struct addrinfo *remote_res_temp ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 3229
  remote_res = resolve_host(hostname, port, remfam);
  }
#line 3230
  if (! remote_res) {
#line 3231
    return (-1);
  }
  {
#line 3233
  local_res = resolve_host(localhost, localport, locfam);
  }
#line 3234
  if (! local_res) {
#line 3235
    return (-1);
  }
#line 3237
  if (debug) {
    {
#line 3238
    tmp = inet_ftos(locfam);
#line 3238
    tmp___0 = inet_ftos(remfam);
#line 3238
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"establish_control called with host \'%s\' port \'%s\' remfam %s\n\t\tlocal \'%s\' port \'%s\' locfam %s\n",
            hostname, port, tmp___0, localhost, localport, tmp);
#line 3247
    fflush(where);
    }
  }
#line 3250
  not_connected = 1;
#line 3251
  local_res_temp = local_res;
#line 3252
  remote_res_temp = remote_res;
  {
#line 3258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3258
    if (! ((unsigned long )remote_res_temp != (unsigned long )((void *)0))) {
#line 3258
      goto while_break;
    }
    {
#line 3265
    control_sock = socket(local_res_temp->ai_family, 1, 0);
    }
#line 3268
    if (control_sock == -1) {
#line 3274
      if (debug) {
        {
#line 3275
        perror("establish_control: unable to allocate control socket");
        }
      }
#line 3277
      return (-1);
    }
    {
#line 3283
    tmp___8 = bind(control_sock, (struct sockaddr  const  *)local_res_temp->ai_addr,
                   local_res_temp->ai_addrlen);
    }
#line 3283
    if (tmp___8 == 0) {
#line 3286
      if (debug) {
        {
#line 3287
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"bound control socket to %s and %s\n",
                localhost, localport);
        }
      }
      {
#line 3293
      tmp___4 = connect(control_sock, (struct sockaddr  const  *)remote_res_temp->ai_addr,
                        remote_res_temp->ai_addrlen);
      }
#line 3293
      if (tmp___4 == 0) {
#line 3297
        if (debug) {
          {
#line 3298
          fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"successful connection to remote netserver at %s and %s\n",
                  hostname, port);
          }
        }
#line 3303
        not_connected = 0;
#line 3305
        goto while_break;
      } else
#line 3308
      if (debug) {
        {
#line 3309
        tmp___1 = __errno_location();
#line 3309
        tmp___2 = strerror(*tmp___1);
#line 3309
        tmp___3 = __errno_location();
#line 3309
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"establish_control: connect failed, errno %d %s\n    trying next address combination\n",
                *tmp___3, tmp___2);
#line 3314
        fflush(where);
        }
      }
    } else
#line 3320
    if (debug) {
      {
#line 3321
      tmp___5 = __errno_location();
#line 3321
      tmp___6 = strerror(*tmp___5);
#line 3321
      tmp___7 = __errno_location();
#line 3321
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"establish_control: bind failed, errno %d %s\n    trying next address combination\n",
              *tmp___7, tmp___6);
#line 3326
      fflush(where);
      }
    }
#line 3330
    local_res_temp = local_res_temp->ai_next;
#line 3330
    if ((unsigned long )local_res_temp == (unsigned long )((void *)0)) {
#line 3333
      local_res_temp = local_res;
#line 3336
      remote_res_temp = remote_res_temp->ai_next;
    }
    {
#line 3342
    close(control_sock);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3345
  control_family = local_res_temp->ai_family;
#line 3348
  freeaddrinfo(local_res);
#line 3349
  freeaddrinfo(remote_res);
  }
#line 3352
  if (not_connected) {
    {
#line 3353
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"establish control: are you sure there is a netserver listening on %s at port %s?\n",
            hostname, port);
#line 3358
    fflush(where);
#line 3359
    control_family = 0;
    }
#line 3360
    return (-1);
  }
#line 3364
  return (control_sock);
}
}
#line 3367 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void establish_control(char *hostname , char *port , int remfam , char *localhost ,
                       char *localport , int locfam ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 3377
  netlib_control = establish_control_internal(hostname, port, remfam, localhost, localport,
                                              locfam);
  }
#line 3383
  if (netlib_control == -1) {
    {
#line 3384
    tmp = inet_ftos(remfam);
#line 3384
    tmp___0 = inet_ftos(locfam);
#line 3384
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"establish_control could not establish the control connection from %s port %s address family %s to %s port %s address family %s\n",
            localhost, localport, tmp___0, hostname, port, tmp);
#line 3390
    fflush(where);
#line 3391
    exit(-1);
    }
  }
#line 3393
  return;
}
}
#line 3412 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
static char id_string[80]  ;
#line 3409 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
char *get_id(void) 
{ 
  struct utsname system_name ;
  int tmp ;

  {
  {
#line 3426
  tmp = uname(& system_name);
  }
#line 3426
  if (tmp < 0) {
    {
#line 3427
    perror("identify_local: uname");
#line 3428
    exit(1);
    }
  }
  {
#line 3432
  snprintf((char */* __restrict  */)(id_string), sizeof(id_string), (char const   */* __restrict  */)"%-15s%-15s%-15s%-15s%-15s",
           system_name.sysname, system_name.nodename, system_name.release, system_name.version,
           system_name.machine);
  }
#line 3450
  return (id_string);
}
}
#line 3466 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void identify_local(void) 
{ 
  char *local_id ;

  {
  {
#line 3472
  local_id = get_id();
#line 3474
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Local Information \nSysname       Nodename       Release        Version        Machine\n");
#line 3477
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s\n",
          local_id);
  }
#line 3480
  return;
}
}
#line 3497 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void identify_remote(void) 
{ 
  char *remote_id ;
  int *tmp ;

  {
  {
#line 3501
  remote_id = (char *)"";
#line 3504
  netperf_request.content.request_type = 4;
#line 3506
  send_request();
#line 3510
  recv_response();
  }
#line 3512
  if (netperf_response.content.serv_errno) {
    {
#line 3513
    tmp = __errno_location();
#line 3513
    *tmp = netperf_response.content.serv_errno;
#line 3514
    perror("identify_remote: on remote");
#line 3515
    exit(1);
    }
  }
  {
#line 3518
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Remote Information \nSysname       Nodename       Release        Version        Machine\n");
#line 3521
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s", remote_id);
  }
#line 3523
  return;
}
}
#line 3525 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void cpu_start(int measure_cpu ) 
{ 


  {
  {
#line 3529
  gettimeofday((struct timeval */* __restrict  */)(& time1), (__timezone_ptr_t )(& tz));
  }
#line 3532
  if (measure_cpu) {
    {
#line 3533
    cpu_util_init();
#line 3534
    measuring_cpu = 1;
#line 3535
    cpu_method = get_cpu_method();
#line 3536
    cpu_start_internal();
    }
  }
#line 3538
  return;
}
}
#line 3541 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void cpu_stop(int measure_cpu , float *elapsed ) 
{ 
  int sec ;
  int usec ;

  {
#line 3549
  if (measure_cpu) {
    {
#line 3550
    cpu_stop_internal();
#line 3551
    cpu_util_terminate();
    }
  }
  {
#line 3554
  gettimeofday((struct timeval */* __restrict  */)(& time2), (__timezone_ptr_t )(& tz));
  }
#line 3557
  if (time2.tv_usec < time1.tv_usec) {
#line 3558
    time2.tv_usec += 1000000L;
#line 3559
    (time2.tv_sec) --;
  }
#line 3562
  sec = (int )(time2.tv_sec - time1.tv_sec);
#line 3563
  usec = (int )(time2.tv_usec - time1.tv_usec);
#line 3564
  lib_elapsed = (float )sec + (float )usec / (float )1000000.0;
#line 3568
  *elapsed = lib_elapsed;
#line 3570
  return;
}
}
#line 3573 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double calc_thruput_interval(double units_received , double elapsed ) 
{ 
  double divisor ;

  {
  {
#line 3581
  if ((int )libfmt == 75) {
#line 3581
    goto case_75;
  }
#line 3584
  if ((int )libfmt == 77) {
#line 3584
    goto case_77;
  }
#line 3587
  if ((int )libfmt == 71) {
#line 3587
    goto case_71;
  }
#line 3590
  if ((int )libfmt == 107) {
#line 3590
    goto case_107;
  }
#line 3593
  if ((int )libfmt == 109) {
#line 3593
    goto case_109;
  }
#line 3596
  if ((int )libfmt == 103) {
#line 3596
    goto case_103;
  }
#line 3599
  if ((int )libfmt == 120) {
#line 3599
    goto case_120;
  }
#line 3603
  goto switch_default;
  case_75: /* CIL Label */ 
#line 3582
  divisor = 1024.0;
#line 3583
  goto switch_break;
  case_77: /* CIL Label */ 
#line 3585
  divisor = 1024.0 * 1024.0;
#line 3586
  goto switch_break;
  case_71: /* CIL Label */ 
#line 3588
  divisor = (1024.0 * 1024.0) * 1024.0;
#line 3589
  goto switch_break;
  case_107: /* CIL Label */ 
#line 3591
  divisor = 1000.0 / 8.0;
#line 3592
  goto switch_break;
  case_109: /* CIL Label */ 
#line 3594
  divisor = (1000.0 * 1000.0) / 8.0;
#line 3595
  goto switch_break;
  case_103: /* CIL Label */ 
#line 3597
  divisor = ((1000.0 * 1000.0) * 1000.0) / 8.0;
#line 3598
  goto switch_break;
  case_120: /* CIL Label */ 
#line 3600
  divisor = 1.0;
#line 3601
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3604
  divisor = 1024.0;
  switch_break: /* CIL Label */ ;
  }
#line 3607
  return ((units_received / divisor) / elapsed);
}
}
#line 3611 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double calc_thruput(double units_received ) 
{ 
  double tmp ;

  {
  {
#line 3615
  tmp = calc_thruput_interval(units_received, (double )lib_elapsed);
  }
#line 3615
  return (tmp);
}
}
#line 3623 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double calc_thruput_interval_omni(double units_received , double elapsed ) 
{ 
  double divisor ;

  {
  {
#line 3631
  if ((int )libfmt == 75) {
#line 3631
    goto case_75;
  }
#line 3634
  if ((int )libfmt == 77) {
#line 3634
    goto case_77;
  }
#line 3637
  if ((int )libfmt == 71) {
#line 3637
    goto case_71;
  }
#line 3640
  if ((int )libfmt == 107) {
#line 3640
    goto case_107;
  }
#line 3643
  if ((int )libfmt == 109) {
#line 3643
    goto case_109;
  }
#line 3646
  if ((int )libfmt == 103) {
#line 3646
    goto case_103;
  }
#line 3649
  if ((int )libfmt == 120) {
#line 3649
    goto case_120;
  }
#line 3653
  goto switch_default;
  case_75: /* CIL Label */ 
#line 3632
  divisor = 1024.0;
#line 3633
  goto switch_break;
  case_77: /* CIL Label */ 
#line 3635
  divisor = 1024.0 * 1024.0;
#line 3636
  goto switch_break;
  case_71: /* CIL Label */ 
#line 3638
  divisor = (1024.0 * 1024.0) * 1024.0;
#line 3639
  goto switch_break;
  case_107: /* CIL Label */ 
#line 3641
  divisor = 1000.0 / 8.0;
#line 3642
  goto switch_break;
  case_109: /* CIL Label */ 
#line 3644
  divisor = (1000.0 * 1000.0) / 8.0;
#line 3645
  goto switch_break;
  case_103: /* CIL Label */ 
#line 3647
  divisor = ((1000.0 * 1000.0) * 1000.0) / 8.0;
#line 3648
  goto switch_break;
  case_120: /* CIL Label */ 
#line 3650
  divisor = 1.0;
#line 3651
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 3654
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"WARNING calc_throughput_internal_omni: unknown units %c\n",
          (int )libfmt);
#line 3657
  fflush(where);
#line 3658
  divisor = 1024.0;
  }
  switch_break: /* CIL Label */ ;
  }
#line 3661
  return ((units_received / divisor) / elapsed);
}
}
#line 3665 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double calc_thruput_omni(double units_received ) 
{ 
  double tmp ;

  {
  {
#line 3669
  tmp = calc_thruput_interval_omni(units_received, (double )lib_elapsed);
  }
#line 3669
  return (tmp);
}
}
#line 3676 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
float calc_cpu_util(float elapsed_time___0 ) 
{ 
  float temp_util ;
  int i ;

  {
  {
#line 3681
  temp_util = calc_cpu_util_internal(elapsed_time___0);
#line 3684
  i = 0;
  }
  {
#line 3684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3684
    if (! (i < 256)) {
#line 3684
      goto while_break;
    }
#line 3685
    if ((double )lib_local_per_cpu_util[i] > lib_local_peak_cpu_util) {
#line 3686
      lib_local_peak_cpu_util = (double )lib_local_per_cpu_util[i];
#line 3687
      lib_local_peak_cpu_id = lib_cpu_map[i];
    }
#line 3684
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3691
  return (temp_util);
}
}
#line 3694 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
float calc_service_demand_internal(double unit_divisor , double units_sent , float elapsed_time___0 ,
                                   float cpu_utilization , int num_cpus ) 
{ 
  double service_demand ;
  double thruput___0 ;

  {
#line 3706
  if (debug) {
    {
#line 3707
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"calc_service_demand called:  units_sent = %f\n                             elapsed_time = %f\n                             cpu_util = %f\n                             num cpu = %d\n",
            units_sent, (double )elapsed_time___0, (double )cpu_utilization, num_cpus);
#line 3716
    fflush(where);
    }
  }
#line 3719
  if (num_cpus == 0) {
#line 3719
    num_cpus = lib_num_loc_cpus;
  }
#line 3721
  if ((double )elapsed_time___0 == 0.0) {
#line 3722
    elapsed_time___0 = lib_elapsed;
  }
#line 3724
  if ((double )cpu_utilization == 0.0) {
#line 3725
    cpu_utilization = lib_local_cpu_util;
  }
#line 3728
  thruput___0 = (units_sent / unit_divisor) / (double )elapsed_time___0;
#line 3742
  service_demand = (((double )cpu_utilization * 10000.0) / thruput___0) * (double )((float )num_cpus);
#line 3745
  if (debug) {
    {
#line 3746
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"calc_service_demand using:   units_sent = %f\n                             elapsed_time = %f\n                             cpu_util = %f\n                             num cpu = %d\ncalc_service_demand got:     thruput = %f\n                             servdem = %f\n",
            units_sent, (double )elapsed_time___0, (double )cpu_utilization, num_cpus,
            thruput___0, service_demand);
#line 3759
    fflush(where);
    }
  }
#line 3761
  return ((float )service_demand);
}
}
#line 3764 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
float calc_service_demand(double units_sent , float elapsed_time___0 , float cpu_utilization ,
                          int num_cpus ) 
{ 
  double unit_divisor ;
  float tmp ;

  {
  {
#line 3771
  unit_divisor = 1024.0;
#line 3773
  tmp = calc_service_demand_internal(unit_divisor, units_sent, elapsed_time___0, cpu_utilization,
                                     num_cpus);
  }
#line 3773
  return (tmp);
}
}
#line 3781 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
float calc_service_demand_fmt(double units_sent , float elapsed_time___0 , float cpu_utilization ,
                              int num_cpus ) 
{ 
  double unit_divisor ;
  float tmp ;

  {
#line 3789
  if (120 == (int )libfmt) {
#line 3789
    unit_divisor = 1.0;
  } else {
#line 3790
    unit_divisor = 1024.0;
  }
  {
#line 3792
  tmp = calc_service_demand_internal(unit_divisor, units_sent, elapsed_time___0, cpu_utilization,
                                     num_cpus);
  }
#line 3792
  return (tmp);
}
}
#line 3801 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
float calibrate_local_cpu(float local_cpu_rate___0 ) 
{ 


  {
  {
#line 3805
  lib_num_loc_cpus = get_num_cpus();
#line 3807
  lib_use_idle = 0;
  }
#line 3813
  if (local_cpu_rate___0 > (float )0) {
#line 3819
    lib_local_maxrate = local_cpu_rate___0;
  } else {
    {
#line 3825
    lib_local_maxrate = (float )0.0;
#line 3827
    lib_local_maxrate = calibrate_idle_rate(4, 10);
    }
  }
#line 3830
  return (lib_local_maxrate);
}
}
#line 3834 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
float calibrate_remote_cpu(void) 
{ 
  float remrate ;

  {
  {
#line 3839
  netperf_request.content.request_type = 5;
#line 3840
  send_request();
#line 3848
  recv_response_timed(40);
  }
#line 3850
  if (netperf_response.content.serv_errno) {
#line 3854
    return ((float )0.0);
  } else {
    {
#line 3858
    memcpy((void */* __restrict  */)((char *)(& remrate)), (void const   */* __restrict  */)((char *)(netperf_response.content.test_specific_data)),
           sizeof(remrate));
#line 3861
    memcpy((void */* __restrict  */)((char *)(& lib_num_rem_cpus)), (void const   */* __restrict  */)((char *)(netperf_response.content.test_specific_data) + sizeof(remrate)),
           sizeof(lib_num_rem_cpus));
    }
#line 3865
    return (remrate);
  }
}
}
#line 3876 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int msec_sleep(int msecs ) 
{ 
  int rval ;
  struct timeval timeout ;
  int *tmp ;

  {
  {
#line 3883
  timeout.tv_sec = (__time_t )(msecs / 1000);
#line 3884
  timeout.tv_usec = (__suseconds_t )((msecs - (msecs / 1000) * 1000) * 1000);
#line 3885
  rval = select(0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0,
                (struct timeval */* __restrict  */)(& timeout));
  }
#line 3885
  if (rval) {
    {
#line 3890
    tmp = __errno_location();
    }
#line 3890
    if (*tmp == 4) {
#line 3891
      return (1);
    }
    {
#line 3893
    perror("msec_sleep: select");
#line 3894
    exit(1);
    }
  }
#line 3896
  return (0);
}
}
#line 4148 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
HIST HIST_new_n(int max_outstanding ) 
{ 
  HIST h ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 4152
  tmp = malloc(sizeof(struct histogram_struct ));
#line 4152
  h = (HIST )tmp;
  }
#line 4152
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 4153
    perror("HIST_new_n - histogram_struct malloc failed");
#line 4154
    exit(1);
    }
  }
  {
#line 4156
  HIST_clear(h);
#line 4160
  h->limit = max_outstanding + 1;
#line 4171
  tmp___0 = malloc((unsigned long )h->limit * sizeof(struct timeval ));
#line 4171
  h->time_ones = (struct timeval *)tmp___0;
  }
#line 4174
  if ((unsigned long )h->time_ones == (unsigned long )((void *)0)) {
    {
#line 4175
    perror("HIST_new_n - time_ones malloc failed");
#line 4176
    exit(1);
    }
  }
#line 4179
  return (h);
}
}
#line 4182 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
HIST HIST_new(void) 
{ 
  HIST tmp ;

  {
  {
#line 4184
  tmp = HIST_new_n(0);
  }
#line 4184
  return (tmp);
}
}
#line 4188 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void HIST_clear(HIST h ) 
{ 
  int i ;

  {
#line 4191
  i = 0;
  {
#line 4191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4191
    if (! (i < 100)) {
#line 4191
      goto while_break;
    }
#line 4192
    h->unit_usec[i] = 0;
#line 4193
    h->ten_usec[i] = 0;
#line 4194
    h->hundred_usec[i] = 0;
#line 4195
    h->unit_msec[i] = 0;
#line 4196
    h->ten_msec[i] = 0;
#line 4197
    h->hundred_msec[i] = 0;
#line 4198
    h->unit_sec[i] = 0;
#line 4199
    h->ten_sec[i] = 0;
#line 4191
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4201
  h->ridiculous = 0;
#line 4202
  h->total = 0;
#line 4203
  h->sum = (int64_t )0;
#line 4204
  h->sumsquare = (double )0;
#line 4205
  h->hmin = 0;
#line 4206
  h->hmax = 0;
#line 4207
  h->limit = 0;
#line 4208
  h->count = 0;
#line 4209
  h->producer = 0;
#line 4210
  h->consumer = 0;
#line 4211
  h->time_ones = (struct timeval *)((void *)0);
#line 4212
  return;
}
}
#line 4214 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void HIST_purge(HIST h ) 
{ 


  {
#line 4216
  h->count = 0;
#line 4217
  h->producer = 0;
#line 4218
  h->consumer = 0;
#line 4219
  return;
}
}
#line 4221 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void HIST_add(HIST h , int time_delta ) 
{ 
  register float val ;
  register int base ;
  int tmp ;
  double tmp___0 ;

  {
#line 4224
  base = 10;
#line 4231
  if (time_delta < 0) {
#line 4232
    (h->ridiculous) ++;
#line 4233
    return;
  }
#line 4236
  if (! h->total) {
#line 4237
    tmp = time_delta;
#line 4237
    h->hmax = tmp;
#line 4237
    h->hmin = tmp;
  }
#line 4238
  (h->total) ++;
#line 4239
  h->sum += (int64_t )time_delta;
#line 4243
  if (keep_statistics) {
    {
#line 4244
    tmp___0 = pow((double )time_delta, (double )2);
#line 4244
    h->sumsquare += tmp___0;
    }
  }
#line 4246
  if (h->hmin < time_delta) {
#line 4246
    h->hmin = h->hmin;
  } else {
#line 4246
    h->hmin = time_delta;
  }
#line 4247
  if (h->hmax > time_delta) {
#line 4247
    h->hmax = h->hmax;
  } else {
#line 4247
    h->hmax = time_delta;
  }
#line 4248
  val = (float )time_delta;
#line 4249
  if (val < (float )10) {
#line 4249
    (h->unit_usec[(int )(val * (float )base)]) ++;
  } else {
#line 4251
    val /= (float )10;
#line 4252
    if (val < (float )10) {
#line 4252
      (h->ten_usec[(int )(val * (float )base)]) ++;
    } else {
#line 4254
      val /= (float )10;
#line 4255
      if (val < (float )10) {
#line 4255
        (h->hundred_usec[(int )(val * (float )base)]) ++;
      } else {
#line 4257
        val /= (float )10;
#line 4258
        if (val < (float )10) {
#line 4258
          (h->unit_msec[(int )(val * (float )base)]) ++;
        } else {
#line 4260
          val /= (float )10;
#line 4261
          if (val < (float )10) {
#line 4261
            (h->ten_msec[(int )(val * (float )base)]) ++;
          } else {
#line 4263
            val /= (float )10;
#line 4264
            if (val < (float )10) {
#line 4264
              (h->hundred_msec[(int )(val * (float )base)]) ++;
            } else {
#line 4266
              val /= (float )10;
#line 4267
              if (val < (float )10) {
#line 4267
                (h->unit_sec[(int )(val * (float )base)]) ++;
              } else {
#line 4269
                val /= (float )10;
#line 4270
                if (val < (float )10) {
#line 4270
                  (h->ten_sec[(int )(val * (float )base)]) ++;
                } else {
#line 4271
                  (h->ridiculous) ++;
                }
              }
            }
          }
        }
      }
    }
  }
#line 4279
  return;
}
}
#line 4281 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void output_row(FILE *fd , char *title , int *row ) 
{ 
  register int i ;
  register int j ;
  register int base ;
  register int sum ;

  {
  {
#line 4285
  base = 10;
#line 4287
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s", title);
#line 4288
  i = 0;
  }
  {
#line 4288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4288
    if (! (i < 10)) {
#line 4288
      goto while_break;
    }
#line 4289
    sum = 0;
#line 4290
    j = i * base;
    {
#line 4290
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4290
      if (! (j < (i + 1) * base)) {
#line 4290
        goto while_break___0;
      }
#line 4291
      sum += *(row + j);
#line 4290
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4293
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)": %4d",
            sum);
#line 4288
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4295
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"\n");
  }
#line 4296
  return;
}
}
#line 4298 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int sum_row(int *row ) 
{ 
  int sum ;
  int i ;

  {
#line 4300
  sum = 0;
#line 4302
  i = 0;
  {
#line 4302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4302
    if (! (i < 100)) {
#line 4302
      goto while_break;
    }
#line 4302
    sum += *(row + i);
#line 4302
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4303
  return (sum);
}
}
#line 4306 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void HIST_report(HIST h ) 
{ 


  {
  {
#line 4309
  output_row(stdout, (char *)"UNIT_USEC     ", h->unit_usec);
#line 4310
  output_row(stdout, (char *)"TEN_USEC      ", h->ten_usec);
#line 4311
  output_row(stdout, (char *)"HUNDRED_USEC  ", h->hundred_usec);
#line 4317
  output_row(stdout, (char *)"UNIT_MSEC     ", h->unit_msec);
#line 4318
  output_row(stdout, (char *)"TEN_MSEC      ", h->ten_msec);
#line 4319
  output_row(stdout, (char *)"HUNDRED_MSEC  ", h->hundred_msec);
#line 4320
  output_row(stdout, (char *)"UNIT_SEC      ", h->unit_sec);
#line 4321
  output_row(stdout, (char *)"TEN_SEC       ", h->ten_sec);
#line 4322
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)">100_SECS: %d\n",
          h->ridiculous);
#line 4323
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"HIST_TOTAL:      %d\n",
          h->total);
  }
#line 4324
  if (debug) {
    {
#line 4325
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"sum %li, sumsquare %f, limit %d count %d\n",
            h->sum, h->sumsquare, h->limit, h->count);
    }
  }
#line 4332
  return;
}
}
#line 4335 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int HIST_search_bucket(int *unit , int num , int *last , int *current , double scale ) 
{ 
  int base ;
  int i ;

  {
#line 4337
  base = 10;
#line 4339
  i = 0;
  {
#line 4339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4339
    if (! (i < 100)) {
#line 4339
      goto while_break;
    }
#line 4340
    *last = *current;
#line 4341
    *current += *(unit + i);
#line 4342
    if (*current >= num) {
#line 4343
      return ((int )((((double )i + (double )(num - *last) / (double )(*current - *last)) * scale) / (double )base));
    }
#line 4339
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4345
  return (0);
}
}
#line 4349 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int HIST_get_percentile(HIST h , double const   percentile ) 
{ 
  double win_kludge ;
  int num ;
  int last ;
  int current ;
  int result ;

  {
#line 4351
  win_kludge = (double )(percentile * (double const   )((double )h->total));
#line 4352
  num = (int )win_kludge;
#line 4353
  last = 0;
#line 4354
  current = 0;
#line 4357
  if (! num) {
#line 4358
    return (0);
  }
  {
#line 4361
  result = HIST_search_bucket(h->unit_usec, num, & last, & current, 1e0);
  }
#line 4362
  if (result) {
#line 4363
    return (result);
  }
  {
#line 4366
  result = HIST_search_bucket(h->ten_usec, num, & last, & current, 1e1);
  }
#line 4367
  if (result) {
#line 4368
    return (result);
  }
  {
#line 4371
  result = HIST_search_bucket(h->hundred_usec, num, & last, & current, 1e2);
  }
#line 4372
  if (result) {
#line 4373
    return (result);
  }
  {
#line 4376
  result = HIST_search_bucket(h->unit_msec, num, & last, & current, 1e3);
  }
#line 4377
  if (result) {
#line 4378
    return (result);
  }
  {
#line 4381
  result = HIST_search_bucket(h->ten_msec, num, & last, & current, 1e4);
  }
#line 4382
  if (result) {
#line 4383
    return (result);
  }
  {
#line 4386
  result = HIST_search_bucket(h->hundred_msec, num, & last, & current, 1e5);
  }
#line 4387
  if (result) {
#line 4388
    return (result);
  }
  {
#line 4391
  result = HIST_search_bucket(h->unit_sec, num, & last, & current, 1e6);
  }
#line 4392
  if (result) {
#line 4393
    return (result);
  }
  {
#line 4396
  result = HIST_search_bucket(h->ten_sec, num, & last, & current, 1e7);
  }
#line 4397
  if (result) {
#line 4398
    return (result);
  }
#line 4400
  return ((int )1e8);
}
}
#line 4405 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void HIST_get_stats(HIST h , int *min , int *max , double *mean , double *stddev ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
#line 4407
  *min = h->hmin;
#line 4408
  *max = h->hmax;
#line 4409
  if (h->total) {
    {
#line 4410
    *mean = (double )h->sum / (double )h->total;
#line 4411
    tmp = pow((double )h->sum, (double )2);
#line 4411
    tmp___0 = pow((double )h->total, (double )2);
#line 4411
    *stddev = (h->sumsquare * (double )h->total - tmp) / tmp___0;
#line 4413
    *stddev = sqrt(*stddev);
    }
  } else {
#line 4416
    *mean = (double )0;
#line 4417
    *stddev = (double )0;
  }
#line 4419
  return;
}
}
#line 4487 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void HIST_timestamp(struct timeval *timestamp ) 
{ 


  {
  {
#line 4490
  gettimeofday((struct timeval */* __restrict  */)timestamp, (__timezone_ptr_t )((void *)0));
  }
#line 4491
  return;
}
}
#line 4495 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int delta_micro(struct timeval *begin , struct timeval *end ) 
{ 
  int usecs ;
  int secs ;

  {
#line 4502
  if (end->tv_usec < begin->tv_usec) {
#line 4504
    end->tv_usec += 1000000L;
#line 4505
    (end->tv_sec) --;
  }
#line 4507
  usecs = (int )(end->tv_usec - begin->tv_usec);
#line 4508
  secs = (int )(end->tv_sec - begin->tv_sec);
#line 4510
  usecs += secs * 1000000;
#line 4512
  return (usecs);
}
}
#line 4517 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void HIST_timestamp_start(HIST h ) 
{ 


  {
#line 4520
  if ((unsigned long )((void *)0) == (unsigned long )h) {
    {
#line 4521
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"HIST_timestamp_start called with NULL histogram\n");
#line 4522
    fflush(where);
#line 4523
    exit(-1);
    }
  }
#line 4525
  if (h->count == h->limit) {
    {
#line 4526
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"HIST_timestamp_start called with full time_ones\n");
    }
  }
  {
#line 4529
  HIST_timestamp(h->time_ones + h->producer);
#line 4530
  (h->producer) ++;
#line 4531
  h->producer %= h->limit;
#line 4532
  (h->count) ++;
  }
#line 4535
  return;
}
}
#line 4538 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void HIST_timestamp_stop_add(HIST h ) 
{ 
  int tmp ;

  {
#line 4541
  if ((unsigned long )((void *)0) == (unsigned long )h) {
    {
#line 4542
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"HIST_timestamp_stop called with NULL histogram\n");
#line 4543
    fflush(where);
#line 4544
    exit(-1);
    }
  }
#line 4547
  if (h->consumer == h->producer) {
    {
#line 4548
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"HIST_timestamp_stop called with empty time_ones consumer %d producer %d\n",
            h->consumer, h->producer);
#line 4552
    fflush(where);
#line 4553
    exit(-1);
    }
  }
  {
#line 4556
  HIST_timestamp(& h->time_two);
#line 4559
  tmp = delta_micro(h->time_ones + h->consumer, & h->time_two);
#line 4559
  HIST_add(h, tmp);
#line 4560
  (h->consumer) ++;
#line 4561
  h->consumer %= h->limit;
#line 4562
  (h->count) --;
  }
#line 4564
  return;
}
}
#line 4573 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
int confidence_iterations  ;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double result_confid  =    - 10.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double loc_cpu_confid  =    - 10.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double rem_cpu_confid  =    - 10.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_sum_result  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_square_sum_result  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_mean_result  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_var_result  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_sum_local_cpu  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_square_sum_local_cpu  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_mean_local_cpu  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_var_local_cpu  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_sum_remote_cpu  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_square_sum_remote_cpu  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_mean_remote_cpu  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_var_remote_cpu  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_sum_local_service_demand  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_square_sum_local_service_demand  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_mean_local_service_demand  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_var_local_service_demand  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_sum_remote_service_demand  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_square_sum_remote_service_demand  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_mean_remote_service_demand  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_var_remote_service_demand  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_sum_local_time  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_square_sum_local_time  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_mean_local_time  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_var_local_time  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_mean_remote_time  =    0.0;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_fails  ;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double measured_local_results  ;
#line 4575 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double confidence  =    - 10.0;
#line 4622 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void init_stat(void) 
{ 


  {
#line 4625
  measured_sum_result = 0.0;
#line 4626
  measured_square_sum_result = 0.0;
#line 4627
  measured_mean_result = 0.0;
#line 4628
  measured_var_result = 0.0;
#line 4630
  measured_sum_local_cpu = 0.0;
#line 4631
  measured_square_sum_local_cpu = 0.0;
#line 4632
  measured_mean_local_cpu = 0.0;
#line 4633
  measured_var_local_cpu = 0.0;
#line 4635
  measured_sum_remote_cpu = 0.0;
#line 4636
  measured_square_sum_remote_cpu = 0.0;
#line 4637
  measured_mean_remote_cpu = 0.0;
#line 4638
  measured_var_remote_cpu = 0.0;
#line 4640
  measured_sum_local_service_demand = 0.0;
#line 4641
  measured_square_sum_local_service_demand = 0.0;
#line 4642
  measured_mean_local_service_demand = 0.0;
#line 4643
  measured_var_local_service_demand = 0.0;
#line 4645
  measured_sum_remote_service_demand = 0.0;
#line 4646
  measured_square_sum_remote_service_demand = 0.0;
#line 4647
  measured_mean_remote_service_demand = 0.0;
#line 4648
  measured_var_remote_service_demand = 0.0;
#line 4650
  measured_sum_local_time = 0.0;
#line 4651
  measured_square_sum_local_time = 0.0;
#line 4652
  measured_mean_local_time = 0.0;
#line 4653
  measured_var_local_time = 0.0;
#line 4655
  measured_mean_remote_time = 0.0;
#line 4657
  measured_fails = 0.0;
#line 4658
  measured_local_results = 0.0;
#line 4658
  confidence = - 10.0;
#line 4660
  return;
}
}
#line 4665 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double confid(int level , int freedom ) 
{ 
  double t99[35] ;
  double t95[35] ;

  {
#line 4670
  t95[1] = 12.706;
#line 4671
  t95[2] = 4.303;
#line 4672
  t95[3] = 3.182;
#line 4673
  t95[4] = 2.776;
#line 4674
  t95[5] = 2.571;
#line 4675
  t95[6] = 2.447;
#line 4676
  t95[7] = 2.365;
#line 4677
  t95[8] = 2.306;
#line 4678
  t95[9] = 2.262;
#line 4679
  t95[10] = 2.228;
#line 4680
  t95[11] = 2.201;
#line 4681
  t95[12] = 2.179;
#line 4682
  t95[13] = 2.160;
#line 4683
  t95[14] = 2.145;
#line 4684
  t95[15] = 2.131;
#line 4685
  t95[16] = 2.120;
#line 4686
  t95[17] = 2.110;
#line 4687
  t95[18] = 2.101;
#line 4688
  t95[19] = 2.093;
#line 4689
  t95[20] = 2.086;
#line 4690
  t95[21] = 2.080;
#line 4691
  t95[22] = 2.074;
#line 4692
  t95[23] = 2.069;
#line 4693
  t95[24] = 2.064;
#line 4694
  t95[25] = 2.060;
#line 4695
  t95[26] = 2.056;
#line 4696
  t95[27] = 2.052;
#line 4697
  t95[28] = 2.048;
#line 4698
  t95[29] = 2.045;
#line 4699
  t95[30] = 2.042;
#line 4701
  t99[1] = 63.657;
#line 4702
  t99[2] = 9.925;
#line 4703
  t99[3] = 5.841;
#line 4704
  t99[4] = 4.604;
#line 4705
  t99[5] = 4.032;
#line 4706
  t99[6] = 3.707;
#line 4707
  t99[7] = 3.499;
#line 4708
  t99[8] = 3.355;
#line 4709
  t99[9] = 3.250;
#line 4710
  t99[10] = 3.169;
#line 4711
  t99[11] = 3.106;
#line 4712
  t99[12] = 3.055;
#line 4713
  t99[13] = 3.012;
#line 4714
  t99[14] = 2.977;
#line 4715
  t99[15] = 2.947;
#line 4716
  t99[16] = 2.921;
#line 4717
  t99[17] = 2.898;
#line 4718
  t99[18] = 2.878;
#line 4719
  t99[19] = 2.861;
#line 4720
  t99[20] = 2.845;
#line 4721
  t99[21] = 2.831;
#line 4722
  t99[22] = 2.819;
#line 4723
  t99[23] = 2.807;
#line 4724
  t99[24] = 2.797;
#line 4725
  t99[25] = 2.787;
#line 4726
  t99[26] = 2.779;
#line 4727
  t99[27] = 2.771;
#line 4728
  t99[28] = 2.763;
#line 4729
  t99[29] = 2.756;
#line 4730
  t99[30] = 2.750;
#line 4732
  if (level == 95) {
#line 4733
    return (t95[freedom]);
  } else
#line 4734
  if (level == 99) {
#line 4735
    return (t99[freedom]);
  } else {
#line 4737
    return ((double )0);
  }
}
}
#line 4741 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void calculate_confidence(int confidence_iterations___0 , float time___0 , double result ,
                          float loc_cpu , float rem_cpu , float loc_sd , float rem_sd ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___6 ;
  double tmp___7 ;

  {
#line 4751
  if (debug) {
    {
#line 4752
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"calculate_confidence: itr  %d; time %f; res  %f\n                               lcpu %f; rcpu %f\n                               lsdm %f; rsdm %f\n",
            confidence_iterations___0, (double )time___0, result, (double )loc_cpu,
            (double )rem_cpu, (double )loc_sd, (double )rem_sd);
#line 4763
    fflush(where);
    }
  }
#line 4767
  measured_sum_local_time += (double )time___0;
#line 4769
  measured_square_sum_local_time += (double )time___0 * (double )time___0;
#line 4771
  measured_mean_local_time = measured_sum_local_time / (double )confidence_iterations___0;
#line 4773
  measured_var_local_time = measured_square_sum_local_time / (double )confidence_iterations___0 - measured_mean_local_time * measured_mean_local_time;
#line 4778
  measured_sum_result += result;
#line 4780
  measured_square_sum_result += result * result;
#line 4782
  measured_mean_result = measured_sum_result / (double )confidence_iterations___0;
#line 4784
  measured_var_result = measured_square_sum_result / (double )confidence_iterations___0 - measured_mean_result * measured_mean_result;
#line 4789
  measured_sum_local_cpu += (double )loc_cpu;
#line 4791
  measured_square_sum_local_cpu += (double )loc_cpu * (double )loc_cpu;
#line 4793
  measured_mean_local_cpu = measured_sum_local_cpu / (double )confidence_iterations___0;
#line 4795
  measured_var_local_cpu = measured_square_sum_local_cpu / (double )confidence_iterations___0 - measured_mean_local_cpu * measured_mean_local_cpu;
#line 4800
  measured_sum_remote_cpu += (double )rem_cpu;
#line 4802
  measured_square_sum_remote_cpu += (double )rem_cpu * (double )rem_cpu;
#line 4804
  measured_mean_remote_cpu = measured_sum_remote_cpu / (double )confidence_iterations___0;
#line 4806
  measured_var_remote_cpu = measured_square_sum_remote_cpu / (double )confidence_iterations___0 - measured_mean_remote_cpu * measured_mean_remote_cpu;
#line 4811
  measured_sum_local_service_demand += (double )loc_sd;
#line 4813
  measured_square_sum_local_service_demand += (double )loc_sd * (double )loc_sd;
#line 4815
  measured_mean_local_service_demand = measured_sum_local_service_demand / (double )confidence_iterations___0;
#line 4817
  measured_var_local_service_demand = measured_square_sum_local_service_demand / (double )confidence_iterations___0 - measured_mean_local_service_demand * measured_mean_local_service_demand;
#line 4822
  measured_sum_remote_service_demand += (double )rem_sd;
#line 4824
  measured_square_sum_remote_service_demand += (double )rem_sd * (double )rem_sd;
#line 4826
  measured_mean_remote_service_demand = measured_sum_remote_service_demand / (double )confidence_iterations___0;
#line 4828
  measured_var_remote_service_demand = measured_square_sum_remote_service_demand / (double )confidence_iterations___0 - measured_mean_remote_service_demand * measured_mean_remote_service_demand;
#line 4832
  if (confidence_iterations___0 > 1) {
    {
#line 4833
    tmp = confid(confidence_level, confidence_iterations___0 - 1);
#line 4833
    tmp___0 = sqrt(measured_var_result / ((double )confidence_iterations___0 - 1.0));
#line 4833
    result_confid = interval - ((2.0 * tmp) * tmp___0) / measured_mean_result;
#line 4838
    tmp___1 = confid(confidence_level, confidence_iterations___0 - 1);
#line 4838
    tmp___2 = sqrt(measured_var_local_cpu / ((double )confidence_iterations___0 - 1.0));
#line 4838
    loc_cpu_confid = interval - ((2.0 * tmp___1) * tmp___2) / measured_mean_local_cpu;
#line 4843
    tmp___3 = confid(confidence_level, confidence_iterations___0 - 1);
#line 4843
    tmp___4 = sqrt(measured_var_remote_cpu / ((double )confidence_iterations___0 - 1.0));
#line 4843
    rem_cpu_confid = interval - ((2.0 * tmp___3) * tmp___4) / measured_mean_remote_cpu;
    }
#line 4848
    if (debug) {
      {
#line 4849
      printf((char const   */* __restrict  */)"Conf_itvl %2d: results:%4.1f%% loc_cpu:%4.1f%% rem_cpu:%4.1f%%\n",
             confidence_iterations___0, (interval - result_confid) * 100.0, (interval - loc_cpu_confid) * 100.0,
             (interval - rem_cpu_confid) * 100.0);
      }
    }
#line 4859
    if (! result_confidence_only) {
#line 4860
      if (result_confid < loc_cpu_confid) {
#line 4860
        tmp___7 = result_confid;
      } else {
#line 4860
        tmp___7 = loc_cpu_confid;
      }
#line 4860
      if (tmp___7 < rem_cpu_confid) {
#line 4860
        if (result_confid < loc_cpu_confid) {
#line 4860
          tmp___6 = result_confid;
        } else {
#line 4860
          tmp___6 = loc_cpu_confid;
        }
#line 4860
        confidence = tmp___6;
      } else {
#line 4860
        confidence = rem_cpu_confid;
      }
    } else {
#line 4863
      confidence = result_confid;
    }
  }
#line 4866
  return;
}
}
#line 4870 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void retrieve_confident_values(float *elapsed_time___0 , double *thruput___0 , float *local_cpu_utilization___0 ,
                               float *remote_cpu_utilization___0 , float *local_service_demand___0 ,
                               float *remote_service_demand___0 ) 
{ 


  {
#line 4879
  *elapsed_time___0 = (float )measured_mean_local_time;
#line 4880
  *thruput___0 = measured_mean_result;
#line 4881
  *local_cpu_utilization___0 = (float )measured_mean_local_cpu;
#line 4882
  *remote_cpu_utilization___0 = (float )measured_mean_remote_cpu;
#line 4883
  *local_service_demand___0 = (float )measured_mean_local_service_demand;
#line 4884
  *remote_service_demand___0 = (float )measured_mean_remote_service_demand;
#line 4885
  return;
}
}
#line 4887 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double get_result_confid(void) 
{ 


  {
#line 4890
  return (100.0 * (interval - result_confid));
}
}
#line 4893 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double get_loc_cpu_confid(void) 
{ 


  {
#line 4896
  return (100.0 * (interval - loc_cpu_confid));
}
}
#line 4899 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
double get_rem_cpu_confid(void) 
{ 


  {
#line 4902
  return (100.0 * (interval - rem_cpu_confid));
}
}
#line 4908 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
void display_confidence(void) 
{ 


  {
  {
#line 4912
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"!!! WARNING\n!!! Desired confidence was not achieved within the specified iterations.\n!!! This implies that there was variability in the test environment that\n!!! must be investigated before going further.\n!!! Confidence intervals: Throughput      : %4.3f%%\n!!!                       Local CPU util  : %4.3f%%\n!!!                       Remote CPU util : %4.3f%%\n\n",
          100.0 * (interval - result_confid), 100.0 * (interval - loc_cpu_confid),
          100.0 * (interval - rem_cpu_confid));
  }
#line 4925
  return;
}
}
#line 2 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_sdp.c"
char nettest_sdp[76]  = 
#line 2 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_sdp.c"
  {      (char )'@',      (char )'(',      (char )'#',      (char )')', 
        (char )'n',      (char )'e',      (char )'t',      (char )'t', 
        (char )'e',      (char )'s',      (char )'t',      (char )'_', 
        (char )'s',      (char )'d',      (char )'p',      (char )'.', 
        (char )'c',      (char )' ',      (char )'(',      (char )'c', 
        (char )')',      (char )' ',      (char )'C',      (char )'o', 
        (char )'p',      (char )'y',      (char )'r',      (char )'i', 
        (char )'g',      (char )'h',      (char )'t',      (char )' ', 
        (char )'2',      (char )'0',      (char )'0',      (char )'7', 
        (char )'-',      (char )'2',      (char )'0',      (char )'1', 
        (char )'2',      (char )' ',      (char )'H',      (char )'e', 
        (char )'w',      (char )'l',      (char )'e',      (char )'t', 
        (char )'t',      (char )'-',      (char )'P',      (char )'a', 
        (char )'c',      (char )'k',      (char )'a',      (char )'r', 
        (char )'d',      (char )' ',      (char )'C',      (char )'o', 
        (char )'.',      (char )' ',      (char )'V',      (char )'e', 
        (char )'r',      (char )'s',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'2',      (char )'.', 
        (char )'6',      (char )'.',      (char )'0',      (char )'\000'};
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 279 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) rint)(double __x ) ;
#line 14 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsys_linux.c"
static void find_cpu_model(char **cpu_model ) 
{ 
  char linebuf[256] ;
  char *cret ;
  FILE *proccpu ;
  char *target ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 21
  proccpu = fopen((char const   */* __restrict  */)"/proc/cpuinfo", (char const   */* __restrict  */)"r");
  }
#line 23
  if ((unsigned long )((void *)0) == (unsigned long )proccpu) {
    {
#line 24
    *cpu_model = strdup("fopen");
    }
#line 25
    return;
  }
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 29
    cret = fgets((char */* __restrict  */)(linebuf), 256, (FILE */* __restrict  */)proccpu);
    }
#line 30
    if ((unsigned long )((void *)0) != (unsigned long )cret) {
      {
#line 33
      tmp___0 = strstr((char const   *)(linebuf), "model name");
      }
#line 33
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
        {
#line 35
        target = strtok((char */* __restrict  */)(linebuf), (char const   */* __restrict  */)":");
#line 37
        target = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
#line 39
        tmp = strlen((char const   *)target);
#line 39
        *(target + (tmp - 1UL)) = (char)0;
#line 41
        *cpu_model = strdup((char const   *)(target + 1));
#line 42
        fclose(proccpu);
        }
#line 43
        return;
      }
    }
    {
#line 28
    tmp___1 = feof(proccpu);
    }
#line 28
    if (tmp___1) {
#line 28
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  *cpu_model = strdup("model_name");
#line 48
  fclose(proccpu);
  }
#line 49
  return;
}
}
#line 51 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsys_linux.c"
static int find_cpu_freq(void) 
{ 
  char linebuf[256] ;
  char *cret ;
  FILE *proccpu ;
  char *target ;
  double tmp ;
  double tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 58
  proccpu = fopen((char const   */* __restrict  */)"/proc/cpuinfo", (char const   */* __restrict  */)"r");
  }
#line 60
  if ((unsigned long )((void *)0) == (unsigned long )proccpu) {
#line 61
    return (-1);
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 65
    cret = fgets((char */* __restrict  */)(linebuf), 256, (FILE */* __restrict  */)proccpu);
    }
#line 66
    if ((unsigned long )((void *)0) != (unsigned long )cret) {
      {
#line 69
      tmp___1 = strstr((char const   *)(linebuf), "cpu MHz");
      }
#line 69
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
#line 70
        target = strtok((char */* __restrict  */)(linebuf), (char const   */* __restrict  */)":");
#line 71
        target = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
#line 72
        fclose(proccpu);
#line 73
        tmp = strtod((char const   */* __restrict  */)(target + 1), (char **/* __restrict  */)((void *)0));
#line 73
        tmp___0 = rint(tmp);
        }
#line 73
        return ((int )tmp___0);
      }
    }
    {
#line 64
    tmp___2 = feof(proccpu);
    }
#line 64
    if (tmp___2) {
#line 64
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  fclose(proccpu);
  }
#line 78
  return (-1);
}
}
#line 81 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsys_linux.c"
static void find_system_model(char **system_model ) 
{ 


  {
  {
#line 105
  *system_model = strdup("Teach Me SMBIOS");
  }
#line 107
  return;
}
}
#line 110 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsys_linux.c"
void find_system_info(char **system_model , char **cpu_model , int *cpu_frequency ) 
{ 


  {
  {
#line 113
  find_system_model(system_model);
#line 114
  find_cpu_model(cpu_model);
#line 115
  *cpu_frequency = find_cpu_freq();
  }
#line 117
  return;
}
}
#line 1 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
char netcpu_procstat_id[60]  = 
#line 1 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
  {      (char )'@',      (char )'(',      (char )'#',      (char )')', 
        (char )'n',      (char )'e',      (char )'t',      (char )'c', 
        (char )'p',      (char )'u',      (char )'_',      (char )'p', 
        (char )'r',      (char )'o',      (char )'c',      (char )'s', 
        (char )'t',      (char )'a',      (char )'t',      (char )'.', 
        (char )'c',      (char )' ',      (char )'(',      (char )'c', 
        (char )')',      (char )' ',      (char )'C',      (char )'o', 
        (char )'p',      (char )'y',      (char )'r',      (char )'i', 
        (char )'g',      (char )'h',      (char )'t',      (char )' ', 
        (char )'2',      (char )'0',      (char )'0',      (char )'5', 
        (char )'-',      (char )'2',      (char )'0',      (char )'1', 
        (char )'2',      (char )' ',      (char )'V',      (char )'e', 
        (char )'r',      (char )'s',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'2',      (char )'.', 
        (char )'6',      (char )'.',      (char )'0',      (char )'\000'};
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 60 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
static cpu_states_t lib_start_count[256]  ;
#line 61 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
static cpu_states_t lib_end_count[256]  ;
#line 69 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
static int proc_stat_fd  =    -1;
#line 70 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
static char *proc_stat_buf  =    (char *)((void *)0);
#line 71 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
static int proc_stat_buflen  =    0;
#line 73 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
void cpu_util_init(void) 
{ 
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 77
  if (debug) {
    {
#line 78
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"cpu_util_init enter, proc_stat_fd %d proc_stat_buf %p\n",
            proc_stat_fd, proc_stat_buf);
#line 82
    fflush(where);
    }
  }
#line 84
  if (proc_stat_fd < 0) {
    {
#line 85
    proc_stat_fd = open("/proc/stat", 0, (void *)0);
    }
#line 86
    if (proc_stat_fd < 0) {
      {
#line 87
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open %s!\n",
              "/proc/stat");
#line 88
      exit(1);
      }
    }
  }
#line 92
  if (! proc_stat_buf) {
#line 93
    if (lib_num_loc_cpus == 1) {
#line 93
      tmp = 1;
    } else {
#line 93
      tmp = 1 + lib_num_loc_cpus;
    }
#line 93
    proc_stat_buflen = tmp * (int )(((9UL * sizeof(long )) / 3UL + 1UL) * 4UL + 8UL);
#line 94
    if (debug) {
#line 95
      if (lib_num_loc_cpus == 1) {
#line 95
        tmp___0 = 1;
      } else {
#line 95
        tmp___0 = 1 + lib_num_loc_cpus;
      }
      {
#line 95
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"lib_num_loc_cpus %d lines %d CPU_LINE_LENGTH %d proc_stat_buflen %d\n",
              lib_num_loc_cpus, tmp___0, (int )(((9UL * sizeof(long )) / 3UL + 1UL) * 4UL + 8UL),
              proc_stat_buflen);
#line 101
      fflush(where);
      }
    }
    {
#line 103
    tmp___1 = malloc((size_t )proc_stat_buflen);
#line 103
    proc_stat_buf = (char *)tmp___1;
    }
#line 104
    if (! proc_stat_buf) {
      {
#line 105
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate buffer memory!\n");
#line 106
      exit(1);
      }
    }
  }
#line 109
  return;
}
}
#line 112 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
void cpu_util_terminate(void) 
{ 


  {
  {
#line 115
  close(proc_stat_fd);
#line 116
  proc_stat_fd = -1;
#line 117
  free((void *)proc_stat_buf);
#line 118
  proc_stat_buf = (char *)((void *)0);
  }
#line 119
  return;
}
}
#line 122 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
int get_cpu_method(void) 
{ 


  {
#line 125
  return (8);
}
}
#line 128 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
float calibrate_idle_rate(int iterations , int interval___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;

  {
#line 131
  if (proc_stat_fd < 0) {
    {
#line 132
    proc_stat_fd = open("/proc/stat", 0, (void *)0);
    }
#line 133
    if (proc_stat_fd < 0) {
      {
#line 134
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open %s!\n",
              "/proc/stat");
#line 135
      exit(1);
      }
    }
  }
#line 139
  if (! proc_stat_buf) {
#line 140
    if (lib_num_loc_cpus == 1) {
#line 140
      tmp = 1;
    } else {
#line 140
      tmp = 1 + lib_num_loc_cpus;
    }
#line 140
    proc_stat_buflen = tmp * (int )(((9UL * sizeof(long )) / 3UL + 1UL) * 4UL + 8UL);
#line 141
    if (debug) {
#line 142
      if (lib_num_loc_cpus == 1) {
#line 142
        tmp___0 = 1;
      } else {
#line 142
        tmp___0 = 1 + lib_num_loc_cpus;
      }
      {
#line 142
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"calibrate: lib_num_loc_cpus %d lines %d CPU_LINE_LENGTH %d proc_stat_buflen %d\n",
              lib_num_loc_cpus, tmp___0, (int )(((9UL * sizeof(long )) / 3UL + 1UL) * 4UL + 8UL),
              proc_stat_buflen);
#line 148
      fflush(where);
      }
    }
    {
#line 150
    tmp___1 = malloc((size_t )proc_stat_buflen);
#line 150
    proc_stat_buf = (char *)tmp___1;
    }
#line 151
    if (! proc_stat_buf) {
      {
#line 152
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate buffer memory!\n");
#line 153
      exit(1);
      }
    }
  }
  {
#line 157
  tmp___2 = sysconf(2);
  }
#line 157
  return ((float )tmp___2);
}
}
#line 160 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
static void get_cpu(cpu_states_t *res ) 
{ 
  int i ;
  int n ;
  char *p ;

  {
  {
#line 164
  n = lib_num_loc_cpus;
#line 165
  p = proc_stat_buf;
#line 167
  lseek(proc_stat_fd, (__off_t )0, 0);
#line 168
  read(proc_stat_fd, (void *)p, (size_t )proc_stat_buflen);
  }
#line 170
  if (debug) {
    {
#line 171
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"proc_stat_buf \'%.*s\'\n",
            proc_stat_buflen, p);
#line 172
    fflush(where);
    }
  }
#line 175
  if (n > 1) {
    {
#line 175
    p = strchr((char const   *)p, '\n');
    }
  }
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < n)) {
#line 177
      goto while_break;
    }
    {
#line 178
    memset((void *)(res + i), 0, sizeof(*(res + i)));
#line 179
    p = strchr((char const   *)p, ' ');
#line 180
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%llu %llu %llu %llu %llu %llu %llu %llu %llu",
           (unsigned long long *)(& (res + i)->user), (unsigned long long *)(& (res + i)->nice),
           (unsigned long long *)(& (res + i)->sys), (unsigned long long *)(& (res + i)->idle),
           (unsigned long long *)(& (res + i)->iowait), (unsigned long long *)(& (res + i)->hard_irq),
           (unsigned long long *)(& (res + i)->soft_irq), (unsigned long long *)(& (res + i)->steal),
           (unsigned long long *)(& (res + i)->guest));
    }
#line 190
    if (debug) {
      {
#line 191
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"res[%d] is %llu %llu %llu %llu %llu %llu %llu %llu %llu\n",
              i, (unsigned long long )(res + i)->user, (unsigned long long )(res + i)->nice,
              (unsigned long long )(res + i)->sys, (unsigned long long )(res + i)->idle,
              (unsigned long long )(res + i)->iowait, (unsigned long long )(res + i)->hard_irq,
              (unsigned long long )(res + i)->soft_irq, (unsigned long long )(res + i)->steal,
              (unsigned long long )(res + i)->guest);
#line 203
      fflush(where);
      }
    }
    {
#line 205
    p = strchr((char const   *)p, '\n');
#line 177
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
#line 213 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
void measure_cpu_start(void) 
{ 


  {
  {
#line 216
  cpu_method = 8;
#line 217
  get_cpu(lib_start_count);
  }
#line 218
  return;
}
}
#line 221 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
void measure_cpu_stop(void) 
{ 


  {
  {
#line 224
  get_cpu(lib_end_count);
  }
#line 225
  return;
}
}
#line 227 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
static uint64_t tick_subtract(uint64_t start , uint64_t end ) 
{ 


  {
#line 230
  if (end >= start) {
#line 231
    return (end - start);
  } else
#line 230
  if ((unsigned long long )start & 0xffffffff00000000ULL) {
#line 231
    return (end - start);
  }
#line 240
  return ((uint64_t )((unsigned long long )(end - start) + 0xffffffff00000000ULL));
}
}
#line 243 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
float calc_cpu_util_internal(float elapsed_time___0 ) 
{ 
  int i ;
  float correction_factor ;
  cpu_states_t diff ;
  uint64_t total_ticks ;

  {
#line 252
  lib_local_cpu_util = (float )0.0;
#line 260
  if ((double )elapsed_time___0 != 0.0) {
#line 261
    correction_factor = (float )1.0 + (lib_elapsed - elapsed_time___0) / elapsed_time___0;
  } else {
#line 265
    correction_factor = (float )1.0;
  }
#line 268
  if (debug) {
    {
#line 269
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"lib_local_maxrate = %f\n",
            (double )lib_local_maxrate);
    }
  }
#line 272
  i = 0;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (i < lib_num_loc_cpus)) {
#line 272
      goto while_break;
    }
    {
#line 275
    diff.user = tick_subtract(lib_start_count[i].user, lib_end_count[i].user);
#line 277
    diff.nice = tick_subtract(lib_start_count[i].nice, lib_end_count[i].nice);
#line 279
    diff.sys = tick_subtract(lib_start_count[i].sys, lib_end_count[i].sys);
#line 281
    diff.idle = tick_subtract(lib_start_count[i].idle, lib_end_count[i].idle);
#line 283
    diff.iowait = tick_subtract(lib_start_count[i].iowait, lib_end_count[i].iowait);
#line 285
    diff.hard_irq = tick_subtract(lib_start_count[i].hard_irq, lib_end_count[i].hard_irq);
#line 287
    diff.soft_irq = tick_subtract(lib_start_count[i].soft_irq, lib_end_count[i].soft_irq);
#line 289
    diff.steal = tick_subtract(lib_start_count[i].steal, lib_end_count[i].steal);
#line 291
    diff.guest = tick_subtract(lib_start_count[i].guest, lib_end_count[i].guest);
#line 293
    total_ticks = (((((((diff.user + diff.nice) + diff.sys) + diff.idle) + diff.iowait) + diff.hard_irq) + diff.soft_irq) + diff.steal) + diff.guest;
    }
#line 297
    if (total_ticks == 0UL) {
#line 298
      if (debug) {
        {
#line 299
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Total ticks 0 on CPU %d, charging nothing!\n",
                i);
        }
      }
#line 301
      lib_local_per_cpu_util[i] = (float )100.0;
    } else {
#line 303
      lib_local_per_cpu_util[i] = (float )(100.0 * (double )((float )diff.idle / (float )total_ticks));
    }
#line 307
    lib_local_per_cpu_util[i] = (float )(100.0 - (double )lib_local_per_cpu_util[i]);
#line 310
    lib_local_per_cpu_util[i] *= correction_factor;
#line 311
    if (debug) {
      {
#line 312
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"calc_cpu_util: util on processor %d, diff = %llu %llu %llu %llu %llu %llu %llu %llu %llu util %f cf %f\n",
              i, (unsigned long long )diff.user, (unsigned long long )diff.nice, (unsigned long long )diff.sys,
              (unsigned long long )diff.idle, (unsigned long long )diff.iowait, (unsigned long long )diff.hard_irq,
              (unsigned long long )diff.soft_irq, (unsigned long long )diff.steal,
              (unsigned long long )diff.guest, (double )lib_local_per_cpu_util[i],
              (double )correction_factor);
      }
    }
#line 328
    lib_local_cpu_util += lib_local_per_cpu_util[i];
#line 272
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  lib_local_cpu_util /= (float )lib_num_loc_cpus;
#line 333
  return (lib_local_cpu_util);
}
}
#line 336 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
void cpu_start_internal(void) 
{ 


  {
  {
#line 339
  get_cpu(lib_start_count);
  }
#line 340
  return;
}
}
#line 343 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
void cpu_stop_internal(void) 
{ 


  {
  {
#line 346
  get_cpu(lib_end_count);
  }
#line 347
  return;
}
}
#line 56 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 60
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2), __leaf__)) dlsym)(void * __restrict  __handle ,
                                                                                              char const   * __restrict  __name ) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dlerror)(void) ;
#line 16 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsec_linux.c"
void *messiah  ;
#line 22 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsec_linux.c"
void find_security_info_selinux(int *enabled , int *type , char **specific ) 
{ 
  int ret ;
  int enforcing ;
  int (*getenforce)(int * ) ;
  int (*getpolicy)(char ** ) ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 33
  *enabled = -1;
#line 34
  *type = 1;
#line 36
  tmp = dlsym((void */* __restrict  */)messiah, (char const   */* __restrict  */)"selinux_getenforcemode");
#line 36
  getenforce = (int (*)(int * ))tmp;
  }
#line 37
  if ((unsigned long )((void *)0) == (unsigned long )getenforce) {
    {
#line 38
    dlclose(messiah);
#line 39
    *specific = strdup("no getenforcemode");
    }
#line 40
    return;
  }
  {
#line 43
  ret = (*getenforce)(& enforcing);
  }
  {
#line 49
  if (enforcing == -1) {
#line 49
    goto case_neg_1;
  }
#line 52
  if (enforcing == 0) {
#line 52
    goto case_0;
  }
#line 55
  if (enforcing == 1) {
#line 55
    goto case_1;
  }
#line 58
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 50
  *enabled = 0;
#line 51
  goto switch_break;
  case_0: /* CIL Label */ 
#line 53
  *enabled = 1;
#line 54
  goto switch_break;
  case_1: /* CIL Label */ 
#line 56
  *enabled = 2;
#line 57
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 59
  *enabled = -1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 62
  tmp___0 = dlsym((void */* __restrict  */)messiah, (char const   */* __restrict  */)"selinux_getpolicytype");
#line 62
  getpolicy = (int (*)(char ** ))tmp___0;
  }
#line 63
  if ((unsigned long )((void *)0) == (unsigned long )getpolicy) {
    {
#line 64
    dlclose(messiah);
#line 65
    *specific = strdup("no getpolicytype");
    }
#line 66
    return;
  }
  {
#line 69
  ret = (*getpolicy)(specific);
  }
#line 74
  return;
}
}
#line 81 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsec_linux.c"
void find_security_info(int *enabled , int *type , char **specific ) 
{ 


  {
  {
#line 85
  messiah = dlopen("libselinux.so", 1);
  }
#line 86
  if ((unsigned long )((void *)0) != (unsigned long )messiah) {
    {
#line 87
    dlerror();
#line 88
    find_security_info_selinux(enabled, type, specific);
    }
#line 88
    return;
  } else {
#line 91
    *enabled = -1;
#line 92
    *type = -1;
#line 93
    *specific = (char *)"unknown";
#line 94
    return;
  }
}
}
#line 136 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static HIST time_hist___0  ;
#line 442 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int confidence_iteration___1  ;
#line 444 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int local_cpu_method___1  ;
#line 445 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int remote_cpu_method___1  ;
#line 449 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int client_port_min___1  =    5000;
#line 450 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int client_port_max___1  =    65535;
#line 702 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static unsigned short get_port_number___1(struct addrinfo *res ) 
{ 
  struct sockaddr_in *foo ;
  uint16_t tmp ;
  struct sockaddr_in6 *foo___0 ;
  uint16_t tmp___0 ;

  {
  {
#line 706
  if (res->ai_family == 2) {
#line 706
    goto case_2;
  }
#line 712
  if (res->ai_family == 10) {
#line 712
    goto case_10;
  }
#line 718
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 707
  foo = (struct sockaddr_in *)res->ai_addr;
#line 708
  tmp = ntohs(foo->sin_port);
  }
#line 708
  return (tmp);
#line 709
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 713
  foo___0 = (struct sockaddr_in6 *)res->ai_addr;
#line 714
  tmp___0 = ntohs(foo___0->sin6_port);
  }
#line 714
  return (tmp___0);
#line 715
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 719
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Unexpected Address Family %u\n",
          res->ai_family);
#line 721
  fflush(where);
#line 722
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 724
  return ((unsigned short)0);
}
}
#line 729 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int is_multicast_addr___0(struct addrinfo *res ) 
{ 
  struct in_addr bar ;
  uint32_t tmp ;
  struct in6_addr *bar___0 ;

  {
  {
#line 732
  if (res->ai_family == 2) {
#line 732
    goto case_2;
  }
#line 742
  if (res->ai_family == 10) {
#line 742
    goto case_10;
  }
#line 747
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 736
  bar = ((struct sockaddr_in *)res->ai_addr)->sin_addr;
#line 739
  tmp = ntohl(bar.s_addr);
  }
#line 739
  return ((tmp & 4026531840U) == 3758096384U);
  case_10: /* CIL Label */ 
#line 743
  bar___0 = & ((struct sockaddr_in6 *)res->ai_addr)->sin6_addr;
#line 744
  return ((int const   )*((uint8_t const   *)bar___0 + 0) == 255);
  switch_default: /* CIL Label */ 
  {
#line 748
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Unexpected Address Family for Multicast Check %u\n",
          res->ai_family);
#line 751
  fflush(where);
  }
#line 752
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 756 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void set_multicast_ttl___0(int sock ) 
{ 
  int optlen ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 758
  optlen = (int )sizeof(int );
#line 761
  if (multicast_ttl >= 0) {
    {
#line 762
    tmp___0 = setsockopt(sock, 0, 2, (void const   *)((char const   *)(& multicast_ttl)),
                         (socklen_t )sizeof(multicast_ttl));
    }
#line 762
    if (tmp___0 == -1) {
      {
#line 767
      tmp = __errno_location();
#line 767
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"setsockopt(IP_TTL) failed errno %d\n",
              *tmp);
      }
    }
  }
  {
#line 772
  tmp___2 = getsockopt(sock, 0, 2, (void */* __restrict  */)((char *)(& multicast_ttl)),
                       (socklen_t */* __restrict  */)((unsigned int *)(& optlen)));
  }
#line 772
  if (tmp___2 < 0) {
    {
#line 777
    tmp___1 = __errno_location();
#line 777
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"getsockopt(IP_TTL) failed errno %d\n",
            *tmp___1);
#line 780
    multicast_ttl = -2;
    }
  }
#line 782
  return;
}
}
#line 786 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void join_multicast_addr___0(int sock , struct addrinfo *res ) 
{ 
  struct ip_mreq mreq ;
  struct in_addr bar ;
  int optlen ;
  int one ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 789
  if (res->ai_family == 2) {
#line 789
    goto case_2;
  }
#line 850
  if (res->ai_family == 10) {
#line 850
    goto case_10;
  }
#line 788
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 791
  bar = ((struct sockaddr_in *)res->ai_addr)->sin_addr;
#line 792
  optlen = (int )sizeof(int );
#line 793
  one = 1;
#line 795
  mreq.imr_multiaddr.s_addr = bar.s_addr;
#line 796
  mreq.imr_interface.s_addr = htonl((in_addr_t )0);
#line 797
  tmp___6 = setsockopt(sock, 0, 35, (void const   *)((char const   *)(& mreq)), (socklen_t )sizeof(mreq));
  }
#line 797
  if (tmp___6 == 0) {
    {
#line 804
    tmp___0 = setsockopt(sock, 1, 2, (void const   *)((char const   *)(& one)), (socklen_t )sizeof(one));
    }
#line 804
    if (tmp___0 == -1) {
#line 809
      if (debug) {
        {
#line 810
        tmp = __errno_location();
#line 810
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"join_multicast_addr SO_REUSADDR failed errno %d\n",
                *tmp);
#line 813
        fflush(where);
        }
      }
    }
#line 818
    if (multicast_ttl >= 0) {
      {
#line 819
      tmp___2 = setsockopt(sock, 0, 2, (void const   *)((char const   *)(& multicast_ttl)),
                           (socklen_t )sizeof(multicast_ttl));
      }
#line 819
      if (tmp___2 == -1) {
        {
#line 824
        tmp___1 = __errno_location();
#line 824
        fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"setsockopt(IP_TTL) failed errno %d\n",
                *tmp___1);
        }
      }
    }
    {
#line 829
    tmp___4 = getsockopt(sock, 0, 2, (void */* __restrict  */)((char *)(& multicast_ttl)),
                         (socklen_t */* __restrict  */)((unsigned int *)(& optlen)));
    }
#line 829
    if (tmp___4 == -1) {
      {
#line 834
      tmp___3 = __errno_location();
#line 834
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"getsockopt(IP_TTL) failed errno %d\n",
              *tmp___3);
#line 837
      multicast_ttl = -2;
      }
    }
  } else
#line 841
  if (debug) {
    {
#line 842
    tmp___5 = __errno_location();
#line 842
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"setsockopt(IP_ADD_MEMBERSHIP) failed errno %d\n",
            *tmp___5);
#line 845
    fflush(where);
    }
  }
#line 848
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 851
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"I do not know how to join an IPv6 multicast group\n");
  }
#line 852
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 856
  return;
}
}
#line 886 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int myport_init___0  =    0;
#line 887 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static unsigned short myport___0  =    (unsigned short)0;
#line 1740 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void set_output_elt___0(enum netperf_output_name name , char *line0 , char *line1 ,
                               char *line2 , char *line3 , char *format , void *value ,
                               unsigned int out_default , unsigned int group , enum netperf_output_type type ) 
{ 
  size_t tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  size_t tmp___41 ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  size_t tmp___46 ;
  size_t tmp___47 ;
  size_t tmp___48 ;
  size_t tmp___49 ;
  size_t tmp___50 ;
  size_t tmp___61 ;
  size_t tmp___62 ;
  size_t tmp___63 ;
  size_t tmp___64 ;
  size_t tmp___65 ;
  size_t tmp___66 ;
  size_t tmp___67 ;
  size_t tmp___70 ;
  size_t tmp___71 ;
  size_t tmp___72 ;
  size_t tmp___73 ;
  size_t tmp___74 ;
  size_t tmp___75 ;
  size_t tmp___76 ;
  size_t tmp___77 ;
  size_t tmp___78 ;
  size_t tmp___79 ;
  size_t tmp___80 ;

  {
  {
#line 1749
  netperf_output_source[name].output_name = name;
#line 1750
  netperf_output_source[name].line[0] = line0;
#line 1751
  netperf_output_source[name].line[1] = line1;
#line 1752
  netperf_output_source[name].line[2] = line2;
#line 1753
  netperf_output_source[name].line[3] = line3;
#line 1754
  netperf_output_source[name].format = format;
#line 1755
  netperf_output_source[name].display_value = value;
#line 1756
  netperf_output_source[name].output_default = (int )out_default;
#line 1757
  netperf_output_source[name].output_group = group;
#line 1758
  tmp___73 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
  tmp___74 = strlen((char const   *)netperf_output_source[name].line[1]);
  }
#line 1758
  if (tmp___73 > tmp___74) {
    {
#line 1758
    tmp___70 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
    tmp___72 = tmp___70;
    }
  } else {
    {
#line 1758
    tmp___71 = strlen((char const   *)netperf_output_source[name].line[1]);
#line 1758
    tmp___72 = tmp___71;
    }
  }
  {
#line 1758
  tmp___75 = strlen((char const   *)netperf_output_source[name].line[2]);
  }
#line 1758
  if (tmp___72 > tmp___75) {
    {
#line 1758
    tmp___64 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
    tmp___65 = strlen((char const   *)netperf_output_source[name].line[1]);
    }
#line 1758
    if (tmp___64 > tmp___65) {
      {
#line 1758
      tmp___61 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
      tmp___63 = tmp___61;
      }
    } else {
      {
#line 1758
      tmp___62 = strlen((char const   *)netperf_output_source[name].line[1]);
#line 1758
      tmp___63 = tmp___62;
      }
    }
#line 1758
    tmp___67 = tmp___63;
  } else {
    {
#line 1758
    tmp___66 = strlen((char const   *)netperf_output_source[name].line[2]);
#line 1758
    tmp___67 = tmp___66;
    }
  }
  {
#line 1758
  tmp___76 = strlen((char const   *)netperf_output_source[name].line[3]);
  }
#line 1758
  if (tmp___67 > tmp___76) {
    {
#line 1758
    tmp___47 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
    tmp___48 = strlen((char const   *)netperf_output_source[name].line[1]);
    }
#line 1758
    if (tmp___47 > tmp___48) {
      {
#line 1758
      tmp___44 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
      tmp___46 = tmp___44;
      }
    } else {
      {
#line 1758
      tmp___45 = strlen((char const   *)netperf_output_source[name].line[1]);
#line 1758
      tmp___46 = tmp___45;
      }
    }
    {
#line 1758
    tmp___49 = strlen((char const   *)netperf_output_source[name].line[2]);
    }
#line 1758
    if (tmp___46 > tmp___49) {
      {
#line 1758
      tmp___38 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
      tmp___39 = strlen((char const   *)netperf_output_source[name].line[1]);
      }
#line 1758
      if (tmp___38 > tmp___39) {
        {
#line 1758
        tmp___35 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1758
        tmp___37 = tmp___35;
        }
      } else {
        {
#line 1758
        tmp___36 = strlen((char const   *)netperf_output_source[name].line[1]);
#line 1758
        tmp___37 = tmp___36;
        }
      }
#line 1758
      tmp___41 = tmp___37;
    } else {
      {
#line 1758
      tmp___40 = strlen((char const   *)netperf_output_source[name].line[2]);
#line 1758
      tmp___41 = tmp___40;
      }
    }
#line 1758
    netperf_output_source[name].max_line_len = (int )tmp___41;
  } else {
    {
#line 1758
    tmp___50 = strlen((char const   *)netperf_output_source[name].line[3]);
#line 1758
    netperf_output_source[name].max_line_len = (int )tmp___50;
    }
  }
  {
#line 1759
  tmp___77 = strlen((char const   *)netperf_output_source[name].line[0]);
#line 1759
  tmp___78 = strlen((char const   *)netperf_output_source[name].line[1]);
#line 1759
  tmp___79 = strlen((char const   *)netperf_output_source[name].line[2]);
#line 1759
  tmp___80 = strlen((char const   *)netperf_output_source[name].line[3]);
#line 1759
  netperf_output_source[name].tot_line_len = (int )((((tmp___77 + tmp___78) + tmp___79) + tmp___80) + 4UL);
#line 1760
  netperf_output_source[name].output_type = type;
  }
#line 1761
  return;
}
}
#line 2892
static int recv_data_no_copy___0(int data_socket , struct ring_elt *recv_ring , uint32_t bytes_to_recv___0 ,
                                 struct sockaddr *source , unsigned int *sourcelen ,
                                 uint32_t flags , uint32_t *num_receives ) ;
#line 2892 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int pfd___0[2]  = {      -1,      -1};
#line 2893 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int fdnull___0  =    -1;
#line 2888 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int recv_data_no_copy___0(int data_socket , struct ring_elt *recv_ring , uint32_t bytes_to_recv___0 ,
                                 struct sockaddr *source , unsigned int *sourcelen ,
                                 uint32_t flags , uint32_t *num_receives ) 
{ 
  int bytes_left ;
  int bytes_recvd ;
  int my_recvs ;
  int my_flags ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;

  {
#line 2900
  my_flags = 0;
#line 2903
  if (pfd___0[0] == -1) {
    {
#line 2904
    tmp___2 = pipe((int *)(pfd___0));
    }
#line 2904
    if (tmp___2) {
      {
#line 2905
      tmp = __errno_location();
#line 2905
      tmp___0 = strerror(*tmp);
#line 2905
      tmp___1 = __errno_location();
#line 2905
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s pipe call failed with errno %d \'%s\'\n",
              "recv_data_no_copy", *tmp___1, tmp___0);
      }
#line 2910
      return (-4);
    }
    {
#line 2913
    fdnull___0 = open("/dev/null", 1);
    }
#line 2913
    if (fdnull___0 == -1) {
      {
#line 2914
      tmp___3 = __errno_location();
#line 2914
      tmp___4 = strerror(*tmp___3);
#line 2914
      tmp___5 = __errno_location();
#line 2914
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s open call failed with errno %d \'%s\'\n",
              "recv_data_no_copy", *tmp___5, tmp___4);
      }
#line 2919
      return (-4);
    }
  }
#line 2925
  my_recvs = 0;
#line 2926
  bytes_left = (int )bytes_to_recv___0;
#line 2928
  if (debug > 1) {
#line 2929
    if ((unsigned long )source != (unsigned long )((void *)0)) {
#line 2929
      tmp___6 = *sourcelen;
    } else {
#line 2929
      tmp___6 = 4294967295U;
    }
    {
#line 2929
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s sock %d, ring elt %p, bytes %d, source %p, srclen %d, flags %x, num_recv %p\n",
            "recv_data_no_copy", data_socket, recv_ring, bytes_to_recv___0, source,
            tmp___6, flags, num_receives);
#line 2939
    fflush(where);
    }
  }
  {
#line 2941
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2943
    bytes_recvd = splice(data_socket, (void *)0, pfd___0[1], (void *)0, bytes_left,
                         my_flags);
    }
#line 2951
    if (bytes_recvd > 0) {
      {
#line 2952
      tmp___7 = splice(pfd___0[0], (void *)0, fdnull___0, (void *)0, bytes_recvd,
                       my_flags);
      }
#line 2952
      if (tmp___7 != bytes_recvd) {
#line 2958
        return (-3);
      }
#line 2960
      bytes_left -= bytes_recvd;
    } else {
#line 2963
      goto while_break;
    }
#line 2965
    my_recvs ++;
#line 2941
    if (bytes_left > 0) {
#line 2941
      if (! (flags & 1U)) {
#line 2941
        goto while_break;
      }
    } else {
#line 2941
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2968
  *num_receives = (uint32_t )my_recvs;
#line 2971
  if (bytes_recvd < 0) {
    {
#line 2973
    tmp___8 = __errno_location();
    }
#line 2973
    if (*tmp___8 == 4) {
#line 2976
      return (-1);
    }
#line 2979
    return (-3);
  }
#line 2989
  if (bytes_left) {
#line 2990
    return (bytes_recvd);
  } else {
#line 2992
    return ((int )bytes_to_recv___0);
  }
}
}
#line 3238 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void dump_tcp_info___0(struct tcp_info *tcp_info ) 
{ 


  {
  {
#line 3242
  printf((char const   */* __restrict  */)"tcpi_rto %d tcpi_ato %d tcpi_pmtu %d tcpi_rcv_ssthresh %d\ntcpi_rtt %d tcpi_rttvar %d tcpi_snd_ssthresh %d tpci_snd_cwnd %d\ntcpi_reordering %d tcpi_total_retrans %d\n",
         tcp_info->tcpi_rto, tcp_info->tcpi_ato, tcp_info->tcpi_pmtu, tcp_info->tcpi_rcv_ssthresh,
         tcp_info->tcpi_rtt, tcp_info->tcpi_rttvar, tcp_info->tcpi_snd_ssthresh, tcp_info->tcpi_snd_cwnd,
         tcp_info->tcpi_reordering, tcp_info->tcpi_total_retrans);
  }
#line 3256
  return;
}
}
#line 3261 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int get_transport_retrans___0(int socket___0 , int protocol___0 ) 
{ 
  struct tcp_info tcp_info ;
  int ret ;
  unsigned int infosize ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
#line 3270
  if (protocol___0 != 6) {
#line 3271
    return (-1);
  }
  {
#line 3273
  infosize = (unsigned int )sizeof(struct tcp_info );
#line 3275
  ret = getsockopt(socket___0, protocol___0, 11, (void */* __restrict  */)(& tcp_info),
                   (socklen_t */* __restrict  */)(& infosize));
  }
#line 3275
  if (ret < 0) {
#line 3276
    if (debug) {
      {
#line 3277
      tmp = __errno_location();
#line 3277
      tmp___0 = strerror(*tmp);
#line 3277
      tmp___1 = __errno_location();
#line 3277
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: getsockopt errno %d %s\n",
              "get_transport_retrans", *tmp___1, tmp___0);
#line 3282
      fflush(where);
      }
    }
#line 3284
    return (-1);
  } else {
#line 3288
    if (debug > 1) {
      {
#line 3289
      dump_tcp_info___0(& tcp_info);
      }
    }
#line 3291
    return ((int )tcp_info.tcpi_total_retrans);
  }
}
}
#line 3301 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void get_transport_info___0(int socket___0 , int *mss , int protocol___0 ) 
{ 
  unsigned int sock_opt_len ;
  int option ;
  int *tmp ;
  int tmp___0 ;

  {
#line 3307
  sock_opt_len = (unsigned int )sizeof(unsigned int );
  {
#line 3311
  if (protocol___0 == 6) {
#line 3311
    goto case_6;
  }
#line 3321
  goto switch_default;
  case_6: /* CIL Label */ 
#line 3312
  option = 2;
#line 3313
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3322
  *mss = -1;
#line 3323
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 3326
  tmp___0 = getsockopt(socket___0, protocol___0, option, (void */* __restrict  */)((char *)mss),
                       (socklen_t */* __restrict  */)(& sock_opt_len));
  }
#line 3326
  if (tmp___0 == -1) {
    {
#line 3331
    tmp = __errno_location();
#line 3331
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s: getsockopt: errno %d\n",
            "get_transport_info", *tmp);
#line 3335
    fflush(where);
#line 3336
    *mss = -1;
    }
  }
#line 3339
  return;
}
}
#line 3347 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void get_transport_cong_control___0(int socket___0 , int protocol___0 , char *cong_control ,
                                           int len ) 
{ 
  int my_len ;
  int *tmp ;
  int tmp___0 ;

  {
#line 3351
  my_len = len;
#line 3352
  if (protocol___0 != 6) {
    {
#line 3353
    strncpy((char */* __restrict  */)cong_control, (char const   */* __restrict  */)"TCP Only",
            (size_t )len);
    }
  } else {
    {
#line 3355
    tmp___0 = getsockopt(socket___0, protocol___0, 13, (void */* __restrict  */)cong_control,
                         (socklen_t */* __restrict  */)(& my_len));
    }
#line 3355
    if (tmp___0 == -1) {
      {
#line 3358
      tmp = __errno_location();
#line 3358
      snprintf((char */* __restrict  */)cong_control, (size_t )len, (char const   */* __restrict  */)"%d errno",
               *tmp);
      }
    }
  }
#line 3363
  *(cong_control + (len - 1)) = (char )'\000';
#line 3364
  return;
}
}
#line 3366 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void set_transport_cong_control___0(int socket___0 , int protocol___0 , char *cong_control ,
                                           int len ) 
{ 


  {
#line 3370
  if (protocol___0 == 6) {
    {
#line 3372
    setsockopt(socket___0, protocol___0, 13, (void const   *)cong_control, (socklen_t )len);
    }
  }
#line 3375
  return;
}
}
#line 3377 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int omni_create_data_socket___0(struct addrinfo *res ) 
{ 
  int temp_socket ;

  {
  {
#line 3382
  temp_socket = create_data_socket(res);
  }
#line 3384
  if (temp_socket != -1) {
#line 3385
    if ((int )local_cong_control_req[0] != 0) {
      {
#line 3386
      set_transport_cong_control___0(temp_socket, res->ai_protocol, local_cong_control_req,
                                     (int )sizeof(local_cong_control_req));
      }
    }
  }
#line 3392
  return (temp_socket);
}
}
#line 3399 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static int choose_send_size___0(int lss , int protocol___0 ) 
{ 
  int send_size___0 ;

  {
#line 3404
  if (lss > 0) {
#line 3405
    send_size___0 = lss_size;
#line 3409
    if (protocol___0 == 17) {
#line 3409
      if (send_size___0 > 65507) {
#line 3410
        send_size___0 = 65507;
      }
    }
  } else {
#line 3414
    send_size___0 = 4096;
  }
#line 3416
  return (send_size___0);
}
}
#line 3440 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void enable_enobufs___0(int s ) 
{ 
  struct protoent *pr ;
  int on ;
  int tmp ;

  {
  {
#line 3444
  on = 1;
#line 3446
  pr = getprotobyname("ip");
  }
#line 3446
  if ((unsigned long )pr == (unsigned long )((void *)0)) {
    {
#line 3447
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s failed: getprotobyname\n",
            "enable_enobufs");
#line 3448
    fflush(where);
    }
#line 3449
    return;
  }
  {
#line 3451
  tmp = setsockopt(s, pr->p_proto, 11, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
  }
#line 3451
  if (tmp < 0) {
    {
#line 3452
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"%s failed: setsockopt\n",
            "enable_enobufs");
#line 3453
    fflush(where);
    }
#line 3454
    return;
  }
#line 3456
  return;
}
}
#line 4870 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void set_hostname_and_port_2___0(void *addr , char *hostname , char *portstr ,
                                        int family , int port ) 
{ 


  {
  {
#line 4874
  inet_ntop(family, (void const   */* __restrict  */)addr, (char */* __restrict  */)hostname,
            (socklen_t )8192);
#line 4876
  sprintf((char */* __restrict  */)portstr, (char const   */* __restrict  */)"%u",
          port);
  }
#line 4878
  return;
}
}
#line 6775 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_omni.c"
static void set_omni_defaults_by_legacy_testname___0(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 6779
  protocol = 6;
#line 6780
  socket_type = 1;
#line 6781
  connection_test = 0;
#line 6782
  rsp_size = -1;
#line 6782
  req_size = rsp_size;
#line 6783
  was_legacy = 1;
#line 6784
  legacy = 1;
#line 6785
  implicit_direction = 0;
#line 6787
  tmp___6 = strcasecmp((char const   *)(test_name), "TCP_STREAM");
  }
#line 6787
  if (tmp___6 == 0) {
#line 6788
    direction = 2;
  } else {
    {
#line 6790
    tmp___5 = strcasecmp((char const   *)(test_name), "TCP_MAERTS");
    }
#line 6790
    if (tmp___5 == 0) {
#line 6791
      direction = 4;
    } else {
      {
#line 6793
      tmp___4 = strcasecmp((char const   *)(test_name), "TCP_RR");
      }
#line 6793
      if (tmp___4 == 0) {
#line 6794
        rsp_size = 1;
#line 6794
        req_size = rsp_size;
#line 6795
        direction = 0;
#line 6796
        direction |= 2;
#line 6797
        direction |= 4;
      } else {
        {
#line 6799
        tmp___3 = strcasecmp((char const   *)(test_name), "UDP_STREAM");
        }
#line 6799
        if (tmp___3 == 0) {
#line 6800
          protocol = 17;
#line 6801
          socket_type = 2;
        } else {
          {
#line 6803
          tmp___2 = strcasecmp((char const   *)(test_name), "UDP_RR");
          }
#line 6803
          if (tmp___2 == 0) {
#line 6804
            protocol = 17;
#line 6805
            socket_type = 2;
#line 6806
            direction = 0;
#line 6807
            direction |= 2;
#line 6808
            direction |= 4;
#line 6809
            rsp_size = 1;
#line 6809
            req_size = rsp_size;
          } else {
            {
#line 6811
            tmp___1 = strcasecmp((char const   *)(test_name), "TCP_CC");
            }
#line 6811
            if (tmp___1 == 0) {
#line 6812
              direction = 0;
#line 6813
              connection_test = 1;
            } else {
              {
#line 6815
              tmp___0 = strcasecmp((char const   *)(test_name), "TCP_CRR");
              }
#line 6815
              if (tmp___0 == 0) {
#line 6816
                direction = 0;
#line 6817
                direction |= 2;
#line 6818
                direction |= 4;
#line 6819
                rsp_size = 1;
#line 6819
                req_size = rsp_size;
#line 6820
                connection_test = 1;
              } else {
                {
#line 6822
                tmp = strcasecmp((char const   *)(test_name), "omni");
                }
#line 6822
                if (tmp == 0) {
#line 6824
                  was_legacy = 0;
#line 6825
                  legacy = 0;
#line 6826
                  implicit_direction = 1;
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 6828
  socket_type_str = hst_to_str(socket_type);
  }
#line 6829
  return;
}
}
#line 562 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsh.c"
static void convert_to_upper___0(char *source ) 
{ 
  int i ;
  int length ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 568
  tmp = strlen((char const   *)source);
#line 568
  length = (int )tmp;
#line 570
  i = 0;
  }
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
#line 570
    if (! (i < length)) {
#line 570
      goto while_break;
    }
    {
#line 571
    tmp___0 = toupper((int )*(source + i));
#line 571
    *(source + i) = (char )tmp___0;
#line 570
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 574
  return;
}
}
#line 100 "/home/wheatley/newnew/temp/netperf-2.6.0/src/dscp.c"
static struct __anonstruct_ipqos_32___0  const  ipqos___0[25]  = 
#line 100 "/home/wheatley/newnew/temp/netperf-2.6.0/src/dscp.c"
  {      {"af11", 40}, 
        {"af12", 48}, 
        {"af13", 56}, 
        {"af21", 72}, 
        {"af22", 80}, 
        {"af23", 88}, 
        {"af31", 104}, 
        {"af32", 112}, 
        {"af33", 120}, 
        {"af41", 136}, 
        {"af42", 144}, 
        {"af43", 152}, 
        {"cs0", 0}, 
        {"cs1", 32}, 
        {"cs2", 64}, 
        {"cs3", 96}, 
        {"cs4", 128}, 
        {"cs5", 160}, 
        {"cs6", 192}, 
        {"cs7", 224}, 
        {"ef", 184}, 
        {"lowdelay", 16}, 
        {"throughput", 8}, 
        {"reliability", 4}, 
        {(char const   *)((void *)0), -1}};
#line 155 "/home/wheatley/newnew/temp/netperf-2.6.0/src/dscp.c"
static char iptos_str___0[5UL]  ;
#line 7 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netslot_linux.c"
static char interface_match___0[32]  ;
#line 8 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netslot_linux.c"
static char interface_address___0[13]  ;
#line 9 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netslot_linux.c"
static char interface_slot___0[13]  = 
#line 9
  {      (char )'n',      (char )'o',      (char )'t',      (char )' ', 
        (char )'f',      (char )'o',      (char )'u',      (char )'n', 
        (char )'d',      (char )'\000'};
#line 11 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netslot_linux.c"
static int find_slot___0(char const   *fpath , struct stat___0  const  *sb , int tflag ,
                         struct FTW *ftwbuf ) 
{ 
  char slot_address[11] ;
  int ret ;
  FILE *address_file ;
  char *myfpath ;
  char *this_tok ;
  char *last_tok ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 20
  last_tok = (char *)((void *)0);
#line 24
  tmp___2 = strcmp("address", fpath + ftwbuf->base);
  }
#line 24
  if (tmp___2 == 0) {
    {
#line 25
    address_file = fopen((char const   */* __restrict  */)fpath, (char const   */* __restrict  */)"r");
    }
#line 26
    if ((unsigned long )address_file == (unsigned long )((void *)0)) {
      {
#line 27
      strcpy((char */* __restrict  */)(interface_slot___0), (char const   */* __restrict  */)"fopen");
      }
#line 28
      return (0);
    }
    {
#line 33
    tmp = fread((void */* __restrict  */)(slot_address), (size_t )1, (size_t )10,
                (FILE */* __restrict  */)address_file);
#line 33
    ret = (int )tmp;
    }
#line 34
    if (ret != 10) {
      {
#line 35
      strcpy((char */* __restrict  */)(interface_slot___0), (char const   */* __restrict  */)"fread");
#line 36
      fclose(address_file);
      }
#line 37
      return (0);
    }
    {
#line 39
    slot_address[ret] = (char)0;
#line 42
    tmp___1 = strstr((char const   *)(interface_address___0), (char const   *)(slot_address));
    }
#line 42
    if (tmp___1) {
      {
#line 43
      myfpath = strdup(fpath);
      }
#line 44
      if ((unsigned long )myfpath == (unsigned long )((void *)0)) {
        {
#line 45
        strcpy((char */* __restrict  */)(interface_slot___0), (char const   */* __restrict  */)"strcpy");
        }
#line 46
        return (1);
      }
      {
#line 49
      this_tok = strtok((char */* __restrict  */)myfpath, (char const   */* __restrict  */)"/");
      }
      {
#line 50
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 50
        tmp___0 = strcmp((char const   *)this_tok, "address");
        }
#line 50
        if (! tmp___0) {
#line 50
          goto while_break;
        }
        {
#line 51
        last_tok = this_tok;
#line 52
        this_tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"/");
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 54
      if ((unsigned long )last_tok != (unsigned long )((void *)0)) {
        {
#line 55
        strcpy((char */* __restrict  */)(interface_slot___0), (char const   */* __restrict  */)last_tok);
        }
      } else {
        {
#line 57
        strcpy((char */* __restrict  */)(interface_slot___0), (char const   */* __restrict  */)"last_tok");
        }
      }
      {
#line 58
      free((void *)myfpath);
#line 59
      fclose(address_file);
      }
#line 60
      return (1);
    }
    {
#line 62
    fclose(address_file);
    }
  }
#line 64
  return (0);
}
}
#line 67 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netslot_linux.c"
static int find_interface___0(char const   *fpath , struct stat___0  const  *sb ,
                              int tflag , struct FTW *ftwbuf ) 
{ 
  char *myfpath ;
  char *this_tok ;
  char *last_tok ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 73
  last_tok = (char *)((void *)0);
#line 75
  tmp___0 = strcmp((char const   *)(interface_match___0), fpath + ftwbuf->base);
  }
#line 75
  if (tmp___0 == 0) {
    {
#line 76
    myfpath = strdup(fpath);
    }
#line 77
    if ((unsigned long )myfpath == (unsigned long )((void *)0)) {
      {
#line 78
      strcpy((char */* __restrict  */)(interface_address___0), (char const   */* __restrict  */)"strcpy");
      }
#line 79
      return (1);
    }
    {
#line 81
    this_tok = strtok((char */* __restrict  */)myfpath, (char const   */* __restrict  */)"/");
    }
    {
#line 82
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 82
      tmp = strcmp((char const   *)this_tok, (char const   *)(interface_match___0));
      }
#line 82
      if (! tmp) {
#line 82
        goto while_break;
      }
      {
#line 83
      last_tok = this_tok;
#line 84
      this_tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"/");
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 86
    if ((unsigned long )last_tok != (unsigned long )((void *)0)) {
      {
#line 87
      strcpy((char */* __restrict  */)(interface_address___0), (char const   */* __restrict  */)last_tok);
      }
    } else {
      {
#line 89
      strcpy((char */* __restrict  */)(interface_address___0), (char const   */* __restrict  */)"last_tok");
      }
    }
    {
#line 90
    free((void *)myfpath);
    }
#line 91
    return (1);
  }
#line 93
  return (0);
}
}
#line 115 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netslot_linux.c"
static int get_val_from_file___0(char *valsource ) 
{ 
  FILE *valfile ;
  char buffer[6] ;
  int ret ;
  size_t tmp ;
  long tmp___0 ;

  {
  {
#line 121
  valfile = fopen((char const   */* __restrict  */)valsource, (char const   */* __restrict  */)"r");
  }
#line 122
  if ((unsigned long )valfile == (unsigned long )((void *)0)) {
#line 122
    return (-1);
  }
  {
#line 124
  tmp = fread((void */* __restrict  */)(buffer), (size_t )1, sizeof(buffer), (FILE */* __restrict  */)valfile);
#line 124
  ret = (int )tmp;
  }
#line 125
  if ((unsigned long )ret != sizeof(buffer)) {
    {
#line 126
    fclose(valfile);
    }
#line 127
    return (-1);
  }
  {
#line 130
  tmp___0 = strtol((char const   */* __restrict  */)(buffer), (char **/* __restrict  */)((void *)0),
                   0);
#line 130
  ret = (int )tmp___0;
#line 132
  fclose(valfile);
  }
#line 133
  return (ret);
}
}
#line 194 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static int confidence_iteration___2  ;
#line 195 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static char local_cpu_method___2  ;
#line 196 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static char remote_cpu_method___2  ;
#line 200 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static int client_port_min___2  =    5000;
#line 201 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static int client_port_max___2  =    65535;
#line 580 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static void get_tcp_info___0(int socket___0 , int *mss ) 
{ 
  unsigned int sock_opt_len ;
  int *tmp ;
  struct protoent *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 588
  sock_opt_len = (unsigned int )sizeof(int );
#line 589
  tmp___0 = getprotobyname("tcp");
#line 589
  tmp___1 = getsockopt(socket___0, tmp___0->p_proto, 2, (void */* __restrict  */)((char *)mss),
                       (socklen_t */* __restrict  */)(& sock_opt_len));
  }
#line 589
  if (tmp___1 == -1) {
    {
#line 594
    tmp = __errno_location();
#line 594
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: get_tcp_info: getsockopt TCP_MAXSEG: errno %d\n",
            *tmp);
#line 597
    fflush(where);
#line 598
    *mss = -1;
    }
  }
#line 603
  return;
}
}
#line 605 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static void set_tcp_mss___0(int socket___0 , int mss ) 
{ 
  unsigned int sock_opt_len ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  struct protoent *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 611
  sock_opt_len = (unsigned int )sizeof(int );
#line 612
  tmp___2 = getprotobyname("tcp");
#line 612
  tmp___3 = setsockopt(socket___0, tmp___2->p_proto, 2, (void const   *)((char const   *)(& mss)),
                       sock_opt_len);
  }
#line 612
  if (tmp___3 == -1) {
#line 612
    if (debug) {
      {
#line 617
      tmp = __errno_location();
#line 617
      tmp___0 = __errno_location();
#line 617
      tmp___1 = strerror(*tmp___0);
#line 617
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"netperf: %s: setsockopt TCP_MAXSEG: %s (errno %d)\n",
              "set_tcp_mss", tmp___1, *tmp);
#line 622
      fflush(where);
      }
    }
  }
#line 633
  return;
}
}
#line 655 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static int change_warning_displayed___0  =    0;
#line 952 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static unsigned short get_port_number___2(struct addrinfo *res ) 
{ 
  struct sockaddr_in *foo ;
  uint16_t tmp ;
  struct sockaddr_in6 *foo___0 ;
  uint16_t tmp___0 ;

  {
  {
#line 956
  if (res->ai_family == 2) {
#line 956
    goto case_2;
  }
#line 962
  if (res->ai_family == 10) {
#line 962
    goto case_10;
  }
#line 968
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 957
  foo = (struct sockaddr_in *)res->ai_addr;
#line 958
  tmp = ntohs(foo->sin_port);
  }
#line 958
  return (tmp);
#line 959
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 963
  foo___0 = (struct sockaddr_in6 *)res->ai_addr;
#line 964
  tmp___0 = ntohs(foo___0->sin6_port);
  }
#line 964
  return (tmp___0);
#line 965
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 969
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"Given Unexpected Address Family of %u\n",
          res->ai_family);
#line 971
  fflush(where);
#line 972
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 974
  return ((unsigned short)0);
}
}
#line 1560 "/home/wheatley/newnew/temp/netperf-2.6.0/src/nettest_bsd.c"
static void *get_address_address___0(struct addrinfo *info ) 
{ 
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;

  {
  {
#line 1569
  if (info->ai_family == 2) {
#line 1569
    goto case_2;
  }
#line 1574
  if (info->ai_family == 10) {
#line 1574
    goto case_10;
  }
#line 1579
  goto switch_default;
  case_2: /* CIL Label */ 
#line 1570
  sin = (struct sockaddr_in *)info->ai_addr;
#line 1571
  return ((void *)(& sin->sin_addr));
#line 1572
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1575
  sin6 = (struct sockaddr_in6 *)info->ai_addr;
#line 1576
  return ((void *)(& sin6->sin6_addr));
#line 1577
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1580
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"we never expected to get here in get_address_address\n");
#line 1581
  fflush(stderr);
#line 1582
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1584
  return ((void *)0);
}
}
#line 91 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static uint16_t true_random___0(void) ;
#line 131 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static void get_system_time___0(uuid_time_t *uuid_time ) 
{ 
  struct timeval tp ;

  {
  {
#line 135
  gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((struct timezone *)0));
#line 140
  *uuid_time = (uuid_time_t )((long long )((uint64_t )tp.tv_sec * 10000000UL + (uint64_t )tp.tv_usec * 10UL) + 122192928000000000LL);
  }
#line 143
  return;
}
}
#line 146 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static void get_random_info___0(char *seed ) 
{ 
  FILE *fp ;
  uint16_t myrand ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 154
  fp = fopen((char const   */* __restrict  */)"/dev/urandom", (char const   */* __restrict  */)"rb");
  }
#line 156
  if ((unsigned long )((void *)0) != (unsigned long )fp) {
    {
#line 157
    fread((void */* __restrict  */)seed, sizeof(char ), (size_t )16, (FILE */* __restrict  */)fp);
#line 158
    fclose(fp);
    }
#line 159
    return;
  }
#line 164
  i = 0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 166
    myrand = true_random___0();
#line 167
    tmp = i;
#line 167
    i ++;
#line 167
    *(seed + tmp) = (char )((int )myrand & 255);
#line 168
    tmp___0 = i;
#line 168
    i ++;
#line 168
    *(seed + tmp___0) = (char )((int )myrand >> 8);
    }
#line 165
    if (! (i < 14)) {
#line 165
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  fclose(fp);
  }
#line 172
  return;
}
}
#line 181 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static int inited___2  =    0;
#line 179 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static uint16_t true_random___0(void) 
{ 
  uuid_time_t time_now ;
  int tmp ;

  {
#line 184
  if (! inited___2) {
    {
#line 185
    get_system_time___0(& time_now);
#line 186
    time_now /= 1024UL;
#line 187
    srand((unsigned int )(((time_now >> 32) ^ time_now) & 4294967295UL));
#line 189
    inited___2 = 1;
    }
  }
  {
#line 192
  tmp = rand();
  }
#line 192
  return ((uint16_t )tmp);
}
}
#line 240
static void get_current_time___0(uuid_time_t *timestamp ) ;
#line 240 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static int inited___3  =    0;
#line 241 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static uuid_time_t time_last___0  ;
#line 242 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static uint16_t uuids_this_tick___0  ;
#line 238 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static void get_current_time___0(uuid_time_t *timestamp ) 
{ 
  uuid_time_t time_now ;

  {
#line 245
  if (! inited___3) {
    {
#line 246
    get_system_time___0(& time_now);
#line 247
    uuids_this_tick___0 = (uint16_t )1024;
#line 248
    inited___3 = 1;
    }
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 252
    get_system_time___0(& time_now);
    }
#line 255
    if (time_last___0 != time_now) {
#line 257
      uuids_this_tick___0 = (uint16_t )0;
#line 258
      time_last___0 = time_now;
#line 259
      goto while_break;
    }
#line 261
    if ((int )uuids_this_tick___0 < 1024) {
#line 262
      uuids_this_tick___0 = (uint16_t )((int )uuids_this_tick___0 + 1);
#line 263
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  *timestamp = time_now + (uuid_time_t )uuids_this_tick___0;
#line 269
  return;
}
}
#line 277
static void get_ieee_node_identifier___0(uuid_node_t *node ) ;
#line 277 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static int inited___4  =    0;
#line 278 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static uuid_node_t saved_node___0  ;
#line 275 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static void get_ieee_node_identifier___0(uuid_node_t *node ) 
{ 
  char seed[16] ;

  {
#line 281
  if (! inited___4) {
    {
#line 282
    get_random_info___0((char *)(seed));
#line 283
    seed[0] = (char )((int )seed[0] | 1);
#line 284
    memcpy((void */* __restrict  */)(& saved_node___0), (void const   */* __restrict  */)(seed),
           sizeof(saved_node___0));
    }
  }
#line 286
  inited___4 = 1;
#line 288
  *node = saved_node___0;
#line 289
  return;
}
}
#line 294 "/home/wheatley/newnew/temp/netperf-2.6.0/src/net_uuid.c"
static void format_uuid_v1___0(uuid_t *uuid , uint16_t clock_seq , uuid_time_t timestamp ,
                               uuid_node_t node ) 
{ 


  {
  {
#line 299
  uuid->time_low = (uint32_t )(timestamp & 4294967295UL);
#line 300
  uuid->time_mid = (unsigned short )((timestamp >> 32) & 65535UL);
#line 301
  uuid->time_hi_and_version = (unsigned short )((timestamp >> 48) & 4095UL);
#line 303
  uuid->time_hi_and_version = (uint16_t )((int )uuid->time_hi_and_version | (1 << 12));
#line 304
  uuid->clock_seq_low = (uint8_t )((int )clock_seq & 255);
#line 305
  uuid->clock_seq_hi_and_reserved = (uint8_t )(((int )clock_seq & 16128) >> 8);
#line 306
  uuid->clock_seq_hi_and_reserved = (uint8_t )((int )uuid->clock_seq_hi_and_reserved | 128);
#line 307
  memcpy((void */* __restrict  */)(& uuid->node), (void const   */* __restrict  */)(& node),
         sizeof(uuid->node));
  }
#line 308
  return;
}
}
#line 288 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
static int measuring_cpu___0  ;
#line 2027 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
static char fmtbuf___0[64]  ;
#line 2117 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
static char unitbuf___0[64]  ;
#line 3412 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netlib.c"
static char id_string___0[80]  ;
#line 44 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netperf.c"
char netperf_id[77]  = 
#line 44 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netperf.c"
  {      (char )'@',      (char )'(',      (char )'#',      (char )')', 
        (char )'n',      (char )'e',      (char )'t',      (char )'p', 
        (char )'e',      (char )'r',      (char )'f',      (char )'.', 
        (char )'c',      (char )' ',      (char )'(',      (char )'c', 
        (char )')',      (char )' ',      (char )'C',      (char )'o', 
        (char )'p',      (char )'y',      (char )'r',      (char )'i', 
        (char )'g',      (char )'h',      (char )'t',      (char )' ', 
        (char )'1',      (char )'9',      (char )'9',      (char )'3', 
        (char )'-',      (char )'2',      (char )'0',      (char )'1', 
        (char )'2',      (char )' ',      (char )'H',      (char )'e', 
        (char )'w',      (char )'l',      (char )'e',      (char )'t', 
        (char )'t',      (char )'-',      (char )'P',      (char )'a', 
        (char )'c',      (char )'k',      (char )'a',      (char )'r', 
        (char )'d',      (char )' ',      (char )'C',      (char )'o', 
        (char )'m',      (char )'p',      (char )'a',      (char )'n', 
        (char )'y',      (char )'.',      (char )' ',      (char )'V', 
        (char )'e',      (char )'r',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'2', 
        (char )'.',      (char )'6',      (char )'.',      (char )'0', 
        (char )'\000'};
#line 14 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsys_linux.c"
static void find_cpu_model___0(char **cpu_model ) 
{ 
  char linebuf[256] ;
  char *cret ;
  FILE *proccpu ;
  char *target ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 21
  proccpu = fopen((char const   */* __restrict  */)"/proc/cpuinfo", (char const   */* __restrict  */)"r");
  }
#line 23
  if ((unsigned long )((void *)0) == (unsigned long )proccpu) {
    {
#line 24
    *cpu_model = strdup("fopen");
    }
#line 25
    return;
  }
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 29
    cret = fgets((char */* __restrict  */)(linebuf), 256, (FILE */* __restrict  */)proccpu);
    }
#line 30
    if ((unsigned long )((void *)0) != (unsigned long )cret) {
      {
#line 33
      tmp___0 = strstr((char const   *)(linebuf), "model name");
      }
#line 33
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
        {
#line 35
        target = strtok((char */* __restrict  */)(linebuf), (char const   */* __restrict  */)":");
#line 37
        target = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
#line 39
        tmp = strlen((char const   *)target);
#line 39
        *(target + (tmp - 1UL)) = (char)0;
#line 41
        *cpu_model = strdup((char const   *)(target + 1));
#line 42
        fclose(proccpu);
        }
#line 43
        return;
      }
    }
    {
#line 28
    tmp___1 = feof(proccpu);
    }
#line 28
    if (tmp___1) {
#line 28
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  *cpu_model = strdup("model_name");
#line 48
  fclose(proccpu);
  }
#line 49
  return;
}
}
#line 51 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsys_linux.c"
static int find_cpu_freq___0(void) 
{ 
  char linebuf[256] ;
  char *cret ;
  FILE *proccpu ;
  char *target ;
  double tmp ;
  double tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 58
  proccpu = fopen((char const   */* __restrict  */)"/proc/cpuinfo", (char const   */* __restrict  */)"r");
  }
#line 60
  if ((unsigned long )((void *)0) == (unsigned long )proccpu) {
#line 61
    return (-1);
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 65
    cret = fgets((char */* __restrict  */)(linebuf), 256, (FILE */* __restrict  */)proccpu);
    }
#line 66
    if ((unsigned long )((void *)0) != (unsigned long )cret) {
      {
#line 69
      tmp___1 = strstr((char const   *)(linebuf), "cpu MHz");
      }
#line 69
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
#line 70
        target = strtok((char */* __restrict  */)(linebuf), (char const   */* __restrict  */)":");
#line 71
        target = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
#line 72
        fclose(proccpu);
#line 73
        tmp = strtod((char const   */* __restrict  */)(target + 1), (char **/* __restrict  */)((void *)0));
#line 73
        tmp___0 = rint(tmp);
        }
#line 73
        return ((int )tmp___0);
      }
    }
    {
#line 64
    tmp___2 = feof(proccpu);
    }
#line 64
    if (tmp___2) {
#line 64
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  fclose(proccpu);
  }
#line 78
  return (-1);
}
}
#line 81 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netsys_linux.c"
static void find_system_model___0(char **system_model ) 
{ 


  {
  {
#line 105
  *system_model = strdup("Teach Me SMBIOS");
  }
#line 107
  return;
}
}
#line 60 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
static cpu_states_t lib_start_count___0[256]  ;
#line 61 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
static cpu_states_t lib_end_count___0[256]  ;
#line 69 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
static int proc_stat_fd___0  =    -1;
#line 70 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
static char *proc_stat_buf___0  =    (char *)((void *)0);
#line 71 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
static int proc_stat_buflen___0  =    0;
#line 160 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
static void get_cpu___0(cpu_states_t *res ) 
{ 
  int i ;
  int n ;
  char *p ;

  {
  {
#line 164
  n = lib_num_loc_cpus;
#line 165
  p = proc_stat_buf___0;
#line 167
  lseek(proc_stat_fd___0, (__off_t )0, 0);
#line 168
  read(proc_stat_fd___0, (void *)p, (size_t )proc_stat_buflen___0);
  }
#line 170
  if (debug) {
    {
#line 171
    fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"proc_stat_buf \'%.*s\'\n",
            proc_stat_buflen___0, p);
#line 172
    fflush(where);
    }
  }
#line 175
  if (n > 1) {
    {
#line 175
    p = strchr((char const   *)p, '\n');
    }
  }
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < n)) {
#line 177
      goto while_break;
    }
    {
#line 178
    memset((void *)(res + i), 0, sizeof(*(res + i)));
#line 179
    p = strchr((char const   *)p, ' ');
#line 180
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%llu %llu %llu %llu %llu %llu %llu %llu %llu",
           (unsigned long long *)(& (res + i)->user), (unsigned long long *)(& (res + i)->nice),
           (unsigned long long *)(& (res + i)->sys), (unsigned long long *)(& (res + i)->idle),
           (unsigned long long *)(& (res + i)->iowait), (unsigned long long *)(& (res + i)->hard_irq),
           (unsigned long long *)(& (res + i)->soft_irq), (unsigned long long *)(& (res + i)->steal),
           (unsigned long long *)(& (res + i)->guest));
    }
#line 190
    if (debug) {
      {
#line 191
      fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)"res[%d] is %llu %llu %llu %llu %llu %llu %llu %llu %llu\n",
              i, (unsigned long long )(res + i)->user, (unsigned long long )(res + i)->nice,
              (unsigned long long )(res + i)->sys, (unsigned long long )(res + i)->idle,
              (unsigned long long )(res + i)->iowait, (unsigned long long )(res + i)->hard_irq,
              (unsigned long long )(res + i)->soft_irq, (unsigned long long )(res + i)->steal,
              (unsigned long long )(res + i)->guest);
#line 203
      fflush(where);
      }
    }
    {
#line 205
    p = strchr((char const   *)p, '\n');
#line 177
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
#line 227 "/home/wheatley/newnew/temp/netperf-2.6.0/src/netcpu_procstat.c"
static uint64_t tick_subtract___0(uint64_t start , uint64_t end ) 
{ 


  {
#line 230
  if (end >= start) {
#line 231
    return (end - start);
  } else
#line 230
  if ((unsigned long long )start & 0xffffffff00000000ULL) {
#line 231
    return (end - start);
  }
#line 240
  return ((uint64_t )((unsigned long long )(end - start) + 0xffffffff00000000ULL));
}
}
