/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 74 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
struct track_t {
   int num ;
   int mode ;
   int audio ;
   char *modes ;
   char *extension ;
   int bstart ;
   int bsize ;
   long startsect ;
   long stopsect ;
   long start ;
   long stop ;
   struct track_t *next ;
};
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 89 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
char *basefile  =    (char *)((void *)0);
#line 90 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
char *binfile  =    (char *)((void *)0);
#line 91 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
char *cuefile  =    (char *)((void *)0);
#line 92 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
int verbose  =    0;
#line 93 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
int psxtruncate  =    0;
#line 94 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
int raw  =    0;
#line 95 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
int swabaudio  =    0;
#line 96 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
int towav  =    0;
#line 102 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
void parse_args(int argc , char **argv ) 
{ 
  int s ;

  {
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    s = getopt(argc, (char * const  *)argv, "swvp?hr");
    }
#line 106
    if (! (s != -1)) {
#line 106
      goto while_break;
    }
    {
#line 108
    if (s == 114) {
#line 108
      goto case_114;
    }
#line 111
    if (s == 118) {
#line 111
      goto case_118;
    }
#line 114
    if (s == 119) {
#line 114
      goto case_119;
    }
#line 117
    if (s == 112) {
#line 117
      goto case_112;
    }
#line 120
    if (s == 115) {
#line 120
      goto case_115;
    }
#line 124
    if (s == 104) {
#line 124
      goto case_104;
    }
#line 124
    if (s == 63) {
#line 124
      goto case_104;
    }
#line 107
    goto switch_break;
    case_114: /* CIL Label */ 
#line 109
    raw = 1;
#line 110
    goto switch_break;
    case_118: /* CIL Label */ 
#line 112
    verbose = 1;
#line 113
    goto switch_break;
    case_119: /* CIL Label */ 
#line 115
    towav = 1;
#line 116
    goto switch_break;
    case_112: /* CIL Label */ 
#line 118
    psxtruncate = 1;
#line 119
    goto switch_break;
    case_115: /* CIL Label */ 
#line 121
    swabaudio = 1;
#line 122
    goto switch_break;
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 125
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            "Usage: bchunk [-v] [-r] [-p (PSX)] [-w (wav)] [-s (swabaudio)]\n         <image.bin> <image.cue> <basename>\nExample: bchunk foo.bin foo.cue foo\n  -v  Verbose mode\n  -r  Raw mode for MODE2/2352: write all 2352 bytes from offset 0 (VCD/MPEG)\n  -p  PSX mode for MODE2/2352: write 2336 bytes from offset 24\n      (default MODE2/2352 mode writes 2048 bytes from offset 24)\n  -w  Output audio files in WAV format\n  -s  swabaudio: swap byte order in audio tracks\n");
#line 126
    exit(0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  if (argc - optind != 3) {
    {
#line 131
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            "Usage: bchunk [-v] [-r] [-p (PSX)] [-w (wav)] [-s (swabaudio)]\n         <image.bin> <image.cue> <basename>\nExample: bchunk foo.bin foo.cue foo\n  -v  Verbose mode\n  -r  Raw mode for MODE2/2352: write all 2352 bytes from offset 0 (VCD/MPEG)\n  -p  PSX mode for MODE2/2352: write 2336 bytes from offset 24\n      (default MODE2/2352 mode writes 2048 bytes from offset 24)\n  -w  Output audio files in WAV format\n  -s  swabaudio: swap byte order in audio tracks\n");
#line 132
    exit(1);
    }
  }
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    if (! (optind < argc)) {
#line 135
      goto while_break___0;
    }
    {
#line 137
    if (argc - optind == 3) {
#line 137
      goto case_3;
    }
#line 140
    if (argc - optind == 2) {
#line 140
      goto case_2;
    }
#line 143
    if (argc - optind == 1) {
#line 143
      goto case_1;
    }
#line 146
    goto switch_default;
    case_3: /* CIL Label */ 
    {
#line 138
    binfile = strdup((char const   *)*(argv + optind));
    }
#line 139
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 141
    cuefile = strdup((char const   *)*(argv + optind));
    }
#line 142
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 144
    basefile = strdup((char const   *)*(argv + optind));
    }
#line 145
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 147
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            "Usage: bchunk [-v] [-r] [-p (PSX)] [-w (wav)] [-s (swabaudio)]\n         <image.bin> <image.cue> <basename>\nExample: bchunk foo.bin foo.cue foo\n  -v  Verbose mode\n  -r  Raw mode for MODE2/2352: write all 2352 bytes from offset 0 (VCD/MPEG)\n  -p  PSX mode for MODE2/2352: write 2336 bytes from offset 24\n      (default MODE2/2352 mode writes 2048 bytes from offset 24)\n  -w  Output audio files in WAV format\n  -s  swabaudio: swap byte order in audio tracks\n");
#line 148
    exit(1);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 150
    optind ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 152
  return;
}
}
#line 158 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
long time2frames(char *s ) 
{ 
  int mins ;
  int secs ;
  int frames ;
  char *p ;
  char *t ;

  {
  {
#line 160
  mins = 0;
#line 160
  secs = 0;
#line 160
  frames = 0;
#line 163
  p = strchr((char const   *)s, ':');
  }
#line 163
  if (! p) {
#line 164
    return (-1L);
  }
  {
#line 165
  *p = (char )'\000';
#line 166
  mins = atoi((char const   *)s);
#line 168
  p ++;
#line 169
  t = strchr((char const   *)p, ':');
  }
#line 169
  if (! t) {
#line 170
    return (-1L);
  }
  {
#line 171
  *t = (char )'\000';
#line 172
  secs = atoi((char const   *)p);
#line 174
  t ++;
#line 175
  frames = atoi((char const   *)t);
  }
#line 177
  return ((long )(75 * (mins * 60 + secs) + frames));
}
}
#line 186
void gettrackmode(struct track_t *track , char *modes ) ;
#line 186 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
static char ext_iso[4]  = {      (char )'i',      (char )'s',      (char )'o',      (char )'\000'};
#line 187
void gettrackmode(struct track_t *track , char *modes ) ;
#line 187 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
static char ext_cdr[4]  = {      (char )'c',      (char )'d',      (char )'r',      (char )'\000'};
#line 188
void gettrackmode(struct track_t *track , char *modes ) ;
#line 188 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
static char ext_wav[4]  = {      (char )'w',      (char )'a',      (char )'v',      (char )'\000'};
#line 189
void gettrackmode(struct track_t *track , char *modes ) ;
#line 189 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
static char ext_ugh[4]  = {      (char )'u',      (char )'g',      (char )'h',      (char )'\000'};
#line 184 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
void gettrackmode(struct track_t *track , char *modes ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 191
  track->audio = 0;
#line 193
  tmp___2 = strcasecmp((char const   *)modes, "MODE1/2352");
  }
#line 193
  if (tmp___2) {
    {
#line 198
    tmp___1 = strcasecmp((char const   *)modes, "MODE2/2352");
    }
#line 198
    if (tmp___1) {
      {
#line 214
      tmp___0 = strcasecmp((char const   *)modes, "MODE2/2336");
      }
#line 214
      if (tmp___0) {
        {
#line 222
        tmp = strcasecmp((char const   *)modes, "AUDIO");
        }
#line 222
        if (tmp) {
          {
#line 231
          printf((char const   */* __restrict  */)"(?) ");
#line 232
          track->bstart = 0;
#line 233
          track->bsize = 2352;
#line 234
          track->extension = ext_ugh;
          }
        } else {
#line 223
          track->bstart = 0;
#line 224
          track->bsize = 2352;
#line 225
          track->audio = 1;
#line 226
          if (towav) {
#line 227
            track->extension = ext_wav;
          } else {
#line 229
            track->extension = ext_cdr;
          }
        }
      } else {
#line 218
        track->bstart = 16;
#line 219
        track->bsize = 2336;
#line 220
        track->extension = ext_iso;
      }
    } else {
#line 199
      track->extension = ext_iso;
#line 200
      if (raw) {
#line 202
        track->bstart = 0;
#line 203
        track->bsize = 2352;
      } else
#line 204
      if (psxtruncate) {
#line 206
        track->bstart = 0;
#line 207
        track->bsize = 2336;
      } else {
#line 210
        track->bstart = 24;
#line 211
        track->bsize = 2048;
      }
    }
  } else {
#line 194
    track->bstart = 16;
#line 195
    track->bsize = 2048;
#line 196
    track->extension = ext_iso;
  }
#line 236
  return;
}
}
#line 244 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
static char s[80]  ;
#line 242 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
char *progressbar(float f , int l ) 
{ 
  int i ;
  int n ;

  {
#line 247
  n = (int )((float )l * f);
#line 248
  i = 0;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! (i < n)) {
#line 248
      goto while_break;
    }
#line 249
    s[i] = (char )'*';
#line 248
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 251
    if (! (i < l)) {
#line 251
      goto while_break___0;
    }
#line 252
    s[i] = (char )' ';
#line 251
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 254
  s[i] = (char )'\000';
#line 256
  return (s);
}
}
#line 263 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
int writetrack(FILE *bf , struct track_t *track , char *bname ) 
{ 
  char *fname ;
  FILE *f ;
  char buf[2362] ;
  long sz ;
  long sect ;
  long realsz ;
  long reallen ;
  char c ;
  char *p ;
  char *p2 ;
  char *ep ;
  int32_t l ;
  int16_t i ;
  float fl ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint16_t tmp___14 ;
  uint16_t tmp___15 ;
  uint16_t tmp___16 ;
  uint16_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t tmp___25 ;
  uint16_t tmp___26 ;
  uint16_t tmp___27 ;
  uint16_t tmp___28 ;
  uint16_t tmp___29 ;
  uint32_t tmp___30 ;
  uint32_t tmp___31 ;
  uint32_t tmp___32 ;
  uint32_t tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  size_t tmp___36 ;
  char *tmp___37 ;
  size_t tmp___38 ;
  char *tmp___39 ;
  int *tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  int *tmp___43 ;
  char *tmp___44 ;
  int tmp___45 ;

  {
  {
#line 274
  tmp = strlen((char const   *)bname);
#line 274
  tmp___0 = malloc(tmp + 8UL);
#line 274
  fname = (char *)tmp___0;
  }
#line 274
  if (! fname) {
    {
#line 275
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"main(): malloc() failed, out of memory\n");
#line 276
    exit(4);
    }
  }
  {
#line 278
  sprintf((char */* __restrict  */)fname, (char const   */* __restrict  */)"%s%2.2d.%s",
          bname, track->num, track->extension);
#line 280
  printf((char const   */* __restrict  */)"%2d: %s ", track->num, fname);
#line 282
  f = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
  }
#line 282
  if (! f) {
    {
#line 283
    tmp___1 = __errno_location();
#line 283
    tmp___2 = strerror(*tmp___1);
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Could not fopen track file: %s\n",
            tmp___2);
#line 284
    exit(4);
    }
  }
  {
#line 287
  tmp___5 = fseek(bf, track->start, 0);
  }
#line 287
  if (tmp___5) {
    {
#line 288
    tmp___3 = __errno_location();
#line 288
    tmp___4 = strerror(*tmp___3);
#line 288
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Could not fseek to track location: %s\n",
            tmp___4);
#line 289
    exit(4);
    }
  }
#line 292
  reallen = ((track->stopsect - track->startsect) + 1L) * (long )track->bsize;
#line 293
  if (verbose) {
    {
#line 294
    printf((char const   */* __restrict  */)"\n mmc sectors %ld->%ld (%ld)", track->startsect,
           track->stopsect, (track->stopsect - track->startsect) + 1L);
#line 295
    printf((char const   */* __restrict  */)"\n mmc bytes %ld->%ld (%ld)", track->start,
           track->stop, (track->stop - track->start) + 1L);
#line 296
    printf((char const   */* __restrict  */)"\n sector data at %d, %d bytes per sector",
           track->bstart, track->bsize);
#line 297
    printf((char const   */* __restrict  */)"\n real data %ld bytes", ((track->stopsect - track->startsect) + 1L) * (long )track->bsize);
#line 298
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 301
  printf((char const   */* __restrict  */)"                                          ");
  }
#line 303
  if (track->audio) {
#line 303
    if (towav) {
      {
#line 305
      fputs((char const   */* __restrict  */)"RIFF", (FILE */* __restrict  */)f);
#line 306
      tmp___6 = htonl((uint32_t )(((reallen + 8L) + 24L) + 4L));
#line 306
      tmp___7 = htonl((uint32_t )(((reallen + 8L) + 24L) + 4L));
#line 306
      tmp___8 = htonl((uint32_t )(((reallen + 8L) + 24L) + 4L));
#line 306
      tmp___9 = htonl((uint32_t )(((reallen + 8L) + 24L) + 4L));
#line 306
      l = (int32_t )(((((tmp___6 & 4278190080U) >> 24) | ((tmp___7 & 16711680U) >> 8)) | ((tmp___8 & 65280U) << 8)) | ((tmp___9 & 255U) << 24));
#line 307
      fwrite((void const   */* __restrict  */)(& l), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 308
      fputs((char const   */* __restrict  */)"WAVE", (FILE */* __restrict  */)f);
#line 310
      fputs((char const   */* __restrict  */)"fmt ", (FILE */* __restrict  */)f);
#line 311
      tmp___10 = htonl((uint32_t )16);
#line 311
      tmp___11 = htonl((uint32_t )16);
#line 311
      tmp___12 = htonl((uint32_t )16);
#line 311
      tmp___13 = htonl((uint32_t )16);
#line 311
      l = (int32_t )(((((tmp___10 & 4278190080U) >> 24) | ((tmp___11 & 16711680U) >> 8)) | ((tmp___12 & 65280U) << 8)) | ((tmp___13 & 255U) << 24));
#line 312
      fwrite((void const   */* __restrict  */)(& l), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 313
      tmp___14 = htons((uint16_t )1);
#line 313
      tmp___15 = htons((uint16_t )1);
#line 313
      i = (int16_t )((((int )tmp___14 >> 8) & 255) | (((int )tmp___15 & 255) << 8));
#line 314
      fwrite((void const   */* __restrict  */)(& i), (size_t )2, (size_t )1, (FILE */* __restrict  */)f);
#line 315
      tmp___16 = htons((uint16_t )2);
#line 315
      tmp___17 = htons((uint16_t )2);
#line 315
      i = (int16_t )((((int )tmp___16 >> 8) & 255) | (((int )tmp___17 & 255) << 8));
#line 316
      fwrite((void const   */* __restrict  */)(& i), (size_t )2, (size_t )1, (FILE */* __restrict  */)f);
#line 317
      tmp___18 = htonl((uint32_t )44100);
#line 317
      tmp___19 = htonl((uint32_t )44100);
#line 317
      tmp___20 = htonl((uint32_t )44100);
#line 317
      tmp___21 = htonl((uint32_t )44100);
#line 317
      l = (int32_t )(((((tmp___18 & 4278190080U) >> 24) | ((tmp___19 & 16711680U) >> 8)) | ((tmp___20 & 65280U) << 8)) | ((tmp___21 & 255U) << 24));
#line 318
      fwrite((void const   */* __restrict  */)(& l), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 319
      tmp___22 = htonl((uint32_t )176400);
#line 319
      tmp___23 = htonl((uint32_t )176400);
#line 319
      tmp___24 = htonl((uint32_t )176400);
#line 319
      tmp___25 = htonl((uint32_t )176400);
#line 319
      l = (int32_t )(((((tmp___22 & 4278190080U) >> 24) | ((tmp___23 & 16711680U) >> 8)) | ((tmp___24 & 65280U) << 8)) | ((tmp___25 & 255U) << 24));
#line 320
      fwrite((void const   */* __restrict  */)(& l), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
#line 321
      tmp___26 = htons((uint16_t )4);
#line 321
      tmp___27 = htons((uint16_t )4);
#line 321
      i = (int16_t )((((int )tmp___26 >> 8) & 255) | (((int )tmp___27 & 255) << 8));
#line 322
      fwrite((void const   */* __restrict  */)(& i), (size_t )2, (size_t )1, (FILE */* __restrict  */)f);
#line 323
      tmp___28 = htons((uint16_t )16);
#line 323
      tmp___29 = htons((uint16_t )16);
#line 323
      i = (int16_t )((((int )tmp___28 >> 8) & 255) | (((int )tmp___29 & 255) << 8));
#line 324
      fwrite((void const   */* __restrict  */)(& i), (size_t )2, (size_t )1, (FILE */* __restrict  */)f);
#line 326
      fputs((char const   */* __restrict  */)"data", (FILE */* __restrict  */)f);
#line 327
      tmp___30 = htonl((uint32_t )reallen);
#line 327
      tmp___31 = htonl((uint32_t )reallen);
#line 327
      tmp___32 = htonl((uint32_t )reallen);
#line 327
      tmp___33 = htonl((uint32_t )reallen);
#line 327
      l = (int32_t )(((((tmp___30 & 4278190080U) >> 24) | ((tmp___31 & 16711680U) >> 8)) | ((tmp___32 & 65280U) << 8)) | ((tmp___33 & 255U) << 24));
#line 328
      fwrite((void const   */* __restrict  */)(& l), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
      }
    }
  }
#line 331
  realsz = 0L;
#line 332
  sz = track->start;
#line 333
  sect = track->startsect;
#line 334
  fl = (float )0;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (sect <= track->stopsect) {
      {
#line 335
      tmp___38 = fread((void */* __restrict  */)(buf), (size_t )2352, (size_t )1,
                       (FILE */* __restrict  */)bf);
      }
#line 335
      if (! (tmp___38 > 0UL)) {
#line 335
        goto while_break;
      }
    } else {
#line 335
      goto while_break;
    }
#line 336
    if (track->audio) {
#line 337
      if (swabaudio) {
#line 339
        p = & buf[track->bstart];
#line 340
        ep = p + track->bsize;
        {
#line 341
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 341
          if (! ((unsigned long )p < (unsigned long )ep)) {
#line 341
            goto while_break___0;
          }
#line 342
          p2 = p + 1;
#line 343
          c = *p;
#line 344
          *p = *p2;
#line 345
          *p2 = c;
#line 346
          p += 2;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    {
#line 350
    tmp___36 = fwrite((void const   */* __restrict  */)(& buf[track->bstart]), (size_t )track->bsize,
                      (size_t )1, (FILE */* __restrict  */)f);
    }
#line 350
    if (tmp___36 < 1UL) {
      {
#line 351
      tmp___34 = __errno_location();
#line 351
      tmp___35 = strerror(*tmp___34);
#line 351
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Could not write to track: %s\n",
              tmp___35);
#line 352
      exit(4);
      }
    }
#line 354
    sect ++;
#line 355
    sz += 2352L;
#line 356
    realsz += (long )track->bsize;
#line 357
    if ((sz / 2352L) % 500L == 0L) {
      {
#line 358
      fl = (float )realsz / (float )reallen;
#line 359
      tmp___37 = progressbar(fl, 20);
#line 359
      printf((char const   */* __restrict  */)"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b%4ld/%-4ld MB  [%s] %3.0f %%",
             (realsz / 1024L) / 1024L, (reallen / 1024L) / 1024L, tmp___37, (double )(fl * (float )100));
#line 360
      fflush(stdout);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 364
  fl = (float )realsz / (float )reallen;
#line 365
  tmp___39 = progressbar((float )1, 20);
#line 365
  printf((char const   */* __restrict  */)"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b%4ld/%-4ld MB  [%s] %3.0f %%",
         (realsz / 1024L) / 1024L, (reallen / 1024L) / 1024L, tmp___39, (double )(fl * (float )100));
#line 366
  fflush(stdout);
#line 368
  tmp___42 = ferror(bf);
  }
#line 368
  if (tmp___42) {
    {
#line 369
    tmp___40 = __errno_location();
#line 369
    tmp___41 = strerror(*tmp___40);
#line 369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Could not read from %s: %s\n",
            binfile, tmp___41);
#line 370
    exit(4);
    }
  }
  {
#line 373
  tmp___45 = fclose(f);
  }
#line 373
  if (tmp___45) {
    {
#line 374
    tmp___43 = __errno_location();
#line 374
    tmp___44 = strerror(*tmp___43);
#line 374
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Could not fclose track file: %s\n",
            tmp___44);
#line 375
    exit(4);
    }
  }
  {
#line 378
  printf((char const   */* __restrict  */)"\n");
  }
#line 379
  return (0);
}
}
#line 386 "/home/june/collector/temp/bchunk-1.2.0/bchunk.c"
int main(int argc , char **argv ) 
{ 
  char s___0[1025] ;
  char *p ;
  char *t ;
  int i ;
  int idx ;
  struct track_t *tracks ;
  struct track_t *track ;
  struct track_t *prevtrack ;
  struct track_t **prevp ;
  FILE *binf ;
  FILE *cuef ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  char *tmp___9 ;
  long tmp___10 ;

  {
  {
#line 391
  tracks = (struct track_t *)((void *)0);
#line 392
  track = (struct track_t *)((void *)0);
#line 393
  prevtrack = (struct track_t *)((void *)0);
#line 394
  prevp = & tracks;
#line 398
  printf((char const   */* __restrict  */)"%s", "binchunker for Unix, version 1.2.0 by Heikki Hannikainen <hessu@hes.iki.fi>\n\tCreated with the kind help of Bob Marietta <marietrg@SLU.EDU>,\n\tpartly based on his Pascal (Delphi) implementation.\n\tSupport for MODE2/2352 ISO tracks thanks to input from\n\tGodmar Back <gback@cs.utah.edu>, Colas Nahaboo <Colas@Nahaboo.com>\n\tand Matthew Green <mrg@eterna.com.au>.\n\tReleased under the GNU GPL, version 2 or later (at your option).\n\n");
#line 400
  parse_args(argc, argv);
#line 402
  binf = fopen((char const   */* __restrict  */)binfile, (char const   */* __restrict  */)"r");
  }
#line 402
  if (! binf) {
    {
#line 403
    tmp = __errno_location();
#line 403
    tmp___0 = strerror(*tmp);
#line 403
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open BIN %s: %s\n",
            binfile, tmp___0);
    }
#line 404
    return (2);
  }
  {
#line 407
  cuef = fopen((char const   */* __restrict  */)cuefile, (char const   */* __restrict  */)"r");
  }
#line 407
  if (! cuef) {
    {
#line 408
    tmp___1 = __errno_location();
#line 408
    tmp___2 = strerror(*tmp___1);
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open CUE %s: %s\n",
            cuefile, tmp___2);
    }
#line 409
    return (2);
  }
  {
#line 412
  printf((char const   */* __restrict  */)"Reading the CUE file:\n");
#line 415
  tmp___5 = fgets((char */* __restrict  */)(s___0), 1024, (FILE */* __restrict  */)cuef);
  }
#line 415
  if (! tmp___5) {
    {
#line 416
    tmp___3 = __errno_location();
#line 416
    tmp___4 = strerror(*tmp___3);
#line 416
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not read first line from %s: %s\n",
            cuefile, tmp___4);
    }
#line 417
    return (3);
  }
#line 420
  i = 0;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 421
    tmp___9 = fgets((char */* __restrict  */)(s___0), 1024, (FILE */* __restrict  */)cuef);
    }
#line 421
    if (! tmp___9) {
#line 421
      goto while_break;
    }
    {
#line 422
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 422
      p = strchr((char const   *)(s___0), '\r');
      }
#line 422
      if (! p) {
        {
#line 422
        p = strchr((char const   *)(s___0), '\n');
        }
#line 422
        if (! p) {
#line 422
          goto while_break___0;
        }
      }
#line 423
      *p = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 425
    p = strstr((char const   *)(s___0), "TRACK");
    }
#line 425
    if (p) {
      {
#line 426
      printf((char const   */* __restrict  */)"\nTrack ");
#line 427
      p = strchr((char const   *)p, ' ');
      }
#line 427
      if (! p) {
        {
#line 428
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"... ouch, no space after TRACK.\n");
        }
#line 429
        goto while_continue;
      }
      {
#line 431
      p ++;
#line 432
      t = strchr((char const   *)p, ' ');
      }
#line 432
      if (! t) {
        {
#line 433
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"... ouch, no space after track number.\n");
        }
#line 434
        goto while_continue;
      }
      {
#line 436
      *t = (char )'\000';
#line 438
      prevtrack = track;
#line 439
      tmp___6 = malloc(sizeof(struct track_t ));
#line 439
      track = (struct track_t *)tmp___6;
      }
#line 439
      if (! track) {
        {
#line 440
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"main(): malloc() failed, out of memory\n");
#line 441
        exit(4);
        }
      }
      {
#line 443
      *prevp = track;
#line 444
      prevp = & track->next;
#line 445
      track->next = (struct track_t *)((void *)0);
#line 446
      track->num = atoi((char const   *)p);
#line 448
      p = t + 1;
#line 449
      printf((char const   */* __restrict  */)"%2d: %-12.12s ", track->num, p);
#line 450
      track->modes = strdup((char const   *)p);
#line 451
      track->extension = (char *)((void *)0);
#line 452
      track->mode = 0;
#line 453
      track->audio = 0;
#line 454
      tmp___7 = -1;
#line 454
      track->bstart = tmp___7;
#line 454
      track->bsize = tmp___7;
#line 455
      track->bsize = -1;
#line 456
      tmp___8 = -1L;
#line 456
      track->stopsect = tmp___8;
#line 456
      track->startsect = tmp___8;
#line 458
      gettrackmode(track, p);
      }
    } else {
      {
#line 460
      p = strstr((char const   *)(s___0), "INDEX");
      }
#line 460
      if (p) {
        {
#line 461
        p = strchr((char const   *)p, ' ');
        }
#line 461
        if (! p) {
          {
#line 462
          printf((char const   */* __restrict  */)"... ouch, no space after INDEX.\n");
          }
#line 463
          goto while_continue;
        }
        {
#line 465
        p ++;
#line 466
        t = strchr((char const   *)p, ' ');
        }
#line 466
        if (! t) {
          {
#line 467
          printf((char const   */* __restrict  */)"... ouch, no space after index number.\n");
          }
#line 468
          goto while_continue;
        }
        {
#line 470
        *t = (char )'\000';
#line 471
        t ++;
#line 472
        idx = atoi((char const   *)p);
#line 473
        printf((char const   */* __restrict  */)" %s %s", p, t);
#line 474
        track->startsect = time2frames(t);
#line 475
        track->start = track->startsect * 2352L;
        }
#line 476
        if (verbose) {
          {
#line 477
          printf((char const   */* __restrict  */)" (startsect %ld ofs %ld)", track->startsect,
                 track->start);
          }
        }
#line 478
        if (prevtrack) {
#line 478
          if (prevtrack->stopsect < 0L) {
#line 479
            prevtrack->stopsect = track->startsect - 1L;
#line 480
            prevtrack->stop = track->start - 1L;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 485
  if (track) {
    {
#line 486
    fseek(binf, 0L, 2);
#line 487
    tmp___10 = ftell(binf);
#line 487
    track->stop = tmp___10 - 1L;
#line 488
    track->stopsect = track->stop / 2352L;
    }
  }
  {
#line 491
  printf((char const   */* __restrict  */)"\n\n");
#line 494
  printf((char const   */* __restrict  */)"Writing tracks:\n\n");
#line 495
  track = tracks;
  }
  {
#line 495
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 495
    if (! track) {
#line 495
      goto while_break___1;
    }
    {
#line 496
    writetrack(binf, track, basefile);
#line 495
    track = track->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 498
  fclose(binf);
#line 499
  fclose(cuef);
  }
#line 501
  return (0);
}
}
