/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 22 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.h"
enum __anonenum_BrInitError_1 {
    BR_INIT_ERROR_NOMEM = 0,
    BR_INIT_ERROR_OPEN_MAPS = 1,
    BR_INIT_ERROR_READ_MAPS = 2,
    BR_INIT_ERROR_INVALID_MAPS = 3,
    BR_INIT_ERROR_DISABLED = 4
} ;
#line 22 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.h"
typedef enum __anonenum_BrInitError_1 BrInitError;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 327 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
struct __anonstruct_flags_44 {
   unsigned int foreground : 1 ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 34 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.h"
struct miredo_conf;
#line 34 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.h"
typedef struct miredo_conf miredo_conf;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 90
struct sockaddr_in6;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_35 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_35 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 50 "../libteredo/teredo.h"
struct __anonstruct_teredo_39 {
   uint32_t prefix ;
   uint32_t server_ip ;
   uint16_t flags ;
   uint16_t client_port ;
   uint32_t client_ip ;
};
#line 50 "../libteredo/teredo.h"
union teredo_addr {
   struct in6_addr ip6 ;
   struct __anonstruct_teredo_39 teredo ;
   uint32_t t6_addr32[4] ;
};
#line 48 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
struct setting {
   char *name ;
   char *value ;
   unsigned int line ;
   struct setting *next ;
};
#line 57 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
struct miredo_conf {
   struct setting *head ;
   struct setting *tail ;
   void (*logger)(void * , _Bool  , char const   * , va_list  ) ;
   void *logger_data ;
};
#line 494 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
struct miredo_conf_syslog_facility {
   char const   *str ;
   int facility ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 207 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.c"
union __anonunion_68 {
   int __in ;
   int __i ;
};
#line 216 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.c"
union __anonunion_69 {
   int __in ;
   int __i ;
};
#line 214 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.c"
union __anonunion_70 {
   int __in ;
   int __i ;
};
#line 205 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.c"
union __anonunion_71 {
   int __in ;
   int __i ;
};
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_17 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_17 pthread_mutex_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 24 "/usr/include/netinet/ip6.h"
struct ip6_hdrctl {
   uint32_t ip6_un1_flow ;
   uint16_t ip6_un1_plen ;
   uint8_t ip6_un1_nxt ;
   uint8_t ip6_un1_hlim ;
};
#line 24 "/usr/include/netinet/ip6.h"
union __anonunion_ip6_ctlun_39 {
   struct ip6_hdrctl ip6_un1 ;
   uint8_t ip6_un2_vfc ;
};
#line 24 "/usr/include/netinet/ip6.h"
struct ip6_hdr {
   union __anonunion_ip6_ctlun_39 ip6_ctlun ;
   struct in6_addr ip6_src ;
   struct in6_addr ip6_dst ;
};
#line 38 "/usr/include/netinet/icmp6.h"
union __anonunion_icmp6_dataun_40 {
   uint32_t icmp6_un_data32[1] ;
   uint16_t icmp6_un_data16[2] ;
   uint8_t icmp6_un_data8[4] ;
};
#line 38 "/usr/include/netinet/icmp6.h"
struct icmp6_hdr {
   uint8_t icmp6_type ;
   uint8_t icmp6_code ;
   uint16_t icmp6_cksum ;
   union __anonunion_icmp6_dataun_40 icmp6_dataun ;
};
#line 111 "/usr/include/netinet/icmp6.h"
struct nd_router_solicit {
   struct icmp6_hdr nd_rs_hdr ;
};
#line 122 "/usr/include/netinet/icmp6.h"
struct nd_router_advert {
   struct icmp6_hdr nd_ra_hdr ;
   uint32_t nd_ra_reachable ;
   uint32_t nd_ra_retransmit ;
};
#line 201 "/usr/include/netinet/icmp6.h"
struct nd_opt_prefix_info {
   uint8_t nd_opt_pi_type ;
   uint8_t nd_opt_pi_len ;
   uint8_t nd_opt_pi_prefix_len ;
   uint8_t nd_opt_pi_flags_reserved ;
   uint32_t nd_opt_pi_valid_time ;
   uint32_t nd_opt_pi_preferred_time ;
   uint32_t nd_opt_pi_reserved2 ;
   struct in6_addr nd_opt_pi_prefix ;
};
#line 226 "/usr/include/netinet/icmp6.h"
struct nd_opt_mtu {
   uint8_t nd_opt_mtu_type ;
   uint8_t nd_opt_mtu_len ;
   uint16_t nd_opt_mtu_reserved ;
   uint32_t nd_opt_mtu_mtu ;
};
#line 27 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.h"
struct teredo_server;
#line 27 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.h"
typedef struct teredo_server teredo_server;
#line 119 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.h"
struct teredo_orig_ind {
   uint8_t orig_zero ;
   uint8_t orig_code ;
   uint16_t orig_port ;
   uint32_t orig_addr ;
};
#line 41 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo-udp.h"
union __anonunion_buf_56 {
   uint64_t align[1] ;
   uint8_t fill[65507] ;
};
#line 41 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo-udp.h"
struct teredo_packet {
   struct ip6_hdr *ip6 ;
   size_t ip6_len ;
   uint32_t source_ipv4 ;
   uint16_t source_port ;
   uint16_t orig_port ;
   uint32_t orig_ipv4 ;
   uint32_t dest_ipv4 ;
   _Bool auth_present ;
   _Bool auth_fail ;
   uint8_t auth_nonce[8] ;
   union __anonunion_buf_56 buf ;
};
#line 62 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
struct teredo_server {
   pthread_t t1 ;
   pthread_t t2 ;
   int fd_primary ;
   int fd_secondary ;
   uint32_t server_ip ;
   uint32_t server_ip2 ;
   uint32_t prefix ;
   uint32_t advLinkMTU ;
   union teredo_addr lladdr ;
};
#line 85 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
struct __anonstruct_ra_57 {
   struct ip6_hdr ip6 ;
   struct nd_router_advert ra ;
   struct nd_opt_prefix_info pi ;
   struct nd_opt_mtu mtu ;
};
#line 327 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
struct __anonstruct_flags_44___0 {
   unsigned int foreground : 1 ;
};
#line 207 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.c"
union __anonunion_68___0 {
   int __in ;
   int __i ;
};
#line 216 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.c"
union __anonunion_69___0 {
   int __in ;
   int __i ;
};
#line 214 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.c"
union __anonunion_70___0 {
   int __in ;
   int __i ;
};
#line 205 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.c"
union __anonunion_71___0 {
   int __in ;
   int __i ;
};
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 38 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 91 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 103 "/usr/include/time.h"
typedef __timer_t timer_t;
#line 161 "/usr/include/time.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 168
struct sigevent;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 307 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigev_thread_21 {
   void (*_function)(sigval_t  ) ;
   pthread_attr_t *_attribute ;
};
#line 307 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sigev_un_20 {
   int _pad[64UL / sizeof(int ) - 4UL] ;
   __pid_t _tid ;
   struct __anonstruct__sigev_thread_21 _sigev_thread ;
};
#line 307 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct sigevent {
   sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_20 _sigev_un ;
};
#line 37 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.h"
typedef unsigned long teredo_clock_t;
#line 41 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
struct clock_data_t {
   timer_t handle ;
   teredo_clock_t value ;
   _Bool active ;
};
#line 41 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
typedef struct clock_data_t clock_data_t;
#line 82 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
struct __anonstruct_priv_55 {
   pthread_mutex_t lock ;
   clockid_t id ;
   _Bool present ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_12 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_12 pthread_mutexattr_t;
#line 29 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.h"
struct teredo_queue;
#line 29 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.h"
typedef struct teredo_queue teredo_queue;
#line 31 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.h"
struct teredo_peer {
   teredo_queue *queue ;
   size_t queue_left ;
   teredo_clock_t last_rx ;
   teredo_clock_t last_tx ;
   uint32_t mapped_addr ;
   uint16_t mapped_port ;
   unsigned int trusted : 1 ;
   unsigned int bubbles : 3 ;
   unsigned int pings : 3 ;
   unsigned int last_ping : 9 ;
};
#line 31 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.h"
typedef struct teredo_peer teredo_peer;
#line 89
struct teredo_peerlist;
#line 89 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.h"
typedef struct teredo_peerlist teredo_peerlist;
#line 57 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
struct teredo_queue {
   teredo_queue *next ;
   size_t length ;
   uint32_t ipv4 ;
   uint16_t port ;
   _Bool incoming ;
   uint8_t data[] ;
};
#line 159 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
struct teredo_listitem {
   union teredo_addr key ;
   struct teredo_listitem **pprev ;
   struct teredo_listitem *next ;
   teredo_peer peer ;
};
#line 159 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
typedef struct teredo_listitem teredo_listitem;
#line 166 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
struct teredo_peerlist {
   teredo_listitem *recent ;
   teredo_listitem *old ;
   unsigned int left ;
   unsigned int expiration ;
   pthread_t gc ;
   pthread_mutex_t lock ;
   void *root ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_4 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_5 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_4 __wait_terminated ;
   struct __anonstruct___wait_stopped_5 __wait_stopped ;
};
#line 33 "/usr/include/netinet/icmp6.h"
struct icmp6_filter {
   uint32_t icmp6_filt[8] ;
};
#line 61 "../libtun6/tun6.h"
struct tun6;
#line 61 "../libtun6/tun6.h"
typedef struct tun6 tun6;
#line 83 "../libteredo/tunnel.h"
struct teredo_tunnel;
#line 83 "../libteredo/tunnel.h"
typedef struct teredo_tunnel teredo_tunnel;
#line 25 "/home/wheatley/newnew/temp/miredo-1.2.6/src/privproc.h"
struct miredo_tunnel_settings {
   struct in6_addr addr ;
   uint16_t mtu ;
};
#line 86 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
struct miredo_tunnel {
   tun6 *tunnel ;
   int priv_fd ;
   teredo_tunnel *relay ;
};
#line 86 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
typedef struct miredo_tunnel miredo_tunnel;
#line 393 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
struct __anonstruct_pbuf_81 {
   struct ip6_hdr ip6 ;
   uint8_t fill[65467] ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 242 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 127 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
#line 341 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
union __anonunion_w_31 {
   uint16_t word ;
   uint8_t bytes[2] ;
};
#line 63 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.h"
typedef unsigned char md5_byte_t;
#line 64 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.h"
typedef unsigned int md5_word_t;
#line 67 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.h"
struct md5_state_s {
   md5_word_t count[2] ;
   md5_word_t abcd[4] ;
   md5_byte_t buf[64] ;
};
#line 67 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.h"
typedef struct md5_state_s md5_state_t;
#line 57 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
union __anonunion_inner_key_40 {
   unsigned char key[16] ;
   unsigned char ipad[64] ;
};
#line 63 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
union __anonunion_outer_key_41 {
   unsigned char key[16] ;
   unsigned char opad[64] ;
};
#line 173 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_17 {
   int __lock ;
   unsigned int __nr_readers ;
   unsigned int __readers_wakeup ;
   unsigned int __writer_wakeup ;
   unsigned int __nr_readers_queued ;
   unsigned int __nr_writers_queued ;
   int __writer ;
   int __shared ;
   unsigned long __pad1 ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 173 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_rwlock_t_16 {
   struct __anonstruct___data_17 __data ;
   char __size[56] ;
   long __align ;
};
#line 173 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlock_t_16 pthread_rwlock_t;
#line 215 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_rwlockattr_t_18 {
   char __size[8] ;
   long __align ;
};
#line 215 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlockattr_t_18 pthread_rwlockattr_t;
#line 41 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo-udp.h"
typedef struct teredo_packet teredo_packet;
#line 30 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.h"
struct teredo_state {
   union teredo_addr addr ;
   uint32_t ipv4 ;
   uint16_t mtu ;
   _Bool up ;
};
#line 30 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.h"
typedef struct teredo_state teredo_state;
#line 52
struct teredo_maintenance;
#line 52 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.h"
typedef struct teredo_maintenance teredo_maintenance;
#line 62 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
struct __anonstruct_ratelimit_49 {
   pthread_mutex_t lock ;
   int count ;
   teredo_clock_t last ;
};
#line 62 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
struct __anonstruct_recv_50 {
   pthread_t thread ;
   _Bool running ;
};
#line 62 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
struct teredo_tunnel {
   struct teredo_peerlist *list ;
   void *opaque ;
   struct teredo_maintenance *maintenance ;
   void (*up_cb)(void *opaque , struct in6_addr  const  *addr , uint16_t mtu ) ;
   void (*down_cb)(void *opaque ) ;
   void (*recv_cb)(void *opaque , void const   *data , size_t len ) ;
   void (*icmpv6_cb)(void *opaque , void const   *data , size_t len , struct in6_addr  const  *dst ) ;
   teredo_state state ;
   pthread_rwlock_t state_lock ;
   struct __anonstruct_ratelimit_49 ratelimit ;
   struct __anonstruct_recv_50 recv ;
   int fd ;
};
#line 125 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
struct __anonstruct_buf_51 {
   struct icmp6_hdr hdr ;
   char fill[(1280UL - sizeof(struct ip6_hdr )) - sizeof(struct icmp6_hdr )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 186 "/usr/include/netinet/icmp6.h"
struct nd_opt_hdr {
   uint8_t nd_opt_type ;
   uint8_t nd_opt_len ;
};
#line 123 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
struct __anonstruct_rs_29 {
   struct ip6_hdr ip6 ;
   struct nd_router_solicit rs ;
};
#line 277 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
struct __anonstruct_ping_30 {
   struct ip6_hdr ip6 ;
   struct icmp6_hdr icmp6 ;
   uint8_t payload[18] ;
};
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_15 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_15 fd_set;
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_41 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_42 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_41 ifr_ifrn ;
   union __anonunion_ifr_ifru_42 ifr_ifru ;
};
#line 61 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
struct in6_ifreq {
   struct in6_addr ifr6_addr ;
   uint32_t ifr6_prefixlen ;
   int ifr6_ifindex ;
};
#line 57 "/usr/include/net/route.h"
struct in6_rtmsg {
   struct in6_addr rtmsg_dst ;
   struct in6_addr rtmsg_src ;
   struct in6_addr rtmsg_gateway ;
   u_int32_t rtmsg_type ;
   u_int16_t rtmsg_dst_len ;
   u_int16_t rtmsg_src_len ;
   u_int32_t rtmsg_metric ;
   unsigned long rtmsg_info ;
   u_int32_t rtmsg_flags ;
   int rtmsg_ifindex ;
};
#line 70 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
struct __anonstruct_tun_head_t_46 {
   uint16_t flags ;
   uint16_t proto ;
};
#line 70 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
typedef struct __anonstruct_tun_head_t_46 tun_head_t;
#line 134 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
struct tun6 {
   int id ;
   int fd ;
   int reqfd ;
};
#line 523 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
union __anonunion_r_47 {
   struct in6_ifreq req6 ;
   struct ifreq req ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_8 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_7 {
   struct __anonstruct___data_8 __data ;
   char __size[48] ;
   long long __align ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_7 pthread_cond_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_9 {
   char __size[4] ;
   int __align ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_9 pthread_condattr_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 534 "/usr/include/pthread.h"
struct __anonstruct___cancel_jmp_buf_50 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 534 "/usr/include/pthread.h"
struct __anonstruct___pthread_unwind_buf_t_49 {
   struct __anonstruct___cancel_jmp_buf_50 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 534 "/usr/include/pthread.h"
typedef struct __anonstruct___pthread_unwind_buf_t_49  __attribute__((__aligned__)) __pthread_unwind_buf_t;
#line 753
struct __jmp_buf_tag;
#line 76 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
struct __anonstruct_state_86 {
   teredo_state state ;
   void (*cb)(struct teredo_state  const  *s , void *opaque ) ;
   void *opaque ;
};
#line 76 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
struct teredo_maintenance {
   pthread_t thread ;
   pthread_mutex_t outer ;
   pthread_mutex_t inner ;
   pthread_cond_t received ;
   pthread_cond_t processed ;
   teredo_packet const   *incoming ;
   int fd ;
   struct __anonstruct_state_86 state ;
   char *server ;
   unsigned int qualification_delay ;
   unsigned int qualification_retries ;
   unsigned int refresh_delay ;
   unsigned int restart_delay ;
};
#line 248
enum __anonenum_last_error_87 {
    TERR_NONE = 0,
    TERR_BLACKHOLE = 1
} ;
#line 248
enum __anonenum_last_error_87___0 {
    TERR_NONE___0 = 0,
    TERR_BLACKHOLE___0 = 1
} ;
#line 82 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
struct __anonstruct_priv_55___0 {
   pthread_mutex_t lock ;
   clockid_t id ;
   _Bool present ;
};
#line 341 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
union __anonunion_w_31___0 {
   uint16_t word ;
   uint8_t bytes[2] ;
};
#line 125 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
struct __anonstruct_buf_51___0 {
   struct icmp6_hdr hdr ;
   char fill[(1280UL - sizeof(struct ip6_hdr )) - sizeof(struct icmp6_hdr )] ;
};
#line 123 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
struct __anonstruct_rs_29___0 {
   struct ip6_hdr ip6 ;
   struct nd_router_solicit rs ;
};
#line 277 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
struct __anonstruct_ping_30___0 {
   struct ip6_hdr ip6 ;
   struct icmp6_hdr icmp6 ;
   uint8_t payload[18] ;
};
#line 94 "/home/wheatley/newnew/temp/miredo-1.2.6/src/privproc.c"
union __anonunion_84 {
   int __in ;
   int __i ;
};
#line 93 "/home/wheatley/newnew/temp/miredo-1.2.6/src/privproc.c"
union __anonunion_85 {
   int __in ;
   int __i ;
};
#line 57 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
union __anonunion_inner_key_40___0 {
   unsigned char key[16] ;
   unsigned char ipad[64] ;
};
#line 63 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
union __anonunion_outer_key_41___0 {
   unsigned char key[16] ;
   unsigned char opad[64] ;
};
#line 523 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
union __anonunion_r_47___0 {
   struct in6_ifreq req6 ;
   struct ifreq req ;
};
#line 248 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
enum __anonenum_last_error_87___1 {
    TERR_NONE___1 = 0,
    TERR_BLACKHOLE___1 = 1
} ;
#line 82 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
struct __anonstruct_priv_55___1 {
   pthread_mutex_t lock ;
   clockid_t id ;
   _Bool present ;
};
#line 341 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
union __anonunion_w_31___1 {
   uint16_t word ;
   uint8_t bytes[2] ;
};
#line 125 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
struct __anonstruct_buf_51___1 {
   struct icmp6_hdr hdr ;
   char fill[(1280UL - sizeof(struct ip6_hdr )) - sizeof(struct icmp6_hdr )] ;
};
#line 123 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
struct __anonstruct_rs_29___1 {
   struct ip6_hdr ip6 ;
   struct nd_router_solicit rs ;
};
#line 277 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
struct __anonstruct_ping_30___1 {
   struct ip6_hdr ip6 ;
   struct icmp6_hdr icmp6 ;
   uint8_t payload[18] ;
};
#line 57 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
union __anonunion_inner_key_40___1 {
   unsigned char key[16] ;
   unsigned char ipad[64] ;
};
#line 63 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
union __anonunion_outer_key_41___1 {
   unsigned char key[16] ;
   unsigned char opad[64] ;
};
#line 125 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
struct __anonstruct_buf_51___2 {
   struct icmp6_hdr hdr ;
   char fill[(1280UL - sizeof(struct ip6_hdr )) - sizeof(struct icmp6_hdr )] ;
};
#line 82 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
struct __anonstruct_priv_55___2 {
   pthread_mutex_t lock ;
   clockid_t id ;
   _Bool present ;
};
#line 248 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
enum __anonenum_last_error_87___2 {
    TERR_NONE___2 = 0,
    TERR_BLACKHOLE___2 = 1
} ;
#line 123 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
struct __anonstruct_rs_29___2 {
   struct ip6_hdr ip6 ;
   struct nd_router_solicit rs ;
};
#line 277 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
struct __anonstruct_ping_30___2 {
   struct ip6_hdr ip6 ;
   struct icmp6_hdr icmp6 ;
   uint8_t payload[18] ;
};
#line 341 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
union __anonunion_w_31___2 {
   uint16_t word ;
   uint8_t bytes[2] ;
};
#line 57 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
union __anonunion_inner_key_40___2 {
   unsigned char key[16] ;
   unsigned char ipad[64] ;
};
#line 63 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
union __anonunion_outer_key_41___2 {
   unsigned char key[16] ;
   unsigned char opad[64] ;
};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 44 "../compat/fixups.h"
extern int closefrom(int fd ) ;
#line 44 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dgettext)(char const   *__domainname ,
                                                                                 char const   *__msgid )  __attribute__((__format_arg__(2))) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 56 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.h"
int Pryt4897810065911_br_init(BrInitError *error ) ;
#line 65
char *Pryt4897810065911_br_find_locale_dir(char const   *default_locale_dir ) ;
#line 68
char *Pryt4897810065911_br_find_etc_dir(char const   *default_etc_dir ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 278
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 595
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clearenv)(void) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 710
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 1016 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 1081
extern int lockf(int __fd , int __cmd , __off_t __len ) ;
#line 1112
extern int fdatasync(int __fildes ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 201 "/usr/include/grp.h"
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 41 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.h"
int miredo_main(int argc , char **argv ) ;
#line 42
extern int miredo_version(void) ;
#line 43
extern int miredo(char const   *confpath , char const   *server_name , int pidfd ) ;
#line 50
int (*miredo_diagnose)(void) ;
#line 55
uid_t unpriv_uid ;
#line 56
char const   *miredo_chrootdir ;
#line 57
char const   *miredo_name ;
#line 63 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static int quick_usage(char const   *path___0 ) 
{ 
  char *tmp ;

  {
  {
#line 66
  tmp = dgettext("miredo", "Try \"%s -h | more\" for more information.\n");
#line 66
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, path___0);
  }
#line 68
  return (2);
}
}
#line 72 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static int usage(char const   *path___0 ) 
{ 
  char *tmp ;

  {
  {
#line 75
  tmp = dgettext("miredo", "Usage: %s [OPTIONS] [SERVER_NAME]\nCreates a Teredo tunneling interface for encapsulation of IPv6 over UDP.\n\n  -c, --config     specify an configuration file\n  -f, --foreground run in the foreground\n  -h, --help       display this help and exit\n  -p, --pidfile    override the location of the PID file\n  -u, --user       override the user to set UID to\n  -V, --version    display program version and exit\n");
#line 75
  printf((char const   */* __restrict  */)tmp, path___0);
  }
#line 85
  return (0);
}
}
#line 89 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
extern int miredo_version(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 95
  tmp = dgettext("miredo", "Miredo: Teredo IPv6 tunneling software %s (%s)\n built %s on %s (%s)\n");
#line 95
  printf((char const   */* __restrict  */)tmp, "1.2.6", "x86_64-unknown-linux-gnu",
         "Mar  3 2016", "GLaDOS", "x86_64-unknown-linux-gnu");
#line 99
  tmp___0 = dgettext("miredo", "Configured with: %s\n");
#line 99
  printf((char const   */* __restrict  */)tmp___0, "./configure ");
#line 100
  tmp___1 = dgettext("miredo", "Written by Remi Denis-Courmont.\n");
#line 100
  puts((char const   *)tmp___1);
#line 102
  tmp___2 = dgettext("miredo", "Copyright (C) 2004-%u Remi Denis-Courmont\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.\n");
#line 102
  printf((char const   */* __restrict  */)tmp___2, 2006);
  }
#line 106
  return (0);
}
}
#line 110 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static int error_dup(int opt , char const   *already , char const   *additionnal ) 
{ 
  char *tmp ;

  {
  {
#line 113
  tmp = dgettext("miredo", "Duplicate parameter \"%s\" for option -%c\nwould override previous value \"%s\".\n");
#line 113
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, additionnal,
          opt, already);
  }
#line 117
  return (2);
}
}
#line 132 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static int error_extra(char const   *extra ) 
{ 
  char *tmp ;

  {
  {
#line 135
  tmp = dgettext("miredo", "%s: unexpected extra parameter\n");
#line 135
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, extra);
  }
#line 136
  return (2);
}
}
#line 140 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static int error_errno(char const   *str ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 143
  tmp = __errno_location();
#line 143
  tmp___0 = strerror(*tmp);
#line 143
  tmp___1 = dgettext("miredo", "Error (%s): %s\n");
#line 143
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
          str, tmp___0);
  }
#line 144
  return (-1);
}
}
#line 154 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static int create_pidfile(char const   *path___0 ) 
{ 
  int fd ;
  char buf[20] ;
  struct stat s ;
  __pid_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  ssize_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 159
  fd = open(path___0, 131137, 420);
  }
#line 160
  if (fd != -1) {
    {
#line 165
    tmp = getpid();
#line 165
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d",
             tmp);
#line 166
    buf[sizeof(buf) - 1UL] = (char )'\000';
#line 168
    tmp___0 = fcntl(fd, 1);
#line 168
    fcntl(fd, 2, tmp___0 | 1);
#line 169
    tmp___1 = __errno_location();
#line 169
    *tmp___1 = 0;
#line 172
    tmp___2 = fstat(fd, & s);
    }
#line 172
    if (tmp___2 == 0) {
#line 172
      if ((s.st_mode & 61440U) == 32768U) {
        {
#line 172
        tmp___3 = lockf(fd, 2, (__off_t )0);
        }
#line 172
        if (tmp___3 == 0) {
          {
#line 172
          tmp___4 = ftruncate(fd, (__off_t )0);
          }
#line 172
          if (tmp___4 == 0) {
            {
#line 172
            tmp___5 = strlen((char const   *)(buf));
#line 172
            tmp___6 = write(fd, (void const   *)(buf), tmp___5);
#line 172
            tmp___7 = strlen((char const   *)(buf));
            }
#line 172
            if (tmp___6 == (ssize_t )tmp___7) {
              {
#line 172
              tmp___8 = fdatasync(fd);
              }
#line 172
              if (tmp___8 == 0) {
#line 178
                return (fd);
              }
            }
          }
        }
      }
    }
    {
#line 180
    tmp___10 = __errno_location();
    }
#line 180
    if (*tmp___10 == 0) {
      {
#line 181
      tmp___9 = __errno_location();
#line 181
      *tmp___9 = 13;
      }
    }
    {
#line 183
    close(fd);
    }
  }
#line 186
  return (-1);
}
}
#line 191 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static void setuid_notice(void) 
{ 
  char *tmp ;

  {
  {
#line 194
  tmp = dgettext("miredo", "That is usually an indication that you are trying to start\nthe program as an user with insufficient system privileges.\nThis program should normally be started by root.\n");
#line 194
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
  }
#line 198
  return;
}
}
#line 205 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static int init_security(char const   *username ) 
{ 
  int val ;
  int tmp ;
  int *tmp___0 ;
  struct passwd *pw ;
  struct passwd *tmp___1 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 210
  umask((__mode_t )18);
#line 211
  tmp = chdir("/");
  }
#line 211
  if (tmp) {
#line 212
    return (-1);
  }
  {
#line 221
  closefrom(3);
#line 226
  val = dup(2);
  }
#line 227
  if (val != 3) {
#line 228
    return (-1);
  }
  {
#line 229
  close(val);
#line 232
  clearenv();
#line 236
  tmp___0 = __errno_location();
#line 236
  *tmp___0 = 0;
#line 237
  tmp___1 = getpwnam(username);
#line 237
  pw = tmp___1;
  }
#line 238
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    {
#line 240
    tmp___7 = __errno_location();
    }
#line 240
    if (*tmp___7) {
      {
#line 240
      tmp___3 = __errno_location();
#line 240
      tmp___4 = strerror(*tmp___3);
#line 240
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 240
      tmp___5 = dgettext("miredo", "User not found");
#line 240
      tmp___6 = tmp___5;
      }
    }
    {
#line 240
    tmp___8 = dgettext("miredo", "User \"%s\": %s\n");
#line 240
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
            username, tmp___6);
    }
#line 242
    return (-1);
  }
#line 245
  if (pw->pw_uid == 0U) {
    {
#line 247
    tmp___9 = dgettext("miredo", "Error: This program is not supposed to keep root\nprivileges. That is potentially very dangerous\n(all the more as it has never been externally audited).\n");
#line 247
    fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)stderr);
    }
#line 251
    return (-1);
  }
  {
#line 253
  unpriv_uid = pw->pw_uid;
#line 256
  tmp___13 = seteuid((__uid_t )0);
  }
#line 256
  if (tmp___13) {
#line 256
    goto _L;
  } else {
    {
#line 256
    tmp___14 = setgid(pw->pw_gid);
    }
#line 256
    if (tmp___14) {
#line 256
      goto _L;
    } else {
      {
#line 256
      tmp___15 = initgroups(username, pw->pw_gid);
      }
#line 256
      if (tmp___15) {
        _L: /* CIL Label */ 
        {
#line 261
        tmp___10 = __errno_location();
#line 261
        tmp___11 = strerror(*tmp___10);
#line 261
        tmp___12 = dgettext("miredo", "SetUID to root: %s\n");
#line 261
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
                tmp___11);
#line 262
        setuid_notice();
        }
#line 263
        return (-1);
      }
    }
  }
#line 308
  return (0);
}
}
#line 312 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static void init_locale(void) 
{ 
  char *path___0 ;
  char *tmp ;

  {
  {
#line 314
  Pryt4897810065911_br_init((BrInitError *)((void *)0));
#line 315
  setlocale(6, "");
#line 316
  tmp = Pryt4897810065911_br_find_locale_dir("/usr/local/share/locale");
#line 316
  path___0 = tmp;
#line 317
  bindtextdomain("miredo", (char const   *)path___0);
#line 318
  free((void *)path___0);
#line 319
  textdomain("miredo");
  }
#line 320
  return;
}
}
#line 332 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static struct option  const  opts[11]  = 
#line 332
  {      {"conf", 1, (int *)((void *)0), 'c'}, 
        {"config", 1, (int *)((void *)0), 'c'}, 
        {"foreground", 0, (int *)((void *)0), 'f'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"pidfile", 1, (int *)((void *)0), 'p'}, 
        {"chroot", 1, (int *)((void *)0), 't'}, 
        {"chrootdir", 1, (int *)((void *)0), 't'}, 
        {"user", 1, (int *)((void *)0), 'u'}, 
        {"username", 1, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 323 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
int miredo_main(int argc , char **argv ) 
{ 
  char const   *username ;
  char const   *conffile___0 ;
  char const   *servername ;
  char const   *pidfile ;
  char const   *chrootdir ;
  struct __anonstruct_flags_44 flags ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t str_len ;
  char *path___0 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char *conffile_buf ;
  unsigned long __lengthofconffile_buf ;
  void *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  struct stat s ;
  int *tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  char *pidfile_buf ;
  unsigned long __lengthofpidfile_buf ;
  void *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int pipes[2] ;
  int tmp___24 ;
  pid_t pid ;
  __pid_t tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  ssize_t tmp___29 ;
  int fd ;
  int tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  int *tmp___35 ;
  int *tmp___36 ;
  FILE *tmp___37 ;
  FILE *tmp___38 ;
  FILE *tmp___39 ;
  ssize_t tmp___40 ;
  int tmp___41 ;

  {
  {
#line 325
  username = (char const   *)((void *)0);
#line 325
  conffile___0 = (char const   *)((void *)0);
#line 325
  servername = (char const   *)((void *)0);
#line 325
  pidfile = (char const   *)((void *)0);
#line 325
  chrootdir = (char const   *)((void *)0);
#line 347
  init_locale();
#line 355
  memset((void *)(& flags), 0, sizeof(flags));
  }
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 358
    c = getopt_long(argc, (char * const  *)argv, "c:fhp:t:u:V", opts, (int *)((void *)0));
    }
#line 358
    if (! (c != -1)) {
#line 358
      goto while_break;
    }
    {
#line 362
    if (c == 99) {
#line 362
      goto case_99;
    }
#line 366
    if (c == 102) {
#line 366
      goto case_102;
    }
#line 370
    if (c == 104) {
#line 370
      goto case_104;
    }
#line 373
    if (c == 112) {
#line 373
      goto case_112;
    }
#line 377
    if (c == 117) {
#line 377
      goto case_117;
    }
#line 381
    if (c == 116) {
#line 381
      goto case_116;
    }
#line 385
    if (c == 86) {
#line 385
      goto case_86;
    }
#line 389
    goto switch_default;
    case_99: /* CIL Label */ 
#line 363
    if ((unsigned long )conffile___0 != (unsigned long )((void *)0)) {
      {
#line 363
      tmp = error_dup(c, (char const   *)optarg, conffile___0);
      }
#line 363
      return (tmp);
    } else {
#line 363
      conffile___0 = (char const   *)optarg;
    }
#line 364
    goto switch_break;
    case_102: /* CIL Label */ 
#line 367
    flags.foreground = 1U;
#line 368
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 371
    tmp___0 = usage((char const   *)*(argv + 0));
    }
#line 371
    return (tmp___0);
    case_112: /* CIL Label */ 
#line 374
    if ((unsigned long )pidfile != (unsigned long )((void *)0)) {
      {
#line 374
      tmp___1 = error_dup(c, (char const   *)optarg, pidfile);
      }
#line 374
      return (tmp___1);
    } else {
#line 374
      pidfile = (char const   *)optarg;
    }
#line 375
    goto switch_break;
    case_117: /* CIL Label */ 
#line 378
    if ((unsigned long )username != (unsigned long )((void *)0)) {
      {
#line 378
      tmp___2 = error_dup(c, (char const   *)optarg, username);
      }
#line 378
      return (tmp___2);
    } else {
#line 378
      username = (char const   *)optarg;
    }
#line 379
    goto switch_break;
    case_116: /* CIL Label */ 
#line 382
    if ((unsigned long )chrootdir != (unsigned long )((void *)0)) {
      {
#line 382
      tmp___3 = error_dup(c, (char const   *)optarg, chrootdir);
      }
#line 382
      return (tmp___3);
    } else {
#line 382
      chrootdir = (char const   *)optarg;
    }
#line 383
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 386
    tmp___4 = miredo_version();
    }
#line 386
    return (tmp___4);
    switch_default: /* CIL Label */ 
    {
#line 390
    tmp___5 = quick_usage((char const   *)*(argv + 0));
    }
#line 390
    return (tmp___5);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  if (optind < argc) {
#line 394
    tmp___6 = optind;
#line 394
    optind ++;
#line 394
    servername = (char const   *)*(argv + tmp___6);
  }
#line 396
  if (optind < argc) {
    {
#line 397
    tmp___7 = error_extra((char const   *)*(argv + optind));
    }
#line 397
    return (tmp___7);
  }
#line 400
  if ((unsigned long )username == (unsigned long )((void *)0)) {
#line 401
    username = "nobody";
  }
#line 407
  str_len = (size_t )0;
#line 408
  path___0 = (char *)((void *)0);
#line 409
  if ((unsigned long )conffile___0 == (unsigned long )((void *)0)) {
    {
#line 411
    path___0 = Pryt4897810065911_br_find_etc_dir("/usr/local/etc");
#line 412
    tmp___8 = strlen((char const   *)path___0);
#line 412
    tmp___9 = strlen(miredo_name);
#line 412
    str_len = (tmp___8 + tmp___9) + sizeof("/miredo/.conf");
    }
  }
  {
#line 416
  __lengthofconffile_buf = str_len;
#line 416
  tmp___10 = __builtin_alloca(sizeof(*conffile_buf) * __lengthofconffile_buf);
#line 416
  conffile_buf = (char *)tmp___10;
  }
#line 417
  if ((unsigned long )conffile___0 == (unsigned long )((void *)0)) {
    {
#line 419
    snprintf((char */* __restrict  */)conffile_buf, str_len, (char const   */* __restrict  */)"%s/miredo/%s.conf",
             path___0, miredo_name);
#line 421
    free((void *)path___0);
#line 422
    conffile___0 = (char const   *)conffile_buf;
    }
  }
#line 426
  if ((unsigned long )servername == (unsigned long )((void *)0)) {
    {
#line 426
    tmp___14 = access(conffile___0, 4);
    }
#line 426
    if (tmp___14) {
      {
#line 428
      tmp___11 = __errno_location();
#line 428
      tmp___12 = strerror(*tmp___11);
#line 428
      tmp___13 = dgettext("miredo", "Reading configuration from %s: %s\n");
#line 428
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___13,
              conffile___0, tmp___12);
      }
#line 430
      return (1);
    }
  }
#line 433
  if ((unsigned long )chrootdir != (unsigned long )((void *)0)) {
    {
#line 436
    tmp___15 = __errno_location();
#line 436
    *tmp___15 = 0;
#line 438
    tmp___18 = stat((char const   */* __restrict  */)chrootdir, (struct stat */* __restrict  */)(& s));
    }
#line 438
    if (tmp___18) {
#line 438
      goto _L;
    } else
#line 438
    if (! ((s.st_mode & 61440U) == 16384U)) {
#line 438
      goto _L;
    } else {
      {
#line 438
      tmp___19 = access(chrootdir, 1);
      }
#line 438
      if (tmp___19) {
        _L: /* CIL Label */ 
        {
#line 441
        tmp___17 = __errno_location();
        }
#line 441
        if (*tmp___17 == 0) {
          {
#line 442
          tmp___16 = __errno_location();
#line 442
          *tmp___16 = 20;
          }
        }
        {
#line 444
        error_errno(chrootdir);
        }
#line 445
        return (1);
      }
    }
  }
#line 448
  miredo_chrootdir = chrootdir;
#line 450
  if ((unsigned long )pidfile == (unsigned long )((void *)0)) {
    {
#line 451
    tmp___20 = strlen(miredo_name);
#line 451
    str_len = sizeof("/usr/local/var/run/.pid") + tmp___20;
    }
  } else {
#line 453
    str_len = (size_t )0;
  }
  {
#line 455
  __lengthofpidfile_buf = str_len;
#line 455
  tmp___21 = __builtin_alloca(sizeof(*pidfile_buf) * __lengthofpidfile_buf);
#line 455
  pidfile_buf = (char *)tmp___21;
  }
#line 456
  if ((unsigned long )pidfile == (unsigned long )((void *)0)) {
    {
#line 458
    snprintf((char */* __restrict  */)pidfile_buf, str_len, (char const   */* __restrict  */)"/usr/local/var/run/%s.pid",
             miredo_name);
#line 460
    pidfile = (char const   *)pidfile_buf;
    }
  }
  {
#line 463
  tmp___22 = init_security(username);
  }
#line 463
  if (tmp___22) {
#line 464
    return (1);
  }
  {
#line 466
  tmp___23 = (*miredo_diagnose)();
  }
#line 466
  if (tmp___23) {
#line 467
    return (1);
  }
  {
#line 470
  tmp___24 = pipe((int *)(pipes));
  }
#line 470
  if (tmp___24) {
#line 471
    pipes[1] = -1;
#line 471
    pipes[0] = pipes[1];
  }
#line 473
  if (! flags.foreground) {
    {
#line 475
    tmp___25 = fork();
#line 475
    pid = tmp___25;
    }
    {
#line 479
    if (pid == -1) {
#line 479
      goto case_neg_1;
    }
#line 483
    if (pid == 0) {
#line 483
      goto case_0;
    }
#line 486
    goto switch_default___0;
    case_neg_1: /* CIL Label */ 
    {
#line 480
    tmp___26 = __errno_location();
#line 480
    tmp___27 = strerror(*tmp___26);
#line 480
    tmp___28 = dgettext("miredo", "Error (%s): %s\n");
#line 480
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___28,
            "fork", tmp___27);
    }
#line 481
    return (1);
    case_0: /* CIL Label */ 
#line 484
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 488
    close(pipes[1]);
#line 489
    tmp___29 = read(pipes[0], (void *)(& c), sizeof(c));
    }
#line 489
    if ((unsigned long )tmp___29 != sizeof(c)) {
#line 490
      c = 1;
    }
    {
#line 492
    close(pipes[0]);
    }
#line 493
    return (c);
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 497
  close(pipes[0]);
#line 500
  tmp___30 = create_pidfile(pidfile);
#line 500
  fd = tmp___30;
  }
#line 501
  if (fd == -1) {
    {
#line 503
    tmp___31 = __errno_location();
#line 503
    tmp___32 = strerror(*tmp___31);
#line 503
    tmp___33 = dgettext("miredo", "Cannot create PID file %s:\n %s\n");
#line 503
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___33,
            pidfile, tmp___32);
#line 505
    tmp___35 = __errno_location();
    }
#line 505
    if (*tmp___35 == 11) {
      {
#line 506
      tmp___34 = dgettext("miredo", "Please make sure another instance of the program is not already running.");
#line 506
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              tmp___34);
      }
    } else {
      {
#line 505
      tmp___36 = __errno_location();
      }
#line 505
      if (*tmp___36 == 13) {
        {
#line 506
        tmp___34 = dgettext("miredo", "Please make sure another instance of the program is not already running.");
#line 506
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                tmp___34);
        }
      }
    }
    {
#line 509
    exit(1);
    }
  }
#line 513
  if (! flags.foreground) {
    {
#line 515
    c = 0;
#line 517
    setsid();
#line 518
    tmp___37 = freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"r",
                       (FILE */* __restrict  */)stdin);
    }
#line 518
    if ((unsigned long )tmp___37 == (unsigned long )((void *)0)) {
      {
#line 522
      exit(1);
      }
    } else {
      {
#line 518
      tmp___38 = freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
                         (FILE */* __restrict  */)stdout);
      }
#line 518
      if ((unsigned long )tmp___38 == (unsigned long )((void *)0)) {
        {
#line 522
        exit(1);
        }
      } else {
        {
#line 518
        tmp___39 = freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
                           (FILE */* __restrict  */)stderr);
        }
#line 518
        if ((unsigned long )tmp___39 == (unsigned long )((void *)0)) {
          {
#line 522
          exit(1);
          }
        } else {
          {
#line 518
          tmp___40 = write(pipes[1], (void const   *)(& c), sizeof(c));
          }
#line 518
          if (tmp___40 <= 0L) {
            {
#line 522
            exit(1);
            }
          }
        }
      }
    }
  }
  {
#line 524
  close(pipes[1]);
#line 529
  c = miredo(conffile___0, servername, fd);
#line 531
  unlink(pidfile);
#line 532
  close(fd);
  }
#line 534
  if (c) {
#line 534
    tmp___41 = 1;
  } else {
#line 534
    tmp___41 = 0;
  }
  {
#line 534
  exit(tmp___41);
  }
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 57 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.h"
int Pryt4897810065911_br_init_lib(BrInitError *error ) ;
#line 59
char *Pryt4897810065911_br_find_exe(char const   *default_exe ) ;
#line 60
char *Pryt4897810065911_br_find_exe_dir(char const   *default_dir ) ;
#line 61
char *Pryt4897810065911_br_find_prefix(char const   *default_prefix ) ;
#line 62
char *Pryt4897810065911_br_find_bin_dir(char const   *default_bin_dir ) ;
#line 63
char *Pryt4897810065911_br_find_sbin_dir(char const   *default_sbin_dir ) ;
#line 64
char *Pryt4897810065911_br_find_data_dir(char const   *default_data_dir ) ;
#line 66
char *Pryt4897810065911_br_find_lib_dir(char const   *default_lib_dir ) ;
#line 67
char *Pryt4897810065911_br_find_libexec_dir(char const   *default_libexec_dir ) ;
#line 71
char *Pryt4897810065911_br_strcat(char const   *str1 , char const   *str2 ) ;
#line 72
char *Pryt4897810065911_br_build_path(char const   *dir , char const   *file ) ;
#line 73
char *Pryt4897810065911_br_dirname(char const   *path___0 ) ;
#line 42 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
static char *_br_find_exe(BrInitError *error ) 
{ 


  {
#line 46
  if (error) {
#line 47
    *error = (BrInitError )4;
  }
#line 48
  return ((char *)((void *)0));
}
}
#line 181 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
static char *_br_find_exe_for_symbol(void const   *symbol , BrInitError *error ) 
{ 


  {
#line 186
  if (error) {
#line 187
    *error = (BrInitError )4;
  }
#line 188
  return ((char *)((void *)0));
}
}
#line 292 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
static char *exe  =    (char *)((void *)0);
#line 309 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
int Pryt4897810065911_br_init(BrInitError *error ) 
{ 


  {
  {
#line 312
  exe = _br_find_exe(error);
  }
#line 313
  return ((unsigned long )exe != (unsigned long )((void *)0));
}
}
#line 331 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
int Pryt4897810065911_br_init_lib(BrInitError *error ) 
{ 


  {
  {
#line 334
  exe = _br_find_exe_for_symbol((void const   *)"", error);
  }
#line 335
  return ((unsigned long )exe != (unsigned long )((void *)0));
}
}
#line 348 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
char *Pryt4897810065911_br_find_exe(char const   *default_exe ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 351
  if ((unsigned long )exe == (unsigned long )((char *)((void *)0))) {
#line 353
    if ((unsigned long )default_exe != (unsigned long )((char const   *)((void *)0))) {
      {
#line 354
      tmp = strdup(default_exe);
      }
#line 354
      return (tmp);
    } else {
#line 356
      return ((char *)((void *)0));
    }
  }
  {
#line 358
  tmp___0 = strdup((char const   *)exe);
  }
#line 358
  return (tmp___0);
}
}
#line 376 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
char *Pryt4897810065911_br_find_exe_dir(char const   *default_dir ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 379
  if ((unsigned long )exe == (unsigned long )((void *)0)) {
#line 381
    if ((unsigned long )default_dir != (unsigned long )((void *)0)) {
      {
#line 382
      tmp = strdup(default_dir);
      }
#line 382
      return (tmp);
    } else {
#line 384
      return ((char *)((void *)0));
    }
  }
  {
#line 387
  tmp___0 = Pryt4897810065911_br_dirname((char const   *)exe);
  }
#line 387
  return (tmp___0);
}
}
#line 404 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
char *Pryt4897810065911_br_find_prefix(char const   *default_prefix ) 
{ 
  char *dir1 ;
  char *dir2 ;
  char *tmp ;

  {
#line 409
  if ((unsigned long )exe == (unsigned long )((char *)((void *)0))) {
#line 411
    if ((unsigned long )default_prefix != (unsigned long )((char const   *)((void *)0))) {
      {
#line 412
      tmp = strdup(default_prefix);
      }
#line 412
      return (tmp);
    } else {
#line 414
      return ((char *)((void *)0));
    }
  }
  {
#line 417
  dir1 = Pryt4897810065911_br_dirname((char const   *)exe);
#line 418
  dir2 = Pryt4897810065911_br_dirname((char const   *)dir1);
#line 419
  free((void *)dir1);
  }
#line 420
  return (dir2);
}
}
#line 437 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
char *Pryt4897810065911_br_find_bin_dir(char const   *default_bin_dir ) 
{ 
  char *prefix ;
  char *dir ;
  char *tmp ;

  {
  {
#line 442
  prefix = Pryt4897810065911_br_find_prefix((char const   *)((void *)0));
  }
#line 443
  if ((unsigned long )prefix == (unsigned long )((char *)((void *)0))) {
#line 445
    if ((unsigned long )default_bin_dir != (unsigned long )((char const   *)((void *)0))) {
      {
#line 446
      tmp = strdup(default_bin_dir);
      }
#line 446
      return (tmp);
    } else {
#line 448
      return ((char *)((void *)0));
    }
  }
  {
#line 451
  dir = Pryt4897810065911_br_build_path((char const   *)prefix, "bin");
#line 452
  free((void *)prefix);
  }
#line 453
  return (dir);
}
}
#line 470 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
char *Pryt4897810065911_br_find_sbin_dir(char const   *default_sbin_dir ) 
{ 
  char *prefix ;
  char *dir ;
  char *tmp ;

  {
  {
#line 475
  prefix = Pryt4897810065911_br_find_prefix((char const   *)((void *)0));
  }
#line 476
  if ((unsigned long )prefix == (unsigned long )((char *)((void *)0))) {
#line 478
    if ((unsigned long )default_sbin_dir != (unsigned long )((char const   *)((void *)0))) {
      {
#line 479
      tmp = strdup(default_sbin_dir);
      }
#line 479
      return (tmp);
    } else {
#line 481
      return ((char *)((void *)0));
    }
  }
  {
#line 484
  dir = Pryt4897810065911_br_build_path((char const   *)prefix, "sbin");
#line 485
  free((void *)prefix);
  }
#line 486
  return (dir);
}
}
#line 504 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
char *Pryt4897810065911_br_find_data_dir(char const   *default_data_dir ) 
{ 
  char *prefix ;
  char *dir ;
  char *tmp ;

  {
  {
#line 509
  prefix = Pryt4897810065911_br_find_prefix((char const   *)((void *)0));
  }
#line 510
  if ((unsigned long )prefix == (unsigned long )((char *)((void *)0))) {
#line 512
    if ((unsigned long )default_data_dir != (unsigned long )((char const   *)((void *)0))) {
      {
#line 513
      tmp = strdup(default_data_dir);
      }
#line 513
      return (tmp);
    } else {
#line 515
      return ((char *)((void *)0));
    }
  }
  {
#line 518
  dir = Pryt4897810065911_br_build_path((char const   *)prefix, "share");
#line 519
  free((void *)prefix);
  }
#line 520
  return (dir);
}
}
#line 537 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
char *Pryt4897810065911_br_find_locale_dir(char const   *default_locale_dir ) 
{ 
  char *data_dir ;
  char *dir ;
  char *tmp ;

  {
  {
#line 542
  data_dir = Pryt4897810065911_br_find_data_dir((char const   *)((void *)0));
  }
#line 543
  if ((unsigned long )data_dir == (unsigned long )((char *)((void *)0))) {
#line 545
    if ((unsigned long )default_locale_dir != (unsigned long )((char const   *)((void *)0))) {
      {
#line 546
      tmp = strdup(default_locale_dir);
      }
#line 546
      return (tmp);
    } else {
#line 548
      return ((char *)((void *)0));
    }
  }
  {
#line 551
  dir = Pryt4897810065911_br_build_path((char const   *)data_dir, "locale");
#line 552
  free((void *)data_dir);
  }
#line 553
  return (dir);
}
}
#line 570 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
char *Pryt4897810065911_br_find_lib_dir(char const   *default_lib_dir ) 
{ 
  char *prefix ;
  char *dir ;
  char *tmp ;

  {
  {
#line 575
  prefix = Pryt4897810065911_br_find_prefix((char const   *)((void *)0));
  }
#line 576
  if ((unsigned long )prefix == (unsigned long )((char *)((void *)0))) {
#line 578
    if ((unsigned long )default_lib_dir != (unsigned long )((char const   *)((void *)0))) {
      {
#line 579
      tmp = strdup(default_lib_dir);
      }
#line 579
      return (tmp);
    } else {
#line 581
      return ((char *)((void *)0));
    }
  }
  {
#line 584
  dir = Pryt4897810065911_br_build_path((char const   *)prefix, "lib");
#line 585
  free((void *)prefix);
  }
#line 586
  return (dir);
}
}
#line 603 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
char *Pryt4897810065911_br_find_libexec_dir(char const   *default_libexec_dir ) 
{ 
  char *prefix ;
  char *dir ;
  char *tmp ;

  {
  {
#line 608
  prefix = Pryt4897810065911_br_find_prefix((char const   *)((void *)0));
  }
#line 609
  if ((unsigned long )prefix == (unsigned long )((char *)((void *)0))) {
#line 611
    if ((unsigned long )default_libexec_dir != (unsigned long )((char const   *)((void *)0))) {
      {
#line 612
      tmp = strdup(default_libexec_dir);
      }
#line 612
      return (tmp);
    } else {
#line 614
      return ((char *)((void *)0));
    }
  }
  {
#line 617
  dir = Pryt4897810065911_br_build_path((char const   *)prefix, "libexec");
#line 618
  free((void *)prefix);
  }
#line 619
  return (dir);
}
}
#line 636 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
char *Pryt4897810065911_br_find_etc_dir(char const   *default_etc_dir ) 
{ 
  char *prefix ;
  char *dir ;
  char *tmp ;

  {
  {
#line 641
  prefix = Pryt4897810065911_br_find_prefix((char const   *)((void *)0));
  }
#line 642
  if ((unsigned long )prefix == (unsigned long )((char *)((void *)0))) {
#line 644
    if ((unsigned long )default_etc_dir != (unsigned long )((char const   *)((void *)0))) {
      {
#line 645
      tmp = strdup(default_etc_dir);
      }
#line 645
      return (tmp);
    } else {
#line 647
      return ((char *)((void *)0));
    }
  }
  {
#line 650
  dir = Pryt4897810065911_br_build_path((char const   *)prefix, "etc");
#line 651
  free((void *)prefix);
  }
#line 652
  return (dir);
}
}
#line 666 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
char *Pryt4897810065911_br_strcat(char const   *str1 , char const   *str2 ) 
{ 
  char *result ;
  size_t len1 ;
  size_t len2 ;
  void *tmp ;

  {
#line 672
  if ((unsigned long )str1 == (unsigned long )((void *)0)) {
#line 673
    str1 = "";
  }
#line 674
  if ((unsigned long )str2 == (unsigned long )((void *)0)) {
#line 675
    str2 = "";
  }
  {
#line 677
  len1 = strlen(str1);
#line 678
  len2 = strlen(str2);
#line 680
  tmp = malloc((len1 + len2) + 1UL);
#line 680
  result = (char *)tmp;
#line 681
  memcpy((void */* __restrict  */)result, (void const   */* __restrict  */)str1, len1);
#line 682
  memcpy((void */* __restrict  */)(result + len1), (void const   */* __restrict  */)str2,
         len2);
#line 683
  *(result + (len1 + len2)) = (char )'\000';
  }
#line 685
  return (result);
}
}
#line 689 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
char *Pryt4897810065911_br_build_path(char const   *dir , char const   *file ) 
{ 
  char *dir2 ;
  char *result ;
  size_t len ;
  int must_free ;

  {
  {
#line 694
  must_free = 0;
#line 696
  len = strlen(dir);
  }
#line 697
  if (len > 0UL) {
#line 697
    if ((int const   )*(dir + (len - 1UL)) != 47) {
      {
#line 698
      dir2 = Pryt4897810065911_br_strcat(dir, "/");
#line 699
      must_free = 1;
      }
    } else {
#line 701
      dir2 = (char *)dir;
    }
  } else {
#line 701
    dir2 = (char *)dir;
  }
  {
#line 703
  result = Pryt4897810065911_br_strcat((char const   *)dir2, file);
  }
#line 704
  if (must_free) {
    {
#line 705
    free((void *)dir2);
    }
  }
#line 706
  return (result);
}
}
#line 711 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
static char *br_strndup(char const   *str , size_t size ) 
{ 
  char *result ;
  size_t len ;
  char *tmp ;
  void *tmp___0 ;

  {
#line 714
  result = (char *)((void *)0);
#line 717
  if ((unsigned long )str == (unsigned long )((char const   *)((void *)0))) {
#line 718
    return ((char *)((void *)0));
  }
  {
#line 720
  len = strlen(str);
  }
#line 721
  if (len == 0UL) {
    {
#line 722
    tmp = strdup("");
    }
#line 722
    return (tmp);
  }
#line 723
  if (size > len) {
#line 724
    size = len;
  }
  {
#line 726
  tmp___0 = malloc(len + 1UL);
#line 726
  result = (char *)tmp___0;
#line 727
  memcpy((void */* __restrict  */)result, (void const   */* __restrict  */)str, size);
#line 728
  *(result + size) = (char )'\000';
  }
#line 729
  return (result);
}
}
#line 745 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
char *Pryt4897810065911_br_dirname(char const   *path___0 ) 
{ 
  char *end ;
  char *result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 750
  if ((unsigned long )path___0 == (unsigned long )((char const   *)((void *)0))) {
#line 751
    return ((char *)((void *)0));
  }
  {
#line 753
  end = strrchr(path___0, '/');
  }
#line 754
  if ((unsigned long )end == (unsigned long )((char const   *)((void *)0))) {
    {
#line 755
    tmp = strdup(".");
    }
#line 755
    return (tmp);
  }
  {
#line 757
  while (1) {
    while_continue: /* CIL Label */ ;
#line 757
    if ((unsigned long )end > (unsigned long )path___0) {
#line 757
      if (! ((int )*end == 47)) {
#line 757
        goto while_break;
      }
    } else {
#line 757
      goto while_break;
    }
#line 758
    end --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 759
  result = br_strndup(path___0, (size_t )((end - (char *)path___0) + 1L));
  }
#line 760
  if ((int )*(result + 0) == 0) {
    {
#line 761
    free((void *)result);
#line 762
    tmp___0 = strdup("/");
    }
#line 762
    return (tmp___0);
  } else {
#line 764
    return (result);
  }
}
}
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 33 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.h"
miredo_conf *miredo_conf_create(void (*logger___2)(void * , _Bool  , char const   * ,
                                                   va_list  ) , void *opaque ) ;
#line 34
void miredo_conf_destroy(miredo_conf *conf ) ;
#line 36
_Bool miredo_conf_read_file(miredo_conf *conf , char const   *path___0 ) ;
#line 38
void miredo_conf_clear(miredo_conf *conf , int show ) ;
#line 39
char *miredo_conf_get(miredo_conf *conf , char const   *name , unsigned int *line ) ;
#line 41
_Bool miredo_conf_get_int16(miredo_conf *conf , char const   *name , uint16_t *value ,
                            unsigned int *line ) ;
#line 48
_Bool miredo_conf_parse_IPv4(miredo_conf *conf , char const   *name , uint32_t *ipv4 ) ;
#line 52
_Bool miredo_conf_parse_teredo_prefix(miredo_conf *conf , char const   *name , uint32_t *value ) ;
#line 55
_Bool miredo_conf_parse_syslog_facility(miredo_conf *conf , char const   *name , int *facility ) ;
#line 46 "/home/wheatley/newnew/temp/miredo-1.2.6/src/checkconf.c"
static void logger(void *fail , _Bool error , char const   *fmt , va_list ap ) 
{ 


  {
  {
#line 48
  *((_Bool *)fail) = (_Bool)1;
#line 51
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 52
  fputc('\n', stderr);
  }
#line 53
  return;
}
}
#line 56 "/home/wheatley/newnew/temp/miredo-1.2.6/src/checkconf.c"
static char const   conffile[34]  = 
#line 56
  {      (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
        (char const   )'/',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'a',      (char const   )'l',      (char const   )'/',      (char const   )'e', 
        (char const   )'t',      (char const   )'c',      (char const   )'/',      (char const   )'m', 
        (char const   )'i',      (char const   )'r',      (char const   )'e',      (char const   )'d', 
        (char const   )'o',      (char const   )'/',      (char const   )'m',      (char const   )'i', 
        (char const   )'r',      (char const   )'e',      (char const   )'d',      (char const   )'o', 
        (char const   )'.',      (char const   )'c',      (char const   )'o',      (char const   )'n', 
        (char const   )'f',      (char const   )'\000'};
#line 58 "/home/wheatley/newnew/temp/miredo-1.2.6/src/checkconf.c"
static int miredo_checkconf(miredo_conf *conf ) 
{ 
  int i ;
  int res ;
  _Bool tmp ;
  _Bool client ;
  unsigned int line ;
  char *val ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  uint32_t u32 ;
  uint16_t u16 ;
  uint32_t ip ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___9 ;
  uint32_t pref ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  char *str ;
  char *tmp___14 ;

  {
  {
#line 60
  res = 0;
#line 61
  tmp = miredo_conf_parse_syslog_facility(conf, "SyslogFacility", & i);
  }
#line 61
  if (! tmp) {
#line 62
    res = -1;
  }
  {
#line 64
  client = (_Bool)1;
#line 67
  tmp___0 = miredo_conf_get(conf, "RelayType", & line);
#line 67
  val = tmp___0;
  }
#line 69
  if ((unsigned long )val != (unsigned long )((void *)0)) {
    {
#line 71
    tmp___5 = strcasecmp((char const   *)val, "client");
    }
#line 71
    if (tmp___5 == 0) {
#line 73
      client = (_Bool)1;
    } else {
      {
#line 71
      tmp___6 = strcasecmp((char const   *)val, "autoclient");
      }
#line 71
      if (tmp___6 == 0) {
#line 73
        client = (_Bool)1;
      } else {
        {
#line 75
        tmp___2 = strcasecmp((char const   *)val, "relay");
        }
#line 75
        if (tmp___2 == 0) {
#line 78
          client = (_Bool)0;
        } else {
          {
#line 75
          tmp___3 = strcasecmp((char const   *)val, "cone");
          }
#line 75
          if (tmp___3 == 0) {
#line 78
            client = (_Bool)0;
          } else {
            {
#line 75
            tmp___4 = strcasecmp((char const   *)val, "restricted");
            }
#line 75
            if (tmp___4 == 0) {
#line 78
              client = (_Bool)0;
            } else {
              {
#line 81
              tmp___1 = dgettext("miredo", "Invalid relay type \"%s\" at line %u");
#line 81
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                      val, line);
#line 83
              fputc('\n', stderr);
#line 84
              res = -1;
              }
            }
          }
        }
      }
    }
    {
#line 86
    free((void *)val);
    }
  }
#line 92
  if (client) {
    {
#line 95
    ip = (uint32_t )0;
#line 97
    tmp___7 = miredo_conf_parse_IPv4(conf, "ServerAddress", & ip);
    }
#line 97
    if (tmp___7) {
      {
#line 97
      tmp___8 = miredo_conf_parse_IPv4(conf, "ServerAddress2", & u32);
      }
#line 97
      if (! tmp___8) {
#line 99
        res = -1;
      }
    } else {
#line 99
      res = -1;
    }
#line 101
    if (ip == 0U) {
      {
#line 103
      tmp___9 = dgettext("miredo", "Server address not specified");
#line 103
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              tmp___9);
#line 104
      res = -1;
      }
    }
  } else {
    {
#line 114
    tmp___10 = miredo_conf_parse_teredo_prefix(conf, "Prefix", & pref);
    }
#line 114
    if (tmp___10) {
      {
#line 114
      tmp___11 = miredo_conf_get_int16(conf, "InterfaceMTU", & u16, (unsigned int *)((void *)0));
      }
#line 114
      if (! tmp___11) {
#line 116
        res = -1;
      }
    } else {
#line 116
      res = -1;
    }
  }
  {
#line 119
  tmp___12 = miredo_conf_parse_IPv4(conf, "BindAddress", & u32);
  }
#line 119
  if (tmp___12) {
    {
#line 119
    tmp___13 = miredo_conf_get_int16(conf, "BindPort", & u16, (unsigned int *)((void *)0));
    }
#line 119
    if (! tmp___13) {
#line 121
      res = -1;
    }
  } else {
#line 121
    res = -1;
  }
  {
#line 123
  tmp___14 = miredo_conf_get(conf, "InterfaceName", (unsigned int *)((void *)0));
#line 123
  str = tmp___14;
  }
#line 124
  if ((unsigned long )str != (unsigned long )((void *)0)) {
    {
#line 125
    free((void *)str);
    }
  }
  {
#line 127
  miredo_conf_clear(conf, 5);
  }
#line 128
  return (res);
}
}
#line 132 "/home/wheatley/newnew/temp/miredo-1.2.6/src/checkconf.c"
static int miredo_checkconffile(char const   *filename ) 
{ 
  _Bool failed ;
  miredo_conf *conf ;
  miredo_conf *tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 134
  failed = (_Bool)0;
#line 135
  tmp = miredo_conf_create(& logger, (void *)(& failed));
#line 135
  conf = tmp;
  }
#line 137
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 138
    return (-1);
  }
  {
#line 140
  tmp___1 = miredo_conf_read_file(conf, filename);
  }
#line 140
  if (tmp___1) {
    {
#line 143
    tmp___0 = miredo_checkconf(conf);
    }
#line 143
    if (tmp___0) {
#line 144
      failed = (_Bool)1;
    }
  } else {
#line 141
    failed = (_Bool)1;
  }
  {
#line 146
  miredo_conf_destroy(conf);
  }
#line 147
  if (failed) {
    {
#line 149
    tmp___2 = dgettext("miredo", "Fatal configuration error");
#line 149
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            tmp___2);
    }
#line 150
    return (-1);
  }
#line 152
  return (0);
}
}
#line 156 "/home/wheatley/newnew/temp/miredo-1.2.6/src/checkconf.c"
static int usage___0(char const   *path___0 ) 
{ 


  {
  {
#line 158
  printf((char const   */* __restrict  */)"Usage: %s [CONF_FILE]\n", path___0);
  }
#line 159
  return (0);
}
}
#line 172
int main(int argc , char **argv ) ;
#line 172 "/home/wheatley/newnew/temp/miredo-1.2.6/src/checkconf.c"
static struct option  const  opts___0[11]  = 
#line 172
  {      {"conf", 1, (int *)((void *)0), 'c'}, 
        {"config", 1, (int *)((void *)0), 'c'}, 
        {"foreground", 0, (int *)((void *)0), 'f'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"pidfile", 1, (int *)((void *)0), 'p'}, 
        {"chroot", 1, (int *)((void *)0), 't'}, 
        {"chrootdir", 1, (int *)((void *)0), 't'}, 
        {"user", 1, (int *)((void *)0), 'u'}, 
        {"username", 1, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 163 "/home/wheatley/newnew/temp/miredo-1.2.6/src/checkconf.c"
int main(int argc , char **argv ) 
{ 
  char *path___0 ;
  char *tmp ;
  char const   *filename ;
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *srcdir ;
  char *tmp___3 ;
  int res ;
  int tmp___4 ;

  {
  {
#line 165
  Pryt4897810065911_br_init((BrInitError *)((void *)0));
#line 166
  setlocale(6, "");
#line 167
  tmp = Pryt4897810065911_br_find_locale_dir("/usr/local/share/locale");
#line 167
  path___0 = tmp;
#line 168
  bindtextdomain("miredo", (char const   *)path___0);
#line 169
  free((void *)path___0);
#line 170
  path___0 = (char *)((void *)0);
#line 187
  filename = (char const   *)((void *)0);
  }
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 190
    c = getopt_long(argc, (char * const  *)argv, "c:fhp:t:u:V", opts___0, (int *)((void *)0));
    }
#line 190
    if (! (c != -1)) {
#line 190
      goto while_break;
    }
    {
#line 193
    if (c == 99) {
#line 193
      goto case_99;
    }
#line 197
    if (c == 104) {
#line 197
      goto case_104;
    }
#line 200
    if (c == 86) {
#line 200
      goto case_86;
    }
#line 191
    goto switch_break;
    case_99: /* CIL Label */ 
#line 194
    filename = (char const   *)optarg;
#line 195
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 198
    tmp___0 = usage___0((char const   *)*(argv + 0));
    }
#line 198
    return (tmp___0);
    case_86: /* CIL Label */ 
    {
#line 201
    tmp___1 = miredo_version();
    }
#line 201
    return (tmp___1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  if (optind < argc) {
#line 205
    tmp___2 = optind;
#line 205
    optind ++;
#line 205
    filename = (char const   *)*(argv + tmp___2);
  } else
#line 207
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    {
#line 210
    tmp___3 = getenv("srcdir");
#line 210
    srcdir = (char const   *)tmp___3;
    }
#line 212
    if ((unsigned long )srcdir != (unsigned long )((void *)0)) {
#line 213
      filename = "../misc/miredo.conf";
    } else {
#line 215
      filename = conffile;
    }
  }
  {
#line 218
  tmp___4 = miredo_checkconffile(filename);
#line 218
  res = tmp___4;
  }
#line 220
  if ((unsigned long )path___0 != (unsigned long )((void *)0)) {
    {
#line 221
    free((void *)path___0);
    }
  }
#line 223
  return (res);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 46 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.h"
int GetIPv4ByName(char const   *hostname , uint32_t *ipv4 ) ;
#line 50
_Bool miredo_conf_parse_IPv6(miredo_conf *conf , char const   *name , struct in6_addr *value ) ;
#line 65 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
miredo_conf *miredo_conf_create(void (*logger___2)(void * , _Bool  , char const   * ,
                                                   va_list  ) , void *opaque ) 
{ 
  miredo_conf *conf ;
  void *tmp ;
  struct setting *tmp___0 ;

  {
  {
#line 67
  tmp = malloc(sizeof(*conf));
#line 67
  conf = (miredo_conf *)tmp;
  }
#line 68
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 69
    return ((miredo_conf *)((void *)0));
  }
#line 71
  tmp___0 = (struct setting *)((void *)0);
#line 71
  conf->tail = tmp___0;
#line 71
  conf->head = tmp___0;
#line 72
  conf->logger = logger___2;
#line 73
  conf->logger_data = opaque;
#line 74
  return (conf);
}
}
#line 78 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
void miredo_conf_destroy(miredo_conf *conf ) 
{ 


  {
#line 80
  if (! ((unsigned long )conf != (unsigned long )((void *)0))) {
    {
#line 80
    __assert_fail("conf != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  80U, "miredo_conf_destroy");
    }
  }
  {
#line 81
  miredo_conf_clear(conf, 0);
#line 82
  free((void *)conf);
  }
#line 83
  return;
}
}
#line 86 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
static void ( /* format attribute */  LogError)(miredo_conf *conf , char const   *fmt 
                                                , ...) 
{ 
  va_list ap ;

  {
#line 93
  if (! ((unsigned long )conf != (unsigned long )((void *)0))) {
    {
#line 93
    __assert_fail("conf != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  93U, "LogError");
    }
  }
#line 94
  if (! ((unsigned long )fmt != (unsigned long )((void *)0))) {
    {
#line 94
    __assert_fail("fmt != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  94U, "LogError");
    }
  }
#line 96
  if ((unsigned long )conf->logger == (unsigned long )((void *)0)) {
#line 97
    return;
  }
  {
#line 101
  __builtin_va_start(ap, fmt);
#line 102
  (*(conf->logger))(conf->logger_data, (_Bool)1, fmt, ap);
#line 103
  __builtin_va_end(ap);
  }
#line 104
  return;
}
}
#line 107 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
static void ( /* format attribute */  LogWarning)(miredo_conf *conf , char const   *fmt 
                                                  , ...) 
{ 
  va_list ap ;

  {
#line 113
  if (! ((unsigned long )conf != (unsigned long )((void *)0))) {
    {
#line 113
    __assert_fail("conf != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  113U, "LogWarning");
    }
  }
#line 114
  if (! ((unsigned long )fmt != (unsigned long )((void *)0))) {
    {
#line 114
    __assert_fail("fmt != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  114U, "LogWarning");
    }
  }
#line 116
  if ((unsigned long )conf->logger == (unsigned long )((void *)0)) {
#line 117
    return;
  }
  {
#line 121
  __builtin_va_start(ap, fmt);
#line 122
  (*(conf->logger))(conf->logger_data, (_Bool)0, fmt, ap);
#line 123
  __builtin_va_end(ap);
  }
#line 124
  return;
}
}
#line 127 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
void miredo_conf_clear(miredo_conf *conf , int show ) 
{ 
  struct setting *ptr ;
  struct setting *buf ;
  char *tmp ;

  {
#line 130
  ptr = conf->head;
#line 132
  conf->head = (struct setting *)((void *)0);
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 135
      goto while_break;
    }
#line 137
    buf = ptr->next;
#line 138
    if (show > 0) {
      {
#line 140
      tmp = dgettext("miredo", "Superfluous directive %s at line %u");
#line 140
      LogWarning(conf, (char const   *)tmp, ptr->name, ptr->line);
#line 142
      show --;
      }
    }
    {
#line 144
    free((void *)ptr->name);
#line 145
    free((void *)ptr->value);
#line 146
    free((void *)ptr);
#line 147
    ptr = buf;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 156 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
static _Bool miredo_conf_set(miredo_conf *conf , char const   *name , char const   *value ,
                             unsigned int line ) 
{ 
  struct setting *parm ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 160
  if (! ((unsigned long )conf != (unsigned long )((void *)0))) {
    {
#line 160
    __assert_fail("conf != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  160U, "miredo_conf_set");
    }
  }
#line 161
  if (! ((unsigned long )name != (unsigned long )((void *)0))) {
    {
#line 161
    __assert_fail("name != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  161U, "miredo_conf_set");
    }
  }
#line 162
  if (! ((unsigned long )value != (unsigned long )((void *)0))) {
    {
#line 162
    __assert_fail("value != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  162U, "miredo_conf_set");
    }
  }
  {
#line 164
  tmp = malloc(sizeof(struct setting ));
#line 164
  parm = (struct setting *)tmp;
  }
#line 167
  if ((unsigned long )parm != (unsigned long )((void *)0)) {
    {
#line 169
    parm->name = strdup(name);
    }
#line 170
    if ((unsigned long )parm->name != (unsigned long )((void *)0)) {
      {
#line 172
      parm->value = strdup(value);
      }
#line 173
      if ((unsigned long )parm->value != (unsigned long )((void *)0)) {
#line 175
        parm->line = line;
#line 176
        parm->next = (struct setting *)((void *)0);
#line 179
        if ((unsigned long )conf->head == (unsigned long )((void *)0)) {
#line 180
          conf->head = parm;
        } else {
#line 183
          if (! ((unsigned long )conf->tail != (unsigned long )((void *)0))) {
            {
#line 183
            __assert_fail("conf->tail != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                          183U, "miredo_conf_set");
            }
          }
#line 184
          (conf->tail)->next = parm;
        }
#line 186
        conf->tail = parm;
#line 189
        return ((_Bool)1);
      }
      {
#line 191
      free((void *)parm->name);
      }
    }
    {
#line 193
    free((void *)parm);
    }
  }
  {
#line 196
  tmp___0 = __errno_location();
#line 196
  tmp___1 = strerror(*tmp___0);
#line 196
  tmp___2 = dgettext("miredo", "Error (%s): %s");
#line 196
  LogError(conf, (char const   *)tmp___2, "strdup", tmp___1);
  }
#line 197
  return ((_Bool)0);
}
}
#line 206 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
char *miredo_conf_get(miredo_conf *conf , char const   *name , unsigned int *line ) 
{ 
  struct setting *p ;
  struct setting *prev ;
  char *buf ;
  int tmp ;

  {
#line 208
  p = conf->head;
#line 208
  prev = (struct setting *)((void *)0);
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 208
      goto while_break;
    }
    {
#line 210
    tmp = strcasecmp((char const   *)p->name, name);
    }
#line 210
    if (tmp == 0) {
#line 212
      buf = p->value;
#line 214
      if ((unsigned long )line != (unsigned long )((void *)0)) {
#line 215
        *line = p->line;
      }
#line 217
      if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 218
        prev->next = p->next;
      } else {
#line 220
        conf->head = p->next;
      }
      {
#line 222
      free((void *)p->name);
#line 223
      free((void *)p);
      }
#line 224
      return (buf);
    }
#line 226
    prev = p;
#line 208
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return ((char *)((void *)0));
}
}
#line 233 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
static _Bool miredo_conf_read_FILE(miredo_conf *conf , FILE *stream ) 
{ 
  char lbuf[1056] ;
  unsigned int line ;
  size_t len ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char nbuf[32] ;
  char vbuf[1024] ;
  int tmp___4 ;
  _Bool tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 236
  line = 0U;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 238
    tmp___7 = fgets((char */* __restrict  */)(lbuf), (int )sizeof(lbuf), (FILE */* __restrict  */)stream);
    }
#line 238
    if (! ((unsigned long )tmp___7 != (unsigned long )((void *)0))) {
#line 238
      goto while_break;
    }
    {
#line 240
    tmp = strlen((char const   *)(lbuf));
#line 240
    len = tmp - 1UL;
#line 241
    line ++;
    }
#line 243
    if ((int )lbuf[len] != 10) {
      {
#line 245
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 245
        tmp___2 = fgetc(stream);
        }
#line 245
        if (! (tmp___2 != 10)) {
#line 245
          goto while_break___0;
        }
        {
#line 246
        tmp___0 = feof(stream);
        }
#line 246
        if (tmp___0) {
#line 247
          goto while_break___0;
        } else {
          {
#line 246
          tmp___1 = ferror(stream);
          }
#line 246
          if (tmp___1) {
#line 247
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 249
      tmp___3 = dgettext("miredo", "Skipped overly long line %u");
#line 249
      LogWarning(conf, (char const   *)tmp___3, line);
      }
#line 250
      goto while_continue;
    }
    {
#line 253
    lbuf[len] = (char )'\000';
#line 256
    tmp___4 = sscanf((char const   */* __restrict  */)(lbuf), (char const   */* __restrict  */)" %31s %1023s",
                     nbuf, vbuf);
    }
    {
#line 258
    if (tmp___4 == 2) {
#line 258
      goto case_2;
    }
#line 264
    if (tmp___4 == 1) {
#line 264
      goto case_1;
    }
#line 256
    goto switch_break;
    case_2: /* CIL Label */ 
#line 259
    if ((int )nbuf[0] != 35) {
      {
#line 259
      tmp___5 = miredo_conf_set(conf, (char const   *)(nbuf), (char const   *)(vbuf),
                                line);
      }
#line 259
      if (! tmp___5) {
#line 261
        return ((_Bool)0);
      }
    }
#line 262
    goto switch_break;
    case_1: /* CIL Label */ 
#line 265
    if ((int )nbuf[0] != 35) {
      {
#line 266
      tmp___6 = dgettext("miredo", "Ignoring line %u: %s");
#line 266
      LogWarning(conf, (char const   *)tmp___6, line, nbuf);
      }
    }
#line 268
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  tmp___11 = ferror(stream);
  }
#line 272
  if (tmp___11) {
    {
#line 274
    tmp___8 = __errno_location();
#line 274
    tmp___9 = strerror(*tmp___8);
#line 274
    tmp___10 = dgettext("miredo", "Error reading configuration file: %s");
#line 274
    LogError(conf, (char const   *)tmp___10, tmp___9);
    }
#line 276
    return ((_Bool)0);
  }
#line 278
  return ((_Bool)1);
}
}
#line 286 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
_Bool miredo_conf_read_file(miredo_conf *conf , char const   *path___0 ) 
{ 
  FILE *stream ;
  FILE *tmp ;
  _Bool ret ;
  _Bool tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 288
  if (! ((unsigned long )path___0 != (unsigned long )((void *)0))) {
    {
#line 288
    __assert_fail("path != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  288U, "miredo_conf_read_file");
    }
  }
  {
#line 290
  tmp = fopen((char const   */* __restrict  */)path___0, (char const   */* __restrict  */)"r");
#line 290
  stream = tmp;
  }
#line 291
  if ((unsigned long )stream != (unsigned long )((void *)0)) {
    {
#line 293
    tmp___0 = miredo_conf_read_FILE(conf, stream);
#line 293
    ret = tmp___0;
#line 294
    fclose(stream);
    }
#line 295
    return (ret);
  }
  {
#line 298
  tmp___1 = __errno_location();
#line 298
  tmp___2 = strerror(*tmp___1);
#line 298
  tmp___3 = dgettext("miredo", "Error opening configuration file %s: %s");
#line 298
  LogError(conf, (char const   *)tmp___3, path___0, tmp___2);
  }
#line 300
  return ((_Bool)0);
}
}
#line 311 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
_Bool miredo_conf_get_int16(miredo_conf *conf , char const   *name , uint16_t *value ,
                            unsigned int *line ) 
{ 
  char *val ;
  char *tmp ;
  char *end ;
  unsigned long l ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 314
  tmp = miredo_conf_get(conf, name, line);
#line 314
  val = tmp;
  }
#line 316
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 317
    return ((_Bool)1);
  }
  {
#line 322
  l = strtoul((char const   */* __restrict  */)val, (char **/* __restrict  */)(& end),
              0);
  }
#line 324
  if (*end) {
#line 324
    goto _L;
  } else
#line 324
  if (l > 65535UL) {
    _L: /* CIL Label */ 
    {
#line 326
    tmp___0 = __errno_location();
#line 326
    tmp___1 = strerror(*tmp___0);
#line 326
    tmp___2 = dgettext("miredo", "Invalid integer value \"%s\" for %s: %s");
#line 326
    LogError(conf, (char const   *)tmp___2, val, name, tmp___1);
#line 328
    free((void *)val);
    }
#line 329
    return ((_Bool)0);
  }
  {
#line 331
  *value = (uint16_t )l;
#line 332
  free((void *)val);
  }
#line 333
  return ((_Bool)1);
}
}
#line 393 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
int GetIPv4ByName(char const   *hostname , uint32_t *ipv4 ) 
{ 
  struct addrinfo help ;
  struct addrinfo *res ;
  int check ;
  int tmp ;

  {
  {
#line 395
  help.ai_flags = 0;
#line 395
  help.ai_family = 2;
#line 395
  help.ai_socktype = 2;
#line 395
  help.ai_protocol = 17;
#line 395
  help.ai_addrlen = 0U;
#line 395
  help.ai_addr = (struct sockaddr *)0;
#line 395
  help.ai_canonname = (char *)0;
#line 395
  help.ai_next = (struct addrinfo *)0;
#line 402
  tmp = getaddrinfo((char const   */* __restrict  */)hostname, (char const   */* __restrict  */)((void *)0),
                    (struct addrinfo  const  */* __restrict  */)(& help), (struct addrinfo **/* __restrict  */)(& res));
#line 402
  check = tmp;
  }
#line 403
  if (check) {
#line 404
    return (check);
  }
  {
#line 406
  *ipv4 = (uint32_t )((struct sockaddr_in  const  *)res->ai_addr)->sin_addr.s_addr;
#line 407
  freeaddrinfo(res);
  }
#line 408
  return (0);
}
}
#line 412 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
_Bool miredo_conf_parse_IPv4(miredo_conf *conf , char const   *name , uint32_t *ipv4 ) 
{ 
  unsigned int line ;
  char *val ;
  char *tmp ;
  int check ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 416
  tmp = miredo_conf_get(conf, name, & line);
#line 416
  val = tmp;
  }
#line 418
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 419
    return ((_Bool)1);
  }
  {
#line 421
  tmp___0 = GetIPv4ByName((char const   *)val, ipv4);
#line 421
  check = tmp___0;
  }
#line 423
  if (check) {
    {
#line 425
    tmp___1 = gai_strerror(check);
#line 425
    tmp___2 = dgettext("miredo", "Invalid hostname \"%s\" at line %u: %s");
#line 425
    LogError(conf, (char const   *)tmp___2, val, line, tmp___1);
#line 427
    free((void *)val);
    }
#line 428
    return ((_Bool)0);
  }
  {
#line 431
  free((void *)val);
  }
#line 432
  return ((_Bool)1);
}
}
#line 436 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
_Bool miredo_conf_parse_IPv6(miredo_conf *conf , char const   *name , struct in6_addr *value ) 
{ 
  unsigned int line ;
  char *val ;
  char *tmp ;
  struct addrinfo help ;
  struct addrinfo *res ;
  int check ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 440
  tmp = miredo_conf_get(conf, name, & line);
#line 440
  val = tmp;
  }
#line 442
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 443
    return ((_Bool)1);
  }
  {
#line 445
  help.ai_flags = 0;
#line 445
  help.ai_family = 10;
#line 445
  help.ai_socktype = 2;
#line 445
  help.ai_protocol = 17;
#line 445
  help.ai_addrlen = 0U;
#line 445
  help.ai_addr = (struct sockaddr *)0;
#line 445
  help.ai_canonname = (char *)0;
#line 445
  help.ai_next = (struct addrinfo *)0;
#line 452
  tmp___0 = getaddrinfo((char const   */* __restrict  */)val, (char const   */* __restrict  */)((void *)0),
                        (struct addrinfo  const  */* __restrict  */)(& help), (struct addrinfo **/* __restrict  */)(& res));
#line 452
  check = tmp___0;
  }
#line 454
  if (check) {
    {
#line 456
    tmp___1 = gai_strerror(check);
#line 456
    tmp___2 = dgettext("miredo", "Invalid hostname \"%s\" at line %u: %s");
#line 456
    LogError(conf, (char const   *)tmp___2, val, line, tmp___1);
#line 458
    free((void *)val);
    }
#line 459
    return ((_Bool)0);
  }
  {
#line 462
  memcpy((void */* __restrict  */)value, (void const   */* __restrict  */)(& ((struct sockaddr_in6  const  *)res->ai_addr)->sin6_addr),
         sizeof(struct in6_addr ));
#line 465
  freeaddrinfo(res);
#line 466
  free((void *)val);
  }
#line 467
  return ((_Bool)1);
}
}
#line 471 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
_Bool miredo_conf_parse_teredo_prefix(miredo_conf *conf , char const   *name , uint32_t *value ) 
{ 
  union teredo_addr addr ;
  char *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 475
  memset((void *)(& addr), 0, sizeof(addr));
#line 476
  addr.teredo.prefix = *value;
#line 478
  tmp___0 = miredo_conf_parse_IPv6(conf, name, & addr.ip6);
  }
#line 478
  if (tmp___0) {
#line 480
    if (! ((addr.teredo.prefix & 4278190080U) != 4278190080U)) {
      {
#line 482
      tmp = dgettext("miredo", "Invalid Teredo IPv6 prefix: %x::/32");
#line 482
      LogError(conf, (char const   *)tmp, addr.teredo.prefix);
      }
#line 484
      return ((_Bool)0);
    }
#line 487
    *value = addr.teredo.prefix;
#line 488
    return ((_Bool)1);
  }
#line 490
  return ((_Bool)0);
}
}
#line 494 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
static struct miredo_conf_syslog_facility  const  facilities[21]  = 
#line 494
  {      {"auth", 4 << 3}, 
        {"authpriv", 10 << 3}, 
        {"cron", 9 << 3}, 
        {"daemon", 3 << 3}, 
        {"ftp", 11 << 3}, 
        {"kern", 0}, 
        {"local0", 16 << 3}, 
        {"local1", 17 << 3}, 
        {"local2", 18 << 3}, 
        {"local3", 19 << 3}, 
        {"local4", 20 << 3}, 
        {"local5", 21 << 3}, 
        {"local6", 22 << 3}, 
        {"local7", 23 << 3}, 
        {"lpr", 6 << 3}, 
        {"mail", 2 << 3}, 
        {"news", 7 << 3}, 
        {"syslog", 5 << 3}, 
        {"user", 1 << 3}, 
        {"uucp", 8 << 3}, 
        {(char const   *)((void *)0), 0}};
#line 546 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
_Bool miredo_conf_parse_syslog_facility(miredo_conf *conf , char const   *name , int *facility ) 
{ 
  unsigned int line ;
  char *str ;
  char *tmp ;
  struct miredo_conf_syslog_facility  const  *ptr ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 550
  tmp = miredo_conf_get(conf, name, & line);
#line 550
  str = tmp;
  }
#line 552
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 553
    return ((_Bool)1);
  }
#line 555
  ptr = facilities;
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if (! ((unsigned long )ptr->str != (unsigned long )((void *)0))) {
#line 555
      goto while_break;
    }
    {
#line 558
    tmp___0 = strcasecmp((char const   *)str, (char const   *)ptr->str);
    }
#line 558
    if (! tmp___0) {
      {
#line 560
      *facility = (int )ptr->facility;
#line 561
      free((void *)str);
      }
#line 562
      return ((_Bool)1);
    }
#line 555
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 566
  tmp___1 = dgettext("miredo", "Unknown syslog facility \"%s\" at line %u");
#line 566
  LogError(conf, (char const   *)tmp___1, str, line);
#line 568
  free((void *)str);
  }
#line 569
  return ((_Bool)0);
}
}
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 564 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strsignal)(int __sig ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 227
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigismember)(sigset_t const   *__set ,
                                                                                                  int __signo ) ;
#line 270
extern int ( __attribute__((__nonnull__(1,2))) sigwait)(sigset_t const   * __restrict  __set ,
                                                        int * __restrict  __sig ) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_sigmask)(int __how ,
                                                                                      __sigset_t const   * __restrict  __newmask ,
                                                                                      __sigset_t * __restrict  __oldmask ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 200
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 944
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 44 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.h"
extern int drop_privileges(void) ;
#line 50 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.h"
int (*miredo_diagnose)(void)  ;
#line 51 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.h"
int (*miredo_run)(miredo_conf *conf , char const   *server )  ;
#line 57 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.h"
char const   *miredo_name  ;
#line 56 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.c"
uid_t unpriv_uid  =    (uid_t )0;
#line 57 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.c"
char const   *miredo_chrootdir  =    (char const   *)((void *)0);
#line 59 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.c"
extern int drop_privileges(void) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 67
  if ((unsigned long )miredo_chrootdir != (unsigned long )((void *)0)) {
    {
#line 67
    tmp___0 = chroot(miredo_chrootdir);
    }
#line 67
    if (tmp___0) {
      {
#line 70
      tmp = dgettext("miredo", "Error (%s): %m");
#line 70
      syslog(1, (char const   *)tmp, "chroot");
      }
#line 71
      return (-1);
    } else {
      {
#line 67
      tmp___1 = chdir("/");
      }
#line 67
      if (tmp___1) {
        {
#line 70
        tmp = dgettext("miredo", "Error (%s): %m");
#line 70
        syslog(1, (char const   *)tmp, "chroot");
        }
#line 71
        return (-1);
      }
    }
  }
  {
#line 75
  tmp___3 = setuid(unpriv_uid);
  }
#line 75
  if (tmp___3) {
    {
#line 77
    tmp___2 = dgettext("miredo", "Error (%s): %m");
#line 77
    syslog(1, (char const   *)tmp___2, "setuid");
    }
#line 78
    return (-1);
  }
#line 89
  return (0);
}
}
#line 96 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.c"
static void logger___0(void *dummy , _Bool error , char const   *fmt , va_list ap ) 
{ 
  int tmp ;

  {
#line 100
  if (error) {
#line 100
    tmp = 3;
  } else {
#line 100
    tmp = 4;
  }
  {
#line 100
  vsyslog(tmp, fmt, ap);
  }
#line 101
  return;
}
}
#line 104 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.c"
extern int miredo(char const   *confpath , char const   *server_name , int pidfd ) 
{ 
  sigset_t set ;
  sigset_t exit_set ;
  sigset_t reload_set ;
  int retval ;
  miredo_conf *cnf ;
  miredo_conf *tmp ;
  int facility ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  char *tmp___2 ;
  pid_t pid ;
  __pid_t tmp___3 ;
  char *tmp___4 ;
  int status ;
  int signum ;
  int tmp___5 ;
  __pid_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  __pid_t tmp___13 ;
  union __anonunion_68 __constr_expr_0 ;
  char *tmp___14 ;
  union __anonunion_69 __constr_expr_1 ;
  char *tmp___15 ;
  char *tmp___16 ;
  union __anonunion_70 __constr_expr_2 ;
  union __anonunion_71 __constr_expr_3 ;
  char const   *tmp___17 ;
  char *tmp___18 ;

  {
  {
#line 109
  tmp = miredo_conf_create(& logger___0, (void *)0);
#line 109
  cnf = tmp;
  }
#line 111
  if ((unsigned long )cnf == (unsigned long )((void *)0)) {
#line 112
    return (-1);
  }
  {
#line 114
  sigemptyset(& set);
#line 117
  sigaddset(& set, 2);
#line 118
  sigaddset(& set, 3);
#line 119
  sigaddset(& set, 15);
#line 120
  exit_set = set;
#line 123
  sigaddset(& set, 1);
#line 124
  reload_set = set;
#line 127
  sigaddset(& set, 17);
#line 129
  pthread_sigmask(0, (__sigset_t const   */* __restrict  */)(& set), (__sigset_t */* __restrict  */)((void *)0));
#line 131
  openlog(miredo_name, 33, 3 << 3);
  }
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 135
    facility = 3 << 3;
#line 136
    retval = 1;
#line 138
    tmp___1 = miredo_conf_read_file(cnf, confpath);
    }
#line 138
    if (! tmp___1) {
      {
#line 139
      tmp___0 = dgettext("miredo", "Loading configuration from %s failed");
#line 139
      syslog(4, (char const   *)tmp___0, confpath);
      }
    }
    {
#line 142
    miredo_conf_parse_syslog_facility(cnf, "SyslogFacility", & facility);
#line 145
    closelog();
#line 146
    openlog(miredo_name, 33, facility);
#line 147
    tmp___2 = dgettext("miredo", "Starting...");
#line 147
    syslog(6, (char const   *)tmp___2);
#line 150
    tmp___3 = fork();
#line 150
    pid = tmp___3;
    }
    {
#line 154
    if (pid == -1) {
#line 154
      goto case_neg_1;
    }
#line 158
    if (pid == 0) {
#line 158
      goto case_0;
    }
#line 166
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    {
#line 155
    tmp___4 = dgettext("miredo", "Error (%s): %m");
#line 155
    syslog(1, (char const   *)tmp___4, "fork");
    }
#line 156
    goto __Cont;
    case_0: /* CIL Label */ 
    {
#line 159
    close(pidfd);
#line 160
    retval = (*miredo_run)(cnf, server_name);
#line 161
    miredo_conf_destroy(cnf);
#line 162
    closelog();
#line 163
    exit(- retval);
    }
#line 164
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 167
    miredo_conf_clear(cnf, 0);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 172
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 174
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 174
        tmp___5 = sigwait((sigset_t const   */* __restrict  */)(& set), (int */* __restrict  */)(& signum));
        }
#line 174
        if (! tmp___5) {
#line 174
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 176
      if (signum == 17) {
        {
#line 176
        tmp___6 = waitpid(pid, & status, 1);
        }
#line 176
        if (tmp___6 == pid) {
#line 178
          goto while_break___0;
        }
      }
      {
#line 180
      tmp___12 = sigismember((sigset_t const   *)(& exit_set), signum);
      }
#line 180
      if (tmp___12) {
        {
#line 182
        tmp___7 = strsignal(signum);
#line 182
        tmp___8 = dgettext("miredo", "Exiting on signal %d (%s)");
#line 182
        syslog(5, (char const   *)tmp___8, signum, tmp___7);
#line 184
        retval = 0;
        }
      } else {
        {
#line 187
        tmp___11 = sigismember((sigset_t const   *)(& reload_set), signum);
        }
#line 187
        if (tmp___11) {
          {
#line 189
          tmp___9 = strsignal(signum);
#line 189
          tmp___10 = dgettext("miredo", "Reloading configuration on signal %d (%s)");
#line 189
          syslog(5, (char const   *)tmp___10, signum, tmp___9);
#line 192
          retval = 2;
          }
        } else {
#line 195
          goto __Cont___0;
        }
      }
      {
#line 198
      kill(pid, 15);
      }
      {
#line 200
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 200
        tmp___13 = waitpid(pid, & status, 0);
        }
#line 200
        if (! (tmp___13 != pid)) {
#line 200
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 201
      goto while_break___0;
      __Cont___0: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 205
    __constr_expr_3.__in = status;
#line 205
    if ((__constr_expr_3.__i & 127) == 0) {
      {
#line 207
      __constr_expr_0.__in = status;
#line 207
      status = (__constr_expr_0.__i & 65280) >> 8;
#line 208
      tmp___14 = dgettext("miredo", "Child %d exited (code: %d)");
#line 208
      syslog(5, (char const   *)tmp___14, pid, status);
      }
#line 210
      if (status) {
#line 211
        retval = 1;
      }
    } else {
#line 214
      __constr_expr_2.__in = status;
#line 214
      if ((int )((signed char )((__constr_expr_2.__i & 127) + 1)) >> 1 > 0) {
        {
#line 216
        __constr_expr_1.__in = status;
#line 216
        status = __constr_expr_1.__i & 127;
#line 217
        tmp___15 = strsignal(status);
#line 217
        tmp___16 = dgettext("miredo", "Child %d killed by signal %d (%s)");
#line 217
        syslog(6, (char const   *)tmp___16, pid, status, tmp___15);
#line 219
        retval = 2;
#line 220
        sleep(1U);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 133
    if (! (retval == 2)) {
#line 133
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  miredo_conf_destroy(cnf);
  }
#line 227
  if (retval) {
#line 227
    tmp___17 = "Terminated with error(s).";
  } else {
#line 227
    tmp___17 = "Terminated with no error.";
  }
  {
#line 227
  tmp___18 = gettext(tmp___17);
#line 227
  syslog(6, (char const   *)tmp___18);
#line 231
  closelog();
  }
#line 232
  return (- retval);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 261
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 524
extern int pthread_cancel(pthread_t __th ) ;
#line 529
extern void pthread_testcancel(void) ;
#line 773
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 33 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.h"
int teredo_server_check(char *errmsg , size_t len ) ;
#line 46
teredo_server *teredo_server_create(uint32_t ip1 , uint32_t ip2 ) ;
#line 57
int teredo_server_set_prefix(teredo_server *s , uint32_t prefix ) ;
#line 65
uint32_t teredo_server_get_prefix(teredo_server const   *s ) ;
#line 76
int teredo_server_set_MTU(teredo_server *s , uint16_t mtu ) ;
#line 83
uint16_t teredo_server_get_MTU(teredo_server const   *s ) ;
#line 92
int teredo_server_start(teredo_server *s ) ;
#line 99
void teredo_server_stop(teredo_server *s ) ;
#line 108
void teredo_server_destroy(teredo_server *s ) ;
#line 34 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/v4global.h"
int is_ipv4_global_unicast(uint32_t ip ) ;
#line 94 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.h"
__inline static int in6_matches_teredo_client(struct in6_addr  const  *ip6 , uint32_t ip ,
                                              uint16_t port ) 
{ 
  int tmp ;

  {
#line 98
  if (ip ^ (unsigned int )(((union teredo_addr  const  *)ip6)->teredo.client_ip ^ 4294967295U)) {
#line 98
    tmp = 0;
  } else
#line 98
  if ((int )port ^ (int )((int const   )((union teredo_addr  const  *)ip6)->teredo.client_port ^ 65535)) {
#line 98
    tmp = 0;
  } else {
#line 98
    tmp = 1;
  }
#line 98
  return (tmp);
}
}
#line 90 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo-udp.h"
int teredo_socket(uint32_t bind_ip , uint16_t port ) ;
#line 113
int teredo_sendv(int fd , struct iovec  const  *iov , size_t count , uint32_t dest_ip ,
                 uint16_t dest_port ) ;
#line 145
int teredo_wait_recv(int fd , struct teredo_packet *p ) ;
#line 152
uint16_t teredo_cksum(void const   *src , void const   *dst , uint8_t protocol , struct iovec  const  *data ,
                      size_t n ) ;
#line 163
void teredo_close(int fd ) ;
#line 33 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/checksum.h"
__inline static uint16_t icmp6_checksum(struct ip6_hdr  const  *ip6 , struct icmp6_hdr  const  *icmp6 ) 
{ 
  struct iovec iov ;
  uint16_t tmp ;
  uint16_t tmp___0 ;

  {
  {
#line 36
  tmp = ntohs((uint16_t )ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 36
  iov.iov_base = (void *)icmp6;
#line 36
  iov.iov_len = (size_t )tmp;
#line 37
  tmp___0 = teredo_cksum((void const   *)(& ip6->ip6_src), (void const   *)(& ip6->ip6_dst),
                         (uint8_t )58, (struct iovec  const  *)(& iov), (size_t )1);
  }
#line 37
  return (tmp___0);
}
}
#line 35 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/debug.h"
__inline static void debug(char const   *str  , ...) 
{ 
  va_list ap ;

  {
  {
#line 38
  __builtin_va_start(ap, str);
#line 39
  vsyslog(7, str, ap);
#line 40
  __builtin_va_end(ap);
  }
#line 41
  return;
}
}
#line 69 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/debug.h"
__inline static int d_pthread_mutex_lock(pthread_mutex_t *mutex___3 ) 
{ 
  int err ;
  int tmp ;

  {
  {
#line 71
  tmp = pthread_mutex_lock(mutex___3);
#line 71
  err = tmp;
  }
#line 72
  if (! (err != 35)) {
    {
#line 72
    __assert_fail("err != 35", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/debug.h",
                  72U, "d_pthread_mutex_lock");
    }
  }
#line 73
  if (! (err == 0)) {
    {
#line 73
    __assert_fail("err == 0", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/debug.h",
                  73U, "d_pthread_mutex_lock");
    }
  }
#line 74
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/debug.h"
__inline static int d_pthread_mutex_unlock(pthread_mutex_t *mutex___3 ) 
{ 
  int err ;
  int tmp ;

  {
  {
#line 80
  tmp = pthread_mutex_unlock(mutex___3);
#line 80
  err = tmp;
  }
#line 81
  if (! (err != 1)) {
    {
#line 81
    __assert_fail("err != 1", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/debug.h",
                  81U, "d_pthread_mutex_unlock");
    }
  }
#line 82
  if (! (err == 0)) {
    {
#line 82
    __assert_fail("err == 0", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/debug.h",
                  82U, "d_pthread_mutex_unlock");
    }
  }
#line 83
  return (0);
}
}
#line 48 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.h"
__inline static _Bool IsBubble(struct ip6_hdr  const  *hdr ) 
{ 
  int tmp ;

  {
#line 50
  if ((int const   )hdr->ip6_ctlun.ip6_un1.ip6_un1_plen == 0) {
#line 50
    if ((int const   )hdr->ip6_ctlun.ip6_un1.ip6_un1_nxt == 59) {
#line 50
      tmp = 1;
    } else {
#line 50
      tmp = 0;
    }
  } else {
#line 50
    tmp = 0;
  }
#line 50
  return ((_Bool )tmp);
}
}
#line 58 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
static pthread_mutex_t raw_mutex  =    {{0, 0U, 0, 0U, 2, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 59 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
static int raw_fd  ;
#line 60 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
static unsigned int raw_users  =    0U;
#line 77 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
static _Bool SendRA(teredo_server const   * __restrict  s , struct teredo_packet  const  *p ,
                    struct in6_addr  const  *dest_ip6 , _Bool secondary ) 
{ 
  uint8_t const   *nonce ;
  struct in6_addr *addr ;
  uint8_t auth[13] ;
  unsigned int tmp ;
  struct teredo_orig_ind orig ;
  struct __anonstruct_ra_57 ra ;
  struct iovec iov[3] ;
  uint16_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 83
  auth[0] = (uint8_t )0;
#line 83
  auth[1] = (uint8_t )1;
#line 83
  tmp = 2U;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (tmp >= 13U) {
#line 83
      goto while_break;
    }
#line 83
    auth[tmp] = (unsigned char)0;
#line 83
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  iov[0].iov_base = (void *)(auth);
#line 92
  iov[0].iov_len = (size_t )13;
#line 92
  iov[1].iov_base = (void *)(& orig);
#line 92
  iov[1].iov_len = (size_t )8;
#line 92
  iov[2].iov_base = (void *)(& ra);
#line 92
  iov[2].iov_len = sizeof(ra);
#line 101
  nonce = (uint8_t const   *)(p->auth_nonce);
#line 102
  if ((unsigned long )nonce != (unsigned long )((void *)0)) {
    {
#line 103
    memcpy((void */* __restrict  */)(auth + 4), (void const   */* __restrict  */)nonce,
           (size_t )8);
    }
  } else {
#line 105
    iov[0].iov_len = (size_t )0;
  }
  {
#line 109
  orig.orig_zero = (uint8_t )0;
#line 110
  orig.orig_code = (uint8_t )0;
#line 111
  orig.orig_port = (uint16_t )(~ ((int const   )p->source_port));
#line 112
  orig.orig_addr = (uint32_t )(~ p->source_ipv4);
#line 115
  memset((void *)(& ra), 0, sizeof(ra));
#line 116
  ra.ip6.ip6_ctlun.ip6_un1.ip6_un1_flow = htonl((uint32_t )1610612736);
#line 117
  ra.ip6.ip6_ctlun.ip6_un1.ip6_un1_plen = htons((uint16_t )(sizeof(ra) - sizeof(ra.ip6)));
#line 118
  ra.ip6.ip6_ctlun.ip6_un1.ip6_un1_nxt = (uint8_t )58;
#line 119
  ra.ip6.ip6_ctlun.ip6_un1.ip6_un1_hlim = (uint8_t )255;
#line 120
  ra.ip6.ip6_src = (struct in6_addr )s->lladdr.ip6;
#line 121
  ra.ip6.ip6_dst = (struct in6_addr )*dest_ip6;
#line 124
  ra.ra.nd_ra_hdr.icmp6_type = (uint8_t )134;
#line 131
  ra.ra.nd_ra_retransmit = htonl((uint32_t )2000);
#line 134
  ra.pi.nd_opt_pi_type = (uint8_t )3;
#line 135
  ra.pi.nd_opt_pi_len = (uint8_t )(sizeof(ra.pi) >> 3);
#line 136
  ra.pi.nd_opt_pi_prefix_len = (uint8_t )64;
#line 137
  ra.pi.nd_opt_pi_flags_reserved = (uint8_t )64;
#line 138
  ra.pi.nd_opt_pi_valid_time = 4294967295U;
#line 139
  ra.pi.nd_opt_pi_preferred_time = 4294967295U;
#line 140
  addr = & ra.pi.nd_opt_pi_prefix;
#line 141
  memcpy((void */* __restrict  */)(& addr->__in6_u.__u6_addr8[0]), (void const   */* __restrict  */)(& s->prefix),
         sizeof(s->prefix));
#line 142
  memcpy((void */* __restrict  */)(& addr->__in6_u.__u6_addr8[4]), (void const   */* __restrict  */)(& s->server_ip),
         sizeof(s->server_ip));
#line 146
  ra.mtu.nd_opt_mtu_type = (uint8_t )5;
#line 147
  ra.mtu.nd_opt_mtu_len = (uint8_t )(sizeof(ra.mtu) >> 3);
#line 149
  ra.mtu.nd_opt_mtu_mtu = (uint32_t )s->advLinkMTU;
#line 152
  ra.ra.nd_ra_hdr.icmp6_cksum = icmp6_checksum((struct ip6_hdr  const  *)(& ra.ip6),
                                               (struct icmp6_hdr  const  *)((struct icmp6_hdr *)(& ra.ra)));
#line 154
  tmp___0 = htons((uint16_t )32768);
  }
#line 154
  if ((int const   )((union teredo_addr  const  *)dest_ip6)->teredo.flags & (int const   )tmp___0) {
#line 155
    secondary = (_Bool )(! secondary);
  }
#line 157
  if (secondary) {
#line 157
    tmp___1 = s->fd_secondary;
  } else {
#line 157
    tmp___1 = s->fd_primary;
  }
  {
#line 157
  tmp___2 = teredo_sendv((int )tmp___1, (struct iovec  const  *)(iov), (size_t )3,
                         (uint32_t )p->source_ipv4, (uint16_t )p->source_port);
  }
#line 157
  return ((_Bool )(tmp___2 > 0));
}
}
#line 165 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
static _Bool teredo_forward_udp(int fd , struct teredo_packet  const  *packet , _Bool insert_orig ) 
{ 
  struct teredo_orig_ind orig ;
  struct iovec iov[2] ;
  uint32_t dest_ipv4 ;
  uint16_t dest_port ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 174
  dest_ipv4 = (uint32_t )(((union teredo_addr  const  *)(& (packet->ip6)->ip6_dst))->teredo.client_ip ^ 4294967295U);
#line 175
  dest_port = (uint16_t )((int const   )((union teredo_addr  const  *)(& (packet->ip6)->ip6_dst))->teredo.client_port ^ 65535);
#line 176
  tmp = is_ipv4_global_unicast(dest_ipv4);
  }
#line 176
  if (! tmp) {
#line 177
    return ((_Bool)0);
  }
#line 183
  iov[0].iov_base = (void *)(& orig);
#line 184
  if (insert_orig) {
#line 186
    iov[0].iov_len = sizeof(orig);
#line 187
    orig.orig_zero = (uint8_t )0;
#line 188
    orig.orig_code = (uint8_t )0;
#line 189
    orig.orig_port = (uint16_t )(~ ((int const   )packet->source_port));
#line 190
    orig.orig_addr = (uint32_t )(~ packet->source_ipv4);
  } else {
#line 193
    iov[0].iov_len = (size_t )0;
  }
  {
#line 195
  iov[1].iov_base = (void *)packet->ip6;
#line 196
  iov[1].iov_len = (size_t )packet->ip6_len;
#line 198
  tmp___0 = teredo_sendv(fd, (struct iovec  const  *)(iov), (size_t )2, dest_ipv4,
                         dest_port);
  }
#line 198
  return ((_Bool )(tmp___0 > 0));
}
}
#line 205 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
static _Bool teredo_send_ipv6(struct ip6_hdr  const  *p , size_t len ) 
{ 
  struct sockaddr_in6 dst ;
  int tries ;
  ssize_t res ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 210
  memset((void *)(& dst), 0, sizeof(dst));
#line 211
  dst.sin6_family = (sa_family_t )10;
#line 215
  dst.sin6_addr = (struct in6_addr )p->ip6_dst;
#line 217
  tries = 0;
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (tries < 10)) {
#line 217
      goto while_break;
    }
    {
#line 219
    tmp = sendto(raw_fd, (void const   *)p, len, 0, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dst)),
                 (socklen_t )sizeof(dst));
#line 219
    res = tmp;
    }
#line 221
    if (res != -1L) {
#line 222
      return ((_Bool )(res == (ssize_t )len));
    }
    {
#line 224
    tmp___0 = __errno_location();
    }
    {
#line 233
    if (*tmp___0 == 71) {
#line 233
      goto case_71;
    }
#line 233
    if (*tmp___0 == 90) {
#line 233
      goto case_71;
    }
#line 233
    if (*tmp___0 == 111) {
#line 233
      goto case_71;
    }
#line 233
    if (*tmp___0 == 113) {
#line 233
      goto case_71;
    }
#line 233
    if (*tmp___0 == 13) {
#line 233
      goto case_71;
    }
#line 233
    if (*tmp___0 == 101) {
#line 233
      goto case_71;
    }
#line 237
    goto switch_default;
    case_71: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_101: /* CIL Label */ 
#line 235
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 238
    return ((_Bool)0);
    switch_break: /* CIL Label */ ;
    }
#line 217
    tries ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return ((_Bool)0);
}
}
#line 246 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
static struct in6_addr  const  in6addr_allrouters  =    {{{(uint8_t )255, (uint8_t )2, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0,
      (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0,
      (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )2}}};
#line 250 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
__inline static _Bool IN6_IS_ADDR_GLOBAL(struct in6_addr  const  *addr ) 
{ 
  struct in6_addr  const  *__a ;
  int tmp ;
  struct in6_addr  const  *__a___0 ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  struct in6_addr  const  *__a___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 253
  __a = addr;
#line 253
  if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 253
    if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 253
      if (__a->__in6_u.__u6_addr32[2] == 0U) {
#line 253
        if (__a->__in6_u.__u6_addr32[3] == 0U) {
#line 253
          tmp = 1;
        } else {
#line 253
          tmp = 0;
        }
      } else {
#line 253
        tmp = 0;
      }
    } else {
#line 253
      tmp = 0;
    }
  } else {
#line 253
    tmp = 0;
  }
#line 255
  if (tmp) {
#line 255
    tmp___4 = 0;
  } else {
#line 254
    __a___0 = addr;
#line 254
    if (__a___0->__in6_u.__u6_addr32[0] == 0U) {
#line 254
      if (__a___0->__in6_u.__u6_addr32[1] == 0U) {
#line 254
        if (__a___0->__in6_u.__u6_addr32[2] == 0U) {
          {
#line 254
          tmp___0 = htonl((uint32_t )1);
          }
#line 254
          if (__a___0->__in6_u.__u6_addr32[3] == tmp___0) {
#line 254
            tmp___1 = 1;
          } else {
#line 254
            tmp___1 = 0;
          }
        } else {
#line 254
          tmp___1 = 0;
        }
      } else {
#line 254
        tmp___1 = 0;
      }
    } else {
#line 254
      tmp___1 = 0;
    }
#line 255
    if (tmp___1) {
#line 255
      tmp___4 = 0;
    } else {
      {
#line 255
      __a___1 = addr;
#line 255
      tmp___2 = htonl(4290772992U);
#line 255
      tmp___3 = htonl(4269801472U);
      }
#line 255
      if ((__a___1->__in6_u.__u6_addr32[0] & tmp___2) == tmp___3) {
#line 255
        tmp___4 = 0;
      } else
#line 255
      if ((int const   )*((uint8_t const   *)addr + 0) == 255) {
#line 255
        tmp___4 = 0;
      } else {
#line 255
        tmp___4 = 1;
      }
    }
  }
#line 253
  return ((_Bool )tmp___4);
}
}
#line 261 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
static void debug_error_header(uint32_t const   *v4src , struct in6_addr  const  *v6src ,
                               struct in6_addr  const  *v6dst ) 
{ 
  char v4s[16] ;
  unsigned int tmp ;
  char v6s[46] ;
  unsigned int tmp___0 ;
  char v6d[46] ;
  unsigned int tmp___1 ;

  {
#line 265
  v4s[0] = (char )'u';
#line 265
  v4s[1] = (char )'n';
#line 265
  v4s[2] = (char )'k';
#line 265
  v4s[3] = (char )'n';
#line 265
  v4s[4] = (char )'o';
#line 265
  v4s[5] = (char )'w';
#line 265
  v4s[6] = (char )'n';
#line 265
  v4s[7] = (char )'\000';
#line 265
  tmp = 8U;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (tmp >= 16U) {
#line 265
      goto while_break;
    }
#line 265
    v4s[tmp] = (char)0;
#line 265
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  v6s[0] = (char )'u';
#line 266
  v6s[1] = (char )'n';
#line 266
  v6s[2] = (char )'k';
#line 266
  v6s[3] = (char )'n';
#line 266
  v6s[4] = (char )'o';
#line 266
  v6s[5] = (char )'w';
#line 266
  v6s[6] = (char )'n';
#line 266
  v6s[7] = (char )'\000';
#line 266
  tmp___0 = 8U;
  {
#line 266
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 266
    if (tmp___0 >= 46U) {
#line 266
      goto while_break___0;
    }
#line 266
    v6s[tmp___0] = (char)0;
#line 266
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 267
  v6d[0] = (char )'u';
#line 267
  v6d[1] = (char )'n';
#line 267
  v6d[2] = (char )'k';
#line 267
  v6d[3] = (char )'n';
#line 267
  v6d[4] = (char )'o';
#line 267
  v6d[5] = (char )'w';
#line 267
  v6d[6] = (char )'n';
#line 267
  v6d[7] = (char )'\000';
#line 267
  tmp___1 = 8U;
  {
#line 267
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 267
    if (tmp___1 >= 46U) {
#line 267
      goto while_break___1;
    }
#line 267
    v6d[tmp___1] = (char)0;
#line 267
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 269
  if ((unsigned long )v4src != (unsigned long )((void *)0)) {
    {
#line 270
    inet_ntop(2, (void const   */* __restrict  */)v4src, (char */* __restrict  */)(v4s),
              (socklen_t )sizeof(v4s));
    }
  }
#line 271
  if ((unsigned long )v6src != (unsigned long )((void *)0)) {
    {
#line 272
    inet_ntop(10, (void const   */* __restrict  */)v6src, (char */* __restrict  */)(v6s),
              (socklen_t )sizeof(v6s));
    }
  }
#line 273
  if ((unsigned long )v6dst != (unsigned long )((void *)0)) {
    {
#line 274
    inet_ntop(10, (void const   */* __restrict  */)v6dst, (char */* __restrict  */)(v6d),
              (socklen_t )sizeof(v6d));
    }
  }
  {
#line 276
  debug("Received packet from %s containing %s to %s.", v4s, v6s, v6d);
  }
#line 277
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
static int teredo_process_packet(teredo_server const   *s , _Bool sec ) 
{ 
  struct teredo_packet packet ;
  int tmp ;
  int tmp___0 ;
  struct ip6_hdr  const  *ip6 ;
  size_t plen ;
  uint16_t tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  uint32_t myprefix ;
  struct in6_addr  const  *__a ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  struct in6_addr  const  *__a___0 ;
  struct in6_addr  const  *__b ;
  int tmp___6 ;
  int tmp___7 ;
  uint16_t tmp___8 ;
  uint16_t tmp___9 ;
  struct icmp6_hdr  const  *icmp ;
  int tmp___11 ;
  _Bool tmp___12 ;
  struct in6_addr  const  *__a___1 ;
  struct in6_addr  const  *__b___0 ;
  int tmp___13 ;
  struct in6_addr  const  *__a___2 ;
  struct in6_addr  const  *__b___1 ;
  int tmp___14 ;
  _Bool tmp___15 ;
  int tmp___17 ;
  _Bool tmp___18 ;
  int tmp___20 ;
  _Bool tmp___21 ;

  {
#line 296
  if (sec) {
#line 296
    tmp = s->fd_secondary;
  } else {
#line 296
    tmp = s->fd_primary;
  }
  {
#line 296
  tmp___0 = teredo_wait_recv((int )tmp, & packet);
  }
#line 296
  if (tmp___0) {
#line 297
    return (-1);
  }
#line 300
  ip6 = (struct ip6_hdr  const  *)packet.ip6;
#line 301
  if (packet.ip6_len < sizeof(*ip6)) {
    {
#line 303
    debug_error_header((uint32_t const   *)(& packet.source_ipv4), (struct in6_addr  const  *)((void *)0),
                       (struct in6_addr  const  *)((void *)0));
#line 304
    debug("Packet too small: %d bytes", packet.ip6_len);
    }
#line 305
    return (-2);
  }
  {
#line 308
  tmp___1 = ntohs((uint16_t )ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 308
  plen = (size_t )tmp___1;
  }
#line 309
  if ((int const   )ip6->ip6_ctlun.ip6_un2_vfc >> 4 != 6) {
    {
#line 312
    debug_error_header((uint32_t const   *)(& packet.source_ipv4), (struct in6_addr  const  *)((void *)0),
                       (struct in6_addr  const  *)((void *)0));
#line 313
    debug("Not an IPv6 packet: Version %d", (int const   )ip6->ip6_ctlun.ip6_un2_vfc >> 4);
    }
#line 314
    return (-2);
  } else
#line 309
  if (sizeof(*ip6) + plen > packet.ip6_len) {
    {
#line 312
    debug_error_header((uint32_t const   *)(& packet.source_ipv4), (struct in6_addr  const  *)((void *)0),
                       (struct in6_addr  const  *)((void *)0));
#line 313
    debug("Not an IPv6 packet: Version %d", (int const   )ip6->ip6_ctlun.ip6_un2_vfc >> 4);
    }
#line 314
    return (-2);
  }
  {
#line 320
  tmp___2 = IsBubble(ip6);
  }
#line 320
  if (! tmp___2) {
#line 320
    if ((int const   )ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt != 58) {
      {
#line 323
      debug_error_header((uint32_t const   *)(& packet.source_ipv4), & ip6->ip6_src,
                         & ip6->ip6_dst);
#line 325
      debug("Packet not allowed: Protocol %d", (int const   )ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt);
      }
#line 326
      return (-2);
    }
  }
  {
#line 330
  tmp___3 = is_ipv4_global_unicast(packet.source_ipv4);
  }
#line 330
  if (! tmp___3) {
    {
#line 332
    debug_error_header((uint32_t const   *)(& packet.source_ipv4), & ip6->ip6_src,
                       & ip6->ip6_dst);
#line 334
    debug("Source is not IPv4 unicast.");
    }
#line 335
    return (-2);
  }
  {
#line 338
  myprefix = (uint32_t )s->prefix;
#line 341
  __a = & ip6->ip6_src;
#line 341
  tmp___4 = htonl(4290772992U);
#line 341
  tmp___5 = htonl(4269801472U);
  }
#line 342
  if ((__a->__in6_u.__u6_addr32[0] & tmp___4) == tmp___5) {
#line 342
    __a___0 = & in6addr_allrouters;
#line 342
    __b = & ip6->ip6_dst;
#line 342
    if (__a___0->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 342
      if (__a___0->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 342
        if (__a___0->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 342
          if (__a___0->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 342
            tmp___6 = 1;
          } else {
#line 342
            tmp___6 = 0;
          }
        } else {
#line 342
          tmp___6 = 0;
        }
      } else {
#line 342
        tmp___6 = 0;
      }
    } else {
#line 342
      tmp___6 = 0;
    }
#line 342
    if (tmp___6) {
#line 342
      if ((int const   )ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58) {
#line 342
        if (plen >= sizeof(struct nd_router_solicit )) {
#line 342
          if ((int const   )((struct icmp6_hdr  const  *)(ip6 + 1))->icmp6_type == 133) {
#line 346
            goto accept;
          }
        }
      }
    }
  }
#line 348
  if (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix == (uint32_t const   )myprefix) {
    {
#line 352
    tmp___7 = in6_matches_teredo_client(& ip6->ip6_src, packet.source_ipv4, packet.source_port);
    }
#line 352
    if (tmp___7) {
#line 354
      goto accept;
    }
  } else
#line 360
  if (((union teredo_addr  const  *)(& ip6->ip6_dst))->teredo.prefix == (uint32_t const   )myprefix) {
#line 360
    if (((union teredo_addr  const  *)(& ip6->ip6_dst))->teredo.server_ip == s->server_ip) {
#line 362
      goto accept;
    }
  }
  {
#line 366
  debug_error_header((uint32_t const   *)(& packet.source_ipv4), & ip6->ip6_src, & ip6->ip6_dst);
#line 367
  debug("Drop packet.");
  }
#line 368
  return (-2);
  accept: 
#line 374
  if (packet.source_ipv4 == (uint32_t )s->server_ip) {
#line 374
    goto _L;
  } else
#line 374
  if (packet.source_ipv4 == (uint32_t )s->server_ip2) {
    _L: /* CIL Label */ 
    {
#line 374
    tmp___9 = htons((uint16_t )3544);
    }
#line 374
    if ((int )packet.source_port == (int )tmp___9) {
      {
#line 378
      debug_error_header((uint32_t const   *)(& packet.source_ipv4), & ip6->ip6_src,
                         & ip6->ip6_dst);
#line 380
      tmp___8 = ntohs(packet.source_port);
#line 380
      debug("Prevent infinite local UDP packet loops from port %d", (int )tmp___8);
      }
#line 382
      return (-2);
    }
  }
#line 385
  __a___1 = & in6addr_allrouters;
#line 385
  __b___0 = & ip6->ip6_dst;
#line 385
  if (__a___1->__in6_u.__u6_addr32[0] == __b___0->__in6_u.__u6_addr32[0]) {
#line 385
    if (__a___1->__in6_u.__u6_addr32[1] == __b___0->__in6_u.__u6_addr32[1]) {
#line 385
      if (__a___1->__in6_u.__u6_addr32[2] == __b___0->__in6_u.__u6_addr32[2]) {
#line 385
        if (__a___1->__in6_u.__u6_addr32[3] == __b___0->__in6_u.__u6_addr32[3]) {
#line 385
          tmp___13 = 1;
        } else {
#line 385
          tmp___13 = 0;
        }
      } else {
#line 385
        tmp___13 = 0;
      }
    } else {
#line 385
      tmp___13 = 0;
    }
  } else {
#line 385
    tmp___13 = 0;
  }
#line 386
  if (tmp___13) {
#line 386
    goto _L___0;
  } else {
#line 386
    __a___2 = & s->lladdr.ip6;
#line 386
    __b___1 = & ip6->ip6_dst;
#line 386
    if (__a___2->__in6_u.__u6_addr32[0] == __b___1->__in6_u.__u6_addr32[0]) {
#line 386
      if (__a___2->__in6_u.__u6_addr32[1] == __b___1->__in6_u.__u6_addr32[1]) {
#line 386
        if (__a___2->__in6_u.__u6_addr32[2] == __b___1->__in6_u.__u6_addr32[2]) {
#line 386
          if (__a___2->__in6_u.__u6_addr32[3] == __b___1->__in6_u.__u6_addr32[3]) {
#line 386
            tmp___14 = 1;
          } else {
#line 386
            tmp___14 = 0;
          }
        } else {
#line 386
          tmp___14 = 0;
        }
      } else {
#line 386
        tmp___14 = 0;
      }
    } else {
#line 386
      tmp___14 = 0;
    }
#line 386
    if (tmp___14) {
      _L___0: /* CIL Label */ 
#line 388
      icmp = (struct icmp6_hdr  const  *)(ip6 + 1);
#line 390
      if ((int const   )ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58) {
#line 390
        if (plen >= sizeof(struct nd_router_solicit )) {
#line 390
          if ((int const   )icmp->icmp6_type == 133) {
            {
#line 393
            tmp___12 = SendRA((teredo_server const   */* __restrict  */)s, (struct teredo_packet  const  *)(& packet),
                              & ip6->ip6_src, sec);
            }
#line 393
            if (tmp___12) {
#line 393
              tmp___11 = 1;
            } else {
#line 393
              tmp___11 = -1;
            }
#line 393
            return (tmp___11);
          }
        }
      }
#line 394
      if ((int const   )ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58) {
        {
#line 396
        debug_error_header((uint32_t const   *)(& packet.source_ipv4), & ip6->ip6_src,
                           & ip6->ip6_dst);
#line 398
        debug("Unhandled router message: ICMP type %d", (int const   )icmp->icmp6_type);
        }
      } else {
        {
#line 401
        debug_error_header((uint32_t const   *)(& packet.source_ipv4), & ip6->ip6_src,
                           & ip6->ip6_dst);
#line 403
        debug("Unhandled router message: Protocol %d", (int const   )ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt);
        }
      }
#line 406
      return (-2);
    }
  }
  {
#line 410
  tmp___15 = IN6_IS_ADDR_GLOBAL(& ip6->ip6_dst);
  }
#line 410
  if (! tmp___15) {
    {
#line 412
    debug_error_header((uint32_t const   *)(& packet.source_ipv4), & ip6->ip6_src,
                       & ip6->ip6_dst);
#line 414
    debug("Destination is no global IPv6 address");
    }
#line 415
    return (-2);
  }
#line 432
  if ((int const   )ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt != 59) {
#line 432
    if (plen > 88UL) {
      {
#line 434
      debug_error_header((uint32_t const   *)(& packet.source_ipv4), & ip6->ip6_src,
                         & ip6->ip6_dst);
#line 436
      debug("ICMPv6 too large (%zu bytes)", plen);
      }
#line 437
      return (-2);
    }
  }
#line 440
  if (((union teredo_addr  const  *)(& ip6->ip6_dst))->teredo.prefix != (uint32_t const   )myprefix) {
    {
#line 441
    tmp___18 = teredo_send_ipv6((struct ip6_hdr  const  *)packet.ip6, sizeof(*ip6) + plen);
    }
#line 441
    if (tmp___18) {
#line 441
      tmp___17 = 2;
    } else {
#line 441
      tmp___17 = -1;
    }
#line 441
    return (tmp___17);
  }
  {
#line 445
  tmp___21 = teredo_forward_udp((int )s->fd_primary, (struct teredo_packet  const  *)(& packet),
                                (_Bool )(((union teredo_addr  const  *)(& ip6->ip6_dst))->teredo.server_ip == s->server_ip));
  }
#line 445
  if (tmp___21) {
#line 445
    tmp___20 = 3;
  } else {
#line 445
    tmp___20 = -1;
  }
#line 445
  return (tmp___20);
}
}
#line 450 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
int teredo_server_check(char *errmsg , size_t len ) 
{ 
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 452
  tmp = socket(10, 3, 255);
#line 452
  fd = tmp;
  }
#line 454
  if (fd >= 0) {
    {
#line 456
    close(fd);
    }
#line 457
    return (0);
  }
  {
#line 461
  tmp___0 = __errno_location();
#line 461
  tmp___1 = strerror(*tmp___0);
#line 461
  tmp___2 = dgettext("miredo", "Raw IPv6 socket not working: %s");
#line 461
  snprintf((char */* __restrict  */)errmsg, len, (char const   */* __restrict  */)tmp___2,
           tmp___1);
  }
#line 463
  return (-1);
}
}
#line 467
static  __attribute__((__noreturn__)) void *thread_primary(void *data ) ;
#line 467 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
static void *thread_primary(void *data ) 
{ 


  {
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 471
    pthread_testcancel();
#line 472
    teredo_process_packet((teredo_server const   *)((teredo_server *)data), (_Bool)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 477
static  __attribute__((__noreturn__)) void *thread_secondary(void *data ) ;
#line 477 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
static void *thread_secondary(void *data ) 
{ 


  {
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 481
    pthread_testcancel();
#line 482
    teredo_process_packet((teredo_server const   *)((teredo_server *)data), (_Bool)1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 487 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
teredo_server *teredo_server_create(uint32_t ip1 , uint32_t ip2 ) 
{ 
  int flags ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  teredo_server *s ;
  void *tmp___6 ;
  int fd ;
  uint16_t tmp___7 ;
  int tmp___8 ;
  uint16_t tmp___9 ;
  int tmp___10 ;
  uint16_t tmp___11 ;
  char str[16] ;
  char *tmp___12 ;
  char str___0[16] ;
  char *tmp___13 ;

  {
  {
#line 489
  bindtextdomain("miredo", "/usr/local/share/locale");
#line 492
  d_pthread_mutex_lock(& raw_mutex);
  }
#line 493
  if (raw_users == 4294967295U) {
    {
#line 496
    d_pthread_mutex_unlock(& raw_mutex);
    }
#line 497
    return ((teredo_server *)((void *)0));
  }
#line 499
  tmp___1 = raw_users;
#line 499
  raw_users ++;
#line 499
  if (tmp___1 == 0U) {
    {
#line 501
    raw_fd = socket(10, 3, 255);
    }
#line 502
    if (raw_fd != -1) {
      {
#line 504
      tmp = fcntl(raw_fd, 3, 0);
#line 504
      flags = tmp;
      }
#line 506
      if (flags != -1) {
#line 506
        tmp___0 = flags;
      } else {
#line 506
        tmp___0 = 0;
      }
      {
#line 506
      fcntl(raw_fd, 4, 2048 | tmp___0);
#line 508
      fcntl(raw_fd, 2, 1);
      }
    }
  }
  {
#line 511
  d_pthread_mutex_unlock(& raw_mutex);
  }
#line 513
  if (raw_fd == -1) {
    {
#line 515
    tmp___2 = dgettext("miredo", "Raw IPv6 socket not working: %m");
#line 515
    syslog(3, (char const   *)tmp___2);
    }
#line 516
    return ((teredo_server *)((void *)0));
  }
  {
#line 520
  tmp___4 = is_ipv4_global_unicast(ip1);
  }
#line 520
  if (tmp___4) {
    {
#line 520
    tmp___5 = is_ipv4_global_unicast(ip2);
    }
#line 520
    if (! tmp___5) {
      {
#line 522
      tmp___3 = dgettext("miredo", "Teredo server UDP socket error: Server IPv4 addresses must be global unicast.");
#line 522
      syslog(3, (char const   *)tmp___3);
      }
#line 524
      return ((teredo_server *)((void *)0));
    }
  } else {
    {
#line 522
    tmp___3 = dgettext("miredo", "Teredo server UDP socket error: Server IPv4 addresses must be global unicast.");
#line 522
    syslog(3, (char const   *)tmp___3);
    }
#line 524
    return ((teredo_server *)((void *)0));
  }
  {
#line 527
  tmp___6 = malloc(sizeof(*s));
#line 527
  s = (teredo_server *)tmp___6;
  }
#line 529
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 533
    memset((void *)s, 0, sizeof(*s));
#line 534
    s->server_ip = ip1;
#line 535
    s->server_ip2 = ip2;
#line 536
    s->prefix = htonl((uint32_t )536936448);
#line 537
    s->advLinkMTU = htonl((uint32_t )1280);
#line 538
    s->lladdr.teredo.prefix = htonl(4269801472U);
#line 540
    s->lladdr.teredo.flags = htons((uint16_t )32768);
#line 541
    tmp___7 = htons((uint16_t )3544);
#line 541
    s->lladdr.teredo.client_port = (uint16_t )(~ ((int )tmp___7));
#line 542
    s->lladdr.teredo.client_ip = ~ s->server_ip;
#line 544
    tmp___9 = htons((uint16_t )3544);
#line 544
    tmp___8 = teredo_socket(ip1, tmp___9);
#line 544
    s->fd_primary = tmp___8;
#line 544
    fd = tmp___8;
    }
#line 545
    if (fd != -1) {
      {
#line 547
      tmp___11 = htons((uint16_t )3544);
#line 547
      tmp___10 = teredo_socket(ip2, tmp___11);
#line 547
      s->fd_secondary = tmp___10;
#line 547
      fd = tmp___10;
      }
#line 548
      if (fd != -1) {
#line 549
        return (s);
      } else {
        {
#line 554
        inet_ntop(2, (void const   */* __restrict  */)(& ip2), (char */* __restrict  */)(str),
                  (socklen_t )sizeof(str));
#line 555
        tmp___12 = dgettext("miredo", "Error (%s): %m");
#line 555
        syslog(3, (char const   *)tmp___12, str);
        }
      }
      {
#line 558
      teredo_close(s->fd_primary);
      }
    } else {
      {
#line 564
      inet_ntop(2, (void const   */* __restrict  */)(& ip1), (char */* __restrict  */)(str___0),
                (socklen_t )sizeof(str___0));
#line 565
      tmp___13 = dgettext("miredo", "Error (%s): %m");
#line 565
      syslog(3, (char const   *)tmp___13, str___0);
      }
    }
    {
#line 568
    free((void *)s);
    }
  }
#line 570
  return ((teredo_server *)((void *)0));
}
}
#line 574 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
int teredo_server_set_prefix(teredo_server *s , uint32_t prefix ) 
{ 


  {
#line 576
  if ((prefix & 4278190080U) != 4278190080U) {
#line 578
    s->prefix = prefix;
#line 579
    return (0);
  }
#line 581
  return (-1);
}
}
#line 585 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
uint32_t teredo_server_get_prefix(teredo_server const   *s ) 
{ 


  {
#line 587
  return ((uint32_t )s->prefix);
}
}
#line 590 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
int teredo_server_set_MTU(teredo_server *s , uint16_t mtu ) 
{ 


  {
#line 592
  if ((int )mtu < 1280) {
#line 593
    return (-1);
  }
  {
#line 595
  s->advLinkMTU = htonl((uint32_t )mtu);
  }
#line 596
  return (0);
}
}
#line 600 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
uint16_t teredo_server_get_MTU(teredo_server const   *s ) 
{ 
  uint32_t tmp ;

  {
  {
#line 602
  tmp = ntohl((uint32_t )s->advLinkMTU);
  }
#line 602
  return ((uint16_t )tmp);
}
}
#line 606 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
int teredo_server_start(teredo_server *s ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 608
  tmp___0 = pthread_create((pthread_t */* __restrict  */)(& s->t1), (pthread_attr_t const   */* __restrict  */)((void *)0),
                           & thread_primary, (void */* __restrict  */)s);
  }
#line 608
  if (tmp___0 == 0) {
    {
#line 610
    tmp = pthread_create((pthread_t */* __restrict  */)(& s->t2), (pthread_attr_t const   */* __restrict  */)((void *)0),
                         & thread_secondary, (void */* __restrict  */)s);
    }
#line 610
    if (tmp == 0) {
#line 611
      return (0);
    }
    {
#line 612
    pthread_cancel(s->t1);
#line 613
    pthread_join(s->t1, (void **)((void *)0));
    }
  }
#line 616
  return (-1);
}
}
#line 620 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
void teredo_server_stop(teredo_server *s ) 
{ 


  {
  {
#line 622
  pthread_cancel(s->t1);
#line 623
  pthread_cancel(s->t2);
#line 624
  pthread_join(s->t1, (void **)((void *)0));
#line 625
  pthread_join(s->t2, (void **)((void *)0));
  }
#line 626
  return;
}
}
#line 629 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/server.c"
void teredo_server_destroy(teredo_server *s ) 
{ 


  {
  {
#line 631
  teredo_close(s->fd_primary);
#line 632
  teredo_close(s->fd_secondary);
#line 633
  free((void *)s);
#line 635
  d_pthread_mutex_lock(& raw_mutex);
#line 636
  raw_users --;
  }
#line 636
  if (raw_users == 0U) {
    {
#line 637
    close(raw_fd);
    }
  }
  {
#line 638
  d_pthread_mutex_unlock(& raw_mutex);
  }
#line 639
  return;
}
}
#line 54 "/home/wheatley/newnew/temp/miredo-1.2.6/src/serverd.c"
static int server_diagnose(void) 
{ 
  char buf[1024] ;
  int check ;
  int tmp ;

  {
  {
#line 58
  tmp = teredo_server_check(buf, sizeof(buf));
#line 58
  check = tmp;
  }
#line 59
  if (check) {
    {
#line 61
    buf[sizeof(buf) - 1UL] = (char )'\000';
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            buf);
    }
  }
#line 64
  return (check);
}
}
#line 68 "/home/wheatley/newnew/temp/miredo-1.2.6/src/serverd.c"
static int server_run(miredo_conf *conf , char const   *server_name ) 
{ 
  teredo_server *server ;
  union teredo_addr prefix ;
  uint32_t server_ip ;
  uint32_t server_ip2 ;
  uint16_t mtu ;
  int check ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  uint32_t tmp___7 ;
  char *tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  int tmp___11 ;
  sigset_t dummyset ;
  sigset_t set ;
  int dummy ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
  {
#line 73
  server_ip = (in_addr_t )0;
#line 73
  server_ip2 = (in_addr_t )0;
#line 74
  mtu = (uint16_t )1280;
#line 76
  memset((void *)(& prefix), 0, sizeof(prefix));
#line 77
  prefix.teredo.prefix = htonl((uint32_t )536936448);
  }
#line 79
  if ((unsigned long )server_name != (unsigned long )((void *)0)) {
    {
#line 81
    tmp = GetIPv4ByName(server_name, & server_ip);
#line 81
    check = tmp;
    }
#line 82
    if (check) {
      {
#line 84
      tmp___0 = gai_strerror(check);
#line 84
      tmp___1 = dgettext("miredo", "Invalid server hostname \"%s\": %s");
#line 84
      syslog(1, (char const   *)tmp___1, server_name, tmp___0);
      }
#line 86
      return (-2);
    }
  } else {
    {
#line 91
    tmp___3 = miredo_conf_parse_IPv4(conf, "ServerBindAddress", & server_ip);
    }
#line 91
    if (tmp___3) {
      {
#line 91
      tmp___4 = miredo_conf_parse_IPv4(conf, "ServerBindAddress2", & server_ip2);
      }
#line 91
      if (! tmp___4) {
        {
#line 94
        tmp___2 = dgettext("miredo", "Fatal configuration error");
#line 94
        syslog(1, (char const   *)tmp___2);
        }
#line 95
        return (-2);
      }
    } else {
      {
#line 94
      tmp___2 = dgettext("miredo", "Fatal configuration error");
#line 94
      syslog(1, (char const   *)tmp___2);
      }
#line 95
      return (-2);
    }
  }
#line 99
  if (server_ip == 0U) {
    {
#line 101
    tmp___5 = dgettext("miredo", "Server address not specified");
#line 101
    syslog(1, (char const   *)tmp___5);
#line 102
    tmp___6 = dgettext("miredo", "Fatal configuration error");
#line 102
    syslog(1, (char const   *)tmp___6);
    }
#line 103
    return (-2);
  }
#line 113
  if (server_ip2 == 0U) {
    {
#line 114
    tmp___7 = ntohl(server_ip);
#line 114
    server_ip2 = htonl(tmp___7 + 1U);
    }
  }
  {
#line 116
  tmp___9 = miredo_conf_parse_teredo_prefix(conf, "Prefix", & prefix.teredo.prefix);
  }
#line 116
  if (tmp___9) {
    {
#line 116
    tmp___10 = miredo_conf_get_int16(conf, "InterfaceMTU", & mtu, (unsigned int *)((void *)0));
    }
#line 116
    if (! tmp___10) {
      {
#line 120
      tmp___8 = dgettext("miredo", "Fatal configuration error");
#line 120
      syslog(1, (char const   *)tmp___8);
      }
#line 121
      return (-2);
    }
  } else {
    {
#line 120
    tmp___8 = dgettext("miredo", "Fatal configuration error");
#line 120
    syslog(1, (char const   *)tmp___8);
    }
#line 121
    return (-2);
  }
  {
#line 124
  miredo_conf_clear(conf, 5);
#line 127
  server = teredo_server_create(server_ip, server_ip2);
#line 129
  tmp___11 = drop_privileges();
  }
#line 129
  if (tmp___11) {
#line 130
    return (-1);
  }
#line 132
  if ((unsigned long )server != (unsigned long )((void *)0)) {
    {
#line 134
    tmp___13 = teredo_server_set_prefix(server, prefix.teredo.prefix);
    }
#line 134
    if (tmp___13 == 0) {
      {
#line 134
      tmp___14 = teredo_server_set_MTU(server, mtu);
      }
#line 134
      if (tmp___14 == 0) {
        {
#line 134
        tmp___15 = teredo_server_start(server);
        }
#line 134
        if (tmp___15 == 0) {
          {
#line 142
          sigemptyset(& dummyset);
#line 143
          pthread_sigmask(0, (__sigset_t const   */* __restrict  */)(& dummyset),
                          (__sigset_t */* __restrict  */)(& set));
          }
          {
#line 146
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 146
            tmp___12 = sigwait((sigset_t const   */* __restrict  */)(& set), (int */* __restrict  */)(& dummy));
            }
#line 146
            if (! (tmp___12 != 0)) {
#line 146
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 148
          teredo_server_stop(server);
#line 149
          teredo_server_destroy(server);
          }
#line 152
          return (0);
        }
      }
    }
    {
#line 154
    teredo_server_destroy(server);
    }
  }
  {
#line 157
  tmp___16 = dgettext("miredo", "Teredo server fatal error");
#line 157
  syslog(1, (char const   *)tmp___16);
#line 158
  tmp___17 = dgettext("miredo", "Make sure another instance of the program is not already running.");
#line 158
  syslog(5, (char const   *)tmp___17);
  }
#line 160
  return (-1);
}
}
#line 63 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static int quick_usage___0(char const   *path___0 ) 
{ 
  char *tmp ;

  {
  {
#line 66
  tmp = dgettext("miredo", "Try \"%s -h | more\" for more information.\n");
#line 66
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, path___0);
  }
#line 68
  return (2);
}
}
#line 72 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static int usage___1(char const   *path___0 ) 
{ 
  char *tmp ;

  {
  {
#line 75
  tmp = dgettext("miredo", "Usage: %s [OPTIONS] [SERVER_NAME]\nCreates a Teredo tunneling interface for encapsulation of IPv6 over UDP.\n\n  -c, --config     specify an configuration file\n  -f, --foreground run in the foreground\n  -h, --help       display this help and exit\n  -p, --pidfile    override the location of the PID file\n  -u, --user       override the user to set UID to\n  -V, --version    display program version and exit\n");
#line 75
  printf((char const   */* __restrict  */)tmp, path___0);
  }
#line 85
  return (0);
}
}
#line 110 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static int error_dup___0(int opt , char const   *already , char const   *additionnal ) 
{ 
  char *tmp ;

  {
  {
#line 113
  tmp = dgettext("miredo", "Duplicate parameter \"%s\" for option -%c\nwould override previous value \"%s\".\n");
#line 113
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, additionnal,
          opt, already);
  }
#line 117
  return (2);
}
}
#line 132 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static int error_extra___0(char const   *extra ) 
{ 
  char *tmp ;

  {
  {
#line 135
  tmp = dgettext("miredo", "%s: unexpected extra parameter\n");
#line 135
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, extra);
  }
#line 136
  return (2);
}
}
#line 140 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static int error_errno___0(char const   *str ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 143
  tmp = __errno_location();
#line 143
  tmp___0 = strerror(*tmp);
#line 143
  tmp___1 = dgettext("miredo", "Error (%s): %s\n");
#line 143
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
          str, tmp___0);
  }
#line 144
  return (-1);
}
}
#line 154 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static int create_pidfile___0(char const   *path___0 ) 
{ 
  int fd ;
  char buf[20] ;
  struct stat s ;
  __pid_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  ssize_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 159
  fd = open(path___0, 131137, 420);
  }
#line 160
  if (fd != -1) {
    {
#line 165
    tmp = getpid();
#line 165
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d",
             tmp);
#line 166
    buf[sizeof(buf) - 1UL] = (char )'\000';
#line 168
    tmp___0 = fcntl(fd, 1);
#line 168
    fcntl(fd, 2, tmp___0 | 1);
#line 169
    tmp___1 = __errno_location();
#line 169
    *tmp___1 = 0;
#line 172
    tmp___2 = fstat(fd, & s);
    }
#line 172
    if (tmp___2 == 0) {
#line 172
      if ((s.st_mode & 61440U) == 32768U) {
        {
#line 172
        tmp___3 = lockf(fd, 2, (__off_t )0);
        }
#line 172
        if (tmp___3 == 0) {
          {
#line 172
          tmp___4 = ftruncate(fd, (__off_t )0);
          }
#line 172
          if (tmp___4 == 0) {
            {
#line 172
            tmp___5 = strlen((char const   *)(buf));
#line 172
            tmp___6 = write(fd, (void const   *)(buf), tmp___5);
#line 172
            tmp___7 = strlen((char const   *)(buf));
            }
#line 172
            if (tmp___6 == (ssize_t )tmp___7) {
              {
#line 172
              tmp___8 = fdatasync(fd);
              }
#line 172
              if (tmp___8 == 0) {
#line 178
                return (fd);
              }
            }
          }
        }
      }
    }
    {
#line 180
    tmp___10 = __errno_location();
    }
#line 180
    if (*tmp___10 == 0) {
      {
#line 181
      tmp___9 = __errno_location();
#line 181
      *tmp___9 = 13;
      }
    }
    {
#line 183
    close(fd);
    }
  }
#line 186
  return (-1);
}
}
#line 191 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static void setuid_notice___0(void) 
{ 
  char *tmp ;

  {
  {
#line 194
  tmp = dgettext("miredo", "That is usually an indication that you are trying to start\nthe program as an user with insufficient system privileges.\nThis program should normally be started by root.\n");
#line 194
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
  }
#line 198
  return;
}
}
#line 205 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static int init_security___0(char const   *username ) 
{ 
  int val ;
  int tmp ;
  int *tmp___0 ;
  struct passwd *pw ;
  struct passwd *tmp___1 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 210
  umask((__mode_t )18);
#line 211
  tmp = chdir("/");
  }
#line 211
  if (tmp) {
#line 212
    return (-1);
  }
  {
#line 221
  closefrom(3);
#line 226
  val = dup(2);
  }
#line 227
  if (val != 3) {
#line 228
    return (-1);
  }
  {
#line 229
  close(val);
#line 232
  clearenv();
#line 236
  tmp___0 = __errno_location();
#line 236
  *tmp___0 = 0;
#line 237
  tmp___1 = getpwnam(username);
#line 237
  pw = tmp___1;
  }
#line 238
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    {
#line 240
    tmp___7 = __errno_location();
    }
#line 240
    if (*tmp___7) {
      {
#line 240
      tmp___3 = __errno_location();
#line 240
      tmp___4 = strerror(*tmp___3);
#line 240
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 240
      tmp___5 = dgettext("miredo", "User not found");
#line 240
      tmp___6 = tmp___5;
      }
    }
    {
#line 240
    tmp___8 = dgettext("miredo", "User \"%s\": %s\n");
#line 240
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
            username, tmp___6);
    }
#line 242
    return (-1);
  }
#line 245
  if (pw->pw_uid == 0U) {
    {
#line 247
    tmp___9 = dgettext("miredo", "Error: This program is not supposed to keep root\nprivileges. That is potentially very dangerous\n(all the more as it has never been externally audited).\n");
#line 247
    fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)stderr);
    }
#line 251
    return (-1);
  }
  {
#line 253
  unpriv_uid = pw->pw_uid;
#line 256
  tmp___13 = seteuid((__uid_t )0);
  }
#line 256
  if (tmp___13) {
#line 256
    goto _L;
  } else {
    {
#line 256
    tmp___14 = setgid(pw->pw_gid);
    }
#line 256
    if (tmp___14) {
#line 256
      goto _L;
    } else {
      {
#line 256
      tmp___15 = initgroups(username, pw->pw_gid);
      }
#line 256
      if (tmp___15) {
        _L: /* CIL Label */ 
        {
#line 261
        tmp___10 = __errno_location();
#line 261
        tmp___11 = strerror(*tmp___10);
#line 261
        tmp___12 = dgettext("miredo", "SetUID to root: %s\n");
#line 261
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
                tmp___11);
#line 262
        setuid_notice___0();
        }
#line 263
        return (-1);
      }
    }
  }
#line 308
  return (0);
}
}
#line 312 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static void init_locale___0(void) 
{ 
  char *path___0 ;
  char *tmp ;

  {
  {
#line 314
  Pryt4897810065911_br_init((BrInitError *)((void *)0));
#line 315
  setlocale(6, "");
#line 316
  tmp = Pryt4897810065911_br_find_locale_dir("/usr/local/share/locale");
#line 316
  path___0 = tmp;
#line 317
  bindtextdomain("miredo", (char const   *)path___0);
#line 318
  free((void *)path___0);
#line 319
  textdomain("miredo");
  }
#line 320
  return;
}
}
#line 332 "/home/wheatley/newnew/temp/miredo-1.2.6/src/main.c"
static struct option  const  opts___1[11]  = 
#line 332
  {      {"conf", 1, (int *)((void *)0), 'c'}, 
        {"config", 1, (int *)((void *)0), 'c'}, 
        {"foreground", 0, (int *)((void *)0), 'f'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"pidfile", 1, (int *)((void *)0), 'p'}, 
        {"chroot", 1, (int *)((void *)0), 't'}, 
        {"chrootdir", 1, (int *)((void *)0), 't'}, 
        {"user", 1, (int *)((void *)0), 'u'}, 
        {"username", 1, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 96 "/home/wheatley/newnew/temp/miredo-1.2.6/src/miredo.c"
static void logger___1(void *dummy , _Bool error , char const   *fmt , va_list ap ) 
{ 
  int tmp ;

  {
#line 100
  if (error) {
#line 100
    tmp = 3;
  } else {
#line 100
    tmp = 4;
  }
  {
#line 100
  vsyslog(tmp, fmt, ap);
  }
#line 101
  return;
}
}
#line 42 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
static char *_br_find_exe___0(BrInitError *error ) 
{ 


  {
#line 46
  if (error) {
#line 47
    *error = (BrInitError )4;
  }
#line 48
  return ((char *)((void *)0));
}
}
#line 181 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
static char *_br_find_exe_for_symbol___0(void const   *symbol , BrInitError *error ) 
{ 


  {
#line 186
  if (error) {
#line 187
    *error = (BrInitError )4;
  }
#line 188
  return ((char *)((void *)0));
}
}
#line 292 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
static char *exe___0  =    (char *)((void *)0);
#line 711 "/home/wheatley/newnew/temp/miredo-1.2.6/src/binreloc.c"
static char *br_strndup___0(char const   *str , size_t size ) 
{ 
  char *result ;
  size_t len ;
  char *tmp ;
  void *tmp___0 ;

  {
#line 714
  result = (char *)((void *)0);
#line 717
  if ((unsigned long )str == (unsigned long )((char const   *)((void *)0))) {
#line 718
    return ((char *)((void *)0));
  }
  {
#line 720
  len = strlen(str);
  }
#line 721
  if (len == 0UL) {
    {
#line 722
    tmp = strdup("");
    }
#line 722
    return (tmp);
  }
#line 723
  if (size > len) {
#line 724
    size = len;
  }
  {
#line 726
  tmp___0 = malloc(len + 1UL);
#line 726
  result = (char *)tmp___0;
#line 727
  memcpy((void */* __restrict  */)result, (void const   */* __restrict  */)str, size);
#line 728
  *(result + size) = (char )'\000';
  }
#line 729
  return (result);
}
}
#line 86 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
static void ( /* format attribute */  LogError___0)(miredo_conf *conf , char const   *fmt 
                                                    , ...) 
{ 
  va_list ap ;

  {
#line 93
  if (! ((unsigned long )conf != (unsigned long )((void *)0))) {
    {
#line 93
    __assert_fail("conf != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  93U, "LogError");
    }
  }
#line 94
  if (! ((unsigned long )fmt != (unsigned long )((void *)0))) {
    {
#line 94
    __assert_fail("fmt != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  94U, "LogError");
    }
  }
#line 96
  if ((unsigned long )conf->logger == (unsigned long )((void *)0)) {
#line 97
    return;
  }
  {
#line 101
  __builtin_va_start(ap, fmt);
#line 102
  (*(conf->logger))(conf->logger_data, (_Bool)1, fmt, ap);
#line 103
  __builtin_va_end(ap);
  }
#line 104
  return;
}
}
#line 107 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
static void ( /* format attribute */  LogWarning___0)(miredo_conf *conf , char const   *fmt 
                                                      , ...) 
{ 
  va_list ap ;

  {
#line 113
  if (! ((unsigned long )conf != (unsigned long )((void *)0))) {
    {
#line 113
    __assert_fail("conf != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  113U, "LogWarning");
    }
  }
#line 114
  if (! ((unsigned long )fmt != (unsigned long )((void *)0))) {
    {
#line 114
    __assert_fail("fmt != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  114U, "LogWarning");
    }
  }
#line 116
  if ((unsigned long )conf->logger == (unsigned long )((void *)0)) {
#line 117
    return;
  }
  {
#line 121
  __builtin_va_start(ap, fmt);
#line 122
  (*(conf->logger))(conf->logger_data, (_Bool)0, fmt, ap);
#line 123
  __builtin_va_end(ap);
  }
#line 124
  return;
}
}
#line 156 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
static _Bool miredo_conf_set___0(miredo_conf *conf , char const   *name , char const   *value ,
                                 unsigned int line ) 
{ 
  struct setting *parm ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 160
  if (! ((unsigned long )conf != (unsigned long )((void *)0))) {
    {
#line 160
    __assert_fail("conf != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  160U, "miredo_conf_set");
    }
  }
#line 161
  if (! ((unsigned long )name != (unsigned long )((void *)0))) {
    {
#line 161
    __assert_fail("name != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  161U, "miredo_conf_set");
    }
  }
#line 162
  if (! ((unsigned long )value != (unsigned long )((void *)0))) {
    {
#line 162
    __assert_fail("value != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                  162U, "miredo_conf_set");
    }
  }
  {
#line 164
  tmp = malloc(sizeof(struct setting ));
#line 164
  parm = (struct setting *)tmp;
  }
#line 167
  if ((unsigned long )parm != (unsigned long )((void *)0)) {
    {
#line 169
    parm->name = strdup(name);
    }
#line 170
    if ((unsigned long )parm->name != (unsigned long )((void *)0)) {
      {
#line 172
      parm->value = strdup(value);
      }
#line 173
      if ((unsigned long )parm->value != (unsigned long )((void *)0)) {
#line 175
        parm->line = line;
#line 176
        parm->next = (struct setting *)((void *)0);
#line 179
        if ((unsigned long )conf->head == (unsigned long )((void *)0)) {
#line 180
          conf->head = parm;
        } else {
#line 183
          if (! ((unsigned long )conf->tail != (unsigned long )((void *)0))) {
            {
#line 183
            __assert_fail("conf->tail != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c",
                          183U, "miredo_conf_set");
            }
          }
#line 184
          (conf->tail)->next = parm;
        }
#line 186
        conf->tail = parm;
#line 189
        return ((_Bool)1);
      }
      {
#line 191
      free((void *)parm->name);
      }
    }
    {
#line 193
    free((void *)parm);
    }
  }
  {
#line 196
  tmp___0 = __errno_location();
#line 196
  tmp___1 = strerror(*tmp___0);
#line 196
  tmp___2 = dgettext("miredo", "Error (%s): %s");
#line 196
  LogError___0(conf, (char const   *)tmp___2, "strdup", tmp___1);
  }
#line 197
  return ((_Bool)0);
}
}
#line 233 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
static _Bool miredo_conf_read_FILE___0(miredo_conf *conf , FILE *stream ) 
{ 
  char lbuf[1056] ;
  unsigned int line ;
  size_t len ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char nbuf[32] ;
  char vbuf[1024] ;
  int tmp___4 ;
  _Bool tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 236
  line = 0U;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 238
    tmp___7 = fgets((char */* __restrict  */)(lbuf), (int )sizeof(lbuf), (FILE */* __restrict  */)stream);
    }
#line 238
    if (! ((unsigned long )tmp___7 != (unsigned long )((void *)0))) {
#line 238
      goto while_break;
    }
    {
#line 240
    tmp = strlen((char const   *)(lbuf));
#line 240
    len = tmp - 1UL;
#line 241
    line ++;
    }
#line 243
    if ((int )lbuf[len] != 10) {
      {
#line 245
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 245
        tmp___2 = fgetc(stream);
        }
#line 245
        if (! (tmp___2 != 10)) {
#line 245
          goto while_break___0;
        }
        {
#line 246
        tmp___0 = feof(stream);
        }
#line 246
        if (tmp___0) {
#line 247
          goto while_break___0;
        } else {
          {
#line 246
          tmp___1 = ferror(stream);
          }
#line 246
          if (tmp___1) {
#line 247
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 249
      tmp___3 = dgettext("miredo", "Skipped overly long line %u");
#line 249
      LogWarning___0(conf, (char const   *)tmp___3, line);
      }
#line 250
      goto while_continue;
    }
    {
#line 253
    lbuf[len] = (char )'\000';
#line 256
    tmp___4 = sscanf((char const   */* __restrict  */)(lbuf), (char const   */* __restrict  */)" %31s %1023s",
                     nbuf, vbuf);
    }
    {
#line 258
    if (tmp___4 == 2) {
#line 258
      goto case_2;
    }
#line 264
    if (tmp___4 == 1) {
#line 264
      goto case_1;
    }
#line 256
    goto switch_break;
    case_2: /* CIL Label */ 
#line 259
    if ((int )nbuf[0] != 35) {
      {
#line 259
      tmp___5 = miredo_conf_set___0(conf, (char const   *)(nbuf), (char const   *)(vbuf),
                                    line);
      }
#line 259
      if (! tmp___5) {
#line 261
        return ((_Bool)0);
      }
    }
#line 262
    goto switch_break;
    case_1: /* CIL Label */ 
#line 265
    if ((int )nbuf[0] != 35) {
      {
#line 266
      tmp___6 = dgettext("miredo", "Ignoring line %u: %s");
#line 266
      LogWarning___0(conf, (char const   *)tmp___6, line, nbuf);
      }
    }
#line 268
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  tmp___11 = ferror(stream);
  }
#line 272
  if (tmp___11) {
    {
#line 274
    tmp___8 = __errno_location();
#line 274
    tmp___9 = strerror(*tmp___8);
#line 274
    tmp___10 = dgettext("miredo", "Error reading configuration file: %s");
#line 274
    LogError___0(conf, (char const   *)tmp___10, tmp___9);
    }
#line 276
    return ((_Bool)0);
  }
#line 278
  return ((_Bool)1);
}
}
#line 494 "/home/wheatley/newnew/temp/miredo-1.2.6/src/conf.c"
static struct miredo_conf_syslog_facility  const  facilities___0[21]  = 
#line 494
  {      {"auth", 4 << 3}, 
        {"authpriv", 10 << 3}, 
        {"cron", 9 << 3}, 
        {"daemon", 3 << 3}, 
        {"ftp", 11 << 3}, 
        {"kern", 0}, 
        {"local0", 16 << 3}, 
        {"local1", 17 << 3}, 
        {"local2", 18 << 3}, 
        {"local3", 19 << 3}, 
        {"local4", 20 << 3}, 
        {"local5", 21 << 3}, 
        {"local6", 22 << 3}, 
        {"local7", 23 << 3}, 
        {"lpr", 6 << 3}, 
        {"mail", 2 << 3}, 
        {"news", 7 << 3}, 
        {"syslog", 5 << 3}, 
        {"user", 1 << 3}, 
        {"uucp", 8 << 3}, 
        {(char const   *)((void *)0), 0}};
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 39 "/home/wheatley/newnew/temp/miredo-1.2.6/compat/closefrom.c"
extern int closefrom(int fd ) 
{ 
  struct rlimit lim ;
  unsigned int found ;
  int saved_errno ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 42
  found = 0U;
#line 45
  tmp = getrlimit((__rlimit_resource_t )7, & lim);
  }
#line 45
  if (tmp) {
#line 46
    return (-1);
  }
  {
#line 48
  tmp___0 = __errno_location();
#line 48
  saved_errno = *tmp___0;
  }
#line 68
  if (lim.rlim_max > 1024UL) {
#line 70
    if (lim.rlim_cur > 1024UL) {
#line 71
      lim.rlim_cur = (rlim_t )1024;
    }
    {
#line 72
    lim.rlim_max = (rlim_t )1024;
#line 73
    setrlimit((__rlimit_resource_t )7, (struct rlimit  const  *)(& lim));
    }
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((rlim_t )((unsigned int )fd) < lim.rlim_max)) {
#line 76
      goto while_break;
    }
    {
#line 77
    tmp___1 = fd;
#line 77
    fd ++;
#line 77
    tmp___2 = close(tmp___1);
    }
#line 77
    if (tmp___2 == 0) {
#line 78
      found ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  if (found == 0U) {
    {
#line 82
    tmp___3 = __errno_location();
#line 82
    *tmp___3 = 9;
    }
#line 83
    return (-1);
  }
  {
#line 85
  tmp___4 = __errno_location();
#line 85
  *tmp___4 = saved_errno;
  }
#line 86
  return (0);
}
}
#line 339 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_getres)(clockid_t __clock_id ,
                                                                                   struct timespec *__res ) ;
#line 342
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 363
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) timer_create)(clockid_t __clock_id ,
                                                                                   struct sigevent * __restrict  __evp ,
                                                                                   timer_t * __restrict  __timerid ) ;
#line 371
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) timer_settime)(timer_t __timerid ,
                                                                                    int __flags ,
                                                                                    struct itimerspec  const  * __restrict  __value ,
                                                                                    struct itimerspec * __restrict  __ovalue ) ;
#line 380
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) timer_getoverrun)(timer_t __timerid ) ;
#line 46 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.h"
unsigned long teredo_clock(void) ;
#line 49 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
static void clock_tick(union sigval val ) 
{ 
  clock_data_t *context ;
  int orun ;
  int tmp ;
  struct itimerspec it ;

  {
  {
#line 51
  context = (clock_data_t *)val.sival_ptr;
#line 53
  tmp = timer_getoverrun(context->handle);
#line 53
  orun = tmp;
#line 54
  context->value += (teredo_clock_t )(1 + orun);
  }
#line 57
  if (orun == 2147483647) {
#line 59
    context->active = (_Bool)0;
  }
#line 62
  if (! context->active) {
    {
#line 64
    it.it_interval.tv_sec = 0L;
#line 64
    it.it_interval.tv_nsec = 0L;
#line 64
    it.it_value.tv_sec = (__time_t )0;
#line 64
    it.it_value.tv_nsec = (__syscall_slong_t )0;
#line 68
    timer_settime(context->handle, 0, (struct itimerspec  const  */* __restrict  */)(& it),
                  (struct itimerspec */* __restrict  */)((void *)0));
    }
  }
#line 71
  context->active = (_Bool)0;
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
static clock_data_t clk  =    {(void *)0, (teredo_clock_t )0, (_Bool)0};
#line 82 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
static struct __anonstruct_priv_55 priv  =    {{{0, 0U, 0, 0U, 2, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}},
    0, (_Bool)0};
#line 75 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
unsigned long teredo_clock(void) 
{ 
  teredo_clock_t value ;
  struct sigevent ev ;
  struct timespec res ;
  int tmp ;
  int tmp___0 ;
  struct itimerspec it ;

  {
  {
#line 91
  d_pthread_mutex_lock(& priv.lock);
  }
#line 92
  if (! priv.present) {
    {
#line 96
    memset((void *)(& ev), 0, sizeof(ev));
#line 97
    ev.sigev_notify = 2;
#line 98
    ev.sigev_value.sival_ptr = (void *)(& clk);
#line 99
    ev._sigev_un._sigev_thread._function = & clock_tick;
#line 104
    tmp = clock_getres(1, & res);
    }
#line 104
    if (tmp == 0) {
#line 105
      priv.id = 1;
    }
    {
#line 108
    tmp___0 = timer_create(priv.id, (struct sigevent */* __restrict  */)(& ev), (timer_t */* __restrict  */)(& clk.handle));
    }
#line 108
    if (tmp___0 == 0) {
#line 109
      priv.present = (_Bool)1;
    }
  }
#line 112
  if (! clk.active) {
    {
#line 116
    clock_gettime(priv.id, & it.it_value);
#line 117
    clk.value = (teredo_clock_t )it.it_value.tv_sec;
    }
#line 119
    if (priv.present) {
      {
#line 121
      (it.it_value.tv_sec) ++;
#line 122
      it.it_value.tv_nsec = (__syscall_slong_t )0;
#line 123
      it.it_interval.tv_sec = (__time_t )1;
#line 124
      it.it_interval.tv_nsec = (__syscall_slong_t )0;
#line 126
      clk.active = (_Bool)1;
#line 127
      timer_settime(clk.handle, 1, (struct itimerspec  const  */* __restrict  */)(& it),
                    (struct itimerspec */* __restrict  */)((void *)0));
      }
    }
  }
  {
#line 131
  value = clk.value;
#line 132
  d_pthread_mutex_unlock(& priv.lock);
  }
#line 134
  return (value);
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 353 "/usr/include/time.h"
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec  const  *__req ,
                           struct timespec *__rem ) ;
#line 63 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_yield)(void) ;
#line 517 "/usr/include/pthread.h"
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 760
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 765
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 817
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_init)(pthread_mutexattr_t *__attr ) ;
#line 821
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_destroy)(pthread_mutexattr_t *__attr ) ;
#line 844
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_settype)(pthread_mutexattr_t *__attr ,
                                                                                                                int __kind ) ;
#line 129 "/usr/include/search.h"
extern void *tsearch(void const   *__key , void **__rootp , int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 134
extern void *tfind(void const   *__key , void * const  *__rootp , int (*__compar)(void const   * ,
                                                                                  void const   * ) ) ;
#line 138
extern void *tdelete(void const   * __restrict  __key , void ** __restrict  __rootp ,
                     int (*__compar)(void const   * , void const   * ) ) ;
#line 158
extern void tdestroy(void *__root , void (*__freefct)(void *__nodep ) ) ;
#line 98 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo-udp.h"
int teredo_send(int fd , void const   *packet , size_t plen , uint32_t dest_ip , uint16_t dest_port ) ;
#line 49 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/debug.h"
__inline static int d_pthread_mutex_init(pthread_mutex_t *mutex___3 , pthread_mutexattr_t *pattr ) 
{ 
  pthread_mutexattr_t attr ;
  int res ;
  int tmp ;

  {
#line 54
  if ((unsigned long )pattr == (unsigned long )((void *)0)) {
    {
#line 56
    pattr = & attr;
#line 57
    pthread_mutexattr_init(& attr);
    }
  }
  {
#line 60
  pthread_mutexattr_settype(pattr, 2);
#line 61
  tmp = pthread_mutex_init(mutex___3, (pthread_mutexattr_t const   *)pattr);
#line 61
  res = tmp;
  }
#line 63
  if ((unsigned long )pattr == (unsigned long )(& attr)) {
    {
#line 64
    pthread_mutexattr_destroy(& attr);
    }
  }
#line 65
  return (res);
}
}
#line 52 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.h"
void teredo_enqueue_in(teredo_peer * __restrict  peer , void const   * __restrict  data ,
                       size_t len , uint32_t ip , uint16_t port ) ;
#line 55
void teredo_enqueue_out(teredo_peer * __restrict  peer , void const   * __restrict  data ,
                        size_t len ) ;
#line 57
teredo_queue *teredo_peer_queue_yield(teredo_peer *peer ) ;
#line 58
void teredo_queue_emit(teredo_queue *q , int fd , uint32_t ipv4 , uint16_t port ,
                       void (*cb)(void * , void const   * , size_t  ) , void *opaque ) ;
#line 106
teredo_peerlist *teredo_list_create(unsigned int max , unsigned int expiration ) ;
#line 113
void teredo_list_destroy(teredo_peerlist *l ) ;
#line 122
void teredo_list_reset(teredo_peerlist *l , unsigned int max ) ;
#line 141
teredo_peer *teredo_list_lookup(teredo_peerlist * __restrict  list , struct in6_addr  const  * __restrict  addr ,
                                _Bool * __restrict  create ) ;
#line 149
void teredo_list_release(teredo_peerlist *l ) ;
#line 67 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static unsigned int const   teredo_MaxQueueBytes  =    (unsigned int const   )1280;
#line 70 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
__inline static void teredo_peer_init(teredo_peer *peer ) 
{ 


  {
#line 72
  peer->queue = (teredo_queue *)((void *)0);
#line 73
  peer->queue_left = (size_t )teredo_MaxQueueBytes;
#line 74
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
__inline static void teredo_peer_destroy(teredo_peer *peer ) 
{ 
  teredo_queue *p ;
  teredo_queue *buf ;

  {
#line 79
  p = peer->queue;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 81
      goto while_break;
    }
    {
#line 85
    buf = p->next;
#line 86
    free((void *)p);
#line 87
    p = buf;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void teredo_peer_queue(teredo_peer * __restrict  peer , void const   * __restrict  data ,
                              size_t len , uint32_t ip , uint16_t port , _Bool incoming ) 
{ 
  teredo_queue *p ;
  void *tmp ;

  {
#line 98
  if (len > peer->queue_left) {
#line 99
    return;
  }
  {
#line 100
  peer->queue_left -= len;
#line 102
  tmp = malloc(sizeof(*p) + len);
#line 102
  p = (teredo_queue *)tmp;
#line 103
  p->length = len;
#line 104
  memcpy((void */* __restrict  */)(p->data), data, len);
#line 105
  p->ipv4 = ip;
#line 106
  p->port = port;
#line 107
  p->incoming = incoming;
#line 109
  p->next = peer->queue;
#line 110
  peer->queue = p;
  }
#line 111
  return;
}
}
#line 114 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
void teredo_enqueue_in(teredo_peer * __restrict  peer , void const   * __restrict  data ,
                       size_t len , uint32_t ip , uint16_t port ) 
{ 


  {
  {
#line 117
  teredo_peer_queue(peer, data, len, ip, port, (_Bool)1);
  }
#line 118
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
void teredo_enqueue_out(teredo_peer * __restrict  peer , void const   * __restrict  data ,
                        size_t len ) 
{ 


  {
  {
#line 124
  teredo_peer_queue(peer, data, len, (uint32_t )0, (uint16_t )0, (_Bool)0);
  }
#line 125
  return;
}
}
#line 128 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
teredo_queue *teredo_peer_queue_yield(teredo_peer *peer ) 
{ 
  teredo_queue *q ;

  {
#line 130
  q = peer->queue;
#line 131
  peer->queue = (teredo_queue *)((void *)0);
#line 132
  peer->queue_left = (size_t )teredo_MaxQueueBytes;
#line 133
  return (q);
}
}
#line 137 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
void teredo_queue_emit(teredo_queue *q , int fd , uint32_t ipv4 , uint16_t port ,
                       void (*cb)(void * , void const   * , size_t  ) , void *opaque ) 
{ 
  teredo_queue *buf ;

  {
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 140
      goto while_break;
    }
#line 144
    buf = q->next;
#line 145
    if (q->incoming) {
#line 147
      if (ipv4 == q->ipv4) {
#line 147
        if ((int )port == (int )q->port) {
          {
#line 148
          (*cb)(opaque, (void const   *)(q->data), q->length);
          }
        }
      }
    } else {
      {
#line 151
      teredo_send(fd, (void const   *)(q->data), q->length, ipv4, port);
      }
    }
    {
#line 152
    free((void *)q);
#line 153
    q = buf;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  return;
}
}
#line 181 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
__inline static teredo_listitem *listitem_create(void) 
{ 
  teredo_listitem *entry ;
  void *tmp ;

  {
  {
#line 183
  tmp = malloc(sizeof(*entry));
#line 183
  entry = (teredo_listitem *)tmp;
  }
#line 184
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
    {
#line 185
    teredo_peer_init(& entry->peer);
    }
  }
#line 186
  return (entry);
}
}
#line 190 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
__inline static void listitem_destroy(teredo_listitem *entry ) 
{ 


  {
  {
#line 192
  teredo_peer_destroy(& entry->peer);
#line 193
  free((void *)entry);
  }
#line 194
  return;
}
}
#line 197 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void listitem_recdestroy(teredo_listitem *entry ) 
{ 
  teredo_listitem *buf ;

  {
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 199
      goto while_break;
    }
    {
#line 201
    buf = entry->next;
#line 202
    listitem_destroy(entry);
#line 203
    entry = buf;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 208 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void listitem_free(void *p ) 
{ 


  {
#line 211
  return;
}
}
#line 213 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static int listitem_cmp(void const   *pa , void const   *pb ) 
{ 
  struct in6_addr  const  * const  *a ;
  struct in6_addr  const  * const  *b ;
  int tmp ;

  {
  {
#line 215
  a = (struct in6_addr  const  * const  *)pa;
#line 215
  b = (struct in6_addr  const  * const  *)pb;
#line 217
  tmp = memcmp((void const   *)a, (void const   *)b, sizeof(*(*a)));
  }
#line 217
  return (tmp);
}
}
#line 228
static  __attribute__((__noreturn__)) void *garbage_collector(void *data ) ;
#line 228 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void *garbage_collector(void *data ) 
{ 
  struct teredo_peerlist *l ;
  struct timespec delay ;
  int tmp ;
  int state ;
  teredo_listitem *p ;
  teredo_listitem **pp ;
  void *tmp___0 ;
  teredo_listitem *old ;

  {
#line 230
  l = (struct teredo_peerlist *)data;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    delay.tv_sec = (__time_t )l->expiration;
#line 234
    delay.tv_nsec = 0L;
    {
#line 235
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 235
      tmp = clock_nanosleep(0, 0, (struct timespec  const  *)(& delay), & delay);
      }
#line 235
      if (! tmp) {
#line 235
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 238
    pthread_setcancelstate(1, & state);
#line 240
    d_pthread_mutex_lock(& l->lock);
#line 243
    p = l->old;
    }
    {
#line 243
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 243
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 243
        goto while_break___1;
      }
      {
#line 253
      tmp___0 = tdelete((void const   */* __restrict  */)(& p->key.ip6), (void **/* __restrict  */)(& l->root),
                        & listitem_cmp);
#line 253
      pp = (teredo_listitem **)tmp___0;
      }
#line 254
      if (! ((unsigned long )pp != (unsigned long )((void *)0))) {
        {
#line 254
        __assert_fail("pp != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c",
                      254U, "garbage_collector");
        }
      }
#line 256
      (l->left) ++;
#line 243
      p = p->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 260
    old = l->old;
#line 263
    l->old = l->recent;
#line 264
    l->recent = (teredo_listitem *)((void *)0);
#line 265
    if ((unsigned long )l->old != (unsigned long )((void *)0)) {
#line 266
      (l->old)->pprev = & l->old;
    }
    {
#line 268
    d_pthread_mutex_unlock(& l->lock);
#line 271
    sched_yield();
#line 272
    listitem_recdestroy(old);
#line 275
    pthread_setcancelstate(state, (int *)((void *)0));
#line 276
    sched_yield();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 281 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
teredo_peerlist *teredo_list_create(unsigned int max , unsigned int expiration ) 
{ 
  teredo_peerlist *l ;
  void *tmp ;
  teredo_listitem *tmp___0 ;
  int tmp___1 ;

  {
#line 285
  if (! (expiration > 0U)) {
    {
#line 285
    __assert_fail("expiration > 0", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c",
                  285U, "teredo_list_create");
    }
  }
  {
#line 287
  tmp = malloc(sizeof(*l));
#line 287
  l = (teredo_peerlist *)tmp;
  }
#line 288
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 289
    return ((teredo_peerlist *)((void *)0));
  }
  {
#line 291
  memset((void *)l, 0, sizeof(l));
#line 292
  d_pthread_mutex_init(& l->lock, (pthread_mutexattr_t *)((void *)0));
#line 293
  tmp___0 = (teredo_listitem *)((void *)0);
#line 293
  l->old = tmp___0;
#line 293
  l->recent = tmp___0;
#line 294
  l->left = max;
#line 295
  l->expiration = expiration;
#line 299
  l->root = (void *)0;
#line 302
  tmp___1 = pthread_create((pthread_t */* __restrict  */)(& l->gc), (pthread_attr_t const   */* __restrict  */)((void *)0),
                           & garbage_collector, (void */* __restrict  */)l);
  }
#line 302
  if (tmp___1) {
    {
#line 304
    pthread_mutex_destroy(& l->lock);
#line 305
    free((void *)l);
    }
#line 306
    return ((teredo_peerlist *)((void *)0));
  }
#line 309
  return (l);
}
}
#line 313 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
void teredo_list_reset(teredo_peerlist *l , unsigned int max ) 
{ 
  void *root ;
  teredo_listitem *recent ;
  teredo_listitem *old ;
  teredo_listitem *tmp ;

  {
  {
#line 315
  d_pthread_mutex_lock(& l->lock);
#line 322
  root = l->root;
#line 323
  l->root = (void *)0;
#line 326
  recent = l->recent;
#line 326
  old = l->old;
#line 328
  tmp = (teredo_listitem *)((void *)0);
#line 328
  l->old = tmp;
#line 328
  l->recent = tmp;
#line 329
  l->left = max;
#line 331
  d_pthread_mutex_unlock(& l->lock);
#line 334
  listitem_recdestroy(old);
#line 335
  listitem_recdestroy(recent);
#line 342
  tdestroy(root, & listitem_free);
  }
#line 344
  return;
}
}
#line 347 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
void teredo_list_destroy(teredo_peerlist *l ) 
{ 


  {
  {
#line 349
  teredo_list_reset(l, 0U);
#line 351
  pthread_cancel(l->gc);
#line 352
  pthread_join(l->gc, (void **)((void *)0));
#line 353
  pthread_mutex_destroy(& l->lock);
#line 355
  free((void *)l);
  }
#line 356
  return;
}
}
#line 359 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
teredo_peer *teredo_list_lookup(teredo_peerlist * __restrict  list , struct in6_addr  const  * __restrict  addr ,
                                _Bool * __restrict  create ) 
{ 
  teredo_listitem *p ;
  void **pp ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 365
  d_pthread_mutex_lock(& list->lock);
  }
#line 393
  if ((unsigned long )create != (unsigned long )((void *)0)) {
    {
#line 395
    tmp = tsearch((void const   *)addr, & list->root, & listitem_cmp);
#line 395
    pp = (void **)tmp;
    }
#line 396
    if ((unsigned long )pp == (unsigned long )((void *)0)) {
#line 397
      goto error;
    }
#line 398
    if ((unsigned long )*pp != (unsigned long )addr) {
#line 398
      p = (teredo_listitem *)*pp;
    } else {
#line 398
      p = (teredo_listitem *)((void *)0);
    }
  } else {
    {
#line 402
    tmp___0 = tfind((void const   *)addr, (void * const  *)(& list->root), & listitem_cmp);
#line 402
    pp = (void **)tmp___0;
    }
#line 403
    if ((unsigned long )pp != (unsigned long )((void *)0)) {
#line 403
      p = (teredo_listitem *)*pp;
    } else {
#line 403
      p = (teredo_listitem *)((void *)0);
    }
  }
#line 407
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 410
    if (! ((unsigned long )*(p->pprev) == (unsigned long )p)) {
      {
#line 410
      __assert_fail("*(p->pprev) == p", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c",
                    410U, "teredo_list_lookup");
      }
    }
#line 411
    if (! ((unsigned long )p->next == (unsigned long )((void *)0))) {
#line 411
      if (! ((unsigned long )(p->next)->pprev == (unsigned long )(& p->next))) {
        {
#line 411
        __assert_fail("(p->next == ((void *)0)) || (p->next->pprev == &p->next)",
                      "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c",
                      411U, "teredo_list_lookup");
        }
      }
    }
#line 413
    if ((unsigned long )create != (unsigned long )((void *)0)) {
#line 414
      *create = (_Bool)0;
    }
#line 417
    if ((unsigned long )list->recent != (unsigned long )p) {
#line 420
      if ((unsigned long )p->next != (unsigned long )((void *)0)) {
#line 421
        (p->next)->pprev = p->pprev;
      }
#line 422
      *(p->pprev) = p->next;
#line 425
      p->next = list->recent;
#line 426
      if ((unsigned long )p->next != (unsigned long )((void *)0)) {
#line 427
        (p->next)->pprev = & p->next;
      }
#line 429
      list->recent = p;
#line 430
      p->pprev = & list->recent;
#line 432
      if (! ((unsigned long )*(p->pprev) == (unsigned long )p)) {
        {
#line 432
        __assert_fail("*(p->pprev) == p", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c",
                      432U, "teredo_list_lookup");
        }
      }
#line 433
      if (! ((unsigned long )p->next == (unsigned long )((void *)0))) {
#line 433
        if (! ((unsigned long )(p->next)->pprev == (unsigned long )(& p->next))) {
          {
#line 433
          __assert_fail("(p->next == ((void *)0)) || (p->next->pprev == &p->next)",
                        "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c",
                        433U, "teredo_list_lookup");
          }
        }
      }
    }
#line 436
    return (& p->peer);
  }
#line 440
  if (! ((unsigned long )p == (unsigned long )((void *)0))) {
    {
#line 440
    __assert_fail("p == ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c",
                  440U, "teredo_list_lookup");
    }
  }
#line 441
  if ((unsigned long )create == (unsigned long )((void *)0)) {
#line 442
    goto error;
  }
#line 443
  *create = (_Bool)1;
#line 446
  if (list->left > 0U) {
    {
#line 447
    p = listitem_create();
    }
  }
#line 449
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 455
    tdelete((void const   */* __restrict  */)addr, (void **/* __restrict  */)(& list->root),
            & listitem_cmp);
    }
#line 457
    goto error;
  }
#line 461
  p->next = list->recent;
#line 462
  if ((unsigned long )p->next != (unsigned long )((void *)0)) {
#line 463
    (p->next)->pprev = & p->next;
  }
#line 465
  p->pprev = & list->recent;
#line 466
  list->recent = p;
#line 467
  p->pprev = & list->recent;
#line 469
  (list->left) --;
#line 471
  if (! ((unsigned long )*(p->pprev) == (unsigned long )p)) {
    {
#line 471
    __assert_fail("*(p->pprev) == p", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c",
                  471U, "teredo_list_lookup");
    }
  }
#line 472
  if (! ((unsigned long )p->next == (unsigned long )((void *)0))) {
#line 472
    if (! ((unsigned long )(p->next)->pprev == (unsigned long )(& p->next))) {
      {
#line 472
      __assert_fail("(p->next == ((void *)0)) || (p->next->pprev == &p->next)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c",
                    472U, "teredo_list_lookup");
      }
    }
  }
#line 474
  *pp = (void *)p;
#line 475
  p->key.ip6 = (struct in6_addr )*addr;
#line 476
  return (& p->peer);
  error: 
  {
#line 479
  d_pthread_mutex_unlock(& list->lock);
  }
#line 480
  return ((teredo_peer *)((void *)0));
}
}
#line 484 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
void teredo_list_release(teredo_peerlist *l ) 
{ 


  {
  {
#line 486
  d_pthread_mutex_unlock(& l->lock);
  }
#line 487
  return;
}
}
#line 50 "../compat/fixups.h"
extern size_t strlcpy(char *tgt , char const   *src , size_t bufsize ) ;
#line 534 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 119 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socketpair)(int __domain ,
                                                                                 int __type ,
                                                                                 int __protocol ,
                                                                                 int *__fds ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 227 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_any ;
#line 66 "../libtun6/tun6.h"
int ( __attribute__((__nonnull__)) tun6_driver_diagnose)(char *errbuf ) ;
#line 75
tun6 *( __attribute__((__warn_unused_result__)) tun6_create)(char const   *req_name ) ;
#line 76
void ( __attribute__((__nonnull__)) tun6_destroy)(tun6 *t ) ;
#line 78
int ( __attribute__((__nonnull__)) tun6_getId)(tun6 const   *t ) ;
#line 80
int ( __attribute__((__nonnull__)) tun6_setState)(tun6 *t , _Bool up ) ;
#line 81 "../libtun6/tun6.h"
__inline static int tun6_bringUp(tun6 *t ) 
{ 
  int tmp ;

  {
  {
#line 83
  tmp = tun6_setState(t, (_Bool)1);
  }
#line 83
  return (tmp);
}
}
#line 91
int ( __attribute__((__nonnull__)) tun6_addAddress)(tun6 * __restrict  t , struct in6_addr  const  * __restrict  addr ,
                                                    unsigned int prefixlen ) ;
#line 96
int ( __attribute__((__nonnull__)) tun6_setMTU)(tun6 *t , unsigned int mtu ) ;
#line 98
int ( __attribute__((__nonnull__)) tun6_addRoute)(tun6 * __restrict  t , struct in6_addr  const  * __restrict  addr ,
                                                  unsigned int prefix_len , int rel_metric ) ;
#line 108
int ( __attribute__((__nonnull__)) tun6_wait_recv)(tun6 * __restrict  t , void *buffer ,
                                                   size_t maxlen ) ;
#line 109
int ( __attribute__((__nonnull__)) tun6_send)(tun6 * __restrict  t , void const   *packet ,
                                              size_t len ) ;
#line 44 "../libteredo/teredo.h"
struct in6_addr  const  teredo_restrict ;
#line 65 "../libteredo/tunnel.h"
int teredo_startup(_Bool use_client ) ;
#line 75
void teredo_cleanup(_Bool use_client ) ;
#line 103
teredo_tunnel *teredo_create(uint32_t ipv4 , uint16_t port ) ;
#line 117
void teredo_destroy(teredo_tunnel *t ) ;
#line 151
int teredo_run_async(teredo_tunnel *t ) ;
#line 166
int teredo_set_prefix(teredo_tunnel *t , uint32_t prefix ) ;
#line 181
int teredo_set_cone_flag(teredo_tunnel *t , _Bool cone ) ;
#line 192
int teredo_set_relay_mode(teredo_tunnel *t ) ;
#line 212
int teredo_set_client_mode(teredo_tunnel * __restrict  t , char const   *s , char const   *s2 ) ;
#line 224
void *teredo_set_privdata(teredo_tunnel *t , void *opaque ) ;
#line 252
void teredo_set_recv_callback(teredo_tunnel * __restrict  t , void (*cb)(void *opaque ,
                                                                         void const   *data ,
                                                                         size_t len ) ) ;
#line 272
int teredo_transmit(teredo_tunnel * __restrict  tunnel , struct ip6_hdr  const  * __restrict  packet ,
                    size_t length ) ;
#line 294
void teredo_set_icmpv6_callback(teredo_tunnel * __restrict  t , void (*cb)(void *opaque ,
                                                                           void const   *data ,
                                                                           size_t len ,
                                                                           struct in6_addr  const  *dst ) ) ;
#line 327
void teredo_set_state_cb(teredo_tunnel * __restrict  t , void (*u)(void *opaque ,
                                                                   struct in6_addr  const  *addr ,
                                                                   uint16_t mtu ) ,
                         void (*d)(void *opaque ) ) ;
#line 70 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static void miredo_setup_fd(int fd ) ;
#line 71
static void miredo_setup_nonblock_fd(int fd ) ;
#line 73 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static int relay_diagnose(void) 
{ 
  char errbuf[4096] ;
  int tmp ;

  {
  {
#line 76
  tmp = tun6_driver_diagnose(errbuf);
  }
#line 76
  if (tmp) {
    {
#line 78
    fputs((char const   */* __restrict  */)(errbuf), (FILE */* __restrict  */)stderr);
    }
#line 79
    return (-1);
  }
#line 82
  return (0);
}
}
#line 93 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static int icmp6_fd  =    -1;
#line 95 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static int miredo_init(_Bool client ) 
{ 
  int tmp ;
  int __constr_expr_8 ;
  struct icmp6_filter filt ;

  {
  {
#line 97
  tmp = teredo_startup(client);
  }
#line 97
  if (tmp) {
#line 98
    return (-1);
  }
#line 100
  if (! (icmp6_fd == -1)) {
    {
#line 100
    __assert_fail("icmp6_fd == -1", "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c",
                  100U, "miredo_init");
    }
  }
  {
#line 102
  icmp6_fd = socket(10, 3, 58);
  }
#line 103
  if (icmp6_fd == -1) {
#line 104
    return (-1);
  }
  {
#line 106
  miredo_setup_nonblock_fd(icmp6_fd);
#line 108
  __constr_expr_8 = 2;
#line 108
  setsockopt(icmp6_fd, 41, 7, (void const   *)(& __constr_expr_8), (socklen_t )sizeof(int ));
#line 112
  memset((void *)(& filt), 255, sizeof(struct icmp6_filter ));
#line 113
  setsockopt(icmp6_fd, 58, 1, (void const   *)(& filt), (socklen_t )sizeof(filt));
  }
#line 114
  return (0);
}
}
#line 118 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static void miredo_deinit(_Bool client ) 
{ 


  {
#line 120
  if (! (icmp6_fd != -1)) {
    {
#line 120
    __assert_fail("icmp6_fd != -1", "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c",
                  120U, "miredo_deinit");
    }
  }
  {
#line 121
  close(icmp6_fd);
#line 122
  teredo_cleanup(client);
  }
#line 123
  return;
}
}
#line 129 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static void miredo_recv_callback(void *data , void const   *packet , size_t length ) 
{ 


  {
#line 132
  if (! ((unsigned long )data != (unsigned long )((void *)0))) {
    {
#line 132
    __assert_fail("data != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c",
                  132U, "miredo_recv_callback");
    }
  }
  {
#line 134
  tun6_send((tun6 */* __restrict  */)((miredo_tunnel *)data)->tunnel, packet, length);
  }
#line 135
  return;
}
}
#line 141 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static void miredo_icmp6_callback(void *data , void const   *packet , size_t length ,
                                  struct in6_addr  const  *dst ) 
{ 
  struct sockaddr_in6 addr ;

  {
#line 146
  if (! (icmp6_fd != -1)) {
    {
#line 146
    __assert_fail("icmp6_fd != -1", "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c",
                  146U, "miredo_icmp6_callback");
    }
  }
  {
#line 148
  addr.sin6_family = (sa_family_t )10;
#line 148
  addr.sin6_port = (unsigned short)0;
#line 148
  addr.sin6_flowinfo = 0U;
#line 148
  addr.sin6_addr = *dst;
#line 148
  addr.sin6_scope_id = 0U;
#line 158
  sendto(icmp6_fd, packet, length, 0, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
         (socklen_t )sizeof(addr));
  }
#line 160
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static _Bool ParseRelayType(miredo_conf *conf , char const   *name , int *type ) 
{ 
  unsigned int line ;
  char *val ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 171
  tmp = miredo_conf_get(conf, name, & line);
#line 171
  val = tmp;
  }
#line 173
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 174
    return ((_Bool)1);
  }
  {
#line 176
  tmp___5 = strcasecmp((char const   *)val, "client");
  }
#line 176
  if (tmp___5 == 0) {
#line 178
    *type = 2;
  } else {
    {
#line 176
    tmp___6 = strcasecmp((char const   *)val, "autoclient");
    }
#line 176
    if (tmp___6 == 0) {
#line 178
      *type = 2;
    } else {
      {
#line 180
      tmp___4 = strcasecmp((char const   *)val, "restricted");
      }
#line 180
      if (tmp___4 == 0) {
        {
#line 182
        tmp___0 = dgettext("miredo", "Using deprecated \"restricted\" relay type which is STRONGLY DISCOURAGED (at line %u).");
#line 182
        syslog(4, (char const   *)tmp___0, line);
#line 184
        *type = 1;
        }
      } else {
        {
#line 187
        tmp___2 = strcasecmp((char const   *)val, "relay");
        }
#line 187
        if (tmp___2 == 0) {
#line 189
          *type = 0;
        } else {
          {
#line 187
          tmp___3 = strcasecmp((char const   *)val, "cone");
          }
#line 187
          if (tmp___3 == 0) {
#line 189
            *type = 0;
          } else {
            {
#line 192
            tmp___1 = dgettext("miredo", "Invalid relay type \"%s\" at line %u");
#line 192
            syslog(3, (char const   *)tmp___1, val, line);
#line 194
            free((void *)val);
            }
#line 195
            return ((_Bool)0);
          }
        }
      }
    }
  }
  {
#line 197
  free((void *)val);
  }
#line 198
  return ((_Bool)1);
}
}
#line 220
static tun6 *create_dynamic_tunnel(char const   *ifname , int *pfd ) ;
#line 220 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static char const   path[42]  = 
#line 220
  {      (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
        (char const   )'/',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'a',      (char const   )'l',      (char const   )'/',      (char const   )'l', 
        (char const   )'i',      (char const   )'b',      (char const   )'e',      (char const   )'x', 
        (char const   )'e',      (char const   )'c',      (char const   )'/',      (char const   )'m', 
        (char const   )'i',      (char const   )'r',      (char const   )'e',      (char const   )'d', 
        (char const   )'o',      (char const   )'/',      (char const   )'m',      (char const   )'i', 
        (char const   )'r',      (char const   )'e',      (char const   )'d',      (char const   )'o', 
        (char const   )'-',      (char const   )'p',      (char const   )'r',      (char const   )'i', 
        (char const   )'v',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'c',      (char const   )'\000'};
#line 203 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static tun6 *create_dynamic_tunnel(char const   *ifname , int *pfd ) 
{ 
  tun6 *tunnel ;
  tun6 *tmp ;
  int fd[2] ;
  int tmp___0 ;
  char ifindex[2UL * sizeof(unsigned int ) + 1UL] ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 206
  tmp = tun6_create(ifname);
#line 206
  tunnel = tmp;
  }
#line 207
  if ((unsigned long )tunnel == (unsigned long )((void *)0)) {
#line 208
    return ((tun6 *)((void *)0));
  }
  {
#line 211
  tmp___0 = socketpair(1, 1, 0, (int *)(fd));
  }
#line 211
  if (tmp___0) {
#line 212
    goto error;
  }
  {
#line 214
  miredo_setup_fd(fd[0]);
#line 215
  miredo_setup_fd(fd[1]);
#line 218
  tmp___1 = tun6_getId((tun6 const   *)tunnel);
#line 218
  snprintf((char */* __restrict  */)(ifindex), sizeof(ifindex), (char const   */* __restrict  */)"%X",
           tmp___1);
#line 221
  tmp___2 = fork();
  }
  {
#line 223
  if (tmp___2 == -1) {
#line 223
    goto case_neg_1;
  }
#line 228
  if (tmp___2 == 0) {
#line 228
    goto case_0;
  }
#line 221
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 224
  close(fd[0]);
#line 225
  close(fd[1]);
  }
#line 226
  goto error;
  case_0: /* CIL Label */ 
  {
#line 229
  tmp___3 = dup2(fd[0], 0);
  }
#line 229
  if (tmp___3 == 0) {
    {
#line 229
    tmp___4 = dup2(fd[0], 1);
    }
#line 229
    if (tmp___4 == 1) {
      {
#line 230
      execl(path, path, ifindex, (char *)((void *)0));
      }
    }
  }
  {
#line 232
  tmp___5 = dgettext("miredo", "Could not execute %s: %m");
#line 232
  syslog(3, (char const   *)tmp___5, path);
#line 233
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 235
  close(fd[0]);
#line 236
  *pfd = fd[1];
  }
#line 237
  return (tunnel);
  error: 
  {
#line 239
  tun6_destroy(tunnel);
  }
#line 240
  return ((tun6 *)((void *)0));
}
}
#line 244 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static int configure_tunnel(int fd , struct in6_addr  const  *addr , unsigned int mtu ) 
{ 
  struct miredo_tunnel_settings s ;
  int res ;
  int *tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 250
  if (mtu > 65535U) {
    {
#line 252
    tmp = __errno_location();
#line 252
    *tmp = 22;
    }
#line 253
    return (-1);
  }
  {
#line 256
  memset((void *)(& s), 0, sizeof(s));
#line 257
  memcpy((void */* __restrict  */)(& s.addr), (void const   */* __restrict  */)addr,
         sizeof(s.addr));
#line 258
  s.mtu = (uint16_t )mtu;
#line 260
  tmp___0 = send(fd, (void const   *)(& s), sizeof(s), 16384);
  }
#line 260
  if ((unsigned long )tmp___0 != sizeof(s)) {
#line 262
    return (-1);
  } else {
    {
#line 260
    tmp___1 = recv(fd, (void *)(& res), sizeof(res), 256);
    }
#line 260
    if ((unsigned long )tmp___1 != sizeof(res)) {
#line 262
      return (-1);
    }
  }
#line 264
  return (res);
}
}
#line 268 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static void destroy_dynamic_tunnel(tun6 *tunnel , int fd ) 
{ 


  {
#line 271
  if (! (fd != -1)) {
    {
#line 271
    __assert_fail("fd != -1", "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c",
                  271U, "destroy_dynamic_tunnel");
    }
  }
  {
#line 272
  close(fd);
#line 274
  wait((union wait *)((void *)0));
#line 276
  tun6_destroy(tunnel);
  }
#line 277
  return;
}
}
#line 283 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static void miredo_up_callback(void *data , struct in6_addr  const  *addr , uint16_t mtu ) 
{ 
  char str[46] ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 288
  tmp = dgettext("miredo", "Teredo pseudo-tunnel started");
#line 288
  syslog(5, (char const   *)tmp);
#line 289
  tmp___1 = inet_ntop(10, (void const   */* __restrict  */)addr, (char */* __restrict  */)(str),
                      (socklen_t )sizeof(str));
  }
#line 289
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
    {
#line 290
    tmp___0 = dgettext("miredo", " (address: %s, MTU: %u)");
#line 290
    syslog(6, (char const   *)tmp___0, str, (int )mtu);
    }
  }
#line 293
  if (! ((unsigned long )data != (unsigned long )((void *)0))) {
    {
#line 293
    __assert_fail("data != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c",
                  293U, "miredo_up_callback");
    }
  }
  {
#line 295
  configure_tunnel(((miredo_tunnel *)data)->priv_fd, addr, (unsigned int )mtu);
  }
#line 296
  return;
}
}
#line 302 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static void miredo_down_callback(void *data ) 
{ 
  char *tmp ;

  {
#line 305
  if (! ((unsigned long )data != (unsigned long )((void *)0))) {
    {
#line 305
    __assert_fail("data != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c",
                  305U, "miredo_down_callback");
    }
  }
  {
#line 307
  configure_tunnel(((miredo_tunnel *)data)->priv_fd, & in6addr_any, 1280U);
#line 309
  tmp = dgettext("miredo", "Teredo pseudo-tunnel stopped");
#line 309
  syslog(5, (char const   *)tmp);
  }
#line 310
  return;
}
}
#line 313 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static int setup_client(teredo_tunnel *client , char const   *server , char const   *server2 ) 
{ 
  int tmp ;

  {
  {
#line 316
  teredo_set_state_cb((teredo_tunnel */* __restrict  */)client, & miredo_up_callback,
                      & miredo_down_callback);
#line 317
  tmp = teredo_set_client_mode((teredo_tunnel */* __restrict  */)client, server, server2);
  }
#line 317
  return (tmp);
}
}
#line 326 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static tun6 *create_static_tunnel(char const   * __restrict  ifname , struct in6_addr  const  * __restrict  prefix ,
                                  uint16_t mtu ) 
{ 
  tun6 *tunnel ;
  tun6 *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 331
  tmp = tun6_create((char const   *)ifname);
#line 331
  tunnel = tmp;
  }
#line 333
  if ((unsigned long )tunnel == (unsigned long )((void *)0)) {
#line 333
    if ((unsigned long )ifname != (unsigned long )((void *)0)) {
      {
#line 333
      tmp___0 = __errno_location();
      }
#line 333
      if (*tmp___0 == 38) {
        {
#line 334
        tunnel = tun6_create((char const   *)((void *)0));
        }
      }
    }
  }
#line 335
  if ((unsigned long )tunnel == (unsigned long )((void *)0)) {
#line 336
    return ((tun6 *)((void *)0));
  }
  {
#line 338
  tmp___1 = tun6_setMTU(tunnel, (unsigned int )mtu);
  }
#line 338
  if (tmp___1) {
    {
#line 342
    tun6_destroy(tunnel);
    }
#line 343
    return ((tun6 *)((void *)0));
  } else {
    {
#line 338
    tmp___2 = tun6_bringUp(tunnel);
    }
#line 338
    if (tmp___2) {
      {
#line 342
      tun6_destroy(tunnel);
      }
#line 343
      return ((tun6 *)((void *)0));
    } else {
      {
#line 338
      tmp___3 = tun6_addAddress((tun6 */* __restrict  */)tunnel, (struct in6_addr  const  */* __restrict  */)(& teredo_restrict),
                                64U);
      }
#line 338
      if (tmp___3) {
        {
#line 342
        tun6_destroy(tunnel);
        }
#line 343
        return ((tun6 *)((void *)0));
      } else {
        {
#line 338
        tmp___4 = tun6_addRoute((tun6 */* __restrict  */)tunnel, prefix, 32U, 0);
        }
#line 338
        if (tmp___4) {
          {
#line 342
          tun6_destroy(tunnel);
          }
#line 343
          return ((tun6 *)((void *)0));
        }
      }
    }
  }
#line 345
  return (tunnel);
}
}
#line 372 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static int setup_relay(teredo_tunnel *relay , uint32_t prefix , _Bool cone ) 
{ 
  int tmp ;

  {
  {
#line 375
  teredo_set_prefix(relay, prefix);
#line 376
  teredo_set_cone_flag(relay, cone);
#line 377
  tmp = teredo_set_relay_mode(relay);
  }
#line 377
  return (tmp);
}
}
#line 385
static  __attribute__((__noreturn__)) void *miredo_encap_thread(void *d ) ;
#line 385 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static void *miredo_encap_thread(void *d ) 
{ 
  teredo_tunnel *relay ;
  tun6 *tunnel ;
  struct __anonstruct_pbuf_81 pbuf ;
  int val ;
  int tmp ;

  {
#line 387
  relay = ((miredo_tunnel *)d)->relay;
#line 388
  tunnel = ((miredo_tunnel *)d)->tunnel;
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 401
    tmp = tun6_wait_recv((tun6 */* __restrict  */)tunnel, (void *)(& pbuf.ip6), sizeof(pbuf));
#line 401
    val = tmp;
    }
#line 402
    if (val >= 40) {
      {
#line 404
      pthread_setcancelstate(1, (int *)((void *)0));
#line 405
      teredo_transmit((teredo_tunnel */* __restrict  */)relay, (struct ip6_hdr  const  */* __restrict  */)(& pbuf.ip6),
                      (size_t )val);
#line 406
      pthread_setcancelstate(0, (int *)((void *)0));
      }
    } else {
      {
#line 409
      pthread_testcancel();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 418 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static int run_tunnel(miredo_tunnel *tunnel ) 
{ 
  pthread_t encap_th ;
  int tmp ;
  int tmp___0 ;
  sigset_t dummyset ;
  sigset_t set ;
  int __constr_expr_9 ;
  int tmp___1 ;

  {
  {
#line 422
  tmp = teredo_run_async(tunnel->relay);
  }
#line 422
  if (tmp) {
#line 424
    return (-1);
  } else {
    {
#line 422
    tmp___0 = pthread_create((pthread_t */* __restrict  */)(& encap_th), (pthread_attr_t const   */* __restrict  */)((void *)0),
                             & miredo_encap_thread, (void */* __restrict  */)tunnel);
    }
#line 422
    if (tmp___0) {
#line 424
      return (-1);
    }
  }
  {
#line 427
  sigemptyset(& dummyset);
#line 428
  pthread_sigmask(0, (__sigset_t const   */* __restrict  */)(& dummyset), (__sigset_t */* __restrict  */)(& set));
  }
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 429
    __constr_expr_9 = 0;
#line 429
    tmp___1 = sigwait((sigset_t const   */* __restrict  */)(& set), (int */* __restrict  */)(& __constr_expr_9));
    }
#line 429
    if (! tmp___1) {
#line 429
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 431
  pthread_cancel(encap_th);
#line 432
  pthread_join(encap_th, (void **)((void *)0));
  }
#line 433
  return (0);
}
}
#line 437 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static int relay_run(miredo_conf *conf , char const   *server_name ) 
{ 
  union teredo_addr prefix ;
  int mode ;
  char *tmp ;
  _Bool tmp___0 ;
  char const   *server_name2 ;
  char namebuf[1025] ;
  char namebuf2[1025] ;
  uint16_t mtu ;
  _Bool cone ;
  char *name ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  uint32_t bind_ip ;
  uint16_t bind_port ;
  char *tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  char *ifname ;
  char *tmp___10 ;
  int privfd ;
  tun6 *tunnel ;
  tun6 *tmp___11 ;
  tun6 *tmp___12 ;
  tun6 *tmp___13 ;
  int retval ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  teredo_tunnel *relay ;
  teredo_tunnel *tmp___18 ;
  miredo_tunnel data ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
  {
#line 444
  memset((void *)(& prefix), 0, sizeof(prefix));
#line 445
  prefix.teredo.prefix = htonl((uint32_t )536936448);
#line 447
  mode = 2;
#line 448
  tmp___0 = ParseRelayType(conf, "RelayType", & mode);
  }
#line 448
  if (! tmp___0) {
    {
#line 450
    tmp = dgettext("miredo", "Fatal configuration error");
#line 450
    syslog(1, (char const   *)tmp);
    }
#line 451
    return (-2);
  }
#line 455
  server_name2 = (char const   *)((void *)0);
#line 458
  mtu = (uint16_t )1280;
#line 459
  cone = (_Bool)0;
#line 461
  if (mode & 2) {
#line 464
    if ((unsigned long )server_name == (unsigned long )((void *)0)) {
      {
#line 466
      tmp___1 = miredo_conf_get(conf, "ServerAddress", (unsigned int *)((void *)0));
#line 466
      name = tmp___1;
      }
#line 467
      if ((unsigned long )name == (unsigned long )((void *)0)) {
        {
#line 469
        tmp___2 = dgettext("miredo", "Server address not specified");
#line 469
        syslog(1, (char const   *)tmp___2);
#line 470
        tmp___3 = dgettext("miredo", "Fatal configuration error");
#line 470
        syslog(1, (char const   *)tmp___3);
        }
#line 471
        return (-2);
      }
      {
#line 473
      strlcpy(namebuf, (char const   *)name, sizeof(namebuf));
#line 474
      free((void *)name);
#line 475
      server_name = (char const   *)(namebuf);
#line 477
      name = miredo_conf_get(conf, "ServerAddress2", (unsigned int *)((void *)0));
      }
#line 478
      if ((unsigned long )name != (unsigned long )((void *)0)) {
        {
#line 480
        strlcpy(namebuf2, (char const   *)name, sizeof(namebuf2));
#line 481
        free((void *)name);
#line 482
        server_name2 = (char const   *)(namebuf2);
        }
      }
    }
  } else {
    {
#line 493
    server_name = (char const   *)((void *)0);
#line 494
    mtu = (uint16_t )1280;
#line 495
    cone = (_Bool )(mode == 0);
#line 497
    tmp___5 = miredo_conf_parse_teredo_prefix(conf, "Prefix", & prefix.teredo.prefix);
    }
#line 497
    if (tmp___5) {
      {
#line 497
      tmp___6 = miredo_conf_get_int16(conf, "InterfaceMTU", & mtu, (unsigned int *)((void *)0));
      }
#line 497
      if (! tmp___6) {
        {
#line 501
        tmp___4 = dgettext("miredo", "Fatal configuration error");
#line 501
        syslog(1, (char const   *)tmp___4);
        }
#line 502
        return (-2);
      }
    } else {
      {
#line 501
      tmp___4 = dgettext("miredo", "Fatal configuration error");
#line 501
      syslog(1, (char const   *)tmp___4);
      }
#line 502
      return (-2);
    }
  }
  {
#line 506
  bind_ip = (in_addr_t )0;
#line 507
  bind_port = (uint16_t )0;
#line 522
  tmp___8 = miredo_conf_parse_IPv4(conf, "BindAddress", & bind_ip);
  }
#line 522
  if (tmp___8) {
    {
#line 522
    tmp___9 = miredo_conf_get_int16(conf, "BindPort", & bind_port, (unsigned int *)((void *)0));
    }
#line 522
    if (! tmp___9) {
      {
#line 525
      tmp___7 = dgettext("miredo", "Fatal configuration error");
#line 525
      syslog(1, (char const   *)tmp___7);
      }
#line 526
      return (-2);
    }
  } else {
    {
#line 525
    tmp___7 = dgettext("miredo", "Fatal configuration error");
#line 525
    syslog(1, (char const   *)tmp___7);
    }
#line 526
    return (-2);
  }
  {
#line 529
  bind_port = htons(bind_port);
#line 531
  tmp___10 = miredo_conf_get(conf, "InterfaceName", (unsigned int *)((void *)0));
#line 531
  ifname = tmp___10;
#line 533
  miredo_conf_clear(conf, 5);
#line 540
  privfd = -1;
  }
#line 541
  if (mode & 2) {
    {
#line 541
    tmp___11 = create_dynamic_tunnel((char const   *)ifname, & privfd);
#line 541
    tmp___13 = tmp___11;
    }
  } else {
    {
#line 541
    tmp___12 = create_static_tunnel((char const   */* __restrict  */)ifname, (struct in6_addr  const  */* __restrict  */)(& prefix.ip6),
                                    mtu);
#line 541
    tmp___13 = tmp___12;
    }
  }
#line 541
  tunnel = tmp___13;
#line 545
  if ((unsigned long )ifname != (unsigned long )((void *)0)) {
    {
#line 546
    free((void *)ifname);
    }
  }
#line 548
  retval = -1;
#line 550
  if ((unsigned long )tunnel == (unsigned long )((void *)0)) {
    {
#line 552
    tmp___14 = dgettext("miredo", "Cannot create IPv6 tunnel");
#line 552
    tmp___15 = dgettext("miredo", "Miredo setup failure: %s");
#line 552
    syslog(1, (char const   *)tmp___15, tmp___14);
    }
#line 554
    return (-1);
  }
  {
#line 557
  tmp___24 = miredo_init((_Bool )((mode & 2) != 0));
  }
#line 557
  if (tmp___24) {
    {
#line 558
    tmp___16 = dgettext("miredo", "libteredo cannot be initialized");
#line 558
    tmp___17 = dgettext("miredo", "Miredo setup failure: %s");
#line 558
    syslog(1, (char const   *)tmp___17, tmp___16);
    }
  } else {
    {
#line 562
    tmp___23 = drop_privileges();
    }
#line 562
    if (tmp___23 == 0) {
      {
#line 564
      tmp___18 = teredo_create(bind_ip, bind_port);
#line 564
      relay = tmp___18;
      }
#line 565
      if ((unsigned long )relay != (unsigned long )((void *)0)) {
        {
#line 567
        data.tunnel = tunnel;
#line 567
        data.priv_fd = privfd;
#line 567
        data.relay = relay;
#line 568
        teredo_set_privdata(relay, (void *)(& data));
#line 569
        teredo_set_recv_callback((teredo_tunnel */* __restrict  */)relay, & miredo_recv_callback);
#line 570
        teredo_set_icmpv6_callback((teredo_tunnel */* __restrict  */)relay, & miredo_icmp6_callback);
        }
#line 572
        if (mode & 2) {
          {
#line 572
          tmp___19 = setup_client(relay, server_name, server_name2);
#line 572
          retval = tmp___19;
          }
        } else {
          {
#line 572
          tmp___20 = setup_relay(relay, prefix.teredo.prefix, cone);
#line 572
          retval = tmp___20;
          }
        }
#line 579
        if (retval == 0) {
          {
#line 580
          retval = run_tunnel(& data);
          }
        }
        {
#line 581
        teredo_destroy(relay);
        }
      }
#line 584
      if (retval) {
        {
#line 585
        tmp___21 = dgettext("miredo", "libteredo cannot be initialized");
#line 585
        tmp___22 = dgettext("miredo", "Miredo setup failure: %s");
#line 585
        syslog(1, (char const   *)tmp___22, tmp___21);
        }
      }
    }
    {
#line 588
    miredo_deinit((_Bool )((mode & 2) != 0));
    }
  }
#line 591
  if (mode & 2) {
    {
#line 592
    destroy_dynamic_tunnel(tunnel, privfd);
    }
  } else {
    {
#line 594
    tun6_destroy(tunnel);
    }
  }
#line 596
  return (retval);
}
}
#line 600 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static void miredo_setup_fd(int fd ) 
{ 


  {
  {
#line 602
  fcntl(fd, 2, 1);
  }
#line 603
  return;
}
}
#line 606 "/home/wheatley/newnew/temp/miredo-1.2.6/src/relayd.c"
static void miredo_setup_nonblock_fd(int fd ) 
{ 
  int flags ;
  int tmp ;

  {
  {
#line 608
  tmp = fcntl(fd, 3);
#line 608
  flags = tmp;
  }
#line 609
  if (flags == -1) {
#line 610
    flags = 0;
  }
  {
#line 611
  fcntl(fd, 4, 2048 | flags);
#line 612
  miredo_setup_fd(fd);
  }
#line 613
  return;
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 272 "/usr/include/x86_64-linux-gnu/bits/socket.h"
extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                struct cmsghdr *__cmsg ) ;
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 184
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 45 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.h"
struct in6_addr  const  teredo_cone ;
#line 129 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo-udp.h"
int teredo_recv(int fd , struct teredo_packet *p ) ;
#line 54 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
struct in6_addr  const  teredo_restrict  =    {{{(uint8_t )254, (uint8_t )128, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0,
      (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )255, (uint8_t )255,
      (uint8_t )255, (uint8_t )255, (uint8_t )255, (uint8_t )255}}};
#line 63 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
struct in6_addr  const  teredo_cone  =    {{{(uint8_t )254, (uint8_t )128, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0,
      (uint8_t )0, (uint8_t )0, (uint8_t )128, (uint8_t )0, (uint8_t )'T', (uint8_t )'E',
      (uint8_t )'R', (uint8_t )'E', (uint8_t )'D', (uint8_t )'O'}}};
#line 67 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
int teredo_socket(uint32_t bind_ip , uint16_t port ) 
{ 
  struct sockaddr_in myaddr ;
  int fd ;
  int tmp ;
  int tmp___0 ;
  int __constr_expr_10 ;
  int __constr_expr_11 ;
  int __constr_expr_12 ;
  int __constr_expr_13 ;

  {
  {
#line 69
  myaddr.sin_family = (sa_family_t )2;
#line 69
  myaddr.sin_port = port;
#line 69
  myaddr.sin_addr.s_addr = bind_ip;
#line 69
  myaddr.sin_zero[0] = (unsigned char)0;
#line 69
  myaddr.sin_zero[1] = (unsigned char)0;
#line 69
  myaddr.sin_zero[2] = (unsigned char)0;
#line 69
  myaddr.sin_zero[3] = (unsigned char)0;
#line 69
  myaddr.sin_zero[4] = (unsigned char)0;
#line 69
  myaddr.sin_zero[5] = (unsigned char)0;
#line 69
  myaddr.sin_zero[6] = (unsigned char)0;
#line 69
  myaddr.sin_zero[7] = (unsigned char)0;
#line 79
  tmp = socket(2, 2, 17);
#line 79
  fd = tmp;
  }
#line 80
  if (fd == -1) {
#line 81
    return (-1);
  }
  {
#line 83
  fcntl(fd, 2, 1);
#line 85
  tmp___0 = bind(fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& myaddr)),
                 (socklen_t )sizeof(myaddr));
  }
#line 85
  if (tmp___0) {
    {
#line 87
    close(fd);
    }
#line 88
    return (-1);
  }
  {
#line 97
  __constr_expr_10 = 0;
#line 97
  setsockopt(fd, 0, 10, (void const   *)(& __constr_expr_10), (socklen_t )sizeof(int ));
#line 101
  __constr_expr_11 = 1;
#line 101
  setsockopt(fd, 0, 11, (void const   *)(& __constr_expr_11), (socklen_t )sizeof(int ));
#line 104
  __constr_expr_12 = 1;
#line 104
  setsockopt(fd, 0, 8, (void const   *)(& __constr_expr_12), (socklen_t )sizeof(int ));
#line 112
  __constr_expr_13 = 1;
#line 112
  setsockopt(fd, 0, 33, (void const   *)(& __constr_expr_13), (socklen_t )sizeof(int ));
  }
#line 113
  return (fd);
}
}
#line 117 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
static ssize_t teredo_recverr(int fd ) 
{ 
  struct msghdr msg ;
  ssize_t tmp ;

  {
  {
#line 123
  memset((void *)(& msg), 0, sizeof(msg));
#line 124
  tmp = recvmsg(fd, & msg, 8192);
  }
#line 124
  return (tmp);
}
}
#line 133 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
int teredo_sendv(int fd , struct iovec  const  *iov , size_t count , uint32_t dest_ip ,
                 uint16_t dest_port ) 
{ 
  struct sockaddr_in addr ;
  struct msghdr msg ;
  ssize_t res ;
  ssize_t tmp ;

  {
#line 136
  addr.sin_family = (sa_family_t )2;
#line 136
  addr.sin_port = dest_port;
#line 136
  addr.sin_addr.s_addr = dest_ip;
#line 136
  addr.sin_zero[0] = (unsigned char)0;
#line 136
  addr.sin_zero[1] = (unsigned char)0;
#line 136
  addr.sin_zero[2] = (unsigned char)0;
#line 136
  addr.sin_zero[3] = (unsigned char)0;
#line 136
  addr.sin_zero[4] = (unsigned char)0;
#line 136
  addr.sin_zero[5] = (unsigned char)0;
#line 136
  addr.sin_zero[6] = (unsigned char)0;
#line 136
  addr.sin_zero[7] = (unsigned char)0;
#line 146
  msg.msg_name = (void *)(& addr);
#line 146
  msg.msg_namelen = (socklen_t )sizeof(addr);
#line 146
  msg.msg_iov = (struct iovec *)iov;
#line 146
  msg.msg_iovlen = count;
#line 146
  msg.msg_control = (void *)0;
#line 146
  msg.msg_controllen = 0UL;
#line 146
  msg.msg_flags = 0;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 158
    res = sendmsg(fd, (struct msghdr  const  *)(& msg), 0);
    }
#line 157
    if (res == -1L) {
      {
#line 157
      tmp = teredo_recverr(fd);
      }
#line 157
      if (! (tmp != -1L)) {
#line 157
        goto while_break;
      }
    } else {
#line 157
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return ((int )res);
}
}
#line 165 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
int teredo_send(int fd , void const   *packet , size_t plen , uint32_t dest_ip , uint16_t dest_port ) 
{ 
  struct iovec iov ;
  int tmp ;

  {
  {
#line 168
  iov.iov_base = (void *)packet;
#line 168
  iov.iov_len = plen;
#line 169
  tmp = teredo_sendv(fd, (struct iovec  const  *)(& iov), (size_t )1, dest_ip, dest_port);
  }
#line 169
  return (tmp);
}
}
#line 173 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
static int teredo_recv_inner(int fd , struct teredo_packet *p , int flags ) 
{ 
  struct sockaddr_in ad ;
  char cbuf[(((sizeof(struct in_pktinfo ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
  struct iovec iov ;
  struct msghdr msg ;
  ssize_t length ;
  ssize_t tmp ;
  struct cmsghdr *cmsg ;
  struct cmsghdr *tmp___0 ;
  struct in_pktinfo  const  *nfo ;
  uint8_t *ptr ;
  uint8_t id_len ;
  uint8_t au_len ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;
  uint32_t addr ;
  uint16_t port ;

  {
  {
#line 181
  iov.iov_base = (void *)(p->buf.fill);
#line 181
  iov.iov_len = (size_t )65507;
#line 186
  msg.msg_name = (void *)(& ad);
#line 186
  msg.msg_namelen = (socklen_t )sizeof(ad);
#line 186
  msg.msg_iov = & iov;
#line 186
  msg.msg_iovlen = (size_t )1;
#line 186
  msg.msg_control = (void *)(cbuf);
#line 186
  msg.msg_controllen = sizeof(cbuf);
#line 186
  msg.msg_flags = 0;
#line 199
  tmp = recvmsg(fd, & msg, flags);
#line 199
  length = tmp;
  }
#line 200
  if (length == -1L) {
    {
#line 201
    teredo_recverr(fd);
    }
  }
#line 202
  if (length < 2L) {
#line 203
    return (-1);
  }
#line 205
  p->source_ipv4 = ad.sin_addr.s_addr;
#line 206
  p->source_port = ad.sin_port;
#line 207
  p->dest_ipv4 = (uint32_t )0;
#line 212
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 212
    tmp___0 = (struct cmsghdr *)msg.msg_control;
  } else {
#line 212
    tmp___0 = (struct cmsghdr *)0;
  }
#line 212
  cmsg = tmp___0;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! ((unsigned long )cmsg != (unsigned long )((void *)0))) {
#line 212
      goto while_break;
    }
#line 217
    if (cmsg->cmsg_level == 0) {
#line 217
      if (cmsg->cmsg_type == 8) {
#line 220
        nfo = (struct in_pktinfo  const  *)((struct in_pktinfo *)(cmsg->__cmsg_data));
#line 222
        p->dest_ipv4 = (uint32_t )nfo->ipi_addr.s_addr;
      }
    }
    {
#line 212
    cmsg = __cmsg_nxthdr(& msg, cmsg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  ptr = p->buf.fill;
#line 238
  p->auth_present = (_Bool)0;
#line 239
  p->orig_ipv4 = (uint32_t )0;
#line 240
  p->orig_port = (uint16_t )0;
#line 243
  if ((int )*(ptr + 0) == 0) {
#line 243
    if ((int )*(ptr + 1) == 1) {
#line 247
      p->auth_present = (_Bool)1;
#line 249
      length -= 13L;
#line 250
      if (length < 0L) {
#line 251
        return (-1);
      }
#line 252
      ptr += 2;
#line 255
      tmp___1 = ptr;
#line 255
      ptr ++;
#line 255
      id_len = *tmp___1;
#line 256
      tmp___2 = ptr;
#line 256
      ptr ++;
#line 256
      au_len = *tmp___2;
#line 259
      length -= (ssize_t )((int )id_len + (int )au_len);
#line 260
      if (length < 0L) {
#line 261
        return (-1);
      }
      {
#line 262
      ptr += (int )id_len + (int )au_len;
#line 265
      memcpy((void */* __restrict  */)(p->auth_nonce), (void const   */* __restrict  */)ptr,
             (size_t )8);
#line 266
      ptr += 8;
#line 267
      p->auth_fail = (_Bool )(! (! *ptr));
#line 268
      ptr ++;
#line 273
      memmove((void *)(p->buf.align), (void const   *)ptr, (size_t )length);
#line 274
      ptr = p->buf.fill;
      }
    }
  }
#line 278
  if ((int )*(ptr + 0) == 0) {
#line 278
    if ((int )*(ptr + 1) == 0) {
#line 283
      length -= 8L;
#line 284
      if (length < 0L) {
#line 285
        return (-1);
      }
      {
#line 286
      ptr += 2;
#line 289
      memcpy((void */* __restrict  */)(& port), (void const   */* __restrict  */)ptr,
             (size_t )2);
#line 290
      ptr += 2;
#line 291
      p->orig_port = (uint16_t )(~ ((int )port));
#line 294
      memcpy((void */* __restrict  */)(& addr), (void const   */* __restrict  */)ptr,
             (size_t )4);
#line 295
      ptr += 4;
#line 296
      p->orig_ipv4 = ~ addr;
      }
    }
  }
#line 299
  p->ip6_len = (size_t )length;
#line 300
  p->ip6 = (struct ip6_hdr *)ptr;
#line 302
  return (0);
}
}
#line 306 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
int teredo_recv(int fd , struct teredo_packet *p ) 
{ 
  int tmp ;

  {
  {
#line 308
  tmp = teredo_recv_inner(fd, p, 64);
  }
#line 308
  return (tmp);
}
}
#line 317 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
int teredo_wait_recv(int fd , struct teredo_packet *p ) 
{ 
  int tmp ;

  {
  {
#line 326
  tmp = teredo_recv_inner(fd, p, 0);
  }
#line 326
  return (tmp);
}
}
#line 338 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
static uint16_t in_cksum(struct iovec  const  *iov , size_t n ) 
{ 
  uint32_t sum ;
  union __anonunion_w_31 w ;
  _Bool odd ;
  uint8_t const   *ptr ;
  size_t len ;
  uint8_t const   *tmp ;
  uint8_t const   *tmp___0 ;

  {
#line 340
  sum = (uint32_t )0;
#line 346
  odd = (_Bool)0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (n > 0UL)) {
#line 348
      goto while_break;
    }
#line 350
    ptr = (uint8_t const   *)iov->iov_base;
#line 352
    len = (size_t )iov->iov_len;
    {
#line 352
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 352
      if (! (len > 0UL)) {
#line 352
        goto while_break___0;
      }
#line 354
      if (odd) {
#line 356
        tmp = ptr;
#line 356
        ptr ++;
#line 356
        w.bytes[1] = (uint8_t )*tmp;
#line 357
        sum += (uint32_t )w.word;
#line 358
        if (sum > 65535U) {
#line 359
          sum -= 65535U;
        }
      } else {
#line 362
        tmp___0 = ptr;
#line 362
        ptr ++;
#line 362
        w.bytes[0] = (uint8_t )*tmp___0;
      }
#line 363
      odd = (_Bool )(! odd);
#line 352
      len --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    iov ++;
#line 367
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  if (odd) {
#line 372
    w.bytes[1] = (uint8_t )0;
#line 373
    sum += (uint32_t )w.word;
#line 374
    if (sum > 65535U) {
#line 375
      sum -= 65535U;
    }
  }
#line 378
  return ((uint16_t )(sum ^ 65535U));
}
}
#line 382 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
uint16_t teredo_cksum(void const   *src , void const   *dst , uint8_t protocol , struct iovec  const  *data ,
                      size_t n ) 
{ 
  struct iovec *iov ;
  unsigned long __lengthofiov ;
  void *tmp ;
  size_t plen ;
  size_t i ;
  size_t tmp___0 ;
  uint32_t pseudo[4] ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  unsigned int tmp___3 ;
  uint16_t tmp___4 ;

  {
  {
#line 386
  __lengthofiov = 3UL + n;
#line 386
  tmp = __builtin_alloca(sizeof(*iov) * __lengthofiov);
#line 386
  iov = (struct iovec *)tmp;
#line 387
  plen = (size_t )0;
#line 388
  i = (size_t )0;
  }
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! (i < n)) {
#line 388
      goto while_break;
    }
#line 390
    (iov + (3UL + i))->iov_base = (void *)(data + i)->iov_base;
#line 391
    tmp___0 = (size_t )(data + i)->iov_len;
#line 391
    (iov + (3UL + i))->iov_len = tmp___0;
#line 391
    plen += tmp___0;
#line 388
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 394
  tmp___1 = htonl((uint32_t )plen);
#line 394
  tmp___2 = htonl((uint32_t )protocol);
#line 394
  pseudo[0] = tmp___1;
#line 394
  pseudo[1] = tmp___2;
#line 394
  tmp___3 = 2U;
  }
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 394
    if (tmp___3 >= 4U) {
#line 394
      goto while_break___0;
    }
#line 394
    pseudo[tmp___3] = 0U;
#line 394
    tmp___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 395
  (iov + 0)->iov_base = (void *)src;
#line 396
  (iov + 0)->iov_len = (size_t )16;
#line 397
  (iov + 1)->iov_base = (void *)dst;
#line 398
  (iov + 1)->iov_len = (size_t )16;
#line 399
  (iov + 2)->iov_base = (void *)(pseudo);
#line 400
  (iov + 2)->iov_len = (size_t )8;
#line 402
  tmp___4 = in_cksum((struct iovec  const  *)iov, 3UL + n);
  }
#line 402
  return (tmp___4);
}
}
#line 406 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
void teredo_close(int fd ) 
{ 


  {
  {
#line 408
  close(fd);
  }
#line 409
  return;
}
}
#line 438 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strerror_r)(int __errnum ,
                                                                                                   char *__buf ,
                                                                                                   size_t __buflen ) ;
#line 42 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/diag.c"
char const   os_driver[6] ;
#line 53 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/diag.c"
int ( __attribute__((__nonnull__)) tun6_driver_diagnose)(char *errbuf ) 
{ 
  int fd ;
  int tmp ;
  char tundev___1[13] ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char buf[256] ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 55
  bindtextdomain("miredo", "/usr/local/share/locale");
#line 57
  tmp = socket(10, 2, 0);
#line 57
  fd = tmp;
  }
#line 58
  if (fd == -1) {
    {
#line 60
    strlcpy(errbuf, "Error: IPv6 stack not available.\n", (size_t )4095);
#line 62
    *(errbuf + 4095) = (char )'\000';
    }
#line 63
    return (-1);
  }
  {
#line 65
  close(fd);
#line 68
  tundev___1[0] = (char )'/';
#line 68
  tundev___1[1] = (char )'d';
#line 68
  tundev___1[2] = (char )'e';
#line 68
  tundev___1[3] = (char )'v';
#line 68
  tundev___1[4] = (char )'/';
#line 68
  tundev___1[5] = (char )'n';
#line 68
  tundev___1[6] = (char )'e';
#line 68
  tundev___1[7] = (char )'t';
#line 68
  tundev___1[8] = (char )'/';
#line 68
  tundev___1[9] = (char )'t';
#line 68
  tundev___1[10] = (char )'u';
#line 68
  tundev___1[11] = (char )'n';
#line 68
  tundev___1[12] = (char )'\000';
#line 70
  fd = open((char const   *)(tundev___1), 2);
  }
#line 71
  if (fd != -1) {
    {
#line 73
    close(fd);
#line 74
    snprintf((char */* __restrict  */)errbuf, (size_t )4096, (char const   */* __restrict  */)"%s tunneling driver found.",
             os_driver);
    }
#line 76
    return (0);
  }
  {
#line 79
  tmp___0 = __errno_location();
  }
  {
#line 81
  if (*tmp___0 == 2) {
#line 81
    goto case_2;
  }
#line 90
  if (*tmp___0 == 19) {
#line 90
    goto case_19;
  }
#line 90
  if (*tmp___0 == 6) {
#line 90
    goto case_19;
  }
#line 79
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 82
  tmp___1 = dgettext("miredo", "You might try to run this command to load it:\n$ modprobe tun\n(you must be root to do that).\n");
#line 82
  tmp___2 = dgettext("miredo", "Error: %s character device not found or unavailable.\n%s");
#line 82
  snprintf((char */* __restrict  */)errbuf, (size_t )4096, (char const   */* __restrict  */)tmp___2,
           tundev___1, tmp___1);
  }
#line 88
  return (-1);
  case_19: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 91
  tmp___3 = dgettext("miredo", "Make sure your Linux kernel includes the \"Universal TUNTAP driver\"\n(CONFIG_TUN option), possibly as a module.\n");
#line 91
  tmp___4 = dgettext("miredo", "Error: your operating system does not seem to provide a network tunneling\ndevice driver, which is required.\n%s");
#line 91
  snprintf((char */* __restrict  */)errbuf, (size_t )4096, (char const   */* __restrict  */)tmp___4,
           tmp___3);
  }
#line 98
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 142
  tmp___5 = __errno_location();
#line 142
  strerror_r(*tmp___5, buf, sizeof(buf));
#line 143
  tmp___6 = dgettext("miredo", "Error: cannot open device file %s (%s)\nIPv6 tunneling will not work.\n");
#line 143
  snprintf((char */* __restrict  */)errbuf, (size_t )4096, (char const   */* __restrict  */)tmp___6,
           tundev___1, buf);
  }
#line 146
  return (-1);
}
}
#line 32 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/v4global.c"
int is_ipv4_global_unicast(uint32_t ip ) 
{ 
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  int tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;
  int tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;

  {
  {
#line 44
  tmp___4 = htonl(2147483648U);
  }
#line 44
  if ((ip & tmp___4) == 0U) {
    {
#line 48
    tmp = htonl(4278190080U);
#line 48
    ip &= tmp;
#line 49
    tmp___0 = htonl((uint32_t )167772160);
    }
#line 49
    if (ip != tmp___0) {
      {
#line 49
      tmp___1 = htonl((uint32_t )2130706432);
      }
#line 49
      if (ip != tmp___1) {
        {
#line 49
        tmp___2 = htonl((uint32_t )0);
        }
#line 49
        if (ip != tmp___2) {
#line 49
          tmp___3 = 1;
        } else {
#line 49
          tmp___3 = 0;
        }
      } else {
#line 49
        tmp___3 = 0;
      }
    } else {
#line 49
      tmp___3 = 0;
    }
#line 49
    return (tmp___3);
  }
  {
#line 54
  tmp___10 = htonl((uint32_t )1073741824);
  }
#line 54
  if ((ip & tmp___10) == 0U) {
    {
#line 58
    tmp___5 = htonl(4294901760U);
#line 58
    tmp___6 = htonl(2851995648U);
    }
#line 58
    if ((ip & tmp___5) != tmp___6) {
      {
#line 58
      tmp___7 = htonl(4293918720U);
#line 58
      tmp___8 = htonl(2886729728U);
      }
#line 58
      if ((ip & tmp___7) != tmp___8) {
#line 58
        tmp___9 = 1;
      } else {
#line 58
        tmp___9 = 0;
      }
    } else {
#line 58
      tmp___9 = 0;
    }
#line 58
    return (tmp___9);
  }
  {
#line 62
  tmp___16 = htonl((uint32_t )536870912);
  }
#line 62
  if ((ip & tmp___16) == 0U) {
    {
#line 66
    tmp___11 = htonl(4294901760U);
#line 66
    tmp___12 = htonl(3232235520U);
    }
#line 66
    if ((ip & tmp___11) != tmp___12) {
      {
#line 66
      tmp___13 = htonl(4294967040U);
#line 66
      tmp___14 = htonl(3227017728U);
      }
#line 66
      if ((ip & tmp___13) != tmp___14) {
#line 66
        tmp___15 = 1;
      } else {
#line 66
        tmp___15 = 0;
      }
    } else {
#line 66
      tmp___15 = 0;
    }
#line 66
    return (tmp___15);
  }
  {
#line 70
  tmp___17 = htonl((uint32_t )268435456);
  }
#line 70
  if ((ip & tmp___17) == 0U) {
#line 72
    return (0);
  }
  {
#line 74
  tmp___18 = htonl(4294967295U);
  }
#line 74
  return (ip != tmp___18);
}
}
#line 27 "/home/wheatley/newnew/temp/miredo-1.2.6/compat/strlcpy.c"
extern size_t strlcpy(char *tgt , char const   *src , size_t bufsize ) 
{ 
  size_t length ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 31
  length = (size_t )1;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (length < bufsize) {
#line 31
      if (! *src) {
#line 31
        goto while_break;
      }
    } else {
#line 31
      goto while_break;
    }
#line 32
    tmp = tgt;
#line 32
    tgt ++;
#line 32
    tmp___0 = src;
#line 32
    src ++;
#line 32
    *tmp = (char )*tmp___0;
#line 31
    length ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  if (bufsize) {
#line 35
    *tgt = (char )'\000';
  }
  {
#line 37
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 37
    tmp___1 = src;
#line 37
    src ++;
#line 37
    if (! *tmp___1) {
#line 37
      goto while_break___0;
    }
#line 38
    length ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 40
  return (length - 1UL);
}
}
#line 34 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.h"
int teredo_init_HMAC(void) ;
#line 35
void teredo_deinit_HMAC(void) ;
#line 36
void teredo_get_pinghash(uint32_t timestamp , struct in6_addr  const  *src , struct in6_addr  const  *dst ,
                         uint8_t * __restrict  hash ) ;
#line 38
int teredo_verify_pinghash(uint32_t now , struct in6_addr  const  *src , struct in6_addr  const  *dst ,
                           uint8_t const   * __restrict  hash ) ;
#line 42
void teredo_get_nonce(uint32_t timestamp , uint32_t ipv4 , uint16_t port , uint8_t * __restrict  nonce ) ;
#line 44
uint16_t teredo_get_flbits(uint32_t timestamp ) ;
#line 79 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.h"
void md5_init(md5_state_t *pms ) ;
#line 82
void md5_append(md5_state_t *pms , md5_byte_t const   *data , int nbytes ) ;
#line 85
void md5_finish(md5_state_t *pms , md5_byte_t *digest ) ;
#line 46 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static char const   randfile[12]  = 
#line 46 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
  {      (char const   )'/',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'/',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'o',      (char const   )'m',      (char const   )'\000'};
#line 57 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static union __anonunion_inner_key_40 inner_key  ;
#line 63 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static union __anonunion_outer_key_41 outer_key  ;
#line 70 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static uint16_t hmac_pid  =    (uint16_t )0;
#line 74 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static pthread_mutex_t mutex  =    {{0, 0U, 0, 0U, 2, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 72 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
int teredo_init_HMAC(void) 
{ 
  int retval ;
  int fd ;
  int tmp ;
  unsigned int len ;
  int val ;
  ssize_t tmp___0 ;
  unsigned int i ;
  __pid_t tmp___1 ;
  __pid_t tmp___2 ;
  uint16_t tmp___3 ;

  {
  {
#line 75
  retval = -1;
#line 78
  d_pthread_mutex_lock(& mutex);
#line 80
  tmp___2 = getpid();
#line 80
  tmp___3 = htons((uint16_t )tmp___2);
  }
#line 80
  if ((int )hmac_pid != (int )tmp___3) {
    {
#line 83
    tmp = open(randfile, 0);
#line 83
    fd = tmp;
    }
#line 84
    if (fd == -1) {
#line 85
      goto error;
    }
    {
#line 87
    memset((void *)(& inner_key), 0, sizeof(inner_key));
#line 89
    len = 0U;
    }
    {
#line 89
    while (1) {
      while_continue: /* CIL Label */ ;
#line 89
      if (! (len < 16U)) {
#line 89
        goto while_break;
      }
      {
#line 91
      tmp___0 = read(fd, (void *)(inner_key.key + len), (size_t )(16U - len));
#line 91
      val = (int )tmp___0;
      }
#line 92
      if (val > 0) {
#line 93
        len -= (unsigned int )val;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 95
    close(fd);
#line 98
    memcpy((void */* __restrict  */)(& outer_key), (void const   */* __restrict  */)(& inner_key),
           sizeof(outer_key));
#line 100
    i = 0U;
    }
    {
#line 100
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 100
      if (! ((unsigned long )i < sizeof(inner_key))) {
#line 100
        goto while_break___0;
      }
#line 102
      inner_key.ipad[i] = (unsigned char )((int )inner_key.ipad[i] ^ 54);
#line 103
      outer_key.opad[i] = (unsigned char )((int )outer_key.opad[i] ^ 92);
#line 100
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 106
    tmp___1 = getpid();
#line 106
    hmac_pid = htons((uint16_t )tmp___1);
    }
  }
#line 108
  retval = 0;
  error: 
  {
#line 111
  d_pthread_mutex_unlock(& mutex);
  }
#line 114
  return (retval);
}
}
#line 118 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
void teredo_deinit_HMAC(void) 
{ 


  {
#line 120
  return;
}
}
#line 125 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static void teredo_hash(void const   *src , size_t slen , void const   *dst , size_t dlen ,
                        uint8_t * __restrict  hash , uint32_t timestamp ) 
{ 
  md5_state_t ctx ;

  {
  {
#line 131
  md5_init(& ctx);
#line 132
  md5_append(& ctx, (md5_byte_t const   *)(inner_key.ipad), (int )sizeof(inner_key.ipad));
#line 133
  md5_append(& ctx, (unsigned char const   *)src, (int )slen);
#line 134
  md5_append(& ctx, (unsigned char const   *)dst, (int )dlen);
#line 135
  md5_append(& ctx, (unsigned char const   *)(& hmac_pid), (int )sizeof(hmac_pid));
#line 136
  md5_append(& ctx, (unsigned char const   *)(& timestamp), (int )sizeof(timestamp));
#line 137
  md5_finish(& ctx, (md5_byte_t *)hash);
#line 139
  md5_init(& ctx);
#line 140
  md5_append(& ctx, (md5_byte_t const   *)(outer_key.opad), (int )sizeof(outer_key.opad));
#line 141
  md5_append(& ctx, (md5_byte_t const   *)hash, 16);
#line 142
  md5_finish(& ctx, (md5_byte_t *)hash);
  }
#line 143
  return;
}
}
#line 157 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
__inline static void teredo_pinghash(struct in6_addr  const  *src , struct in6_addr  const  *dst ,
                                     uint8_t * __restrict  hash , uint32_t timestamp ) 
{ 


  {
  {
#line 161
  teredo_hash((void const   *)src, sizeof(*src), (void const   *)dst, sizeof(*dst),
              hash, timestamp);
  }
#line 162
  return;
}
}
#line 180 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
void teredo_get_pinghash(uint32_t timestamp , struct in6_addr  const  *src , struct in6_addr  const  *dst ,
                         uint8_t * __restrict  hash ) 
{ 


  {
  {
#line 185
  memcpy((void */* __restrict  */)hash, (void const   */* __restrict  */)(& hmac_pid),
         sizeof(hmac_pid));
#line 186
  hash += sizeof(hmac_pid);
#line 188
  timestamp = htonl(timestamp);
#line 189
  memcpy((void */* __restrict  */)hash, (void const   */* __restrict  */)((uint8_t *)(& timestamp) + 2),
         (size_t )2);
#line 190
  hash += 2;
#line 191
  memcpy((void */* __restrict  */)hash, (void const   */* __restrict  */)(& timestamp),
         (size_t )2);
#line 192
  hash += 2;
#line 194
  teredo_pinghash(src, dst, hash, timestamp);
  }
#line 195
  return;
}
}
#line 198 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
int teredo_verify_pinghash(uint32_t now , struct in6_addr  const  *src , struct in6_addr  const  *dst ,
                           uint8_t const   * __restrict  hash ) 
{ 
  int tmp ;
  uint32_t timestamp ;
  uint32_t tmp___0 ;
  unsigned char h1[16] ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 204
  tmp = memcmp((void const   *)hash, (void const   *)(& hmac_pid), sizeof(hmac_pid));
  }
#line 204
  if (tmp) {
#line 205
    return (-1);
  }
  {
#line 206
  hash += sizeof(hmac_pid);
#line 210
  memcpy((void */* __restrict  */)((uint8_t *)(& timestamp) + 2), (void const   */* __restrict  */)hash,
         (size_t )2);
#line 211
  hash += 2;
#line 212
  memcpy((void */* __restrict  */)(& timestamp), (void const   */* __restrict  */)hash,
         (size_t )2);
#line 213
  hash += 2;
#line 215
  tmp___0 = ntohl(timestamp);
  }
#line 215
  if (((now - tmp___0) & 4294967295U) >= 30U) {
#line 216
    return (-1);
  }
  {
#line 219
  teredo_pinghash(src, dst, (uint8_t */* __restrict  */)(h1), timestamp);
#line 222
  tmp___3 = memcmp((void const   *)(h1), (void const   *)hash, (size_t )16);
  }
#line 222
  if (tmp___3) {
#line 222
    tmp___2 = -1;
  } else {
#line 222
    tmp___2 = 0;
  }
#line 222
  return (tmp___2);
}
}
#line 226 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
uint16_t teredo_get_flbits(uint32_t timestamp ) 
{ 
  uint8_t buf[16] ;

  {
  {
#line 230
  teredo_hash((void const   *)((void *)0), (size_t )0, (void const   *)((void *)0),
              (size_t )0, (uint8_t */* __restrict  */)(buf), timestamp);
  }
#line 231
  return ((uint16_t )(((int )buf[0] << 8) | (int )buf[1]));
}
}
#line 240 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
void teredo_get_nonce(uint32_t timestamp , uint32_t ipv4 , uint16_t port , uint8_t * __restrict  nonce ) 
{ 
  uint8_t buf[16] ;

  {
  {
#line 246
  teredo_hash((void const   *)(& ipv4), (size_t )4, (void const   *)(& port), (size_t )2,
              (uint8_t */* __restrict  */)(buf), timestamp);
#line 247
  memcpy((void */* __restrict  */)nonce, (void const   */* __restrict  */)(buf), (size_t )8);
  }
#line 248
  return;
}
}
#line 899 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlock_init)(pthread_rwlock_t * __restrict  __rwlock ,
                                                                                                          pthread_rwlockattr_t const   * __restrict  __attr ) ;
#line 904
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlock_destroy)(pthread_rwlock_t *__rwlock ) ;
#line 908
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_rdlock)(pthread_rwlock_t *__rwlock ) ;
#line 923
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_wrlock)(pthread_rwlock_t *__rwlock ) ;
#line 938
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_unlock)(pthread_rwlock_t *__rwlock ) ;
#line 40 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.h"
int CheckPing(teredo_packet const   *packet ) ;
#line 41
int CheckBubble(teredo_packet const   *packet ) ;
#line 63
int SendBubbleFromDst(int fd , struct in6_addr  const  *dst , _Bool indirect ) ;
#line 75
int teredo_send_bubble(int fd , uint32_t ip , uint16_t port , struct in6_addr  const  *src ,
                       struct in6_addr  const  *dst ) ;
#line 79 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.h"
__inline static int teredo_reply_bubble(int fd , uint32_t ip , uint16_t port , struct ip6_hdr  const  *req ) 
{ 
  int tmp ;

  {
  {
#line 82
  tmp = teredo_send_bubble(fd, ip, port, & req->ip6_dst, & req->ip6_src);
  }
#line 82
  return (tmp);
}
}
#line 127
int SendPing(int fd , union teredo_addr  const  *src , struct in6_addr  const  *dst ) ;
#line 145
int BuildICMPv6Error(struct icmp6_hdr * __restrict  out , uint8_t type , uint8_t code ,
                     struct ip6_hdr  const  * __restrict  in , size_t inlen ) ;
#line 133 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/tunnel.h"
void teredo_run(teredo_tunnel *tunnel ) ;
#line 234
void *teredo_get_privdata(teredo_tunnel const   *t ) ;
#line 77 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.h"
teredo_maintenance *teredo_maintenance_start(int fd , void (*cb)(struct teredo_state  const  *s ,
                                                                 void *opaque ) ,
                                             void *opaque , char const   *s1 , char const   *s2 ,
                                             unsigned int q_sec , unsigned int q_retries ,
                                             unsigned int refresh_sec , unsigned int restart_sec ) ;
#line 89
void teredo_maintenance_stop(teredo_maintenance *m ) ;
#line 98
int teredo_maintenance_process(teredo_maintenance * __restrict  m , teredo_packet const   * __restrict  packet ) ;
#line 65 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.h"
__inline static void SetMapping(teredo_peer *peer , uint32_t ip , uint16_t port ) 
{ 


  {
#line 67
  peer->mapped_addr = ip;
#line 68
  peer->mapped_port = port;
#line 69
  return;
}
}
#line 71 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.h"
__inline static void TouchReceive(teredo_peer *peer , teredo_clock_t now ) 
{ 


  {
#line 73
  peer->last_rx = now;
#line 74
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.h"
__inline static void TouchTransmit(teredo_peer *peer , teredo_clock_t now ) 
{ 


  {
#line 78
  peer->last_tx = now;
#line 79
  return;
}
}
#line 82 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.h"
__inline static _Bool IsValid(teredo_peer const   *peer , teredo_clock_t now ) 
{ 


  {
#line 85
  return ((_Bool )(now - (teredo_clock_t )peer->last_rx <= 30UL));
}
}
#line 121 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_send_unreach(teredo_tunnel * __restrict  tunnel , uint8_t code ,
                                struct ip6_hdr  const  * __restrict  in , size_t len ) 
{ 
  struct __anonstruct_buf_51 buf ;
  teredo_clock_t now ;
  teredo_clock_t tmp ;
  int tmp___0 ;

  {
  {
#line 130
  tmp = teredo_clock();
#line 130
  now = tmp;
#line 133
  d_pthread_mutex_lock(& tunnel->ratelimit.lock);
  }
#line 134
  if (now != tunnel->ratelimit.last) {
#line 136
    tunnel->ratelimit.last = now;
#line 137
    tunnel->ratelimit.count = 10;
  }
#line 141
  if (tunnel->ratelimit.count == 0) {
    {
#line 144
    d_pthread_mutex_unlock(& tunnel->ratelimit.lock);
    }
#line 145
    return;
  }
#line 147
  if (tunnel->ratelimit.count > 0) {
#line 148
    (tunnel->ratelimit.count) --;
  }
  {
#line 149
  d_pthread_mutex_unlock(& tunnel->ratelimit.lock);
#line 151
  tmp___0 = BuildICMPv6Error((struct icmp6_hdr */* __restrict  */)(& buf.hdr), (uint8_t )1,
                             code, in, len);
#line 151
  len = (size_t )tmp___0;
#line 152
  (*(tunnel->icmpv6_cb))(tunnel->opaque, (void const   *)(& buf.hdr), len, & in->ip6_src);
  }
#line 153
  return;
}
}
#line 177 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_state_change(teredo_state const   *state , void *self ) 
{ 
  teredo_tunnel *tunnel ;
  _Bool previously_up ;
  char b[16] ;
  char const   *tmp ;

  {
  {
#line 180
  tunnel = (teredo_tunnel *)self;
#line 182
  pthread_rwlock_wrlock(& tunnel->state_lock);
#line 183
  previously_up = tunnel->state.up;
#line 184
  tunnel->state = (teredo_state )*state;
  }
#line 186
  if (tunnel->state.up) {
    {
#line 194
    teredo_list_reset(tunnel->list, 1024U);
#line 195
    (*(tunnel->up_cb))(tunnel->opaque, (struct in6_addr  const  *)(& tunnel->state.addr.ip6),
                       tunnel->state.mtu);
#line 200
    tmp = inet_ntop(2, (void const   */* __restrict  */)(& tunnel->state.ipv4), (char */* __restrict  */)(b),
                    (socklen_t )sizeof(b));
#line 200
    debug("Internal IPv4 address: %s", tmp);
    }
  } else
#line 205
  if (previously_up) {
    {
#line 206
    (*(tunnel->down_cb))(tunnel->opaque);
    }
  }
  {
#line 213
  pthread_rwlock_unlock(& tunnel->state_lock);
  }
#line 214
  return;
}
}
#line 220 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static int CountPing(teredo_peer *peer , teredo_clock_t now ) 
{ 
  int res ;

  {
#line 224
  if (peer->pings == 0U) {
#line 225
    res = 0;
  } else
#line 227
  if (peer->pings >= 4U) {
#line 228
    res = -1;
  } else
#line 231
  if (((now - (teredo_clock_t )peer->last_ping) & 511UL) <= 2UL) {
#line 232
    res = 1;
  } else {
#line 234
    res = 0;
  }
#line 236
  if (res == 0) {
#line 238
    peer->last_ping = (unsigned int )now;
#line 239
    (peer->pings) ++;
  }
#line 242
  return (res);
}
}
#line 246 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
__inline static _Bool IsClient(teredo_tunnel const   *tunnel ) 
{ 


  {
#line 248
  return ((_Bool )((unsigned long )tunnel->maintenance != (unsigned long )((void *)0)));
}
}
#line 257 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static int CountBubble(teredo_peer *peer , teredo_clock_t now ) 
{ 
  int res ;

  {
#line 262
  if (peer->bubbles > 0U) {
#line 264
    if (peer->bubbles >= 4U) {
#line 267
      if (now - peer->last_tx <= 300UL) {
#line 268
        res = -1;
      } else {
#line 272
        peer->bubbles = 0U;
#line 273
        res = 0;
      }
    } else
#line 278
    if (now - peer->last_tx <= 2UL) {
#line 279
      res = 1;
    } else {
#line 281
      res = 0;
    }
  } else {
#line 284
    res = 0;
  }
#line 286
  if (res == 0) {
#line 288
    peer->last_tx = now;
#line 289
    (peer->bubbles) ++;
  }
#line 292
  return (res);
}
}
#line 296 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
__inline static void SetMappingFromPacket(teredo_peer *peer , struct teredo_packet  const  *p ) 
{ 


  {
  {
#line 299
  SetMapping(peer, (uint32_t )p->source_ipv4, (uint16_t )p->source_port);
  }
#line 300
  return;
}
}
#line 310 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static int teredo_encap(teredo_tunnel * __restrict  tunnel , teredo_peer * __restrict  peer ,
                        void const   * __restrict  data , size_t len , teredo_clock_t now ) 
{ 
  uint32_t ipv4 ;
  uint16_t port ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 314
  ipv4 = peer->mapped_addr;
#line 315
  port = peer->mapped_port;
#line 316
  TouchTransmit((teredo_peer *)peer, now);
#line 317
  teredo_list_release(tunnel->list);
#line 319
  tmp___1 = teredo_send(tunnel->fd, (void const   *)data, len, ipv4, port);
  }
#line 319
  if (tmp___1 == (int )len) {
#line 319
    tmp___0 = 0;
  } else {
#line 319
    tmp___0 = -1;
  }
#line 319
  return (tmp___0);
}
}
#line 324 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
int teredo_transmit(teredo_tunnel * __restrict  tunnel , struct ip6_hdr  const  * __restrict  packet ,
                    size_t length ) 
{ 
  union teredo_addr  const  *dst ;
  char b[46] ;
  teredo_state s ;
  _Bool tmp ;
  union teredo_addr  const  *src ;
  char const   *tmp___0 ;
  _Bool tmp___1 ;
  uint32_t peer_server ;
  char b___0[16] ;
  char const   *tmp___2 ;
  int tmp___3 ;
  _Bool created ;
  teredo_clock_t now ;
  teredo_clock_t tmp___4 ;
  struct teredo_peerlist *list ;
  teredo_peer *p ;
  teredo_peer *tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  char const   *tmp___11 ;
  _Bool tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  int res ;
  _Bool tmp___16 ;
  char const   *tmp___17 ;
  int res___0 ;
  int tmp___18 ;
  uint16_t tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 327
  if (! ((unsigned long )tunnel != (unsigned long )((void *)0))) {
    {
#line 327
    __assert_fail("tunnel != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  327U, "teredo_transmit");
    }
  }
#line 329
  dst = (union teredo_addr  const  *)(& packet->ip6_dst);
#line 336
  if ((int )dst->ip6.__in6_u.__u6_addr8[0] == 255) {
#line 337
    return (0);
  }
  {
#line 340
  pthread_rwlock_rdlock(& tunnel->state_lock);
#line 341
  s = tunnel->state;
#line 346
  pthread_rwlock_unlock(& tunnel->state_lock);
#line 349
  tmp = IsClient((teredo_tunnel const   *)tunnel);
  }
#line 349
  if (tmp) {
#line 349
    if (! s.up) {
      {
#line 352
      teredo_send_unreach(tunnel, (uint8_t )3, packet, length);
      }
#line 353
      return (0);
    }
  }
#line 357
  if (dst->teredo.prefix != (uint32_t const   )s.addr.teredo.prefix) {
    {
#line 361
    tmp___1 = IsClient((teredo_tunnel const   *)tunnel);
    }
#line 361
    if (tmp___1) {
#line 363
      src = (union teredo_addr  const  *)(& packet->ip6_src);
#line 366
      if (src->teredo.prefix != (uint32_t const   )s.addr.teredo.prefix) {
        {
#line 370
        teredo_send_unreach(tunnel, (uint8_t )1, packet, length);
        }
#line 372
        return (0);
      }
    } else {
      {
#line 380
      tmp___0 = inet_ntop(10, (void const   */* __restrict  */)(& dst->ip6.__in6_u.__u6_addr8),
                          (char */* __restrict  */)(b), (socklen_t )sizeof(b));
#line 380
      debug("Unacceptable destination: %s", tmp___0);
#line 382
      teredo_send_unreach(tunnel, (uint8_t )3, packet, length);
      }
#line 384
      return (0);
    }
  } else {
#line 390
    if (! (dst->teredo.prefix == (uint32_t const   )s.addr.teredo.prefix)) {
      {
#line 390
      __assert_fail("dst->teredo.prefix == s.addr.teredo.prefix", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                    390U, "teredo_transmit");
      }
    }
    {
#line 404
    peer_server = (uint32_t )dst->teredo.server_ip;
#line 405
    tmp___3 = is_ipv4_global_unicast(peer_server);
    }
#line 405
    if (tmp___3) {
#line 405
      if (peer_server == 0U) {
        {
#line 409
        tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& peer_server), (char */* __restrict  */)(b___0),
                            (socklen_t )sizeof(b___0));
#line 409
        debug("Non global server address: %s", tmp___2);
        }
#line 412
        return (0);
      }
    } else {
      {
#line 409
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& peer_server), (char */* __restrict  */)(b___0),
                          (socklen_t )sizeof(b___0));
#line 409
      debug("Non global server address: %s", tmp___2);
      }
#line 412
      return (0);
    }
  }
  {
#line 417
  tmp___4 = teredo_clock();
#line 417
  now = tmp___4;
#line 418
  list = tunnel->list;
#line 420
  tmp___5 = teredo_list_lookup((teredo_peerlist */* __restrict  */)list, (struct in6_addr  const  */* __restrict  */)(& dst->ip6),
                               (_Bool */* __restrict  */)(& created));
#line 420
  p = tmp___5;
  }
#line 421
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 422
    return (-1);
  }
#line 424
  if (! created) {
#line 427
    if (p->trusted) {
      {
#line 427
      tmp___7 = IsValid((teredo_peer const   *)p, now);
      }
#line 427
      if (tmp___7) {
        {
#line 429
        tmp___6 = teredo_encap(tunnel, (teredo_peer */* __restrict  */)p, (void const   */* __restrict  */)packet,
                               length, now);
        }
#line 429
        return (tmp___6);
      }
    }
  } else {
#line 433
    tmp___9 = 0U;
#line 433
    p->pings = tmp___9;
#line 433
    tmp___8 = tmp___9;
#line 433
    p->bubbles = tmp___8;
#line 433
    p->trusted = tmp___8;
  }
  {
#line 436
  tmp___12 = IsValid((teredo_peer const   *)p, now);
  }
#line 436
  if (tmp___12) {
#line 436
    tmp___11 = "";
  } else {
#line 436
    tmp___11 = "NOT ";
  }
#line 436
  if (p->trusted) {
#line 436
    tmp___13 = "";
  } else {
#line 436
    tmp___13 = "NOT ";
  }
#line 436
  if (created) {
#line 436
    tmp___15 = "<unknown>";
  } else {
    {
#line 436
    tmp___14 = inet_ntop(2, (void const   */* __restrict  */)(& p->mapped_addr), (char */* __restrict  */)(b),
                         (socklen_t )sizeof(b));
#line 436
    tmp___15 = tmp___14;
    }
  }
  {
#line 436
  debug("Connecting %s: %strusted, %svalid, %u pings, %u bubbles", tmp___15, tmp___13,
        tmp___11, p->pings, p->bubbles);
  }
#line 448
  if (dst->teredo.prefix != (uint32_t const   )s.addr.teredo.prefix) {
    {
#line 452
    tmp___16 = IsClient((teredo_tunnel const   *)tunnel);
    }
#line 452
    if (! tmp___16) {
      {
#line 452
      __assert_fail("IsClient (tunnel)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                    452U, "teredo_transmit");
      }
    }
#line 456
    if (created) {
#line 458
      p->mapped_port = (uint16_t )0;
#line 459
      p->mapped_addr = (uint32_t )0;
    }
    {
#line 462
    teredo_enqueue_out((teredo_peer */* __restrict  */)p, (void const   */* __restrict  */)packet,
                       length);
#line 463
    res = CountPing(p, now);
#line 464
    teredo_list_release(list);
    }
#line 466
    if (res == 0) {
      {
#line 467
      res = SendPing(tunnel->fd, (union teredo_addr  const  *)(& s.addr), & dst->ip6);
      }
    }
#line 469
    if (res == -1) {
      {
#line 470
      teredo_send_unreach(tunnel, (uint8_t )3, packet, length);
      }
    }
    {
#line 473
    tmp___17 = inet_ntop(10, (void const   */* __restrict  */)(& dst->ip6), (char */* __restrict  */)(b),
                         (socklen_t )sizeof(b));
#line 473
    debug("%s: ping returned %d", tmp___17, res);
    }
#line 475
    return (0);
  }
#line 483
  if (created) {
    {
#line 485
    SetMapping(p, (uint32_t )(dst->teredo.client_ip ^ 4294967295U), (uint16_t )((int const   )dst->teredo.client_port ^ 65535));
    }
  }
  {
#line 498
  teredo_enqueue_out((teredo_peer */* __restrict  */)p, (void const   */* __restrict  */)packet,
                     length);
#line 501
  tmp___18 = CountBubble(p, now);
#line 501
  res___0 = tmp___18;
#line 502
  teredo_list_release(list);
  }
  {
#line 505
  if (res___0 == 0) {
#line 505
    goto case_0;
  }
#line 516
  if (res___0 == -1) {
#line 516
    goto case_neg_1;
  }
#line 503
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 510
  tmp___19 = htons((uint16_t )32768);
  }
#line 510
  if (! ((int )s.addr.teredo.flags & (int )tmp___19)) {
    {
#line 510
    tmp___20 = SendBubbleFromDst(tunnel->fd, & dst->ip6, (_Bool)0);
    }
#line 510
    if (tmp___20) {
#line 512
      return (-1);
    }
  }
  {
#line 514
  tmp___21 = SendBubbleFromDst(tunnel->fd, & dst->ip6, (_Bool)1);
  }
#line 514
  return (tmp___21);
  case_neg_1: /* CIL Label */ 
  {
#line 517
  teredo_send_unreach(tunnel, (uint8_t )3, packet, length);
  }
  switch_break: /* CIL Label */ ;
  }
#line 523
  return (0);
}
}
#line 527 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_predecap(teredo_tunnel * __restrict  tunnel , teredo_peer * __restrict  peer ,
                            teredo_clock_t now ) 
{ 
  unsigned int tmp ;
  teredo_queue *q ;
  teredo_queue *tmp___0 ;

  {
  {
#line 531
  TouchReceive((teredo_peer *)peer, now);
#line 532
  tmp = 0U;
#line 532
  peer->pings = tmp;
#line 532
  peer->bubbles = tmp;
#line 533
  tmp___0 = teredo_peer_queue_yield((teredo_peer *)peer);
#line 533
  q = tmp___0;
#line 534
  teredo_list_release(tunnel->list);
  }
#line 536
  if ((unsigned long )q != (unsigned long )((void *)0)) {
    {
#line 537
    teredo_queue_emit(q, tunnel->fd, peer->mapped_addr, peer->mapped_port, tunnel->recv_cb,
                      tunnel->opaque);
    }
  }
#line 540
  return;
}
}
#line 552 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_run_inner(teredo_tunnel * __restrict  tunnel , struct teredo_packet  const  * __restrict  packet ) 
{ 
  char b[46] ;
  struct ip6_hdr *ip6 ;
  size_t length ;
  uint16_t tmp ;
  teredo_state s ;
  int tmp___0 ;
  uint32_t ipv4 ;
  uint16_t port ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  uint16_t tmp___3 ;
  char const   *tmp___4 ;
  _Bool tmp___5 ;
  char const   *tmp___6 ;
  teredo_clock_t now ;
  teredo_clock_t tmp___7 ;
  struct teredo_peerlist *list ;
  teredo_peer *p ;
  teredo_peer *tmp___8 ;
  _Bool tmp___9 ;
  int tmp___10 ;
  _Bool __constr_expr_14 ;
  _Bool tmp___11 ;
  char const   *tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  _Bool tmp___15 ;
  int tmp___16 ;
  _Bool tmp___17 ;
  _Bool create ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  int res ;
  int tmp___20 ;

  {
#line 556
  if (! ((unsigned long )tunnel != (unsigned long )((void *)0))) {
    {
#line 556
    __assert_fail("tunnel != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  556U, "teredo_run_inner");
    }
  }
#line 557
  if (! ((unsigned long )packet != (unsigned long )((void *)0))) {
    {
#line 557
    __assert_fail("packet != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  557U, "teredo_run_inner");
    }
  }
#line 562
  ip6 = (struct ip6_hdr *)packet->ip6;
#line 565
  if (packet->ip6_len < (size_t const   )sizeof(*ip6)) {
    {
#line 567
    debug("Packet size invalid: %zu bytes.", packet->ip6_len);
    }
#line 568
    return;
  }
  {
#line 571
  tmp = ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 571
  length = sizeof(*ip6) + (unsigned long )tmp;
  }
#line 572
  if ((int )ip6->ip6_ctlun.ip6_un2_vfc >> 4 != 6) {
    {
#line 575
    debug("Received malformed IPv6 packet.");
    }
#line 576
    return;
  } else
#line 572
  if (length > (size_t )packet->ip6_len) {
    {
#line 575
    debug("Received malformed IPv6 packet.");
    }
#line 576
    return;
  }
  {
#line 580
  pthread_rwlock_rdlock(& tunnel->state_lock);
#line 581
  s = tunnel->state;
#line 588
  pthread_rwlock_unlock(& tunnel->state_lock);
#line 592
  tmp___5 = IsClient((teredo_tunnel const   *)tunnel);
  }
#line 592
  if (tmp___5) {
    {
#line 594
    tmp___0 = teredo_maintenance_process((teredo_maintenance */* __restrict  */)tunnel->maintenance,
                                         packet);
    }
#line 594
    if (tmp___0 == 0) {
      {
#line 596
      debug(" packet passed to maintenance procedure");
      }
#line 597
      return;
    }
#line 600
    if (! s.up) {
      {
#line 602
      debug(" packet dropped because tunnel down");
      }
#line 603
      return;
    }
#line 606
    if (packet->source_ipv4 == (uint32_t const   )s.addr.teredo.server_ip) {
      {
#line 606
      tmp___3 = htons((uint16_t )3544);
      }
#line 606
      if ((int const   )packet->source_port == (int const   )tmp___3) {
#line 609
        ipv4 = (uint32_t )packet->orig_ipv4;
#line 610
        port = (uint16_t )packet->orig_port;
#line 612
        if (ipv4 == 0U) {
          {
#line 612
          tmp___1 = IsBubble((struct ip6_hdr  const  *)ip6);
          }
#line 612
          if (tmp___1) {
#line 612
            if (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix == (uint32_t const   )s.addr.teredo.prefix) {
#line 620
              ipv4 = (uint32_t )(((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.client_ip ^ 4294967295U);
#line 621
              port = (uint16_t )((int const   )((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.client_port ^ 65535);
            }
          }
        }
#line 624
        if (ipv4) {
          {
#line 627
          teredo_reply_bubble(tunnel->fd, ipv4, port, (struct ip6_hdr  const  *)ip6);
#line 628
          debug(" bubble sent");
#line 629
          tmp___2 = IsBubble((struct ip6_hdr  const  *)ip6);
          }
#line 629
          if (tmp___2) {
#line 630
            return;
          }
        }
      }
    }
#line 659
    if (((int )ip6->ip6_src.__in6_u.__u6_addr8[0] & 255) == 254) {
#line 659
      if (((int )ip6->ip6_src.__in6_u.__u6_addr8[1] & 192) == 128) {
#line 661
        return;
      }
    }
  } else
#line 666
  if (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix != (uint32_t const   )s.addr.teredo.prefix) {
    {
#line 668
    tmp___4 = inet_ntop(10, (void const   */* __restrict  */)(& ip6->ip6_src.__in6_u.__u6_addr8),
                        (char */* __restrict  */)(b), (socklen_t )sizeof(b));
#line 668
    debug("Source %s is not a teredo address.", tmp___4);
    }
#line 670
    return;
  }
#line 693
  if ((int )ip6->ip6_dst.__in6_u.__u6_addr8[0] == 255) {
    {
#line 695
    tmp___6 = inet_ntop(10, (void const   */* __restrict  */)(& ip6->ip6_dst.__in6_u.__u6_addr8),
                        (char */* __restrict  */)(b), (socklen_t )sizeof(b));
#line 695
    debug("Multicast destination %s not supported.", tmp___6);
    }
#line 697
    return;
  }
  {
#line 702
  tmp___7 = teredo_clock();
#line 702
  now = tmp___7;
#line 705
  list = tunnel->list;
#line 706
  tmp___8 = teredo_list_lookup((teredo_peerlist */* __restrict  */)list, (struct in6_addr  const  */* __restrict  */)(& ip6->ip6_src),
                               (_Bool */* __restrict  */)((void *)0));
#line 706
  p = tmp___8;
  }
#line 708
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 712
    if (p->trusted) {
#line 712
      if (packet->source_ipv4 == (uint32_t const   )p->mapped_addr) {
#line 712
        if ((int const   )packet->source_port == (int const   )p->mapped_port) {
          {
#line 716
          teredo_predecap(tunnel, (teredo_peer */* __restrict  */)p, now);
#line 717
          (*(tunnel->recv_cb))(tunnel->opaque, (void const   *)ip6, length);
          }
#line 718
          return;
        }
      }
    }
    {
#line 727
    tmp___9 = IsClient((teredo_tunnel const   *)tunnel);
    }
#line 727
    if (tmp___9) {
      {
#line 727
      tmp___10 = CheckPing((teredo_packet const   *)packet);
      }
#line 727
      if (tmp___10 == 0) {
        {
#line 729
        p->trusted = 1U;
#line 730
        SetMappingFromPacket(p, (struct teredo_packet  const  *)packet);
#line 732
        teredo_predecap(tunnel, (teredo_peer */* __restrict  */)p, now);
        }
#line 733
        return;
      }
    }
  }
#line 742
  if (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix == (uint32_t const   )s.addr.teredo.prefix) {
    {
#line 745
    tmp___14 = in6_matches_teredo_client((struct in6_addr  const  *)(& ip6->ip6_src),
                                         (uint32_t )packet->source_ipv4, (uint16_t )packet->source_port);
    }
#line 745
    if (tmp___14) {
#line 745
      goto _L;
    } else {
      {
#line 745
      tmp___15 = IsBubble((struct ip6_hdr  const  *)ip6);
      }
#line 745
      if (tmp___15) {
        {
#line 745
        tmp___16 = CheckBubble((teredo_packet const   *)packet);
        }
#line 745
        if (tmp___16 == 0) {
          _L: /* CIL Label */ 
          {
#line 751
          tmp___11 = IsClient((teredo_tunnel const   *)tunnel);
          }
#line 751
          if (tmp___11) {
#line 751
            if ((unsigned long )p == (unsigned long )((void *)0)) {
              {
#line 752
              __constr_expr_14 = (_Bool)0;
#line 752
              p = teredo_list_lookup((teredo_peerlist */* __restrict  */)list, (struct in6_addr  const  */* __restrict  */)(& ip6->ip6_src),
                                     (_Bool */* __restrict  */)(& __constr_expr_14));
              }
            }
          }
#line 761
          if ((unsigned long )p == (unsigned long )((void *)0)) {
            {
#line 763
            tmp___12 = inet_ntop(10, (void const   */* __restrict  */)(& ip6->ip6_src.__in6_u.__u6_addr8),
                                 (char */* __restrict  */)(b), (socklen_t )sizeof(b));
#line 763
            debug("No peer for %s found. Dropping packet.", tmp___12);
            }
#line 766
            return;
          }
          {
#line 769
          SetMappingFromPacket(p, (struct teredo_packet  const  *)packet);
#line 770
          p->trusted = 1U;
#line 771
          teredo_predecap(tunnel, (teredo_peer */* __restrict  */)p, now);
#line 773
          tmp___13 = IsBubble((struct ip6_hdr  const  *)ip6);
          }
#line 773
          if (! tmp___13) {
            {
#line 774
            (*(tunnel->recv_cb))(tunnel->opaque, (void const   *)ip6, length);
            }
          }
#line 775
          return;
        }
      }
    }
  } else {
#line 783
    if (! (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix != (uint32_t const   )s.addr.teredo.prefix)) {
      {
#line 783
      __assert_fail("((&((const union teredo_addr *)(&ip6->ip6_src))->teredo)->prefix) != s.addr.teredo.prefix",
                    "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c", 783U,
                    "teredo_run_inner");
      }
    }
    {
#line 784
    tmp___17 = IsClient((teredo_tunnel const   *)tunnel);
    }
#line 784
    if (! tmp___17) {
      {
#line 784
      __assert_fail("IsClient (tunnel)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                    784U, "teredo_run_inner");
      }
    }
#line 798
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 801
      p = teredo_list_lookup((teredo_peerlist */* __restrict  */)list, (struct in6_addr  const  */* __restrict  */)(& ip6->ip6_src),
                             (_Bool */* __restrict  */)(& create));
      }
#line 802
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
#line 804
        debug("Out of memory.");
        }
#line 805
        return;
      }
#line 814
      if (create) {
#line 816
        p->mapped_port = (uint16_t )0;
#line 817
        p->mapped_addr = (uint32_t )0;
#line 818
        tmp___19 = 0U;
#line 818
        p->pings = tmp___19;
#line 818
        tmp___18 = tmp___19;
#line 818
        p->bubbles = tmp___18;
#line 818
        p->trusted = tmp___18;
      }
    }
    {
#line 822
    teredo_enqueue_in((teredo_peer */* __restrict  */)p, (void const   */* __restrict  */)ip6,
                      length, (uint32_t )packet->source_ipv4, (uint16_t )packet->source_port);
#line 824
    TouchReceive(p, now);
#line 826
    tmp___20 = CountPing(p, now);
#line 826
    res = tmp___20;
#line 827
    teredo_list_release(list);
    }
#line 829
    if (res == 0) {
      {
#line 830
      SendPing(tunnel->fd, (union teredo_addr  const  *)(& s.addr), (struct in6_addr  const  *)(& ip6->ip6_src));
      }
    }
#line 832
    return;
  }
  {
#line 836
  debug("Dropping packet.");
  }
#line 838
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 839
    teredo_list_release(list);
    }
  }
#line 840
  return;
}
}
#line 844 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_recv_cb(void *o , void const   *p , size_t l ) 
{ 


  {
#line 849
  return;
}
}
#line 852 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_icmpv6_cb(void *o , void const   *p , size_t l , struct in6_addr  const  *d ) 
{ 


  {
#line 859
  return;
}
}
#line 863 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_state_up_cb(void *o , struct in6_addr  const  *a , uint16_t m ) 
{ 


  {
#line 869
  return;
}
}
#line 872 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_state_down_cb(void *o ) 
{ 


  {
#line 875
  return;
}
}
#line 879 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
teredo_tunnel *teredo_create(uint32_t ipv4 , uint16_t port ) 
{ 
  teredo_tunnel *tunnel ;
  void *tmp ;
  struct teredo_peerlist *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 881
  tmp = malloc(sizeof(*tunnel));
#line 881
  tunnel = (teredo_tunnel *)tmp;
  }
#line 882
  if ((unsigned long )tunnel == (unsigned long )((void *)0)) {
#line 883
    return ((teredo_tunnel *)((void *)0));
  }
  {
#line 885
  memset((void *)tunnel, 0, sizeof(*tunnel));
#line 886
  tunnel->state.addr.teredo.prefix = htonl((uint32_t )536936448);
#line 894
  tunnel->state.addr.teredo.client_port = (uint16_t )(~ ((int )port));
#line 895
  tunnel->state.addr.teredo.client_ip = ~ ipv4;
#line 897
  tunnel->state.up = (_Bool)0;
#line 898
  tunnel->ratelimit.count = 1;
#line 900
  tunnel->recv_cb = & teredo_dummy_recv_cb;
#line 901
  tunnel->icmpv6_cb = & teredo_dummy_icmpv6_cb;
#line 903
  tunnel->up_cb = & teredo_dummy_state_up_cb;
#line 904
  tunnel->down_cb = & teredo_dummy_state_down_cb;
#line 907
  tmp___1 = teredo_socket(ipv4, port);
#line 907
  tunnel->fd = tmp___1;
  }
#line 907
  if (tmp___1 != -1) {
    {
#line 909
    tmp___0 = teredo_list_create(1024U, 30U);
#line 909
    tunnel->list = tmp___0;
    }
#line 909
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      {
#line 911
      pthread_rwlock_init((pthread_rwlock_t */* __restrict  */)(& tunnel->state_lock),
                          (pthread_rwlockattr_t const   */* __restrict  */)((void *)0));
#line 912
      d_pthread_mutex_init(& tunnel->ratelimit.lock, (pthread_mutexattr_t *)((void *)0));
      }
#line 913
      return (tunnel);
    }
    {
#line 915
    teredo_close(tunnel->fd);
    }
  }
  {
#line 918
  free((void *)tunnel);
  }
#line 919
  return ((teredo_tunnel *)((void *)0));
}
}
#line 923 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
void teredo_destroy(teredo_tunnel *t ) 
{ 


  {
#line 925
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 925
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  925U, "teredo_destroy");
    }
  }
#line 926
  if (! (t->fd != -1)) {
    {
#line 926
    __assert_fail("t->fd != -1", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  926U, "teredo_destroy");
    }
  }
#line 927
  if (! ((unsigned long )t->list != (unsigned long )((void *)0))) {
    {
#line 927
    __assert_fail("t->list != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  927U, "teredo_destroy");
    }
  }
#line 934
  if ((unsigned long )t->maintenance != (unsigned long )((void *)0)) {
    {
#line 935
    teredo_maintenance_stop(t->maintenance);
    }
  }
#line 938
  if (t->recv.running) {
    {
#line 940
    pthread_cancel(t->recv.thread);
#line 941
    pthread_join(t->recv.thread, (void **)((void *)0));
    }
  }
  {
#line 944
  teredo_list_destroy(t->list);
#line 945
  pthread_rwlock_destroy(& t->state_lock);
#line 946
  pthread_mutex_destroy(& t->ratelimit.lock);
#line 947
  teredo_close(t->fd);
#line 948
  free((void *)t);
  }
#line 949
  return;
}
}
#line 952
static  __attribute__((__noreturn__)) void *teredo_recv_thread(void *t ) ;
#line 952 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void *teredo_recv_thread(void *t ) 
{ 
  teredo_tunnel *tunnel ;
  struct teredo_packet packet ;
  int tmp ;

  {
#line 954
  tunnel = (teredo_tunnel *)t;
  {
#line 956
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 960
    tmp = teredo_wait_recv(tunnel->fd, & packet);
    }
#line 960
    if (tmp == 0) {
      {
#line 962
      pthread_setcancelstate(1, (int *)((void *)0));
#line 963
      teredo_run_inner((teredo_tunnel */* __restrict  */)tunnel, (struct teredo_packet  const  */* __restrict  */)(& packet));
#line 964
      pthread_setcancelstate(0, (int *)((void *)0));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 970 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
int teredo_run_async(teredo_tunnel *t ) 
{ 
  int tmp ;

  {
#line 972
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 972
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  972U, "teredo_run_async");
    }
  }
#line 975
  if (t->recv.running) {
#line 976
    return (-1);
  }
  {
#line 978
  tmp = pthread_create((pthread_t */* __restrict  */)(& t->recv.thread), (pthread_attr_t const   */* __restrict  */)((void *)0),
                       & teredo_recv_thread, (void */* __restrict  */)t);
  }
#line 978
  if (tmp) {
#line 979
    return (-1);
  }
#line 981
  t->recv.running = (_Bool)1;
#line 982
  return (0);
}
}
#line 986 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
void teredo_run(teredo_tunnel *tunnel ) 
{ 
  struct teredo_packet packet ;
  int tmp ;

  {
#line 988
  if (! ((unsigned long )tunnel != (unsigned long )((void *)0))) {
    {
#line 988
    __assert_fail("tunnel != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  988U, "teredo_run");
    }
  }
  {
#line 992
  tmp = teredo_recv(tunnel->fd, & packet);
  }
#line 992
  if (tmp) {
#line 993
    return;
  }
  {
#line 995
  teredo_run_inner((teredo_tunnel */* __restrict  */)tunnel, (struct teredo_packet  const  */* __restrict  */)(& packet));
  }
#line 996
  return;
}
}
#line 999 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
int teredo_set_prefix(teredo_tunnel *t , uint32_t prefix ) 
{ 
  int retval ;

  {
#line 1001
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 1001
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  1001U, "teredo_set_prefix");
    }
  }
#line 1002
  if (! ((prefix & 4278190080U) != 4278190080U)) {
#line 1003
    return (-1);
  }
  {
#line 1005
  retval = 0;
#line 1007
  pthread_rwlock_wrlock(& t->state_lock);
  }
#line 1010
  if ((unsigned long )t->maintenance != (unsigned long )((void *)0)) {
#line 1011
    retval = -1;
  } else {
#line 1014
    t->state.addr.teredo.prefix = prefix;
  }
  {
#line 1016
  pthread_rwlock_unlock(& t->state_lock);
  }
#line 1017
  return (retval);
}
}
#line 1021 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
int teredo_set_cone_flag(teredo_tunnel *t , _Bool cone ) 
{ 
  int retval ;
  uint16_t tmp ;
  uint16_t tmp___0 ;

  {
#line 1023
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 1023
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  1023U, "teredo_set_cone_flag");
    }
  }
  {
#line 1025
  retval = 0;
#line 1027
  pthread_rwlock_wrlock(& t->state_lock);
  }
#line 1030
  if ((unsigned long )t->maintenance != (unsigned long )((void *)0)) {
#line 1031
    retval = -1;
  } else
#line 1034
  if (cone) {
    {
#line 1035
    tmp = htons((uint16_t )32768);
#line 1035
    t->state.addr.teredo.flags = (uint16_t )((int )t->state.addr.teredo.flags | (int )tmp);
    }
  } else {
    {
#line 1037
    tmp___0 = htons((uint16_t )32768);
#line 1037
    t->state.addr.teredo.flags = (uint16_t )((int )t->state.addr.teredo.flags & ~ ((int )tmp___0));
    }
  }
  {
#line 1039
  pthread_rwlock_unlock(& t->state_lock);
  }
#line 1041
  return (retval);
}
}
#line 1045 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
int teredo_set_relay_mode(teredo_tunnel *t ) 
{ 
  int retval ;

  {
  {
#line 1050
  pthread_rwlock_wrlock(& t->state_lock);
  }
#line 1051
  if ((unsigned long )t->maintenance != (unsigned long )((void *)0)) {
#line 1051
    retval = -1;
  } else {
#line 1051
    retval = 0;
  }
  {
#line 1052
  pthread_rwlock_unlock(& t->state_lock);
  }
#line 1058
  return (retval);
}
}
#line 1062 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
int teredo_set_client_mode(teredo_tunnel * __restrict  t , char const   *s , char const   *s2 ) 
{ 
  struct teredo_maintenance *m ;

  {
#line 1066
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 1066
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  1066U, "teredo_set_client_mode");
    }
  }
  {
#line 1068
  pthread_rwlock_wrlock(& t->state_lock);
  }
#line 1069
  if ((unsigned long )t->maintenance != (unsigned long )((void *)0)) {
    {
#line 1071
    pthread_rwlock_unlock(& t->state_lock);
    }
#line 1072
    return (-1);
  }
  {
#line 1076
  m = teredo_maintenance_start(t->fd, & teredo_state_change, (void *)t, s, s2, 0U,
                               0U, 0U, 0U);
#line 1078
  t->maintenance = m;
#line 1079
  pthread_rwlock_unlock(& t->state_lock);
  }
#line 1081
  if ((unsigned long )m != (unsigned long )((void *)0)) {
#line 1082
    return (0);
  }
#line 1088
  return (-1);
}
}
#line 1092 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
void *teredo_set_privdata(teredo_tunnel *t , void *opaque ) 
{ 
  void *prev ;

  {
#line 1094
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 1094
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  1094U, "teredo_set_privdata");
    }
  }
#line 1096
  prev = t->opaque;
#line 1097
  t->opaque = opaque;
#line 1098
  return (prev);
}
}
#line 1105 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
void *teredo_get_privdata(teredo_tunnel const   *t ) 
{ 


  {
#line 1107
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 1107
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  1107U, "teredo_get_privdata");
    }
  }
#line 1109
  return ((void *)t->opaque);
}
}
#line 1116 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
void teredo_set_recv_callback(teredo_tunnel * __restrict  t , void (*cb)(void *opaque ,
                                                                         void const   *data ,
                                                                         size_t len ) ) 
{ 


  {
#line 1118
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 1118
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  1118U, "teredo_set_recv_callback");
    }
  }
#line 1119
  if ((unsigned long )cb != (unsigned long )((void *)0)) {
#line 1119
    t->recv_cb = cb;
  } else {
#line 1119
    t->recv_cb = & teredo_dummy_recv_cb;
  }
#line 1120
  return;
}
}
#line 1126 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
void teredo_set_icmpv6_callback(teredo_tunnel * __restrict  t , void (*cb)(void *opaque ,
                                                                           void const   *data ,
                                                                           size_t len ,
                                                                           struct in6_addr  const  *dst ) ) 
{ 


  {
#line 1129
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 1129
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  1129U, "teredo_set_icmpv6_callback");
    }
  }
#line 1130
  if ((unsigned long )cb != (unsigned long )((void *)0)) {
#line 1130
    t->icmpv6_cb = cb;
  } else {
#line 1130
    t->icmpv6_cb = & teredo_dummy_icmpv6_cb;
  }
#line 1131
  return;
}
}
#line 1134 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
void teredo_set_state_cb(teredo_tunnel * __restrict  t , void (*u)(void *opaque ,
                                                                   struct in6_addr  const  *addr ,
                                                                   uint16_t mtu ) ,
                         void (*d)(void *opaque ) ) 
{ 


  {
#line 1138
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 1138
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  1138U, "teredo_set_state_cb");
    }
  }
  {
#line 1140
  pthread_rwlock_wrlock(& t->state_lock);
  }
#line 1141
  if ((unsigned long )u != (unsigned long )((void *)0)) {
#line 1141
    t->up_cb = u;
  } else {
#line 1141
    t->up_cb = & teredo_dummy_state_up_cb;
  }
#line 1142
  if ((unsigned long )d != (unsigned long )((void *)0)) {
#line 1142
    t->down_cb = d;
  } else {
#line 1142
    t->down_cb = & teredo_dummy_state_down_cb;
  }
  {
#line 1143
  pthread_rwlock_unlock(& t->state_lock);
  }
#line 1149
  return;
}
}
#line 36 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/init.c"
int teredo_startup(_Bool use_client ) 
{ 
  int tmp ;

  {
  {
#line 38
  bindtextdomain("miredo", "/usr/local/share/locale");
#line 47
  tmp = teredo_init_HMAC();
  }
#line 47
  if (tmp == 0) {
#line 48
    return (0);
  }
#line 49
  return (-1);
}
}
#line 53 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/init.c"
void teredo_cleanup(_Bool use_client ) 
{ 


  {
  {
#line 60
  teredo_deinit_HMAC();
  }
#line 61
  return;
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 96 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.h"
int teredo_send_rs(int fd , uint32_t server_ip , unsigned char const   *nonce , _Bool cone ) ;
#line 120
int teredo_parse_ra(teredo_packet const   * __restrict  packet , union teredo_addr * __restrict  newaddr ,
                    _Bool cone , uint16_t * __restrict  mtu ) ;
#line 59 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
static uint8_t const   head[9]  = 
#line 59 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
  {      (uint8_t const   )'`',      (uint8_t const   )'\000',      (uint8_t const   )'\000',      (uint8_t const   )'\000', 
        (uint8_t const   )'\000',      (uint8_t const   )'\000',      (uint8_t const   )';',      (uint8_t const   )'\000', 
        (uint8_t const   )'\000'};
#line 53 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
int teredo_send_bubble(int fd , uint32_t ip , uint16_t port , struct in6_addr  const  *src ,
                       struct in6_addr  const  *dst ) 
{ 
  struct iovec iov[3] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 57
  tmp___2 = is_ipv4_global_unicast(ip);
  }
#line 57
  if (tmp___2) {
    {
#line 64
    iov[0].iov_base = (void *)(head);
#line 64
    iov[0].iov_len = (size_t )8;
#line 64
    iov[1].iov_base = (void *)src;
#line 64
    iov[1].iov_len = (size_t )16;
#line 64
    iov[2].iov_base = (void *)dst;
#line 64
    iov[2].iov_len = (size_t )16;
#line 71
    tmp___1 = teredo_sendv(fd, (struct iovec  const  *)(iov), (size_t )3, ip, port);
    }
#line 71
    if (tmp___1 == 40) {
#line 71
      tmp___0 = 0;
    } else {
#line 71
      tmp___0 = -1;
    }
#line 71
    return (tmp___0);
  }
#line 74
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
int SendBubbleFromDst(int fd , struct in6_addr  const  *dst , _Bool indirect ) 
{ 
  uint32_t ip ;
  uint16_t port ;
  struct in6_addr src ;
  int tmp ;

  {
  {
#line 81
  ip = (uint32_t )(((union teredo_addr  const  *)dst)->teredo.client_ip ^ 4294967295U);
#line 82
  port = (uint16_t )((int const   )((union teredo_addr  const  *)dst)->teredo.client_port ^ 65535);
#line 85
  memcpy((void */* __restrict  */)(src.__in6_u.__u6_addr8), (void const   */* __restrict  */)"\376\200\000\000\000\000\000\000",
         (size_t )8);
#line 87
  teredo_get_nonce((uint32_t )0, ip, port, (uint8_t */* __restrict  */)(src.__in6_u.__u6_addr8 + 8));
#line 88
  src.__in6_u.__u6_addr8[8] = (uint8_t )((int )src.__in6_u.__u6_addr8[8] & 252);
  }
#line 90
  if (indirect) {
    {
#line 92
    ip = (uint32_t )((union teredo_addr  const  *)dst)->teredo.server_ip;
#line 93
    port = htons((uint16_t )3544);
    }
  }
  {
#line 96
  tmp = teredo_send_bubble(fd, ip, port, (struct in6_addr  const  *)(& src), dst);
  }
#line 96
  return (tmp);
}
}
#line 100 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
int CheckBubble(teredo_packet const   *packet ) 
{ 
  struct ip6_hdr  const  *ip6 ;
  struct in6_addr  const  *me ;
  struct in6_addr  const  *it ;
  uint8_t hash[8] ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 102
  ip6 = (struct ip6_hdr  const  *)packet->ip6;
#line 103
  me = & ip6->ip6_dst;
#line 103
  it = & ip6->ip6_src;
#line 107
  teredo_get_nonce((uint32_t )0, (uint32_t )(((union teredo_addr  const  *)it)->teredo.client_ip ^ 4294967295U),
                   (uint16_t )((int const   )((union teredo_addr  const  *)it)->teredo.client_port ^ 65535),
                   (uint8_t */* __restrict  */)(hash));
#line 108
  hash[0] = (uint8_t )((int )hash[0] & 252);
#line 110
  tmp___1 = memcmp((void const   *)(hash), (void const   *)(me->__in6_u.__u6_addr8 + 8),
                   (size_t )8);
  }
#line 110
  if (tmp___1) {
#line 110
    tmp___0 = -1;
  } else {
#line 110
    tmp___0 = 0;
  }
#line 110
  return (tmp___0);
}
}
#line 115 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
static struct in6_addr  const  in6addr_allrouters___0  =    {{{(uint8_t )255, (uint8_t )2, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0,
      (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0,
      (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )2}}};
#line 118 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
int teredo_send_rs(int fd , uint32_t server_ip , unsigned char const   *nonce , _Bool cone ) 
{ 
  uint8_t auth[13] ;
  unsigned int tmp ;
  struct __anonstruct_rs_29 rs ;
  struct iovec iov[2] ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  int tmp___4 ;
  uint16_t tmp___5 ;
  int tmp___6 ;

  {
#line 122
  auth[0] = (uint8_t )0;
#line 122
  auth[1] = (uint8_t )1;
#line 122
  tmp = 2U;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (tmp >= 13U) {
#line 122
      goto while_break;
    }
#line 122
    auth[tmp] = (unsigned char)0;
#line 122
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  iov[0].iov_base = (void *)(auth);
#line 128
  iov[0].iov_len = (size_t )13;
#line 128
  iov[1].iov_base = (void *)(& rs);
#line 128
  iov[1].iov_len = sizeof(rs);
#line 137
  memcpy((void */* __restrict  */)(auth + 4), (void const   */* __restrict  */)nonce,
         (size_t )8);
#line 139
  rs.ip6.ip6_ctlun.ip6_un1.ip6_un1_flow = htonl((uint32_t )1610612736);
#line 140
  rs.ip6.ip6_ctlun.ip6_un1.ip6_un1_plen = htons((uint16_t )(sizeof(rs) - sizeof(rs.ip6)));
#line 141
  rs.ip6.ip6_ctlun.ip6_un1.ip6_un1_nxt = (uint8_t )58;
#line 142
  rs.ip6.ip6_ctlun.ip6_un1.ip6_un1_hlim = (uint8_t )255;
  }
#line 143
  if (cone) {
#line 143
    rs.ip6.ip6_src = (struct in6_addr )teredo_cone;
  } else {
#line 143
    rs.ip6.ip6_src = (struct in6_addr )teredo_restrict;
  }
#line 144
  rs.ip6.ip6_dst = (struct in6_addr )in6addr_allrouters___0;
#line 146
  rs.rs.nd_rs_hdr.icmp6_type = (uint8_t )133;
#line 147
  rs.rs.nd_rs_hdr.icmp6_code = (uint8_t )0;
#line 149
  if (cone) {
    {
#line 149
    tmp___0 = htons((uint16_t )4701);
#line 149
    rs.rs.nd_rs_hdr.icmp6_cksum = tmp___0;
    }
  } else {
    {
#line 149
    tmp___1 = htons((uint16_t )32055);
#line 149
    rs.rs.nd_rs_hdr.icmp6_cksum = tmp___1;
    }
  }
  {
#line 150
  rs.rs.nd_rs_hdr.icmp6_dataun.icmp6_un_data32[0] = (uint32_t )0;
#line 152
  tmp___5 = htons((uint16_t )3544);
#line 152
  tmp___6 = teredo_sendv(fd, (struct iovec  const  *)(iov), sizeof(iov) / sizeof(iov[0]),
                         server_ip, tmp___5);
  }
#line 152
  if (tmp___6 > 0) {
#line 152
    tmp___4 = 0;
  } else {
#line 152
    tmp___4 = -1;
  }
#line 152
  return (tmp___4);
}
}
#line 157 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
int teredo_parse_ra(teredo_packet const   * __restrict  packet , union teredo_addr * __restrict  newaddr ,
                    _Bool cone , uint16_t * __restrict  mtu ) 
{ 
  struct ip6_hdr  const  *ip6 ;
  size_t length ;
  uint16_t tmp ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  struct in6_addr  const  *tmp___0 ;
  int tmp___1 ;
  struct nd_router_advert  const  *ra ;
  uint32_t net_mtu ;
  struct nd_opt_hdr  const  *hdr ;
  size_t optlen ;
  struct nd_opt_prefix_info  const  *pi ;
  char *tmp___2 ;
  struct nd_opt_mtu  const  *mo ;
  uint32_t tmp___3 ;
  uint16_t tmp___4 ;

  {
#line 162
  if (packet->orig_ipv4 == 0U) {
#line 163
    return (-1);
  }
  {
#line 165
  ip6 = (struct ip6_hdr  const  *)packet->ip6;
#line 166
  tmp = ntohs((uint16_t )ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 166
  length = (size_t )tmp;
#line 168
  __a = & ip6->ip6_dst;
  }
#line 168
  if (cone) {
#line 168
    tmp___0 = & teredo_cone;
  } else {
#line 168
    tmp___0 = & teredo_restrict;
  }
#line 168
  __b = tmp___0;
#line 168
  if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 168
    if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 168
      if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 168
        if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 168
          tmp___1 = 1;
        } else {
#line 168
          tmp___1 = 0;
        }
      } else {
#line 168
        tmp___1 = 0;
      }
    } else {
#line 168
      tmp___1 = 0;
    }
  } else {
#line 168
    tmp___1 = 0;
  }
#line 168
  if (tmp___1) {
#line 168
    if ((int const   )ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt != 58) {
#line 172
      return (-1);
    } else
#line 168
    if (length < sizeof(struct nd_router_advert )) {
#line 172
      return (-1);
    }
  } else {
#line 172
    return (-1);
  }
#line 175
  ra = (struct nd_router_advert  const  *)(ip6 + 1);
#line 177
  length -= sizeof(*ra);
#line 179
  if ((int const   )ra->nd_ra_hdr.icmp6_type != 134) {
#line 186
    return (-1);
  } else
#line 179
  if ((int const   )ra->nd_ra_hdr.icmp6_code != 0) {
#line 186
    return (-1);
  } else
#line 179
  if (length < sizeof(struct nd_opt_prefix_info )) {
#line 186
    return (-1);
  }
#line 188
  net_mtu = (uint32_t )0;
#line 189
  newaddr->teredo.server_ip = (uint32_t )0;
#line 193
  hdr = (struct nd_opt_hdr  const  *)(ra + 1);
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! (length >= 8UL)) {
#line 193
      goto while_break;
    }
#line 197
    optlen = (size_t )((int const   )hdr->nd_opt_len << 3);
#line 199
    if (length < optlen) {
#line 201
      return (-1);
    } else
#line 199
    if (optlen == 0UL) {
#line 201
      return (-1);
    }
    {
#line 206
    if ((int const   )hdr->nd_opt_type == 3) {
#line 206
      goto case_3;
    }
#line 227
    if ((int const   )hdr->nd_opt_type == 5) {
#line 227
      goto case_5;
    }
#line 203
    goto switch_break;
    case_3: /* CIL Label */ 
#line 208
    pi = (struct nd_opt_prefix_info  const  *)hdr;
#line 211
    if (optlen < sizeof(*pi)) {
#line 213
      return (-1);
    } else
#line 211
    if ((int const   )pi->nd_opt_pi_prefix_len != 64) {
#line 213
      return (-1);
    }
#line 215
    if (newaddr->teredo.server_ip != 0U) {
      {
#line 218
      tmp___2 = dgettext("miredo", "Multiple Teredo prefixes received");
#line 218
      syslog(3, (char const   *)tmp___2);
      }
#line 219
      return (-1);
    }
    {
#line 222
    memcpy((void */* __restrict  */)newaddr, (void const   */* __restrict  */)(& pi->nd_opt_pi_prefix),
           (size_t )8);
    }
#line 223
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 229
    mo = (struct nd_opt_mtu  const  *)hdr;
#line 234
    net_mtu = ntohl((uint32_t )mo->nd_opt_mtu_mtu);
    }
#line 235
    if (net_mtu < 1280U) {
#line 236
      return (-1);
    } else
#line 235
    if (net_mtu > 65535U) {
#line 236
      return (-1);
    }
#line 238
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 242
    length -= optlen;
#line 193
    hdr = (struct nd_opt_hdr  const  *)((uint8_t const   *)hdr + ((int const   )hdr->nd_opt_len << 3));
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  tmp___3 = htonl((uint32_t )1073644319);
  }
#line 255
  if (newaddr->teredo.prefix == tmp___3) {
    {
#line 256
    newaddr->teredo.prefix = htonl((uint32_t )536936448);
    }
  }
#line 258
  if (! ((newaddr->teredo.prefix & 4278190080U) != 4278190080U)) {
#line 259
    return (-1);
  }
#line 262
  if (cone) {
    {
#line 262
    tmp___4 = htons((uint16_t )32768);
#line 262
    newaddr->teredo.flags = tmp___4;
    }
  } else {
#line 262
    newaddr->teredo.flags = (uint16_t )0;
  }
#line 264
  newaddr->teredo.client_port = (uint16_t )(~ ((int const   )packet->orig_port));
#line 265
  newaddr->teredo.client_ip = (uint32_t )(~ packet->orig_ipv4);
#line 267
  if (net_mtu != 0U) {
#line 268
    *mtu = (uint16_t )net_mtu;
  }
#line 270
  return (0);
}
}
#line 274 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
int SendPing(int fd , union teredo_addr  const  *src , struct in6_addr  const  *dst ) 
{ 
  struct __anonstruct_ping_30 ping ;
  time_t tmp ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 284
  ping.ip6.ip6_ctlun.ip6_un1.ip6_un1_flow = htonl((uint32_t )1610612736);
#line 285
  ping.ip6.ip6_ctlun.ip6_un1.ip6_un1_plen = htons((uint16_t )(sizeof(ping.icmp6) + 18UL));
#line 286
  ping.ip6.ip6_ctlun.ip6_un1.ip6_un1_nxt = (uint8_t )58;
#line 287
  ping.ip6.ip6_ctlun.ip6_un1.ip6_un1_hlim = (uint8_t )128;
#line 288
  ping.ip6.ip6_src = (struct in6_addr )src->ip6;
#line 289
  ping.ip6.ip6_dst = (struct in6_addr )*dst;
#line 291
  ping.icmp6.icmp6_type = (uint8_t )128;
#line 292
  ping.icmp6.icmp6_code = (uint8_t )0;
#line 293
  ping.icmp6.icmp6_cksum = (uint16_t )0;
#line 298
  tmp = time((time_t *)((void *)0));
#line 298
  teredo_get_pinghash((uint32_t )tmp, (struct in6_addr  const  *)(& ping.ip6.ip6_src),
                      (struct in6_addr  const  *)(& ping.ip6.ip6_dst), (uint8_t */* __restrict  */)((uint8_t *)(& ping.icmp6.icmp6_dataun.icmp6_un_data16[0])));
#line 301
  ping.icmp6.icmp6_cksum = icmp6_checksum((struct ip6_hdr  const  *)(& ping.ip6),
                                          (struct icmp6_hdr  const  *)(& ping.icmp6));
#line 303
  tmp___3 = htons((uint16_t )3544);
#line 303
  tmp___4 = teredo_send(fd, (void const   *)(& ping), (sizeof(ping.ip6) + sizeof(ping.icmp6)) + 18UL,
                        (uint32_t )src->teredo.server_ip, tmp___3);
  }
#line 303
  if (tmp___4 > 0) {
#line 303
    tmp___2 = 0;
  } else {
#line 303
    tmp___2 = -1;
  }
#line 303
  return (tmp___2);
}
}
#line 309 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
int CheckPing(teredo_packet const   *packet ) 
{ 
  struct ip6_hdr  const  *ip6 ;
  size_t length ;
  uint16_t tmp ;
  struct icmp6_hdr  const  *icmp6 ;
  struct in6_addr  const  *me ;
  struct in6_addr  const  *it ;
  uint16_t tmp___0 ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp___1 ;
  struct in6_addr  const  *__a___0 ;
  struct in6_addr  const  *__b___0 ;
  int tmp___2 ;
  time_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 311
  ip6 = (struct ip6_hdr  const  *)packet->ip6;
#line 312
  tmp = ntohs((uint16_t )ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 312
  length = (size_t )tmp;
  }
#line 314
  if ((int const   )ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt != 58) {
#line 316
    return (-1);
  } else
#line 314
  if (length < sizeof(struct icmp6_hdr ) + 18UL) {
#line 316
    return (-1);
  }
#line 318
  icmp6 = (struct icmp6_hdr  const  *)(ip6 + 1);
#line 319
  me = & ip6->ip6_dst;
#line 319
  it = & ip6->ip6_src;
#line 321
  if ((int const   )icmp6->icmp6_type == 1) {
#line 335
    length -= sizeof(*icmp6);
#line 336
    ip6 = (struct ip6_hdr  const  *)(icmp6 + 1);
#line 338
    if (length < (sizeof(*ip6) + sizeof(*icmp6)) + 18UL) {
#line 340
      return (-1);
    } else
#line 338
    if ((int const   )ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt != 58) {
#line 340
      return (-1);
    }
    {
#line 342
    tmp___0 = ntohs((uint16_t )ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 342
    length = (size_t )tmp___0;
    }
#line 343
    if (length != sizeof(*icmp6) + 18UL) {
#line 344
      return (-1);
    }
#line 346
    icmp6 = (struct icmp6_hdr  const  *)(ip6 + 1);
#line 348
    __a = & ip6->ip6_src;
#line 348
    __b = me;
#line 348
    if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 348
      if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 348
        if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 348
          if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 348
            tmp___1 = 1;
          } else {
#line 348
            tmp___1 = 0;
          }
        } else {
#line 348
          tmp___1 = 0;
        }
      } else {
#line 348
        tmp___1 = 0;
      }
    } else {
#line 348
      tmp___1 = 0;
    }
#line 348
    if (tmp___1) {
#line 348
      if ((int const   )icmp6->icmp6_type != 128) {
#line 350
        return (-1);
      }
    } else {
#line 350
      return (-1);
    }
#line 374
    __a___0 = & ip6->ip6_dst;
#line 374
    __b___0 = it;
#line 374
    if (__a___0->__in6_u.__u6_addr32[0] == __b___0->__in6_u.__u6_addr32[0]) {
#line 374
      if (__a___0->__in6_u.__u6_addr32[1] == __b___0->__in6_u.__u6_addr32[1]) {
#line 374
        if (__a___0->__in6_u.__u6_addr32[2] == __b___0->__in6_u.__u6_addr32[2]) {
#line 374
          if (__a___0->__in6_u.__u6_addr32[3] == __b___0->__in6_u.__u6_addr32[3]) {
#line 374
            tmp___2 = 1;
          } else {
#line 374
            tmp___2 = 0;
          }
        } else {
#line 374
          tmp___2 = 0;
        }
      } else {
#line 374
        tmp___2 = 0;
      }
    } else {
#line 374
      tmp___2 = 0;
    }
#line 374
    if (! tmp___2) {
#line 375
      return (-1);
    }
#line 377
    me = & ip6->ip6_src;
#line 378
    it = & ip6->ip6_dst;
  } else
#line 381
  if ((int const   )icmp6->icmp6_type != 129) {
#line 382
    return (-1);
  }
#line 384
  if ((int const   )icmp6->icmp6_code != 0) {
#line 385
    return (-1);
  }
  {
#line 387
  tmp___3 = time((time_t *)((void *)0));
#line 387
  tmp___4 = teredo_verify_pinghash((uint32_t )tmp___3, me, it, (uint8_t const   */* __restrict  */)((uint8_t const   *)(& icmp6->icmp6_dataun.icmp6_un_data16[0])));
  }
#line 387
  return (tmp___4);
}
}
#line 394 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
int BuildICMPv6Error(struct icmp6_hdr * __restrict  out , uint8_t type , uint8_t code ,
                     struct ip6_hdr  const  * __restrict  in , size_t inlen ) 
{ 
  struct in6_addr  const  *p ;
  struct in6_addr  const  *__a ;
  int tmp ;

  {
#line 401
  if (inlen < sizeof(*in)) {
#line 402
    return (0);
  }
#line 405
  if ((int const   )in->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58) {
#line 405
    if (((int const   )((struct icmp6_hdr  const  *)(in + 1))->icmp6_type & 128) == 0) {
#line 407
      return (0);
    }
  }
#line 410
  if ((int const   )*((uint8_t const   *)(& in->ip6_dst) + 0) == 255) {
#line 411
    return (0);
  }
#line 413
  p = & in->ip6_src;
#line 416
  if ((int const   )*((uint8_t const   *)p + 0) == 255) {
#line 417
    return (0);
  } else {
#line 416
    __a = p;
#line 416
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 416
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 416
        if (__a->__in6_u.__u6_addr32[2] == 0U) {
#line 416
          if (__a->__in6_u.__u6_addr32[3] == 0U) {
#line 416
            tmp = 1;
          } else {
#line 416
            tmp = 0;
          }
        } else {
#line 416
          tmp = 0;
        }
      } else {
#line 416
        tmp = 0;
      }
    } else {
#line 416
      tmp = 0;
    }
#line 416
    if (tmp) {
#line 417
      return (0);
    }
  }
#line 419
  out->icmp6_type = type;
#line 420
  out->icmp6_code = code;
#line 421
  out->icmp6_cksum = (uint16_t )0;
#line 422
  out->icmp6_dataun.icmp6_un_data32[0] = (uint32_t )0;
#line 424
  if (inlen > 1280UL - (sizeof(struct ip6_hdr ) + sizeof(struct icmp6_hdr ))) {
#line 425
    inlen = 1280UL - (sizeof(struct ip6_hdr ) + sizeof(struct icmp6_hdr ));
  }
  {
#line 428
  memcpy((void */* __restrict  */)(out + 1), (void const   */* __restrict  */)in,
         inlen);
  }
#line 430
  return ((int )(sizeof(*out) + inlen));
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 39 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t readv(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 50
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 193 "/usr/include/net/if.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) if_nametoindex)(char const   *__ifname ) ;
#line 194
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) if_indextoname)(unsigned int __ifindex ,
                                                                                       char *__ifname ) ;
#line 53 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
char const   os_driver[6]  = {      (char const   )'L',      (char const   )'i',      (char const   )'n',      (char const   )'u', 
        (char const   )'x',      (char const   )'\000'};
#line 93 "../libtun6/tun6.h"
int ( __attribute__((__nonnull__)) tun6_delAddress)(tun6 * __restrict  t , struct in6_addr  const  * __restrict  addr ,
                                                    unsigned int prefixlen ) ;
#line 100
int ( __attribute__((__nonnull__)) tun6_delRoute)(tun6 * __restrict  t , struct in6_addr  const  * __restrict  addr ,
                                                  unsigned int prefix_len , int rel_metric ) ;
#line 103
int ( __attribute__((__nonnull__)) tun6_registerReadSet)(tun6 const   * __restrict  t ,
                                                         fd_set * __restrict  readset )  __attribute__((__pure__)) ;
#line 106
int ( __attribute__((__nonnull__)) tun6_recv)(tun6 * __restrict  t , fd_set const   * __restrict  readset ,
                                              void *buffer , size_t maxlen ) ;
#line 172 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
static char const   tundev[13]  = 
#line 172 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
  {      (char const   )'/',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'/',      (char const   )'n',      (char const   )'e',      (char const   )'t', 
        (char const   )'/',      (char const   )'t',      (char const   )'u',      (char const   )'n', 
        (char const   )'\000'};
#line 151 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
tun6 *( __attribute__((__warn_unused_result__)) tun6_create)(char const   *req_name ) 
{ 
  tun6 *t ;
  void *tmp ;
  int reqfd ;
  int tmp___0 ;
  struct ifreq req ;
  int tmp___2 ;
  size_t tmp___3 ;
  int fd ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int id ;
  unsigned int tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 153
  bindtextdomain("miredo", "/usr/local/share/locale");
#line 154
  tmp = malloc(sizeof(*t));
#line 154
  t = (tun6 *)tmp;
  }
#line 155
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 156
    return ((tun6 *)((void *)0));
  }
  {
#line 157
  memset((void *)t, 0, sizeof(*t));
#line 159
  tmp___0 = socket(10, 2, 0);
#line 159
  t->reqfd = tmp___0;
#line 159
  reqfd = tmp___0;
  }
#line 160
  if (reqfd == -1) {
    {
#line 162
    free((void *)t);
    }
#line 163
    return ((tun6 *)((void *)0));
  }
  {
#line 166
  fcntl(reqfd, 2, 1);
#line 173
  req.ifr_ifrn.ifrn_name[0] = (char)0;
#line 173
  req.ifr_ifrn.ifrn_name[1] = (char)0;
#line 173
  req.ifr_ifrn.ifrn_name[2] = (char)0;
#line 173
  req.ifr_ifrn.ifrn_name[3] = (char)0;
#line 173
  req.ifr_ifrn.ifrn_name[4] = (char)0;
#line 173
  req.ifr_ifrn.ifrn_name[5] = (char)0;
#line 173
  req.ifr_ifrn.ifrn_name[6] = (char)0;
#line 173
  req.ifr_ifrn.ifrn_name[7] = (char)0;
#line 173
  req.ifr_ifrn.ifrn_name[8] = (char)0;
#line 173
  req.ifr_ifrn.ifrn_name[9] = (char)0;
#line 173
  req.ifr_ifrn.ifrn_name[10] = (char)0;
#line 173
  req.ifr_ifrn.ifrn_name[11] = (char)0;
#line 173
  req.ifr_ifrn.ifrn_name[12] = (char)0;
#line 173
  req.ifr_ifrn.ifrn_name[13] = (char)0;
#line 173
  req.ifr_ifrn.ifrn_name[14] = (char)0;
#line 173
  req.ifr_ifrn.ifrn_name[15] = (char)0;
#line 173
  req.ifr_ifru.ifru_flags = (short)1;
  }
#line 178
  if ((unsigned long )req_name != (unsigned long )((void *)0)) {
    {
#line 178
    tmp___3 = strlcpy(req.ifr_ifrn.ifrn_name, req_name, sizeof(req.ifr_ifrn.ifrn_name));
    }
#line 178
    if (tmp___3 >= sizeof(req.ifr_ifrn.ifrn_name)) {
#line 178
      tmp___2 = -1;
    } else {
#line 178
      tmp___2 = 0;
    }
#line 178
    if (tmp___2) {
      {
#line 180
      free((void *)t);
      }
#line 181
      return ((tun6 *)((void *)0));
    }
  }
  {
#line 184
  tmp___4 = open(tundev, 2);
#line 184
  fd = tmp___4;
  }
#line 185
  if (fd == -1) {
    {
#line 187
    tmp___5 = dgettext("miredo", "Tunneling driver error (%s): %m");
#line 187
    syslog(3, (char const   *)tmp___5, tundev);
#line 188
    close(reqfd);
#line 189
    free((void *)t);
    }
#line 190
    return ((tun6 *)((void *)0));
  }
  {
#line 194
  tmp___9 = ioctl(fd, (unsigned long )(((1U << 30) | (unsigned int )(84 << 8)) | 202U) | (sizeof(int ) << 16),
                  (void *)(& req));
  }
#line 194
  if (tmp___9) {
    {
#line 196
    tmp___6 = dgettext("miredo", "Tunneling driver error (%s): %m");
#line 196
    syslog(3, (char const   *)tmp___6, "TUNSETIFF");
#line 197
    tmp___8 = __errno_location();
    }
#line 197
    if (*tmp___8 == 16) {
      {
#line 198
      tmp___7 = dgettext("miredo", "Please make sure another instance of the program is not already running.");
#line 198
      syslog(6, (char const   *)tmp___7);
      }
    }
#line 201
    goto error;
  }
  {
#line 204
  tmp___10 = if_nametoindex((char const   *)(req.ifr_ifrn.ifrn_name));
#line 204
  id = (int )tmp___10;
  }
#line 205
  if (id == 0) {
#line 206
    goto error;
  }
  {
#line 334
  fcntl(fd, 2, 1);
#line 338
  t->id = id;
#line 339
  t->fd = fd;
  }
#line 340
  return (t);
  error: 
  {
#line 343
  close(reqfd);
  }
#line 344
  if (fd != -1) {
    {
#line 345
    close(fd);
    }
  }
  {
#line 346
  tmp___11 = dgettext("miredo", "%s tunneling interface creation failure");
#line 346
  syslog(3, (char const   *)tmp___11, os_driver);
#line 347
  free((void *)t);
  }
#line 348
  return ((tun6 *)((void *)0));
}
}
#line 359 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
void ( __attribute__((__nonnull__)) tun6_destroy)(tun6 *t ) 
{ 


  {
#line 361
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 361
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  361U, "tun6_destroy");
    }
  }
#line 362
  if (! (t->fd != -1)) {
    {
#line 362
    __assert_fail("t->fd != -1", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  362U, "tun6_destroy");
    }
  }
#line 363
  if (! (t->reqfd != -1)) {
    {
#line 363
    __assert_fail("t->reqfd != -1", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  363U, "tun6_destroy");
    }
  }
#line 364
  if (! (t->id != 0)) {
    {
#line 364
    __assert_fail("t->id != 0", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  364U, "tun6_destroy");
    }
  }
  {
#line 366
  tun6_setState(t, (_Bool)0);
#line 392
  close(t->fd);
#line 393
  close(t->reqfd);
#line 394
  free((void *)t);
  }
#line 395
  return;
}
}
#line 406 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
int ( __attribute__((__nonnull__)) tun6_getId)(tun6 const   *t ) 
{ 


  {
#line 408
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 408
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  408U, "tun6_getId");
    }
  }
#line 409
  if (! (t->id != 0)) {
    {
#line 409
    __assert_fail("t-> id != 0", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  409U, "tun6_getId");
    }
  }
#line 411
  return ((int )t->id);
}
}
#line 416 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
static int proc_write_zero(char const   *path___0 ) 
{ 
  int fd ;
  int tmp ;
  int retval ;
  ssize_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 419
  tmp = open(path___0, 1);
#line 419
  fd = tmp;
  }
#line 420
  if (fd == -1) {
#line 421
    return (-1);
  }
  {
#line 423
  retval = 0;
#line 425
  tmp___0 = write(fd, (void const   *)"0", (size_t )1);
  }
#line 425
  if (tmp___0 != 1L) {
#line 426
    retval = -1;
  }
  {
#line 427
  tmp___1 = close(fd);
  }
#line 427
  if (tmp___1) {
#line 428
    retval = -1;
  }
#line 430
  return (retval);
}
}
#line 440 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
int ( __attribute__((__nonnull__)) tun6_setState)(tun6 *t , _Bool up ) 
{ 
  struct ifreq req ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 443
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 443
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  443U, "tun6_setState");
    }
  }
#line 444
  if (! (t->id != 0)) {
    {
#line 444
    __assert_fail("t-> id != 0", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  444U, "tun6_setState");
    }
  }
  {
#line 447
  memset((void *)(& req), 0, sizeof(req));
#line 448
  tmp = if_indextoname((unsigned int )t->id, req.ifr_ifrn.ifrn_name);
  }
#line 448
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 450
    return (-1);
  } else {
    {
#line 448
    tmp___0 = ioctl(t->reqfd, 35091UL, & req);
    }
#line 448
    if (tmp___0) {
#line 450
      return (-1);
    }
  }
#line 453
  req.ifr_ifru.ifru_flags = (short )((int )req.ifr_ifru.ifru_flags | 128);
#line 454
  req.ifr_ifru.ifru_flags = (short )((int )req.ifr_ifru.ifru_flags & -4099);
#line 455
  if (up) {
#line 456
    req.ifr_ifru.ifru_flags = (short )((int )req.ifr_ifru.ifru_flags | 65);
  } else {
#line 458
    req.ifr_ifru.ifru_flags = (short )((int )req.ifr_ifru.ifru_flags & -66);
  }
  {
#line 461
  tmp___1 = if_indextoname((unsigned int )t->id, req.ifr_ifrn.ifrn_name);
  }
#line 461
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 463
    return (-1);
  } else {
    {
#line 461
    tmp___2 = ioctl(t->reqfd, 35092UL, & req);
    }
#line 461
    if (tmp___2) {
#line 463
      return (-1);
    }
  }
#line 465
  return (0);
}
}
#line 506 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
static int _iface_addr(int reqfd , int id , _Bool add , struct in6_addr  const  *addr ,
                       unsigned int prefix_len ) 
{ 
  void *req ;
  long cmd ;
  union __anonunion_r_47 r ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 510
  req = (void *)0;
#line 511
  cmd = 0L;
#line 513
  if (! (reqfd != -1)) {
    {
#line 513
    __assert_fail("reqfd != -1", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  513U, "_iface_addr");
    }
  }
#line 514
  if (! (id != 0)) {
    {
#line 514
    __assert_fail("id != 0", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  514U, "_iface_addr");
    }
  }
#line 516
  if (prefix_len > 128U) {
#line 517
    return (-1);
  } else
#line 516
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 517
    return (-1);
  }
  {
#line 529
  memset((void *)(& r), 0, sizeof(r));
#line 530
  r.req6.ifr6_ifindex = id;
#line 531
  memcpy((void */* __restrict  */)(& r.req6.ifr6_addr), (void const   */* __restrict  */)addr,
         sizeof(r.req6.ifr6_addr));
#line 532
  r.req6.ifr6_prefixlen = prefix_len;
  }
#line 534
  if (add) {
#line 534
    cmd = 35094L;
  } else {
#line 534
    cmd = 35126L;
  }
  {
#line 535
  req = (void *)(& r);
#line 581
  tmp___1 = ioctl(reqfd, (unsigned long )cmd, req);
  }
#line 581
  if (tmp___1 >= 0) {
#line 581
    tmp___0 = 0;
  } else {
#line 581
    tmp___0 = -1;
  }
#line 581
  return (tmp___0);
}
}
#line 585 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
static int _iface_route(int reqfd , int id , _Bool add , struct in6_addr  const  *addr ,
                        unsigned int prefix_len , int rel_metric ) 
{ 
  int retval ;
  struct in6_rtmsg req6 ;
  int tmp ;
  int tmp___0 ;

  {
#line 589
  if (! (reqfd != -1)) {
    {
#line 589
    __assert_fail("reqfd != -1", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  589U, "_iface_route");
    }
  }
#line 590
  if (! (id != 0)) {
    {
#line 590
    __assert_fail("id != 0", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  590U, "_iface_route");
    }
  }
#line 592
  if (prefix_len > 128U) {
#line 593
    return (-1);
  } else
#line 592
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 593
    return (-1);
  }
  {
#line 595
  retval = -1;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[0] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[1] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[2] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[3] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[4] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[5] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[6] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[7] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[8] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[9] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[10] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[11] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[12] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[13] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[14] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[15] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[0] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[1] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[2] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[3] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[4] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[5] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[6] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[7] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[8] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[9] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[10] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[11] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[12] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[13] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[14] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[15] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[0] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[1] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[2] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[3] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[4] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[5] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[6] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[7] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[8] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[9] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[10] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[11] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[12] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[13] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[14] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[15] = (unsigned char)0;
#line 601
  req6.rtmsg_type = 0U;
#line 601
  req6.rtmsg_dst_len = (unsigned short )prefix_len;
#line 601
  req6.rtmsg_src_len = (unsigned short)0;
#line 601
  req6.rtmsg_metric = (u_int32_t )(1024 + rel_metric);
#line 601
  req6.rtmsg_info = 0UL;
#line 601
  req6.rtmsg_flags = (u_int32_t )1;
#line 601
  req6.rtmsg_ifindex = id;
#line 612
  memcpy((void */* __restrict  */)(& req6.rtmsg_dst), (void const   */* __restrict  */)addr,
         sizeof(req6.rtmsg_dst));
  }
#line 613
  if (prefix_len == 128U) {
#line 614
    req6.rtmsg_flags |= 4U;
  }
#line 617
  if (add) {
#line 617
    tmp = 35083;
  } else {
#line 617
    tmp = 35084;
  }
  {
#line 617
  tmp___0 = ioctl(reqfd, (unsigned long )tmp, & req6);
  }
#line 617
  if (tmp___0 == 0) {
#line 618
    retval = 0;
  }
#line 710
  return (retval);
}
}
#line 720 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
int ( __attribute__((__nonnull__)) tun6_addAddress)(tun6 * __restrict  t , struct in6_addr  const  * __restrict  addr ,
                                                    unsigned int prefixlen ) 
{ 
  int res ;
  int tmp ;
  char ifname[16] ;
  char proc_path[57] ;
  unsigned int tmp___0 ;
  char *tmp___1 ;

  {
#line 723
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 723
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  723U, "tun6_addAddress");
    }
  }
  {
#line 725
  tmp = _iface_addr(t->reqfd, t->id, (_Bool)1, (struct in6_addr  const  *)addr, prefixlen);
#line 725
  res = tmp;
  }
#line 729
  if (res == 0) {
    {
#line 729
    tmp___1 = if_indextoname((unsigned int )t->id, ifname);
    }
#line 729
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 733
      proc_path[0] = (char )'/';
#line 733
      proc_path[1] = (char )'p';
#line 733
      proc_path[2] = (char )'r';
#line 733
      proc_path[3] = (char )'o';
#line 733
      proc_path[4] = (char )'c';
#line 733
      proc_path[5] = (char )'/';
#line 733
      proc_path[6] = (char )'s';
#line 733
      proc_path[7] = (char )'y';
#line 733
      proc_path[8] = (char )'s';
#line 733
      proc_path[9] = (char )'/';
#line 733
      proc_path[10] = (char )'n';
#line 733
      proc_path[11] = (char )'e';
#line 733
      proc_path[12] = (char )'t';
#line 733
      proc_path[13] = (char )'/';
#line 733
      proc_path[14] = (char )'i';
#line 733
      proc_path[15] = (char )'p';
#line 733
      proc_path[16] = (char )'v';
#line 733
      proc_path[17] = (char )'6';
#line 733
      proc_path[18] = (char )'/';
#line 733
      proc_path[19] = (char )'c';
#line 733
      proc_path[20] = (char )'o';
#line 733
      proc_path[21] = (char )'n';
#line 733
      proc_path[22] = (char )'f';
#line 733
      proc_path[23] = (char )'/';
#line 733
      proc_path[24] = (char )'\000';
#line 733
      tmp___0 = 25U;
      {
#line 733
      while (1) {
        while_continue: /* CIL Label */ ;
#line 733
        if (tmp___0 >= 57U) {
#line 733
          goto while_break;
        }
#line 733
        proc_path[tmp___0] = (char)0;
#line 733
        tmp___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 745
      snprintf((char */* __restrict  */)(proc_path + 24), sizeof(proc_path) - 24UL,
               (char const   */* __restrict  */)"%s/accept_redirects", ifname);
#line 747
      proc_write_zero((char const   *)(proc_path));
      }
    }
  }
#line 752
  return (res);
}
}
#line 761 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
int ( __attribute__((__nonnull__)) tun6_delAddress)(tun6 * __restrict  t , struct in6_addr  const  * __restrict  addr ,
                                                    unsigned int prefixlen ) 
{ 
  int tmp ;

  {
#line 764
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 764
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  764U, "tun6_delAddress");
    }
  }
  {
#line 766
  tmp = _iface_addr(t->reqfd, t->id, (_Bool)0, (struct in6_addr  const  *)addr, prefixlen);
  }
#line 766
  return (tmp);
}
}
#line 780 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
int ( __attribute__((__nonnull__)) tun6_addRoute)(tun6 * __restrict  t , struct in6_addr  const  * __restrict  addr ,
                                                  unsigned int prefix_len , int rel_metric ) 
{ 
  int tmp ;

  {
#line 784
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 784
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  784U, "tun6_addRoute");
    }
  }
  {
#line 786
  tmp = _iface_route(t->reqfd, t->id, (_Bool)1, (struct in6_addr  const  *)addr, prefix_len,
                     rel_metric);
  }
#line 786
  return (tmp);
}
}
#line 796 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
int ( __attribute__((__nonnull__)) tun6_delRoute)(tun6 * __restrict  t , struct in6_addr  const  * __restrict  addr ,
                                                  unsigned int prefix_len , int rel_metric ) 
{ 
  int tmp ;

  {
#line 800
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 800
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  800U, "tun6_delRoute");
    }
  }
  {
#line 802
  tmp = _iface_route(t->reqfd, t->id, (_Bool)0, (struct in6_addr  const  *)addr, prefix_len,
                     rel_metric);
  }
#line 802
  return (tmp);
}
}
#line 812 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
int ( __attribute__((__nonnull__)) tun6_setMTU)(tun6 *t , unsigned int mtu ) 
{ 
  struct ifreq req ;
  char *tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 815
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 815
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  815U, "tun6_setMTU");
    }
  }
#line 817
  if (mtu < 1280U) {
#line 818
    return (-1);
  } else
#line 817
  if (mtu > 65535U) {
#line 818
    return (-1);
  }
  {
#line 820
  req.ifr_ifrn.ifrn_name[0] = (char)0;
#line 820
  req.ifr_ifrn.ifrn_name[1] = (char)0;
#line 820
  req.ifr_ifrn.ifrn_name[2] = (char)0;
#line 820
  req.ifr_ifrn.ifrn_name[3] = (char)0;
#line 820
  req.ifr_ifrn.ifrn_name[4] = (char)0;
#line 820
  req.ifr_ifrn.ifrn_name[5] = (char)0;
#line 820
  req.ifr_ifrn.ifrn_name[6] = (char)0;
#line 820
  req.ifr_ifrn.ifrn_name[7] = (char)0;
#line 820
  req.ifr_ifrn.ifrn_name[8] = (char)0;
#line 820
  req.ifr_ifrn.ifrn_name[9] = (char)0;
#line 820
  req.ifr_ifrn.ifrn_name[10] = (char)0;
#line 820
  req.ifr_ifrn.ifrn_name[11] = (char)0;
#line 820
  req.ifr_ifrn.ifrn_name[12] = (char)0;
#line 820
  req.ifr_ifrn.ifrn_name[13] = (char)0;
#line 820
  req.ifr_ifrn.ifrn_name[14] = (char)0;
#line 820
  req.ifr_ifrn.ifrn_name[15] = (char)0;
#line 820
  req.ifr_ifru.ifru_mtu = (int )mtu;
#line 824
  tmp = if_indextoname((unsigned int )t->id, req.ifr_ifrn.ifrn_name);
  }
#line 824
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 825
    return (-1);
  }
  {
#line 827
  tmp___2 = ioctl(t->reqfd, 35106UL, & req);
  }
#line 827
  if (tmp___2) {
#line 827
    tmp___1 = -1;
  } else {
#line 827
    tmp___1 = 0;
  }
#line 827
  return (tmp___1);
}
}
#line 843
int ( __attribute__((__nonnull__)) tun6_registerReadSet)(tun6 const   * __restrict  t ,
                                                         fd_set * __restrict  readset )  __attribute__((__pure__)) ;
#line 843 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
int ( __attribute__((__nonnull__)) tun6_registerReadSet)(tun6 const   * __restrict  t ,
                                                         fd_set * __restrict  readset ) 
{ 


  {
#line 846
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 846
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  846U, "tun6_registerReadSet");
    }
  }
#line 848
  if (t->fd >= 1024) {
#line 849
    return (-1);
  }
#line 851
  readset->fds_bits[t->fd / (int const   )(8 * (int )sizeof(__fd_mask ))] |= 1L << t->fd % (int const   )(8 * (int )sizeof(__fd_mask ));
#line 852
  return ((int )t->fd);
}
}
#line 865 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
__inline static int tun6_recv_inner(int fd , void *buffer , size_t maxlen ) 
{ 
  struct iovec vect[2] ;
  tun_head_t head___3 ;
  int len ;
  ssize_t tmp ;
  uint16_t tmp___0 ;

  {
  {
#line 871
  vect[0].iov_base = (void *)((char *)(& head___3));
#line 872
  vect[0].iov_len = sizeof(head___3);
#line 873
  vect[1].iov_base = (void *)((char *)buffer);
#line 874
  vect[1].iov_len = maxlen;
#line 876
  tmp = readv(fd, (struct iovec  const  *)(vect), 2);
#line 876
  len = (int )tmp;
  }
#line 877
  if (len < (int )sizeof(head___3)) {
#line 879
    return (-1);
  } else {
    {
#line 877
    tmp___0 = htons((uint16_t )34525);
    }
#line 877
    if (! ((int )head___3.proto == (int )tmp___0)) {
#line 879
      return (-1);
    }
  }
#line 881
  return ((int )((unsigned long )len - sizeof(head___3)));
}
}
#line 895 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
int ( __attribute__((__nonnull__)) tun6_recv)(tun6 * __restrict  t , fd_set const   * __restrict  readset ,
                                              void *buffer , size_t maxlen ) 
{ 
  int fd ;
  int *tmp ;
  int tmp___0 ;

  {
#line 898
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 898
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  898U, "tun6_recv");
    }
  }
#line 900
  fd = t->fd;
#line 901
  if (fd < 1024) {
#line 901
    if (! ((readset->fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
      {
#line 903
      tmp = __errno_location();
#line 903
      *tmp = 11;
      }
#line 904
      return (-1);
    }
  }
  {
#line 906
  tmp___0 = tun6_recv_inner(fd, buffer, maxlen);
  }
#line 906
  return (tmp___0);
}
}
#line 919 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
int ( __attribute__((__nonnull__)) tun6_wait_recv)(tun6 * __restrict  t , void *buffer ,
                                                   size_t maxlen ) 
{ 
  int tmp ;

  {
  {
#line 922
  tmp = tun6_recv_inner(t->fd, buffer, maxlen);
  }
#line 922
  return (tmp);
}
}
#line 934 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
int ( __attribute__((__nonnull__)) tun6_send)(tun6 * __restrict  t , void const   *packet ,
                                              size_t len ) 
{ 
  tun_head_t head___3 ;
  uint16_t tmp ;
  struct iovec vect[2] ;
  int val ;
  ssize_t tmp___0 ;

  {
#line 937
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
#line 937
    __assert_fail("t != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  937U, "tun6_send");
    }
  }
#line 939
  if (len > 65535UL) {
#line 940
    return (-1);
  }
  {
#line 942
  tmp = htons((uint16_t )34525);
#line 942
  head___3.flags = (uint16_t )0;
#line 942
  head___3.proto = tmp;
#line 944
  vect[0].iov_base = (void *)((char *)(& head___3));
#line 945
  vect[0].iov_len = sizeof(head___3);
#line 946
  vect[1].iov_base = (void *)((char *)packet);
#line 947
  vect[1].iov_len = len;
#line 949
  tmp___0 = writev(t->fd, (struct iovec  const  *)(vect), 2);
#line 949
  val = (int )tmp___0;
  }
#line 950
  if (val == -1) {
#line 951
    return (-1);
  }
#line 953
  val = (int )((unsigned long )val - sizeof(head___3));
#line 954
  if (val < 0) {
#line 955
    return (-1);
  }
#line 957
  return (val);
}
}
#line 146 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.c"
static void md5_process(md5_state_t *pms , md5_byte_t const   *data ) 
{ 
  md5_word_t a ;
  md5_word_t b ;
  md5_word_t c ;
  md5_word_t d ;
  md5_word_t t ;
  md5_word_t xbuf[16] ;
  md5_word_t const   *X ;

  {
#line 149
  a = pms->abcd[0];
#line 149
  b = pms->abcd[1];
#line 149
  c = pms->abcd[2];
#line 149
  d = pms->abcd[3];
#line 179
  if (! ((data - (md5_byte_t const   *)0) & 3L)) {
#line 181
    X = (md5_word_t const   *)data;
  } else {
    {
#line 184
    memcpy((void */* __restrict  */)(xbuf), (void const   */* __restrict  */)data,
           (size_t )64);
#line 185
    X = (md5_word_t const   *)(xbuf);
    }
  }
#line 222
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 0)) + 3614090360U;
#line 222
  a = ((t << 7) | (t >> 25)) + b;
#line 223
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 1)) + 3905402710U;
#line 223
  d = ((t << 12) | (t >> 20)) + a;
#line 224
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 2)) + 606105819U;
#line 224
  c = ((t << 17) | (t >> 15)) + d;
#line 225
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 3)) + 3250441966U;
#line 225
  b = ((t << 22) | (t >> 10)) + c;
#line 226
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 4)) + 4118548399U;
#line 226
  a = ((t << 7) | (t >> 25)) + b;
#line 227
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 5)) + 1200080426U;
#line 227
  d = ((t << 12) | (t >> 20)) + a;
#line 228
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 6)) + 2821735955U;
#line 228
  c = ((t << 17) | (t >> 15)) + d;
#line 229
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 7)) + 4249261313U;
#line 229
  b = ((t << 22) | (t >> 10)) + c;
#line 230
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 8)) + 1770035416U;
#line 230
  a = ((t << 7) | (t >> 25)) + b;
#line 231
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 9)) + 2336552879U;
#line 231
  d = ((t << 12) | (t >> 20)) + a;
#line 232
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 10)) + 4294925233U;
#line 232
  c = ((t << 17) | (t >> 15)) + d;
#line 233
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 11)) + 2304563134U;
#line 233
  b = ((t << 22) | (t >> 10)) + c;
#line 234
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 12)) + 1804603682U;
#line 234
  a = ((t << 7) | (t >> 25)) + b;
#line 235
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 13)) + 4254626195U;
#line 235
  d = ((t << 12) | (t >> 20)) + a;
#line 236
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 14)) + 2792965006U;
#line 236
  c = ((t << 17) | (t >> 15)) + d;
#line 237
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 15)) + 1236535329U;
#line 237
  b = ((t << 22) | (t >> 10)) + c;
#line 248
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 1)) + 4129170786U;
#line 248
  a = ((t << 5) | (t >> 27)) + b;
#line 249
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 6)) + 3225465664U;
#line 249
  d = ((t << 9) | (t >> 23)) + a;
#line 250
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 11)) + 643717713U;
#line 250
  c = ((t << 14) | (t >> 18)) + d;
#line 251
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 0)) + 3921069994U;
#line 251
  b = ((t << 20) | (t >> 12)) + c;
#line 252
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 5)) + 3593408605U;
#line 252
  a = ((t << 5) | (t >> 27)) + b;
#line 253
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 10)) + 38016083U;
#line 253
  d = ((t << 9) | (t >> 23)) + a;
#line 254
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 15)) + 3634488961U;
#line 254
  c = ((t << 14) | (t >> 18)) + d;
#line 255
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 4)) + 3889429448U;
#line 255
  b = ((t << 20) | (t >> 12)) + c;
#line 256
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 9)) + 568446438U;
#line 256
  a = ((t << 5) | (t >> 27)) + b;
#line 257
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 14)) + 3275163606U;
#line 257
  d = ((t << 9) | (t >> 23)) + a;
#line 258
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 3)) + 4107603335U;
#line 258
  c = ((t << 14) | (t >> 18)) + d;
#line 259
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 8)) + 1163531501U;
#line 259
  b = ((t << 20) | (t >> 12)) + c;
#line 260
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 13)) + 2850285829U;
#line 260
  a = ((t << 5) | (t >> 27)) + b;
#line 261
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 2)) + 4243563512U;
#line 261
  d = ((t << 9) | (t >> 23)) + a;
#line 262
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 7)) + 1735328473U;
#line 262
  c = ((t << 14) | (t >> 18)) + d;
#line 263
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 12)) + 2368359562U;
#line 263
  b = ((t << 20) | (t >> 12)) + c;
#line 274
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 5)) + 4294588738U;
#line 274
  a = ((t << 4) | (t >> 28)) + b;
#line 275
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 8)) + 2272392833U;
#line 275
  d = ((t << 11) | (t >> 21)) + a;
#line 276
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 11)) + 1839030562U;
#line 276
  c = ((t << 16) | (t >> 16)) + d;
#line 277
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 14)) + 4259657740U;
#line 277
  b = ((t << 23) | (t >> 9)) + c;
#line 278
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 1)) + 2763975236U;
#line 278
  a = ((t << 4) | (t >> 28)) + b;
#line 279
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 4)) + 1272893353U;
#line 279
  d = ((t << 11) | (t >> 21)) + a;
#line 280
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 7)) + 4139469664U;
#line 280
  c = ((t << 16) | (t >> 16)) + d;
#line 281
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 10)) + 3200236656U;
#line 281
  b = ((t << 23) | (t >> 9)) + c;
#line 282
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 13)) + 681279174U;
#line 282
  a = ((t << 4) | (t >> 28)) + b;
#line 283
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 0)) + 3936430074U;
#line 283
  d = ((t << 11) | (t >> 21)) + a;
#line 284
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 3)) + 3572445317U;
#line 284
  c = ((t << 16) | (t >> 16)) + d;
#line 285
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 6)) + 76029189U;
#line 285
  b = ((t << 23) | (t >> 9)) + c;
#line 286
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 9)) + 3654602809U;
#line 286
  a = ((t << 4) | (t >> 28)) + b;
#line 287
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 12)) + 3873151461U;
#line 287
  d = ((t << 11) | (t >> 21)) + a;
#line 288
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 15)) + 530742520U;
#line 288
  c = ((t << 16) | (t >> 16)) + d;
#line 289
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 2)) + 3299628645U;
#line 289
  b = ((t << 23) | (t >> 9)) + c;
#line 300
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 0)) + 4096336452U;
#line 300
  a = ((t << 6) | (t >> 26)) + b;
#line 301
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 7)) + 1126891415U;
#line 301
  d = ((t << 10) | (t >> 22)) + a;
#line 302
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 14)) + 2878612391U;
#line 302
  c = ((t << 15) | (t >> 17)) + d;
#line 303
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 5)) + 4237533241U;
#line 303
  b = ((t << 21) | (t >> 11)) + c;
#line 304
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 12)) + 1700485571U;
#line 304
  a = ((t << 6) | (t >> 26)) + b;
#line 305
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 3)) + 2399980690U;
#line 305
  d = ((t << 10) | (t >> 22)) + a;
#line 306
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 10)) + 4293915773U;
#line 306
  c = ((t << 15) | (t >> 17)) + d;
#line 307
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 1)) + 2240044497U;
#line 307
  b = ((t << 21) | (t >> 11)) + c;
#line 308
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 8)) + 1873313359U;
#line 308
  a = ((t << 6) | (t >> 26)) + b;
#line 309
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 15)) + 4264355552U;
#line 309
  d = ((t << 10) | (t >> 22)) + a;
#line 310
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 6)) + 2734768916U;
#line 310
  c = ((t << 15) | (t >> 17)) + d;
#line 311
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 13)) + 1309151649U;
#line 311
  b = ((t << 21) | (t >> 11)) + c;
#line 312
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 4)) + 4149444226U;
#line 312
  a = ((t << 6) | (t >> 26)) + b;
#line 313
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 11)) + 3174756917U;
#line 313
  d = ((t << 10) | (t >> 22)) + a;
#line 314
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 2)) + 718787259U;
#line 314
  c = ((t << 15) | (t >> 17)) + d;
#line 315
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 9)) + 3951481745U;
#line 315
  b = ((t << 21) | (t >> 11)) + c;
#line 321
  pms->abcd[0] += a;
#line 322
  pms->abcd[1] += b;
#line 323
  pms->abcd[2] += c;
#line 324
  pms->abcd[3] += d;
#line 325
  return;
}
}
#line 327 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.c"
void md5_init(md5_state_t *pms ) 
{ 
  md5_word_t tmp ;

  {
#line 330
  tmp = (md5_word_t )0;
#line 330
  pms->count[1] = tmp;
#line 330
  pms->count[0] = tmp;
#line 331
  pms->abcd[0] = (md5_word_t )1732584193;
#line 332
  pms->abcd[1] = 4023233417U;
#line 333
  pms->abcd[2] = 2562383102U;
#line 334
  pms->abcd[3] = (md5_word_t )271733878;
#line 335
  return;
}
}
#line 337 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.c"
void md5_append(md5_state_t *pms , md5_byte_t const   *data , int nbytes ) 
{ 
  md5_byte_t const   *p ;
  int left ;
  int offset ;
  md5_word_t nbits ;
  int copy ;
  int tmp ;

  {
#line 340
  p = data;
#line 341
  left = nbytes;
#line 342
  offset = (int )((pms->count[0] >> 3) & 63U);
#line 343
  nbits = (md5_word_t )(nbytes << 3);
#line 345
  if (nbytes <= 0) {
#line 346
    return;
  }
#line 349
  pms->count[1] += (md5_word_t )(nbytes >> 29);
#line 350
  pms->count[0] += nbits;
#line 351
  if (pms->count[0] < nbits) {
#line 352
    (pms->count[1]) ++;
  }
#line 355
  if (offset) {
#line 356
    if (offset + nbytes > 64) {
#line 356
      tmp = 64 - offset;
    } else {
#line 356
      tmp = nbytes;
    }
    {
#line 356
    copy = tmp;
#line 358
    memcpy((void */* __restrict  */)(pms->buf + offset), (void const   */* __restrict  */)p,
           (size_t )copy);
    }
#line 359
    if (offset + copy < 64) {
#line 360
      return;
    }
    {
#line 361
    p += copy;
#line 362
    left -= copy;
#line 363
    md5_process(pms, (md5_byte_t const   *)(pms->buf));
    }
  }
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! (left >= 64)) {
#line 367
      goto while_break;
    }
    {
#line 368
    md5_process(pms, p);
#line 367
    p += 64;
#line 367
    left -= 64;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  if (left) {
    {
#line 372
    memcpy((void */* __restrict  */)(pms->buf), (void const   */* __restrict  */)p,
           (size_t )left);
    }
  }
#line 373
  return;
}
}
#line 378 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.c"
static md5_byte_t const   pad[64]  = 
#line 378
  {      (md5_byte_t const   )128,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0};
#line 375 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.c"
void md5_finish(md5_state_t *pms , md5_byte_t *digest ) 
{ 
  md5_byte_t data[8] ;
  int i ;

  {
#line 388
  i = 0;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! (i < 8)) {
#line 388
      goto while_break;
    }
#line 389
    data[i] = (md5_byte_t )(pms->count[i >> 2] >> ((i & 3) << 3));
#line 388
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 391
  md5_append(pms, pad, (int )(((55U - (pms->count[0] >> 3)) & 63U) + 1U));
#line 393
  md5_append(pms, (md5_byte_t const   *)(data), 8);
#line 394
  i = 0;
  }
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 394
    if (! (i < 16)) {
#line 394
      goto while_break___0;
    }
#line 395
    *(digest + i) = (md5_byte_t )(pms->abcd[i >> 2] >> ((i & 3) << 3));
#line 394
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 396
  return;
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 691 "/usr/include/pthread.h"
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 703
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 744
extern  __attribute__((__noreturn__)) void __pthread_unwind_next(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__)) ;
#line 754
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 979
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                                        pthread_condattr_t const   * __restrict  __cond_attr ) ;
#line 984
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
#line 988
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
#line 1000
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
#line 1011
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t * __restrict  __mutex ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
#line 1019
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_init)(pthread_condattr_t *__attr ) ;
#line 1023
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_destroy)(pthread_condattr_t *__attr ) ;
#line 1044
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_setclock)(pthread_condattr_t *__attr ,
                                                                                                                __clockid_t __clock_id ) ;
#line 60 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
__inline static void gettime(struct timespec *now ) 
{ 
  int tmp ;

  {
  {
#line 63
  tmp = clock_gettime(1, now);
  }
#line 63
  if (tmp == 0) {
#line 64
    return;
  }
  {
#line 72
  clock_gettime(0, now);
  }
#line 73
  return;
}
}
#line 107 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static int getipv4byname(char const   * __restrict  name , uint32_t * __restrict  ipv4 ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *res ;
  int val ;
  int tmp ;

  {
  {
#line 109
  hints.ai_flags = 0;
#line 109
  hints.ai_family = 2;
#line 109
  hints.ai_socktype = 2;
#line 109
  hints.ai_protocol = 0;
#line 109
  hints.ai_addrlen = 0U;
#line 109
  hints.ai_addr = (struct sockaddr *)0;
#line 109
  hints.ai_canonname = (char *)0;
#line 109
  hints.ai_next = (struct addrinfo *)0;
#line 115
  tmp = getaddrinfo(name, (char const   */* __restrict  */)((void *)0), (struct addrinfo  const  */* __restrict  */)(& hints),
                    (struct addrinfo **/* __restrict  */)(& res));
#line 115
  val = tmp;
  }
#line 116
  if (val) {
#line 117
    return (val);
  }
  {
#line 119
  *ipv4 = (uint32_t )((struct sockaddr_in  const  *)res->ai_addr)->sin_addr.s_addr;
#line 120
  freeaddrinfo(res);
  }
#line 122
  return (0);
}
}
#line 131 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static int maintenance_recv(teredo_packet const   * __restrict  packet , uint32_t server_ip ,
                            uint8_t const   * __restrict  nonce , _Bool cone , teredo_state * __restrict  state ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 136
  if (! packet->auth_present) {
    {
#line 136
    __assert_fail("packet->auth_present", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c",
                  136U, "maintenance_recv");
    }
  }
  {
#line 138
  tmp = memcmp((void const   *)(packet->auth_nonce), (void const   *)nonce, (size_t )8);
  }
#line 138
  if (tmp) {
#line 139
    return (1);
  }
#line 142
  if (packet->auth_fail) {
    {
#line 144
    tmp___0 = dgettext("miredo", "Authentication with server failed.");
#line 144
    syslog(3, (char const   *)tmp___0);
    }
#line 145
    return (13);
  }
  {
#line 148
  tmp___1 = teredo_parse_ra(packet, (union teredo_addr */* __restrict  */)(& state->addr),
                            cone, (uint16_t */* __restrict  */)(& state->mtu));
  }
#line 148
  if (tmp___1) {
#line 151
    return (22);
  } else
#line 148
  if (state->addr.teredo.server_ip != server_ip) {
#line 151
    return (22);
  }
#line 154
  state->ipv4 = (uint32_t )packet->dest_ipv4;
#line 155
  return (0);
}
}
#line 163 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static int wait_reply(teredo_maintenance * __restrict  m , struct timespec  const  * __restrict  deadline ) 
{ 
  int tmp ;

  {
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! ((unsigned long )m->incoming == (unsigned long )((void *)0))) {
#line 166
      goto while_break;
    }
    {
#line 168
    tmp = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& m->received),
                                 (pthread_mutex_t */* __restrict  */)(& m->inner),
                                 deadline);
    }
    {
#line 170
    if (tmp == 0) {
#line 170
      goto case_0;
    }
#line 172
    if (tmp == 110) {
#line 172
      goto case_110;
    }
#line 168
    goto switch_break;
    case_0: /* CIL Label */ 
#line 171
    goto switch_break;
    case_110: /* CIL Label */ 
#line 173
    return (110);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return (0);
}
}
#line 184 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static void wait_reply_ignore(teredo_maintenance * __restrict  m , struct timespec  const  * __restrict  deadline ) 
{ 
  int tmp ;

  {
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 187
    tmp = wait_reply(m, deadline);
    }
#line 187
    if (! (tmp == 0)) {
#line 187
      goto while_break;
    }
    {
#line 189
    m->incoming = (teredo_packet const   *)((void *)0);
#line 190
    pthread_cond_signal(& m->processed);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 199 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static _Bool checkTimeDrift(struct timespec *ts ) 
{ 
  struct timespec now ;
  char *tmp ;

  {
  {
#line 203
  gettime(& now);
  }
#line 205
  if (now.tv_sec > ts->tv_sec) {
    {
#line 209
    tmp = dgettext("miredo", "Too much time drift. Resynchronizing.");
#line 209
    syslog(4, (char const   *)tmp);
#line 210
    *ts = now;
    }
#line 211
    return ((_Bool)0);
  } else
#line 205
  if (now.tv_sec == ts->tv_sec) {
#line 205
    if (now.tv_nsec > ts->tv_nsec) {
      {
#line 209
      tmp = dgettext("miredo", "Too much time drift. Resynchronizing.");
#line 209
      syslog(4, (char const   *)tmp);
#line 210
      *ts = now;
      }
#line 211
      return ((_Bool)0);
    }
  }
#line 213
  return ((_Bool)1);
}
}
#line 217 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static void cleanup_unlock(void *o ) 
{ 


  {
  {
#line 220
  d_pthread_mutex_unlock((pthread_mutex_t *)o);
  }
#line 221
  return;
}
}
#line 241
__inline static  __attribute__((__noreturn__)) void maintenance_thread(teredo_maintenance *m ) ;
#line 241 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
__inline static void maintenance_thread(teredo_maintenance *m ) 
{ 
  struct timespec deadline ;
  teredo_state *c_state ;
  uint32_t server_ip ;
  unsigned int count ;
  enum __anonenum_last_error_87 last_error ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp ;
  long tmp___0 ;
  int val ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;
  uint8_t nonce[8] ;
  uint16_t tmp___7 ;
  int val___0 ;
  teredo_state newst ;
  unsigned int delay ;
  char *tmp___8 ;
  char *tmp___9 ;
  uint16_t f ;
  uint16_t tmp___10 ;
  uint16_t tmp___11 ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp___12 ;
  char *tmp___13 ;
  struct in6_addr  const  *__a___0 ;
  struct in6_addr  const  *__b___0 ;
  int tmp___14 ;

  {
  {
#line 244
  deadline.tv_sec = (__time_t )0;
#line 244
  deadline.tv_nsec = (__syscall_slong_t )0;
#line 245
  c_state = & m->state.state;
#line 246
  server_ip = (uint32_t )0;
#line 247
  count = 0U;
#line 248
  last_error = (enum __anonenum_last_error_87 )0;
#line 254
  d_pthread_mutex_lock(& m->inner);
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 259
    __cancel_routine = & cleanup_unlock;
#line 259
    __cancel_arg = (void *)(& m->inner);
#line 259
    tmp = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                      0);
#line 259
    __not_first_call = tmp;
#line 259
    tmp___0 = __builtin_expect((long )__not_first_call, 0L);
    }
#line 259
    if (tmp___0) {
      {
#line 259
      (*__cancel_routine)(__cancel_arg);
#line 259
      __pthread_unwind_next(& __cancel_buf);
      }
    }
    {
#line 259
    __pthread_register_cancel(& __cancel_buf);
    }
    {
#line 259
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 260
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 263
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 263
          if (! (server_ip == 0U)) {
#line 263
            goto while_break___2;
          }
          {
#line 266
          tmp___1 = getipv4byname((char const   */* __restrict  */)m->server, (uint32_t */* __restrict  */)(& server_ip));
#line 266
          val = tmp___1;
#line 267
          gettime(& deadline);
          }
#line 269
          if (val) {
            {
#line 272
            tmp___2 = gai_strerror(val);
#line 272
            tmp___3 = dgettext("miredo", "Cannot resolve Teredo server address \"%s\": %s");
#line 272
            syslog(3, (char const   *)tmp___3, m->server, tmp___2);
            }
          } else {
            {
#line 277
            tmp___5 = is_ipv4_global_unicast(server_ip);
            }
#line 277
            if (tmp___5) {
#line 286
              if (! (! c_state->up)) {
                {
#line 286
                __assert_fail("!c_state->up", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c",
                              286U, "maintenance_thread");
                }
              }
              {
#line 287
              c_state->addr.teredo.server_ip = server_ip;
#line 288
              (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
              }
#line 289
              goto while_break___2;
            } else {
              {
#line 279
              tmp___4 = dgettext("miredo", "Teredo server has a non global IPv4 address.");
#line 279
              syslog(3, (char const   *)tmp___4);
              }
            }
          }
          {
#line 293
          deadline.tv_sec += (__time_t )m->restart_delay;
#line 294
          server_ip = (uint32_t )0;
#line 295
          wait_reply_ignore((teredo_maintenance */* __restrict  */)m, (struct timespec  const  */* __restrict  */)(& deadline));
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 299
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 300
          deadline.tv_sec += (__time_t )m->qualification_delay;
#line 299
          tmp___6 = checkTimeDrift(& deadline);
          }
#line 299
          if (tmp___6) {
#line 299
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 304
        tmp___7 = htons((uint16_t )3544);
#line 304
        teredo_get_nonce((uint32_t )deadline.tv_sec, server_ip, tmp___7, (uint8_t */* __restrict  */)(nonce));
#line 306
        teredo_send_rs(m->fd, server_ip, (unsigned char const   *)(nonce), (_Bool)0);
#line 308
        val___0 = 0;
#line 310
        newst.mtu = (uint16_t )1280;
#line 311
        newst.up = (_Bool)1;
        }
        {
#line 314
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 316
          val___0 = wait_reply((teredo_maintenance */* __restrict  */)m, (struct timespec  const  */* __restrict  */)(& deadline));
          }
#line 317
          if (val___0) {
#line 318
            goto __Cont;
          }
          {
#line 321
          val___0 = maintenance_recv((teredo_packet const   */* __restrict  */)m->incoming,
                                     server_ip, (uint8_t const   */* __restrict  */)(nonce),
                                     (_Bool)0, (teredo_state */* __restrict  */)(& newst));
#line 323
          m->incoming = (teredo_packet const   *)((void *)0);
#line 324
          pthread_cond_signal(& m->processed);
          }
          __Cont: /* CIL Label */ 
#line 314
          if (val___0 != 0) {
#line 314
            if (! (val___0 != 110)) {
#line 314
              goto while_break___4;
            }
          } else {
#line 314
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 328
        delay = 0U;
#line 331
        if (val___0) {
#line 334
          count ++;
#line 336
          if (count >= m->qualification_retries) {
#line 338
            count = 0U;
#line 341
            if ((unsigned int )last_error != 1U) {
              {
#line 343
              tmp___8 = dgettext("miredo", "No reply from Teredo server");
#line 343
              syslog(6, (char const   *)tmp___8);
#line 344
              last_error = (enum __anonenum_last_error_87 )1;
              }
            }
#line 347
            if (c_state->up) {
              {
#line 349
              tmp___9 = dgettext("miredo", "Lost Teredo connectivity");
#line 349
              syslog(5, (char const   *)tmp___9);
#line 350
              c_state->up = (_Bool)0;
#line 351
              (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
#line 352
              server_ip = (uint32_t )0;
              }
            }
#line 356
            delay = m->restart_delay;
          }
        } else {
#line 362
          count = 0U;
#line 365
          newst.addr.teredo.flags = c_state->addr.teredo.flags;
#line 366
          __a = (struct in6_addr  const  *)(& c_state->addr.ip6);
#line 366
          __b = (struct in6_addr  const  *)(& newst.addr.ip6);
#line 366
          if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 366
            if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 366
              if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 366
                if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 366
                  tmp___12 = 1;
                } else {
#line 366
                  tmp___12 = 0;
                }
              } else {
#line 366
                tmp___12 = 0;
              }
            } else {
#line 366
              tmp___12 = 0;
            }
          } else {
#line 366
            tmp___12 = 0;
          }
#line 366
          if (! tmp___12) {
            {
#line 368
            tmp___10 = teredo_get_flbits((uint32_t )deadline.tv_sec);
#line 368
            f = tmp___10;
#line 369
            tmp___11 = htons((uint16_t )15615);
#line 369
            newst.addr.teredo.flags = (uint16_t )((int )f & (int )tmp___11);
            }
          }
#line 374
          if (! c_state->up) {
            {
#line 377
            memcpy((void */* __restrict  */)c_state, (void const   */* __restrict  */)(& newst),
                   sizeof(*c_state));
#line 379
            tmp___13 = dgettext("miredo", "New Teredo address/MTU");
#line 379
            syslog(5, (char const   *)tmp___13);
#line 380
            (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
            }
          } else {
#line 374
            __a___0 = (struct in6_addr  const  *)(& c_state->addr.ip6);
#line 374
            __b___0 = (struct in6_addr  const  *)(& newst.addr.ip6);
#line 374
            if (__a___0->__in6_u.__u6_addr32[0] == __b___0->__in6_u.__u6_addr32[0]) {
#line 374
              if (__a___0->__in6_u.__u6_addr32[1] == __b___0->__in6_u.__u6_addr32[1]) {
#line 374
                if (__a___0->__in6_u.__u6_addr32[2] == __b___0->__in6_u.__u6_addr32[2]) {
#line 374
                  if (__a___0->__in6_u.__u6_addr32[3] == __b___0->__in6_u.__u6_addr32[3]) {
#line 374
                    tmp___14 = 1;
                  } else {
#line 374
                    tmp___14 = 0;
                  }
                } else {
#line 374
                  tmp___14 = 0;
                }
              } else {
#line 374
                tmp___14 = 0;
              }
            } else {
#line 374
              tmp___14 = 0;
            }
#line 374
            if (tmp___14) {
#line 374
              if ((int )c_state->mtu != (int )newst.mtu) {
                {
#line 377
                memcpy((void */* __restrict  */)c_state, (void const   */* __restrict  */)(& newst),
                       sizeof(*c_state));
#line 379
                tmp___13 = dgettext("miredo", "New Teredo address/MTU");
#line 379
                syslog(5, (char const   *)tmp___13);
#line 380
                (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
                }
              }
            } else {
              {
#line 377
              memcpy((void */* __restrict  */)c_state, (void const   */* __restrict  */)(& newst),
                     sizeof(*c_state));
#line 379
              tmp___13 = dgettext("miredo", "New Teredo address/MTU");
#line 379
              syslog(5, (char const   *)tmp___13);
#line 380
              (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
              }
            }
          }
#line 384
          last_error = (enum __anonenum_last_error_87 )0;
#line 385
          delay = m->refresh_delay;
        }
#line 391
        if (delay) {
          {
#line 393
          deadline.tv_sec -= (__time_t )m->qualification_delay;
#line 394
          deadline.tv_sec += (__time_t )delay;
#line 395
          wait_reply_ignore((teredo_maintenance */* __restrict  */)m, (struct timespec  const  */* __restrict  */)(& deadline));
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 399
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 399
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 259
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 399
    __pthread_unregister_cancel(& __cancel_buf);
#line 399
    (*__cancel_routine)(__cancel_arg);
    }
#line 259
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 403
static  __attribute__((__noreturn__)) void *do_maintenance(void *opaque ) ;
#line 403 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static void *do_maintenance(void *opaque ) 
{ 


  {
  {
#line 405
  maintenance_thread((teredo_maintenance *)opaque);
  }
}
}
#line 409 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   QualificationDelay  =    (unsigned int const   )4;
#line 410 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   QualificationRetries  =    (unsigned int const   )3;
#line 412 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   RefreshDelay  =    (unsigned int const   )30;
#line 413 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   RestartDelay  =    (unsigned int const   )100;
#line 415 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
teredo_maintenance *teredo_maintenance_start(int fd , void (*cb)(struct teredo_state  const  *s ,
                                                                 void *opaque ) ,
                                             void *opaque , char const   *s1 , char const   *s2 ,
                                             unsigned int q_sec , unsigned int q_retries ,
                                             unsigned int refresh_sec , unsigned int restart_sec ) 
{ 
  teredo_maintenance *m ;
  void *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  pthread_condattr_t attr ;
  int err ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 421
  tmp = malloc(sizeof(*m));
#line 421
  m = (teredo_maintenance *)tmp;
  }
#line 423
  if ((unsigned long )m == (unsigned long )((void *)0)) {
#line 424
    return ((teredo_maintenance *)((void *)0));
  }
  {
#line 426
  memset((void *)m, 0, sizeof(*m));
#line 427
  m->fd = fd;
#line 428
  m->state.cb = cb;
#line 429
  m->state.opaque = opaque;
  }
#line 431
  if (! ((unsigned long )s1 != (unsigned long )((void *)0))) {
    {
#line 431
    __assert_fail("s1 != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c",
                  431U, "teredo_maintenance_start");
    }
  }
  {
#line 432
  m->server = strdup(s1);
#line 435
  tmp___0 = q_sec;
  }
#line 435
  if (! tmp___0) {
#line 435
    tmp___0 = (unsigned int )QualificationDelay;
  }
#line 435
  m->qualification_delay = tmp___0;
#line 436
  tmp___1 = q_retries;
#line 436
  if (! tmp___1) {
#line 436
    tmp___1 = (unsigned int )QualificationRetries;
  }
#line 436
  m->qualification_retries = tmp___1;
#line 437
  tmp___2 = refresh_sec;
#line 437
  if (! tmp___2) {
#line 437
    tmp___2 = (unsigned int )RefreshDelay;
  }
#line 437
  m->refresh_delay = tmp___2;
#line 438
  tmp___3 = restart_sec;
#line 438
  if (! tmp___3) {
#line 438
    tmp___3 = (unsigned int )RestartDelay;
  }
#line 438
  m->restart_delay = tmp___3;
#line 440
  if ((unsigned long )m->server == (unsigned long )((void *)0)) {
    {
#line 442
    free((void *)m);
    }
#line 443
    return ((teredo_maintenance *)((void *)0));
  } else {
    {
#line 449
    pthread_condattr_init(& attr);
#line 450
    pthread_condattr_setclock(& attr, 1);
#line 453
    pthread_cond_init((pthread_cond_t */* __restrict  */)(& m->received), (pthread_condattr_t const   */* __restrict  */)(& attr));
#line 454
    pthread_condattr_destroy(& attr);
    }
  }
  {
#line 457
  pthread_cond_init((pthread_cond_t */* __restrict  */)(& m->processed), (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 458
  d_pthread_mutex_init(& m->outer, (pthread_mutexattr_t *)((void *)0));
#line 459
  d_pthread_mutex_init(& m->inner, (pthread_mutexattr_t *)((void *)0));
#line 461
  tmp___4 = pthread_create((pthread_t */* __restrict  */)(& m->thread), (pthread_attr_t const   */* __restrict  */)((void *)0),
                           & do_maintenance, (void */* __restrict  */)m);
#line 461
  err = tmp___4;
  }
#line 462
  if (err == 0) {
#line 463
    return (m);
  }
  {
#line 465
  tmp___5 = __errno_location();
#line 465
  *tmp___5 = err;
#line 466
  tmp___6 = dgettext("miredo", "Error (%s): %m");
#line 466
  syslog(1, (char const   *)tmp___6, "pthread_create");
#line 468
  pthread_cond_destroy(& m->processed);
#line 469
  pthread_cond_destroy(& m->received);
#line 470
  pthread_mutex_destroy(& m->outer);
#line 471
  pthread_mutex_destroy(& m->inner);
#line 473
  free((void *)m->server);
#line 474
  free((void *)m);
  }
#line 475
  return ((teredo_maintenance *)((void *)0));
}
}
#line 479 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
void teredo_maintenance_stop(teredo_maintenance *m ) 
{ 


  {
  {
#line 481
  pthread_cancel(m->thread);
#line 482
  pthread_join(m->thread, (void **)((void *)0));
#line 484
  pthread_cond_destroy(& m->processed);
#line 485
  pthread_cond_destroy(& m->received);
#line 486
  pthread_mutex_destroy(& m->inner);
#line 487
  pthread_mutex_destroy(& m->outer);
#line 489
  free((void *)m->server);
#line 490
  free((void *)m);
  }
#line 491
  return;
}
}
#line 494 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
int teredo_maintenance_process(teredo_maintenance * __restrict  m , teredo_packet const   * __restrict  packet ) 
{ 
  uint16_t tmp ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp___0 ;

  {
#line 497
  if (! ((unsigned long )m != (unsigned long )((void *)0))) {
    {
#line 497
    __assert_fail("m != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c",
                  497U, "teredo_maintenance_process");
    }
  }
#line 498
  if (! ((unsigned long )packet != (unsigned long )((void *)0))) {
    {
#line 498
    __assert_fail("packet != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c",
                  498U, "teredo_maintenance_process");
    }
  }
  {
#line 504
  tmp = htons((uint16_t )3544);
  }
#line 507
  if ((int const   )packet->source_port != (int const   )tmp) {
#line 508
    return (-1);
  } else
#line 507
  if (! packet->auth_present) {
#line 508
    return (-1);
  } else {
#line 507
    __a = (struct in6_addr  const  *)(& (packet->ip6)->ip6_dst);
#line 507
    __b = & teredo_restrict;
#line 507
    if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 507
      if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 507
        if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 507
          if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 507
            tmp___0 = 1;
          } else {
#line 507
            tmp___0 = 0;
          }
        } else {
#line 507
          tmp___0 = 0;
        }
      } else {
#line 507
        tmp___0 = 0;
      }
    } else {
#line 507
      tmp___0 = 0;
    }
#line 507
    if (! tmp___0) {
#line 508
      return (-1);
    }
  }
  {
#line 510
  d_pthread_mutex_lock(& m->outer);
#line 511
  d_pthread_mutex_lock(& m->inner);
#line 513
  m->incoming = (teredo_packet const   *)packet;
#line 514
  pthread_cond_signal(& m->received);
  }
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 518
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& m->processed), (pthread_mutex_t */* __restrict  */)(& m->inner));
    }
#line 517
    if (! ((unsigned long )m->incoming != (unsigned long )((void *)0))) {
#line 517
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 521
  d_pthread_mutex_unlock(& m->inner);
#line 522
  d_pthread_mutex_unlock(& m->outer);
  }
#line 524
  return (0);
}
}
#line 107 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static int getipv4byname___0(char const   * __restrict  name , uint32_t * __restrict  ipv4 ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *res ;
  int val ;
  int tmp ;

  {
  {
#line 109
  hints.ai_flags = 0;
#line 109
  hints.ai_family = 2;
#line 109
  hints.ai_socktype = 2;
#line 109
  hints.ai_protocol = 0;
#line 109
  hints.ai_addrlen = 0U;
#line 109
  hints.ai_addr = (struct sockaddr *)0;
#line 109
  hints.ai_canonname = (char *)0;
#line 109
  hints.ai_next = (struct addrinfo *)0;
#line 115
  tmp = getaddrinfo(name, (char const   */* __restrict  */)((void *)0), (struct addrinfo  const  */* __restrict  */)(& hints),
                    (struct addrinfo **/* __restrict  */)(& res));
#line 115
  val = tmp;
  }
#line 116
  if (val) {
#line 117
    return (val);
  }
  {
#line 119
  *ipv4 = (uint32_t )((struct sockaddr_in  const  *)res->ai_addr)->sin_addr.s_addr;
#line 120
  freeaddrinfo(res);
  }
#line 122
  return (0);
}
}
#line 131 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static int maintenance_recv___0(teredo_packet const   * __restrict  packet , uint32_t server_ip ,
                                uint8_t const   * __restrict  nonce , _Bool cone ,
                                teredo_state * __restrict  state ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 136
  if (! packet->auth_present) {
    {
#line 136
    __assert_fail("packet->auth_present", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c",
                  136U, "maintenance_recv");
    }
  }
  {
#line 138
  tmp = memcmp((void const   *)(packet->auth_nonce), (void const   *)nonce, (size_t )8);
  }
#line 138
  if (tmp) {
#line 139
    return (1);
  }
#line 142
  if (packet->auth_fail) {
    {
#line 144
    tmp___0 = dgettext("miredo", "Authentication with server failed.");
#line 144
    syslog(3, (char const   *)tmp___0);
    }
#line 145
    return (13);
  }
  {
#line 148
  tmp___1 = teredo_parse_ra(packet, (union teredo_addr */* __restrict  */)(& state->addr),
                            cone, (uint16_t */* __restrict  */)(& state->mtu));
  }
#line 148
  if (tmp___1) {
#line 151
    return (22);
  } else
#line 148
  if (state->addr.teredo.server_ip != server_ip) {
#line 151
    return (22);
  }
#line 154
  state->ipv4 = (uint32_t )packet->dest_ipv4;
#line 155
  return (0);
}
}
#line 163 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static int wait_reply___0(teredo_maintenance * __restrict  m , struct timespec  const  * __restrict  deadline ) 
{ 
  int tmp ;

  {
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! ((unsigned long )m->incoming == (unsigned long )((void *)0))) {
#line 166
      goto while_break;
    }
    {
#line 168
    tmp = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& m->received),
                                 (pthread_mutex_t */* __restrict  */)(& m->inner),
                                 deadline);
    }
    {
#line 170
    if (tmp == 0) {
#line 170
      goto case_0;
    }
#line 172
    if (tmp == 110) {
#line 172
      goto case_110;
    }
#line 168
    goto switch_break;
    case_0: /* CIL Label */ 
#line 171
    goto switch_break;
    case_110: /* CIL Label */ 
#line 173
    return (110);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return (0);
}
}
#line 184 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static void wait_reply_ignore___0(teredo_maintenance * __restrict  m , struct timespec  const  * __restrict  deadline ) 
{ 
  int tmp ;

  {
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 187
    tmp = wait_reply___0(m, deadline);
    }
#line 187
    if (! (tmp == 0)) {
#line 187
      goto while_break;
    }
    {
#line 189
    m->incoming = (teredo_packet const   *)((void *)0);
#line 190
    pthread_cond_signal(& m->processed);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 199 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static _Bool checkTimeDrift___0(struct timespec *ts ) 
{ 
  struct timespec now ;
  char *tmp ;

  {
  {
#line 203
  gettime(& now);
  }
#line 205
  if (now.tv_sec > ts->tv_sec) {
    {
#line 209
    tmp = dgettext("miredo", "Too much time drift. Resynchronizing.");
#line 209
    syslog(4, (char const   *)tmp);
#line 210
    *ts = now;
    }
#line 211
    return ((_Bool)0);
  } else
#line 205
  if (now.tv_sec == ts->tv_sec) {
#line 205
    if (now.tv_nsec > ts->tv_nsec) {
      {
#line 209
      tmp = dgettext("miredo", "Too much time drift. Resynchronizing.");
#line 209
      syslog(4, (char const   *)tmp);
#line 210
      *ts = now;
      }
#line 211
      return ((_Bool)0);
    }
  }
#line 213
  return ((_Bool)1);
}
}
#line 217 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static void cleanup_unlock___0(void *o ) 
{ 


  {
  {
#line 220
  d_pthread_mutex_unlock((pthread_mutex_t *)o);
  }
#line 221
  return;
}
}
#line 241
__inline static  __attribute__((__noreturn__)) void maintenance_thread___0(teredo_maintenance *m ) ;
#line 241 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
__inline static void maintenance_thread___0(teredo_maintenance *m ) 
{ 
  struct timespec deadline ;
  teredo_state *c_state ;
  uint32_t server_ip ;
  unsigned int count ;
  enum __anonenum_last_error_87___0 last_error ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp ;
  long tmp___0 ;
  int val ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;
  uint8_t nonce[8] ;
  uint16_t tmp___7 ;
  int val___0 ;
  teredo_state newst ;
  unsigned int delay ;
  char *tmp___8 ;
  char *tmp___9 ;
  uint16_t f ;
  uint16_t tmp___10 ;
  uint16_t tmp___11 ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp___12 ;
  char *tmp___13 ;
  struct in6_addr  const  *__a___0 ;
  struct in6_addr  const  *__b___0 ;
  int tmp___14 ;

  {
  {
#line 244
  deadline.tv_sec = (__time_t )0;
#line 244
  deadline.tv_nsec = (__syscall_slong_t )0;
#line 245
  c_state = & m->state.state;
#line 246
  server_ip = (uint32_t )0;
#line 247
  count = 0U;
#line 248
  last_error = (enum __anonenum_last_error_87___0 )0;
#line 254
  d_pthread_mutex_lock(& m->inner);
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 259
    __cancel_routine = & cleanup_unlock___0;
#line 259
    __cancel_arg = (void *)(& m->inner);
#line 259
    tmp = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                      0);
#line 259
    __not_first_call = tmp;
#line 259
    tmp___0 = __builtin_expect((long )__not_first_call, 0L);
    }
#line 259
    if (tmp___0) {
      {
#line 259
      (*__cancel_routine)(__cancel_arg);
#line 259
      __pthread_unwind_next(& __cancel_buf);
      }
    }
    {
#line 259
    __pthread_register_cancel(& __cancel_buf);
    }
    {
#line 259
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 260
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 263
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 263
          if (! (server_ip == 0U)) {
#line 263
            goto while_break___2;
          }
          {
#line 266
          tmp___1 = getipv4byname___0((char const   */* __restrict  */)m->server,
                                      (uint32_t */* __restrict  */)(& server_ip));
#line 266
          val = tmp___1;
#line 267
          gettime(& deadline);
          }
#line 269
          if (val) {
            {
#line 272
            tmp___2 = gai_strerror(val);
#line 272
            tmp___3 = dgettext("miredo", "Cannot resolve Teredo server address \"%s\": %s");
#line 272
            syslog(3, (char const   *)tmp___3, m->server, tmp___2);
            }
          } else {
            {
#line 277
            tmp___5 = is_ipv4_global_unicast(server_ip);
            }
#line 277
            if (tmp___5) {
#line 286
              if (! (! c_state->up)) {
                {
#line 286
                __assert_fail("!c_state->up", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c",
                              286U, "maintenance_thread");
                }
              }
              {
#line 287
              c_state->addr.teredo.server_ip = server_ip;
#line 288
              (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
              }
#line 289
              goto while_break___2;
            } else {
              {
#line 279
              tmp___4 = dgettext("miredo", "Teredo server has a non global IPv4 address.");
#line 279
              syslog(3, (char const   *)tmp___4);
              }
            }
          }
          {
#line 293
          deadline.tv_sec += (__time_t )m->restart_delay;
#line 294
          server_ip = (uint32_t )0;
#line 295
          wait_reply_ignore___0((teredo_maintenance */* __restrict  */)m, (struct timespec  const  */* __restrict  */)(& deadline));
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 299
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 300
          deadline.tv_sec += (__time_t )m->qualification_delay;
#line 299
          tmp___6 = checkTimeDrift___0(& deadline);
          }
#line 299
          if (tmp___6) {
#line 299
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 304
        tmp___7 = htons((uint16_t )3544);
#line 304
        teredo_get_nonce((uint32_t )deadline.tv_sec, server_ip, tmp___7, (uint8_t */* __restrict  */)(nonce));
#line 306
        teredo_send_rs(m->fd, server_ip, (unsigned char const   *)(nonce), (_Bool)0);
#line 308
        val___0 = 0;
#line 310
        newst.mtu = (uint16_t )1280;
#line 311
        newst.up = (_Bool)1;
        }
        {
#line 314
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 316
          val___0 = wait_reply___0((teredo_maintenance */* __restrict  */)m, (struct timespec  const  */* __restrict  */)(& deadline));
          }
#line 317
          if (val___0) {
#line 318
            goto __Cont;
          }
          {
#line 321
          val___0 = maintenance_recv___0((teredo_packet const   */* __restrict  */)m->incoming,
                                         server_ip, (uint8_t const   */* __restrict  */)(nonce),
                                         (_Bool)0, (teredo_state */* __restrict  */)(& newst));
#line 323
          m->incoming = (teredo_packet const   *)((void *)0);
#line 324
          pthread_cond_signal(& m->processed);
          }
          __Cont: /* CIL Label */ 
#line 314
          if (val___0 != 0) {
#line 314
            if (! (val___0 != 110)) {
#line 314
              goto while_break___4;
            }
          } else {
#line 314
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 328
        delay = 0U;
#line 331
        if (val___0) {
#line 334
          count ++;
#line 336
          if (count >= m->qualification_retries) {
#line 338
            count = 0U;
#line 341
            if ((unsigned int )last_error != 1U) {
              {
#line 343
              tmp___8 = dgettext("miredo", "No reply from Teredo server");
#line 343
              syslog(6, (char const   *)tmp___8);
#line 344
              last_error = (enum __anonenum_last_error_87___0 )1;
              }
            }
#line 347
            if (c_state->up) {
              {
#line 349
              tmp___9 = dgettext("miredo", "Lost Teredo connectivity");
#line 349
              syslog(5, (char const   *)tmp___9);
#line 350
              c_state->up = (_Bool)0;
#line 351
              (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
#line 352
              server_ip = (uint32_t )0;
              }
            }
#line 356
            delay = m->restart_delay;
          }
        } else {
#line 362
          count = 0U;
#line 365
          newst.addr.teredo.flags = c_state->addr.teredo.flags;
#line 366
          __a = (struct in6_addr  const  *)(& c_state->addr.ip6);
#line 366
          __b = (struct in6_addr  const  *)(& newst.addr.ip6);
#line 366
          if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 366
            if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 366
              if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 366
                if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 366
                  tmp___12 = 1;
                } else {
#line 366
                  tmp___12 = 0;
                }
              } else {
#line 366
                tmp___12 = 0;
              }
            } else {
#line 366
              tmp___12 = 0;
            }
          } else {
#line 366
            tmp___12 = 0;
          }
#line 366
          if (! tmp___12) {
            {
#line 368
            tmp___10 = teredo_get_flbits((uint32_t )deadline.tv_sec);
#line 368
            f = tmp___10;
#line 369
            tmp___11 = htons((uint16_t )15615);
#line 369
            newst.addr.teredo.flags = (uint16_t )((int )f & (int )tmp___11);
            }
          }
#line 374
          if (! c_state->up) {
            {
#line 377
            memcpy((void */* __restrict  */)c_state, (void const   */* __restrict  */)(& newst),
                   sizeof(*c_state));
#line 379
            tmp___13 = dgettext("miredo", "New Teredo address/MTU");
#line 379
            syslog(5, (char const   *)tmp___13);
#line 380
            (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
            }
          } else {
#line 374
            __a___0 = (struct in6_addr  const  *)(& c_state->addr.ip6);
#line 374
            __b___0 = (struct in6_addr  const  *)(& newst.addr.ip6);
#line 374
            if (__a___0->__in6_u.__u6_addr32[0] == __b___0->__in6_u.__u6_addr32[0]) {
#line 374
              if (__a___0->__in6_u.__u6_addr32[1] == __b___0->__in6_u.__u6_addr32[1]) {
#line 374
                if (__a___0->__in6_u.__u6_addr32[2] == __b___0->__in6_u.__u6_addr32[2]) {
#line 374
                  if (__a___0->__in6_u.__u6_addr32[3] == __b___0->__in6_u.__u6_addr32[3]) {
#line 374
                    tmp___14 = 1;
                  } else {
#line 374
                    tmp___14 = 0;
                  }
                } else {
#line 374
                  tmp___14 = 0;
                }
              } else {
#line 374
                tmp___14 = 0;
              }
            } else {
#line 374
              tmp___14 = 0;
            }
#line 374
            if (tmp___14) {
#line 374
              if ((int )c_state->mtu != (int )newst.mtu) {
                {
#line 377
                memcpy((void */* __restrict  */)c_state, (void const   */* __restrict  */)(& newst),
                       sizeof(*c_state));
#line 379
                tmp___13 = dgettext("miredo", "New Teredo address/MTU");
#line 379
                syslog(5, (char const   *)tmp___13);
#line 380
                (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
                }
              }
            } else {
              {
#line 377
              memcpy((void */* __restrict  */)c_state, (void const   */* __restrict  */)(& newst),
                     sizeof(*c_state));
#line 379
              tmp___13 = dgettext("miredo", "New Teredo address/MTU");
#line 379
              syslog(5, (char const   *)tmp___13);
#line 380
              (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
              }
            }
          }
#line 384
          last_error = (enum __anonenum_last_error_87___0 )0;
#line 385
          delay = m->refresh_delay;
        }
#line 391
        if (delay) {
          {
#line 393
          deadline.tv_sec -= (__time_t )m->qualification_delay;
#line 394
          deadline.tv_sec += (__time_t )delay;
#line 395
          wait_reply_ignore___0((teredo_maintenance */* __restrict  */)m, (struct timespec  const  */* __restrict  */)(& deadline));
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 399
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 399
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 259
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 399
    __pthread_unregister_cancel(& __cancel_buf);
#line 399
    (*__cancel_routine)(__cancel_arg);
    }
#line 259
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 403
static  __attribute__((__noreturn__)) void *do_maintenance___0(void *opaque ) ;
#line 403 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static void *do_maintenance___0(void *opaque ) 
{ 


  {
  {
#line 405
  maintenance_thread___0((teredo_maintenance *)opaque);
  }
}
}
#line 409 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   QualificationDelay___0  =    (unsigned int const   )4;
#line 410 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   QualificationRetries___0  =    (unsigned int const   )3;
#line 412 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   RefreshDelay___0  =    (unsigned int const   )30;
#line 413 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   RestartDelay___0  =    (unsigned int const   )100;
#line 49 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
static void clock_tick___0(union sigval val ) 
{ 
  clock_data_t *context ;
  int orun ;
  int tmp ;
  struct itimerspec it ;

  {
  {
#line 51
  context = (clock_data_t *)val.sival_ptr;
#line 53
  tmp = timer_getoverrun(context->handle);
#line 53
  orun = tmp;
#line 54
  context->value += (teredo_clock_t )(1 + orun);
  }
#line 57
  if (orun == 2147483647) {
#line 59
    context->active = (_Bool)0;
  }
#line 62
  if (! context->active) {
    {
#line 64
    it.it_interval.tv_sec = 0L;
#line 64
    it.it_interval.tv_nsec = 0L;
#line 64
    it.it_value.tv_sec = (__time_t )0;
#line 64
    it.it_value.tv_nsec = (__syscall_slong_t )0;
#line 68
    timer_settime(context->handle, 0, (struct itimerspec  const  */* __restrict  */)(& it),
                  (struct itimerspec */* __restrict  */)((void *)0));
    }
  }
#line 71
  context->active = (_Bool)0;
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
static clock_data_t clk___0  =    {(void *)0, (teredo_clock_t )0, (_Bool)0};
#line 82 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
static struct __anonstruct_priv_55___0 priv___0  =    {{{0, 0U, 0, 0U, 2, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}},
    0, (_Bool)0};
#line 117 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
static ssize_t teredo_recverr___0(int fd ) 
{ 
  struct msghdr msg ;
  ssize_t tmp ;

  {
  {
#line 123
  memset((void *)(& msg), 0, sizeof(msg));
#line 124
  tmp = recvmsg(fd, & msg, 8192);
  }
#line 124
  return (tmp);
}
}
#line 173 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
static int teredo_recv_inner___0(int fd , struct teredo_packet *p , int flags ) 
{ 
  struct sockaddr_in ad ;
  char cbuf[(((sizeof(struct in_pktinfo ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
  struct iovec iov ;
  struct msghdr msg ;
  ssize_t length ;
  ssize_t tmp ;
  struct cmsghdr *cmsg ;
  struct cmsghdr *tmp___0 ;
  struct in_pktinfo  const  *nfo ;
  uint8_t *ptr ;
  uint8_t id_len ;
  uint8_t au_len ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;
  uint32_t addr ;
  uint16_t port ;

  {
  {
#line 181
  iov.iov_base = (void *)(p->buf.fill);
#line 181
  iov.iov_len = (size_t )65507;
#line 186
  msg.msg_name = (void *)(& ad);
#line 186
  msg.msg_namelen = (socklen_t )sizeof(ad);
#line 186
  msg.msg_iov = & iov;
#line 186
  msg.msg_iovlen = (size_t )1;
#line 186
  msg.msg_control = (void *)(cbuf);
#line 186
  msg.msg_controllen = sizeof(cbuf);
#line 186
  msg.msg_flags = 0;
#line 199
  tmp = recvmsg(fd, & msg, flags);
#line 199
  length = tmp;
  }
#line 200
  if (length == -1L) {
    {
#line 201
    teredo_recverr___0(fd);
    }
  }
#line 202
  if (length < 2L) {
#line 203
    return (-1);
  }
#line 205
  p->source_ipv4 = ad.sin_addr.s_addr;
#line 206
  p->source_port = ad.sin_port;
#line 207
  p->dest_ipv4 = (uint32_t )0;
#line 212
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 212
    tmp___0 = (struct cmsghdr *)msg.msg_control;
  } else {
#line 212
    tmp___0 = (struct cmsghdr *)0;
  }
#line 212
  cmsg = tmp___0;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! ((unsigned long )cmsg != (unsigned long )((void *)0))) {
#line 212
      goto while_break;
    }
#line 217
    if (cmsg->cmsg_level == 0) {
#line 217
      if (cmsg->cmsg_type == 8) {
#line 220
        nfo = (struct in_pktinfo  const  *)((struct in_pktinfo *)(cmsg->__cmsg_data));
#line 222
        p->dest_ipv4 = (uint32_t )nfo->ipi_addr.s_addr;
      }
    }
    {
#line 212
    cmsg = __cmsg_nxthdr(& msg, cmsg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  ptr = p->buf.fill;
#line 238
  p->auth_present = (_Bool)0;
#line 239
  p->orig_ipv4 = (uint32_t )0;
#line 240
  p->orig_port = (uint16_t )0;
#line 243
  if ((int )*(ptr + 0) == 0) {
#line 243
    if ((int )*(ptr + 1) == 1) {
#line 247
      p->auth_present = (_Bool)1;
#line 249
      length -= 13L;
#line 250
      if (length < 0L) {
#line 251
        return (-1);
      }
#line 252
      ptr += 2;
#line 255
      tmp___1 = ptr;
#line 255
      ptr ++;
#line 255
      id_len = *tmp___1;
#line 256
      tmp___2 = ptr;
#line 256
      ptr ++;
#line 256
      au_len = *tmp___2;
#line 259
      length -= (ssize_t )((int )id_len + (int )au_len);
#line 260
      if (length < 0L) {
#line 261
        return (-1);
      }
      {
#line 262
      ptr += (int )id_len + (int )au_len;
#line 265
      memcpy((void */* __restrict  */)(p->auth_nonce), (void const   */* __restrict  */)ptr,
             (size_t )8);
#line 266
      ptr += 8;
#line 267
      p->auth_fail = (_Bool )(! (! *ptr));
#line 268
      ptr ++;
#line 273
      memmove((void *)(p->buf.align), (void const   *)ptr, (size_t )length);
#line 274
      ptr = p->buf.fill;
      }
    }
  }
#line 278
  if ((int )*(ptr + 0) == 0) {
#line 278
    if ((int )*(ptr + 1) == 0) {
#line 283
      length -= 8L;
#line 284
      if (length < 0L) {
#line 285
        return (-1);
      }
      {
#line 286
      ptr += 2;
#line 289
      memcpy((void */* __restrict  */)(& port), (void const   */* __restrict  */)ptr,
             (size_t )2);
#line 290
      ptr += 2;
#line 291
      p->orig_port = (uint16_t )(~ ((int )port));
#line 294
      memcpy((void */* __restrict  */)(& addr), (void const   */* __restrict  */)ptr,
             (size_t )4);
#line 295
      ptr += 4;
#line 296
      p->orig_ipv4 = ~ addr;
      }
    }
  }
#line 299
  p->ip6_len = (size_t )length;
#line 300
  p->ip6 = (struct ip6_hdr *)ptr;
#line 302
  return (0);
}
}
#line 338 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
static uint16_t in_cksum___0(struct iovec  const  *iov , size_t n ) 
{ 
  uint32_t sum ;
  union __anonunion_w_31___0 w ;
  _Bool odd ;
  uint8_t const   *ptr ;
  size_t len ;
  uint8_t const   *tmp ;
  uint8_t const   *tmp___0 ;

  {
#line 340
  sum = (uint32_t )0;
#line 346
  odd = (_Bool)0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (n > 0UL)) {
#line 348
      goto while_break;
    }
#line 350
    ptr = (uint8_t const   *)iov->iov_base;
#line 352
    len = (size_t )iov->iov_len;
    {
#line 352
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 352
      if (! (len > 0UL)) {
#line 352
        goto while_break___0;
      }
#line 354
      if (odd) {
#line 356
        tmp = ptr;
#line 356
        ptr ++;
#line 356
        w.bytes[1] = (uint8_t )*tmp;
#line 357
        sum += (uint32_t )w.word;
#line 358
        if (sum > 65535U) {
#line 359
          sum -= 65535U;
        }
      } else {
#line 362
        tmp___0 = ptr;
#line 362
        ptr ++;
#line 362
        w.bytes[0] = (uint8_t )*tmp___0;
      }
#line 363
      odd = (_Bool )(! odd);
#line 352
      len --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    iov ++;
#line 367
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  if (odd) {
#line 372
    w.bytes[1] = (uint8_t )0;
#line 373
    sum += (uint32_t )w.word;
#line 374
    if (sum > 65535U) {
#line 375
      sum -= 65535U;
    }
  }
#line 378
  return ((uint16_t )(sum ^ 65535U));
}
}
#line 121 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_send_unreach___0(teredo_tunnel * __restrict  tunnel , uint8_t code ,
                                    struct ip6_hdr  const  * __restrict  in , size_t len ) 
{ 
  struct __anonstruct_buf_51___0 buf ;
  teredo_clock_t now ;
  teredo_clock_t tmp ;
  int tmp___0 ;

  {
  {
#line 130
  tmp = teredo_clock();
#line 130
  now = tmp;
#line 133
  d_pthread_mutex_lock(& tunnel->ratelimit.lock);
  }
#line 134
  if (now != tunnel->ratelimit.last) {
#line 136
    tunnel->ratelimit.last = now;
#line 137
    tunnel->ratelimit.count = 10;
  }
#line 141
  if (tunnel->ratelimit.count == 0) {
    {
#line 144
    d_pthread_mutex_unlock(& tunnel->ratelimit.lock);
    }
#line 145
    return;
  }
#line 147
  if (tunnel->ratelimit.count > 0) {
#line 148
    (tunnel->ratelimit.count) --;
  }
  {
#line 149
  d_pthread_mutex_unlock(& tunnel->ratelimit.lock);
#line 151
  tmp___0 = BuildICMPv6Error((struct icmp6_hdr */* __restrict  */)(& buf.hdr), (uint8_t )1,
                             code, in, len);
#line 151
  len = (size_t )tmp___0;
#line 152
  (*(tunnel->icmpv6_cb))(tunnel->opaque, (void const   *)(& buf.hdr), len, & in->ip6_src);
  }
#line 153
  return;
}
}
#line 177 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_state_change___0(teredo_state const   *state , void *self ) 
{ 
  teredo_tunnel *tunnel ;
  _Bool previously_up ;
  char b[16] ;
  char const   *tmp ;

  {
  {
#line 180
  tunnel = (teredo_tunnel *)self;
#line 182
  pthread_rwlock_wrlock(& tunnel->state_lock);
#line 183
  previously_up = tunnel->state.up;
#line 184
  tunnel->state = (teredo_state )*state;
  }
#line 186
  if (tunnel->state.up) {
    {
#line 194
    teredo_list_reset(tunnel->list, 1024U);
#line 195
    (*(tunnel->up_cb))(tunnel->opaque, (struct in6_addr  const  *)(& tunnel->state.addr.ip6),
                       tunnel->state.mtu);
#line 200
    tmp = inet_ntop(2, (void const   */* __restrict  */)(& tunnel->state.ipv4), (char */* __restrict  */)(b),
                    (socklen_t )sizeof(b));
#line 200
    debug("Internal IPv4 address: %s", tmp);
    }
  } else
#line 205
  if (previously_up) {
    {
#line 206
    (*(tunnel->down_cb))(tunnel->opaque);
    }
  }
  {
#line 213
  pthread_rwlock_unlock(& tunnel->state_lock);
  }
#line 214
  return;
}
}
#line 220 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static int CountPing___0(teredo_peer *peer , teredo_clock_t now ) 
{ 
  int res ;

  {
#line 224
  if (peer->pings == 0U) {
#line 225
    res = 0;
  } else
#line 227
  if (peer->pings >= 4U) {
#line 228
    res = -1;
  } else
#line 231
  if (((now - (teredo_clock_t )peer->last_ping) & 511UL) <= 2UL) {
#line 232
    res = 1;
  } else {
#line 234
    res = 0;
  }
#line 236
  if (res == 0) {
#line 238
    peer->last_ping = (unsigned int )now;
#line 239
    (peer->pings) ++;
  }
#line 242
  return (res);
}
}
#line 257 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static int CountBubble___0(teredo_peer *peer , teredo_clock_t now ) 
{ 
  int res ;

  {
#line 262
  if (peer->bubbles > 0U) {
#line 264
    if (peer->bubbles >= 4U) {
#line 267
      if (now - peer->last_tx <= 300UL) {
#line 268
        res = -1;
      } else {
#line 272
        peer->bubbles = 0U;
#line 273
        res = 0;
      }
    } else
#line 278
    if (now - peer->last_tx <= 2UL) {
#line 279
      res = 1;
    } else {
#line 281
      res = 0;
    }
  } else {
#line 284
    res = 0;
  }
#line 286
  if (res == 0) {
#line 288
    peer->last_tx = now;
#line 289
    (peer->bubbles) ++;
  }
#line 292
  return (res);
}
}
#line 310 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static int teredo_encap___0(teredo_tunnel * __restrict  tunnel , teredo_peer * __restrict  peer ,
                            void const   * __restrict  data , size_t len , teredo_clock_t now ) 
{ 
  uint32_t ipv4 ;
  uint16_t port ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 314
  ipv4 = peer->mapped_addr;
#line 315
  port = peer->mapped_port;
#line 316
  TouchTransmit((teredo_peer *)peer, now);
#line 317
  teredo_list_release(tunnel->list);
#line 319
  tmp___1 = teredo_send(tunnel->fd, (void const   *)data, len, ipv4, port);
  }
#line 319
  if (tmp___1 == (int )len) {
#line 319
    tmp___0 = 0;
  } else {
#line 319
    tmp___0 = -1;
  }
#line 319
  return (tmp___0);
}
}
#line 527 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_predecap___0(teredo_tunnel * __restrict  tunnel , teredo_peer * __restrict  peer ,
                                teredo_clock_t now ) 
{ 
  unsigned int tmp ;
  teredo_queue *q ;
  teredo_queue *tmp___0 ;

  {
  {
#line 531
  TouchReceive((teredo_peer *)peer, now);
#line 532
  tmp = 0U;
#line 532
  peer->pings = tmp;
#line 532
  peer->bubbles = tmp;
#line 533
  tmp___0 = teredo_peer_queue_yield((teredo_peer *)peer);
#line 533
  q = tmp___0;
#line 534
  teredo_list_release(tunnel->list);
  }
#line 536
  if ((unsigned long )q != (unsigned long )((void *)0)) {
    {
#line 537
    teredo_queue_emit(q, tunnel->fd, peer->mapped_addr, peer->mapped_port, tunnel->recv_cb,
                      tunnel->opaque);
    }
  }
#line 540
  return;
}
}
#line 552 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_run_inner___0(teredo_tunnel * __restrict  tunnel , struct teredo_packet  const  * __restrict  packet ) 
{ 
  char b[46] ;
  struct ip6_hdr *ip6 ;
  size_t length ;
  uint16_t tmp ;
  teredo_state s ;
  int tmp___0 ;
  uint32_t ipv4 ;
  uint16_t port ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  uint16_t tmp___3 ;
  char const   *tmp___4 ;
  _Bool tmp___5 ;
  char const   *tmp___6 ;
  teredo_clock_t now ;
  teredo_clock_t tmp___7 ;
  struct teredo_peerlist *list ;
  teredo_peer *p ;
  teredo_peer *tmp___8 ;
  _Bool tmp___9 ;
  int tmp___10 ;
  _Bool __constr_expr_19 ;
  _Bool tmp___11 ;
  char const   *tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  _Bool tmp___15 ;
  int tmp___16 ;
  _Bool tmp___17 ;
  _Bool create ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  int res ;
  int tmp___20 ;

  {
#line 556
  if (! ((unsigned long )tunnel != (unsigned long )((void *)0))) {
    {
#line 556
    __assert_fail("tunnel != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  556U, "teredo_run_inner");
    }
  }
#line 557
  if (! ((unsigned long )packet != (unsigned long )((void *)0))) {
    {
#line 557
    __assert_fail("packet != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  557U, "teredo_run_inner");
    }
  }
#line 562
  ip6 = (struct ip6_hdr *)packet->ip6;
#line 565
  if (packet->ip6_len < (size_t const   )sizeof(*ip6)) {
    {
#line 567
    debug("Packet size invalid: %zu bytes.", packet->ip6_len);
    }
#line 568
    return;
  }
  {
#line 571
  tmp = ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 571
  length = sizeof(*ip6) + (unsigned long )tmp;
  }
#line 572
  if ((int )ip6->ip6_ctlun.ip6_un2_vfc >> 4 != 6) {
    {
#line 575
    debug("Received malformed IPv6 packet.");
    }
#line 576
    return;
  } else
#line 572
  if (length > (size_t )packet->ip6_len) {
    {
#line 575
    debug("Received malformed IPv6 packet.");
    }
#line 576
    return;
  }
  {
#line 580
  pthread_rwlock_rdlock(& tunnel->state_lock);
#line 581
  s = tunnel->state;
#line 588
  pthread_rwlock_unlock(& tunnel->state_lock);
#line 592
  tmp___5 = IsClient((teredo_tunnel const   *)tunnel);
  }
#line 592
  if (tmp___5) {
    {
#line 594
    tmp___0 = teredo_maintenance_process((teredo_maintenance */* __restrict  */)tunnel->maintenance,
                                         packet);
    }
#line 594
    if (tmp___0 == 0) {
      {
#line 596
      debug(" packet passed to maintenance procedure");
      }
#line 597
      return;
    }
#line 600
    if (! s.up) {
      {
#line 602
      debug(" packet dropped because tunnel down");
      }
#line 603
      return;
    }
#line 606
    if (packet->source_ipv4 == (uint32_t const   )s.addr.teredo.server_ip) {
      {
#line 606
      tmp___3 = htons((uint16_t )3544);
      }
#line 606
      if ((int const   )packet->source_port == (int const   )tmp___3) {
#line 609
        ipv4 = (uint32_t )packet->orig_ipv4;
#line 610
        port = (uint16_t )packet->orig_port;
#line 612
        if (ipv4 == 0U) {
          {
#line 612
          tmp___1 = IsBubble((struct ip6_hdr  const  *)ip6);
          }
#line 612
          if (tmp___1) {
#line 612
            if (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix == (uint32_t const   )s.addr.teredo.prefix) {
#line 620
              ipv4 = (uint32_t )(((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.client_ip ^ 4294967295U);
#line 621
              port = (uint16_t )((int const   )((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.client_port ^ 65535);
            }
          }
        }
#line 624
        if (ipv4) {
          {
#line 627
          teredo_reply_bubble(tunnel->fd, ipv4, port, (struct ip6_hdr  const  *)ip6);
#line 628
          debug(" bubble sent");
#line 629
          tmp___2 = IsBubble((struct ip6_hdr  const  *)ip6);
          }
#line 629
          if (tmp___2) {
#line 630
            return;
          }
        }
      }
    }
#line 659
    if (((int )ip6->ip6_src.__in6_u.__u6_addr8[0] & 255) == 254) {
#line 659
      if (((int )ip6->ip6_src.__in6_u.__u6_addr8[1] & 192) == 128) {
#line 661
        return;
      }
    }
  } else
#line 666
  if (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix != (uint32_t const   )s.addr.teredo.prefix) {
    {
#line 668
    tmp___4 = inet_ntop(10, (void const   */* __restrict  */)(& ip6->ip6_src.__in6_u.__u6_addr8),
                        (char */* __restrict  */)(b), (socklen_t )sizeof(b));
#line 668
    debug("Source %s is not a teredo address.", tmp___4);
    }
#line 670
    return;
  }
#line 693
  if ((int )ip6->ip6_dst.__in6_u.__u6_addr8[0] == 255) {
    {
#line 695
    tmp___6 = inet_ntop(10, (void const   */* __restrict  */)(& ip6->ip6_dst.__in6_u.__u6_addr8),
                        (char */* __restrict  */)(b), (socklen_t )sizeof(b));
#line 695
    debug("Multicast destination %s not supported.", tmp___6);
    }
#line 697
    return;
  }
  {
#line 702
  tmp___7 = teredo_clock();
#line 702
  now = tmp___7;
#line 705
  list = tunnel->list;
#line 706
  tmp___8 = teredo_list_lookup((teredo_peerlist */* __restrict  */)list, (struct in6_addr  const  */* __restrict  */)(& ip6->ip6_src),
                               (_Bool */* __restrict  */)((void *)0));
#line 706
  p = tmp___8;
  }
#line 708
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 712
    if (p->trusted) {
#line 712
      if (packet->source_ipv4 == (uint32_t const   )p->mapped_addr) {
#line 712
        if ((int const   )packet->source_port == (int const   )p->mapped_port) {
          {
#line 716
          teredo_predecap___0(tunnel, (teredo_peer */* __restrict  */)p, now);
#line 717
          (*(tunnel->recv_cb))(tunnel->opaque, (void const   *)ip6, length);
          }
#line 718
          return;
        }
      }
    }
    {
#line 727
    tmp___9 = IsClient((teredo_tunnel const   *)tunnel);
    }
#line 727
    if (tmp___9) {
      {
#line 727
      tmp___10 = CheckPing((teredo_packet const   *)packet);
      }
#line 727
      if (tmp___10 == 0) {
        {
#line 729
        p->trusted = 1U;
#line 730
        SetMappingFromPacket(p, (struct teredo_packet  const  *)packet);
#line 732
        teredo_predecap___0(tunnel, (teredo_peer */* __restrict  */)p, now);
        }
#line 733
        return;
      }
    }
  }
#line 742
  if (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix == (uint32_t const   )s.addr.teredo.prefix) {
    {
#line 745
    tmp___14 = in6_matches_teredo_client((struct in6_addr  const  *)(& ip6->ip6_src),
                                         (uint32_t )packet->source_ipv4, (uint16_t )packet->source_port);
    }
#line 745
    if (tmp___14) {
#line 745
      goto _L;
    } else {
      {
#line 745
      tmp___15 = IsBubble((struct ip6_hdr  const  *)ip6);
      }
#line 745
      if (tmp___15) {
        {
#line 745
        tmp___16 = CheckBubble((teredo_packet const   *)packet);
        }
#line 745
        if (tmp___16 == 0) {
          _L: /* CIL Label */ 
          {
#line 751
          tmp___11 = IsClient((teredo_tunnel const   *)tunnel);
          }
#line 751
          if (tmp___11) {
#line 751
            if ((unsigned long )p == (unsigned long )((void *)0)) {
              {
#line 752
              __constr_expr_19 = (_Bool)0;
#line 752
              p = teredo_list_lookup((teredo_peerlist */* __restrict  */)list, (struct in6_addr  const  */* __restrict  */)(& ip6->ip6_src),
                                     (_Bool */* __restrict  */)(& __constr_expr_19));
              }
            }
          }
#line 761
          if ((unsigned long )p == (unsigned long )((void *)0)) {
            {
#line 763
            tmp___12 = inet_ntop(10, (void const   */* __restrict  */)(& ip6->ip6_src.__in6_u.__u6_addr8),
                                 (char */* __restrict  */)(b), (socklen_t )sizeof(b));
#line 763
            debug("No peer for %s found. Dropping packet.", tmp___12);
            }
#line 766
            return;
          }
          {
#line 769
          SetMappingFromPacket(p, (struct teredo_packet  const  *)packet);
#line 770
          p->trusted = 1U;
#line 771
          teredo_predecap___0(tunnel, (teredo_peer */* __restrict  */)p, now);
#line 773
          tmp___13 = IsBubble((struct ip6_hdr  const  *)ip6);
          }
#line 773
          if (! tmp___13) {
            {
#line 774
            (*(tunnel->recv_cb))(tunnel->opaque, (void const   *)ip6, length);
            }
          }
#line 775
          return;
        }
      }
    }
  } else {
#line 783
    if (! (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix != (uint32_t const   )s.addr.teredo.prefix)) {
      {
#line 783
      __assert_fail("((&((const union teredo_addr *)(&ip6->ip6_src))->teredo)->prefix) != s.addr.teredo.prefix",
                    "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c", 783U,
                    "teredo_run_inner");
      }
    }
    {
#line 784
    tmp___17 = IsClient((teredo_tunnel const   *)tunnel);
    }
#line 784
    if (! tmp___17) {
      {
#line 784
      __assert_fail("IsClient (tunnel)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                    784U, "teredo_run_inner");
      }
    }
#line 798
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 801
      p = teredo_list_lookup((teredo_peerlist */* __restrict  */)list, (struct in6_addr  const  */* __restrict  */)(& ip6->ip6_src),
                             (_Bool */* __restrict  */)(& create));
      }
#line 802
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
#line 804
        debug("Out of memory.");
        }
#line 805
        return;
      }
#line 814
      if (create) {
#line 816
        p->mapped_port = (uint16_t )0;
#line 817
        p->mapped_addr = (uint32_t )0;
#line 818
        tmp___19 = 0U;
#line 818
        p->pings = tmp___19;
#line 818
        tmp___18 = tmp___19;
#line 818
        p->bubbles = tmp___18;
#line 818
        p->trusted = tmp___18;
      }
    }
    {
#line 822
    teredo_enqueue_in((teredo_peer */* __restrict  */)p, (void const   */* __restrict  */)ip6,
                      length, (uint32_t )packet->source_ipv4, (uint16_t )packet->source_port);
#line 824
    TouchReceive(p, now);
#line 826
    tmp___20 = CountPing___0(p, now);
#line 826
    res = tmp___20;
#line 827
    teredo_list_release(list);
    }
#line 829
    if (res == 0) {
      {
#line 830
      SendPing(tunnel->fd, (union teredo_addr  const  *)(& s.addr), (struct in6_addr  const  *)(& ip6->ip6_src));
      }
    }
#line 832
    return;
  }
  {
#line 836
  debug("Dropping packet.");
  }
#line 838
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 839
    teredo_list_release(list);
    }
  }
#line 840
  return;
}
}
#line 844 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_recv_cb___0(void *o , void const   *p , size_t l ) 
{ 


  {
#line 849
  return;
}
}
#line 852 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_icmpv6_cb___0(void *o , void const   *p , size_t l , struct in6_addr  const  *d ) 
{ 


  {
#line 859
  return;
}
}
#line 863 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_state_up_cb___0(void *o , struct in6_addr  const  *a , uint16_t m ) 
{ 


  {
#line 869
  return;
}
}
#line 872 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_state_down_cb___0(void *o ) 
{ 


  {
#line 875
  return;
}
}
#line 952
static  __attribute__((__noreturn__)) void *teredo_recv_thread___0(void *t ) ;
#line 952 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void *teredo_recv_thread___0(void *t ) 
{ 
  teredo_tunnel *tunnel ;
  struct teredo_packet packet ;
  int tmp ;

  {
#line 954
  tunnel = (teredo_tunnel *)t;
  {
#line 956
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 960
    tmp = teredo_wait_recv(tunnel->fd, & packet);
    }
#line 960
    if (tmp == 0) {
      {
#line 962
      pthread_setcancelstate(1, (int *)((void *)0));
#line 963
      teredo_run_inner___0((teredo_tunnel */* __restrict  */)tunnel, (struct teredo_packet  const  */* __restrict  */)(& packet));
#line 964
      pthread_setcancelstate(0, (int *)((void *)0));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 59 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
static uint8_t const   head___0[9]  = 
#line 59 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
  {      (uint8_t const   )'`',      (uint8_t const   )'\000',      (uint8_t const   )'\000',      (uint8_t const   )'\000', 
        (uint8_t const   )'\000',      (uint8_t const   )'\000',      (uint8_t const   )';',      (uint8_t const   )'\000', 
        (uint8_t const   )'\000'};
#line 115 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
static struct in6_addr  const  in6addr_allrouters___1  =    {{{(uint8_t )255, (uint8_t )2, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0,
      (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0,
      (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )2}}};
#line 146 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.c"
static void md5_process___0(md5_state_t *pms , md5_byte_t const   *data ) 
{ 
  md5_word_t a ;
  md5_word_t b ;
  md5_word_t c ;
  md5_word_t d ;
  md5_word_t t ;
  md5_word_t xbuf[16] ;
  md5_word_t const   *X ;

  {
#line 149
  a = pms->abcd[0];
#line 149
  b = pms->abcd[1];
#line 149
  c = pms->abcd[2];
#line 149
  d = pms->abcd[3];
#line 179
  if (! ((data - (md5_byte_t const   *)0) & 3L)) {
#line 181
    X = (md5_word_t const   *)data;
  } else {
    {
#line 184
    memcpy((void */* __restrict  */)(xbuf), (void const   */* __restrict  */)data,
           (size_t )64);
#line 185
    X = (md5_word_t const   *)(xbuf);
    }
  }
#line 222
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 0)) + 3614090360U;
#line 222
  a = ((t << 7) | (t >> 25)) + b;
#line 223
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 1)) + 3905402710U;
#line 223
  d = ((t << 12) | (t >> 20)) + a;
#line 224
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 2)) + 606105819U;
#line 224
  c = ((t << 17) | (t >> 15)) + d;
#line 225
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 3)) + 3250441966U;
#line 225
  b = ((t << 22) | (t >> 10)) + c;
#line 226
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 4)) + 4118548399U;
#line 226
  a = ((t << 7) | (t >> 25)) + b;
#line 227
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 5)) + 1200080426U;
#line 227
  d = ((t << 12) | (t >> 20)) + a;
#line 228
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 6)) + 2821735955U;
#line 228
  c = ((t << 17) | (t >> 15)) + d;
#line 229
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 7)) + 4249261313U;
#line 229
  b = ((t << 22) | (t >> 10)) + c;
#line 230
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 8)) + 1770035416U;
#line 230
  a = ((t << 7) | (t >> 25)) + b;
#line 231
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 9)) + 2336552879U;
#line 231
  d = ((t << 12) | (t >> 20)) + a;
#line 232
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 10)) + 4294925233U;
#line 232
  c = ((t << 17) | (t >> 15)) + d;
#line 233
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 11)) + 2304563134U;
#line 233
  b = ((t << 22) | (t >> 10)) + c;
#line 234
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 12)) + 1804603682U;
#line 234
  a = ((t << 7) | (t >> 25)) + b;
#line 235
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 13)) + 4254626195U;
#line 235
  d = ((t << 12) | (t >> 20)) + a;
#line 236
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 14)) + 2792965006U;
#line 236
  c = ((t << 17) | (t >> 15)) + d;
#line 237
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 15)) + 1236535329U;
#line 237
  b = ((t << 22) | (t >> 10)) + c;
#line 248
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 1)) + 4129170786U;
#line 248
  a = ((t << 5) | (t >> 27)) + b;
#line 249
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 6)) + 3225465664U;
#line 249
  d = ((t << 9) | (t >> 23)) + a;
#line 250
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 11)) + 643717713U;
#line 250
  c = ((t << 14) | (t >> 18)) + d;
#line 251
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 0)) + 3921069994U;
#line 251
  b = ((t << 20) | (t >> 12)) + c;
#line 252
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 5)) + 3593408605U;
#line 252
  a = ((t << 5) | (t >> 27)) + b;
#line 253
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 10)) + 38016083U;
#line 253
  d = ((t << 9) | (t >> 23)) + a;
#line 254
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 15)) + 3634488961U;
#line 254
  c = ((t << 14) | (t >> 18)) + d;
#line 255
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 4)) + 3889429448U;
#line 255
  b = ((t << 20) | (t >> 12)) + c;
#line 256
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 9)) + 568446438U;
#line 256
  a = ((t << 5) | (t >> 27)) + b;
#line 257
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 14)) + 3275163606U;
#line 257
  d = ((t << 9) | (t >> 23)) + a;
#line 258
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 3)) + 4107603335U;
#line 258
  c = ((t << 14) | (t >> 18)) + d;
#line 259
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 8)) + 1163531501U;
#line 259
  b = ((t << 20) | (t >> 12)) + c;
#line 260
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 13)) + 2850285829U;
#line 260
  a = ((t << 5) | (t >> 27)) + b;
#line 261
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 2)) + 4243563512U;
#line 261
  d = ((t << 9) | (t >> 23)) + a;
#line 262
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 7)) + 1735328473U;
#line 262
  c = ((t << 14) | (t >> 18)) + d;
#line 263
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 12)) + 2368359562U;
#line 263
  b = ((t << 20) | (t >> 12)) + c;
#line 274
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 5)) + 4294588738U;
#line 274
  a = ((t << 4) | (t >> 28)) + b;
#line 275
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 8)) + 2272392833U;
#line 275
  d = ((t << 11) | (t >> 21)) + a;
#line 276
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 11)) + 1839030562U;
#line 276
  c = ((t << 16) | (t >> 16)) + d;
#line 277
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 14)) + 4259657740U;
#line 277
  b = ((t << 23) | (t >> 9)) + c;
#line 278
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 1)) + 2763975236U;
#line 278
  a = ((t << 4) | (t >> 28)) + b;
#line 279
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 4)) + 1272893353U;
#line 279
  d = ((t << 11) | (t >> 21)) + a;
#line 280
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 7)) + 4139469664U;
#line 280
  c = ((t << 16) | (t >> 16)) + d;
#line 281
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 10)) + 3200236656U;
#line 281
  b = ((t << 23) | (t >> 9)) + c;
#line 282
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 13)) + 681279174U;
#line 282
  a = ((t << 4) | (t >> 28)) + b;
#line 283
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 0)) + 3936430074U;
#line 283
  d = ((t << 11) | (t >> 21)) + a;
#line 284
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 3)) + 3572445317U;
#line 284
  c = ((t << 16) | (t >> 16)) + d;
#line 285
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 6)) + 76029189U;
#line 285
  b = ((t << 23) | (t >> 9)) + c;
#line 286
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 9)) + 3654602809U;
#line 286
  a = ((t << 4) | (t >> 28)) + b;
#line 287
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 12)) + 3873151461U;
#line 287
  d = ((t << 11) | (t >> 21)) + a;
#line 288
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 15)) + 530742520U;
#line 288
  c = ((t << 16) | (t >> 16)) + d;
#line 289
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 2)) + 3299628645U;
#line 289
  b = ((t << 23) | (t >> 9)) + c;
#line 300
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 0)) + 4096336452U;
#line 300
  a = ((t << 6) | (t >> 26)) + b;
#line 301
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 7)) + 1126891415U;
#line 301
  d = ((t << 10) | (t >> 22)) + a;
#line 302
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 14)) + 2878612391U;
#line 302
  c = ((t << 15) | (t >> 17)) + d;
#line 303
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 5)) + 4237533241U;
#line 303
  b = ((t << 21) | (t >> 11)) + c;
#line 304
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 12)) + 1700485571U;
#line 304
  a = ((t << 6) | (t >> 26)) + b;
#line 305
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 3)) + 2399980690U;
#line 305
  d = ((t << 10) | (t >> 22)) + a;
#line 306
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 10)) + 4293915773U;
#line 306
  c = ((t << 15) | (t >> 17)) + d;
#line 307
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 1)) + 2240044497U;
#line 307
  b = ((t << 21) | (t >> 11)) + c;
#line 308
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 8)) + 1873313359U;
#line 308
  a = ((t << 6) | (t >> 26)) + b;
#line 309
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 15)) + 4264355552U;
#line 309
  d = ((t << 10) | (t >> 22)) + a;
#line 310
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 6)) + 2734768916U;
#line 310
  c = ((t << 15) | (t >> 17)) + d;
#line 311
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 13)) + 1309151649U;
#line 311
  b = ((t << 21) | (t >> 11)) + c;
#line 312
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 4)) + 4149444226U;
#line 312
  a = ((t << 6) | (t >> 26)) + b;
#line 313
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 11)) + 3174756917U;
#line 313
  d = ((t << 10) | (t >> 22)) + a;
#line 314
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 2)) + 718787259U;
#line 314
  c = ((t << 15) | (t >> 17)) + d;
#line 315
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 9)) + 3951481745U;
#line 315
  b = ((t << 21) | (t >> 11)) + c;
#line 321
  pms->abcd[0] += a;
#line 322
  pms->abcd[1] += b;
#line 323
  pms->abcd[2] += c;
#line 324
  pms->abcd[3] += d;
#line 325
  return;
}
}
#line 378 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.c"
static md5_byte_t const   pad___0[64]  = 
#line 378
  {      (md5_byte_t const   )128,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0};
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 60 "/home/wheatley/newnew/temp/miredo-1.2.6/src/privproc.c"
static char const   script_path[34]  = 
#line 60 "/home/wheatley/newnew/temp/miredo-1.2.6/src/privproc.c"
  {      (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
        (char const   )'/',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'a',      (char const   )'l',      (char const   )'/',      (char const   )'e', 
        (char const   )'t',      (char const   )'c',      (char const   )'/',      (char const   )'m', 
        (char const   )'i',      (char const   )'r',      (char const   )'e',      (char const   )'d', 
        (char const   )'o',      (char const   )'/',      (char const   )'c',      (char const   )'l', 
        (char const   )'i',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )'-',      (char const   )'h',      (char const   )'o',      (char const   )'o', 
        (char const   )'k',      (char const   )'\000'};
#line 66 "/home/wheatley/newnew/temp/miredo-1.2.6/src/privproc.c"
static int run_script(void) 
{ 
  pid_t pid ;
  __pid_t tmp ;
  sigset_t emptyset ;
  int tmp___0 ;
  int tmp___1 ;
  int res ;
  __pid_t tmp___2 ;
  union __anonunion_84 __constr_expr_20 ;
  union __anonunion_85 __constr_expr_21 ;

  {
  {
#line 68
  tmp = fork();
#line 68
  pid = tmp;
  }
  {
#line 72
  if (pid == -1) {
#line 72
    goto case_neg_1;
  }
#line 75
  if (pid == 0) {
#line 75
    goto case_0;
  }
#line 70
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 73
  return (-1);
  case_0: /* CIL Label */ 
  {
#line 78
  sigemptyset(& emptyset);
#line 79
  pthread_sigmask(2, (__sigset_t const   */* __restrict  */)(& emptyset), (__sigset_t */* __restrict  */)((void *)0));
#line 81
  tmp___0 = dup2(2, 0);
  }
#line 81
  if (tmp___0 == 0) {
    {
#line 81
    tmp___1 = dup2(2, 1);
    }
#line 81
    if (tmp___1 == 1) {
      {
#line 82
      execl(script_path, script_path, (char *)((void *)0));
      }
    }
  }
  {
#line 84
  syslog(3, "Could not execute %s: %m", script_path);
#line 86
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    tmp___2 = waitpid(pid, & res, 0);
    }
#line 91
    if (! (tmp___2 == -1)) {
#line 91
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  __constr_expr_21.__in = res;
#line 93
  if ((__constr_expr_21.__i & 127) == 0) {
#line 94
    __constr_expr_20.__in = res;
#line 94
    return ((__constr_expr_20.__i & 65280) >> 8);
  }
#line 96
  return (-1);
}
}
#line 67 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static unsigned int const   teredo_MaxQueueBytes___0  =    (unsigned int const   )1280;
#line 70 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
__inline static void teredo_peer_init___0(teredo_peer *peer ) 
{ 


  {
#line 72
  peer->queue = (teredo_queue *)((void *)0);
#line 73
  peer->queue_left = (size_t )teredo_MaxQueueBytes___0;
#line 74
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void teredo_peer_queue___0(teredo_peer * __restrict  peer , void const   * __restrict  data ,
                                  size_t len , uint32_t ip , uint16_t port , _Bool incoming ) 
{ 
  teredo_queue *p ;
  void *tmp ;

  {
#line 98
  if (len > peer->queue_left) {
#line 99
    return;
  }
  {
#line 100
  peer->queue_left -= len;
#line 102
  tmp = malloc(sizeof(*p) + len);
#line 102
  p = (teredo_queue *)tmp;
#line 103
  p->length = len;
#line 104
  memcpy((void */* __restrict  */)(p->data), data, len);
#line 105
  p->ipv4 = ip;
#line 106
  p->port = port;
#line 107
  p->incoming = incoming;
#line 109
  p->next = peer->queue;
#line 110
  peer->queue = p;
  }
#line 111
  return;
}
}
#line 181 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
__inline static teredo_listitem *listitem_create___0(void) 
{ 
  teredo_listitem *entry ;
  void *tmp ;

  {
  {
#line 183
  tmp = malloc(sizeof(*entry));
#line 183
  entry = (teredo_listitem *)tmp;
  }
#line 184
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
    {
#line 185
    teredo_peer_init___0(& entry->peer);
    }
  }
#line 186
  return (entry);
}
}
#line 197 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void listitem_recdestroy___0(teredo_listitem *entry ) 
{ 
  teredo_listitem *buf ;

  {
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 199
      goto while_break;
    }
    {
#line 201
    buf = entry->next;
#line 202
    listitem_destroy(entry);
#line 203
    entry = buf;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 208 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void listitem_free___0(void *p ) 
{ 


  {
#line 211
  return;
}
}
#line 213 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static int listitem_cmp___0(void const   *pa , void const   *pb ) 
{ 
  struct in6_addr  const  * const  *a ;
  struct in6_addr  const  * const  *b ;
  int tmp ;

  {
  {
#line 215
  a = (struct in6_addr  const  * const  *)pa;
#line 215
  b = (struct in6_addr  const  * const  *)pb;
#line 217
  tmp = memcmp((void const   *)a, (void const   *)b, sizeof(*(*a)));
  }
#line 217
  return (tmp);
}
}
#line 228
static  __attribute__((__noreturn__)) void *garbage_collector___0(void *data ) ;
#line 228 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void *garbage_collector___0(void *data ) 
{ 
  struct teredo_peerlist *l ;
  struct timespec delay ;
  int tmp ;
  int state ;
  teredo_listitem *p ;
  teredo_listitem **pp ;
  void *tmp___0 ;
  teredo_listitem *old ;

  {
#line 230
  l = (struct teredo_peerlist *)data;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    delay.tv_sec = (__time_t )l->expiration;
#line 234
    delay.tv_nsec = 0L;
    {
#line 235
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 235
      tmp = clock_nanosleep(0, 0, (struct timespec  const  *)(& delay), & delay);
      }
#line 235
      if (! tmp) {
#line 235
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 238
    pthread_setcancelstate(1, & state);
#line 240
    d_pthread_mutex_lock(& l->lock);
#line 243
    p = l->old;
    }
    {
#line 243
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 243
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 243
        goto while_break___1;
      }
      {
#line 253
      tmp___0 = tdelete((void const   */* __restrict  */)(& p->key.ip6), (void **/* __restrict  */)(& l->root),
                        & listitem_cmp___0);
#line 253
      pp = (teredo_listitem **)tmp___0;
      }
#line 254
      if (! ((unsigned long )pp != (unsigned long )((void *)0))) {
        {
#line 254
        __assert_fail("pp != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c",
                      254U, "garbage_collector");
        }
      }
#line 256
      (l->left) ++;
#line 243
      p = p->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 260
    old = l->old;
#line 263
    l->old = l->recent;
#line 264
    l->recent = (teredo_listitem *)((void *)0);
#line 265
    if ((unsigned long )l->old != (unsigned long )((void *)0)) {
#line 266
      (l->old)->pprev = & l->old;
    }
    {
#line 268
    d_pthread_mutex_unlock(& l->lock);
#line 271
    sched_yield();
#line 272
    listitem_recdestroy___0(old);
#line 275
    pthread_setcancelstate(state, (int *)((void *)0));
#line 276
    sched_yield();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 46 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static char const   randfile___0[12]  = 
#line 46 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
  {      (char const   )'/',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'/',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'o',      (char const   )'m',      (char const   )'\000'};
#line 57 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static union __anonunion_inner_key_40___0 inner_key___0  ;
#line 63 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static union __anonunion_outer_key_41___0 outer_key___0  ;
#line 70 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static uint16_t hmac_pid___0  =    (uint16_t )0;
#line 74 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static pthread_mutex_t mutex___0  =    {{0, 0U, 0, 0U, 2, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 125 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static void teredo_hash___0(void const   *src , size_t slen , void const   *dst ,
                            size_t dlen , uint8_t * __restrict  hash , uint32_t timestamp ) 
{ 
  md5_state_t ctx ;

  {
  {
#line 131
  md5_init(& ctx);
#line 132
  md5_append(& ctx, (md5_byte_t const   *)(inner_key___0.ipad), (int )sizeof(inner_key___0.ipad));
#line 133
  md5_append(& ctx, (unsigned char const   *)src, (int )slen);
#line 134
  md5_append(& ctx, (unsigned char const   *)dst, (int )dlen);
#line 135
  md5_append(& ctx, (unsigned char const   *)(& hmac_pid___0), (int )sizeof(hmac_pid___0));
#line 136
  md5_append(& ctx, (unsigned char const   *)(& timestamp), (int )sizeof(timestamp));
#line 137
  md5_finish(& ctx, (md5_byte_t *)hash);
#line 139
  md5_init(& ctx);
#line 140
  md5_append(& ctx, (md5_byte_t const   *)(outer_key___0.opad), (int )sizeof(outer_key___0.opad));
#line 141
  md5_append(& ctx, (md5_byte_t const   *)hash, 16);
#line 142
  md5_finish(& ctx, (md5_byte_t *)hash);
  }
#line 143
  return;
}
}
#line 157 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
__inline static void teredo_pinghash___0(struct in6_addr  const  *src , struct in6_addr  const  *dst ,
                                         uint8_t * __restrict  hash , uint32_t timestamp ) 
{ 


  {
  {
#line 161
  teredo_hash___0((void const   *)src, sizeof(*src), (void const   *)dst, sizeof(*dst),
                  hash, timestamp);
  }
#line 162
  return;
}
}
#line 172 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
static char const   tundev___0[13]  = 
#line 172 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
  {      (char const   )'/',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'/',      (char const   )'n',      (char const   )'e',      (char const   )'t', 
        (char const   )'/',      (char const   )'t',      (char const   )'u',      (char const   )'n', 
        (char const   )'\000'};
#line 416 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
static int proc_write_zero___0(char const   *path___0 ) 
{ 
  int fd ;
  int tmp ;
  int retval ;
  ssize_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 419
  tmp = open(path___0, 1);
#line 419
  fd = tmp;
  }
#line 420
  if (fd == -1) {
#line 421
    return (-1);
  }
  {
#line 423
  retval = 0;
#line 425
  tmp___0 = write(fd, (void const   *)"0", (size_t )1);
  }
#line 425
  if (tmp___0 != 1L) {
#line 426
    retval = -1;
  }
  {
#line 427
  tmp___1 = close(fd);
  }
#line 427
  if (tmp___1) {
#line 428
    retval = -1;
  }
#line 430
  return (retval);
}
}
#line 506 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
static int _iface_addr___0(int reqfd , int id , _Bool add , struct in6_addr  const  *addr ,
                           unsigned int prefix_len ) 
{ 
  void *req ;
  long cmd ;
  union __anonunion_r_47___0 r ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 510
  req = (void *)0;
#line 511
  cmd = 0L;
#line 513
  if (! (reqfd != -1)) {
    {
#line 513
    __assert_fail("reqfd != -1", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  513U, "_iface_addr");
    }
  }
#line 514
  if (! (id != 0)) {
    {
#line 514
    __assert_fail("id != 0", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  514U, "_iface_addr");
    }
  }
#line 516
  if (prefix_len > 128U) {
#line 517
    return (-1);
  } else
#line 516
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 517
    return (-1);
  }
  {
#line 529
  memset((void *)(& r), 0, sizeof(r));
#line 530
  r.req6.ifr6_ifindex = id;
#line 531
  memcpy((void */* __restrict  */)(& r.req6.ifr6_addr), (void const   */* __restrict  */)addr,
         sizeof(r.req6.ifr6_addr));
#line 532
  r.req6.ifr6_prefixlen = prefix_len;
  }
#line 534
  if (add) {
#line 534
    cmd = 35094L;
  } else {
#line 534
    cmd = 35126L;
  }
  {
#line 535
  req = (void *)(& r);
#line 581
  tmp___1 = ioctl(reqfd, (unsigned long )cmd, req);
  }
#line 581
  if (tmp___1 >= 0) {
#line 581
    tmp___0 = 0;
  } else {
#line 581
    tmp___0 = -1;
  }
#line 581
  return (tmp___0);
}
}
#line 585 "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c"
static int _iface_route___0(int reqfd , int id , _Bool add , struct in6_addr  const  *addr ,
                            unsigned int prefix_len , int rel_metric ) 
{ 
  int retval ;
  struct in6_rtmsg req6 ;
  int tmp ;
  int tmp___0 ;

  {
#line 589
  if (! (reqfd != -1)) {
    {
#line 589
    __assert_fail("reqfd != -1", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  589U, "_iface_route");
    }
  }
#line 590
  if (! (id != 0)) {
    {
#line 590
    __assert_fail("id != 0", "/home/wheatley/newnew/temp/miredo-1.2.6/libtun6/tun6.c",
                  590U, "_iface_route");
    }
  }
#line 592
  if (prefix_len > 128U) {
#line 593
    return (-1);
  } else
#line 592
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 593
    return (-1);
  }
  {
#line 595
  retval = -1;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[0] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[1] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[2] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[3] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[4] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[5] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[6] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[7] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[8] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[9] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[10] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[11] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[12] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[13] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[14] = (unsigned char)0;
#line 601
  req6.rtmsg_dst.__in6_u.__u6_addr8[15] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[0] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[1] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[2] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[3] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[4] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[5] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[6] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[7] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[8] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[9] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[10] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[11] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[12] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[13] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[14] = (unsigned char)0;
#line 601
  req6.rtmsg_src.__in6_u.__u6_addr8[15] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[0] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[1] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[2] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[3] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[4] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[5] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[6] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[7] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[8] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[9] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[10] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[11] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[12] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[13] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[14] = (unsigned char)0;
#line 601
  req6.rtmsg_gateway.__in6_u.__u6_addr8[15] = (unsigned char)0;
#line 601
  req6.rtmsg_type = 0U;
#line 601
  req6.rtmsg_dst_len = (unsigned short )prefix_len;
#line 601
  req6.rtmsg_src_len = (unsigned short)0;
#line 601
  req6.rtmsg_metric = (u_int32_t )(1024 + rel_metric);
#line 601
  req6.rtmsg_info = 0UL;
#line 601
  req6.rtmsg_flags = (u_int32_t )1;
#line 601
  req6.rtmsg_ifindex = id;
#line 612
  memcpy((void */* __restrict  */)(& req6.rtmsg_dst), (void const   */* __restrict  */)addr,
         sizeof(req6.rtmsg_dst));
  }
#line 613
  if (prefix_len == 128U) {
#line 614
    req6.rtmsg_flags |= 4U;
  }
#line 617
  if (add) {
#line 617
    tmp = 35083;
  } else {
#line 617
    tmp = 35084;
  }
  {
#line 617
  tmp___0 = ioctl(reqfd, (unsigned long )tmp, & req6);
  }
#line 617
  if (tmp___0 == 0) {
#line 618
    retval = 0;
  }
#line 710
  return (retval);
}
}
#line 107 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static int getipv4byname___1(char const   * __restrict  name , uint32_t * __restrict  ipv4 ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *res ;
  int val ;
  int tmp ;

  {
  {
#line 109
  hints.ai_flags = 0;
#line 109
  hints.ai_family = 2;
#line 109
  hints.ai_socktype = 2;
#line 109
  hints.ai_protocol = 0;
#line 109
  hints.ai_addrlen = 0U;
#line 109
  hints.ai_addr = (struct sockaddr *)0;
#line 109
  hints.ai_canonname = (char *)0;
#line 109
  hints.ai_next = (struct addrinfo *)0;
#line 115
  tmp = getaddrinfo(name, (char const   */* __restrict  */)((void *)0), (struct addrinfo  const  */* __restrict  */)(& hints),
                    (struct addrinfo **/* __restrict  */)(& res));
#line 115
  val = tmp;
  }
#line 116
  if (val) {
#line 117
    return (val);
  }
  {
#line 119
  *ipv4 = (uint32_t )((struct sockaddr_in  const  *)res->ai_addr)->sin_addr.s_addr;
#line 120
  freeaddrinfo(res);
  }
#line 122
  return (0);
}
}
#line 131 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static int maintenance_recv___1(teredo_packet const   * __restrict  packet , uint32_t server_ip ,
                                uint8_t const   * __restrict  nonce , _Bool cone ,
                                teredo_state * __restrict  state ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 136
  if (! packet->auth_present) {
    {
#line 136
    __assert_fail("packet->auth_present", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c",
                  136U, "maintenance_recv");
    }
  }
  {
#line 138
  tmp = memcmp((void const   *)(packet->auth_nonce), (void const   *)nonce, (size_t )8);
  }
#line 138
  if (tmp) {
#line 139
    return (1);
  }
#line 142
  if (packet->auth_fail) {
    {
#line 144
    tmp___0 = dgettext("miredo", "Authentication with server failed.");
#line 144
    syslog(3, (char const   *)tmp___0);
    }
#line 145
    return (13);
  }
  {
#line 148
  tmp___1 = teredo_parse_ra(packet, (union teredo_addr */* __restrict  */)(& state->addr),
                            cone, (uint16_t */* __restrict  */)(& state->mtu));
  }
#line 148
  if (tmp___1) {
#line 151
    return (22);
  } else
#line 148
  if (state->addr.teredo.server_ip != server_ip) {
#line 151
    return (22);
  }
#line 154
  state->ipv4 = (uint32_t )packet->dest_ipv4;
#line 155
  return (0);
}
}
#line 163 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static int wait_reply___1(teredo_maintenance * __restrict  m , struct timespec  const  * __restrict  deadline ) 
{ 
  int tmp ;

  {
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! ((unsigned long )m->incoming == (unsigned long )((void *)0))) {
#line 166
      goto while_break;
    }
    {
#line 168
    tmp = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& m->received),
                                 (pthread_mutex_t */* __restrict  */)(& m->inner),
                                 deadline);
    }
    {
#line 170
    if (tmp == 0) {
#line 170
      goto case_0;
    }
#line 172
    if (tmp == 110) {
#line 172
      goto case_110;
    }
#line 168
    goto switch_break;
    case_0: /* CIL Label */ 
#line 171
    goto switch_break;
    case_110: /* CIL Label */ 
#line 173
    return (110);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return (0);
}
}
#line 184 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static void wait_reply_ignore___1(teredo_maintenance * __restrict  m , struct timespec  const  * __restrict  deadline ) 
{ 
  int tmp ;

  {
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 187
    tmp = wait_reply___1(m, deadline);
    }
#line 187
    if (! (tmp == 0)) {
#line 187
      goto while_break;
    }
    {
#line 189
    m->incoming = (teredo_packet const   *)((void *)0);
#line 190
    pthread_cond_signal(& m->processed);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 199 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static _Bool checkTimeDrift___1(struct timespec *ts ) 
{ 
  struct timespec now ;
  char *tmp ;

  {
  {
#line 203
  gettime(& now);
  }
#line 205
  if (now.tv_sec > ts->tv_sec) {
    {
#line 209
    tmp = dgettext("miredo", "Too much time drift. Resynchronizing.");
#line 209
    syslog(4, (char const   *)tmp);
#line 210
    *ts = now;
    }
#line 211
    return ((_Bool)0);
  } else
#line 205
  if (now.tv_sec == ts->tv_sec) {
#line 205
    if (now.tv_nsec > ts->tv_nsec) {
      {
#line 209
      tmp = dgettext("miredo", "Too much time drift. Resynchronizing.");
#line 209
      syslog(4, (char const   *)tmp);
#line 210
      *ts = now;
      }
#line 211
      return ((_Bool)0);
    }
  }
#line 213
  return ((_Bool)1);
}
}
#line 217 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static void cleanup_unlock___1(void *o ) 
{ 


  {
  {
#line 220
  d_pthread_mutex_unlock((pthread_mutex_t *)o);
  }
#line 221
  return;
}
}
#line 241
__inline static  __attribute__((__noreturn__)) void maintenance_thread___1(teredo_maintenance *m ) ;
#line 241 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
__inline static void maintenance_thread___1(teredo_maintenance *m ) 
{ 
  struct timespec deadline ;
  teredo_state *c_state ;
  uint32_t server_ip ;
  unsigned int count ;
  enum __anonenum_last_error_87___1 last_error ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp ;
  long tmp___0 ;
  int val ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;
  uint8_t nonce[8] ;
  uint16_t tmp___7 ;
  int val___0 ;
  teredo_state newst ;
  unsigned int delay ;
  char *tmp___8 ;
  char *tmp___9 ;
  uint16_t f ;
  uint16_t tmp___10 ;
  uint16_t tmp___11 ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp___12 ;
  char *tmp___13 ;
  struct in6_addr  const  *__a___0 ;
  struct in6_addr  const  *__b___0 ;
  int tmp___14 ;

  {
  {
#line 244
  deadline.tv_sec = (__time_t )0;
#line 244
  deadline.tv_nsec = (__syscall_slong_t )0;
#line 245
  c_state = & m->state.state;
#line 246
  server_ip = (uint32_t )0;
#line 247
  count = 0U;
#line 248
  last_error = (enum __anonenum_last_error_87___1 )0;
#line 254
  d_pthread_mutex_lock(& m->inner);
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 259
    __cancel_routine = & cleanup_unlock___1;
#line 259
    __cancel_arg = (void *)(& m->inner);
#line 259
    tmp = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                      0);
#line 259
    __not_first_call = tmp;
#line 259
    tmp___0 = __builtin_expect((long )__not_first_call, 0L);
    }
#line 259
    if (tmp___0) {
      {
#line 259
      (*__cancel_routine)(__cancel_arg);
#line 259
      __pthread_unwind_next(& __cancel_buf);
      }
    }
    {
#line 259
    __pthread_register_cancel(& __cancel_buf);
    }
    {
#line 259
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 260
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 263
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 263
          if (! (server_ip == 0U)) {
#line 263
            goto while_break___2;
          }
          {
#line 266
          tmp___1 = getipv4byname___1((char const   */* __restrict  */)m->server,
                                      (uint32_t */* __restrict  */)(& server_ip));
#line 266
          val = tmp___1;
#line 267
          gettime(& deadline);
          }
#line 269
          if (val) {
            {
#line 272
            tmp___2 = gai_strerror(val);
#line 272
            tmp___3 = dgettext("miredo", "Cannot resolve Teredo server address \"%s\": %s");
#line 272
            syslog(3, (char const   *)tmp___3, m->server, tmp___2);
            }
          } else {
            {
#line 277
            tmp___5 = is_ipv4_global_unicast(server_ip);
            }
#line 277
            if (tmp___5) {
#line 286
              if (! (! c_state->up)) {
                {
#line 286
                __assert_fail("!c_state->up", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c",
                              286U, "maintenance_thread");
                }
              }
              {
#line 287
              c_state->addr.teredo.server_ip = server_ip;
#line 288
              (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
              }
#line 289
              goto while_break___2;
            } else {
              {
#line 279
              tmp___4 = dgettext("miredo", "Teredo server has a non global IPv4 address.");
#line 279
              syslog(3, (char const   *)tmp___4);
              }
            }
          }
          {
#line 293
          deadline.tv_sec += (__time_t )m->restart_delay;
#line 294
          server_ip = (uint32_t )0;
#line 295
          wait_reply_ignore___1((teredo_maintenance */* __restrict  */)m, (struct timespec  const  */* __restrict  */)(& deadline));
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 299
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 300
          deadline.tv_sec += (__time_t )m->qualification_delay;
#line 299
          tmp___6 = checkTimeDrift___1(& deadline);
          }
#line 299
          if (tmp___6) {
#line 299
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 304
        tmp___7 = htons((uint16_t )3544);
#line 304
        teredo_get_nonce((uint32_t )deadline.tv_sec, server_ip, tmp___7, (uint8_t */* __restrict  */)(nonce));
#line 306
        teredo_send_rs(m->fd, server_ip, (unsigned char const   *)(nonce), (_Bool)0);
#line 308
        val___0 = 0;
#line 310
        newst.mtu = (uint16_t )1280;
#line 311
        newst.up = (_Bool)1;
        }
        {
#line 314
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 316
          val___0 = wait_reply___1((teredo_maintenance */* __restrict  */)m, (struct timespec  const  */* __restrict  */)(& deadline));
          }
#line 317
          if (val___0) {
#line 318
            goto __Cont;
          }
          {
#line 321
          val___0 = maintenance_recv___1((teredo_packet const   */* __restrict  */)m->incoming,
                                         server_ip, (uint8_t const   */* __restrict  */)(nonce),
                                         (_Bool)0, (teredo_state */* __restrict  */)(& newst));
#line 323
          m->incoming = (teredo_packet const   *)((void *)0);
#line 324
          pthread_cond_signal(& m->processed);
          }
          __Cont: /* CIL Label */ 
#line 314
          if (val___0 != 0) {
#line 314
            if (! (val___0 != 110)) {
#line 314
              goto while_break___4;
            }
          } else {
#line 314
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 328
        delay = 0U;
#line 331
        if (val___0) {
#line 334
          count ++;
#line 336
          if (count >= m->qualification_retries) {
#line 338
            count = 0U;
#line 341
            if ((unsigned int )last_error != 1U) {
              {
#line 343
              tmp___8 = dgettext("miredo", "No reply from Teredo server");
#line 343
              syslog(6, (char const   *)tmp___8);
#line 344
              last_error = (enum __anonenum_last_error_87___1 )1;
              }
            }
#line 347
            if (c_state->up) {
              {
#line 349
              tmp___9 = dgettext("miredo", "Lost Teredo connectivity");
#line 349
              syslog(5, (char const   *)tmp___9);
#line 350
              c_state->up = (_Bool)0;
#line 351
              (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
#line 352
              server_ip = (uint32_t )0;
              }
            }
#line 356
            delay = m->restart_delay;
          }
        } else {
#line 362
          count = 0U;
#line 365
          newst.addr.teredo.flags = c_state->addr.teredo.flags;
#line 366
          __a = (struct in6_addr  const  *)(& c_state->addr.ip6);
#line 366
          __b = (struct in6_addr  const  *)(& newst.addr.ip6);
#line 366
          if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 366
            if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 366
              if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 366
                if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 366
                  tmp___12 = 1;
                } else {
#line 366
                  tmp___12 = 0;
                }
              } else {
#line 366
                tmp___12 = 0;
              }
            } else {
#line 366
              tmp___12 = 0;
            }
          } else {
#line 366
            tmp___12 = 0;
          }
#line 366
          if (! tmp___12) {
            {
#line 368
            tmp___10 = teredo_get_flbits((uint32_t )deadline.tv_sec);
#line 368
            f = tmp___10;
#line 369
            tmp___11 = htons((uint16_t )15615);
#line 369
            newst.addr.teredo.flags = (uint16_t )((int )f & (int )tmp___11);
            }
          }
#line 374
          if (! c_state->up) {
            {
#line 377
            memcpy((void */* __restrict  */)c_state, (void const   */* __restrict  */)(& newst),
                   sizeof(*c_state));
#line 379
            tmp___13 = dgettext("miredo", "New Teredo address/MTU");
#line 379
            syslog(5, (char const   *)tmp___13);
#line 380
            (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
            }
          } else {
#line 374
            __a___0 = (struct in6_addr  const  *)(& c_state->addr.ip6);
#line 374
            __b___0 = (struct in6_addr  const  *)(& newst.addr.ip6);
#line 374
            if (__a___0->__in6_u.__u6_addr32[0] == __b___0->__in6_u.__u6_addr32[0]) {
#line 374
              if (__a___0->__in6_u.__u6_addr32[1] == __b___0->__in6_u.__u6_addr32[1]) {
#line 374
                if (__a___0->__in6_u.__u6_addr32[2] == __b___0->__in6_u.__u6_addr32[2]) {
#line 374
                  if (__a___0->__in6_u.__u6_addr32[3] == __b___0->__in6_u.__u6_addr32[3]) {
#line 374
                    tmp___14 = 1;
                  } else {
#line 374
                    tmp___14 = 0;
                  }
                } else {
#line 374
                  tmp___14 = 0;
                }
              } else {
#line 374
                tmp___14 = 0;
              }
            } else {
#line 374
              tmp___14 = 0;
            }
#line 374
            if (tmp___14) {
#line 374
              if ((int )c_state->mtu != (int )newst.mtu) {
                {
#line 377
                memcpy((void */* __restrict  */)c_state, (void const   */* __restrict  */)(& newst),
                       sizeof(*c_state));
#line 379
                tmp___13 = dgettext("miredo", "New Teredo address/MTU");
#line 379
                syslog(5, (char const   *)tmp___13);
#line 380
                (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
                }
              }
            } else {
              {
#line 377
              memcpy((void */* __restrict  */)c_state, (void const   */* __restrict  */)(& newst),
                     sizeof(*c_state));
#line 379
              tmp___13 = dgettext("miredo", "New Teredo address/MTU");
#line 379
              syslog(5, (char const   *)tmp___13);
#line 380
              (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
              }
            }
          }
#line 384
          last_error = (enum __anonenum_last_error_87___1 )0;
#line 385
          delay = m->refresh_delay;
        }
#line 391
        if (delay) {
          {
#line 393
          deadline.tv_sec -= (__time_t )m->qualification_delay;
#line 394
          deadline.tv_sec += (__time_t )delay;
#line 395
          wait_reply_ignore___1((teredo_maintenance */* __restrict  */)m, (struct timespec  const  */* __restrict  */)(& deadline));
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 399
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 399
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 259
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 399
    __pthread_unregister_cancel(& __cancel_buf);
#line 399
    (*__cancel_routine)(__cancel_arg);
    }
#line 259
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 403
static  __attribute__((__noreturn__)) void *do_maintenance___1(void *opaque ) ;
#line 403 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static void *do_maintenance___1(void *opaque ) 
{ 


  {
  {
#line 405
  maintenance_thread___1((teredo_maintenance *)opaque);
  }
}
}
#line 409 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   QualificationDelay___1  =    (unsigned int const   )4;
#line 410 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   QualificationRetries___1  =    (unsigned int const   )3;
#line 412 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   RefreshDelay___1  =    (unsigned int const   )30;
#line 413 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   RestartDelay___1  =    (unsigned int const   )100;
#line 49 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
static void clock_tick___1(union sigval val ) 
{ 
  clock_data_t *context ;
  int orun ;
  int tmp ;
  struct itimerspec it ;

  {
  {
#line 51
  context = (clock_data_t *)val.sival_ptr;
#line 53
  tmp = timer_getoverrun(context->handle);
#line 53
  orun = tmp;
#line 54
  context->value += (teredo_clock_t )(1 + orun);
  }
#line 57
  if (orun == 2147483647) {
#line 59
    context->active = (_Bool)0;
  }
#line 62
  if (! context->active) {
    {
#line 64
    it.it_interval.tv_sec = 0L;
#line 64
    it.it_interval.tv_nsec = 0L;
#line 64
    it.it_value.tv_sec = (__time_t )0;
#line 64
    it.it_value.tv_nsec = (__syscall_slong_t )0;
#line 68
    timer_settime(context->handle, 0, (struct itimerspec  const  */* __restrict  */)(& it),
                  (struct itimerspec */* __restrict  */)((void *)0));
    }
  }
#line 71
  context->active = (_Bool)0;
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
static clock_data_t clk___1  =    {(void *)0, (teredo_clock_t )0, (_Bool)0};
#line 82 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
static struct __anonstruct_priv_55___1 priv___1  =    {{{0, 0U, 0, 0U, 2, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}},
    0, (_Bool)0};
#line 117 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
static ssize_t teredo_recverr___1(int fd ) 
{ 
  struct msghdr msg ;
  ssize_t tmp ;

  {
  {
#line 123
  memset((void *)(& msg), 0, sizeof(msg));
#line 124
  tmp = recvmsg(fd, & msg, 8192);
  }
#line 124
  return (tmp);
}
}
#line 173 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
static int teredo_recv_inner___1(int fd , struct teredo_packet *p , int flags ) 
{ 
  struct sockaddr_in ad ;
  char cbuf[(((sizeof(struct in_pktinfo ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
  struct iovec iov ;
  struct msghdr msg ;
  ssize_t length ;
  ssize_t tmp ;
  struct cmsghdr *cmsg ;
  struct cmsghdr *tmp___0 ;
  struct in_pktinfo  const  *nfo ;
  uint8_t *ptr ;
  uint8_t id_len ;
  uint8_t au_len ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;
  uint32_t addr ;
  uint16_t port ;

  {
  {
#line 181
  iov.iov_base = (void *)(p->buf.fill);
#line 181
  iov.iov_len = (size_t )65507;
#line 186
  msg.msg_name = (void *)(& ad);
#line 186
  msg.msg_namelen = (socklen_t )sizeof(ad);
#line 186
  msg.msg_iov = & iov;
#line 186
  msg.msg_iovlen = (size_t )1;
#line 186
  msg.msg_control = (void *)(cbuf);
#line 186
  msg.msg_controllen = sizeof(cbuf);
#line 186
  msg.msg_flags = 0;
#line 199
  tmp = recvmsg(fd, & msg, flags);
#line 199
  length = tmp;
  }
#line 200
  if (length == -1L) {
    {
#line 201
    teredo_recverr___1(fd);
    }
  }
#line 202
  if (length < 2L) {
#line 203
    return (-1);
  }
#line 205
  p->source_ipv4 = ad.sin_addr.s_addr;
#line 206
  p->source_port = ad.sin_port;
#line 207
  p->dest_ipv4 = (uint32_t )0;
#line 212
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 212
    tmp___0 = (struct cmsghdr *)msg.msg_control;
  } else {
#line 212
    tmp___0 = (struct cmsghdr *)0;
  }
#line 212
  cmsg = tmp___0;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! ((unsigned long )cmsg != (unsigned long )((void *)0))) {
#line 212
      goto while_break;
    }
#line 217
    if (cmsg->cmsg_level == 0) {
#line 217
      if (cmsg->cmsg_type == 8) {
#line 220
        nfo = (struct in_pktinfo  const  *)((struct in_pktinfo *)(cmsg->__cmsg_data));
#line 222
        p->dest_ipv4 = (uint32_t )nfo->ipi_addr.s_addr;
      }
    }
    {
#line 212
    cmsg = __cmsg_nxthdr(& msg, cmsg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  ptr = p->buf.fill;
#line 238
  p->auth_present = (_Bool)0;
#line 239
  p->orig_ipv4 = (uint32_t )0;
#line 240
  p->orig_port = (uint16_t )0;
#line 243
  if ((int )*(ptr + 0) == 0) {
#line 243
    if ((int )*(ptr + 1) == 1) {
#line 247
      p->auth_present = (_Bool)1;
#line 249
      length -= 13L;
#line 250
      if (length < 0L) {
#line 251
        return (-1);
      }
#line 252
      ptr += 2;
#line 255
      tmp___1 = ptr;
#line 255
      ptr ++;
#line 255
      id_len = *tmp___1;
#line 256
      tmp___2 = ptr;
#line 256
      ptr ++;
#line 256
      au_len = *tmp___2;
#line 259
      length -= (ssize_t )((int )id_len + (int )au_len);
#line 260
      if (length < 0L) {
#line 261
        return (-1);
      }
      {
#line 262
      ptr += (int )id_len + (int )au_len;
#line 265
      memcpy((void */* __restrict  */)(p->auth_nonce), (void const   */* __restrict  */)ptr,
             (size_t )8);
#line 266
      ptr += 8;
#line 267
      p->auth_fail = (_Bool )(! (! *ptr));
#line 268
      ptr ++;
#line 273
      memmove((void *)(p->buf.align), (void const   *)ptr, (size_t )length);
#line 274
      ptr = p->buf.fill;
      }
    }
  }
#line 278
  if ((int )*(ptr + 0) == 0) {
#line 278
    if ((int )*(ptr + 1) == 0) {
#line 283
      length -= 8L;
#line 284
      if (length < 0L) {
#line 285
        return (-1);
      }
      {
#line 286
      ptr += 2;
#line 289
      memcpy((void */* __restrict  */)(& port), (void const   */* __restrict  */)ptr,
             (size_t )2);
#line 290
      ptr += 2;
#line 291
      p->orig_port = (uint16_t )(~ ((int )port));
#line 294
      memcpy((void */* __restrict  */)(& addr), (void const   */* __restrict  */)ptr,
             (size_t )4);
#line 295
      ptr += 4;
#line 296
      p->orig_ipv4 = ~ addr;
      }
    }
  }
#line 299
  p->ip6_len = (size_t )length;
#line 300
  p->ip6 = (struct ip6_hdr *)ptr;
#line 302
  return (0);
}
}
#line 338 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
static uint16_t in_cksum___1(struct iovec  const  *iov , size_t n ) 
{ 
  uint32_t sum ;
  union __anonunion_w_31___1 w ;
  _Bool odd ;
  uint8_t const   *ptr ;
  size_t len ;
  uint8_t const   *tmp ;
  uint8_t const   *tmp___0 ;

  {
#line 340
  sum = (uint32_t )0;
#line 346
  odd = (_Bool)0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (n > 0UL)) {
#line 348
      goto while_break;
    }
#line 350
    ptr = (uint8_t const   *)iov->iov_base;
#line 352
    len = (size_t )iov->iov_len;
    {
#line 352
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 352
      if (! (len > 0UL)) {
#line 352
        goto while_break___0;
      }
#line 354
      if (odd) {
#line 356
        tmp = ptr;
#line 356
        ptr ++;
#line 356
        w.bytes[1] = (uint8_t )*tmp;
#line 357
        sum += (uint32_t )w.word;
#line 358
        if (sum > 65535U) {
#line 359
          sum -= 65535U;
        }
      } else {
#line 362
        tmp___0 = ptr;
#line 362
        ptr ++;
#line 362
        w.bytes[0] = (uint8_t )*tmp___0;
      }
#line 363
      odd = (_Bool )(! odd);
#line 352
      len --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    iov ++;
#line 367
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  if (odd) {
#line 372
    w.bytes[1] = (uint8_t )0;
#line 373
    sum += (uint32_t )w.word;
#line 374
    if (sum > 65535U) {
#line 375
      sum -= 65535U;
    }
  }
#line 378
  return ((uint16_t )(sum ^ 65535U));
}
}
#line 121 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_send_unreach___1(teredo_tunnel * __restrict  tunnel , uint8_t code ,
                                    struct ip6_hdr  const  * __restrict  in , size_t len ) 
{ 
  struct __anonstruct_buf_51___1 buf ;
  teredo_clock_t now ;
  teredo_clock_t tmp ;
  int tmp___0 ;

  {
  {
#line 130
  tmp = teredo_clock();
#line 130
  now = tmp;
#line 133
  d_pthread_mutex_lock(& tunnel->ratelimit.lock);
  }
#line 134
  if (now != tunnel->ratelimit.last) {
#line 136
    tunnel->ratelimit.last = now;
#line 137
    tunnel->ratelimit.count = 10;
  }
#line 141
  if (tunnel->ratelimit.count == 0) {
    {
#line 144
    d_pthread_mutex_unlock(& tunnel->ratelimit.lock);
    }
#line 145
    return;
  }
#line 147
  if (tunnel->ratelimit.count > 0) {
#line 148
    (tunnel->ratelimit.count) --;
  }
  {
#line 149
  d_pthread_mutex_unlock(& tunnel->ratelimit.lock);
#line 151
  tmp___0 = BuildICMPv6Error((struct icmp6_hdr */* __restrict  */)(& buf.hdr), (uint8_t )1,
                             code, in, len);
#line 151
  len = (size_t )tmp___0;
#line 152
  (*(tunnel->icmpv6_cb))(tunnel->opaque, (void const   *)(& buf.hdr), len, & in->ip6_src);
  }
#line 153
  return;
}
}
#line 177 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_state_change___1(teredo_state const   *state , void *self ) 
{ 
  teredo_tunnel *tunnel ;
  _Bool previously_up ;
  char b[16] ;
  char const   *tmp ;

  {
  {
#line 180
  tunnel = (teredo_tunnel *)self;
#line 182
  pthread_rwlock_wrlock(& tunnel->state_lock);
#line 183
  previously_up = tunnel->state.up;
#line 184
  tunnel->state = (teredo_state )*state;
  }
#line 186
  if (tunnel->state.up) {
    {
#line 194
    teredo_list_reset(tunnel->list, 1024U);
#line 195
    (*(tunnel->up_cb))(tunnel->opaque, (struct in6_addr  const  *)(& tunnel->state.addr.ip6),
                       tunnel->state.mtu);
#line 200
    tmp = inet_ntop(2, (void const   */* __restrict  */)(& tunnel->state.ipv4), (char */* __restrict  */)(b),
                    (socklen_t )sizeof(b));
#line 200
    debug("Internal IPv4 address: %s", tmp);
    }
  } else
#line 205
  if (previously_up) {
    {
#line 206
    (*(tunnel->down_cb))(tunnel->opaque);
    }
  }
  {
#line 213
  pthread_rwlock_unlock(& tunnel->state_lock);
  }
#line 214
  return;
}
}
#line 220 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static int CountPing___1(teredo_peer *peer , teredo_clock_t now ) 
{ 
  int res ;

  {
#line 224
  if (peer->pings == 0U) {
#line 225
    res = 0;
  } else
#line 227
  if (peer->pings >= 4U) {
#line 228
    res = -1;
  } else
#line 231
  if (((now - (teredo_clock_t )peer->last_ping) & 511UL) <= 2UL) {
#line 232
    res = 1;
  } else {
#line 234
    res = 0;
  }
#line 236
  if (res == 0) {
#line 238
    peer->last_ping = (unsigned int )now;
#line 239
    (peer->pings) ++;
  }
#line 242
  return (res);
}
}
#line 257 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static int CountBubble___1(teredo_peer *peer , teredo_clock_t now ) 
{ 
  int res ;

  {
#line 262
  if (peer->bubbles > 0U) {
#line 264
    if (peer->bubbles >= 4U) {
#line 267
      if (now - peer->last_tx <= 300UL) {
#line 268
        res = -1;
      } else {
#line 272
        peer->bubbles = 0U;
#line 273
        res = 0;
      }
    } else
#line 278
    if (now - peer->last_tx <= 2UL) {
#line 279
      res = 1;
    } else {
#line 281
      res = 0;
    }
  } else {
#line 284
    res = 0;
  }
#line 286
  if (res == 0) {
#line 288
    peer->last_tx = now;
#line 289
    (peer->bubbles) ++;
  }
#line 292
  return (res);
}
}
#line 310 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static int teredo_encap___1(teredo_tunnel * __restrict  tunnel , teredo_peer * __restrict  peer ,
                            void const   * __restrict  data , size_t len , teredo_clock_t now ) 
{ 
  uint32_t ipv4 ;
  uint16_t port ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 314
  ipv4 = peer->mapped_addr;
#line 315
  port = peer->mapped_port;
#line 316
  TouchTransmit((teredo_peer *)peer, now);
#line 317
  teredo_list_release(tunnel->list);
#line 319
  tmp___1 = teredo_send(tunnel->fd, (void const   *)data, len, ipv4, port);
  }
#line 319
  if (tmp___1 == (int )len) {
#line 319
    tmp___0 = 0;
  } else {
#line 319
    tmp___0 = -1;
  }
#line 319
  return (tmp___0);
}
}
#line 527 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_predecap___1(teredo_tunnel * __restrict  tunnel , teredo_peer * __restrict  peer ,
                                teredo_clock_t now ) 
{ 
  unsigned int tmp ;
  teredo_queue *q ;
  teredo_queue *tmp___0 ;

  {
  {
#line 531
  TouchReceive((teredo_peer *)peer, now);
#line 532
  tmp = 0U;
#line 532
  peer->pings = tmp;
#line 532
  peer->bubbles = tmp;
#line 533
  tmp___0 = teredo_peer_queue_yield((teredo_peer *)peer);
#line 533
  q = tmp___0;
#line 534
  teredo_list_release(tunnel->list);
  }
#line 536
  if ((unsigned long )q != (unsigned long )((void *)0)) {
    {
#line 537
    teredo_queue_emit(q, tunnel->fd, peer->mapped_addr, peer->mapped_port, tunnel->recv_cb,
                      tunnel->opaque);
    }
  }
#line 540
  return;
}
}
#line 552 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_run_inner___1(teredo_tunnel * __restrict  tunnel , struct teredo_packet  const  * __restrict  packet ) 
{ 
  char b[46] ;
  struct ip6_hdr *ip6 ;
  size_t length ;
  uint16_t tmp ;
  teredo_state s ;
  int tmp___0 ;
  uint32_t ipv4 ;
  uint16_t port ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  uint16_t tmp___3 ;
  char const   *tmp___4 ;
  _Bool tmp___5 ;
  char const   *tmp___6 ;
  teredo_clock_t now ;
  teredo_clock_t tmp___7 ;
  struct teredo_peerlist *list ;
  teredo_peer *p ;
  teredo_peer *tmp___8 ;
  _Bool tmp___9 ;
  int tmp___10 ;
  _Bool __constr_expr_26 ;
  _Bool tmp___11 ;
  char const   *tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  _Bool tmp___15 ;
  int tmp___16 ;
  _Bool tmp___17 ;
  _Bool create ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  int res ;
  int tmp___20 ;

  {
#line 556
  if (! ((unsigned long )tunnel != (unsigned long )((void *)0))) {
    {
#line 556
    __assert_fail("tunnel != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  556U, "teredo_run_inner");
    }
  }
#line 557
  if (! ((unsigned long )packet != (unsigned long )((void *)0))) {
    {
#line 557
    __assert_fail("packet != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  557U, "teredo_run_inner");
    }
  }
#line 562
  ip6 = (struct ip6_hdr *)packet->ip6;
#line 565
  if (packet->ip6_len < (size_t const   )sizeof(*ip6)) {
    {
#line 567
    debug("Packet size invalid: %zu bytes.", packet->ip6_len);
    }
#line 568
    return;
  }
  {
#line 571
  tmp = ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 571
  length = sizeof(*ip6) + (unsigned long )tmp;
  }
#line 572
  if ((int )ip6->ip6_ctlun.ip6_un2_vfc >> 4 != 6) {
    {
#line 575
    debug("Received malformed IPv6 packet.");
    }
#line 576
    return;
  } else
#line 572
  if (length > (size_t )packet->ip6_len) {
    {
#line 575
    debug("Received malformed IPv6 packet.");
    }
#line 576
    return;
  }
  {
#line 580
  pthread_rwlock_rdlock(& tunnel->state_lock);
#line 581
  s = tunnel->state;
#line 588
  pthread_rwlock_unlock(& tunnel->state_lock);
#line 592
  tmp___5 = IsClient((teredo_tunnel const   *)tunnel);
  }
#line 592
  if (tmp___5) {
    {
#line 594
    tmp___0 = teredo_maintenance_process((teredo_maintenance */* __restrict  */)tunnel->maintenance,
                                         packet);
    }
#line 594
    if (tmp___0 == 0) {
      {
#line 596
      debug(" packet passed to maintenance procedure");
      }
#line 597
      return;
    }
#line 600
    if (! s.up) {
      {
#line 602
      debug(" packet dropped because tunnel down");
      }
#line 603
      return;
    }
#line 606
    if (packet->source_ipv4 == (uint32_t const   )s.addr.teredo.server_ip) {
      {
#line 606
      tmp___3 = htons((uint16_t )3544);
      }
#line 606
      if ((int const   )packet->source_port == (int const   )tmp___3) {
#line 609
        ipv4 = (uint32_t )packet->orig_ipv4;
#line 610
        port = (uint16_t )packet->orig_port;
#line 612
        if (ipv4 == 0U) {
          {
#line 612
          tmp___1 = IsBubble((struct ip6_hdr  const  *)ip6);
          }
#line 612
          if (tmp___1) {
#line 612
            if (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix == (uint32_t const   )s.addr.teredo.prefix) {
#line 620
              ipv4 = (uint32_t )(((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.client_ip ^ 4294967295U);
#line 621
              port = (uint16_t )((int const   )((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.client_port ^ 65535);
            }
          }
        }
#line 624
        if (ipv4) {
          {
#line 627
          teredo_reply_bubble(tunnel->fd, ipv4, port, (struct ip6_hdr  const  *)ip6);
#line 628
          debug(" bubble sent");
#line 629
          tmp___2 = IsBubble((struct ip6_hdr  const  *)ip6);
          }
#line 629
          if (tmp___2) {
#line 630
            return;
          }
        }
      }
    }
#line 659
    if (((int )ip6->ip6_src.__in6_u.__u6_addr8[0] & 255) == 254) {
#line 659
      if (((int )ip6->ip6_src.__in6_u.__u6_addr8[1] & 192) == 128) {
#line 661
        return;
      }
    }
  } else
#line 666
  if (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix != (uint32_t const   )s.addr.teredo.prefix) {
    {
#line 668
    tmp___4 = inet_ntop(10, (void const   */* __restrict  */)(& ip6->ip6_src.__in6_u.__u6_addr8),
                        (char */* __restrict  */)(b), (socklen_t )sizeof(b));
#line 668
    debug("Source %s is not a teredo address.", tmp___4);
    }
#line 670
    return;
  }
#line 693
  if ((int )ip6->ip6_dst.__in6_u.__u6_addr8[0] == 255) {
    {
#line 695
    tmp___6 = inet_ntop(10, (void const   */* __restrict  */)(& ip6->ip6_dst.__in6_u.__u6_addr8),
                        (char */* __restrict  */)(b), (socklen_t )sizeof(b));
#line 695
    debug("Multicast destination %s not supported.", tmp___6);
    }
#line 697
    return;
  }
  {
#line 702
  tmp___7 = teredo_clock();
#line 702
  now = tmp___7;
#line 705
  list = tunnel->list;
#line 706
  tmp___8 = teredo_list_lookup((teredo_peerlist */* __restrict  */)list, (struct in6_addr  const  */* __restrict  */)(& ip6->ip6_src),
                               (_Bool */* __restrict  */)((void *)0));
#line 706
  p = tmp___8;
  }
#line 708
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 712
    if (p->trusted) {
#line 712
      if (packet->source_ipv4 == (uint32_t const   )p->mapped_addr) {
#line 712
        if ((int const   )packet->source_port == (int const   )p->mapped_port) {
          {
#line 716
          teredo_predecap___1(tunnel, (teredo_peer */* __restrict  */)p, now);
#line 717
          (*(tunnel->recv_cb))(tunnel->opaque, (void const   *)ip6, length);
          }
#line 718
          return;
        }
      }
    }
    {
#line 727
    tmp___9 = IsClient((teredo_tunnel const   *)tunnel);
    }
#line 727
    if (tmp___9) {
      {
#line 727
      tmp___10 = CheckPing((teredo_packet const   *)packet);
      }
#line 727
      if (tmp___10 == 0) {
        {
#line 729
        p->trusted = 1U;
#line 730
        SetMappingFromPacket(p, (struct teredo_packet  const  *)packet);
#line 732
        teredo_predecap___1(tunnel, (teredo_peer */* __restrict  */)p, now);
        }
#line 733
        return;
      }
    }
  }
#line 742
  if (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix == (uint32_t const   )s.addr.teredo.prefix) {
    {
#line 745
    tmp___14 = in6_matches_teredo_client((struct in6_addr  const  *)(& ip6->ip6_src),
                                         (uint32_t )packet->source_ipv4, (uint16_t )packet->source_port);
    }
#line 745
    if (tmp___14) {
#line 745
      goto _L;
    } else {
      {
#line 745
      tmp___15 = IsBubble((struct ip6_hdr  const  *)ip6);
      }
#line 745
      if (tmp___15) {
        {
#line 745
        tmp___16 = CheckBubble((teredo_packet const   *)packet);
        }
#line 745
        if (tmp___16 == 0) {
          _L: /* CIL Label */ 
          {
#line 751
          tmp___11 = IsClient((teredo_tunnel const   *)tunnel);
          }
#line 751
          if (tmp___11) {
#line 751
            if ((unsigned long )p == (unsigned long )((void *)0)) {
              {
#line 752
              __constr_expr_26 = (_Bool)0;
#line 752
              p = teredo_list_lookup((teredo_peerlist */* __restrict  */)list, (struct in6_addr  const  */* __restrict  */)(& ip6->ip6_src),
                                     (_Bool */* __restrict  */)(& __constr_expr_26));
              }
            }
          }
#line 761
          if ((unsigned long )p == (unsigned long )((void *)0)) {
            {
#line 763
            tmp___12 = inet_ntop(10, (void const   */* __restrict  */)(& ip6->ip6_src.__in6_u.__u6_addr8),
                                 (char */* __restrict  */)(b), (socklen_t )sizeof(b));
#line 763
            debug("No peer for %s found. Dropping packet.", tmp___12);
            }
#line 766
            return;
          }
          {
#line 769
          SetMappingFromPacket(p, (struct teredo_packet  const  *)packet);
#line 770
          p->trusted = 1U;
#line 771
          teredo_predecap___1(tunnel, (teredo_peer */* __restrict  */)p, now);
#line 773
          tmp___13 = IsBubble((struct ip6_hdr  const  *)ip6);
          }
#line 773
          if (! tmp___13) {
            {
#line 774
            (*(tunnel->recv_cb))(tunnel->opaque, (void const   *)ip6, length);
            }
          }
#line 775
          return;
        }
      }
    }
  } else {
#line 783
    if (! (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix != (uint32_t const   )s.addr.teredo.prefix)) {
      {
#line 783
      __assert_fail("((&((const union teredo_addr *)(&ip6->ip6_src))->teredo)->prefix) != s.addr.teredo.prefix",
                    "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c", 783U,
                    "teredo_run_inner");
      }
    }
    {
#line 784
    tmp___17 = IsClient((teredo_tunnel const   *)tunnel);
    }
#line 784
    if (! tmp___17) {
      {
#line 784
      __assert_fail("IsClient (tunnel)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                    784U, "teredo_run_inner");
      }
    }
#line 798
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 801
      p = teredo_list_lookup((teredo_peerlist */* __restrict  */)list, (struct in6_addr  const  */* __restrict  */)(& ip6->ip6_src),
                             (_Bool */* __restrict  */)(& create));
      }
#line 802
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
#line 804
        debug("Out of memory.");
        }
#line 805
        return;
      }
#line 814
      if (create) {
#line 816
        p->mapped_port = (uint16_t )0;
#line 817
        p->mapped_addr = (uint32_t )0;
#line 818
        tmp___19 = 0U;
#line 818
        p->pings = tmp___19;
#line 818
        tmp___18 = tmp___19;
#line 818
        p->bubbles = tmp___18;
#line 818
        p->trusted = tmp___18;
      }
    }
    {
#line 822
    teredo_enqueue_in((teredo_peer */* __restrict  */)p, (void const   */* __restrict  */)ip6,
                      length, (uint32_t )packet->source_ipv4, (uint16_t )packet->source_port);
#line 824
    TouchReceive(p, now);
#line 826
    tmp___20 = CountPing___1(p, now);
#line 826
    res = tmp___20;
#line 827
    teredo_list_release(list);
    }
#line 829
    if (res == 0) {
      {
#line 830
      SendPing(tunnel->fd, (union teredo_addr  const  *)(& s.addr), (struct in6_addr  const  *)(& ip6->ip6_src));
      }
    }
#line 832
    return;
  }
  {
#line 836
  debug("Dropping packet.");
  }
#line 838
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 839
    teredo_list_release(list);
    }
  }
#line 840
  return;
}
}
#line 844 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_recv_cb___1(void *o , void const   *p , size_t l ) 
{ 


  {
#line 849
  return;
}
}
#line 852 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_icmpv6_cb___1(void *o , void const   *p , size_t l , struct in6_addr  const  *d ) 
{ 


  {
#line 859
  return;
}
}
#line 863 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_state_up_cb___1(void *o , struct in6_addr  const  *a , uint16_t m ) 
{ 


  {
#line 869
  return;
}
}
#line 872 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_state_down_cb___1(void *o ) 
{ 


  {
#line 875
  return;
}
}
#line 952
static  __attribute__((__noreturn__)) void *teredo_recv_thread___1(void *t ) ;
#line 952 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void *teredo_recv_thread___1(void *t ) 
{ 
  teredo_tunnel *tunnel ;
  struct teredo_packet packet ;
  int tmp ;

  {
#line 954
  tunnel = (teredo_tunnel *)t;
  {
#line 956
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 960
    tmp = teredo_wait_recv(tunnel->fd, & packet);
    }
#line 960
    if (tmp == 0) {
      {
#line 962
      pthread_setcancelstate(1, (int *)((void *)0));
#line 963
      teredo_run_inner___1((teredo_tunnel */* __restrict  */)tunnel, (struct teredo_packet  const  */* __restrict  */)(& packet));
#line 964
      pthread_setcancelstate(0, (int *)((void *)0));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 59 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
static uint8_t const   head___1[9]  = 
#line 59 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
  {      (uint8_t const   )'`',      (uint8_t const   )'\000',      (uint8_t const   )'\000',      (uint8_t const   )'\000', 
        (uint8_t const   )'\000',      (uint8_t const   )'\000',      (uint8_t const   )';',      (uint8_t const   )'\000', 
        (uint8_t const   )'\000'};
#line 115 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
static struct in6_addr  const  in6addr_allrouters___2  =    {{{(uint8_t )255, (uint8_t )2, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0,
      (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0,
      (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )2}}};
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 68 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/mire.c"
static void process_icmpv6(int fd , struct ip6_hdr *ip6 , size_t plen , uint32_t ipv4 ,
                           uint16_t port ) 
{ 
  struct icmp6_hdr *hdr ;
  struct in6_addr buf ;

  {
#line 72
  if (plen < sizeof(struct icmp6_hdr )) {
#line 73
    return;
  }
#line 75
  hdr = (struct icmp6_hdr *)(ip6 + 1);
#line 84
  if ((int )hdr->icmp6_type != 128) {
#line 85
    return;
  }
  {
#line 87
  ip6->ip6_ctlun.ip6_un1.ip6_un1_hlim = (uint8_t )255;
#line 90
  buf = ip6->ip6_dst;
#line 91
  ip6->ip6_dst = ip6->ip6_src;
#line 92
  ip6->ip6_src = buf;
#line 94
  hdr->icmp6_type = (uint8_t )129;
#line 95
  hdr->icmp6_code = (uint8_t )0;
#line 96
  hdr->icmp6_cksum = (uint16_t )0;
#line 97
  hdr->icmp6_cksum = icmp6_checksum((struct ip6_hdr  const  *)ip6, (struct icmp6_hdr  const  *)hdr);
#line 99
  teredo_send(fd, (void const   *)ip6, sizeof(*ip6) + plen, ipv4, port);
  }
#line 100
  return;
}
}
#line 103 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/mire.c"
static void process_none(int fd , struct ip6_hdr  const  *ip6 , size_t plen , uint32_t ipv4 ,
                         uint16_t port ) 
{ 


  {
#line 107
  if (plen != 0UL) {
#line 108
    return;
  }
  {
#line 110
  teredo_reply_bubble(fd, ipv4, port, ip6);
  }
#line 111
  return;
}
}
#line 114 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/mire.c"
static void process_unknown(int fd , struct ip6_hdr  const  *in , size_t plen , uint32_t ipv4 ,
                            uint16_t port ) 
{ 
  struct ip6_hdr ip6 ;
  struct icmp6_hdr icmp6 ;
  struct iovec iov[3] ;

  {
#line 118
  plen += sizeof(struct ip6_hdr );
#line 119
  if (plen > 1232UL) {
#line 120
    plen = (size_t )1232;
  }
  {
#line 124
  iov[0].iov_base = (void *)(& ip6);
#line 124
  iov[0].iov_len = sizeof(ip6);
#line 124
  iov[1].iov_base = (void *)(& icmp6);
#line 124
  iov[1].iov_len = sizeof(icmp6);
#line 124
  iov[2].iov_base = (void *)in;
#line 124
  iov[2].iov_len = plen;
#line 131
  ip6.ip6_ctlun.ip6_un1.ip6_un1_flow = htonl((uint32_t )(6 << 28));
#line 132
  ip6.ip6_ctlun.ip6_un1.ip6_un1_plen = htons((uint16_t )(sizeof(struct icmp6_hdr ) + plen));
#line 133
  ip6.ip6_ctlun.ip6_un1.ip6_un1_nxt = (uint8_t )58;
#line 134
  ip6.ip6_ctlun.ip6_un1.ip6_un1_hlim = (uint8_t )255;
#line 135
  ip6.ip6_src = (struct in6_addr )in->ip6_dst;
#line 136
  ip6.ip6_dst = (struct in6_addr )in->ip6_src;
#line 138
  icmp6.icmp6_type = (uint8_t )4;
#line 139
  icmp6.icmp6_code = (uint8_t )1;
#line 140
  icmp6.icmp6_cksum = (uint16_t )0;
#line 141
  icmp6.icmp6_dataun.icmp6_un_data32[0] = htonl((uint32_t )6);
#line 143
  icmp6.icmp6_cksum = teredo_cksum((void const   *)(& ip6.ip6_src), (void const   *)(& ip6.ip6_dst),
                                   (uint8_t )58, (struct iovec  const  *)(iov + 1),
                                   (size_t )2);
#line 146
  teredo_sendv(fd, (struct iovec  const  *)(iov), sizeof(iov) / sizeof(iov[0]), ipv4,
               port);
  }
#line 147
  return;
}
}
#line 157 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/mire.c"
static ssize_t recv_packet(int fd , teredo_packet *p ) 
{ 
  int tmp ;
  struct ip6_hdr *ip6 ;
  uint16_t plen ;

  {
  {
#line 160
  tmp = teredo_wait_recv(fd, p);
  }
#line 160
  if (tmp) {
#line 161
    return ((ssize_t )-1);
  }
#line 163
  ip6 = p->ip6;
#line 167
  if (p->ip6_len < sizeof(*ip6)) {
#line 168
    return ((ssize_t )-1);
  }
  {
#line 171
  plen = ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
  }
#line 177
  if ((int )ip6->ip6_ctlun.ip6_un2_vfc >> 4 != 6) {
#line 179
    return ((ssize_t )-1);
  } else
#line 177
  if ((unsigned long )plen + sizeof(*ip6) > p->ip6_len) {
#line 179
    return ((ssize_t )-1);
  }
#line 181
  return ((ssize_t )plen);
}
}
#line 185
static  __attribute__((__noreturn__)) void *server_thread(void *data ) ;
#line 185 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/mire.c"
static void *server_thread(void *data ) 
{ 
  int fdserv ;
  int fd ;
  struct teredo_packet p ;
  ssize_t plen ;
  ssize_t tmp ;

  {
#line 187
  fdserv = *((int *)data + 0);
#line 187
  fd = *((int *)data + 1);
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 192
    tmp = recv_packet(fdserv, & p);
#line 192
    plen = tmp;
    }
#line 193
    if (plen == -1L) {
#line 194
      goto __Cont;
    }
#line 196
    if ((int )(p.ip6)->ip6_ctlun.ip6_un1.ip6_un1_nxt == 59) {
      {
#line 197
      process_none(fd, (struct ip6_hdr  const  *)p.ip6, (size_t )plen, p.source_ipv4,
                   p.source_port);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 202
static  __attribute__((__noreturn__)) int client_thread(int fd ) ;
#line 202 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/mire.c"
static int client_thread(int fd ) 
{ 
  struct teredo_packet p ;
  ssize_t plen ;
  ssize_t tmp ;

  {
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 207
    tmp = recv_packet(fd, & p);
#line 207
    plen = tmp;
    }
#line 208
    if (plen == -1L) {
#line 209
      goto __Cont;
    }
    {
#line 215
    if ((int )(p.ip6)->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58) {
#line 215
      goto case_58;
    }
#line 221
    if ((int )(p.ip6)->ip6_ctlun.ip6_un1.ip6_un1_nxt == 43) {
#line 221
      goto case_43;
    }
#line 221
    if ((int )(p.ip6)->ip6_ctlun.ip6_un1.ip6_un1_nxt == 59) {
#line 221
      goto case_43;
    }
#line 224
    goto switch_default;
    case_58: /* CIL Label */ 
    {
#line 216
    process_icmpv6(fd, p.ip6, (size_t )plen, p.source_ipv4, p.source_port);
    }
#line 218
    goto switch_break;
    case_43: /* CIL Label */ 
    case_59: /* CIL Label */ 
#line 222
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 225
    process_unknown(fd, (struct ip6_hdr  const  *)p.ip6, (size_t )plen, p.source_ipv4,
                    p.source_port);
    }
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 231 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/mire.c"
static int usage___2(char const   *path___0 ) 
{ 


  {
  {
#line 233
  printf((char const   */* __restrict  */)"Usage: %s\n", path___0);
  }
#line 234
  return (0);
}
}
#line 237 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/mire.c"
static int version(void) 
{ 


  {
  {
#line 239
  puts("miredo v1.2.6");
  }
#line 240
  return (0);
}
}
#line 245 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/mire.c"
static struct option  const  opts___2[3]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 146 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.c"
static void md5_process___1(md5_state_t *pms , md5_byte_t const   *data ) 
{ 
  md5_word_t a ;
  md5_word_t b ;
  md5_word_t c ;
  md5_word_t d ;
  md5_word_t t ;
  md5_word_t xbuf[16] ;
  md5_word_t const   *X ;

  {
#line 149
  a = pms->abcd[0];
#line 149
  b = pms->abcd[1];
#line 149
  c = pms->abcd[2];
#line 149
  d = pms->abcd[3];
#line 179
  if (! ((data - (md5_byte_t const   *)0) & 3L)) {
#line 181
    X = (md5_word_t const   *)data;
  } else {
    {
#line 184
    memcpy((void */* __restrict  */)(xbuf), (void const   */* __restrict  */)data,
           (size_t )64);
#line 185
    X = (md5_word_t const   *)(xbuf);
    }
  }
#line 222
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 0)) + 3614090360U;
#line 222
  a = ((t << 7) | (t >> 25)) + b;
#line 223
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 1)) + 3905402710U;
#line 223
  d = ((t << 12) | (t >> 20)) + a;
#line 224
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 2)) + 606105819U;
#line 224
  c = ((t << 17) | (t >> 15)) + d;
#line 225
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 3)) + 3250441966U;
#line 225
  b = ((t << 22) | (t >> 10)) + c;
#line 226
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 4)) + 4118548399U;
#line 226
  a = ((t << 7) | (t >> 25)) + b;
#line 227
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 5)) + 1200080426U;
#line 227
  d = ((t << 12) | (t >> 20)) + a;
#line 228
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 6)) + 2821735955U;
#line 228
  c = ((t << 17) | (t >> 15)) + d;
#line 229
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 7)) + 4249261313U;
#line 229
  b = ((t << 22) | (t >> 10)) + c;
#line 230
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 8)) + 1770035416U;
#line 230
  a = ((t << 7) | (t >> 25)) + b;
#line 231
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 9)) + 2336552879U;
#line 231
  d = ((t << 12) | (t >> 20)) + a;
#line 232
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 10)) + 4294925233U;
#line 232
  c = ((t << 17) | (t >> 15)) + d;
#line 233
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 11)) + 2304563134U;
#line 233
  b = ((t << 22) | (t >> 10)) + c;
#line 234
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 12)) + 1804603682U;
#line 234
  a = ((t << 7) | (t >> 25)) + b;
#line 235
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 13)) + 4254626195U;
#line 235
  d = ((t << 12) | (t >> 20)) + a;
#line 236
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 14)) + 2792965006U;
#line 236
  c = ((t << 17) | (t >> 15)) + d;
#line 237
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 15)) + 1236535329U;
#line 237
  b = ((t << 22) | (t >> 10)) + c;
#line 248
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 1)) + 4129170786U;
#line 248
  a = ((t << 5) | (t >> 27)) + b;
#line 249
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 6)) + 3225465664U;
#line 249
  d = ((t << 9) | (t >> 23)) + a;
#line 250
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 11)) + 643717713U;
#line 250
  c = ((t << 14) | (t >> 18)) + d;
#line 251
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 0)) + 3921069994U;
#line 251
  b = ((t << 20) | (t >> 12)) + c;
#line 252
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 5)) + 3593408605U;
#line 252
  a = ((t << 5) | (t >> 27)) + b;
#line 253
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 10)) + 38016083U;
#line 253
  d = ((t << 9) | (t >> 23)) + a;
#line 254
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 15)) + 3634488961U;
#line 254
  c = ((t << 14) | (t >> 18)) + d;
#line 255
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 4)) + 3889429448U;
#line 255
  b = ((t << 20) | (t >> 12)) + c;
#line 256
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 9)) + 568446438U;
#line 256
  a = ((t << 5) | (t >> 27)) + b;
#line 257
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 14)) + 3275163606U;
#line 257
  d = ((t << 9) | (t >> 23)) + a;
#line 258
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 3)) + 4107603335U;
#line 258
  c = ((t << 14) | (t >> 18)) + d;
#line 259
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 8)) + 1163531501U;
#line 259
  b = ((t << 20) | (t >> 12)) + c;
#line 260
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 13)) + 2850285829U;
#line 260
  a = ((t << 5) | (t >> 27)) + b;
#line 261
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 2)) + 4243563512U;
#line 261
  d = ((t << 9) | (t >> 23)) + a;
#line 262
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 7)) + 1735328473U;
#line 262
  c = ((t << 14) | (t >> 18)) + d;
#line 263
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 12)) + 2368359562U;
#line 263
  b = ((t << 20) | (t >> 12)) + c;
#line 274
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 5)) + 4294588738U;
#line 274
  a = ((t << 4) | (t >> 28)) + b;
#line 275
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 8)) + 2272392833U;
#line 275
  d = ((t << 11) | (t >> 21)) + a;
#line 276
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 11)) + 1839030562U;
#line 276
  c = ((t << 16) | (t >> 16)) + d;
#line 277
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 14)) + 4259657740U;
#line 277
  b = ((t << 23) | (t >> 9)) + c;
#line 278
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 1)) + 2763975236U;
#line 278
  a = ((t << 4) | (t >> 28)) + b;
#line 279
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 4)) + 1272893353U;
#line 279
  d = ((t << 11) | (t >> 21)) + a;
#line 280
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 7)) + 4139469664U;
#line 280
  c = ((t << 16) | (t >> 16)) + d;
#line 281
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 10)) + 3200236656U;
#line 281
  b = ((t << 23) | (t >> 9)) + c;
#line 282
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 13)) + 681279174U;
#line 282
  a = ((t << 4) | (t >> 28)) + b;
#line 283
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 0)) + 3936430074U;
#line 283
  d = ((t << 11) | (t >> 21)) + a;
#line 284
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 3)) + 3572445317U;
#line 284
  c = ((t << 16) | (t >> 16)) + d;
#line 285
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 6)) + 76029189U;
#line 285
  b = ((t << 23) | (t >> 9)) + c;
#line 286
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 9)) + 3654602809U;
#line 286
  a = ((t << 4) | (t >> 28)) + b;
#line 287
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 12)) + 3873151461U;
#line 287
  d = ((t << 11) | (t >> 21)) + a;
#line 288
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 15)) + 530742520U;
#line 288
  c = ((t << 16) | (t >> 16)) + d;
#line 289
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 2)) + 3299628645U;
#line 289
  b = ((t << 23) | (t >> 9)) + c;
#line 300
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 0)) + 4096336452U;
#line 300
  a = ((t << 6) | (t >> 26)) + b;
#line 301
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 7)) + 1126891415U;
#line 301
  d = ((t << 10) | (t >> 22)) + a;
#line 302
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 14)) + 2878612391U;
#line 302
  c = ((t << 15) | (t >> 17)) + d;
#line 303
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 5)) + 4237533241U;
#line 303
  b = ((t << 21) | (t >> 11)) + c;
#line 304
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 12)) + 1700485571U;
#line 304
  a = ((t << 6) | (t >> 26)) + b;
#line 305
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 3)) + 2399980690U;
#line 305
  d = ((t << 10) | (t >> 22)) + a;
#line 306
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 10)) + 4293915773U;
#line 306
  c = ((t << 15) | (t >> 17)) + d;
#line 307
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 1)) + 2240044497U;
#line 307
  b = ((t << 21) | (t >> 11)) + c;
#line 308
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 8)) + 1873313359U;
#line 308
  a = ((t << 6) | (t >> 26)) + b;
#line 309
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 15)) + 4264355552U;
#line 309
  d = ((t << 10) | (t >> 22)) + a;
#line 310
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 6)) + 2734768916U;
#line 310
  c = ((t << 15) | (t >> 17)) + d;
#line 311
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 13)) + 1309151649U;
#line 311
  b = ((t << 21) | (t >> 11)) + c;
#line 312
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 4)) + 4149444226U;
#line 312
  a = ((t << 6) | (t >> 26)) + b;
#line 313
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 11)) + 3174756917U;
#line 313
  d = ((t << 10) | (t >> 22)) + a;
#line 314
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 2)) + 718787259U;
#line 314
  c = ((t << 15) | (t >> 17)) + d;
#line 315
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 9)) + 3951481745U;
#line 315
  b = ((t << 21) | (t >> 11)) + c;
#line 321
  pms->abcd[0] += a;
#line 322
  pms->abcd[1] += b;
#line 323
  pms->abcd[2] += c;
#line 324
  pms->abcd[3] += d;
#line 325
  return;
}
}
#line 378 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.c"
static md5_byte_t const   pad___1[64]  = 
#line 378
  {      (md5_byte_t const   )128,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0};
#line 67 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static unsigned int const   teredo_MaxQueueBytes___1  =    (unsigned int const   )1280;
#line 70 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
__inline static void teredo_peer_init___1(teredo_peer *peer ) 
{ 


  {
#line 72
  peer->queue = (teredo_queue *)((void *)0);
#line 73
  peer->queue_left = (size_t )teredo_MaxQueueBytes___1;
#line 74
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void teredo_peer_queue___1(teredo_peer * __restrict  peer , void const   * __restrict  data ,
                                  size_t len , uint32_t ip , uint16_t port , _Bool incoming ) 
{ 
  teredo_queue *p ;
  void *tmp ;

  {
#line 98
  if (len > peer->queue_left) {
#line 99
    return;
  }
  {
#line 100
  peer->queue_left -= len;
#line 102
  tmp = malloc(sizeof(*p) + len);
#line 102
  p = (teredo_queue *)tmp;
#line 103
  p->length = len;
#line 104
  memcpy((void */* __restrict  */)(p->data), data, len);
#line 105
  p->ipv4 = ip;
#line 106
  p->port = port;
#line 107
  p->incoming = incoming;
#line 109
  p->next = peer->queue;
#line 110
  peer->queue = p;
  }
#line 111
  return;
}
}
#line 181 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
__inline static teredo_listitem *listitem_create___1(void) 
{ 
  teredo_listitem *entry ;
  void *tmp ;

  {
  {
#line 183
  tmp = malloc(sizeof(*entry));
#line 183
  entry = (teredo_listitem *)tmp;
  }
#line 184
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
    {
#line 185
    teredo_peer_init___1(& entry->peer);
    }
  }
#line 186
  return (entry);
}
}
#line 197 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void listitem_recdestroy___1(teredo_listitem *entry ) 
{ 
  teredo_listitem *buf ;

  {
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 199
      goto while_break;
    }
    {
#line 201
    buf = entry->next;
#line 202
    listitem_destroy(entry);
#line 203
    entry = buf;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 208 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void listitem_free___1(void *p ) 
{ 


  {
#line 211
  return;
}
}
#line 213 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static int listitem_cmp___1(void const   *pa , void const   *pb ) 
{ 
  struct in6_addr  const  * const  *a ;
  struct in6_addr  const  * const  *b ;
  int tmp ;

  {
  {
#line 215
  a = (struct in6_addr  const  * const  *)pa;
#line 215
  b = (struct in6_addr  const  * const  *)pb;
#line 217
  tmp = memcmp((void const   *)a, (void const   *)b, sizeof(*(*a)));
  }
#line 217
  return (tmp);
}
}
#line 228
static  __attribute__((__noreturn__)) void *garbage_collector___1(void *data ) ;
#line 228 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void *garbage_collector___1(void *data ) 
{ 
  struct teredo_peerlist *l ;
  struct timespec delay ;
  int tmp ;
  int state ;
  teredo_listitem *p ;
  teredo_listitem **pp ;
  void *tmp___0 ;
  teredo_listitem *old ;

  {
#line 230
  l = (struct teredo_peerlist *)data;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    delay.tv_sec = (__time_t )l->expiration;
#line 234
    delay.tv_nsec = 0L;
    {
#line 235
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 235
      tmp = clock_nanosleep(0, 0, (struct timespec  const  *)(& delay), & delay);
      }
#line 235
      if (! tmp) {
#line 235
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 238
    pthread_setcancelstate(1, & state);
#line 240
    d_pthread_mutex_lock(& l->lock);
#line 243
    p = l->old;
    }
    {
#line 243
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 243
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 243
        goto while_break___1;
      }
      {
#line 253
      tmp___0 = tdelete((void const   */* __restrict  */)(& p->key.ip6), (void **/* __restrict  */)(& l->root),
                        & listitem_cmp___1);
#line 253
      pp = (teredo_listitem **)tmp___0;
      }
#line 254
      if (! ((unsigned long )pp != (unsigned long )((void *)0))) {
        {
#line 254
        __assert_fail("pp != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c",
                      254U, "garbage_collector");
        }
      }
#line 256
      (l->left) ++;
#line 243
      p = p->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 260
    old = l->old;
#line 263
    l->old = l->recent;
#line 264
    l->recent = (teredo_listitem *)((void *)0);
#line 265
    if ((unsigned long )l->old != (unsigned long )((void *)0)) {
#line 266
      (l->old)->pprev = & l->old;
    }
    {
#line 268
    d_pthread_mutex_unlock(& l->lock);
#line 271
    sched_yield();
#line 272
    listitem_recdestroy___1(old);
#line 275
    pthread_setcancelstate(state, (int *)((void *)0));
#line 276
    sched_yield();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 46 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static char const   randfile___1[12]  = 
#line 46 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
  {      (char const   )'/',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'/',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'o',      (char const   )'m',      (char const   )'\000'};
#line 57 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static union __anonunion_inner_key_40___1 inner_key___1  ;
#line 63 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static union __anonunion_outer_key_41___1 outer_key___1  ;
#line 70 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static uint16_t hmac_pid___1  =    (uint16_t )0;
#line 74 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static pthread_mutex_t mutex___1  =    {{0, 0U, 0, 0U, 2, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 125 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static void teredo_hash___1(void const   *src , size_t slen , void const   *dst ,
                            size_t dlen , uint8_t * __restrict  hash , uint32_t timestamp ) 
{ 
  md5_state_t ctx ;

  {
  {
#line 131
  md5_init(& ctx);
#line 132
  md5_append(& ctx, (md5_byte_t const   *)(inner_key___1.ipad), (int )sizeof(inner_key___1.ipad));
#line 133
  md5_append(& ctx, (unsigned char const   *)src, (int )slen);
#line 134
  md5_append(& ctx, (unsigned char const   *)dst, (int )dlen);
#line 135
  md5_append(& ctx, (unsigned char const   *)(& hmac_pid___1), (int )sizeof(hmac_pid___1));
#line 136
  md5_append(& ctx, (unsigned char const   *)(& timestamp), (int )sizeof(timestamp));
#line 137
  md5_finish(& ctx, (md5_byte_t *)hash);
#line 139
  md5_init(& ctx);
#line 140
  md5_append(& ctx, (md5_byte_t const   *)(outer_key___1.opad), (int )sizeof(outer_key___1.opad));
#line 141
  md5_append(& ctx, (md5_byte_t const   *)hash, 16);
#line 142
  md5_finish(& ctx, (md5_byte_t *)hash);
  }
#line 143
  return;
}
}
#line 157 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
__inline static void teredo_pinghash___1(struct in6_addr  const  *src , struct in6_addr  const  *dst ,
                                         uint8_t * __restrict  hash , uint32_t timestamp ) 
{ 


  {
  {
#line 161
  teredo_hash___1((void const   *)src, sizeof(*src), (void const   *)dst, sizeof(*dst),
                  hash, timestamp);
  }
#line 162
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_send_unreach___2(teredo_tunnel * __restrict  tunnel , uint8_t code ,
                                    struct ip6_hdr  const  * __restrict  in , size_t len ) 
{ 
  struct __anonstruct_buf_51___2 buf ;
  teredo_clock_t now ;
  teredo_clock_t tmp ;
  int tmp___0 ;

  {
  {
#line 130
  tmp = teredo_clock();
#line 130
  now = tmp;
#line 133
  d_pthread_mutex_lock(& tunnel->ratelimit.lock);
  }
#line 134
  if (now != tunnel->ratelimit.last) {
#line 136
    tunnel->ratelimit.last = now;
#line 137
    tunnel->ratelimit.count = 10;
  }
#line 141
  if (tunnel->ratelimit.count == 0) {
    {
#line 144
    d_pthread_mutex_unlock(& tunnel->ratelimit.lock);
    }
#line 145
    return;
  }
#line 147
  if (tunnel->ratelimit.count > 0) {
#line 148
    (tunnel->ratelimit.count) --;
  }
  {
#line 149
  d_pthread_mutex_unlock(& tunnel->ratelimit.lock);
#line 151
  tmp___0 = BuildICMPv6Error((struct icmp6_hdr */* __restrict  */)(& buf.hdr), (uint8_t )1,
                             code, in, len);
#line 151
  len = (size_t )tmp___0;
#line 152
  (*(tunnel->icmpv6_cb))(tunnel->opaque, (void const   *)(& buf.hdr), len, & in->ip6_src);
  }
#line 153
  return;
}
}
#line 177 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_state_change___2(teredo_state const   *state , void *self ) 
{ 
  teredo_tunnel *tunnel ;
  _Bool previously_up ;
  char b[16] ;
  char const   *tmp ;

  {
  {
#line 180
  tunnel = (teredo_tunnel *)self;
#line 182
  pthread_rwlock_wrlock(& tunnel->state_lock);
#line 183
  previously_up = tunnel->state.up;
#line 184
  tunnel->state = (teredo_state )*state;
  }
#line 186
  if (tunnel->state.up) {
    {
#line 194
    teredo_list_reset(tunnel->list, 1024U);
#line 195
    (*(tunnel->up_cb))(tunnel->opaque, (struct in6_addr  const  *)(& tunnel->state.addr.ip6),
                       tunnel->state.mtu);
#line 200
    tmp = inet_ntop(2, (void const   */* __restrict  */)(& tunnel->state.ipv4), (char */* __restrict  */)(b),
                    (socklen_t )sizeof(b));
#line 200
    debug("Internal IPv4 address: %s", tmp);
    }
  } else
#line 205
  if (previously_up) {
    {
#line 206
    (*(tunnel->down_cb))(tunnel->opaque);
    }
  }
  {
#line 213
  pthread_rwlock_unlock(& tunnel->state_lock);
  }
#line 214
  return;
}
}
#line 220 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static int CountPing___2(teredo_peer *peer , teredo_clock_t now ) 
{ 
  int res ;

  {
#line 224
  if (peer->pings == 0U) {
#line 225
    res = 0;
  } else
#line 227
  if (peer->pings >= 4U) {
#line 228
    res = -1;
  } else
#line 231
  if (((now - (teredo_clock_t )peer->last_ping) & 511UL) <= 2UL) {
#line 232
    res = 1;
  } else {
#line 234
    res = 0;
  }
#line 236
  if (res == 0) {
#line 238
    peer->last_ping = (unsigned int )now;
#line 239
    (peer->pings) ++;
  }
#line 242
  return (res);
}
}
#line 257 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static int CountBubble___2(teredo_peer *peer , teredo_clock_t now ) 
{ 
  int res ;

  {
#line 262
  if (peer->bubbles > 0U) {
#line 264
    if (peer->bubbles >= 4U) {
#line 267
      if (now - peer->last_tx <= 300UL) {
#line 268
        res = -1;
      } else {
#line 272
        peer->bubbles = 0U;
#line 273
        res = 0;
      }
    } else
#line 278
    if (now - peer->last_tx <= 2UL) {
#line 279
      res = 1;
    } else {
#line 281
      res = 0;
    }
  } else {
#line 284
    res = 0;
  }
#line 286
  if (res == 0) {
#line 288
    peer->last_tx = now;
#line 289
    (peer->bubbles) ++;
  }
#line 292
  return (res);
}
}
#line 310 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static int teredo_encap___2(teredo_tunnel * __restrict  tunnel , teredo_peer * __restrict  peer ,
                            void const   * __restrict  data , size_t len , teredo_clock_t now ) 
{ 
  uint32_t ipv4 ;
  uint16_t port ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 314
  ipv4 = peer->mapped_addr;
#line 315
  port = peer->mapped_port;
#line 316
  TouchTransmit((teredo_peer *)peer, now);
#line 317
  teredo_list_release(tunnel->list);
#line 319
  tmp___1 = teredo_send(tunnel->fd, (void const   *)data, len, ipv4, port);
  }
#line 319
  if (tmp___1 == (int )len) {
#line 319
    tmp___0 = 0;
  } else {
#line 319
    tmp___0 = -1;
  }
#line 319
  return (tmp___0);
}
}
#line 527 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_predecap___2(teredo_tunnel * __restrict  tunnel , teredo_peer * __restrict  peer ,
                                teredo_clock_t now ) 
{ 
  unsigned int tmp ;
  teredo_queue *q ;
  teredo_queue *tmp___0 ;

  {
  {
#line 531
  TouchReceive((teredo_peer *)peer, now);
#line 532
  tmp = 0U;
#line 532
  peer->pings = tmp;
#line 532
  peer->bubbles = tmp;
#line 533
  tmp___0 = teredo_peer_queue_yield((teredo_peer *)peer);
#line 533
  q = tmp___0;
#line 534
  teredo_list_release(tunnel->list);
  }
#line 536
  if ((unsigned long )q != (unsigned long )((void *)0)) {
    {
#line 537
    teredo_queue_emit(q, tunnel->fd, peer->mapped_addr, peer->mapped_port, tunnel->recv_cb,
                      tunnel->opaque);
    }
  }
#line 540
  return;
}
}
#line 552 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_run_inner___2(teredo_tunnel * __restrict  tunnel , struct teredo_packet  const  * __restrict  packet ) 
{ 
  char b[46] ;
  struct ip6_hdr *ip6 ;
  size_t length ;
  uint16_t tmp ;
  teredo_state s ;
  int tmp___0 ;
  uint32_t ipv4 ;
  uint16_t port ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  uint16_t tmp___3 ;
  char const   *tmp___4 ;
  _Bool tmp___5 ;
  char const   *tmp___6 ;
  teredo_clock_t now ;
  teredo_clock_t tmp___7 ;
  struct teredo_peerlist *list ;
  teredo_peer *p ;
  teredo_peer *tmp___8 ;
  _Bool tmp___9 ;
  int tmp___10 ;
  _Bool __constr_expr_27 ;
  _Bool tmp___11 ;
  char const   *tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  _Bool tmp___15 ;
  int tmp___16 ;
  _Bool tmp___17 ;
  _Bool create ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  int res ;
  int tmp___20 ;

  {
#line 556
  if (! ((unsigned long )tunnel != (unsigned long )((void *)0))) {
    {
#line 556
    __assert_fail("tunnel != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  556U, "teredo_run_inner");
    }
  }
#line 557
  if (! ((unsigned long )packet != (unsigned long )((void *)0))) {
    {
#line 557
    __assert_fail("packet != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                  557U, "teredo_run_inner");
    }
  }
#line 562
  ip6 = (struct ip6_hdr *)packet->ip6;
#line 565
  if (packet->ip6_len < (size_t const   )sizeof(*ip6)) {
    {
#line 567
    debug("Packet size invalid: %zu bytes.", packet->ip6_len);
    }
#line 568
    return;
  }
  {
#line 571
  tmp = ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 571
  length = sizeof(*ip6) + (unsigned long )tmp;
  }
#line 572
  if ((int )ip6->ip6_ctlun.ip6_un2_vfc >> 4 != 6) {
    {
#line 575
    debug("Received malformed IPv6 packet.");
    }
#line 576
    return;
  } else
#line 572
  if (length > (size_t )packet->ip6_len) {
    {
#line 575
    debug("Received malformed IPv6 packet.");
    }
#line 576
    return;
  }
  {
#line 580
  pthread_rwlock_rdlock(& tunnel->state_lock);
#line 581
  s = tunnel->state;
#line 588
  pthread_rwlock_unlock(& tunnel->state_lock);
#line 592
  tmp___5 = IsClient((teredo_tunnel const   *)tunnel);
  }
#line 592
  if (tmp___5) {
    {
#line 594
    tmp___0 = teredo_maintenance_process((teredo_maintenance */* __restrict  */)tunnel->maintenance,
                                         packet);
    }
#line 594
    if (tmp___0 == 0) {
      {
#line 596
      debug(" packet passed to maintenance procedure");
      }
#line 597
      return;
    }
#line 600
    if (! s.up) {
      {
#line 602
      debug(" packet dropped because tunnel down");
      }
#line 603
      return;
    }
#line 606
    if (packet->source_ipv4 == (uint32_t const   )s.addr.teredo.server_ip) {
      {
#line 606
      tmp___3 = htons((uint16_t )3544);
      }
#line 606
      if ((int const   )packet->source_port == (int const   )tmp___3) {
#line 609
        ipv4 = (uint32_t )packet->orig_ipv4;
#line 610
        port = (uint16_t )packet->orig_port;
#line 612
        if (ipv4 == 0U) {
          {
#line 612
          tmp___1 = IsBubble((struct ip6_hdr  const  *)ip6);
          }
#line 612
          if (tmp___1) {
#line 612
            if (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix == (uint32_t const   )s.addr.teredo.prefix) {
#line 620
              ipv4 = (uint32_t )(((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.client_ip ^ 4294967295U);
#line 621
              port = (uint16_t )((int const   )((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.client_port ^ 65535);
            }
          }
        }
#line 624
        if (ipv4) {
          {
#line 627
          teredo_reply_bubble(tunnel->fd, ipv4, port, (struct ip6_hdr  const  *)ip6);
#line 628
          debug(" bubble sent");
#line 629
          tmp___2 = IsBubble((struct ip6_hdr  const  *)ip6);
          }
#line 629
          if (tmp___2) {
#line 630
            return;
          }
        }
      }
    }
#line 659
    if (((int )ip6->ip6_src.__in6_u.__u6_addr8[0] & 255) == 254) {
#line 659
      if (((int )ip6->ip6_src.__in6_u.__u6_addr8[1] & 192) == 128) {
#line 661
        return;
      }
    }
  } else
#line 666
  if (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix != (uint32_t const   )s.addr.teredo.prefix) {
    {
#line 668
    tmp___4 = inet_ntop(10, (void const   */* __restrict  */)(& ip6->ip6_src.__in6_u.__u6_addr8),
                        (char */* __restrict  */)(b), (socklen_t )sizeof(b));
#line 668
    debug("Source %s is not a teredo address.", tmp___4);
    }
#line 670
    return;
  }
#line 693
  if ((int )ip6->ip6_dst.__in6_u.__u6_addr8[0] == 255) {
    {
#line 695
    tmp___6 = inet_ntop(10, (void const   */* __restrict  */)(& ip6->ip6_dst.__in6_u.__u6_addr8),
                        (char */* __restrict  */)(b), (socklen_t )sizeof(b));
#line 695
    debug("Multicast destination %s not supported.", tmp___6);
    }
#line 697
    return;
  }
  {
#line 702
  tmp___7 = teredo_clock();
#line 702
  now = tmp___7;
#line 705
  list = tunnel->list;
#line 706
  tmp___8 = teredo_list_lookup((teredo_peerlist */* __restrict  */)list, (struct in6_addr  const  */* __restrict  */)(& ip6->ip6_src),
                               (_Bool */* __restrict  */)((void *)0));
#line 706
  p = tmp___8;
  }
#line 708
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 712
    if (p->trusted) {
#line 712
      if (packet->source_ipv4 == (uint32_t const   )p->mapped_addr) {
#line 712
        if ((int const   )packet->source_port == (int const   )p->mapped_port) {
          {
#line 716
          teredo_predecap___2(tunnel, (teredo_peer */* __restrict  */)p, now);
#line 717
          (*(tunnel->recv_cb))(tunnel->opaque, (void const   *)ip6, length);
          }
#line 718
          return;
        }
      }
    }
    {
#line 727
    tmp___9 = IsClient((teredo_tunnel const   *)tunnel);
    }
#line 727
    if (tmp___9) {
      {
#line 727
      tmp___10 = CheckPing((teredo_packet const   *)packet);
      }
#line 727
      if (tmp___10 == 0) {
        {
#line 729
        p->trusted = 1U;
#line 730
        SetMappingFromPacket(p, (struct teredo_packet  const  *)packet);
#line 732
        teredo_predecap___2(tunnel, (teredo_peer */* __restrict  */)p, now);
        }
#line 733
        return;
      }
    }
  }
#line 742
  if (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix == (uint32_t const   )s.addr.teredo.prefix) {
    {
#line 745
    tmp___14 = in6_matches_teredo_client((struct in6_addr  const  *)(& ip6->ip6_src),
                                         (uint32_t )packet->source_ipv4, (uint16_t )packet->source_port);
    }
#line 745
    if (tmp___14) {
#line 745
      goto _L;
    } else {
      {
#line 745
      tmp___15 = IsBubble((struct ip6_hdr  const  *)ip6);
      }
#line 745
      if (tmp___15) {
        {
#line 745
        tmp___16 = CheckBubble((teredo_packet const   *)packet);
        }
#line 745
        if (tmp___16 == 0) {
          _L: /* CIL Label */ 
          {
#line 751
          tmp___11 = IsClient((teredo_tunnel const   *)tunnel);
          }
#line 751
          if (tmp___11) {
#line 751
            if ((unsigned long )p == (unsigned long )((void *)0)) {
              {
#line 752
              __constr_expr_27 = (_Bool)0;
#line 752
              p = teredo_list_lookup((teredo_peerlist */* __restrict  */)list, (struct in6_addr  const  */* __restrict  */)(& ip6->ip6_src),
                                     (_Bool */* __restrict  */)(& __constr_expr_27));
              }
            }
          }
#line 761
          if ((unsigned long )p == (unsigned long )((void *)0)) {
            {
#line 763
            tmp___12 = inet_ntop(10, (void const   */* __restrict  */)(& ip6->ip6_src.__in6_u.__u6_addr8),
                                 (char */* __restrict  */)(b), (socklen_t )sizeof(b));
#line 763
            debug("No peer for %s found. Dropping packet.", tmp___12);
            }
#line 766
            return;
          }
          {
#line 769
          SetMappingFromPacket(p, (struct teredo_packet  const  *)packet);
#line 770
          p->trusted = 1U;
#line 771
          teredo_predecap___2(tunnel, (teredo_peer */* __restrict  */)p, now);
#line 773
          tmp___13 = IsBubble((struct ip6_hdr  const  *)ip6);
          }
#line 773
          if (! tmp___13) {
            {
#line 774
            (*(tunnel->recv_cb))(tunnel->opaque, (void const   *)ip6, length);
            }
          }
#line 775
          return;
        }
      }
    }
  } else {
#line 783
    if (! (((union teredo_addr  const  *)(& ip6->ip6_src))->teredo.prefix != (uint32_t const   )s.addr.teredo.prefix)) {
      {
#line 783
      __assert_fail("((&((const union teredo_addr *)(&ip6->ip6_src))->teredo)->prefix) != s.addr.teredo.prefix",
                    "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c", 783U,
                    "teredo_run_inner");
      }
    }
    {
#line 784
    tmp___17 = IsClient((teredo_tunnel const   *)tunnel);
    }
#line 784
    if (! tmp___17) {
      {
#line 784
      __assert_fail("IsClient (tunnel)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c",
                    784U, "teredo_run_inner");
      }
    }
#line 798
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 801
      p = teredo_list_lookup((teredo_peerlist */* __restrict  */)list, (struct in6_addr  const  */* __restrict  */)(& ip6->ip6_src),
                             (_Bool */* __restrict  */)(& create));
      }
#line 802
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
#line 804
        debug("Out of memory.");
        }
#line 805
        return;
      }
#line 814
      if (create) {
#line 816
        p->mapped_port = (uint16_t )0;
#line 817
        p->mapped_addr = (uint32_t )0;
#line 818
        tmp___19 = 0U;
#line 818
        p->pings = tmp___19;
#line 818
        tmp___18 = tmp___19;
#line 818
        p->bubbles = tmp___18;
#line 818
        p->trusted = tmp___18;
      }
    }
    {
#line 822
    teredo_enqueue_in((teredo_peer */* __restrict  */)p, (void const   */* __restrict  */)ip6,
                      length, (uint32_t )packet->source_ipv4, (uint16_t )packet->source_port);
#line 824
    TouchReceive(p, now);
#line 826
    tmp___20 = CountPing___2(p, now);
#line 826
    res = tmp___20;
#line 827
    teredo_list_release(list);
    }
#line 829
    if (res == 0) {
      {
#line 830
      SendPing(tunnel->fd, (union teredo_addr  const  *)(& s.addr), (struct in6_addr  const  *)(& ip6->ip6_src));
      }
    }
#line 832
    return;
  }
  {
#line 836
  debug("Dropping packet.");
  }
#line 838
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 839
    teredo_list_release(list);
    }
  }
#line 840
  return;
}
}
#line 844 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_recv_cb___2(void *o , void const   *p , size_t l ) 
{ 


  {
#line 849
  return;
}
}
#line 852 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_icmpv6_cb___2(void *o , void const   *p , size_t l , struct in6_addr  const  *d ) 
{ 


  {
#line 859
  return;
}
}
#line 863 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_state_up_cb___2(void *o , struct in6_addr  const  *a , uint16_t m ) 
{ 


  {
#line 869
  return;
}
}
#line 872 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void teredo_dummy_state_down_cb___2(void *o ) 
{ 


  {
#line 875
  return;
}
}
#line 952
static  __attribute__((__noreturn__)) void *teredo_recv_thread___2(void *t ) ;
#line 952 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/relay.c"
static void *teredo_recv_thread___2(void *t ) 
{ 
  teredo_tunnel *tunnel ;
  struct teredo_packet packet ;
  int tmp ;

  {
#line 954
  tunnel = (teredo_tunnel *)t;
  {
#line 956
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 960
    tmp = teredo_wait_recv(tunnel->fd, & packet);
    }
#line 960
    if (tmp == 0) {
      {
#line 962
      pthread_setcancelstate(1, (int *)((void *)0));
#line 963
      teredo_run_inner___2((teredo_tunnel */* __restrict  */)tunnel, (struct teredo_packet  const  */* __restrict  */)(& packet));
#line 964
      pthread_setcancelstate(0, (int *)((void *)0));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 67 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static unsigned int const   teredo_MaxQueueBytes___2  =    (unsigned int const   )1280;
#line 70 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
__inline static void teredo_peer_init___2(teredo_peer *peer ) 
{ 


  {
#line 72
  peer->queue = (teredo_queue *)((void *)0);
#line 73
  peer->queue_left = (size_t )teredo_MaxQueueBytes___2;
#line 74
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void teredo_peer_queue___2(teredo_peer * __restrict  peer , void const   * __restrict  data ,
                                  size_t len , uint32_t ip , uint16_t port , _Bool incoming ) 
{ 
  teredo_queue *p ;
  void *tmp ;

  {
#line 98
  if (len > peer->queue_left) {
#line 99
    return;
  }
  {
#line 100
  peer->queue_left -= len;
#line 102
  tmp = malloc(sizeof(*p) + len);
#line 102
  p = (teredo_queue *)tmp;
#line 103
  p->length = len;
#line 104
  memcpy((void */* __restrict  */)(p->data), data, len);
#line 105
  p->ipv4 = ip;
#line 106
  p->port = port;
#line 107
  p->incoming = incoming;
#line 109
  p->next = peer->queue;
#line 110
  peer->queue = p;
  }
#line 111
  return;
}
}
#line 181 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
__inline static teredo_listitem *listitem_create___2(void) 
{ 
  teredo_listitem *entry ;
  void *tmp ;

  {
  {
#line 183
  tmp = malloc(sizeof(*entry));
#line 183
  entry = (teredo_listitem *)tmp;
  }
#line 184
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
    {
#line 185
    teredo_peer_init___2(& entry->peer);
    }
  }
#line 186
  return (entry);
}
}
#line 197 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void listitem_recdestroy___2(teredo_listitem *entry ) 
{ 
  teredo_listitem *buf ;

  {
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 199
      goto while_break;
    }
    {
#line 201
    buf = entry->next;
#line 202
    listitem_destroy(entry);
#line 203
    entry = buf;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 208 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void listitem_free___2(void *p ) 
{ 


  {
#line 211
  return;
}
}
#line 213 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static int listitem_cmp___2(void const   *pa , void const   *pb ) 
{ 
  struct in6_addr  const  * const  *a ;
  struct in6_addr  const  * const  *b ;
  int tmp ;

  {
  {
#line 215
  a = (struct in6_addr  const  * const  *)pa;
#line 215
  b = (struct in6_addr  const  * const  *)pb;
#line 217
  tmp = memcmp((void const   *)a, (void const   *)b, sizeof(*(*a)));
  }
#line 217
  return (tmp);
}
}
#line 228
static  __attribute__((__noreturn__)) void *garbage_collector___2(void *data ) ;
#line 228 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c"
static void *garbage_collector___2(void *data ) 
{ 
  struct teredo_peerlist *l ;
  struct timespec delay ;
  int tmp ;
  int state ;
  teredo_listitem *p ;
  teredo_listitem **pp ;
  void *tmp___0 ;
  teredo_listitem *old ;

  {
#line 230
  l = (struct teredo_peerlist *)data;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    delay.tv_sec = (__time_t )l->expiration;
#line 234
    delay.tv_nsec = 0L;
    {
#line 235
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 235
      tmp = clock_nanosleep(0, 0, (struct timespec  const  *)(& delay), & delay);
      }
#line 235
      if (! tmp) {
#line 235
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 238
    pthread_setcancelstate(1, & state);
#line 240
    d_pthread_mutex_lock(& l->lock);
#line 243
    p = l->old;
    }
    {
#line 243
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 243
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 243
        goto while_break___1;
      }
      {
#line 253
      tmp___0 = tdelete((void const   */* __restrict  */)(& p->key.ip6), (void **/* __restrict  */)(& l->root),
                        & listitem_cmp___2);
#line 253
      pp = (teredo_listitem **)tmp___0;
      }
#line 254
      if (! ((unsigned long )pp != (unsigned long )((void *)0))) {
        {
#line 254
        __assert_fail("pp != ((void *)0)", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/peerlist.c",
                      254U, "garbage_collector");
        }
      }
#line 256
      (l->left) ++;
#line 243
      p = p->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 260
    old = l->old;
#line 263
    l->old = l->recent;
#line 264
    l->recent = (teredo_listitem *)((void *)0);
#line 265
    if ((unsigned long )l->old != (unsigned long )((void *)0)) {
#line 266
      (l->old)->pprev = & l->old;
    }
    {
#line 268
    d_pthread_mutex_unlock(& l->lock);
#line 271
    sched_yield();
#line 272
    listitem_recdestroy___2(old);
#line 275
    pthread_setcancelstate(state, (int *)((void *)0));
#line 276
    sched_yield();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 49 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
static void clock_tick___2(union sigval val ) 
{ 
  clock_data_t *context ;
  int orun ;
  int tmp ;
  struct itimerspec it ;

  {
  {
#line 51
  context = (clock_data_t *)val.sival_ptr;
#line 53
  tmp = timer_getoverrun(context->handle);
#line 53
  orun = tmp;
#line 54
  context->value += (teredo_clock_t )(1 + orun);
  }
#line 57
  if (orun == 2147483647) {
#line 59
    context->active = (_Bool)0;
  }
#line 62
  if (! context->active) {
    {
#line 64
    it.it_interval.tv_sec = 0L;
#line 64
    it.it_interval.tv_nsec = 0L;
#line 64
    it.it_value.tv_sec = (__time_t )0;
#line 64
    it.it_value.tv_nsec = (__syscall_slong_t )0;
#line 68
    timer_settime(context->handle, 0, (struct itimerspec  const  */* __restrict  */)(& it),
                  (struct itimerspec */* __restrict  */)((void *)0));
    }
  }
#line 71
  context->active = (_Bool)0;
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
static clock_data_t clk___2  =    {(void *)0, (teredo_clock_t )0, (_Bool)0};
#line 82 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/clock.c"
static struct __anonstruct_priv_55___2 priv___2  =    {{{0, 0U, 0, 0U, 2, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}},
    0, (_Bool)0};
#line 146 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.c"
static void md5_process___2(md5_state_t *pms , md5_byte_t const   *data ) 
{ 
  md5_word_t a ;
  md5_word_t b ;
  md5_word_t c ;
  md5_word_t d ;
  md5_word_t t ;
  md5_word_t xbuf[16] ;
  md5_word_t const   *X ;

  {
#line 149
  a = pms->abcd[0];
#line 149
  b = pms->abcd[1];
#line 149
  c = pms->abcd[2];
#line 149
  d = pms->abcd[3];
#line 179
  if (! ((data - (md5_byte_t const   *)0) & 3L)) {
#line 181
    X = (md5_word_t const   *)data;
  } else {
    {
#line 184
    memcpy((void */* __restrict  */)(xbuf), (void const   */* __restrict  */)data,
           (size_t )64);
#line 185
    X = (md5_word_t const   *)(xbuf);
    }
  }
#line 222
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 0)) + 3614090360U;
#line 222
  a = ((t << 7) | (t >> 25)) + b;
#line 223
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 1)) + 3905402710U;
#line 223
  d = ((t << 12) | (t >> 20)) + a;
#line 224
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 2)) + 606105819U;
#line 224
  c = ((t << 17) | (t >> 15)) + d;
#line 225
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 3)) + 3250441966U;
#line 225
  b = ((t << 22) | (t >> 10)) + c;
#line 226
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 4)) + 4118548399U;
#line 226
  a = ((t << 7) | (t >> 25)) + b;
#line 227
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 5)) + 1200080426U;
#line 227
  d = ((t << 12) | (t >> 20)) + a;
#line 228
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 6)) + 2821735955U;
#line 228
  c = ((t << 17) | (t >> 15)) + d;
#line 229
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 7)) + 4249261313U;
#line 229
  b = ((t << 22) | (t >> 10)) + c;
#line 230
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 8)) + 1770035416U;
#line 230
  a = ((t << 7) | (t >> 25)) + b;
#line 231
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 9)) + 2336552879U;
#line 231
  d = ((t << 12) | (t >> 20)) + a;
#line 232
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 10)) + 4294925233U;
#line 232
  c = ((t << 17) | (t >> 15)) + d;
#line 233
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 11)) + 2304563134U;
#line 233
  b = ((t << 22) | (t >> 10)) + c;
#line 234
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 12)) + 1804603682U;
#line 234
  a = ((t << 7) | (t >> 25)) + b;
#line 235
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 13)) + 4254626195U;
#line 235
  d = ((t << 12) | (t >> 20)) + a;
#line 236
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 14)) + 2792965006U;
#line 236
  c = ((t << 17) | (t >> 15)) + d;
#line 237
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 15)) + 1236535329U;
#line 237
  b = ((t << 22) | (t >> 10)) + c;
#line 248
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 1)) + 4129170786U;
#line 248
  a = ((t << 5) | (t >> 27)) + b;
#line 249
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 6)) + 3225465664U;
#line 249
  d = ((t << 9) | (t >> 23)) + a;
#line 250
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 11)) + 643717713U;
#line 250
  c = ((t << 14) | (t >> 18)) + d;
#line 251
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 0)) + 3921069994U;
#line 251
  b = ((t << 20) | (t >> 12)) + c;
#line 252
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 5)) + 3593408605U;
#line 252
  a = ((t << 5) | (t >> 27)) + b;
#line 253
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 10)) + 38016083U;
#line 253
  d = ((t << 9) | (t >> 23)) + a;
#line 254
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 15)) + 3634488961U;
#line 254
  c = ((t << 14) | (t >> 18)) + d;
#line 255
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 4)) + 3889429448U;
#line 255
  b = ((t << 20) | (t >> 12)) + c;
#line 256
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 9)) + 568446438U;
#line 256
  a = ((t << 5) | (t >> 27)) + b;
#line 257
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 14)) + 3275163606U;
#line 257
  d = ((t << 9) | (t >> 23)) + a;
#line 258
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 3)) + 4107603335U;
#line 258
  c = ((t << 14) | (t >> 18)) + d;
#line 259
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 8)) + 1163531501U;
#line 259
  b = ((t << 20) | (t >> 12)) + c;
#line 260
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 13)) + 2850285829U;
#line 260
  a = ((t << 5) | (t >> 27)) + b;
#line 261
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 2)) + 4243563512U;
#line 261
  d = ((t << 9) | (t >> 23)) + a;
#line 262
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 7)) + 1735328473U;
#line 262
  c = ((t << 14) | (t >> 18)) + d;
#line 263
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 12)) + 2368359562U;
#line 263
  b = ((t << 20) | (t >> 12)) + c;
#line 274
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 5)) + 4294588738U;
#line 274
  a = ((t << 4) | (t >> 28)) + b;
#line 275
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 8)) + 2272392833U;
#line 275
  d = ((t << 11) | (t >> 21)) + a;
#line 276
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 11)) + 1839030562U;
#line 276
  c = ((t << 16) | (t >> 16)) + d;
#line 277
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 14)) + 4259657740U;
#line 277
  b = ((t << 23) | (t >> 9)) + c;
#line 278
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 1)) + 2763975236U;
#line 278
  a = ((t << 4) | (t >> 28)) + b;
#line 279
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 4)) + 1272893353U;
#line 279
  d = ((t << 11) | (t >> 21)) + a;
#line 280
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 7)) + 4139469664U;
#line 280
  c = ((t << 16) | (t >> 16)) + d;
#line 281
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 10)) + 3200236656U;
#line 281
  b = ((t << 23) | (t >> 9)) + c;
#line 282
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 13)) + 681279174U;
#line 282
  a = ((t << 4) | (t >> 28)) + b;
#line 283
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 0)) + 3936430074U;
#line 283
  d = ((t << 11) | (t >> 21)) + a;
#line 284
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 3)) + 3572445317U;
#line 284
  c = ((t << 16) | (t >> 16)) + d;
#line 285
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 6)) + 76029189U;
#line 285
  b = ((t << 23) | (t >> 9)) + c;
#line 286
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 9)) + 3654602809U;
#line 286
  a = ((t << 4) | (t >> 28)) + b;
#line 287
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 12)) + 3873151461U;
#line 287
  d = ((t << 11) | (t >> 21)) + a;
#line 288
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 15)) + 530742520U;
#line 288
  c = ((t << 16) | (t >> 16)) + d;
#line 289
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 2)) + 3299628645U;
#line 289
  b = ((t << 23) | (t >> 9)) + c;
#line 300
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 0)) + 4096336452U;
#line 300
  a = ((t << 6) | (t >> 26)) + b;
#line 301
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 7)) + 1126891415U;
#line 301
  d = ((t << 10) | (t >> 22)) + a;
#line 302
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 14)) + 2878612391U;
#line 302
  c = ((t << 15) | (t >> 17)) + d;
#line 303
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 5)) + 4237533241U;
#line 303
  b = ((t << 21) | (t >> 11)) + c;
#line 304
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 12)) + 1700485571U;
#line 304
  a = ((t << 6) | (t >> 26)) + b;
#line 305
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 3)) + 2399980690U;
#line 305
  d = ((t << 10) | (t >> 22)) + a;
#line 306
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 10)) + 4293915773U;
#line 306
  c = ((t << 15) | (t >> 17)) + d;
#line 307
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 1)) + 2240044497U;
#line 307
  b = ((t << 21) | (t >> 11)) + c;
#line 308
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 8)) + 1873313359U;
#line 308
  a = ((t << 6) | (t >> 26)) + b;
#line 309
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 15)) + 4264355552U;
#line 309
  d = ((t << 10) | (t >> 22)) + a;
#line 310
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 6)) + 2734768916U;
#line 310
  c = ((t << 15) | (t >> 17)) + d;
#line 311
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 13)) + 1309151649U;
#line 311
  b = ((t << 21) | (t >> 11)) + c;
#line 312
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 4)) + 4149444226U;
#line 312
  a = ((t << 6) | (t >> 26)) + b;
#line 313
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 11)) + 3174756917U;
#line 313
  d = ((t << 10) | (t >> 22)) + a;
#line 314
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 2)) + 718787259U;
#line 314
  c = ((t << 15) | (t >> 17)) + d;
#line 315
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 9)) + 3951481745U;
#line 315
  b = ((t << 21) | (t >> 11)) + c;
#line 321
  pms->abcd[0] += a;
#line 322
  pms->abcd[1] += b;
#line 323
  pms->abcd[2] += c;
#line 324
  pms->abcd[3] += d;
#line 325
  return;
}
}
#line 378 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/md5.c"
static md5_byte_t const   pad___2[64]  = 
#line 378
  {      (md5_byte_t const   )128,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0};
#line 107 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static int getipv4byname___2(char const   * __restrict  name , uint32_t * __restrict  ipv4 ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *res ;
  int val ;
  int tmp ;

  {
  {
#line 109
  hints.ai_flags = 0;
#line 109
  hints.ai_family = 2;
#line 109
  hints.ai_socktype = 2;
#line 109
  hints.ai_protocol = 0;
#line 109
  hints.ai_addrlen = 0U;
#line 109
  hints.ai_addr = (struct sockaddr *)0;
#line 109
  hints.ai_canonname = (char *)0;
#line 109
  hints.ai_next = (struct addrinfo *)0;
#line 115
  tmp = getaddrinfo(name, (char const   */* __restrict  */)((void *)0), (struct addrinfo  const  */* __restrict  */)(& hints),
                    (struct addrinfo **/* __restrict  */)(& res));
#line 115
  val = tmp;
  }
#line 116
  if (val) {
#line 117
    return (val);
  }
  {
#line 119
  *ipv4 = (uint32_t )((struct sockaddr_in  const  *)res->ai_addr)->sin_addr.s_addr;
#line 120
  freeaddrinfo(res);
  }
#line 122
  return (0);
}
}
#line 131 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static int maintenance_recv___2(teredo_packet const   * __restrict  packet , uint32_t server_ip ,
                                uint8_t const   * __restrict  nonce , _Bool cone ,
                                teredo_state * __restrict  state ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 136
  if (! packet->auth_present) {
    {
#line 136
    __assert_fail("packet->auth_present", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c",
                  136U, "maintenance_recv");
    }
  }
  {
#line 138
  tmp = memcmp((void const   *)(packet->auth_nonce), (void const   *)nonce, (size_t )8);
  }
#line 138
  if (tmp) {
#line 139
    return (1);
  }
#line 142
  if (packet->auth_fail) {
    {
#line 144
    tmp___0 = dgettext("miredo", "Authentication with server failed.");
#line 144
    syslog(3, (char const   *)tmp___0);
    }
#line 145
    return (13);
  }
  {
#line 148
  tmp___1 = teredo_parse_ra(packet, (union teredo_addr */* __restrict  */)(& state->addr),
                            cone, (uint16_t */* __restrict  */)(& state->mtu));
  }
#line 148
  if (tmp___1) {
#line 151
    return (22);
  } else
#line 148
  if (state->addr.teredo.server_ip != server_ip) {
#line 151
    return (22);
  }
#line 154
  state->ipv4 = (uint32_t )packet->dest_ipv4;
#line 155
  return (0);
}
}
#line 163 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static int wait_reply___2(teredo_maintenance * __restrict  m , struct timespec  const  * __restrict  deadline ) 
{ 
  int tmp ;

  {
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! ((unsigned long )m->incoming == (unsigned long )((void *)0))) {
#line 166
      goto while_break;
    }
    {
#line 168
    tmp = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& m->received),
                                 (pthread_mutex_t */* __restrict  */)(& m->inner),
                                 deadline);
    }
    {
#line 170
    if (tmp == 0) {
#line 170
      goto case_0;
    }
#line 172
    if (tmp == 110) {
#line 172
      goto case_110;
    }
#line 168
    goto switch_break;
    case_0: /* CIL Label */ 
#line 171
    goto switch_break;
    case_110: /* CIL Label */ 
#line 173
    return (110);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return (0);
}
}
#line 184 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static void wait_reply_ignore___2(teredo_maintenance * __restrict  m , struct timespec  const  * __restrict  deadline ) 
{ 
  int tmp ;

  {
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 187
    tmp = wait_reply___2(m, deadline);
    }
#line 187
    if (! (tmp == 0)) {
#line 187
      goto while_break;
    }
    {
#line 189
    m->incoming = (teredo_packet const   *)((void *)0);
#line 190
    pthread_cond_signal(& m->processed);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 199 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static _Bool checkTimeDrift___2(struct timespec *ts ) 
{ 
  struct timespec now ;
  char *tmp ;

  {
  {
#line 203
  gettime(& now);
  }
#line 205
  if (now.tv_sec > ts->tv_sec) {
    {
#line 209
    tmp = dgettext("miredo", "Too much time drift. Resynchronizing.");
#line 209
    syslog(4, (char const   *)tmp);
#line 210
    *ts = now;
    }
#line 211
    return ((_Bool)0);
  } else
#line 205
  if (now.tv_sec == ts->tv_sec) {
#line 205
    if (now.tv_nsec > ts->tv_nsec) {
      {
#line 209
      tmp = dgettext("miredo", "Too much time drift. Resynchronizing.");
#line 209
      syslog(4, (char const   *)tmp);
#line 210
      *ts = now;
      }
#line 211
      return ((_Bool)0);
    }
  }
#line 213
  return ((_Bool)1);
}
}
#line 217 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static void cleanup_unlock___2(void *o ) 
{ 


  {
  {
#line 220
  d_pthread_mutex_unlock((pthread_mutex_t *)o);
  }
#line 221
  return;
}
}
#line 241
__inline static  __attribute__((__noreturn__)) void maintenance_thread___2(teredo_maintenance *m ) ;
#line 241 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
__inline static void maintenance_thread___2(teredo_maintenance *m ) 
{ 
  struct timespec deadline ;
  teredo_state *c_state ;
  uint32_t server_ip ;
  unsigned int count ;
  enum __anonenum_last_error_87___2 last_error ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp ;
  long tmp___0 ;
  int val ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;
  uint8_t nonce[8] ;
  uint16_t tmp___7 ;
  int val___0 ;
  teredo_state newst ;
  unsigned int delay ;
  char *tmp___8 ;
  char *tmp___9 ;
  uint16_t f ;
  uint16_t tmp___10 ;
  uint16_t tmp___11 ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp___12 ;
  char *tmp___13 ;
  struct in6_addr  const  *__a___0 ;
  struct in6_addr  const  *__b___0 ;
  int tmp___14 ;

  {
  {
#line 244
  deadline.tv_sec = (__time_t )0;
#line 244
  deadline.tv_nsec = (__syscall_slong_t )0;
#line 245
  c_state = & m->state.state;
#line 246
  server_ip = (uint32_t )0;
#line 247
  count = 0U;
#line 248
  last_error = (enum __anonenum_last_error_87___2 )0;
#line 254
  d_pthread_mutex_lock(& m->inner);
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 259
    __cancel_routine = & cleanup_unlock___2;
#line 259
    __cancel_arg = (void *)(& m->inner);
#line 259
    tmp = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                      0);
#line 259
    __not_first_call = tmp;
#line 259
    tmp___0 = __builtin_expect((long )__not_first_call, 0L);
    }
#line 259
    if (tmp___0) {
      {
#line 259
      (*__cancel_routine)(__cancel_arg);
#line 259
      __pthread_unwind_next(& __cancel_buf);
      }
    }
    {
#line 259
    __pthread_register_cancel(& __cancel_buf);
    }
    {
#line 259
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 260
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 263
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 263
          if (! (server_ip == 0U)) {
#line 263
            goto while_break___2;
          }
          {
#line 266
          tmp___1 = getipv4byname___2((char const   */* __restrict  */)m->server,
                                      (uint32_t */* __restrict  */)(& server_ip));
#line 266
          val = tmp___1;
#line 267
          gettime(& deadline);
          }
#line 269
          if (val) {
            {
#line 272
            tmp___2 = gai_strerror(val);
#line 272
            tmp___3 = dgettext("miredo", "Cannot resolve Teredo server address \"%s\": %s");
#line 272
            syslog(3, (char const   *)tmp___3, m->server, tmp___2);
            }
          } else {
            {
#line 277
            tmp___5 = is_ipv4_global_unicast(server_ip);
            }
#line 277
            if (tmp___5) {
#line 286
              if (! (! c_state->up)) {
                {
#line 286
                __assert_fail("!c_state->up", "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c",
                              286U, "maintenance_thread");
                }
              }
              {
#line 287
              c_state->addr.teredo.server_ip = server_ip;
#line 288
              (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
              }
#line 289
              goto while_break___2;
            } else {
              {
#line 279
              tmp___4 = dgettext("miredo", "Teredo server has a non global IPv4 address.");
#line 279
              syslog(3, (char const   *)tmp___4);
              }
            }
          }
          {
#line 293
          deadline.tv_sec += (__time_t )m->restart_delay;
#line 294
          server_ip = (uint32_t )0;
#line 295
          wait_reply_ignore___2((teredo_maintenance */* __restrict  */)m, (struct timespec  const  */* __restrict  */)(& deadline));
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 299
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 300
          deadline.tv_sec += (__time_t )m->qualification_delay;
#line 299
          tmp___6 = checkTimeDrift___2(& deadline);
          }
#line 299
          if (tmp___6) {
#line 299
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 304
        tmp___7 = htons((uint16_t )3544);
#line 304
        teredo_get_nonce((uint32_t )deadline.tv_sec, server_ip, tmp___7, (uint8_t */* __restrict  */)(nonce));
#line 306
        teredo_send_rs(m->fd, server_ip, (unsigned char const   *)(nonce), (_Bool)0);
#line 308
        val___0 = 0;
#line 310
        newst.mtu = (uint16_t )1280;
#line 311
        newst.up = (_Bool)1;
        }
        {
#line 314
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 316
          val___0 = wait_reply___2((teredo_maintenance */* __restrict  */)m, (struct timespec  const  */* __restrict  */)(& deadline));
          }
#line 317
          if (val___0) {
#line 318
            goto __Cont;
          }
          {
#line 321
          val___0 = maintenance_recv___2((teredo_packet const   */* __restrict  */)m->incoming,
                                         server_ip, (uint8_t const   */* __restrict  */)(nonce),
                                         (_Bool)0, (teredo_state */* __restrict  */)(& newst));
#line 323
          m->incoming = (teredo_packet const   *)((void *)0);
#line 324
          pthread_cond_signal(& m->processed);
          }
          __Cont: /* CIL Label */ 
#line 314
          if (val___0 != 0) {
#line 314
            if (! (val___0 != 110)) {
#line 314
              goto while_break___4;
            }
          } else {
#line 314
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 328
        delay = 0U;
#line 331
        if (val___0) {
#line 334
          count ++;
#line 336
          if (count >= m->qualification_retries) {
#line 338
            count = 0U;
#line 341
            if ((unsigned int )last_error != 1U) {
              {
#line 343
              tmp___8 = dgettext("miredo", "No reply from Teredo server");
#line 343
              syslog(6, (char const   *)tmp___8);
#line 344
              last_error = (enum __anonenum_last_error_87___2 )1;
              }
            }
#line 347
            if (c_state->up) {
              {
#line 349
              tmp___9 = dgettext("miredo", "Lost Teredo connectivity");
#line 349
              syslog(5, (char const   *)tmp___9);
#line 350
              c_state->up = (_Bool)0;
#line 351
              (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
#line 352
              server_ip = (uint32_t )0;
              }
            }
#line 356
            delay = m->restart_delay;
          }
        } else {
#line 362
          count = 0U;
#line 365
          newst.addr.teredo.flags = c_state->addr.teredo.flags;
#line 366
          __a = (struct in6_addr  const  *)(& c_state->addr.ip6);
#line 366
          __b = (struct in6_addr  const  *)(& newst.addr.ip6);
#line 366
          if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 366
            if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 366
              if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 366
                if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 366
                  tmp___12 = 1;
                } else {
#line 366
                  tmp___12 = 0;
                }
              } else {
#line 366
                tmp___12 = 0;
              }
            } else {
#line 366
              tmp___12 = 0;
            }
          } else {
#line 366
            tmp___12 = 0;
          }
#line 366
          if (! tmp___12) {
            {
#line 368
            tmp___10 = teredo_get_flbits((uint32_t )deadline.tv_sec);
#line 368
            f = tmp___10;
#line 369
            tmp___11 = htons((uint16_t )15615);
#line 369
            newst.addr.teredo.flags = (uint16_t )((int )f & (int )tmp___11);
            }
          }
#line 374
          if (! c_state->up) {
            {
#line 377
            memcpy((void */* __restrict  */)c_state, (void const   */* __restrict  */)(& newst),
                   sizeof(*c_state));
#line 379
            tmp___13 = dgettext("miredo", "New Teredo address/MTU");
#line 379
            syslog(5, (char const   *)tmp___13);
#line 380
            (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
            }
          } else {
#line 374
            __a___0 = (struct in6_addr  const  *)(& c_state->addr.ip6);
#line 374
            __b___0 = (struct in6_addr  const  *)(& newst.addr.ip6);
#line 374
            if (__a___0->__in6_u.__u6_addr32[0] == __b___0->__in6_u.__u6_addr32[0]) {
#line 374
              if (__a___0->__in6_u.__u6_addr32[1] == __b___0->__in6_u.__u6_addr32[1]) {
#line 374
                if (__a___0->__in6_u.__u6_addr32[2] == __b___0->__in6_u.__u6_addr32[2]) {
#line 374
                  if (__a___0->__in6_u.__u6_addr32[3] == __b___0->__in6_u.__u6_addr32[3]) {
#line 374
                    tmp___14 = 1;
                  } else {
#line 374
                    tmp___14 = 0;
                  }
                } else {
#line 374
                  tmp___14 = 0;
                }
              } else {
#line 374
                tmp___14 = 0;
              }
            } else {
#line 374
              tmp___14 = 0;
            }
#line 374
            if (tmp___14) {
#line 374
              if ((int )c_state->mtu != (int )newst.mtu) {
                {
#line 377
                memcpy((void */* __restrict  */)c_state, (void const   */* __restrict  */)(& newst),
                       sizeof(*c_state));
#line 379
                tmp___13 = dgettext("miredo", "New Teredo address/MTU");
#line 379
                syslog(5, (char const   *)tmp___13);
#line 380
                (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
                }
              }
            } else {
              {
#line 377
              memcpy((void */* __restrict  */)c_state, (void const   */* __restrict  */)(& newst),
                     sizeof(*c_state));
#line 379
              tmp___13 = dgettext("miredo", "New Teredo address/MTU");
#line 379
              syslog(5, (char const   *)tmp___13);
#line 380
              (*(m->state.cb))((struct teredo_state  const  *)c_state, m->state.opaque);
              }
            }
          }
#line 384
          last_error = (enum __anonenum_last_error_87___2 )0;
#line 385
          delay = m->refresh_delay;
        }
#line 391
        if (delay) {
          {
#line 393
          deadline.tv_sec -= (__time_t )m->qualification_delay;
#line 394
          deadline.tv_sec += (__time_t )delay;
#line 395
          wait_reply_ignore___2((teredo_maintenance */* __restrict  */)m, (struct timespec  const  */* __restrict  */)(& deadline));
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 399
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 399
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 259
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 399
    __pthread_unregister_cancel(& __cancel_buf);
#line 399
    (*__cancel_routine)(__cancel_arg);
    }
#line 259
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 403
static  __attribute__((__noreturn__)) void *do_maintenance___2(void *opaque ) ;
#line 403 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static void *do_maintenance___2(void *opaque ) 
{ 


  {
  {
#line 405
  maintenance_thread___2((teredo_maintenance *)opaque);
  }
}
}
#line 409 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   QualificationDelay___2  =    (unsigned int const   )4;
#line 410 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   QualificationRetries___2  =    (unsigned int const   )3;
#line 412 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   RefreshDelay___2  =    (unsigned int const   )30;
#line 413 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/maintain.c"
static unsigned int const   RestartDelay___2  =    (unsigned int const   )100;
#line 59 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
static uint8_t const   head___2[9]  = 
#line 59 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
  {      (uint8_t const   )'`',      (uint8_t const   )'\000',      (uint8_t const   )'\000',      (uint8_t const   )'\000', 
        (uint8_t const   )'\000',      (uint8_t const   )'\000',      (uint8_t const   )';',      (uint8_t const   )'\000', 
        (uint8_t const   )'\000'};
#line 115 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/packets.c"
static struct in6_addr  const  in6addr_allrouters___3  =    {{{(uint8_t )255, (uint8_t )2, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0,
      (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0,
      (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )2}}};
#line 117 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
static ssize_t teredo_recverr___2(int fd ) 
{ 
  struct msghdr msg ;
  ssize_t tmp ;

  {
  {
#line 123
  memset((void *)(& msg), 0, sizeof(msg));
#line 124
  tmp = recvmsg(fd, & msg, 8192);
  }
#line 124
  return (tmp);
}
}
#line 173 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
static int teredo_recv_inner___2(int fd , struct teredo_packet *p , int flags ) 
{ 
  struct sockaddr_in ad ;
  char cbuf[(((sizeof(struct in_pktinfo ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
  struct iovec iov ;
  struct msghdr msg ;
  ssize_t length ;
  ssize_t tmp ;
  struct cmsghdr *cmsg ;
  struct cmsghdr *tmp___0 ;
  struct in_pktinfo  const  *nfo ;
  uint8_t *ptr ;
  uint8_t id_len ;
  uint8_t au_len ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;
  uint32_t addr ;
  uint16_t port ;

  {
  {
#line 181
  iov.iov_base = (void *)(p->buf.fill);
#line 181
  iov.iov_len = (size_t )65507;
#line 186
  msg.msg_name = (void *)(& ad);
#line 186
  msg.msg_namelen = (socklen_t )sizeof(ad);
#line 186
  msg.msg_iov = & iov;
#line 186
  msg.msg_iovlen = (size_t )1;
#line 186
  msg.msg_control = (void *)(cbuf);
#line 186
  msg.msg_controllen = sizeof(cbuf);
#line 186
  msg.msg_flags = 0;
#line 199
  tmp = recvmsg(fd, & msg, flags);
#line 199
  length = tmp;
  }
#line 200
  if (length == -1L) {
    {
#line 201
    teredo_recverr___2(fd);
    }
  }
#line 202
  if (length < 2L) {
#line 203
    return (-1);
  }
#line 205
  p->source_ipv4 = ad.sin_addr.s_addr;
#line 206
  p->source_port = ad.sin_port;
#line 207
  p->dest_ipv4 = (uint32_t )0;
#line 212
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 212
    tmp___0 = (struct cmsghdr *)msg.msg_control;
  } else {
#line 212
    tmp___0 = (struct cmsghdr *)0;
  }
#line 212
  cmsg = tmp___0;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! ((unsigned long )cmsg != (unsigned long )((void *)0))) {
#line 212
      goto while_break;
    }
#line 217
    if (cmsg->cmsg_level == 0) {
#line 217
      if (cmsg->cmsg_type == 8) {
#line 220
        nfo = (struct in_pktinfo  const  *)((struct in_pktinfo *)(cmsg->__cmsg_data));
#line 222
        p->dest_ipv4 = (uint32_t )nfo->ipi_addr.s_addr;
      }
    }
    {
#line 212
    cmsg = __cmsg_nxthdr(& msg, cmsg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  ptr = p->buf.fill;
#line 238
  p->auth_present = (_Bool)0;
#line 239
  p->orig_ipv4 = (uint32_t )0;
#line 240
  p->orig_port = (uint16_t )0;
#line 243
  if ((int )*(ptr + 0) == 0) {
#line 243
    if ((int )*(ptr + 1) == 1) {
#line 247
      p->auth_present = (_Bool)1;
#line 249
      length -= 13L;
#line 250
      if (length < 0L) {
#line 251
        return (-1);
      }
#line 252
      ptr += 2;
#line 255
      tmp___1 = ptr;
#line 255
      ptr ++;
#line 255
      id_len = *tmp___1;
#line 256
      tmp___2 = ptr;
#line 256
      ptr ++;
#line 256
      au_len = *tmp___2;
#line 259
      length -= (ssize_t )((int )id_len + (int )au_len);
#line 260
      if (length < 0L) {
#line 261
        return (-1);
      }
      {
#line 262
      ptr += (int )id_len + (int )au_len;
#line 265
      memcpy((void */* __restrict  */)(p->auth_nonce), (void const   */* __restrict  */)ptr,
             (size_t )8);
#line 266
      ptr += 8;
#line 267
      p->auth_fail = (_Bool )(! (! *ptr));
#line 268
      ptr ++;
#line 273
      memmove((void *)(p->buf.align), (void const   *)ptr, (size_t )length);
#line 274
      ptr = p->buf.fill;
      }
    }
  }
#line 278
  if ((int )*(ptr + 0) == 0) {
#line 278
    if ((int )*(ptr + 1) == 0) {
#line 283
      length -= 8L;
#line 284
      if (length < 0L) {
#line 285
        return (-1);
      }
      {
#line 286
      ptr += 2;
#line 289
      memcpy((void */* __restrict  */)(& port), (void const   */* __restrict  */)ptr,
             (size_t )2);
#line 290
      ptr += 2;
#line 291
      p->orig_port = (uint16_t )(~ ((int )port));
#line 294
      memcpy((void */* __restrict  */)(& addr), (void const   */* __restrict  */)ptr,
             (size_t )4);
#line 295
      ptr += 4;
#line 296
      p->orig_ipv4 = ~ addr;
      }
    }
  }
#line 299
  p->ip6_len = (size_t )length;
#line 300
  p->ip6 = (struct ip6_hdr *)ptr;
#line 302
  return (0);
}
}
#line 338 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/teredo.c"
static uint16_t in_cksum___2(struct iovec  const  *iov , size_t n ) 
{ 
  uint32_t sum ;
  union __anonunion_w_31___2 w ;
  _Bool odd ;
  uint8_t const   *ptr ;
  size_t len ;
  uint8_t const   *tmp ;
  uint8_t const   *tmp___0 ;

  {
#line 340
  sum = (uint32_t )0;
#line 346
  odd = (_Bool)0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (n > 0UL)) {
#line 348
      goto while_break;
    }
#line 350
    ptr = (uint8_t const   *)iov->iov_base;
#line 352
    len = (size_t )iov->iov_len;
    {
#line 352
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 352
      if (! (len > 0UL)) {
#line 352
        goto while_break___0;
      }
#line 354
      if (odd) {
#line 356
        tmp = ptr;
#line 356
        ptr ++;
#line 356
        w.bytes[1] = (uint8_t )*tmp;
#line 357
        sum += (uint32_t )w.word;
#line 358
        if (sum > 65535U) {
#line 359
          sum -= 65535U;
        }
      } else {
#line 362
        tmp___0 = ptr;
#line 362
        ptr ++;
#line 362
        w.bytes[0] = (uint8_t )*tmp___0;
      }
#line 363
      odd = (_Bool )(! odd);
#line 352
      len --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    iov ++;
#line 367
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  if (odd) {
#line 372
    w.bytes[1] = (uint8_t )0;
#line 373
    sum += (uint32_t )w.word;
#line 374
    if (sum > 65535U) {
#line 375
      sum -= 65535U;
    }
  }
#line 378
  return ((uint16_t )(sum ^ 65535U));
}
}
#line 46 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static char const   randfile___2[12]  = 
#line 46 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
  {      (char const   )'/',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'/',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'o',      (char const   )'m',      (char const   )'\000'};
#line 57 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static union __anonunion_inner_key_40___2 inner_key___2  ;
#line 63 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static union __anonunion_outer_key_41___2 outer_key___2  ;
#line 70 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static uint16_t hmac_pid___2  =    (uint16_t )0;
#line 74 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static pthread_mutex_t mutex___2  =    {{0, 0U, 0, 0U, 2, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 125 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
static void teredo_hash___2(void const   *src , size_t slen , void const   *dst ,
                            size_t dlen , uint8_t * __restrict  hash , uint32_t timestamp ) 
{ 
  md5_state_t ctx ;

  {
  {
#line 131
  md5_init(& ctx);
#line 132
  md5_append(& ctx, (md5_byte_t const   *)(inner_key___2.ipad), (int )sizeof(inner_key___2.ipad));
#line 133
  md5_append(& ctx, (unsigned char const   *)src, (int )slen);
#line 134
  md5_append(& ctx, (unsigned char const   *)dst, (int )dlen);
#line 135
  md5_append(& ctx, (unsigned char const   *)(& hmac_pid___2), (int )sizeof(hmac_pid___2));
#line 136
  md5_append(& ctx, (unsigned char const   *)(& timestamp), (int )sizeof(timestamp));
#line 137
  md5_finish(& ctx, (md5_byte_t *)hash);
#line 139
  md5_init(& ctx);
#line 140
  md5_append(& ctx, (md5_byte_t const   *)(outer_key___2.opad), (int )sizeof(outer_key___2.opad));
#line 141
  md5_append(& ctx, (md5_byte_t const   *)hash, 16);
#line 142
  md5_finish(& ctx, (md5_byte_t *)hash);
  }
#line 143
  return;
}
}
#line 157 "/home/wheatley/newnew/temp/miredo-1.2.6/libteredo/security.c"
__inline static void teredo_pinghash___2(struct in6_addr  const  *src , struct in6_addr  const  *dst ,
                                         uint8_t * __restrict  hash , uint32_t timestamp ) 
{ 


  {
  {
#line 161
  teredo_hash___2((void const   *)src, sizeof(*src), (void const   *)dst, sizeof(*dst),
                  hash, timestamp);
  }
#line 162
  return;
}
}
