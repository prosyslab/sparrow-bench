/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_un;
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_29 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_31 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_32 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_33 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_34 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_27 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_28 _kill ;
   struct __anonstruct__timer_29 _timer ;
   struct __anonstruct__rt_30 _rt ;
   struct __anonstruct__sigchld_31 _sigchld ;
   struct __anonstruct__sigfault_32 _sigfault ;
   struct __anonstruct__sigpoll_33 _sigpoll ;
   struct __anonstruct__sigsys_34 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_26 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_27 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_26 siginfo_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_46 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_46 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 90
struct sockaddr_in6;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_62 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_62 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 40 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
struct __anonstruct_entries_64 {
   struct reqelem *le_next ;
   struct reqelem **le_prev ;
};
#line 40 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
struct reqelem {
   int socket ;
   struct __anonstruct_entries_64 entries ;
};
#line 46 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
struct header {
   char const   *p ;
   int l ;
};
#line 55 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
struct device {
   struct device *next ;
   time_t t ;
   struct header headers[3] ;
   char data[] ;
};
#line 214 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
struct __anonstruct_entries_65 {
   struct service *le_next ;
   struct service **le_prev ;
};
#line 214 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
struct service {
   char *st ;
   char *usn ;
   char *server ;
   char *location ;
   struct __anonstruct_entries_65 entries ;
};
#line 221 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
struct servicehead {
   struct service *lh_first ;
};
#line 766 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
struct reqstructhead {
   struct reqelem *lh_first ;
};
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 11 "/usr/include/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 35 "/usr/include/linux/netlink.h"
struct sockaddr_nl {
   __kernel_sa_family_t nl_family ;
   unsigned short nl_pad ;
   __u32 nl_pid ;
   __u32 nl_groups ;
};
#line 42 "/usr/include/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 7 "/usr/include/linux/if_addr.h"
struct ifaddrmsg {
   __u8 ifa_family ;
   __u8 ifa_prefixlen ;
   __u8 ifa_flags ;
   __u8 ifa_scope ;
   __u32 ifa_index ;
};
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 264 "/usr/include/netinet/in.h"
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
#line 288 "/usr/include/netinet/in.h"
struct ipv6_mreq {
   struct in6_addr ipv6mr_multiaddr ;
   unsigned int ipv6mr_interface ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_28 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_29 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_28 ifr_ifrn ;
   union __anonunion_ifr_ifru_29 ifr_ifru ;
};
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 19 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/testminissdpd.c"
void printresponse(unsigned char const   *resp , int n ) 
{ 
  int i ;
  int l ;
  unsigned int nresp ;
  unsigned char const   *p ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;

  {
#line 24
  i = 0;
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 24
    if (! (i < n)) {
#line 24
      goto while_break;
    }
    {
#line 25
    printf((char const   */* __restrict  */)"%02x ", (int const   )*(resp + i));
#line 24
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 26
  printf((char const   */* __restrict  */)"\n");
#line 27
  nresp = (unsigned int )*(resp + 0);
#line 28
  p = resp + 1;
#line 29
  i = 0;
  }
  {
#line 29
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 29
    if (! ((unsigned int )i < nresp)) {
#line 29
      goto while_break___0;
    }
#line 31
    l = 0;
    {
#line 31
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 31
      l = (l << 7) | (int )((int const   )*p & 127);
#line 31
      tmp = p;
#line 31
      p ++;
#line 31
      if (! ((int const   )*tmp & 128)) {
#line 31
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 32
    printf((char const   */* __restrict  */)"%d - %.*s\n", i, l, p);
#line 33
    p += l;
#line 35
    l = 0;
    }
    {
#line 35
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 35
      l = (l << 7) | (int )((int const   )*p & 127);
#line 35
      tmp___0 = p;
#line 35
      p ++;
#line 35
      if (! ((int const   )*tmp___0 & 128)) {
#line 35
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 36
    printf((char const   */* __restrict  */)"    %.*s\n", l, p);
#line 37
    p += l;
#line 39
    l = 0;
    }
    {
#line 39
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 39
      l = (l << 7) | (int )((int const   )*p & 127);
#line 39
      tmp___1 = p;
#line 39
      p ++;
#line 39
      if (! ((int const   )*tmp___1 & 128)) {
#line 39
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 40
    printf((char const   */* __restrict  */)"    %.*s\n", l, p);
#line 41
    p += l;
#line 29
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 43
  return;
}
}
#line 49 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/testminissdpd.c"
int main(int argc , char **argv ) 
{ 
  char command1[52] ;
  char command2[61] ;
  char command3[2] ;
  struct sockaddr_un addr ;
  int s ;
  int i ;
  unsigned char buf[2048] ;
  ssize_t n ;
  char const   *sockpath ;
  int tmp ;
  int tmp___0 ;

  {
#line 52
  command1[0] = (char )'\001';
#line 52
  command1[1] = (char )'\000';
#line 52
  command1[2] = (char )'u';
#line 52
  command1[3] = (char )'r';
#line 52
  command1[4] = (char )'n';
#line 52
  command1[5] = (char )':';
#line 52
  command1[6] = (char )'s';
#line 52
  command1[7] = (char )'c';
#line 52
  command1[8] = (char )'h';
#line 52
  command1[9] = (char )'e';
#line 52
  command1[10] = (char )'m';
#line 52
  command1[11] = (char )'a';
#line 52
  command1[12] = (char )'s';
#line 52
  command1[13] = (char )'-';
#line 52
  command1[14] = (char )'u';
#line 52
  command1[15] = (char )'p';
#line 52
  command1[16] = (char )'n';
#line 52
  command1[17] = (char )'p';
#line 52
  command1[18] = (char )'-';
#line 52
  command1[19] = (char )'o';
#line 52
  command1[20] = (char )'r';
#line 52
  command1[21] = (char )'g';
#line 52
  command1[22] = (char )':';
#line 52
  command1[23] = (char )'d';
#line 52
  command1[24] = (char )'e';
#line 52
  command1[25] = (char )'v';
#line 52
  command1[26] = (char )'i';
#line 52
  command1[27] = (char )'c';
#line 52
  command1[28] = (char )'e';
#line 52
  command1[29] = (char )':';
#line 52
  command1[30] = (char )'I';
#line 52
  command1[31] = (char )'n';
#line 52
  command1[32] = (char )'t';
#line 52
  command1[33] = (char )'e';
#line 52
  command1[34] = (char )'r';
#line 52
  command1[35] = (char )'n';
#line 52
  command1[36] = (char )'e';
#line 52
  command1[37] = (char )'t';
#line 52
  command1[38] = (char )'G';
#line 52
  command1[39] = (char )'a';
#line 52
  command1[40] = (char )'t';
#line 52
  command1[41] = (char )'e';
#line 52
  command1[42] = (char )'w';
#line 52
  command1[43] = (char )'a';
#line 52
  command1[44] = (char )'y';
#line 52
  command1[45] = (char )'D';
#line 52
  command1[46] = (char )'e';
#line 52
  command1[47] = (char )'v';
#line 52
  command1[48] = (char )'i';
#line 52
  command1[49] = (char )'c';
#line 52
  command1[50] = (char )'e';
#line 52
  command1[51] = (char )'\000';
#line 53
  command2[0] = (char )'\002';
#line 53
  command2[1] = (char )'\000';
#line 53
  command2[2] = (char )'u';
#line 53
  command2[3] = (char )'u';
#line 53
  command2[4] = (char )'i';
#line 53
  command2[5] = (char )'d';
#line 53
  command2[6] = (char )':';
#line 53
  command2[7] = (char )'f';
#line 53
  command2[8] = (char )'c';
#line 53
  command2[9] = (char )'4';
#line 53
  command2[10] = (char )'e';
#line 53
  command2[11] = (char )'c';
#line 53
  command2[12] = (char )'5';
#line 53
  command2[13] = (char )'7';
#line 53
  command2[14] = (char )'e';
#line 53
  command2[15] = (char )'-';
#line 53
  command2[16] = (char )'b';
#line 53
  command2[17] = (char )'0';
#line 53
  command2[18] = (char )'5';
#line 53
  command2[19] = (char )'1';
#line 53
  command2[20] = (char )'-';
#line 53
  command2[21] = (char )'1';
#line 53
  command2[22] = (char )'1';
#line 53
  command2[23] = (char )'d';
#line 53
  command2[24] = (char )'b';
#line 53
  command2[25] = (char )'-';
#line 53
  command2[26] = (char )'8';
#line 53
  command2[27] = (char )'8';
#line 53
  command2[28] = (char )'f';
#line 53
  command2[29] = (char )'8';
#line 53
  command2[30] = (char )'-';
#line 53
  command2[31] = (char )'0';
#line 53
  command2[32] = (char )'0';
#line 53
  command2[33] = (char )'6';
#line 53
  command2[34] = (char )'0';
#line 53
  command2[35] = (char )'0';
#line 53
  command2[36] = (char )'8';
#line 53
  command2[37] = (char )'5';
#line 53
  command2[38] = (char )'d';
#line 53
  command2[39] = (char )'b';
#line 53
  command2[40] = (char )'3';
#line 53
  command2[41] = (char )'f';
#line 53
  command2[42] = (char )'6';
#line 53
  command2[43] = (char )':';
#line 53
  command2[44] = (char )':';
#line 53
  command2[45] = (char )'u';
#line 53
  command2[46] = (char )'p';
#line 53
  command2[47] = (char )'n';
#line 53
  command2[48] = (char )'p';
#line 53
  command2[49] = (char )':';
#line 53
  command2[50] = (char )'r';
#line 53
  command2[51] = (char )'o';
#line 53
  command2[52] = (char )'o';
#line 53
  command2[53] = (char )'t';
#line 53
  command2[54] = (char )'d';
#line 53
  command2[55] = (char )'e';
#line 53
  command2[56] = (char )'v';
#line 53
  command2[57] = (char )'i';
#line 53
  command2[58] = (char )'c';
#line 53
  command2[59] = (char )'e';
#line 53
  command2[60] = (char )'\000';
#line 54
  command3[0] = (char)3;
#line 54
  command3[1] = (char)0;
#line 60
  sockpath = "/var/run/minissdpd.sock";
#line 62
  i = 0;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (i < argc - 1)) {
#line 62
      goto while_break;
    }
    {
#line 63
    tmp = strcmp((char const   *)*(argv + i), "-s");
    }
#line 63
    if (0 == tmp) {
#line 64
      i ++;
#line 64
      sockpath = (char const   *)*(argv + i);
    }
#line 62
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  command1[1] = (char )(sizeof(command1) - 3UL);
#line 67
  command2[1] = (char )(sizeof(command2) - 3UL);
#line 68
  s = socket(1, 1, 0);
#line 69
  addr.sun_family = (sa_family_t )1;
#line 70
  strncpy((char */* __restrict  */)(addr.sun_path), (char const   */* __restrict  */)sockpath,
          sizeof(addr.sun_path));
#line 71
  tmp___0 = connect(s, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
                    (socklen_t )sizeof(struct sockaddr_un ));
  }
#line 71
  if (tmp___0 < 0) {
    {
#line 72
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"connecting to %s\n",
            addr.sun_path);
#line 73
    perror("connect");
    }
#line 74
    return (1);
  }
  {
#line 76
  printf((char const   */* __restrict  */)"Connected.\n");
#line 78
  write(s, (void const   *)(command1), sizeof(command1) - 1UL);
#line 78
  printf((char const   */* __restrict  */)"Command written type=%u\n", (unsigned int )command1[0]);
#line 79
  n = read(s, (void *)(buf), sizeof(buf));
#line 80
  printf((char const   */* __restrict  */)"Response received %d bytes\n", (int )n);
#line 81
  printresponse((unsigned char const   *)(buf), (int )n);
#line 83
  write(s, (void const   *)(command2), sizeof(command2) - 1UL);
#line 83
  printf((char const   */* __restrict  */)"Command written type=%u\n", (unsigned int )command2[0]);
#line 84
  n = read(s, (void *)(buf), sizeof(buf));
#line 85
  printf((char const   */* __restrict  */)"Response received %d bytes\n", (int )n);
#line 86
  printresponse((unsigned char const   *)(buf), (int )n);
#line 88
  write(s, (void const   *)(command3), sizeof(command3));
#line 88
  printf((char const   */* __restrict  */)"Command written type=%u\n", (unsigned int )command3[0]);
#line 89
  n = read(s, (void *)(buf), sizeof(buf));
#line 90
  printf((char const   */* __restrict  */)"Response received %d bytes\n", (int )n);
#line 91
  printresponse((unsigned char const   *)(buf), (int )n);
#line 93
  close(s);
  }
#line 94
  return (0);
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 23 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/daemonize.h"
int writepidfile(char const   *fname , int pid ) ;
#line 31
int checkforrunning(char const   *fname ) ;
#line 63 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/daemonize.c"
int writepidfile(char const   *fname , int pid ) 
{ 
  char pidstring[16] ;
  int pidstringlen ;
  int pidfile ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
#line 70
  if (! fname) {
#line 71
    return (-1);
  } else {
    {
#line 70
    tmp = strlen(fname);
    }
#line 70
    if (tmp == 0UL) {
#line 71
      return (-1);
    }
  }
  {
#line 73
  pidfile = open(fname, 65, 420);
  }
#line 73
  if (pidfile < 0) {
    {
#line 75
    syslog(3, "Unable to open pidfile for writing %s: %m", fname);
    }
#line 76
    return (-1);
  }
  {
#line 79
  pidstringlen = snprintf((char */* __restrict  */)(pidstring), sizeof(pidstring),
                          (char const   */* __restrict  */)"%d\n", pid);
  }
#line 80
  if (pidstringlen <= 0) {
    {
#line 82
    syslog(3, "Unable to write to pidfile %s: snprintf(): FAILED", fname);
#line 84
    close(pidfile);
    }
#line 85
    return (-1);
  } else {
    {
#line 89
    tmp___0 = write(pidfile, (void const   *)(pidstring), (size_t )pidstringlen);
    }
#line 89
    if (tmp___0 < 0L) {
      {
#line 90
      syslog(3, "Unable to write to pidfile %s: %m", fname);
      }
    }
  }
  {
#line 93
  close(pidfile);
  }
#line 95
  return (0);
}
}
#line 98 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/daemonize.c"
int checkforrunning(char const   *fname ) 
{ 
  char buffer[64] ;
  int pidfile ;
  pid_t pid ;
  size_t tmp ;
  int tmp___0 ;
  long tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 105
  if (! fname) {
#line 106
    return (-1);
  } else {
    {
#line 105
    tmp = strlen(fname);
    }
#line 105
    if (tmp == 0UL) {
#line 106
      return (-1);
    }
  }
  {
#line 108
  pidfile = open(fname, 0);
  }
#line 108
  if (pidfile < 0) {
#line 109
    return (0);
  }
  {
#line 111
  memset((void *)(buffer), 0, (size_t )64);
#line 113
  tmp___2 = read(pidfile, (void *)(buffer), (size_t )63);
  }
#line 113
  if (tmp___2) {
    {
#line 115
    tmp___1 = atol((char const   *)(buffer));
#line 115
    pid = (pid_t )tmp___1;
    }
#line 115
    if (pid > 0) {
      {
#line 117
      tmp___0 = kill(pid, 0);
      }
#line 117
      if (! tmp___0) {
        {
#line 119
        close(pidfile);
        }
#line 120
        return (-2);
      }
    }
  }
  {
#line 125
  close(pidfile);
  }
#line 127
  return (0);
}
}
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 937
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 184
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setlogmask)(int __mask ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 16 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/upnputils.h"
int sockaddr_to_string(struct sockaddr  const  *addr , char *str , size_t size ) ;
#line 18 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/openssdpsocket.h"
int OpenAndConfSSDPReceiveSocket(int n_listen_addr , char const   **listen_addr ,
                                 int ipv6 ) ;
#line 11 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/ifacewatch.h"
int OpenAndConfInterfaceWatchSocket(void) ;
#line 14
int ProcessInterfaceWatch(int s , int s_ssdp , int s_ssdp6 , int n_if_addr , char const   **if_addr ) ;
#line 66 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
struct device *devlist  =    (struct device *)0;
#line 69 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
unsigned int upnp_bootid  =    1U;
#line 70 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
unsigned int upnp_configid  =    1337U;
#line 78 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
static int updateDevice(struct header  const  *headers , time_t t ) 
{ 
  struct device **pp ;
  struct device *p ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *pc ;
  int i ;
  void *tmp___2 ;

  {
#line 81
  pp = & devlist;
#line 82
  p = *pp;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! p) {
#line 83
      goto while_break;
    }
#line 85
    if (p->headers[0].l == (int )(headers + 0)->l) {
      {
#line 85
      tmp___0 = memcmp((void const   *)p->headers[0].p, (void const   *)(headers + 0)->p,
                       (size_t )(headers + 0)->l);
      }
#line 85
      if (0 == tmp___0) {
#line 85
        if (p->headers[1].l == (int )(headers + 1)->l) {
          {
#line 85
          tmp___1 = memcmp((void const   *)p->headers[1].p, (void const   *)(headers + 1)->p,
                           (size_t )(headers + 1)->l);
          }
#line 85
          if (0 == tmp___1) {
            {
#line 91
            syslog(7, "device updated : %.*s", (headers + 1)->l, (headers + 1)->p);
#line 92
            p->t = t;
            }
#line 94
            if ((headers + 2)->l > (int const   )p->headers[2].l) {
              {
#line 96
              tmp = realloc((void *)p, ((sizeof(struct device ) + (unsigned long )(headers + 0)->l) + (unsigned long )(headers + 1)->l) + (unsigned long )(headers + 2)->l);
#line 96
              p = (struct device *)tmp;
              }
#line 98
              if (! p) {
#line 99
                return (0);
              }
#line 100
              *pp = p;
            }
            {
#line 102
            memcpy((void */* __restrict  */)((p->data + p->headers[0].l) + p->headers[1].l),
                   (void const   */* __restrict  */)(headers + 2)->p, (size_t )(headers + 2)->l);
            }
#line 104
            return (0);
          }
        }
      }
    }
#line 106
    pp = & p->next;
#line 107
    p = *pp;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  syslog(6, "new device discovered : %.*s", (headers + 1)->l, (headers + 1)->p);
#line 115
  tmp___2 = malloc(((sizeof(struct device ) + (unsigned long )(headers + 0)->l) + (unsigned long )(headers + 1)->l) + (unsigned long )(headers + 2)->l);
#line 115
  p = (struct device *)tmp___2;
  }
#line 117
  if (! p) {
    {
#line 118
    syslog(3, "updateDevice(): cannot allocate memory");
    }
#line 119
    return (-1);
  }
#line 121
  p->next = devlist;
#line 122
  p->t = t;
#line 123
  pc = p->data;
#line 124
  i = 0;
  {
#line 124
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 124
    if (! (i < 3)) {
#line 124
      goto while_break___0;
    }
    {
#line 126
    p->headers[i].p = (char const   *)pc;
#line 127
    p->headers[i].l = (int )(headers + i)->l;
#line 128
    memcpy((void */* __restrict  */)pc, (void const   */* __restrict  */)(headers + i)->p,
           (size_t )(headers + i)->l);
#line 129
    pc += (headers + i)->l;
#line 124
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 131
  devlist = p;
#line 133
  return (1);
}
}
#line 141 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
static int removeDevice(struct header  const  *headers ) 
{ 
  struct device **pp ;
  struct device *p ;
  int tmp ;
  int tmp___0 ;

  {
#line 144
  pp = & devlist;
#line 145
  p = *pp;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! p) {
#line 146
      goto while_break;
    }
#line 148
    if (p->headers[0].l == (int )(headers + 0)->l) {
      {
#line 148
      tmp = memcmp((void const   *)p->headers[0].p, (void const   *)(headers + 0)->p,
                   (size_t )(headers + 0)->l);
      }
#line 148
      if (0 == tmp) {
#line 148
        if (p->headers[1].l == (int )(headers + 1)->l) {
          {
#line 148
          tmp___0 = memcmp((void const   *)p->headers[1].p, (void const   *)(headers + 1)->p,
                           (size_t )(headers + 1)->l);
          }
#line 148
          if (0 == tmp___0) {
            {
#line 153
            syslog(6, "remove device : %.*s", (headers + 1)->l, (headers + 1)->p);
#line 154
            *pp = p->next;
#line 155
            free((void *)p);
            }
#line 156
            return (-1);
          }
        }
      }
    }
#line 158
    pp = & p->next;
#line 159
    p = *pp;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 161
  syslog(4, "device not found for removing : %.*s", (headers + 1)->l, (headers + 1)->p);
  }
#line 162
  return (0);
}
}
#line 167 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
static void SendSSDPMSEARCHResponse(int s , struct sockaddr  const  *sockname , char const   *st ,
                                    char const   *usn , char const   *server , char const   *location ) 
{ 
  int l ;
  int n ;
  char buf[512] ;
  socklen_t sockname_len ;
  ssize_t tmp ;

  {
  {
#line 183
  l = snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"HTTP/1.1 200 OK\r\nCACHE-CONTROL: max-age=120\r\nST: %s\r\nUSN: %s\r\nEXT:\r\nSERVER: %s\r\nLOCATION: %s\r\nOPT: \"http://schemas.upnp.org/upnp/1/0/\";\r\n01-NLS: %u\r\nBOOTID.UPNP.ORG: %u\r\nCONFIGID.UPNP.ORG: %u\r\n\r\n",
               st, usn, server, location, upnp_bootid, upnp_bootid, upnp_configid);
  }
#line 200
  if ((int const   )sockname->sa_family == 10) {
#line 200
    sockname_len = (socklen_t )sizeof(struct sockaddr_in6 );
  } else {
#line 200
    sockname_len = (socklen_t )sizeof(struct sockaddr_in );
  }
  {
#line 206
  tmp = sendto(s, (void const   *)(buf), (size_t )l, 0, (struct sockaddr  const  */* __restrict  */)sockname,
               sockname_len);
#line 206
  n = (int )tmp;
  }
#line 208
  if (n < 0) {
    {
#line 209
    syslog(3, "sendto(udp): %m");
    }
  }
#line 211
  return;
}
}
#line 221 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
struct servicehead servicelisthead  ;
#line 224 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
static void processMSEARCH(int s , char const   *st , int st_len , struct sockaddr  const  *addr ) 
{ 
  struct service *serv ;
  char buf[64] ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 233
  if (! st) {
#line 234
    return;
  } else
#line 233
  if (st_len == 0) {
#line 234
    return;
  }
  {
#line 236
  sockaddr_to_string(addr, buf, sizeof(buf));
#line 237
  syslog(6, "SSDP M-SEARCH from %s ST:%.*s", buf, st_len, st);
  }
#line 245
  if (st_len == 8) {
    {
#line 245
    tmp___3 = memcmp((void const   *)st, (void const   *)"ssdp:all", (size_t )8);
    }
#line 245
    if (0 == tmp___3) {
#line 247
      serv = servicelisthead.lh_first;
      {
#line 247
      while (1) {
        while_continue: /* CIL Label */ ;
#line 247
        if (! serv) {
#line 247
          goto while_break;
        }
        {
#line 250
        SendSSDPMSEARCHResponse(s, addr, (char const   *)serv->st, (char const   *)serv->usn,
                                (char const   *)serv->server, (char const   *)serv->location);
#line 247
        serv = serv->entries.le_next;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 245
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 254
  if (st_len > 5) {
    {
#line 254
    tmp___2 = memcmp((void const   *)st, (void const   *)"uuid:", (size_t )5);
    }
#line 254
    if (0 == tmp___2) {
#line 256
      serv = servicelisthead.lh_first;
      {
#line 256
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 256
        if (! serv) {
#line 256
          goto while_break___0;
        }
        {
#line 259
        tmp = strncmp((char const   *)serv->usn, st, (size_t )st_len);
        }
#line 259
        if (0 == tmp) {
          {
#line 260
          SendSSDPMSEARCHResponse(s, addr, (char const   *)serv->st, (char const   *)serv->usn,
                                  (char const   *)serv->server, (char const   *)serv->location);
          }
        }
#line 256
        serv = serv->entries.le_next;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 254
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 267
    if ((int const   )*(st + (st_len - 2)) == 58) {
      {
#line 267
      tmp___0 = __ctype_b_loc();
      }
#line 267
      if ((int const   )*(*tmp___0 + (int )*(st + (st_len - 1))) & 2048) {
#line 268
        st_len -= 2;
      }
    }
#line 269
    serv = servicelisthead.lh_first;
    {
#line 269
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 269
      if (! serv) {
#line 269
        goto while_break___1;
      }
      {
#line 272
      tmp___1 = strncmp((char const   *)serv->st, st, (size_t )st_len);
      }
#line 272
      if (0 == tmp___1) {
        {
#line 273
        SendSSDPMSEARCHResponse(s, addr, (char const   *)serv->st, (char const   *)serv->usn,
                                (char const   *)serv->server, (char const   *)serv->location);
        }
      }
#line 269
      serv = serv->entries.le_next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 279
  return;
}
}
#line 285 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
static int containsForbiddenChars(unsigned char const   *p , int len ) 
{ 


  {
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! (len > 0)) {
#line 288
      goto while_break;
    }
#line 289
    if ((int const   )*p < 32) {
#line 290
      return (1);
    } else
#line 289
    if ((int const   )*p >= 127) {
#line 290
      return (1);
    }
#line 291
    p ++;
#line 292
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  return (0);
}
}
#line 307 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
static int ParseSSDPPacket(int s , char const   *p , ssize_t n , struct sockaddr  const  *addr ) 
{ 
  char const   *linestart ;
  char const   *lineend ;
  char const   *nameend ;
  char const   *valuestart ;
  struct header headers[3] ;
  int i ;
  int r ;
  int methodlen ;
  int nts ;
  int method ;
  unsigned int lifetime ;
  char const   *st ;
  int st_len ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int l ;
  int m ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *name ;
  char const   *val ;
  int rem ;
  unsigned short const   **tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  time_t tmp___17 ;

  {
  {
#line 316
  r = 0;
#line 318
  nts = -1;
#line 319
  method = -1;
#line 320
  lifetime = 180U;
#line 321
  st = (char const   *)((void *)0);
#line 322
  st_len = 0;
#line 323
  memset((void *)(headers), 0, sizeof(headers));
#line 324
  methodlen = 0;
  }
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if ((ssize_t )methodlen < n) {
      {
#line 324
      tmp = __ctype_b_loc();
      }
#line 324
      if (! ((int const   )*(*tmp + (int )*(p + methodlen)) & 1024)) {
#line 324
        if (! ((int const   )*(p + methodlen) == 45)) {
#line 324
          goto while_break;
        }
      }
    } else {
#line 324
      goto while_break;
    }
#line 324
    methodlen ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  if (methodlen == 8) {
    {
#line 327
    tmp___1 = memcmp((void const   *)p, (void const   *)"M-SEARCH", (size_t )8);
    }
#line 327
    if (0 == tmp___1) {
#line 328
      method = 1;
    } else {
#line 327
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 329
  if (methodlen == 6) {
    {
#line 329
    tmp___0 = memcmp((void const   *)p, (void const   *)"NOTIFY", (size_t )6);
    }
#line 329
    if (0 == tmp___0) {
#line 330
      method = 2;
    }
  }
#line 331
  linestart = p;
  {
#line 332
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 332
    if (! ((unsigned long )linestart < (unsigned long )((p + n) - 2))) {
#line 332
      goto while_break___0;
    }
#line 334
    lineend = linestart;
    {
#line 335
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 335
      if ((unsigned long )lineend < (unsigned long )(p + n)) {
#line 335
        if ((int const   )*lineend != 10) {
#line 335
          if (! ((int const   )*lineend != 13)) {
#line 335
            goto while_break___1;
          }
        } else {
#line 335
          goto while_break___1;
        }
      } else {
#line 335
        goto while_break___1;
      }
#line 336
      lineend ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 339
    nameend = linestart;
    {
#line 340
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 340
      if ((unsigned long )nameend < (unsigned long )lineend) {
#line 340
        if (! ((int const   )*nameend != 58)) {
#line 340
          goto while_break___2;
        }
      } else {
#line 340
        goto while_break___2;
      }
#line 341
      nameend ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 343
    if ((unsigned long )nameend < (unsigned long )lineend) {
#line 344
      valuestart = nameend + 1;
    } else {
#line 346
      valuestart = nameend;
    }
    {
#line 348
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 348
      if ((unsigned long )valuestart < (unsigned long )lineend) {
        {
#line 348
        tmp___2 = __ctype_b_loc();
        }
#line 348
        if (! ((int const   )*(*tmp___2 + (int )*valuestart) & 8192)) {
#line 348
          goto while_break___3;
        }
      } else {
#line 348
        goto while_break___3;
      }
#line 349
      valuestart ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 351
    if ((unsigned long )valuestart < (unsigned long )lineend) {
#line 351
      if ((int const   )*valuestart == 34) {
#line 352
        valuestart ++;
      }
    }
#line 353
    if ((unsigned long )nameend > (unsigned long )linestart) {
#line 353
      if ((unsigned long )valuestart < (unsigned long )lineend) {
#line 354
        l = (int )(nameend - linestart);
#line 355
        m = (int )(lineend - valuestart);
        {
#line 357
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 357
          if (m > 0) {
            {
#line 357
            tmp___3 = __ctype_b_loc();
            }
#line 357
            if (! ((int const   )*(*tmp___3 + (int )*(valuestart + (m - 1))) & 8192)) {
#line 357
              goto while_break___4;
            }
          } else {
#line 357
            goto while_break___4;
          }
#line 358
          m --;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 360
        if (m > 0) {
#line 360
          if ((int const   )*(valuestart + (m - 1)) == 34) {
#line 361
            m --;
          }
        }
#line 362
        i = -1;
#line 365
        if (l == 2) {
          {
#line 365
          tmp___16 = strncasecmp(linestart, "nt", (size_t )2);
          }
#line 365
          if (0 == tmp___16) {
#line 366
            i = 0;
          } else {
#line 365
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 367
        if (l == 3) {
          {
#line 367
          tmp___15 = strncasecmp(linestart, "usn", (size_t )3);
          }
#line 367
          if (0 == tmp___15) {
#line 368
            i = 1;
          } else {
#line 367
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 369
        if (l == 3) {
          {
#line 369
          tmp___14 = strncasecmp(linestart, "nts", (size_t )3);
          }
#line 369
          if (0 == tmp___14) {
#line 370
            if (m == 10) {
              {
#line 370
              tmp___5 = strncasecmp(valuestart, "ssdp:alive", (size_t )10);
              }
#line 370
              if (0 == tmp___5) {
#line 371
                nts = 1;
              } else {
#line 370
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 372
            if (m == 11) {
              {
#line 372
              tmp___4 = strncasecmp(valuestart, "ssdp:byebye", (size_t )11);
              }
#line 372
              if (0 == tmp___4) {
#line 373
                nts = 2;
              }
            }
          } else {
#line 369
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 375
        if (l == 8) {
          {
#line 375
          tmp___13 = strncasecmp(linestart, "location", (size_t )8);
          }
#line 375
          if (0 == tmp___13) {
#line 376
            i = 2;
          } else {
#line 375
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 377
        if (l == 13) {
          {
#line 377
          tmp___12 = strncasecmp(linestart, "cache-control", (size_t )13);
          }
#line 377
          if (0 == tmp___12) {
#line 379
            name = valuestart;
#line 381
            rem = m;
            {
#line 382
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 382
              if (! (rem > 0)) {
#line 382
                goto while_break___5;
              }
#line 383
              val = name;
              {
#line 384
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 384
                if ((unsigned long )val < (unsigned long )(name + rem)) {
#line 384
                  if ((int const   )*val != 61) {
#line 384
                    if (! ((int const   )*val != 44)) {
#line 384
                      goto while_break___6;
                    }
                  } else {
#line 384
                    goto while_break___6;
                  }
                } else {
#line 384
                  goto while_break___6;
                }
#line 385
                val ++;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 386
              if ((unsigned long )val >= (unsigned long )(name + rem)) {
#line 387
                goto while_break___5;
              }
#line 388
              if ((int const   )*val == 61) {
                {
#line 389
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 389
                  if ((unsigned long )val < (unsigned long )(name + rem)) {
#line 389
                    if (! ((int const   )*val == 61)) {
                      {
#line 389
                      tmp___6 = __ctype_b_loc();
                      }
#line 389
                      if (! ((int const   )*(*tmp___6 + (int )*val) & 8192)) {
#line 389
                        goto while_break___7;
                      }
                    }
                  } else {
#line 389
                    goto while_break___7;
                  }
#line 390
                  val ++;
                }
                while_break___7: /* CIL Label */ ;
                }
#line 391
                if ((unsigned long )val >= (unsigned long )(name + rem)) {
#line 392
                  goto while_break___5;
                }
                {
#line 393
                tmp___8 = strncasecmp(name, "max-age", (size_t )7);
                }
#line 393
                if (0 == tmp___8) {
                  {
#line 394
                  tmp___7 = strtoul((char const   */* __restrict  */)val, (char **/* __restrict  */)0,
                                    0);
#line 394
                  lifetime = (unsigned int )tmp___7;
                  }
                }
                {
#line 396
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 396
                  if (rem > 0) {
#line 396
                    if (! ((int const   )*name != 44)) {
#line 396
                      goto while_break___8;
                    }
                  } else {
#line 396
                    goto while_break___8;
                  }
#line 397
                  rem --;
#line 398
                  name ++;
                }
                while_break___8: /* CIL Label */ ;
                }
                {
#line 401
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 401
                  if (rem > 0) {
#line 401
                    if (! ((int const   )*name == 44)) {
                      {
#line 401
                      tmp___9 = __ctype_b_loc();
                      }
#line 401
                      if (! ((int const   )*(*tmp___9 + (int )*name) & 8192)) {
#line 401
                        goto while_break___9;
                      }
                    }
                  } else {
#line 401
                    goto while_break___9;
                  }
#line 402
                  rem --;
#line 403
                  name ++;
                }
                while_break___9: /* CIL Label */ ;
                }
              } else {
#line 406
                rem = (int )((long )rem - (val - name));
#line 407
                name = val;
                {
#line 408
                while (1) {
                  while_continue___10: /* CIL Label */ ;
#line 408
                  if (rem > 0) {
#line 408
                    if (! ((int const   )*name == 44)) {
                      {
#line 408
                      tmp___10 = __ctype_b_loc();
                      }
#line 408
                      if (! ((int const   )*(*tmp___10 + (int )*name) & 8192)) {
#line 408
                        goto while_break___10;
                      }
                    }
                  } else {
#line 408
                    goto while_break___10;
                  }
#line 409
                  rem --;
#line 410
                  name ++;
                }
                while_break___10: /* CIL Label */ ;
                }
              }
            }
            while_break___5: /* CIL Label */ ;
            }
          } else {
#line 377
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 415
        if (l == 2) {
          {
#line 415
          tmp___11 = strncasecmp(linestart, "st", (size_t )2);
          }
#line 415
          if (0 == tmp___11) {
#line 416
            st = valuestart;
#line 417
            st_len = m;
          }
        }
#line 419
        if (i >= 0) {
#line 420
          headers[i].p = valuestart;
#line 421
          headers[i].l = m;
        }
      }
    }
#line 424
    linestart = lineend;
    {
#line 425
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 425
      if ((int const   )*linestart == 10) {
#line 425
        goto _L___6;
      } else
#line 425
      if ((int const   )*linestart == 13) {
        _L___6: /* CIL Label */ 
#line 425
        if (! ((unsigned long )linestart < (unsigned long )(p + n))) {
#line 425
          goto while_break___11;
        }
      } else {
#line 425
        goto while_break___11;
      }
#line 426
      linestart ++;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 435
  syslog(7, "SSDP request: \'%.*s\' (%d) st=%.*s", methodlen, p, method, st_len, st);
  }
  {
#line 438
  if (method == 2) {
#line 438
    goto case_2;
  }
#line 448
  if (method == 1) {
#line 448
    goto case_1;
  }
#line 451
  goto switch_default;
  case_2: /* CIL Label */ 
#line 439
  if (headers[0].p) {
#line 439
    if (headers[1].p) {
#line 439
      if (headers[2].p) {
#line 440
        if (nts == 1) {
          {
#line 441
          tmp___17 = time((time_t *)((void *)0));
#line 441
          r = updateDevice((struct header  const  *)(headers), tmp___17 + (time_t )lifetime);
          }
        } else
#line 443
        if (nts == 2) {
          {
#line 444
          r = removeDevice((struct header  const  *)(headers));
          }
        }
      }
    }
  }
#line 447
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 449
  processMSEARCH(s, st, st_len, addr);
  }
#line 450
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 452
  syslog(4, "method %.*s, don\'t know what to do", methodlen, p);
  }
  switch_break: /* CIL Label */ ;
  }
#line 454
  return (r);
}
}
#line 460 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
static int OpenUnixSocket(char const   *path ) 
{ 
  struct sockaddr_un addr ;
  int s ;
  int rv ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 466
  s = socket(1, 1, 0);
  }
#line 467
  if (s < 0) {
    {
#line 469
    syslog(3, "socket(AF_UNIX): %m");
    }
#line 470
    return (-1);
  }
  {
#line 473
  rv = unlink(path);
  }
#line 474
  if (rv < 0) {
    {
#line 474
    tmp = __errno_location();
    }
#line 474
    if (*tmp != 2) {
      {
#line 476
      syslog(3, "unlink(unixsocket, \"%s\"): %m", path);
#line 477
      close(s);
      }
#line 478
      return (-1);
    }
  }
  {
#line 480
  addr.sun_family = (sa_family_t )1;
#line 481
  strncpy((char */* __restrict  */)(addr.sun_path), (char const   */* __restrict  */)path,
          sizeof(addr.sun_path));
#line 482
  tmp___1 = bind(s, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
                 (socklen_t )sizeof(struct sockaddr_un ));
  }
#line 482
  if (tmp___1 < 0) {
    {
#line 485
    syslog(3, "bind(unixsocket, \"%s\"): %m", path);
#line 486
    close(s);
    }
#line 487
    return (-1);
  } else {
    {
#line 489
    tmp___0 = listen(s, 5);
    }
#line 489
    if (tmp___0 < 0) {
      {
#line 491
      syslog(3, "listen(unixsocket): %m");
#line 492
      close(s);
      }
#line 493
      return (-1);
    }
  }
  {
#line 496
  tmp___2 = chmod(path, (__mode_t )438);
  }
#line 496
  if (tmp___2 < 0) {
    {
#line 498
    syslog(4, "chmod(\"%s\"): %m", path);
    }
  }
#line 500
  return (s);
}
}
#line 505 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
void processRequest(struct reqelem *req ) 
{ 
  ssize_t n ;
  unsigned int l ;
  unsigned int m ;
  unsigned char buf[2048] ;
  unsigned char const   *p ;
  int type ;
  struct device *d ;
  unsigned char rbuf[4096] ;
  unsigned char *rp ;
  unsigned char nrep ;
  time_t t ;
  struct service *newserv ;
  struct service *serv ;
  unsigned char const   *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  size_t tmp___26 ;
  unsigned char *tmp___27 ;
  unsigned char *tmp___28 ;
  unsigned char *tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char *tmp___31 ;
  size_t tmp___32 ;
  unsigned char *tmp___33 ;
  unsigned char *tmp___34 ;
  unsigned char *tmp___35 ;
  unsigned char *tmp___36 ;
  unsigned char *tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  ssize_t tmp___40 ;
  void *tmp___41 ;
  int tmp___42 ;
  void *tmp___43 ;
  unsigned char const   *tmp___44 ;
  int tmp___45 ;
  void *tmp___46 ;
  unsigned char const   *tmp___47 ;
  int tmp___48 ;
  void *tmp___49 ;
  unsigned char const   *tmp___50 ;
  int tmp___51 ;
  void *tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  struct service *tmp___55 ;
  ssize_t tmp___56 ;

  {
  {
#line 512
  d = devlist;
#line 514
  rp = rbuf + 1;
#line 515
  nrep = (unsigned char)0;
#line 517
  newserv = (struct service *)((void *)0);
#line 520
  n = read(req->socket, (void *)(buf), sizeof(buf));
  }
#line 521
  if (n < 0L) {
    {
#line 522
    syslog(3, "(s=%d) processRequest(): read(): %m", req->socket);
    }
#line 523
    goto error;
  }
#line 525
  if (n == 0L) {
    {
#line 526
    syslog(6, "(s=%d) request connection closed", req->socket);
    }
#line 527
    goto error;
  }
  {
#line 529
  t = time((time_t *)((void *)0));
#line 530
  type = (int )buf[0];
#line 531
  p = (unsigned char const   *)(buf + 1);
#line 532
  l = 0U;
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if ((unsigned long )p >= (unsigned long )(buf + n)) {
#line 532
      goto while_break;
    }
#line 532
    l = (l << 7) | (unsigned int )((int const   )*p & 127);
#line 532
    tmp = p;
#line 532
    p ++;
#line 532
    if ((int const   )*tmp & 128) {
#line 532
      if (! (l < (unsigned int )(1 << 25))) {
#line 532
        goto while_break;
      }
    } else {
#line 532
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  if ((unsigned long )(p + l) > (unsigned long )(buf + n)) {
    {
#line 534
    syslog(4, "bad request (length encoding)");
    }
#line 535
    goto error;
  }
#line 537
  if (l == 0U) {
    {
#line 538
    syslog(4, "bad request (length=0)");
    }
#line 539
    goto error;
  }
  {
#line 541
  syslog(6, "(s=%d) request type=%d str=\'%.*s\'", req->socket, type, l, p);
  }
  {
#line 546
  if (type == 3) {
#line 546
    goto case_3;
  }
#line 546
  if (type == 2) {
#line 546
    goto case_3;
  }
#line 546
  if (type == 1) {
#line 546
    goto case_3;
  }
#line 615
  if (type == 4) {
#line 615
    goto case_4;
  }
#line 716
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 547
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 547
    if (d) {
#line 547
      if (! ((int )nrep < 255)) {
#line 547
        goto while_break___0;
      }
    } else {
#line 547
      goto while_break___0;
    }
#line 548
    if (d->t < t) {
      {
#line 549
      syslog(6, "outdated device");
      }
    } else {
#line 552
      if ((unsigned long )((long )(((d->headers[2].l + d->headers[0].l) + d->headers[1].l) + 6) + (rp - rbuf)) >= sizeof(rbuf)) {
#line 554
        goto while_break___0;
      }
#line 555
      if (type == 1) {
        {
#line 555
        tmp___15 = memcmp((void const   *)d->headers[0].p, (void const   *)p, (size_t )l);
        }
#line 555
        if (0 == tmp___15) {
#line 555
          goto _L;
        } else {
#line 555
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 555
      if (type == 2) {
        {
#line 555
        tmp___16 = memcmp((void const   *)d->headers[1].p, (void const   *)p, (size_t )l);
        }
#line 555
        if (0 == tmp___16) {
#line 555
          goto _L;
        } else {
#line 555
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 555
      if (type == 3) {
        _L: /* CIL Label */ 
#line 562
        m = (unsigned int )d->headers[2].l;
#line 563
        if (m >= 268435456U) {
#line 563
          tmp___0 = rp;
#line 563
          rp ++;
#line 563
          *tmp___0 = (unsigned char )((m >> 28) | 128U);
        }
#line 563
        if (m >= 2097152U) {
#line 563
          tmp___1 = rp;
#line 563
          rp ++;
#line 563
          *tmp___1 = (unsigned char )((m >> 21) | 128U);
        }
#line 563
        if (m >= 16384U) {
#line 563
          tmp___2 = rp;
#line 563
          rp ++;
#line 563
          *tmp___2 = (unsigned char )((m >> 14) | 128U);
        }
#line 563
        if (m >= 128U) {
#line 563
          tmp___3 = rp;
#line 563
          rp ++;
#line 563
          *tmp___3 = (unsigned char )((m >> 7) | 128U);
        }
        {
#line 563
        tmp___4 = rp;
#line 563
        rp ++;
#line 563
        *tmp___4 = (unsigned char )(m & 127U);
#line 564
        memcpy((void */* __restrict  */)rp, (void const   */* __restrict  */)d->headers[2].p,
               (size_t )d->headers[2].l);
#line 565
        rp += d->headers[2].l;
#line 566
        m = (unsigned int )d->headers[0].l;
        }
#line 567
        if (m >= 268435456U) {
#line 567
          tmp___5 = rp;
#line 567
          rp ++;
#line 567
          *tmp___5 = (unsigned char )((m >> 28) | 128U);
        }
#line 567
        if (m >= 2097152U) {
#line 567
          tmp___6 = rp;
#line 567
          rp ++;
#line 567
          *tmp___6 = (unsigned char )((m >> 21) | 128U);
        }
#line 567
        if (m >= 16384U) {
#line 567
          tmp___7 = rp;
#line 567
          rp ++;
#line 567
          *tmp___7 = (unsigned char )((m >> 14) | 128U);
        }
#line 567
        if (m >= 128U) {
#line 567
          tmp___8 = rp;
#line 567
          rp ++;
#line 567
          *tmp___8 = (unsigned char )((m >> 7) | 128U);
        }
        {
#line 567
        tmp___9 = rp;
#line 567
        rp ++;
#line 567
        *tmp___9 = (unsigned char )(m & 127U);
#line 568
        memcpy((void */* __restrict  */)rp, (void const   */* __restrict  */)d->headers[0].p,
               (size_t )d->headers[0].l);
#line 569
        rp += d->headers[0].l;
#line 570
        m = (unsigned int )d->headers[1].l;
        }
#line 571
        if (m >= 268435456U) {
#line 571
          tmp___10 = rp;
#line 571
          rp ++;
#line 571
          *tmp___10 = (unsigned char )((m >> 28) | 128U);
        }
#line 571
        if (m >= 2097152U) {
#line 571
          tmp___11 = rp;
#line 571
          rp ++;
#line 571
          *tmp___11 = (unsigned char )((m >> 21) | 128U);
        }
#line 571
        if (m >= 16384U) {
#line 571
          tmp___12 = rp;
#line 571
          rp ++;
#line 571
          *tmp___12 = (unsigned char )((m >> 14) | 128U);
        }
#line 571
        if (m >= 128U) {
#line 571
          tmp___13 = rp;
#line 571
          rp ++;
#line 571
          *tmp___13 = (unsigned char )((m >> 7) | 128U);
        }
        {
#line 571
        tmp___14 = rp;
#line 571
        rp ++;
#line 571
        *tmp___14 = (unsigned char )(m & 127U);
#line 572
        memcpy((void */* __restrict  */)rp, (void const   */* __restrict  */)d->headers[1].p,
               (size_t )d->headers[1].l);
#line 573
        rp += d->headers[1].l;
#line 574
        nrep = (unsigned char )((int )nrep + 1);
        }
      }
    }
#line 577
    d = d->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 580
  serv = servicelisthead.lh_first;
  {
#line 580
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 580
    if (serv) {
#line 580
      if (! ((int )nrep < 255)) {
#line 580
        goto while_break___1;
      }
    } else {
#line 580
      goto while_break___1;
    }
    {
#line 584
    tmp___17 = strlen((char const   *)serv->location);
#line 584
    tmp___18 = strlen((char const   *)serv->st);
#line 584
    tmp___19 = strlen((char const   *)serv->usn);
    }
#line 584
    if ((((tmp___17 + tmp___18) + tmp___19) + 6UL) + (size_t )(rp - rbuf) >= sizeof(rbuf)) {
#line 586
      goto while_break___1;
    }
#line 587
    if (type == 1) {
      {
#line 587
      tmp___38 = strncmp((char const   *)serv->st, (char const   *)p, (size_t )l);
      }
#line 587
      if (0 == tmp___38) {
#line 587
        goto _L___2;
      } else {
#line 587
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 587
    if (type == 2) {
      {
#line 587
      tmp___39 = strncmp((char const   *)serv->usn, (char const   *)p, (size_t )l);
      }
#line 587
      if (0 == tmp___39) {
#line 587
        goto _L___2;
      } else {
#line 587
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 587
    if (type == 3) {
      _L___2: /* CIL Label */ 
      {
#line 594
      tmp___20 = strlen((char const   *)serv->location);
#line 594
      m = (unsigned int )tmp___20;
      }
#line 595
      if (m >= 268435456U) {
#line 595
        tmp___21 = rp;
#line 595
        rp ++;
#line 595
        *tmp___21 = (unsigned char )((m >> 28) | 128U);
      }
#line 595
      if (m >= 2097152U) {
#line 595
        tmp___22 = rp;
#line 595
        rp ++;
#line 595
        *tmp___22 = (unsigned char )((m >> 21) | 128U);
      }
#line 595
      if (m >= 16384U) {
#line 595
        tmp___23 = rp;
#line 595
        rp ++;
#line 595
        *tmp___23 = (unsigned char )((m >> 14) | 128U);
      }
#line 595
      if (m >= 128U) {
#line 595
        tmp___24 = rp;
#line 595
        rp ++;
#line 595
        *tmp___24 = (unsigned char )((m >> 7) | 128U);
      }
      {
#line 595
      tmp___25 = rp;
#line 595
      rp ++;
#line 595
      *tmp___25 = (unsigned char )(m & 127U);
#line 596
      memcpy((void */* __restrict  */)rp, (void const   */* __restrict  */)serv->location,
             (size_t )m);
#line 597
      rp += m;
#line 598
      tmp___26 = strlen((char const   *)serv->st);
#line 598
      m = (unsigned int )tmp___26;
      }
#line 599
      if (m >= 268435456U) {
#line 599
        tmp___27 = rp;
#line 599
        rp ++;
#line 599
        *tmp___27 = (unsigned char )((m >> 28) | 128U);
      }
#line 599
      if (m >= 2097152U) {
#line 599
        tmp___28 = rp;
#line 599
        rp ++;
#line 599
        *tmp___28 = (unsigned char )((m >> 21) | 128U);
      }
#line 599
      if (m >= 16384U) {
#line 599
        tmp___29 = rp;
#line 599
        rp ++;
#line 599
        *tmp___29 = (unsigned char )((m >> 14) | 128U);
      }
#line 599
      if (m >= 128U) {
#line 599
        tmp___30 = rp;
#line 599
        rp ++;
#line 599
        *tmp___30 = (unsigned char )((m >> 7) | 128U);
      }
      {
#line 599
      tmp___31 = rp;
#line 599
      rp ++;
#line 599
      *tmp___31 = (unsigned char )(m & 127U);
#line 600
      memcpy((void */* __restrict  */)rp, (void const   */* __restrict  */)serv->st,
             (size_t )m);
#line 601
      rp += m;
#line 602
      tmp___32 = strlen((char const   *)serv->usn);
#line 602
      m = (unsigned int )tmp___32;
      }
#line 603
      if (m >= 268435456U) {
#line 603
        tmp___33 = rp;
#line 603
        rp ++;
#line 603
        *tmp___33 = (unsigned char )((m >> 28) | 128U);
      }
#line 603
      if (m >= 2097152U) {
#line 603
        tmp___34 = rp;
#line 603
        rp ++;
#line 603
        *tmp___34 = (unsigned char )((m >> 21) | 128U);
      }
#line 603
      if (m >= 16384U) {
#line 603
        tmp___35 = rp;
#line 603
        rp ++;
#line 603
        *tmp___35 = (unsigned char )((m >> 14) | 128U);
      }
#line 603
      if (m >= 128U) {
#line 603
        tmp___36 = rp;
#line 603
        rp ++;
#line 603
        *tmp___36 = (unsigned char )((m >> 7) | 128U);
      }
      {
#line 603
      tmp___37 = rp;
#line 603
      rp ++;
#line 603
      *tmp___37 = (unsigned char )(m & 127U);
#line 604
      memcpy((void */* __restrict  */)rp, (void const   */* __restrict  */)serv->usn,
             (size_t )m);
#line 605
      rp += m;
#line 606
      nrep = (unsigned char )((int )nrep + 1);
      }
    }
#line 580
    serv = serv->entries.le_next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 609
  rbuf[0] = nrep;
#line 610
  tmp___40 = write(req->socket, (void const   *)(rbuf), (size_t )(rp - rbuf));
  }
#line 610
  if (tmp___40 < 0L) {
    {
#line 611
    syslog(3, "(s=%d) write: %m", req->socket);
    }
#line 612
    goto error;
  }
#line 614
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 616
  tmp___41 = malloc(sizeof(struct service ));
#line 616
  newserv = (struct service *)tmp___41;
  }
#line 617
  if (! newserv) {
    {
#line 618
    syslog(3, "cannot allocate memory");
    }
#line 619
    goto error;
  }
  {
#line 621
  tmp___42 = containsForbiddenChars(p, (int )l);
  }
#line 621
  if (tmp___42) {
    {
#line 622
    syslog(3, "bad request (st contains forbidden chars)");
    }
#line 623
    goto error;
  }
  {
#line 625
  tmp___43 = malloc((size_t )(l + 1U));
#line 625
  newserv->st = (char *)tmp___43;
  }
#line 626
  if (! newserv->st) {
    {
#line 627
    syslog(3, "cannot allocate memory");
    }
#line 628
    goto error;
  }
  {
#line 630
  memcpy((void */* __restrict  */)newserv->st, (void const   */* __restrict  */)p,
         (size_t )l);
#line 631
  *(newserv->st + l) = (char )'\000';
#line 632
  p += l;
  }
#line 633
  if ((unsigned long )p >= (unsigned long )(buf + n)) {
    {
#line 634
    syslog(4, "bad request (missing usn)");
    }
#line 635
    goto error;
  }
#line 637
  l = 0U;
  {
#line 637
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 637
    if ((unsigned long )p >= (unsigned long )(buf + n)) {
#line 637
      goto while_break___2;
    }
#line 637
    l = (l << 7) | (unsigned int )((int const   )*p & 127);
#line 637
    tmp___44 = p;
#line 637
    p ++;
#line 637
    if ((int const   )*tmp___44 & 128) {
#line 637
      if (! (l < (unsigned int )(1 << 25))) {
#line 637
        goto while_break___2;
      }
    } else {
#line 637
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 638
  if ((unsigned long )(p + l) > (unsigned long )(buf + n)) {
    {
#line 639
    syslog(4, "bad request (length encoding)");
    }
#line 640
    goto error;
  }
  {
#line 642
  tmp___45 = containsForbiddenChars(p, (int )l);
  }
#line 642
  if (tmp___45) {
    {
#line 643
    syslog(3, "bad request (usn contains forbidden chars)");
    }
#line 644
    goto error;
  }
  {
#line 646
  syslog(6, "usn=\'%.*s\'", l, p);
#line 647
  tmp___46 = malloc((size_t )(l + 1U));
#line 647
  newserv->usn = (char *)tmp___46;
  }
#line 648
  if (! newserv->usn) {
    {
#line 649
    syslog(3, "cannot allocate memory");
    }
#line 650
    goto error;
  }
  {
#line 652
  memcpy((void */* __restrict  */)newserv->usn, (void const   */* __restrict  */)p,
         (size_t )l);
#line 653
  *(newserv->usn + l) = (char )'\000';
#line 654
  p += l;
#line 655
  l = 0U;
  }
  {
#line 655
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 655
    if ((unsigned long )p >= (unsigned long )(buf + n)) {
#line 655
      goto while_break___3;
    }
#line 655
    l = (l << 7) | (unsigned int )((int const   )*p & 127);
#line 655
    tmp___47 = p;
#line 655
    p ++;
#line 655
    if ((int const   )*tmp___47 & 128) {
#line 655
      if (! (l < (unsigned int )(1 << 25))) {
#line 655
        goto while_break___3;
      }
    } else {
#line 655
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 656
  if ((unsigned long )(p + l) > (unsigned long )(buf + n)) {
    {
#line 657
    syslog(4, "bad request (length encoding)");
    }
#line 658
    goto error;
  }
  {
#line 660
  tmp___48 = containsForbiddenChars(p, (int )l);
  }
#line 660
  if (tmp___48) {
    {
#line 661
    syslog(3, "bad request (server contains forbidden chars)");
    }
#line 662
    goto error;
  }
  {
#line 664
  syslog(6, "server=\'%.*s\'", l, p);
#line 665
  tmp___49 = malloc((size_t )(l + 1U));
#line 665
  newserv->server = (char *)tmp___49;
  }
#line 666
  if (! newserv->server) {
    {
#line 667
    syslog(3, "cannot allocate memory");
    }
#line 668
    goto error;
  }
  {
#line 670
  memcpy((void */* __restrict  */)newserv->server, (void const   */* __restrict  */)p,
         (size_t )l);
#line 671
  *(newserv->server + l) = (char )'\000';
#line 672
  p += l;
#line 673
  l = 0U;
  }
  {
#line 673
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 673
    if ((unsigned long )p >= (unsigned long )(buf + n)) {
#line 673
      goto while_break___4;
    }
#line 673
    l = (l << 7) | (unsigned int )((int const   )*p & 127);
#line 673
    tmp___50 = p;
#line 673
    p ++;
#line 673
    if ((int const   )*tmp___50 & 128) {
#line 673
      if (! (l < (unsigned int )(1 << 25))) {
#line 673
        goto while_break___4;
      }
    } else {
#line 673
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 674
  if ((unsigned long )(p + l) > (unsigned long )(buf + n)) {
    {
#line 675
    syslog(4, "bad request (length encoding)");
    }
#line 676
    goto error;
  }
  {
#line 678
  tmp___51 = containsForbiddenChars(p, (int )l);
  }
#line 678
  if (tmp___51) {
    {
#line 679
    syslog(3, "bad request (location contains forbidden chars)");
    }
#line 680
    goto error;
  }
  {
#line 682
  syslog(6, "location=\'%.*s\'", l, p);
#line 683
  tmp___52 = malloc((size_t )(l + 1U));
#line 683
  newserv->location = (char *)tmp___52;
  }
#line 684
  if (! newserv->location) {
    {
#line 685
    syslog(3, "cannot allocate memory");
    }
#line 686
    goto error;
  }
  {
#line 688
  memcpy((void */* __restrict  */)newserv->location, (void const   */* __restrict  */)p,
         (size_t )l);
#line 689
  *(newserv->location + l) = (char )'\000';
#line 691
  serv = servicelisthead.lh_first;
  }
  {
#line 691
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 691
    if (! serv) {
#line 691
      goto while_break___5;
    }
    {
#line 694
    tmp___53 = strcmp((char const   *)newserv->usn, (char const   *)serv->usn);
    }
#line 694
    if (0 == tmp___53) {
      {
#line 694
      tmp___54 = strcmp((char const   *)newserv->st, (char const   *)serv->st);
      }
#line 694
      if (0 == tmp___54) {
        {
#line 696
        syslog(6, "Service allready in the list. Updating...");
#line 697
        free((void *)newserv->st);
#line 698
        free((void *)newserv->usn);
#line 699
        free((void *)serv->server);
#line 700
        serv->server = newserv->server;
#line 701
        free((void *)serv->location);
#line 702
        serv->location = newserv->location;
#line 703
        free((void *)newserv);
#line 704
        newserv = (struct service *)((void *)0);
        }
#line 705
        return;
      }
    }
#line 691
    serv = serv->entries.le_next;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 709
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 709
    tmp___55 = servicelisthead.lh_first;
#line 709
    newserv->entries.le_next = tmp___55;
#line 709
    if ((unsigned long )tmp___55 != (unsigned long )((void *)0)) {
#line 709
      (servicelisthead.lh_first)->entries.le_prev = & newserv->entries.le_next;
    }
#line 709
    servicelisthead.lh_first = newserv;
#line 709
    newserv->entries.le_prev = & servicelisthead.lh_first;
#line 709
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 710
  newserv = (struct service *)((void *)0);
#line 715
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 717
  syslog(4, "Unknown request type %d", type);
#line 718
  rbuf[0] = (unsigned char )'\000';
#line 719
  tmp___56 = write(req->socket, (void const   *)(rbuf), (size_t )1);
  }
#line 719
  if (tmp___56 < 0L) {
    {
#line 720
    syslog(3, "(s=%d) write: %m", req->socket);
    }
#line 721
    goto error;
  }
  switch_break: /* CIL Label */ ;
  }
#line 724
  return;
  error: 
#line 726
  if (newserv) {
    {
#line 727
    free((void *)newserv->st);
#line 728
    free((void *)newserv->usn);
#line 729
    free((void *)newserv->server);
#line 730
    free((void *)newserv->location);
#line 731
    free((void *)newserv);
#line 732
    newserv = (struct service *)((void *)0);
    }
  }
  {
#line 734
  close(req->socket);
#line 735
  req->socket = -1;
  }
#line 736
  return;
}
}
#line 739 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
static int volatile   quitting  =    (int volatile   )0;
#line 741 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/minissdpd.c"
static void sigterm(int sig ) 
{ 


  {
  {
#line 744
  signal(sig, (void (*)(int  ))1);
#line 745
  syslog(5, "received signal %d, good-bye", sig);
#line 746
  quitting = (int volatile   )1;
  }
#line 747
  return;
}
}
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 21 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/upnputils.c"
int sockaddr_to_string(struct sockaddr  const  *addr , char *str , size_t size ) 
{ 
  char buffer[64] ;
  unsigned short port ;
  int n ;

  {
#line 25
  port = (unsigned short)0;
#line 26
  n = -1;
  {
#line 30
  if ((int const   )addr->sa_family == 10) {
#line 30
    goto case_10;
  }
#line 37
  if ((int const   )addr->sa_family == 2) {
#line 37
    goto case_2;
  }
#line 54
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 31
  inet_ntop((int )addr->sa_family, (void const   */* __restrict  */)(& ((struct sockaddr_in6 *)addr)->sin6_addr),
            (char */* __restrict  */)(buffer), (socklen_t )sizeof(buffer));
#line 34
  port = ntohs(((struct sockaddr_in6 *)addr)->sin6_port);
#line 35
  n = snprintf((char */* __restrict  */)str, size, (char const   */* __restrict  */)"[%s]:%hu",
               buffer, (int )port);
  }
#line 36
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 38
  inet_ntop((int )addr->sa_family, (void const   */* __restrict  */)(& ((struct sockaddr_in *)addr)->sin_addr),
            (char */* __restrict  */)(buffer), (socklen_t )sizeof(buffer));
#line 41
  port = ntohs(((struct sockaddr_in *)addr)->sin_port);
#line 42
  n = snprintf((char */* __restrict  */)str, size, (char const   */* __restrict  */)"%s:%hu",
               buffer, (int )port);
  }
#line 43
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 55
  n = snprintf((char */* __restrict  */)str, size, (char const   */* __restrict  */)"unknown address family %d",
               (int const   )addr->sa_family);
  }
  switch_break: /* CIL Label */ ;
  }
#line 64
  return (n);
}
}
#line 202 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 193 "/usr/include/net/if.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) if_nametoindex)(char const   *__ifname ) ;
#line 30 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/openssdpsocket.h"
int AddDropMulticastMembership(int s , char const   *ifaddr , int ipv6 , int drop ) ;
#line 27 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/ifacewatch.c"
int OpenAndConfInterfaceWatchSocket(void) 
{ 
  int s ;
  struct sockaddr_nl addr ;
  int tmp ;

  {
  {
#line 34
  s = socket(16, 3, 0);
  }
#line 43
  if (s < 0) {
    {
#line 44
    syslog(3, "OpenAndConfInterfaceWatchSocket socket: %m");
    }
#line 45
    return (-1);
  }
  {
#line 48
  memset((void *)(& addr), 0, sizeof(addr));
#line 49
  addr.nl_family = (__kernel_sa_family_t )16;
#line 50
  addr.nl_groups = (__u32 )273;
#line 52
  tmp = bind(s, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
             (socklen_t )sizeof(addr));
  }
#line 52
  if (tmp < 0) {
    {
#line 53
    syslog(3, "bind(netlink): %m");
#line 54
    close(s);
    }
#line 55
    return (-1);
  }
#line 58
  return (s);
}
}
#line 64 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/ifacewatch.c"
int ProcessInterfaceWatch(int s , int s_ssdp , int s_ssdp6 , int n_if_addr , char const   **if_addr ) 
{ 
  ssize_t len ;
  int i ;
  char buffer[4096] ;
  struct iovec iov ;
  struct msghdr hdr ;
  struct nlmsghdr *nlhdr ;
  struct ifaddrmsg *ifa ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 77
  iov.iov_base = (void *)(buffer);
#line 78
  iov.iov_len = sizeof(buffer);
#line 80
  memset((void *)(& hdr), 0, sizeof(hdr));
#line 81
  hdr.msg_iov = & iov;
#line 82
  hdr.msg_iovlen = (size_t )1;
#line 84
  len = recvmsg(s, & hdr, 0);
  }
#line 85
  if (len < 0L) {
    {
#line 86
    syslog(3, "recvmsg(s, &hdr, 0): %m");
    }
#line 87
    return (-1);
  }
#line 90
  nlhdr = (struct nlmsghdr *)(buffer);
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (len >= (ssize_t )((int )sizeof(struct nlmsghdr ))) {
#line 90
      if ((unsigned long )nlhdr->nlmsg_len >= sizeof(struct nlmsghdr )) {
#line 90
        if (! ((ssize_t )nlhdr->nlmsg_len <= len)) {
#line 90
          goto while_break;
        }
      } else {
#line 90
        goto while_break;
      }
    } else {
#line 90
      goto while_break;
    }
    {
#line 93
    syslog(7, "nlmsg_type=%d", (int )nlhdr->nlmsg_type);
    }
#line 94
    if ((int )nlhdr->nlmsg_type == 3) {
#line 95
      goto while_break;
    }
#line 96
    if ((int )nlhdr->nlmsg_type == 20) {
      {
#line 97
      ifa = (struct ifaddrmsg *)((void *)((char *)nlhdr + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 98
      syslog(7, "ProcessInterfaceWatchNotify RTM_NEWADDR index=%d", ifa->ifa_index);
#line 99
      i = 0;
      }
      {
#line 99
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 99
        if (! (i < n_if_addr)) {
#line 99
          goto while_break___0;
        }
        {
#line 100
        tmp = if_nametoindex(*(if_addr + i));
        }
#line 100
        if (ifa->ifa_index == tmp) {
          {
#line 101
          AddDropMulticastMembership(s_ssdp, *(if_addr + i), 0, 0);
          }
#line 102
          goto while_break___0;
        }
#line 99
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 105
    if ((int )nlhdr->nlmsg_type == 21) {
      {
#line 106
      ifa = (struct ifaddrmsg *)((void *)((char *)nlhdr + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 107
      syslog(7, "ProcessInterfaceWatchNotify RTM_DELADDR index=%d", ifa->ifa_index);
#line 108
      i = 0;
      }
      {
#line 108
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 108
        if (! (i < n_if_addr)) {
#line 108
          goto while_break___1;
        }
        {
#line 109
        tmp___0 = if_nametoindex(*(if_addr + i));
        }
#line 109
        if (ifa->ifa_index == tmp___0) {
          {
#line 110
          AddDropMulticastMembership(s_ssdp, *(if_addr + i), 0, 1);
          }
#line 111
          goto while_break___1;
        }
#line 108
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 90
    len -= (ssize_t )(((nlhdr->nlmsg_len + 4U) - 1U) & 4294967292U);
#line 90
    nlhdr = (struct nlmsghdr *)((char *)nlhdr + (((nlhdr->nlmsg_len + 4U) - 1U) & 4294967292U));
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return (0);
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 226 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 227 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_any ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 58
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 32 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/openssdpsocket.c"
static in_addr_t GetIfAddrIPv4(char const   *ifaddr ) 
{ 
  in_addr_t addr ;
  int s ;
  struct ifreq ifr ;
  int ifrlen ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 42
  addr = inet_addr(ifaddr);
  }
#line 43
  if (addr != 4294967295U) {
#line 45
    return (addr);
  }
  {
#line 49
  s = socket(2, 2, 0);
  }
#line 50
  if (s < 0) {
    {
#line 52
    syslog(3, "socket(PF_INET, SOCK_DGRAM): %m");
    }
#line 53
    return (4294967295U);
  }
  {
#line 55
  memset((void *)(& ifr), 0, sizeof(struct ifreq ));
#line 56
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifaddr,
          (size_t )16);
#line 57
  tmp = ioctl(s, 35093UL, & ifr, & ifrlen);
  }
#line 57
  if (tmp < 0) {
    {
#line 59
    syslog(3, "ioctl(s, SIOCGIFADDR, ...): %m");
#line 60
    close(s);
    }
#line 61
    return (4294967295U);
  }
  {
#line 63
  tmp___0 = inet_ntoa(((struct sockaddr_in *)(& ifr.ifr_ifru.ifru_addr))->sin_addr);
#line 63
  syslog(7, "GetIfAddrIPv4(%s) = %s", ifaddr, tmp___0);
#line 65
  addr = ((struct sockaddr_in *)(& ifr.ifr_ifru.ifru_addr))->sin_addr.s_addr;
#line 66
  close(s);
  }
#line 67
  return (addr);
}
}
#line 76 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/openssdpsocket.c"
int AddDropMulticastMembership(int s , char const   *ifaddr , int ipv6 , int drop ) 
{ 
  struct ip_mreq imr ;
  struct ipv6_mreq mr ;
  unsigned int ifindex ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 86
  if (ipv6) {
    {
#line 88
    ifindex = if_nametoindex(ifaddr);
#line 89
    memset((void *)(& mr), 0, sizeof(mr));
#line 90
    inet_pton(10, (char const   */* __restrict  */)"FF02::C", (void */* __restrict  */)(& mr.ipv6mr_multiaddr));
#line 91
    mr.ipv6mr_interface = ifindex;
    }
#line 92
    if (drop) {
#line 92
      tmp___0 = 21;
    } else {
#line 92
      tmp___0 = 20;
    }
    {
#line 92
    tmp___1 = setsockopt(s, 41, tmp___0, (void const   *)(& mr), (socklen_t )sizeof(struct ipv6_mreq ));
    }
#line 92
    if (tmp___1 < 0) {
#line 95
      if (drop) {
#line 95
        tmp = "IPV6_LEAVE_GROUP";
      } else {
#line 95
        tmp = "IPV6_JOIN_GROUP";
      }
      {
#line 95
      syslog(3, "setsockopt(udp, %s)(%s): %m", tmp, ifaddr);
      }
#line 98
      return (-1);
    }
    {
#line 100
    inet_pton(10, (char const   */* __restrict  */)"FF05::C", (void */* __restrict  */)(& mr.ipv6mr_multiaddr));
    }
#line 101
    if (drop) {
#line 101
      tmp___3 = 21;
    } else {
#line 101
      tmp___3 = 20;
    }
    {
#line 101
    tmp___4 = setsockopt(s, 41, tmp___3, (void const   *)(& mr), (socklen_t )sizeof(struct ipv6_mreq ));
    }
#line 101
    if (tmp___4 < 0) {
#line 104
      if (drop) {
#line 104
        tmp___2 = "IPV6_LEAVE_GROUP";
      } else {
#line 104
        tmp___2 = "IPV6_JOIN_GROUP";
      }
      {
#line 104
      syslog(3, "setsockopt(udp, %s)(%s): %m", tmp___2, ifaddr);
      }
#line 107
      return (-1);
    }
  } else {
    {
#line 114
    imr.imr_multiaddr.s_addr = inet_addr("239.255.255.250");
#line 117
    imr.imr_interface.s_addr = GetIfAddrIPv4(ifaddr);
    }
#line 118
    if (imr.imr_interface.s_addr == 4294967295U) {
      {
#line 120
      syslog(3, "no IPv4 address for interface %s", ifaddr);
      }
#line 122
      return (-1);
    }
#line 125
    if (drop) {
#line 125
      tmp___6 = 36;
    } else {
#line 125
      tmp___6 = 35;
    }
    {
#line 125
    tmp___7 = setsockopt(s, 0, tmp___6, (void const   *)((void *)(& imr)), (socklen_t )sizeof(struct ip_mreq ));
    }
#line 125
    if (tmp___7 < 0) {
#line 128
      if (drop) {
#line 128
        tmp___5 = "IP_DROP_MEMBERSHIP";
      } else {
#line 128
        tmp___5 = "IP_ADD_MEMBERSHIP";
      }
      {
#line 128
      syslog(3, "setsockopt(udp, %s)(%s): %m", tmp___5, ifaddr);
      }
#line 131
      return (-1);
    }
  }
#line 137
  return (0);
}
}
#line 140 "/home/wheatley/newnew/temp/minissdpd-1.1.20120121/openssdpsocket.c"
int OpenAndConfSSDPReceiveSocket(int n_listen_addr , char const   **listen_addr ,
                                 int ipv6 ) 
{ 
  int s ;
  int opt ;
  struct sockaddr_storage sockname ;
  socklen_t sockname_len ;
  int tmp ;
  int tmp___0 ;
  struct sockaddr_in6 *sa ;
  struct sockaddr_in *sa___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 146
  opt = 1;
#line 155
  if (ipv6) {
#line 155
    tmp = 10;
  } else {
#line 155
    tmp = 2;
  }
  {
#line 155
  s = socket(tmp, 2, 0);
  }
#line 155
  if (s < 0) {
    {
#line 160
    syslog(3, "socket(udp): %m");
    }
#line 161
    return (-1);
  }
  {
#line 165
  memset((void *)(& sockname), 0, sizeof(struct sockaddr_storage ));
  }
#line 166
  if (ipv6) {
    {
#line 169
    tmp___0 = setsockopt(s, 41, 26, (void const   *)((char *)(& opt)), (socklen_t )sizeof(opt));
    }
#line 169
    if (tmp___0 < 0) {
      {
#line 172
      syslog(4, "setsockopt(IPV6_V6ONLY): %m");
      }
    }
    {
#line 175
    sa = (struct sockaddr_in6 *)(& sockname);
#line 176
    sa->sin6_family = (sa_family_t )10;
#line 177
    sa->sin6_port = htons((uint16_t )1900);
#line 178
    sa->sin6_addr = (struct in6_addr )in6addr_any;
#line 179
    sockname_len = (socklen_t )sizeof(struct sockaddr_in6 );
    }
  } else {
    {
#line 183
    sa___0 = (struct sockaddr_in *)(& sockname);
#line 184
    sa___0->sin_family = (sa_family_t )2;
#line 185
    sa___0->sin_port = htons((uint16_t )1900);
#line 186
    sa___0->sin_addr.s_addr = htonl((in_addr_t )0);
#line 187
    sockname_len = (socklen_t )sizeof(struct sockaddr_in );
    }
  }
  {
#line 200
  tmp___1 = setsockopt(s, 1, 2, (void const   *)(& opt), (socklen_t )sizeof(opt));
  }
#line 200
  if (tmp___1 < 0) {
    {
#line 202
    syslog(4, "setsockopt(SO_REUSEADDR): %m");
    }
  }
  {
#line 205
  tmp___3 = bind(s, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sockname)),
                 sockname_len);
  }
#line 205
  if (tmp___3 < 0) {
#line 207
    if (ipv6) {
#line 207
      tmp___2 = "6";
    } else {
#line 207
      tmp___2 = "";
    }
    {
#line 207
    syslog(3, "bind(udp%s): %m", tmp___2);
#line 208
    close(s);
    }
#line 209
    return (-1);
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! (n_listen_addr > 0)) {
#line 212
      goto while_break;
    }
    {
#line 214
    n_listen_addr --;
#line 215
    tmp___5 = AddDropMulticastMembership(s, *(listen_addr + n_listen_addr), ipv6,
                                         0);
    }
#line 215
    if (tmp___5 < 0) {
#line 217
      if (ipv6) {
#line 217
        tmp___4 = 6;
      } else {
#line 217
        tmp___4 = 4;
      }
      {
#line 217
      syslog(4, "Failed to add IPv%d multicast membership for interface %s.", tmp___4,
             *(listen_addr + n_listen_addr));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return (s);
}
}
