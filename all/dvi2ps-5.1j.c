/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 170 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gdefs.h"
typedef int BOOLEAN;
#line 180
struct font_entry;
#line 186 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gdefs.h"
typedef int DEV_FONT;
#line 189
struct openfont_list;
#line 189 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gdefs.h"
struct font_entry {
   int k ;
   int c ;
   int s ;
   int d ;
   int a ;
   int l ;
   char n[257] ;
   void (*fnt_readfontinfo)() ;
   void (*rvf_setchar)() ;
   void (*rvf_setstring)() ;
   DEV_FONT (*dev_fontdict)() ;
   int (*dev_setchar)() ;
   int (*dev_setstring)() ;
   void *finfo ;
   struct font_entry *next ;
   char name[1024] ;
   FILE *openfile ;
   struct openfont_list *openlist ;
   int ncdl ;
   int nbpxl ;
   int ncts ;
};
#line 231 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gdefs.h"
struct confop {
   char *co_name ;
   void (*co_get)() ;
};
#line 4 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rastfont.h"
union __anonunion_where_29 {
   unsigned int fileoffset ;
   char *pixptr ;
};
#line 4 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rastfont.h"
struct rastchar_entry {
   unsigned short width ;
   unsigned short height ;
   short xoffset ;
   short yoffset ;
   short dev_font ;
   short dev_char ;
   unsigned short nbpl ;
   union __anonunion_where_29 where ;
   int tfmw ;
};
#line 16 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rastfont.h"
struct rastfntinfo {
   float corrfact ;
   int nfntchars ;
   int dictform ;
   struct rastchar_entry ch[1] ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.h"
struct pdlist {
   int pl_corr ;
   short pl_font ;
   short pl_char ;
   struct pdlist *pl_next ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
struct packdict {
   char *pd_name ;
   int pd_len ;
   int pd_pack ;
   struct packdict *pd_next ;
};
#line 161 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gdefs.h"
typedef unsigned char byte;
#line 180 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gdefs.h"
struct font_index {
   int k ;
   struct font_entry *fent ;
   struct font_index *next ;
};
#line 1 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dconv.h"
struct dconv {
   int (*dc_getcommand)() ;
   void (*dc_backupone)() ;
   void (*dc_getbytes)() ;
   void (*dc_skipbytes)() ;
   int (*dc_getuint)() ;
   int (*dc_getint)() ;
   FILE *dc_file ;
   byte *dc_bufbeg ;
   byte *dc_bufend ;
   void (*dc_movedown)() ;
   void (*dc_movedown_v)() ;
   void (*dc_moveover)() ;
   void (*dc_moveover_v)() ;
   void (*dc_setrule)() ;
   void (*dc_setrule_v)() ;
   int dc_scale ;
};
#line 223 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gdefs.h"
struct fontop {
   char *fo_type ;
   int (*fo_init)() ;
   int (*fo_access)() ;
   void (*fo_initfontinfo)() ;
};
#line 242 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gdefs.h"
struct accarg {
   int acc_mode ;
   float rawmagfact ;
   float actmagfact ;
   int submag ;
   int reqmag ;
   float stepmagfact ;
   char *pv_name ;
   int pv_mag ;
   char *pv_fam ;
   int pv_ds ;
   char *pv_jsub ;
};
#line 163 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gdefs.h"
typedef float SCALED;
#line 4 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
struct tfmchar_entry {
   short dev_font ;
   short dev_char ;
   int tfmw ;
};
#line 9
struct bifont;
#line 9 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
struct tfmfntinfo {
   struct bifont *tfm_bf ;
   int lastfntchar ;
   int em ;
   struct tfmchar_entry ch[256] ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
struct jstfmchar_entry {
   unsigned short dev_ku ;
   unsigned short dev_ten ;
   int tfmw ;
};
#line 28
struct jssinfo;
#line 28
struct jsubshare;
#line 28 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
struct jstfmfntinfo {
   struct bifont *js_bf ;
   int lastfntchar ;
   int em ;
   struct jstfmchar_entry ch[256] ;
   short jsubfont ;
   short dev_font ;
   struct jssinfo *js_info ;
   struct jsubshare *js_share ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
struct jfmtype_entry {
   int jfm_code ;
   int jfm_type ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
struct jfmchar_entry {
   int tfmw ;
};
#line 58 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
struct jfmfntinfo {
   struct bifont *jfm_bf ;
   int nctype ;
   struct jfmtype_entry *ctype ;
   int lasttypecode ;
   int em ;
   struct jfmchar_entry *ch ;
};
#line 145 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
struct jsubshare {
   int jss_stat ;
   struct bifont *jss_bf ;
   int jss_s ;
   int jss_dev_font ;
   struct jssinfo *jss_info ;
   char *jss_parent ;
   struct jsubshare *jss_next ;
};
#line 157 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
struct biaccessinfo {
   struct bifont *bf ;
   short jsubf ;
};
#line 97 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
struct finfo;
#line 5 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.h"
struct ffinfo;
#line 5 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.h"
struct funcfont {
   struct fontop *ff_fop ;
   BOOLEAN ff_body ;
   struct ffinfo *ff_info ;
   struct funcfont *ff_next ;
};
#line 171 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gdefs.h"
typedef char Boolean;
#line 34 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rastfont.h"
struct rastaccessinfo {
   float corrfact ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rastfont.h"
struct rastinitfontinfo {
   float corrfact ;
   int maxc ;
   Boolean mark[1] ;
};
#line 1 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/cscommands.h"
enum cscom {
    callothersubr = 0,
    callsubr = 1,
    closepath = 2,
    csdiv = 3,
    dotsection = 4,
    endchar = 5,
    escape = 6,
    hlineto = 7,
    hmoveto = 8,
    hsbw = 9,
    hstem = 10,
    hstem3 = 11,
    hvcurveto = 12,
    pop = 13,
    csreturn = 14,
    rlineto = 15,
    rmoveto = 16,
    rrcurveto = 17,
    sbw = 18,
    seac = 19,
    setcurrentpoint = 20,
    vhcurveto = 21,
    vlineto = 22,
    vmoveto = 23,
    vstem = 24,
    vstem3 = 25
} ;
#line 30 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/cscommands.h"
typedef enum cscom cscommand;
#line 310 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
struct cs {
   int one ;
   int two ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psifont.c"
struct ifsizes;
#line 26 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psifont.c"
struct ifonts {
   struct ifsizes *if_ss ;
   struct ifonts *if_next ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psifont.c"
struct ifsizes {
   char *is_sstr ;
   struct font_entry *is_fe ;
   struct ifsizes *is_next ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
struct bangspecial {
   struct bangspecial *bs_next ;
   char bs_string[1] ;
};
#line 65
enum __anonenum_ValTyp_31 {
    None = 0,
    String = 1,
    Integer = 2,
    Number = 3,
    Dimension = 4
} ;
#line 65 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
typedef enum __anonenum_ValTyp_31 ValTyp;
#line 69 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
union __anonunion_v_33 {
   int i ;
   float n ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
struct __anonstruct_KeyWord_32 {
   char *Key ;
   char *Val ;
   ValTyp vt ;
   union __anonunion_v_33 v ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
typedef struct __anonstruct_KeyWord_32 KeyWord;
#line 79 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
struct __anonstruct_KeyDesc_34 {
   char *Entry ;
   ValTyp Type ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
typedef struct __anonstruct_KeyDesc_34 KeyDesc;
#line 19 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.h"
struct decomp {
   char dcmp_type ;
   char *dcmp_name ;
   struct font_entry *dcmp_fetab[1] ;
};
#line 163 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
struct biinitfontinfo {
   struct bifont *bf ;
   int maxc ;
   Boolean mark[1] ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/type1font.c"
struct encr {
   char *er_filename ;
   BOOLEAN *er_done ;
   struct encr *er_next ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.h"
struct comp {
   char cmp_type ;
   char *cmp_name ;
   struct font_entry *cmp_fe ;
   unsigned short cmp_sub ;
};
#line 5 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/open.c"
struct openfont_list {
   struct font_entry *openfont_entry ;
   int use_count ;
   int last_use ;
};
#line 74 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
struct wlchar_entry {
   short dev_font ;
   short dev_char ;
   int tfmw ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
struct wlfntinfo {
   struct bifont *wl_bf ;
   int nfntchars ;
   struct wlchar_entry ch[1] ;
};
#line 8 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.h"
struct psbiops {
   int po_size ;
   char *po_dev_name ;
   struct bifont *po_bf ;
   int po_stand ;
   char po_stlen ;
   char po_mode_font ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.h"
struct pd {
   int pd_font ;
   int pd_char ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
struct __anonstruct_paperinfo_29 {
   char *size ;
   char *command ;
   int width ;
   int height ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dviconv.c"
struct __anonstruct_stack_29 {
   int h ;
   int v ;
   int w ;
   int x ;
   int y ;
   int z ;
   int d ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pscolor.c"
typedef int integer;
#line 45 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pscolor.c"
struct colorpage {
   struct colorpage *next ;
   integer boploc ;
   char *bg ;
   char colordat[2] ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.h"
struct __anonstruct_set_30 {
   struct font_entry *f ;
   int c ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.h"
union __anonunion_where_32 {
   unsigned int fileoffset ;
   unsigned char *dviptr ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.h"
struct __anonstruct_dvi_31 {
   unsigned int dvilen ;
   union __anonunion_where_32 where ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.h"
union __anonunion_vfd_29 {
   struct __anonstruct_set_30 set ;
   struct __anonstruct_dvi_31 dvi ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.h"
struct vfchar_entry {
   char vfdstat ;
   union __anonunion_vfd_29 vfd ;
   int tfmw ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.h"
struct virfntinfo {
   struct font_index *vf_fontidx ;
   struct font_entry *vf_default_fent ;
   struct vfchar_entry ch[1] ;
};
#line 78 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct fdin {
   char *name ;
   FILE *file ;
   int ch ;
   int line ;
};
#line 89 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct libdir {
   char *dir ;
   char *lcldir ;
   char *defpath ;
};
#line 95 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct libdir_body {
   char dir[1024] ;
   char lcldir[1024] ;
   char *defpath ;
};
#line 466 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct fontdesc {
   struct fontop *fd_op ;
   char *fd_spec ;
   int fd_sub ;
   struct funcfont *fd_path ;
   struct fontdesc *fd_next ;
};
#line 540 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct definition {
   char *def_name ;
   char *def_body ;
   struct definition *def_next ;
};
#line 705 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct devfile {
   char *df_file ;
   void (*df_op)() ;
   int df_kind ;
   struct devfile *df_next ;
};
#line 907 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct fontsubst {
   char *fs_font ;
   int fs_len ;
   int fs_reqmag ;
   int fs_submag ;
   struct fontsubst *fs_next ;
};
#line 948 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct fontreplace {
   char *fr_replfont ;
   char *fr_font ;
   int fr_ds ;
   int fr_fix ;
   struct fontreplace *fr_next ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
struct bifont {
   char *bf_name ;
   int bf_len ;
   char bf_mode_name ;
   char bf_mode_type ;
   char bf_mode_font ;
   char bf_mode_pos ;
   int bf_stand ;
   int bf_scale ;
   char bf_font_kind ;
   int bf_bold ;
   char *bf_cs_enc ;
   char *bf_psfont ;
   char *bf_psfile ;
   char *bf_psmod ;
   char *bf_psenc ;
   char bf_coding ;
   struct font_entry *bf_repfe ;
   struct bifont *bf_next ;
};
#line 676 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
struct __anonstruct_pops_29 {
   char *opname ;
   BOOLEAN extraarg ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 59 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvips.h"
typedef char boolean;
#line 147 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
typedef char *extra_glyphs_entry;
#line 190 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
struct __anonstruct_cc_entry_25 {
   byte nargs ;
   boolean bottom ;
   boolean clear ;
   boolean valid ;
};
#line 190 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
typedef struct __anonstruct_cc_entry_25 cc_entry;
#line 197 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
struct __anonstruct_cs_entry_26 {
   char *name ;
   byte *data ;
   unsigned short len ;
   unsigned short cslen ;
   boolean used ;
   boolean valid ;
};
#line 197 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
typedef struct __anonstruct_cs_entry_26 cs_entry;
#line 50 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/conftest.c"
extern char sqrt() ;
#line 51 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/conftest.c"
int main(void) 
{ 
  char tmp ;

  {
  {
#line 54
  tmp = sqrt();
  }
#line 54
  return ((int )tmp);
#line 56
  return (0);
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/emit.h"
char *digit ;
#line 5 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
struct font_entry *curfontent ;
#line 15
FILE *outfp ;
#line 21
int debug ;
#line 38
int Snbpxl ;
#line 39
int Sonbpx ;
#line 40
int Sndc ;
#line 94
void skipline(void) ;
#line 117
char *alloc_check(char *p , char *e ) ;
#line 120
char *strsave(char *s ) ;
#line 129 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
BOOLEAN landscape  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rastfont.h"
DEV_FONT rast_fontdict(struct font_entry *fe , int c ) ;
#line 62
void dev_rast_initfe(struct font_entry *fe ) ;
#line 63
void dev_rast_initfontdict(struct font_entry *fe , int c ) ;
#line 2 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.h"
int hconv ;
#line 4
int *ps_move ;
#line 6
char *psfname(int psf ) ;
#line 41
struct pdlist *getpdlist(int corr ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
void getpackdict(void) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
struct confop pdcop  =    {(char *)"packdict", & getpackdict};
#line 17
void getdvidict(void) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
struct confop ddcop  =    {(char *)"dvidict", & getdvidict};
#line 29 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
struct packdict *packdicts  =    (struct packdict *)((void *)0);
#line 31
void getdictstat(int p ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
void getpackdict(void) 
{ 


  {
  {
#line 36
  getdictstat(0);
  }
#line 37
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
void getdvidict(void) 
{ 


  {
  {
#line 42
  getdictstat(1);
  }
#line 43
  return;
}
}
#line 52
int getfield(char *field ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
void getdictstat(int p ) 
{ 
  char field[257] ;
  struct packdict *pd___0 ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 52
  getfield(field);
#line 53
  skipline();
#line 54
  tmp = malloc((size_t )((unsigned int )sizeof(struct packdict )));
#line 54
  tmp___0 = alloc_check(tmp, "packdict");
#line 54
  pd___0 = (struct packdict *)tmp___0;
#line 55
  pd___0->pd_name = strsave(field);
#line 56
  tmp___1 = strlen((char const   *)(field));
#line 56
  pd___0->pd_len = (int )tmp___1;
#line 57
  pd___0->pd_pack = p;
#line 58
  pd___0->pd_next = packdicts;
#line 59
  packdicts = pd___0;
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
int dictform(char *name ) 
{ 
  struct packdict *pd___0 ;
  int tmp ;

  {
#line 67
  pd___0 = packdicts;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! ((unsigned long )pd___0 != (unsigned long )((void *)0))) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = strncmp((char const   *)name, (char const   *)pd___0->pd_name, (size_t )pd___0->pd_len);
    }
#line 68
    if (tmp == 0) {
#line 69
      return (pd___0->pd_pack);
    }
#line 67
    pd___0 = pd___0->pd_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return (1);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
static struct pdlist *pdlists  =    (struct pdlist *)((void *)0);
#line 74 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
static struct pdlist **nextpl  =    & pdlists;
#line 85
int dev_newdevfont(void) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
struct pdlist *getpdlist(int corr ) 
{ 
  struct pdlist *pl ;
  int tmp ;
  short tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 82
  pl = pdlists;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 82
      goto while_break;
    }
#line 83
    if (corr == pl->pl_corr) {
#line 84
      tmp___0 = pl->pl_char;
#line 84
      pl->pl_char = (short )((int )pl->pl_char + 1);
#line 84
      if ((int )tmp___0 == 31) {
        {
#line 85
        tmp = dev_newdevfont();
#line 85
        pl->pl_font = (short )tmp;
#line 86
        pl->pl_char = (short)32;
        }
      } else
#line 87
      if ((int )pl->pl_char == 256) {
#line 88
        pl->pl_char = (short)0;
      }
#line 89
      return (pl);
    }
#line 82
    pl = pl->pl_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 91
  tmp___1 = malloc((size_t )((unsigned int )sizeof(struct pdlist )));
#line 91
  tmp___2 = alloc_check(tmp___1, "pdlist");
#line 91
  pl = (struct pdlist *)tmp___2;
#line 92
  pl->pl_corr = corr;
#line 93
  tmp___3 = dev_newdevfont();
#line 93
  pl->pl_font = (short )tmp___3;
#line 94
  pl->pl_char = (short)32;
#line 95
  pl->pl_next = (struct pdlist *)((void *)0);
#line 96
  *nextpl = pl;
#line 97
  nextpl = & pl->pl_next;
  }
#line 98
  return (pl);
}
}
#line 117
int end_string(void) ;
#line 144
int dev_setfont(int psf ) ;
#line 152
int pscharbitmap(int bytewidth , int nbpl , int height___0 , char *pixel___0 ) ;
#line 101 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
void dev_rast_initfontdict(struct font_entry *fe , int c ) 
{ 
  struct rastchar_entry *ce ;
  struct rastfntinfo *rfi ;
  struct pdlist *pl ;
  int corr ;
  int bytewidth ;
  float cf ;
  float cw ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 117
  end_string();
#line 119
  rfi = *((struct rastfntinfo **)(& fe->finfo));
#line 119
  ce = & rfi->ch[c];
  }
#line 121
  if (rfi->dictform == 0) {
    {
#line 122
    corr = (int )(rfi->corrfact * (float )1000);
#line 123
    cf = (float )corr / (float )1000;
#line 124
    pl = getpdlist(corr);
    }
#line 124
    if ((int )pl->pl_char == 32) {
      {
#line 125
      tmp = psfname((int )pl->pl_font);
#line 125
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%.3f %d /%s NF\n",
              (double )cf, 256, tmp);
      }
    }
#line 128
    if (fe->ncdl == -1) {
#line 129
      fe->ncdl = 0;
    }
#line 131
    ce->dev_font = pl->pl_font;
#line 132
    ce->dev_char = pl->pl_char;
  } else {
#line 134
    cf = rfi->corrfact;
#line 135
    if (fe->ncdl == -1) {
      {
#line 136
      fe->k = dev_newdevfont();
#line 137
      tmp___0 = psfname(fe->k);
#line 137
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%.3f %d /%s NF\n",
              (double )cf, rfi->nfntchars, tmp___0);
#line 139
      fe->ncdl = 0;
      }
    }
#line 141
    ce->dev_font = (short )fe->k;
#line 142
    ce->dev_char = (short )c;
  }
  {
#line 144
  dev_setfont((int )ce->dev_font);
  }
#line 147
  if (debug >= 2) {
    {
#line 148
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%% font: %s char: %x\n",
            fe->n, c);
    }
  }
  {
#line 150
  bytewidth = (int )((unsigned short )((int )ce->width + 7)) >> 3;
#line 151
  _IO_putc('[', outfp);
#line 152
  tmp___1 = pscharbitmap(bytewidth, (int )ce->nbpl, (int )ce->height, ce->where.pixptr);
  }
#line 152
  if (! tmp___1) {
#line 153
    bytewidth = 1;
#line 154
    ce->height = (unsigned short)1;
  }
  {
#line 156
  cw = (float )ce->tfmw / (float )hconv;
#line 157
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"\n%d %d %d %d %.3f] %d D\n",
          bytewidth << 3, (int )ce->height, (int )ce->xoffset, ((int )ce->height - (int )ce->yoffset) - 1,
          (double )(cw / cf), (int )ce->dev_char);
#line 162
  (fe->ncdl) ++;
#line 163
  Snbpxl += bytewidth * (int )ce->height;
#line 164
  fe->nbpxl += bytewidth * (int )ce->height;
#line 165
  Sonbpx += (int )((unsigned short )((int )ce->width * (int )ce->height + 7)) >> 3;
#line 166
  Sndc ++;
  }
#line 168
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
int pscharbitmap(int bytewidth , int nbpl , int height___0 , char *pixel___0 ) 
{ 
  int i ;
  int j ;
  int cc ;
  unsigned char *sl ;

  {
  {
#line 180
  _IO_putc('<', outfp);
#line 181
  i = height___0 - 1;
#line 181
  cc = 2;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (i >= 0)) {
#line 181
      goto while_break;
    }
#line 182
    sl = (unsigned char *)(pixel___0 + i * nbpl);
#line 183
    j = 0;
    {
#line 183
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 183
      if (! (j < bytewidth)) {
#line 183
        goto while_break___0;
      }
#line 184
      if (cc > 72) {
        {
#line 185
        fputs((char const   */* __restrict  */)"\n  ", (FILE */* __restrict  */)outfp);
#line 185
        cc = 2;
        }
      }
      {
#line 187
      _IO_putc((int )*(digit + (((int )*sl >> 4) & 15)), outfp);
#line 187
      _IO_putc((int )*(digit + ((int )*sl & 15)), outfp);
#line 188
      cc += 2;
#line 183
      j ++;
#line 183
      sl ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 181
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  if (bytewidth == 0) {
    {
#line 192
    fputs((char const   */* __restrict  */)"00>", (FILE */* __restrict  */)outfp);
    }
#line 193
    return (0);
  } else
#line 191
  if (height___0 == 0) {
    {
#line 192
    fputs((char const   */* __restrict  */)"00>", (FILE */* __restrict  */)outfp);
    }
#line 193
    return (0);
  }
  {
#line 195
  _IO_putc('>', outfp);
  }
#line 196
  return (1);
}
}
#line 203
int rast_setchar(int c ) ;
#line 203
int rast_setstring(char *s , int len ) ;
#line 199 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
void dev_rast_initfe(struct font_entry *fe ) 
{ 


  {
  {
#line 205
  fe->dev_fontdict = & rast_fontdict;
#line 206
  fe->dev_setchar = & rast_setchar;
#line 207
  fe->dev_setstring = & rast_setstring;
#line 208
  (*((struct rastfntinfo **)(& fe->finfo)))->dictform = dictform(fe->n);
  }
#line 209
  return;
}
}
#line 217
int begin_string(void) ;
#line 218
int pschar(int c ) ;
#line 211 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
int rast_setchar(int c ) 
{ 
  struct rastchar_entry *ce ;
  int cw ;

  {
  {
#line 214
  ce = & (*((struct rastfntinfo **)(& curfontent->finfo)))->ch[c];
#line 217
  begin_string();
#line 218
  pschar((int )ce->dev_char);
#line 219
  cw = ce->tfmw;
#line 219
  *ps_move += cw;
  }
#line 220
  return (cw);
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psrast.c"
int rast_setstring(char *s , int len ) 
{ 
  char *sp ;
  struct rastchar_entry *ce ;
  int cw ;

  {
  {
#line 228
  ce = (*((struct rastfntinfo **)(& curfontent->finfo)))->ch;
#line 229
  cw = 0;
#line 231
  begin_string();
#line 232
  sp = s;
  }
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! ((unsigned long )sp < (unsigned long )(s + len))) {
#line 232
      goto while_break;
    }
    {
#line 233
    pschar((int )(ce + (int )*sp)->dev_char);
#line 234
    cw += (ce + (int )*sp)->tfmw;
#line 232
    sp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  *ps_move += cw;
#line 237
  return (cw);
}
}
#line 749 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int h ;
#line 46
int v ;
#line 52
void ReadFontDef(int k , struct font_index **hdfip ) ;
#line 53
void SkipFontDef(void) ;
#line 56
void readfontdef(int k , int c , int s , int d , int a , int l , char *n , struct font_index **hdfip ) ;
#line 63
struct dconv dfd_dconv_templ ;
#line 70
FILE *dc_file ;
#line 109
void getbytes(FILE *fp , byte *cp , int n ) ;
#line 110
void skipbytes(FILE *fp , int n ) ;
#line 111
int getuint(FILE *fp , int n ) ;
#line 112
int getint(FILE *fp , int n ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
int dfd_getcommand(void) ;
#line 11
void dfd_backupone(void) ;
#line 12
void dfd_getbytes(byte *cp , int n ) ;
#line 13
void dfd_skipbytes(int n ) ;
#line 14
int dfd_getuint(int n ) ;
#line 15
int dfd_getint(int n ) ;
#line 16
void dfd_movedown(int a ) ;
#line 17
void dfd_movedown_v(int a ) ;
#line 18
void dfd_moveover(int b ) ;
#line 19
void dfd_moveover_v(int b ) ;
#line 20
void dfd_setrule(int a , int b , BOOLEAN Set ) ;
#line 21
void dfd_setrule_v(int a , int b , BOOLEAN Set ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
struct dconv dfd_dconv_templ  = 
#line 22
     {& dfd_getcommand, & dfd_backupone, & dfd_getbytes, & dfd_skipbytes, & dfd_getuint,
    & dfd_getint, (FILE *)((void *)0), (byte *)((void *)0), (byte *)((void *)0), & dfd_movedown,
    & dfd_movedown_v, & dfd_moveover, & dfd_moveover_v, & dfd_setrule, & dfd_setrule_v,
    0};
#line 41 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
int dfd_getcommand(void) 
{ 
  int tmp ;

  {
  {
#line 44
  tmp = getuint(dc_file, 1);
  }
#line 44
  return (tmp);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
void dfd_backupone(void) 
{ 


  {
  {
#line 50
  fseek(dc_file, -1L, 1);
  }
#line 51
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
void dfd_getbytes(byte *cp , int n ) 
{ 


  {
  {
#line 58
  getbytes(dc_file, cp, n);
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
void dfd_skipbytes(int n ) 
{ 


  {
  {
#line 65
  fseek(dc_file, (long )n, 1);
  }
#line 66
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
int dfd_getuint(int n ) 
{ 
  int tmp ;

  {
  {
#line 72
  tmp = getuint(dc_file, n);
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
int dfd_getint(int n ) 
{ 
  int tmp ;

  {
  {
#line 79
  tmp = getint(dc_file, n);
  }
#line 79
  return (tmp);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
void ReadFontDef(int k , struct font_index **hdfip ) 
{ 
  int c ;
  int s ;
  int d ;
  int a ;
  int l ;
  byte n[257] ;

  {
  {
#line 91
  c = getuint(dc_file, 4);
#line 92
  s = getuint(dc_file, 4);
#line 93
  d = getuint(dc_file, 4);
#line 94
  a = getuint(dc_file, 1);
#line 95
  l = getuint(dc_file, 1);
#line 96
  getbytes(dc_file, n, a + l);
#line 97
  n[a + l] = (byte )'\000';
#line 98
  readfontdef(k, c, s, d, a, l, (char *)(n), hdfip);
  }
#line 99
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
void SkipFontDef(void) 
{ 
  int a ;
  int l ;

  {
  {
#line 106
  skipbytes(dc_file, 12);
#line 107
  a = getuint(dc_file, 1);
#line 108
  l = getuint(dc_file, 1);
#line 109
  skipbytes(dc_file, a + l);
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
int HasBeenRead(int k , struct font_index *hdfidx ) 
{ 
  struct font_index *ptr ;

  {
#line 119
  ptr = hdfidx;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 119
      if (! (ptr->k != k)) {
#line 119
        goto while_break;
      }
    } else {
#line 119
      goto while_break;
    }
#line 120
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return ((unsigned long )ptr != (unsigned long )((void *)0));
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
void dfd_movedown(int a ) 
{ 


  {
#line 129
  v += a;
#line 130
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
void dfd_movedown_v(int a ) 
{ 


  {
#line 136
  h -= a;
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
void dfd_moveover(int b ) 
{ 


  {
#line 143
  h += b;
#line 144
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
void dfd_moveover_v(int b ) 
{ 


  {
#line 150
  v += b;
#line 151
  return;
}
}
#line 159
int dev_setposn(int x , int y ) ;
#line 160
int dev_setrule(int a , int b ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
void dfd_setrule(int a , int b , BOOLEAN Set ) 
{ 


  {
#line 158
  if (a > 0) {
#line 158
    if (b > 0) {
      {
#line 159
      dev_setposn(h, v);
#line 160
      dev_setrule(a, b);
      }
    }
  }
#line 162
  if (Set) {
#line 163
    h += b;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dfdcom.c"
void dfd_setrule_v(int a , int b , BOOLEAN Set ) 
{ 


  {
#line 171
  if (a > 0) {
#line 171
    if (b > 0) {
      {
#line 172
      dev_setposn(h, v);
#line 173
      dev_setrule(- b, a);
      }
    }
  }
#line 175
  if (Set) {
#line 176
    v += b;
  }
#line 177
  return;
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int resolution ;
#line 26
char *G_progname ;
#line 82
void Fatal(char *fmt , char *a , char *b , char *c ) ;
#line 83
void Warning(char *fmt , char *a , char *b , char *c ) ;
#line 97
int pathtype_init(char *proto , struct funcfont **ff ) ;
#line 103
void pave(char *path , char *proto , struct accarg *acca ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/execfont.c"
int cexectype_access(char *proto , struct font_entry *fe , struct accarg *acca ) ;
#line 9
int exectype_access(char *proto , struct font_entry *fe , struct accarg *acca ) ;
#line 10
void init_exec_fontinfo(struct font_entry *fe ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/execfont.c"
struct fontop cexecop  =    {(char *)"exec", & pathtype_init, & cexectype_access, & init_exec_fontinfo};
#line 17 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/execfont.c"
struct fontop execop  =    {(char *)"exec", & pathtype_init, & exectype_access, & init_exec_fontinfo};
#line 24 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/execfont.c"
int cexectype_access(char *proto , struct font_entry *fe , struct accarg *acca ) 
{ 
  FILE *f ;
  int c ;
  char execline[1024] ;
  int stat ;

  {
#line 35
  if (acca->acc_mode != 0) {
#line 36
    return (0);
  }
  {
#line 38
  acca->pv_mag = (int )((double )(acca->actmagfact * (float )resolution) + 0.5);
#line 39
  pave(execline, proto, acca);
  }
#line 41
  if (debug >= 1) {
    {
#line 42
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trying to exec for %s\n\t%s\n",
            fe->n, execline);
    }
  }
  {
#line 46
  f = popen((char const   *)(execline), "r");
  }
#line 46
  if ((unsigned long )f != (unsigned long )((void *)0)) {
#line 47
    if (debug >= 2) {
      {
#line 48
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 48
        c = _IO_getc(f);
        }
#line 48
        if (! (c != -1)) {
#line 48
          goto while_break;
        }
        {
#line 49
        _IO_putc(c, stderr);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 51
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 51
        c = _IO_getc(f);
        }
#line 51
        if (! (c != -1)) {
#line 51
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 53
    stat = pclose(f);
    }
#line 53
    if (stat != 0) {
      {
#line 54
      Warning("exec font generation failed : %s", execline);
      }
    }
  } else {
    {
#line 56
    Warning("exec font execution failed : %s", execline);
    }
  }
#line 58
  return (! stat);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/execfont.c"
int exectype_access(char *proto , struct font_entry *fe , struct accarg *acca ) 
{ 


  {
  {
#line 67
  cexectype_access(proto, fe, acca);
  }
#line 68
  return (0);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/execfont.c"
void init_exec_fontinfo(struct font_entry *fe ) 
{ 


  {
  {
#line 76
  Fatal("%s implementation error: init_exec_fontinfo", G_progname);
  }
#line 77
  return;
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/jsub.h"
char *jsf_names[35] ;
#line 8 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/jsub.h"
int foundjsubf  ;
#line 11 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
char *jsf_names[35]  = 
#line 11 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
  {      (char *)"",      (char *)"jsy",      (char *)"jroma",      (char *)"jhira", 
        (char *)"jkata",      (char *)"jgreek",      (char *)"jrussian",      (char *)"jkeisen", 
        (char *)"jka",      (char *)"jkb",      (char *)"jkc",      (char *)"jkd", 
        (char *)"jke",      (char *)"jkf",      (char *)"jkg",      (char *)"jkh", 
        (char *)"jki",      (char *)"jkj",      (char *)"jkk",      (char *)"jkl", 
        (char *)"jkm",      (char *)"jkn",      (char *)"jko",      (char *)"jkp", 
        (char *)"jkq",      (char *)"jkr",      (char *)"jks",      (char *)"jkt", 
        (char *)"jku",      (char *)"jkv",      (char *)"jkw",      (char *)"jkx", 
        (char *)"jky",      (char *)"jkz",      (char *)((void *)0)};
#line 49 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
int getjsubfont(char *n , char **subend ) 
{ 
  int f ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 55
  f = 1;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (f <= 33)) {
#line 55
      goto while_break;
    }
    {
#line 56
    tmp___0 = strlen((char const   *)jsf_names[f]);
#line 56
    tmp___1 = strncmp((char const   *)n, (char const   *)jsf_names[f], tmp___0);
    }
#line 56
    if (! tmp___1) {
      {
#line 57
      tmp = strlen((char const   *)jsf_names[f]);
#line 57
      *subend = (n + tmp) - 1;
      }
#line 58
      return (f);
    }
#line 55
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  return (0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
int getdcode(char *n , char **subend ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 69
  if ((int )*n == 67) {
#line 69
    if ((int )*(n + 3) == 67) {
#line 70
      *subend = n + 3;
#line 71
      if ((int )*(n + 1) >= 97) {
#line 71
        tmp = ((int )*(n + 1) - 97) + 10;
      } else {
#line 71
        tmp = (int )*(n + 1) - 48;
      }
#line 71
      if ((int )*(n + 2) >= 97) {
#line 71
        tmp___0 = ((int )*(n + 2) - 97) + 10;
      } else {
#line 71
        tmp___0 = (int )*(n + 2) - 48;
      }
#line 71
      return (tmp * 16 + tmp___0);
    }
  }
#line 73
  return (0);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
void jsub_to_jis(short f , short c , unsigned short *ku , unsigned short *ten ) 
{ 
  int n ;

  {
#line 86
  if ((int )f <= 7) {
#line 87
    if ((int )f == 1) {
#line 88
      if ((int )c >= 100) {
#line 89
        *ku = (unsigned short)34;
#line 90
        *ten = (unsigned short )(((int )c - 100) + 32);
      } else {
#line 92
        *ku = (unsigned short)33;
#line 93
        *ten = (unsigned short )((int )c + 32);
      }
    } else
#line 95
    if ((int )f == 2) {
#line 96
      *ku = (unsigned short)35;
#line 97
      *ten = (unsigned short )(((int )c - 32) + 32);
    } else {
#line 99
      *ku = (unsigned short )(((int )f + 1) + 32);
#line 100
      *ten = (unsigned short )((int )c + 32);
    }
  } else
#line 102
  if ((int )f <= 19) {
#line 103
    n = ((int )f - 8) * 256 + (int )c;
#line 104
    *ku = (unsigned short )((n / 94 + 16) + 32);
#line 105
    *ten = (unsigned short )((n % 94 + 1) + 32);
  } else {
#line 107
    n = ((int )f - 20) * 256 + (int )c;
#line 108
    *ku = (unsigned short )((n / 94 + 48) + 32);
#line 109
    *ten = (unsigned short )((n % 94 + 1) + 32);
  }
#line 111
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
void jis_to_jsub(short ku , short ten , unsigned short *f , unsigned short *c ) 
{ 
  int n ;

  {
#line 120
  ku = (short )((int )ku - 32);
#line 121
  ten = (short )((int )ten - 32);
#line 122
  *f = (unsigned short)1;
#line 123
  *c = (unsigned short)1;
#line 124
  if ((int )ku <= 0) {
    {
#line 125
    Warning("invalid ku in jis (%x, %x)", (int )ku + 32, (int )ten + 32);
    }
#line 126
    return;
  } else
#line 124
  if (9 <= (int )ku) {
#line 124
    if ((int )ku <= 15) {
      {
#line 125
      Warning("invalid ku in jis (%x, %x)", (int )ku + 32, (int )ten + 32);
      }
#line 126
      return;
    } else {
#line 124
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 124
  if ((int )ku > 84) {
    {
#line 125
    Warning("invalid ku in jis (%x, %x)", (int )ku + 32, (int )ten + 32);
    }
#line 126
    return;
  }
#line 128
  if ((int )ten < 1) {
    {
#line 129
    Warning("invalid ten in jis (%x, %x)", (int )ku + 32, (int )ten + 32);
    }
#line 130
    return;
  } else
#line 128
  if ((int )ten > 94) {
    {
#line 129
    Warning("invalid ten in jis (%x, %x)", (int )ku + 32, (int )ten + 32);
    }
#line 130
    return;
  }
#line 132
  if ((int )ku <= 8) {
#line 133
    if ((int )ku == 1) {
#line 134
      *f = (unsigned short)1;
#line 135
      *c = (unsigned short )ten;
    } else
#line 136
    if ((int )ku == 2) {
#line 137
      *f = (unsigned short)1;
#line 138
      *c = (unsigned short )((int )ten + 100);
    } else
#line 139
    if ((int )ku == 3) {
#line 140
      *f = (unsigned short)2;
#line 141
      *c = (unsigned short )((int )ten + 32);
    } else {
#line 143
      *f = (unsigned short )((int )ku - 1);
#line 144
      *c = (unsigned short )ten;
    }
  } else
#line 146
  if ((int )ku <= 47) {
#line 147
    n = (((int )ku - 16) * 94 + (int )ten) - 1;
#line 148
    *f = (unsigned short )(n / 256 + 8);
#line 149
    *c = (unsigned short )(n % 256);
  } else {
#line 151
    n = (((int )ku - 48) * 94 + (int )ten) - 1;
#line 152
    *f = (unsigned short )(n / 256 + 20);
#line 153
    *c = (unsigned short )(n % 256);
  }
#line 155
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
void code_to_jis(unsigned short s , unsigned short c , unsigned short *ku , unsigned short *ten ) 
{ 


  {
#line 162
  if ((int )c >= 128) {
#line 163
    *ku = (unsigned short )((int )s + 1);
#line 164
    *ten = (unsigned short )((int )c - 128);
  } else {
#line 166
    *ku = s;
#line 167
    *ten = c;
  }
#line 169
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
void jis_to_dcode(unsigned short ku , unsigned short ten , unsigned short *f , unsigned short *c ) 
{ 


  {
#line 192
  *f = (unsigned short )((int )((unsigned short )((int )ku - 33)) / 2 + 1);
#line 193
  if ((int )ku % 2 == 1) {
#line 193
    *c = ten;
  } else {
#line 193
    *c = (unsigned short )((int )ten + 128);
  }
#line 194
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
int match_subf(char *sname , char *fname , BOOLEAN ini , char **sb , char **se ) 
{ 


  {
#line 207
  *sb = (char *)((void *)0);
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! ((int )*sname != 0)) {
#line 208
      goto while_break;
    }
#line 209
    if ((int )*sname == 37) {
#line 210
      sname ++;
#line 210
      if ((int )*sname == 106) {
        {
#line 211
        foundjsubf = getjsubfont(fname, se);
        }
#line 211
        if (foundjsubf == 0) {
#line 212
          return (0);
        }
      } else
#line 213
      if ((int )*sname == 99) {
#line 214
        if ((int )*fname == 67) {
#line 214
          if ((int )*(fname + 3) == 67) {
#line 215
            *se = fname + 3;
          } else {
#line 217
            return (0);
          }
        } else {
#line 217
          return (0);
        }
      } else
#line 218
      if ((int )*sname == 100) {
#line 219
        if (48 <= (int )*fname) {
#line 219
          if ((int )*fname <= 57) {
#line 220
            fname ++;
            {
#line 220
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 220
              if (48 <= (int )*fname) {
#line 220
                if (! ((int )*fname <= 57)) {
#line 220
                  goto while_break___0;
                }
              } else {
#line 220
                goto while_break___0;
              }
#line 220
              fname ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 222
            fname --;
#line 223
            goto __Cont;
          } else {
#line 225
            return (0);
          }
        } else {
#line 225
          return (0);
        }
      } else {
#line 227
        return (0);
      }
#line 228
      *sb = fname;
#line 229
      fname = *se;
    } else
#line 230
    if ((int )*sname != (int )*fname) {
#line 231
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 208
    sname ++;
#line 208
    fname ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  if ((int )*fname == 0) {
#line 234
    return (1);
  } else {
#line 236
    return (ini);
  }
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
void subst_subf(char *fname , char *sname , char *sb , char *se ) 
{ 
  char *s ;
  char *tmp ;

  {
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! ((int )*sname != 0)) {
#line 246
      goto while_break;
    }
#line 247
    if ((int )*sname == 37) {
#line 248
      sname ++;
#line 249
      s = sb;
      {
#line 249
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 249
        if (! ((unsigned long )s <= (unsigned long )se)) {
#line 249
          goto while_break___0;
        }
#line 250
        *fname = *s;
#line 249
        s ++;
#line 249
        fname ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 252
      tmp = fname;
#line 252
      fname ++;
#line 252
      *tmp = *sname;
    }
#line 246
    sname ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  *fname = (char )'\000';
#line 255
  return;
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
int jis_to_idx94(int jis ) 
{ 
  int kanji ;
  int c1___0 ;
  int c2___0 ;

  {
#line 265
  kanji = jis - 8481;
#line 265
  if (kanji < 0) {
#line 266
    return (-1);
  }
#line 267
  c1___0 = (kanji >> 8) & 255;
#line 268
  if (c1___0 >= 94) {
#line 269
    return (-1);
  }
#line 270
  c2___0 = kanji & 255;
#line 271
  if (c2___0 >= 94) {
#line 272
    return (-1);
  }
#line 273
  return (c1___0 * 94 + c2___0);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
int idx94_to_std(int idx ) 
{ 


  {
#line 279
  return (((idx / 94) * 256 + idx % 94) + 8481);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
int jsub_to_idx94(short f , short c ) 
{ 
  unsigned short ku ;
  unsigned short ten ;
  int tmp ;

  {
  {
#line 287
  jsub_to_jis(f, c, & ku, & ten);
#line 288
  tmp = jis_to_idx94((int )ku * 256 + (int )ten);
  }
#line 288
  return (tmp);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
int idx94_to_sjis(int idx ) 
{ 
  int i1 ;
  int i2 ;
  int c1___0 ;
  int c2___0 ;

  {
#line 296
  i1 = idx / 94;
#line 297
  i2 = idx % 94;
#line 298
  if ((i1 & 1) == 0) {
#line 299
    if (i1 < 62) {
#line 299
      c1___0 = i1 / 2 + 129;
    } else {
#line 300
      c1___0 = i1 / 2 + 193;
    }
#line 301
    if (i2 >= 63) {
#line 301
      c2___0 = i2 + 65;
    } else {
#line 302
      c2___0 = i2 + 64;
    }
  } else {
#line 304
    if (i1 < 62) {
#line 304
      c1___0 = i1 / 2 + 129;
    } else {
#line 305
      c1___0 = i1 / 2 + 193;
    }
#line 306
    c2___0 = i2 + 159;
  }
#line 308
  return (c1___0 * 256 + c2___0);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
int jis_to_euc(int jis ) 
{ 


  {
#line 314
  return (jis + 32896);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/kanji.c"
int jis_to_sjis(int jis ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 320
  tmp = jis_to_idx94(jis);
#line 320
  tmp___0 = idx94_to_sjis(tmp);
  }
#line 320
  return (tmp___0);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 118 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int makeuint(byte *s , int n ) ;
#line 119
int makeint(byte *s , int n ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/util.c"
char *alloc_check(char *p , char *e ) 
{ 


  {
#line 8
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 9
    Fatal("can\'t malloc space for %s", e);
    }
  }
#line 10
  return (p);
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/util.c"
int makeuint(byte *s , int n ) 
{ 
  int x ;
  byte *tmp ;
  int tmp___0 ;

  {
#line 19
  x = 0;
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    tmp___0 = n;
#line 20
    n --;
#line 20
    if (! tmp___0) {
#line 20
      goto while_break;
    }
#line 21
    x <<= 8;
#line 22
    tmp = s;
#line 22
    s ++;
#line 22
    x |= (int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 24
  return (x);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/util.c"
int makeint(byte *s , int n ) 
{ 
  int n1 ;
  int x ;
  byte *tmp ;
  int tmp___0 ;
  byte *tmp___1 ;
  int tmp___2 ;

  {
#line 34
  tmp = s;
#line 34
  s ++;
#line 34
  x = (int )*tmp;
#line 35
  tmp___0 = n;
#line 35
  n --;
#line 35
  n1 = tmp___0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    tmp___2 = n;
#line 36
    n --;
#line 36
    if (! tmp___2) {
#line 36
      goto while_break;
    }
#line 37
    x <<= 8;
#line 38
    tmp___1 = s;
#line 38
    s ++;
#line 38
    x |= (int )*tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  x <<= 32 - 8 * n1;
#line 46
  x >>= 32 - 8 * n1;
#line 48
  return (x);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/util.c"
int htoi(char *s , char **se ) 
{ 
  int x ;

  {
#line 56
  x = 0;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (48 <= (int )*s) {
#line 57
      if ((int )*s <= 57) {
#line 58
        x = (x * 16 + (int )*s) - 48;
      } else {
#line 57
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 59
    if (97 <= (int )*s) {
#line 59
      if ((int )*s <= 102) {
#line 60
        x = ((x * 16 + (int )*s) - 97) + 10;
      } else {
#line 59
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 61
    if (65 <= (int )*s) {
#line 61
      if ((int )*s <= 70) {
#line 62
        x = ((x * 16 + (int )*s) - 65) + 10;
      } else {
#line 64
        *se = s;
#line 65
        return (x);
      }
    } else {
#line 64
      *se = s;
#line 65
      return (x);
    }
#line 56
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/util.c"
int numstr(char *s ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((int )*s != 0)) {
#line 73
      goto while_break;
    }
    {
#line 74
    tmp = __ctype_b_loc();
    }
#line 74
    if (! ((int const   )*(*tmp + (int )*s) & 2048)) {
#line 75
      return (0);
    }
#line 73
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (1);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/util.c"
char *strsave(char *s ) 
{ 
  char *t ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 86
  tmp = strlen((char const   *)s);
#line 86
  len = (int )(tmp + 1UL);
#line 86
  tmp___0 = malloc((size_t )((unsigned int )len));
#line 86
  t = (char *)tmp___0;
  }
#line 86
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    {
#line 87
    Fatal("cannot save string %s", s);
    }
  }
  {
#line 88
  memcpy((void */* __restrict  */)t, (void const   */* __restrict  */)s, (size_t )len);
  }
#line 89
  return (t);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/util.c"
int getstrtok(char *d , char c , char **e ) 
{ 


  {
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if ((int )*d != (int )c) {
#line 100
      if (! ((int )*d != 0)) {
#line 100
        goto while_break;
      }
    } else {
#line 100
      goto while_break;
    }
#line 100
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  if ((int )*d == (int )c) {
#line 103
    *d = (char )'\000';
#line 104
    *e = d + 1;
#line 105
    return (1);
  }
#line 107
  return (0);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/util.c"
int skipstrblank(char *d , char **e ) 
{ 


  {
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((int )*d == 32)) {
#line 114
      if (! ((int )*d == 9)) {
#line 114
        goto while_break;
      }
    }
#line 114
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  *e = d;
#line 117
  return (0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/util.c"
int scale_exact(int s , int d ) 
{ 
  int sign ;
  unsigned int s1 ;
  unsigned int s0 ;
  unsigned int d1 ;
  unsigned int d0 ;

  {
#line 134
  if (s < 0) {
#line 135
    sign = -1;
#line 136
    s *= -1;
  } else {
#line 138
    sign = 1;
  }
#line 139
  s0 = (unsigned int )(s & ((1 << 16) - 1));
#line 140
  d0 = (unsigned int )(d & ((1 << 16) - 1));
#line 141
  s1 = (unsigned int )(s >> 16);
#line 142
  d1 = (unsigned int )(d >> 16);
#line 143
  return ((int )((unsigned int )sign * ((s1 * d1 << 12) + (((s1 * d0 + s0 * d1) + (s0 * d0 >> 16)) >> 4))));
}
}
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
void openfontfile(struct font_entry *fe ) ;
#line 193 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
char *enc_read(struct bifont *bf ) ;
#line 208
int dev_is_tfm(struct font_entry *fe , int tfmmode ) ;
#line 209
int dev_is_jstfm(struct font_entry *fe , int tfmmode ) ;
#line 210
int dev_jstfm_kind(struct font_entry *fe ) ;
#line 212
int dev_is_jfm(struct font_entry *fe , int tfmmode ) ;
#line 213
int dev_jfm_kind(struct font_entry *fe ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
int tfm_access(char *proto , struct font_entry *fe , struct accarg *acca ) ;
#line 34
int jstfm_access(char *proto , struct font_entry *fe , struct accarg *acca ) ;
#line 35
int jfm_access(char *proto , struct font_entry *fe , struct accarg *acca ) ;
#line 36
void init_tfm_fontinfo(struct font_entry *fe ) ;
#line 37
void init_jstfm_fontinfo(struct font_entry *fe ) ;
#line 38
void init_jfm_fontinfo(struct font_entry *fe ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
struct fontop tfmop  =    {(char *)"tfm", & pathtype_init, & tfm_access, & init_tfm_fontinfo};
#line 47 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
struct fontop jstfmop  =    {(char *)"jstfm", & pathtype_init, & jstfm_access, & init_jstfm_fontinfo};
#line 54 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
struct fontop jfmop  =    {(char *)"jfm", & pathtype_init, & jfm_access, & init_jfm_fontinfo};
#line 61 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
struct biaccessinfo biainfo  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
static byte width[1024]  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
static byte param[128]  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
static int id  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
static int nt  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
static int lh  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
static int bc  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
static int ec  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
static int nw  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
static int np  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
static byte header[8]  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
int gentfm_access(char *proto , struct font_entry *fe , struct accarg *acca , int (*dev_is_format)() ,
                  char *type ) 
{ 
  BOOLEAN ok ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 88
  pave(fe->name, proto, acca);
#line 89
  tmp = access((char const   *)(fe->name), 4);
#line 89
  ok = tmp == 0;
  }
#line 92
  if (debug >= 1) {
    {
#line 93
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trying to access(%s) %s\n",
            type, fe->name);
    }
  }
#line 95
  if (ok) {
    {
#line 97
    fe->finfo = (void *)((struct finfo *)(& biainfo));
#line 98
    tmp___0 = (*dev_is_format)(fe, acca->acc_mode);
    }
#line 98
    return (tmp___0);
  }
#line 100
  return (0);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
int tfm_access(char *proto , struct font_entry *fe , struct accarg *acca ) 
{ 
  int tmp ;

  {
  {
#line 112
  tmp = gentfm_access(proto, fe, acca, & dev_is_tfm, (char *)"tfm");
  }
#line 112
  return (tmp);
}
}
#line 119
int null_markchar(int c ) ;
#line 120
void read_tfm_fontinfo(struct font_entry *fe ) ;
#line 121
void init_t1_fontinfo(struct font_entry *fe ) ;
#line 123
int dev_tfm_kind(struct font_entry *fe ) ;
#line 134
void init_ft_fontinfo(struct font_entry *fe ) ;
#line 115 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
void init_tfm_fontinfo(struct font_entry *fe ) 
{ 
  int tmp ;

  {
  {
#line 123
  tmp = dev_tfm_kind(fe);
  }
  {
#line 124
  if (tmp == 0) {
#line 124
    goto case_0;
  }
#line 129
  if (tmp == 1) {
#line 129
    goto case_1;
  }
#line 133
  if (tmp == 3) {
#line 133
    goto case_3;
  }
#line 133
  if (tmp == 2) {
#line 133
    goto case_3;
  }
#line 136
  goto switch_default;
  case_0: /* CIL Label */ 
#line 125
  *((struct bifont **)(& fe->finfo)) = (*((struct biaccessinfo **)(& fe->finfo)))->bf;
#line 126
  fe->dev_setchar = & null_markchar;
#line 127
  fe->fnt_readfontinfo = & read_tfm_fontinfo;
#line 128
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 130
  init_t1_fontinfo(fe);
  }
#line 131
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 134
  init_ft_fontinfo(fe);
  }
#line 135
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 137
  Fatal("%s implementation error: init_tfm_fontinfo", G_progname);
  }
  switch_break: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 151
int readtfm(FILE *fntfp___1 ) ;
#line 141 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
void read_tfm_finfo(struct font_entry *fe ) 
{ 
  FILE *fntfp___1 ;
  struct tfmchar_entry *ce ;
  int i ;
  SCALED s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 150
  openfontfile(fe);
#line 151
  fntfp___1 = fe->openfile;
#line 151
  readtfm(fntfp___1);
#line 152
  (*((struct tfmfntinfo **)(& fe->finfo)))->lastfntchar = ec;
#line 153
  s = (SCALED )fe->s;
#line 154
  tmp = makeuint(param + 20, 4);
#line 154
  (*((struct tfmfntinfo **)(& fe->finfo)))->em = (int )(((SCALED )tmp * s) / (SCALED )(1 << 20));
#line 155
  i = bc;
#line 155
  ce = (*((struct tfmfntinfo **)(& fe->finfo)))->ch + bc;
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! (i <= ec)) {
#line 155
      goto while_break;
    }
    {
#line 157
    ce->dev_char = (short )i;
#line 158
    tmp___0 = getuint(fntfp___1, 1);
#line 158
    tmp___1 = makeuint(width + 4 * tmp___0, 4);
#line 158
    ce->tfmw = (int )(((SCALED )tmp___1 * s) / (SCALED )(1 << 20));
#line 159
    fseek(fntfp___1, 3L, 1);
#line 155
    i ++;
#line 155
    ce ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return;
}
}
#line 173
void dev_tfm_initfe(struct font_entry *fe ) ;
#line 175
void dev_tfm_initfontdict(struct font_entry *fe ) ;
#line 163 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
void read_tfm_fontinfo(struct font_entry *fe ) 
{ 
  struct tfmfntinfo *tfmfi ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 169
  tmp = malloc((size_t )((unsigned int )sizeof(struct tfmfntinfo )));
#line 169
  tmp___0 = alloc_check(tmp, "tfmfont info");
#line 169
  tfmfi = (struct tfmfntinfo *)tmp___0;
#line 170
  tfmfi->tfm_bf = *((struct bifont **)(& fe->finfo));
#line 171
  *((struct tfmfntinfo **)(& fe->finfo)) = tfmfi;
#line 172
  read_tfm_finfo(fe);
#line 173
  dev_tfm_initfe(fe);
#line 174
  enc_read(tfmfi->tfm_bf);
#line 175
  dev_tfm_initfontdict(fe);
  }
#line 176
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
DEV_FONT tfm_fontdict(struct font_entry *fe , int c ) 
{ 


  {
#line 184
  return (fe->k);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
struct jsubshare *jsubshares  =    (struct jsubshare *)((void *)0);
#line 190 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
struct jsubshare **nextjss  =    & jsubshares;
#line 199
char *dev_jstfm_parent(struct bifont *bf , char *name ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
struct jsubshare *getjsubshare(struct font_entry *fe ) 
{ 
  int s ;
  struct jsubshare *jss ;
  struct bifont *jbf ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 201
  s = fe->s;
#line 202
  jbf = (*((struct biaccessinfo **)(& fe->finfo)))->bf;
#line 203
  jss = jsubshares;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! ((unsigned long )jss != (unsigned long )((void *)0))) {
#line 203
      goto while_break;
    }
#line 204
    if (jss->jss_s == s) {
#line 204
      if ((unsigned long )jss->jss_bf == (unsigned long )jbf) {
#line 205
        return (jss);
      }
    }
#line 203
    jss = jss->jss_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 207
  tmp = malloc((size_t )((unsigned int )sizeof(struct jsubshare )));
#line 207
  tmp___0 = alloc_check(tmp, "jsubshare");
#line 207
  jss = (struct jsubshare *)tmp___0;
#line 208
  jss->jss_s = s;
#line 209
  jss->jss_bf = jbf;
#line 210
  jss->jss_stat = 0;
#line 211
  tmp___1 = dev_jstfm_parent(jbf, fe->n);
#line 211
  jss->jss_parent = strsave(tmp___1);
#line 212
  jss->jss_next = (struct jsubshare *)((void *)0);
#line 213
  *nextjss = jss;
#line 214
  nextjss = & jss->jss_next;
  }
#line 215
  return (jss);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
int jstfm_access(char *proto , struct font_entry *fe , struct accarg *acca ) 
{ 
  int tmp ;

  {
  {
#line 225
  tmp = gentfm_access(proto, fe, acca, & dev_is_jstfm, (char *)"jstfm");
  }
#line 225
  return (tmp);
}
}
#line 234
void read_jstfm_fontinfo(struct font_entry *fe ) ;
#line 235
void init_jswl_fontinfo(struct font_entry *fe ) ;
#line 235
void init_jsft_fontinfo(struct font_entry *fe ) ;
#line 235
void init_jsvfl_fontinfo(struct font_entry *fe ) ;
#line 228 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
void init_jstfm_fontinfo(struct font_entry *fe ) 
{ 
  struct jstfmfntinfo *jsfi ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 237
  tmp = malloc((size_t )((unsigned int )sizeof(struct jstfmfntinfo )));
#line 237
  tmp___0 = alloc_check(tmp, "jstfmfont info");
#line 237
  jsfi = (struct jstfmfntinfo *)tmp___0;
#line 238
  jsfi->jsubfont = (*((struct biaccessinfo **)(& fe->finfo)))->jsubf;
#line 239
  jsfi->js_bf = (*((struct biaccessinfo **)(& fe->finfo)))->bf;
#line 240
  jsfi->js_share = getjsubshare(fe);
#line 241
  *((struct jstfmfntinfo **)(& fe->finfo)) = jsfi;
#line 242
  tmp___1 = dev_jstfm_kind(fe);
  }
  {
#line 243
  if (tmp___1 == 0) {
#line 243
    goto case_0;
  }
#line 247
  if (tmp___1 == 1) {
#line 247
    goto case_1;
  }
#line 251
  if (tmp___1 == 3) {
#line 251
    goto case_3;
  }
#line 251
  if (tmp___1 == 2) {
#line 251
    goto case_3;
  }
#line 255
  if (tmp___1 == 5) {
#line 255
    goto case_5;
  }
#line 255
  if (tmp___1 == 4) {
#line 255
    goto case_5;
  }
#line 258
  goto switch_default;
  case_0: /* CIL Label */ 
#line 244
  fe->dev_setchar = & null_markchar;
#line 245
  fe->fnt_readfontinfo = & read_jstfm_fontinfo;
#line 246
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 248
  init_jswl_fontinfo(fe);
  }
#line 249
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 252
  init_jsft_fontinfo(fe);
  }
#line 253
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 256
  init_jsvfl_fontinfo(fe);
  }
#line 257
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 259
  Fatal("%s implementation error: init_jstfm_fontinfo", G_progname);
  }
  switch_break: /* CIL Label */ ;
  }
#line 261
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
void read_jstfm_finfo(struct font_entry *fe ) 
{ 
  FILE *fntfp___1 ;
  struct jstfmchar_entry *ce ;
  int i ;
  SCALED s ;
  int subfont ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 273
  openfontfile(fe);
#line 274
  fntfp___1 = fe->openfile;
#line 274
  readtfm(fntfp___1);
  }
#line 275
  if (lh <= 2) {
    {
#line 276
    Fatal("%s is not japanese subfont", fe->name);
    }
  } else {
    {
#line 275
    tmp = makeuint(header, 4);
    }
#line 275
    if (tmp != 142857) {
      {
#line 276
      Fatal("%s is not japanese subfont", fe->name);
      }
    }
  }
#line 277
  subfont = (int )header[7];
#line 278
  if (subfont != (int )(*((struct jstfmfntinfo **)(& fe->finfo)))->jsubfont) {
    {
#line 279
    Warning("%s has subfont number %d", fe->name, subfont);
    }
  }
  {
#line 280
  (*((struct jstfmfntinfo **)(& fe->finfo)))->lastfntchar = ec;
#line 281
  s = (SCALED )fe->s;
#line 282
  tmp___0 = makeuint(param + 20, 4);
#line 282
  (*((struct jstfmfntinfo **)(& fe->finfo)))->em = (int )(((SCALED )tmp___0 * s) / (SCALED )(1 << 20));
#line 283
  i = bc;
#line 283
  ce = (*((struct jstfmfntinfo **)(& fe->finfo)))->ch + bc;
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (i <= ec)) {
#line 283
      goto while_break;
    }
    {
#line 284
    jsub_to_jis(subfont, i, & ce->dev_ku, & ce->dev_ten);
#line 285
    tmp___1 = getuint(fntfp___1, 1);
#line 285
    tmp___2 = makeuint(width + 4 * tmp___1, 4);
#line 285
    ce->tfmw = (int )(((SCALED )tmp___2 * s) / (SCALED )(1 << 20));
#line 286
    fseek(fntfp___1, 3L, 1);
#line 283
    i ++;
#line 283
    ce ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 289
  if (subfont == 1) {
#line 289
    if (bc == 2) {
      {
#line 290
      ce = ((*((struct jstfmfntinfo **)(& fe->finfo)))->ch + bc) - 1;
#line 291
      jsub_to_jis(subfont, bc - 1, & ce->dev_ku, & ce->dev_ten);
#line 292
      ce->tfmw = (ce + 1)->tfmw;
      }
    }
  }
#line 294
  return;
}
}
#line 303
void dev_jstfm_initfe(struct font_entry *fe ) ;
#line 306
void dev_jstfm_initfontdict(struct font_entry *fe ) ;
#line 296 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
void read_jstfm_fontinfo(struct font_entry *fe ) 
{ 
  struct jsubshare *jss ;

  {
  {
#line 302
  read_jstfm_finfo(fe);
#line 303
  dev_jstfm_initfe(fe);
#line 304
  jss = (*((struct jstfmfntinfo **)(& fe->finfo)))->js_share;
  }
#line 305
  if (jss->jss_stat < 2) {
    {
#line 306
    dev_jstfm_initfontdict(fe);
#line 307
    jss->jss_stat = 2;
    }
  }
#line 309
  (*((struct jstfmfntinfo **)(& fe->finfo)))->dev_font = (short )jss->jss_dev_font;
#line 310
  return;
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
DEV_FONT jstfm_fontdict(struct font_entry *fe , int c ) 
{ 


  {
#line 318
  return ((DEV_FONT )(*((struct jstfmfntinfo **)(& fe->finfo)))->dev_font);
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
int jfm_access(char *proto , struct font_entry *fe , struct accarg *acca ) 
{ 
  int tmp ;

  {
  {
#line 330
  tmp = gentfm_access(proto, fe, acca, & dev_is_jfm, (char *)"jfm");
  }
#line 330
  return (tmp);
}
}
#line 338
void read_jfm_fontinfo(struct font_entry *fe ) ;
#line 339
void init_wl_fontinfo(struct font_entry *fe ) ;
#line 339
void init_jft_fontinfo(struct font_entry *fe ) ;
#line 339
void init_vfl_fontinfo(struct font_entry *fe ) ;
#line 333 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
void init_jfm_fontinfo(struct font_entry *fe ) 
{ 
  int tmp ;

  {
  {
#line 341
  tmp = dev_jfm_kind(fe);
  }
  {
#line 342
  if (tmp == 0) {
#line 342
    goto case_0;
  }
#line 347
  if (tmp == 1) {
#line 347
    goto case_1;
  }
#line 351
  if (tmp == 3) {
#line 351
    goto case_3;
  }
#line 351
  if (tmp == 2) {
#line 351
    goto case_3;
  }
#line 355
  if (tmp == 5) {
#line 355
    goto case_5;
  }
#line 355
  if (tmp == 4) {
#line 355
    goto case_5;
  }
#line 358
  goto switch_default;
  case_0: /* CIL Label */ 
#line 343
  *((struct bifont **)(& fe->finfo)) = (*((struct biaccessinfo **)(& fe->finfo)))->bf;
#line 344
  fe->dev_setchar = & null_markchar;
#line 345
  fe->fnt_readfontinfo = & read_jfm_fontinfo;
#line 346
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 348
  init_wl_fontinfo(fe);
  }
#line 349
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 352
  init_jft_fontinfo(fe);
  }
#line 353
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 356
  init_vfl_fontinfo(fe);
  }
#line 357
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 359
  Fatal("%s implementation error: init_jfm_fontinfo", G_progname);
  }
  switch_break: /* CIL Label */ ;
  }
#line 361
  return;
}
}
#line 374
int readjfm(FILE *fntfp___1 ) ;
#line 363 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
void read_jfm_finfo(struct font_entry *fe ) 
{ 
  FILE *fntfp___1 ;
  struct jfmtype_entry *te ;
  struct jfmchar_entry *ce ;
  int i ;
  SCALED s ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 373
  openfontfile(fe);
#line 374
  fntfp___1 = fe->openfile;
#line 374
  tmp = readjfm(fntfp___1);
  }
#line 374
  if (! tmp) {
    {
#line 375
    Fatal("%s is not jfm file", fe->name);
    }
  }
  {
#line 376
  (*((struct jfmfntinfo **)(& fe->finfo)))->nctype = nt;
#line 377
  tmp___0 = malloc((size_t )((unsigned int )sizeof(struct jfmtype_entry ) * (unsigned int )nt));
#line 377
  tmp___1 = alloc_check(tmp___0, "jfmtype table");
#line 377
  (*((struct jfmfntinfo **)(& fe->finfo)))->ctype = (struct jfmtype_entry *)tmp___1;
#line 378
  i = 0;
#line 378
  te = (*((struct jfmfntinfo **)(& fe->finfo)))->ctype;
  }
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! (i < nt)) {
#line 378
      goto while_break;
    }
    {
#line 379
    te->jfm_code = getuint(fntfp___1, 2);
#line 380
    te->jfm_type = getuint(fntfp___1, 2);
#line 378
    i ++;
#line 378
    te ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 382
  (*((struct jfmfntinfo **)(& fe->finfo)))->lasttypecode = (te - 1)->jfm_code;
#line 383
  tmp___2 = malloc((size_t )((unsigned int )sizeof(struct jfmchar_entry ) * (unsigned int )(ec + 1)));
#line 383
  tmp___3 = alloc_check(tmp___2, "jfmchar table");
#line 383
  (*((struct jfmfntinfo **)(& fe->finfo)))->ch = (struct jfmchar_entry *)tmp___3;
#line 384
  s = (SCALED )fe->s;
#line 385
  tmp___4 = makeuint(param + 20, 4);
#line 385
  (*((struct jfmfntinfo **)(& fe->finfo)))->em = (int )(((SCALED )tmp___4 * s) / (SCALED )(1 << 20));
#line 386
  i = bc;
#line 386
  ce = (*((struct jfmfntinfo **)(& fe->finfo)))->ch + bc;
  }
  {
#line 386
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 386
    if (! (i <= ec)) {
#line 386
      goto while_break___0;
    }
    {
#line 387
    tmp___5 = getuint(fntfp___1, 1);
#line 387
    tmp___6 = makeuint(width + 4 * tmp___5, 4);
#line 387
    ce->tfmw = (int )(((SCALED )tmp___6 * s) / (SCALED )(1 << 20));
#line 388
    fseek(fntfp___1, 3L, 1);
#line 386
    i ++;
#line 386
    ce ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 390
  return;
}
}
#line 402
void dev_jfm_initfe(struct font_entry *fe , int id___0 ) ;
#line 403
void dev_jfm_initfontdict(struct font_entry *fe ) ;
#line 392 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
void read_jfm_fontinfo(struct font_entry *fe ) 
{ 
  struct jfmfntinfo *jfmfi ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 398
  tmp = malloc((size_t )((unsigned int )sizeof(struct jfmfntinfo )));
#line 398
  tmp___0 = alloc_check(tmp, "jfmfont info");
#line 398
  jfmfi = (struct jfmfntinfo *)tmp___0;
#line 399
  jfmfi->jfm_bf = *((struct bifont **)(& fe->finfo));
#line 400
  *((struct jfmfntinfo **)(& fe->finfo)) = jfmfi;
#line 401
  read_jfm_finfo(fe);
#line 402
  dev_jfm_initfe(fe, id);
#line 403
  dev_jfm_initfontdict(fe);
  }
#line 404
  return;
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
int getctype(int c , struct jfmfntinfo *jfmfi ) 
{ 
  int m ;
  int left ;
  int right ;
  struct jfmtype_entry *te ;
  int code ;

  {
#line 415
  if (c > jfmfi->lasttypecode) {
#line 416
    return (0);
  }
#line 417
  left = 0;
#line 417
  right = jfmfi->nctype;
#line 417
  te = jfmfi->ctype;
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (left <= right)) {
#line 417
      goto while_break;
    }
#line 418
    m = (left + right) / 2;
#line 419
    code = (te + m)->jfm_code;
#line 419
    if (c < code) {
#line 420
      right = m - 1;
    } else
#line 421
    if (c > code) {
#line 422
      left = m + 1;
    } else
#line 423
    if (c == code) {
#line 424
      return ((te + m)->jfm_type);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  return (0);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
int readtfm(FILE *fntfp___1 ) 
{ 
  int tmp ;

  {
  {
#line 435
  fseek(fntfp___1, 2L, 0);
#line 436
  lh = getuint(fntfp___1, 2);
#line 437
  bc = getuint(fntfp___1, 2);
#line 438
  ec = getuint(fntfp___1, 2);
#line 439
  nw = getuint(fntfp___1, 2);
#line 440
  fseek(fntfp___1, 22L, 0);
#line 441
  np = getuint(fntfp___1, 2);
#line 442
  fseek(fntfp___1, 8L, 1);
  }
#line 443
  if ((lh - 2) * 4 > 8) {
#line 443
    tmp = 8;
  } else {
#line 443
    tmp = (lh - 2) * 4;
  }
  {
#line 443
  getbytes(fntfp___1, header, tmp);
#line 444
  fseek(fntfp___1, (long )(((6 + lh) + (ec - bc)) + 1) * 4L, 0);
#line 445
  getbytes(fntfp___1, width, 4 * nw);
#line 446
  fseek(fntfp___1, (long )(- np) * 4L, 2);
#line 447
  getbytes(fntfp___1, param, 4 * np);
#line 448
  fseek(fntfp___1, (long )(6 + lh) * 4L, 0);
  }
#line 449
  return (0);
}
}
#line 451 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.c"
int readjfm(FILE *fntfp___1 ) 
{ 


  {
  {
#line 454
  id = getuint(fntfp___1, 2);
  }
#line 454
  if (id != 11) {
#line 454
    if (id != 9) {
#line 455
      return (0);
    }
  }
  {
#line 456
  nt = getuint(fntfp___1, 2);
#line 457
  fseek(fntfp___1, 2L, 1);
#line 458
  lh = getuint(fntfp___1, 2);
#line 459
  bc = getuint(fntfp___1, 2);
#line 460
  ec = getuint(fntfp___1, 2);
#line 461
  nw = getuint(fntfp___1, 2);
#line 462
  fseek(fntfp___1, 26L, 0);
#line 463
  np = getuint(fntfp___1, 2);
#line 464
  fseek(fntfp___1, (long )((((7 + lh) + nt) + (ec - bc)) + 1) * 4L, 0);
#line 465
  getbytes(fntfp___1, width, 4 * nw);
#line 466
  fseek(fntfp___1, (long )(- np) * 4L, 2);
#line 467
  getbytes(fntfp___1, param, 4 * np);
#line 468
  fseek(fntfp___1, (long )(7 + lh) * 4L, 0);
  }
#line 469
  return (1);
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 96 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
struct fontop *findfontop(char *type ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
int functype_init(char *desc , struct funcfont **ff ) ;
#line 16
int functype_access(struct funcfont *ff , struct font_entry *fe , struct accarg *acca ) ;
#line 17
void init_func_fontinfo(struct font_entry *fe ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
struct fontop funcop  =    {(char *)"func", & functype_init, & functype_access, & init_func_fontinfo};
#line 36
struct fontop *findcondop(char *type ) ;
#line 37
struct fontop falseop ;
#line 25 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
int functype_init(char *desc , struct funcfont **ff ) 
{ 
  char *d ;
  char *e ;
  struct fontop *fop ;
  BOOLEAN body ;
  int numbody ;
  struct ffinfo *ffi ;
  struct funcfont *ffs___0 ;
  struct funcfont **nextff ;
  struct funcfont *ffnew ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 39
  ffs___0 = (struct funcfont *)((void *)0);
#line 39
  nextff = & ffs___0;
#line 39
  numbody = 0;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 40
    tmp = getstrtok(desc, '(', & d);
    }
#line 40
    if (! tmp) {
#line 41
      return (0);
    }
    {
#line 42
    fop = findcondop(desc);
    }
#line 42
    if ((unsigned long )fop != (unsigned long )((void *)0)) {
#line 43
      body = 0;
    } else {
      {
#line 44
      fop = findfontop(desc);
      }
#line 44
      if ((unsigned long )fop != (unsigned long )((void *)0)) {
#line 44
        if ((unsigned long )fop != (unsigned long )(& funcop)) {
#line 45
          body = 1;
#line 46
          numbody ++;
        } else {
          {
#line 48
          Warning("illegal functional font %s", desc);
          }
#line 49
          return (0);
        }
      } else {
        {
#line 48
        Warning("illegal functional font %s", desc);
        }
#line 49
        return (0);
      }
    }
    {
#line 51
    tmp___0 = getstrtok(d, ')', & e);
    }
#line 51
    if (! tmp___0) {
#line 52
      return (0);
    }
    {
#line 53
    tmp___1 = (*(fop->fo_init))(d, & ffi);
    }
#line 53
    if (! tmp___1) {
#line 54
      return (0);
    }
    {
#line 55
    tmp___2 = malloc((size_t )((unsigned int )sizeof(struct funcfont )));
#line 55
    tmp___3 = alloc_check(tmp___2, "funcfont init");
#line 55
    ffnew = (struct funcfont *)tmp___3;
#line 56
    ffnew->ff_fop = fop;
#line 57
    ffnew->ff_body = body;
#line 58
    ffnew->ff_info = ffi;
#line 59
    ffnew->ff_next = (struct funcfont *)((void *)0);
#line 60
    *nextff = ffnew;
#line 61
    nextff = & ffnew->ff_next;
#line 62
    skipstrblank(e, & d);
    }
#line 63
    if ((int )*d == 0) {
#line 64
      goto while_break;
    } else
#line 65
    if ((int )*d == 44) {
      {
#line 66
      skipstrblank(e + 1, & desc);
      }
    } else {
#line 68
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  if (numbody == 0) {
    {
#line 71
    tmp___4 = malloc((size_t )((unsigned int )sizeof(struct funcfont )));
#line 71
    tmp___5 = alloc_check(tmp___4, "funcfont init");
#line 71
    ffnew = (struct funcfont *)tmp___5;
#line 72
    ffnew->ff_fop = & falseop;
#line 73
    ffnew->ff_body = 1;
#line 74
    ffnew->ff_info = (struct ffinfo *)((void *)0);
#line 75
    ffnew->ff_next = (struct funcfont *)((void *)0);
#line 76
    *nextff = ffnew;
    }
  }
#line 78
  *ff = ffs___0;
#line 79
  return (1);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
int functype_access(struct funcfont *ff , struct font_entry *fe , struct accarg *acca ) 
{ 
  struct funcfont *ffnew ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! ((unsigned long )ff != (unsigned long )((void *)0))) {
#line 89
      goto while_break;
    }
#line 91
    if (debug >= 1) {
      {
#line 92
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trying to apply %s to %s\n",
              (ff->ff_fop)->fo_type, fe->n);
      }
    }
    {
#line 95
    tmp___1 = (*((ff->ff_fop)->fo_access))(ff->ff_info, fe, acca);
    }
#line 95
    if (tmp___1) {
#line 96
      if (ff->ff_body) {
        {
#line 97
        tmp = malloc((size_t )((unsigned int )sizeof(struct funcfont )));
#line 97
        tmp___0 = alloc_check(tmp, "funcfont access");
#line 97
        ffnew = (struct funcfont *)tmp___0;
#line 98
        *ffnew = *ff;
#line 99
        ffnew->ff_info = (struct ffinfo *)fe->finfo;
#line 100
        fe->finfo = (void *)((struct finfo *)ffnew);
        }
      }
    } else {
#line 103
      return (0);
    }
#line 89
    ff = ff->ff_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return (1);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
void init_func_fontinfo(struct font_entry *fe ) 
{ 
  struct funcfont *ff ;

  {
  {
#line 114
  ff = (struct funcfont *)fe->finfo;
#line 115
  fe->finfo = (void *)((struct finfo *)ff->ff_info);
#line 116
  (*((ff->ff_fop)->fo_initfontinfo))(fe);
  }
#line 117
  return;
}
}
#line 122
struct fontop existop ;
#line 122
struct fontop preop ;
#line 122
struct fontop notpreop ;
#line 128 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
struct fontop *condops[6]  = {      & cexecop,      & existop,      & preop,      & notpreop, 
        & falseop,      (struct fontop *)((void *)0)};
#line 137 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
struct fontop *findcondop(char *type ) 
{ 
  struct fontop **fo ;
  int tmp ;

  {
#line 143
  fo = condops;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! ((unsigned long )*fo != (unsigned long )((void *)0))) {
#line 143
      goto while_break;
    }
    {
#line 144
    tmp = strcmp((char const   *)(*fo)->fo_type, (char const   *)type);
    }
#line 144
    if (tmp == 0) {
#line 145
      return (*fo);
    }
#line 143
    fo ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return ((struct fontop *)((void *)0));
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
void init_dummy_fontinfo(struct font_entry *fe ) 
{ 


  {
  {
#line 154
  Fatal("%s implementation error: init_dummy_fontinfo", G_progname);
  }
#line 155
  return;
}
}
#line 158
int false_access(char *proto , struct font_entry *fe , struct accarg *acca ) ;
#line 159 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
struct fontop falseop  =    {(char *)"false", & pathtype_init, & false_access, (void (*)())(& init_dummy_fontinfo)};
#line 167 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
int false_access(char *proto , struct font_entry *fe , struct accarg *acca ) 
{ 


  {
#line 173
  return (0);
}
}
#line 176
int exist_access(char *proto , struct font_entry *fe , struct accarg *acca ) ;
#line 177 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
struct fontop existop  =    {(char *)"exist", & pathtype_init, & exist_access, (void (*)())(& init_dummy_fontinfo)};
#line 184 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
int exist_access(char *proto , struct font_entry *fe , struct accarg *acca ) 
{ 
  BOOLEAN ok ;
  int tmp ;

  {
  {
#line 208
  pave(fe->name, proto, acca);
#line 209
  tmp = access((char const   *)(fe->name), 4);
#line 209
  ok = tmp == 0;
  }
#line 212
  if (debug >= 1) {
    {
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  condition: exist %s\n",
            fe->name);
    }
  }
#line 215
  return (ok);
}
}
#line 218
int pre_access(char *proto , struct font_entry *fe , struct accarg *acca ) ;
#line 219
int notpre_access(char *proto , struct font_entry *fe , struct accarg *acca ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
struct fontop preop  =    {(char *)"pre", & pathtype_init, & pre_access, (void (*)())(& init_dummy_fontinfo)};
#line 226 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
struct fontop notpreop  =    {(char *)"!pre", & pathtype_init, & notpre_access, (void (*)())(& init_dummy_fontinfo)};
#line 233 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
int pre_access(char *proto , struct font_entry *fe , struct accarg *acca ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 240
  if (debug >= 1) {
    {
#line 241
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  condition: pre(%s) %s\n",
            proto, fe->n);
    }
  }
  {
#line 243
  tmp = strlen((char const   *)proto);
#line 243
  tmp___0 = strncmp((char const   *)(fe->n), (char const   *)proto, tmp);
  }
#line 243
  if (tmp___0) {
#line 243
    tmp___1 = 0;
  } else {
#line 243
    tmp___1 = 1;
  }
#line 243
  return (tmp___1);
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/funcfont.c"
int notpre_access(char *proto , struct font_entry *fe , struct accarg *acca ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
#line 253
  if (debug >= 1) {
    {
#line 254
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  condition: !pre(%s) %s\n",
            proto, fe->n);
    }
  }
  {
#line 256
  tmp = strlen((char const   *)proto);
#line 256
  tmp___0 = strncmp((char const   *)(fe->n), (char const   *)proto, tmp);
  }
#line 256
  return (tmp___0);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 113 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
void putint(int n ) ;
#line 114
void putoct(int n ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/io.c"
void getbytes(FILE *fp , byte *cp , int n ) 
{ 


  {
  {
#line 16
  fread((void */* __restrict  */)((char *)cp), (size_t )1, (size_t )n, (FILE */* __restrict  */)fp);
  }
#line 17
  return;
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/io.c"
void skipbytes(FILE *fp , int n ) 
{ 


  {
  {
#line 24
  fseek(fp, (long )n, 1);
  }
#line 25
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/io.c"
int getuint(FILE *fp , int n ) 
{ 
  byte s[sizeof(int )] ;
  int tmp ;

  {
  {
#line 40
  fread((void */* __restrict  */)((char *)(s)), (size_t )1, (size_t )n, (FILE */* __restrict  */)fp);
#line 41
  tmp = makeuint(s, n);
  }
#line 41
  return (tmp);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/io.c"
int getint(FILE *fp , int n ) 
{ 
  byte s[sizeof(int )] ;
  int tmp ;

  {
  {
#line 57
  fread((void */* __restrict  */)((char *)(s)), (size_t )1, (size_t )n, (FILE */* __restrict  */)fp);
#line 58
  tmp = makeint(s, n);
  }
#line 58
  return (tmp);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/io.c"
char *digit  =    (char *)"0123456789ABCDEF";
#line 70 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/io.c"
void putint(int n ) 
{ 
  char buf[10] ;
  char *b ;
  char *tmp ;

  {
#line 77
  if (n == 0) {
    {
#line 78
    _IO_putc('0', outfp);
    }
  } else {
#line 80
    if (n < 0) {
      {
#line 81
      _IO_putc('-', outfp);
#line 82
      n = - n;
      }
    }
#line 84
    b = buf;
    {
#line 84
    while (1) {
      while_continue: /* CIL Label */ ;
#line 84
      if (! (n > 0)) {
#line 84
        goto while_break;
      }
#line 85
      tmp = b;
#line 85
      b ++;
#line 85
      *tmp = *(digit + n % 10);
#line 86
      n /= 10;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 88
      if (! ((unsigned long )b > (unsigned long )(buf))) {
#line 88
        goto while_break___0;
      }
      {
#line 89
      b --;
#line 89
      _IO_putc((int )*b, outfp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 91
  _IO_putc(' ', outfp);
  }
#line 92
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/io.c"
void putoct(int n ) 
{ 


  {
  {
#line 104
  _IO_putc('\\', outfp);
#line 105
  _IO_putc((int )*(digit + ((n & 192) >> 6)), outfp);
#line 106
  _IO_putc((int )*(digit + ((n & 56) >> 3)), outfp);
#line 107
  _IO_putc((int )*(digit + (n & 7)), outfp);
  }
#line 108
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rastfont.h"
struct rastfntinfo *alloc_rastfinfo(int nchars , int init , struct rastinitfontinfo *rii ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rastfont.c"
struct rastaccessinfo raccinfo  ;
#line 7 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rastfont.c"
int rast_mag(struct font_entry *fe , struct accarg *acca , int t ) 
{ 


  {
#line 12
  fe->finfo = (void *)((struct finfo *)(& raccinfo));
  {
#line 15
  if (acca->acc_mode == 4) {
#line 15
    goto case_4;
  }
#line 15
  if (acca->acc_mode == 0) {
#line 15
    goto case_4;
  }
#line 19
  if (acca->acc_mode == 1) {
#line 19
    goto case_1;
  }
#line 25
  if (acca->acc_mode == 2) {
#line 25
    goto case_2;
  }
#line 13
  goto switch_break;
  case_4: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 16
  acca->pv_mag = (int )((double )((acca->actmagfact * (float )resolution) * (float )t) + 0.5);
#line 17
  raccinfo.corrfact = (float )1;
#line 18
  goto switch_break;
  case_1: /* CIL Label */ 
#line 20
  if ((int )((double )((acca->actmagfact * (float )resolution) * (float )t) + 0.5) != acca->reqmag) {
#line 21
    return (0);
  }
#line 22
  acca->pv_mag = acca->submag;
#line 23
  raccinfo.corrfact = (float )acca->reqmag / (float )acca->submag;
#line 24
  goto switch_break;
  case_2: /* CIL Label */ 
#line 26
  acca->pv_mag = (int )((double )((acca->stepmagfact * (float )resolution) * (float )t) + 0.5);
#line 27
  raccinfo.corrfact = acca->rawmagfact / acca->stepmagfact;
#line 28
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 30
  return (0);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rastfont.c"
int rast_debug_report(struct font_entry *fe , struct accarg *acca , BOOLEAN ok , char *type ) 
{ 


  {
#line 39
  if (debug >= 1) {
#line 40
    if (acca->acc_mode == 0) {
      {
#line 41
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trying to access(%s) %s\n",
              type, fe->name);
      }
    } else
#line 40
    if (acca->acc_mode == 4) {
      {
#line 41
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trying to access(%s) %s\n",
              type, fe->name);
      }
    } else
#line 42
    if (ok) {
      {
#line 43
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trying to access[%d](%s) %s\n",
              acca->acc_mode, type, fe->name);
      }
    }
  }
#line 46
  return (0);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rastfont.c"
int check_id(char *name , int id___0 ) 
{ 
  FILE *tfp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 55
  tfp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 55
  if ((unsigned long )tfp == (unsigned long )((void *)0)) {
    {
#line 56
    Fatal("FNT file %s could not be opened", name);
    }
  }
  {
#line 57
  tmp = getuint(tfp, 4);
  }
#line 57
  if (tmp != id___0) {
    {
#line 58
    fclose(tfp);
    }
#line 59
    return (0);
  }
  {
#line 61
  fseek(tfp, -4L, 2);
#line 62
  tmp___0 = getuint(tfp, 4);
  }
#line 62
  if (tmp___0 != id___0) {
    {
#line 63
    fclose(tfp);
    }
#line 64
    return (0);
  }
  {
#line 66
  fclose(tfp);
  }
#line 67
  return (1);
}
}
#line 75
int rast_markchar(int c ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rastfont.c"
int init_rast_fontinfo(struct font_entry *fe ) 
{ 
  int i ;
  struct rastinitfontinfo *k ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 77
  fe->dev_setchar = & rast_markchar;
#line 78
  tmp = malloc((unsigned long )((unsigned int )sizeof(struct rastinitfontinfo )) + 255UL * sizeof(Boolean ));
#line 78
  tmp___0 = alloc_check(tmp, "rastinitfontinfo");
#line 78
  k = (struct rastinitfontinfo *)tmp___0;
#line 82
  i = 0;
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i <= 255)) {
#line 82
      goto while_break;
    }
#line 83
    k->mark[i] = (Boolean )0;
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  k->maxc = 0;
#line 85
  k->corrfact = (*((struct rastaccessinfo **)(& fe->finfo)))->corrfact;
#line 86
  *((struct rastinitfontinfo **)(& fe->finfo)) = k;
#line 87
  return (0);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rastfont.c"
int rast_markchar(int c ) 
{ 


  {
#line 92
  if (c > 255) {
    {
#line 93
    Warning("char %d in %s ignored", c, curfontent->name);
    }
#line 94
    return;
  }
#line 96
  (*((struct rastinitfontinfo **)(& curfontent->finfo)))->mark[c] = (Boolean )1;
#line 97
  if (c > (*((struct rastinitfontinfo **)(& curfontent->finfo)))->maxc) {
#line 98
    (*((struct rastinitfontinfo **)(& curfontent->finfo)))->maxc = c;
  }
#line 99
  return (0);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rastfont.c"
struct rastfntinfo *alloc_rastfinfo(int nchars , int init , struct rastinitfontinfo *rii ) 
{ 
  struct rastfntinfo *rfi ;
  struct rastchar_entry *ce ;
  int i ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 110
  tmp = malloc((unsigned long )((unsigned int )sizeof(struct rastfntinfo )) + (unsigned long )(nchars - 1) * sizeof(struct rastchar_entry ));
#line 110
  tmp___0 = alloc_check(tmp, "rastfont info");
#line 110
  rfi = (struct rastfntinfo *)tmp___0;
  }
#line 114
  if (init) {
#line 115
    i = 0;
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;
#line 115
      if (! (i < nchars)) {
#line 115
        goto while_break;
      }
#line 116
      ce = & rfi->ch[i];
#line 117
      ce->width = (unsigned short)0;
#line 118
      ce->height = (unsigned short)0;
#line 119
      ce->xoffset = (short)0;
#line 120
      ce->yoffset = (short)0;
#line 121
      ce->dev_font = (short)-1;
#line 123
      ce->where.fileoffset = 4294967295U;
#line 124
      ce->tfmw = 0;
#line 115
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 126
  rfi->corrfact = rii->corrfact;
#line 127
  return (rfi);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rastfont.c"
DEV_FONT rast_fontdict(struct font_entry *fe , int c ) 
{ 


  {
#line 137
  return ((DEV_FONT )(*((struct rastfntinfo **)(& fe->finfo)))->ch[c].dev_font);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.h"
char *stdex_type1_charname(int c ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
char *std_char_names[256]  = 
#line 11 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
  {      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)"space",      (char *)"exclam",      (char *)"quotedbl",      (char *)"numbersign", 
        (char *)"dollar",      (char *)"percent",      (char *)"ampersand",      (char *)"quoteright", 
        (char *)"parenleft",      (char *)"parenright",      (char *)"asterisk",      (char *)"plus", 
        (char *)"comma",      (char *)"hyphen",      (char *)"period",      (char *)"slash", 
        (char *)"zero",      (char *)"one",      (char *)"two",      (char *)"three", 
        (char *)"four",      (char *)"five",      (char *)"six",      (char *)"seven", 
        (char *)"eight",      (char *)"nine",      (char *)"colon",      (char *)"semicolon", 
        (char *)"less",      (char *)"equal",      (char *)"greater",      (char *)"question", 
        (char *)"at",      (char *)"A",      (char *)"B",      (char *)"C", 
        (char *)"D",      (char *)"E",      (char *)"F",      (char *)"G", 
        (char *)"H",      (char *)"I",      (char *)"J",      (char *)"K", 
        (char *)"L",      (char *)"M",      (char *)"N",      (char *)"O", 
        (char *)"P",      (char *)"Q",      (char *)"R",      (char *)"S", 
        (char *)"T",      (char *)"U",      (char *)"V",      (char *)"W", 
        (char *)"X",      (char *)"Y",      (char *)"Z",      (char *)"bracketleft", 
        (char *)"backslash",      (char *)"bracketright",      (char *)"asciicircum",      (char *)"underscore", 
        (char *)"quoteleft",      (char *)"a",      (char *)"b",      (char *)"c", 
        (char *)"d",      (char *)"e",      (char *)"f",      (char *)"g", 
        (char *)"h",      (char *)"i",      (char *)"j",      (char *)"k", 
        (char *)"l",      (char *)"m",      (char *)"n",      (char *)"o", 
        (char *)"p",      (char *)"q",      (char *)"r",      (char *)"s", 
        (char *)"t",      (char *)"u",      (char *)"v",      (char *)"w", 
        (char *)"x",      (char *)"y",      (char *)"z",      (char *)"braceleft", 
        (char *)"bar",      (char *)"braceright",      (char *)"asciitilde",      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)"exclamdown",      (char *)"cent",      (char *)"sterling", 
        (char *)"fraction",      (char *)"yen",      (char *)"florin",      (char *)"section", 
        (char *)"currency",      (char *)"quotesingle",      (char *)"quotedblleft",      (char *)"guillemotleft", 
        (char *)"guilsinglleft",      (char *)"guilsinglright",      (char *)"fi",      (char *)"fl", 
        (char *)((void *)0),      (char *)"endash",      (char *)"dagger",      (char *)"daggerdbl", 
        (char *)"periodcentered",      (char *)((void *)0),      (char *)"paragraph",      (char *)"bullet", 
        (char *)"quotesinglbase",      (char *)"quotedblbase",      (char *)"quotedblright",      (char *)"guillemotright", 
        (char *)"ellipsis",      (char *)"perthousand",      (char *)((void *)0),      (char *)"questiondown", 
        (char *)((void *)0),      (char *)"grave",      (char *)"acute",      (char *)"circumflex", 
        (char *)"tilde",      (char *)"macron",      (char *)"breve",      (char *)"dotaccent", 
        (char *)"dieresis",      (char *)((void *)0),      (char *)"ring",      (char *)"cedilla", 
        (char *)((void *)0),      (char *)"hungarumlaut",      (char *)"ogonek",      (char *)"caron", 
        (char *)"emdash",      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)"AE",      (char *)((void *)0),      (char *)"ordfeminine", 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)"Lslash",      (char *)"Oslash",      (char *)"OE",      (char *)"ordmasculine", 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)"ae",      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)"dotlessi",      (char *)((void *)0),      (char *)((void *)0), 
        (char *)"lslash",      (char *)"oslash",      (char *)"oe",      (char *)"germandbls", 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0)};
#line 52 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
char *extra_char_names[256]  = 
#line 52
  {      (char *)"c00",      (char *)"c01",      (char *)"c02",      (char *)"c03", 
        (char *)"c04",      (char *)"c05",      (char *)"c06",      (char *)"c07", 
        (char *)"c08",      (char *)"c09",      (char *)"c0A",      (char *)"c0B", 
        (char *)"c0C",      (char *)"c0D",      (char *)"c0E",      (char *)"c0F", 
        (char *)"c10",      (char *)"c11",      (char *)"c12",      (char *)"c13", 
        (char *)"c14",      (char *)"c15",      (char *)"c16",      (char *)"c17", 
        (char *)"c18",      (char *)"c19",      (char *)"c1A",      (char *)"c1B", 
        (char *)"c1C",      (char *)"c1D",      (char *)"c1E",      (char *)"c1F", 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)"c7F", 
        (char *)"c80",      (char *)"c81",      (char *)"c82",      (char *)"c83", 
        (char *)"c84",      (char *)"c85",      (char *)"c86",      (char *)"c87", 
        (char *)"c88",      (char *)"c89",      (char *)"c8A",      (char *)"c8B", 
        (char *)"c8C",      (char *)"c8D",      (char *)"c8E",      (char *)"c8F", 
        (char *)"c90",      (char *)"c91",      (char *)"c92",      (char *)"c93", 
        (char *)"c94",      (char *)"c95",      (char *)"c96",      (char *)"c97", 
        (char *)"c98",      (char *)"c99",      (char *)"c9A",      (char *)"c9B", 
        (char *)"c9C",      (char *)"c9D",      (char *)"c9E",      (char *)"c9F", 
        (char *)"cA0",      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)"cB0",      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)"cB5",      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)"cBE",      (char *)((void *)0), 
        (char *)"cC0",      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)"cC9",      (char *)((void *)0),      (char *)((void *)0), 
        (char *)"cCC",      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)"cD1",      (char *)"cD2",      (char *)"cD3", 
        (char *)"cD4",      (char *)"cD5",      (char *)"cD6",      (char *)"cD7", 
        (char *)"cD8",      (char *)"cD9",      (char *)"cDA",      (char *)"cDB", 
        (char *)"cDC",      (char *)"cDD",      (char *)"cDE",      (char *)"cDF", 
        (char *)"cE0",      (char *)((void *)0),      (char *)"cE2",      (char *)((void *)0), 
        (char *)"cE4",      (char *)"cE5",      (char *)"cE6",      (char *)"cE7", 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)"cEC",      (char *)"cED",      (char *)"cEE",      (char *)"cEF", 
        (char *)"cF0",      (char *)((void *)0),      (char *)"cF2",      (char *)"cF3", 
        (char *)"cF4",      (char *)((void *)0),      (char *)"cF6",      (char *)"cF7", 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)"cFC",      (char *)"cFD",      (char *)"cFE",      (char *)"cFF"};
#line 87 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
char *stdex_type1_charname(int c ) 
{ 


  {
#line 91
  if ((unsigned long )std_char_names[c] != (unsigned long )((void *)0)) {
#line 92
    return (std_char_names[c]);
  }
#line 93
  return (extra_char_names[c]);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
int stdex_type1_reencoding(Boolean *mark , int maxc , unsigned char *remap ) 
{ 
  int i ;
  char *tmp ;

  {
  {
#line 103
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/Encoding %d array\n",
          maxc + 1);
#line 104
  i = 0;
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (i <= maxc)) {
#line 104
      goto while_break;
    }
#line 105
    if (*(mark + i)) {
      {
#line 106
      tmp = stdex_type1_charname((int )*(remap + i));
#line 106
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"dup %d /%s put\n",
              i, tmp);
      }
    }
#line 104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"readonly def\n");
  }
#line 108
  return (0);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
int stdex_type1_encoding(Boolean *mark , int maxc , unsigned char *remap ) 
{ 
  int i ;

  {
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i <= maxc)) {
#line 117
      goto while_break;
    }
#line 118
    if (*(mark + i)) {
#line 118
      if ((unsigned long )std_char_names[*(remap + i)] == (unsigned long )((void *)0)) {
        {
#line 119
        stdex_type1_reencoding(mark, maxc, remap);
        }
#line 120
        return;
      }
    }
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/Encoding StandardEncoding def\n");
  }
#line 123
  return (0);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
static char cname[4]  ;
#line 125 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
char *cnum_type1_charname(int c ) 
{ 


  {
  {
#line 131
  sprintf((char */* __restrict  */)(cname), (char const   */* __restrict  */)"c%02X",
          c);
  }
#line 132
  return (cname);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
int cnum_type1_encoding(int nc ) 
{ 
  int n ;
  int i ;
  int j ;

  {
#line 140
  if (nc > 224) {
#line 140
    n = 256;
  } else {
#line 140
    n = 32 + nc;
  }
  {
#line 141
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/Encoding %d array\n",
          n);
#line 142
  i = 32;
#line 142
  j = 0;
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (i < n)) {
#line 142
      goto while_break;
    }
    {
#line 143
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"dup %d /c%02X put",
            i, i);
    }
#line 144
    if (j % 4 == 3) {
      {
#line 145
      _IO_putc('\n', outfp);
      }
    } else {
      {
#line 147
      _IO_putc(' ', outfp);
      }
    }
#line 142
    i ++;
#line 142
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  i = 0;
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 149
    if (! (i < nc - 224)) {
#line 149
      goto while_break___0;
    }
    {
#line 150
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"dup %d /c%02X put",
            i, i);
    }
#line 151
    if (j % 4 == 3) {
      {
#line 152
      _IO_putc('\n', outfp);
      }
    } else {
      {
#line 154
      _IO_putc(' ', outfp);
      }
    }
#line 149
    i ++;
#line 149
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 156
  if ((j - 1) % 4 != 3) {
    {
#line 157
    _IO_putc('\n', outfp);
    }
  }
  {
#line 158
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"readonly def\n");
  }
#line 159
  return (0);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
int reencode(char **glyphs , Boolean *mark , int maxc , unsigned char *remap ) 
{ 
  int i ;
  int j ;
  char *tmp ;
  int tmp___0 ;

  {
#line 169
  i = 0;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (i <= maxc)) {
#line 169
      goto while_break;
    }
#line 170
    if (*(mark + i)) {
#line 171
      *(remap + i) = (unsigned char )i;
#line 172
      j = 0;
      {
#line 172
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 172
        if (! (j <= 255)) {
#line 172
          goto while_break___0;
        }
        {
#line 173
        tmp = stdex_type1_charname(j);
#line 173
        tmp___0 = strcmp((char const   *)*(glyphs + i), (char const   *)tmp);
        }
#line 173
        if (tmp___0 == 0) {
#line 174
          *(remap + i) = (unsigned char )j;
#line 175
          goto while_break___0;
        }
#line 172
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 169
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return (0);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
static int ecol  ;
#line 186
int init_encrypt(void) ;
#line 188
int e_putchar(unsigned char plain ) ;
#line 184 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
int begin_eexec(void) 
{ 


  {
  {
#line 186
  init_encrypt();
#line 187
  ecol = 0;
#line 188
  e_putchar(0);
#line 189
  e_putchar(0);
#line 190
  e_putchar(0);
#line 191
  e_putchar(0);
  }
#line 192
  return (0);
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
int end_eexec(void) 
{ 
  int i ;
  int j ;

  {
  {
#line 198
  _IO_putc('\n', outfp);
#line 199
  i = 0;
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (i < 8)) {
#line 199
      goto while_break;
    }
#line 200
    j = 0;
    {
#line 200
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 200
      if (! (j < 64)) {
#line 200
        goto while_break___0;
      }
      {
#line 201
      _IO_putc('0', outfp);
#line 200
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 202
    _IO_putc('\n', outfp);
#line 199
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  return (0);
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
static int lenIV  =    4;
#line 233 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
static char cs_start[10]  = {      (char )'-',      (char )'|',      (char )'\000'};
#line 236 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
static byte charstring_buf[65535]  ;
#line 237 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
static byte *charstring_bp  ;
#line 247
int init_cencrypt(void) ;
#line 249
int cencrypt_char(unsigned char plain ) ;
#line 242 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
void charstring_start(void) 
{ 
  int i ;
  byte *tmp ;
  int tmp___0 ;

  {
  {
#line 246
  charstring_bp = charstring_buf;
#line 247
  init_cencrypt();
#line 248
  i = 0;
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! (i < lenIV)) {
#line 248
      goto while_break;
    }
    {
#line 249
    tmp = charstring_bp;
#line 249
    charstring_bp ++;
#line 249
    tmp___0 = cencrypt_char((int )((byte )0));
#line 249
    *tmp = (byte )tmp___0;
#line 248
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
static void charstring_byte(int v___0 ) 
{ 
  byte b ;
  byte *tmp ;
  int tmp___0 ;

  {
#line 257
  b = (byte )((unsigned int )v___0 & 255U);
#line 259
  if ((unsigned long )(charstring_bp - charstring_buf) > sizeof(charstring_buf)) {
    {
#line 260
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: charstring_buf full (%d bytes)\n",
            sizeof(charstring_buf));
#line 262
    exit(1);
    }
  }
  {
#line 264
  tmp = charstring_bp;
#line 264
  charstring_bp ++;
#line 264
  tmp___0 = cencrypt_char((int )b);
#line 264
  *tmp = (byte )tmp___0;
  }
#line 265
  return;
}
}
#line 276
int e_printf(char *form , int i0 , int i1 , int i2 , int i3 , int i4 , int i5 , int i6 ,
             int i7 , int i8 , int i9 ) ;
#line 270 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
void charstring_end(void) 
{ 
  byte *bp ;
  char line[256] ;

  {
  {
#line 275
  sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)"%d %s ",
          charstring_bp - charstring_buf, cs_start);
#line 276
  e_printf(line);
#line 277
  bp = charstring_buf;
  }
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! ((unsigned long )bp < (unsigned long )charstring_bp)) {
#line 277
      goto while_break;
    }
    {
#line 278
    e_putchar((int )*bp);
#line 277
    bp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
void charstring_int(int num___0 ) 
{ 
  int x ;
  int tmp ;

  {
#line 287
  if (num___0 >= -107) {
#line 287
    if (num___0 <= 107) {
      {
#line 288
      charstring_byte(num___0 + 139);
      }
    } else {
#line 287
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 289
  if (num___0 >= 108) {
#line 289
    if (num___0 <= 1131) {
      {
#line 290
      x = num___0 - 108;
#line 291
      charstring_byte(x / 256 + 247);
#line 292
      charstring_byte(x % 256);
      }
    } else {
#line 289
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 293
  if (num___0 >= -1131) {
#line 293
    if (num___0 <= -108) {
      {
#line 294
      tmp = abs(num___0);
#line 294
      x = tmp - 108;
#line 295
      charstring_byte(x / 256 + 251);
#line 296
      charstring_byte(x % 256);
      }
    } else {
#line 293
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 297
  if (num___0 >= (-0x7FFFFFFF-1)) {
#line 297
    if (num___0 <= 2147483647) {
      {
#line 298
      charstring_byte(255);
#line 299
      charstring_byte(num___0 >> 24);
#line 300
      charstring_byte(num___0 >> 16);
#line 301
      charstring_byte(num___0 >> 8);
#line 302
      charstring_byte(num___0);
      }
    } else {
      {
#line 304
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: cannot format the integer %d, too large\n",
              num___0);
#line 306
      exit(1);
      }
    }
  } else {
    {
#line 304
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: cannot format the integer %d, too large\n",
            num___0);
#line 306
    exit(1);
    }
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
struct cs cscom_table[26]  = 
#line 310
  {      {12, 16}, 
        {10, -1}, 
        {9, -1}, 
        {12, 12}, 
        {12, 0}, 
        {14, -1}, 
        {12, -1}, 
        {6, -1}, 
        {22, -1}, 
        {13, -1}, 
        {1, -1}, 
        {12, 2}, 
        {31, -1}, 
        {12, 17}, 
        {11, -1}, 
        {5, -1}, 
        {21, -1}, 
        {8, -1}, 
        {12, 7}, 
        {12, 6}, 
        {12, 33}, 
        {30, -1}, 
        {7, -1}, 
        {4, -1}, 
        {3, -1}, 
        {12, 1}};
#line 341 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
int charstring_com(cscommand com ) 
{ 


  {
  {
#line 344
  charstring_byte(cscom_table[com].one);
  }
#line 345
  if (cscom_table[com].two >= 0) {
    {
#line 346
    charstring_byte(cscom_table[com].two);
    }
  }
#line 347
  return (0);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
int e_printf(char *form , int i0 , int i1 , int i2 , int i3 , int i4 , int i5 , int i6 ,
             int i7 , int i8 , int i9 ) 
{ 
  int len ;
  int i ;
  char buf[4096] ;
  size_t tmp ;

  {
  {
#line 357
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)form, i0,
          i1, i2, i3, i4, i5, i6, i7, i8, i9);
#line 358
  tmp = strlen((char const   *)(buf));
#line 358
  len = (int )tmp;
#line 359
  i = 0;
  }
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (i < len)) {
#line 359
      goto while_break;
    }
    {
#line 360
    e_putchar((unsigned int )buf[i]);
#line 359
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  return (0);
}
}
#line 366
int encrypt_char(unsigned char plain ) ;
#line 363 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
int e_putchar(unsigned char plain ) 
{ 
  int tmp ;

  {
  {
#line 366
  tmp = encrypt_char((int )plain);
#line 366
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%02X",
          tmp);
#line 367
  ecol += 2;
  }
#line 368
  if (ecol == 64) {
    {
#line 369
    _IO_putc('\n', outfp);
#line 370
    ecol = 0;
    }
  }
#line 372
  return (0);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
static unsigned short r  ;
#line 376 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
static unsigned short cr  ;
#line 377 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
static unsigned short c1  =    (unsigned short)52845;
#line 377 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
static unsigned short c2  =    (unsigned short)22719;
#line 379 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
int init_encrypt(void) 
{ 


  {
#line 381
  r = (unsigned short)55665;
#line 382
  return (0);
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
int init_cencrypt(void) 
{ 


  {
#line 386
  cr = (unsigned short)4330;
#line 387
  return (0);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
int encrypt_char(unsigned char plain ) 
{ 
  unsigned char cipher ;

  {
#line 394
  cipher = (unsigned char )((int )plain ^ ((int )r >> 8));
#line 395
  r = (unsigned short )(((int )cipher + (int )r) * (int )c1 + (int )c2);
#line 396
  return ((int )cipher);
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pst1form.c"
int cencrypt_char(unsigned char plain ) 
{ 
  unsigned char cipher ;

  {
#line 404
  cipher = (unsigned char )((int )plain ^ ((int )cr >> 8));
#line 405
  cr = (unsigned short )(((int )cipher + (int )cr) * (int )c1 + (int )c2);
#line 406
  return ((int )cipher);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int Stats ;
#line 86
float actfact(float magfact ) ;
#line 87
float apprfact(float magfact ) ;
#line 88
float mag_table[33] ;
#line 89 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int mag_index  ;
#line 90
int magtabsize ;
#line 12 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/mag.c"
float mag_table[33]  = 
#line 12 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/mag.c"
  {      (float )0.23256803936137783874,      (float )0.25476552262595201888,      (float )0.27908164723365340649,      (float )0.30571862715114242265, 
        (float )0.33489797668038408779,      (float )0.36686235258137090718,      (float )0.40187757201646090535,      (float )0.44023482309764508862, 
        (float )0.48225308641975308642,      (float )0.52828178771717410634,      (float )0.57870370370370370370,      (float )0.63393814526060892761, 
        (float )0.69444444444444444444,      (float )0.76072577431273071313,      (float )0.83333333333333333333,      (float )0.91287092917527685576, 
        (float )1.00000000000000000000,      (float )1.09544511501033222690,      (float )1.20000000000000000000,      (float )1.31453413801239867230, 
        (float )1.44000000000000000000,      (float )1.57744096561487840680,      (float )1.72800000000000000000,      (float )1.89292915873785408810, 
        (float )2.07360000000000000000,      (float )2.27151499048542490570,      (float )2.48832000000000000000,      (float )2.72581798858250988690, 
        (float )2.98598400000000000000,      (float )3.27098158629901186430,      (float )3.58318080000000000000,      (float )3.92517790355881423710, 
        (float )4.29981696000000000000};
#line 50 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/mag.c"
int magtabsize  =    (int )(sizeof(mag_table) / sizeof(float ));
#line 58 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/mag.c"
float actfact(float magfact ) 
{ 
  unsigned int unmodsize ;
  int k ;
  unsigned int tab_entry ;
  int left ;
  int right ;

  {
#line 73
  unmodsize = (unsigned int )(1000.0 * (double )magfact + 0.5);
#line 74
  left = 0;
#line 74
  right = (int )(sizeof(mag_table) / sizeof(float ));
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (left <= right)) {
#line 74
      goto while_break;
    }
#line 75
    k = (left + right) / 2;
#line 76
    tab_entry = (unsigned int )(1000.0 * (double )mag_table[k] + 0.5);
#line 77
    if (unmodsize == tab_entry) {
#line 78
      return (mag_table[k]);
    } else
#line 79
    if (unmodsize < tab_entry) {
#line 80
      right = k - 1;
    } else {
#line 82
      left = k + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (Stats) {
    {
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Non-standard mag %d\n",
            unmodsize);
    }
  }
#line 88
  return (magfact);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/mag.c"
float apprfact(float magfact ) 
{ 
  unsigned int unmodsize ;
  int k ;
  unsigned int tab_entry ;
  int left ;
  int right ;

  {
#line 111
  unmodsize = (unsigned int )(1000.0 * (double )magfact + 0.5);
#line 112
  left = 0;
#line 112
  right = (int )(sizeof(mag_table) / sizeof(float ));
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    k = (left + right) / 2;
#line 114
    if (left + 1 == right) {
#line 115
      goto while_break;
    }
#line 116
    tab_entry = (unsigned int )(1000.0 * (double )mag_table[k] + 0.5);
#line 117
    if (unmodsize == tab_entry) {
#line 118
      goto while_break;
    } else
#line 119
    if (unmodsize < tab_entry) {
#line 120
      right = k;
    } else {
#line 122
      left = k;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  mag_index = k;
#line 124
  return (mag_table[mag_index]);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
struct font_entry *hdfontent ;
#line 5 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
struct font_entry *curfontent  ;
#line 57
struct font_entry *get_font_entry(int c , int s , int d , int a , int l , char *n ) ;
#line 58
void SetFntNum(int k , struct font_index *hdfidx ) ;
#line 59
void read_fontinfo(struct font_entry *fe ) ;
#line 102
void init_fontinfo(struct font_entry *fe ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/set.h"
void realf_setchar(int c , BOOLEAN Move ) ;
#line 7
void realf_setstring(int firstch ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontcom.c"
struct font_entry *hdfontent  =    (struct font_entry *)((void *)0);
#line 14 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontcom.c"
void readfontdef(int k , int c , int s , int d , int a , int l , char *n , struct font_index **hdfip ) 
{ 
  struct font_index *fi ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 22
  tmp = malloc((size_t )((unsigned int )sizeof(struct font_index )));
#line 22
  tmp___0 = alloc_check(tmp, "font_index");
#line 22
  fi = (struct font_index *)tmp___0;
#line 23
  fi->k = k;
#line 24
  fi->next = *hdfip;
#line 25
  *hdfip = fi;
  }
#line 27
  if (debug >= 2) {
    {
#line 28
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"readfontdef %s k = %d s = %d d = %d",
            n, k, s, d);
    }
  }
  {
#line 31
  fi->fent = get_font_entry(c, s, d, a, l, n);
  }
#line 32
  return;
}
}
#line 42
int first_markchar(int c ) ;
#line 43
void read_null_fontinfo(struct font_entry *fe ) ;
#line 45
int replfont(char *n , int s , char *rn , int *rd , int *rs ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontcom.c"
struct font_entry *get_font_entry(int c , int s , int d , int a , int l , char *n ) 
{ 
  struct font_entry *fe ;
  char rn[257] ;
  int rd ;
  int rs ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 45
  tmp___0 = replfont(n, s, rn, & rd, & rs);
  }
#line 45
  if (tmp___0) {
#line 47
    if (debug >= 2) {
      {
#line 48
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -> %s s = %d d = %d",
              rn, rs, rd);
      }
    }
    {
#line 50
    n = rn;
#line 51
    tmp = strlen((char const   *)(rn));
#line 51
    l = (int )tmp;
#line 52
    d = rd;
#line 53
    s = rs;
    }
  }
#line 55
  fe = hdfontent;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! ((unsigned long )fe != (unsigned long )((void *)0))) {
#line 55
      goto while_break;
    }
    {
#line 56
    tmp___1 = strcmp((char const   *)n, (char const   *)(fe->n));
    }
#line 56
    if (tmp___1 == 0) {
#line 56
      if (s == fe->s) {
#line 58
        if (debug >= 2) {
          {
#line 59
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [already read]\n");
          }
        }
#line 61
        return (fe);
      }
    }
#line 55
    fe = fe->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  if (debug >= 2) {
    {
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 68
  tmp___2 = malloc((size_t )((unsigned int )sizeof(struct font_entry )));
#line 68
  tmp___3 = alloc_check(tmp___2, "font_entry");
#line 68
  fe = (struct font_entry *)tmp___3;
#line 69
  fe->next = hdfontent;
#line 70
  hdfontent = fe;
#line 71
  fe->c = c;
#line 72
  fe->s = s;
#line 73
  fe->d = d;
#line 74
  fe->a = a;
#line 75
  fe->l = l;
#line 76
  strcpy((char */* __restrict  */)(fe->n), (char const   */* __restrict  */)n);
#line 77
  fe->openfile = (FILE *)-1;
#line 78
  fe->ncdl = -1;
#line 80
  fe->nbpxl = 0;
#line 81
  fe->ncts = 0;
#line 84
  fe->dev_setchar = & first_markchar;
#line 85
  fe->fnt_readfontinfo = & read_null_fontinfo;
  }
#line 87
  return (fe);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontcom.c"
int first_markchar(int c ) 
{ 


  {
  {
#line 99
  init_fontinfo(curfontent);
#line 100
  (*(curfontent->dev_setchar))(c);
  }
#line 101
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontcom.c"
void SetFntNum(int k , struct font_index *hdfidx ) 
{ 
  struct font_index *ptr ;

  {
#line 118
  ptr = hdfidx;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 118
      if (! (ptr->k != k)) {
#line 118
        goto while_break;
      }
    } else {
#line 118
      goto while_break;
    }
#line 119
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 121
    Fatal("font %d undefined", k);
    }
  }
#line 122
  curfontent = ptr->fent;
#line 123
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontcom.c"
void read_fontinfo(struct font_entry *fe ) 
{ 


  {
#line 133
  if (debug >= 2) {
    {
#line 134
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<%s>\n",
            fe->n);
    }
  }
  {
#line 137
  fe->rvf_setchar = & realf_setchar;
#line 138
  fe->rvf_setstring = & realf_setstring;
#line 139
  (*(fe->fnt_readfontinfo))(fe);
  }
#line 140
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontcom.c"
int null_markchar(int c ) 
{ 


  {
#line 148
  return (0);
}
}
#line 154
DEV_FONT null_fontdict(struct font_entry *fe , int c ) ;
#line 155
int null_setchar(int c ) ;
#line 155
int null_setstring(char *s , int len ) ;
#line 150 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontcom.c"
void read_null_fontinfo(struct font_entry *fe ) 
{ 


  {
#line 157
  fe->dev_fontdict = & null_fontdict;
#line 158
  fe->dev_setchar = & null_setchar;
#line 159
  fe->dev_setstring = & null_setstring;
#line 160
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontcom.c"
DEV_FONT null_fontdict(struct font_entry *fe , int c ) 
{ 


  {
#line 168
  return (-1);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontcom.c"
int null_setchar(int c ) 
{ 


  {
#line 175
  return (0);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontcom.c"
int null_setstring(char *s , int len ) 
{ 


  {
#line 183
  return (0);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int dir ;
#line 62 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
struct dconv *curdconvp  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int (*dc_getcommand)()  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
void (*dc_backupone)()  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
void (*dc_getbytes)()  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
void (*dc_skipbytes)()  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int (*dc_getuint)()  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int (*dc_getint)()  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
FILE *dc_file  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
byte *dc_bufbeg  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
byte *dc_bufend  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
void (*dc_movedown)()  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
void (*dc_moveover)()  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
void (*dc_setrule)()  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int dc_scale  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dconv.c"
int setcurdconv(struct dconv *dp ) 
{ 


  {
#line 23
  curdconvp = dp;
#line 24
  dc_getcommand = dp->dc_getcommand;
#line 25
  dc_backupone = dp->dc_backupone;
#line 26
  dc_getbytes = dp->dc_getbytes;
#line 27
  dc_skipbytes = dp->dc_skipbytes;
#line 28
  dc_getuint = dp->dc_getuint;
#line 29
  dc_getint = dp->dc_getint;
#line 30
  dc_file = dp->dc_file;
#line 31
  dc_bufbeg = dp->dc_bufbeg;
#line 32
  dc_bufend = dp->dc_bufend;
#line 33
  if (dir == 0) {
#line 34
    dc_movedown = dp->dc_movedown;
#line 35
    dc_moveover = dp->dc_moveover;
#line 36
    dc_setrule = dp->dc_setrule;
  } else {
#line 38
    dc_movedown = dp->dc_movedown_v;
#line 39
    dc_moveover = dp->dc_moveover_v;
#line 40
    dc_setrule = dp->dc_setrule_v;
  }
#line 42
  dc_scale = dp->dc_scale;
#line 43
  return (0);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dconv.c"
int setdirhor(void) 
{ 


  {
#line 47
  dc_movedown = curdconvp->dc_movedown;
#line 48
  dc_moveover = curdconvp->dc_moveover;
#line 49
  dc_setrule = curdconvp->dc_setrule;
#line 50
  return (0);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dconv.c"
int setdirver(void) 
{ 


  {
#line 54
  dc_movedown = curdconvp->dc_movedown_v;
#line 55
  dc_moveover = curdconvp->dc_moveover_v;
#line 56
  dc_setrule = curdconvp->dc_setrule_v;
#line 57
  return (0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int Stnc ;
#line 48
int *move ;
#line 49
BOOLEAN chmove ;
#line 8 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/set.h"
void virf_setchar(int c , BOOLEAN Move ) ;
#line 9
void virf_setstring(int firstch ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfset.c"
void virf_setchar(int c , BOOLEAN Move ) 
{ 
  int cw ;

  {
  {
#line 18
  chmove = Move;
#line 19
  cw = (*(curfontent->dev_setchar))(c);
  }
#line 20
  if (Move) {
#line 21
    *move += cw;
  }
#line 24
  Stnc ++;
#line 25
  (curfontent->ncts) ++;
#line 27
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfset.c"
void virf_setstring(int firstch ) 
{ 
  char s[256] ;
  char *sp ;
  int c ;
  int len ;
  int w ;
  char *tmp ;

  {
#line 40
  c = firstch;
#line 40
  sp = s;
#line 40
  len = 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (c >= 0) {
#line 40
      if (c <= 127) {
#line 40
        if (! (len < 256)) {
#line 40
          goto while_break;
        }
      } else {
#line 40
        goto while_break;
      }
    } else {
#line 40
      goto while_break;
    }
    {
#line 42
    tmp = sp;
#line 42
    sp ++;
#line 42
    *tmp = (char )c;
#line 43
    c = (*dc_getcommand)();
#line 40
    len ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  (*dc_backupone)();
#line 47
  chmove = 1;
#line 48
  w = (*(curfontent->dev_setstring))(s, len);
#line 49
  *move += w;
#line 52
  Stnc += len;
#line 53
  curfontent->ncts += len;
  }
#line 55
  return;
}
}
#line 754 "/usr/include/stdio.h"
extern long ftell(FILE *__stream ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
int pktype_access(char *proto , struct font_entry *fe , struct accarg *acca ) ;
#line 18
void init_pk_fontinfo(struct font_entry *fe ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
struct fontop pkop  =    {(char *)"pk", & pathtype_init, & pktype_access, & init_pk_fontinfo};
#line 26 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
static FILE *fntfp  ;
#line 27
void loadpkchar(struct font_entry *fe , struct rastchar_entry *ce , int flag , long pl ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
int pktype_access(char *proto , struct font_entry *fe , struct accarg *acca ) 
{ 
  BOOLEAN ok ;
  int tmp ;

  {
  {
#line 37
  rast_mag(fe, acca, 1);
#line 43
  pave(fe->name, proto, acca);
#line 44
  tmp = access((char const   *)(fe->name), 4);
#line 44
  ok = tmp == 0;
#line 47
  rast_debug_report(fe, acca, ok, "pk");
  }
#line 49
  return (ok);
}
}
#line 56
void read_pk_fontinfo(struct font_entry *fe ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
void init_pk_fontinfo(struct font_entry *fe ) 
{ 


  {
  {
#line 58
  fe->fnt_readfontinfo = & read_pk_fontinfo;
#line 59
  init_rast_fontinfo(fe);
  }
#line 60
  return;
}
}
#line 119
int readpkchar(int flag , struct font_entry *fe , struct rastinitfontinfo *rii ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
void read_pk_fontinfo(struct font_entry *fe ) 
{ 
  int cmd ;
  int i ;
  int t ;
  struct rastinitfontinfo *rii ;
  struct rastfntinfo *rfi ;
  int ds ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 71
  openfontfile(fe);
#line 72
  fntfp = fe->openfile;
#line 73
  i = 0;
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    i --;
#line 75
    tmp = fseek(fntfp, (long )i, 2);
    }
#line 75
    if (tmp == -1) {
      {
#line 76
      Fatal("can\'t seek to the end of pk file %s\n", fe->name);
      }
    }
    {
#line 74
    t = getuint(fntfp, 1);
    }
#line 74
    if (! (t == 246)) {
#line 74
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  fseek(fntfp, 0L, 0);
  }
#line 79
  if (t != 245) {
    {
#line 81
    Fatal("bad pk file %s\n", fe->name);
    }
  } else {
    {
#line 79
    tmp___0 = getuint(fntfp, 1);
    }
#line 79
    if (tmp___0 != 247) {
      {
#line 81
      Fatal("bad pk file %s\n", fe->name);
      }
    } else {
      {
#line 79
      tmp___1 = getuint(fntfp, 1);
      }
#line 79
      if (tmp___1 != 89) {
        {
#line 81
        Fatal("bad pk file %s\n", fe->name);
        }
      }
    }
  }
  {
#line 82
  tmp___2 = getuint(fntfp, 1);
#line 82
  fseek(fntfp, (long )tmp___2, 1);
#line 83
  ds = getuint(fntfp, 4);
#line 84
  t = getuint(fntfp, 4);
  }
#line 84
  if (t) {
#line 84
    if (fe->c) {
#line 84
      if (t != fe->c) {
        {
#line 85
        Warning("font = \"%s\",\n-->font checksum = %d,\n-->dvi checksum = %d", fe->name,
                fe->c, t);
        }
      }
    }
  }
  {
#line 87
  fseek(fntfp, 8L, 1);
#line 89
  rii = *((struct rastinitfontinfo **)(& fe->finfo));
#line 90
  rfi = alloc_rastfinfo(rii->maxc + 1, 1, rii);
#line 90
  *((struct rastfntinfo **)(& fe->finfo)) = rfi;
  }
#line 92
  if (debug >= 2) {
#line 93
    i = 0;
    {
#line 93
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 93
      if (! (i <= rii->maxc)) {
#line 93
        goto while_break___0;
      }
#line 94
      (*((struct rastfntinfo **)(& fe->finfo)))->ch[i].where.pixptr = (char *)((void *)0);
#line 93
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 97
  dev_rast_initfe(fe);
#line 99
  rfi->nfntchars = rii->maxc + 1;
  }
  {
#line 100
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 101
    cmd = getuint(fntfp, 1);
    }
    {
#line 103
    if (cmd == 243) {
#line 103
      goto case_243;
    }
#line 103
    if (cmd == 242) {
#line 103
      goto case_243;
    }
#line 103
    if (cmd == 241) {
#line 103
      goto case_243;
    }
#line 103
    if (cmd == 240) {
#line 103
      goto case_243;
    }
#line 107
    if (cmd == 244) {
#line 107
      goto case_244;
    }
#line 111
    if (cmd == 246) {
#line 111
      goto case_246;
    }
#line 114
    if (cmd == 245) {
#line 114
      goto case_245;
    }
#line 117
    goto switch_default;
    case_243: /* CIL Label */ 
    case_242: /* CIL Label */ 
    case_241: /* CIL Label */ 
    case_240: /* CIL Label */ 
    {
#line 104
    tmp___3 = getuint(fntfp, (cmd - 240) + 1);
#line 104
    fseek(fntfp, (long )tmp___3, 1);
    }
#line 105
    goto __Cont;
    case_244: /* CIL Label */ 
    {
#line 108
    skipbytes(fntfp, 4);
    }
#line 109
    goto __Cont;
    case_246: /* CIL Label */ 
#line 112
    goto __Cont;
    case_245: /* CIL Label */ 
#line 115
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 118
    if (cmd <= 239) {
      {
#line 119
      readpkchar(cmd, fe, rii);
      }
    } else {
      {
#line 121
      Fatal("illegal pk command %d in %s\n", cmd, fe->name);
      }
    }
#line 122
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
#line 124
    goto while_break___1;
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 128
  if (debug >= 2) {
#line 129
    i = 0;
    {
#line 129
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 129
      if (! (i <= rii->maxc)) {
#line 129
        goto while_break___2;
      }
#line 130
      if (rii->mark[i]) {
#line 130
        if ((unsigned long )(*((struct rastfntinfo **)(& fe->finfo)))->ch[i].where.pixptr == (unsigned long )((void *)0)) {
          {
#line 131
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The glyf of char %x in %s missing\n",
                  i, fe->name);
          }
        }
      }
#line 129
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 135
  free((void *)((char *)rii));
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
int readpkchar(int flag , struct font_entry *fe , struct rastinitfontinfo *rii ) 
{ 
  long pl ;
  unsigned int cc ;
  int n ;
  struct rastchar_entry *ce ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 148
  n = flag & 7;
#line 148
  if (n == 7) {
    {
#line 149
    tmp = getuint(fntfp, 4);
#line 149
    pl = (long )(tmp - 8);
#line 150
    tmp___0 = getuint(fntfp, 4);
#line 150
    cc = (unsigned int )tmp___0;
    }
#line 150
    if (cc > 255U) {
      {
#line 151
      Warning("cc %d in pk file %s (skipped)", cc, fe->name);
#line 152
      fseek(fntfp, pl + 8L, 1);
      }
#line 153
      return;
    }
#line 155
    if ((int )rii->mark[cc] == 0) {
      {
#line 156
      fseek(fntfp, pl + 8L, 1);
      }
#line 157
      return;
    }
    {
#line 159
    ce = & (*((struct rastfntinfo **)(& fe->finfo)))->ch[cc];
#line 160
    tmp___1 = getuint(fntfp, 4);
#line 160
    ce->tfmw = (int )(((SCALED )tmp___1 * (SCALED )fe->s) / (SCALED )(1 << 20));
#line 161
    skipbytes(fntfp, 4);
#line 162
    n = 4;
    }
  } else
#line 163
  if (n >= 4) {
    {
#line 164
    tmp___2 = getuint(fntfp, 2);
#line 164
    pl = (long )(((n - 4) * 65536 + tmp___2) - 3);
#line 165
    tmp___3 = getuint(fntfp, 1);
#line 165
    cc = (unsigned int )tmp___3;
#line 165
    ce = & (*((struct rastfntinfo **)(& fe->finfo)))->ch[cc];
    }
#line 166
    if ((int )rii->mark[cc] == 0) {
      {
#line 167
      fseek(fntfp, pl + 3L, 1);
      }
#line 168
      return;
    }
    {
#line 170
    tmp___4 = getuint(fntfp, 3);
#line 170
    ce->tfmw = (int )(((SCALED )tmp___4 * (SCALED )fe->s) / (SCALED )(1 << 20));
#line 171
    n = 2;
    }
  } else {
    {
#line 173
    tmp___5 = getuint(fntfp, 1);
#line 173
    pl = (long )((n * 256 + tmp___5) - 3);
#line 174
    tmp___6 = getuint(fntfp, 1);
#line 174
    cc = (unsigned int )tmp___6;
#line 174
    ce = & (*((struct rastfntinfo **)(& fe->finfo)))->ch[cc];
    }
#line 175
    if ((int )rii->mark[cc] == 0) {
      {
#line 176
      fseek(fntfp, pl + 3L, 1);
      }
#line 177
      return;
    }
    {
#line 179
    tmp___7 = getuint(fntfp, 3);
#line 179
    ce->tfmw = (int )(((SCALED )tmp___7 * (SCALED )fe->s) / (SCALED )(1 << 20));
#line 180
    n = 1;
    }
  }
  {
#line 182
  skipbytes(fntfp, n);
#line 183
  tmp___8 = getuint(fntfp, n);
#line 183
  ce->width = (unsigned short )tmp___8;
#line 184
  tmp___9 = getuint(fntfp, n);
#line 184
  ce->height = (unsigned short )tmp___9;
#line 185
  tmp___10 = getint(fntfp, n);
#line 185
  ce->xoffset = (short )tmp___10;
#line 186
  tmp___11 = getint(fntfp, n);
#line 186
  ce->yoffset = (short )tmp___11;
#line 187
  ce->nbpl = (unsigned short )((int )((unsigned short )((int )ce->width + 7)) >> 3);
#line 189
  loadpkchar(fe, ce, flag, pl - (long )(5 * n));
#line 190
  dev_rast_initfontdict(fe, cc);
  }
#line 191
  return (0);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
static int width___0  ;
#line 193 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
static int height  ;
#line 193 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
static int dyn_f  ;
#line 194 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
static int b_width  ;
#line 194 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
static int black  ;
#line 195 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
static unsigned char *pixel  ;
#line 196 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
static unsigned char pat[8]  = 
#line 196
  {      (unsigned char)255,      (unsigned char)127,      (unsigned char)63,      (unsigned char)31, 
        (unsigned char)15,      (unsigned char)7,      (unsigned char)3,      (unsigned char)1};
#line 215
int unpack_raster(void) ;
#line 217
int unpack_run(long pl ) ;
#line 200 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
void loadpkchar(struct font_entry *fe , struct rastchar_entry *ce , int flag , long pl ) 
{ 
  void *tmp ;

  {
  {
#line 207
  dyn_f = flag / 16;
#line 208
  black = (flag & 8) >> 3;
#line 209
  width___0 = (int )ce->width;
#line 210
  height = (int )ce->height;
#line 211
  b_width = (int )ce->nbpl;
#line 212
  tmp = calloc((size_t )((unsigned int )height), (size_t )((unsigned int )b_width));
#line 212
  pixel = (unsigned char *)tmp;
  }
#line 212
  if ((unsigned long )pixel == (unsigned long )((void *)0)) {
    {
#line 213
    Fatal("Unable to allocate memory for char\n");
    }
  }
#line 214
  if (dyn_f == 14) {
    {
#line 215
    unpack_raster();
    }
  } else {
    {
#line 217
    unpack_run(pl);
    }
  }
#line 218
  ce->where.pixptr = (char *)pixel;
#line 219
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
int unpack_run(long pl ) 
{ 
  unsigned char *p ;
  unsigned char *q ;
  int i ;
  int run ;
  int rep ;
  int h___0 ;
  int h1 ;
  int v___0 ;
  int nyb_f ;
  int nyb_w ;
  long off ;
  int tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
  {
#line 260
  nyb_f = 0;
#line 264
  p = pixel;
#line 265
  black ^= 1;
#line 266
  run = 0;
#line 267
  off = ftell(fntfp);
#line 268
  v___0 = 0;
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! (v___0 < height)) {
#line 268
      goto while_break;
    }
#line 269
    rep = 0;
#line 270
    h___0 = 0;
    {
#line 270
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 270
      if (! (h___0 < width___0)) {
#line 270
        goto while_break___0;
      }
#line 271
      if (run == 0) {
        {
#line 272
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 272
          nyb_f ^= 1;
#line 272
          if (nyb_f) {
            {
#line 272
            nyb_w = getuint(fntfp, 1);
#line 272
            i = nyb_w / 16;
            }
          } else {
#line 272
            i = nyb_w & 15;
          }
#line 272
          if (i >= 14) {
#line 272
            rep = i * 2 - 29;
#line 272
            goto __Cont;
          } else
#line 272
          if (i > dyn_f) {
#line 272
            nyb_f ^= 1;
#line 272
            if (nyb_f) {
              {
#line 272
              nyb_w = getuint(fntfp, 1);
#line 272
              tmp = nyb_w / 16;
              }
            } else {
#line 272
              tmp = nyb_w & 15;
            }
#line 272
            run = ((((i - dyn_f) - 1) * 16 + tmp) + dyn_f) + 1;
          } else
#line 272
          if (i > 0) {
#line 272
            run = i;
          } else {
            {
#line 272
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 272
              i ++;
#line 272
              nyb_f ^= 1;
#line 272
              if (nyb_f) {
                {
#line 272
                nyb_w = getuint(fntfp, 1);
#line 272
                run = nyb_w / 16;
                }
              } else {
#line 272
                run = nyb_w & 15;
              }
#line 272
              if (! (run == 0)) {
#line 272
                goto while_break___2;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
            {
#line 272
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 272
              i --;
#line 272
              if (! (i >= 0)) {
#line 272
                goto while_break___3;
              }
#line 272
              nyb_f ^= 1;
#line 272
              if (nyb_f) {
                {
#line 272
                nyb_w = getuint(fntfp, 1);
#line 272
                tmp___0 = nyb_w / 16;
                }
              } else {
#line 272
                tmp___0 = nyb_w & 15;
              }
#line 272
              run = run * 16 + tmp___0;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 272
            run += ((13 - dyn_f) * 16 + dyn_f) - 15;
          }
#line 272
          if (rep >= 0) {
#line 272
            goto while_break___1;
          }
#line 272
          rep = run;
          __Cont: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 273
        black ^= 1;
      }
#line 275
      if (h___0 + run <= width___0) {
#line 275
        h1 = h___0 + run;
      } else {
#line 275
        h1 = width___0;
      }
#line 276
      if (black) {
#line 277
        if (h1 <= ((h___0 + 8) & -8)) {
#line 277
          h1 = h1;
        } else {
#line 277
          h1 = (h___0 + 8) & -8;
        }
#line 278
        *(p + h___0 / 8) = (unsigned char )((int )*(p + h___0 / 8) | (int )pat[h___0 & 7]);
#line 279
        if (h1 & 7) {
#line 280
          *(p + h1 / 8) = (unsigned char )((int )*(p + h1 / 8) & ~ ((int )pat[h1 & 7]));
        }
      }
#line 282
      run -= h1 - h___0;
#line 270
      h___0 = h1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 284
    q = p;
#line 284
    p += b_width;
#line 285
    h___0 = rep * b_width;
    {
#line 285
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 285
      h___0 --;
#line 285
      if (! (h___0 >= 0)) {
#line 285
        goto while_break___4;
      }
#line 286
      tmp___1 = p;
#line 286
      p ++;
#line 286
      tmp___2 = q;
#line 286
      q ++;
#line 286
      *tmp___1 = *tmp___2;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 268
    v___0 += rep + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 288
  fseek(fntfp, off + pl, 0);
  }
#line 289
  return (0);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pkfont.c"
int unpack_raster(void) 
{ 
  unsigned char *p ;
  int n ;
  int m ;
  int t ;
  int h___0 ;
  int v___0 ;

  {
#line 298
  p = pixel;
#line 299
  n = 0;
#line 300
  v___0 = 0;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! (v___0 < height)) {
#line 300
      goto while_break;
    }
#line 301
    h___0 = 0;
    {
#line 301
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 301
      if (! (h___0 < width___0)) {
#line 301
        goto while_break___0;
      }
#line 302
      if (n == 0) {
        {
#line 303
        t = getuint(fntfp, 1);
#line 304
        n = 8;
        }
      }
#line 306
      if (n <= 8 - (h___0 & 7)) {
#line 306
        m = n;
      } else {
#line 306
        m = 8 - (h___0 & 7);
      }
#line 307
      if (m <= width___0 - h___0) {
#line 307
        m = m;
      } else {
#line 307
        m = width___0 - h___0;
      }
#line 308
      *(p + h___0 / 8) = (unsigned char )((int )*(p + h___0 / 8) | (t >> (h___0 & 7)));
#line 309
      t <<= m;
#line 309
      n -= m;
#line 301
      h___0 += m;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 311
    if (width___0 & 7) {
#line 312
      *(p + width___0 / 8) = (unsigned char )((int )*(p + width___0 / 8) & ~ ((int )pat[width___0 & 7]));
    }
#line 313
    p += b_width;
#line 300
    v___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  return (0);
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rfset.c"
void realf_setchar(int c , BOOLEAN Move ) 
{ 
  int cw ;
  DEV_FONT devf ;

  {
  {
#line 19
  devf = (*(curfontent->dev_fontdict))(curfontent, c);
  }
#line 21
  if (devf != -1) {
    {
#line 22
    chmove = Move;
#line 23
    dev_setfont(devf);
#line 24
    dev_setposn(h, v);
#line 25
    cw = (*(curfontent->dev_setchar))(c);
    }
#line 26
    if (Move) {
#line 27
      *move += cw;
    }
  } else {
    {
#line 29
    dev_setposn(h, v);
    }
  }
#line 32
  Stnc ++;
#line 33
  (curfontent->ncts) ++;
#line 35
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/rfset.c"
void realf_setstring(int firstch ) 
{ 
  char s[256] ;
  char *sp ;
  int c ;
  int len ;
  int w ;
  DEV_FONT devf ;
  DEV_FONT tmp ;
  char *tmp___0 ;

  {
  {
#line 49
  devf = (*(curfontent->dev_fontdict))(curfontent, firstch);
#line 50
  c = firstch;
#line 50
  sp = s;
#line 50
  len = 0;
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (c >= 0) {
#line 50
      if (c <= 127) {
#line 50
        if (! (len < 256)) {
#line 50
          goto while_break;
        }
      } else {
#line 50
        goto while_break;
      }
    } else {
#line 50
      goto while_break;
    }
    {
#line 52
    tmp = (*(curfontent->dev_fontdict))(curfontent, c);
    }
#line 52
    if (devf != tmp) {
#line 53
      goto while_break;
    }
    {
#line 54
    tmp___0 = sp;
#line 54
    sp ++;
#line 54
    *tmp___0 = (char )c;
#line 55
    c = (*dc_getcommand)();
#line 50
    len ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 57
  (*dc_backupone)();
  }
#line 60
  if (devf != -1) {
    {
#line 61
    chmove = 1;
#line 62
    dev_setfont(devf);
#line 63
    dev_setposn(h, v);
#line 64
    w = (*(curfontent->dev_setstring))(s, len);
#line 65
    *move += w;
    }
  } else {
    {
#line 67
    dev_setposn(h, v);
    }
  }
#line 70
  Stnc += len;
#line 71
  curfontent->ncts += len;
#line 73
  return;
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psifont.c"
static void scanifont(char *fn ) ;
#line 18
int ps_searchfile(char *f , char *newf ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psifont.c"
int ps_scanifont(char *str ) 
{ 
  int found ;
  char newf[1024] ;
  char *tmp ;

  {
  {
#line 18
  found = ps_searchfile(str, newf);
  }
#line 18
  if (found) {
#line 19
    if (found == 1) {
#line 19
      tmp = str;
    } else {
#line 19
      tmp = newf;
    }
    {
#line 19
    scanifont(tmp);
    }
  }
#line 22
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psifont.c"
struct ifonts *if_list  =    (struct ifonts *)((void *)0);
#line 74
int bp2sp(float f ) ;
#line 123
void MarkChar(int c ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psifont.c"
static void scanifont(char *fn ) 
{ 
  FILE *spfp ;
  char buffer[512] ;
  char *p ;
  char *q ;
  char *n ;
  char *sstr ;
  int s ;
  int d ;
  int c ;
  float f ;
  struct ifonts *ifl ;
  struct ifsizes *isl ;
  struct font_entry *fe ;
  struct font_entry *save_curfontent ;
  int mask ;
  int b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  void *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 51
  spfp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 51
  if ((unsigned long )spfp == (unsigned long )((void *)0)) {
#line 53
    return;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 56
    tmp___20 = fgets((char */* __restrict  */)(buffer), 512, (FILE */* __restrict  */)spfp);
    }
#line 56
    if (! ((unsigned long )tmp___20 != (unsigned long )((void *)0))) {
#line 56
      goto while_break;
    }
#line 57
    if ((int )buffer[0] != 37) {
#line 59
      goto while_break;
    } else
#line 57
    if ((int )buffer[1] != 37) {
#line 57
      if ((int )buffer[1] != 42) {
#line 57
        if ((int )buffer[1] != 33) {
#line 59
          goto while_break;
        }
      }
    }
    {
#line 60
    tmp = strncmp((char const   *)(buffer), "%*Font:", (size_t )7);
    }
#line 60
    if (tmp) {
#line 61
      goto while_continue;
    }
    {
#line 63
    skipstrblank(buffer + 7, & n);
#line 64
    tmp___0 = getstrtok(n, ' ', & p);
    }
#line 64
    if (! tmp___0) {
      {
#line 65
      Warning("PS included font: illegal font name");
      }
#line 66
      goto while_break;
    }
    {
#line 68
    skipstrblank(p, & p);
#line 69
    tmp___1 = getstrtok(p, ' ', & q);
    }
#line 69
    if (! tmp___1) {
      {
#line 70
      Warning("PS included font: no scaled size");
      }
#line 71
      goto while_break;
    }
    {
#line 73
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%f",
           & f);
#line 74
    s = bp2sp((double )f);
#line 75
    sstr = p;
#line 76
    skipstrblank(q, & p);
#line 77
    tmp___2 = getstrtok(p, ' ', & q);
    }
#line 77
    if (! tmp___2) {
      {
#line 78
      Warning("PS included font: no design size");
      }
#line 79
      goto while_break;
    }
    {
#line 81
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%f",
           & f);
#line 82
    d = bp2sp((double )f);
#line 83
    skipstrblank(q, & p);
#line 84
    tmp___3 = __ctype_b_loc();
    }
#line 84
    if ((int const   )*(*tmp___3 + (int )*p) & 4096) {
      {
#line 84
      tmp___4 = __ctype_b_loc();
      }
#line 84
      if ((int const   )*(*tmp___4 + (int )*(p + 1)) & 4096) {
#line 84
        if ((int )*(p + 2) != 58) {
          {
#line 85
          Warning("PS included font: illegal included chars");
          }
#line 86
          goto while_break;
        }
      } else {
        {
#line 85
        Warning("PS included font: illegal included chars");
        }
#line 86
        goto while_break;
      }
    } else {
      {
#line 85
      Warning("PS included font: illegal included chars");
      }
#line 86
      goto while_break;
    }
#line 90
    if (debug >= 2) {
      {
#line 91
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"psfile-fontdef %s s = %d d = %d",
              n, s, d);
      }
    }
    {
#line 94
    tmp___5 = strlen((char const   *)n);
#line 94
    fe = get_font_entry(0, s, d, 0, tmp___5, n);
#line 95
    ifl = if_list;
    }
    {
#line 95
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 95
      if (! ((unsigned long )ifl != (unsigned long )((void *)0))) {
#line 95
        goto while_break___0;
      }
      {
#line 96
      tmp___9 = strcmp((char const   *)(((ifl->if_ss)->is_fe)->n), (char const   *)n);
      }
#line 96
      if (tmp___9 == 0) {
#line 97
        isl = ifl->if_ss;
        {
#line 97
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 97
          if (! ((unsigned long )isl != (unsigned long )((void *)0))) {
#line 97
            goto while_break___1;
          }
          {
#line 98
          tmp___6 = strcmp((char const   *)isl->is_sstr, (char const   *)sstr);
          }
#line 98
          if (tmp___6 == 0) {
#line 99
            goto found;
          }
#line 97
          isl = isl->is_next;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 100
        tmp___7 = malloc((size_t )((unsigned int )sizeof(struct ifsizes )));
#line 100
        tmp___8 = alloc_check(tmp___7, "ifsizes");
#line 100
        isl = (struct ifsizes *)tmp___8;
#line 101
        isl->is_sstr = strsave(sstr);
#line 102
        isl->is_fe = fe;
#line 103
        isl->is_next = ifl->if_ss;
#line 104
        ifl->if_ss = isl;
        }
#line 105
        goto found;
      }
#line 95
      ifl = ifl->if_next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 107
    tmp___10 = malloc((size_t )((unsigned int )sizeof(struct ifonts )));
#line 107
    tmp___11 = alloc_check(tmp___10, "ifonts");
#line 107
    ifl = (struct ifonts *)tmp___11;
#line 108
    ifl->if_next = if_list;
#line 109
    tmp___12 = malloc((size_t )((unsigned int )sizeof(struct ifsizes )));
#line 109
    tmp___13 = alloc_check(tmp___12, "ifsizes");
#line 109
    isl = (struct ifsizes *)tmp___13;
#line 110
    isl->is_sstr = strsave(sstr);
#line 111
    isl->is_fe = fe;
#line 112
    isl->is_next = (struct ifsizes *)((void *)0);
#line 113
    ifl->if_ss = isl;
#line 114
    if_list = ifl;
    }
    found: 
#line 116
    save_curfontent = curfontent;
#line 117
    curfontent = fe;
#line 118
    if ((int )*p <= 57) {
#line 118
      tmp___15 = (int )*p - 48;
    } else {
#line 118
      if ((int )*p <= 70) {
#line 118
        tmp___14 = ((int )*p - 65) + 10;
      } else {
#line 118
        tmp___14 = ((int )*p - 97) + 10;
      }
#line 118
      tmp___15 = tmp___14;
    }
#line 118
    if ((int )*(p + 1) <= 57) {
#line 118
      tmp___17 = (int )*(p + 1) - 48;
    } else {
#line 118
      if ((int )*(p + 1) <= 70) {
#line 118
        tmp___16 = ((int )*(p + 1) - 65) + 10;
      } else {
#line 118
        tmp___16 = ((int )*(p + 1) - 97) + 10;
      }
#line 118
      tmp___17 = tmp___16;
    }
#line 118
    c = tmp___15 * 16 + tmp___17;
#line 119
    p += 3;
    {
#line 119
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 119
      tmp___19 = __ctype_b_loc();
      }
#line 119
      if (! ((int const   )*(*tmp___19 + (int )*p) & 4096)) {
#line 119
        goto while_break___2;
      }
#line 120
      if ((int )*p <= 57) {
#line 120
        mask = (int )*p - 48;
      } else {
#line 120
        if ((int )*p <= 70) {
#line 120
          tmp___18 = ((int )*p - 65) + 10;
        } else {
#line 120
          tmp___18 = ((int )*p - 97) + 10;
        }
#line 120
        mask = tmp___18;
      }
#line 121
      b = 8;
      {
#line 121
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 121
        if (! (b > 0)) {
#line 121
          goto while_break___3;
        }
#line 122
        if (mask & b) {
          {
#line 123
          MarkChar(c);
          }
        }
#line 124
        c ++;
#line 124
        if (c >= 256) {
#line 125
          goto charend;
        }
#line 121
        b >>= 1;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 119
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    charend: 
#line 129
    curfontent = save_curfontent;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 132
  fclose(spfp);
  }
#line 133
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psifont.c"
int bp2sp(float f ) 
{ 


  {
#line 138
  return ((int )(((double )(f * (float )65536) * 72.27) / (double )72));
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psifont.c"
int useifont(void) 
{ 


  {
#line 143
  return ((unsigned long )if_list != (unsigned long )((void *)0));
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psifont.c"
int ifont_setup(void) 
{ 
  struct ifonts *ifl ;
  struct ifsizes *isl ;
  int i ;
  char *tmp ;

  {
  {
#line 157
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"end\n");
#line 158
  ifl = if_list;
  }
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! ((unsigned long )ifl != (unsigned long )((void *)0))) {
#line 158
      goto while_break;
    }
    {
#line 159
    _IO_putc('(', outfp);
#line 160
    fputs((char const   */* __restrict  */)(((ifl->if_ss)->is_fe)->n), (FILE */* __restrict  */)outfp);
#line 161
    fputs((char const   */* __restrict  */)")cvn ", (FILE */* __restrict  */)outfp);
#line 162
    isl = ifl->if_ss;
#line 162
    i = 0;
    }
    {
#line 162
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 162
      if (! ((unsigned long )isl != (unsigned long )((void *)0))) {
#line 162
        goto while_break___0;
      }
      {
#line 163
      fputs((char const   */* __restrict  */)isl->is_sstr, (FILE */* __restrict  */)outfp);
      }
#line 164
      if ((unsigned long )(isl->is_fe)->dev_fontdict == (unsigned long )(& null_fontdict)) {
        {
#line 165
        fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)" /nullfont ");
        }
      } else {
        {
#line 167
        tmp = psfname((isl->is_fe)->k);
#line 167
        fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)" /%s ",
                tmp);
        }
      }
#line 162
      isl = isl->is_next;
#line 162
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 169
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%d fstore\n",
            i);
#line 158
    ifl = ifl->if_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"TeXDict begin\n");
  }
#line 172
  return (0);
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int mag ;
#line 133
void dev_predospecial(char *str , int n ) ;
#line 134
void dev_dospecial(char *str , int n ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.h"
void ps_copyfigfile(char *str ) ;
#line 65
void ps_createpipe(char *str ) ;
#line 66
void ps_string(char *str ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
char *GetKeyStr(char *str , KeyWord *kw ) ;
#line 8
int GetKeyVal(KeyWord *kw , KeyDesc *tab , int nt___0 , int *tno ) ;
#line 9
int IsSame(char *a , char *b ) ;
#line 11
static void ps_pensize(char *cp ) ;
#line 12
static void ps_flushpath(int invisible ) ;
#line 13
static void ps_flushdashedpath(char *cp , int dotted ) ;
#line 14
static void ps_drawto(char *cp ) ;
#line 15
static void ps_arc(char *cp , int invisible ) ;
#line 16
static void ps_flushspline(char *cp ) ;
#line 17
static int dist(int x1 , int y1___0 , int x2 , int y2 ) ;
#line 18
static void ps_whiten(void) ;
#line 19
static void ps_blacken(void) ;
#line 20
static void ps_shade(char *cp ) ;
#line 21
static void push_location(void) ;
#line 21
static void pop_location(void) ;
#line 22
static void ps_setrgbcolor(char *cp ) ;
#line 22
static void ps_sethsbcolor(char *cp ) ;
#line 22
static void ps_setcmykcolor(char *cp ) ;
#line 24
static void ps_texture(char *cp ) ;
#line 25
static void ps_rotate(char *cp ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static int xx[600]  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static int yy[600]  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static int pathlen  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static int pensize  =    2;
#line 37 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static double graylevel  =    0.5;
#line 43 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static int shade_next  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static int is_rotated  =    0;
#line 48 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
BOOLEAN usesspecial  =    0;
#line 49 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
BOOLEAN usescolor  =    0;
#line 57 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static struct bangspecial *bangspecials  =    (struct bangspecial *)((void *)0);
#line 58 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static struct bangspecial **nextbs  =    & bangspecials;
#line 87 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
KeyDesc KeyTab[17]  = 
#line 87
  {      {(char *)"psfile", (ValTyp )1}, 
        {(char *)"epsfile", (ValTyp )1}, 
        {(char *)"hsize", (ValTyp )4}, 
        {(char *)"vsize", (ValTyp )4}, 
        {(char *)"hoffset", (ValTyp )4}, 
        {(char *)"voffset", (ValTyp )4}, 
        {(char *)"hscale", (ValTyp )3}, 
        {(char *)"vscale", (ValTyp )3}, 
        {(char *)"rotation", (ValTyp )4}, 
        {(char *)"angle", (ValTyp )3}, 
        {(char *)"llx", (ValTyp )3}, 
        {(char *)"lly", (ValTyp )3}, 
        {(char *)"urx", (ValTyp )3}, 
        {(char *)"ury", (ValTyp )3}, 
        {(char *)"rwi", (ValTyp )3}, 
        {(char *)"rhi", (ValTyp )3}, 
        {(char *)"clip", (ValTyp )0}};
#line 160
void ps_add_include(char *str ) ;
#line 167
void background(char *bkgrnd ) ;
#line 177
void pushcolor(char *p , Boolean outtops ) ;
#line 179
void popcolor(Boolean outtops ) ;
#line 181
void resetcolorstack(char *p , int outtops ) ;
#line 109 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
void dev_predospecial(char *str , int n ) 
{ 
  char spbuf[257] ;
  char *sf ;
  char *p ;
  char *q ;
  struct bangspecial *b ;
  KeyWord k ;
  int i ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 115
  sf = (char *)((void *)0);
#line 121
  *(str + n) = (char )'\000';
#line 122
  spbuf[0] = (char )'\000';
#line 123
  p = str;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! ((int )*p == 32)) {
#line 125
      goto while_break;
    }
#line 125
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  if ((int )*p == 0) {
#line 127
    return;
  }
#line 128
  usesspecial = 1;
#line 130
  if ((int )*p == 33) {
    {
#line 131
    tmp = malloc((size_t )(((unsigned int )sizeof(struct bangspecial ) + (unsigned int )n) - 1U));
#line 131
    tmp___0 = alloc_check(tmp, "bangspecials");
#line 131
    b = (struct bangspecial *)tmp___0;
#line 134
    strncpy((char */* __restrict  */)(b->bs_string), (char const   */* __restrict  */)(p + 1),
            (size_t )n);
#line 135
    b->bs_next = (struct bangspecial *)((void *)0);
#line 136
    *nextbs = b;
#line 137
    nextbs = & b->bs_next;
    }
#line 138
    return;
  }
  {
#line 140
  tmp___1 = strncmp((char const   *)p, "landscape", (size_t )9);
  }
#line 140
  if (tmp___1 == 0) {
#line 141
    landscape = 1;
#line 142
    return;
  }
  {
#line 144
  tmp___2 = strncmp((char const   *)p, "papersize", (size_t )9);
  }
#line 144
  if (tmp___2 == 0) {
#line 145
    p += 9;
    {
#line 146
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 146
      if (! ((int )*p == 61)) {
#line 146
        if (! ((int )*p == 32)) {
#line 146
          goto while_break___0;
        }
      }
#line 147
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 149
    return;
  }
  {
#line 151
  tmp___4 = strncmp((char const   *)p, "header", (size_t )6);
  }
#line 151
  if (tmp___4 == 0) {
#line 152
    p += 6;
    {
#line 153
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 153
      if ((int )*p <= 32) {
#line 153
        goto _L;
      } else
#line 153
      if ((int )*p == 61) {
#line 153
        goto _L;
      } else
#line 153
      if ((int )*p == 40) {
        _L: /* CIL Label */ 
#line 153
        if (! ((int )*p != 0)) {
#line 153
          goto while_break___1;
        }
      } else {
#line 153
        goto while_break___1;
      }
#line 154
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 155
    tmp___3 = strlen((char const   *)p);
#line 155
    q = (p + tmp___3) - 1;
    }
    {
#line 156
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 156
      if ((int )*q <= 32) {
#line 156
        goto _L___0;
      } else
#line 156
      if ((int )*q == 40) {
        _L___0: /* CIL Label */ 
#line 156
        if (! ((unsigned long )p <= (unsigned long )q)) {
#line 156
          goto while_break___2;
        }
      } else {
#line 156
        goto while_break___2;
      }
#line 157
      q --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 158
    q ++;
#line 158
    *q = (char )'\000';
#line 159
    if ((unsigned long )p <= (unsigned long )q) {
      {
#line 160
      ps_add_include(p);
      }
    }
#line 161
    return;
  }
  {
#line 163
  tmp___5 = strncmp((char const   *)p, "background", (size_t )10);
  }
#line 163
  if (tmp___5 == 0) {
#line 164
    usescolor = 1;
#line 165
    p += 11;
    {
#line 166
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 166
      if (! ((int )*p == 32)) {
#line 166
        goto while_break___3;
      }
#line 166
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 167
    background(p);
    }
#line 168
    return;
  }
  {
#line 170
  tmp___8 = strncmp((char const   *)p, "color", (size_t )5);
  }
#line 170
  if (tmp___8 == 0) {
#line 171
    usescolor = 1;
#line 172
    p += 6;
    {
#line 173
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 173
      if (! ((int )*p == 32)) {
#line 173
        goto while_break___4;
      }
#line 173
      p ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 174
    tmp___7 = strncmp((char const   *)p, "push", (size_t )4);
    }
#line 174
    if (tmp___7 == 0) {
#line 175
      p += 5;
      {
#line 176
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 176
        if (! ((int )*p == 32)) {
#line 176
          goto while_break___5;
        }
#line 176
        p ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 177
      pushcolor(p, 0);
      }
    } else {
      {
#line 178
      tmp___6 = strncmp((char const   *)p, "pop", (size_t )3);
      }
#line 178
      if (tmp___6 == 0) {
        {
#line 179
        popcolor(0);
        }
      } else {
        {
#line 181
        resetcolorstack(p, 0);
        }
      }
    }
#line 183
    return;
  }
  {
#line 185
  tmp___9 = strncmp((char const   *)p, "src:", (size_t )4);
  }
#line 185
  if (tmp___9 == 0) {
#line 186
    return;
  }
  {
#line 188
  tmp___10 = strncmp((char const   *)p, "pos:", (size_t )4);
  }
#line 188
  if (tmp___10 == 0) {
#line 189
    return;
  }
  {
#line 191
  tmp___11 = strncmp((char const   *)p, "om:", (size_t )3);
  }
#line 191
  if (tmp___11 == 0) {
#line 192
    return;
  }
  {
#line 194
  tmp___12 = strncmp((char const   *)p, "xtex:", (size_t )5);
  }
#line 194
  if (tmp___12 == 0) {
#line 195
    return;
  }
  {
#line 197
  tmp___13 = strncmp((char const   *)p, "html:", (size_t )5);
  }
#line 197
  if (tmp___13 == 0) {
#line 198
    return;
  }
  {
#line 201
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 201
    p = GetKeyStr(p, & k);
    }
#line 201
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 201
      goto while_break___6;
    }
#line 203
    if ((unsigned int )k.vt == 0U) {
      {
#line 203
      tmp___15 = access((char const   *)k.Key, 0);
      }
#line 203
      if (tmp___15 == 0) {
        {
#line 208
        strcpy((char */* __restrict  */)(spbuf), (char const   */* __restrict  */)k.Key);
#line 209
        sf = spbuf;
        }
      } else {
#line 203
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 210
      tmp___14 = GetKeyVal(& k, KeyTab, sizeof(KeyTab) / sizeof(KeyTab[0]), & i);
      }
#line 210
      if (tmp___14) {
#line 210
        if (i != -1) {
#line 211
          if (i == 0) {
            {
#line 216
            strcpy((char */* __restrict  */)(spbuf), (char const   */* __restrict  */)k.Val);
#line 217
            sf = spbuf;
            }
          } else
#line 211
          if (i == 1) {
            {
#line 216
            strcpy((char */* __restrict  */)(spbuf), (char const   */* __restrict  */)k.Val);
#line 217
            sf = spbuf;
            }
          }
        }
      }
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 223
  if (sf) {
#line 224
    if (! ((int )*sf == 96)) {
      {
#line 227
      ps_scanifont(sf);
      }
    }
  }
#line 230
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
int dev_outbangspecials(void) 
{ 
  struct bangspecial *b ;

  {
#line 236
  if ((unsigned long )bangspecials != (unsigned long )((void *)0)) {
    {
#line 237
    fputs((char const   */* __restrict  */)"TeXDict begin @defspecial\n", (FILE */* __restrict  */)outfp);
#line 238
    b = bangspecials;
    }
    {
#line 238
    while (1) {
      while_continue: /* CIL Label */ ;
#line 238
      if (! ((unsigned long )b != (unsigned long )((void *)0))) {
#line 238
        goto while_break;
      }
      {
#line 239
      _IO_putc('\n', outfp);
#line 240
      ps_string(b->bs_string);
#line 241
      _IO_putc('\n', outfp);
#line 238
      b = b->bs_next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 243
    fputs((char const   */* __restrict  */)"\n@fedspecial end\n", (FILE */* __restrict  */)outfp);
    }
  }
#line 245
  return (0);
}
}
#line 281
int dev_initfont(void) ;
#line 436
BOOLEAN scanfile(char *str , float *llx , float *lly , float *urx , float *ury ) ;
#line 248 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
void dev_dospecial(char *str , int n ) 
{ 
  char spbuf[257] ;
  char *sf ;
  char *p ;
  char *q ;
  KeyWord k ;
  int i ;
  float llx ;
  float lly ;
  float urx ;
  float ury ;
  float hsize ;
  float vsize ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;

  {
  {
#line 254
  sf = (char *)((void *)0);
#line 260
  *(str + n) = (char )'\000';
#line 261
  spbuf[0] = (char )'\000';
#line 262
  p = str;
#line 264
  end_string();
#line 265
  dev_setposn(h, v);
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! ((int )*p == 32)) {
#line 267
      goto while_break;
    }
#line 267
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  if ((int )*p == 0) {
#line 270
    return;
  }
#line 272
  if ((int )*p == 33) {
#line 273
    return;
  }
  {
#line 274
  tmp = strncmp((char const   *)p, "landscape", (size_t )9);
  }
#line 274
  if (tmp == 0) {
#line 275
    return;
  }
  {
#line 276
  tmp___0 = strncmp((char const   *)p, "papersize", (size_t )9);
  }
#line 276
  if (tmp___0 == 0) {
#line 277
    return;
  }
  {
#line 278
  tmp___1 = strncmp((char const   *)p, "header", (size_t )6);
  }
#line 278
  if (tmp___1 == 0) {
#line 279
    return;
  }
  {
#line 280
  tmp___5 = strncmp((char const   *)p, "ps:", (size_t )3);
  }
#line 280
  if (tmp___5 == 0) {
    {
#line 281
    dev_initfont();
#line 282
    p += 3;
    }
#line 283
    if ((int )*p == 58) {
      {
#line 284
      p ++;
#line 285
      tmp___3 = strncmp((char const   *)p, "[begin]", (size_t )7);
      }
#line 285
      if (tmp___3 == 0) {
        {
#line 286
        _IO_putc('\n', outfp);
#line 287
        ps_string(p + 7);
#line 288
        _IO_putc('\n', outfp);
        }
      } else {
        {
#line 289
        tmp___2 = strncmp((char const   *)p, "[end]", (size_t )5);
        }
#line 289
        if (tmp___2 == 0) {
          {
#line 290
          _IO_putc('\n', outfp);
#line 291
          ps_string(p + 5);
#line 292
          _IO_putc('\n', outfp);
          }
        } else {
          {
#line 294
          _IO_putc('\n', outfp);
#line 295
          ps_string(p);
#line 296
          _IO_putc('\n', outfp);
          }
        }
      }
    } else {
      {
#line 298
      tmp___4 = strncmp((char const   *)p, " plotfile ", (size_t )10);
      }
#line 298
      if (tmp___4 == 0) {
#line 299
        p += 10;
        {
#line 300
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 300
          if (! ((int )*p == 32)) {
#line 300
            goto while_break___0;
          }
#line 300
          p ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 301
        if ((int )*p == 34) {
#line 302
          p ++;
#line 302
          q = p;
          {
#line 302
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 302
            if ((int )*q != 0) {
#line 302
              if (! ((int )*q != 34)) {
#line 302
                goto while_break___1;
              }
            } else {
#line 302
              goto while_break___1;
            }
#line 302
            q ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 304
          q = p;
          {
#line 304
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 304
            if ((int )*q != 0) {
#line 304
              if (! ((int )*q != 32)) {
#line 304
                goto while_break___2;
              }
            } else {
#line 304
              goto while_break___2;
            }
#line 304
            q ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 305
        *q = (char )'\000';
#line 306
        if ((int )*p == 96) {
          {
#line 307
          p ++;
#line 307
          ps_createpipe(p);
          }
        } else {
          {
#line 309
          ps_copyfigfile(p);
          }
        }
      } else {
        {
#line 311
        _IO_putc('\n', outfp);
#line 312
        ps_string(p);
#line 313
        _IO_putc('\n', outfp);
#line 314
        dev_setposn(h, v);
#line 315
        dev_initfont();
        }
      }
    }
#line 317
    return;
  }
#line 319
  if ((int )*p == 34) {
    {
#line 320
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"@beginspecial\n");
#line 321
    fputs((char const   */* __restrict  */)"@setspecial\n", (FILE */* __restrict  */)outfp);
#line 322
    fputs((char const   */* __restrict  */)"TeXDict begin\n", (FILE */* __restrict  */)outfp);
#line 323
    p ++;
#line 323
    ps_string(p);
#line 324
    fputs((char const   */* __restrict  */)"\nend\n", (FILE */* __restrict  */)outfp);
#line 325
    fputs((char const   */* __restrict  */)"@endspecial\n", (FILE */* __restrict  */)outfp);
    }
#line 326
    return;
  }
  {
#line 328
  tmp___6 = strncmp((char const   *)p, "pn ", (size_t )3);
  }
#line 328
  if (tmp___6 == 0) {
    {
#line 329
    ps_pensize(p + 3);
    }
#line 330
    return;
  }
  {
#line 332
  tmp___7 = strcmp((char const   *)p, "fp");
  }
#line 332
  if (tmp___7 == 0) {
    {
#line 333
    ps_flushpath(0);
    }
#line 334
    return;
  }
  {
#line 336
  tmp___8 = strcmp((char const   *)p, "ip");
  }
#line 336
  if (tmp___8 == 0) {
    {
#line 337
    ps_flushpath(1);
    }
#line 338
    return;
  }
  {
#line 340
  tmp___9 = strncmp((char const   *)p, "da ", (size_t )3);
  }
#line 340
  if (tmp___9 == 0) {
    {
#line 341
    ps_flushdashedpath(p + 3, 0);
    }
#line 342
    return;
  }
  {
#line 344
  tmp___10 = strncmp((char const   *)p, "dt ", (size_t )3);
  }
#line 344
  if (tmp___10 == 0) {
    {
#line 345
    ps_flushdashedpath(p + 3, 1);
    }
#line 346
    return;
  }
  {
#line 348
  tmp___11 = strncmp((char const   *)p, "pa ", (size_t )3);
  }
#line 348
  if (tmp___11 == 0) {
    {
#line 349
    ps_drawto(p + 3);
    }
#line 350
    return;
  }
  {
#line 352
  tmp___12 = strncmp((char const   *)p, "ar ", (size_t )3);
  }
#line 352
  if (tmp___12 == 0) {
    {
#line 353
    ps_arc(p + 3, 0);
    }
#line 354
    return;
  }
  {
#line 356
  tmp___13 = strncmp((char const   *)p, "ia ", (size_t )3);
  }
#line 356
  if (tmp___13 == 0) {
    {
#line 357
    ps_arc(p + 3, 1);
    }
#line 358
    return;
  }
  {
#line 360
  tmp___14 = strcmp((char const   *)p, "sp");
  }
#line 360
  if (tmp___14 == 0) {
    {
#line 361
    ps_flushspline(p + 2);
    }
#line 362
    return;
  }
  {
#line 364
  tmp___15 = strncmp((char const   *)p, "sp ", (size_t )3);
  }
#line 364
  if (tmp___15 == 0) {
    {
#line 365
    ps_flushspline(p + 3);
    }
#line 366
    return;
  }
  {
#line 368
  tmp___16 = strcmp((char const   *)p, "sh");
  }
#line 368
  if (tmp___16 == 0) {
    {
#line 369
    ps_shade(p + 2);
    }
#line 370
    return;
  }
  {
#line 372
  tmp___17 = strncmp((char const   *)p, "sh", (size_t )2);
  }
#line 372
  if (tmp___17 == 0) {
    {
#line 373
    ps_shade(p + 3);
    }
#line 374
    return;
  }
  {
#line 376
  tmp___18 = strcmp((char const   *)p, "wh");
  }
#line 376
  if (tmp___18 == 0) {
    {
#line 377
    ps_whiten();
    }
#line 378
    return;
  }
  {
#line 380
  tmp___19 = strcmp((char const   *)p, "bk");
  }
#line 380
  if (tmp___19 == 0) {
    {
#line 381
    ps_blacken();
    }
#line 382
    return;
  }
  {
#line 384
  tmp___20 = strncmp((char const   *)p, "tx ", (size_t )3);
  }
#line 384
  if (tmp___20 == 0) {
    {
#line 385
    ps_texture(p + 3);
    }
#line 386
    return;
  }
  {
#line 388
  tmp___21 = strncmp((char const   *)p, "rt ", (size_t )3);
  }
#line 388
  if (tmp___21 == 0) {
    {
#line 389
    ps_rotate(p + 2);
    }
#line 390
    return;
  }
  {
#line 392
  tmp___22 = strncmp((char const   *)p, "background", (size_t )10);
  }
#line 392
  if (tmp___22 == 0) {
#line 393
    return;
  }
  {
#line 394
  tmp___25 = strncmp((char const   *)p, "color", (size_t )5);
  }
#line 394
  if (tmp___25 == 0) {
#line 395
    p += 6;
    {
#line 396
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 396
      if (! ((int )*p == 32)) {
#line 396
        goto while_break___3;
      }
#line 396
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 397
    tmp___24 = strncmp((char const   *)p, "push", (size_t )4);
    }
#line 397
    if (tmp___24 == 0) {
#line 398
      p += 5;
      {
#line 399
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 399
        if (! ((int )*p == 32)) {
#line 399
          goto while_break___4;
        }
#line 399
        p ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 400
      pushcolor(p, 1);
      }
    } else {
      {
#line 401
      tmp___23 = strncmp((char const   *)p, "pop", (size_t )3);
      }
#line 401
      if (tmp___23 == 0) {
        {
#line 402
        popcolor(1);
        }
      } else {
        {
#line 404
        resetcolorstack(p, 1);
        }
      }
    }
#line 406
    return;
  }
  {
#line 408
  tmp___26 = strncmp((char const   *)p, "RGB", (size_t )3);
  }
#line 408
  if (tmp___26 == 0) {
#line 409
    p += 3;
#line 410
    if ((int )*p == 61) {
#line 411
      p ++;
    }
    {
#line 412
    ps_setrgbcolor(p);
    }
#line 413
    return;
  }
  {
#line 415
  tmp___27 = strncmp((char const   *)p, "HSB", (size_t )3);
  }
#line 415
  if (tmp___27 == 0) {
#line 416
    p += 3;
#line 417
    if ((int )*p == 61) {
#line 418
      p ++;
    }
    {
#line 419
    ps_sethsbcolor(p);
    }
#line 420
    return;
  }
  {
#line 422
  tmp___28 = strncmp((char const   *)p, "CMYK", (size_t )4);
  }
#line 422
  if (tmp___28 == 0) {
#line 423
    p += 4;
#line 424
    if ((int )*p == 61) {
#line 425
      p ++;
    }
    {
#line 426
    ps_setcmykcolor(p);
    }
#line 427
    return;
  }
  {
#line 429
  tmp___31 = strncmp((char const   *)p, "postscriptbox", (size_t )13);
  }
#line 429
  if (tmp___31 == 0) {
    {
#line 430
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"@beginspecial\n");
#line 431
    p += 13;
    }
    {
#line 431
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 431
      if (! ((int )*p == 32)) {
#line 431
        goto while_break___5;
      }
#line 431
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 433
    tmp___29 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"{ %fpt }{ %fpt }{ %[^ {}] }",
                      & hsize, & vsize, spbuf);
    }
#line 433
    if (tmp___29 != 3) {
      {
#line 434
      Warning("  badly formed postscriptbox command - ignored");
      }
    }
    {
#line 435
    sf = spbuf;
#line 436
    tmp___30 = scanfile(sf, & llx, & lly, & urx, & ury);
    }
#line 436
    if (tmp___30) {
      {
#line 437
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%f %f %f %f false @bbox\n",
              (double )llx, (double )lly, (double )urx, (double )ury);
#line 438
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%f @hsize\n",
              (double )(hsize * (float )72) / 72.27);
#line 439
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%f @vsize\n",
              (double )(vsize * (float )72) / 72.27);
      }
    }
    {
#line 441
    fputs((char const   */* __restrict  */)"@setspecial\n", (FILE */* __restrict  */)outfp);
    }
#line 442
    if (sf) {
#line 443
      if ((int )*sf == 96) {
        {
#line 444
        sf ++;
#line 444
        ps_createpipe(sf);
        }
      } else {
        {
#line 446
        ps_copyfigfile(sf);
        }
      }
    } else {
      {
#line 448
      Warning("  No special file name provided.");
      }
    }
    {
#line 449
    fputs((char const   */* __restrict  */)"@endspecial\n", (FILE */* __restrict  */)outfp);
    }
#line 450
    return;
  }
  {
#line 452
  tmp___32 = strncmp((char const   *)p, "src:", (size_t )4);
  }
#line 452
  if (tmp___32 == 0) {
#line 453
    return;
  }
  {
#line 455
  tmp___33 = strncmp((char const   *)p, "pos:", (size_t )4);
  }
#line 455
  if (tmp___33 == 0) {
#line 456
    return;
  }
  {
#line 458
  tmp___34 = strncmp((char const   *)p, "om:", (size_t )3);
  }
#line 458
  if (tmp___34 == 0) {
#line 459
    return;
  }
  {
#line 461
  tmp___35 = strncmp((char const   *)p, "xtex:", (size_t )5);
  }
#line 461
  if (tmp___35 == 0) {
#line 462
    return;
  }
  {
#line 464
  tmp___36 = strncmp((char const   *)p, "html:", (size_t )5);
  }
#line 464
  if (tmp___36 == 0) {
#line 465
    return;
  }
  {
#line 468
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"@beginspecial\n");
  }
  {
#line 469
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 469
    p = GetKeyStr(p, & k);
    }
#line 469
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 469
      goto while_break___6;
    }
#line 471
    if ((unsigned int )k.vt == 0U) {
      {
#line 471
      tmp___39 = access((char const   *)k.Key, 0);
      }
#line 471
      if (tmp___39 == 0) {
#line 472
        if (sf) {
          {
#line 473
          Warning("  More than one \\special file name given. %s ignored", sf);
          }
        }
        {
#line 474
        strcpy((char */* __restrict  */)(spbuf), (char const   */* __restrict  */)k.Key);
#line 475
        sf = spbuf;
        }
      } else {
#line 471
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 476
      tmp___38 = GetKeyVal(& k, KeyTab, sizeof(KeyTab) / sizeof(KeyTab[0]), & i);
      }
#line 476
      if (tmp___38) {
#line 476
        if (i != -1) {
#line 477
          if (i == 0) {
#line 477
            goto _L;
          } else
#line 477
          if (i == 1) {
            _L: /* CIL Label */ 
#line 478
            if (sf) {
              {
#line 479
              Warning("  More than one \\special file name given. %s ignored", sf);
              }
            }
            {
#line 480
            strcpy((char */* __restrict  */)(spbuf), (char const   */* __restrict  */)k.Val);
#line 481
            sf = spbuf;
            }
#line 482
            if (i == 1) {
              {
#line 482
              tmp___37 = scanfile(sf, & llx, & lly, & urx, & ury);
              }
#line 482
              if (tmp___37) {
                {
#line 483
                fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%f %f %f %f true @bbox\n",
                        (double )llx, (double )lly, (double )urx, (double )ury);
#line 485
                fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"@ecl\n");
                }
              }
            }
          } else {
            {
#line 488
            fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%f @%s\n",
                    (double )k.v.n, KeyTab[i].Entry);
            }
          }
        } else {
          {
#line 490
          Warning("  Invalid keyword or value in \\special - \"%s\" ignored", k.Key);
          }
        }
      } else {
        {
#line 490
        Warning("  Invalid keyword or value in \\special - \"%s\" ignored", k.Key);
        }
      }
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 494
  fputs((char const   */* __restrict  */)"@setspecial\n", (FILE */* __restrict  */)outfp);
  }
#line 495
  if (sf) {
#line 496
    if ((int )*sf == 96) {
      {
#line 497
      sf ++;
#line 497
      ps_createpipe(sf);
      }
    } else {
      {
#line 499
      ps_copyfigfile(sf);
      }
    }
  } else {
    {
#line 501
    Warning("  No special file name provided.");
    }
  }
  {
#line 502
  fputs((char const   */* __restrict  */)"@endspecial\n", (FILE */* __restrict  */)outfp);
  }
#line 503
  return;
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
char KeyStr[257]  ;
#line 518 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
char ValStr[257]  ;
#line 520 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
char *GetKeyStr(char *str , KeyWord *kw ) 
{ 
  char *s ;
  char *k ;
  char *v___0 ;
  char t ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 526
  if (! str) {
#line 527
    return ((char *)((void *)0));
  }
#line 528
  s = str;
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! ((int )*s == 32)) {
#line 528
      goto while_break;
    }
#line 528
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  if ((int )*s == 0) {
#line 531
    return ((char *)((void *)0));
  }
#line 534
  k = KeyStr;
  {
#line 534
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 534
    if ((int )*s != 32) {
#line 534
      if ((int )*s != 0) {
#line 534
        if (! ((int )*s != 61)) {
#line 534
          goto while_break___0;
        }
      } else {
#line 534
        goto while_break___0;
      }
    } else {
#line 534
      goto while_break___0;
    }
#line 534
    tmp = k;
#line 534
    k ++;
#line 534
    tmp___0 = s;
#line 534
    s ++;
#line 534
    *tmp = *tmp___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 536
  *k = (char )'\000';
#line 538
  kw->Key = KeyStr;
#line 539
  v___0 = (char *)((void *)0);
#line 539
  kw->Val = v___0;
#line 540
  kw->vt = (ValTyp )0;
  {
#line 541
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 541
    if (! ((int )*s == 32)) {
#line 541
      goto while_break___1;
    }
#line 541
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 543
  if ((int )*s != 61) {
#line 544
    return (s);
  }
#line 546
  s ++;
  {
#line 546
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 546
    if (! ((int )*s == 32)) {
#line 546
      goto while_break___2;
    }
#line 546
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 548
  if ((int )*s == 39) {
#line 549
    tmp___1 = s;
#line 549
    s ++;
#line 549
    t = *tmp___1;
  } else
#line 548
  if ((int )*s == 34) {
#line 549
    tmp___1 = s;
#line 549
    s ++;
#line 549
    t = *tmp___1;
  } else {
#line 551
    t = (char )' ';
  }
#line 553
  v___0 = ValStr;
  {
#line 553
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 553
    if ((int )*s != (int )t) {
#line 553
      if (! ((int )*s != 0)) {
#line 553
        goto while_break___3;
      }
    } else {
#line 553
      goto while_break___3;
    }
#line 553
    tmp___2 = v___0;
#line 553
    v___0 ++;
#line 553
    tmp___3 = s;
#line 553
    s ++;
#line 553
    *tmp___2 = *tmp___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 555
  if ((int )t != 32) {
#line 555
    if ((int )*s == (int )t) {
#line 556
      s ++;
    }
  }
#line 557
  *v___0 = (char )'\000';
#line 558
  kw->Val = ValStr;
#line 559
  kw->vt = (ValTyp )1;
#line 561
  return (s);
}
}
#line 574 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
int GetKeyVal(KeyWord *kw , KeyDesc *tab , int nt___0 , int *tno ) 
{ 
  int i ;
  char c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 581
  c = (char )'\000';
#line 583
  *tno = -1;
#line 585
  i = 0;
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    if (! (i < nt___0)) {
#line 585
      goto while_break;
    }
    {
#line 586
    tmp___1 = IsSame(kw->Key, (tab + i)->Entry);
    }
#line 586
    if (tmp___1) {
#line 587
      *tno = i;
      {
#line 589
      if ((unsigned int )(tab + i)->Type == 0U) {
#line 589
        goto case_0;
      }
#line 593
      if ((unsigned int )(tab + i)->Type == 1U) {
#line 593
        goto case_1;
      }
#line 597
      if ((unsigned int )(tab + i)->Type == 2U) {
#line 597
        goto case_2;
      }
#line 604
      if ((unsigned int )(tab + i)->Type == 4U) {
#line 604
        goto case_4;
      }
#line 604
      if ((unsigned int )(tab + i)->Type == 3U) {
#line 604
        goto case_4;
      }
#line 588
      goto switch_break;
      case_0: /* CIL Label */ 
#line 590
      if ((unsigned int )kw->vt != 0U) {
#line 591
        return (0);
      }
#line 592
      goto switch_break;
      case_1: /* CIL Label */ 
#line 594
      if ((unsigned int )kw->vt != 1U) {
#line 595
        return (0);
      }
#line 596
      goto switch_break;
      case_2: /* CIL Label */ 
#line 598
      if ((unsigned int )kw->vt != 1U) {
#line 599
        return (0);
      }
      {
#line 600
      tmp = sscanf((char const   */* __restrict  */)kw->Val, (char const   */* __restrict  */)"%d%c",
                   & kw->v.i, & c);
      }
#line 600
      if (tmp != 1) {
#line 601
        return (0);
      } else
#line 600
      if ((int )c != 0) {
#line 601
        return (0);
      }
#line 602
      goto switch_break;
      case_4: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 605
      if ((unsigned int )kw->vt != 1U) {
#line 606
        return (0);
      }
      {
#line 607
      tmp___0 = sscanf((char const   */* __restrict  */)kw->Val, (char const   */* __restrict  */)"%f%c",
                       & kw->v.n, & c);
      }
#line 607
      if (tmp___0 != 1) {
#line 608
        return (0);
      } else
#line 607
      if ((int )c != 0) {
#line 608
        return (0);
      }
#line 609
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 611
      kw->vt = (tab + i)->Type;
#line 612
      return (1);
    }
#line 585
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 615
  return (1);
}
}
#line 618 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
char ToLower(char c ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 621
  tmp___2 = __ctype_b_loc();
  }
#line 621
  if ((int const   )*(*tmp___2 + (int )c) & 256) {
    {
#line 621
    tmp___0 = tolower((int )c);
#line 621
    tmp___1 = tmp___0;
    }
  } else {
#line 621
    tmp___1 = (int )c;
  }
#line 621
  return ((char )tmp___1);
}
}
#line 624 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
int IsSame(char *a , char *b ) 
{ 
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;

  {
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! ((int )*a != 0)) {
#line 627
      goto while_break;
    }
    {
#line 628
    tmp = a;
#line 628
    a ++;
#line 628
    tmp___0 = ToLower(*tmp);
#line 628
    tmp___1 = b;
#line 628
    b ++;
#line 628
    tmp___2 = ToLower(*tmp___1);
    }
#line 628
    if ((int )tmp___0 != (int )tmp___2) {
#line 629
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 630
  if ((int )*a == (int )*b) {
#line 630
    tmp___3 = 1;
  } else {
#line 630
    tmp___3 = 0;
  }
#line 630
  return (tmp___3);
}
}
#line 637 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
BOOLEAN scanfile(char *str , float *llx , float *lly , float *urx , float *ury ) 
{ 
  FILE *spfp ;
  char buffer[8192] ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 646
  spfp = fopen((char const   */* __restrict  */)str, (char const   */* __restrict  */)"r");
  }
#line 646
  if ((unsigned long )spfp == (unsigned long )((void *)0)) {
    {
#line 647
    Warning("Unable to open file %s", str);
    }
#line 648
    return (0);
  }
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 650
    tmp___4 = fgets((char */* __restrict  */)(buffer), 8192, (FILE */* __restrict  */)spfp);
    }
#line 650
    if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 650
      goto while_break;
    }
#line 651
    i = 0;
#line 652
    tmp___2 = i;
#line 652
    i ++;
#line 652
    if ((int )buffer[tmp___2] == 37) {
#line 652
      tmp___3 = i;
#line 652
      i ++;
#line 652
      if ((int )buffer[tmp___3] == 37) {
        {
#line 653
        tmp___1 = strncmp((char const   *)(& buffer[i]), "BoundingBox:", (size_t )12);
        }
#line 653
        if (! tmp___1) {
          {
#line 654
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 654
            tmp = i;
#line 654
            i ++;
#line 654
            if (! ((int )buffer[tmp] != 58)) {
#line 654
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 656
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 656
            if (! ((int )buffer[i] == 32)) {
#line 656
              goto while_break___1;
            }
#line 656
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 658
          if ((int )buffer[i] != 63) {
            {
#line 658
            tmp___0 = strncmp((char const   *)(& buffer[i]), "(atend)", (size_t )7);
            }
#line 658
            if (tmp___0) {
              {
#line 659
              sscanf((char const   */* __restrict  */)(& buffer[i]), (char const   */* __restrict  */)"%f %f %f %f",
                     llx, lly, urx, ury);
#line 660
              fclose(spfp);
              }
#line 661
              return (1);
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 666
  fclose(spfp);
  }
#line 667
  return (0);
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void push_location(void) 
{ 


  {
  {
#line 688
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%.3f @push\n",
          (double )((float )mag / (float )1000));
  }
#line 689
  return;
}
}
#line 694 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void pop_location(void) 
{ 


  {
  {
#line 696
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"@pop\n");
  }
#line 697
  return;
}
}
#line 707 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void ps_pensize(char *cp ) 
{ 
  int size ;
  int tmp ;

  {
  {
#line 712
  tmp = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%d ",
               & size);
  }
#line 712
  if (tmp != 1) {
    {
#line 713
    Warning("Illegal format for pn: %s", cp);
    }
#line 714
    return;
  }
#line 716
  pensize = (int )((double )size * ((double )((float )resolution) / 1000.0) + 0.5);
#line 717
  if (pensize < 0) {
#line 717
    pensize = 0;
  }
#line 718
  return;
}
}
#line 724 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void set_pen_size(void) 
{ 


  {
  {
#line 726
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%d setlinewidth\n",
          pensize);
  }
#line 727
  return;
}
}
#line 733 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void do_attributes(void) 
{ 


  {
  {
#line 736
  if (shade_next == 1) {
#line 736
    goto case_1;
  }
#line 739
  if (shade_next == 2) {
#line 739
    goto case_2;
  }
#line 742
  if (shade_next == 3) {
#line 742
    goto case_3;
  }
#line 735
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 737
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"0 setgray ");
  }
#line 738
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 740
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%1.3f setgray ",
          graylevel);
  }
#line 741
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 743
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"1 setgray ");
  }
#line 744
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 746
  shade_next = 0;
#line 747
  return;
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void ps_flushpath(int invisible ) 
{ 
  int i ;

  {
  {
#line 758
  push_location();
  }
#line 759
  if (pathlen <= 0) {
#line 759
    return;
  }
  {
#line 760
  set_pen_size();
#line 761
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%d %d p\n",
          xx[1], yy[1]);
#line 762
  i = 2;
  }
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;
#line 762
    if (! (i <= pathlen)) {
#line 762
      goto while_break;
    }
    {
#line 763
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%d %d l\n",
            xx[i], yy[i]);
#line 762
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 765
  pathlen = 0;
#line 766
  if (shade_next == 0) {
    {
#line 767
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"stroke\n");
    }
  } else
#line 769
  if (invisible) {
    {
#line 770
    do_attributes();
#line 771
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"fill\n");
    }
  } else {
    {
#line 773
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"gsave ");
#line 774
    do_attributes();
#line 775
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"fill grestore stroke\n");
    }
  }
  {
#line 778
  pop_location();
  }
#line 779
  return;
}
}
#line 787 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void ps_flushdashedpath(char *cp , int dotted ) 
{ 
  int i ;
  int ipd ;
  float inchesperdash ;
  int tmp ;

  {
  {
#line 795
  tmp = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%f ",
               & inchesperdash);
  }
#line 795
  if (tmp != 1) {
    {
#line 796
    Warning("Illegal format for dotted/dashed line da/dt: %s", cp);
    }
#line 797
    return;
  }
#line 799
  ipd = (int )(1000.0 * (double )inchesperdash + 0.5);
#line 800
  if (ipd == 0) {
#line 801
    ipd = 1;
  }
  {
#line 802
  push_location();
  }
#line 803
  if (pathlen <= 0) {
#line 803
    return;
  }
  {
#line 804
  set_pen_size();
#line 805
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%d %d p\n",
          xx[1], yy[1]);
#line 806
  i = 2;
  }
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 806
    if (! (i <= pathlen)) {
#line 806
      goto while_break;
    }
#line 807
    if (dotted) {
      {
#line 808
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"1 setlinecap\n");
#line 809
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"[%d %d] 0 setdash\n",
              pensize, (int )((double )ipd * ((double )((float )resolution) / 1000.0) + 0.5) - pensize);
      }
    } else {
      {
#line 812
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"[%d] 0 setdash\n",
              (int )((double )ipd * ((double )((float )resolution) / 1000.0) + 0.5));
      }
    }
    {
#line 814
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%d %d l\n",
            xx[i], yy[i]);
#line 806
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 816
  pathlen = 0;
#line 817
  if (shade_next == 0) {
    {
#line 818
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"stroke\n");
    }
  } else {
    {
#line 820
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"gsave ");
#line 821
    do_attributes();
#line 822
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"fill grestore stroke\n");
    }
  }
  {
#line 824
  pop_location();
  }
#line 825
  return;
}
}
#line 835 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void ps_drawto(char *cp ) 
{ 
  int x ;
  int y ;
  int tmp ;

  {
  {
#line 840
  tmp = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%d %d ",
               & x, & y);
  }
#line 840
  if (tmp != 2) {
    {
#line 841
    Warning("Illegal format for pa: %s", cp);
    }
#line 842
    return;
  }
#line 844
  pathlen ++;
#line 844
  if (pathlen >= 600) {
    {
#line 845
    Fatal("Too many points specified\n", 0);
    }
  }
#line 846
  xx[pathlen] = (int )((double )x * ((double )((float )resolution) / 1000.0) + 0.5);
#line 847
  yy[pathlen] = (int )((double )y * ((double )((float )resolution) / 1000.0) + 0.5);
#line 848
  return;
}
}
#line 850 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void ps_arc(char *cp , int invisible ) 
{ 
  int xc ;
  int yc ;
  int xrad ;
  int yrad ;
  float start_angle ;
  float end_angle ;
  short alpha0 ;
  short alpha1 ;
  int tmp ;

  {
  {
#line 858
  tmp = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%d %d %d %d %f %f ",
               & xc, & yc, & xrad, & yrad, & start_angle, & end_angle);
  }
#line 858
  if (tmp != 6) {
    {
#line 860
    Warning("Illegal format for arc: %s", cp);
    }
#line 861
    return;
  }
  {
#line 863
  push_location();
#line 864
  set_pen_size();
  }
#line 866
  if ((double )start_angle < 0.0) {
#line 867
    start_angle = (float )((double )start_angle + 3.14157926536 * 2.0);
  }
#line 868
  if ((double )end_angle < 0.0) {
#line 869
    end_angle = (float )((double )end_angle + 3.14157926536 * 2.0);
  }
  {
#line 870
  alpha0 = (short )((double )start_angle * ((double )360 / (3.14157926536 * 2.0)) + 0.5);
#line 871
  alpha1 = (short )((double )end_angle * ((double )360 / (3.14157926536 * 2.0)) + 0.5);
#line 872
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%d %d %d %d %d %d @ar\n",
          (int )((double )xc * ((double )((float )resolution) / 1000.0) + 0.5), (int )((double )yc * ((double )((float )resolution) / 1000.0) + 0.5),
          (int )((double )xrad * ((double )((float )resolution) / 1000.0) + 0.5),
          (int )((double )yrad * ((double )((float )resolution) / 1000.0) + 0.5),
          (int )alpha0, (int )alpha1);
  }
#line 875
  if (shade_next == 0) {
    {
#line 876
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"stroke\n");
    }
  } else
#line 878
  if (invisible) {
    {
#line 879
    do_attributes();
#line 880
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"fill\n");
    }
  } else {
    {
#line 882
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"gsave ");
#line 883
    do_attributes();
#line 884
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"fill grestore stroke\n");
    }
  }
  {
#line 887
  pop_location();
  }
#line 888
  return;
}
}
#line 897 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
int splinex[5000]  ;
#line 897 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
int spliney[5000]  ;
#line 897 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
int splinelen  ;
#line 898 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void ps_flushspline(char *cp ) 
{ 
  int xp ;
  int yp ;
  int N ;
  double t1 ;
  double t2 ;
  double t3 ;
  double w ;
  int i ;
  int j ;
  int steps ;
  float f ;
  int ipd ;
  float tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 905
  push_location();
#line 906
  set_pen_size();
  }
#line 907
  if (*cp) {
    {
#line 911
    sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%f",
           & f);
    }
#line 912
    if (f > (float )0) {
#line 912
      tmp = f;
    } else {
#line 912
      tmp = - f;
    }
#line 912
    ipd = (int )(1000.0 * (double )tmp + 0.5);
#line 913
    if (ipd == 0) {
#line 914
      ipd = 1;
    }
#line 915
    if ((double )f < 0.0) {
      {
#line 916
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"1 setlinecap\n");
#line 917
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"[%d %d] 0 setdash\n",
              pensize, (int )((double )ipd * ((double )((float )resolution) / 1000.0) + 0.5) - pensize);
      }
    } else
#line 919
    if ((double )f > 0.0) {
      {
#line 920
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"[%d] 0 setdash\n",
              (int )((double )ipd * ((double )((float )resolution) / 1000.0) + 0.5));
      }
    }
  }
#line 922
  splinelen = 0;
#line 923
  N = pathlen + 1;
#line 924
  xx[0] = xx[1];
#line 925
  yy[0] = yy[1];
#line 926
  xx[N] = xx[N - 1];
#line 927
  yy[N] = yy[N - 1];
#line 928
  i = 0;
  {
#line 928
  while (1) {
    while_continue: /* CIL Label */ ;
#line 928
    if (! (i < N - 1)) {
#line 928
      goto while_break;
    }
    {
#line 929
    tmp___0 = dist(xx[i], yy[i], xx[i + 1], yy[i + 1]);
#line 929
    tmp___1 = dist(xx[i + 1], yy[i + 1], xx[i + 2], yy[i + 2]);
#line 929
    steps = (tmp___0 + tmp___1) / 20;
#line 931
    j = 0;
    }
    {
#line 931
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 931
      if (! (j < steps)) {
#line 931
        goto while_break___0;
      }
#line 932
      w = ((double )j + 0.5) / (double )steps;
#line 933
      t1 = (0.5 * w) * w;
#line 934
      w -= 0.5;
#line 935
      t2 = 0.75 - w * w;
#line 936
      w -= 0.5;
#line 937
      t3 = (0.5 * w) * w;
#line 938
      xp = (int )(((t1 * (double )xx[i + 2] + t2 * (double )xx[i + 1]) + t3 * (double )xx[i]) + 0.5);
#line 939
      yp = (int )(((t1 * (double )yy[i + 2] + t2 * (double )yy[i + 1]) + t3 * (double )yy[i]) + 0.5);
#line 940
      if (splinelen >= 5000) {
        {
#line 941
        Fatal("Too many points in spline\n", 0);
        }
      }
#line 942
      splinex[splinelen] = xp;
#line 943
      tmp___2 = splinelen;
#line 943
      splinelen ++;
#line 943
      spliney[tmp___2] = yp;
#line 931
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 928
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 946
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%d %d p\n",
          splinex[0], spliney[0]);
#line 947
  i = 1;
  }
  {
#line 947
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 947
    if (! (i < splinelen)) {
#line 947
      goto while_break___1;
    }
    {
#line 948
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%d %d l\n",
            splinex[i], spliney[i]);
#line 947
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 951
  pathlen = 0;
#line 952
  if (shade_next == 0) {
    {
#line 953
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"stroke\n");
    }
  } else {
    {
#line 955
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"gsave ");
#line 956
    do_attributes();
#line 957
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"fill grestore stroke\n");
    }
  }
  {
#line 959
  pop_location();
  }
#line 960
  return;
}
}
#line 962 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static int dist(int x1 , int y1___0 , int x2 , int y2 ) 
{ 
  double dx ;
  double dy ;
  double tmp ;

  {
  {
#line 966
  dx = (double )(x2 - x1);
#line 967
  dy = (double )(y2 - y1___0);
#line 968
  tmp = sqrt(dx * dx + dy * dy);
  }
#line 968
  return ((int )(tmp + 0.5));
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void ps_whiten(void) 
{ 


  {
#line 977
  shade_next = 3;
#line 978
  return;
}
}
#line 984 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void ps_blacken(void) 
{ 


  {
#line 986
  shade_next = 1;
#line 987
  return;
}
}
#line 994 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void ps_shade(char *cp ) 
{ 
  float f ;
  int tmp ;

  {
#line 997
  if (*cp) {
    {
#line 1000
    tmp = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%f",
                 & f);
    }
#line 1000
    if (tmp != 1) {
      {
#line 1001
      Warning("Illegal format for shading value sh: %s", cp);
      }
#line 1002
      return;
    }
#line 1004
    if ((double )f >= 0.0) {
#line 1004
      if ((double )f <= 1.0) {
#line 1005
        graylevel = 1.0 - (double )f;
      }
    }
  } else {
#line 1007
    graylevel = 0.5;
  }
#line 1008
  shade_next = 2;
#line 1009
  return;
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void ps_texture(char *cp ) 
{ 
  int blackbits ;
  int totalbits ;

  {
#line 1014
  blackbits = 0;
#line 1014
  totalbits = 0;
  {
#line 1016
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1016
    if (! *cp) {
#line 1016
      goto while_break;
    }
    {
#line 1018
    if ((int )*cp == 48) {
#line 1018
      goto case_48;
    }
#line 1024
    if ((int )*cp == 56) {
#line 1024
      goto case_56;
    }
#line 1024
    if ((int )*cp == 52) {
#line 1024
      goto case_56;
    }
#line 1024
    if ((int )*cp == 50) {
#line 1024
      goto case_56;
    }
#line 1024
    if ((int )*cp == 49) {
#line 1024
      goto case_56;
    }
#line 1035
    if ((int )*cp == 67) {
#line 1035
      goto case_67;
    }
#line 1035
    if ((int )*cp == 99) {
#line 1035
      goto case_67;
    }
#line 1035
    if ((int )*cp == 65) {
#line 1035
      goto case_67;
    }
#line 1035
    if ((int )*cp == 97) {
#line 1035
      goto case_67;
    }
#line 1035
    if ((int )*cp == 57) {
#line 1035
      goto case_67;
    }
#line 1035
    if ((int )*cp == 54) {
#line 1035
      goto case_67;
    }
#line 1035
    if ((int )*cp == 53) {
#line 1035
      goto case_67;
    }
#line 1035
    if ((int )*cp == 51) {
#line 1035
      goto case_67;
    }
#line 1045
    if ((int )*cp == 69) {
#line 1045
      goto case_69;
    }
#line 1045
    if ((int )*cp == 101) {
#line 1045
      goto case_69;
    }
#line 1045
    if ((int )*cp == 68) {
#line 1045
      goto case_69;
    }
#line 1045
    if ((int )*cp == 100) {
#line 1045
      goto case_69;
    }
#line 1045
    if ((int )*cp == 66) {
#line 1045
      goto case_69;
    }
#line 1045
    if ((int )*cp == 98) {
#line 1045
      goto case_69;
    }
#line 1045
    if ((int )*cp == 55) {
#line 1045
      goto case_69;
    }
#line 1050
    if ((int )*cp == 70) {
#line 1050
      goto case_70;
    }
#line 1050
    if ((int )*cp == 102) {
#line 1050
      goto case_70;
    }
#line 1054
    if ((int )*cp == 32) {
#line 1054
      goto case_32;
    }
#line 1056
    goto switch_default;
    case_48: /* CIL Label */ 
#line 1019
    totalbits += 4;
#line 1020
    goto switch_break;
    case_56: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 1025
    blackbits ++;
#line 1026
    totalbits += 4;
#line 1027
    goto switch_break;
    case_67: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_51: /* CIL Label */ 
#line 1036
    blackbits += 2;
#line 1037
    totalbits += 4;
#line 1038
    goto switch_break;
    case_69: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_55: /* CIL Label */ 
#line 1046
    blackbits += 3;
#line 1047
    totalbits += 4;
#line 1048
    goto switch_break;
    case_70: /* CIL Label */ 
    case_102: /* CIL Label */ 
#line 1051
    blackbits += 4;
#line 1052
    totalbits += 4;
#line 1053
    goto switch_break;
    case_32: /* CIL Label */ 
#line 1055
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1058
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1060
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1062
  graylevel = 1.0 - (double )blackbits / (double )totalbits;
#line 1063
  shade_next = 2;
#line 1064
  return;
}
}
#line 1066 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void ps_rotate(char *cp ) 
{ 
  int x ;
  int y ;
  float angle ;
  int tmp ;

  {
  {
#line 1072
  tmp = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%d %d %f",
               & x, & y, & angle);
  }
#line 1072
  if (tmp != 3) {
    {
#line 1073
    Warning("Illegal format for rt: %s", cp);
    }
#line 1074
    return;
  }
  {
#line 1076
  dev_initfont();
  }
#line 1077
  if (angle == (float )0) {
#line 1077
    if (is_rotated) {
      {
#line 1078
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"currentpoint grestore moveto\n");
#line 1079
      is_rotated = 0;
      }
    } else {
#line 1077
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1081
    if (is_rotated) {
      {
#line 1082
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"currentpoint grestore moveto\n");
      }
    } else {
#line 1084
      is_rotated = 1;
    }
    {
#line 1085
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"gsave currentpoint %d add exch %d add exch 2 copy\n",
            (int )((double )y * ((double )((float )resolution) / 1000.0) + 0.5), (int )((double )x * ((double )((float )resolution) / 1000.0) + 0.5));
#line 1087
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"translate %f rotate neg exch neg exch translate\n",
            (double )angle * ((double )360 / (3.14157926536 * 2.0)));
    }
  }
#line 1090
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void ps_setrgbcolor(char *cp ) 
{ 
  float r___0 ;
  float g ;
  float b ;

  {
  {
#line 1097
  sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%f %f %f",
         & r___0, & g, & b);
#line 1098
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%f %f %f @RGB\n",
          (double )r___0, (double )g, (double )b);
  }
#line 1099
  return;
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void ps_sethsbcolor(char *cp ) 
{ 
  float h___0 ;
  float s ;
  float b ;

  {
  {
#line 1106
  sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%f %f %f",
         & h___0, & s, & b);
#line 1107
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%f %f %f @HSB\n",
          (double )h___0, (double )s, (double )b);
  }
#line 1108
  return;
}
}
#line 1110 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psspecial.c"
static void ps_setcmykcolor(char *cp ) 
{ 
  float c ;
  float m ;
  float y ;
  float k ;

  {
  {
#line 1115
  sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%f %f %f %f",
         & c, & m, & y, & k);
#line 1116
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%f %f %f %f @CMYK\n",
          (double )c, (double )m, (double )y, (double )k);
  }
#line 1117
  return;
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
int decomptype_init(char *pars , struct decomp **ff ) ;
#line 11
int decomptype_access(struct decomp *ffdcmp , struct font_entry *fe , struct accarg *acca ) ;
#line 12
void init_decomp_fontinfo(struct font_entry *fe ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
struct fontop dcmpop  =    {(char *)"decomp", & decomptype_init, & decomptype_access, & init_decomp_fontinfo};
#line 20 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
int decomptype_init(char *pars , struct decomp **ff ) 
{ 
  char *p1 ;
  char *p2 ;
  int dt ;
  struct decomp *ffdcmp ;
  int tmp ;
  int tmp___0 ;
  int tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 28
  tmp = getstrtok(pars, ',', & p1);
  }
#line 28
  if (! tmp) {
#line 29
    return (0);
  }
  {
#line 30
  tmp___0 = getstrtok(p1, '\000', & p2);
  }
#line 30
  if (! tmp___0) {
#line 31
    return (0);
  }
  {
#line 32
  tmp___2 = strcmp((char const   *)p1, "ntt");
  }
#line 32
  if (tmp___2 == 0) {
#line 32
    dt = 0;
  } else {
#line 32
    dt = 1;
  }
  {
#line 33
  tmp___3 = malloc((size_t )((unsigned int )sizeof(struct decomp )));
#line 33
  tmp___4 = alloc_check(tmp___3, "decomp init");
#line 33
  ffdcmp = (struct decomp *)tmp___4;
#line 34
  ffdcmp->dcmp_type = (char )dt;
#line 35
  ffdcmp->dcmp_name = strsave(pars);
#line 36
  *ff = ffdcmp;
  }
#line 37
  return (1);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
int decomptype_access(struct decomp *ffdcmp , struct font_entry *fe , struct accarg *acca ) 
{ 
  struct decomp *ffnew ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
#line 48
  if (debug >= 1) {
    {
#line 49
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trying to decompose %s/%s\n",
            fe->n, ffdcmp->dcmp_name);
    }
  }
  {
#line 52
  tmp___4 = strlen((char const   *)ffdcmp->dcmp_name);
#line 52
  tmp___5 = strncmp((char const   *)(fe->n), (char const   *)ffdcmp->dcmp_name, tmp___4);
  }
#line 52
  if (tmp___5 == 0) {
    {
#line 53
    tmp___2 = strlen((char const   *)ffdcmp->dcmp_name);
#line 53
    tmp___3 = numstr(fe->n + tmp___2);
    }
#line 53
    if (tmp___3) {
#line 54
      if ((int )ffdcmp->dcmp_type == 0) {
#line 54
        tmp = 33;
      } else {
#line 54
        tmp = 47;
      }
      {
#line 54
      tmp___0 = malloc((unsigned long )((unsigned int )sizeof(struct decomp )) + (unsigned long )tmp * sizeof(struct font_entry *));
#line 54
      tmp___1 = alloc_check(tmp___0, "decomp init");
#line 54
      ffnew = (struct decomp *)tmp___1;
#line 60
      *ffnew = *ffdcmp;
#line 61
      fe->finfo = (void *)((struct finfo *)ffnew);
      }
#line 62
      return (1);
    }
  }
#line 65
  return (0);
}
}
#line 72
void init_dcmpntt_fontinfo(struct font_entry *fe ) ;
#line 72
void init_dcmpdcd_fontinfo(struct font_entry *fe ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
void init_decomp_fontinfo(struct font_entry *fe ) 
{ 


  {
#line 74
  if ((int )((struct decomp *)fe->finfo)->dcmp_type == 0) {
    {
#line 75
    init_dcmpntt_fontinfo(fe);
    }
  } else {
    {
#line 77
    init_dcmpdcd_fontinfo(fe);
    }
  }
#line 78
  return;
}
}
#line 89
int dcmpntt_markchar(int c ) ;
#line 90
void read_dcmpntt_fontinfo(struct font_entry *fe ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
void init_dcmpntt_fontinfo(struct font_entry *fe ) 
{ 
  struct decomp *ffdcmp ;
  char *ntail ;
  char n[257] ;
  int i ;
  struct font_index *fontidx ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 92
  ffdcmp = (struct decomp *)fe->finfo;
#line 93
  tmp = strlen((char const   *)ffdcmp->dcmp_name);
#line 93
  ntail = fe->n + tmp;
#line 94
  fontidx = (struct font_index *)((void *)0);
#line 95
  i = 1;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i <= 33)) {
#line 95
      goto while_break;
    }
    {
#line 96
    sprintf((char */* __restrict  */)(n), (char const   */* __restrict  */)"%s%s%s",
            ffdcmp->dcmp_name, jsf_names[i], ntail);
#line 97
    tmp___0 = strlen((char const   *)(n));
#line 97
    readfontdef(i, 0, fe->s, fe->d, 0, tmp___0, n, & fontidx);
#line 98
    ffdcmp->dcmp_fetab[i] = fontidx->fent;
#line 95
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  fe->dev_setchar = & dcmpntt_markchar;
#line 101
  fe->fnt_readfontinfo = & read_dcmpntt_fontinfo;
#line 102
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
int dcmpntt_markchar(int c ) 
{ 
  unsigned short f ;
  unsigned short cc ;
  struct font_entry *save_curfontent ;

  {
  {
#line 119
  jis_to_jsub(c >> 8, c & 255, & f, & cc);
#line 120
  save_curfontent = curfontent;
#line 120
  curfontent = ((struct decomp *)curfontent->finfo)->dcmp_fetab[f];
#line 120
  MarkChar((int )cc);
#line 120
  curfontent = save_curfontent;
  }
#line 121
  return (0);
}
}
#line 127
DEV_FONT dcmpntt_fontdict(struct font_entry *fe , int c ) ;
#line 128
int dcmpntt_setchar(unsigned int c ) ;
#line 128
int dcmpntt_setstring(byte *s , int len ) ;
#line 123 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
void read_dcmpntt_fontinfo(struct font_entry *fe ) 
{ 


  {
#line 130
  fe->rvf_setchar = & virf_setchar;
#line 131
  fe->rvf_setstring = & virf_setstring;
#line 132
  fe->dev_fontdict = & dcmpntt_fontdict;
#line 133
  fe->dev_setchar = & dcmpntt_setchar;
#line 134
  fe->dev_setstring = & dcmpntt_setstring;
#line 135
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
DEV_FONT dcmpntt_fontdict(struct font_entry *fe , int c ) 
{ 
  unsigned short f ;
  unsigned short cc ;
  struct font_entry *sfe ;
  DEV_FONT tmp ;

  {
  {
#line 145
  jis_to_jsub(c >> 8, c & 255, & f, & cc);
#line 146
  sfe = ((struct decomp *)fe->finfo)->dcmp_fetab[f];
#line 147
  tmp = (*(sfe->dev_fontdict))(sfe, (int )cc);
  }
#line 147
  return (tmp);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
int dcmpntt_setchar(unsigned int c ) 
{ 
  unsigned short f ;
  unsigned short cc ;
  struct font_entry *save_curfontent ;

  {
  {
#line 162
  jis_to_jsub(c >> 8, c & 255U, & f, & cc);
#line 163
  save_curfontent = curfontent;
#line 163
  curfontent = ((struct decomp *)curfontent->finfo)->dcmp_fetab[f];
#line 163
  (*(curfontent->rvf_setchar))((int )cc, chmove);
#line 163
  curfontent = save_curfontent;
  }
#line 164
  return (0);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
int dcmpntt_setstring(byte *s , int len ) 
{ 


  {
  {
#line 172
  Fatal("%s implementation error: dcmpntt_setstring", G_progname);
  }
#line 173
  return (0);
}
}
#line 184
int dcmpdcd_markchar(int c ) ;
#line 185
void read_dcmpdcd_fontinfo(struct font_entry *fe ) ;
#line 175 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
void init_dcmpdcd_fontinfo(struct font_entry *fe ) 
{ 
  struct decomp *ffdcmp ;
  char *ntail ;
  char n[257] ;
  int i ;
  struct font_index *fontidx ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 187
  ffdcmp = (struct decomp *)fe->finfo;
#line 188
  tmp = strlen((char const   *)ffdcmp->dcmp_name);
#line 188
  ntail = fe->n + tmp;
#line 189
  fontidx = (struct font_index *)((void *)0);
#line 190
  i = 1;
  }
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i <= 47)) {
#line 190
      goto while_break;
    }
    {
#line 191
    sprintf((char */* __restrict  */)(n), (char const   */* __restrict  */)"%s%c%02x%c%s",
            ffdcmp->dcmp_name, 'C', 31 + i * 2, 'C', ntail);
#line 193
    tmp___0 = strlen((char const   *)(n));
#line 193
    readfontdef(i, 0, fe->s, fe->d, 0, tmp___0, n, & fontidx);
#line 194
    ffdcmp->dcmp_fetab[i] = fontidx->fent;
#line 190
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  fe->dev_setchar = & dcmpdcd_markchar;
#line 197
  fe->fnt_readfontinfo = & read_dcmpdcd_fontinfo;
#line 198
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
int dcmpdcd_markchar(int c ) 
{ 
  unsigned short f ;
  unsigned short cc ;
  struct font_entry *save_curfontent ;

  {
  {
#line 206
  jis_to_dcode(c >> 8, c & 255, & f, & cc);
#line 207
  save_curfontent = curfontent;
#line 207
  curfontent = ((struct decomp *)curfontent->finfo)->dcmp_fetab[f];
#line 207
  MarkChar((int )cc);
#line 207
  curfontent = save_curfontent;
  }
#line 208
  return (0);
}
}
#line 214
DEV_FONT dcmpdcd_fontdict(struct font_entry *fe , int c ) ;
#line 215
int dcmpdcd_setchar(unsigned int c ) ;
#line 215
int dcmpdcd_setstring(byte *s , int len ) ;
#line 210 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
void read_dcmpdcd_fontinfo(struct font_entry *fe ) 
{ 


  {
#line 217
  fe->rvf_setchar = & virf_setchar;
#line 218
  fe->rvf_setstring = & virf_setstring;
#line 219
  fe->dev_fontdict = & dcmpdcd_fontdict;
#line 220
  fe->dev_setchar = & dcmpdcd_setchar;
#line 221
  fe->dev_setstring = & dcmpdcd_setstring;
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
DEV_FONT dcmpdcd_fontdict(struct font_entry *fe , int c ) 
{ 
  unsigned short f ;
  unsigned short cc ;
  struct font_entry *sfe ;
  DEV_FONT tmp ;

  {
  {
#line 232
  jis_to_dcode(c >> 8, c & 255, & f, & cc);
#line 233
  sfe = ((struct decomp *)fe->finfo)->dcmp_fetab[f];
#line 234
  tmp = (*(sfe->dev_fontdict))(sfe, (int )cc);
  }
#line 234
  return (tmp);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
int dcmpdcd_setchar(unsigned int c ) 
{ 
  unsigned short f ;
  unsigned short cc ;
  struct font_entry *save_curfontent ;

  {
  {
#line 243
  jis_to_dcode(c >> 8, c & 255U, & f, & cc);
#line 244
  save_curfontent = curfontent;
#line 244
  curfontent = ((struct decomp *)curfontent->finfo)->dcmp_fetab[f];
#line 244
  (*(curfontent->rvf_setchar))((int )cc, chmove);
#line 244
  curfontent = save_curfontent;
  }
#line 245
  return (0);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/decompfont.c"
int dcmpdcd_setstring(byte *s , int len ) 
{ 


  {
  {
#line 253
  Fatal("%s implementation error: dcmpdcd_setstring", G_progname);
  }
#line 254
  return (0);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
void dev_copyfile(char *str ) ;
#line 196 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
struct biinitfontinfo *alloc_biinif(struct bifont *bi ) ;
#line 204
struct font_entry *dev_get_repfe(struct bifont *bi ) ;
#line 205
char *dev_fontpath(struct bifont *bi ) ;
#line 207
char *dev_encfile(struct bifont *bi ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/type1font.c"
int mm_markchar(int c ) ;
#line 19
void read_t1_fontinfo(struct font_entry *fe ) ;
#line 23
int dev_set_repfe(struct bifont *bi , struct font_entry *fe ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/type1font.c"
void init_t1_fontinfo(struct font_entry *fe ) 
{ 
  struct font_entry *repfe ;

  {
  {
#line 21
  repfe = dev_get_repfe((*((struct biaccessinfo **)(& fe->finfo)))->bf);
  }
#line 21
  if ((unsigned long )repfe == (unsigned long )((void *)0)) {
    {
#line 22
    *((struct biinitfontinfo **)(& fe->finfo)) = alloc_biinif((*((struct biaccessinfo **)(& fe->finfo)))->bf);
#line 23
    dev_set_repfe((*((struct biinitfontinfo **)(& fe->finfo)))->bf, fe);
    }
  } else {
#line 25
    *((struct biinitfontinfo **)(& fe->finfo)) = *((struct biinitfontinfo **)(& repfe->finfo));
  }
#line 26
  fe->dev_setchar = & mm_markchar;
#line 27
  fe->fnt_readfontinfo = & read_t1_fontinfo;
#line 28
  return;
}
}
#line 48
void dev_t1_initfontdict(struct font_entry *fe , struct biinitfontinfo *bii , char *t1path ,
                         char *encpath ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/type1font.c"
void read_t1_fontinfo(struct font_entry *fe ) 
{ 
  struct biinitfontinfo *bii ;
  struct tfmfntinfo *tfmfi ;
  char *fn ;
  char *filename ;
  void *tmp ;
  char *tmp___0 ;
  struct font_entry *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 40
  bii = *((struct biinitfontinfo **)(& fe->finfo));
#line 41
  tmp = malloc((size_t )((unsigned int )sizeof(struct tfmfntinfo )));
#line 41
  tmp___0 = alloc_check(tmp, "tfmfont info");
#line 41
  tfmfi = (struct tfmfntinfo *)tmp___0;
#line 42
  tfmfi->tfm_bf = bii->bf;
#line 43
  *((struct tfmfntinfo **)(& fe->finfo)) = tfmfi;
#line 44
  read_tfm_finfo(fe);
#line 45
  dev_tfm_initfe(fe);
#line 47
  tmp___1 = dev_get_repfe(bii->bf);
  }
#line 47
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 48
    dev_t1_initfontdict(fe, bii, (void *)0, (void *)0);
    }
#line 49
    return;
  }
  {
#line 51
  fn = dev_fontpath((*((struct tfmfntinfo **)(& fe->finfo)))->tfm_bf);
#line 59
  filename = fn;
  }
#line 62
  if (debug >= 1) {
    {
#line 63
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Type1font %s (for %s)\n",
            filename, fe->n);
    }
  }
  {
#line 65
  tmp___2 = enc_read(bii->bf);
#line 65
  dev_t1_initfontdict(fe, bii, filename, tmp___2);
#line 66
  dev_set_repfe(bii->bf, (void *)0);
  }
#line 67
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/type1font.c"
struct encr *encfiles  =    (struct encr *)((void *)0);
#line 75 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/type1font.c"
char *enc_read(struct bifont *bf ) 
{ 
  char *enc ;
  char *encname ;
  struct encr *er ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 82
  enc = dev_encfile(bf);
#line 94
  encname = enc;
  }
#line 96
  if ((unsigned long )encname == (unsigned long )((void *)0)) {
#line 97
    return ((char *)((void *)0));
  }
#line 98
  er = encfiles;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((unsigned long )er != (unsigned long )((void *)0))) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp = strcmp((char const   *)encname, (char const   *)er->er_filename);
    }
#line 99
    if (tmp == 0) {
#line 100
      return (encname);
    }
#line 98
    er = er->er_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  dev_copyfile(encname);
#line 102
  tmp___0 = malloc((size_t )((unsigned int )sizeof(struct encr )));
#line 102
  tmp___1 = alloc_check(tmp___0, "encr");
#line 102
  er = (struct encr *)tmp___1;
#line 103
  er->er_filename = encname;
#line 104
  er->er_next = encfiles;
#line 105
  encfiles = er;
  }
#line 106
  return (encname);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
int comptype_init(char *pars , struct comp **ff ) ;
#line 11
int comptype_access(struct comp *ffcmp , struct font_entry *fe , struct accarg *acca ) ;
#line 12
void init_comp_fontinfo(struct font_entry *fe ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
struct fontop cmpop  =    {(char *)"comp", & comptype_init, & comptype_access, & init_comp_fontinfo};
#line 20 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
int comptype_init(char *pars , struct comp **ff ) 
{ 
  char *p1 ;
  char *p2 ;
  int dt ;
  struct comp *ffcmp ;
  int tmp ;
  int tmp___0 ;
  int tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 28
  tmp = getstrtok(pars, ',', & p1);
  }
#line 28
  if (! tmp) {
#line 29
    return (0);
  }
  {
#line 30
  tmp___0 = getstrtok(p1, '\000', & p2);
  }
#line 30
  if (! tmp___0) {
#line 31
    return (0);
  }
  {
#line 32
  tmp___2 = strcmp((char const   *)p1, "ntt");
  }
#line 32
  if (tmp___2 == 0) {
#line 32
    dt = 0;
  } else {
#line 32
    dt = 1;
  }
  {
#line 33
  tmp___3 = malloc((size_t )((unsigned int )sizeof(struct comp )));
#line 33
  tmp___4 = alloc_check(tmp___3, "comp init");
#line 33
  ffcmp = (struct comp *)tmp___4;
#line 34
  ffcmp->cmp_type = (char )dt;
#line 35
  ffcmp->cmp_name = strsave(pars);
#line 36
  *ff = ffcmp;
  }
#line 37
  return (1);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
int comptype_access(struct comp *ffcmp , struct font_entry *fe , struct accarg *acca ) 
{ 
  BOOLEAN subpre ;
  int s ;
  char *se ;
  struct comp *ffnew ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
#line 51
  if (debug >= 1) {
    {
#line 52
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trying to compose %s/%s\n",
            fe->n, ffcmp->cmp_name);
    }
  }
  {
#line 55
  tmp___4 = strlen((char const   *)ffcmp->cmp_name);
#line 55
  tmp___5 = strncmp((char const   *)(fe->n), (char const   *)ffcmp->cmp_name, tmp___4);
  }
#line 55
  if (tmp___5 == 0) {
#line 56
    if ((int )ffcmp->cmp_type == 0) {
      {
#line 57
      tmp = strlen((char const   *)ffcmp->cmp_name);
#line 57
      s = getjsubfont(fe->n + tmp, & se);
#line 57
      subpre = s > 0;
      }
    } else {
      {
#line 59
      tmp___0 = strlen((char const   *)ffcmp->cmp_name);
#line 59
      s = getdcode(fe->n + tmp___0, & se);
#line 59
      subpre = s > 0;
      }
    }
#line 60
    if (subpre) {
      {
#line 60
      tmp___3 = numstr(se + 1);
      }
#line 60
      if (tmp___3) {
        {
#line 61
        sprintf((char */* __restrict  */)(fe->name), (char const   */* __restrict  */)"%s%s",
                ffcmp->cmp_name, se + 1);
#line 62
        tmp___1 = malloc((size_t )((unsigned int )sizeof(struct comp )));
#line 62
        tmp___2 = alloc_check(tmp___1, "comp init");
#line 62
        ffnew = (struct comp *)tmp___2;
#line 63
        *ffnew = *ffcmp;
#line 64
        ffnew->cmp_sub = (unsigned short )s;
#line 65
        fe->finfo = (void *)((struct finfo *)ffnew);
        }
#line 66
        return (1);
      }
    }
  }
#line 69
  return (0);
}
}
#line 76
void init_cmpntt_fontinfo(struct font_entry *fe ) ;
#line 76
void init_cmpdcd_fontinfo(struct font_entry *fe ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
void init_comp_fontinfo(struct font_entry *fe ) 
{ 


  {
#line 78
  if ((int )((struct comp *)fe->finfo)->cmp_type == 0) {
    {
#line 79
    init_cmpntt_fontinfo(fe);
    }
  } else {
    {
#line 81
    init_cmpdcd_fontinfo(fe);
    }
  }
#line 82
  return;
}
}
#line 90
int cmpntt_markchar(int c ) ;
#line 91
void read_cmpntt_fontinfo(struct font_entry *fe ) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
void init_cmpntt_fontinfo(struct font_entry *fe ) 
{ 
  struct comp *ffcmp ;
  struct font_index *fontidx ;
  size_t tmp ;

  {
  {
#line 93
  ffcmp = (struct comp *)fe->finfo;
#line 94
  fontidx = (struct font_index *)((void *)0);
#line 95
  tmp = strlen((char const   *)(fe->name));
#line 95
  readfontdef(0, 0, fe->s, fe->d, 0, tmp, fe->name, & fontidx);
#line 96
  ffcmp->cmp_fe = fontidx->fent;
#line 97
  fe->dev_setchar = & cmpntt_markchar;
#line 98
  fe->fnt_readfontinfo = & read_cmpntt_fontinfo;
  }
#line 99
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
int cmpntt_markchar(int c ) 
{ 
  unsigned short ku ;
  unsigned short ten ;
  struct font_entry *save_curfontent ;

  {
  {
#line 115
  jsub_to_jis((int )((struct comp *)curfontent->finfo)->cmp_sub, c, & ku, & ten);
#line 116
  save_curfontent = curfontent;
#line 116
  curfontent = ((struct comp *)curfontent->finfo)->cmp_fe;
#line 116
  MarkChar((int )ku * 256 + (int )ten);
#line 116
  curfontent = save_curfontent;
  }
#line 117
  return (0);
}
}
#line 123
DEV_FONT cmpntt_fontdict(struct font_entry *fe , int c ) ;
#line 124
int cmpntt_setchar(unsigned int c ) ;
#line 124
int cmpntt_setstring(byte *s , int len ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
void read_cmpntt_fontinfo(struct font_entry *fe ) 
{ 


  {
#line 126
  fe->rvf_setchar = & virf_setchar;
#line 127
  fe->rvf_setstring = & virf_setstring;
#line 128
  fe->dev_fontdict = & cmpntt_fontdict;
#line 129
  fe->dev_setchar = & cmpntt_setchar;
#line 130
  fe->dev_setstring = & cmpntt_setstring;
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
DEV_FONT cmpntt_fontdict(struct font_entry *fe , int c ) 
{ 
  unsigned short ku ;
  unsigned short ten ;
  struct font_entry *sfe ;
  DEV_FONT tmp ;

  {
  {
#line 141
  jsub_to_jis((int )((struct comp *)curfontent->finfo)->cmp_sub, c, & ku, & ten);
#line 142
  sfe = ((struct comp *)fe->finfo)->cmp_fe;
#line 143
  tmp = (*(sfe->dev_fontdict))(sfe, (int )ku * 256 + (int )ten);
  }
#line 143
  return (tmp);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
int cmpntt_setchar(unsigned int c ) 
{ 
  unsigned short ku ;
  unsigned short ten ;
  struct font_entry *save_curfontent ;

  {
  {
#line 158
  jsub_to_jis((int )((struct comp *)curfontent->finfo)->cmp_sub, c, & ku, & ten);
#line 159
  save_curfontent = curfontent;
#line 159
  curfontent = ((struct comp *)curfontent->finfo)->cmp_fe;
#line 159
  (*(curfontent->rvf_setchar))((int )ku * 256 + (int )ten, chmove);
#line 159
  curfontent = save_curfontent;
  }
#line 160
  return (0);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
int cmpntt_setstring(byte *s , int len ) 
{ 
  unsigned char *sp ;

  {
#line 170
  sp = s;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! ((unsigned long )sp < (unsigned long )(s + len))) {
#line 170
      goto while_break;
    }
    {
#line 171
    cmpntt_setchar((unsigned int )*sp);
#line 170
    sp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return (0);
}
}
#line 181
int cmpdcd_markchar(int c ) ;
#line 182
void read_cmpdcd_fontinfo(struct font_entry *fe ) ;
#line 175 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
void init_cmpdcd_fontinfo(struct font_entry *fe ) 
{ 
  struct comp *ffcmp ;
  struct font_index *fontidx ;
  size_t tmp ;

  {
  {
#line 184
  ffcmp = (struct comp *)fe->finfo;
#line 185
  fontidx = (struct font_index *)((void *)0);
#line 186
  tmp = strlen((char const   *)(fe->name));
#line 186
  readfontdef(0, 0, fe->s, fe->d, 0, tmp, fe->name, & fontidx);
#line 187
  ffcmp->cmp_fe = fontidx->fent;
#line 188
  fe->dev_setchar = & cmpdcd_markchar;
#line 189
  fe->fnt_readfontinfo = & read_cmpdcd_fontinfo;
  }
#line 190
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
int cmpdcd_markchar(int c ) 
{ 
  unsigned short ku ;
  unsigned short ten ;
  struct font_entry *save_curfontent ;

  {
  {
#line 198
  code_to_jis((int )((struct comp *)curfontent->finfo)->cmp_sub, c, & ku, & ten);
#line 199
  save_curfontent = curfontent;
#line 199
  curfontent = ((struct comp *)curfontent->finfo)->cmp_fe;
#line 199
  MarkChar((int )ku * 256 + (int )ten);
#line 199
  curfontent = save_curfontent;
  }
#line 200
  return (0);
}
}
#line 206
DEV_FONT cmpdcd_fontdict(struct font_entry *fe , int c ) ;
#line 207
int cmpdcd_setchar(unsigned int c ) ;
#line 207
int cmpdcd_setstring(byte *s , int len ) ;
#line 202 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
void read_cmpdcd_fontinfo(struct font_entry *fe ) 
{ 


  {
#line 209
  fe->rvf_setchar = & virf_setchar;
#line 210
  fe->rvf_setstring = & virf_setstring;
#line 211
  fe->dev_fontdict = & cmpdcd_fontdict;
#line 212
  fe->dev_setchar = & cmpdcd_setchar;
#line 213
  fe->dev_setstring = & cmpdcd_setstring;
#line 214
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
DEV_FONT cmpdcd_fontdict(struct font_entry *fe , int c ) 
{ 
  unsigned short ku ;
  unsigned short ten ;
  struct font_entry *sfe ;
  DEV_FONT tmp ;

  {
  {
#line 224
  code_to_jis((int )((struct comp *)curfontent->finfo)->cmp_sub, c, & ku, & ten);
#line 225
  sfe = ((struct comp *)fe->finfo)->cmp_fe;
#line 226
  tmp = (*(sfe->dev_fontdict))(sfe, (int )ku * 256 + (int )ten);
  }
#line 226
  return (tmp);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
int cmpdcd_setchar(unsigned int c ) 
{ 
  unsigned short ku ;
  unsigned short ten ;
  struct font_entry *save_curfontent ;

  {
  {
#line 235
  code_to_jis((int )((struct comp *)curfontent->finfo)->cmp_sub, c, & ku, & ten);
#line 236
  save_curfontent = curfontent;
#line 236
  curfontent = ((struct comp *)curfontent->finfo)->cmp_fe;
#line 236
  (*(curfontent->rvf_setchar))((int )ku * 256 + (int )ten, chmove);
#line 236
  curfontent = save_curfontent;
  }
#line 237
  return (0);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/compfont.c"
int cmpdcd_setstring(byte *s , int len ) 
{ 
  unsigned char *sp ;

  {
#line 247
  sp = s;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! ((unsigned long )sp < (unsigned long )(s + len))) {
#line 247
      goto while_break;
    }
    {
#line 248
    cmpdcd_setchar((unsigned int )*sp);
#line 247
    sp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  return (0);
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 2 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/set.h"
void MarkString(int firstch ) ;
#line 2 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int FirstPage ;
#line 2
int LastPage ;
#line 27
int G_quiet ;
#line 34
int SpecialSize ;
#line 35
char *SpecialStr ;
#line 54 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/scanfont.c"
int dev_prebop(int count ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/scanfont.c"
void scanfont(BOOLEAN PreLoad___0 , struct font_index **hdfip ) 
{ 
  int SkipMode ;
  int command ;
  int count[10] ;
  int i ;
  int k ;
  int val ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 15
  SkipMode = 0;
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 23
    command = (*dc_getcommand)();
    }
    {
#line 25
    if (command == 131) {
#line 25
      goto case_131;
    }
#line 25
    if (command == 130) {
#line 25
      goto case_131;
    }
#line 25
    if (command == 129) {
#line 25
      goto case_131;
    }
#line 25
    if (command == 128) {
#line 25
      goto case_131;
    }
#line 31
    if (command == 137) {
#line 31
      goto case_137;
    }
#line 31
    if (command == 132) {
#line 31
      goto case_137;
    }
#line 35
    if (command == 136) {
#line 35
      goto case_136;
    }
#line 35
    if (command == 135) {
#line 35
      goto case_136;
    }
#line 35
    if (command == 134) {
#line 35
      goto case_136;
    }
#line 35
    if (command == 133) {
#line 35
      goto case_136;
    }
#line 40
    if (command == 138) {
#line 40
      goto case_138;
    }
#line 43
    if (command == 139) {
#line 43
      goto case_139;
    }
#line 68
    if (command == 140) {
#line 68
      goto case_140;
    }
#line 86
    if (command == 160) {
#line 86
      goto case_160;
    }
#line 86
    if (command == 170) {
#line 86
      goto case_160;
    }
#line 86
    if (command == 165) {
#line 86
      goto case_160;
    }
#line 86
    if (command == 151) {
#line 86
      goto case_160;
    }
#line 86
    if (command == 156) {
#line 86
      goto case_160;
    }
#line 86
    if (command == 146) {
#line 86
      goto case_160;
    }
#line 95
    if (command == 159) {
#line 95
      goto case_159;
    }
#line 95
    if (command == 169) {
#line 95
      goto case_159;
    }
#line 95
    if (command == 164) {
#line 95
      goto case_159;
    }
#line 95
    if (command == 150) {
#line 95
      goto case_159;
    }
#line 95
    if (command == 155) {
#line 95
      goto case_159;
    }
#line 95
    if (command == 145) {
#line 95
      goto case_159;
    }
#line 104
    if (command == 158) {
#line 104
      goto case_158;
    }
#line 104
    if (command == 168) {
#line 104
      goto case_158;
    }
#line 104
    if (command == 163) {
#line 104
      goto case_158;
    }
#line 104
    if (command == 149) {
#line 104
      goto case_158;
    }
#line 104
    if (command == 154) {
#line 104
      goto case_158;
    }
#line 104
    if (command == 144) {
#line 104
      goto case_158;
    }
#line 113
    if (command == 157) {
#line 113
      goto case_157;
    }
#line 113
    if (command == 167) {
#line 113
      goto case_157;
    }
#line 113
    if (command == 162) {
#line 113
      goto case_157;
    }
#line 113
    if (command == 148) {
#line 113
      goto case_157;
    }
#line 113
    if (command == 153) {
#line 113
      goto case_157;
    }
#line 113
    if (command == 143) {
#line 113
      goto case_157;
    }
#line 122
    if (command == 166) {
#line 122
      goto case_166;
    }
#line 122
    if (command == 161) {
#line 122
      goto case_166;
    }
#line 122
    if (command == 147) {
#line 122
      goto case_166;
    }
#line 122
    if (command == 152) {
#line 122
      goto case_166;
    }
#line 122
    if (command == 142) {
#line 122
      goto case_166;
    }
#line 122
    if (command == 141) {
#line 122
      goto case_166;
    }
#line 125
    if (command == 238) {
#line 125
      goto case_238;
    }
#line 125
    if (command == 237) {
#line 125
      goto case_238;
    }
#line 125
    if (command == 236) {
#line 125
      goto case_238;
    }
#line 125
    if (command == 235) {
#line 125
      goto case_238;
    }
#line 130
    if (command == 242) {
#line 130
      goto case_242;
    }
#line 130
    if (command == 241) {
#line 130
      goto case_242;
    }
#line 130
    if (command == 240) {
#line 130
      goto case_242;
    }
#line 130
    if (command == 239) {
#line 130
      goto case_242;
    }
#line 141
    if (command == 246) {
#line 141
      goto case_246;
    }
#line 141
    if (command == 245) {
#line 141
      goto case_246;
    }
#line 141
    if (command == 244) {
#line 141
      goto case_246;
    }
#line 141
    if (command == 243) {
#line 141
      goto case_246;
    }
#line 150
    if (command == 247) {
#line 150
      goto case_247;
    }
#line 155
    if (command == 248) {
#line 155
      goto case_248;
    }
#line 159
    if (command == 249) {
#line 159
      goto case_249;
    }
#line 164
    if (command == 255) {
#line 164
      goto case_255;
    }
#line 168
    goto switch_default;
    case_131: /* CIL Label */ 
    case_130: /* CIL Label */ 
    case_129: /* CIL Label */ 
    case_128: /* CIL Label */ 
    {
#line 26
    val = (*dc_getuint)((command - 128) + 1);
    }
#line 27
    if (! SkipMode) {
      {
#line 27
      MarkChar(val);
      }
    }
#line 28
    goto switch_break;
    case_137: /* CIL Label */ 
    case_132: /* CIL Label */ 
    {
#line 32
    (*dc_skipbytes)(8);
    }
#line 33
    goto switch_break;
    case_136: /* CIL Label */ 
    case_135: /* CIL Label */ 
    case_134: /* CIL Label */ 
    case_133: /* CIL Label */ 
    {
#line 36
    val = (*dc_getuint)((command - 133) + 1);
    }
#line 37
    if (! SkipMode) {
      {
#line 37
      MarkChar(val);
      }
    }
#line 38
    goto switch_break;
    case_138: /* CIL Label */ 
#line 41
    goto switch_break;
    case_139: /* CIL Label */ 
#line 45
    i = 0;
    {
#line 45
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 45
      if (! (i <= 9)) {
#line 45
        goto while_break___0;
      }
      {
#line 46
      count[i] = (*dc_getuint)(4);
#line 45
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 47
    (*dc_getuint)(4);
#line 49
    curfontent = (struct font_entry *)((void *)0);
    }
#line 51
    if (count[0] < FirstPage) {
#line 51
      tmp = 1;
    } else
#line 51
    if (count[0] > LastPage) {
#line 51
      tmp = 1;
    } else {
#line 51
      tmp = 0;
    }
#line 51
    SkipMode = tmp;
#line 53
    if (! SkipMode) {
      {
#line 54
      dev_prebop(count[0]);
      }
#line 55
      if (! G_quiet) {
#line 57
        if (debug >= 1) {
          {
#line 58
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"{bop:%d\n",
                  count[0]);
          }
        } else {
          {
#line 63
          fflush(stderr);
          }
        }
      }
    }
#line 66
    goto switch_break;
    case_140: /* CIL Label */ 
#line 69
    if (! SkipMode) {
#line 70
      if (! G_quiet) {
#line 72
        if (debug >= 1) {
          {
#line 73
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"eop}\n",
                  count[0]);
#line 74
          fflush(stderr);
          }
        }
      }
    }
#line 79
    goto switch_break;
    case_160: /* CIL Label */ 
    case_170: /* CIL Label */ 
    case_165: /* CIL Label */ 
    case_151: /* CIL Label */ 
    case_156: /* CIL Label */ 
    case_146: /* CIL Label */ 
    {
#line 87
    (*dc_skipbytes)(4);
    }
#line 88
    goto switch_break;
    case_159: /* CIL Label */ 
    case_169: /* CIL Label */ 
    case_164: /* CIL Label */ 
    case_150: /* CIL Label */ 
    case_155: /* CIL Label */ 
    case_145: /* CIL Label */ 
    {
#line 96
    (*dc_skipbytes)(3);
    }
#line 97
    goto switch_break;
    case_158: /* CIL Label */ 
    case_168: /* CIL Label */ 
    case_163: /* CIL Label */ 
    case_149: /* CIL Label */ 
    case_154: /* CIL Label */ 
    case_144: /* CIL Label */ 
    {
#line 105
    (*dc_skipbytes)(2);
    }
#line 106
    goto switch_break;
    case_157: /* CIL Label */ 
    case_167: /* CIL Label */ 
    case_162: /* CIL Label */ 
    case_148: /* CIL Label */ 
    case_153: /* CIL Label */ 
    case_143: /* CIL Label */ 
    {
#line 114
    (*dc_skipbytes)(1);
    }
#line 115
    goto switch_break;
    case_166: /* CIL Label */ 
    case_161: /* CIL Label */ 
    case_147: /* CIL Label */ 
    case_152: /* CIL Label */ 
    case_142: /* CIL Label */ 
    case_141: /* CIL Label */ 
#line 123
    goto switch_break;
    case_238: /* CIL Label */ 
    case_237: /* CIL Label */ 
    case_236: /* CIL Label */ 
    case_235: /* CIL Label */ 
    {
#line 126
    k = (*dc_getuint)((command - 235) + 1);
    }
#line 127
    if (! SkipMode) {
      {
#line 127
      SetFntNum(k, *hdfip);
      }
    }
#line 128
    goto switch_break;
    case_242: /* CIL Label */ 
    case_241: /* CIL Label */ 
    case_240: /* CIL Label */ 
    case_239: /* CIL Label */ 
    {
#line 131
    k = (*dc_getuint)((command - 239) + 1);
    }
#line 131
    if (k + 1 > SpecialSize) {
      {
#line 132
      SpecialSize = k + 256;
#line 133
      tmp___0 = realloc((void *)SpecialStr, (size_t )((unsigned int )SpecialSize));
#line 133
      SpecialStr = (char *)tmp___0;
      }
#line 133
      if ((unsigned long )SpecialStr == (unsigned long )((void *)0)) {
        {
#line 135
        Fatal("can\'t malloc space for special");
        }
      }
    }
    {
#line 137
    (*dc_getbytes)(SpecialStr, k);
    }
#line 138
    if (! SkipMode) {
      {
#line 138
      dev_predospecial(SpecialStr, k);
      }
    }
#line 139
    goto switch_break;
    case_246: /* CIL Label */ 
    case_245: /* CIL Label */ 
    case_244: /* CIL Label */ 
    case_243: /* CIL Label */ 
    {
#line 143
    k = (*dc_getuint)((command - 243) + 1);
    }
#line 144
    if (PreLoad___0) {
      {
#line 145
      SkipFontDef();
      }
    } else {
      {
#line 144
      tmp___1 = HasBeenRead(k, *hdfip);
      }
#line 144
      if (tmp___1) {
        {
#line 145
        SkipFontDef();
        }
      } else {
        {
#line 147
        ReadFontDef(k, hdfip);
        }
      }
    }
#line 148
    goto switch_break;
    case_247: /* CIL Label */ 
    {
#line 152
    Fatal("PRE occurs within file");
    }
#line 153
    goto switch_break;
    case_248: /* CIL Label */ 
#line 156
    return;
#line 157
    goto switch_break;
    case_249: /* CIL Label */ 
    {
#line 161
    Fatal("POST_POST with no preceding POST");
    }
#line 162
    goto switch_break;
    case_255: /* CIL Label */ 
    {
#line 165
    (*dc_skipbytes)(1);
    }
#line 166
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 169
    if (command >= 171) {
#line 169
      if (command <= 234) {
#line 170
        if (! SkipMode) {
          {
#line 170
          SetFntNum(command - 171, *hdfip);
          }
        }
      } else {
#line 169
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 171
    if (command >= 0) {
#line 171
      if (command <= 127) {
#line 172
        if (! SkipMode) {
          {
#line 172
          MarkString(command);
          }
        }
      } else {
        {
#line 174
        Fatal("%d is an undefined command", command);
        }
      }
    } else {
      {
#line 174
      Fatal("%d is an undefined command", command);
      }
    }
#line 175
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/open.c"
struct openfont_list openfont_files[12]  ;
#line 11 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/open.c"
int nopen  =    0;
#line 12 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/open.c"
int openfont_time  =    0;
#line 56
int priority(int i ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/open.c"
void openfontfile(struct font_entry *fe ) 
{ 
  int i ;
  int least_used ;
  int current ;
  struct openfont_list *curopen ;
  int prio ;
  struct font_entry *lu_fe ;
  FILE *fntfp___1 ;
  int tmp ;
  int tmp___0 ;
  FILE *tmp___1 ;

  {
#line 42
  openfont_time ++;
#line 43
  fntfp___1 = fe->openfile;
#line 43
  if ((unsigned long )fntfp___1 != (unsigned long )((FILE *)-1)) {
    {
#line 44
    fseek(fntfp___1, 0L, 0);
#line 45
    curopen = fe->openlist;
    }
#line 47
    if (Stats) {
      {
#line 48
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FNT file %s already open.\n",
              fe->name);
      }
    }
  } else {
#line 51
    if (nopen < 12) {
#line 52
      tmp = nopen;
#line 52
      nopen ++;
#line 52
      current = tmp;
    } else {
      {
#line 55
      least_used = 0;
#line 56
      prio = priority(least_used);
#line 57
      i = 1;
      }
      {
#line 57
      while (1) {
        while_continue: /* CIL Label */ ;
#line 57
        if (! (i < 12)) {
#line 57
          goto while_break;
        }
        {
#line 58
        tmp___0 = priority(i);
        }
#line 58
        if (prio > tmp___0) {
          {
#line 59
          least_used = i;
#line 59
          prio = priority(least_used);
          }
        }
#line 57
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 60
      lu_fe = openfont_files[least_used].openfont_entry;
#line 62
      if (Stats) {
        {
#line 63
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FNT file %s closed.\n",
                lu_fe->name);
        }
      }
      {
#line 65
      fclose(lu_fe->openfile);
#line 66
      lu_fe->openfile = (FILE *)-1;
#line 67
      current = least_used;
      }
    }
    {
#line 69
    tmp___1 = fopen((char const   */* __restrict  */)(fe->name), (char const   */* __restrict  */)"r");
#line 69
    fe->openfile = tmp___1;
    }
#line 69
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 70
      Fatal("FNT file %s could not be opened", fe->name);
      }
    } else
#line 73
    if (Stats) {
      {
#line 74
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FNT file %s opened.\n",
              fe->name);
      }
    }
#line 77
    curopen = & openfont_files[current];
#line 77
    fe->openlist = curopen;
#line 78
    curopen->openfont_entry = fe;
#line 79
    curopen->use_count = 0;
  }
#line 81
  (curopen->use_count) ++;
#line 82
  curopen->last_use = openfont_time;
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/open.c"
int priority(int i ) 
{ 


  {
#line 88
  return (openfont_files[i].use_count - (openfont_time - openfont_files[i].last_use));
}
}
#line 3 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.h"
int ps_h ;
#line 3
int ps_v ;
#line 12 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
static char *FontBase  =    (char *)"Wadalab";
#line 13 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
static char *version_str  =    (char *)"001.001";
#line 17 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
static struct pd pd  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
static struct psbiops po  ;
#line 24
int get_jfm_psbiops(struct font_entry *fe , struct psbiops *po___0 ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int dev_wl_begfontdict(struct font_entry *fe ) 
{ 


  {
  {
#line 23
  pd.pd_char = 31;
#line 24
  get_jfm_psbiops(fe, & po);
  }
#line 25
  return (0);
}
}
#line 56
int wl_type1_prologue1(int fid ) ;
#line 58
int wl_type1_prologue2(void) ;
#line 55
int getpd(struct pd *pd___0 ) ;
#line 62
int wl_type1_char(int c , char *cstr , int len ) ;
#line 64
int wl_endfontdict(void) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
void dev_wl_initfontdict(struct font_entry *fe , struct wlfntinfo *wlfi , int k ,
                         int c , int nc , FILE *kfp ) 
{ 
  char buffer[4096] ;
  char *be ;
  int len ;
  int i ;
  char *charstr ;
  char *p ;
  int c1___0 ;
  int c2___0 ;
  struct wlchar_entry *ce ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 42
    tmp___8 = fgets((char */* __restrict  */)(buffer), 4096, (FILE */* __restrict  */)kfp);
    }
#line 42
    if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
#line 42
      goto while_break;
    }
    {
#line 43
    tmp = strlen((char const   *)(buffer));
#line 43
    len = (int )tmp;
    }
#line 44
    if ((int )buffer[0] == 60) {
      {
#line 44
      tmp___7 = strncmp((char const   *)((buffer + len) - 6), "CompD", (size_t )5);
      }
#line 44
      if (! tmp___7) {
        {
#line 45
        tmp___6 = htoi((buffer + len) - 12, & be);
        }
#line 45
        if (c == tmp___6) {
          {
#line 46
          len = (len - 16) / 2;
#line 47
          tmp___0 = malloc((size_t )((unsigned int )len));
#line 47
          charstr = (char *)tmp___0;
#line 48
          i = 0;
#line 48
          p = charstr;
          }
          {
#line 48
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 48
            if (! (i < len)) {
#line 48
              goto while_break___0;
            }
#line 49
            c1___0 = (int )buffer[i * 2 + 1];
#line 50
            c2___0 = (int )buffer[i * 2 + 2];
#line 51
            tmp___1 = p;
#line 51
            p ++;
#line 51
            if (c1___0 >= 97) {
#line 51
              tmp___2 = (c1___0 - 97) + 10;
            } else {
#line 51
              tmp___2 = c1___0 - 48;
            }
#line 51
            if (c2___0 >= 97) {
#line 51
              tmp___3 = (c2___0 - 97) + 10;
            } else {
#line 51
              tmp___3 = c2___0 - 48;
            }
#line 51
            *tmp___1 = (char )((tmp___2 << 4) | tmp___3);
#line 48
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 53
          ce = wlfi->ch + k;
#line 55
          tmp___5 = getpd(& pd);
          }
#line 55
          if (tmp___5) {
            {
#line 56
            wl_type1_prologue1(pd.pd_font);
            }
#line 57
            if (nc >= 256) {
#line 57
              tmp___4 = 256;
            } else {
#line 57
              tmp___4 = nc;
            }
            {
#line 57
            cnum_type1_encoding(tmp___4);
#line 58
            wl_type1_prologue2();
            }
          }
          {
#line 60
          ce->dev_font = (short )pd.pd_font;
#line 61
          ce->dev_char = (short )pd.pd_char;
#line 62
          wl_type1_char((int )ce->dev_char, charstr, len);
          }
#line 63
          if (pd.pd_char == 31) {
            {
#line 64
            wl_endfontdict();
            }
          }
          {
#line 65
          free((void *)charstr);
          }
#line 66
          return;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  Warning("The charstring of char %x in %s (wadalab) missing", c, fe->n);
  }
#line 71
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int dev_wl_endfontdict(void) 
{ 


  {
#line 75
  if (! (pd.pd_char == 31)) {
    {
#line 76
    wl_endfontdict();
    }
  }
#line 77
  return (0);
}
}
#line 83
int wl_type1_epilogue(void) ;
#line 86
int psfindfontop(char *psfn , struct psbiops *po___0 ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int wl_endfontdict(void) 
{ 
  char dictname[257] ;
  char *tmp ;

  {
  {
#line 83
  wl_type1_epilogue();
#line 84
  sprintf((char */* __restrict  */)(dictname), (char const   */* __restrict  */)"%s-p%d",
          FontBase, pd.pd_font);
#line 85
  po.po_dev_name = dictname;
#line 86
  tmp = psfname(pd.pd_font);
#line 86
  psfindfontop(tmp, & po);
  }
#line 87
  return (0);
}
}
#line 93
DEV_FONT wl_fontdict(struct font_entry *fe , int c ) ;
#line 94
int wl_setchar(int c ) ;
#line 94
int wl_setstring(char *s , int len ) ;
#line 95
int wl_setchar_abs(int c ) ;
#line 95
int wl_setstring_abs(char *s , int len ) ;
#line 98
int bifpos_rel(struct bifont *bf ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
void dev_wl_initfe(struct font_entry *fe ) 
{ 
  int tmp ;

  {
  {
#line 97
  fe->dev_fontdict = & wl_fontdict;
#line 98
  tmp = bifpos_rel((*((struct jfmfntinfo **)(& fe->finfo)))->jfm_bf);
  }
#line 98
  if (tmp) {
#line 99
    fe->dev_setchar = & wl_setchar;
#line 100
    fe->dev_setstring = & wl_setstring;
  } else {
#line 102
    fe->dev_setchar = & wl_setchar_abs;
#line 103
    fe->dev_setstring = & wl_setstring_abs;
  }
#line 105
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int wl_setchar(int c ) 
{ 
  struct wlchar_entry *ce ;
  int cw ;
  int tmp ;

  {
  {
#line 113
  tmp = jis_to_idx94(c);
#line 113
  ce = & (*((struct wlfntinfo **)(& curfontent->finfo)))->ch[tmp];
#line 114
  begin_string();
#line 115
  pschar((int )ce->dev_char);
#line 116
  cw = ce->tfmw;
#line 116
  *ps_move += cw;
  }
#line 117
  return (cw);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int wl_setstring(char *s , int len ) 
{ 


  {
  {
#line 125
  Fatal("%s implementation error: wl_setstring", G_progname);
  }
#line 126
  return (0);
}
}
#line 134
int dev_setposn_abs(int x , int y ) ;
#line 128 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int wl_setchar_abs(int c ) 
{ 
  int cw ;

  {
  {
#line 133
  cw = wl_setchar(c);
#line 134
  dev_setposn_abs(ps_h, ps_v);
  }
#line 135
  return (cw);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int wl_setstring_abs(char *s , int len ) 
{ 


  {
  {
#line 143
  Fatal("%s implementation error: wl_setstring_abs", G_progname);
  }
#line 144
  return (0);
}
}
#line 153
int get_jstfm_psbiops(struct font_entry *fe , struct psbiops *po___0 ) ;
#line 149 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int dev_jswl_begfontdict(struct font_entry *fe ) 
{ 


  {
  {
#line 152
  pd.pd_char = 31;
#line 153
  get_jstfm_psbiops(fe, & po);
  }
#line 154
  return (0);
}
}
#line 160
DEV_FONT jswl_fontdict(struct font_entry *fe , int c ) ;
#line 161
int jswl_setchar(int c ) ;
#line 161
int jswl_setstring(char *s , int len ) ;
#line 162
int jswl_setchar_abs(int c ) ;
#line 162
int jswl_setstring_abs(char *s , int len ) ;
#line 156 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
void dev_jswl_initfe(struct font_entry *fe ) 
{ 
  int tmp ;

  {
  {
#line 164
  fe->dev_fontdict = & jswl_fontdict;
#line 165
  tmp = bifpos_rel((*((struct jstfmfntinfo **)(& fe->finfo)))->js_bf);
  }
#line 165
  if (tmp) {
#line 166
    fe->dev_setchar = & jswl_setchar;
#line 167
    fe->dev_setstring = & jswl_setstring;
  } else {
#line 169
    fe->dev_setchar = & jswl_setchar_abs;
#line 170
    fe->dev_setstring = & jswl_setstring_abs;
  }
#line 172
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int jswl_setchar(int c ) 
{ 
  struct jstfmfntinfo *jsfi ;
  int cw ;
  int tmp ;

  {
  {
#line 180
  jsfi = *((struct jstfmfntinfo **)(& curfontent->finfo));
#line 181
  begin_string();
#line 182
  tmp = jsub_to_idx94((int )jsfi->jsubfont, c);
#line 182
  pschar((int )(*((struct wlfntinfo **)(& jsfi->js_info)))->ch[tmp].dev_char);
#line 183
  cw = jsfi->ch[c].tfmw;
#line 183
  *ps_move += cw;
  }
#line 184
  return (cw);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int jswl_setstring(char *s , int len ) 
{ 
  char *sp ;
  struct jstfmchar_entry *ce ;
  struct jstfmfntinfo *jsfi ;
  int cw ;
  int tmp ;

  {
  {
#line 193
  ce = (*((struct jstfmfntinfo **)(& curfontent->finfo)))->ch;
#line 197
  jsfi = *((struct jstfmfntinfo **)(& curfontent->finfo));
#line 198
  begin_string();
#line 199
  sp = s;
#line 199
  cw = 0;
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! ((unsigned long )sp < (unsigned long )(s + len))) {
#line 199
      goto while_break;
    }
    {
#line 200
    tmp = jsub_to_idx94((int )jsfi->jsubfont, (int )*sp);
#line 200
    pschar((int )(*((struct wlfntinfo **)(& jsfi->js_info)))->ch[tmp].dev_char);
#line 201
    cw += (ce + (int )*sp)->tfmw;
#line 199
    sp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  *ps_move += cw;
#line 204
  return (cw);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int jswl_setchar_abs(int c ) 
{ 
  int cw ;

  {
  {
#line 212
  cw = jswl_setchar(c);
#line 213
  dev_setposn_abs(ps_h, ps_v);
  }
#line 214
  return (cw);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int jswl_setstring_abs(char *s , int len ) 
{ 
  char *sp ;
  struct jstfmchar_entry *ce ;
  struct jstfmfntinfo *jsfi ;
  int cw ;
  int w ;
  int tmp ;

  {
#line 223
  ce = (*((struct jstfmfntinfo **)(& curfontent->finfo)))->ch;
#line 227
  jsfi = *((struct jstfmfntinfo **)(& curfontent->finfo));
#line 228
  sp = s;
#line 228
  cw = 0;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! ((unsigned long )sp < (unsigned long )(s + len))) {
#line 228
      goto while_break;
    }
    {
#line 229
    begin_string();
#line 230
    tmp = jsub_to_idx94((int )jsfi->jsubfont, (int )*sp);
#line 230
    pschar((int )(*((struct wlfntinfo **)(& jsfi->js_info)))->ch[tmp].dev_char);
#line 231
    end_string();
#line 232
    w = (ce + (int )*sp)->tfmw;
#line 232
    cw += w;
#line 233
    *ps_move += w;
#line 234
    dev_setposn_abs(ps_h, ps_v);
#line 228
    sp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return (cw);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
static char *StdHW  =    (char *)"32";
#line 243 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
static char *StdVW  =    (char *)"32";
#line 249 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int wl_type1_prologue1(int fid ) 
{ 


  {
  {
#line 254
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%BeginFont: %s-p%d\n",
          FontBase, fid);
#line 256
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%!PS-AdobeFont-1.0: %s-p%d %s\n",
          FontBase, fid, version_str);
#line 259
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%VMusage: 100000 100000\n");
#line 260
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"11 dict begin\n");
#line 261
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/FontInfo 8 dict dup begin\n");
#line 262
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/version (%s) readonly def\n",
          version_str);
#line 263
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/FullName (%s-p%d) readonly def\n",
          FontBase, fid);
#line 264
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/FamilyName (%s) readonly def\n",
          FontBase);
#line 265
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/Weight (Regular) readonly def\n");
#line 266
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/ItalicAngle 0 def\n");
#line 267
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/isFixedPitch true def\n");
#line 268
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/UnderlinePosition 0 def\n");
#line 269
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/UnderlineThickness 0 def\n");
#line 270
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"end readonly def\n");
#line 271
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/FontName /%s-p%d def\n",
          FontBase, fid);
  }
#line 272
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int wl_type1_prologue2(void) 
{ 


  {
  {
#line 276
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/PaintType 0 def\n");
#line 277
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/FontType 1 def\n");
#line 278
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/FontMatrix [.001 0 0 .001 0 -0.16] readonly def\n");
#line 281
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/FontBBox [0 0 1000 1000] readonly def\n");
#line 282
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"currentdict end\n");
#line 283
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"currentfile eexec\n");
#line 285
  begin_eexec();
#line 286
  e_printf("dup /Private 14 dict dup begin\n");
#line 287
  e_printf("/-|{string currentfile exch readstring pop}executeonly def\n");
#line 288
  e_printf("/|-{noaccess def}executeonly def\n");
#line 289
  e_printf("/|{noaccess put}executeonly def\n");
#line 290
  e_printf("/BlueValues [] |-\n");
#line 291
  e_printf("/OtherBlues [] |-\n");
#line 292
  e_printf("/MinFeature{16 16} |-\n");
#line 293
  e_printf("/StdHW [ %s ] |-\n", StdHW);
#line 294
  e_printf("/StdVW [ %s ] |-\n", StdVW);
#line 295
  e_printf("/ForceBold false def\n");
#line 296
  e_printf("/password 5839 def\n");
#line 299
  e_printf("/OtherSubrs [] |-\n");
#line 300
  e_printf("/Subrs 5 array\n");
#line 301
  e_printf("dup 0 15 -| \020\2771p|\020\024\020=-\223D\\\342R |\n");
#line 302
  e_printf("dup 1 9 -| \020\2771py\274\366Uz |\n");
#line 303
  e_printf("dup 2 9 -| \020\2771py\275\304\236i |\n");
#line 304
  e_printf("dup 3 5 -| \020\2771p\371 |\n");
#line 305
  e_printf("dup 4 12 -| \020\2771p~\266+6\034\3446z |\n");
#line 306
  e_printf("|-\n");
#line 307
  e_printf("2 index /CharStrings 257 dict dup begin\n");
#line 308
  e_printf("/.notdef 10 -| \020\2771py\3128\217\347c |-\n");
  }
#line 309
  return (0);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int wl_type1_char(int c , char *cstr , int len ) 
{ 
  int i ;

  {
  {
#line 318
  e_printf("/c%02X %d -| ", c, len);
#line 319
  i = 0;
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! (i < len)) {
#line 319
      goto while_break;
    }
    {
#line 320
    e_putchar((unsigned int )*(cstr + i));
#line 319
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 321
  e_printf(" |-\n");
  }
#line 322
  return (0);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pswl.c"
int wl_type1_epilogue(void) 
{ 


  {
  {
#line 326
  e_printf("end\n");
#line 327
  e_printf("end\n");
#line 328
  e_printf("readonly put\n");
#line 329
  e_printf("noaccess put\n");
#line 330
  e_printf("dup/FontName get exch definefont pop\n");
#line 331
  e_printf("mark currentfile closefile\n");
#line 332
  end_eexec();
#line 334
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"cleartomark\n");
#line 336
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%EndFont\n");
  }
#line 337
  return (0);
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ttfont.c"
void init_ft_fontinfo(struct font_entry *fe ) 
{ 


  {
  {
#line 694
  Warning("This %s is not compiled with FreeType option.\nFont %s is ignored", G_progname,
          fe->n);
#line 696
  fe->dev_setchar = & null_markchar;
#line 697
  fe->fnt_readfontinfo = & read_null_fontinfo;
  }
#line 698
  return;
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ttfont.c"
void init_jft_fontinfo(struct font_entry *fe ) 
{ 


  {
  {
#line 704
  init_ft_fontinfo(fe);
  }
#line 705
  return;
}
}
#line 707 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ttfont.c"
void init_jsft_fontinfo(struct font_entry *fe ) 
{ 


  {
  {
#line 711
  init_ft_fontinfo(fe);
  }
#line 712
  return;
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
char dvifilename[1024] ;
#line 17
int ncopies ;
#line 130
float dev_fontmag(struct font_entry *fe ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.h"
int hconvresolution  ;
#line 1 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.h"
int vconvresolution  ;
#line 2 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.h"
int hconv  ;
#line 2 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.h"
int vconv  ;
#line 4 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.h"
int *ps_move  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int ordinal  =    0;
#line 20 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
BOOLEAN epsf  =    0;
#line 23 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int ps_h  =    0;
#line 24 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int ps_v  =    0;
#line 27
int num ;
#line 27
int den ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
struct __anonstruct_paperinfo_29 paperinfo[9]  = 
#line 39
  {      {(char *)"Letter", (char *)"letter", 612, 792}, 
        {(char *)"Legal", (char *)"legal", 612, 1008}, 
        {(char *)"Tabloid", (char *)"tabloid", 792, 1224}, 
        {(char *)"B4", (char *)"b4", 709, 1001}, 
        {(char *)"B5", (char *)"b5", 499, 709}, 
        {(char *)"A5", (char *)"a5", 420, 595}, 
        {(char *)"A4", (char *)"a4", 595, 842}, 
        {(char *)"A3", (char *)"a3", 842, 1191}, 
        {(char *)"Letter", (char *)"envelope", 612, 792}};
#line 63 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int paper  =    6;
#line 64 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int large  =    1;
#line 65 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
BOOLEAN manualfeed  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
BOOLEAN landscape  =    0;
#line 74
int ChkOpt(char *str ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_arg(char option , char *c ) 
{ 
  int tmp ;

  {
  {
#line 73
  if ((int )option == 111) {
#line 73
    goto case_111;
  }
#line 72
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 74
  tmp = ChkOpt(c);
  }
#line 74
  if (! tmp) {
    {
#line 75
    Fatal("%s is an invalid option\n", c);
    }
  }
#line 76
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 78
  return (0);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int ChkOpt(char *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
  {
#line 86
  tmp___21 = strcmp((char const   *)str, "landscape");
  }
#line 86
  if (tmp___21 == 0) {
#line 87
    landscape = 1;
#line 88
    return (1);
  } else {
    {
#line 89
    tmp___20 = strcmp((char const   *)str, "manualfeed");
    }
#line 89
    if (tmp___20 == 0) {
#line 90
      manualfeed = 1;
#line 91
      return (1);
    } else {
      {
#line 92
      tmp___19 = strcmp((char const   *)str, "large");
      }
#line 92
      if (tmp___19 == 0) {
#line 93
        large = 1;
#line 94
        return (1);
      } else {
        {
#line 95
        tmp___18 = strcmp((char const   *)str, "small");
        }
#line 95
        if (tmp___18 == 0) {
#line 96
          large = 0;
#line 97
          return (1);
        } else {
          {
#line 98
          tmp___17 = strcmp((char const   *)str, "letter");
          }
#line 98
          if (tmp___17 == 0) {
#line 99
            paper = 0;
#line 100
            return (1);
          } else {
            {
#line 101
            tmp___16 = strcmp((char const   *)str, "note");
            }
#line 101
            if (tmp___16 == 0) {
#line 102
              paper = 0;
#line 103
              large = 0;
#line 104
              return (1);
            } else {
              {
#line 105
              tmp___15 = strcmp((char const   *)str, "legal");
              }
#line 105
              if (tmp___15 == 0) {
#line 106
                paper = 1;
#line 107
                return (1);
              } else {
                {
#line 108
                tmp___14 = strcmp((char const   *)str, "tabloid");
                }
#line 108
                if (tmp___14 == 0) {
#line 109
                  paper = 2;
#line 110
                  return (1);
                } else {
                  {
#line 111
                  tmp___13 = strcmp((char const   *)str, "a3");
                  }
#line 111
                  if (tmp___13 == 0) {
#line 112
                    paper = 7;
#line 113
                    return (1);
                  } else {
                    {
#line 114
                    tmp___12 = strcmp((char const   *)str, "a4");
                    }
#line 114
                    if (tmp___12 == 0) {
#line 115
                      paper = 6;
#line 116
                      return (1);
                    } else {
                      {
#line 117
                      tmp___11 = strcmp((char const   *)str, "a5");
                      }
#line 117
                      if (tmp___11 == 0) {
#line 118
                        paper = 5;
#line 119
                        return (1);
                      } else {
                        {
#line 120
                        tmp___10 = strcmp((char const   *)str, "b4");
                        }
#line 120
                        if (tmp___10 == 0) {
#line 121
                          paper = 3;
#line 122
                          return (1);
                        } else {
                          {
#line 123
                          tmp___9 = strcmp((char const   *)str, "b5");
                          }
#line 123
                          if (tmp___9 == 0) {
#line 124
                            paper = 4;
#line 125
                            return (1);
                          } else {
                            {
#line 126
                            tmp___8 = strcmp((char const   *)str, "letterlandscape");
                            }
#line 126
                            if (tmp___8 == 0) {
#line 127
                              paper = 0;
#line 128
                              landscape = 1;
#line 129
                              return (1);
                            } else {
                              {
#line 130
                              tmp___7 = strcmp((char const   *)str, "notelandscape");
                              }
#line 130
                              if (tmp___7 == 0) {
#line 131
                                paper = 0;
#line 132
                                large = 0;
#line 133
                                landscape = 1;
#line 134
                                return (1);
                              } else {
                                {
#line 135
                                tmp___6 = strcmp((char const   *)str, "legallandscape");
                                }
#line 135
                                if (tmp___6 == 0) {
#line 136
                                  paper = 1;
#line 137
                                  landscape = 1;
#line 138
                                  return (1);
                                } else {
                                  {
#line 139
                                  tmp___5 = strcmp((char const   *)str, "tabloidlandscape");
                                  }
#line 139
                                  if (tmp___5 == 0) {
#line 140
                                    paper = 2;
#line 141
                                    landscape = 1;
#line 142
                                    return (1);
                                  } else {
                                    {
#line 143
                                    tmp___4 = strcmp((char const   *)str, "a3landscape");
                                    }
#line 143
                                    if (tmp___4 == 0) {
#line 144
                                      paper = 7;
#line 145
                                      landscape = 1;
#line 146
                                      return (1);
                                    } else {
                                      {
#line 147
                                      tmp___3 = strcmp((char const   *)str, "a4landscape");
                                      }
#line 147
                                      if (tmp___3 == 0) {
#line 148
                                        paper = 6;
#line 149
                                        landscape = 1;
#line 150
                                        return (1);
                                      } else {
                                        {
#line 151
                                        tmp___2 = strcmp((char const   *)str, "a5landscape");
                                        }
#line 151
                                        if (tmp___2 == 0) {
#line 152
                                          paper = 5;
#line 153
                                          landscape = 1;
#line 154
                                          return (1);
                                        } else {
                                          {
#line 155
                                          tmp___1 = strcmp((char const   *)str, "b4landscape");
                                          }
#line 155
                                          if (tmp___1 == 0) {
#line 156
                                            paper = 3;
#line 157
                                            landscape = 1;
#line 158
                                            return (1);
                                          } else {
                                            {
#line 159
                                            tmp___0 = strcmp((char const   *)str,
                                                             "b5landscape");
                                            }
#line 159
                                            if (tmp___0 == 0) {
#line 160
                                              paper = 4;
#line 161
                                              landscape = 1;
#line 162
                                              return (1);
                                            } else {
                                              {
#line 163
                                              tmp = strcmp((char const   *)str, "envelope");
                                              }
#line 163
                                              if (tmp == 0) {
#line 164
                                                paper = 8;
#line 165
                                                manualfeed = 1;
#line 166
                                                landscape = 1;
#line 167
                                                return (1);
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 170
  return (0);
}
}
#line 175
void initcolor(void) ;
#line 173 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_init(void) 
{ 


  {
  {
#line 175
  initcolor();
  }
#line 176
  return (0);
}
}
#line 200
int do_include(void) ;
#line 178 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_prologue(void) 
{ 
  char const   *tmp ;

  {
#line 180
  if (epsf) {
#line 180
    if (ordinal > 1) {
      {
#line 181
      Warning("We cannot make it EPSF.");
#line 182
      epsf = 0;
      }
    }
  }
#line 184
  if (! epsf) {
    {
#line 185
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%!PS-Adobe-3.0\n");
    }
  } else {
    {
#line 187
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%!PS-Adobe-3.0 EPSF-3.0\n");
    }
  }
  {
#line 188
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%Creator: %s\n",
          G_progname);
#line 189
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%Title: %s\n",
          dvifilename);
  }
#line 190
  if (! epsf) {
    {
#line 191
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%Pages: %d\n",
            ordinal);
    }
  }
  {
#line 192
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%BoundingBox: 0 0 %d %d\n",
          paperinfo[paper].width, paperinfo[paper].height);
  }
#line 195
  if (! epsf) {
#line 196
    if (landscape) {
#line 196
      tmp = "Landscape";
    } else {
#line 196
      tmp = "Portrait";
    }
    {
#line 196
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%Orientation: %s\n",
            tmp);
    }
  }
  {
#line 198
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%EndComments\n");
#line 200
  do_include();
#line 201
  dev_outbangspecials();
#line 202
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%EndProlog\n");
  }
#line 203
  return (0);
}
}
#line 209
int DoConv(int num___0 , int den___0 , int mag___0 , int convResolution ) ;
#line 205 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_setup(void) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 207
  hconvresolution = resolution;
#line 208
  vconvresolution = resolution;
#line 209
  hconv = DoConv(num, den, mag, hconvresolution);
#line 210
  vconv = DoConv(num, den, mag, vconvresolution);
  }
#line 212
  if (debug >= 2) {
    {
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"hconv = %d\n",
            hconv);
#line 214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"vconv = %d\n",
            vconv);
    }
  }
  {
#line 217
  ordinal = 0;
#line 219
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%BeginSetup\n");
  }
#line 220
  if (! epsf) {
#line 221
    if (manualfeed) {
#line 221
      tmp = "True";
    } else {
#line 221
      tmp = "False";
    }
    {
#line 221
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%Feature: *ManualFeed %s\n",
            tmp);
    }
  }
  {
#line 223
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%Feature: *Resolution %d\n",
          resolution);
#line 224
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"TeXDict begin\n");
  }
#line 225
  if (! epsf) {
    {
#line 226
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%PaperSize: %s\n",
            paperinfo[paper].size);
    }
#line 227
    if (manualfeed) {
      {
#line 228
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"@manualfeed\n");
      }
    }
#line 229
    if (landscape) {
      {
#line 230
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"@landscape\n");
      }
    }
#line 231
    if (large) {
#line 231
      tmp___0 = "large";
    } else {
#line 231
      tmp___0 = "small";
    }
    {
#line 231
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"@%s\n",
            tmp___0);
#line 232
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"@%s\n",
            paperinfo[paper].command);
    }
#line 233
    if (ncopies > 1) {
      {
#line 234
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%d COPIES\n",
              ncopies);
      }
    }
  } else {
    {
#line 236
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"@%ssize\n",
            paperinfo[paper].command);
    }
  }
#line 237
  return (0);
}
}
#line 244
int do_setup(void) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_endsetup(void) 
{ 
  int tmp ;

  {
  {
#line 241
  tmp = useifont();
  }
#line 241
  if (tmp) {
    {
#line 242
    ifont_setup();
    }
  }
  {
#line 244
  do_setup();
#line 245
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%d %.3f START\n",
          resolution, (double )((float )mag / (float )1000));
#line 246
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%EndSetup\n");
  }
#line 247
  return (0);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_finish(void) 
{ 


  {
  {
#line 251
  end_string();
#line 252
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%Trailer\n");
#line 253
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"end\n");
#line 254
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"userdict /end-hook known{end-hook}if\n");
#line 255
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%EOF\n");
  }
#line 256
  return (0);
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_devfilekind(char *kind ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 267
  tmp___2 = strcmp((char const   *)kind, "special");
  }
#line 267
  if (tmp___2 == 0) {
#line 268
    return (1);
  } else {
    {
#line 269
    tmp___1 = strcmp((char const   *)kind, "psmod");
    }
#line 269
    if (tmp___1 == 0) {
#line 270
      return (2);
    } else {
      {
#line 271
      tmp___0 = strcmp((char const   *)kind, "psifont");
      }
#line 271
      if (tmp___0 == 0) {
#line 272
        return (3);
      } else {
        {
#line 273
        tmp = strcmp((char const   *)kind, "color");
        }
#line 273
        if (tmp == 0) {
#line 274
          return (4);
        } else {
#line 276
          return (0);
        }
      }
    }
  }
}
}
#line 283
BOOLEAN usespsmod ;
#line 279 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_devfileif(int kind ) 
{ 
  int tmp ;

  {
#line 286
  if (kind == 1) {
#line 287
    return (usesspecial);
  } else
#line 288
  if (kind == 2) {
#line 289
    return (usespsmod);
  } else
#line 290
  if (kind == 3) {
    {
#line 291
    tmp = useifont();
    }
#line 291
    return (tmp);
  } else
#line 292
  if (kind == 4) {
#line 293
    return (usescolor);
  }
#line 294
  return (0);
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
static DEV_FONT ps_curf  ;
#line 301 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
static char psfnamebuf[256]  ;
#line 302 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
static int devicefont  =    0;
#line 304 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
char *psfname(int psf ) 
{ 


  {
  {
#line 308
  sprintf((char */* __restrict  */)(psfnamebuf), (char const   */* __restrict  */)"f%d",
          (unsigned int )psf);
  }
#line 309
  return (psfnamebuf);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_newdevfont(void) 
{ 
  int tmp ;

  {
#line 314
  tmp = devicefont;
#line 314
  devicefont ++;
#line 314
  return (tmp);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_initpage(void) 
{ 


  {
  {
#line 319
  ps_v = 0;
#line 319
  ps_h = ps_v;
#line 320
  dev_initfont();
  }
#line 321
  return (0);
}
}
#line 326
int pagenum ;
#line 330
void bopcolor(int outtops ) ;
#line 323 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_prebop(int count ) 
{ 


  {
  {
#line 328
  ordinal ++;
#line 329
  pagenum = count;
#line 330
  bopcolor(0);
  }
#line 331
  return (0);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_bop(int count ) 
{ 


  {
  {
#line 336
  end_string();
#line 337
  _IO_putc('\n', outfp);
  }
#line 338
  if (! epsf) {
    {
#line 339
    ordinal ++;
#line 339
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%Page: %d %d\n",
            count, ordinal);
    }
  }
  {
#line 340
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"BP\n");
#line 341
  bopcolor(1);
  }
#line 342
  return (0);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_eop(void) 
{ 


  {
  {
#line 346
  end_string();
#line 347
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"EP\n");
  }
#line 348
  return (0);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
float dev_fontmag(struct font_entry *fe ) 
{ 


  {
#line 354
  return ((float )((double )((float )fe->s / (float )fe->d) * ((double )((float )mag) / 1000.0)));
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_initfont(void) 
{ 


  {
#line 363
  ps_curf = -1;
#line 364
  return (0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_setfont(int psf ) 
{ 
  char *tmp ;

  {
#line 369
  if (ps_curf != psf) {
    {
#line 370
    end_string();
#line 371
    tmp = psfname(psf);
#line 371
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%s SF\n",
            tmp);
#line 372
    ps_curf = psf;
    }
  }
#line 374
  return (0);
}
}
#line 383
int pixround(int x , int conv ) ;
#line 376 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_setposn(int x , int y ) 
{ 
  int rx ;
  int tmp ;

  {
#line 381
  if (y == ps_v) {
#line 382
    if (x != ps_h) {
      {
#line 383
      rx = pixround(x - ps_h, hconv);
      }
#line 383
      if (rx != 0) {
        {
#line 384
        end_string();
#line 385
        putint(rx);
#line 386
        fputs((char const   */* __restrict  */)"r ", (FILE */* __restrict  */)outfp);
#line 387
        ps_h += rx * hconv;
        }
      }
    }
  } else {
    {
#line 392
    end_string();
#line 393
    rx = pixround(x, hconv);
#line 393
    putint(rx);
#line 394
    tmp = pixround(y, vconv);
#line 394
    putint(tmp);
#line 395
    fputs((char const   */* __restrict  */)"p ", (FILE */* __restrict  */)outfp);
#line 396
    ps_h = rx * hconv;
#line 397
    ps_v = y;
    }
  }
#line 401
  return (0);
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_setposn_abs(int x , int y ) 
{ 
  int rx ;
  int tmp ;

  {
  {
#line 408
  end_string();
#line 409
  rx = pixround(x, hconv);
#line 409
  putint(rx);
#line 410
  tmp = pixround(y, vconv);
#line 410
  putint(tmp);
#line 411
  fputs((char const   */* __restrict  */)"p ", (FILE */* __restrict  */)outfp);
#line 412
  ps_h = rx * hconv;
#line 413
  ps_v = y;
  }
#line 414
  return (0);
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_setrule(int a , int b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 419
  end_string();
#line 420
  tmp = pixround(b, hconv);
#line 420
  putint(tmp);
#line 421
  tmp___0 = pixround(a, vconv);
#line 421
  putint(tmp___0);
#line 422
  fputs((char const   */* __restrict  */)"ru\n", (FILE */* __restrict  */)outfp);
  }
#line 423
  return (0);
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
char *endscom  =    (char *)"s";
#line 426 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
char *endvscom  =    (char *)"rs";
#line 427 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
char *endstrcom  ;
#line 429 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int dev_dir(int d ) 
{ 


  {
  {
#line 432
  end_string();
  }
#line 433
  if (d == 0) {
#line 434
    ps_move = & ps_h;
#line 435
    endstrcom = endscom;
  } else
#line 436
  if (d == 1) {
#line 437
    ps_move = & ps_v;
#line 438
    endstrcom = endvscom;
  } else {
    {
#line 440
    Fatal("direction %d not supported", d);
    }
  }
#line 441
  return (0);
}
}
#line 443 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
BOOLEAN instring  =    0;
#line 444 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
BOOLEAN vertstring  =    0;
#line 446 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int begin_string(void) 
{ 


  {
#line 448
  if (! instring) {
    {
#line 449
    instring = 1;
#line 450
    _IO_putc('(', outfp);
    }
  }
#line 452
  return (0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int begin_string_v(void) 
{ 


  {
#line 456
  if (! instring) {
    {
#line 457
    instring = 1;
#line 458
    vertstring = 1;
#line 459
    _IO_putc('(', outfp);
    }
  }
#line 461
  return (0);
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int end_string(void) 
{ 


  {
#line 465
  if (instring) {
#line 466
    instring = 0;
#line 467
    if (vertstring) {
      {
#line 468
      fputs((char const   */* __restrict  */)")s\n", (FILE */* __restrict  */)outfp);
#line 469
      vertstring = 0;
      }
    } else {
      {
#line 471
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)")%s\n",
              endstrcom);
      }
    }
  }
#line 473
  return (0);
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int DoConv(int num___0 , int den___0 , int mag___0 , int convResolution ) 
{ 
  float conv ;

  {
#line 491
  conv = (float )(((double )((float )num___0 / (float )den___0) * ((double )((float )mag___0) / 1000.0)) * ((double )((float )convResolution) / 254000.0));
#line 496
  return ((int )(1.0 / (double )conv + 0.5));
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.c"
int pixround(int x , int conv ) 
{ 


  {
#line 504
  return ((x + (conv >> 1)) / conv);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
struct biinitfontinfo *alloc_jbiinif(struct bifont *bi ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/wlfont.c"
int jmm_markchar(int c ) ;
#line 18
void read_wl_fontinfo(struct font_entry *fe ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/wlfont.c"
void init_wl_fontinfo(struct font_entry *fe ) 
{ 


  {
  {
#line 20
  *((struct biinitfontinfo **)(& fe->finfo)) = alloc_jbiinif((*((struct biaccessinfo **)(& fe->finfo)))->bf);
#line 21
  fe->dev_setchar = & jmm_markchar;
#line 22
  fe->fnt_readfontinfo = & read_wl_fontinfo;
  }
#line 23
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/wlfont.c"
static void wlpave(char *path , char *proto , int k ) 
{ 
  char *p ;
  char *s ;
  char *t ;
  char *pend ;
  int len ;
  char buf[32] ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 35
  p = path;
#line 35
  s = proto;
#line 35
  pend = (path + 1024) - 1;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! ((int )*s != 0)) {
#line 35
      goto while_break;
    }
#line 36
    if ((int )*s == 37) {
#line 37
      s ++;
      {
#line 38
      if ((int )*s == 75) {
#line 38
        goto case_75;
      }
#line 41
      goto switch_default;
      case_75: /* CIL Label */ 
      {
#line 39
      t = buf;
#line 39
      sprintf((char */* __restrict  */)t, (char const   */* __restrict  */)"%2x",
              k);
      }
#line 40
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 42
      t = buf;
#line 42
      *t = *s;
#line 42
      *(t + 1) = (char )'\000';
#line 43
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 45
      tmp = strlen((char const   *)t);
#line 45
      len = (int )tmp;
      }
#line 45
      if ((unsigned long )(p + len) <= (unsigned long )pend) {
        {
#line 46
        strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)t, (size_t )len);
#line 47
        p += len;
        }
      } else {
        {
#line 49
        Fatal("font path too long %s", proto);
        }
      }
    } else
#line 50
    if ((unsigned long )p < (unsigned long )pend) {
#line 51
      tmp___0 = p;
#line 51
      p ++;
#line 51
      *tmp___0 = *s;
    } else {
      {
#line 53
      Fatal("font path too long %s", proto);
      }
    }
#line 35
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  *p = (char )'\000';
#line 55
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/wlfont.c"
struct wlfntinfo *read_wl_finfo(struct font_entry *fe , struct biinitfontinfo *bii ,
                                struct jfmfntinfo *jfmfi , BOOLEAN settfmw ) 
{ 
  struct wlfntinfo *wlfi ;
  int nchars ;
  int i ;
  int k1 ;
  int kk ;
  int c ;
  int k1end ;
  BOOLEAN k1init ;
  char k1wlfn[1024] ;
  char *filename ;
  FILE *k1fp ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 70
  tmp = malloc((unsigned long )((unsigned int )sizeof(struct wlfntinfo )) + (unsigned long )bii->maxc * sizeof(struct wlchar_entry ));
#line 70
  tmp___0 = alloc_check(tmp, "wlfont info");
#line 70
  wlfi = (struct wlfntinfo *)tmp___0;
#line 74
  wlfi->wl_bf = bii->bf;
#line 75
  nchars = 0;
#line 75
  i = 0;
  }
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i <= bii->maxc)) {
#line 75
      goto while_break;
    }
#line 76
    wlfi->ch[i].dev_font = (short)-1;
#line 77
    if (bii->mark[i]) {
#line 78
      nchars ++;
    }
#line 75
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  k1 = 0;
#line 81
  kk = 0;
#line 81
  k1end = 0;
  {
#line 81
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 81
    if (! (k1 < bii->maxc / 94 + 1)) {
#line 81
      goto while_break___0;
    }
#line 82
    k1init = 0;
#line 83
    k1end += 94;
#line 84
    if (k1end > bii->maxc + 1) {
#line 85
      k1end = bii->maxc + 1;
    }
#line 86
    kk = k1 * 94;
    {
#line 86
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 86
      if (! (kk < k1end)) {
#line 86
        goto while_break___1;
      }
#line 87
      if (! bii->mark[kk]) {
#line 88
        goto __Cont;
      }
#line 89
      if (! k1init) {
        {
#line 90
        tmp___1 = dev_fontpath(bii->bf);
#line 90
        wlpave(k1wlfn, tmp___1, k1 + 33);
#line 99
        filename = k1wlfn;
        }
#line 102
        if (debug >= 1) {
          {
#line 103
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wadalabfont open %s (for %s)\n",
                  filename, fe->n);
          }
        }
        {
#line 106
        k1fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
        }
#line 106
        if ((unsigned long )k1fp == (unsigned long )((void *)0)) {
          {
#line 107
          Warning("chars 0x%2xXX in %s not found (open failed)", k1 + 33, fe->n);
          }
#line 109
          goto while_break___1;
        }
#line 111
        k1init = 1;
      }
      {
#line 113
      c = idx94_to_std(kk);
      }
#line 114
      if (settfmw) {
        {
#line 115
        tmp___2 = getctype(c, jfmfi);
#line 115
        (wlfi->ch + kk)->tfmw = (jfmfi->ch + tmp___2)->tfmw;
        }
      }
      {
#line 116
      tmp___3 = nchars;
#line 116
      nchars --;
#line 116
      dev_wl_initfontdict(fe, wlfi, kk, c, tmp___3, k1fp);
      }
      __Cont: /* CIL Label */ 
#line 86
      kk ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 118
    if (k1init) {
      {
#line 119
      fclose(k1fp);
      }
    }
#line 81
    k1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 121
  dev_wl_endfontdict();
  }
#line 123
  return (wlfi);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/wlfont.c"
void read_wl_fontinfo(struct font_entry *fe ) 
{ 
  struct biinitfontinfo *bii ;
  struct jfmfntinfo *jfmfi ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 134
  bii = *((struct biinitfontinfo **)(& fe->finfo));
#line 135
  tmp = malloc((size_t )((unsigned int )sizeof(struct jfmfntinfo )));
#line 135
  tmp___0 = alloc_check(tmp, "jfmfont info");
#line 135
  jfmfi = (struct jfmfntinfo *)tmp___0;
#line 136
  jfmfi->jfm_bf = bii->bf;
#line 137
  *((struct jfmfntinfo **)(& fe->finfo)) = jfmfi;
#line 138
  read_jfm_finfo(fe);
#line 140
  dev_wl_initfe(fe);
#line 141
  dev_wl_begfontdict(fe);
#line 142
  *((struct wlfntinfo **)(& fe->finfo)) = read_wl_finfo(fe, bii, jfmfi, 1);
#line 144
  free((void *)((char *)bii));
#line 145
  free((void *)((char *)jfmfi->ctype));
#line 146
  free((void *)((char *)jfmfi->ch));
#line 147
  free((void *)((char *)jfmfi));
  }
#line 148
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/wlfont.c"
DEV_FONT wl_fontdict(struct font_entry *fe , int c ) 
{ 
  int tmp ;

  {
  {
#line 155
  tmp = jis_to_idx94(c);
  }
#line 155
  return ((DEV_FONT )(*((struct wlfntinfo **)(& fe->finfo)))->ch[tmp].dev_font);
}
}
#line 166
int jsmm_markchar(int c ) ;
#line 167
void read_jswl_fontinfo(struct font_entry *fe ) ;
#line 161 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/wlfont.c"
void init_jswl_fontinfo(struct font_entry *fe ) 
{ 
  struct jsubshare *jss ;
  struct biinitfontinfo *tmp ;

  {
#line 169
  jss = (*((struct jstfmfntinfo **)(& fe->finfo)))->js_share;
#line 170
  if (jss->jss_stat < 1) {
    {
#line 171
    tmp = alloc_jbiinif(jss->jss_bf);
#line 171
    jss->jss_info = (struct jssinfo *)tmp;
#line 172
    jss->jss_stat = 1;
    }
  }
#line 174
  (*((struct jstfmfntinfo **)(& fe->finfo)))->js_info = jss->jss_info;
#line 175
  fe->dev_setchar = & jsmm_markchar;
#line 176
  fe->fnt_readfontinfo = & read_jswl_fontinfo;
#line 177
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/wlfont.c"
void read_jswl_fontinfo(struct font_entry *fe ) 
{ 
  struct biinitfontinfo *bii ;
  struct jsubshare *jss ;
  struct wlfntinfo *tmp ;

  {
  {
#line 187
  read_jstfm_finfo(fe);
#line 189
  dev_jswl_initfe(fe);
#line 190
  jss = (*((struct jstfmfntinfo **)(& fe->finfo)))->js_share;
  }
#line 191
  if (jss->jss_stat < 2) {
    {
#line 192
    bii = (struct biinitfontinfo *)jss->jss_info;
#line 193
    dev_jswl_begfontdict(fe);
#line 194
    tmp = read_wl_finfo(fe, bii, (struct jfmfntinfo *)((void *)0), 0);
#line 194
    jss->jss_info = (struct jssinfo *)tmp;
#line 196
    jss->jss_stat = 2;
#line 197
    free((void *)((char *)bii));
    }
  }
#line 199
  (*((struct jstfmfntinfo **)(& fe->finfo)))->js_info = jss->jss_info;
#line 200
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/wlfont.c"
DEV_FONT jswl_fontdict(struct font_entry *fe , int c ) 
{ 
  struct jstfmfntinfo *jsfi ;
  int tmp ;

  {
  {
#line 207
  jsfi = *((struct jstfmfntinfo **)(& fe->finfo));
#line 209
  tmp = jsub_to_idx94((int )jsfi->jsubfont, c);
  }
#line 209
  return ((DEV_FONT )(*((struct wlfntinfo **)(& jsfi->js_info)))->ch[tmp].dev_font);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 99 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
void defexpand(char *path , char *proto ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vflfont.c"
char *vfontcap  =    (char *)((void *)0);
#line 12 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vflfont.c"
BOOLEAN vfl_init  =    0;
#line 14
void getvfcap(void) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vflfont.c"
struct confop vfccop  =    {(char *)"vfontcap", & getvfcap};
#line 20 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vflfont.c"
void getvfcap(void) 
{ 
  char field_file[1024] ;
  char vfcap[1024] ;

  {
  {
#line 26
  getfield(field_file);
#line 27
  skipline();
#line 28
  defexpand(vfcap, field_file);
#line 29
  vfontcap = strsave(vfcap);
  }
#line 30
  return;
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vflfont.c"
int depthratio  =    165565;
#line 34
void getvflbase(void) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vflfont.c"
struct confop vfbcop  =    {(char *)"vflbaseline", & getvflbase};
#line 40 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vflfont.c"
void getvflbase(void) 
{ 
  char field_number[1024] ;
  char ratio[1024] ;

  {
  {
#line 46
  getfield(field_number);
#line 47
  skipline();
#line 48
  defexpand(ratio, field_number);
#line 49
  depthratio = atoi((char const   *)(ratio));
  }
#line 50
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vflfont.c"
void init_vfl_fontinfo(struct font_entry *fe ) 
{ 


  {
  {
#line 244
  Warning("This %s is not compiled with VFlib option.\nFont %s is ignored", G_progname,
          fe->n);
#line 246
  fe->dev_setchar = & null_markchar;
#line 247
  fe->fnt_readfontinfo = & read_null_fontinfo;
  }
#line 248
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vflfont.c"
void init_jsvfl_fontinfo(struct font_entry *fe ) 
{ 


  {
  {
#line 254
  init_vfl_fontinfo(fe);
  }
#line 255
  return;
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/mmfont.c"
static struct biinitfontinfo *alloc_bi(struct bifont *bi , int nchars , char *s ) 
{ 
  int i ;
  struct biinitfontinfo *bii ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 19
  tmp = malloc((unsigned long )((unsigned int )sizeof(struct biinitfontinfo )) + (unsigned long )(nchars - 1) * sizeof(Boolean ));
#line 19
  tmp___0 = alloc_check(tmp, s);
#line 19
  bii = (struct biinitfontinfo *)tmp___0;
#line 23
  i = 0;
  }
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (! (i < nchars)) {
#line 23
      goto while_break;
    }
#line 24
    bii->mark[i] = (Boolean )0;
#line 23
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 25
  bii->maxc = 0;
#line 26
  bii->bf = bi;
#line 27
  return (bii);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/mmfont.c"
struct biinitfontinfo *alloc_biinif(struct bifont *bi ) 
{ 
  struct biinitfontinfo *tmp ;

  {
  {
#line 34
  tmp = alloc_bi(bi, 256, (char *)"biinitfontinfo");
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/mmfont.c"
struct biinitfontinfo *alloc_jbiinif(struct bifont *bi ) 
{ 
  struct biinitfontinfo *tmp ;

  {
  {
#line 41
  tmp = alloc_bi(bi, 8836, (char *)"j-biinitfontinfo");
  }
#line 41
  return (tmp);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/mmfont.c"
int jmm_markchar(int c ) 
{ 


  {
  {
#line 47
  c = jis_to_idx94(c);
#line 48
  (*((struct biinitfontinfo **)(& curfontent->finfo)))->mark[c] = (Boolean )1;
  }
#line 49
  if (c > (*((struct biinitfontinfo **)(& curfontent->finfo)))->maxc) {
#line 50
    (*((struct biinitfontinfo **)(& curfontent->finfo)))->maxc = c;
  }
#line 51
  return (0);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/mmfont.c"
int mm_markchar(int c ) 
{ 


  {
#line 56
  (*((struct biinitfontinfo **)(& curfontent->finfo)))->mark[c] = (Boolean )1;
#line 57
  if (c > (*((struct biinitfontinfo **)(& curfontent->finfo)))->maxc) {
#line 58
    (*((struct biinitfontinfo **)(& curfontent->finfo)))->maxc = c;
  }
#line 59
  return (0);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/mmfont.c"
int jsmm_markchar(int c ) 
{ 
  struct jstfmfntinfo *jsfi ;
  struct biinitfontinfo *bii ;

  {
  {
#line 64
  jsfi = *((struct jstfmfntinfo **)(& curfontent->finfo));
#line 67
  c = jsub_to_idx94((int )jsfi->jsubfont, c);
#line 68
  bii = (struct biinitfontinfo *)jsfi->js_info;
#line 69
  bii->mark[c] = (Boolean )1;
  }
#line 70
  if (c > bii->maxc) {
#line 71
    bii->maxc = c;
  }
#line 72
  return (0);
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int ndone ;
#line 24
int Reverse ;
#line 42
int Snbpx0 ;
#line 42
int Sndc0 ;
#line 42
int Stnc0 ;
#line 46 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int h  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int v  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int dir  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int *move  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
BOOLEAN chmove  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dviconv.c"
int setdir(int d ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dviconv.c"
void dviconv(struct font_index *hdfidx ) 
{ 
  int SkipMode ;
  int command ;
  int count[10] ;
  int sp ;
  struct __anonstruct_stack_29 stack[100] ;
  int basedir ;
  int i ;
  int k ;
  int val ;
  int val2 ;
  int w ;
  int x ;
  int y ;
  int z ;
  long ppagep ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 24
  SkipMode = 0;
#line 44
  z = 0;
#line 44
  y = z;
#line 44
  x = y;
#line 44
  w = x;
#line 45
  basedir = dir;
#line 46
  sp = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 49
    command = (*dc_getcommand)();
    }
    {
#line 51
    if (command == 131) {
#line 51
      goto case_131;
    }
#line 51
    if (command == 130) {
#line 51
      goto case_131;
    }
#line 51
    if (command == 129) {
#line 51
      goto case_131;
    }
#line 51
    if (command == 128) {
#line 51
      goto case_131;
    }
#line 56
    if (command == 132) {
#line 56
      goto case_132;
    }
#line 62
    if (command == 136) {
#line 62
      goto case_136;
    }
#line 62
    if (command == 135) {
#line 62
      goto case_136;
    }
#line 62
    if (command == 134) {
#line 62
      goto case_136;
    }
#line 62
    if (command == 133) {
#line 62
      goto case_136;
    }
#line 67
    if (command == 137) {
#line 67
      goto case_137;
    }
#line 73
    if (command == 138) {
#line 73
      goto case_138;
    }
#line 76
    if (command == 139) {
#line 76
      goto case_139;
    }
#line 104
    if (command == 140) {
#line 104
      goto case_140;
    }
#line 135
    if (command == 141) {
#line 135
      goto case_141;
    }
#line 148
    if (command == 142) {
#line 148
      goto case_142;
    }
#line 161
    if (command == 146) {
#line 161
      goto case_146;
    }
#line 161
    if (command == 145) {
#line 161
      goto case_146;
    }
#line 161
    if (command == 144) {
#line 161
      goto case_146;
    }
#line 161
    if (command == 143) {
#line 161
      goto case_146;
    }
#line 166
    if (command == 147) {
#line 166
      goto case_147;
    }
#line 170
    if (command == 151) {
#line 170
      goto case_151;
    }
#line 170
    if (command == 150) {
#line 170
      goto case_151;
    }
#line 170
    if (command == 149) {
#line 170
      goto case_151;
    }
#line 170
    if (command == 148) {
#line 170
      goto case_151;
    }
#line 175
    if (command == 152) {
#line 175
      goto case_152;
    }
#line 179
    if (command == 156) {
#line 179
      goto case_156;
    }
#line 179
    if (command == 155) {
#line 179
      goto case_156;
    }
#line 179
    if (command == 154) {
#line 179
      goto case_156;
    }
#line 179
    if (command == 153) {
#line 179
      goto case_156;
    }
#line 184
    if (command == 160) {
#line 184
      goto case_160;
    }
#line 184
    if (command == 159) {
#line 184
      goto case_160;
    }
#line 184
    if (command == 158) {
#line 184
      goto case_160;
    }
#line 184
    if (command == 157) {
#line 184
      goto case_160;
    }
#line 189
    if (command == 161) {
#line 189
      goto case_161;
    }
#line 193
    if (command == 165) {
#line 193
      goto case_165;
    }
#line 193
    if (command == 164) {
#line 193
      goto case_165;
    }
#line 193
    if (command == 163) {
#line 193
      goto case_165;
    }
#line 193
    if (command == 162) {
#line 193
      goto case_165;
    }
#line 198
    if (command == 166) {
#line 198
      goto case_166;
    }
#line 202
    if (command == 170) {
#line 202
      goto case_170;
    }
#line 202
    if (command == 169) {
#line 202
      goto case_170;
    }
#line 202
    if (command == 168) {
#line 202
      goto case_170;
    }
#line 202
    if (command == 167) {
#line 202
      goto case_170;
    }
#line 207
    if (command == 238) {
#line 207
      goto case_238;
    }
#line 207
    if (command == 237) {
#line 207
      goto case_238;
    }
#line 207
    if (command == 236) {
#line 207
      goto case_238;
    }
#line 207
    if (command == 235) {
#line 207
      goto case_238;
    }
#line 212
    if (command == 242) {
#line 212
      goto case_242;
    }
#line 212
    if (command == 241) {
#line 212
      goto case_242;
    }
#line 212
    if (command == 240) {
#line 212
      goto case_242;
    }
#line 212
    if (command == 239) {
#line 212
      goto case_242;
    }
#line 218
    if (command == 246) {
#line 218
      goto case_246;
    }
#line 218
    if (command == 245) {
#line 218
      goto case_246;
    }
#line 218
    if (command == 244) {
#line 218
      goto case_246;
    }
#line 218
    if (command == 243) {
#line 218
      goto case_246;
    }
#line 223
    if (command == 247) {
#line 223
      goto case_247;
    }
#line 227
    if (command == 248) {
#line 227
      goto case_248;
    }
#line 230
    if (command == 249) {
#line 230
      goto case_249;
    }
#line 234
    if (command == 255) {
#line 234
      goto case_255;
    }
#line 238
    goto switch_default;
    case_131: /* CIL Label */ 
    case_130: /* CIL Label */ 
    case_129: /* CIL Label */ 
    case_128: /* CIL Label */ 
    {
#line 52
    val = (*dc_getuint)((command - 128) + 1);
    }
#line 53
    if (! SkipMode) {
      {
#line 53
      (*(curfontent->rvf_setchar))(val, 1);
      }
    }
#line 54
    goto switch_break;
    case_132: /* CIL Label */ 
    {
#line 57
    val = (*dc_getuint)(4);
#line 58
    val2 = (*dc_getuint)(4);
    }
#line 59
    if (! SkipMode) {
      {
#line 59
      (*dc_setrule)(val, val2, 1);
      }
    }
#line 60
    goto switch_break;
    case_136: /* CIL Label */ 
    case_135: /* CIL Label */ 
    case_134: /* CIL Label */ 
    case_133: /* CIL Label */ 
    {
#line 63
    val = (*dc_getuint)((command - 133) + 1);
    }
#line 64
    if (! SkipMode) {
      {
#line 64
      (*(curfontent->rvf_setchar))(val, 0);
      }
    }
#line 65
    goto switch_break;
    case_137: /* CIL Label */ 
    {
#line 68
    val = (*dc_getuint)(4);
#line 69
    val2 = (*dc_getuint)(4);
    }
#line 70
    if (! SkipMode) {
      {
#line 70
      (*dc_setrule)(val, val2, 0);
      }
    }
#line 71
    goto switch_break;
    case_138: /* CIL Label */ 
#line 74
    goto switch_break;
    case_139: /* CIL Label */ 
#line 78
    i = 0;
    {
#line 78
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 78
      if (! (i <= 9)) {
#line 78
        goto while_break___0;
      }
      {
#line 79
      count[i] = (*dc_getuint)(4);
#line 78
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 80
    tmp = (*dc_getuint)(4);
#line 80
    ppagep = (long )tmp;
#line 82
    z = 0;
#line 82
    y = z;
#line 82
    x = y;
#line 82
    w = x;
#line 82
    v = w;
#line 82
    h = v;
#line 83
    setdir(0);
#line 84
    basedir = 0;
#line 85
    sp = 0;
#line 86
    curfontent = (struct font_entry *)((void *)0);
#line 87
    dev_initpage();
    }
#line 89
    if (count[0] < FirstPage) {
#line 89
      tmp___0 = 1;
    } else
#line 89
    if (count[0] > LastPage) {
#line 89
      tmp___0 = 1;
    } else {
#line 89
      tmp___0 = 0;
    }
#line 89
    SkipMode = tmp___0;
#line 91
    if (! SkipMode) {
      {
#line 92
      dev_bop(count[0]);
      }
#line 93
      if (! G_quiet) {
#line 95
        if (debug >= 1) {
          {
#line 96
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[bop:%d\n",
                  count[0]);
          }
        } else {
          {
#line 99
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%d",
                  count[0]);
          }
        }
      }
    }
#line 102
    goto switch_break;
    case_140: /* CIL Label */ 
#line 105
    if (! SkipMode) {
      {
#line 106
      dev_eop();
      }
#line 108
      if (Stats) {
        {
#line 109
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" - %d total ch,  %d diff ch,  %d pxl bytes]\n",
                Stnc - Stnc0, Sndc - Sndc0, Snbpxl - Snbpx0);
        }
      } else
#line 114
      if (! G_quiet) {
#line 116
        if (debug >= 1) {
          {
#line 117
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"eop]\n");
          }
        } else {
          {
#line 120
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"] ");
#line 121
          ndone ++;
          }
#line 121
          if (ndone % 10 == 0) {
            {
#line 121
            _IO_putc('\n', stderr);
            }
          }
        }
        {
#line 125
        fflush(stderr);
        }
      }
    }
#line 128
    if (Reverse) {
#line 129
      if (ppagep > 0L) {
        {
#line 130
        fseek(dc_file, ppagep, 0);
        }
      } else {
#line 132
        return;
      }
    }
#line 133
    goto switch_break;
    case_141: /* CIL Label */ 
#line 136
    if (sp >= 100) {
      {
#line 137
      Fatal("stack overflow");
      }
    }
#line 138
    stack[sp].h = h;
#line 139
    stack[sp].v = v;
#line 140
    stack[sp].w = w;
#line 141
    stack[sp].x = x;
#line 142
    stack[sp].y = y;
#line 143
    stack[sp].z = z;
#line 144
    stack[sp].d = dir;
#line 145
    sp ++;
#line 146
    goto switch_break;
    case_142: /* CIL Label */ 
#line 149
    sp --;
#line 150
    if (sp < 0) {
      {
#line 151
      Fatal("stack underflow");
      }
    }
    {
#line 152
    h = stack[sp].h;
#line 153
    v = stack[sp].v;
#line 154
    w = stack[sp].w;
#line 155
    x = stack[sp].x;
#line 156
    y = stack[sp].y;
#line 157
    z = stack[sp].z;
#line 158
    setdir(stack[sp].d);
    }
#line 159
    goto switch_break;
    case_146: /* CIL Label */ 
    case_145: /* CIL Label */ 
    case_144: /* CIL Label */ 
    case_143: /* CIL Label */ 
    {
#line 162
    val = (*dc_getint)((command - 143) + 1);
    }
#line 163
    if (! SkipMode) {
      {
#line 163
      (*dc_moveover)(val);
      }
    }
#line 164
    goto switch_break;
    case_147: /* CIL Label */ 
#line 167
    if (! SkipMode) {
      {
#line 167
      (*dc_moveover)(w);
      }
    }
#line 168
    goto switch_break;
    case_151: /* CIL Label */ 
    case_150: /* CIL Label */ 
    case_149: /* CIL Label */ 
    case_148: /* CIL Label */ 
    {
#line 171
    w = (*dc_getint)((command - 148) + 1);
    }
#line 172
    if (! SkipMode) {
      {
#line 172
      (*dc_moveover)(w);
      }
    }
#line 173
    goto switch_break;
    case_152: /* CIL Label */ 
#line 176
    if (! SkipMode) {
      {
#line 176
      (*dc_moveover)(x);
      }
    }
#line 177
    goto switch_break;
    case_156: /* CIL Label */ 
    case_155: /* CIL Label */ 
    case_154: /* CIL Label */ 
    case_153: /* CIL Label */ 
    {
#line 180
    x = (*dc_getint)((command - 153) + 1);
    }
#line 181
    if (! SkipMode) {
      {
#line 181
      (*dc_moveover)(x);
      }
    }
#line 182
    goto switch_break;
    case_160: /* CIL Label */ 
    case_159: /* CIL Label */ 
    case_158: /* CIL Label */ 
    case_157: /* CIL Label */ 
    {
#line 185
    val = (*dc_getint)((command - 157) + 1);
    }
#line 186
    if (! SkipMode) {
      {
#line 186
      (*dc_movedown)(val);
      }
    }
#line 187
    goto switch_break;
    case_161: /* CIL Label */ 
#line 190
    if (! SkipMode) {
      {
#line 190
      (*dc_movedown)(y);
      }
    }
#line 191
    goto switch_break;
    case_165: /* CIL Label */ 
    case_164: /* CIL Label */ 
    case_163: /* CIL Label */ 
    case_162: /* CIL Label */ 
    {
#line 194
    y = (*dc_getint)((command - 162) + 1);
    }
#line 195
    if (! SkipMode) {
      {
#line 195
      (*dc_movedown)(y);
      }
    }
#line 196
    goto switch_break;
    case_166: /* CIL Label */ 
#line 199
    if (! SkipMode) {
      {
#line 199
      (*dc_movedown)(z);
      }
    }
#line 200
    goto switch_break;
    case_170: /* CIL Label */ 
    case_169: /* CIL Label */ 
    case_168: /* CIL Label */ 
    case_167: /* CIL Label */ 
    {
#line 203
    z = (*dc_getint)((command - 167) + 1);
    }
#line 204
    if (! SkipMode) {
      {
#line 204
      (*dc_movedown)(z);
      }
    }
#line 205
    goto switch_break;
    case_238: /* CIL Label */ 
    case_237: /* CIL Label */ 
    case_236: /* CIL Label */ 
    case_235: /* CIL Label */ 
    {
#line 208
    k = (*dc_getuint)((command - 235) + 1);
    }
#line 209
    if (! SkipMode) {
      {
#line 209
      SetFntNum(k, hdfidx);
      }
    }
#line 210
    goto switch_break;
    case_242: /* CIL Label */ 
    case_241: /* CIL Label */ 
    case_240: /* CIL Label */ 
    case_239: /* CIL Label */ 
    {
#line 213
    k = (*dc_getuint)((command - 239) + 1);
#line 214
    (*dc_getbytes)(SpecialStr, k);
    }
#line 215
    if (! SkipMode) {
      {
#line 215
      dev_dospecial(SpecialStr, k);
      }
    }
#line 216
    goto switch_break;
    case_246: /* CIL Label */ 
    case_245: /* CIL Label */ 
    case_244: /* CIL Label */ 
    case_243: /* CIL Label */ 
    {
#line 219
    (*dc_skipbytes)((command - 243) + 1);
#line 220
    SkipFontDef();
    }
#line 221
    goto switch_break;
    case_247: /* CIL Label */ 
    {
#line 224
    Fatal("PRE occurs within file");
    }
#line 225
    goto switch_break;
    case_248: /* CIL Label */ 
#line 228
    return;
    case_249: /* CIL Label */ 
    {
#line 231
    Fatal("POST_POST with no preceding POST");
    }
#line 232
    goto switch_break;
    case_255: /* CIL Label */ 
    {
#line 235
    tmp___1 = (*dc_getuint)(1);
#line 235
    setdir(basedir + tmp___1);
    }
#line 236
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 239
    if (command >= 171) {
#line 239
      if (command <= 234) {
#line 240
        if (! SkipMode) {
          {
#line 240
          SetFntNum(command - 171, hdfidx);
          }
        }
      } else {
#line 239
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 241
    if (command >= 0) {
#line 241
      if (command <= 127) {
#line 242
        if (! SkipMode) {
          {
#line 242
          (*(curfontent->rvf_setstring))(command);
          }
        }
      } else {
        {
#line 244
        Fatal("%d is an undefined command", command);
        }
      }
    } else {
      {
#line 244
      Fatal("%d is an undefined command", command);
      }
    }
#line 245
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dviconv.c"
int initdir(void) 
{ 


  {
  {
#line 252
  dir = 1;
#line 253
  setdir(0);
  }
#line 254
  return (0);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dviconv.c"
int setdir(int d ) 
{ 


  {
#line 259
  d %= 4;
#line 260
  if (dir != d) {
#line 261
    dir = d;
#line 262
    if (d == 0) {
      {
#line 263
      move = & h;
#line 264
      setdirhor();
      }
    } else
#line 265
    if (d == 1) {
      {
#line 266
      move = & v;
#line 267
      setdirver();
      }
    } else {
      {
#line 269
      Fatal("direction %d not supported", d);
      }
    }
    {
#line 270
    dev_dir(d);
    }
  }
#line 272
  return (0);
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
char *dvi2lib ;
#line 12
char dvidirpath[1024] ;
#line 29
int G_removecomments ;
#line 138
void dev_copystring(char *str ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.h"
void copy_type1_pfb(FILE *fp , char *fn ) ;
#line 63
void ps_add_setup(char *str ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psio.c"
static void copyfile(char *fn , BOOLEAN remcom ) ;
#line 16
static void createpipe(char *fn , BOOLEAN remcom ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psio.c"
void dev_copyfile(char *str ) 
{ 


  {
  {
#line 22
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%BeginFile: %s\n",
          str);
#line 23
  copyfile(str, 0);
#line 24
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%EndFile\n");
  }
#line 25
  return;
}
}
#line 35
int add_include_spec(char *f , void (*op)() ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psio.c"
void ps_add_include(char *str ) 
{ 
  int found ;
  char newf[1024] ;
  char *tmp ;

  {
  {
#line 34
  found = ps_searchfile(str, newf);
  }
#line 34
  if (found) {
#line 35
    if (found == 1) {
#line 35
      tmp = str;
    } else {
#line 35
      tmp = newf;
    }
    {
#line 35
    add_include_spec(tmp, & dev_copyfile);
    }
  } else {
    {
#line 37
    Warning("File %s not found", str);
    }
  }
#line 38
  return;
}
}
#line 48
int add_setup_spec(char *f , void (*op)() ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psio.c"
void ps_add_setup(char *str ) 
{ 
  int found ;
  char newf[1024] ;
  char *tmp ;

  {
  {
#line 47
  found = ps_searchfile(str, newf);
  }
#line 47
  if (found) {
#line 48
    if (found == 1) {
#line 48
      tmp = str;
    } else {
#line 48
      tmp = newf;
    }
    {
#line 48
    add_setup_spec(tmp, & dev_copyfile);
    }
  } else {
    {
#line 50
    Warning("File %s not found", str);
    }
  }
#line 51
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psio.c"
void ps_copyfigfile(char *str ) 
{ 
  int found ;
  char newf[1024] ;
  char *tmp ;

  {
  {
#line 60
  found = ps_searchfile(str, newf);
  }
#line 60
  if (found) {
    {
#line 61
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%BeginDocument: %s\n",
            str);
    }
#line 62
    if (found == 1) {
#line 62
      tmp = str;
    } else {
#line 62
      tmp = newf;
    }
    {
#line 62
    copyfile(tmp, G_removecomments);
#line 63
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%EndDocument\n");
    }
  } else {
    {
#line 65
    Warning("File %s not found", str);
    }
  }
#line 66
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psio.c"
int ps_searchfile(char *f , char *newf ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 73
  if ((int )*(f + 0) == 47) {
    {
#line 74
    tmp = access((char const   *)f, 4);
    }
#line 74
    if (tmp == 0) {
#line 75
      return (1);
    }
  } else {
#line 77
    if ((int )dvidirpath[0] != 0) {
      {
#line 78
      strcpy((char */* __restrict  */)newf, (char const   */* __restrict  */)(dvidirpath));
#line 79
      strcat((char */* __restrict  */)newf, (char const   */* __restrict  */)f);
#line 80
      tmp___0 = access((char const   *)newf, 4);
      }
#line 80
      if (tmp___0 == 0) {
#line 81
        return (2);
      }
    }
    {
#line 90
    tmp___1 = access((char const   *)f, 4);
    }
#line 90
    if (tmp___1 == 0) {
#line 91
      return (1);
    }
    {
#line 93
    strcpy((char */* __restrict  */)newf, (char const   */* __restrict  */)dvi2lib);
#line 94
    strcat((char */* __restrict  */)newf, (char const   */* __restrict  */)"/");
#line 95
    strcat((char */* __restrict  */)newf, (char const   */* __restrict  */)f);
#line 96
    tmp___2 = access((char const   *)newf, 4);
    }
#line 96
    if (tmp___2 == 0) {
#line 97
      return (2);
    }
  }
#line 99
  return (0);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psio.c"
void ps_createpipe(char *str ) 
{ 


  {
  {
#line 106
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%BeginDocument: %s\n",
          str);
#line 107
  createpipe(str, G_removecomments);
#line 108
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%EndDocument\n");
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psio.c"
void dev_copystring(char *str ) 
{ 


  {
  {
#line 115
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%s\n",
          str);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psio.c"
void ps_string(char *str ) 
{ 
  int i ;
  int instring___0 ;
  int lastc ;

  {
#line 123
  instring___0 = 0;
#line 124
  lastc = 0;
#line 126
  i = 0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! *str) {
#line 127
      goto while_break;
    }
#line 128
    if (i > 65) {
#line 128
      if ((int )*str == 32) {
#line 128
        if (instring___0 == 0) {
          {
#line 129
          _IO_putc('\n', outfp);
#line 130
          i = 0;
          }
        } else {
          {
#line 132
          _IO_putc((int )*str, outfp);
#line 133
          i ++;
          }
        }
      } else {
        {
#line 132
        _IO_putc((int )*str, outfp);
#line 133
        i ++;
        }
      }
    } else {
      {
#line 132
      _IO_putc((int )*str, outfp);
#line 133
      i ++;
      }
    }
#line 135
    if ((int )*str == 40) {
#line 135
      if (lastc != 92) {
#line 136
        instring___0 = 1;
      } else {
#line 135
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 137
    if ((int )*str == 41) {
#line 137
      if (lastc != 92) {
#line 138
        instring___0 = 0;
      }
    }
#line 139
    lastc = (int )*str;
#line 140
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psio.c"
int pschar(int c ) 
{ 


  {
#line 147
  if (c < 32) {
    {
#line 148
    putoct(c);
    }
  } else
#line 147
  if (c >= 127) {
    {
#line 148
    putoct(c);
    }
  } else
#line 149
  if (c == 40) {
    {
#line 150
    _IO_putc('\\', outfp);
#line 151
    _IO_putc(c, outfp);
    }
  } else
#line 149
  if (c == 41) {
    {
#line 150
    _IO_putc('\\', outfp);
#line 151
    _IO_putc(c, outfp);
    }
  } else
#line 149
  if (c == 92) {
    {
#line 150
    _IO_putc('\\', outfp);
#line 151
    _IO_putc(c, outfp);
    }
  } else {
    {
#line 153
    _IO_putc(c, outfp);
    }
  }
#line 154
  return (0);
}
}
#line 160
int c2pstr(int code , int n ) ;
#line 156 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psio.c"
int codetopsstr(int code , int n ) 
{ 


  {
  {
#line 159
  _IO_putc('(', outfp);
#line 160
  c2pstr(code, n);
#line 161
  fputs((char const   */* __restrict  */)") ", (FILE */* __restrict  */)outfp);
  }
#line 162
  return (0);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psio.c"
int c2pstr(int code , int n ) 
{ 


  {
#line 167
  if (n > 0) {
    {
#line 168
    c2pstr(code >> 8, n - 1);
#line 169
    pschar(code & 255);
    }
  }
#line 171
  return (0);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psio.c"
int cpfile(FILE *spfp , BOOLEAN remcom , char *fn ) 
{ 
  int t ;
  int pt ;

  {
  {
#line 181
  t = _IO_getc(spfp);
  }
#line 181
  if (t == 128) {
    {
#line 182
    copy_type1_pfb(spfp, fn);
    }
  } else
#line 183
  if (remcom) {
#line 184
    pt = '\n';
    {
#line 184
    while (1) {
      while_continue: /* CIL Label */ ;
#line 184
      if (! (t != -1)) {
#line 184
        goto while_break;
      }
#line 185
      if (t == 37) {
#line 185
        if (pt == 10) {
          {
#line 186
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 186
            t = _IO_getc(spfp);
            }
#line 186
            if (! (t != -1)) {
#line 186
              goto while_break___0;
            }
#line 187
            if (t == 10) {
#line 188
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 190
          _IO_putc(t, outfp);
#line 191
          pt = t;
          }
        }
      } else {
        {
#line 190
        _IO_putc(t, outfp);
#line 191
        pt = t;
        }
      }
      {
#line 184
      t = _IO_getc(spfp);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 195
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 195
      if (! (t != -1)) {
#line 195
        goto while_break___1;
      }
      {
#line 196
      _IO_putc(t, outfp);
#line 195
      t = _IO_getc(spfp);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 197
  return (0);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psio.c"
static void copyfile(char *fn , BOOLEAN remcom ) 
{ 
  FILE *spfp ;

  {
  {
#line 210
  spfp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 210
  if ((unsigned long )spfp == (unsigned long )((void *)0)) {
    {
#line 211
    Warning("Unable to open file %s", fn);
    }
#line 212
    return;
  }
#line 214
  if (! G_quiet) {
    {
#line 215
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s",
            fn);
    }
  }
  {
#line 216
  cpfile(spfp, remcom, fn);
#line 217
  fclose(spfp);
  }
#line 218
  if (! G_quiet) {
    {
#line 219
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"] ");
#line 220
    fflush(stderr);
    }
  }
#line 222
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psio.c"
static void createpipe(char *fn , BOOLEAN remcom ) 
{ 
  FILE *spfp ;

  {
  {
#line 240
  spfp = popen((char const   *)fn, "r");
  }
#line 240
  if ((unsigned long )spfp != (unsigned long )((void *)0)) {
    {
#line 241
    Warning("Unable to create pipe %s", fn);
    }
#line 242
    return;
  }
#line 244
  if (! G_quiet) {
    {
#line 245
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s",
            fn);
    }
  }
  {
#line 246
  cpfile(spfp, remcom, fn);
#line 247
  pclose(spfp);
  }
#line 248
  if (! G_quiet) {
    {
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"] ");
#line 250
    fflush(stderr);
    }
  }
#line 253
  return;
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
FILE *dvifp ;
#line 30 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pscolor.c"
int pagenum  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pscolor.c"
static struct colorpage *colorhash[89]  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pscolor.c"
static char cstack[3000]  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pscolor.c"
static char *csp  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pscolor.c"
static char *cend  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pscolor.c"
static char *bg  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pscolor.c"
void colorcmdout(char *s ) 
{ 
  char *p ;
  char tempword[100] ;
  size_t tmp ;

  {
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! ((int )*s <= 32)) {
#line 65
      goto while_break;
    }
#line 66
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  if ((int )*s == 34) {
    {
#line 68
    fputs((char const   */* __restrict  */)(s + 1), (FILE */* __restrict  */)outfp);
#line 69
    _IO_putc('\n', outfp);
    }
#line 70
    return;
  }
#line 72
  p = s;
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 72
    if (*p) {
#line 72
      if (! ((int )*p > 32)) {
#line 72
        goto while_break___0;
      }
    } else {
#line 72
      goto while_break___0;
    }
#line 72
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 73
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 73
    if (*p) {
#line 73
      if (! ((int )*p <= 32)) {
#line 73
        goto while_break___1;
      }
    } else {
#line 73
      goto while_break___1;
    }
#line 73
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 74
  if ((int )*p == 0) {
    {
#line 75
    fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)outfp);
#line 76
    _IO_putc('\n', outfp);
    }
#line 77
    return;
  }
  {
#line 79
  fputs((char const   */* __restrict  */)p, (FILE */* __restrict  */)outfp);
#line 80
  strcpy((char */* __restrict  */)(tempword), (char const   */* __restrict  */)" TeXcolor");
#line 81
  tmp = strlen((char const   *)(tempword));
#line 81
  p = tempword + tmp;
  }
  {
#line 81
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 81
    if (*s) {
#line 81
      if (! ((int )*s > 32)) {
#line 81
        goto while_break___2;
      }
    } else {
#line 81
      goto while_break___2;
    }
#line 82
    *p = *s;
#line 81
    p ++;
#line 81
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 83
  *p = (char)0;
#line 84
  fputs((char const   */* __restrict  */)(tempword), (FILE */* __restrict  */)outfp);
#line 85
  _IO_putc('\n', outfp);
  }
#line 86
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pscolor.c"
void initcolor(void) 
{ 
  int i ;
  struct colorpage *p ;
  struct colorpage *q ;
  size_t tmp ;

  {
#line 96
  i = 0;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (i < 89)) {
#line 96
      goto while_break;
    }
#line 97
    p = colorhash[i];
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 97
      if (! p) {
#line 97
        goto while_break___0;
      }
      {
#line 98
      q = p->next;
#line 99
      free((void *)p);
#line 97
      p = q;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 101
    colorhash[i] = (struct colorpage *)0;
#line 96
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  strcpy((char */* __restrict  */)(cstack), (char const   */* __restrict  */)"\n");
#line 104
  strcat((char */* __restrict  */)(cstack), (char const   */* __restrict  */)"Black");
#line 105
  tmp = strlen((char const   *)(cstack));
#line 105
  csp = cstack + tmp;
#line 106
  cend = (cstack + 3000) - 3;
#line 107
  bg = (char *)0;
  }
#line 108
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pscolor.c"
void background(char *bkgrnd ) 
{ 
  size_t tmp ;

  {
#line 118
  if (bkgrnd) {
#line 118
    if (*bkgrnd) {
      {
#line 119
      tmp = strlen((char const   *)bkgrnd);
      }
#line 119
      if (tmp > 120UL) {
        {
#line 120
        Warning(" color name too long; ignored");
        }
      } else {
        {
#line 122
        strcpy((char */* __restrict  */)bg, (char const   */* __restrict  */)bkgrnd);
        }
      }
    }
  }
#line 124
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pscolor.c"
void pushcolor(char *p , Boolean outtops ) 
{ 
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 134
  tmp = strlen((char const   *)p);
  }
#line 134
  if ((unsigned long )(csp + tmp) > (unsigned long )cend) {
    {
#line 135
    Fatal("! out of color stack space");
    }
  }
  {
#line 136
  tmp___0 = csp;
#line 136
  csp ++;
#line 136
  *tmp___0 = (char )'\n';
#line 137
  strcpy((char */* __restrict  */)csp, (char const   */* __restrict  */)p);
#line 138
  tmp___1 = strlen((char const   *)p);
#line 138
  csp += tmp___1;
  }
#line 139
  if (outtops) {
    {
#line 140
    colorcmdout(p);
    }
  }
#line 142
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pscolor.c"
void popcolor(Boolean outtops ) 
{ 
  char *p ;

  {
#line 151
  p = csp - 1;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if ((unsigned long )p >= (unsigned long )(cstack)) {
#line 153
      if (! ((int )*p != 10)) {
#line 153
        goto while_break;
      }
    } else {
#line 153
      goto while_break;
    }
#line 154
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  if ((unsigned long )p == (unsigned long )(cstack)) {
#line 156
    return;
  }
#line 157
  *p = (char)0;
#line 158
  csp = p;
#line 159
  p --;
  {
#line 159
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 159
    if ((unsigned long )p >= (unsigned long )(cstack)) {
#line 159
      if (! ((int )*p != 10)) {
#line 159
        goto while_break___0;
      }
    } else {
#line 159
      goto while_break___0;
    }
#line 159
    p --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 160
  p ++;
#line 161
  if (outtops) {
    {
#line 162
    colorcmdout(p);
    }
  }
#line 164
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pscolor.c"
void resetcolorstack(char *p , int outtops ) 
{ 
  char *q ;

  {
#line 174
  q = csp - 1;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if ((unsigned long )q > (unsigned long )(cstack)) {
#line 176
      if (! ((int )*q != 10)) {
#line 176
        goto while_break;
      }
    } else {
#line 176
      goto while_break;
    }
#line 177
    q --;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  if ((unsigned long )q > (unsigned long )(cstack)) {
#line 178
    if (outtops == 0) {
      {
#line 184
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You\'ve mistakenly made a global color change ");
#line 185
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"to %s within nested colors\n",
              p);
#line 186
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"on page %d. Will try to recover.\n",
              pagenum);
      }
    }
  }
  {
#line 189
  csp = cstack;
#line 190
  *csp = (char)0;
#line 191
  pushcolor(p, (Boolean )outtops);
  }
#line 192
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pscolor.c"
void bopcolor(int outtops ) 
{ 
  integer pageloc ;
  long tmp ;
  int h___0 ;
  struct colorpage *p ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  char *p___0 ;
  int tmp___5 ;

  {
  {
#line 210
  tmp = ftell(dvifp);
#line 210
  pageloc = (integer )tmp;
#line 211
  h___0 = pageloc % 89;
#line 212
  p = colorhash[h___0];
  }
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! p) {
#line 214
      goto while_break;
    }
#line 215
    if (p->boploc == pageloc) {
#line 216
      goto while_break;
    } else {
#line 218
      p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  if (p) {
    {
#line 221
    strcpy((char */* __restrict  */)(cstack), (char const   */* __restrict  */)(p->colordat));
#line 222
    tmp___0 = strlen((char const   *)(cstack));
#line 222
    csp = cstack + tmp___0;
#line 223
    bg = p->bg;
    }
#line 224
    if (outtops) {
      {
#line 224
      tmp___1 = strcmp((char const   *)bg, "White");
      }
#line 224
      if (tmp___1 != 0) {
#line 224
        if (*(bg + 0)) {
          {
#line 225
          fputs((char const   */* __restrict  */)"gsave ", (FILE */* __restrict  */)outfp);
#line 226
          colorcmdout(bg);
#line 227
          fputs((char const   */* __restrict  */)"clippath fill grestore\n", (FILE */* __restrict  */)outfp);
          }
        }
      }
    }
  } else {
    {
#line 230
    tmp___2 = strlen((char const   *)(cstack));
#line 230
    tmp___3 = malloc((size_t )((integer )((tmp___2 + sizeof(struct colorpage )) + 120UL)));
#line 230
    p = (struct colorpage *)tmp___3;
#line 232
    p->next = colorhash[h___0];
#line 233
    p->boploc = pageloc;
#line 234
    strcpy((char */* __restrict  */)(p->colordat), (char const   */* __restrict  */)(cstack));
#line 235
    tmp___4 = strlen((char const   *)(cstack));
#line 235
    p->bg = (p->colordat + tmp___4) + 1;
    }
#line 236
    if (bg) {
      {
#line 237
      strcpy((char */* __restrict  */)p->bg, (char const   */* __restrict  */)bg);
      }
    } else {
#line 239
      *(p->bg) = (char)0;
    }
#line 240
    bg = p->bg;
#line 241
    colorhash[h___0] = p;
  }
#line 243
  if (outtops) {
#line 244
    p___0 = csp - 1;
    {
#line 245
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 245
      if ((unsigned long )p___0 >= (unsigned long )(cstack)) {
#line 245
        if (! ((int )*p___0 != 10)) {
#line 245
          goto while_break___0;
        }
      } else {
#line 245
        goto while_break___0;
      }
#line 246
      p___0 --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 247
    p___0 ++;
#line 248
    tmp___5 = strcmp((char const   *)p___0, "Black");
    }
#line 248
    if (tmp___5 != 0) {
      {
#line 249
      colorcmdout(p___0);
      }
    }
  }
#line 252
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int get_tfm_psbiops(struct font_entry *fe , struct psbiops *po___0 ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
void dev_tfm_initfontdict(struct font_entry *fe ) 
{ 
  struct psbiops po___0 ;
  char *tmp ;

  {
  {
#line 21
  fe->k = dev_newdevfont();
#line 22
  get_tfm_psbiops(fe, & po___0);
#line 23
  tmp = psfname(fe->k);
#line 23
  psfindfontop(tmp, & po___0);
#line 24
  fe->ncdl = 0;
  }
#line 25
  return;
}
}
#line 32
int tfm_setchar(int c ) ;
#line 32
int tfm_setstring(char *s , int len ) ;
#line 33
int tfm_setchar_abs(int c ) ;
#line 33
int tfm_setstring_abs(char *s , int len ) ;
#line 36
int bifpos_relun(struct bifont *bf ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
void dev_tfm_initfe(struct font_entry *fe ) 
{ 
  int tmp ;

  {
  {
#line 35
  fe->dev_fontdict = & tfm_fontdict;
#line 36
  tmp = bifpos_relun((*((struct tfmfntinfo **)(& fe->finfo)))->tfm_bf);
  }
#line 36
  if (tmp) {
#line 37
    fe->dev_setchar = & tfm_setchar;
#line 38
    fe->dev_setstring = & tfm_setstring;
  } else {
#line 40
    fe->dev_setchar = & tfm_setchar_abs;
#line 41
    fe->dev_setstring = & tfm_setstring_abs;
  }
#line 43
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int tfm_setchar(int c ) 
{ 
  struct tfmchar_entry *ce ;
  int cw ;

  {
  {
#line 48
  ce = & (*((struct tfmfntinfo **)(& curfontent->finfo)))->ch[c];
#line 51
  begin_string();
#line 52
  pschar((int )ce->dev_char);
#line 53
  cw = ce->tfmw;
#line 53
  *ps_move += cw;
  }
#line 54
  return (cw);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int tfm_setstring(char *s , int len ) 
{ 
  char *sp ;
  struct tfmchar_entry *ce ;
  int cw ;

  {
  {
#line 62
  ce = (*((struct tfmfntinfo **)(& curfontent->finfo)))->ch;
#line 65
  begin_string();
#line 66
  sp = s;
#line 66
  cw = 0;
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! ((unsigned long )sp < (unsigned long )(s + len))) {
#line 66
      goto while_break;
    }
    {
#line 67
    pschar((int )(ce + (int )*sp)->dev_char);
#line 68
    cw += (ce + (int )*sp)->tfmw;
#line 66
    sp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  *ps_move += cw;
#line 71
  return (cw);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int tfm_setchar_abs(int c ) 
{ 
  int cw ;

  {
  {
#line 79
  cw = tfm_setchar(c);
#line 80
  dev_setposn_abs(ps_h, ps_v);
  }
#line 81
  return (cw);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int tfm_setstring_abs(char *s , int len ) 
{ 
  char *sp ;
  struct tfmchar_entry *ce ;
  int cw ;
  int w ;

  {
#line 89
  ce = (*((struct tfmfntinfo **)(& curfontent->finfo)))->ch;
#line 92
  sp = s;
#line 92
  cw = 0;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! ((unsigned long )sp < (unsigned long )(s + len))) {
#line 92
      goto while_break;
    }
    {
#line 93
    begin_string();
#line 94
    pschar((int )(ce + (int )*sp)->dev_char);
#line 95
    end_string();
#line 96
    w = (ce + (int )*sp)->tfmw;
#line 96
    cw += w;
#line 97
    *ps_move += w;
#line 98
    dev_setposn_abs(ps_h, ps_v);
#line 92
    sp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (cw);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
void dev_jstfm_initfontdict(struct font_entry *fe ) 
{ 
  struct jsubshare *jss ;
  struct psbiops po___0 ;
  char *tmp ;

  {
  {
#line 113
  jss = (*((struct jstfmfntinfo **)(& fe->finfo)))->js_share;
#line 114
  jss->jss_dev_font = dev_newdevfont();
#line 115
  get_jstfm_psbiops(fe, & po___0);
#line 116
  tmp = psfname(jss->jss_dev_font);
#line 116
  psfindfontop(tmp, & po___0);
  }
#line 118
  return;
}
}
#line 126
int jstfm_setchar(int c ) ;
#line 126
int jstfm_setchar_euc(int c ) ;
#line 126
int jstfm_setchar_sjis(int c ) ;
#line 127
int jstfm_setstring(char *s , int len ) ;
#line 127
int jstfm_setstring_euc(char *s , int len ) ;
#line 127
int jstfm_setstring_sjis(char *s , int len ) ;
#line 128
int jstfm_setchar_abs(int c ) ;
#line 128
int jstfm_setchar_abs_euc(int c ) ;
#line 128
int jstfm_setchar_abs_sjis(int c ) ;
#line 129
int jstfm_setstring_abs(char *s , int len ) ;
#line 129
int jstfm_setstring_abs_euc(char *s , int len ) ;
#line 129
int jstfm_setstring_abs_sjis(char *s , int len ) ;
#line 135
int bif_coding(struct bifont *bf ) ;
#line 120 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
void dev_jstfm_initfe(struct font_entry *fe ) 
{ 
  struct bifont *bf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 132
  fe->dev_fontdict = & jstfm_fontdict;
#line 133
  bf = (*((struct jstfmfntinfo **)(& fe->finfo)))->js_bf;
#line 134
  tmp___1 = bifpos_relun(bf);
  }
#line 134
  if (tmp___1) {
    {
#line 135
    tmp = bif_coding(bf);
    }
    {
#line 136
    if (tmp == 0) {
#line 136
      goto case_0;
    }
#line 140
    if (tmp == 1) {
#line 140
      goto case_1;
    }
#line 144
    if (tmp == 2) {
#line 144
      goto case_2;
    }
#line 135
    goto switch_break;
    case_0: /* CIL Label */ 
#line 137
    fe->dev_setchar = & jstfm_setchar;
#line 138
    fe->dev_setstring = & jstfm_setstring;
#line 139
    goto switch_break;
    case_1: /* CIL Label */ 
#line 141
    fe->dev_setchar = & jstfm_setchar_euc;
#line 142
    fe->dev_setstring = & jstfm_setstring_euc;
#line 143
    goto switch_break;
    case_2: /* CIL Label */ 
#line 145
    fe->dev_setchar = & jstfm_setchar_sjis;
#line 146
    fe->dev_setstring = & jstfm_setstring_sjis;
#line 147
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 150
    tmp___0 = bif_coding(bf);
    }
    {
#line 151
    if (tmp___0 == 0) {
#line 151
      goto case_0___0;
    }
#line 155
    if (tmp___0 == 1) {
#line 155
      goto case_1___0;
    }
#line 159
    if (tmp___0 == 2) {
#line 159
      goto case_2___0;
    }
#line 150
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 152
    fe->dev_setchar = & jstfm_setchar_abs;
#line 153
    fe->dev_setstring = & jstfm_setstring_abs;
#line 154
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 156
    fe->dev_setchar = & jstfm_setchar_abs_euc;
#line 157
    fe->dev_setstring = & jstfm_setstring_abs_euc;
#line 158
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 160
    fe->dev_setchar = & jstfm_setchar_abs_sjis;
#line 161
    fe->dev_setstring = & jstfm_setstring_abs_sjis;
#line 162
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 165
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int pschar_jis(int c1___0 , int c2___0 ) 
{ 


  {
  {
#line 170
  pschar(c1___0);
#line 171
  pschar(c2___0);
  }
#line 172
  return (0);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int pschar_euc(int c1___0 , int c2___0 ) 
{ 


  {
  {
#line 177
  pschar(c1___0 + 128);
#line 178
  pschar(c2___0 + 128);
  }
#line 179
  return (0);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int pschar_sjis(int c1___0 , int c2___0 ) 
{ 
  int c ;
  int tmp ;

  {
  {
#line 184
  tmp = jis_to_sjis((c1___0 << 8) + c2___0);
#line 184
  c = tmp;
#line 186
  pschar(c >> 8);
#line 187
  pschar(c & 255);
  }
#line 188
  return (0);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jstfm_setchar_gen(int c , int (*psch)() ) 
{ 
  struct jstfmchar_entry *ce ;
  int cw ;

  {
  {
#line 194
  ce = & (*((struct jstfmfntinfo **)(& curfontent->finfo)))->ch[c];
#line 197
  begin_string();
#line 198
  (*psch)((int )ce->dev_ku, (int )ce->dev_ten);
#line 199
  cw = ce->tfmw;
#line 199
  *ps_move += cw;
  }
#line 200
  return (cw);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jstfm_setchar(int c ) 
{ 
  int tmp ;

  {
  {
#line 206
  tmp = jstfm_setchar_gen(c, (int (*)())(& pschar_jis));
  }
#line 206
  return (tmp);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jstfm_setchar_euc(int c ) 
{ 
  int tmp ;

  {
  {
#line 212
  tmp = jstfm_setchar_gen(c, (int (*)())(& pschar_euc));
  }
#line 212
  return (tmp);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jstfm_setchar_sjis(int c ) 
{ 
  int tmp ;

  {
  {
#line 218
  tmp = jstfm_setchar_gen(c, (int (*)())(& pschar_sjis));
  }
#line 218
  return (tmp);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jstfm_setstring_gen(char *s , int len , int (*psch)() ) 
{ 
  char *sp ;
  struct jstfmchar_entry *ce ;
  int cw ;

  {
  {
#line 227
  ce = (*((struct jstfmfntinfo **)(& curfontent->finfo)))->ch;
#line 230
  begin_string();
#line 231
  sp = s;
#line 231
  cw = 0;
  }
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! ((unsigned long )sp < (unsigned long )(s + len))) {
#line 231
      goto while_break;
    }
    {
#line 232
    (*psch)((int )(ce + (int )*sp)->dev_ku, (int )(ce + (int )*sp)->dev_ten);
#line 233
    cw += (ce + (int )*sp)->tfmw;
#line 231
    sp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  *ps_move += cw;
#line 236
  return (cw);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jstfm_setstring(char *s , int len ) 
{ 
  int tmp ;

  {
  {
#line 243
  tmp = jstfm_setstring_gen(s, len, (int (*)())(& pschar_jis));
  }
#line 243
  return (tmp);
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jstfm_setstring_euc(char *s , int len ) 
{ 
  int tmp ;

  {
  {
#line 250
  tmp = jstfm_setstring_gen(s, len, (int (*)())(& pschar_euc));
  }
#line 250
  return (tmp);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jstfm_setstring_sjis(char *s , int len ) 
{ 
  int tmp ;

  {
  {
#line 257
  tmp = jstfm_setstring_gen(s, len, (int (*)())(& pschar_sjis));
  }
#line 257
  return (tmp);
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int setchar_abs_gen(int c , int (*setch)() ) 
{ 
  int cw ;

  {
  {
#line 266
  cw = (*setch)(c);
#line 267
  dev_setposn_abs(ps_h, ps_v);
  }
#line 268
  return (cw);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jstfm_setchar_abs(int c ) 
{ 
  int tmp ;

  {
  {
#line 274
  tmp = setchar_abs_gen(c, (int (*)())(& jstfm_setchar));
  }
#line 274
  return (tmp);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jstfm_setchar_abs_euc(int c ) 
{ 
  int tmp ;

  {
  {
#line 280
  tmp = setchar_abs_gen(c, (int (*)())(& jstfm_setchar_euc));
  }
#line 280
  return (tmp);
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jstfm_setchar_abs_sjis(int c ) 
{ 
  int tmp ;

  {
  {
#line 286
  tmp = setchar_abs_gen(c, (int (*)())(& jstfm_setchar_sjis));
  }
#line 286
  return (tmp);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jstfm_setstring_abs_gen(char *s , int len , int (*psch)() ) 
{ 
  char *sp ;
  struct jstfmchar_entry *ce ;
  int cw ;
  int w ;

  {
#line 295
  ce = (*((struct jstfmfntinfo **)(& curfontent->finfo)))->ch;
#line 298
  sp = s;
#line 298
  cw = 0;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! ((unsigned long )sp < (unsigned long )(s + len))) {
#line 298
      goto while_break;
    }
    {
#line 299
    begin_string();
#line 300
    (*psch)((int )(ce + (int )*sp)->dev_ku, (int )(ce + (int )*sp)->dev_ten);
#line 301
    end_string();
#line 302
    w = (ce + (int )*sp)->tfmw;
#line 302
    cw += w;
#line 303
    *ps_move += w;
#line 304
    dev_setposn_abs(ps_h, ps_v);
#line 298
    sp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  return (cw);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jstfm_setstring_abs(char *s , int len ) 
{ 
  int tmp ;

  {
  {
#line 313
  tmp = jstfm_setstring_abs_gen(s, len, (int (*)())(& pschar_jis));
  }
#line 313
  return (tmp);
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jstfm_setstring_abs_euc(char *s , int len ) 
{ 
  int tmp ;

  {
  {
#line 320
  tmp = jstfm_setstring_abs_gen(s, len, (int (*)())(& pschar_euc));
  }
#line 320
  return (tmp);
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jstfm_setstring_abs_sjis(char *s , int len ) 
{ 
  int tmp ;

  {
  {
#line 327
  tmp = jstfm_setstring_abs_gen(s, len, (int (*)())(& pschar_sjis));
  }
#line 327
  return (tmp);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
void dev_jfm_initfontdict(struct font_entry *fe ) 
{ 
  struct psbiops po___0 ;
  char *tmp ;

  {
  {
#line 339
  fe->k = dev_newdevfont();
#line 340
  get_jfm_psbiops(fe, & po___0);
#line 341
  tmp = psfname(fe->k);
#line 341
  psfindfontop(tmp, & po___0);
#line 342
  fe->ncdl = 0;
  }
#line 343
  return;
}
}
#line 352
int jfm_setchar(int c ) ;
#line 352
int jfm_setchar_euc(int c ) ;
#line 352
int jfm_setchar_sjis(int c ) ;
#line 353
int jfm_setstring(char *s , int len ) ;
#line 354
int jfm_setchar_abs(int c ) ;
#line 354
int jfm_setchar_abs_euc(int c ) ;
#line 354
int jfm_setchar_abs_sjis(int c ) ;
#line 355
int jfm_setstring_abs(char *s , int len ) ;
#line 356
int jfm_setchar_v(int c ) ;
#line 356
int jfm_setchar_v_euc(int c ) ;
#line 356
int jfm_setchar_v_sjis(int c ) ;
#line 357
int jfm_setstring_v(char *s , int len ) ;
#line 358
int jfm_setchar_vabs(int c ) ;
#line 358
int jfm_setchar_vabs_euc(int c ) ;
#line 358
int jfm_setchar_vabs_sjis(int c ) ;
#line 359
int jfm_setstring_vabs(char *s , int len ) ;
#line 345 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
void dev_jfm_initfe(struct font_entry *fe , int id___0 ) 
{ 
  struct bifont *bf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 361
  fe->dev_fontdict = & tfm_fontdict;
#line 362
  bf = (*((struct jfmfntinfo **)(& fe->finfo)))->jfm_bf;
#line 363
  if (id___0 == 11) {
    {
#line 364
    tmp___1 = bifpos_rel(bf);
    }
#line 364
    if (tmp___1) {
      {
#line 365
      tmp = bif_coding(bf);
      }
      {
#line 366
      if (tmp == 0) {
#line 366
        goto case_0;
      }
#line 369
      if (tmp == 1) {
#line 369
        goto case_1;
      }
#line 372
      if (tmp == 2) {
#line 372
        goto case_2;
      }
#line 365
      goto switch_break;
      case_0: /* CIL Label */ 
#line 367
      fe->dev_setchar = & jfm_setchar;
#line 368
      goto switch_break;
      case_1: /* CIL Label */ 
#line 370
      fe->dev_setchar = & jfm_setchar_euc;
#line 371
      goto switch_break;
      case_2: /* CIL Label */ 
#line 373
      fe->dev_setchar = & jfm_setchar_sjis;
#line 374
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 376
      fe->dev_setstring = & jfm_setstring;
    } else {
      {
#line 378
      tmp___0 = bif_coding(bf);
      }
      {
#line 379
      if (tmp___0 == 0) {
#line 379
        goto case_0___0;
      }
#line 382
      if (tmp___0 == 1) {
#line 382
        goto case_1___0;
      }
#line 385
      if (tmp___0 == 2) {
#line 385
        goto case_2___0;
      }
#line 378
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 380
      fe->dev_setchar = & jfm_setchar_abs;
#line 381
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 383
      fe->dev_setchar = & jfm_setchar_abs_euc;
#line 384
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 386
      fe->dev_setchar = & jfm_setchar_abs_sjis;
#line 387
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 389
      fe->dev_setstring = & jfm_setstring_abs;
    }
  } else {
    {
#line 392
    tmp___2 = bifpos_rel((*((struct jfmfntinfo **)(& fe->finfo)))->jfm_bf);
    }
#line 392
    if (tmp___2) {
#line 393
      fe->dev_setchar = & jfm_setchar_v;
#line 394
      fe->dev_setstring = & jfm_setstring_v;
    } else {
#line 396
      fe->dev_setchar = & jfm_setchar_vabs;
#line 397
      fe->dev_setstring = & jfm_setstring_vabs;
    }
  }
#line 400
  return;
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setchar_gen(int c , int (*bstr)() , int (*psch)() ) 
{ 
  int cw ;
  struct jfmfntinfo *jfmfi ;
  int tmp ;

  {
  {
#line 407
  jfmfi = *((struct jfmfntinfo **)(& curfontent->finfo));
#line 409
  (*bstr)();
#line 410
  (*psch)(c >> 8, c & 255);
#line 411
  tmp = getctype(c, jfmfi);
#line 411
  cw = (jfmfi->ch + tmp)->tfmw;
#line 411
  *ps_move += cw;
  }
#line 412
  return (cw);
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setchar(int c ) 
{ 
  int tmp ;

  {
  {
#line 420
  tmp = jfm_setchar_gen(c, & begin_string, (int (*)())(& pschar_jis));
  }
#line 420
  return (tmp);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setchar_euc(int c ) 
{ 
  int tmp ;

  {
  {
#line 426
  tmp = jfm_setchar_gen(c, & begin_string, (int (*)())(& pschar_euc));
  }
#line 426
  return (tmp);
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setchar_sjis(int c ) 
{ 
  int tmp ;

  {
  {
#line 432
  tmp = jfm_setchar_gen(c, & begin_string, (int (*)())(& pschar_sjis));
  }
#line 432
  return (tmp);
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setstring(char *s , int len ) 
{ 


  {
  {
#line 440
  Fatal("%s implementation error: jfm_setstring", G_progname);
  }
#line 441
  return (0);
}
}
#line 443 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setchar_abs(int c ) 
{ 
  int tmp ;

  {
  {
#line 446
  tmp = setchar_abs_gen(c, (int (*)())(& jfm_setchar));
  }
#line 446
  return (tmp);
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setchar_abs_euc(int c ) 
{ 
  int tmp ;

  {
  {
#line 452
  tmp = setchar_abs_gen(c, (int (*)())(& jfm_setchar_euc));
  }
#line 452
  return (tmp);
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setchar_abs_sjis(int c ) 
{ 
  int tmp ;

  {
  {
#line 458
  tmp = setchar_abs_gen(c, (int (*)())(& jfm_setchar_sjis));
  }
#line 458
  return (tmp);
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setstring_abs(char *s , int len ) 
{ 


  {
  {
#line 466
  Fatal("%s implementation error: jfm_setstring_abs", G_progname);
  }
#line 467
  return (0);
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setchar_v(int c ) 
{ 
  int tmp ;

  {
  {
#line 472
  tmp = jfm_setchar_gen(c, & begin_string_v, (int (*)())(& pschar_jis));
  }
#line 472
  return (tmp);
}
}
#line 475 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setchar_v_euc(int c ) 
{ 
  int tmp ;

  {
  {
#line 478
  tmp = jfm_setchar_gen(c, & begin_string_v, (int (*)())(& pschar_euc));
  }
#line 478
  return (tmp);
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setchar_v_sjis(int c ) 
{ 
  int tmp ;

  {
  {
#line 484
  tmp = jfm_setchar_gen(c, & begin_string_v, (int (*)())(& pschar_sjis));
  }
#line 484
  return (tmp);
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setstring_v(char *s , int len ) 
{ 


  {
  {
#line 492
  Fatal("%s implementation error: jfm_setstring_v", G_progname);
  }
#line 493
  return (0);
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int setchar_vabs_gen(int c , int (*setch)() ) 
{ 
  int cw ;

  {
  {
#line 504
  cw = (*setch)(c);
#line 505
  ps_v --;
  }
#line 507
  return (cw);
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setchar_vabs(int c ) 
{ 
  int tmp ;

  {
  {
#line 513
  tmp = setchar_vabs_gen(c, (int (*)())(& jfm_setchar_v));
  }
#line 513
  return (tmp);
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setchar_vabs_euc(int c ) 
{ 
  int tmp ;

  {
  {
#line 519
  tmp = setchar_vabs_gen(c, (int (*)())(& jfm_setchar_v_euc));
  }
#line 519
  return (tmp);
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setchar_vabs_sjis(int c ) 
{ 
  int tmp ;

  {
  {
#line 525
  tmp = setchar_vabs_gen(c, (int (*)())(& jfm_setchar_v_sjis));
  }
#line 525
  return (tmp);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstfm.c"
int jfm_setstring_vabs(char *s , int len ) 
{ 


  {
  {
#line 533
  Fatal("%s implementation error: jfm_setstring_vabs", G_progname);
  }
#line 534
  return (0);
}
}
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int mag  ;
#line 4
int usermag ;
#line 6 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
char *dvi2path  ;
#line 7 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
char *dvi2lib  ;
#line 9 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
char *mfmode  ;
#line 11 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
char dvifilename[1024]  ;
#line 12 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
char dvidirpath[1024]  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
char rootname[1024]  ;
#line 23
int PreLoad ;
#line 25
int G_errenc ;
#line 26 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
char *G_progname  ;
#line 28
int G_nowarn ;
#line 30
int G_t1part ;
#line 34 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int SpecialSize  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
char *SpecialStr  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int Snbpx0  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int Sndc0  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
int Stnc0  ;
#line 79
void init_settings(int argc , char **argv , char *fontdescfile___0 ) ;
#line 81
void AllDone(void) ;
#line 123
char *version ;
#line 45 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
void ReadPreAmble(void) ;
#line 46
void ReadPostAmble(int load , struct font_index **hdfip ) ;
#line 47
void FindPostAmblePtr(long *postambleptr___0 ) ;
#line 48
void GetFontDef(struct font_index **hdfip ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int FirstPage  =    -1000000;
#line 55 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int LastPage  =    1000000;
#line 57 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int den  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int num  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int usermag  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
char *fontdescfile  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int resolution  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
long postambleptr  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
long fpagep  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
FILE *dvifp  =    (FILE *)((void *)0);
#line 76 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
FILE *outfp  =    (FILE *)((void *)0);
#line 78 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int ncopies  =    1;
#line 79 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int ndone  =    0;
#line 82 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int debug  =    0;
#line 84 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int PreLoad  =    1;
#line 85 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int Reverse  =    0;
#line 86 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int G_errenc  =    0;
#line 88 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int G_quiet  =    0;
#line 89 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int G_nowarn  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int G_removecomments  =    0;
#line 91 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int G_t1part  =    1;
#line 98 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int Stats  =    0;
#line 99 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int Snbpxl  =    0;
#line 100 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int Sonbpx  =    0;
#line 101 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int Sndc  =    0;
#line 102 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int Stnc  =    0;
#line 142
int fix_default(int def_resolution , char *def_mfmode ) ;
#line 244
int init_default(char *def_mfmode , char *def_kpse ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
int default_def(void) 
{ 


  {
  {
#line 244
  init_default("canonex", "");
  }
#line 245
  return (0);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
void ReadPreAmble(void) 
{ 


  {
  {
#line 250
  num = getuint(dvifp, 4);
#line 251
  den = getuint(dvifp, 4);
#line 252
  mag = getuint(dvifp, 4);
  }
#line 254
  if (usermag > 0) {
#line 254
    if (usermag != mag) {
      {
#line 255
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DVI magnification of %d over-ridden by user mag of %d\n",
              mag, usermag);
      }
    }
  }
#line 259
  if (usermag > 0) {
#line 260
    mag = usermag;
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
void ReadPostAmble(int load , struct font_index **hdfip ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 277
  FindPostAmblePtr(& postambleptr);
#line 278
  tmp = getuint(dvifp, 1);
  }
#line 278
  if (tmp != 248) {
    {
#line 279
    Fatal("POST missing at head of postamble");
    }
  }
#line 281
  if (debug >= 2) {
    {
#line 282
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"got POST command\n");
    }
  }
  {
#line 284
  tmp___0 = getuint(dvifp, 4);
#line 284
  fpagep = (long )tmp___0;
#line 285
  num = getuint(dvifp, 4);
#line 286
  den = getuint(dvifp, 4);
#line 287
  mag = getuint(dvifp, 4);
  }
#line 289
  if (usermag > 0) {
#line 289
    if (usermag != mag) {
      {
#line 290
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DVI magnification of %d over-ridden by user mag of %d\n",
              mag, usermag);
      }
    }
  }
#line 294
  if (usermag > 0) {
#line 295
    mag = usermag;
  }
  {
#line 301
  skipbytes(dvifp, 4);
#line 302
  skipbytes(dvifp, 4);
#line 303
  tmp___1 = getuint(dvifp, 2);
  }
#line 303
  if (tmp___1 >= 100) {
    {
#line 304
    Fatal("Stack size is too small");
    }
  }
  {
#line 305
  skipbytes(dvifp, 2);
  }
#line 307
  if (debug >= 2) {
    {
#line 308
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"now reading font defs\n");
    }
  }
#line 310
  if (load) {
    {
#line 311
    GetFontDef(hdfip);
    }
  }
#line 312
  return;
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
void FindPostAmblePtr(long *postambleptr___0 ) 
{ 
  int i ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 322
  fseek(dvifp, 0L, 2);
#line 323
  tmp = ftell(dvifp);
#line 323
  *postambleptr___0 = tmp - 4L;
#line 324
  fseek(dvifp, *postambleptr___0, 0);
  }
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    (*postambleptr___0) --;
#line 327
    fseek(dvifp, *postambleptr___0, 0);
#line 328
    i = getuint(dvifp, 1);
    }
#line 328
    if (i != 223) {
#line 328
      if (i != 2) {
#line 328
        if (i != 3) {
          {
#line 330
          Fatal("Bad end of DVI file");
          }
        }
      }
    }
#line 331
    if (i == 2) {
#line 332
      goto while_break;
    } else
#line 331
    if (i == 3) {
#line 332
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 334
  fseek(dvifp, *postambleptr___0 - 4L, 0);
#line 335
  tmp___0 = getuint(dvifp, 4);
#line 335
  *postambleptr___0 = (long )tmp___0;
#line 336
  fseek(dvifp, *postambleptr___0, 0);
  }
#line 337
  return;
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/dvi2.c"
void GetFontDef(struct font_index **hdfip ) 
{ 
  int cmd ;
  int tmp ;

  {
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 356
    cmd = getuint(dvifp, 1);
    }
#line 357
    if (243 <= cmd) {
#line 357
      if (cmd <= 246) {
        {
#line 358
        tmp = getuint(dvifp, (cmd - 243) + 1);
#line 358
        ReadFontDef(tmp, hdfip);
        }
      } else {
#line 357
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 359
    if (! (cmd == 138)) {
#line 361
      if (cmd == 249) {
#line 362
        return;
      } else {
        {
#line 364
        Fatal("POST_POST missing after fontdefs");
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
struct dconv vfd_dconv_templ ;
#line 10 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfdcom.c"
int vfd_getcommand(void) ;
#line 11
void vfd_backupone(void) ;
#line 12
void vfd_getbytes(char *cp , int n ) ;
#line 13
void vfd_skipbytes(int n ) ;
#line 14
int vfd_getuint(int n ) ;
#line 15
int vfd_getint(int n ) ;
#line 16
void vfd_movedown(int a ) ;
#line 17
void vfd_movedown_v(int a ) ;
#line 18
void vfd_moveover(int b ) ;
#line 19
void vfd_moveover_v(int b ) ;
#line 20
void vfd_setrule(int a , int b , BOOLEAN Set ) ;
#line 21
void vfd_setrule_v(int a , int b , BOOLEAN Set ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfdcom.c"
struct dconv vfd_dconv_templ  = 
#line 22
     {& vfd_getcommand, & vfd_backupone, & vfd_getbytes, & vfd_skipbytes, & vfd_getuint,
    & vfd_getint, (FILE *)((void *)0), (byte *)((void *)0), (byte *)((void *)0), & vfd_movedown,
    & vfd_movedown_v, & vfd_moveover, & vfd_moveover_v, & vfd_setrule, & vfd_setrule_v,
    0};
#line 41 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfdcom.c"
int vfd_getcommand(void) 
{ 
  int tmp ;

  {
#line 44
  dc_bufbeg ++;
#line 45
  if ((unsigned long )dc_bufbeg > (unsigned long )dc_bufend) {
#line 45
    tmp = 248;
  } else {
#line 45
    tmp = (int )*(dc_bufbeg - 1);
  }
#line 45
  return (tmp);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfdcom.c"
void vfd_backupone(void) 
{ 


  {
#line 51
  dc_bufbeg --;
#line 52
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfdcom.c"
void vfd_getbytes(char *cp , int n ) 
{ 


  {
  {
#line 59
  strncpy((char */* __restrict  */)cp, (char const   */* __restrict  */)((char *)dc_bufbeg),
          (size_t )n);
#line 60
  dc_bufbeg += n;
  }
#line 61
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfdcom.c"
void vfd_skipbytes(int n ) 
{ 


  {
#line 67
  dc_bufbeg += n;
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfdcom.c"
int vfd_getuint(int n ) 
{ 
  int x ;

  {
  {
#line 76
  x = makeuint(dc_bufbeg, n);
#line 77
  dc_bufbeg += n;
  }
#line 78
  return (x);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfdcom.c"
int vfd_getint(int n ) 
{ 
  int x ;

  {
  {
#line 87
  x = makeint(dc_bufbeg, n);
#line 88
  dc_bufbeg += n;
  }
#line 89
  return (x);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfdcom.c"
void vfd_movedown(int a ) 
{ 


  {
#line 97
  v += (int )(((SCALED )a * (SCALED )dc_scale) / (SCALED )(1 << 20));
#line 98
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfdcom.c"
void vfd_movedown_v(int a ) 
{ 


  {
#line 104
  h -= (int )(((SCALED )a * (SCALED )dc_scale) / (SCALED )(1 << 20));
#line 105
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfdcom.c"
void vfd_moveover(int b ) 
{ 


  {
#line 111
  h += (int )(((SCALED )b * (SCALED )dc_scale) / (SCALED )(1 << 20));
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfdcom.c"
void vfd_moveover_v(int b ) 
{ 


  {
#line 118
  v += (int )(((SCALED )b * (SCALED )dc_scale) / (SCALED )(1 << 20));
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfdcom.c"
void vfd_setrule(int a , int b , BOOLEAN Set ) 
{ 


  {
  {
#line 126
  dfd_setrule((int )(((SCALED )a * (SCALED )dc_scale) / (SCALED )(1 << 20)), (int )(((SCALED )b * (SCALED )dc_scale) / (SCALED )(1 << 20)));
  }
#line 127
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/vfdcom.c"
void vfd_setrule_v(int a , int b , BOOLEAN Set ) 
{ 


  {
  {
#line 134
  dfd_setrule_v((int )(((SCALED )a * (SCALED )dc_scale) / (SCALED )(1 << 20)), (int )(((SCALED )b * (SCALED )dc_scale) / (SCALED )(1 << 20)));
  }
#line 135
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int vftype_access(char *proto , struct font_entry *fe , struct accarg *acca ) ;
#line 17
int jvftype_access(char *proto , struct font_entry *fe , struct accarg *acca ) ;
#line 18
void init_vf_fontinfo(struct font_entry *fe ) ;
#line 19
void init_jvf_fontinfo(struct font_entry *fe ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
struct fontop vfop  =    {(char *)"vf", & pathtype_init, & vftype_access, & init_vf_fontinfo};
#line 26 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
struct fontop jvfop  =    {(char *)"jvf", & pathtype_init, & jvftype_access, & init_jvf_fontinfo};
#line 38
int vfty_acc(char *proto , struct font_entry *fe , struct accarg *acca , char *type ,
             char *suffix ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int vftype_access(char *proto , struct font_entry *fe , struct accarg *acca ) 
{ 
  int tmp ;

  {
  {
#line 38
  tmp = vfty_acc(proto, fe, acca, "vf", (void *)0);
  }
#line 38
  return (tmp);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int jvftype_access(char *proto , struct font_entry *fe , struct accarg *acca ) 
{ 
  int tmp ;

  {
  {
#line 47
  tmp = vfty_acc(proto, fe, acca, "jvf", (void *)0);
  }
#line 47
  return (tmp);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int vfty_acc(char *proto , struct font_entry *fe , struct accarg *acca , char *type ,
             char *suffix ) 
{ 
  BOOLEAN ok ;
  int tmp ;

  {
  {
#line 65
  pave(fe->name, proto, acca);
#line 66
  tmp = access((char const   *)(fe->name), 4);
#line 66
  ok = tmp == 0;
  }
#line 69
  if (debug >= 1) {
    {
#line 70
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trying to access(%s) %s\n",
            type, fe->name);
    }
  }
#line 72
  return (ok);
}
}
#line 79
int vf_markchar(int c ) ;
#line 80
void read_vf_fontinfo(struct font_entry *fe ) ;
#line 82
int read_vf_dviinfo(struct font_entry *fe ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
void init_vf_fontinfo(struct font_entry *fe ) 
{ 


  {
  {
#line 82
  read_vf_dviinfo(fe);
#line 83
  fe->dev_setchar = & vf_markchar;
#line 84
  fe->fnt_readfontinfo = & read_vf_fontinfo;
  }
#line 85
  return;
}
}
#line 91
int jvf_markchar(int c ) ;
#line 92
void read_jvf_fontinfo(struct font_entry *fe ) ;
#line 94
int read_jvf_dviinfo(struct font_entry *fe ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
void init_jvf_fontinfo(struct font_entry *fe ) 
{ 


  {
  {
#line 94
  read_jvf_dviinfo(fe);
#line 95
  fe->dev_setchar = & jvf_markchar;
#line 96
  fe->fnt_readfontinfo = & read_jvf_fontinfo;
  }
#line 97
  return;
}
}
#line 110
int read_vf_di(struct font_entry *fe , int coding ) ;
#line 107 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int read_vf_dviinfo(struct font_entry *fe ) 
{ 


  {
  {
#line 110
  read_vf_di(fe, 0);
  }
#line 111
  return (0);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int read_jvf_dviinfo(struct font_entry *fe ) 
{ 


  {
  {
#line 116
  read_vf_di(fe, 1);
  }
#line 117
  return (0);
}
}
#line 134
struct virfntinfo *alloc_virfinfo(int nchars ) ;
#line 134
struct virfntinfo *realloc_virfinfo(struct virfntinfo *vfi0 , int nchars0 , int nchars ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int read_vf_di(struct font_entry *fe , int coding ) 
{ 
  FILE *fntfp___1 ;
  int cmd ;
  int t ;
  int ds ;
  int k ;
  int c ;
  int s ;
  int d ;
  int a ;
  int l ;
  byte n[257] ;
  int nvfc ;
  int nvfc1 ;
  struct virfntinfo *vfi ;
  struct font_index *fip ;
  struct vfchar_entry *ce ;
  int pl ;
  int cc ;
  int idx ;
  int tfm ;
  int misschar ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;

  {
  {
#line 133
  misschar = 0;
#line 136
  openfontfile(fe);
#line 137
  fntfp___1 = fe->openfile;
#line 138
  tmp = getuint(fntfp___1, 1);
  }
#line 138
  if (tmp != 247) {
    {
#line 139
    Fatal("bad vf file %s\n", fe->name);
    }
  } else {
    {
#line 138
    tmp___0 = getuint(fntfp___1, 1);
    }
#line 138
    if (tmp___0 != 202) {
      {
#line 139
      Fatal("bad vf file %s\n", fe->name);
      }
    }
  }
  {
#line 140
  tmp___1 = getuint(fntfp___1, 1);
#line 140
  fseek(fntfp___1, (long )tmp___1, 1);
#line 141
  t = getuint(fntfp___1, 4);
  }
#line 141
  if (t) {
#line 141
    if (fe->c) {
#line 141
      if (t != fe->c) {
        {
#line 142
        Warning("font = \"%s\",\n-->font checksum = %d,\n-->dvi checksum = %d", fe->name,
                fe->c, t);
        }
      }
    }
  }
  {
#line 144
  ds = getuint(fntfp___1, 4);
#line 145
  nvfc = 256;
  }
#line 146
  if (coding == 0) {
#line 146
    tmp___2 = 256;
  } else {
#line 146
    tmp___2 = 8837;
  }
  {
#line 146
  vfi = alloc_virfinfo(tmp___2);
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 148
    cmd = getuint(fntfp___1, 1);
    }
#line 148
    if (cmd >= 243) {
#line 148
      if (! (cmd <= 246)) {
#line 148
        goto while_break;
      }
    } else {
#line 148
      goto while_break;
    }
    {
#line 149
    k = getuint(fntfp___1, (cmd - 243) + 1);
#line 150
    c = getuint(fntfp___1, 4);
#line 151
    tmp___3 = getuint(fntfp___1, 4);
#line 151
    s = (int )(((SCALED )fe->s * (SCALED )tmp___3) / (SCALED )(1 << 20));
#line 152
    tmp___4 = getuint(fntfp___1, 4);
#line 152
    d = tmp___4 >> 4;
#line 153
    a = getuint(fntfp___1, 1);
#line 154
    l = getuint(fntfp___1, 1);
#line 155
    getbytes(fntfp___1, n, a + l);
#line 156
    n[a + l] = (byte )'\000';
#line 157
    readfontdef(k, c, s, d, a, l, (char *)(n), & vfi->vf_fontidx);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )vfi->vf_fontidx == (unsigned long )((void *)0)) {
#line 161
    vfi->vf_default_fent = (struct font_entry *)((void *)0);
  } else {
#line 163
    fip = vfi->vf_fontidx;
    {
#line 163
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 163
      if (! ((unsigned long )fip->next != (unsigned long )((void *)0))) {
#line 163
        goto while_break___0;
      }
#line 163
      fip = fip->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 166
    vfi->vf_default_fent = fip->fent;
  }
  {
#line 169
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 170
    if (cmd <= 242) {
#line 171
      if (cmd == 242) {
        {
#line 172
        pl = getuint(fntfp___1, 4);
#line 173
        cc = getuint(fntfp___1, 4);
#line 174
        tfm = getuint(fntfp___1, 4);
        }
      } else {
        {
#line 176
        pl = cmd;
#line 177
        cc = getuint(fntfp___1, 1);
#line 178
        tfm = getuint(fntfp___1, 3);
        }
      }
#line 180
      if (coding == 0) {
#line 181
        if (cc >= nvfc) {
          {
#line 182
          nvfc1 = cc + 24064;
#line 183
          vfi = realloc_virfinfo(vfi, nvfc, nvfc1);
#line 184
          nvfc = nvfc1;
          }
        }
#line 186
        ce = & vfi->ch[cc];
      } else
#line 188
      if (cc == 0) {
#line 189
        ce = & vfi->ch[8836];
      } else {
        {
#line 190
        idx = jis_to_idx94(cc);
        }
#line 190
        if (idx < 0) {
#line 191
          misschar ++;
#line 193
          if (debug >= 2) {
            {
#line 194
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cc 0x%x in (j)vf file %s (skipped)\n",
                    cc, fe->name);
            }
          }
          {
#line 198
          fseek(fntfp___1, (long )pl, 1);
          }
#line 199
          goto __Cont;
        } else {
#line 201
          ce = & vfi->ch[idx];
        }
      }
#line 203
      ce->tfmw = (int )(((SCALED )tfm * (SCALED )fe->s) / (SCALED )(1 << 20));
#line 204
      if (pl == 0) {
#line 205
        ce->vfdstat = (char)2;
      } else {
        {
#line 207
        ce->vfdstat = (char)1;
#line 208
        ce->vfd.dvi.dvilen = (unsigned int )pl;
#line 209
        tmp___5 = ftell(fntfp___1);
#line 209
        ce->vfd.dvi.where.fileoffset = (unsigned int )tmp___5;
#line 210
        fseek(fntfp___1, (long )pl, 1);
        }
      }
    } else
#line 212
    if (cmd == 248) {
#line 213
      goto while_break___1;
    } else {
      {
#line 215
      Fatal("illegal vf command %d in %s\n", cmd, fe->name);
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 169
    cmd = getuint(fntfp___1, 1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 217
  if (misschar > 0) {
    {
#line 218
    Warning("char(s) in vf file %s skipped", fe->name);
#line 219
    Warning("\t\"font jvf\" may be the mistake of \"font vf\"");
    }
  }
#line 221
  *((struct virfntinfo **)(& fe->finfo)) = vfi;
#line 222
  return (0);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
struct virfntinfo *alloc_virfinfo(int nchars ) 
{ 
  struct virfntinfo *vfi ;
  struct vfchar_entry *ce ;
  int i ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 232
  tmp = malloc((unsigned long )((unsigned int )sizeof(struct virfntinfo )) + (unsigned long )(nchars - 1) * sizeof(struct vfchar_entry ));
#line 232
  tmp___0 = alloc_check(tmp, "virfont info");
#line 232
  vfi = (struct virfntinfo *)tmp___0;
#line 236
  vfi->vf_fontidx = (struct font_index *)((void *)0);
#line 237
  i = 0;
  }
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! (i < nchars)) {
#line 237
      goto while_break;
    }
#line 238
    ce = & vfi->ch[i];
#line 239
    ce->vfdstat = (char)0;
#line 240
    ce->tfmw = 0;
#line 237
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return (vfi);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
struct virfntinfo *realloc_virfinfo(struct virfntinfo *vfi0 , int nchars0 , int nchars ) 
{ 
  struct virfntinfo *vfi ;
  struct vfchar_entry *ce ;
  int i ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 254
  tmp = realloc((void *)vfi0, (unsigned long )((unsigned int )sizeof(struct virfntinfo )) + (unsigned long )(nchars - 1) * sizeof(struct vfchar_entry ));
#line 254
  tmp___0 = alloc_check(tmp, "virfont info");
#line 254
  vfi = (struct virfntinfo *)tmp___0;
#line 259
  i = nchars0;
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! (i < nchars)) {
#line 259
      goto while_break;
    }
#line 260
    ce = & vfi->ch[i];
#line 261
    ce->vfdstat = (char)0;
#line 262
    ce->tfmw = 0;
#line 259
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  return (vfi);
}
}
#line 270
int vf_mc(struct font_entry *fe , struct vfchar_entry *ce , int c ) ;
#line 267 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int vf_markchar(int c ) 
{ 


  {
  {
#line 270
  vf_mc(curfontent, & (*((struct virfntinfo **)(& curfontent->finfo)))->ch[c], c);
  }
#line 271
  return (0);
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int jvf_markchar(int c ) 
{ 
  int idx ;

  {
  {
#line 278
  idx = jis_to_idx94(c);
  }
#line 278
  if (idx < 0) {
#line 280
    if (debug >= 1) {
      {
#line 281
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"char 0x%x (font %s) invalid\n",
              c, curfontent->n);
      }
    }
  } else {
    {
#line 285
    vf_mc(curfontent, & (*((struct virfntinfo **)(& curfontent->finfo)))->ch[idx],
          c);
    }
  }
#line 286
  return (0);
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
byte *getvfdvi(struct font_entry *fe , struct vfchar_entry *ce ) 
{ 
  int dvilen ;
  byte *dvip ;
  FILE *fntfp___1 ;
  void *tmp ;

  {
  {
#line 297
  openfontfile(fe);
#line 298
  fntfp___1 = fe->openfile;
#line 299
  fseek(fntfp___1, (long )ce->vfd.dvi.where.fileoffset, 0);
#line 300
  dvilen = (int )ce->vfd.dvi.dvilen;
#line 301
  tmp = malloc((size_t )((unsigned int )dvilen));
#line 301
  dvip = (byte *)tmp;
  }
#line 301
  if ((unsigned long )dvip == (unsigned long )((void *)0)) {
    {
#line 302
    Fatal("Unable to allocate memory for vf char\n");
    }
  }
  {
#line 303
  fread((void */* __restrict  */)((char *)dvip), (size_t )1, (size_t )dvilen, (FILE */* __restrict  */)fntfp___1);
  }
#line 304
  return (dvip);
}
}
#line 355
int setc_com(byte cmd , byte *dvip , int dvilen , struct vfchar_entry *ce ) ;
#line 307 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int vf_mc(struct font_entry *fe , struct vfchar_entry *ce , int c ) 
{ 
  int cmd ;
  int dvilen ;
  int k ;
  struct vfchar_entry *defce ;
  byte *dvip ;
  byte *dp ;
  struct font_index *fi ;
  struct dconv save_curdconv ;
  struct dconv *save_curdconvp ;
  struct font_entry *save_curfontent ;
  unsigned int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 319
  if ((int )ce->vfdstat >= 2) {
#line 320
    return;
  }
#line 321
  if ((int )ce->vfdstat == 0) {
#line 322
    defce = & (*((struct virfntinfo **)(& fe->finfo)))->ch[8836];
#line 322
    if ((int )defce->vfdstat == 0) {
      {
#line 323
      Fatal("char %d in vf file %s is not defined", c, fe->n);
      }
    }
#line 324
    if ((int )defce->vfdstat == 1) {
      {
#line 325
      defce->vfd.dvi.where.dviptr = getvfdvi(fe, defce);
#line 326
      defce->vfdstat = (char)2;
      }
    }
    {
#line 328
    tmp = defce->vfd.dvi.dvilen;
#line 328
    ce->vfd.dvi.dvilen = tmp;
#line 328
    dvilen = (int )tmp;
#line 329
    tmp___0 = malloc((size_t )((unsigned int )dvilen));
#line 329
    dvip = (byte *)tmp___0;
    }
#line 329
    if ((unsigned long )dvip == (unsigned long )((void *)0)) {
      {
#line 330
      Fatal("Unable to allocate memory for vf char\n");
      }
    }
    {
#line 333
    memcpy((void */* __restrict  */)dvip, (void const   */* __restrict  */)defce->vfd.dvi.where.dviptr,
           (size_t )dvilen);
#line 334
    *((dvip + dvilen) - 2) = (byte )(c >> 8);
#line 335
    *((dvip + dvilen) - 1) = (byte )(c & 255);
#line 336
    ce->tfmw = defce->tfmw;
    }
  } else {
    {
#line 338
    dvip = getvfdvi(fe, ce);
#line 339
    dvilen = (int )ce->vfd.dvi.dvilen;
    }
  }
  {
#line 343
  ce->vfdstat = (char)4;
#line 344
  cmd = (int )*dvip;
#line 344
  tmp___3 = setc_com(cmd, dvip, dvilen, ce);
  }
#line 344
  if (tmp___3) {
#line 345
    ce->vfdstat = (char)3;
#line 346
    ce->vfd.set.f = (*((struct virfntinfo **)(& fe->finfo)))->vf_default_fent;
  } else
#line 347
  if (171 <= cmd) {
#line 347
    if (cmd <= 238) {
#line 348
      if (cmd <= 234) {
#line 349
        dvilen --;
#line 350
        dp = dvip + 1;
      } else {
#line 352
        dvilen -= (cmd - 235) + 2;
#line 353
        dp = ((dvip + cmd) - 235) + 2;
      }
      {
#line 355
      tmp___2 = setc_com((int )*dp, dp, dvilen, ce);
      }
#line 355
      if (tmp___2) {
#line 356
        ce->vfdstat = (char)3;
#line 357
        if (cmd <= 234) {
#line 357
          k = cmd - 171;
        } else {
          {
#line 357
          tmp___1 = makeuint(dvip + 1, (cmd - 235) + 1);
#line 357
          k = tmp___1;
          }
        }
#line 359
        fi = (*((struct virfntinfo **)(& fe->finfo)))->vf_fontidx;
        {
#line 359
        while (1) {
          while_continue: /* CIL Label */ ;
#line 359
          if ((unsigned long )fi != (unsigned long )((void *)0)) {
#line 359
            if (! (fi->k != k)) {
#line 359
              goto while_break;
            }
          } else {
#line 359
            goto while_break;
          }
#line 359
          fi = fi->next;
        }
        while_break: /* CIL Label */ ;
        }
#line 362
        ce->vfd.set.f = fi->fent;
      }
    }
  }
#line 366
  if ((int )ce->vfdstat == 3) {
    {
#line 367
    save_curfontent = curfontent;
#line 368
    curfontent = ce->vfd.set.f;
#line 369
    MarkChar(ce->vfd.set.c);
#line 370
    curfontent = save_curfontent;
#line 371
    free((void *)((char *)dvip));
    }
#line 372
    return;
  }
  {
#line 374
  ce->vfd.dvi.where.dviptr = dvip;
#line 377
  save_curdconvp = curdconvp;
#line 378
  curdconvp->dc_bufbeg = dc_bufbeg;
#line 379
  save_curdconv = *curdconvp;
#line 380
  vfd_dconv_templ.dc_bufbeg = dvip;
#line 381
  vfd_dconv_templ.dc_bufend = dvip + ce->vfd.dvi.dvilen;
#line 383
  setcurdconv(& vfd_dconv_templ);
#line 384
  save_curfontent = curfontent;
#line 385
  curfontent = (*((struct virfntinfo **)(& fe->finfo)))->vf_default_fent;
#line 387
  scanfont(1, & (*((struct virfntinfo **)(& fe->finfo)))->vf_fontidx);
#line 390
  *save_curdconvp = save_curdconv;
#line 391
  setcurdconv(save_curdconvp);
#line 392
  curfontent = save_curfontent;
  }
#line 393
  return (0);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int setc_com(byte cmd , byte *dvip , int dvilen , struct vfchar_entry *ce ) 
{ 


  {
#line 401
  if ((int )cmd <= 127) {
#line 401
    if (dvilen <= 1) {
#line 402
      ce->vfd.set.c = (int )cmd;
#line 403
      return (1);
    } else {
#line 401
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 404
  if (128 <= (int )cmd) {
#line 404
    if ((int )cmd <= 131) {
#line 404
      if (dvilen == ((int )cmd - 128) + 2) {
        {
#line 405
        ce->vfd.set.c = makeuint(dvip + 1, dvilen - 1);
        }
#line 406
        return (1);
      }
    }
  }
#line 408
  return (0);
}
}
#line 415
DEV_FONT vf_fontdict(struct font_entry *fe , int c ) ;
#line 416
int vf_setchar(int c ) ;
#line 416
int vf_setstring(unsigned char *s , int len ) ;
#line 411 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
void read_vf_fontinfo(struct font_entry *fe ) 
{ 


  {
#line 418
  fe->rvf_setchar = & virf_setchar;
#line 419
  fe->rvf_setstring = & virf_setstring;
#line 420
  fe->dev_fontdict = & vf_fontdict;
#line 421
  fe->dev_setchar = & vf_setchar;
#line 422
  fe->dev_setstring = & vf_setstring;
#line 423
  return;
}
}
#line 430
int jvf_setchar(int c ) ;
#line 430
int jvf_setstring(unsigned char *s , int len ) ;
#line 425 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
void read_jvf_fontinfo(struct font_entry *fe ) 
{ 


  {
#line 432
  fe->rvf_setchar = & virf_setchar;
#line 433
  fe->rvf_setstring = & virf_setstring;
#line 434
  fe->dev_fontdict = & vf_fontdict;
#line 435
  fe->dev_setchar = & jvf_setchar;
#line 436
  fe->dev_setstring = & jvf_setstring;
#line 437
  return;
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
DEV_FONT vf_fontdict(struct font_entry *fe , int c ) 
{ 


  {
  {
#line 445
  Fatal("%s implementation error: vf_fontdict", G_progname);
  }
#line 446
  return (0);
}
}
#line 451
int vf_sc(struct font_entry *fe , struct vfchar_entry *ce , int c ) ;
#line 448 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int vf_setchar(int c ) 
{ 
  int tmp ;

  {
  {
#line 451
  tmp = vf_sc(curfontent, & (*((struct virfntinfo **)(& curfontent->finfo)))->ch[c],
              c);
  }
#line 451
  return (tmp);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int jvf_setchar(int c ) 
{ 
  int idx ;
  int tmp ;

  {
  {
#line 459
  idx = jis_to_idx94(c);
  }
#line 459
  if (idx < 0) {
#line 460
    return (0);
  } else {
    {
#line 462
    tmp = vf_sc(curfontent, & (*((struct virfntinfo **)(& curfontent->finfo)))->ch[idx],
                c);
    }
#line 462
    return (tmp);
  }
}
}
#line 466 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int vf_sc(struct font_entry *fe , struct vfchar_entry *ce , int c ) 
{ 
  struct dconv save_curdconv ;
  struct dconv *save_curdconvp ;
  struct font_entry *save_curfontent ;
  int save_h ;
  int save_v ;
  int save_dir ;
  BOOLEAN save_chmove ;

  {
#line 476
  if ((int )ce->vfdstat == 3) {
    {
#line 477
    save_curfontent = curfontent;
#line 478
    curfontent = ce->vfd.set.f;
#line 479
    save_chmove = chmove;
#line 480
    (*(curfontent->rvf_setchar))(ce->vfd.set.c, 0);
#line 481
    curfontent = save_curfontent;
#line 482
    chmove = save_chmove;
    }
#line 483
    return (ce->tfmw);
  }
#line 486
  if ((int )ce->vfdstat == 2) {
#line 487
    return (ce->tfmw);
  }
  {
#line 490
  save_curdconvp = curdconvp;
#line 491
  curdconvp->dc_bufbeg = dc_bufbeg;
#line 492
  save_curdconv = *curdconvp;
#line 493
  vfd_dconv_templ.dc_bufbeg = ce->vfd.dvi.where.dviptr;
#line 494
  vfd_dconv_templ.dc_bufend = ce->vfd.dvi.where.dviptr + ce->vfd.dvi.dvilen;
#line 495
  vfd_dconv_templ.dc_scale = fe->s;
#line 496
  setcurdconv(& vfd_dconv_templ);
#line 497
  save_curfontent = curfontent;
#line 498
  curfontent = (*((struct virfntinfo **)(& fe->finfo)))->vf_default_fent;
#line 499
  save_h = h;
#line 500
  save_v = v;
#line 501
  save_dir = dir;
#line 502
  save_chmove = chmove;
#line 504
  dviconv((*((struct virfntinfo **)(& fe->finfo)))->vf_fontidx);
#line 507
  *save_curdconvp = save_curdconv;
#line 508
  setcurdconv(save_curdconvp);
#line 509
  curfontent = save_curfontent;
#line 510
  h = save_h;
#line 511
  v = save_v;
#line 512
  setdir(save_dir);
#line 513
  chmove = save_chmove;
  }
#line 515
  return (ce->tfmw);
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int vf_setstring(unsigned char *s , int len ) 
{ 
  unsigned char *sp ;
  int w ;

  {
#line 526
  sp = s;
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 526
    if (! ((unsigned long )sp < (unsigned long )(s + len))) {
#line 526
      goto while_break;
    }
    {
#line 527
    w = vf_setchar((int )*sp);
#line 528
    *move += w;
#line 526
    sp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  return (0);
}
}
#line 533 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/virfont.c"
int jvf_setstring(unsigned char *s , int len ) 
{ 
  unsigned char *sp ;
  int w ;

  {
#line 541
  sp = s;
  {
#line 541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 541
    if (! ((unsigned long )sp < (unsigned long )(s + len))) {
#line 541
      goto while_break;
    }
    {
#line 542
    w = jvf_setchar((int )*sp);
#line 543
    *move += w;
#line 541
    sp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 545
  return (0);
}
}
#line 702 "/usr/include/stdio.h"
extern int ungetc(int __c , FILE *__stream ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
void read_fontdesc(char *fdn , BOOLEAN top ) ;
#line 95
void skipblanks(void) ;
#line 98
void arg_fontdesc(char *fdn ) ;
#line 100
void add_include(char *f , BOOLEAN top ) ;
#line 101
void add_setup(char *f , BOOLEAN top ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct fontop gfop ;
#line 16 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct fontop *fontops[12]  = 
#line 16
  {      & pkop,      & gfop,      & vfop,      & jvfop, 
        & tfmop,      & jstfmop,      & jfmop,      & cmpop, 
        & dcmpop,      & execop,      & funcop,      (struct fontop *)((void *)0)};
#line 31
struct confop fdcop ;
#line 31
struct confop fontcop ;
#line 31
struct confop defcop ;
#line 31
struct confop mapcop ;
#line 31
struct confop bicop ;
#line 31
struct confop bfcop ;
#line 31
struct confop bkcop ;
#line 31
struct confop resolutioncop ;
#line 31
struct confop includecop ;
#line 31
struct confop includeifcop ;
#line 31
struct confop setupcop ;
#line 31
struct confop setupifcop ;
#line 31
struct confop cconvcop ;
#line 31
struct confop substcop ;
#line 31
struct confop replfcop ;
#line 51 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct confop *confops[20]  = 
#line 51
  {      & fdcop,      & fontcop,      & defcop,      & pdcop, 
        & ddcop,      & mapcop,      & bicop,      & bfcop, 
        & bkcop,      & vfccop,      & vfbcop,      & resolutioncop, 
        & includecop,      & includeifcop,      & setupcop,      & setupifcop, 
        & cconvcop,      & substcop,      & replfcop,      (struct confop *)((void *)0)};
#line 78 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static struct fdin fdin  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static struct libdir libdir  =    {(char *)"", (char *)"", (char *)""};
#line 100 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static void setlibdir(struct libdir_body *nld ) 
{ 


  {
#line 104
  libdir.dir = nld->dir;
#line 105
  libdir.lcldir = nld->lcldir;
#line 106
  libdir.defpath = nld->defpath;
#line 107
  return;
}
}
#line 120
struct confop *findconfop(char *field ) ;
#line 122
int searchfile(char *f , char *newf , struct libdir_body *nld , BOOLEAN top , char *ext ) ;
#line 109 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void read_fontdesc(char *fdn , BOOLEAN top ) 
{ 
  char fdfile[1024] ;
  FILE *f ;
  char field[257] ;
  struct libdir_body newlibdir ;
  struct fdin save_fdin ;
  struct libdir save_libdir ;
  int tmp ;
  struct confop *tmp___0 ;

  {
  {
#line 122
  tmp = searchfile(fdn, fdfile, & newlibdir, top, (char *)((void *)0));
  }
#line 122
  if (tmp) {
#line 124
    if (debug >= 1) {
      {
#line 125
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"open fontdesc \"%s\"\n",
              fdfile);
#line 126
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    in [%s]+[%s]:[%s]\n",
              newlibdir.dir, newlibdir.lcldir, newlibdir.defpath);
      }
    }
    {
#line 130
    f = fopen((char const   */* __restrict  */)(fdfile), (char const   */* __restrict  */)"r");
    }
  } else {
    {
#line 132
    Fatal("cannot open fontdesc file \"%s\"", fdn);
    }
  }
  {
#line 133
  save_fdin = fdin;
#line 134
  save_libdir = libdir;
#line 135
  fdin.name = fdfile;
#line 136
  fdin.file = f;
#line 137
  setlibdir(& newlibdir);
#line 138
  fdin.line = 1;
  }
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 138
    fdin.ch = _IO_getc(fdin.file);
    }
#line 138
    if (! (fdin.ch != -1)) {
#line 138
      goto while_break;
    }
#line 139
    if (fdin.ch == 35) {
      {
#line 140
      skipline();
      }
#line 141
      goto __Cont;
    } else
#line 139
    if (fdin.ch == 10) {
      {
#line 140
      skipline();
      }
#line 141
      goto __Cont;
    }
    {
#line 143
    getfield(field);
#line 144
    tmp___0 = findconfop(field);
#line 144
    (*(tmp___0->co_get))();
    }
    __Cont: /* CIL Label */ 
#line 138
    (fdin.line) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  fclose(fdin.file);
#line 147
  fdin = save_fdin;
#line 148
  libdir = save_libdir;
  }
#line 149
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static int findsearchfile(char *newf , char *newlcd , char *ld , char *lcd , char *f ,
                          char *ext ) 
{ 
  char *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 160
  strcpy((char */* __restrict  */)newlcd, (char const   */* __restrict  */)lcd);
#line 161
  strcat((char */* __restrict  */)newlcd, (char const   */* __restrict  */)f);
#line 162
  strcpy((char */* __restrict  */)newf, (char const   */* __restrict  */)ld);
#line 163
  strcat((char */* __restrict  */)newf, (char const   */* __restrict  */)newlcd);
#line 164
  tmp___0 = access((char const   *)newf, 4);
  }
#line 164
  if (tmp___0 != 0) {
#line 165
    if ((unsigned long )ext != (unsigned long )((void *)0)) {
      {
#line 166
      strcat((char */* __restrict  */)newf, (char const   */* __restrict  */)ext);
#line 167
      tmp = access((char const   *)newf, 4);
      }
#line 167
      if (tmp != 0) {
#line 168
        return (0);
      }
    } else {
#line 170
      return (0);
    }
  }
  {
#line 172
  p = strrchr((char const   *)newlcd, '/');
  }
#line 172
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 173
    *(p + 1) = (char )'\000';
  } else {
#line 175
    *newlcd = (char )'\000';
  }
#line 176
  return (1);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static int pathsearchfile(char **nextpath , char *path , char *newf , char *newlcd ,
                          char *newld , char *lcd , char *f , char *ext ) 
{ 
  char *p ;
  char *d ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! ((int )*path != 0)) {
#line 189
      goto while_break;
    }
    {
#line 190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 190
      if (! ((int )*path == 58)) {
#line 190
        goto while_break___0;
      }
#line 190
      path ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 192
    p = path;
#line 192
    d = newld;
    {
#line 192
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 192
      if ((int )*p != 58) {
#line 192
        if (! ((int )*p != 0)) {
#line 192
          goto while_break___1;
        }
      } else {
#line 192
        goto while_break___1;
      }
#line 193
      tmp = d;
#line 193
      d ++;
#line 193
      tmp___0 = p;
#line 193
      p ++;
#line 193
      *tmp = *tmp___0;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 194
    if ((unsigned long )d == (unsigned long )newld) {
#line 195
      goto __Cont;
    }
#line 196
    if ((int )*(d - 1) != 47) {
#line 197
      tmp___1 = d;
#line 197
      d ++;
#line 197
      *tmp___1 = (char )'/';
    }
    {
#line 198
    *d = (char )'\000';
#line 199
    tmp___2 = findsearchfile(newf, newlcd, newld, lcd, f, ext);
    }
#line 199
    if (tmp___2) {
#line 200
      *nextpath = p;
#line 201
      return (1);
    }
#line 203
    if ((int )*p == 0) {
#line 204
      goto while_break;
    }
#line 205
    path = p + 1;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return (0);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int searchfile(char *f , char *newf , struct libdir_body *nld , BOOLEAN top , char *ext ) 
{ 
  char *dfp ;
  char *lcd ;
  char *next ;
  char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 219
  if (debug >= 1) {
    {
#line 220
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"search file \"%s\" in [%s]+[%s]\n",
            f, libdir.dir, libdir.lcldir);
    }
  }
  {
#line 223
  tmp___5 = strncmp((char const   *)f, "//", (size_t )2);
  }
#line 223
  if (tmp___5 == 0) {
#line 224
    f += 2;
#line 225
    lcd = (char *)"";
#line 226
    if (top) {
#line 226
      dfp = dvi2lib;
    } else {
#line 226
      dfp = libdir.defpath;
    }
  } else
#line 227
  if ((int )*f == 47) {
    {
#line 232
    p = strrchr((char const   *)f, '/');
#line 237
    strncpy((char */* __restrict  */)(nld->dir), (char const   */* __restrict  */)f,
            (size_t )((p + 1) - f));
#line 238
    nld->dir[(p + 1) - f] = (char )'\000';
#line 239
    nld->defpath = dvi2lib;
#line 240
    tmp = findsearchfile(newf, nld->lcldir, nld->dir, (char *)"", p + 1, ext);
    }
#line 240
    return (tmp);
  } else
#line 241
  if (top) {
    {
#line 242
    nld->defpath = dvi2lib;
#line 243
    tmp___1 = strncmp((char const   *)f, "./", (size_t )2);
    }
#line 243
    if (tmp___1 == 0) {
      {
#line 244
      p = strrchr((char const   *)f, '/');
#line 245
      strncpy((char */* __restrict  */)(nld->dir), (char const   */* __restrict  */)f,
              (size_t )((p + 1) - f));
#line 246
      nld->dir[(p + 1) - f] = (char )'\000';
#line 247
      tmp___0 = findsearchfile(newf, nld->lcldir, nld->dir, (char *)"", p + 1, ext);
      }
#line 247
      return (tmp___0);
    } else {
      {
#line 243
      tmp___2 = strncmp((char const   *)f, "../", (size_t )3);
      }
#line 243
      if (tmp___2 == 0) {
        {
#line 244
        p = strrchr((char const   *)f, '/');
#line 245
        strncpy((char */* __restrict  */)(nld->dir), (char const   */* __restrict  */)f,
                (size_t )((p + 1) - f));
#line 246
        nld->dir[(p + 1) - f] = (char )'\000';
#line 247
        tmp___0 = findsearchfile(newf, nld->lcldir, nld->dir, (char *)"", p + 1, ext);
        }
#line 247
        return (tmp___0);
      }
    }
    {
#line 249
    tmp___3 = pathsearchfile(& next, dvi2path, newf, nld->lcldir, nld->dir, (char *)"",
                             f, ext);
    }
#line 249
    if (tmp___3) {
#line 251
      return (1);
    }
#line 252
    lcd = (char *)"";
#line 253
    dfp = dvi2lib;
  } else {
    {
#line 255
    tmp___4 = findsearchfile(newf, nld->lcldir, libdir.dir, libdir.lcldir, f, ext);
    }
#line 255
    if (tmp___4) {
      {
#line 257
      strcpy((char */* __restrict  */)(nld->dir), (char const   */* __restrict  */)libdir.dir);
#line 258
      nld->defpath = libdir.defpath;
      }
#line 259
      return (1);
    }
#line 261
    lcd = libdir.lcldir;
#line 262
    dfp = libdir.defpath;
  }
#line 266
  if (debug >= 1) {
    {
#line 267
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"search file \"%s\" in lib [%s]+[%s]\n",
            f, dfp, lcd);
    }
  }
  {
#line 270
  tmp___6 = pathsearchfile(& next, dfp, newf, nld->lcldir, nld->dir, lcd, f, ext);
  }
#line 270
  if (tmp___6) {
#line 271
    nld->defpath = next;
#line 272
    return (1);
  }
#line 274
  return (0);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int searchfiledir(char *f , struct libdir_body *ld , char *newf ) 
{ 
  struct libdir_body newlibdir ;
  struct libdir save_libdir ;
  int found ;

  {
  {
#line 286
  save_libdir = libdir;
#line 287
  setlibdir(ld);
#line 288
  found = searchfile(f, newf, & newlibdir, 0, (char *)((void *)0));
#line 289
  libdir = save_libdir;
  }
#line 290
  return (found);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void skipline(void) 
{ 


  {
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (fdin.ch != 10) {
#line 296
      if (! (fdin.ch != -1)) {
#line 296
        goto while_break;
      }
    } else {
#line 296
      goto while_break;
    }
    {
#line 296
    fdin.ch = _IO_getc(fdin.file);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  return;
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void skipblanks0(void) 
{ 
  int c ;

  {
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (fdin.ch == 32)) {
#line 305
      if (! (fdin.ch == 9)) {
#line 305
        if (! (fdin.ch == 92)) {
#line 305
          goto while_break;
        }
      }
    }
#line 306
    if (fdin.ch == 92) {
      {
#line 307
      c = _IO_getc(fdin.file);
      }
#line 307
      if (c != 10) {
        {
#line 308
        ungetc(c, fdin.file);
        }
#line 309
        goto while_break;
      }
    }
    {
#line 305
    fdin.ch = _IO_getc(fdin.file);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return;
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void skipblanks(void) 
{ 


  {
  {
#line 316
  skipblanks0();
  }
#line 317
  if (fdin.ch == 10) {
    {
#line 318
    Fatal("fontdesc: %s illegal line %d", fdin.name, fdin.line);
    }
  }
#line 319
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int getfield(char *field ) 
{ 
  char *fend ;
  int c ;
  char *tmp ;

  {
  {
#line 327
  skipblanks();
#line 328
  fend = (field + 257) - 1;
  }
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (fdin.ch != 32) {
#line 328
      if (fdin.ch != 9) {
#line 328
        if (fdin.ch != 10) {
#line 328
          if (! (fdin.ch != -1)) {
#line 328
            goto while_break;
          }
        } else {
#line 328
          goto while_break;
        }
      } else {
#line 328
        goto while_break;
      }
    } else {
#line 328
      goto while_break;
    }
#line 331
    if (fdin.ch == 92) {
      {
#line 332
      c = _IO_getc(fdin.file);
      }
#line 332
      if (c != 10) {
        {
#line 333
        ungetc(c, fdin.file);
        }
      } else {
#line 335
        fdin.ch = ' ';
#line 336
        goto while_break;
      }
    }
#line 338
    if ((unsigned long )field < (unsigned long )fend) {
#line 339
      tmp = field;
#line 339
      field ++;
#line 339
      *tmp = (char )fdin.ch;
    } else {
      {
#line 341
      Fatal("fontdesc: field too long (%s line %d)", fdin.name, fdin.line);
      }
    }
    {
#line 328
    fdin.ch = _IO_getc(fdin.file);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  *field = (char )'\000';
#line 344
  return (0);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int getqfield0(char *field ) 
{ 
  char *fend ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;

  {
#line 352
  if (fdin.ch == 34) {
#line 353
    tmp = field;
#line 353
    field ++;
#line 353
    *tmp = (char )fdin.ch;
#line 354
    fend = (field + 257) - 1;
    {
#line 354
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 354
      tmp___1 = field;
#line 354
      field ++;
#line 354
      fdin.ch = _IO_getc(fdin.file);
#line 354
      tmp___2 = (char )fdin.ch;
#line 354
      *tmp___1 = tmp___2;
      }
#line 354
      if ((int )tmp___2 != 34) {
#line 354
        if (! (fdin.ch != -1)) {
#line 354
          goto while_break;
        }
      } else {
#line 354
        goto while_break;
      }
#line 356
      if (fdin.ch == 92) {
        {
#line 357
        tmp___0 = _IO_getc(fdin.file);
#line 357
        *(field - 1) = (char )tmp___0;
        }
      }
#line 358
      if ((unsigned long )field >= (unsigned long )fend) {
        {
#line 359
        Fatal("fontdesc: field too long (%s line %d)", fdin.name, fdin.line);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 361
    if (fdin.ch == -1) {
      {
#line 362
      Fatal("fontdesc: %c not closed (%s line %d)", '\"', fdin.name, fdin.line);
      }
    }
    {
#line 364
    *field = (char )'\000';
#line 365
    fdin.ch = _IO_getc(fdin.file);
    }
  } else {
    {
#line 367
    getfield(field);
    }
  }
#line 368
  return (0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int getqfield(char *field ) 
{ 


  {
  {
#line 373
  skipblanks();
#line 374
  getqfield0(field);
  }
#line 375
  return (0);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int getoqfield(char *field ) 
{ 


  {
  {
#line 380
  skipblanks0();
  }
#line 381
  if (fdin.ch != 10) {
    {
#line 382
    getqfield0(field);
    }
  } else {
#line 384
    *field = (char )'\000';
  }
#line 385
  return (0);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int getlfield(char *field ) 
{ 
  char *fend ;
  int c ;
  char *tmp ;

  {
  {
#line 393
  skipblanks();
#line 394
  fend = (field + 257) - 1;
  }
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (fdin.ch != 10) {
#line 394
      if (! (fdin.ch != -1)) {
#line 394
        goto while_break;
      }
    } else {
#line 394
      goto while_break;
    }
#line 396
    if (fdin.ch == 92) {
      {
#line 397
      c = _IO_getc(fdin.file);
      }
#line 397
      if (c != 10) {
        {
#line 398
        ungetc(c, fdin.file);
        }
      } else {
#line 400
        fdin.ch = ' ';
      }
    }
#line 402
    if ((unsigned long )field < (unsigned long )fend) {
#line 403
      tmp = field;
#line 403
      field ++;
#line 403
      *tmp = (char )fdin.ch;
    } else {
      {
#line 405
      Fatal("fontdesc: field too long (%s line %d)", fdin.name, fdin.line);
      }
    }
    {
#line 394
    fdin.ch = _IO_getc(fdin.file);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 407
  *field = (char )'\000';
#line 408
  return (0);
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct confop skipcop  =    {(char *)"", & skipline};
#line 415 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct confop *findconfop(char *field ) 
{ 
  struct confop **co ;
  int tmp ;

  {
#line 421
  co = confops;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! ((unsigned long )*co != (unsigned long )((void *)0))) {
#line 421
      goto while_break;
    }
    {
#line 422
    tmp = strcmp((char const   *)(*co)->co_name, (char const   *)field);
    }
#line 422
    if (tmp == 0) {
#line 423
      return (*co);
    }
#line 421
    co ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 424
  Warning("fontdesc: %s illegal (%s line %d)", field, fdin.name, fdin.line);
  }
#line 425
  return (& skipcop);
}
}
#line 432
void getfontdesc(void) ;
#line 433 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct confop fdcop  =    {(char *)"fontdesc", & getfontdesc};
#line 438 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void getfontdesc(void) 
{ 
  char field_file[1024] ;
  char path[1024] ;

  {
  {
#line 444
  getfield(field_file);
#line 445
  skipline();
#line 446
  defexpand(path, field_file);
#line 447
  read_fontdesc(path, 0);
  }
#line 448
  return;
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void arg_fontdesc(char *fdn ) 
{ 
  char path[1024] ;

  {
  {
#line 456
  defexpand(path, fdn);
#line 457
  read_fontdesc(path, 1);
  }
#line 458
  return;
}
}
#line 460
void getfdfont(void) ;
#line 461 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct confop fontcop  =    {(char *)"font", & getfdfont};
#line 473 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static struct fontdesc *fontdescs  =    (struct fontdesc *)((void *)0);
#line 474 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static struct fontdesc **nextfd  =    & fontdescs;
#line 476 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void getfdfont(void) 
{ 
  char field_type[257] ;
  char field_spec[257] ;
  char field_sub[257] ;
  char field_path[257] ;
  struct fontdesc *fd ;
  struct fontop *fop ;
  struct funcfont *ff ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 487
  getfield(field_type);
#line 488
  fop = findfontop(field_type);
  }
#line 488
  if ((unsigned long )fop == (unsigned long )((void *)0)) {
    {
#line 489
    Warning("fontdesc: illegal font type %s (%s line %d)", field_type, fdin.name,
            fdin.line);
#line 491
    skipline();
    }
#line 492
    return;
  }
  {
#line 494
  getfield(field_spec);
#line 495
  getfield(field_sub);
#line 496
  getlfield(field_path);
#line 497
  tmp = (*(fop->fo_init))(field_path, & ff);
  }
#line 497
  if (! tmp) {
    {
#line 498
    Warning("fontdesc: illegal font line (%s line %d)", fdin.name, fdin.line);
    }
#line 499
    return;
  }
  {
#line 501
  tmp___0 = malloc((size_t )((unsigned int )sizeof(struct fontdesc )));
#line 501
  tmp___1 = alloc_check(tmp___0, "fontdesc");
#line 501
  fd = (struct fontdesc *)tmp___1;
#line 502
  fd->fd_op = fop;
#line 503
  fd->fd_spec = strsave(field_spec);
#line 504
  fd->fd_sub = atoi((char const   *)(field_sub));
#line 505
  fd->fd_path = ff;
#line 506
  fd->fd_next = (struct fontdesc *)((void *)0);
#line 507
  *nextfd = fd;
#line 508
  nextfd = & fd->fd_next;
  }
#line 509
  return;
}
}
#line 511 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct fontop *findfontop(char *type ) 
{ 
  struct fontop **fo ;
  int tmp ;

  {
#line 517
  fo = fontops;
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    if (! ((unsigned long )*fo != (unsigned long )((void *)0))) {
#line 517
      goto while_break;
    }
    {
#line 518
    tmp = strcmp((char const   *)(*fo)->fo_type, (char const   *)type);
    }
#line 518
    if (tmp == 0) {
#line 519
      return (*fo);
    }
#line 517
    fo ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  return ((struct fontop *)((void *)0));
}
}
#line 523 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int pathtype_init(char *proto , struct funcfont **ff ) 
{ 
  char path[1024] ;
  char *tmp ;

  {
  {
#line 529
  defexpand(path, proto);
#line 530
  tmp = strsave(path);
#line 530
  *ff = (struct funcfont *)tmp;
  }
#line 531
  return (1);
}
}
#line 534
void getdef(void) ;
#line 535 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct confop defcop  =    {(char *)"define", & getdef};
#line 545 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static struct definition *definitions  =    (struct definition *)((void *)0);
#line 546 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static struct definition *arg_defs  =    (struct definition *)((void *)0);
#line 548 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int add_def0(char *var , char *val ) 
{ 
  struct definition *def ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 553
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 554
    val = (char *)"";
  }
  {
#line 555
  tmp = malloc((size_t )((unsigned int )sizeof(struct definition )));
#line 555
  tmp___0 = alloc_check(tmp, "definition");
#line 555
  def = (struct definition *)tmp___0;
#line 556
  def->def_name = var;
#line 557
  def->def_body = val;
#line 558
  def->def_next = definitions;
#line 559
  definitions = def;
  }
#line 560
  return (0);
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int add_def(char *var , char *val ) 
{ 
  char path[1024] ;
  struct definition *def ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 568
  tmp = malloc((size_t )((unsigned int )sizeof(struct definition )));
#line 568
  tmp___0 = alloc_check(tmp, "definition");
#line 568
  def = (struct definition *)tmp___0;
#line 569
  def->def_name = strsave(var);
#line 570
  defexpand(path, val);
#line 571
  def->def_body = strsave(path);
#line 572
  def->def_next = definitions;
#line 573
  definitions = def;
  }
#line 574
  return (0);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct definition *get_def(char *var , struct definition *defs ) 
{ 
  struct definition *def ;
  int tmp ;

  {
#line 583
  def = defs;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    if (! ((unsigned long )def != (unsigned long )((void *)0))) {
#line 583
      goto while_break;
    }
    {
#line 584
    tmp = strcmp((char const   *)var, (char const   *)def->def_name);
    }
#line 584
    if (tmp == 0) {
#line 585
      return (def);
    }
#line 583
    def = def->def_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 586
  return ((struct definition *)((void *)0));
}
}
#line 589 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int arg_define(char *def ) 
{ 
  char *val ;
  char *tmp ;

  {
#line 594
  val = def;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if ((int )*val != 61) {
#line 594
      if (! ((int )*val != 0)) {
#line 594
        goto while_break;
      }
    } else {
#line 594
      goto while_break;
    }
#line 594
    val ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 596
  if ((int )*val == 61) {
#line 597
    tmp = val;
#line 597
    val ++;
#line 597
    *tmp = (char )'\000';
  }
  {
#line 598
  add_def(def, val);
#line 599
  arg_defs = definitions;
  }
#line 600
  return (0);
}
}
#line 602 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void getdef(void) 
{ 
  char field_name[257] ;
  char field_body[257] ;
  struct definition *tmp ;

  {
  {
#line 609
  getfield(field_name);
#line 610
  getfield(field_body);
#line 611
  skipline();
#line 612
  tmp = get_def(field_name, arg_defs);
  }
#line 612
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 613
    add_def(field_name, field_body);
    }
  }
#line 614
  return;
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
char *getdefbody(char *var ) 
{ 
  struct definition *def ;
  char const   *tmp ;

  {
  {
#line 622
  def = get_def(var, definitions);
  }
#line 622
  if ((unsigned long )def != (unsigned long )((void *)0)) {
#line 622
    tmp = (char const   *)def->def_body;
  } else {
#line 622
    tmp = "";
  }
#line 622
  return ((char *)tmp);
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void defexpand(char *path , char *proto ) 
{ 
  char *p ;
  char *s ;
  char *t ;
  char *pend ;
  char dname[257] ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
#line 633
  p = path;
#line 633
  s = proto;
#line 633
  pend = (path + 1024) - 1;
  {
#line 633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 633
    if (! ((int )*s != 0)) {
#line 633
      goto while_break;
    }
#line 634
    if ((int )*s == 36) {
#line 635
      s ++;
#line 635
      if ((int )*s == 123) {
#line 636
        t = dname;
#line 636
        s ++;
        {
#line 636
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 636
          if ((int )*s != 125) {
#line 636
            if (! ((int )*s != 0)) {
#line 636
              goto while_break___0;
            }
          } else {
#line 636
            goto while_break___0;
          }
#line 637
          *t = *s;
#line 636
          s ++;
#line 636
          t ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 638
        if ((int )*s == 0) {
#line 639
          s --;
        }
      } else {
#line 641
        t = dname;
        {
#line 641
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 641
          tmp = __ctype_b_loc();
          }
#line 641
          if (! ((int const   )*(*tmp + (int )*s) & 8)) {
#line 641
            goto while_break___1;
          }
#line 642
          *t = *s;
#line 641
          s ++;
#line 641
          t ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 643
        s --;
      }
      {
#line 645
      *t = (char )'\000';
#line 646
      t = getdefbody(dname);
#line 647
      tmp___0 = strlen((char const   *)t);
      }
#line 647
      if ((unsigned long )(p + tmp___0) >= (unsigned long )pend) {
        {
#line 648
        Fatal("font path too long %s", proto);
        }
      }
      {
#line 649
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)t);
#line 650
      tmp___1 = strlen((char const   *)t);
#line 650
      p += tmp___1;
      }
    } else
#line 651
    if ((unsigned long )p < (unsigned long )pend) {
#line 652
      tmp___2 = p;
#line 652
      p ++;
#line 652
      *tmp___2 = *s;
    } else {
      {
#line 654
      Fatal("font path too long %s", proto);
      }
    }
#line 633
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 655
  *p = (char )'\000';
#line 656
  return;
}
}
#line 658
void getresolution(void) ;
#line 659 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct confop resolutioncop  =    {(char *)"resolution", & getresolution};
#line 664 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int set_resolution(char *r___0 ) 
{ 
  char val[1024] ;

  {
  {
#line 669
  defexpand(val, r___0);
#line 670
  resolution = atoi((char const   *)(val));
  }
#line 671
  return (0);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void getresolution(void) 
{ 
  char fd_resolution[257] ;

  {
  {
#line 678
  getfield(fd_resolution);
#line 679
  skipline();
#line 680
  set_resolution(fd_resolution);
  }
#line 681
  return;
}
}
#line 683
void getinclude(void) ;
#line 684 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct confop includecop  =    {(char *)"include", & getinclude};
#line 688
void getincludeif(void) ;
#line 689 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct confop includeifcop  =    {(char *)"includeif", & getincludeif};
#line 693
void getsetup(void) ;
#line 694 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct confop setupcop  =    {(char *)"setup", & getsetup};
#line 698
void getsetupif(void) ;
#line 699 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct confop setupifcop  =    {(char *)"setupif", & getsetupif};
#line 711 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static struct devfile *includefiles  =    (struct devfile *)((void *)0);
#line 712 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static struct devfile **nextif  =    & includefiles;
#line 713 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static struct devfile *setupfiles  =    (struct devfile *)((void *)0);
#line 714 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static struct devfile **nextsf  =    & setupfiles;
#line 721
int add_devfile(char *f , BOOLEAN top , int kind , char *k , struct devfile ***np___0 ) ;
#line 716 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void add_include(char *f , BOOLEAN top ) 
{ 


  {
  {
#line 721
  add_devfile(f, top, 0, "includefile", & nextif);
  }
#line 722
  return;
}
}
#line 724 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void add_includeif(char *f , BOOLEAN top , int kind ) 
{ 


  {
  {
#line 730
  add_devfile(f, top, kind, "includefile", & nextif);
  }
#line 731
  return;
}
}
#line 733 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void add_setup(char *f , BOOLEAN top ) 
{ 


  {
  {
#line 738
  add_devfile(f, top, 0, "setupfile", & nextsf);
  }
#line 739
  return;
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void add_setupif(char *f , BOOLEAN top , int kind ) 
{ 


  {
  {
#line 747
  add_devfile(f, top, kind, "setupfile", & nextsf);
  }
#line 748
  return;
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int add_devfile(char *f , BOOLEAN top , int kind , char *k , struct devfile ***np___0 ) 
{ 
  struct devfile *df ;
  char file[1024] ;
  char incfile[1024] ;
  struct libdir_body newlibdir ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 762
  tmp = malloc((size_t )((unsigned int )sizeof(struct devfile )));
#line 762
  tmp___0 = alloc_check(tmp, k);
#line 762
  df = (struct devfile *)tmp___0;
  }
#line 763
  if ((int )*f == 34) {
    {
#line 764
    tmp___1 = strlen((char const   *)f);
#line 764
    *((f + tmp___1) - 1) = (char )'\000';
#line 765
    df->df_file = strsave(f + 1);
#line 766
    df->df_op = & dev_copystring;
    }
  } else {
    {
#line 768
    defexpand(file, f);
#line 769
    tmp___2 = searchfile(file, incfile, & newlibdir, top, (char *)".ps");
    }
#line 769
    if (tmp___2) {
      {
#line 770
      df->df_file = strsave(incfile);
#line 771
      df->df_op = & dev_copyfile;
      }
    } else {
      {
#line 773
      Fatal("cannot open file %s", file);
      }
    }
  }
#line 775
  df->df_kind = kind;
#line 776
  df->df_next = (struct devfile *)((void *)0);
#line 777
  *(*np___0) = df;
#line 778
  *np___0 = & df->df_next;
#line 779
  return (0);
}
}
#line 781 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int add_include_spec(char *f , void (*op)() ) 
{ 
  struct devfile *df ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 787
  tmp = malloc((size_t )((unsigned int )sizeof(struct devfile )));
#line 787
  tmp___0 = alloc_check(tmp, "special header");
#line 787
  df = (struct devfile *)tmp___0;
#line 788
  df->df_file = strsave(f);
#line 789
  df->df_op = op;
#line 790
  df->df_next = (struct devfile *)((void *)0);
#line 791
  *nextif = df;
#line 792
  nextif = & df->df_next;
  }
#line 793
  return (0);
}
}
#line 795 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int add_setup_spec(char *f , void (*op)() ) 
{ 
  struct devfile *df ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 801
  tmp = malloc((size_t )((unsigned int )sizeof(struct devfile )));
#line 801
  tmp___0 = alloc_check(tmp, "special header");
#line 801
  df = (struct devfile *)tmp___0;
#line 802
  df->df_file = strsave(f);
#line 803
  df->df_op = op;
#line 804
  df->df_next = (struct devfile *)((void *)0);
#line 805
  *nextsf = df;
#line 806
  nextsf = & df->df_next;
  }
#line 807
  return (0);
}
}
#line 812
int getdevfile(void (*add)() ) ;
#line 809 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void getinclude(void) 
{ 


  {
  {
#line 812
  getdevfile(& add_include);
  }
#line 813
  return;
}
}
#line 818
int getdevfileif(void (*add)() ) ;
#line 815 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void getincludeif(void) 
{ 


  {
  {
#line 818
  getdevfileif(& add_includeif);
  }
#line 819
  return;
}
}
#line 821 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void getsetup(void) 
{ 


  {
  {
#line 824
  getdevfile(& add_setup);
  }
#line 825
  return;
}
}
#line 827 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void getsetupif(void) 
{ 


  {
  {
#line 830
  getdevfileif(& add_setupif);
  }
#line 831
  return;
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int getdevfile(void (*add)() ) 
{ 
  char field_file[1024] ;

  {
  {
#line 838
  getqfield(field_file);
#line 839
  skipline();
#line 840
  (*add)(field_file, 0);
  }
#line 841
  return (0);
}
}
#line 843 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int getdevfileif(void (*add)() ) 
{ 
  char field_kind[1024] ;
  char field_file[1024] ;
  int tmp ;

  {
  {
#line 850
  getfield(field_kind);
#line 851
  getqfield(field_file);
#line 852
  skipline();
#line 853
  tmp = dev_devfilekind(field_kind);
#line 853
  (*add)(field_file, 0, tmp);
  }
#line 854
  return (0);
}
}
#line 858
int do_devfile(struct devfile *df ) ;
#line 856 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int do_include(void) 
{ 


  {
  {
#line 858
  do_devfile(includefiles);
  }
#line 859
  return (0);
}
}
#line 861 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int do_setup(void) 
{ 


  {
  {
#line 863
  do_devfile(setupfiles);
  }
#line 864
  return (0);
}
}
#line 866 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int do_devfile(struct devfile *df ) 
{ 
  int tmp ;

  {
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 869
    if (! ((unsigned long )df != (unsigned long )((void *)0))) {
#line 869
      goto while_break;
    }
#line 870
    if (df->df_kind == 0) {
      {
#line 871
      (*(df->df_op))(df->df_file);
      }
    } else {
      {
#line 870
      tmp = dev_devfileif(df->df_kind);
      }
#line 870
      if (tmp) {
        {
#line 871
        (*(df->df_op))(df->df_file);
        }
      }
    }
#line 869
    df = df->df_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 872
  return (0);
}
}
#line 874
void getcconv(void) ;
#line 875 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct confop cconvcop  =    {(char *)"cconvdir", & getcconv};
#line 880 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static struct libdir_body cconvlibdir  ;
#line 882 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void getcconv(void) 
{ 
  char field_mapdir[257] ;

  {
  {
#line 887
  getfield(field_mapdir);
#line 888
  skipline();
#line 889
  strcpy((char */* __restrict  */)(cconvlibdir.dir), (char const   */* __restrict  */)libdir.dir);
#line 890
  strcpy((char */* __restrict  */)(cconvlibdir.lcldir), (char const   */* __restrict  */)(field_mapdir));
#line 891
  strcat((char */* __restrict  */)(cconvlibdir.lcldir), (char const   */* __restrict  */)"/");
#line 892
  cconvlibdir.defpath = dvi2lib;
  }
#line 893
  return;
}
}
#line 895 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int findcconvmap(char *name , char *file ) 
{ 
  int tmp ;

  {
  {
#line 898
  tmp = searchfiledir(name, & cconvlibdir, file);
  }
#line 898
  return (tmp);
}
}
#line 901
void getsubst(void) ;
#line 902 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct confop substcop  =    {(char *)"subst", & getsubst};
#line 914 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static struct fontsubst *fontsubsts  =    (struct fontsubst *)((void *)0);
#line 915 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static struct fontsubst **nextfs  =    & fontsubsts;
#line 917 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void getsubst(void) 
{ 
  char field_font[257] ;
  char field_reqmag[257] ;
  char field_submag[257] ;
  struct fontsubst *fs ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 925
  getfield(field_font);
#line 926
  getfield(field_reqmag);
#line 927
  getfield(field_submag);
#line 928
  skipline();
#line 929
  tmp = malloc((size_t )((unsigned int )sizeof(struct fontsubst )));
#line 929
  tmp___0 = alloc_check(tmp, "fontsubst");
#line 929
  fs = (struct fontsubst *)tmp___0;
#line 930
  fs->fs_font = strsave(field_font);
#line 931
  tmp___1 = strlen((char const   *)(field_font));
#line 931
  fs->fs_len = (int )tmp___1;
#line 932
  tmp___2 = strcmp((char const   *)(field_reqmag), "%R");
  }
#line 932
  if (tmp___2 == 0) {
#line 933
    fs->fs_reqmag = resolution;
  } else {
    {
#line 935
    fs->fs_reqmag = atoi((char const   *)(field_reqmag));
    }
  }
  {
#line 936
  fs->fs_submag = atoi((char const   *)(field_submag));
#line 937
  fs->fs_next = (struct fontsubst *)((void *)0);
#line 938
  *nextfs = fs;
#line 939
  nextfs = & fs->fs_next;
  }
#line 940
  return;
}
}
#line 942
void getreplfont(void) ;
#line 943 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
struct confop replfcop  =    {(char *)"replfont", & getreplfont};
#line 955 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static struct fontreplace *fontreplaces  =    (struct fontreplace *)((void *)0);
#line 956 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static struct fontreplace **nextfr  =    & fontreplaces;
#line 958 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void getreplfont(void) 
{ 
  char field_replfont[257] ;
  char field_font[257] ;
  char field_par[257] ;
  struct fontreplace *fr ;
  char *c ;
  char *f ;
  BOOLEAN fixs ;
  float fx ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 969
  getfield(field_replfont);
#line 970
  getfield(field_font);
#line 971
  getfield(field_par);
#line 972
  skipline();
#line 973
  tmp = malloc((size_t )((unsigned int )sizeof(struct fontreplace )));
#line 973
  tmp___0 = alloc_check(tmp, "fontreplace");
#line 973
  fr = (struct fontreplace *)tmp___0;
#line 974
  fr->fr_replfont = strsave(field_replfont);
#line 975
  fr->fr_font = strsave(field_font);
#line 976
  c = field_par;
  }
  {
#line 976
  while (1) {
    while_continue: /* CIL Label */ ;
#line 976
    if ((int )*c != 0) {
#line 976
      if (! ((int )*c != 44)) {
#line 976
        goto while_break;
      }
    } else {
#line 976
      goto while_break;
    }
#line 976
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 978
  fixs = (int )*c == 44;
#line 979
  *c = (char )'\000';
#line 980
  tmp___1 = atoi((char const   *)(field_par));
#line 980
  fr->fr_ds = tmp___1 << 16;
#line 981
  fr->fr_fix = -1;
  }
  {
#line 982
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 982
    if (! fixs) {
#line 982
      goto while_break___0;
    }
#line 983
    c ++;
#line 983
    f = c;
    {
#line 983
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 983
      if ((int )*c != 0) {
#line 983
        if (! ((int )*c != 42)) {
#line 983
          goto while_break___1;
        }
      } else {
#line 983
        goto while_break___1;
      }
#line 983
      c ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 985
    fixs = (int )*c == 42;
#line 986
    *c = (char )'\000';
#line 987
    if ((int )*f == 102) {
#line 988
      if (fr->fr_fix >= 0) {
        {
#line 989
        tmp___2 = atoi((char const   *)(f + 1));
#line 989
        fr->fr_fix = scale_exact(fr->fr_fix, tmp___2);
        }
      } else {
        {
#line 991
        fr->fr_fix = atoi((char const   *)(f + 1));
        }
      }
    } else {
      {
#line 993
      sscanf((char const   */* __restrict  */)f, (char const   */* __restrict  */)"%f",
             & fx);
      }
#line 994
      if (fr->fr_fix >= 0) {
        {
#line 995
        fr->fr_fix = scale_exact(fr->fr_fix, (int )(fx * (float )(1 << 20)));
        }
      } else {
#line 997
        fr->fr_fix = (int )(fx * (float )(1 << 20));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1000
  fr->fr_next = (struct fontreplace *)((void *)0);
#line 1001
  *nextfr = fr;
#line 1002
  nextfr = & fr->fr_next;
#line 1003
  return;
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
char *mfmodevname  =    (char *)"mode";
#line 1009 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
char *kpsevname  =    (char *)"kpse";
#line 1011 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int init_default(char *def_mfmode , char *def_kpse ) 
{ 


  {
  {
#line 1014
  mfmode = def_mfmode;
#line 1014
  add_def0(mfmodevname, mfmode);
#line 1015
  add_def0(kpsevname, def_kpse);
  }
#line 1016
  return (0);
}
}
#line 1018 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int fix_default(int def_resolution , char *def_mfmode ) 
{ 
  char *m ;

  {
#line 1024
  if (resolution <= 0) {
#line 1025
    resolution = def_resolution;
  }
  {
#line 1026
  m = getdefbody(mfmodevname);
  }
#line 1027
  if ((int )*m != 0) {
#line 1028
    mfmode = m;
  } else {
    {
#line 1030
    mfmode = def_mfmode;
#line 1030
    add_def0(mfmodevname, mfmode);
    }
  }
#line 1031
  return (0);
}
}
#line 1037 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
int replfont(char *n , int s , char *rn , int *rd , int *rs ) 
{ 
  struct fontreplace *fr ;
  char *sb ;
  char *se ;
  int tmp ;

  {
#line 1046
  fr = fontreplaces;
  {
#line 1046
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1046
    if (! ((unsigned long )fr != (unsigned long )((void *)0))) {
#line 1046
      goto while_break;
    }
    {
#line 1047
    tmp = match_subf(fr->fr_replfont, n, 0, & sb, & se);
    }
#line 1047
    if (tmp) {
      {
#line 1048
      subst_subf(rn, fr->fr_font, sb, se);
#line 1049
      *rd = fr->fr_ds;
      }
#line 1050
      if (fr->fr_fix < 0) {
#line 1051
        *rs = s;
      } else {
        {
#line 1053
        *rs = scale_exact(fr->fr_fix, s);
        }
      }
#line 1054
      return (1);
    }
#line 1046
    fr = fr->fr_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1056
  return (0);
}
}
#line 1073 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
static int advice  =    0;
#line 1062 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void init_fontinfo(struct font_entry *fe ) 
{ 
  struct accarg acca ;
  float rawmagfact ;
  float newmagfact ;
  struct fontdesc *fd ;
  struct fontsubst *fs ;
  char *sb ;
  char *se ;
  int i ;
  int next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 1075
  newmagfact = dev_fontmag(fe);
#line 1075
  rawmagfact = newmagfact;
#line 1075
  acca.rawmagfact = rawmagfact;
#line 1076
  acca.pv_name = fe->n;
  }
#line 1079
  if (debug >= 1) {
    {
#line 1080
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<- Begin to find font file for %s (mag %d)\n",
            fe->n, (unsigned int )(1000.0 * (double )rawmagfact + 0.5));
    }
  }
  {
#line 1084
  acca.acc_mode = 0;
#line 1085
  acca.actmagfact = actfact((double )acca.rawmagfact);
#line 1086
  fd = fontdescs;
  }
  {
#line 1086
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1086
    if (! ((unsigned long )fd != (unsigned long )((void *)0))) {
#line 1086
      goto while_break;
    }
    {
#line 1087
    tmp = (*((fd->fd_op)->fo_access))(fd->fd_path, fe, & acca);
    }
#line 1087
    if (tmp) {
#line 1089
      if (debug >= 1) {
        {
#line 1090
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-> Font file for %s (mag %d) found\n",
                fe->n, (unsigned int )(1000.0 * (double )rawmagfact + 0.5));
        }
      }
      {
#line 1093
      (*((fd->fd_op)->fo_initfontinfo))(fe);
      }
#line 1094
      return;
    }
#line 1086
    fd = fd->fd_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1098
  acca.acc_mode = 1;
#line 1099
  fs = fontsubsts;
  {
#line 1099
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1099
    if (! ((unsigned long )fs != (unsigned long )((void *)0))) {
#line 1099
      goto while_break___0;
    }
    {
#line 1100
    tmp___1 = match_subf(fs->fs_font, fe->n, 1, & sb, & se);
    }
#line 1100
    if (tmp___1) {
#line 1101
      acca.submag = fs->fs_submag;
#line 1102
      acca.reqmag = fs->fs_reqmag;
#line 1103
      fd = fontdescs;
      {
#line 1103
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1103
        if (! ((unsigned long )fd != (unsigned long )((void *)0))) {
#line 1103
          goto while_break___1;
        }
#line 1104
        if ((fd->fd_sub & 1) == 0) {
#line 1105
          goto __Cont;
        }
        {
#line 1106
        tmp___0 = (*((fd->fd_op)->fo_access))(fd->fd_path, fe, & acca);
        }
#line 1106
        if (tmp___0) {
          {
#line 1107
          Warning("-> Font file for %s: font mag %d replaced by %d", fe->n, fs->fs_reqmag,
                  fs->fs_submag);
#line 1109
          (*((fd->fd_op)->fo_initfontinfo))(fe);
          }
#line 1110
          return;
        }
        __Cont: /* CIL Label */ 
#line 1103
        fd = fd->fd_next;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1099
    fs = fs->fs_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1115
  acca.acc_mode = 2;
#line 1116
  apprfact((double )rawmagfact);
#line 1117
  i = 0;
  }
  {
#line 1117
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1118
    newmagfact = mag_table[mag_index + i];
#line 1118
    acca.stepmagfact = newmagfact;
#line 1119
    fd = fontdescs;
    {
#line 1119
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1119
      if (! ((unsigned long )fd != (unsigned long )((void *)0))) {
#line 1119
        goto while_break___3;
      }
#line 1120
      if ((fd->fd_sub & 2) == 0) {
#line 1121
        goto __Cont___0;
      }
      {
#line 1122
      tmp___2 = (*((fd->fd_op)->fo_access))(fd->fd_path, fe, & acca);
      }
#line 1122
      if (tmp___2) {
        {
#line 1123
        Warning("-> Font file for %s: magnification %d replaced by %d", fe->n, (unsigned int )(1000.0 * (double )rawmagfact + 0.5),
                (unsigned int )(1000.0 * (double )newmagfact + 0.5));
#line 1125
        (*((fd->fd_op)->fo_initfontinfo))(fe);
        }
#line 1126
        return;
      }
      __Cont___0: /* CIL Label */ 
#line 1119
      fd = fd->fd_next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1129
    if (i >= 0) {
#line 1130
      next = - i - 1;
#line 1130
      if (mag_index + next < 0) {
#line 1131
        next = i + 1;
#line 1131
        if (mag_index + next >= magtabsize) {
#line 1132
          goto while_break___2;
        }
      }
    } else {
#line 1134
      next = - i;
#line 1134
      if (mag_index + next >= magtabsize) {
#line 1135
        next = i - 1;
#line 1135
        if (mag_index + next < 0) {
#line 1136
          goto while_break___2;
        }
      }
    }
#line 1117
    i = next;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1140
  acca.actmagfact = actfact((double )acca.rawmagfact);
#line 1141
  fd = fontdescs;
  }
  {
#line 1141
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1141
    if (! ((unsigned long )fd != (unsigned long )((void *)0))) {
#line 1141
      goto while_break___4;
    }
#line 1142
    if ((fd->fd_sub & -4) == 0) {
#line 1143
      goto __Cont___1;
    }
    {
#line 1144
    acca.acc_mode = fd->fd_sub & -4;
#line 1145
    tmp___3 = (*((fd->fd_op)->fo_access))(fd->fd_path, fe, & acca);
    }
#line 1145
    if (tmp___3) {
#line 1147
      if (debug >= 1) {
        {
#line 1148
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-> Font file for %s (mag %d) found\n",
                fe->n, (unsigned int )(1000.0 * (double )rawmagfact + 0.5));
        }
      }
      {
#line 1151
      (*((fd->fd_op)->fo_initfontinfo))(fe);
      }
#line 1152
      return;
    }
    __Cont___1: /* CIL Label */ 
#line 1141
    fd = fd->fd_next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1157
  if (debug <= 0) {
#line 1157
    tmp___4 = "";
  } else {
#line 1157
    tmp___4 = "-> ";
  }
  {
#line 1157
  Warning("%sNo font file for %s (mag %d)", tmp___4, fe->n, (unsigned int )(1000.0 * (double )rawmagfact + 0.5));
  }
#line 1159
  if (debug <= 0) {
#line 1159
    if (! advice) {
      {
#line 1160
      advice = 1;
#line 1161
      Warning("(use -d option to know the font file names tried)");
      }
    }
  }
  {
#line 1163
  fe->dev_setchar = & null_markchar;
#line 1164
  sprintf((char */* __restrict  */)(fe->name), (char const   */* __restrict  */)"null:%s:%d",
          fe->n, (unsigned int )(1000.0 * (double )rawmagfact + 0.5));
  }
#line 1165
  return;
}
}
#line 1170 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/fontdesc.c"
void pave(char *path , char *proto , struct accarg *acca ) 
{ 
  char *p ;
  char *s ;
  char *t ;
  char *pend ;
  int len ;
  char buf[32] ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 1183
  p = path;
#line 1183
  s = proto;
#line 1183
  pend = (path + 1024) - 1;
  {
#line 1183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1183
    if (! ((int )*s != 0)) {
#line 1183
      goto while_break;
    }
#line 1184
    if ((int )*s == 37) {
#line 1185
      s ++;
      {
#line 1188
      if ((int )*s == 115) {
#line 1188
        goto case_115;
      }
#line 1188
      if ((int )*s == 110) {
#line 1188
        goto case_115;
      }
#line 1188
      if ((int )*s == 102) {
#line 1188
        goto case_115;
      }
#line 1212
      if ((int )*s == 109) {
#line 1212
        goto case_109;
      }
#line 1212
      if ((int )*s == 100) {
#line 1212
        goto case_109;
      }
#line 1215
      if ((int )*s == 77) {
#line 1215
        goto case_77;
      }
#line 1218
      if ((int )*s == 82) {
#line 1218
        goto case_82;
      }
#line 1221
      if ((int )*s == 70) {
#line 1221
        goto case_70;
      }
#line 1224
      if ((int )*s == 68) {
#line 1224
        goto case_68;
      }
#line 1227
      if ((int )*s == 106) {
#line 1227
        goto case_106;
      }
#line 1230
      goto switch_default;
      case_115: /* CIL Label */ 
      case_110: /* CIL Label */ 
      case_102: /* CIL Label */ 
#line 1208
      t = acca->pv_name;
#line 1210
      goto switch_break;
      case_109: /* CIL Label */ 
      case_100: /* CIL Label */ 
      {
#line 1213
      t = buf;
#line 1213
      sprintf((char */* __restrict  */)t, (char const   */* __restrict  */)"%d", acca->pv_mag);
      }
#line 1214
      goto switch_break;
      case_77: /* CIL Label */ 
      {
#line 1216
      t = buf;
#line 1216
      sprintf((char */* __restrict  */)t, (char const   */* __restrict  */)"%f", (double )acca->actmagfact);
      }
#line 1217
      goto switch_break;
      case_82: /* CIL Label */ 
      {
#line 1219
      t = buf;
#line 1219
      sprintf((char */* __restrict  */)t, (char const   */* __restrict  */)"%d", resolution);
      }
#line 1220
      goto switch_break;
      case_70: /* CIL Label */ 
#line 1222
      t = acca->pv_fam;
#line 1223
      goto switch_break;
      case_68: /* CIL Label */ 
      {
#line 1225
      t = buf;
#line 1225
      sprintf((char */* __restrict  */)t, (char const   */* __restrict  */)"%d", acca->pv_ds);
      }
#line 1226
      goto switch_break;
      case_106: /* CIL Label */ 
#line 1228
      t = acca->pv_jsub;
#line 1229
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1231
      t = buf;
#line 1231
      *t = *s;
#line 1231
      *(t + 1) = (char )'\000';
#line 1232
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1234
      tmp = strlen((char const   *)t);
#line 1234
      len = (int )tmp;
      }
#line 1234
      if ((unsigned long )(p + len) <= (unsigned long )pend) {
        {
#line 1235
        strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)t, (size_t )len);
#line 1236
        p += len;
        }
      } else {
        {
#line 1238
        Fatal("font path too long %s", proto);
        }
      }
    } else
#line 1239
    if ((unsigned long )p < (unsigned long )pend) {
#line 1240
      tmp___0 = p;
#line 1240
      p ++;
#line 1240
      *tmp___0 = *s;
    } else {
      {
#line 1242
      Fatal("font path too long %s", proto);
      }
    }
#line 1183
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1243
  *p = (char )'\000';
#line 1244
  return;
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 206 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/bifont.h"
char *dev_cs_enc(struct bifont *bi ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
BOOLEAN usespsmod  =    0;
#line 17
void getbuiltin(void) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
struct confop mapcop  =    {(char *)"map", & getbuiltin};
#line 22 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
struct confop bicop  =    {(char *)"builtin", & getbuiltin};
#line 26
void getbifont(void) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
struct confop bfcop  =    {(char *)"bifont", & getbifont};
#line 31
void getbikanji(void) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
struct confop bkcop  =    {(char *)"bikanji", & getbikanji};
#line 67 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
static int mf_kind[7]  = {      0,      0,      1,      2, 
        3,      4,      5};
#line 97 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
struct bifont *bifonts  =    (struct bifont *)((void *)0);
#line 98 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
struct bifont **nextbf  =    & bifonts;
#line 100 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
struct bifont selfbifont  = 
#line 100
     {(char *)"", 0, (char)0, (char)0, (char)0, (char)1, 0, 0, (char)0, 0, (char *)((void *)0),
    (char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
    (char)0, (struct font_entry *)((void *)0), (struct bifont *)((void *)0)};
#line 108
void getbuiltinfont(char *cop , struct bifont ***next , char defm_name , char defm_type ,
                    char defm_font , char defm_font_fix ) ;
#line 110 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
void getbuiltin(void) 
{ 


  {
  {
#line 113
  getbuiltinfont("builtin", & nextbf, 0, 0, 0, 3);
  }
#line 115
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
void getbifont(void) 
{ 


  {
  {
#line 120
  getbuiltinfont("bifont", & nextbf, 0, 0, 0, 3);
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
void getbikanji(void) 
{ 


  {
  {
#line 127
  getbuiltinfont("bikanji", & nextbf, 1, 1, 1, 1);
  }
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
void getbuiltinfont(char *cop , struct bifont ***next , char defm_name , char defm_type ,
                    char defm_font , char defm_font_fix ) 
{ 
  char field_name[257] ;
  char field_mode[257] ;
  char field_psfont[257] ;
  char field_psopt1[257] ;
  char field_psopt2[257] ;
  struct bifont *bf ;
  char *mode ;
  char *he ;
  char *psf ;
  char *psfl ;
  char *psm ;
  char *pse ;
  char *p ;
  char path[1024] ;
  char encpath[1024] ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  long tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  long tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 147
  getfield(field_name);
#line 148
  getfield(field_mode);
#line 149
  getqfield(field_psfont);
#line 150
  getoqfield(field_psopt1);
#line 151
  getoqfield(field_psopt2);
#line 152
  skipline();
#line 153
  tmp = malloc((size_t )((unsigned int )sizeof(struct bifont )));
#line 153
  tmp___0 = alloc_check(tmp, cop);
#line 153
  bf = (struct bifont *)tmp___0;
#line 154
  bf->bf_name = strsave(field_name);
#line 155
  tmp___1 = strlen((char const   *)(field_name));
#line 155
  bf->bf_len = (int )tmp___1;
#line 156
  tmp___8 = strcmp((char const   *)(field_mode), "fixed");
  }
#line 156
  if (tmp___8 == 0) {
#line 157
    bf->bf_mode_name = defm_name;
#line 158
    bf->bf_mode_type = defm_type;
#line 159
    bf->bf_mode_font = defm_font_fix;
#line 160
    bf->bf_mode_pos = (char)3;
  } else {
    {
#line 161
    tmp___7 = strcmp((char const   *)(field_mode), "var");
    }
#line 161
    if (tmp___7 == 0) {
#line 162
      bf->bf_mode_name = defm_name;
#line 163
      bf->bf_mode_type = defm_type;
#line 164
      bf->bf_mode_font = (char)0;
#line 165
      bf->bf_mode_pos = (char)3;
    } else {
#line 167
      mode = field_mode;
#line 168
      tmp___2 = mode;
#line 168
      mode ++;
      {
#line 169
      if ((int )*tmp___2 == 84) {
#line 169
        goto case_84;
      }
#line 172
      if ((int )*tmp___2 == 75) {
#line 172
        goto case_75;
      }
#line 175
      if ((int )*tmp___2 == 83) {
#line 175
        goto case_83;
      }
#line 178
      if ((int )*tmp___2 == 74) {
#line 178
        goto case_74;
      }
#line 182
      goto switch_default;
      case_84: /* CIL Label */ 
#line 170
      bf->bf_mode_type = (char)0;
#line 171
      goto switch_break;
      case_75: /* CIL Label */ 
#line 173
      bf->bf_mode_type = (char)1;
#line 174
      goto switch_break;
      case_83: /* CIL Label */ 
#line 176
      bf->bf_mode_type = (char)2;
#line 177
      goto switch_break;
      case_74: /* CIL Label */ 
#line 179
      bf->bf_mode_type = (char)3;
#line 180
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 183
      bf->bf_mode_type = defm_type;
#line 184
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 186
      tmp___3 = mode;
#line 186
      mode ++;
      {
#line 187
      if ((int )*tmp___3 == 83) {
#line 187
        goto case_83___0;
      }
#line 190
      if ((int )*tmp___3 == 73) {
#line 190
        goto case_73;
      }
#line 195
      goto switch_default___0;
      case_83___0: /* CIL Label */ 
#line 188
      bf->bf_mode_name = (char)0;
#line 189
      goto switch_break___0;
      case_73: /* CIL Label */ 
#line 191
      bf->bf_mode_name = (char)1;
#line 192
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 196
      bf->bf_mode_name = defm_name;
#line 197
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 199
      tmp___4 = mode;
#line 199
      mode ++;
      {
#line 200
      if ((int )*tmp___4 == 84) {
#line 200
        goto case_84___0;
      }
#line 209
      if ((int )*tmp___4 == 78) {
#line 209
        goto case_78;
      }
#line 212
      if ((int )*tmp___4 == 69) {
#line 212
        goto case_69;
      }
#line 219
      if ((int )*tmp___4 == 83) {
#line 219
        goto case_83___1;
      }
#line 222
      if ((int )*tmp___4 == 70) {
#line 222
        goto case_70;
      }
#line 229
      if ((int )*tmp___4 == 77) {
#line 229
        goto case_77;
      }
#line 233
      goto switch_default___1;
      case_84___0: /* CIL Label */ 
#line 201
      if ((int )*mode == 40) {
        {
#line 202
        bf->bf_mode_font = (char)6;
#line 203
        tmp___5 = strtol((char const   */* __restrict  */)(mode + 1), (char **/* __restrict  */)(& he),
                         10);
#line 203
        bf->bf_scale = (int )tmp___5;
#line 205
        mode = he + 1;
        }
      } else {
#line 207
        bf->bf_mode_font = (char)0;
      }
#line 208
      goto switch_break___1;
      case_78: /* CIL Label */ 
#line 210
      bf->bf_mode_font = (char)1;
#line 211
      goto switch_break___1;
      case_69: /* CIL Label */ 
      {
#line 213
      bf->bf_mode_font = (char)2;
#line 215
      mode ++;
#line 215
      bf->bf_stand = htoi(mode, & he);
#line 217
      mode = he + 1;
      }
#line 218
      goto switch_break___1;
      case_83___1: /* CIL Label */ 
#line 220
      bf->bf_mode_font = (char)3;
#line 221
      goto switch_break___1;
      case_70: /* CIL Label */ 
      {
#line 223
      bf->bf_mode_font = (char)4;
#line 225
      mode ++;
#line 225
      bf->bf_stand = htoi(mode, & he);
#line 227
      mode = he + 1;
      }
#line 228
      goto switch_break___1;
      case_77: /* CIL Label */ 
#line 230
      bf->bf_mode_font = (char)5;
#line 231
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 234
      bf->bf_mode_font = defm_font;
#line 235
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 237
      tmp___6 = mode;
#line 237
      mode ++;
      {
#line 242
      if ((int )*tmp___6 == 65) {
#line 242
        goto case_65;
      }
#line 245
      if ((int )*tmp___6 == 42) {
#line 245
        goto case_42;
      }
#line 239
      goto switch_default___2;
      switch_default___2: /* CIL Label */ 
#line 240
      bf->bf_mode_pos = (char)1;
#line 241
      goto switch_break___2;
      case_65: /* CIL Label */ 
#line 243
      bf->bf_mode_pos = (char)2;
#line 244
      goto switch_break___2;
      case_42: /* CIL Label */ 
#line 246
      bf->bf_mode_pos = (char)3;
#line 247
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    }
  }
#line 250
  pse = (char *)((void *)0);
#line 250
  psm = pse;
#line 250
  psfl = psm;
#line 250
  psf = psfl;
#line 251
  if ((int )field_psfont[0] == 34) {
    {
#line 252
    bf->bf_font_kind = (char)1;
#line 253
    tmp___9 = strlen((char const   *)(field_psfont));
#line 253
    field_psfont[tmp___9 - 1UL] = (char )'\000';
#line 254
    psf = field_psfont + 1;
    }
#line 255
    if ((int )field_psopt1[0] == 60) {
      {
#line 256
      defexpand(encpath, field_psopt1 + 1);
#line 257
      pse = encpath;
      }
    }
  } else {
#line 260
    if ((int )field_psopt1[0] != 0) {
#line 261
      psm = field_psopt1;
#line 262
      if ((int )*(psm + 0) == 34) {
        {
#line 263
        tmp___10 = strlen((char const   *)psm);
#line 263
        *(psm + (tmp___10 - 1UL)) = (char )'\000';
#line 264
        psm ++;
        }
      }
    }
#line 267
    if ((int )field_psfont[0] == 60) {
#line 268
      bf->bf_font_kind = (char)2;
#line 269
      psfl = field_psfont + 1;
#line 270
      if ((int )*(psfl + 0) == 60) {
#line 271
        psfl ++;
      }
      {
#line 272
      defexpand(path, psfl);
#line 273
      psfl = path;
      }
#line 274
      if ((int )field_psopt2[0] == 60) {
        {
#line 275
        defexpand(encpath, field_psopt2 + 1);
#line 276
        pse = encpath;
        }
      }
    } else
#line 278
    if ((int )field_psfont[0] == 58) {
#line 279
      psfl = field_psfont + 1;
#line 280
      if ((int )*(psfl + 0) == 42) {
#line 281
        bf->bf_font_kind = (char)3;
#line 282
        psfl ++;
      } else {
#line 284
        bf->bf_font_kind = (char)4;
      }
#line 285
      if ((int )*(psfl + 0) == 40) {
        {
#line 286
        tmp___11 = strtol((char const   */* __restrict  */)(psfl + 1), (char **/* __restrict  */)(& he),
                          10);
#line 286
        bf->bf_bold = (int )tmp___11;
#line 288
        psfl = he + 1;
        }
      } else {
#line 290
        bf->bf_bold = -1;
      }
#line 291
      if ((int )*(psfl + 0) == 91) {
#line 292
        p = psfl + 1;
        {
#line 292
        while (1) {
          while_continue: /* CIL Label */ ;
#line 292
          if ((int )*p != 93) {
#line 292
            if (! ((int )*p != 0)) {
#line 292
              goto while_break;
            }
          } else {
#line 292
            goto while_break;
          }
#line 292
          p ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 294
        if ((int )*p == 0) {
          {
#line 295
          Warning("illegal map line");
          }
#line 296
          return;
        }
        {
#line 298
        *p = (char )'\000';
#line 299
        bf->bf_cs_enc = strsave(psfl + 1);
#line 300
        psfl = p + 1;
        }
      } else {
#line 302
        bf->bf_cs_enc = (char *)"";
      }
      {
#line 303
      defexpand(path, psfl);
#line 304
      psfl = path;
      }
#line 305
      if ((int )field_psopt2[0] == 60) {
        {
#line 306
        defexpand(encpath, field_psopt2 + 1);
#line 307
        pse = encpath;
        }
      }
    } else
#line 309
    if ((int )field_psfont[0] == 94) {
#line 310
      psfl = field_psfont + 1;
#line 311
      if ((int )*(psfl + 0) == 42) {
#line 312
        bf->bf_font_kind = (char)5;
#line 313
        psfl ++;
      } else {
#line 315
        bf->bf_font_kind = (char)6;
      }
    } else {
#line 317
      if ((int )field_psopt1[0] == 64) {
#line 318
        if ((int )field_psopt1[1] == 106) {
#line 319
          bf->bf_coding = (char)0;
        } else
#line 320
        if ((int )field_psopt1[1] == 101) {
#line 321
          bf->bf_coding = (char)1;
        } else {
#line 323
          bf->bf_coding = (char)2;
        }
      } else {
#line 325
        bf->bf_coding = (char)0;
      }
#line 326
      bf->bf_font_kind = (char)0;
#line 327
      psf = field_psfont;
#line 328
      psm = (char *)((void *)0);
    }
  }
#line 331
  if ((unsigned long )psf != (unsigned long )((void *)0)) {
    {
#line 331
    tmp___12 = strsave(psf);
#line 331
    bf->bf_psfont = tmp___12;
    }
  } else {
#line 331
    bf->bf_psfont = (char *)((void *)0);
  }
#line 332
  if ((unsigned long )psfl != (unsigned long )((void *)0)) {
    {
#line 332
    tmp___13 = strsave(psfl);
#line 332
    bf->bf_psfile = tmp___13;
    }
  } else {
#line 332
    bf->bf_psfile = (char *)((void *)0);
  }
#line 333
  if ((unsigned long )psm != (unsigned long )((void *)0)) {
    {
#line 333
    tmp___14 = strsave(psm);
#line 333
    bf->bf_psmod = tmp___14;
    }
  } else {
#line 333
    bf->bf_psmod = (char *)((void *)0);
  }
#line 334
  if ((unsigned long )pse != (unsigned long )((void *)0)) {
    {
#line 334
    tmp___15 = strsave(pse);
#line 334
    bf->bf_psenc = tmp___15;
    }
  } else {
#line 334
    bf->bf_psenc = (char *)((void *)0);
  }
#line 335
  bf->bf_repfe = (struct font_entry *)((void *)0);
#line 336
  bf->bf_next = (struct bifont *)((void *)0);
#line 337
  *(*next) = bf;
#line 338
  *next = & bf->bf_next;
#line 339
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int comp_bfname(char *fname , struct bifont *bf ) 
{ 
  char *bname ;

  {
#line 347
  bname = bf->bf_name;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! ((int )*bname != 0)) {
#line 347
      goto while_break;
    }
#line 348
    if ((int )*bname == 37) {
#line 349
      bname ++;
#line 349
      if ((int )*bname == 100) {
#line 350
        if (48 <= (int )*fname) {
#line 350
          if ((int )*fname <= 57) {
#line 351
            fname ++;
            {
#line 351
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 351
              if (48 <= (int )*fname) {
#line 351
                if (! ((int )*fname <= 57)) {
#line 351
                  goto while_break___0;
                }
              } else {
#line 351
                goto while_break___0;
              }
#line 351
              fname ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 353
            fname --;
#line 354
            goto __Cont;
          } else {
#line 356
            return (0);
          }
        } else {
#line 356
          return (0);
        }
      } else {
#line 358
        return (0);
      }
    } else
#line 359
    if ((int )*bname != (int )*fname) {
#line 360
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 347
    bname ++;
#line 347
    fname ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 362
  if ((int )*fname == 0) {
#line 363
    return (1);
  } else {
#line 365
    return ((int )bf->bf_mode_name == 1);
  }
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
struct bifont *findbifont(char *name ) 
{ 
  struct bifont *bf ;
  int tmp ;

  {
#line 374
  bf = bifonts;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! ((unsigned long )bf != (unsigned long )((void *)0))) {
#line 374
      goto while_break;
    }
#line 375
    if ((int )bf->bf_mode_type == 0) {
      {
#line 376
      tmp = comp_bfname(name, bf);
      }
#line 376
      if (tmp) {
#line 377
        return (bf);
      }
    }
#line 374
    bf = bf->bf_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  return ((struct bifont *)((void *)0));
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
struct bifont *findbksub(char *name ) 
{ 
  struct bifont *bf ;
  char *subbeg ;
  char *subend ;
  int tmp ;
  int tmp___0 ;

  {
#line 388
  bf = bifonts;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! ((unsigned long )bf != (unsigned long )((void *)0))) {
#line 388
      goto while_break;
    }
#line 389
    if ((int )bf->bf_mode_type == 2) {
      {
#line 390
      tmp = match_subf(bf->bf_name, name, (int )bf->bf_mode_name == 1, & subbeg, & subend);
      }
#line 390
      if (tmp) {
#line 393
        return (bf);
      }
    } else
#line 394
    if ((int )bf->bf_mode_type == 1) {
      {
#line 395
      tmp___0 = comp_bfname(name, bf);
      }
#line 395
      if (tmp___0) {
        {
#line 396
        foundjsubf = getjsubfont(name + bf->bf_len, & subend);
        }
#line 397
        return (bf);
      }
    }
#line 388
    bf = bf->bf_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  return ((struct bifont *)((void *)0));
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
struct bifont *findbkjfm(char *name ) 
{ 
  struct bifont *bf ;
  int tmp ;

  {
#line 410
  bf = bifonts;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    if (! ((unsigned long )bf != (unsigned long )((void *)0))) {
#line 410
      goto while_break;
    }
#line 411
    if ((int )bf->bf_mode_type == 3) {
#line 411
      goto _L;
    } else
#line 411
    if ((int )bf->bf_mode_type == 1) {
      _L: /* CIL Label */ 
      {
#line 413
      tmp = comp_bfname(name, bf);
      }
#line 413
      if (tmp) {
#line 414
        return (bf);
      }
    }
#line 410
    bf = bf->bf_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  return ((struct bifont *)((void *)0));
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int dev_set_repfe(struct bifont *bi , struct font_entry *fe ) 
{ 


  {
#line 422
  bi->bf_repfe = fe;
#line 423
  return (0);
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
struct font_entry *dev_get_repfe(struct bifont *bi ) 
{ 


  {
#line 429
  return (bi->bf_repfe);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
char *dev_fontpath(struct bifont *bi ) 
{ 


  {
#line 436
  return (bi->bf_psfile);
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int dev_bold(struct bifont *bi ) 
{ 


  {
#line 442
  return (bi->bf_bold);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
char *dev_cs_enc(struct bifont *bi ) 
{ 


  {
#line 449
  return (bi->bf_cs_enc);
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
char *dev_encfile(struct bifont *bi ) 
{ 


  {
#line 456
  return (bi->bf_psenc);
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int dev_mf_kind(struct bifont *bf ) 
{ 


  {
#line 462
  return (mf_kind[bf->bf_font_kind]);
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int dev_is_tfm(struct font_entry *fe , int tfmmode ) 
{ 
  struct bifont *bi ;

  {
  {
#line 471
  bi = findbifont(fe->n);
  }
#line 471
  if ((unsigned long )bi == (unsigned long )((void *)0)) {
#line 472
    if (tfmmode & 8) {
#line 473
      bi = & selfbifont;
    } else {
#line 475
      return (0);
    }
  }
#line 477
  (*((struct biaccessinfo **)(& fe->finfo)))->bf = bi;
#line 478
  if ((int )bi->bf_font_kind == 1) {
#line 479
    usespsmod = 1;
  } else
#line 478
  if ((unsigned long )bi->bf_psmod != (unsigned long )((void *)0)) {
#line 479
    usespsmod = 1;
  }
#line 480
  return (1);
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int dev_tfm_kind(struct font_entry *fe ) 
{ 


  {
#line 486
  return (mf_kind[((*((struct tfmfntinfo **)(& fe->finfo)))->tfm_bf)->bf_font_kind]);
}
}
#line 489 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
static void bipave(char *path , char *proto , char *biname ) 
{ 
  char *p ;
  char *s ;
  char *t ;
  char *pend ;
  int len ;
  char buf[32] ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 498
  p = path;
#line 498
  s = proto;
#line 498
  pend = (path + 1024) - 1;
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (! ((int )*s != 0)) {
#line 498
      goto while_break;
    }
#line 499
    if ((int )*s == 37) {
#line 500
      s ++;
      {
#line 501
      if ((int )*s == 98) {
#line 501
        goto case_98;
      }
#line 504
      goto switch_default;
      case_98: /* CIL Label */ 
#line 502
      t = biname;
#line 503
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 505
      t = buf;
#line 505
      *t = *s;
#line 505
      *(t + 1) = (char )'\000';
#line 506
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 508
      tmp = strlen((char const   *)t);
#line 508
      len = (int )tmp;
      }
#line 508
      if ((unsigned long )(p + len) <= (unsigned long )pend) {
        {
#line 509
        strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)t, (size_t )len);
#line 510
        p += len;
        }
      } else {
        {
#line 512
        Fatal("font path too long %s", proto);
        }
      }
    } else
#line 513
    if ((unsigned long )p < (unsigned long )pend) {
#line 514
      tmp___0 = p;
#line 514
      p ++;
#line 514
      *tmp___0 = *s;
    } else {
      {
#line 516
      Fatal("font path too long %s", proto);
      }
    }
#line 498
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  *p = (char )'\000';
#line 518
  return;
}
}
#line 520 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int t1tobi(struct bifont *bi , char *t1fname ) 
{ 
  char psprog[1024] ;

  {
#line 526
  if ((int )bi->bf_font_kind == 2) {
#line 527
    if ((unsigned long )bi->bf_psmod == (unsigned long )((void *)0)) {
      {
#line 528
      bi->bf_font_kind = (char)0;
#line 529
      bi->bf_psfont = strsave(t1fname);
      }
    } else {
      {
#line 531
      bi->bf_font_kind = (char)1;
#line 532
      bipave(psprog, bi->bf_psmod, t1fname);
#line 533
      bi->bf_psfont = strsave(psprog);
      }
    }
  }
#line 536
  return (0);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int fttobi(struct bifont *bi , char *ftfname ) 
{ 
  char psprog[1024] ;

  {
#line 544
  if ((int )bi->bf_font_kind == 4) {
#line 545
    if ((unsigned long )bi->bf_psmod == (unsigned long )((void *)0)) {
      {
#line 546
      bi->bf_font_kind = (char)0;
#line 547
      bi->bf_psfont = strsave(ftfname);
      }
    } else {
      {
#line 549
      bi->bf_font_kind = (char)1;
#line 550
      bipave(psprog, bi->bf_psmod, ftfname);
#line 551
      bi->bf_psfont = strsave(psprog);
      }
    }
  }
#line 554
  return (0);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int dev_is_jstfm(struct font_entry *fe , int tfmmode ) 
{ 
  struct bifont *bi ;

  {
  {
#line 562
  foundjsubf = 0;
#line 563
  bi = findbksub(fe->n);
  }
#line 563
  if ((unsigned long )bi != (unsigned long )((void *)0)) {
#line 564
    if (foundjsubf != 0) {
#line 565
      (*((struct biaccessinfo **)(& fe->finfo)))->bf = bi;
#line 566
      (*((struct biaccessinfo **)(& fe->finfo)))->jsubf = (short )foundjsubf;
#line 567
      if ((int )bi->bf_font_kind == 1) {
#line 568
        usespsmod = 1;
      } else
#line 567
      if ((unsigned long )bi->bf_psmod != (unsigned long )((void *)0)) {
#line 568
        usespsmod = 1;
      }
#line 569
      return (1);
    }
  }
#line 571
  return (0);
}
}
#line 581 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
static char pname[1024]  ;
#line 574 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
char *dev_jstfm_parent(struct bifont *bf , char *name ) 
{ 
  char *subbeg ;
  char *subend ;
  int prelen ;
  int tmp ;
  int tmp___0 ;

  {
#line 583
  if ((int )bf->bf_mode_type == 2) {
    {
#line 584
    tmp = match_subf(bf->bf_name, name, (int )bf->bf_mode_name == 1, & subbeg, & subend);
    }
#line 584
    if (tmp) {
      {
#line 587
      prelen = (int )(subbeg - name);
#line 588
      strncpy((char */* __restrict  */)(pname), (char const   */* __restrict  */)name,
              (size_t )prelen);
#line 589
      strcpy((char */* __restrict  */)(pname + prelen), (char const   */* __restrict  */)(subend + 1));
      }
#line 590
      return (pname);
    }
  } else
#line 592
  if ((int )bf->bf_mode_type == 1) {
    {
#line 593
    tmp___0 = getjsubfont(name + bf->bf_len, & subend);
    }
#line 593
    if (tmp___0) {
      {
#line 594
      strncpy((char */* __restrict  */)(pname), (char const   */* __restrict  */)name,
              (size_t )bf->bf_len);
#line 595
      strcpy((char */* __restrict  */)(pname), (char const   */* __restrict  */)(subend + 1));
      }
#line 596
      return (pname);
    }
  }
  {
#line 599
  Fatal("%s implementation error: dev_jstfm_parent", G_progname);
  }
#line 600
  return ((char *)0);
}
}
#line 602 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int dev_jstfm_kind(struct font_entry *fe ) 
{ 


  {
#line 605
  return (mf_kind[((*((struct jstfmfntinfo **)(& fe->finfo)))->js_bf)->bf_font_kind]);
}
}
#line 608 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int dev_is_jfm(struct font_entry *fe , int tfmmode ) 
{ 
  struct bifont *bi ;

  {
  {
#line 614
  bi = findbkjfm(fe->n);
  }
#line 614
  if ((unsigned long )bi == (unsigned long )((void *)0)) {
#line 615
    if (tfmmode & 8) {
#line 616
      bi = & selfbifont;
    } else {
#line 618
      return (0);
    }
  }
#line 620
  (*((struct biaccessinfo **)(& fe->finfo)))->bf = bi;
#line 621
  if ((int )bi->bf_font_kind == 1) {
#line 622
    usespsmod = 1;
  } else
#line 621
  if ((unsigned long )bi->bf_psmod != (unsigned long )((void *)0)) {
#line 622
    usespsmod = 1;
  }
#line 623
  return (1);
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int dev_jfm_kind(struct font_entry *fe ) 
{ 


  {
#line 629
  return (mf_kind[((*((struct jfmfntinfo **)(& fe->finfo)))->jfm_bf)->bf_font_kind]);
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int bifpos_relun(struct bifont *bf ) 
{ 
  int tmp ;

  {
#line 636
  if ((int )bf->bf_mode_pos == 1) {
#line 636
    tmp = 1;
  } else
#line 636
  if ((int )bf->bf_mode_pos == 3) {
#line 636
    tmp = 1;
  } else {
#line 636
    tmp = 0;
  }
#line 636
  return (tmp);
}
}
#line 640 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int bifpos_rel(struct bifont *bf ) 
{ 


  {
#line 643
  return ((int )bf->bf_mode_pos == 1);
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int bif_coding(struct bifont *bf ) 
{ 


  {
#line 649
  return ((int )bf->bf_coding);
}
}
#line 655
char *newbifontname(void) ;
#line 655 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
static int bifcount  =    0;
#line 656 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
static char newbifname[257]  ;
#line 652 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
char *newbifontname(void) 
{ 
  int tmp ;

  {
  {
#line 658
  tmp = bifcount;
#line 658
  bifcount ++;
#line 658
  sprintf((char */* __restrict  */)(newbifname), (char const   */* __restrict  */)"bf%d",
          tmp);
  }
#line 659
  return (newbifname);
}
}
#line 662 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
char *newbifont(struct bifont *bf ) 
{ 
  char *nbf ;

  {
#line 668
  if ((int )bf->bf_font_kind == 1) {
    {
#line 669
    nbf = newbifontname();
#line 669
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/%s %s\n",
            nbf, bf->bf_psfont);
#line 670
    bf->bf_psfont = strsave(nbf);
#line 671
    bf->bf_font_kind = (char)0;
    }
  }
#line 673
  return (bf->bf_psfont);
}
}
#line 676 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
struct __anonstruct_pops_29 pops[7]  = {      {(char *)"BFT", 0}, 
        {(char *)"BFE", 0}, 
        {(char *)"BFE", 0}, 
        {(char *)"BFF", 1}, 
        {(char *)"BFF", 1}, 
        {(char *)"BFE", 0}, 
        {(char *)"BFE", 0}};
#line 689 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int get_tfm_psbiops(struct font_entry *fe , struct psbiops *po___0 ) 
{ 
  struct tfmfntinfo *tfmfi ;
  struct bifont *bf ;

  {
#line 696
  tfmfi = *((struct tfmfntinfo **)(& fe->finfo));
#line 697
  bf = tfmfi->tfm_bf;
  {
#line 699
  if ((int )bf->bf_mode_font == 0) {
#line 699
    goto case_0;
  }
#line 702
  if ((int )bf->bf_mode_font == 1) {
#line 702
    goto case_1;
  }
#line 705
  if ((int )bf->bf_mode_font == 2) {
#line 705
    goto case_2;
  }
#line 708
  if ((int )bf->bf_mode_font == 3) {
#line 708
    goto case_3;
  }
#line 713
  if ((int )bf->bf_mode_font == 4) {
#line 713
    goto case_4;
  }
#line 718
  if ((int )bf->bf_mode_font == 5) {
#line 718
    goto case_5;
  }
#line 721
  if ((int )bf->bf_mode_font == 6) {
#line 721
    goto case_6;
  }
#line 698
  goto switch_break;
  case_0: /* CIL Label */ 
#line 700
  po___0->po_size = fe->s;
#line 701
  goto switch_break;
  case_1: /* CIL Label */ 
#line 703
  po___0->po_size = tfmfi->ch[tfmfi->lastfntchar].tfmw;
#line 704
  goto switch_break;
  case_2: /* CIL Label */ 
#line 706
  po___0->po_size = tfmfi->ch[bf->bf_stand].tfmw;
#line 707
  goto switch_break;
  case_3: /* CIL Label */ 
#line 709
  po___0->po_size = tfmfi->ch[32].tfmw;
#line 710
  po___0->po_stand = 32;
#line 711
  po___0->po_stlen = (char)1;
#line 712
  goto switch_break;
  case_4: /* CIL Label */ 
#line 714
  po___0->po_size = tfmfi->ch[bf->bf_stand].tfmw;
#line 715
  po___0->po_stand = bf->bf_stand;
#line 716
  po___0->po_stlen = (char)1;
#line 717
  goto switch_break;
  case_5: /* CIL Label */ 
#line 719
  po___0->po_size = tfmfi->em;
#line 720
  goto switch_break;
  case_6: /* CIL Label */ 
#line 722
  po___0->po_size = (int )(((SCALED )bf->bf_scale * (SCALED )fe->s) / (SCALED )(1 << 20));
#line 723
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 725
  if ((unsigned long )bf == (unsigned long )(& selfbifont)) {
#line 726
    po___0->po_dev_name = fe->n;
  } else {
#line 728
    po___0->po_dev_name = (char *)((void *)0);
#line 729
    po___0->po_bf = bf;
  }
#line 731
  po___0->po_mode_font = bf->bf_mode_font;
#line 732
  return (0);
}
}
#line 734 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int get_jstfm_psbiops(struct font_entry *fe , struct psbiops *po___0 ) 
{ 
  struct jstfmfntinfo *jstfmfi ;
  struct bifont *bf ;

  {
#line 741
  jstfmfi = *((struct jstfmfntinfo **)(& fe->finfo));
#line 742
  bf = jstfmfi->js_bf;
  {
#line 744
  if ((int )bf->bf_mode_font == 0) {
#line 744
    goto case_0;
  }
#line 747
  if ((int )bf->bf_mode_font == 1) {
#line 747
    goto case_1;
  }
#line 752
  if ((int )bf->bf_mode_font == 2) {
#line 752
    goto case_2;
  }
#line 755
  if ((int )bf->bf_mode_font == 3) {
#line 755
    goto case_3;
  }
#line 760
  if ((int )bf->bf_mode_font == 4) {
#line 760
    goto case_4;
  }
#line 765
  if ((int )bf->bf_mode_font == 5) {
#line 765
    goto case_5;
  }
#line 768
  if ((int )bf->bf_mode_font == 6) {
#line 768
    goto case_6;
  }
#line 743
  goto switch_break;
  case_0: /* CIL Label */ 
#line 745
  po___0->po_size = fe->s;
#line 746
  goto switch_break;
  case_1: /* CIL Label */ 
#line 750
  po___0->po_size = jstfmfi->ch[jstfmfi->lastfntchar].tfmw;
#line 751
  goto switch_break;
  case_2: /* CIL Label */ 
#line 753
  po___0->po_size = jstfmfi->ch[bf->bf_stand].tfmw;
#line 754
  goto switch_break;
  case_3: /* CIL Label */ 
#line 756
  po___0->po_size = jstfmfi->ch[32].tfmw;
#line 757
  po___0->po_stand = 32;
#line 758
  po___0->po_stlen = (char)1;
#line 759
  goto switch_break;
  case_4: /* CIL Label */ 
#line 761
  po___0->po_size = jstfmfi->ch[bf->bf_stand].tfmw;
#line 762
  po___0->po_stand = bf->bf_stand;
#line 763
  po___0->po_stlen = (char)1;
#line 764
  goto switch_break;
  case_5: /* CIL Label */ 
#line 766
  po___0->po_size = jstfmfi->em;
#line 767
  goto switch_break;
  case_6: /* CIL Label */ 
#line 769
  po___0->po_size = (int )(((SCALED )bf->bf_scale * (SCALED )fe->s) / (SCALED )(1 << 20));
#line 770
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 772
  po___0->po_dev_name = (char *)((void *)0);
#line 773
  po___0->po_bf = bf;
#line 774
  po___0->po_mode_font = bf->bf_mode_font;
#line 775
  return (0);
}
}
#line 777 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
char *tmp_psf(struct bifont *bi ) 
{ 


  {
#line 781
  return (bi->bf_psfont);
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int get_jfm_psbiops(struct font_entry *fe , struct psbiops *po___0 ) 
{ 
  struct jfmfntinfo *jfmfi ;
  struct bifont *bf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 791
  jfmfi = *((struct jfmfntinfo **)(& fe->finfo));
#line 792
  bf = jfmfi->jfm_bf;
  {
#line 794
  if ((int )bf->bf_mode_font == 0) {
#line 794
    goto case_0;
  }
#line 797
  if ((int )bf->bf_mode_font == 1) {
#line 797
    goto case_1;
  }
#line 800
  if ((int )bf->bf_mode_font == 2) {
#line 800
    goto case_2;
  }
#line 803
  if ((int )bf->bf_mode_font == 3) {
#line 803
    goto case_3;
  }
#line 808
  if ((int )bf->bf_mode_font == 4) {
#line 808
    goto case_4;
  }
#line 813
  if ((int )bf->bf_mode_font == 5) {
#line 813
    goto case_5;
  }
#line 816
  if ((int )bf->bf_mode_font == 6) {
#line 816
    goto case_6;
  }
#line 793
  goto switch_break;
  case_0: /* CIL Label */ 
#line 795
  po___0->po_size = fe->s;
#line 796
  goto switch_break;
  case_1: /* CIL Label */ 
#line 798
  po___0->po_size = (jfmfi->ch + 0)->tfmw;
#line 799
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 801
  tmp = getctype(bf->bf_stand, jfmfi);
#line 801
  po___0->po_size = (jfmfi->ch + tmp)->tfmw;
  }
#line 802
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 804
  tmp___0 = getctype(8481, jfmfi);
#line 804
  po___0->po_size = (jfmfi->ch + tmp___0)->tfmw;
#line 805
  po___0->po_stand = 8481;
#line 806
  po___0->po_stlen = (char)2;
  }
#line 807
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 809
  tmp___1 = getctype(bf->bf_stand, jfmfi);
#line 809
  po___0->po_size = (jfmfi->ch + tmp___1)->tfmw;
#line 810
  po___0->po_stand = bf->bf_stand;
#line 811
  po___0->po_stlen = (char)2;
  }
#line 812
  goto switch_break;
  case_5: /* CIL Label */ 
#line 814
  po___0->po_size = jfmfi->em;
#line 815
  goto switch_break;
  case_6: /* CIL Label */ 
#line 817
  po___0->po_size = (int )(((SCALED )bf->bf_scale * (SCALED )fe->s) / (SCALED )(1 << 20));
#line 818
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 820
  if ((unsigned long )bf == (unsigned long )(& selfbifont)) {
#line 821
    po___0->po_dev_name = fe->n;
  } else {
#line 823
    po___0->po_dev_name = (char *)((void *)0);
#line 824
    po___0->po_bf = bf;
  }
#line 826
  po___0->po_mode_font = bf->bf_mode_font;
#line 827
  return (0);
}
}
#line 829 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int psgetfontsize(struct psbiops *po___0 ) 
{ 


  {
#line 832
  return (po___0->po_size);
}
}
#line 841
int psfindfop(char *psfn , struct psbiops *po___0 ) ;
#line 835 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int psfindfontop(char *psfn , struct psbiops *po___0 ) 
{ 


  {
#line 839
  if ((unsigned long )po___0->po_dev_name == (unsigned long )((void *)0)) {
    {
#line 840
    po___0->po_dev_name = newbifont(po___0->po_bf);
    }
  }
  {
#line 841
  psfindfop(psfn, po___0);
  }
#line 842
  return (0);
}
}
#line 844 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int psfindsubfop(char *psfn , struct psbiops *po___0 ) 
{ 
  struct bifont *bf ;
  char psprog[1024] ;
  char *tmp ;

  {
#line 851
  bf = po___0->po_bf;
#line 852
  if ((unsigned long )bf->bf_psmod != (unsigned long )((void *)0)) {
    {
#line 853
    bipave(psprog, bf->bf_psmod, po___0->po_dev_name);
#line 854
    tmp = newbifontname();
#line 854
    po___0->po_dev_name = tmp;
#line 854
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/%s %s\n",
            tmp, psprog);
    }
  }
  {
#line 856
  psfindfop(psfn, po___0);
  }
#line 857
  return (0);
}
}
#line 859 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int psfindfop(char *psfn , struct psbiops *po___0 ) 
{ 


  {
#line 863
  if (pops[po___0->po_mode_font].extraarg) {
    {
#line 864
    codetopsstr(po___0->po_stand, (int )po___0->po_stlen);
    }
  }
  {
#line 865
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/%s /%s %.3f %.3f %s\n",
          psfn, po___0->po_dev_name, (double )((float )po___0->po_size / (float )hconv),
          (double )(- ((float )po___0->po_size) / (float )vconv), pops[po___0->po_mode_font].opname);
  }
#line 868
  return (0);
}
}
#line 870 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/psbi.c"
int getpd(struct pd *pd___0 ) 
{ 
  int tmp ;

  {
#line 873
  tmp = pd___0->pd_char;
#line 873
  (pd___0->pd_char) ++;
#line 873
  if (tmp == 31) {
    {
#line 874
    pd___0->pd_font = dev_newdevfont();
#line 875
    pd___0->pd_char = 32;
    }
#line 876
    return (1);
  } else
#line 877
  if (pd___0->pd_char == 256) {
#line 878
    pd___0->pd_char = 0;
  }
#line 879
  return (0);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/set.c"
void MarkChar(int c ) 
{ 


  {
  {
#line 11
  (*(curfontent->dev_setchar))(c);
  }
#line 12
  return;
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/set.c"
void MarkString(int firstch ) 
{ 
  int c ;

  {
#line 20
  c = firstch;
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    if (c >= 0) {
#line 20
      if (! (c <= 127)) {
#line 20
        goto while_break;
      }
    } else {
#line 20
      goto while_break;
    }
    {
#line 21
    (*(curfontent->dev_setchar))(c);
#line 22
    c = (*dc_getcommand)();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 24
  (*dc_backupone)();
  }
#line 25
  return;
}
}
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 538
extern int getchar(void) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 620 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/global.h"
void AbortRun(int code ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/run.c"
static BOOLEAN stdindvi  =    0;
#line 9 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/run.c"
void sigabort(int sig ) 
{ 


  {
  {
#line 13
  AbortRun(2);
  }
#line 14
  return;
}
}
#line 182
int usage(char c ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/run.c"
void init_settings(int argc , char **argv , char *fontdescfile___0 ) 
{ 
  int argind ;
  int argdvi ;
  int nff ;
  char curname[1024] ;
  char *outfile ;
  char *tcp ;
  char *tcp1 ;
  char *tmp ;
  int fd ;
  int ch ;
  char prfontdesc[257] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;

  {
#line 27
  nff = 0;
#line 29
  outfile = (char *)((void *)0);
#line 32
  fd = -1;
#line 37
  argind = 1;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (argind < argc)) {
#line 37
      goto while_break;
    }
#line 38
    tcp = *(argv + argind);
#line 39
    if ((int )*tcp == 45) {
#line 40
      tcp ++;
      {
#line 42
      if ((int )*tcp == 68) {
#line 42
        goto case_68;
      }
#line 52
      if ((int )*tcp == 69) {
#line 52
        goto case_69;
      }
#line 56
      if ((int )*tcp == 70) {
#line 56
        goto case_70;
      }
#line 62
      if ((int )*tcp == 75) {
#line 62
        goto case_75;
      }
#line 70
      if ((int )*tcp == 80) {
#line 70
        goto case_80;
      }
#line 76
      if ((int )*tcp == 82) {
#line 76
        goto case_82;
      }
#line 81
      if ((int )*tcp == 83) {
#line 81
        goto case_83;
      }
#line 85
      if ((int )*tcp == 99) {
#line 85
        goto case_99;
      }
#line 91
      if ((int )*tcp == 100) {
#line 91
        goto case_100;
      }
#line 98
      if ((int )*tcp == 102) {
#line 98
        goto case_102;
      }
#line 104
      if ((int )*tcp == 105) {
#line 104
        goto case_105;
      }
#line 109
      if ((int )*tcp == 106) {
#line 109
        goto case_106;
      }
#line 114
      if ((int )*tcp == 109) {
#line 114
        goto case_109;
      }
#line 133
      if ((int )*tcp == 110) {
#line 133
        goto case_110;
      }
#line 139
      if ((int )*tcp == 111) {
#line 139
        goto case_111;
      }
#line 153
      if ((int )*tcp == 113) {
#line 153
        goto case_113;
      }
#line 157
      if ((int )*tcp == 114) {
#line 157
        goto case_114;
      }
#line 161
      if ((int )*tcp == 115) {
#line 161
        goto case_115;
      }
#line 166
      if ((int )*tcp == 116) {
#line 166
        goto case_116;
      }
#line 172
      if ((int )*tcp == 118) {
#line 172
        goto case_118;
      }
#line 177
      if ((int )*tcp == 119) {
#line 177
        goto case_119;
      }
#line 181
      goto switch_default___0;
      case_68: /* CIL Label */ 
#line 43
      tcp ++;
#line 43
      if (! ((int )*tcp != 0)) {
#line 45
        argind ++;
#line 45
        if (argind >= argc) {
          {
#line 46
          Fatal("No argument following -D\n");
          }
        } else {
#line 48
          tcp = *(argv + argind);
        }
      }
      {
#line 49
      arg_define(tcp);
      }
#line 50
      goto switch_break;
      case_69: /* CIL Label */ 
#line 53
      if (epsf) {
#line 53
        epsf = 0;
      } else {
#line 53
        epsf = 1;
      }
#line 54
      goto switch_break;
      case_70: /* CIL Label */ 
#line 57
      argind ++;
#line 57
      if (argind >= argc) {
        {
#line 58
        Fatal("No argument following -F\n");
        }
      }
#line 59
      nff ++;
#line 60
      goto switch_break;
      case_75: /* CIL Label */ 
#line 63
      if (G_removecomments) {
#line 63
        G_removecomments = 0;
      } else {
#line 63
        G_removecomments = 1;
      }
#line 64
      goto switch_break;
      case_80: /* CIL Label */ 
#line 71
      tcp ++;
#line 71
      if ((int )*tcp == 0) {
#line 71
        argind ++;
#line 71
        if (argind >= argc) {
          {
#line 72
          Fatal("No argument following -P\n");
          }
        }
      }
#line 73
      nff ++;
#line 74
      goto switch_break;
      case_82: /* CIL Label */ 
#line 77
      tcp ++;
#line 77
      if ((int )*tcp == 0) {
#line 77
        argind ++;
#line 77
        if (argind >= argc) {
          {
#line 78
          Fatal("No argument following -R\n");
          }
        }
      }
#line 79
      goto switch_break;
      case_83: /* CIL Label */ 
#line 82
      if (Stats) {
#line 82
        Stats = 0;
      } else {
#line 82
        Stats = 1;
      }
#line 83
      goto switch_break;
      case_99: /* CIL Label */ 
#line 86
      argind ++;
#line 86
      if (argind >= argc) {
        {
#line 87
        Fatal("No argument following -c\n");
        }
      }
#line 88
      outfile = *(argv + argind);
#line 89
      goto switch_break;
      case_100: /* CIL Label */ 
#line 92
      tcp ++;
#line 92
      if ((int )*tcp == 0) {
#line 93
        debug = 1;
      } else {
#line 95
        debug = 2;
      }
#line 96
      goto switch_break;
      case_102: /* CIL Label */ 
#line 99
      argind ++;
#line 99
      if (argind >= argc) {
        {
#line 101
        Fatal("Argument is not a valid integer\n");
        }
      } else {
        {
#line 99
        tmp___0 = sscanf((char const   */* __restrict  */)*(argv + argind), (char const   */* __restrict  */)"%d",
                         & FirstPage);
        }
#line 99
        if (tmp___0 != 1) {
          {
#line 101
          Fatal("Argument is not a valid integer\n");
          }
        }
      }
#line 102
      goto switch_break;
      case_105: /* CIL Label */ 
#line 105
      argind ++;
#line 105
      if (argind >= argc) {
        {
#line 106
        Fatal("No argument following -i\n");
        }
      }
#line 107
      goto switch_break;
      case_106: /* CIL Label */ 
#line 110
      tcp ++;
#line 110
      G_t1part = (int )*tcp != 48;
#line 111
      goto switch_break;
      case_109: /* CIL Label */ 
#line 115
      tcp ++;
      {
#line 117
      if ((int )*tcp == 0) {
#line 117
        goto case_0;
      }
#line 122
      if ((int )*tcp == 48) {
#line 122
        goto case_48;
      }
#line 123
      if ((int )*tcp == 104) {
#line 123
        goto case_104;
      }
#line 124
      if ((int )*tcp == 49) {
#line 124
        goto case_49;
      }
#line 125
      if ((int )*tcp == 50) {
#line 125
        goto case_50;
      }
#line 126
      if ((int )*tcp == 51) {
#line 126
        goto case_51;
      }
#line 127
      if ((int )*tcp == 52) {
#line 127
        goto case_52;
      }
#line 128
      if ((int )*tcp == 53) {
#line 128
        goto case_53;
      }
#line 129
      goto switch_default;
      case_0: /* CIL Label */ 
#line 118
      argind ++;
#line 118
      if (argind >= argc) {
        {
#line 120
        Fatal("Argument is not a valid integer\n", 0);
        }
      } else {
        {
#line 118
        tmp___1 = sscanf((char const   */* __restrict  */)*(argv + argind), (char const   */* __restrict  */)"%d",
                         & usermag);
        }
#line 118
        if (tmp___1 != 1) {
          {
#line 120
          Fatal("Argument is not a valid integer\n", 0);
          }
        }
      }
#line 121
      goto switch_break___0;
      case_48: /* CIL Label */ 
#line 122
      usermag = 1000;
#line 122
      goto switch_break___0;
      case_104: /* CIL Label */ 
#line 123
      usermag = 1095;
#line 123
      goto switch_break___0;
      case_49: /* CIL Label */ 
#line 124
      usermag = 1200;
#line 124
      goto switch_break___0;
      case_50: /* CIL Label */ 
#line 125
      usermag = 1440;
#line 125
      goto switch_break___0;
      case_51: /* CIL Label */ 
#line 126
      usermag = 1728;
#line 126
      goto switch_break___0;
      case_52: /* CIL Label */ 
#line 127
      usermag = 2074;
#line 127
      goto switch_break___0;
      case_53: /* CIL Label */ 
#line 128
      usermag = 2488;
#line 128
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 129
      Fatal("%c is a bad mag step\n", (int )*tcp);
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 131
      goto switch_break;
      case_110: /* CIL Label */ 
#line 134
      argind ++;
#line 134
      if (argind >= argc) {
        {
#line 136
        Fatal("Argument is not a valid integer\n");
        }
      } else {
        {
#line 134
        tmp___2 = sscanf((char const   */* __restrict  */)*(argv + argind), (char const   */* __restrict  */)"%d",
                         & ncopies);
        }
#line 134
        if (tmp___2 != 1) {
          {
#line 136
          Fatal("Argument is not a valid integer\n");
          }
        }
      }
#line 137
      goto switch_break;
      case_111: /* CIL Label */ 
#line 140
      argind ++;
#line 140
      if (argind >= argc) {
        {
#line 141
        Fatal("No argument following -o\n");
        }
      }
      {
#line 142
      dev_arg('o', *(argv + argind));
      }
#line 143
      goto switch_break;
      case_113: /* CIL Label */ 
#line 154
      if (G_quiet) {
#line 154
        G_quiet = 0;
      } else {
#line 154
        G_quiet = 1;
      }
#line 155
      goto switch_break;
      case_114: /* CIL Label */ 
#line 158
      if (Reverse) {
#line 158
        Reverse = 0;
      } else {
#line 158
        Reverse = 1;
      }
#line 159
      goto switch_break;
      case_115: /* CIL Label */ 
#line 162
      argind ++;
#line 162
      if (argind >= argc) {
        {
#line 163
        Fatal("No argument following -s\n");
        }
      }
#line 164
      goto switch_break;
      case_116: /* CIL Label */ 
#line 167
      argind ++;
#line 167
      if (argind >= argc) {
        {
#line 169
        Fatal("Argument is not a valid integer\n");
        }
      } else {
        {
#line 167
        tmp___3 = sscanf((char const   */* __restrict  */)*(argv + argind), (char const   */* __restrict  */)"%d",
                         & LastPage);
        }
#line 167
        if (tmp___3 != 1) {
          {
#line 169
          Fatal("Argument is not a valid integer\n");
          }
        }
      }
#line 170
      goto switch_break;
      case_118: /* CIL Label */ 
      {
#line 173
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              version);
#line 174
      AbortRun(0);
      }
#line 175
      goto switch_break;
      case_119: /* CIL Label */ 
#line 178
      if (G_nowarn) {
#line 178
        G_nowarn = 0;
      } else {
#line 178
        G_nowarn = 1;
      }
#line 179
      goto switch_break;
      switch_default___0: /* CIL Label */ 
      {
#line 182
      usage((int )*tcp);
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 185
      goto while_break;
    }
#line 37
    argind ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  if (argind < argc) {
    {
#line 190
    tcp = strrchr((char const   *)*(argv + argind), '/');
    }
#line 191
    if ((unsigned long )tcp == (unsigned long )((void *)0)) {
#line 192
      dvidirpath[0] = (char )'\000';
#line 193
      tcp = *(argv + argind);
    } else {
      {
#line 195
      tmp___4 = strlen((char const   *)*(argv + argind));
      }
#line 195
      if (tmp___4 + 1UL >= 1024UL) {
        {
#line 196
        Fatal("DVI file name \"%s\" too long", *(argv + argind));
        }
      }
      {
#line 197
      strcpy((char */* __restrict  */)(dvidirpath), (char const   */* __restrict  */)*(argv + argind));
#line 198
      dvidirpath[(tcp - *(argv + argind)) + 1L] = (char )'\000';
#line 199
      tcp ++;
      }
    }
    {
#line 202
    tmp___5 = strlen((char const   *)tcp);
    }
#line 202
    if ((tmp___5 + 4UL) + 1UL >= 1024UL) {
      {
#line 203
      Fatal("DVI file name \"%s\" too long", tcp);
      }
    }
    {
#line 204
    strcpy((char */* __restrict  */)(curname), (char const   */* __restrict  */)tcp);
#line 205
    tcp1 = strrchr((char const   *)tcp, '.');
    }
#line 206
    if ((unsigned long )tcp1 == (unsigned long )((void *)0)) {
      {
#line 207
      strcat((char */* __restrict  */)(curname), (char const   */* __restrict  */)".dvi");
      }
    } else {
#line 209
      *tcp1 = (char )'.';
    }
    {
#line 211
    tmp___6 = strlen((char const   *)(dvidirpath));
#line 211
    tmp___7 = strlen((char const   *)(curname));
    }
#line 211
    if ((tmp___6 + tmp___7) + 1UL >= 1024UL) {
      {
#line 212
      Fatal("DVI file path \"%s%s\" too long", dvidirpath, curname);
      }
    }
    {
#line 213
    strcpy((char */* __restrict  */)(dvifilename), (char const   */* __restrict  */)(dvidirpath));
#line 214
    strcat((char */* __restrict  */)(dvifilename), (char const   */* __restrict  */)(curname));
#line 215
    dvifp = fopen((char const   */* __restrict  */)(dvifilename), (char const   */* __restrict  */)"r");
    }
#line 215
    if ((unsigned long )dvifp == (unsigned long )((void *)0)) {
      {
#line 216
      Fatal("can\'t find DVI file \"%s\"", dvifilename);
      }
    }
  } else {
    {
#line 219
    dvidirpath[0] = (char )'\000';
#line 221
    tmp = getenv("TMP");
    }
#line 221
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 221
      tmp = getenv("TEMP");
      }
#line 221
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 223
        tmp = (char *)"/tmp/";
      }
    }
    {
#line 224
    tmp___8 = strlen((char const   *)tmp);
#line 224
    tmp___9 = strlen("DVI2PS-XXXXXX");
    }
#line 224
    if ((tmp___8 + tmp___9) + 1UL >= 1024UL) {
      {
#line 225
      Fatal("DVI file name for stdin too long");
      }
    }
    {
#line 226
    strcpy((char */* __restrict  */)(dvifilename), (char const   */* __restrict  */)tmp);
#line 227
    strcat((char */* __restrict  */)(dvifilename), (char const   */* __restrict  */)"DVI2PS-XXXXXX");
#line 229
    fd = mkstemp(dvifilename);
    }
#line 229
    if (fd == -1) {
#line 229
      goto _L;
    } else {
      {
#line 229
      dvifp = fdopen(fd, "w+");
      }
#line 229
      if ((unsigned long )dvifp == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 231
        if (fd != -1) {
          {
#line 232
          unlink((char const   *)(dvifilename));
#line 233
          close(fd);
          }
        }
        {
#line 235
        Fatal("can\'t create DVI file for stdin");
        }
      }
    }
    {
#line 242
    stdindvi = 1;
#line 244
    signal(1, & sigabort);
#line 245
    signal(2, & sigabort);
    }
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 252
      tmp___10 = ferror(stdin);
      }
#line 252
      if (tmp___10) {
#line 252
        goto while_break___0;
      } else {
        {
#line 252
        ch = getchar();
        }
#line 252
        if (! (ch != -1)) {
#line 252
          goto while_break___0;
        }
      }
      {
#line 253
      _IO_putc(ch, dvifp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 254
    tmp___11 = ferror(stdin);
    }
#line 254
    if (tmp___11) {
      {
#line 255
      Fatal("can\'t input DVI from stdin");
      }
    }
    {
#line 256
    fseek(dvifp, 0L, 0);
    }
  }
  {
#line 262
  default_def();
#line 264
  tmp___12 = strlen((char const   *)fontdescfile___0);
  }
#line 264
  if ((tmp___12 + 2UL) + 1UL >= 257UL) {
    {
#line 265
    Fatal("fontdesc name \"%s\" too long", fontdescfile___0);
    }
  }
  {
#line 266
  sprintf((char */* __restrict  */)(prfontdesc), (char const   */* __restrict  */)"%s.0",
          fontdescfile___0);
#line 267
  read_fontdesc(prfontdesc, 1);
  }
#line 268
  if (nff == 0) {
    {
#line 269
    read_fontdesc(fontdescfile___0, 1);
    }
  }
#line 270
  argdvi = argind;
#line 271
  argind = 1;
  {
#line 271
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 271
    if (! (argind < argdvi)) {
#line 271
      goto while_break___1;
    }
    {
#line 273
    if ((int )*(*(argv + argind) + 1) == 68) {
#line 273
      goto case_68___0;
    }
#line 277
    if ((int )*(*(argv + argind) + 1) == 70) {
#line 277
      goto case_70___0;
    }
#line 280
    if ((int )*(*(argv + argind) + 1) == 80) {
#line 280
      goto case_80___0;
    }
#line 291
    if ((int )*(*(argv + argind) + 1) == 82) {
#line 291
      goto case_82___0;
    }
#line 298
    if ((int )*(*(argv + argind) + 1) == 105) {
#line 298
      goto case_105___0;
    }
#line 301
    if ((int )*(*(argv + argind) + 1) == 115) {
#line 301
      goto case_115___0;
    }
#line 304
    if ((int )*(*(argv + argind) + 1) == 116) {
#line 304
      goto case_116___0;
    }
#line 304
    if ((int )*(*(argv + argind) + 1) == 111) {
#line 304
      goto case_116___0;
    }
#line 304
    if ((int )*(*(argv + argind) + 1) == 110) {
#line 304
      goto case_116___0;
    }
#line 304
    if ((int )*(*(argv + argind) + 1) == 102) {
#line 304
      goto case_116___0;
    }
#line 304
    if ((int )*(*(argv + argind) + 1) == 99) {
#line 304
      goto case_116___0;
    }
#line 272
    goto switch_break___1;
    case_68___0: /* CIL Label */ 
#line 274
    if ((int )*(*(argv + argind) + 2) == 0) {
#line 275
      argind ++;
    }
#line 276
    goto switch_break___1;
    case_70___0: /* CIL Label */ 
    {
#line 278
    argind ++;
#line 278
    arg_fontdesc(*(argv + argind));
    }
#line 279
    goto switch_break___1;
    case_80___0: /* CIL Label */ 
#line 281
    if ((int )*(*(argv + argind) + 2) != 0) {
#line 282
      tcp = *(argv + argind) + 2;
    } else {
#line 284
      argind ++;
#line 284
      tcp = *(argv + argind);
    }
    {
#line 285
    tmp___13 = strlen((char const   *)fontdescfile___0);
#line 285
    tmp___14 = strlen((char const   *)tcp);
    }
#line 285
    if (((tmp___13 + 1UL) + tmp___14) + 1UL >= 257UL) {
      {
#line 286
      Fatal("fontdesc name \"%s.%s\" too long", fontdescfile___0, tcp);
      }
    }
    {
#line 288
    sprintf((char */* __restrict  */)(prfontdesc), (char const   */* __restrict  */)"%s.%s",
            fontdescfile___0, tcp);
#line 289
    arg_fontdesc(prfontdesc);
    }
#line 290
    goto switch_break___1;
    case_82___0: /* CIL Label */ 
#line 292
    if ((int )*(*(argv + argind) + 2) != 0) {
#line 293
      tcp = *(argv + argind) + 2;
    } else {
#line 295
      argind ++;
#line 295
      tcp = *(argv + argind);
    }
    {
#line 296
    set_resolution(tcp);
    }
#line 297
    goto switch_break___1;
    case_105___0: /* CIL Label */ 
    {
#line 299
    argind ++;
#line 299
    add_include(*(argv + argind), 1);
    }
#line 300
    goto switch_break___1;
    case_115___0: /* CIL Label */ 
    {
#line 302
    argind ++;
#line 302
    add_setup(*(argv + argind), 1);
    }
#line 303
    goto switch_break___1;
    case_116___0: /* CIL Label */ 
    case_111___0: /* CIL Label */ 
    case_110___0: /* CIL Label */ 
    case_102___0: /* CIL Label */ 
    case_99___0: /* CIL Label */ 
#line 305
    argind ++;
#line 306
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 271
    argind ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 309
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
#line 310
    outfp = stdout;
  } else {
    {
#line 311
    outfp = fopen((char const   */* __restrict  */)outfile, (char const   */* __restrict  */)"w+");
    }
#line 311
    if ((unsigned long )outfp == (unsigned long )((void *)0)) {
      {
#line 312
      Fatal("can\'t write to output file \"%s\"", outfile);
      }
    }
  }
#line 313
  return;
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/run.c"
int usage(char c ) 
{ 


  {
  {
#line 318
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c is not a legal flag\n",
          (int )c);
#line 319
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s %s\n\t%s\n\t%s\n\t%s\n\t%s\n",
          G_progname, "[-D var=val] [-E] [-F fontdesc] [-K] [-Ppr]", "[-R resolution] [-S]",
          "[-c psfile] [-d] [-f n] [-i file]", "[-m{0|h|1|2|3|4|5}] [-m mag] [-n n]",
          "[-o option] [-q] [-r] [-s file] [-t n] [-v] [-w]", "[dvifile]");
#line 327
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          version);
#line 328
  AbortRun(2);
  }
#line 329
  return (0);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/run.c"
void AbortRun(int code ) 
{ 


  {
#line 341
  if (stdindvi) {
    {
#line 342
    unlink((char const   *)(dvifilename));
    }
  }
  {
#line 343
  exit(code);
  }
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/run.c"
void AllDone(void) 
{ 
  struct font_entry *p ;
  int tmp ;

  {
#line 357
  if (! G_quiet) {
    {
#line 358
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 361
  if (Stats) {
    {
#line 362
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Total chars   diff chars   raster bytes\n");
#line 363
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      #   %%        #   %%       #   %%\n");
#line 364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"------- ---   ------ ---   ----- ---\n");
#line 365
    p = hdfontent;
    }
    {
#line 365
    while (1) {
      while_continue: /* CIL Label */ ;
#line 365
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 365
        goto while_break;
      }
      {
#line 366
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%7d%4d",
              p->ncts, (100 * p->ncts) / Stnc);
      }
#line 367
      if (Sndc != 0) {
        {
#line 368
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%9d%4d",
                p->ncdl, (100 * p->ncdl) / Sndc);
        }
      } else {
        {
#line 370
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%9d  --",
                p->ncdl);
        }
      }
#line 371
      if (Snbpxl != 0) {
        {
#line 372
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%8d%4d",
                p->nbpxl, (100 * p->nbpxl) / Snbpxl);
        }
      } else {
        {
#line 374
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%8d  --",
                p->nbpxl);
        }
      }
      {
#line 375
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s\n",
              p->name);
#line 365
      p = p->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 377
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nTotal number of characters typeset: %d\n",
            Stnc);
#line 378
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Number of different characters downloaded: %d\n",
            Sndc);
#line 379
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Number of bytes of raster data downloaded: %d\n",
            Snbpxl);
#line 380
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Optimal # of bytes of raster data: %d\n",
            Sonbpx);
    }
  }
#line 384
  if (G_errenc) {
#line 384
    tmp = 1;
  } else {
#line 384
    tmp = 0;
  }
  {
#line 384
  AbortRun(tmp);
  }
#line 385
  return;
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/run.c"
void Fatal(char *fmt , char *a , char *b , char *c ) 
{ 


  {
  {
#line 398
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 399
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: FATAL-- ",
          G_progname);
#line 400
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt, a,
          b, c);
#line 401
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\n");
#line 402
  AbortRun(2);
  }
#line 403
  return;
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/run.c"
void Warning(char *fmt , char *a , char *b , char *c ) 
{ 


  {
#line 416
  G_errenc = 1;
#line 417
  if (G_nowarn) {
#line 418
    return;
  }
  {
#line 419
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt, a,
          b, c);
#line 420
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 421
  return;
}
}
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char *cur_file_name  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char *cur_enc_name  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static unsigned char *grid  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char *ext_glyph_names[256]  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static int hexline_length  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char notdef[8]  = 
#line 89
  {      (char )'.',      (char )'n',      (char )'o',      (char )'t', 
        (char )'d',      (char )'e',      (char )'f',      (char )'\000'};
#line 108 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char *standard_glyph_names[256]  = 
#line 108
  {      notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        (char *)"space",      (char *)"exclam",      (char *)"quotedbl",      (char *)"numbersign", 
        (char *)"dollar",      (char *)"percent",      (char *)"ampersand",      (char *)"quoteright", 
        (char *)"parenleft",      (char *)"parenright",      (char *)"asterisk",      (char *)"plus", 
        (char *)"comma",      (char *)"hyphen",      (char *)"period",      (char *)"slash", 
        (char *)"zero",      (char *)"one",      (char *)"two",      (char *)"three", 
        (char *)"four",      (char *)"five",      (char *)"six",      (char *)"seven", 
        (char *)"eight",      (char *)"nine",      (char *)"colon",      (char *)"semicolon", 
        (char *)"less",      (char *)"equal",      (char *)"greater",      (char *)"question", 
        (char *)"at",      (char *)"A",      (char *)"B",      (char *)"C", 
        (char *)"D",      (char *)"E",      (char *)"F",      (char *)"G", 
        (char *)"H",      (char *)"I",      (char *)"J",      (char *)"K", 
        (char *)"L",      (char *)"M",      (char *)"N",      (char *)"O", 
        (char *)"P",      (char *)"Q",      (char *)"R",      (char *)"S", 
        (char *)"T",      (char *)"U",      (char *)"V",      (char *)"W", 
        (char *)"X",      (char *)"Y",      (char *)"Z",      (char *)"bracketleft", 
        (char *)"backslash",      (char *)"bracketright",      (char *)"asciicircum",      (char *)"underscore", 
        (char *)"quoteleft",      (char *)"a",      (char *)"b",      (char *)"c", 
        (char *)"d",      (char *)"e",      (char *)"f",      (char *)"g", 
        (char *)"h",      (char *)"i",      (char *)"j",      (char *)"k", 
        (char *)"l",      (char *)"m",      (char *)"n",      (char *)"o", 
        (char *)"p",      (char *)"q",      (char *)"r",      (char *)"s", 
        (char *)"t",      (char *)"u",      (char *)"v",      (char *)"w", 
        (char *)"x",      (char *)"y",      (char *)"z",      (char *)"braceleft", 
        (char *)"bar",      (char *)"braceright",      (char *)"asciitilde",      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      (char *)"exclamdown",      (char *)"cent",      (char *)"sterling", 
        (char *)"fraction",      (char *)"yen",      (char *)"florin",      (char *)"section", 
        (char *)"currency",      (char *)"quotesingle",      (char *)"quotedblleft",      (char *)"guillemotleft", 
        (char *)"guilsinglleft",      (char *)"guilsinglright",      (char *)"fi",      (char *)"fl", 
        notdef,      (char *)"endash",      (char *)"dagger",      (char *)"daggerdbl", 
        (char *)"periodcentered",      notdef,      (char *)"paragraph",      (char *)"bullet", 
        (char *)"quotesinglbase",      (char *)"quotedblbase",      (char *)"quotedblright",      (char *)"guillemotright", 
        (char *)"ellipsis",      (char *)"perthousand",      notdef,      (char *)"questiondown", 
        notdef,      (char *)"grave",      (char *)"acute",      (char *)"circumflex", 
        (char *)"tilde",      (char *)"macron",      (char *)"breve",      (char *)"dotaccent", 
        (char *)"dieresis",      notdef,      (char *)"ring",      (char *)"cedilla", 
        notdef,      (char *)"hungarumlaut",      (char *)"ogonek",      (char *)"caron", 
        (char *)"emdash",      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      (char *)"AE",      notdef,      (char *)"ordfeminine", 
        notdef,      notdef,      notdef,      notdef, 
        (char *)"Lslash",      (char *)"Oslash",      (char *)"OE",      (char *)"ordmasculine", 
        notdef,      notdef,      notdef,      notdef, 
        notdef,      (char *)"ae",      notdef,      notdef, 
        notdef,      (char *)"dotlessi",      notdef,      notdef, 
        (char *)"lslash",      (char *)"oslash",      (char *)"oe",      (char *)"germandbls", 
        notdef,      notdef,      notdef,      notdef};
#line 142 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
char **t1_glyph_names  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
char *t1_builtin_glyph_names[256]  ;
#line 144 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static boolean read_encoding_only  ;
#line 145 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static int t1_encoding  ;
#line 206 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static unsigned short t1_dr  ;
#line 206 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static unsigned short t1_er  ;
#line 207 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static unsigned short t1_c1  =    (unsigned short)52845;
#line 207 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static unsigned short t1_c2  =    (unsigned short)22719;
#line 208 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static unsigned short t1_cslen  ;
#line 208 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static unsigned short t1_lenIV  ;
#line 209 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char t1_line[4096]  ;
#line 209 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char t1_buf[4096]  ;
#line 209 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char *t1_line_ptr  ;
#line 210 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char enc_line[1024]  ;
#line 212 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char *cs_start___0  ;
#line 214 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static cs_entry *cs_tab  ;
#line 214 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static cs_entry *cs_ptr  ;
#line 214 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static cs_entry *cs_notdef  ;
#line 215 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char *cs_dict_start  ;
#line 215 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char *cs_dict_end  ;
#line 216 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static int cs_count  ;
#line 216 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static int cs_size  ;
#line 216 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static int cs_size_pos  ;
#line 218 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static cs_entry *subr_tab  ;
#line 219 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char *subr_array_start  ;
#line 219 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char *subr_array_end  ;
#line 220 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static int subr_max  ;
#line 220 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static int subr_size  ;
#line 220 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static int subr_size_pos  ;
#line 222 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static boolean t1_pfa  ;
#line 222 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static boolean t1_cs  ;
#line 222 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static boolean t1_scan  ;
#line 222 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static boolean t1_eexec_encrypt  ;
#line 222 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static boolean t1_synthetic  ;
#line 223 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static int t1_in_eexec  ;
#line 224 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static long t1_block_length  ;
#line 225 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static int last_hexbyte  ;
#line 226 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static FILE *t1_file  ;
#line 227 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static FILE *enc_file  ;
#line 267
static void pdftex_fail(char *fmt , char *a , char *b , char *c ) ;
#line 268
static void pdftex_warn(char *fmt , char *a , char *b , char *c ) ;
#line 273 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void end_hexline(void) 
{ 


  {
#line 275
  if (hexline_length == 64) {
    {
#line 276
    fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)outfp);
#line 277
    hexline_length = 0;
    }
  }
#line 279
  return;
}
}
#line 283
static void t1_outhex(byte b ) ;
#line 283 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char *hexdigits  =    (char *)"0123456789ABCDEF";
#line 281 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_outhex(byte b ) 
{ 


  {
  {
#line 284
  fputc((int )*(hexdigits + (int )b / 16), outfp);
#line 285
  fputc((int )*(hexdigits + (int )b % 16), outfp);
#line 286
  hexline_length += 2;
#line 287
  end_hexline();
  }
#line 288
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void enc_getline(void) 
{ 
  char *p ;
  int c ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  restart: 
  {
#line 296
  tmp = feof(enc_file);
  }
#line 296
  if (tmp) {
    {
#line 297
    pdftex_fail("unexpected end of file");
    }
  }
#line 298
  p = enc_line;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 300
    c = _IO_getc(enc_file);
    }
    {
#line 301
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 301
      if (c == 9) {
#line 301
        c = 32;
      }
#line 301
      if (c == 13) {
#line 301
        c = 10;
      } else
#line 301
      if (c == -1) {
#line 301
        c = 10;
      }
#line 301
      if (c != 32) {
#line 301
        goto _L;
      } else
#line 301
      if ((unsigned long )p > (unsigned long )(enc_line)) {
#line 301
        if ((int )*(p + -1) != 32) {
          _L: /* CIL Label */ 
#line 301
          if (p - enc_line >= 1022L) {
            {
#line 301
            pdftex_fail("buffer overflow [%i bytes]", 1024);
            }
          }
#line 301
          tmp___0 = p;
#line 301
          p ++;
#line 301
          *tmp___0 = (char )c;
        }
      }
#line 301
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 299
    if (! (c != 10)) {
#line 299
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 303
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 303
    if (p - enc_line > 1L) {
#line 303
      if ((int )*(p + -1) != 10) {
#line 303
        if (p - enc_line >= 1022L) {
          {
#line 303
          pdftex_fail("buffer overflow [%i bytes]", 1024);
          }
        }
#line 303
        tmp___1 = p;
#line 303
        p ++;
#line 303
        *tmp___1 = (char)10;
      }
    }
#line 303
    if (p - enc_line > 2L) {
#line 303
      if ((int )*(p + -2) == 32) {
#line 303
        *(p + -2) = (char)10;
#line 303
        p --;
      }
    }
#line 303
    *p = (char)0;
#line 303
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 304
  if (p - enc_line <= 2L) {
#line 305
    goto restart;
  } else
#line 304
  if ((int )enc_line[0] == 37) {
#line 305
    goto restart;
  }
#line 306
  return;
}
}
#line 313
int enc_open(void) ;
#line 308 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
void load_enc(char *enc_name , char **glyph_names ) 
{ 
  char buf[1024] ;
  char *p ;
  char *r___0 ;
  int names_count ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 312
  cur_file_name = enc_name;
#line 313
  tmp = enc_open();
  }
#line 313
  if (! tmp) {
    {
#line 314
    pdftex_warn("cannot open encoding file for reading");
#line 315
    cur_file_name = (char *)0;
    }
#line 316
    return;
  }
  {
#line 320
  enc_getline();
  }
#line 321
  if ((int )enc_line[0] != 47) {
#line 321
    goto _L;
  } else {
    {
#line 321
    r___0 = strchr((char const   *)(enc_line), '[');
    }
#line 321
    if ((unsigned long )r___0 == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 322
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 322
        tmp___0 = strchr((char const   *)(enc_line), 0);
#line 322
        r___0 = tmp___0 - 1;
        }
#line 322
        if ((int )*r___0 == 10) {
#line 322
          *r___0 = (char)0;
        }
#line 322
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 323
      pdftex_fail("invalid encoding vector (a name or `[\' missing): `%s\'", enc_line);
      }
    }
  }
#line 325
  names_count = 0;
#line 326
  r___0 ++;
#line 327
  if ((int )*r___0 == 32) {
#line 327
    r___0 ++;
  }
  {
#line 328
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 329
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 329
      if (! ((int )*r___0 == 47)) {
#line 329
        goto while_break___1;
      }
#line 330
      p = buf;
#line 330
      r___0 ++;
      {
#line 330
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 330
        if ((int )*r___0 != 32) {
#line 330
          if ((int )*r___0 != 10) {
#line 330
            if ((int )*r___0 != 93) {
#line 330
              if (! ((int )*r___0 != 47)) {
#line 330
                goto while_break___2;
              }
            } else {
#line 330
              goto while_break___2;
            }
          } else {
#line 330
            goto while_break___2;
          }
        } else {
#line 330
          goto while_break___2;
        }
#line 330
        tmp___1 = p;
#line 330
        p ++;
#line 330
        tmp___2 = r___0;
#line 330
        r___0 ++;
#line 330
        *tmp___1 = *tmp___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 331
      *p = (char)0;
#line 332
      if ((int )*r___0 == 32) {
#line 332
        r___0 ++;
      }
#line 333
      if (names_count > 255) {
        {
#line 334
        pdftex_fail("encoding vector contains more than %i names", 256);
        }
      }
      {
#line 336
      tmp___3 = strcmp((char const   *)(buf), (char const   *)(notdef));
      }
#line 336
      if (tmp___3 != 0) {
        {
#line 337
        *(glyph_names + names_count) = strdup((char const   *)(buf));
        }
      }
#line 338
      names_count ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 340
    if ((int )*r___0 != 10) {
#line 340
      if ((int )*r___0 != 37) {
        {
#line 341
        tmp___5 = strlen("] def");
#line 341
        tmp___6 = strncmp((char const   *)r___0, "] def", tmp___5);
        }
#line 341
        if (tmp___6 == 0) {
#line 342
          goto done;
        } else {
          {
#line 344
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 344
            tmp___4 = strchr((char const   *)(enc_line), 0);
#line 344
            r___0 = tmp___4 - 1;
            }
#line 344
            if ((int )*r___0 == 10) {
#line 344
              *r___0 = (char)0;
            }
#line 344
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 345
          pdftex_fail("invalid encoding vector: a name or `] def\' expected: `%s\'",
                      enc_line);
          }
        }
      }
    }
    {
#line 348
    enc_getline();
#line 349
    r___0 = enc_line;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  done: 
  {
#line 352
  fclose(enc_file);
#line 354
  cur_file_name = (char *)0;
  }
#line 355
  return;
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_check_pfa(void) 
{ 
  int c ;
  int tmp ;

  {
  {
#line 359
  tmp = _IO_getc(t1_file);
#line 359
  c = tmp;
  }
#line 360
  if (c != 128) {
#line 361
    t1_pfa = (boolean )1;
  } else {
#line 363
    t1_pfa = (boolean )0;
  }
  {
#line 364
  ungetc(c, t1_file);
  }
#line 365
  return;
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static int t1_getbyte(void) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 369
  tmp = _IO_getc(t1_file);
#line 369
  c = tmp;
  }
#line 370
  if (t1_pfa) {
#line 371
    return (c);
  }
#line 372
  if (t1_block_length == 0L) {
#line 373
    if (c != 128) {
      {
#line 374
      pdftex_fail("invalid marker");
      }
    }
    {
#line 375
    c = _IO_getc(t1_file);
    }
#line 376
    if (c == 3) {
#line 377
      return (-1);
    }
    {
#line 378
    tmp___0 = _IO_getc(t1_file);
#line 378
    t1_block_length = (long )(tmp___0 & 255);
#line 379
    tmp___1 = _IO_getc(t1_file);
#line 379
    t1_block_length |= (long )((tmp___1 & 255) << 8);
#line 380
    tmp___2 = _IO_getc(t1_file);
#line 380
    t1_block_length |= (long )((tmp___2 & 255) << 16);
#line 381
    tmp___3 = _IO_getc(t1_file);
#line 381
    t1_block_length |= (long )((tmp___3 & 255) << 24);
#line 382
    c = _IO_getc(t1_file);
    }
  }
#line 384
  t1_block_length --;
#line 385
  return (c);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static int hexval(int c ) 
{ 


  {
#line 390
  if (c >= 65) {
#line 390
    if (c <= 70) {
#line 391
      return ((c - 65) + 10);
    } else {
#line 390
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 392
  if (c >= 97) {
#line 392
    if (c <= 102) {
#line 393
      return ((c - 97) + 10);
    } else {
#line 392
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 394
  if (c >= 48) {
#line 394
    if (c <= 57) {
#line 395
      return (c - 48);
    } else {
#line 397
      return (-1);
    }
  } else {
#line 397
    return (-1);
  }
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static byte edecrypt(byte cipher ) 
{ 
  byte plain ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 403
  if (t1_pfa) {
    {
#line 404
    while (1) {
      while_continue: /* CIL Label */ ;
#line 404
      if (! ((int )cipher == 10)) {
#line 404
        if (! ((int )cipher == 13)) {
#line 404
          goto while_break;
        }
      }
      {
#line 405
      tmp = t1_getbyte();
#line 405
      cipher = (byte )tmp;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 406
    tmp___0 = hexval((int )cipher);
#line 406
    tmp___1 = t1_getbyte();
#line 406
    tmp___2 = hexval(tmp___1);
#line 406
    cipher = (byte )((tmp___0 << 4) + tmp___2);
#line 406
    last_hexbyte = (int )cipher;
    }
  }
#line 408
  plain = (byte )((int )cipher ^ ((int )t1_dr >> 8));
#line 409
  t1_dr = (unsigned short )(((int )cipher + (int )t1_dr) * (int )t1_c1 + (int )t1_c2);
#line 410
  return (plain);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static byte cdecrypt(byte cipher , unsigned short *cr___0 ) 
{ 
  byte plain ;

  {
#line 415
  plain = (byte )((int )cipher ^ ((int )*cr___0 >> 8));
#line 416
  *cr___0 = (unsigned short )(((int )cipher + (int )*cr___0) * (int )t1_c1 + (int )t1_c2);
#line 417
  return (plain);
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static byte eencrypt(byte plain ) 
{ 
  byte cipher ;

  {
#line 422
  cipher = (byte )((int )plain ^ ((int )t1_er >> 8));
#line 423
  t1_er = (unsigned short )(((int )cipher + (int )t1_er) * (int )t1_c1 + (int )t1_c2);
#line 424
  return (cipher);
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char *eol(char *s ) 
{ 
  char *p ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 429
  tmp = strchr((char const   *)s, 0);
#line 429
  p = tmp;
  }
#line 430
  if (p - s > 1L) {
#line 430
    if ((int )*(p + -1) != 10) {
#line 431
      tmp___0 = p;
#line 431
      p ++;
#line 431
      *tmp___0 = (char)10;
#line 432
      *p = (char)0;
    }
  }
#line 434
  return (p);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static boolean t1_suffix(char *s ) 
{ 
  char *s1 ;
  char *s2 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 439
  s1 = t1_line_ptr - 1;
#line 439
  tmp = strchr((char const   *)s, 0);
#line 439
  s2 = tmp - 1;
  }
#line 441
  if ((int )*s1 == 10) {
#line 442
    s1 --;
  }
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    if ((unsigned long )s1 >= (unsigned long )(t1_line)) {
#line 443
      if (! ((unsigned long )s2 >= (unsigned long )s)) {
#line 443
        goto while_break;
      }
    } else {
#line 443
      goto while_break;
    }
#line 444
    tmp___0 = s1;
#line 444
    s1 --;
#line 444
    tmp___1 = s2;
#line 444
    s2 --;
#line 444
    if ((int )*tmp___0 != (int )*tmp___1) {
#line 445
      return ((boolean )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return ((boolean )((unsigned long )s1 >= (unsigned long )(t1_line - 1)));
}
}
#line 454
static void t1_getline(void) ;
#line 454 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static char eexec_str[18]  = 
#line 454
  {      (char )'c',      (char )'u',      (char )'r',      (char )'r', 
        (char )'e',      (char )'n',      (char )'t',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )' ', 
        (char )'e',      (char )'e',      (char )'x',      (char )'e', 
        (char )'c',      (char )'\000'};
#line 455 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static int eexec_len  =    17;
#line 450 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_getline(void) 
{ 
  int c ;
  int l ;
  int eexec_scan ;
  char *p ;
  int tmp ;
  byte tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  byte tmp___4 ;
  int tmp___5 ;
  boolean tmp___6 ;
  boolean tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
  restart: 
  {
#line 457
  tmp = feof(t1_file);
  }
#line 457
  if (tmp) {
    {
#line 458
    pdftex_fail("unexpected end of file");
    }
  }
  {
#line 459
  t1_line_ptr = t1_line;
#line 460
  t1_cslen = (unsigned short)0;
#line 461
  eexec_scan = 0;
#line 462
  c = t1_getbyte();
  }
#line 463
  if (c == -1) {
#line 464
    return;
  }
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 465
    tmp___8 = feof(t1_file);
    }
#line 465
    if (tmp___8) {
#line 465
      goto while_break;
    }
#line 466
    if (t1_in_eexec == 1) {
      {
#line 467
      tmp___0 = edecrypt((byte )c);
#line 467
      c = (int )tmp___0;
      }
    }
    {
#line 468
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 468
      if (c == 9) {
#line 468
        c = 32;
      }
#line 468
      if (c == 13) {
#line 468
        c = 10;
      } else
#line 468
      if (c == -1) {
#line 468
        c = 10;
      }
#line 468
      if (c != 32) {
#line 468
        goto _L;
      } else
#line 468
      if ((unsigned long )t1_line_ptr > (unsigned long )(t1_line)) {
#line 468
        if ((int )*(t1_line_ptr + -1) != 32) {
          _L: /* CIL Label */ 
#line 468
          if (t1_line_ptr - t1_line >= 4094L) {
            {
#line 468
            pdftex_fail("buffer overflow [%i bytes]", 4096);
            }
          }
#line 468
          tmp___1 = t1_line_ptr;
#line 468
          t1_line_ptr ++;
#line 468
          *tmp___1 = (char )c;
        }
      }
#line 468
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 469
    if (t1_in_eexec == 0) {
#line 469
      if (eexec_scan >= 0) {
#line 469
        if (eexec_scan < eexec_len) {
#line 470
          if ((int )t1_line[eexec_scan] == (int )eexec_str[eexec_scan]) {
#line 471
            eexec_scan ++;
          } else {
#line 473
            eexec_scan = -1;
          }
        }
      }
    }
#line 475
    if (c == 10) {
#line 476
      goto while_break;
    } else
#line 475
    if (t1_pfa) {
#line 475
      if (eexec_scan == eexec_len) {
#line 475
        if (c == 32) {
#line 476
          goto while_break;
        }
      }
    }
#line 477
    if (t1_cs) {
#line 477
      if ((int )t1_cslen == 0) {
#line 477
        if (t1_line_ptr - t1_line > 4L) {
          {
#line 477
          tmp___6 = t1_suffix((char *)" RD ");
          }
#line 477
          if (tmp___6) {
#line 477
            goto _L___0;
          } else {
            {
#line 477
            tmp___7 = t1_suffix((char *)" -| ");
            }
#line 477
            if (tmp___7) {
              _L___0: /* CIL Label */ 
#line 481
              p = t1_line_ptr - 5;
              {
#line 482
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 482
                if (! ((int )*p != 32)) {
#line 482
                  goto while_break___1;
                }
#line 483
                p --;
              }
              while_break___1: /* CIL Label */ ;
              }
              {
#line 484
              l = atoi((char const   *)(p + 1));
#line 484
              t1_cslen = (unsigned short )l;
#line 485
              cs_start___0 = t1_line_ptr;
              }
#line 486
              if ((t1_line_ptr - t1_line) + (long )l >= 4094L) {
                {
#line 486
                pdftex_fail("buffer overflow [%i bytes]", 4096);
                }
              }
              {
#line 487
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 487
                tmp___5 = l;
#line 487
                l --;
#line 487
                if (! (tmp___5 > 0)) {
#line 487
                  goto while_break___2;
                }
                {
#line 488
                tmp___2 = t1_line_ptr;
#line 488
                t1_line_ptr ++;
#line 488
                tmp___3 = t1_getbyte();
#line 488
                tmp___4 = edecrypt((byte )tmp___3);
#line 488
                *tmp___2 = (char )tmp___4;
                }
              }
              while_break___2: /* CIL Label */ ;
              }
            }
          }
        }
      }
    }
    {
#line 490
    c = t1_getbyte();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 492
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 492
    if (t1_line_ptr - t1_line > 1L) {
#line 492
      if ((int )*(t1_line_ptr + -1) != 10) {
#line 492
        if (t1_line_ptr - t1_line >= 4094L) {
          {
#line 492
          pdftex_fail("buffer overflow [%i bytes]", 4096);
          }
        }
#line 492
        tmp___9 = t1_line_ptr;
#line 492
        t1_line_ptr ++;
#line 492
        *tmp___9 = (char)10;
      }
    }
#line 492
    if (t1_line_ptr - t1_line > 2L) {
#line 492
      if ((int )*(t1_line_ptr + -2) == 32) {
#line 492
        *(t1_line_ptr + -2) = (char)10;
#line 492
        t1_line_ptr --;
      }
    }
#line 492
    *t1_line_ptr = (char)0;
#line 492
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 493
  if (t1_line_ptr - t1_line <= 1L) {
#line 494
    goto restart;
  }
#line 495
  if (eexec_scan == eexec_len) {
#line 496
    t1_in_eexec = 1;
  }
#line 497
  return;
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_putline(void) 
{ 
  char *p ;
  char *tmp ;
  byte tmp___0 ;
  char *tmp___1 ;

  {
#line 501
  p = t1_line;
#line 502
  if (t1_line_ptr - t1_line <= 1L) {
#line 503
    return;
  }
#line 504
  if (t1_eexec_encrypt) {
    {
#line 505
    while (1) {
      while_continue: /* CIL Label */ ;
#line 505
      if (! ((unsigned long )p < (unsigned long )t1_line_ptr)) {
#line 505
        goto while_break;
      }
      {
#line 506
      tmp = p;
#line 506
      p ++;
#line 506
      tmp___0 = eencrypt((byte )*tmp);
#line 506
      t1_outhex(tmp___0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 508
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 508
      if (! ((unsigned long )p < (unsigned long )t1_line_ptr)) {
#line 508
        goto while_break___0;
      }
      {
#line 509
      tmp___1 = p;
#line 509
      p ++;
#line 509
      fputc((int )*tmp___1, outfp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 510
  return;
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_puts(char *s ) 
{ 


  {
#line 514
  if ((unsigned long )s != (unsigned long )(t1_line)) {
    {
#line 515
    strcpy((char */* __restrict  */)(t1_line), (char const   */* __restrict  */)s);
    }
  }
  {
#line 516
  t1_line_ptr = strchr((char const   *)(t1_line), 0);
#line 517
  t1_putline();
  }
#line 518
  return;
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_printf(char *fmt , char *a , char *b , char *c ) 
{ 


  {
  {
#line 534
  sprintf((char */* __restrict  */)(t1_line), (char const   */* __restrict  */)fmt,
          a, b, c);
#line 535
  t1_puts(t1_line);
  }
#line 536
  return;
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_init_params(char *open_name_prefix ) 
{ 


  {
  {
#line 543
  t1_lenIV = (unsigned short)4;
#line 544
  t1_dr = (unsigned short)55665;
#line 545
  t1_er = (unsigned short)55665;
#line 546
  t1_in_eexec = 0;
#line 547
  t1_cs = (boolean )0;
#line 548
  t1_scan = (boolean )1;
#line 549
  t1_synthetic = (boolean )0;
#line 550
  t1_eexec_encrypt = (boolean )0;
#line 551
  t1_block_length = 0L;
#line 552
  t1_check_pfa();
  }
#line 553
  return;
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_close_font_file(char *close_name_suffix ) 
{ 


  {
  {
#line 558
  fclose(t1_file);
#line 559
  cur_file_name = (char *)0;
  }
#line 560
  return;
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_check_block_len(boolean decrypt ) 
{ 
  int l ;
  int c ;
  byte tmp ;
  int tmp___0 ;

  {
#line 565
  if (t1_block_length == 0L) {
#line 566
    return;
  }
  {
#line 567
  c = t1_getbyte();
  }
#line 568
  if (decrypt) {
    {
#line 569
    tmp = edecrypt((byte )c);
#line 569
    c = (int )tmp;
    }
  }
#line 570
  l = (int )t1_block_length;
#line 571
  if (l == 0) {
#line 571
    if (! (c == 10)) {
#line 571
      if (! (c == 13)) {
#line 571
        goto _L;
      }
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 572
    pdftex_warn("%i bytes more than expected were ignored", l + 1);
    }
    {
#line 573
    while (1) {
      while_continue: /* CIL Label */ ;
#line 573
      tmp___0 = l;
#line 573
      l --;
#line 573
      if (! (tmp___0 > 0)) {
#line 573
        goto while_break;
      }
      {
#line 574
      t1_getbyte();
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 576
  return;
}
}
#line 578 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_start_eexec(void) 
{ 
  int i ;
  int tmp ;
  char *tmp___0 ;

  {
#line 585
  if (! t1_pfa) {
    {
#line 586
    t1_check_block_len((boolean )0);
    }
  }
#line 587
  t1_line_ptr = t1_line;
#line 587
  i = 0;
  {
#line 587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 587
    if (! (i < 4)) {
#line 587
      goto while_break;
    }
    {
#line 588
    tmp = t1_getbyte();
#line 588
    edecrypt((byte )tmp);
#line 589
    tmp___0 = t1_line_ptr;
#line 589
    t1_line_ptr ++;
#line 589
    *tmp___0 = (char)0;
#line 587
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 591
  t1_eexec_encrypt = (boolean )1;
#line 593
  t1_putline();
  }
#line 594
  return;
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_stop_eexec(void) 
{ 
  int c ;
  int tmp ;
  byte tmp___0 ;

  {
  {
#line 603
  hexline_length = 64;
#line 603
  end_hexline();
#line 603
  t1_eexec_encrypt = (boolean )0;
  }
#line 604
  if (! t1_pfa) {
    {
#line 605
    t1_check_block_len((boolean )1);
    }
  } else {
    {
#line 607
    tmp = t1_getbyte();
#line 607
    tmp___0 = edecrypt((byte )tmp);
#line 607
    c = (int )tmp___0;
    }
#line 608
    if (! (c == 10)) {
#line 608
      if (! (c == 13)) {
#line 609
        if (last_hexbyte == 0) {
          {
#line 610
          t1_puts((char *)"00");
          }
        } else {
          {
#line 612
          pdftex_warn("unexpected data after eexec");
          }
        }
      }
    }
  }
#line 614
  t1_cs = (boolean )0;
#line 615
  t1_in_eexec = 2;
#line 616
  return;
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_scan_param(void) 
{ 
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 790
  if (! t1_scan) {
#line 791
    return;
  } else
#line 790
  if ((int )t1_line[0] != 47) {
#line 791
    return;
  }
  {
#line 792
  tmp___1 = strlen("/lenIV");
#line 792
  tmp___2 = strncmp((char const   *)(t1_line), "/lenIV", tmp___1);
  }
#line 792
  if (tmp___2 == 0) {
    {
#line 793
    tmp = strchr((char const   *)(t1_line), ' ');
#line 793
    tmp___0 = atoi((char const   *)(tmp + 1));
#line 793
    t1_lenIV = (unsigned short )tmp___0;
    }
#line 794
    return;
  }
#line 797
  return;
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static int copy_glyph_names(char **glyph_names , int a , int b ) 
{ 


  {
#line 801
  if ((unsigned long )*(glyph_names + b) != (unsigned long )(notdef)) {
    {
#line 802
    free((void *)*(glyph_names + b));
#line 803
    *(glyph_names + b) = notdef;
    }
  }
#line 805
  if ((unsigned long )*(glyph_names + a) != (unsigned long )(notdef)) {
    {
#line 806
    *(glyph_names + b) = strdup((char const   *)*(glyph_names + a));
    }
  }
#line 808
  return (0);
}
}
#line 810 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_builtin_enc(void) 
{ 
  int i ;
  int a ;
  int b ;
  int c ;
  int counter ;
  char *r___0 ;
  char *p ;
  char **glyph_names ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;

  {
#line 812
  counter = 0;
#line 814
  glyph_names = t1_builtin_glyph_names;
#line 830
  i = 0;
  {
#line 830
  while (1) {
    while_continue: /* CIL Label */ ;
#line 830
    if (! (i <= 255)) {
#line 830
      goto while_break;
    }
#line 831
    *(glyph_names + i) = notdef;
#line 830
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 832
  tmp___19 = strlen("/Encoding [");
#line 832
  tmp___20 = strncmp((char const   *)(t1_line), "/Encoding [", tmp___19);
  }
#line 832
  if (tmp___20 == 0) {
#line 832
    goto _L___6;
  } else {
    {
#line 832
    tmp___21 = strlen("/Encoding[");
#line 832
    tmp___22 = strncmp((char const   *)(t1_line), "/Encoding[", tmp___21);
    }
#line 832
    if (tmp___22 == 0) {
      _L___6: /* CIL Label */ 
      {
#line 833
      tmp = strchr((char const   *)(t1_line), '[');
#line 833
      r___0 = tmp + 1;
      }
#line 834
      if ((int )*r___0 == 32) {
#line 834
        r___0 ++;
      }
      {
#line 835
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 836
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 836
          if (! ((int )*r___0 == 47)) {
#line 836
            goto while_break___1;
          }
#line 837
          p = t1_buf;
#line 837
          r___0 ++;
          {
#line 837
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 837
            if ((int )*r___0 != 32) {
#line 837
              if ((int )*r___0 != 10) {
#line 837
                if ((int )*r___0 != 93) {
#line 837
                  if (! ((int )*r___0 != 47)) {
#line 837
                    goto while_break___2;
                  }
                } else {
#line 837
                  goto while_break___2;
                }
              } else {
#line 837
                goto while_break___2;
              }
            } else {
#line 837
              goto while_break___2;
            }
#line 837
            tmp___0 = p;
#line 837
            p ++;
#line 837
            tmp___1 = r___0;
#line 837
            r___0 ++;
#line 837
            *tmp___0 = *tmp___1;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 840
          *p = (char)0;
#line 841
          if ((int )*r___0 == 32) {
#line 841
            r___0 ++;
          }
#line 842
          if (counter > 255) {
            {
#line 843
            pdftex_fail("encoding vector contains more than %i names", 256);
            }
          }
          {
#line 845
          tmp___2 = strcmp((char const   *)(t1_buf), (char const   *)(notdef));
          }
#line 845
          if (tmp___2 != 0) {
            {
#line 846
            *(glyph_names + counter) = strdup((char const   *)(t1_buf));
            }
          }
#line 847
          counter ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 849
        if ((int )*r___0 != 10) {
#line 849
          if ((int )*r___0 != 37) {
            {
#line 850
            tmp___4 = strlen("] def");
#line 850
            tmp___5 = strncmp((char const   *)r___0, "] def", tmp___4);
            }
#line 850
            if (tmp___5 == 0) {
#line 851
              goto while_break___0;
            } else {
              {
#line 850
              tmp___6 = strlen("] readonly def");
#line 850
              tmp___7 = strncmp((char const   *)r___0, "] readonly def", tmp___6);
              }
#line 850
              if (tmp___7 == 0) {
#line 851
                goto while_break___0;
              } else {
                {
#line 853
                while (1) {
                  while_continue___3: /* CIL Label */ ;
                  {
#line 853
                  tmp___3 = strchr((char const   *)(t1_line), 0);
#line 853
                  r___0 = tmp___3 - 1;
                  }
#line 853
                  if ((int )*r___0 == 10) {
#line 853
                    *r___0 = (char)0;
                  }
#line 853
                  goto while_break___3;
                }
                while_break___3: /* CIL Label */ ;
                }
                {
#line 854
                pdftex_fail("a name or `] def\' or `] readonly def\' expected: `%s\'",
                            t1_line);
                }
              }
            }
          }
        }
        {
#line 858
        t1_getline();
#line 859
        r___0 = t1_line;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 863
      p = strchr((char const   *)(t1_line), 10);
      }
      {
#line 863
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 863
        tmp___18 = strcmp((char const   *)p, "def\n");
        }
#line 863
        if (tmp___18 == 0) {
#line 863
          if ((unsigned long )p > (unsigned long )(t1_line)) {
#line 863
            if ((int )*(p + -1) == 32) {
#line 863
              goto while_break___4;
            }
          }
        }
#line 866
        if ((int )*p == 10) {
          {
#line 867
          t1_getline();
#line 868
          p = t1_line;
          }
        }
        {
#line 873
        tmp___17 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"dup %i%256s put",
                          & i, t1_buf);
        }
#line 873
        if (tmp___17 == 2) {
#line 873
          if ((int )t1_buf[0] == 47) {
#line 873
            if (i >= 0) {
#line 873
              if (i <= 255) {
                {
#line 875
                tmp___8 = strcmp((char const   *)(t1_buf + 1), (char const   *)(notdef));
                }
#line 875
                if (tmp___8 != 0) {
                  {
#line 876
                  *(glyph_names + i) = strdup((char const   *)(t1_buf + 1));
                  }
                }
                {
#line 877
                tmp___9 = strstr((char const   *)p, " put");
#line 877
                tmp___10 = strlen(" put");
#line 877
                p = tmp___9 + tmp___10;
                }
#line 878
                if ((int )*p == 32) {
#line 878
                  p ++;
                }
              } else {
#line 873
                goto _L___5;
              }
            } else {
#line 873
              goto _L___5;
            }
          } else {
#line 873
            goto _L___5;
          }
        } else {
          _L___5: /* CIL Label */ 
          {
#line 883
          tmp___16 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"dup dup %i exch %i get put",
                            & b, & a);
          }
#line 883
          if (tmp___16 == 2) {
#line 883
            if (a >= 0) {
#line 883
              if (a <= 255) {
#line 883
                if (b >= 0) {
#line 883
                  if (b <= 255) {
                    {
#line 885
                    copy_glyph_names(glyph_names, a, b);
#line 886
                    tmp___11 = strstr((char const   *)p, " get put");
#line 886
                    tmp___12 = strlen(" get put");
#line 886
                    p = tmp___11 + tmp___12;
                    }
#line 887
                    if ((int )*p == 32) {
#line 887
                      p ++;
                    }
                  } else {
#line 883
                    goto _L___3;
                  }
                } else {
#line 883
                  goto _L___3;
                }
              } else {
#line 883
                goto _L___3;
              }
            } else {
#line 883
              goto _L___3;
            }
          } else {
            _L___3: /* CIL Label */ 
            {
#line 892
            tmp___15 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"dup dup %i %i getinterval %i exch putinterval",
                              & a, & c, & b);
            }
#line 892
            if (tmp___15 == 3) {
#line 892
              if (a >= 0) {
#line 892
                if (a <= 255) {
#line 892
                  if (b >= 0) {
#line 892
                    if (b <= 255) {
#line 892
                      if (c >= 0) {
#line 892
                        if (c <= 255) {
#line 895
                          i = 0;
                          {
#line 895
                          while (1) {
                            while_continue___5: /* CIL Label */ ;
#line 895
                            if (! (i < c)) {
#line 895
                              goto while_break___5;
                            }
                            {
#line 896
                            copy_glyph_names(glyph_names, a + i, b + i);
#line 895
                            i ++;
                            }
                          }
                          while_break___5: /* CIL Label */ ;
                          }
                          {
#line 897
                          tmp___13 = strstr((char const   *)p, " putinterval");
#line 897
                          tmp___14 = strlen(" putinterval");
#line 897
                          p = tmp___13 + tmp___14;
                          }
#line 898
                          if ((int )*p == 32) {
#line 898
                            p ++;
                          }
                        } else {
#line 892
                          goto _L___1;
                        }
                      } else {
#line 892
                        goto _L___1;
                      }
                    } else {
#line 892
                      goto _L___1;
                    }
                  } else {
#line 892
                    goto _L___1;
                  }
                } else {
#line 892
                  goto _L___1;
                }
              } else {
#line 892
                goto _L___1;
              }
            } else {
              _L___1: /* CIL Label */ 
              {
#line 901
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 901
                if ((int )*p != 32) {
#line 901
                  if (! ((int )*p != 10)) {
#line 901
                    goto while_break___6;
                  }
                } else {
#line 901
                  goto while_break___6;
                }
#line 902
                p ++;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 903
              if ((int )*p == 32) {
#line 903
                p ++;
              }
            }
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 907
  return;
}
}
#line 909 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_check_predef_enc(void) 
{ 
  size_t tmp ;
  int tmp___0 ;
  boolean tmp___1 ;

  {
  {
#line 911
  tmp___1 = t1_suffix((char *)"def");
  }
#line 911
  if (tmp___1) {
    {
#line 912
    tmp = strlen("/Encoding");
#line 912
    sscanf((char const   */* __restrict  */)(t1_line + tmp), (char const   */* __restrict  */)"%256s",
           t1_buf);
#line 913
    tmp___0 = strcmp((char const   *)(t1_buf), "StandardEncoding");
    }
#line 913
    if (tmp___0 == 0) {
#line 914
      t1_encoding = 0;
    } else {
      {
#line 916
      pdftex_fail("cannot subset font (unknown predefined encoding `%s\')", t1_buf);
      }
    }
  } else {
#line 920
    t1_encoding = 1;
  }
#line 921
  return;
}
}
#line 923 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_check_end(void) 
{ 
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 925
  tmp = feof(t1_file);
  }
#line 925
  if (tmp) {
#line 926
    return;
  }
  {
#line 927
  t1_getline();
#line 928
  tmp___0 = strlen("{restore}");
#line 928
  tmp___1 = strncmp((char const   *)(t1_line), "{restore}", tmp___0);
  }
#line 928
  if (tmp___1 == 0) {
    {
#line 929
    t1_putline();
    }
  }
#line 930
  return;
}
}
#line 1022
int t1_open(void) ;
#line 1020 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static boolean t1_open_fontfile(char *open_name_prefix ) 
{ 
  int tmp ;

  {
  {
#line 1022
  tmp = t1_open();
  }
#line 1022
  if (! tmp) {
#line 1023
    return ((boolean )0);
  }
  {
#line 1024
  t1_init_params(open_name_prefix);
  }
#line 1025
  return ((boolean )1);
}
}
#line 1033 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void cs_store(boolean is_subr ) 
{ 
  char *p ;
  char *q ;
  cs_entry *ptr ;
  int subr ;
  char *tmp ;
  char *tmp___0 ;
  cs_entry *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned long tmp___6 ;
  void *tmp___7 ;

  {
#line 1038
  p = t1_line;
#line 1038
  q = t1_buf;
  {
#line 1038
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1038
    if (! ((int )*p != 32)) {
#line 1038
      goto while_break;
    }
#line 1038
    tmp = q;
#line 1038
    q ++;
#line 1038
    tmp___0 = p;
#line 1038
    p ++;
#line 1038
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1039
  *q = (char)0;
#line 1040
  if (is_subr) {
    {
#line 1041
    subr = atoi((char const   *)(p + 1));
    }
#line 1042
    if (subr >= subr_size) {
      {
#line 1042
      pdftex_fail("Subrs array: entry index out of range (%i)", subr);
      }
    } else
#line 1042
    if (subr < 0) {
      {
#line 1042
      pdftex_fail("Subrs array: entry index out of range (%i)", subr);
      }
    }
#line 1043
    ptr = subr_tab + subr;
  } else {
    {
#line 1046
    tmp___1 = cs_ptr;
#line 1046
    cs_ptr ++;
#line 1046
    ptr = tmp___1;
#line 1047
    tmp___2 = strcmp((char const   *)(t1_buf + 1), (char const   *)(notdef));
    }
#line 1047
    if (tmp___2 == 0) {
#line 1048
      ptr->name = notdef;
    } else {
      {
#line 1050
      ptr->name = strdup((char const   *)(t1_buf + 1));
      }
    }
  }
  {
#line 1052
  memcpy((void */* __restrict  */)(t1_buf), (void const   */* __restrict  */)(cs_start___0 - 4),
         (size_t )((int )t1_cslen + 4));
#line 1053
  p = cs_start___0 + (int )t1_cslen;
#line 1053
  q = (t1_buf + (int )t1_cslen) + 4;
  }
  {
#line 1053
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1053
    if (! ((int )*p != 10)) {
#line 1053
      goto while_break___0;
    }
#line 1053
    tmp___3 = q;
#line 1053
    q ++;
#line 1053
    tmp___4 = p;
#line 1053
    p ++;
#line 1053
    *tmp___3 = *tmp___4;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1055
  tmp___5 = q;
#line 1055
  q ++;
#line 1055
  *tmp___5 = (char)10;
#line 1056
  ptr->len = (unsigned short )(q - t1_buf);
#line 1057
  ptr->cslen = t1_cslen;
#line 1058
  if ((unsigned long )ptr->len * sizeof(byte )) {
#line 1058
    tmp___6 = (unsigned long )ptr->len * sizeof(byte );
  } else {
#line 1058
    tmp___6 = 1UL;
  }
  {
#line 1058
  tmp___7 = malloc(tmp___6);
#line 1058
  ptr->data = (byte *)tmp___7;
#line 1059
  memcpy((void */* __restrict  */)ptr->data, (void const   */* __restrict  */)(t1_buf),
         (size_t )ptr->len);
#line 1060
  ptr->valid = (boolean )1;
  }
#line 1061
  return;
}
}
#line 1068 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static integer cc_stack[24]  ;
#line 1068 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static integer *stack_ptr  =    cc_stack;
#line 1069 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static cc_entry cc_tab[66]  ;
#line 1070 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static boolean is_cc_init  =    (boolean )0;
#line 1111 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void cc_init(void) 
{ 
  int i ;

  {
#line 1114
  if (is_cc_init) {
#line 1115
    return;
  }
#line 1116
  i = 0;
  {
#line 1116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1116
    if (! (i < 66)) {
#line 1116
      goto while_break;
    }
#line 1117
    cc_tab[i].valid = (boolean )0;
#line 1116
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1118
  cc_tab[1].nargs = (byte )2;
#line 1118
  cc_tab[1].bottom = (boolean )1;
#line 1118
  cc_tab[1].clear = (boolean )1;
#line 1118
  cc_tab[1].valid = (boolean )1;
#line 1119
  cc_tab[3].nargs = (byte )2;
#line 1119
  cc_tab[3].bottom = (boolean )1;
#line 1119
  cc_tab[3].clear = (boolean )1;
#line 1119
  cc_tab[3].valid = (boolean )1;
#line 1120
  cc_tab[4].nargs = (byte )1;
#line 1120
  cc_tab[4].bottom = (boolean )1;
#line 1120
  cc_tab[4].clear = (boolean )1;
#line 1120
  cc_tab[4].valid = (boolean )1;
#line 1121
  cc_tab[5].nargs = (byte )2;
#line 1121
  cc_tab[5].bottom = (boolean )1;
#line 1121
  cc_tab[5].clear = (boolean )1;
#line 1121
  cc_tab[5].valid = (boolean )1;
#line 1122
  cc_tab[6].nargs = (byte )1;
#line 1122
  cc_tab[6].bottom = (boolean )1;
#line 1122
  cc_tab[6].clear = (boolean )1;
#line 1122
  cc_tab[6].valid = (boolean )1;
#line 1123
  cc_tab[7].nargs = (byte )1;
#line 1123
  cc_tab[7].bottom = (boolean )1;
#line 1123
  cc_tab[7].clear = (boolean )1;
#line 1123
  cc_tab[7].valid = (boolean )1;
#line 1124
  cc_tab[8].nargs = (byte )6;
#line 1124
  cc_tab[8].bottom = (boolean )1;
#line 1124
  cc_tab[8].clear = (boolean )1;
#line 1124
  cc_tab[8].valid = (boolean )1;
#line 1125
  cc_tab[9].nargs = (byte )0;
#line 1125
  cc_tab[9].bottom = (boolean )0;
#line 1125
  cc_tab[9].clear = (boolean )1;
#line 1125
  cc_tab[9].valid = (boolean )1;
#line 1126
  cc_tab[10].nargs = (byte )1;
#line 1126
  cc_tab[10].bottom = (boolean )0;
#line 1126
  cc_tab[10].clear = (boolean )0;
#line 1126
  cc_tab[10].valid = (boolean )1;
#line 1127
  cc_tab[11].nargs = (byte )0;
#line 1127
  cc_tab[11].bottom = (boolean )0;
#line 1127
  cc_tab[11].clear = (boolean )0;
#line 1127
  cc_tab[11].valid = (boolean )1;
#line 1131
  cc_tab[13].nargs = (byte )2;
#line 1131
  cc_tab[13].bottom = (boolean )1;
#line 1131
  cc_tab[13].clear = (boolean )1;
#line 1131
  cc_tab[13].valid = (boolean )1;
#line 1132
  cc_tab[14].nargs = (byte )0;
#line 1132
  cc_tab[14].bottom = (boolean )0;
#line 1132
  cc_tab[14].clear = (boolean )1;
#line 1132
  cc_tab[14].valid = (boolean )1;
#line 1133
  cc_tab[21].nargs = (byte )2;
#line 1133
  cc_tab[21].bottom = (boolean )1;
#line 1133
  cc_tab[21].clear = (boolean )1;
#line 1133
  cc_tab[21].valid = (boolean )1;
#line 1134
  cc_tab[22].nargs = (byte )1;
#line 1134
  cc_tab[22].bottom = (boolean )1;
#line 1134
  cc_tab[22].clear = (boolean )1;
#line 1134
  cc_tab[22].valid = (boolean )1;
#line 1135
  cc_tab[30].nargs = (byte )4;
#line 1135
  cc_tab[30].bottom = (boolean )1;
#line 1135
  cc_tab[30].clear = (boolean )1;
#line 1135
  cc_tab[30].valid = (boolean )1;
#line 1136
  cc_tab[31].nargs = (byte )4;
#line 1136
  cc_tab[31].bottom = (boolean )1;
#line 1136
  cc_tab[31].clear = (boolean )1;
#line 1136
  cc_tab[31].valid = (boolean )1;
#line 1137
  cc_tab[32].nargs = (byte )0;
#line 1137
  cc_tab[32].bottom = (boolean )0;
#line 1137
  cc_tab[32].clear = (boolean )1;
#line 1137
  cc_tab[32].valid = (boolean )1;
#line 1138
  cc_tab[33].nargs = (byte )6;
#line 1138
  cc_tab[33].bottom = (boolean )1;
#line 1138
  cc_tab[33].clear = (boolean )1;
#line 1138
  cc_tab[33].valid = (boolean )1;
#line 1139
  cc_tab[34].nargs = (byte )6;
#line 1139
  cc_tab[34].bottom = (boolean )1;
#line 1139
  cc_tab[34].clear = (boolean )1;
#line 1139
  cc_tab[34].valid = (boolean )1;
#line 1140
  cc_tab[38].nargs = (byte )5;
#line 1140
  cc_tab[38].bottom = (boolean )1;
#line 1140
  cc_tab[38].clear = (boolean )1;
#line 1140
  cc_tab[38].valid = (boolean )1;
#line 1141
  cc_tab[39].nargs = (byte )4;
#line 1141
  cc_tab[39].bottom = (boolean )1;
#line 1141
  cc_tab[39].clear = (boolean )1;
#line 1141
  cc_tab[39].valid = (boolean )1;
#line 1142
  cc_tab[44].nargs = (byte )2;
#line 1142
  cc_tab[44].bottom = (boolean )0;
#line 1142
  cc_tab[44].clear = (boolean )0;
#line 1142
  cc_tab[44].valid = (boolean )1;
#line 1143
  cc_tab[48].nargs = (byte )0;
#line 1143
  cc_tab[48].bottom = (boolean )0;
#line 1143
  cc_tab[48].clear = (boolean )0;
#line 1143
  cc_tab[48].valid = (boolean )1;
#line 1144
  cc_tab[49].nargs = (byte )0;
#line 1144
  cc_tab[49].bottom = (boolean )0;
#line 1144
  cc_tab[49].clear = (boolean )0;
#line 1144
  cc_tab[49].valid = (boolean )1;
#line 1145
  cc_tab[65].nargs = (byte )2;
#line 1145
  cc_tab[65].bottom = (boolean )1;
#line 1145
  cc_tab[65].clear = (boolean )1;
#line 1145
  cc_tab[65].valid = (boolean )1;
#line 1146
  is_cc_init = (boolean )1;
#line 1147
  return;
}
}
#line 1161
static void cs_mark(char *cs_name , int subr ) ;
#line 1161 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static integer lastargOtherSubr3  =    3;
#line 1154 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void cs_mark(char *cs_name , int subr ) 
{ 
  byte *data ;
  int i ;
  int b ;
  int cs_len ;
  integer a ;
  integer a1 ;
  integer a2 ;
  unsigned short cr___0 ;
  boolean cs_error ;
  cs_entry *ptr ;
  cc_entry *cc ;
  int tmp ;
  int tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte tmp___3 ;
  byte *tmp___4 ;
  byte tmp___5 ;
  byte *tmp___6 ;
  byte tmp___7 ;
  byte *tmp___8 ;
  byte tmp___9 ;
  byte *tmp___10 ;
  byte tmp___11 ;
  byte *tmp___12 ;
  byte tmp___13 ;
  byte *tmp___14 ;
  byte tmp___15 ;
  integer *tmp___16 ;
  byte *tmp___17 ;
  byte tmp___18 ;
  integer *tmp___19 ;
  integer *tmp___20 ;

  {
#line 1160
  cs_error = (boolean )0;
#line 1165
  if ((unsigned long )cs_name == (unsigned long )((char *)0)) {
#line 1166
    if (subr >= subr_size) {
      {
#line 1166
      pdftex_fail("Subrs array: entry index out of range (%i)", subr);
      }
    } else
#line 1166
    if (subr < 0) {
      {
#line 1166
      pdftex_fail("Subrs array: entry index out of range (%i)", subr);
      }
    }
#line 1167
    ptr = subr_tab + subr;
#line 1168
    if (! ptr->valid) {
      {
#line 1169
      pdftex_fail("Subrs: entry `%i\' is not valid", subr);
      }
    }
  } else
#line 1172
  if ((unsigned long )cs_notdef != (unsigned long )((cs_entry *)0)) {
#line 1172
    if ((unsigned long )cs_name == (unsigned long )(notdef)) {
#line 1174
      ptr = cs_notdef;
    } else {
      {
#line 1172
      tmp___0 = strcmp((char const   *)cs_name, (char const   *)(notdef));
      }
#line 1172
      if (tmp___0 == 0) {
#line 1174
        ptr = cs_notdef;
      } else {
#line 1172
        goto _L;
      }
    }
  } else {
    _L: /* CIL Label */ 
#line 1176
    ptr = cs_tab;
    {
#line 1176
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1176
      if (! ((unsigned long )ptr < (unsigned long )cs_ptr)) {
#line 1176
        goto while_break;
      }
      {
#line 1177
      tmp = strcmp((char const   *)ptr->name, (char const   *)cs_name);
      }
#line 1177
      if (tmp == 0) {
#line 1178
        goto while_break;
      }
#line 1176
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1179
    if ((unsigned long )ptr == (unsigned long )cs_ptr) {
      {
#line 1180
      pdftex_warn("glyph `%s\' undefined", cs_name);
      }
#line 1181
      return;
    }
#line 1183
    if ((unsigned long )ptr->name == (unsigned long )(notdef)) {
#line 1184
      cs_notdef = ptr;
    }
  }
#line 1189
  if (! ptr->valid) {
#line 1190
    return;
  } else
#line 1189
  if (ptr->used) {
#line 1189
    if ((unsigned long )cs_name != (unsigned long )((char *)0)) {
#line 1190
      return;
    }
  }
#line 1191
  ptr->used = (boolean )1;
#line 1192
  cr___0 = (unsigned short)4330;
#line 1193
  cs_len = (int )ptr->cslen;
#line 1194
  data = ptr->data + 4;
#line 1195
  i = 0;
  {
#line 1195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1195
    if (! (i < (int )t1_lenIV)) {
#line 1195
      goto while_break___0;
    }
    {
#line 1196
    tmp___1 = data;
#line 1196
    data ++;
#line 1196
    cdecrypt(*tmp___1, & cr___0);
#line 1195
    i ++;
#line 1195
    cs_len --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1197
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1197
    if (! (cs_len > 0)) {
#line 1197
      goto while_break___1;
    }
    {
#line 1198
    cs_len --;
#line 1199
    tmp___2 = data;
#line 1199
    data ++;
#line 1199
    tmp___3 = cdecrypt(*tmp___2, & cr___0);
#line 1199
    b = (int )tmp___3;
    }
#line 1200
    if (b >= 32) {
#line 1201
      if (b <= 246) {
#line 1202
        a = b - 139;
      } else
#line 1203
      if (b <= 250) {
        {
#line 1204
        cs_len --;
#line 1205
        tmp___4 = data;
#line 1205
        data ++;
#line 1205
        tmp___5 = cdecrypt(*tmp___4, & cr___0);
#line 1205
        a = (((b - 247) << 8) + 108) + (int )tmp___5;
        }
      } else
#line 1207
      if (b <= 254) {
        {
#line 1208
        cs_len --;
#line 1209
        tmp___6 = data;
#line 1209
        data ++;
#line 1209
        tmp___7 = cdecrypt(*tmp___6, & cr___0);
#line 1209
        a = (- ((b - 251) << 8) - 108) - (int )tmp___7;
        }
      } else {
        {
#line 1212
        cs_len -= 4;
#line 1213
        tmp___8 = data;
#line 1213
        data ++;
#line 1213
        tmp___9 = cdecrypt(*tmp___8, & cr___0);
#line 1213
        a = ((int )tmp___9 & 255) << 24;
#line 1214
        tmp___10 = data;
#line 1214
        data ++;
#line 1214
        tmp___11 = cdecrypt(*tmp___10, & cr___0);
#line 1214
        a |= ((int )tmp___11 & 255) << 16;
#line 1215
        tmp___12 = data;
#line 1215
        data ++;
#line 1215
        tmp___13 = cdecrypt(*tmp___12, & cr___0);
#line 1215
        a |= ((int )tmp___13 & 255) << 8;
#line 1216
        tmp___14 = data;
#line 1216
        data ++;
#line 1216
        tmp___15 = cdecrypt(*tmp___14, & cr___0);
#line 1216
        a |= (int )tmp___15 & 255;
        }
#line 1217
        if (sizeof(integer ) > 4UL) {
#line 1217
          if ((unsigned int )a & 2147483648U) {
#line 1218
            a |= (-0x7FFFFFFF-1);
          }
        }
      }
#line 1220
      tmp___16 = stack_ptr;
#line 1220
      stack_ptr ++;
#line 1220
      *tmp___16 = a;
    } else {
#line 1223
      if (b == 12) {
        {
#line 1224
        tmp___17 = data;
#line 1224
        data ++;
#line 1224
        tmp___18 = cdecrypt(*tmp___17, & cr___0);
#line 1224
        b = (int )tmp___18 + 32;
#line 1225
        cs_len --;
        }
      }
#line 1227
      if (b >= 66) {
        {
#line 1228
        pdftex_warn("CharString: command value out of range: %i", b);
#line 1230
        cs_error = (boolean )1;
        }
      }
#line 1232
      cc = cc_tab + b;
#line 1233
      if (! cc->valid) {
        {
#line 1234
        pdftex_warn("CharString: command not valid: %i", b);
#line 1235
        cs_error = (boolean )1;
        }
      }
#line 1237
      if (cc->bottom) {
#line 1237
        if (stack_ptr - cc_stack < (long )cc->nargs) {
          {
#line 1238
          pdftex_fail("CharString: less arguments on stack (%i) than required (%i)",
                      (int )(stack_ptr - cc_stack), (int )cc->nargs);
#line 1240
          cs_error = (boolean )1;
          }
        }
      }
#line 1242
      if (cc->clear) {
#line 1242
        if (cc->bottom) {
#line 1242
          if (stack_ptr - cc_stack > (long )cc->nargs) {
            {
#line 1243
            pdftex_warn("CharString: more operands on stack (%i) than required (%i)",
                        (int )(stack_ptr - cc_stack), (int )cc->nargs);
#line 1245
            cs_error = (boolean )1;
            }
          }
        }
      }
      {
#line 1248
      if (cc - cc_tab == 10L) {
#line 1248
        goto case_10;
      }
#line 1253
      if (cc - cc_tab == 44L) {
#line 1253
        goto case_44;
      }
#line 1257
      if (cc - cc_tab == 48L) {
#line 1257
        goto case_48;
      }
#line 1263
      if (cc - cc_tab == 49L) {
#line 1263
        goto case_49;
      }
#line 1270
      if (cc - cc_tab == 38L) {
#line 1270
        goto case_38;
      }
#line 1277
      goto switch_default;
      case_10: /* CIL Label */ 
#line 1249
      a1 = *(stack_ptr + -1);
#line 1250
      if (stack_ptr - cc_stack < 1L) {
        {
#line 1250
        pdftex_warn("CharString: invalid access (%i) to stack (%i entries)", 1, stack_ptr - cc_stack);
#line 1250
        cs_error = (boolean )1;
        }
      }
      {
#line 1250
      stack_ptr --;
#line 1251
      cs_mark((char *)0, a1);
      }
#line 1252
      goto switch_break;
      case_44: /* CIL Label */ 
#line 1254
      if (stack_ptr - cc_stack < 2L) {
        {
#line 1254
        pdftex_warn("CharString: invalid access (%i) to stack (%i entries)", 2, stack_ptr - cc_stack);
#line 1254
        cs_error = (boolean )1;
        }
      }
#line 1254
      stack_ptr -= 2;
#line 1255
      tmp___19 = stack_ptr;
#line 1255
      stack_ptr ++;
#line 1255
      *tmp___19 = 0;
#line 1256
      goto switch_break;
      case_48: /* CIL Label */ 
#line 1258
      if (*(stack_ptr + -1) == 3) {
#line 1259
        lastargOtherSubr3 = *(stack_ptr + -3);
      }
#line 1260
      a1 = *(stack_ptr + -2) + 2;
#line 1261
      if (stack_ptr - cc_stack < (long )a1) {
        {
#line 1261
        pdftex_warn("CharString: invalid access (%i) to stack (%i entries)", a1, stack_ptr - cc_stack);
#line 1261
        cs_error = (boolean )1;
        }
      }
#line 1261
      stack_ptr -= a1;
#line 1262
      goto switch_break;
      case_49: /* CIL Label */ 
#line 1264
      tmp___20 = stack_ptr;
#line 1264
      stack_ptr ++;
#line 1264
      *tmp___20 = lastargOtherSubr3;
#line 1269
      goto switch_break;
      case_38: /* CIL Label */ 
      {
#line 1271
      a1 = *(cc_stack + 3);
#line 1272
      a2 = *(cc_stack + 4);
#line 1273
      stack_ptr = cc_stack;
#line 1274
      cs_mark(standard_glyph_names[a1], 0);
#line 1275
      cs_mark(standard_glyph_names[a2], 0);
      }
#line 1276
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1278
      if (cc->clear) {
#line 1279
        stack_ptr = cc_stack;
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 1282
    if (cs_error) {
#line 1283
      ptr->valid = (boolean )0;
#line 1284
      ptr->used = (boolean )0;
#line 1285
      return;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1288
  return;
}
}
#line 1290 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_subset_ascii_part(void) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1294
  t1_getline();
  }
  {
#line 1295
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1295
    tmp = strlen("/Encoding");
#line 1295
    tmp___0 = strncmp((char const   *)(t1_line), "/Encoding", tmp);
    }
#line 1295
    if (tmp___0 == 0) {
#line 1295
      goto while_break;
    }
    {
#line 1296
    t1_scan_param();
#line 1297
    t1_putline();
#line 1298
    t1_getline();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1300
  t1_check_predef_enc();
  }
#line 1301
  if (t1_encoding == 0) {
    {
#line 1302
    t1_putline();
    }
  } else {
    {
#line 1304
    t1_builtin_enc();
    }
  }
#line 1305
  if ((unsigned long )cur_enc_name != (unsigned long )((char *)0)) {
#line 1306
    t1_glyph_names = ext_glyph_names;
  } else
#line 1307
  if (t1_encoding == 1) {
#line 1308
    t1_glyph_names = t1_builtin_glyph_names;
  } else {
#line 1310
    t1_glyph_names = standard_glyph_names;
  }
#line 1314
  if (t1_encoding != 0) {
    {
#line 1315
    t1_puts((char *)"/Encoding 256 array\n0 1 255 {1 index exch /.notdef put} for\n");
#line 1316
    i = 0;
    }
    {
#line 1316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1316
      if (! (i <= 255)) {
#line 1316
        goto while_break___0;
      }
#line 1317
      if ((int )*(grid + i) == 1) {
#line 1317
        if ((unsigned long )*(t1_glyph_names + i) != (unsigned long )(notdef)) {
          {
#line 1318
          t1_printf((char *)"dup %i /%s put\n", (char *)i, *(t1_glyph_names + i));
          }
        }
      }
#line 1316
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1320
    t1_puts((char *)"readonly def\n");
    }
  }
  {
#line 1322
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1323
    t1_getline();
#line 1324
    t1_scan_param();
#line 1325
    t1_putline();
    }
#line 1322
    if (! (t1_in_eexec == 0)) {
#line 1322
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1327
  return;
}
}
#line 1332
static void t1_flush_cs(boolean is_subr ) ;
#line 1334 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void cs_init(void) 
{ 


  {
#line 1336
  cs_tab = (cs_entry *)0;
#line 1336
  cs_ptr = cs_tab;
#line 1337
  cs_dict_end = (char *)0;
#line 1337
  cs_dict_start = cs_dict_end;
#line 1338
  cs_size_pos = 0;
#line 1338
  cs_size = cs_size_pos;
#line 1338
  cs_count = cs_size;
#line 1339
  subr_tab = (cs_entry *)0;
#line 1340
  subr_array_end = (char *)0;
#line 1340
  subr_array_start = subr_array_end;
#line 1341
  subr_size_pos = 0;
#line 1341
  subr_size = subr_size_pos;
#line 1341
  subr_max = subr_size;
#line 1342
  return;
}
}
#line 1344 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void init_cs_entry(cs_entry *cs ) 
{ 


  {
#line 1346
  cs->data = (byte *)0;
#line 1347
  cs->name = (char *)0;
#line 1348
  cs->len = (unsigned short)0;
#line 1349
  cs->cslen = (unsigned short)0;
#line 1350
  cs->used = (boolean )0;
#line 1351
  cs->valid = (boolean )0;
#line 1352
  return;
}
}
#line 1354
static void t1_mark_glyphs(void) ;
#line 1356 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_read_subrs(void) 
{ 
  int i ;
  char *s ;
  cs_entry *ptr ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  unsigned long tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;

  {
  {
#line 1361
  t1_getline();
  }
  {
#line 1362
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1362
    tmp = strstr((char const   *)(t1_line), "/CharStrings");
    }
#line 1362
    if (tmp) {
#line 1362
      goto while_break;
    } else {
      {
#line 1362
      tmp___0 = strlen("/Subrs");
#line 1362
      tmp___1 = strncmp((char const   *)(t1_line), "/Subrs", tmp___0);
      }
#line 1362
      if (tmp___1 == 0) {
#line 1362
        goto while_break;
      }
    }
    {
#line 1363
    t1_scan_param();
#line 1364
    t1_putline();
#line 1365
    t1_getline();
    }
  }
  while_break: /* CIL Label */ ;
  }
  found: 
  {
#line 1368
  t1_cs = (boolean )1;
#line 1369
  t1_scan = (boolean )0;
#line 1370
  tmp___2 = strlen("/Subrs");
#line 1370
  tmp___3 = strncmp((char const   *)(t1_line), "/Subrs", tmp___2);
  }
#line 1370
  if (! (tmp___3 == 0)) {
#line 1371
    return;
  }
  {
#line 1372
  tmp___4 = strlen("/Subrs");
#line 1372
  subr_size_pos = (int )(tmp___4 + 1UL);
#line 1374
  subr_size = atoi((char const   *)(t1_line + subr_size_pos));
  }
#line 1375
  if (subr_size == 0) {
    {
#line 1376
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1376
      tmp___5 = strstr((char const   *)(t1_line), "/CharStrings");
      }
#line 1376
      if (tmp___5) {
#line 1376
        goto while_break___0;
      }
      {
#line 1377
      t1_getline();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1378
    return;
  }
#line 1380
  if ((unsigned long )subr_size * sizeof(cs_entry )) {
#line 1380
    tmp___6 = (unsigned long )subr_size * sizeof(cs_entry );
  } else {
#line 1380
    tmp___6 = 1UL;
  }
  {
#line 1380
  tmp___7 = malloc(tmp___6);
#line 1380
  subr_tab = (cs_entry *)tmp___7;
#line 1381
  ptr = subr_tab;
  }
  {
#line 1381
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1381
    if (! (ptr - subr_tab < (long )subr_size)) {
#line 1381
      goto while_break___1;
    }
    {
#line 1382
    init_cs_entry(ptr);
#line 1381
    ptr ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1383
  subr_array_start = strdup((char const   *)(t1_line));
#line 1384
  t1_getline();
  }
  {
#line 1385
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1385
    if (! t1_cslen) {
#line 1385
      goto while_break___2;
    }
    {
#line 1386
    cs_store((boolean )1);
#line 1387
    t1_getline();
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1390
  i = 0;
  {
#line 1390
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1390
    if (i < subr_size) {
#line 1390
      if (! (i < 4)) {
#line 1390
        goto while_break___3;
      }
    } else {
#line 1390
      goto while_break___3;
    }
#line 1391
    (subr_tab + i)->used = (boolean )1;
#line 1390
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1400
  s = t1_buf;
#line 1401
  t1_buf[0] = (char)0;
#line 1402
  i = 0;
  {
#line 1402
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1402
    if (! (i < 5)) {
#line 1402
      goto while_break___4;
    }
    {
#line 1403
    tmp___8 = strstr((char const   *)(t1_line), "/CharStrings");
    }
#line 1403
    if (tmp___8) {
#line 1404
      goto while_break___4;
    }
#line 1405
    if ((t1_line_ptr - t1_line) + (s - t1_buf) >= 4094L) {
      {
#line 1405
      pdftex_fail("buffer overflow [%i bytes]", 4096);
      }
    }
    {
#line 1406
    strcat((char */* __restrict  */)(t1_buf), (char const   */* __restrict  */)(t1_line));
#line 1407
    s += t1_line_ptr - t1_line;
#line 1408
    t1_getline();
#line 1402
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1410
  subr_array_end = strdup((char const   *)(t1_buf));
  }
#line 1411
  if (i == 5) {
#line 1413
    ptr = subr_tab;
    {
#line 1413
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1413
      if (! (ptr - subr_tab < (long )subr_size)) {
#line 1413
        goto while_break___5;
      }
#line 1414
      if (ptr->valid) {
        {
#line 1415
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1415
          if ((unsigned long )ptr->data != (unsigned long )((byte *)0)) {
            {
#line 1415
            free((void *)ptr->data);
            }
          }
#line 1415
          ptr->data = (byte *)0;
#line 1415
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 1413
      ptr ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1416
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1416
      if ((unsigned long )subr_tab != (unsigned long )((cs_entry *)0)) {
        {
#line 1416
        free((void *)subr_tab);
        }
      }
#line 1416
      subr_tab = (cs_entry *)0;
#line 1416
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 1417
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1417
      if ((unsigned long )subr_array_start != (unsigned long )((char *)0)) {
        {
#line 1417
        free((void *)subr_array_start);
        }
      }
#line 1417
      subr_array_start = (char *)0;
#line 1417
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1418
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1418
      if ((unsigned long )subr_array_end != (unsigned long )((char *)0)) {
        {
#line 1418
        free((void *)subr_array_end);
        }
      }
#line 1418
      subr_array_end = (char *)0;
#line 1418
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 1419
    cs_init();
#line 1420
    t1_cs = (boolean )0;
#line 1421
    t1_synthetic = (boolean )1;
    }
    {
#line 1422
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 1422
      tmp___9 = strstr((char const   *)(t1_line), "/CharStrings");
      }
#line 1422
      if (tmp___9) {
#line 1422
        goto while_break___10;
      } else {
        {
#line 1422
        tmp___10 = strlen("/Subrs");
#line 1422
        tmp___11 = strncmp((char const   *)(t1_line), "/Subrs", tmp___10);
        }
#line 1422
        if (tmp___11 == 0) {
#line 1422
          goto while_break___10;
        }
      }
      {
#line 1423
      t1_getline();
      }
    }
    while_break___10: /* CIL Label */ ;
    }
#line 1424
    goto found;
  }
#line 1426
  return;
}
}
#line 1453
extern int ( /* missing proto */  isdigit)() ;
#line 1428 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_flush_cs(boolean is_subr ) 
{ 
  char *p ;
  cs_entry *tab ;
  cs_entry *end_tab ;
  cs_entry *ptr ;
  char *start_line ;
  char *line_end ;
  int count ;
  int size_pos ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1434
  if (is_subr) {
#line 1435
    start_line = subr_array_start;
#line 1436
    line_end = subr_array_end;
#line 1437
    size_pos = subr_size_pos;
#line 1438
    tab = subr_tab;
#line 1439
    end_tab = subr_tab + subr_size;
#line 1440
    count = subr_max + 1;
  } else {
#line 1443
    start_line = cs_dict_start;
#line 1444
    line_end = cs_dict_end;
#line 1445
    size_pos = cs_size_pos;
#line 1446
    tab = cs_tab;
#line 1447
    end_tab = cs_ptr;
#line 1448
    count = cs_count;
  }
#line 1450
  t1_line_ptr = t1_line;
#line 1451
  p = start_line;
  {
#line 1451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1451
    if (! (p - start_line < (long )size_pos)) {
#line 1451
      goto while_break;
    }
#line 1452
    tmp = t1_line_ptr;
#line 1452
    t1_line_ptr ++;
#line 1452
    tmp___0 = p;
#line 1452
    p ++;
#line 1452
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1453
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1453
    tmp___1 = isdigit((int )*p);
    }
#line 1453
    if (! tmp___1) {
#line 1453
      goto while_break___0;
    }
#line 1454
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1455
  sprintf((char */* __restrict  */)t1_line_ptr, (char const   */* __restrict  */)"%u",
          count);
#line 1456
  strcat((char */* __restrict  */)t1_line_ptr, (char const   */* __restrict  */)p);
#line 1457
  t1_line_ptr = eol(t1_line);
#line 1458
  t1_putline();
#line 1459
  ptr = tab;
  }
  {
#line 1459
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1459
    if (! ((unsigned long )ptr < (unsigned long )end_tab)) {
#line 1459
      goto while_break___1;
    }
#line 1460
    if (ptr->used) {
#line 1461
      if (is_subr) {
        {
#line 1462
        sprintf((char */* __restrict  */)(t1_line), (char const   */* __restrict  */)"dup %u %u",
                ptr - tab, (int )ptr->cslen);
        }
      } else {
        {
#line 1464
        sprintf((char */* __restrict  */)(t1_line), (char const   */* __restrict  */)"/%s %u",
                ptr->name, (int )ptr->cslen);
        }
      }
      {
#line 1465
      p = strchr((char const   *)(t1_line), 0);
#line 1466
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)ptr->data,
             (size_t )ptr->len);
#line 1467
      t1_line_ptr = p + (int )ptr->len;
#line 1468
      t1_putline();
      }
    }
    {
#line 1470
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1470
      if ((unsigned long )ptr->data != (unsigned long )((byte *)0)) {
        {
#line 1470
        free((void *)ptr->data);
        }
      }
#line 1470
      ptr->data = (byte *)0;
#line 1470
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1471
    if ((unsigned long )ptr->name != (unsigned long )((char *)0)) {
#line 1471
      if ((unsigned long )ptr->name != (unsigned long )(notdef)) {
        {
#line 1472
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1472
          if ((unsigned long )ptr->name != (unsigned long )((char *)0)) {
            {
#line 1472
            free((void *)ptr->name);
            }
          }
#line 1472
          ptr->name = (char *)0;
#line 1472
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 1459
    ptr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1474
  sprintf((char */* __restrict  */)(t1_line), (char const   */* __restrict  */)"%s",
          line_end);
#line 1475
  t1_line_ptr = eol(t1_line);
#line 1476
  t1_putline();
  }
  {
#line 1477
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1477
    if ((unsigned long )tab != (unsigned long )((cs_entry *)0)) {
      {
#line 1477
      free((void *)tab);
      }
    }
#line 1477
    tab = (cs_entry *)0;
#line 1477
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1478
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1478
    if ((unsigned long )start_line != (unsigned long )((char *)0)) {
      {
#line 1478
      free((void *)start_line);
      }
    }
#line 1478
    start_line = (char *)0;
#line 1478
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1479
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1479
    if ((unsigned long )line_end != (unsigned long )((char *)0)) {
      {
#line 1479
      free((void *)line_end);
      }
    }
#line 1479
    line_end = (char *)0;
#line 1479
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1480
  return;
}
}
#line 1482 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_mark_glyphs(void) 
{ 
  int i ;
  char *charset ;
  char *g ;
  char *s ;
  char *r___0 ;
  cs_entry *ptr ;

  {
#line 1485
  charset = (char *)0;
#line 1489
  if (t1_synthetic) {
#line 1489
    goto _L;
  } else
#line 1489
  if (0) {
    _L: /* CIL Label */ 
#line 1490
    if ((unsigned long )cs_tab != (unsigned long )((cs_entry *)0)) {
#line 1491
      ptr = cs_tab;
      {
#line 1491
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1491
        if (! ((unsigned long )ptr < (unsigned long )cs_ptr)) {
#line 1491
          goto while_break;
        }
#line 1492
        if (ptr->valid) {
#line 1493
          ptr->used = (boolean )1;
        }
#line 1491
        ptr ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 1494
    if ((unsigned long )subr_tab != (unsigned long )((cs_entry *)0)) {
#line 1495
      ptr = subr_tab;
      {
#line 1495
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1495
        if (! (ptr - subr_tab < (long )subr_size)) {
#line 1495
          goto while_break___0;
        }
#line 1496
        if (ptr->valid) {
#line 1497
          ptr->used = (boolean )1;
        }
#line 1495
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1498
      subr_max = subr_size - 1;
    }
#line 1500
    return;
  }
  {
#line 1502
  cs_mark(notdef, 0);
#line 1503
  i = 0;
  }
  {
#line 1503
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1503
    if (! (i <= 255)) {
#line 1503
      goto while_break___1;
    }
#line 1504
    if ((int )*(grid + i) == 1) {
#line 1505
      if ((unsigned long )*(t1_glyph_names + i) == (unsigned long )(notdef)) {
        {
#line 1506
        pdftex_warn("character %i is mapped to %s", i, notdef);
        }
      } else {
        {
#line 1508
        cs_mark(*(t1_glyph_names + i), 0);
        }
      }
    }
#line 1503
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1510
  if ((unsigned long )charset == (unsigned long )((char *)0)) {
#line 1511
    goto set_subr_max;
  }
  {
#line 1512
  s = charset + 1;
#line 1512
  g = s;
#line 1513
  r___0 = strchr((char const   *)g, 0);
  }
  {
#line 1514
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1514
    if (! ((unsigned long )g < (unsigned long )r___0)) {
#line 1514
      goto while_break___2;
    }
    {
#line 1515
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1515
      if ((int )*s != 47) {
#line 1515
        if (! ((unsigned long )s < (unsigned long )r___0)) {
#line 1515
          goto while_break___3;
        }
      } else {
#line 1515
        goto while_break___3;
      }
#line 1516
      s ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1517
    *s = (char)0;
#line 1518
    cs_mark(g, 0);
#line 1519
    g = s + 1;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  set_subr_max: 
#line 1522
  if ((unsigned long )subr_tab != (unsigned long )((cs_entry *)0)) {
#line 1523
    subr_max = -1;
#line 1523
    ptr = subr_tab;
    {
#line 1523
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1523
      if (! (ptr - subr_tab < (long )subr_size)) {
#line 1523
        goto while_break___4;
      }
#line 1524
      if (ptr->used) {
#line 1524
        if (ptr - subr_tab > (long )subr_max) {
#line 1525
          subr_max = (int )(ptr - subr_tab);
        }
      }
#line 1523
      ptr ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1526
  return;
}
}
#line 1528 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_subset_charstrings(void) 
{ 
  cs_entry *ptr ;
  char *tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1532
  tmp = strstr((char const   *)(t1_line), "/CharStrings");
#line 1532
  tmp___0 = strlen("/CharStrings");
#line 1532
  cs_size_pos = (int )(((tmp + tmp___0) - t1_line) + 1L);
#line 1536
  cs_size = atoi((char const   *)(t1_line + cs_size_pos));
  }
#line 1537
  if ((unsigned long )cs_size * sizeof(cs_entry )) {
#line 1537
    tmp___1 = (unsigned long )cs_size * sizeof(cs_entry );
  } else {
#line 1537
    tmp___1 = 1UL;
  }
  {
#line 1537
  tmp___2 = malloc(tmp___1);
#line 1537
  cs_tab = (cs_entry *)tmp___2;
#line 1537
  cs_ptr = cs_tab;
#line 1538
  ptr = cs_tab;
  }
  {
#line 1538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1538
    if (! (ptr - cs_tab < (long )cs_size)) {
#line 1538
      goto while_break;
    }
    {
#line 1539
    init_cs_entry(ptr);
#line 1538
    ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1540
  cs_notdef = (cs_entry *)0;
#line 1541
  cs_dict_start = strdup((char const   *)(t1_line));
#line 1542
  t1_getline();
  }
  {
#line 1543
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1543
    if (! t1_cslen) {
#line 1543
      goto while_break___0;
    }
    {
#line 1544
    cs_store((boolean )0);
#line 1545
    t1_getline();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1547
  cs_dict_end = strdup((char const   *)(t1_line));
#line 1548
  t1_mark_glyphs();
  }
#line 1549
  if ((unsigned long )subr_tab != (unsigned long )((cs_entry *)0)) {
    {
#line 1550
    t1_flush_cs((boolean )1);
    }
  }
#line 1551
  cs_count = 0;
#line 1551
  ptr = cs_tab;
  {
#line 1551
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1551
    if (! ((unsigned long )ptr < (unsigned long )cs_ptr)) {
#line 1551
      goto while_break___1;
    }
#line 1552
    if (ptr->used) {
#line 1553
      cs_count ++;
    }
#line 1551
    ptr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1554
  t1_flush_cs((boolean )0);
  }
#line 1555
  return;
}
}
#line 1557 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void t1_subset_end(void) 
{ 
  char *tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 1560
  if (t1_synthetic) {
    {
#line 1561
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1561
      tmp = strstr((char const   *)(t1_line), "definefont");
      }
#line 1561
      if (tmp) {
#line 1561
        goto while_break;
      }
      {
#line 1562
      t1_getline();
#line 1563
      t1_putline();
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1565
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1565
      tmp___0 = t1_suffix((char *)"mark currentfile closefile");
      }
#line 1565
      if (tmp___0) {
#line 1565
        goto while_break___0;
      }
      {
#line 1566
      t1_getline();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1567
    t1_putline();
    }
  } else {
    {
#line 1569
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1569
      tmp___1 = t1_suffix((char *)"mark currentfile closefile");
      }
#line 1569
      if (tmp___1) {
#line 1569
        goto while_break___1;
      }
      {
#line 1570
      t1_getline();
#line 1571
      t1_putline();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1573
  t1_stop_eexec();
  }
  {
#line 1574
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 1574
    tmp___2 = strlen("cleartomark");
#line 1574
    tmp___3 = strncmp((char const   *)(t1_line), "cleartomark", tmp___2);
    }
#line 1574
    if (tmp___3 == 0) {
#line 1574
      goto while_break___2;
    }
    {
#line 1575
    t1_getline();
#line 1576
    t1_putline();
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1578
  if (! t1_synthetic) {
    {
#line 1579
    t1_check_end();
    }
  }
#line 1581
  return;
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
void writet1(void) 
{ 
  boolean tmp___1 ;

  {
  {
#line 1585
  read_encoding_only = (boolean )0;
#line 1601
  tmp___1 = t1_open_fontfile((char *)"<");
  }
#line 1601
  if (! tmp___1) {
#line 1602
    return;
  }
  {
#line 1603
  t1_subset_ascii_part();
#line 1604
  t1_start_eexec();
#line 1605
  cc_init();
#line 1606
  cs_init();
#line 1607
  t1_read_subrs();
#line 1608
  t1_subset_charstrings();
#line 1609
  t1_subset_end();
#line 1610
  t1_close_font_file((char *)">");
  }
#line 1611
  return;
}
}
#line 1614 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
boolean t1_subset(char *fontfile , char *encfile , unsigned char *g ) 
{ 
  int i ;

  {
#line 1617
  cur_enc_name = encfile;
#line 1618
  i = 0;
  {
#line 1618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1618
    if (! (i <= 255)) {
#line 1618
      goto while_break;
    }
#line 1619
    ext_glyph_names[i] = notdef;
#line 1618
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1620
  if ((unsigned long )cur_enc_name != (unsigned long )((char *)0)) {
    {
#line 1621
    load_enc(cur_enc_name, ext_glyph_names);
    }
  }
  {
#line 1622
  grid = g;
#line 1623
  cur_file_name = fontfile;
#line 1624
  hexline_length = 0;
#line 1625
  writet1();
#line 1626
  i = 0;
  }
  {
#line 1626
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1626
    if (! (i <= 255)) {
#line 1626
      goto while_break___0;
    }
#line 1627
    if ((unsigned long )ext_glyph_names[i] != (unsigned long )(notdef)) {
      {
#line 1628
      free((void *)ext_glyph_names[i]);
      }
    }
#line 1626
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1629
  return ((char)0);
}
}
#line 1635 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
int t1_open(void) 
{ 


  {
  {
#line 1637
  t1_file = fopen((char const   */* __restrict  */)cur_file_name, (char const   */* __restrict  */)"r");
  }
#line 1638
  return ((unsigned long )t1_file != (unsigned long )((void *)0));
}
}
#line 1641 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
int enc_open(void) 
{ 


  {
  {
#line 1643
  enc_file = fopen((char const   */* __restrict  */)cur_enc_name, (char const   */* __restrict  */)"r");
  }
#line 1644
  return ((unsigned long )enc_file != (unsigned long )((void *)0));
}
}
#line 1647 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void pdftex_fail(char *fmt , char *a , char *b , char *c ) 
{ 
  char newfmt[256] ;

  {
  {
#line 1653
  strcpy((char */* __restrict  */)(newfmt), (char const   */* __restrict  */)"(write1) ");
#line 1654
  strcat((char */* __restrict  */)(newfmt), (char const   */* __restrict  */)fmt);
#line 1655
  Fatal(newfmt, a, b, c);
  }
#line 1656
  return;
}
}
#line 1658 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
static void pdftex_warn(char *fmt , char *a , char *b , char *c ) 
{ 
  char newfmt[256] ;

  {
  {
#line 1664
  strcpy((char */* __restrict  */)(newfmt), (char const   */* __restrict  */)"(write1) ");
#line 1665
  strcat((char */* __restrict  */)(newfmt), (char const   */* __restrict  */)fmt);
#line 1666
  Warning(newfmt, a, b, c);
  }
#line 1667
  return;
}
}
#line 1672 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
int t1_get_encode(char *encfile , char **glyphs ) 
{ 
  int i ;

  {
#line 1678
  cur_enc_name = encfile;
#line 1679
  i = 0;
  {
#line 1679
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1679
    if (! (i <= 255)) {
#line 1679
      goto while_break;
    }
#line 1680
    *(glyphs + i) = notdef;
#line 1679
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1681
  if ((unsigned long )cur_enc_name != (unsigned long )((char *)0)) {
    {
#line 1682
    load_enc(cur_enc_name, glyphs);
    }
  }
#line 1683
  return (0);
}
}
#line 1685 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/writet1.c"
int t1_free_encode(char **glyphs ) 
{ 
  int i ;

  {
#line 1690
  i = 0;
  {
#line 1690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1690
    if (! (i <= 255)) {
#line 1690
      goto while_break;
    }
#line 1691
    if ((unsigned long )*(glyphs + i) != (unsigned long )(notdef)) {
      {
#line 1692
      free((void *)*(glyphs + i));
      }
    }
#line 1690
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1693
  return (0);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/ps.h"
void copy_type1_pfa(FILE *fp ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstype1.c"
int read_type1_file(struct font_entry *fe , struct biinitfontinfo *bii , char *fn ,
                    char *t1f , char *en ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstype1.c"
void dev_t1_initfontdict(struct font_entry *fe , struct biinitfontinfo *bii , char *t1path ,
                         char *encpath ) 
{ 
  char t1font[8192] ;
  struct psbiops po___0 ;
  char *tmp ;

  {
  {
#line 20
  fe->k = dev_newdevfont();
  }
#line 21
  if ((unsigned long )t1path != (unsigned long )((void *)0)) {
    {
#line 22
    read_type1_file(fe, bii, t1path, t1font, encpath);
#line 23
    t1tobi((*((struct tfmfntinfo **)(& fe->finfo)))->tfm_bf, t1font);
    }
  }
  {
#line 25
  get_tfm_psbiops(fe, & po___0);
#line 26
  tmp = psfname(fe->k);
#line 26
  psfindfontop(tmp, & po___0);
#line 27
  fe->ncdl = 0;
  }
#line 28
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstype1.c"
int read_type1_file(struct font_entry *fe , struct biinitfontinfo *bii , char *fn ,
                    char *t1f , char *en ) 
{ 
  FILE *fp ;
  char buffer[8192] ;
  char *b ;
  char *type1id1 ;
  char *type1id2 ;
  BOOLEAN istype1 ;
  BOOLEAN ispfa ;
  int idlen ;
  int i ;
  int c ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 37
  type1id1 = (char *)"%!FontType1-";
#line 38
  type1id2 = (char *)"%!PS-AdobeFont-";
#line 43
  fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 43
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 44
    Fatal("Unable to open type1font file %s", fn);
    }
  }
  {
#line 45
  tmp___0 = _IO_getc(fp);
  }
#line 45
  if (tmp___0 == 128) {
    {
#line 46
    tmp = _IO_getc(fp);
    }
#line 46
    if (tmp == 1) {
      {
#line 47
      fseek(fp, 6L, 0);
#line 48
      ispfa = 0;
      }
    } else {
      {
#line 50
      Fatal("%s is not type1font file", fn);
      }
    }
  } else {
    {
#line 52
    fseek(fp, 0L, 0);
#line 53
    ispfa = 1;
    }
  }
#line 55
  b = buffer;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 55
    c = _IO_getc(fp);
    }
#line 55
    if (c != 13) {
#line 55
      if (! (c != 10)) {
#line 55
        goto while_break;
      }
    } else {
#line 55
      goto while_break;
    }
#line 56
    *b = (char )c;
#line 55
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 57
  *b = (char )'\000';
#line 58
  tmp___5 = strlen((char const   *)type1id1);
#line 58
  tmp___6 = strncmp((char const   *)(buffer), (char const   *)type1id1, tmp___5);
  }
#line 58
  if (tmp___6) {
    {
#line 61
    tmp___3 = strlen((char const   *)type1id2);
#line 61
    tmp___4 = strncmp((char const   *)(buffer), (char const   *)type1id2, tmp___3);
    }
#line 61
    if (tmp___4) {
#line 65
      istype1 = 0;
    } else {
      {
#line 62
      tmp___2 = strlen((char const   *)type1id2);
#line 62
      idlen = (int )tmp___2;
#line 63
      istype1 = 1;
      }
    }
  } else {
    {
#line 59
    tmp___1 = strlen((char const   *)type1id1);
#line 59
    idlen = (int )tmp___1;
#line 60
    istype1 = 1;
    }
  }
#line 66
  if (! istype1) {
    {
#line 67
    fclose(fp);
#line 68
    Fatal("%s is not type1font file", fn);
    }
  }
#line 71
  i = idlen;
  {
#line 71
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 71
    if ((int )buffer[i] != 58) {
#line 71
      if (! ((int )buffer[i] != 0)) {
#line 71
        goto while_break___0;
      }
    } else {
#line 71
      goto while_break___0;
    }
#line 71
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 73
  if ((int )buffer[i] == 58) {
#line 74
    i ++;
    {
#line 74
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 74
      if (! ((int )buffer[i] == 32)) {
#line 74
        goto while_break___1;
      }
#line 74
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 76
    b = t1f;
    {
#line 76
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 76
      if (! ((int )buffer[i] != 32)) {
#line 76
        goto while_break___2;
      }
#line 77
      *b = buffer[i];
#line 76
      b ++;
#line 76
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 78
    *b = (char )'\000';
  } else {
    {
#line 80
    b = strrchr((char const   *)fn, '/');
    }
#line 81
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 82
      b = fn;
    } else {
#line 84
      b ++;
    }
#line 86
    i = (int )(b - fn);
#line 87
    b = t1f;
    {
#line 87
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 87
      if ((int )*(fn + i) != 0) {
#line 87
        if (! ((int )*(fn + i) != 46)) {
#line 87
          goto while_break___3;
        }
      } else {
#line 87
        goto while_break___3;
      }
#line 88
      *b = *(fn + i);
#line 87
      i ++;
#line 87
      b ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 90
    *b = (char )'\000';
  }
  {
#line 93
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%BeginFont: %s\n",
          t1f);
  }
#line 94
  if (G_t1part) {
    {
#line 95
    t1_subset(fn, en, bii->mark);
    }
  } else
#line 96
  if (ispfa) {
    {
#line 97
    copy_type1_pfa(fp);
    }
  } else {
    {
#line 99
    copy_type1_pfb(fp, fn);
    }
  }
  {
#line 100
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%EndFont\n");
#line 101
  fclose(fp);
  }
#line 102
  return (0);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstype1.c"
void copy_type1_pfa(FILE *fp ) 
{ 
  int n ;
  int c ;

  {
  {
#line 110
  fseek(fp, 0L, 0);
  }
#line 111
  if (G_removecomments) {
#line 112
    n = '\n';
    {
#line 112
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 112
      c = _IO_getc(fp);
      }
#line 112
      if (! (c != -1)) {
#line 112
        goto while_break;
      }
#line 113
      if (c == 37) {
#line 113
        if (n == 10) {
          {
#line 114
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 114
            c = _IO_getc(fp);
            }
#line 114
            if (! (c != -1)) {
#line 114
              goto while_break___0;
            }
#line 115
            if (c == 10) {
#line 116
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 118
          _IO_putc(c, outfp);
#line 119
          n = c;
          }
        }
      } else {
        {
#line 118
        _IO_putc(c, outfp);
#line 119
        n = c;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 123
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 123
      c = _IO_getc(fp);
      }
#line 123
      if (! (c != -1)) {
#line 123
        goto while_break___1;
      }
      {
#line 124
      _IO_putc(c, outfp);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 125
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstype1.c"
static char *hexdig  =    (char *)"0123456789ABCDEF";
#line 130 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/pstype1.c"
void copy_type1_pfb(FILE *fp , char *fn ) 
{ 
  int i ;
  int c ;
  long len ;
  long n ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 138
  fseek(fp, 1L, 0);
  }
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 140
    c = _IO_getc(fp);
    }
    {
#line 141
    if (c == 1) {
#line 141
      goto case_1;
    }
#line 153
    if (c == 2) {
#line 153
      goto case_2;
    }
#line 170
    if (c == 3) {
#line 170
      goto case_3;
    }
#line 172
    if (c == -1) {
#line 172
      goto case_neg_1;
    }
#line 140
    goto switch_break;
    case_1: /* CIL Label */ 
#line 142
    len = 0L;
#line 142
    n = 1L;
#line 142
    i = 1;
    {
#line 142
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 142
      if (! (i <= 4)) {
#line 142
        goto while_break___0;
      }
      {
#line 143
      tmp = _IO_getc(fp);
#line 143
      len += n * (long )tmp;
#line 142
      n *= 256L;
#line 142
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 144
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 144
      if (! (len > 0L)) {
#line 144
        goto while_break___1;
      }
      {
#line 145
      c = _IO_getc(fp);
      }
#line 145
      if (c == -1) {
        {
#line 146
        Fatal("premature EOF in type1 font file %s", fn);
        }
      }
#line 147
      if (c == 13) {
        {
#line 148
        _IO_putc('\n', outfp);
        }
      } else {
        {
#line 150
        _IO_putc(c, outfp);
        }
      }
#line 144
      len --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 152
    goto switch_break;
    case_2: /* CIL Label */ 
#line 154
    len = 0L;
#line 154
    n = 1L;
#line 154
    i = 1;
    {
#line 154
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 154
      if (! (i <= 4)) {
#line 154
        goto while_break___2;
      }
      {
#line 155
      tmp___0 = _IO_getc(fp);
#line 155
      len += n * (long )tmp___0;
#line 154
      n *= 256L;
#line 154
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 156
    i = 0;
    {
#line 156
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 156
      if (! (len > 0L)) {
#line 156
        goto while_break___3;
      }
      {
#line 157
      c = _IO_getc(fp);
      }
#line 157
      if (c == -1) {
        {
#line 158
        Fatal("premature EOF in type1 font file %s", fn);
        }
      }
      {
#line 159
      _IO_putc((int )*(hexdig + (c >> 4)), outfp);
#line 160
      _IO_putc((int )*(hexdig + (c & 15)), outfp);
#line 161
      i ++;
      }
#line 162
      if (i == 32) {
        {
#line 163
        _IO_putc('\n', outfp);
#line 164
        i = 0;
        }
      }
#line 156
      len --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 167
    if (i > 0) {
      {
#line 168
      _IO_putc('\n', outfp);
      }
    }
#line 169
    goto switch_break;
    case_3: /* CIL Label */ 
#line 171
    return;
    case_neg_1: /* CIL Label */ 
    {
#line 173
    Fatal("Premature EOF in type1 font file %s", fn);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/version.c"
char *version  =    (char *)"@(#)dvi2ps (j-version) 5.1j";
#line 15 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gffont.c"
int gftype_access(char *proto , struct font_entry *fe , struct accarg *acca ) ;
#line 16
void init_gf_fontinfo(struct font_entry *fe ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gffont.c"
struct fontop gfop  =    {(char *)"gf", & pathtype_init, & gftype_access, & init_gf_fontinfo};
#line 24 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gffont.c"
static FILE *fntfp___0  ;
#line 25
void loadgfchar(struct font_entry *fe , int c ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gffont.c"
int gftype_access(char *proto , struct font_entry *fe , struct accarg *acca ) 
{ 
  BOOLEAN ok ;
  int tmp ;

  {
  {
#line 35
  rast_mag(fe, acca, 1);
#line 41
  pave(fe->name, proto, acca);
#line 42
  tmp = access((char const   *)(fe->name), 4);
#line 42
  ok = tmp == 0;
#line 45
  rast_debug_report(fe, acca, ok, "gf");
  }
#line 47
  return (ok);
}
}
#line 54
void read_gf_fontinfo(struct font_entry *fe ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gffont.c"
void init_gf_fontinfo(struct font_entry *fe ) 
{ 


  {
  {
#line 56
  fe->fnt_readfontinfo = & read_gf_fontinfo;
#line 57
  init_rast_fontinfo(fe);
  }
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gffont.c"
void read_gf_fontinfo(struct font_entry *fe ) 
{ 
  int t ;
  int i ;
  struct rastchar_entry *ce ;
  struct rastinitfontinfo *rii ;
  struct rastfntinfo *rfi ;
  int ds ;
  long possave ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 71
  openfontfile(fe);
#line 72
  fntfp___0 = fe->openfile;
#line 73
  fseek(fntfp___0, -4L, 2);
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 74
    t = getuint(fntfp___0, 1);
    }
#line 74
    if (! (t == 223)) {
#line 74
      goto while_break;
    }
    {
#line 75
    fseek(fntfp___0, -2L, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  if (t != 131) {
    {
#line 77
    Fatal("GF ID = %d, can only process GF ID = %d files", t, 131);
    }
  }
  {
#line 79
  fseek(fntfp___0, -6L, 1);
#line 80
  t = getuint(fntfp___0, 1);
  }
#line 80
  if (t != 249) {
    {
#line 81
    Fatal("GF PostPost = %d, can only process GF PostPost = %d files", t, 249);
    }
  }
  {
#line 83
  tmp = getuint(fntfp___0, 4);
#line 83
  fseek(fntfp___0, (long )tmp, 0);
#line 84
  t = getuint(fntfp___0, 1);
  }
#line 84
  if (t != 248) {
    {
#line 85
    Fatal("GF Post = %d, can only process GF Post = %d files", t, 248);
    }
  }
  {
#line 87
  fseek(fntfp___0, 4L, 1);
#line 88
  ds = getuint(fntfp___0, 4);
#line 89
  t = getuint(fntfp___0, 4);
  }
#line 90
  if (fe->c != 0) {
#line 90
    if (t != 0) {
#line 90
      if (fe->c != t) {
        {
#line 91
        Warning("font = \"%s\",\n-->font checksum = %d,\n-->dvi checksum = %d", fe->name,
                fe->c, t);
        }
      }
    }
  }
  {
#line 93
  t = getuint(fntfp___0, 4);
#line 94
  fseek(fntfp___0, 20L, 1);
#line 96
  rii = *((struct rastinitfontinfo **)(& fe->finfo));
#line 97
  rfi = alloc_rastfinfo(rii->maxc + 1, 1, rii);
#line 97
  *((struct rastfntinfo **)(& fe->finfo)) = rfi;
#line 98
  dev_rast_initfe(fe);
#line 101
  rfi->nfntchars = rii->maxc + 1;
  }
  {
#line 102
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 102
    t = getuint(fntfp___0, 1);
    }
#line 102
    if (! (t == 245)) {
#line 102
      if (! (t == 246)) {
#line 102
        goto while_break___0;
      }
    }
    {
#line 104
    i = getuint(fntfp___0, 1);
    }
#line 105
    if ((int )rii->mark[i] == 0) {
#line 106
      if (t == 245) {
        {
#line 107
        fseek(fntfp___0, 16L, 1);
        }
      } else {
        {
#line 109
        fseek(fntfp___0, 9L, 1);
        }
      }
    } else {
#line 111
      ce = & rfi->ch[i];
#line 112
      if (t == 245) {
        {
#line 113
        fseek(fntfp___0, 8L, 1);
        }
      } else {
        {
#line 115
        fseek(fntfp___0, 1L, 1);
        }
      }
      {
#line 116
      tmp___0 = getuint(fntfp___0, 4);
#line 116
      ce->tfmw = (int )(((SCALED )tmp___0 * (SCALED )fe->s) / (SCALED )(1 << 20));
#line 117
      tmp___1 = getuint(fntfp___0, 4);
#line 117
      ce->where.fileoffset = (unsigned int )tmp___1;
#line 118
      possave = ftell(fntfp___0);
#line 119
      loadgfchar(fe, i);
#line 120
      dev_rast_initfontdict(fe, i);
#line 121
      fseek(fntfp___0, possave, 0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 124
  if (t != 249) {
    {
#line 125
    Fatal("There is %d between Post Charloc and PostPost", t);
    }
  }
  {
#line 127
  free((void *)((char *)rii));
  }
#line 128
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/dvi2ps-5.1j/gffont.c"
void loadgfchar(struct font_entry *fe , int c ) 
{ 
  char *pixel___0 ;
  int i ;
  int j ;
  int k ;
  int t ;
  int min_m ;
  int max_m ;
  int del_m ;
  int min_n ;
  int max_n ;
  int del_n ;
  int paint ;
  int length ;
  struct rastchar_entry *ce ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 146
  ce = & (*((struct rastfntinfo **)(& fe->finfo)))->ch[c];
#line 147
  fseek(fntfp___0, (long )ce->where.fileoffset, 0);
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 149
    t = getuint(fntfp___0, 1);
    }
#line 149
    if (! t) {
#line 149
      goto while_break;
    }
#line 150
    if (239 <= t) {
#line 150
      if (t <= 242) {
        {
#line 151
        tmp = getint(fntfp___0, (t - 239) + 1);
#line 151
        fseek(fntfp___0, (long )tmp, 1);
        }
      } else {
#line 150
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 152
    if (t == 243) {
      {
#line 153
      fseek(fntfp___0, 4L, 1);
      }
    } else
#line 154
    if (! (t == 244)) {
#line 157
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  if (t == 67) {
    {
#line 160
    tmp___0 = getuint(fntfp___0, 4);
    }
#line 160
    if (tmp___0 != c) {
      {
#line 161
      Fatal("Postamble %d points glyph %d", c, t);
      }
    }
    {
#line 162
    fseek(fntfp___0, 4L, 1);
#line 163
    min_m = getint(fntfp___0, 4);
#line 164
    max_m = getint(fntfp___0, 4);
#line 165
    min_n = getint(fntfp___0, 4);
#line 166
    max_n = getint(fntfp___0, 4);
#line 167
    del_m = max_m - min_m;
#line 168
    del_n = max_n - min_n;
    }
  } else
#line 169
  if (t == 68) {
    {
#line 170
    tmp___1 = getuint(fntfp___0, 1);
    }
#line 170
    if (tmp___1 != c) {
      {
#line 171
      Fatal("Postamble %d points glyph %d", c, t);
      }
    }
    {
#line 172
    del_m = getuint(fntfp___0, 1);
#line 173
    max_m = getuint(fntfp___0, 1);
#line 174
    del_n = getuint(fntfp___0, 1);
#line 175
    max_n = getuint(fntfp___0, 1);
#line 176
    min_m = max_m - del_m;
    }
  } else {
    {
#line 178
    Fatal("%d should be GF BOC or GF BOC1", t);
    }
  }
  {
#line 180
  ce->width = (unsigned short )del_m;
#line 181
  ce->height = (unsigned short )(del_n + 1);
#line 182
  ce->xoffset = (short )(- min_m);
#line 183
  ce->yoffset = (short )max_n;
#line 184
  ce->nbpl = (unsigned short )(((int )((unsigned short )((int )ce->width + 31)) >> 5) * 4);
#line 185
  tmp___2 = malloc((size_t )((int )ce->nbpl * (int )ce->height));
#line 185
  pixel___0 = (char *)tmp___2;
  }
#line 185
  if ((unsigned long )pixel___0 == (unsigned long )((void *)0)) {
    {
#line 186
    Fatal("Unable to allocate memory for char");
    }
  }
#line 188
  i = 0;
  {
#line 188
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 188
    if (! (i < (int )ce->height)) {
#line 188
      goto while_break___0;
    }
#line 189
    j = 0;
    {
#line 189
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 189
      if (! (j < (int )ce->nbpl)) {
#line 189
        goto while_break___1;
      }
#line 190
      *(pixel___0 + (j + i * (int )ce->nbpl)) = (char)0;
#line 189
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 188
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 192
  ce->where.pixptr = pixel___0;
#line 193
  j = 0;
#line 193
  i = j;
#line 194
  paint = 0;
  {
#line 196
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 196
    t = getuint(fntfp___0, 1);
    }
#line 196
    if (! (t != 69)) {
#line 196
      goto while_break___2;
    }
    {
#line 198
    if (t == 0) {
#line 198
      goto case_0;
    }
#line 201
    if (t == 66) {
#line 201
      goto case_66;
    }
#line 201
    if (t == 65) {
#line 201
      goto case_66;
    }
#line 201
    if (t == 64) {
#line 201
      goto case_66;
    }
#line 210
    if (t == 70) {
#line 210
      goto case_70;
    }
#line 215
    if (t == 73) {
#line 215
      goto case_73;
    }
#line 215
    if (t == 72) {
#line 215
      goto case_73;
    }
#line 215
    if (t == 71) {
#line 215
      goto case_73;
    }
#line 220
    if (t == 242) {
#line 220
      goto case_242;
    }
#line 220
    if (t == 241) {
#line 220
      goto case_242;
    }
#line 220
    if (t == 240) {
#line 220
      goto case_242;
    }
#line 220
    if (t == 239) {
#line 220
      goto case_242;
    }
#line 223
    if (t == 243) {
#line 223
      goto case_243;
    }
#line 226
    if (t == 244) {
#line 226
      goto case_244;
    }
#line 228
    goto switch_default;
    case_0: /* CIL Label */ 
#line 199
    paint = 1 - paint;
#line 200
    goto switch_break;
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_64: /* CIL Label */ 
    {
#line 202
    length = getuint(fntfp___0, (t - 64) + 1);
    }
#line 203
    if (paint == 1) {
#line 204
      k = 0;
      {
#line 204
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 204
        if (! (k < length)) {
#line 204
          goto while_break___3;
        }
#line 205
        *(pixel___0 + (j + (i >> 3))) = (char )((int )*(pixel___0 + (j + (i >> 3))) | (128 >> (i & 7)));
#line 204
        i ++;
#line 204
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 207
      i += length;
    }
#line 208
    paint = 1 - paint;
#line 209
    goto switch_break;
    case_70: /* CIL Label */ 
#line 211
    j += (int )ce->nbpl;
#line 212
    i = 0;
#line 213
    paint = 0;
#line 214
    goto switch_break;
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    {
#line 216
    tmp___3 = getuint(fntfp___0, t - 70);
#line 216
    j += (int )ce->nbpl * (tmp___3 + 1);
#line 217
    i = 0;
#line 218
    paint = 0;
    }
#line 219
    goto switch_break;
    case_242: /* CIL Label */ 
    case_241: /* CIL Label */ 
    case_240: /* CIL Label */ 
    case_239: /* CIL Label */ 
    {
#line 221
    tmp___4 = getint(fntfp___0, (t - 239) + 1);
#line 221
    fseek(fntfp___0, (long )tmp___4, 1);
    }
#line 222
    goto switch_break;
    case_243: /* CIL Label */ 
    {
#line 224
    fseek(fntfp___0, 4L, 1);
    }
#line 225
    goto switch_break;
    case_244: /* CIL Label */ 
#line 227
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 229
    if (0 < t) {
#line 229
      if (t < 64) {
#line 230
        length = t;
#line 231
        if (paint == 1) {
#line 232
          k = 0;
          {
#line 232
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 232
            if (! (k < length)) {
#line 232
              goto while_break___4;
            }
#line 233
            *(pixel___0 + (j + (i >> 3))) = (char )((int )*(pixel___0 + (j + (i >> 3))) | (128 >> (i & 7)));
#line 232
            i ++;
#line 232
            k ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
#line 235
          i += length;
        }
#line 236
        paint = 1 - paint;
      } else {
#line 229
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 237
    if (74 <= t) {
#line 237
      if (t <= 238) {
#line 238
        j += (int )ce->nbpl;
#line 239
        paint = 1;
#line 240
        i = t - 74;
      } else {
#line 237
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 242
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"GF invalid %d command in %s.\n",
              t, fe->name);
#line 244
      fseek(fntfp___0, -20L, 1);
#line 245
      k = 0;
      }
      {
#line 245
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 245
        if (! (k < 20)) {
#line 245
          goto while_break___5;
        }
        {
#line 246
        tmp___5 = getuint(fntfp___0, 1);
#line 246
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%3d ",
                tmp___5);
#line 245
        k ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 247
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 248
      k = 0;
      }
      {
#line 248
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 248
        if (! (k < 20)) {
#line 248
          goto while_break___6;
        }
        {
#line 249
        tmp___6 = getuint(fntfp___0, 1);
#line 249
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%3d ",
                tmp___6);
#line 248
        k ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 250
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 252
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 255
  return;
}
}
