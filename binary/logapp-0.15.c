/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 24 "/home/wheatley/newnew/temp/logapp-0.15/logapp.h"
enum __anonenum_t_printtype_1 {
    MESSAGE = 0,
    WARNING = 1,
    ERROR = 2
} ;
#line 24 "/home/wheatley/newnew/temp/logapp-0.15/logapp.h"
typedef enum __anonenum_t_printtype_1 t_printtype;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_12 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_12 pthread_mutex_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 31 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
struct __anonstruct_config_t_68 {
   char *argprefix ;
   char *strip_prefix ;
   char *executable ;
   int usepty ;
   int dumbterm ;
   int detectescape ;
   int ptyremovecr ;
   int appendlog ;
   int printsummary ;
   int printlogname ;
   int disable ;
   char *disable_keywords ;
   char *logname ;
   int logtime ;
   int logreltime ;
   int logenv ;
   int maxlogsize ;
   int locklogfile ;
   int warnlogfilelock ;
   int maxlogfiles ;
   int circularlog ;
   int logrename ;
   int alignlog ;
   int jointimeout ;
   int alignlinebreaks ;
   char *configfile ;
   char *configsection ;
   char *custconfigfile ;
   char *preexeccmd ;
   char *postexeccmd ;
   int exitonexecfail ;
   int extregexp ;
};
#line 31 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
typedef struct __anonstruct_config_t_68 config_t;
#line 76 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
struct __anonstruct_readbuf_t_69 {
   char *start ;
   int len ;
   char *end ;
   char *read ;
};
#line 76 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
typedef struct __anonstruct_readbuf_t_69 readbuf_t;
#line 83 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
struct __anonstruct_pipe_t_70 {
   int fh ;
   int cfhno ;
   char *name ;
   pthread_t ct ;
   char *dbuf ;
   char *buf ;
   readbuf_t rdbuf ;
   int state ;
   int charbased ;
   int (*handler)(void * ) ;
   int detectescape ;
   int switchtocbmode ;
   int memcr ;
   int ptyremovecr ;
   int blen ;
   int bfill ;
   int recalclen ;
   int fgcol ;
   int bgcol ;
   int bold ;
   int clip ;
   int eclip ;
   char *escreset ;
   int escresetlen ;
   char *esccolor ;
   int esccolorlen ;
   int linecount ;
   char *lineprefix ;
   int lineprefixlen ;
   int linebreakpos[9] ;
   char *regexp ;
   regex_t preg ;
   int regbgcol ;
   char *bgesccolor ;
   char *execregexp ;
   regex_t pexecreg ;
   char *execcommand ;
};
#line 83 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
typedef struct __anonstruct_pipe_t_70 pipe_t;
#line 135 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
struct __anonstruct_logfile_t_71 {
   int fh ;
   char *name ;
   unsigned int sizelimit ;
   char *oldext ;
   int appendnr ;
   char *head ;
   char *split ;
   char *foot ;
   int addnewline ;
   char *indent ;
};
#line 135 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
typedef struct __anonstruct_logfile_t_71 logfile_t;
#line 152
struct winsize;
#line 152
struct termios;
#line 152 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
struct __anonstruct_app_t_72 {
   char *exe ;
   char **argv ;
   int argc ;
   pid_t pid ;
   int active ;
   int doexit ;
   int exit_state ;
   time_t starttime ;
   struct timeval toffset ;
   pipe_t *pstdout ;
   pipe_t *pstderr ;
   struct winsize *ptysize ;
   struct termios *ptytermios ;
   struct termios *ptytermios_bak ;
   logfile_t *logfile ;
};
#line 152 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
typedef struct __anonstruct_app_t_72 app_t;
#line 280 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
union __anonunion_76 {
   int __in ;
   int __i ;
};
#line 283 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
union __anonunion_77 {
   int __in ;
   int __i ;
};
#line 282 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
union __anonunion_78 {
   int __in ;
   int __i ;
};
#line 279 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
union __anonunion_79 {
   int __in ;
   int __i ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_11 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_11 fd_set;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_70 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_70 regmatch_t;
#line 227 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
union __anonunion_79___0 {
   int __in ;
   int __i ;
};
#line 230 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
#line 229 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 226 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 182 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
enum __anonenum_t_vartype_77 {
    TBOOL = 0,
    TCLIP = 1,
    TCOLOR = 2,
    TINT = 3,
    TNONE = 4,
    TSTRING = 5,
    TUINT = 6
} ;
#line 182 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
typedef enum __anonenum_t_vartype_77 t_vartype;
#line 192 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
struct __anonstruct_arglist_t_78 {
   char shrt ;
   char *lng ;
   char *parm ;
   t_vartype type ;
   void *var ;
   char *desc ;
   int set ;
};
#line 192 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
typedef struct __anonstruct_arglist_t_78 arglist_t;
#line 524 "/home/wheatley/newnew/temp/logapp-0.15/main.c"
union __anonunion_79___1 {
   int __in ;
   int __i ;
};
#line 523 "/home/wheatley/newnew/temp/logapp-0.15/main.c"
union __anonunion_80___0 {
   int __in ;
   int __i ;
};
#line 170 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
struct __anonstruct_stringvalue_t_73 {
   char *string ;
   int value ;
};
#line 170 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
typedef struct __anonstruct_stringvalue_t_73 stringvalue_t;
#line 30 "/home/wheatley/newnew/temp/logapp-0.15/logapp.h"
void print(t_printtype type , char const   *format  , ...) ;
#line 31
void error_outofmemory(void) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 773 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 74 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
config_t config ;
#line 175
app_t app ;
#line 214
char *get_longpath(char const   *filename ) ;
#line 28 "/home/wheatley/newnew/temp/logapp-0.15/logfile.h"
int logfile_write(logfile_t *logfile___0 , pipe_t *pipe___0 ) ;
#line 29
int logfile_open(char *filename , logfile_t *logfile___0 ) ;
#line 30
int logfile_close(logfile_t *logfile___0 ) ;
#line 35 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
static int logfile_check_size(logfile_t *logfile___0 , int addmarker , unsigned int addsize ) ;
#line 37
static int logfile_rename(logfile_t *logfile___0 , char *oldname ) ;
#line 38
static char *logfile_get_alternate_name(logfile_t *logfile___0 ) ;
#line 39
static int logfile_add_header(logfile_t *logfile___0 ) ;
#line 40
static int logfile_add_splitmarker(logfile_t *logfile___0 ) ;
#line 41
static int logfile_add_footer(logfile_t *logfile___0 ) ;
#line 43 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
pthread_mutex_t logfile_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 45
extern char **environ ;
#line 52 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
static int logfile_add_header(logfile_t *logfile___0 ) 
{ 
  int ret ;
  int len ;
  int headlen ;
  int i ;
  struct tm *loctime ;
  char buf[81] ;
  char tmp[51] ;
  char pwd[501] ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  __off_t tmp___2 ;
  size_t tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  ssize_t tmp___6 ;
  size_t tmp___7 ;
  ssize_t tmp___8 ;
  ssize_t tmp___9 ;
  ssize_t tmp___10 ;
  ssize_t tmp___11 ;
  ssize_t tmp___12 ;
  ssize_t tmp___13 ;
  ssize_t tmp___14 ;
  ssize_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  ssize_t tmp___19 ;
  char *tmp___20 ;
  ssize_t tmp___21 ;
  ssize_t tmp___22 ;
  size_t tmp___23 ;
  ssize_t tmp___24 ;
  ssize_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  ssize_t tmp___28 ;

  {
  {
#line 64
  tmp___2 = lseek(logfile___0->fh, (__off_t )0, 2);
  }
#line 64
  if (tmp___2 != 0L) {
    {
#line 65
    tmp___0 = write(logfile___0->fh, (void const   *)"\n", (size_t )1);
    }
#line 65
    if (tmp___0 == -1L) {
#line 66
      return (-1);
    }
    {
#line 68
    tmp___1 = logfile_check_size(logfile___0, 0, 160U);
    }
#line 68
    if (tmp___1) {
      {
#line 69
      print((t_printtype )2, "Problem while checking/resizing logfile\n");
      }
#line 70
      return (-1);
    }
  }
  {
#line 74
  buf[80] = (char )'\000';
#line 76
  tmp___3 = strlen((char const   *)logfile___0->head);
#line 76
  headlen = (int )tmp___3;
#line 79
  len = snprintf((char */* __restrict  */)(buf), (size_t )80, (char const   */* __restrict  */)"%s %s\n",
                 logfile___0->head, app.exe);
  }
#line 80
  if (len < 0) {
#line 81
    return (-1);
  } else
#line 80
  if (len > 80) {
#line 81
    return (-1);
  }
  {
#line 83
  tmp___4 = write(logfile___0->fh, (void const   *)(buf), (size_t )len);
  }
#line 83
  if (tmp___4 == -1L) {
#line 84
    return (-1);
  }
#line 87
  i = 1;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < app.argc)) {
#line 87
      goto while_break;
    }
    {
#line 88
    tmp___5 = write(logfile___0->fh, (void const   *)logfile___0->head, (size_t )headlen);
    }
#line 88
    if (tmp___5 == -1L) {
#line 89
      return (-1);
    }
    {
#line 90
    len = snprintf((char */* __restrict  */)(buf), (size_t )80, (char const   */* __restrict  */)" arg[%d] = \"",
                   i);
    }
#line 91
    if (len < 0) {
#line 92
      return (-1);
    } else
#line 91
    if (len > 80) {
#line 92
      return (-1);
    }
    {
#line 94
    tmp___6 = write(logfile___0->fh, (void const   *)(buf), (size_t )len);
    }
#line 94
    if (tmp___6 == -1L) {
#line 95
      return (-1);
    }
    {
#line 96
    tmp___7 = strlen((char const   *)*(app.argv + i));
#line 96
    tmp___8 = write(logfile___0->fh, (void const   *)*(app.argv + i), tmp___7);
    }
#line 96
    if (tmp___8 == -1L) {
#line 97
      return (-1);
    }
    {
#line 98
    tmp___9 = write(logfile___0->fh, (void const   *)"\"", (size_t )1);
    }
#line 98
    if (tmp___9 != 1L) {
#line 99
      return (-1);
    }
#line 100
    if (i + 1 < app.argc) {
      {
#line 101
      tmp___10 = write(logfile___0->fh, (void const   *)"\n", (size_t )1);
      }
#line 101
      if (tmp___10 != 1L) {
#line 102
        return (-1);
      }
    }
#line 87
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (app.argc < 2) {
    {
#line 105
    tmp___11 = write(logfile___0->fh, (void const   *)logfile___0->head, (size_t )headlen);
    }
#line 105
    if (tmp___11 == -1L) {
#line 106
      return (-1);
    }
    {
#line 107
    tmp___12 = write(logfile___0->fh, (void const   *)" <no command line options>",
                     (size_t )26);
    }
#line 107
    if (tmp___12 != 26L) {
#line 109
      return (-1);
    }
  }
  {
#line 111
  tmp___13 = write(logfile___0->fh, (void const   *)"\n", (size_t )1);
  }
#line 111
  if (tmp___13 != 1L) {
#line 112
    return (-1);
  }
  {
#line 115
  len = snprintf((char */* __restrict  */)(buf), (size_t )80, (char const   */* __restrict  */)"%s pwd = ",
                 logfile___0->head);
  }
#line 116
  if (len < 0) {
#line 117
    return (-1);
  } else
#line 116
  if (len > 80) {
#line 117
    return (-1);
  }
  {
#line 119
  tmp___14 = write(logfile___0->fh, (void const   *)(buf), (size_t )len);
  }
#line 119
  if (tmp___14 == -1L) {
#line 120
    return (-1);
  }
  {
#line 121
  tmp___20 = getcwd(pwd, (size_t )500);
  }
#line 121
  if ((unsigned long )tmp___20 == (unsigned long )((void *)0)) {
    {
#line 122
    tmp___15 = write(logfile___0->fh, (void const   *)"<unable to get working directory>\n",
                     (size_t )34);
    }
#line 122
    if (tmp___15 != 34L) {
#line 124
      return (-1);
    }
  } else {
    {
#line 126
    tmp___16 = strlen((char const   *)(pwd));
#line 126
    pwd[tmp___16 + 1UL] = (char )'\000';
#line 127
    tmp___17 = strlen((char const   *)(pwd));
#line 127
    pwd[tmp___17] = (char )'\n';
#line 128
    tmp___18 = strlen((char const   *)(pwd));
#line 128
    tmp___19 = write(logfile___0->fh, (void const   *)(pwd), tmp___18);
    }
#line 128
    if (tmp___19 == -1L) {
#line 129
      return (-1);
    }
  }
#line 133
  if (config.logenv) {
#line 134
    i = 0;
    {
#line 134
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 134
      if (! ((unsigned long )*(environ + i) != (unsigned long )((void *)0))) {
#line 134
        goto while_break___0;
      }
      {
#line 135
      tmp___21 = write(logfile___0->fh, (void const   *)logfile___0->head, (size_t )headlen);
      }
#line 135
      if (tmp___21 == -1L) {
#line 136
        return (-1);
      }
      {
#line 137
      len = snprintf((char */* __restrict  */)(buf), (size_t )80, (char const   */* __restrict  */)" env[%d] = \"",
                     i);
      }
#line 138
      if (len < 0) {
#line 139
        return (-1);
      } else
#line 138
      if (len > 80) {
#line 139
        return (-1);
      }
      {
#line 141
      tmp___22 = write(logfile___0->fh, (void const   *)(buf), (size_t )len);
      }
#line 141
      if (tmp___22 == -1L) {
#line 142
        return (-1);
      }
      {
#line 143
      tmp___23 = strlen((char const   *)*(environ + i));
#line 143
      tmp___24 = write(logfile___0->fh, (void const   *)*(environ + i), tmp___23);
      }
#line 143
      if (tmp___24 == -1L) {
#line 145
        return (-1);
      }
      {
#line 146
      tmp___25 = write(logfile___0->fh, (void const   *)"\"\n", (size_t )2);
      }
#line 146
      if (tmp___25 != 2L) {
#line 147
        return (-1);
      }
#line 134
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 152
  loctime = localtime((time_t const   *)(& app.starttime));
#line 153
  tmp___26 = strftime((char */* __restrict  */)(tmp), (size_t )50, (char const   */* __restrict  */)"%Y-%m-%d %T %Z",
                      (struct tm  const  */* __restrict  */)loctime);
#line 153
  ret = (int )tmp___26;
  }
#line 155
  if (app.starttime < 0L) {
#line 156
    tmp[0] = (char )'\000';
  } else
#line 155
  if (ret == 0) {
#line 156
    tmp[0] = (char )'\000';
  }
  {
#line 158
  snprintf((char */* __restrict  */)(buf), (size_t )80, (char const   */* __restrict  */)"%s %s\n",
           logfile___0->head, tmp);
  }
#line 159
  if (len < 0) {
#line 160
    return (-1);
  } else
#line 159
  if (len > 80) {
#line 160
    return (-1);
  }
  {
#line 162
  tmp___27 = strlen((char const   *)(buf));
#line 162
  tmp___28 = write(logfile___0->fh, (void const   *)(buf), tmp___27);
  }
#line 162
  if (tmp___28 == -1L) {
#line 163
    return (-1);
  }
#line 165
  return (0);
}
}
#line 168 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
static int logfile_add_splitmarker(logfile_t *logfile___0 ) 
{ 
  int ret ;
  int len ;
  time_t sec ;
  struct tm *loctime ;
  char buf[81] ;
  char tmp[51] ;
  ssize_t tmp___0 ;
  size_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  size_t tmp___4 ;
  time_t tmp___5 ;
  ssize_t tmp___6 ;

  {
  {
#line 177
  buf[80] = (char )'\000';
#line 180
  len = snprintf((char */* __restrict  */)(buf), (size_t )80, (char const   */* __restrict  */)"%s %s\n",
                 logfile___0->split, app.exe);
  }
#line 181
  if (len < 0) {
#line 182
    return (-1);
  } else
#line 181
  if (len > 80) {
#line 182
    return (-1);
  }
  {
#line 184
  tmp___0 = write(logfile___0->fh, (void const   *)(buf), (size_t )len);
  }
#line 184
  if (tmp___0 == -1L) {
#line 185
    return (-1);
  }
  {
#line 188
  loctime = localtime((time_t const   *)(& app.starttime));
#line 189
  tmp___1 = strftime((char */* __restrict  */)(tmp), (size_t )50, (char const   */* __restrict  */)"%Y-%m-%d %T %Z",
                     (struct tm  const  */* __restrict  */)loctime);
#line 189
  ret = (int )tmp___1;
  }
#line 191
  if (app.starttime < 0L) {
#line 192
    tmp[0] = (char )'\000';
  } else
#line 191
  if (ret == 0) {
#line 192
    tmp[0] = (char )'\000';
  }
  {
#line 194
  len = snprintf((char */* __restrict  */)(buf), (size_t )80, (char const   */* __restrict  */)"%s running since %s\n",
                 logfile___0->split, tmp);
  }
#line 196
  if (len < 0) {
#line 197
    return (-1);
  } else
#line 196
  if (len > 80) {
#line 197
    return (-1);
  }
  {
#line 199
  tmp___2 = write(logfile___0->fh, (void const   *)(buf), (size_t )len);
  }
#line 199
  if (tmp___2 == -1L) {
#line 200
    return (-1);
  }
  {
#line 203
  len = snprintf((char */* __restrict  */)(buf), (size_t )80, (char const   */* __restrict  */)"%s %d lines output (%d stdout, %d stderr)\n",
                 logfile___0->split, (app.pstdout)->linecount + (app.pstderr)->linecount,
                 (app.pstdout)->linecount, (app.pstderr)->linecount);
  }
#line 207
  if (len < 0) {
#line 208
    return (-1);
  } else
#line 207
  if (len > 80) {
#line 208
    return (-1);
  }
  {
#line 210
  tmp___3 = write(logfile___0->fh, (void const   *)(buf), (size_t )len);
  }
#line 210
  if (tmp___3 == -1L) {
#line 211
    return (-1);
  }
  {
#line 214
  tmp___5 = time(& sec);
  }
#line 214
  if (tmp___5 > -1L) {
    {
#line 215
    loctime = localtime((time_t const   *)(& sec));
#line 216
    tmp___4 = strftime((char */* __restrict  */)(tmp), (size_t )50, (char const   */* __restrict  */)"%Y-%m-%d %T %Z",
                       (struct tm  const  */* __restrict  */)loctime);
#line 216
    ret = (int )tmp___4;
    }
  }
#line 219
  if (sec < 0L) {
#line 220
    tmp[0] = (char )'\000';
  } else
#line 219
  if (ret == 0) {
#line 220
    tmp[0] = (char )'\000';
  }
#line 223
  if (app.starttime > -1L) {
#line 223
    if (app.starttime <= sec) {
      {
#line 224
      len = snprintf((char */* __restrict  */)(buf), (size_t )80, (char const   */* __restrict  */)"%s execution time is %us\n",
                     logfile___0->split, (unsigned int )(sec - app.starttime));
      }
#line 226
      if (len < 0) {
#line 227
        return (-1);
      } else
#line 226
      if (len > 80) {
#line 227
        return (-1);
      }
      {
#line 229
      tmp___6 = write(logfile___0->fh, (void const   *)(buf), (size_t )len);
      }
#line 229
      if (tmp___6 == -1L) {
#line 230
        return (-1);
      }
    } else {
      {
#line 232
      print((t_printtype )2, "Problem calculating execution time\n");
      }
    }
  } else {
    {
#line 232
    print((t_printtype )2, "Problem calculating execution time\n");
    }
  }
#line 235
  return (0);
}
}
#line 238 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
static int logfile_add_footer(logfile_t *logfile___0 ) 
{ 
  int len ;
  int tmplen ;
  time_t sec ;
  struct tm *loctime ;
  char buf[81] ;
  char tmp[51] ;
  ssize_t tmp___0 ;
  size_t tmp___1 ;
  time_t tmp___2 ;
  size_t tmp___3 ;
  ssize_t tmp___4 ;
  union __anonunion_76 __constr_expr_0 ;
  union __anonunion_77 __constr_expr_1 ;
  int tmp___5 ;
  union __anonunion_78 __constr_expr_2 ;
  union __anonunion_79 __constr_expr_3 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;
  ssize_t tmp___8 ;
  ssize_t tmp___9 ;

  {
#line 240
  len = 0;
#line 241
  tmplen = 0;
#line 248
  if (logfile___0->addnewline) {
    {
#line 249
    tmp___0 = write(logfile___0->fh, (void const   *)"\n", (size_t )1);
    }
#line 249
    if (tmp___0 == -1L) {
#line 250
      return (-1);
    }
  }
  {
#line 252
  buf[80] = (char )'\000';
#line 255
  tmp___2 = time(& sec);
  }
#line 255
  if (tmp___2 > -1L) {
    {
#line 256
    loctime = localtime((time_t const   *)(& sec));
#line 257
    tmp___1 = strftime((char */* __restrict  */)(tmp), (size_t )50, (char const   */* __restrict  */)"%Y-%m-%d %T %Z",
                       (struct tm  const  */* __restrict  */)loctime);
#line 257
    len = (int )tmp___1;
    }
  }
#line 260
  if (sec < 0L) {
#line 261
    tmp[0] = (char )'\000';
#line 262
    len = 0;
  } else
#line 260
  if (len < 1) {
#line 261
    tmp[0] = (char )'\000';
#line 262
    len = 0;
  }
  {
#line 265
  snprintf((char */* __restrict  */)(buf), (size_t )80, (char const   */* __restrict  */)"%s %s\n",
           logfile___0->foot, tmp);
  }
#line 266
  if (len < 0) {
#line 267
    return (-1);
  } else
#line 266
  if (len > 80) {
#line 267
    return (-1);
  }
  {
#line 269
  tmp___3 = strlen((char const   *)logfile___0->foot);
#line 269
  len = (int )((size_t )len + (tmp___3 + 2UL));
#line 270
  tmp___4 = write(logfile___0->fh, (void const   *)(buf), (size_t )len);
  }
#line 270
  if (tmp___4 == -1L) {
#line 271
    return (-1);
  }
  {
#line 274
  len = snprintf((char */* __restrict  */)(buf), (size_t )80, (char const   */* __restrict  */)"%s application exit status: ",
                 logfile___0->foot);
  }
#line 276
  if (len < 0) {
#line 277
    return (-1);
  } else
#line 276
  if (len > 80) {
#line 277
    return (-1);
  }
#line 279
  __constr_expr_3.__in = app.exit_state;
#line 279
  if ((__constr_expr_3.__i & 127) == 0) {
    {
#line 280
    __constr_expr_0.__in = app.exit_state;
#line 280
    tmplen = snprintf((char */* __restrict  */)(buf + len), (size_t )(80 - len), (char const   */* __restrict  */)"%d\n",
                      (__constr_expr_0.__i & 65280) >> 8);
    }
  } else {
#line 282
    __constr_expr_2.__in = app.exit_state;
#line 282
    if ((int )((signed char )((__constr_expr_2.__i & 127) + 1)) >> 1 > 0) {
      {
#line 283
      __constr_expr_1.__in = app.exit_state;
#line 283
      tmplen = snprintf((char */* __restrict  */)(buf + len), (size_t )(80 - len),
                        (char const   */* __restrict  */)"abnormal termination (signal = %d)\n",
                        __constr_expr_1.__i & 127);
      }
    } else {
      {
#line 287
      tmp___5 = snprintf((char */* __restrict  */)(buf + len), (size_t )(80 - len),
                         (char const   */* __restrict  */)"unknown\n");
#line 287
      tmplen += tmp___5;
      }
    }
  }
#line 289
  if (tmplen < 0) {
#line 290
    return (-1);
  } else
#line 289
  if (tmplen > 80) {
#line 290
    return (-1);
  }
  {
#line 292
  len += tmplen;
#line 294
  tmp___6 = write(logfile___0->fh, (void const   *)(buf), (size_t )len);
  }
#line 294
  if (tmp___6 == -1L) {
#line 295
    return (-1);
  }
  {
#line 298
  len = snprintf((char */* __restrict  */)(buf), (size_t )80, (char const   */* __restrict  */)"%s %d lines output (%d stdout, %d stderr)\n",
                 logfile___0->foot, (app.pstdout)->linecount + (app.pstderr)->linecount,
                 (app.pstdout)->linecount, (app.pstderr)->linecount);
  }
#line 302
  if (len < 0) {
#line 303
    return (-1);
  } else
#line 302
  if (len > 80) {
#line 303
    return (-1);
  }
  {
#line 305
  tmp___7 = write(logfile___0->fh, (void const   *)(buf), (size_t )len);
  }
#line 305
  if (tmp___7 == -1L) {
#line 306
    return (-1);
  }
#line 309
  if (app.starttime > -1L) {
#line 309
    if (app.starttime <= sec) {
      {
#line 310
      len = snprintf((char */* __restrict  */)(buf), (size_t )80, (char const   */* __restrict  */)"%s execution time was %us\n",
                     logfile___0->foot, (unsigned int )(sec - app.starttime));
      }
#line 312
      if (len < 0) {
#line 313
        return (-1);
      } else
#line 312
      if (len > 80) {
#line 313
        return (-1);
      }
      {
#line 315
      tmp___8 = write(logfile___0->fh, (void const   *)(buf), (size_t )len);
      }
#line 315
      if (tmp___8 == -1L) {
#line 316
        return (-1);
      }
    } else {
      {
#line 318
      print((t_printtype )2, "problem calculating execution time\n");
      }
    }
  } else {
    {
#line 318
    print((t_printtype )2, "problem calculating execution time\n");
    }
  }
  {
#line 322
  len = snprintf((char */* __restrict  */)(buf), (size_t )80, (char const   */* __restrict  */)"%s %s\n",
                 logfile___0->foot, app.exe);
  }
#line 323
  if (len < 0) {
#line 324
    return (-1);
  } else
#line 323
  if (len > 80) {
#line 324
    return (-1);
  }
  {
#line 326
  tmp___9 = write(logfile___0->fh, (void const   *)(buf), (size_t )len);
  }
#line 326
  if (tmp___9 == -1L) {
#line 327
    return (-1);
  }
#line 329
  return (0);
}
}
#line 332 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
static int logfile_rename(logfile_t *logfile___0 , char *oldname ) 
{ 
  char *newname ;
  int ret ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 335
  ret = 0;
#line 337
  if (! config.logrename) {
#line 338
    return (0);
  }
#line 340
  if ((unsigned long )oldname == (unsigned long )((void *)0)) {
#line 341
    oldname = logfile___0->name;
  }
  {
#line 343
  tmp = strlen((char const   *)oldname);
#line 343
  tmp___0 = malloc(tmp + sizeof(logfile___0->oldext));
#line 343
  newname = (char *)tmp___0;
  }
#line 345
  if ((unsigned long )newname == (unsigned long )((void *)0)) {
    {
#line 346
    error_outofmemory();
    }
#line 347
    return (-1);
  }
  {
#line 350
  strcpy((char */* __restrict  */)newname, (char const   */* __restrict  */)oldname);
#line 351
  strcat((char */* __restrict  */)newname, (char const   */* __restrict  */)logfile___0->oldext);
#line 353
  tmp___3 = rename((char const   *)oldname, (char const   *)newname);
  }
#line 353
  if (tmp___3) {
    {
#line 354
    tmp___2 = __errno_location();
    }
#line 354
    if (*tmp___2 != 2) {
      {
#line 355
      ret = -1;
#line 356
      tmp___1 = __errno_location();
#line 356
      print((t_printtype )1, "logfile rename failed (error: %d)\n", *tmp___1);
      }
    }
  }
  {
#line 360
  free((void *)newname);
  }
#line 362
  return (ret);
}
}
#line 365 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
static char *logfile_get_alternate_name(logfile_t *logfile___0 ) 
{ 
  int len ;
  char *tmp ;
  char number[12] ;
  char *name ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 369
  if (! logfile___0->appendnr) {
    {
#line 370
    tmp = strdup((char const   *)logfile___0->name);
    }
#line 370
    return (tmp);
  }
  {
#line 375
  len = snprintf((char */* __restrict  */)(number), (size_t )12, (char const   */* __restrict  */)".%d",
                 logfile___0->appendnr);
  }
#line 376
  if (len < 0) {
#line 377
    return ((char *)((void *)0));
  }
  {
#line 380
  tmp___0 = strlen((char const   *)logfile___0->name);
#line 380
  tmp___1 = strlen((char const   *)(number));
#line 380
  tmp___2 = malloc((tmp___0 + tmp___1) + 1UL);
#line 380
  name = (char *)tmp___2;
  }
#line 381
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 382
    error_outofmemory();
    }
#line 383
    return ((char *)((void *)0));
  }
  {
#line 386
  strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)logfile___0->name);
#line 387
  strcat((char */* __restrict  */)name, (char const   */* __restrict  */)(number));
  }
#line 389
  return (name);
}
}
#line 392 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
static int logfile_check_size(logfile_t *logfile___0 , int addmarker , unsigned int addsize ) 
{ 
  unsigned int curpos ;
  __off_t tmp ;
  int flags ;
  int tmp___0 ;
  int *tmp___1 ;
  __off_t tmp___2 ;
  int tmp___3 ;

  {
#line 397
  if (! logfile___0->sizelimit) {
#line 398
    return (0);
  }
  {
#line 400
  tmp = lseek(logfile___0->fh, (__off_t )0, 1);
#line 400
  curpos = (unsigned int )(tmp + (__off_t )addsize);
  }
#line 402
  if (curpos > logfile___0->sizelimit) {
#line 403
    flags = 65;
#line 405
    if (addmarker) {
      {
#line 406
      logfile_add_splitmarker(logfile___0);
      }
    }
#line 408
    if (! config.circularlog) {
      {
#line 409
      tmp___0 = logfile_rename(logfile___0, (char *)((void *)0));
      }
#line 409
      if (tmp___0) {
        {
#line 410
        print((t_printtype )2, "problem moving log - continuing anyways\n");
        }
      }
#line 413
      flags |= 512;
    } else {
      {
#line 415
      tmp___2 = lseek(logfile___0->fh, (__off_t )0, 1);
#line 415
      tmp___3 = ftruncate(logfile___0->fh, tmp___2);
      }
#line 415
      if (tmp___3 == -1) {
        {
#line 417
        tmp___1 = __errno_location();
#line 417
        print((t_printtype )2, "Problem truncating logfile (errno=%d)", *tmp___1);
        }
      }
#line 419
      return (-1);
    }
    {
#line 422
    close(logfile___0->fh);
#line 423
    logfile___0->fh = open((char const   *)logfile___0->name, flags, 420);
    }
#line 425
    if (addmarker) {
      {
#line 426
      logfile_add_splitmarker(logfile___0);
      }
    }
  }
#line 429
  return (0);
}
}
#line 466 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
static int oldmsec  =    -1;
#line 467 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
static unsigned int oldsec  =    4294967295U;
#line 432 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
int logfile_write(logfile_t *logfile___0 , pipe_t *pipe___0 ) 
{ 
  unsigned int stamp_sec ;
  int stamp_msec ;
  int writetimestamp ;
  int prefixlen ;
  int tmp ;
  struct timeval tvtime ;
  int ossec ;
  int osmsec ;
  int join ;
  ssize_t tmp___0 ;
  char timestamp[16] ;
  int len ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  int i ;
  int offset___0 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;

  {
#line 434
  stamp_sec = 0U;
#line 435
  stamp_msec = 0;
#line 436
  writetimestamp = config.logtime;
#line 437
  prefixlen = 0;
#line 439
  if (! logfile___0->name) {
#line 440
    return (0);
  }
  {
#line 443
  pthread_mutex_lock(& logfile_mutex);
  }
#line 445
  if (logfile___0->sizelimit) {
    {
#line 446
    tmp = logfile_check_size(logfile___0, 1, (unsigned int )pipe___0->bfill);
    }
#line 446
    if (tmp) {
      {
#line 447
      print((t_printtype )2, "Problem while checking/resizing logfile\n");
      }
#line 448
      return (-1);
    }
  }
#line 452
  if (config.logtime) {
#line 452
    goto _L;
  } else
#line 452
  if (config.jointimeout) {
#line 452
    if (pipe___0->charbased) {
      _L: /* CIL Label */ 
      {
#line 455
      gettimeofday((struct timeval */* __restrict  */)(& tvtime), (__timezone_ptr_t )((void *)0));
#line 456
      stamp_sec = (unsigned int )(tvtime.tv_sec - app.toffset.tv_sec);
#line 457
      stamp_msec = (int )((tvtime.tv_usec - app.toffset.tv_usec) / 1000L);
      }
#line 459
      if (stamp_msec < 0) {
#line 460
        stamp_sec --;
#line 461
        stamp_msec += 1000;
      }
#line 465
      if (config.jointimeout) {
#line 465
        if (pipe___0->charbased) {
#line 470
          join = 0;
#line 472
          osmsec = stamp_msec - oldmsec;
#line 473
          ossec = (int )(stamp_sec - oldsec);
#line 474
          if (osmsec < 0) {
#line 475
            ossec --;
#line 476
            osmsec += 1000;
          }
#line 479
          if (config.jointimeout / 1000 == ossec) {
#line 480
            if (config.jointimeout % 1000 > osmsec) {
#line 481
              join = 1;
            } else {
#line 483
              join = 0;
            }
          } else
#line 485
          if (config.jointimeout / 1000 > ossec) {
#line 486
            join = 1;
          } else {
#line 488
            join = 0;
          }
#line 491
          if (join) {
#line 492
            logfile___0->addnewline = 0;
#line 493
            writetimestamp = 0;
          }
#line 496
          if (config.logreltime) {
#line 496
            if (writetimestamp) {
#line 497
              oldmsec = 0;
#line 498
              oldsec = 0U;
            } else {
#line 500
              oldmsec = stamp_msec;
#line 501
              oldsec = stamp_sec;
            }
          } else {
#line 500
            oldmsec = stamp_msec;
#line 501
            oldsec = stamp_sec;
          }
        }
      }
#line 505
      if (config.logreltime) {
#line 505
        if (writetimestamp) {
          {
#line 506
          memcpy((void */* __restrict  */)(& app.toffset), (void const   */* __restrict  */)(& tvtime),
                 sizeof(struct timeval ));
          }
        }
      }
    }
  }
#line 511
  if (pipe___0->charbased) {
#line 513
    if (logfile___0->addnewline) {
#line 513
      if (config.alignlog) {
        {
#line 514
        tmp___0 = write(logfile___0->fh, (void const   *)"\n", (size_t )1);
        }
#line 514
        if (tmp___0 == -1L) {
#line 515
          goto failure_exit;
        }
      }
    }
#line 518
    if ((int )*(pipe___0->buf + (pipe___0->bfill - 1)) != 10) {
#line 519
      logfile___0->addnewline = 1;
    } else {
#line 521
      logfile___0->addnewline = 0;
    }
  }
#line 527
  if (writetimestamp) {
#line 533
    if (stamp_sec < 999999U) {
      {
#line 534
      len = snprintf((char */* __restrict  */)(timestamp), (size_t )12, (char const   */* __restrict  */)"%06u%03u: ",
                     stamp_sec, stamp_msec);
      }
#line 536
      if (len < 0) {
#line 537
        goto failure_exit;
      }
#line 538
      prefixlen = 11;
    } else {
      {
#line 540
      len = snprintf((char */* __restrict  */)(timestamp), (size_t )16, (char const   */* __restrict  */)"%010u%03u: ",
                     stamp_sec, stamp_msec);
      }
#line 542
      if (len < 0) {
#line 543
        goto failure_exit;
      }
#line 544
      prefixlen = 15;
    }
    {
#line 546
    tmp___1 = write(logfile___0->fh, (void const   *)(timestamp), (size_t )prefixlen);
    }
#line 546
    if (tmp___1 == -1L) {
#line 547
      goto failure_exit;
    }
  }
#line 551
  if ((unsigned long )pipe___0->lineprefix != (unsigned long )((void *)0)) {
    {
#line 552
    tmp___2 = write(logfile___0->fh, (void const   *)pipe___0->lineprefix, (size_t )pipe___0->lineprefixlen);
    }
#line 552
    if (tmp___2 == -1L) {
#line 554
      goto failure_exit;
    }
#line 556
    prefixlen += pipe___0->lineprefixlen;
  }
#line 559
  i = 0;
#line 560
  offset___0 = 0;
#line 562
  if (config.alignlinebreaks) {
#line 562
    if (pipe___0->charbased) {
      {
#line 563
      while (1) {
        while_continue: /* CIL Label */ ;
#line 563
        if (! pipe___0->linebreakpos[i]) {
#line 563
          goto while_break;
        }
#line 564
        if (i) {
          {
#line 565
          tmp___3 = write(logfile___0->fh, (void const   *)logfile___0->indent, (size_t )prefixlen);
          }
#line 565
          if (tmp___3 == -1L) {
#line 567
            goto failure_exit;
          }
        }
        {
#line 570
        tmp___4 = write(logfile___0->fh, (void const   *)(pipe___0->buf + offset___0),
                        (size_t )(pipe___0->linebreakpos[i] - offset___0));
        }
#line 570
        if (tmp___4 == -1L) {
#line 572
          goto failure_exit;
        }
#line 574
        offset___0 = pipe___0->linebreakpos[i];
#line 575
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 577
      i = offset___0;
      {
#line 577
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 577
        if (! (i < pipe___0->bfill)) {
#line 577
          goto while_break___0;
        }
#line 578
        if ((int )*(pipe___0->buf + i) == 10) {
#line 578
          goto _L___0;
        } else
#line 578
        if (i + 1 == pipe___0->bfill) {
          _L___0: /* CIL Label */ 
#line 579
          if (offset___0) {
            {
#line 580
            tmp___5 = write(logfile___0->fh, (void const   *)logfile___0->indent,
                            (size_t )prefixlen);
            }
#line 580
            if (tmp___5 == -1L) {
#line 583
              goto failure_exit;
            }
          }
          {
#line 586
          tmp___6 = write(logfile___0->fh, (void const   *)(pipe___0->buf + offset___0),
                          (size_t )((i - offset___0) + 1));
          }
#line 586
          if (tmp___6 == -1L) {
#line 589
            goto failure_exit;
          }
#line 591
          offset___0 = i + 1;
        }
#line 577
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 562
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 596
    tmp___7 = write(logfile___0->fh, (void const   *)pipe___0->buf, (size_t )pipe___0->bfill);
    }
#line 596
    if (tmp___7 == -1L) {
#line 597
      goto failure_exit;
    }
  }
  {
#line 602
  pthread_mutex_unlock(& logfile_mutex);
  }
#line 604
  return (0);
  failure_exit: 
  {
#line 608
  pthread_mutex_unlock(& logfile_mutex);
  }
#line 609
  return (-1);
}
}
#line 612 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
int get_lock(logfile_t *logfile___0 ) 
{ 
  struct flock lock ;
  int tmp ;

  {
#line 616
  if (! config.locklogfile) {
#line 617
    return (0);
  }
  {
#line 619
  lock.l_type = (short)1;
#line 620
  lock.l_start = (__off_t )0;
#line 621
  lock.l_whence = (short)0;
#line 622
  lock.l_len = (__off_t )0;
#line 624
  tmp = fcntl(logfile___0->fh, 6, & lock);
  }
#line 624
  return (tmp);
}
}
#line 627 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
int logfile_open(char *filename , logfile_t *logfile___0 ) 
{ 
  int flags ;
  char *altname ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 630
  altname = (char *)((void *)0);
#line 632
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
#line 633
    return (0);
  }
  {
#line 635
  logfile___0->name = get_longpath((char const   *)filename);
  }
#line 636
  if ((unsigned long )logfile___0->name == (unsigned long )((void *)0)) {
#line 637
    return (-1);
  }
#line 639
  flags = 1089;
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 641
    if (! (logfile___0->appendnr < config.maxlogfiles)) {
#line 641
      goto while_break;
    }
#line 642
    if ((unsigned long )altname != (unsigned long )((void *)0)) {
      {
#line 643
      free((void *)altname);
      }
    }
    {
#line 645
    altname = logfile_get_alternate_name(logfile___0);
    }
#line 646
    if ((unsigned long )logfile___0->name == (unsigned long )((void *)0)) {
#line 647
      return (-1);
    }
#line 649
    if (! config.appendlog) {
      {
#line 652
      logfile___0->fh = open((char const   *)altname, 1, 420);
      }
#line 653
      if (logfile___0->fh != -1) {
        {
#line 654
        tmp___0 = get_lock(logfile___0);
        }
#line 654
        if (tmp___0) {
          {
#line 665
          close(logfile___0->fh);
#line 666
          logfile___0->fh = -1;
#line 667
          (logfile___0->appendnr) ++;
          }
#line 668
          goto while_continue;
        } else {
          {
#line 655
          close(logfile___0->fh);
#line 656
          tmp = logfile_rename(logfile___0, altname);
          }
#line 656
          if (tmp) {
#line 659
            logfile___0->fh = -1;
#line 660
            (logfile___0->appendnr) ++;
#line 661
            goto while_continue;
          }
        }
      }
    }
    {
#line 673
    logfile___0->fh = open((char const   *)altname, flags, 420);
#line 674
    tmp___1 = get_lock(logfile___0);
    }
#line 674
    if (tmp___1) {
      {
#line 675
      close(logfile___0->fh);
#line 676
      logfile___0->fh = -1;
#line 677
      (logfile___0->appendnr) ++;
      }
#line 678
      goto while_continue;
    }
#line 680
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 685
  free((void *)logfile___0->name);
#line 686
  logfile___0->name = altname;
  }
#line 688
  if (logfile___0->fh == -1) {
#line 689
    if (logfile___0->appendnr == config.maxlogfiles) {
      {
#line 690
      print((t_printtype )2, "no possible logfile is writeable\n");
#line 691
      print((t_printtype )2, "-> check permissions or try increasing the maxaltlogfiles value\n");
      }
    }
#line 694
    return (-1);
  }
#line 697
  if (logfile___0->appendnr) {
#line 697
    if (config.warnlogfilelock) {
      {
#line 698
      print((t_printtype )1, "using %s as logfile\n", logfile___0->name);
#line 699
      print((t_printtype )1, "most likely another logapp session is locking the logfile\n");
      }
    }
  }
#line 703
  if (! config.appendlog) {
    {
#line 704
    tmp___3 = ftruncate(logfile___0->fh, (__off_t )0);
    }
#line 704
    if (tmp___3 == -1) {
      {
#line 705
      tmp___2 = __errno_location();
#line 705
      print((t_printtype )2, "Problem truncating logfile (errno = %d)\n", *tmp___2);
      }
#line 707
      return (-1);
    }
  }
  {
#line 711
  tmp___4 = logfile_add_header(logfile___0);
  }
#line 711
  if (tmp___4) {
    {
#line 712
    print((t_printtype )2, "problem writing log header to file\n");
    }
#line 713
    return (-1);
  }
#line 716
  return (0);
}
}
#line 719 "/home/wheatley/newnew/temp/logapp-0.15/logfile.c"
int logfile_close(logfile_t *logfile___0 ) 
{ 
  int tmp ;

  {
#line 721
  if (! logfile___0->name) {
#line 722
    return (0);
  }
  {
#line 724
  tmp = logfile_add_footer(logfile___0);
  }
#line 724
  if (tmp) {
    {
#line 725
    print((t_printtype )2, "problem writing log footer to file\n");
    }
#line 726
    return (-1);
  }
  {
#line 729
  close(logfile___0->fh);
  }
#line 731
  return (0);
}
}
#line 32 "/home/wheatley/newnew/temp/logapp-0.15/logapp.h"
int execcmd(char *cmd ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 70 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 86
extern int tcdrain(int __fd ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 253
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 261
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 577 "/usr/include/regex.h"
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 150 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
logfile_t logfile ;
#line 22 "/home/wheatley/newnew/temp/logapp-0.15/capture.h"
void reset_console(void) ;
#line 23
int capture_start(void) ;
#line 24
int capture_end(void) ;
#line 25
void print_summary(void) ;
#line 40 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
int handle_cbstream(pipe_t *pipe___0 ) ;
#line 42 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
void reset_console(void) 
{ 
  int err ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 44
  err = 0;
#line 46
  if (! config.dumbterm) {
    {
#line 47
    tmp = write((app.pstdout)->cfhno, (void const   *)(app.pstdout)->escreset, (size_t )(app.pstdout)->escresetlen);
#line 47
    err = (int )tmp;
#line 49
    tmp___0 = write((app.pstderr)->cfhno, (void const   *)(app.pstderr)->escreset,
                    (size_t )(app.pstderr)->escresetlen);
#line 49
    err = (int )tmp___0;
    }
  }
#line 53
  if ((unsigned long )app.ptytermios_bak != (unsigned long )((void *)0)) {
    {
#line 54
    tcsetattr(0, 1, (struct termios  const  *)app.ptytermios_bak);
    }
  }
  {
#line 56
  tcdrain(1);
#line 57
  tcdrain(2);
  }
#line 59
  if (err == -1) {
    {
#line 60
    print((t_printtype )1, "Problem reseting console...");
    }
  }
#line 62
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
static int recalc_cliplen(pipe_t *pipe___0 ) 
{ 
  int i ;
  int length ;
  int checklen ;
  int tmp ;

  {
#line 67
  length = 0;
#line 70
  if (pipe___0->bfill > pipe___0->clip) {
#line 71
    checklen = pipe___0->clip;
  } else {
#line 74
    checklen = pipe___0->bfill;
  }
#line 77
  i = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < pipe___0->bfill)) {
#line 77
      goto while_break;
    }
    {
#line 79
    if ((int )*(pipe___0->buf + i) == 9) {
#line 79
      goto case_9;
    }
#line 81
    goto switch_default;
    case_9: /* CIL Label */ 
#line 79
    length += 8 - length % 8;
#line 80
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 81
    length ++;
#line 82
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 84
    if (length > pipe___0->clip) {
#line 85
      tmp = i;
#line 85
      i --;
#line 85
      return (tmp);
    }
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (pipe___0->clip);
}
}
#line 94 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
static pipe_t *pipe_old  ;
#line 95 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
static unsigned int offset  ;
#line 92 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
int print_stream(pipe_t *pipe___0 ) 
{ 
  char *buf ;
  unsigned int ccount ;
  unsigned int esclength ;
  int regmatch ;
  int tmp ;
  unsigned int clip ;
  int tmp___0 ;
  int rlen ;
  ssize_t tmp___1 ;

  {
#line 98
  esclength = 0U;
#line 99
  regmatch = 0;
#line 101
  if (pipe___0->bfill < 1) {
#line 102
    return (1);
  }
#line 104
  if (! config.dumbterm) {
#line 106
    if (pipe___0->regexp) {
      {
#line 107
      tmp = regexec((regex_t const   */* __restrict  */)(& pipe___0->preg), (char const   */* __restrict  */)pipe___0->buf,
                    (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
      }
#line 107
      if (! tmp) {
#line 108
        regmatch = 1;
      }
    }
#line 113
    if ((unsigned long )((void *)pipe_old) != (unsigned long )((void *)pipe___0)) {
#line 113
      goto _L;
    } else
#line 113
    if (regmatch) {
      _L: /* CIL Label */ 
#line 114
      offset = 0U;
#line 115
      buf = pipe___0->esccolor;
#line 116
      esclength = (unsigned int )(pipe___0->buf - pipe___0->esccolor);
#line 117
      if (pipe___0->bgesccolor) {
#line 118
        if (! regmatch) {
#line 119
          *(pipe___0->bgesccolor) = (char )(pipe___0->bgcol + 48);
#line 120
          pipe_old = pipe___0;
        } else {
#line 122
          *(pipe___0->bgesccolor) = (char )(pipe___0->regbgcol + 48);
#line 124
          pipe_old = (pipe_t *)((void *)0);
        }
      } else {
#line 127
        pipe_old = pipe___0;
      }
    } else {
#line 130
      buf = pipe___0->buf;
    }
  } else {
#line 133
    buf = pipe___0->buf;
  }
#line 137
  if (pipe___0->eclip) {
#line 141
    if (pipe___0->recalclen) {
      {
#line 142
      tmp___0 = recalc_cliplen(pipe___0);
#line 142
      clip = (unsigned int )tmp___0;
      }
    } else {
#line 144
      clip = (unsigned int )pipe___0->clip;
    }
#line 147
    if (offset >= clip) {
#line 148
      return (0);
    }
#line 150
    if ((unsigned int )pipe___0->bfill + offset > clip) {
#line 151
      ccount = clip - offset;
#line 152
      *(pipe___0->buf + ccount) = (char )'\n';
#line 153
      ccount ++;
#line 154
      offset = 0U;
    } else {
#line 156
      ccount = (unsigned int )pipe___0->bfill;
#line 157
      if ((int )*(pipe___0->buf + (ccount - 1U)) == 10) {
#line 158
        offset = 0U;
      } else {
#line 160
        offset += ccount;
      }
    }
  } else {
#line 164
    ccount = (unsigned int )pipe___0->bfill;
  }
#line 167
  if (regmatch) {
#line 167
    if (! config.dumbterm) {
#line 169
      if ((int )*(pipe___0->buf + (ccount - 1U)) == 10) {
        {
#line 170
        rlen = pipe___0->escresetlen + 1;
#line 171
        strcpy((char */* __restrict  */)(pipe___0->buf + (ccount - 1U)), (char const   */* __restrict  */)pipe___0->escreset);
#line 172
        strcpy((char */* __restrict  */)(pipe___0->buf + ((ccount - 1U) + (unsigned int )rlen)),
               (char const   */* __restrict  */)"\n");
#line 173
        esclength += (unsigned int )rlen;
#line 174
        regmatch = 1;
        }
      } else {
#line 176
        regmatch = 0;
      }
    }
  }
  {
#line 180
  tmp___1 = write(pipe___0->cfhno, (void const   *)buf, (size_t )(ccount + esclength));
  }
#line 180
  if (tmp___1 == -1L) {
#line 181
    return (-1);
  }
#line 183
  if (regmatch) {
#line 183
    if (! config.dumbterm) {
#line 185
      if (regmatch) {
#line 186
        *(pipe___0->buf + (ccount - 1U)) = (char )'\n';
      }
    }
  }
#line 190
  pipe___0->recalclen = 0;
#line 192
  return (1);
}
}
#line 195 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
void print_summary(void) 
{ 
  time_t sec ;
  unsigned int executiontime ;
  union __anonunion_79___0 __constr_expr_4 ;
  union __anonunion_80 __constr_expr_5 ;
  union __anonunion_81 __constr_expr_6 ;
  union __anonunion_82 __constr_expr_7 ;

  {
  {
#line 198
  executiontime = 0U;
#line 200
  time(& sec);
  }
#line 202
  if (app.starttime > -1L) {
#line 202
    if (app.starttime <= sec) {
#line 203
      executiontime = (unsigned int )(sec - app.starttime);
    } else {
      {
#line 205
      print((t_printtype )2, "Error calculating execution time\n");
      }
    }
  } else {
    {
#line 205
    print((t_printtype )2, "Error calculating execution time\n");
    }
  }
  {
#line 208
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nLogapp exited after %us; ",
          executiontime);
  }
#line 210
  if (! (app.pstdout)->charbased) {
    {
#line 211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%u",
            (app.pstdout)->linecount);
    }
  } else {
    {
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"?");
    }
  }
  {
#line 216
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" stdout, ");
  }
#line 218
  if (! (app.pstderr)->charbased) {
    {
#line 219
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%u",
            (app.pstderr)->linecount);
    }
  } else {
    {
#line 221
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"?");
    }
  }
  {
#line 224
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" stderr lines;");
#line 226
  __constr_expr_7.__in = app.exit_state;
  }
#line 226
  if ((__constr_expr_7.__i & 127) == 0) {
    {
#line 227
    __constr_expr_4.__in = app.exit_state;
#line 227
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" exit state %u\n",
            (__constr_expr_4.__i & 65280) >> 8);
    }
  } else {
#line 229
    __constr_expr_6.__in = app.exit_state;
#line 229
    if ((int )((signed char )((__constr_expr_6.__i & 127) + 1)) >> 1 > 0) {
      {
#line 230
      __constr_expr_5.__in = app.exit_state;
#line 230
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" signal %d\n",
              __constr_expr_5.__i & 127);
      }
    } else {
      {
#line 233
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" unknown exit state\n");
      }
    }
  }
#line 237
  if (logfile.appendnr) {
#line 237
    if (config.warnlogfilelock) {
      {
#line 239
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Logapp logfile is: %s\n",
              logfile.name);
      }
    } else {
#line 237
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 237
  if (config.printlogname) {
    {
#line 239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Logapp logfile is: %s\n",
            logfile.name);
    }
  }
#line 240
  return;
}
}
#line 242 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
__inline int is_rdbuf_empty(pipe_t *pipe___0 ) 
{ 


  {
#line 244
  return ((unsigned long )pipe___0->rdbuf.read >= (unsigned long )pipe___0->rdbuf.end);
}
}
#line 247 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
int buf_get_char(pipe_t *pipe___0 , char *buf ) 
{ 
  int i ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  {
#line 252
  tmp___0 = is_rdbuf_empty(pipe___0);
  }
#line 252
  if (tmp___0) {
#line 253
    pipe___0->rdbuf.read = pipe___0->rdbuf.start;
#line 255
    if (pipe___0->switchtocbmode) {
#line 256
      pipe___0->charbased = 1;
#line 257
      pipe___0->handler = (int (*)(void * ))(& handle_cbstream);
#line 258
      return (0);
    }
    {
#line 261
    tmp = read(pipe___0->fh, (void *)pipe___0->rdbuf.start, (size_t )pipe___0->rdbuf.len);
#line 261
    i = (int )tmp;
    }
#line 262
    if (i < 1) {
#line 263
      pipe___0->rdbuf.end = pipe___0->rdbuf.start;
#line 264
      return (i);
    }
#line 267
    pipe___0->rdbuf.end = pipe___0->rdbuf.start + i;
  }
#line 271
  *buf = *(pipe___0->rdbuf.read);
#line 273
  (pipe___0->rdbuf.read) ++;
#line 275
  return (1);
}
}
#line 278 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
int read_pipe(pipe_t *pipe___0 ) 
{ 
  int i ;

  {
#line 280
  i = 0;
#line 282
  if (pipe___0->state > 0) {
#line 283
    pipe___0->recalclen = 0;
#line 284
    pipe___0->bfill = 0;
  }
#line 288
  if (pipe___0->memcr) {
#line 289
    *(pipe___0->buf) = (char )'\r';
#line 290
    (pipe___0->bfill) ++;
#line 291
    pipe___0->memcr = 0;
  }
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 295
    i = buf_get_char(pipe___0, pipe___0->buf + pipe___0->bfill);
    }
#line 296
    if (i < 1) {
#line 297
      return (pipe___0->bfill);
    }
#line 299
    if ((int )*(pipe___0->buf + pipe___0->bfill) == 9) {
#line 300
      pipe___0->recalclen = 1;
    }
#line 302
    if ((int )*(pipe___0->buf + pipe___0->bfill) == 10) {
#line 302
      goto _L___2;
    } else
#line 302
    if (i + pipe___0->bfill >= pipe___0->blen) {
#line 302
      goto _L___2;
    } else
#line 302
    if ((int )*(pipe___0->buf + pipe___0->bfill) == 27) {
#line 302
      if (pipe___0->detectescape) {
        _L___2: /* CIL Label */ 
#line 306
        if ((int )*(pipe___0->buf + pipe___0->bfill) == 10) {
#line 306
          if (i > 0) {
#line 308
            if (pipe___0->ptyremovecr) {
#line 308
              if (pipe___0->bfill > 0) {
#line 310
                if ((int )*(pipe___0->buf + (pipe___0->bfill - 1)) == 13) {
#line 311
                  (pipe___0->bfill) --;
#line 312
                  *(pipe___0->buf + pipe___0->bfill) = (char )'\n';
                }
              }
            }
#line 315
            (pipe___0->bfill) ++;
#line 316
            (pipe___0->linecount) ++;
          } else {
#line 306
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 317
        if ((int )*(pipe___0->buf + pipe___0->bfill) == 27) {
#line 317
          if (pipe___0->detectescape) {
#line 317
            if (i > 0) {
#line 319
              (pipe___0->bfill) ++;
#line 322
              pipe___0->switchtocbmode = 1;
            } else {
#line 317
              goto _L___0;
            }
          } else {
#line 317
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 323
        if (i + pipe___0->bfill >= pipe___0->blen) {
#line 324
          (pipe___0->bfill) ++;
        }
#line 329
        if ((int )*(pipe___0->buf + (pipe___0->bfill - 1)) == 13) {
#line 330
          pipe___0->memcr = 1;
#line 331
          (pipe___0->bfill) --;
        }
#line 335
        *(pipe___0->buf + pipe___0->bfill) = (char )'\000';
#line 337
        return (pipe___0->bfill);
      }
    }
#line 339
    if (pipe___0->bfill < pipe___0->blen) {
#line 340
      (pipe___0->bfill) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return (0);
}
}
#line 346 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
int prepare_buffer(pipe_t *pipe___0 ) 
{ 
  int len ;
  char *tmp ;
  void *tmp___0 ;
  struct stat statbuf ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 348
  if (pipe___0->blen) {
    {
#line 350
    len = (pipe___0->blen + pipe___0->esccolorlen) + 1;
#line 352
    tmp___0 = malloc((size_t )len);
#line 352
    tmp = (char *)tmp___0;
#line 352
    pipe___0->dbuf = tmp;
    }
#line 352
    if (! tmp) {
      {
#line 353
      error_outofmemory();
#line 354
      print((t_printtype )2, "trying to allocate %d byte %s buffer\n", len, pipe___0->name);
      }
#line 356
      return (-1);
    }
#line 361
    if (! pipe___0->charbased) {
      {
#line 364
      tmp___1 = fstat(pipe___0->fh, & statbuf);
      }
#line 364
      if (tmp___1) {
        {
#line 365
        print((t_printtype )2, "unable to get io buffer stats for %s\n", pipe___0->name);
#line 367
        free((void *)pipe___0->dbuf);
#line 368
        pipe___0->dbuf = (char *)((void *)0);
        }
#line 369
        return (-1);
      }
      {
#line 371
      pipe___0->rdbuf.len = (int )statbuf.st_blksize;
#line 373
      tmp___2 = malloc((size_t )pipe___0->rdbuf.len);
#line 373
      pipe___0->rdbuf.start = (char *)tmp___2;
      }
#line 374
      if (! pipe___0->rdbuf.start) {
        {
#line 375
        error_outofmemory();
#line 376
        print((t_printtype )2, "trying to allocate %d byte %s read buffer\n", pipe___0->rdbuf.len,
              pipe___0->name);
#line 379
        free((void *)pipe___0->buf);
#line 380
        pipe___0->buf = (char *)((void *)0);
        }
#line 381
        return (-1);
      }
#line 383
      pipe___0->rdbuf.read = pipe___0->rdbuf.start;
#line 384
      pipe___0->rdbuf.end = pipe___0->rdbuf.start;
    }
    {
#line 391
    strcpy((char */* __restrict  */)pipe___0->dbuf, (char const   */* __restrict  */)pipe___0->esccolor);
#line 392
    free((void *)pipe___0->esccolor);
    }
#line 393
    if (pipe___0->bgesccolor) {
#line 394
      pipe___0->bgesccolor = pipe___0->dbuf + (pipe___0->bgesccolor - pipe___0->esccolor);
    }
#line 397
    pipe___0->esccolor = pipe___0->dbuf;
#line 398
    pipe___0->buf = pipe___0->dbuf + pipe___0->esccolorlen;
  }
#line 401
  return (0);
}
}
#line 404 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
void free_buffer(pipe_t *pipe___0 ) 
{ 


  {
#line 406
  if (pipe___0->dbuf) {
    {
#line 407
    free((void *)pipe___0->dbuf);
    }
#line 408
    if ((unsigned long )pipe___0->dbuf == (unsigned long )pipe___0->esccolor) {
#line 409
      pipe___0->esccolor = (char *)((void *)0);
    }
#line 410
    pipe___0->dbuf = (char *)((void *)0);
#line 411
    pipe___0->buf = (char *)((void *)0);
  }
#line 414
  if (pipe___0->rdbuf.start) {
    {
#line 415
    free((void *)pipe___0->rdbuf.start);
#line 416
    pipe___0->rdbuf.start = (char *)((void *)0);
#line 417
    pipe___0->rdbuf.read = (char *)((void *)0);
#line 418
    pipe___0->rdbuf.end = (char *)((void *)0);
    }
  }
#line 421
  return;
}
}
#line 423 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
int handle_cbstream(pipe_t *pipe___0 ) 
{ 
  int i ;
  int lbo ;
  char *bufa ;
  char *bufb ;
  int tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 426
  if (pipe___0->memcr) {
#line 427
    *(pipe___0->buf) = (char )'\r';
  }
  {
#line 430
  tmp___5 = read(pipe___0->fh, (void *)(pipe___0->buf + pipe___0->memcr), (size_t )(pipe___0->blen - pipe___0->memcr));
#line 430
  tmp___4 = (int )tmp___5;
#line 430
  pipe___0->bfill = tmp___4;
  }
#line 430
  if (tmp___4 > 0) {
#line 433
    pipe___0->bfill += pipe___0->memcr;
#line 436
    if (pipe___0->ptyremovecr) {
#line 438
      lbo = 0;
#line 439
      bufa = pipe___0->buf;
#line 440
      bufb = pipe___0->buf;
#line 442
      i = 0;
      {
#line 442
      while (1) {
        while_continue: /* CIL Label */ ;
#line 442
        if (! (i < pipe___0->bfill - 1)) {
#line 442
          goto while_break;
        }
#line 443
        *bufb = *bufa;
#line 444
        bufa ++;
#line 445
        bufb ++;
#line 446
        if ((int )*bufa == 10) {
#line 447
          if ((int )*(bufa - 1) == 13) {
#line 448
            bufb --;
          }
#line 449
          if (config.alignlinebreaks) {
#line 449
            if (lbo < 8) {
#line 451
              tmp = lbo;
#line 451
              lbo ++;
#line 451
              pipe___0->linebreakpos[tmp] = (int )((bufb - pipe___0->buf) + 1L);
            }
          }
        }
#line 442
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 456
      pipe___0->bfill = (int )((long )pipe___0->bfill - (bufa - bufb));
#line 457
      *bufb = *bufa;
#line 459
      pipe___0->linebreakpos[lbo] = 0;
#line 463
      if (! pipe___0->linebreakpos[0]) {
#line 464
        pipe___0->linebreakpos[0] = pipe___0->bfill;
#line 465
        pipe___0->linebreakpos[1] = 0;
      }
#line 470
      if ((int )*(pipe___0->buf + (pipe___0->bfill - 1)) == 13) {
#line 471
        pipe___0->memcr = 1;
#line 472
        (pipe___0->bfill) --;
#line 474
        if (pipe___0->bfill <= 0) {
#line 475
          return (0);
        }
      } else {
#line 478
        pipe___0->memcr = 0;
      }
    }
    {
#line 483
    tmp___0 = write(pipe___0->cfhno, (void const   *)pipe___0->buf, (size_t )pipe___0->bfill);
    }
#line 483
    if (tmp___0 == -1L) {
      {
#line 484
      print((t_printtype )2, "Problem writing data to screen for %s\n", pipe___0->name);
      }
#line 486
      return (-1);
    }
    {
#line 490
    tmp___1 = logfile_write(app.logfile, pipe___0);
    }
#line 490
    if (tmp___1) {
      {
#line 491
      print((t_printtype )2, "error writing logfile\n");
      }
#line 492
      return (-1);
    }
  } else {
#line 498
    if (! app.active) {
#line 501
      if (pipe___0->memcr) {
        {
#line 502
        pipe___0->bfill = 1;
#line 505
        tmp___2 = write(pipe___0->cfhno, (void const   *)pipe___0->buf, (size_t )pipe___0->bfill);
        }
#line 505
        if (tmp___2 == -1L) {
          {
#line 507
          print((t_printtype )2, "Problem writing data to screen for %s\n", pipe___0->name);
          }
#line 509
          return (-1);
        }
        {
#line 513
        tmp___3 = logfile_write(app.logfile, pipe___0);
        }
#line 513
        if (tmp___3) {
          {
#line 514
          print((t_printtype )2, "error writing logfile\n");
          }
#line 515
          return (-1);
        }
      }
#line 518
      return (1);
    }
#line 521
    return (2);
  }
#line 524
  return (0);
}
}
#line 527 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
int handle_lbstream(pipe_t *pipe___0 ) 
{ 
  int clearbuf ;
  int tmp ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 529
  tmp___4 = read_pipe(pipe___0);
#line 529
  pipe___0->state = tmp___4;
  }
#line 529
  if (tmp___4 > 0) {
    {
#line 532
    tmp = logfile_write(app.logfile, pipe___0);
    }
#line 532
    if (tmp) {
      {
#line 533
      print((t_printtype )2, "error writing logfile\n");
      }
#line 534
      return (-1);
    }
    {
#line 537
    clearbuf = print_stream(pipe___0);
    }
#line 537
    if (clearbuf < 0) {
      {
#line 538
      print((t_printtype )2, "error printing %s output\n", pipe___0->name);
      }
#line 539
      return (-1);
    }
#line 543
    if (clearbuf) {
#line 544
      pipe___0->bfill = 0;
    }
#line 547
    if (pipe___0->execregexp) {
      {
#line 548
      tmp___2 = regexec((regex_t const   */* __restrict  */)(& pipe___0->pexecreg),
                        (char const   */* __restrict  */)pipe___0->buf, (size_t )pipe___0->bfill,
                        (regmatch_t */* __restrict  */)((void *)0), 0);
      }
#line 548
      if (! tmp___2) {
        {
#line 550
        tmp___0 = execcmd(pipe___0->execcommand);
#line 550
        ret = tmp___0;
        }
#line 551
        if (ret) {
#line 552
          if (config.exitonexecfail) {
#line 552
            tmp___1 = 2;
          } else {
#line 552
            tmp___1 = 1;
          }
          {
#line 552
          print((t_printtype )tmp___1, "command \"%s\" returned 0x%x\n", pipe___0->execcommand,
                ret);
          }
#line 556
          if (config.exitonexecfail) {
            {
#line 557
            exit(1);
            }
          }
        }
      }
    }
  } else {
    {
#line 564
    tmp___3 = is_rdbuf_empty(pipe___0);
    }
#line 564
    if (! tmp___3) {
#line 565
      return (0);
    }
#line 569
    if (! app.active) {
#line 570
      return (1);
    }
#line 571
    return (2);
  }
#line 574
  return (0);
}
}
#line 577 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
void *capture_thread(void *do_pipe ) 
{ 
  fd_set fd_pipe ;
  pipe_t *pipe___0 ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;

  {
#line 580
  pipe___0 = (pipe_t *)do_pipe;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fd_pipe.__fds_bits[0]): "memory");
#line 583
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 584
  fd_pipe.__fds_bits[pipe___0->fh / (8 * (int )sizeof(__fd_mask ))] |= 1L << pipe___0->fh % (8 * (int )sizeof(__fd_mask ));
#line 586
  if (pipe___0->charbased) {
#line 587
    pipe___0->handler = (int (*)(void * ))(& handle_cbstream);
  } else {
#line 589
    pipe___0->handler = (int (*)(void * ))(& handle_lbstream);
  }
  {
#line 592
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 593
    tmp___0 = select(pipe___0->fh + 1, (fd_set */* __restrict  */)(& fd_pipe), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 593
    if (tmp___0 == 1) {
      {
#line 594
      tmp = (*(pipe___0->handler))((void *)pipe___0);
      }
      {
#line 595
      if (tmp == -1) {
#line 595
        goto case_neg_1;
      }
#line 598
      if (tmp == 1) {
#line 598
        goto case_1;
      }
#line 601
      if (tmp == 2) {
#line 601
        goto case_2;
      }
#line 603
      goto switch_default;
      case_neg_1: /* CIL Label */ 
      {
#line 595
      reset_console();
#line 596
      exit(1);
      }
#line 597
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 599
      pthread_exit((void *)0);
      }
#line 600
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 601
      usleep((__useconds_t )10000);
      }
#line 602
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 603
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 607
      pthread_exit((void *)0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 612 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
int capture_loop(pipe_t *pipe_stdout , pipe_t *pipe_stderr ) 
{ 
  fd_set rdfs ;
  long flags ;
  int do_stdout_loop ;
  int do_stderr_loop ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 615
  flags = 0L;
#line 616
  do_stdout_loop = 1;
#line 617
  do_stderr_loop = 1;
#line 619
  if (pipe_stdout->charbased) {
#line 620
    pipe_stdout->handler = (int (*)(void * ))(& handle_cbstream);
  } else {
#line 622
    pipe_stdout->handler = (int (*)(void * ))(& handle_lbstream);
  }
#line 625
  if (pipe_stderr->charbased) {
#line 626
    pipe_stderr->handler = (int (*)(void * ))(& handle_cbstream);
  } else {
#line 628
    pipe_stderr->handler = (int (*)(void * ))(& handle_lbstream);
  }
  {
#line 631
  fcntl(pipe_stdout->fh, 3, flags);
#line 632
  fcntl(pipe_stdout->fh, 4, flags | 2048L);
#line 633
  fcntl(pipe_stderr->fh, 3, flags);
#line 634
  fcntl(pipe_stderr->fh, 4, flags | 2048L);
  }
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (! do_stdout_loop) {
#line 636
      if (! do_stderr_loop) {
#line 636
        goto while_break;
      }
    }
    {
#line 638
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 638
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rdfs.__fds_bits[0]): "memory");
#line 638
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 639
    rdfs.__fds_bits[pipe_stdout->fh / (8 * (int )sizeof(__fd_mask ))] |= 1L << pipe_stdout->fh % (8 * (int )sizeof(__fd_mask ));
#line 640
    rdfs.__fds_bits[pipe_stderr->fh / (8 * (int )sizeof(__fd_mask ))] |= 1L << pipe_stderr->fh % (8 * (int )sizeof(__fd_mask ));
#line 642
    tmp___1 = select(1024, (fd_set */* __restrict  */)(& rdfs), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 642
    if (tmp___1 > 0) {
#line 644
      if ((rdfs.__fds_bits[pipe_stdout->fh / (8 * (int )sizeof(__fd_mask ))] & (1L << pipe_stdout->fh % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 646
        tmp = (*(pipe_stdout->handler))((void *)pipe_stdout);
        }
        {
#line 647
        if (tmp == -1) {
#line 647
          goto case_neg_1;
        }
#line 650
        if (tmp == 1) {
#line 650
          goto case_1;
        }
#line 653
        goto switch_default;
        case_neg_1: /* CIL Label */ 
        {
#line 647
        reset_console();
#line 648
        do_stdout_loop = 0;
        }
#line 649
        goto switch_break;
        case_1: /* CIL Label */ 
#line 650
        do_stdout_loop = 0;
#line 651
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 653
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 656
      if ((rdfs.__fds_bits[pipe_stderr->fh / (8 * (int )sizeof(__fd_mask ))] & (1L << pipe_stderr->fh % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 658
        tmp___0 = (*(pipe_stdout->handler))((void *)pipe_stderr);
        }
        {
#line 659
        if (tmp___0 == -1) {
#line 659
          goto case_neg_1___0;
        }
#line 662
        if (tmp___0 == 1) {
#line 662
          goto case_1___0;
        }
#line 665
        goto switch_default___0;
        case_neg_1___0: /* CIL Label */ 
        {
#line 659
        reset_console();
#line 660
        do_stderr_loop = 0;
        }
#line 661
        goto switch_break___0;
        case_1___0: /* CIL Label */ 
#line 662
        do_stderr_loop = 0;
#line 663
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 665
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    } else {
#line 671
      do_stdout_loop = 0;
#line 672
      do_stderr_loop = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 677
  return (0);
}
}
#line 680 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
int capture_start(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 682
  tmp = prepare_buffer(app.pstdout);
  }
#line 682
  if (tmp) {
    {
#line 683
    exit(1);
    }
  }
  {
#line 685
  tmp___0 = prepare_buffer(app.pstderr);
  }
#line 685
  if (tmp___0) {
    {
#line 686
    exit(1);
    }
  }
  {
#line 690
  pthread_create((pthread_t */* __restrict  */)(& (app.pstderr)->ct), (pthread_attr_t const   */* __restrict  */)((void *)0),
                 & capture_thread, (void */* __restrict  */)app.pstderr);
#line 692
  pthread_create((pthread_t */* __restrict  */)(& (app.pstdout)->ct), (pthread_attr_t const   */* __restrict  */)((void *)0),
                 & capture_thread, (void */* __restrict  */)app.pstdout);
  }
#line 698
  return (0);
}
}
#line 701 "/home/wheatley/newnew/temp/logapp-0.15/capture.c"
int capture_end(void) 
{ 


  {
  {
#line 705
  pthread_join((app.pstderr)->ct, (void **)((void *)0));
#line 706
  pthread_join((app.pstdout)->ct, (void **)((void *)0));
#line 709
  free_buffer(app.pstdout);
#line 710
  free_buffer(app.pstderr);
  }
#line 712
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 717
extern int system(char const   *__command ) ;
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 33 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) openpty)(int *__amaster ,
                                                                              int *__aslave ,
                                                                              char *__name ,
                                                                              struct termios  const  *__termp ,
                                                                              struct winsize  const  *__winp ) ;
#line 177 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
int show_usage ;
#line 178
int show_version ;
#line 179
int show_config ;
#line 202
arglist_t arglist[56] ;
#line 204
int const   arglistsize ;
#line 206
int parse_args(int argc , char **argv ) ;
#line 207
void show_configuration(void) ;
#line 208
int get_config(void) ;
#line 209
int fixup_config(void) ;
#line 210
void cleanup_config(void) ;
#line 211
int get_display_parameters(void) ;
#line 212
int adjust_clipping(void) ;
#line 213
int check_for_disable_keywords(void) ;
#line 52 "/home/wheatley/newnew/temp/logapp-0.15/main.c"
char const   string_outofmemory[29]  = 
#line 52 "/home/wheatley/newnew/temp/logapp-0.15/main.c"
  {      (char const   )'l',      (char const   )'o',      (char const   )'g',      (char const   )'a', 
        (char const   )'p',      (char const   )'p',      (char const   )' ',      (char const   )'e', 
        (char const   )'r',      (char const   )'r',      (char const   )'o',      (char const   )'r', 
        (char const   )':',      (char const   )' ',      (char const   )'o',      (char const   )'u', 
        (char const   )'t',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'m',      (char const   )'e',      (char const   )'m', 
        (char const   )'o',      (char const   )'r',      (char const   )'y',      (char const   )'\n', 
        (char const   )'\000'};
#line 54 "/home/wheatley/newnew/temp/logapp-0.15/main.c"
void error_outofmemory(void) 
{ 
  int ret ;
  ssize_t tmp ;

  {
  {
#line 58
  tmp = write(2, (void const   *)(string_outofmemory), sizeof(string_outofmemory));
#line 58
  ret = (int )tmp;
  }
#line 60
  return;
}
}
#line 63 "/home/wheatley/newnew/temp/logapp-0.15/main.c"
void print(t_printtype type , char const   *format  , ...) 
{ 
  va_list argptr ;
  int format_len ;
  int fmt_len ;
  int exec_len ;
  int warn_len ;
  int err_len ;
  char *fmtstring ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 73
  tmp = strlen(format);
#line 73
  format_len = (int )tmp;
#line 74
  tmp___0 = strlen("logapp");
#line 74
  exec_len = (int )tmp___0;
#line 75
  tmp___1 = strlen(" warning: ");
#line 75
  warn_len = (int )tmp___1;
#line 76
  tmp___2 = strlen(" error: ");
#line 76
  err_len = (int )tmp___2;
  }
#line 77
  if (warn_len > err_len) {
#line 77
    tmp___3 = warn_len;
  } else {
#line 77
    tmp___3 = err_len;
  }
  {
#line 77
  fmt_len = ((format_len + exec_len) + tmp___3) + 1;
#line 79
  tmp___4 = malloc((size_t )fmt_len);
#line 79
  fmtstring = (char *)tmp___4;
  }
#line 80
  if (! fmtstring) {
    {
#line 81
    error_outofmemory();
#line 82
    exit(1);
    }
  }
  {
#line 85
  __builtin_va_start(argptr, format);
  }
#line 87
  if ((unsigned int )type != 0U) {
    {
#line 88
    memcpy((void */* __restrict  */)fmtstring, (void const   */* __restrict  */)"logapp",
           (size_t )exec_len);
#line 89
    fmt_len = exec_len;
    }
  } else {
#line 91
    fmt_len = 0;
#line 92
    *fmtstring = (char )'\000';
  }
  {
#line 96
  if ((unsigned int )type == 1U) {
#line 96
    goto case_1;
  }
#line 100
  if ((unsigned int )type == 2U) {
#line 100
    goto case_2;
  }
#line 104
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 97
  memcpy((void */* __restrict  */)(fmtstring + exec_len), (void const   */* __restrict  */)" warning: ",
         (size_t )warn_len);
#line 98
  fmt_len += warn_len;
  }
#line 99
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 101
  memcpy((void */* __restrict  */)(fmtstring + exec_len), (void const   */* __restrict  */)" error: ",
         (size_t )err_len);
#line 102
  fmt_len += err_len;
  }
#line 103
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 104
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 107
  memcpy((void */* __restrict  */)(fmtstring + fmt_len), (void const   */* __restrict  */)format,
         (size_t )format_len);
#line 108
  *((fmtstring + fmt_len) + format_len) = (char )'\000';
#line 110
  tmp___5 = vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmtstring,
                     argptr);
  }
#line 110
  if (tmp___5 < 0) {
    {
#line 111
    exit(1);
    }
  }
  {
#line 114
  __builtin_va_end(argptr);
#line 116
  free((void *)fmtstring);
  }
#line 117
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/logapp-0.15/main.c"
int execcmd(char *cmd ) 
{ 
  int tmp ;

  {
  {
#line 121
  tmp = system((char const   *)cmd);
  }
#line 121
  return (tmp);
}
}
#line 126 "/home/wheatley/newnew/temp/logapp-0.15/main.c"
void usage(void) 
{ 
  int i ;
  unsigned int j ;
  int offset___0 ;
  char linebuf[81] ;
  unsigned int descoffset ;
  unsigned int desclen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 133
  print((t_printtype )0, "%s %s\n\n", "logapp", "0.15");
#line 134
  print((t_printtype )0, "Usage: %s [OPTION]... APPLICATION...\n", "logapp");
  }
#line 138
  if (! show_usage) {
    {
#line 139
    print((t_printtype )0, "\nTry \"%s --help\" for more options.\n", "logapp");
    }
#line 140
    return;
  }
#line 143
  i = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i < (int )arglistsize)) {
#line 143
      goto while_break;
    }
#line 144
    descoffset = 0U;
#line 147
    if (! arglist[i].shrt) {
#line 147
      if (! arglist[i].lng) {
#line 147
        if (arglist[i].desc) {
          {
#line 149
          print((t_printtype )0, "\n%s\n", arglist[i].desc);
          }
#line 150
          goto __Cont;
        }
      }
    }
    {
#line 153
    snprintf((char */* __restrict  */)(linebuf), (size_t )3, (char const   */* __restrict  */)"  ");
    }
#line 154
    if (arglist[i].shrt) {
      {
#line 155
      snprintf((char */* __restrict  */)(& linebuf[2]), (size_t )4, (char const   */* __restrict  */)"-%c ",
               (int )arglist[i].shrt);
      }
    } else {
      {
#line 157
      snprintf((char */* __restrict  */)(& linebuf[2]), (size_t )4, (char const   */* __restrict  */)"    ");
      }
    }
#line 159
    offset___0 = 5;
#line 160
    if (arglist[i].lng) {
      {
#line 161
      tmp = snprintf((char */* __restrict  */)(& linebuf[5]), (size_t )75, (char const   */* __restrict  */)"--%s",
                     arglist[i].lng);
#line 161
      offset___0 += tmp;
      }
    } else {
      {
#line 164
      tmp___0 = snprintf((char */* __restrict  */)(& linebuf[5]), (size_t )5, (char const   */* __restrict  */)"    ");
#line 164
      offset___0 += tmp___0;
      }
    }
#line 166
    if (arglist[i].parm) {
      {
#line 167
      tmp___1 = snprintf((char */* __restrict  */)(& linebuf[offset___0]), (size_t )(80 - offset___0),
                         (char const   */* __restrict  */)"=%s ", arglist[i].parm);
#line 167
      offset___0 += tmp___1;
      }
    }
#line 172
    if (offset___0 < 5) {
      {
#line 173
      print((t_printtype )2, "unable to generate usage information\n");
#line 174
      exit(1);
      }
    }
#line 177
    j = (unsigned int )offset___0;
    {
#line 177
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 177
      if (! (j < 33U)) {
#line 177
        goto while_break___0;
      }
#line 178
      linebuf[j] = (char )' ';
#line 179
      offset___0 ++;
#line 177
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 181
    linebuf[j] = (char )'\000';
#line 182
    if (! arglist[i].desc) {
      {
#line 183
      print((t_printtype )0, "%s\n", linebuf);
      }
#line 184
      goto __Cont;
    }
#line 187
    j = 0U;
    {
#line 187
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 187
      tmp___2 = strlen((char const   *)arglist[i].desc);
#line 187
      desclen = (unsigned int )tmp___2;
      }
#line 187
      if (! (j < desclen + 2U)) {
#line 187
        goto while_break___1;
      }
#line 188
      if ((int )*(arglist[i].desc + j) == 32) {
#line 188
        goto _L;
      } else
#line 188
      if ((int )*(arglist[i].desc + j) == 10) {
#line 188
        goto _L;
      } else
#line 188
      if (j > desclen) {
        _L: /* CIL Label */ 
#line 191
        if ((unsigned int )offset___0 + (j - descoffset) >= 80U) {
          {
#line 192
          linebuf[offset___0] = (char )'\n';
#line 193
          linebuf[offset___0 + 1] = (char )'\000';
#line 195
          offset___0 = 34;
#line 196
          print((t_printtype )0, "%s", linebuf);
#line 197
          memset((void *)(linebuf), ' ', (size_t )offset___0);
          }
        }
        {
#line 199
        memcpy((void */* __restrict  */)(& linebuf[offset___0]), (void const   */* __restrict  */)(arglist[i].desc + descoffset),
               (size_t )(j - descoffset));
#line 202
        offset___0 = (int )((unsigned int )offset___0 + (j - descoffset));
#line 203
        descoffset = j;
#line 204
        linebuf[offset___0] = (char )'\000';
        }
      }
#line 187
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 208
    print((t_printtype )0, "%s\n", linebuf);
    }
    __Cont: /* CIL Label */ 
#line 143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 211
  print((t_printtype )0, "\nPlease send bug reports and feature requests to %s\n",
        "Michael Brunner <mibru@gmx.de>");
  }
#line 213
  return;
}
}
#line 215 "/home/wheatley/newnew/temp/logapp-0.15/main.c"
void version(void) 
{ 
  size_t tmp ;

  {
  {
#line 217
  print((t_printtype )0, "%s %s\n", "logapp", "0.15");
#line 218
  print((t_printtype )0, "Build date: %s %s\n", "Mar  3 2016", "11:26:06");
#line 219
  tmp = strlen("");
  }
#line 219
  if (tmp) {
    {
#line 220
    print((t_printtype )0, "SVN revision: %s\n\n", "");
    }
  }
  {
#line 222
  print((t_printtype )0, "\nCompiletime configuration:\n");
#line 223
  print((t_printtype )0, "  PTY support %s\n", "enabled");
#line 224
  print((t_printtype )0, "  Thread usage %s\n\n", "enabled");
  }
#line 226
  return;
}
}
#line 228 "/home/wheatley/newnew/temp/logapp-0.15/main.c"
static void sig_handler(int signr ) 
{ 


  {
  {
#line 231
  if (signr == 28) {
#line 231
    goto case_28;
  }
#line 233
  if (signr == 18) {
#line 233
    goto case_18;
  }
#line 239
  goto switch_default;
  case_28: /* CIL Label */ 
  {
#line 231
  adjust_clipping();
  }
#line 232
  goto switch_break;
  case_18: /* CIL Label */ 
#line 233
  app.active = 1;
#line 234
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 239
  app.active = 0;
#line 240
  app.doexit = 1;
#line 241
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 243
  return;
}
}
#line 245 "/home/wheatley/newnew/temp/logapp-0.15/main.c"
int fork_child(void) 
{ 
  int pipe_stdout[2] ;
  int pipe_stderr[2] ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;

  {
#line 250
  if (! config.disable) {
    {
#line 251
    get_display_parameters();
    }
#line 253
    if ((unsigned long )app.ptytermios != (unsigned long )((void *)0)) {
      {
#line 254
      memcpy((void */* __restrict  */)app.ptytermios_bak, (void const   */* __restrict  */)app.ptytermios,
             sizeof(struct termios ));
      }
    }
#line 258
    if (config.usepty) {
      {
#line 259
      tmp___0 = openpty(& pipe_stdout[0], & pipe_stdout[1], (char *)((void *)0), (struct termios  const  *)app.ptytermios,
                        (struct winsize  const  *)app.ptysize);
      }
#line 259
      if (tmp___0 == -1) {
        {
#line 261
        tmp = __errno_location();
#line 261
        print((t_printtype )2, "opening PTY for %s failed with error %d\n", (app.pstdout)->name,
              *tmp);
#line 265
        (app.pstdout)->ptyremovecr = 0;
        }
      }
    } else {
      {
#line 268
      tmp___1 = pipe((int *)(pipe_stdout));
      }
#line 268
      if (tmp___1 < 0) {
        {
#line 269
        print((t_printtype )2, "creating stdout pipe handler\n");
        }
#line 270
        return (-1);
      }
    }
    {
#line 274
    tmp___2 = pipe((int *)(pipe_stderr));
    }
#line 274
    if (tmp___2 < 0) {
      {
#line 275
      print((t_printtype )2, "creating stderr pipe handler\n");
      }
#line 276
      return (-1);
    }
  }
  {
#line 280
  signal(18, & sig_handler);
#line 283
  fflush((FILE *)((void *)0));
#line 285
  app.pid = fork();
  }
#line 285
  if (app.pid < 0) {
    {
#line 286
    print((t_printtype )2, "fork error\n");
    }
#line 287
    return (-1);
  }
#line 290
  if (app.pid > 0) {
#line 291
    if (! config.disable) {
      {
#line 292
      close(pipe_stdout[1]);
#line 293
      close(pipe_stderr[1]);
#line 294
      (app.pstdout)->fh = pipe_stdout[0];
#line 295
      (app.pstderr)->fh = pipe_stderr[0];
      }
    }
    {
#line 299
    while (1) {
      while_continue: /* CIL Label */ ;
#line 299
      if (! app.active) {
#line 299
        if (! (! app.doexit)) {
#line 299
          goto while_break;
        }
      } else {
#line 299
        goto while_break;
      }
      {
#line 300
      usleep((__useconds_t )10000);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 301
    kill(app.pid, 18);
#line 304
    time(& app.starttime);
#line 305
    gettimeofday((struct timeval */* __restrict  */)(& app.toffset), (__timezone_ptr_t )((void *)0));
    }
  } else
#line 306
  if (app.pid == 0) {
#line 307
    if (! config.disable) {
      {
#line 308
      close(pipe_stdout[0]);
#line 309
      close(pipe_stderr[0]);
      }
#line 311
      if (pipe_stdout[1] != 1) {
        {
#line 312
        tmp___3 = dup2(pipe_stdout[1], 1);
        }
#line 312
        if (tmp___3 != 1) {
          {
#line 314
          print((t_printtype )2, "redirecting stdout failed");
          }
        }
        {
#line 315
        close(pipe_stdout[1]);
        }
      }
#line 318
      if (pipe_stderr[1] != 2) {
        {
#line 319
        tmp___4 = dup2(pipe_stderr[1], 2);
        }
#line 319
        if (tmp___4 != 2) {
          {
#line 321
          print((t_printtype )2, "redirecting stderr failed");
          }
        }
        {
#line 322
        close(pipe_stderr[1]);
        }
      }
#line 325
      if ((unsigned long )app.ptytermios != (unsigned long )((void *)0)) {
        {
#line 326
        tcsetattr(0, 1, (struct termios  const  *)app.ptytermios);
        }
      }
    }
    {
#line 332
    tmp___5 = getppid();
#line 332
    kill(tmp___5, 18);
    }
    {
#line 333
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 333
      if (! app.active) {
#line 333
        if (! (! app.doexit)) {
#line 333
          goto while_break___0;
        }
      } else {
#line 333
        goto while_break___0;
      }
      {
#line 334
      usleep((__useconds_t )10000);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 336
    tmp___6 = execvp((char const   *)app.exe, (char * const  *)app.argv);
    }
#line 336
    if (tmp___6 < 0) {
      {
#line 337
      print((t_printtype )2, "executing application %s failed\n", app.exe);
#line 338
      exit(1);
      }
    }
  } else {
    {
#line 341
    print((t_printtype )2, "forking process failed\n");
    }
#line 342
    return (-1);
  }
#line 345
  return (0);
}
}
#line 348 "/home/wheatley/newnew/temp/logapp-0.15/main.c"
int main(int argc , char **argv ) 
{ 
  char *argv0 ;
  int ret ;
  char *env ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  __sighandler_t tmp___7 ;
  __sighandler_t tmp___8 ;
  __sighandler_t tmp___9 ;
  __sighandler_t tmp___10 ;
  __sighandler_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int ret___0 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int ret___1 ;
  int tmp___18 ;
  int tmp___19 ;
  union __anonunion_79___1 __constr_expr_8 ;
  union __anonunion_80___0 __constr_expr_9 ;

  {
  {
#line 355
  env = getenv("TERM");
  }
#line 356
  if (env) {
    {
#line 357
    tmp = strcmp((char const   *)env, "dumb");
    }
#line 357
    if (! tmp) {
#line 358
      config.dumbterm = 1;
    }
  } else {
#line 363
    config.dumbterm = 1;
  }
  {
#line 367
  argv0 = strrchr((char const   *)*(argv + 0), '/');
  }
#line 368
  if (argv0) {
#line 369
    argv0 ++;
  } else {
#line 371
    argv0 = *(argv + 0);
  }
  {
#line 372
  tmp___3 = strcmp((char const   *)argv0, "logapp");
  }
#line 372
  if (tmp___3) {
    {
#line 373
    app.exe = strstr((char const   *)argv0, (char const   *)config.strip_prefix);
    }
#line 374
    if ((unsigned long )app.exe == (unsigned long )argv0) {
      {
#line 375
      tmp___1 = strlen((char const   *)app.exe);
#line 375
      tmp___2 = strlen((char const   *)config.strip_prefix);
      }
#line 375
      if (tmp___1 > tmp___2) {
        {
#line 376
        tmp___0 = strlen((char const   *)config.strip_prefix);
#line 376
        app.exe += tmp___0;
        }
      }
    } else {
#line 378
      app.exe = argv0;
    }
  }
  {
#line 382
  ret = parse_args(argc, argv);
  }
#line 382
  if (ret) {
    {
#line 383
    print((t_printtype )2, "error parsing logapp argument %d\n", ret);
#line 384
    exit(1);
    }
  }
#line 387
  if (show_usage) {
    {
#line 388
    usage();
#line 389
    exit(0);
    }
  }
#line 392
  if (show_version) {
    {
#line 393
    version();
#line 394
    exit(0);
    }
  }
#line 398
  if (! app.exe) {
#line 398
    if (! show_config) {
      {
#line 399
      print((t_printtype )0, "%s: No application parameter has been provided.\n",
            "logapp");
#line 401
      usage();
#line 402
      exit(0);
      }
    }
  }
  {
#line 406
  tmp___4 = get_config();
  }
#line 406
  if (tmp___4) {
    {
#line 407
    print((t_printtype )2, "problem while loading default config from file\n");
#line 408
    exit(1);
    }
  }
  {
#line 411
  tmp___5 = fixup_config();
  }
#line 411
  if (tmp___5) {
    {
#line 412
    print((t_printtype )2, "problem processing configuration\n");
#line 413
    exit(1);
    }
  }
  {
#line 416
  tmp___6 = check_for_disable_keywords();
  }
#line 416
  if (tmp___6) {
    {
#line 417
    print((t_printtype )2, "failed to check for disable keywords\n");
#line 418
    exit(1);
    }
  }
#line 421
  if (show_config) {
    {
#line 422
    show_configuration();
#line 423
    exit(0);
    }
  }
#line 427
  if ((app.pstderr)->eclip == 2) {
#line 427
    goto _L;
  } else
#line 427
  if ((app.pstdout)->eclip == 2) {
    _L: /* CIL Label */ 
    {
#line 428
    tmp___7 = signal(28, & sig_handler);
    }
#line 428
    if ((unsigned long )tmp___7 == (unsigned long )((void (*)(int  ))-1)) {
      {
#line 429
      print((t_printtype )2, "creating signal handler\n");
      }
#line 430
      return (-1);
    }
    {
#line 432
    adjust_clipping();
    }
  }
  {
#line 435
  tmp___8 = signal(2, & sig_handler);
  }
#line 435
  if ((unsigned long )tmp___8 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 436
    print((t_printtype )2, "creating signal handler\n");
#line 437
    exit(1);
    }
  }
  {
#line 440
  tmp___9 = signal(3, & sig_handler);
  }
#line 440
  if ((unsigned long )tmp___9 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 441
    print((t_printtype )2, "creating signal handler\n");
#line 442
    exit(1);
    }
  }
  {
#line 445
  tmp___10 = signal(15, & sig_handler);
  }
#line 445
  if ((unsigned long )tmp___10 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 446
    print((t_printtype )2, "creating signal handler\n");
#line 447
    exit(1);
    }
  }
  {
#line 450
  tmp___11 = signal(17, & sig_handler);
  }
#line 450
  if ((unsigned long )tmp___11 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 451
    print((t_printtype )2, "creating signal handler\n");
#line 452
    exit(1);
    }
  }
  {
#line 456
  tmp___12 = fork_child();
  }
#line 456
  if (tmp___12) {
    {
#line 457
    exit(1);
    }
  }
  {
#line 461
  tmp___13 = logfile_open(config.logname, app.logfile);
  }
#line 461
  if (tmp___13) {
    {
#line 462
    print((t_printtype )2, "unable to open logfile %s\n", config.logname);
#line 463
    exit(1);
    }
  }
#line 467
  if (config.preexeccmd) {
    {
#line 468
    tmp___14 = execcmd(config.preexeccmd);
#line 468
    ret___0 = tmp___14;
    }
#line 469
    if (ret___0) {
#line 470
      if (config.exitonexecfail) {
#line 470
        tmp___15 = 2;
      } else {
#line 470
        tmp___15 = 1;
      }
      {
#line 470
      print((t_printtype )tmp___15, "preexec command \"%s\" returned 0x%x\n", config.preexeccmd,
            ret___0);
      }
#line 473
      if (config.exitonexecfail) {
        {
#line 474
        exit(1);
        }
      }
    }
  }
#line 480
  if (! config.disable) {
    {
#line 481
    tmp___16 = capture_start();
    }
#line 481
    if (tmp___16) {
      {
#line 482
      print((t_printtype )2, "unable to capture streams\n");
#line 483
      exit(1);
      }
    }
  }
  {
#line 488
  waitpid(app.pid, & app.exit_state, 0);
  }
#line 491
  if (! config.disable) {
    {
#line 492
    capture_end();
    }
  }
  {
#line 494
  tmp___17 = logfile_close(app.logfile);
  }
#line 494
  if (tmp___17) {
    {
#line 495
    print((t_printtype )2, "problem closing logfile");
    }
  }
#line 499
  if (config.postexeccmd) {
    {
#line 500
    tmp___18 = execcmd(config.postexeccmd);
#line 500
    ret___1 = tmp___18;
    }
#line 501
    if (ret___1) {
#line 502
      if (config.exitonexecfail) {
#line 502
        tmp___19 = 2;
      } else {
#line 502
        tmp___19 = 1;
      }
      {
#line 502
      print((t_printtype )tmp___19, "postexec command \"%s\" returned 0x%x\n", config.postexeccmd,
            ret___1);
      }
    }
  }
#line 509
  if (! config.disable) {
    {
#line 510
    reset_console();
    }
  }
  {
#line 513
  fflush((FILE *)((void *)0));
  }
#line 516
  if (config.printsummary) {
    {
#line 517
    print_summary();
    }
  }
  {
#line 520
  cleanup_config();
#line 523
  __constr_expr_9.__in = app.exit_state;
  }
#line 523
  if ((__constr_expr_9.__i & 127) == 0) {
    {
#line 524
    __constr_expr_8.__in = app.exit_state;
#line 524
    exit((__constr_expr_8.__i & 65280) >> 8);
    }
  } else {
    {
#line 526
    exit(1);
    }
  }
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 132 "/home/wheatley/newnew/temp/logapp-0.15/configuration.h"
pipe_t pstdout ;
#line 133
pipe_t pstderr ;
#line 37 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
int show_usage  =    0;
#line 38 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
int show_version  =    0;
#line 39 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
int show_config  =    0;
#line 42 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
config_t config  = 
#line 42
     {(char *)"logapp_", (char *)"log", (char *)"logapp", 1, 0, 0, 1, 0, 0, 0, 0, (char *)((void *)0),
    (char *)"./logapp.log", 0, 0, 0, 0, 1, 1, 10, 0, 1, 1, 0, 1, (char *)((void *)0),
    (char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
    0, 0};
#line 78 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
char *configsearchpath[3]  = {      (char *)"~/.logapprc",      (char *)"/etc/logapp.conf",      (char *)"/etc/logapp/logapp.conf"};
#line 86 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
pipe_t pstdout  = 
#line 86
     {0, 1, (char *)"stdout", 0UL, (char *)0, (char *)((void *)0), {(char *)0, 0, (char *)0,
                                                                  (char *)0}, 0, 0,
    (int (*)(void * ))0, 0, 0, 0, 0, 65540, 0, 0, -1, -1, 0, -2, 2, (char *)"\033[0m",
    0, (char *)((void *)0), 0, 0, (char *)((void *)0), 0, {0}, (char *)((void *)0),
    {(unsigned char *)0, 0UL, 0UL, 0UL, (char *)0, (unsigned char *)0, 0UL, 0U, 0U,
     0U, 0U, 0U, 0U, 0U}, 4, (char *)((void *)0), (char *)((void *)0), {(unsigned char *)0,
                                                                        0UL, 0UL,
                                                                        0UL, (char *)0,
                                                                        (unsigned char *)0,
                                                                        0UL, 0U, 0U,
                                                                        0U, 0U, 0U,
                                                                        0U, 0U}, (char *)((void *)0)};
#line 117 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
pipe_t pstderr  = 
#line 117
     {0, 2, (char *)"stderr", 0UL, (char *)0, (char *)((void *)0), {(char *)0, 0, (char *)0,
                                                                  (char *)0}, 0, 0,
    (int (*)(void * ))0, 0, 0, 0, 0, 65540, 0, 0, 1, -1, 1, -1, 0, (char *)"\033[0m",
    0, (char *)((void *)0), 0, 0, (char *)"STDERR: ", 0, {0}, (char *)((void *)0),
    {(unsigned char *)0, 0UL, 0UL, 0UL, (char *)0, (unsigned char *)0, 0UL, 0U, 0U,
     0U, 0U, 0U, 0U, 0U}, 4, (char *)((void *)0), (char *)((void *)0), {(unsigned char *)0,
                                                                        0UL, 0UL,
                                                                        0UL, (char *)0,
                                                                        (unsigned char *)0,
                                                                        0UL, 0U, 0U,
                                                                        0U, 0U, 0U,
                                                                        0U, 0U}, (char *)((void *)0)};
#line 148 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
logfile_t logfile  = 
#line 148
     {0, (char *)((void *)0), 0U, (char *)".old", 0, (char *)">> logapp:", (char *)"== logapp split:",
    (char *)"<< logapp end:", 0, (char *)0};
#line 160 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
struct winsize ptysize  ;
#line 161 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
struct termios ptytermios  ;
#line 161 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
struct termios ptytermios_bak  ;
#line 164 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
app_t app  = 
#line 164
     {(char *)((void *)0), (char **)((void *)0), 0, 0, 0, 0, 0, (time_t )0, {0L, 0L},
    & pstdout, & pstderr, & ptysize, & ptytermios, & ptytermios_bak, & logfile};
#line 181 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
stringvalue_t const   boolvalues[5]  = {      {(char *)"true", 1}, 
        {(char *)"false", 0}, 
        {(char *)"on", 1}, 
        {(char *)"off", 0}, 
        {(char *)((void *)0), 0}};
#line 189 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
stringvalue_t const   colorvalues[11]  = 
#line 189
  {      {(char *)"disable", -1}, 
        {(char *)"default", -1}, 
        {(char *)"black", 0}, 
        {(char *)"red", 1}, 
        {(char *)"green", 2}, 
        {(char *)"brown", 3}, 
        {(char *)"blue", 4}, 
        {(char *)"magenta", 5}, 
        {(char *)"cyan", 6}, 
        {(char *)"white", 7}, 
        {(char *)((void *)0), 0}};
#line 203 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
stringvalue_t const   clipvalues[3]  = {      {(char *)"disable", -1}, 
        {(char *)"auto", -2}, 
        {(char *)((void *)0), 0}};
#line 209 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
stringvalue_t const   multprefixes[8]  = 
#line 209
  {      {(char *)"", 1}, 
        {(char *)"k", 1000}, 
        {(char *)"M", 1000000}, 
        {(char *)"G", 1000000000}, 
        {(char *)"ki", 1024}, 
        {(char *)"Mi", 1048576}, 
        {(char *)"Gi", 1073741824}, 
        {(char *)((void *)0), 0}};
#line 221 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
arglist_t arglist[56]  = 
#line 221
  {      {(char )'\000', (char *)((void *)0), (char *)((void *)0), (t_vartype )4, (void *)0,
      (char *)"General options:", 0}, 
        {(char )'?', (char *)"help", (char *)((void *)0), (t_vartype )4, (void *)(& show_usage),
      (char *)"show this help", 0}, 
        {(char )'\000', (char *)"version", (char *)((void *)0), (t_vartype )4, (void *)(& show_version),
      (char *)"show version information", 0}, 
        {(char )'\000', (char *)"configfile", (char *)"FILE", (t_vartype )5, (void *)(& config.custconfigfile),
      (char *)"configuration file", 0}, 
        {(char )'\000', (char *)"showconfig", (char *)((void *)0), (t_vartype )4, (void *)(& show_config),
      (char *)"print current configuration on the screen and exit", 0}, 
        {(char )'\000', (char *)"configsection", (char *)"NAME", (t_vartype )5, (void *)(& config.configsection),
      (char *)"select configuration section", 0}, 
        {(char )'\000', (char *)"disable", (char *)((void *)0), (t_vartype )4, (void *)(& config.disable),
      (char *)"disable output handling", 0}, 
        {(char )'\000', (char *)"disable_keywords", (char *)"STRING", (t_vartype )5,
      (void *)(& config.disable_keywords), (char *)"comma separated keywords to disable output handling when found in argument list",
      0}, 
        {(char )'\000', (char *)"detectescape", (char *)"BOOL", (t_vartype )0, (void *)(& config.detectescape),
      (char *)"switch to charbased mode if escape sequence is detected", 0}, 
        {(char )'\000', (char *)"usepty", (char *)"BOOL", (t_vartype )0, (void *)(& config.usepty),
      (char *)"use PTY for stream redirection", 0}, 
        {(char )'\000', (char *)"ptyremovecr", (char *)"BOOL", (t_vartype )0, (void *)(& config.ptyremovecr),
      (char *)"translate CR-LF to LF when capturing PTY", 0}, 
        {(char )'\000', (char *)"stdout_blen", (char *)"SIZE", (t_vartype )6, (void *)(& pstdout.blen),
      (char *)"stdout buffer size", 0}, 
        {(char )'\000', (char *)"stderr_blen", (char *)"SIZE", (t_vartype )6, (void *)(& pstderr.blen),
      (char *)"stderr buffer size", 0}, 
        {(char )'\000', (char *)"stdout_charbased", (char *)"BOOL", (t_vartype )0, (void *)(& pstdout.charbased),
      (char *)"handle stdout char- instead of line-based", 0}, 
        {(char )'\000', (char *)"stderr_charbased", (char *)"BOOL", (t_vartype )0, (void *)(& pstderr.charbased),
      (char *)"handle stderr char- instead of line-based", 0}, 
        {(char )'\000', (char *)"extended-regexp", (char *)"BOOL", (t_vartype )0, (void *)(& config.extregexp),
      (char *)"interpret regexp patterns as extended regular expressions", 0}, 
        {(char )'\000', (char *)((void *)0), (char *)((void *)0), (t_vartype )4, (void *)0,
      (char *)"Logging options:", 0}, 
        {(char )'l', (char *)"logfile", (char *)"NAME", (t_vartype )5, (void *)(& config.logname),
      (char *)"application logfile", 0}, 
        {(char )'a', (char *)"appendlog", (char *)"BOOL", (t_vartype )0, (void *)(& config.appendlog),
      (char *)"append to existing logfile", 0}, 
        {(char )'\000', (char *)"maxlogsize", (char *)"SIZE", (t_vartype )6, (void *)(& config.maxlogsize),
      (char *)"max. logfile size in KiB (0=no limit, 10-4000000) the file will be truncated if logrename isn\'t set",
      0}, 
        {(char )'\000', (char *)"logrename", (char *)"BOOL", (t_vartype )0, (void *)(& config.logrename),
      (char *)"rename logfile before replacing it", 0}, 
        {(char )'\000', (char *)"circularlog", (char *)"BOOL", (t_vartype )0, (void *)(& config.circularlog),
      (char *)"write log in a circular way, keeping the max. size", 0}, 
        {(char )'\000', (char *)"oldlogext", (char *)"STRING", (t_vartype )5, (void *)(& logfile.oldext),
      (char *)"extension for old logfile", 0}, 
        {(char )'\000', (char *)"locklogfile", (char *)"BOOL", (t_vartype )0, (void *)(& config.locklogfile),
      (char *)"lock logfile when opening it", 0}, 
        {(char )'\000', (char *)"warnlogfilelock", (char *)"BOOL", (t_vartype )0, (void *)(& config.warnlogfilelock),
      (char *)"print a warning if current logfile is locked", 0}, 
        {(char )'n', (char *)"print_logname", (char *)"BOOL", (t_vartype )0, (void *)(& config.printlogname),
      (char *)"print logfile name after execution", 0}, 
        {(char )'\000', (char *)"maxaltlogfiles", (char *)"COUNT", (t_vartype )6, (void *)(& config.maxlogfiles),
      (char *)"max # of alternate logfiles on lock", 0}, 
        {(char )'\000', (char *)"alignlog", (char *)"BOOL", (t_vartype )0, (void *)(& config.alignlog),
      (char *)"use one line for every write in charbased mode", 0}, 
        {(char )'\000', (char *)"jointimeout", (char *)"TIME", (t_vartype )6, (void *)(& config.jointimeout),
      (char *)"join timeout for packets with alignlog active", 0}, 
        {(char )'\000', (char *)"alignlinebreaks", (char *)"BOOL", (t_vartype )0, (void *)(& config.alignlinebreaks),
      (char *)"align logged line breaks in charbased mode", 0}, 
        {(char )'t', (char *)"logtime", (char *)"BOOL", (t_vartype )0, (void *)(& config.logtime),
      (char *)"add timestamp to each logged line", 0}, 
        {(char )'\000', (char *)"logreltime", (char *)"BOOL", (t_vartype )0, (void *)(& config.logreltime),
      (char *)"log relative time with --logtime", 0}, 
        {(char )'\000', (char *)"logenv", (char *)"BOOL", (t_vartype )0, (void *)(& config.logenv),
      (char *)"add environment variables to logfile", 0}, 
        {(char )'p', (char *)"stdout_lineprefix", (char *)"STRING", (t_vartype )5, (void *)(& pstdout.lineprefix),
      (char *)"logfile line prefix for stdout", 0}, 
        {(char )'P', (char *)"stderr_lineprefix", (char *)"STRING", (t_vartype )5, (void *)(& pstderr.lineprefix),
      (char *)"logfile line prefix for stderr", 0}, 
        {(char )'\000', (char *)((void *)0), (char *)((void *)0), (t_vartype )4, (void *)0,
      (char *)"Console output options:", 0}, 
        {(char )'\000', (char *)"dumbterm", (char *)"BOOL", (t_vartype )0, (void *)(& config.dumbterm),
      (char *)"disable colors for use with dumb terminals", 0}, 
        {(char )'s', (char *)"print_summary", (char *)"BOOL", (t_vartype )0, (void *)(& config.printsummary),
      (char *)"print execution summary", 0}, 
        {(char )'f', (char *)"stdout_fgcol", (char *)"COLOR", (t_vartype )2, (void *)(& pstdout.fgcol),
      (char *)"stdout console foreground color (disable=-1, 0-7)", 0}, 
        {(char )'F', (char *)"stderr_fgcol", (char *)"COLOR", (t_vartype )2, (void *)(& pstderr.fgcol),
      (char *)"stderr console foreground color (disable=-1, 0-7)", 0}, 
        {(char )'b', (char *)"stdout_bold", (char *)"BOOL", (t_vartype )0, (void *)(& pstdout.bold),
      (char *)"bold stdout console font", 0}, 
        {(char )'B', (char *)"stderr_bold", (char *)"BOOL", (t_vartype )0, (void *)(& pstderr.bold),
      (char *)"bold stderr console font", 0}, 
        {(char )'r', (char *)"stdout_regexp", (char *)"STRING", (t_vartype )5, (void *)(& pstdout.regexp),
      (char *)"regular expression to change stdout background color", 0}, 
        {(char )'R', (char *)"stderr_regexp", (char *)"STRING", (t_vartype )5, (void *)(& pstderr.regexp),
      (char *)"regular expression to change stderr background color", 0}, 
        {(char )'\000', (char *)"stdout_regexp_bgcol", (char *)"COLOR", (t_vartype )2,
      (void *)(& pstdout.regbgcol), (char *)"stdout console background color on regexp match (disable=-1, 0-7)",
      0}, 
        {(char )'\000', (char *)"stderr_regexp_bgcol", (char *)"COLOR", (t_vartype )2,
      (void *)(& pstderr.regbgcol), (char *)"stderr console background color on regexp match (disable=-1, 0-7)",
      0}, 
        {(char )'c', (char *)"stdout_clip", (char *)"LENGTH", (t_vartype )1, (void *)(& pstdout.clip),
      (char *)"clip stdout console at column LENGTH (disable=-1, auto=-2)", 0}, 
        {(char )'C', (char *)"stderr_clip", (char *)"LENGTH", (t_vartype )1, (void *)(& pstderr.clip),
      (char *)"clip stderr console at column LENGTH (disable=-1, auto=-2)", 0}, 
        {(char )'\000', (char *)((void *)0), (char *)((void *)0), (t_vartype )4, (void *)0,
      (char *)"Command execution options:", 0}, 
        {(char )'\000', (char *)"exitonexecfail", (char *)"BOOL", (t_vartype )0, (void *)(& config.exitonexecfail),
      (char *)"exit if execution of command fails", 0}, 
        {(char )'\000', (char *)"preexec", (char *)"STRING", (t_vartype )5, (void *)(& config.preexeccmd),
      (char *)"command executed before application start", 0}, 
        {(char )'\000', (char *)"postexec", (char *)"STRING", (t_vartype )5, (void *)(& config.postexeccmd),
      (char *)"command executed after application exit", 0}, 
        {(char )'e', (char *)"stdout_execregexp", (char *)"STRING", (t_vartype )5, (void *)(& pstdout.execregexp),
      (char *)"regular expression to execute command", 0}, 
        {(char )'E', (char *)"stderr_execregexp", (char *)"STRING", (t_vartype )5, (void *)(& pstderr.execregexp),
      (char *)"regular expression to execute command", 0}, 
        {(char )'x', (char *)"stdout_execcommand", (char *)"STRING", (t_vartype )5, (void *)(& pstdout.execcommand),
      (char *)"command to be executed after stdout regexp match", 0}, 
        {(char )'X', (char *)"stderr_execregexp", (char *)"STRING", (t_vartype )5, (void *)(& pstderr.execcommand),
      (char *)"command to be executed after stderr regexp match", 0}};
#line 355 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
int const   arglistsize  =    (int const   )((int )(sizeof(arglist) / sizeof(arglist_t )));
#line 357 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
void show_configuration(void) 
{ 
  unsigned int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;

  {
  {
#line 361
  print((t_printtype )0, "%s %s\n\n", "logapp", "0.15");
#line 362
  print((t_printtype )0, "current configuration:\n");
#line 363
  print((t_printtype )0, "  argument prefix         %s\n", config.argprefix);
#line 364
  print((t_printtype )0, "  executable prefix       %s\n", config.strip_prefix);
  }
#line 365
  if (config.configfile) {
#line 365
    tmp = (char const   *)config.configfile;
  } else {
#line 365
    tmp = "<none>";
  }
  {
#line 365
  print((t_printtype )0, "  active config file      %s\n", tmp);
  }
#line 367
  if (config.custconfigfile) {
#line 367
    tmp___0 = (char const   *)config.custconfigfile;
  } else {
#line 367
    tmp___0 = "<none>";
  }
  {
#line 367
  print((t_printtype )0, "  custom configfile path  %s\n", tmp___0);
#line 369
  i = 0U;
  }
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! ((unsigned long )i < sizeof(configsearchpath) / sizeof(char *))) {
#line 369
      goto while_break;
    }
    {
#line 370
    print((t_printtype )0, "  config search path (%d)  %s\n", i, configsearchpath[i]);
#line 369
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  if (config.configsection) {
#line 373
    tmp___1 = (char const   *)config.configsection;
  } else {
#line 373
    tmp___1 = "<none>";
  }
  {
#line 373
  print((t_printtype )0, "  activate section        %s\n", tmp___1);
  }
#line 375
  if (config.logname) {
#line 375
    tmp___2 = (char const   *)config.logname;
  } else {
#line 375
    tmp___2 = "<none>";
  }
  {
#line 375
  print((t_printtype )0, "  application logfile     %s\n", tmp___2);
#line 377
  print((t_printtype )0, "  append to logfile       %i\n", config.appendlog);
#line 378
  print((t_printtype )0, "  log timestamps          %i\n", config.logtime);
#line 379
  print((t_printtype )0, "  log relative time       %i\n", config.logreltime);
#line 380
  print((t_printtype )0, "  log environment         %i\n", config.logenv);
#line 381
  print((t_printtype )0, "  align log writes left   %i\n", config.alignlog);
#line 382
  print((t_printtype )0, "  join timeout            %i\n", config.jointimeout);
#line 383
  print((t_printtype )0, "  align line breaks       %i\n", config.alignlinebreaks);
#line 384
  print((t_printtype )0, "  lock logfiles           %i\n", config.locklogfile);
#line 385
  print((t_printtype )0, "  warning on logfile lock %i\n", config.warnlogfilelock);
#line 386
  print((t_printtype )0, "  max. alternate logfiles %u\n", config.maxlogfiles - 1);
#line 387
  print((t_printtype )0, "  maximum logsize         %u\n", logfile.sizelimit);
#line 388
  print((t_printtype )0, "  rename logfiles         %i\n", config.logrename);
#line 389
  print((t_printtype )0, "  circular logfile        %i\n", config.circularlog);
#line 390
  print((t_printtype )0, "  extension for old logs  %s\n", logfile.oldext);
#line 391
  print((t_printtype )0, "  exit on execution fail  %i\n", config.exitonexecfail);
  }
#line 393
  if (app.exe) {
#line 393
    tmp___3 = (char const   *)app.exe;
  } else {
#line 393
    tmp___3 = "<none>";
  }
  {
#line 393
  print((t_printtype )0, "\n  application executable  %s\n", tmp___3);
#line 395
  print((t_printtype )0, "  application argc        %d\n", app.argc);
#line 396
  i = 0U;
  }
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if (! (i < (unsigned int )app.argc)) {
#line 396
      goto while_break___0;
    }
    {
#line 397
    print((t_printtype )0, "  application argv[%d]     %s\n", i, *(app.argv + i));
#line 396
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 401
  print((t_printtype )0, "\n");
  }
#line 402
  if (config.preexeccmd) {
#line 402
    tmp___4 = (char const   *)config.preexeccmd;
  } else {
#line 402
    tmp___4 = "<none>";
  }
  {
#line 402
  print((t_printtype )0, "  preexec command         %s\n", tmp___4);
  }
#line 404
  if (config.postexeccmd) {
#line 404
    tmp___5 = (char const   *)config.postexeccmd;
  } else {
#line 404
    tmp___5 = "<none>";
  }
  {
#line 404
  print((t_printtype )0, "  postexec command        %s\n", tmp___5);
#line 407
  print((t_printtype )0, "\n");
#line 409
  print((t_printtype )0, "  use threads             %i\n", 1);
#line 414
  print((t_printtype )0, "  use PTY                 %i\n", config.usepty);
#line 415
  print((t_printtype )0, "  remove CR for PTY       %i\n", config.ptyremovecr);
#line 421
  print((t_printtype )0, "\n  ext. regexp patterns    %i\n", config.extregexp);
#line 423
  print((t_printtype )0, "\n  dumb terminal mode      %i\n", config.dumbterm);
#line 424
  print((t_printtype )0, "  print_summary           %i\n", config.printsummary);
#line 425
  print((t_printtype )0, "  print_logname           %i\n", config.printlogname);
#line 426
  print((t_printtype )0, "  disable output handling %i\n", config.disable);
  }
#line 427
  if (config.disable_keywords) {
#line 427
    tmp___6 = (char const   *)config.disable_keywords;
  } else {
#line 427
    tmp___6 = "<none>";
  }
  {
#line 427
  print((t_printtype )0, "  disable keywords        %s\n", tmp___6);
#line 430
  print((t_printtype )0, "\n  stdout buffer length    %i\n", (app.pstdout)->blen);
#line 431
  print((t_printtype )0, "  stdout foreground color %i\n", (app.pstdout)->fgcol);
  }
#line 432
  if ((app.pstdout)->bgcol == 9) {
#line 432
    tmp___7 = -1;
  } else {
#line 432
    tmp___7 = (app.pstdout)->bgcol;
  }
  {
#line 432
  print((t_printtype )0, "  stdout background color %i\n", tmp___7);
  }
#line 434
  if ((app.pstdout)->regbgcol == 9) {
#line 434
    tmp___8 = -1;
  } else {
#line 434
    tmp___8 = (app.pstdout)->regbgcol;
  }
  {
#line 434
  print((t_printtype )0, "  stdout regexp bg color  %i\n", tmp___8);
#line 436
  print((t_printtype )0, "  stdout bold font        %i\n", (app.pstdout)->bold);
#line 437
  print((t_printtype )0, "  stdout clip at column   ");
  }
#line 438
  if ((app.pstdout)->eclip == 1) {
    {
#line 439
    print((t_printtype )0, "%d\n", (app.pstdout)->clip);
    }
  } else {
#line 441
    if ((app.pstdout)->eclip) {
#line 441
      tmp___9 = "auto";
    } else {
#line 441
      tmp___9 = "disable";
    }
    {
#line 441
    print((t_printtype )0, "%s\n", tmp___9);
    }
  }
#line 443
  if ((app.pstdout)->lineprefix) {
#line 443
    tmp___10 = (char const   *)(app.pstdout)->lineprefix;
  } else {
#line 443
    tmp___10 = "<none>";
  }
  {
#line 443
  print((t_printtype )0, "  stdout line prefix      %s\n", tmp___10);
  }
#line 445
  if ((app.pstdout)->regexp) {
#line 445
    tmp___11 = (char const   *)(app.pstdout)->regexp;
  } else {
#line 445
    tmp___11 = "<disabled>";
  }
  {
#line 445
  print((t_printtype )0, "  stdout regexp           %s\n", tmp___11);
  }
#line 447
  if ((app.pstdout)->execregexp) {
#line 447
    tmp___12 = (char const   *)(app.pstdout)->execregexp;
  } else {
#line 447
    tmp___12 = "<disabled>";
  }
  {
#line 447
  print((t_printtype )0, "  stdout exec regexp      %s\n", tmp___12);
  }
#line 449
  if ((app.pstdout)->execcommand) {
#line 449
    tmp___13 = (char const   *)(app.pstdout)->execcommand;
  } else {
#line 449
    tmp___13 = "<none>";
  }
  {
#line 449
  print((t_printtype )0, "  stdout regexp command   %s\n", tmp___13);
#line 451
  print((t_printtype )0, "  stdout charbased        %i\n", (app.pstdout)->charbased);
#line 452
  print((t_printtype )0, "  stdout esc detection    %i\n", (app.pstdout)->detectescape);
#line 454
  print((t_printtype )0, "\n  stderr buffer length    %i\n", (app.pstderr)->blen);
#line 455
  print((t_printtype )0, "  stderr foreground color %i\n", (app.pstderr)->fgcol);
  }
#line 456
  if ((app.pstderr)->bgcol == 9) {
#line 456
    tmp___14 = -1;
  } else {
#line 456
    tmp___14 = (app.pstderr)->bgcol;
  }
  {
#line 456
  print((t_printtype )0, "  stderr background color %i\n", tmp___14);
  }
#line 458
  if ((app.pstderr)->regbgcol == 9) {
#line 458
    tmp___15 = -1;
  } else {
#line 458
    tmp___15 = (app.pstderr)->regbgcol;
  }
  {
#line 458
  print((t_printtype )0, "  stderr regexp bg color  %i\n", tmp___15);
#line 460
  print((t_printtype )0, "  stderr bold font        %i\n", (app.pstderr)->bold);
#line 461
  print((t_printtype )0, "  stderr clip at column   ");
  }
#line 462
  if ((app.pstderr)->eclip == 1) {
    {
#line 463
    print((t_printtype )0, "%d\n", (app.pstderr)->clip);
    }
  } else {
#line 465
    if ((app.pstderr)->eclip) {
#line 465
      tmp___16 = "auto";
    } else {
#line 465
      tmp___16 = "disable";
    }
    {
#line 465
    print((t_printtype )0, "%s\n", tmp___16);
    }
  }
#line 467
  if ((app.pstderr)->lineprefix) {
#line 467
    tmp___17 = (char const   *)(app.pstderr)->lineprefix;
  } else {
#line 467
    tmp___17 = "<none>";
  }
  {
#line 467
  print((t_printtype )0, "  stderr line prefix      %s\n", tmp___17);
  }
#line 469
  if ((app.pstderr)->regexp) {
#line 469
    tmp___18 = (char const   *)(app.pstderr)->regexp;
  } else {
#line 469
    tmp___18 = "<disabled>";
  }
  {
#line 469
  print((t_printtype )0, "  stderr regexp           %s\n", tmp___18);
  }
#line 471
  if ((app.pstderr)->execregexp) {
#line 471
    tmp___19 = (char const   *)(app.pstderr)->execregexp;
  } else {
#line 471
    tmp___19 = "<disabled>";
  }
  {
#line 471
  print((t_printtype )0, "  stderr exec regexp      %s\n", tmp___19);
  }
#line 473
  if ((app.pstderr)->execcommand) {
#line 473
    tmp___20 = (char const   *)(app.pstderr)->execcommand;
  } else {
#line 473
    tmp___20 = "<none>";
  }
  {
#line 473
  print((t_printtype )0, "  stderr regexp command   %s\n", tmp___20);
#line 475
  print((t_printtype )0, "  stderr charbased        %i\n", (app.pstderr)->charbased);
#line 476
  print((t_printtype )0, "  stderr esc detection    %i\n", (app.pstderr)->detectescape);
  }
#line 477
  return;
}
}
#line 479 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
char *get_longpath(char const   *filename ) 
{ 
  char *home ;
  char *longpath ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 484
  tmp___2 = strncmp(filename, "~/", (size_t )2);
  }
#line 484
  if (tmp___2) {
    {
#line 497
    longpath = strdup(filename);
    }
  } else {
    {
#line 485
    home = getenv("HOME");
    }
#line 486
    if ((unsigned long )home == (unsigned long )((void *)0)) {
#line 487
      home = (char *)"./";
    }
    {
#line 490
    tmp = strlen((char const   *)home);
#line 490
    tmp___0 = strlen(filename);
#line 490
    tmp___1 = malloc((tmp + tmp___0) + 1UL);
#line 490
    longpath = (char *)tmp___1;
    }
#line 491
    if ((unsigned long )longpath != (unsigned long )((void *)0)) {
      {
#line 492
      strcpy((char */* __restrict  */)longpath, (char const   */* __restrict  */)home);
#line 493
      strcat((char */* __restrict  */)longpath, (char const   */* __restrict  */)"/");
#line 494
      strcat((char */* __restrict  */)longpath, (char const   */* __restrict  */)(filename + 2));
      }
    }
  }
#line 500
  if ((unsigned long )longpath == (unsigned long )((void *)0)) {
    {
#line 501
    error_outofmemory();
    }
#line 502
    return ((char *)((void *)0));
  }
#line 505
  return (longpath);
}
}
#line 508 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
static int fixup_pipe(pipe_t *pipe___0 ) 
{ 
  size_t tmp ;
  int len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int regexp_cflags ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
#line 510
  if (config.detectescape) {
#line 511
    pipe___0->detectescape = 1;
  }
#line 513
  if (pipe___0->fgcol < -1) {
    {
#line 514
    print((t_printtype )2, "%s foreground color out of range\n", pipe___0->name);
    }
#line 515
    return (-1);
  } else
#line 513
  if (pipe___0->fgcol > 7) {
    {
#line 514
    print((t_printtype )2, "%s foreground color out of range\n", pipe___0->name);
    }
#line 515
    return (-1);
  }
#line 518
  if (pipe___0->bgcol < -1) {
    {
#line 519
    print((t_printtype )2, "%s background color out of range\n", pipe___0->name);
    }
#line 520
    return (-1);
  } else
#line 518
  if (pipe___0->bgcol > 7) {
    {
#line 519
    print((t_printtype )2, "%s background color out of range\n", pipe___0->name);
    }
#line 520
    return (-1);
  }
#line 523
  if (pipe___0->regbgcol == -1) {
#line 524
    pipe___0->regexp = (char *)((void *)0);
  }
#line 526
  if (pipe___0->regbgcol < -1) {
    {
#line 527
    print((t_printtype )2, "%s regexp background color out of range\n", pipe___0->name);
    }
#line 528
    return (-1);
  } else
#line 526
  if (pipe___0->regbgcol > 7) {
    {
#line 527
    print((t_printtype )2, "%s regexp background color out of range\n", pipe___0->name);
    }
#line 528
    return (-1);
  } else
#line 529
  if (pipe___0->bgcol != pipe___0->regbgcol) {
#line 530
    if (pipe___0->bgcol == -1) {
#line 531
      pipe___0->bgcol = 9;
    }
#line 533
    if (pipe___0->regbgcol == -1) {
#line 534
      pipe___0->regbgcol = 9;
    }
  }
  {
#line 538
  if (pipe___0->clip == -1) {
#line 538
    goto case_neg_1;
  }
#line 541
  if (pipe___0->clip == -2) {
#line 541
    goto case_neg_2;
  }
#line 544
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 538
  pipe___0->eclip = 0;
#line 539
  pipe___0->clip = 80;
#line 540
  goto switch_break;
  case_neg_2: /* CIL Label */ 
#line 541
  pipe___0->eclip = 2;
#line 542
  pipe___0->clip = 80;
#line 543
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 544
  if (pipe___0->clip < 0) {
#line 545
    pipe___0->eclip = 0;
  } else {
#line 547
    pipe___0->eclip = 1;
  }
  switch_break: /* CIL Label */ ;
  }
#line 550
  if ((unsigned long )pipe___0->lineprefix != (unsigned long )((void *)0)) {
    {
#line 551
    tmp = strlen((char const   *)pipe___0->lineprefix);
#line 551
    pipe___0->lineprefixlen = (int )tmp;
    }
#line 552
    if (pipe___0->lineprefixlen == 0) {
      {
#line 553
      free((void *)pipe___0->lineprefix);
#line 554
      pipe___0->lineprefix = (char *)((void *)0);
      }
    }
  }
  {
#line 560
  tmp___0 = strlen((char const   *)pipe___0->escreset);
#line 560
  pipe___0->escresetlen = (int )tmp___0;
#line 561
  len = pipe___0->escresetlen;
  }
#line 563
  if (pipe___0->fgcol >= 0) {
#line 564
    len += 5;
  }
#line 565
  if (pipe___0->regbgcol >= 0) {
#line 566
    len += 5;
  }
#line 567
  if (pipe___0->bold) {
#line 568
    len += 4;
  }
  {
#line 570
  tmp___1 = malloc((size_t )(len + 1));
#line 570
  pipe___0->esccolor = (char *)tmp___1;
#line 571
  pipe___0->esccolorlen = 0;
  }
#line 572
  if (! pipe___0->esccolor) {
    {
#line 573
    error_outofmemory();
    }
#line 574
    return (-1);
  }
  {
#line 577
  memcpy((void */* __restrict  */)pipe___0->esccolor, (void const   */* __restrict  */)pipe___0->escreset,
         (size_t )pipe___0->escresetlen);
#line 578
  pipe___0->esccolorlen += pipe___0->escresetlen;
  }
#line 580
  if (pipe___0->fgcol >= 0) {
    {
#line 581
    snprintf((char */* __restrict  */)(pipe___0->esccolor + pipe___0->esccolorlen),
             (size_t )6, (char const   */* __restrict  */)"\033[3%dm", pipe___0->fgcol);
#line 583
    pipe___0->esccolorlen += 5;
    }
  }
#line 586
  if (pipe___0->regbgcol >= 0) {
    {
#line 587
    pipe___0->bgesccolor = (pipe___0->esccolor + pipe___0->esccolorlen) + 3;
#line 588
    snprintf((char */* __restrict  */)(pipe___0->esccolor + pipe___0->esccolorlen),
             (size_t )6, (char const   */* __restrict  */)"\033[4%dm", pipe___0->bgcol);
#line 590
    pipe___0->esccolorlen += 5;
    }
  } else {
#line 592
    pipe___0->bgesccolor = (char *)((void *)0);
  }
#line 595
  if (pipe___0->bold) {
    {
#line 596
    snprintf((char */* __restrict  */)(pipe___0->esccolor + pipe___0->esccolorlen),
             (size_t )5, (char const   */* __restrict  */)"\033[1m");
#line 597
    pipe___0->esccolorlen += 4;
    }
  }
#line 600
  regexp_cflags = (((1 << 1) << 1) << 1) | ((1 << 1) << 1);
#line 601
  if (config.extregexp) {
#line 602
    regexp_cflags |= 1;
  }
#line 604
  if (pipe___0->regexp) {
    {
#line 605
    tmp___3 = strlen((char const   *)pipe___0->regexp);
    }
#line 605
    if (tmp___3) {
      {
#line 606
      tmp___2 = regcomp((regex_t */* __restrict  */)(& pipe___0->preg), (char const   */* __restrict  */)pipe___0->regexp,
                        regexp_cflags);
      }
#line 606
      if (tmp___2) {
        {
#line 608
        print((t_printtype )2, "unable to process regular expression for %s\n", pipe___0->name);
        }
#line 610
        return (-1);
      }
    } else {
#line 613
      pipe___0->regexp = (char *)((void *)0);
    }
  }
#line 617
  if (pipe___0->execregexp) {
    {
#line 618
    tmp___5 = strlen((char const   *)pipe___0->execregexp);
    }
#line 618
    if (tmp___5) {
      {
#line 619
      tmp___4 = regcomp((regex_t */* __restrict  */)(& pipe___0->pexecreg), (char const   */* __restrict  */)pipe___0->execregexp,
                        regexp_cflags);
      }
#line 619
      if (tmp___4) {
        {
#line 621
        print((t_printtype )2, "unable to process regular expression for %s\n", pipe___0->name);
        }
#line 623
        return (-1);
      }
    } else {
#line 626
      pipe___0->execregexp = (char *)((void *)0);
    }
#line 629
    if ((unsigned long )pipe___0->execcommand == (unsigned long )((void *)0)) {
#line 630
      pipe___0->execregexp = (char *)((void *)0);
    } else {
      {
#line 632
      tmp___6 = strlen((char const   *)pipe___0->execcommand);
      }
#line 632
      if (tmp___6 == 0UL) {
#line 633
        pipe___0->execregexp = (char *)((void *)0);
      }
    }
  }
#line 638
  return (0);
}
}
#line 641 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
int fixup_config(void) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int maxindentlen ;
  void *tmp___2 ;

  {
  {
#line 643
  tmp = strlen((char const   *)config.logname);
  }
#line 643
  if (tmp == 0UL) {
#line 644
    config.logname = (char *)((void *)0);
  }
#line 647
  (config.maxlogfiles) ++;
#line 649
  if (config.maxlogsize == 0) {
#line 650
    logfile.sizelimit = 0U;
  } else
#line 651
  if (config.maxlogsize < 10) {
    {
#line 652
    print((t_printtype )2, "maximum logsize out of range (0=no limit, 10-4000000 KiB)\n");
    }
#line 654
    return (-1);
  } else
#line 651
  if (config.maxlogsize > 4000000) {
    {
#line 652
    print((t_printtype )2, "maximum logsize out of range (0=no limit, 10-4000000 KiB)\n");
    }
#line 654
    return (-1);
  } else {
#line 656
    logfile.sizelimit = (unsigned int )(config.maxlogsize * 1024);
  }
#line 659
  if (config.usepty) {
#line 660
    (app.pstdout)->ptyremovecr = config.ptyremovecr;
  }
  {
#line 663
  tmp___0 = fixup_pipe(app.pstdout);
  }
#line 663
  if (tmp___0) {
#line 664
    return (-1);
  }
  {
#line 666
  tmp___1 = fixup_pipe(app.pstderr);
  }
#line 666
  if (tmp___1) {
#line 667
    return (-1);
  }
#line 670
  maxindentlen = 15;
#line 671
  if ((app.pstdout)->lineprefixlen > (app.pstderr)->lineprefixlen) {
#line 672
    maxindentlen += (app.pstdout)->lineprefixlen;
  } else {
#line 674
    maxindentlen += (app.pstderr)->lineprefixlen;
  }
  {
#line 676
  tmp___2 = malloc((size_t )(maxindentlen + 1));
#line 676
  (app.logfile)->indent = (char *)tmp___2;
  }
#line 677
  if (! (app.logfile)->indent) {
    {
#line 678
    error_outofmemory();
    }
#line 679
    return (-1);
  }
  {
#line 681
  memset((void *)(app.logfile)->indent, ' ', (size_t )maxindentlen);
  }
#line 683
  return (0);
}
}
#line 686 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
void cleanup_config(void) 
{ 


  {
#line 688
  if (app.argv) {
    {
#line 689
    free((void *)app.argv);
#line 690
    app.argv = (char **)((void *)0);
    }
  }
#line 692
  return;
}
}
#line 694 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
int get_display_parameters(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 701
  tmp___1 = ioctl(1, 21523UL, (char *)app.ptysize);
  }
#line 701
  if (tmp___1 < 0) {
    {
#line 702
    tmp___0 = ioctl(2, 21523UL, (char *)app.ptysize);
    }
#line 702
    if (tmp___0 < 0) {
      {
#line 703
      tmp = ioctl(0, 21523UL, (char *)app.ptysize);
      }
#line 703
      if (tmp < 0) {
#line 705
        app.ptysize = (struct winsize *)((void *)0);
#line 706
        app.ptytermios = (struct termios *)((void *)0);
#line 707
        return (-1);
      }
    }
  }
  {
#line 713
  tmp___4 = tcgetattr(1, app.ptytermios);
  }
#line 713
  if (tmp___4 < 0) {
    {
#line 714
    tmp___3 = tcgetattr(2, app.ptytermios);
    }
#line 714
    if (tmp___3 < 0) {
      {
#line 715
      tmp___2 = tcgetattr(0, app.ptytermios);
      }
#line 715
      if (tmp___2 < 0) {
        {
#line 716
        print((t_printtype )2, "unable to get window termios\n");
#line 717
        app.ptytermios = (struct termios *)((void *)0);
        }
#line 718
        return (-1);
      }
    }
  }
#line 723
  return (0);
}
}
#line 726 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
int adjust_clipping(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 728
  tmp = get_display_parameters();
  }
#line 728
  if (tmp) {
#line 731
    if (pstdout.eclip == 2) {
#line 732
      pstdout.eclip = 0;
    }
#line 734
    if (pstderr.eclip == 2) {
#line 735
      pstderr.eclip = 0;
    }
#line 738
    return (-1);
  }
#line 741
  if (pstdout.eclip == 2) {
#line 742
    pstdout.clip = (int )(app.ptysize)->ws_col;
  }
#line 744
  if (pstderr.eclip == 2) {
#line 745
    pstderr.clip = (int )(app.ptysize)->ws_col;
  }
#line 748
  if (app.pid != 0) {
    {
#line 749
    tmp___0 = ioctl((app.pstdout)->fh, 21524UL, (char *)app.ptysize);
    }
#line 749
    if (tmp___0 < 0) {
      {
#line 751
      print((t_printtype )2, "Unable to set window size");
      }
#line 752
      return (-1);
    }
  }
#line 756
  return (0);
}
}
#line 759 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
int get_argid(char *arg , int isshort ) 
{ 
  int i ;
  int tmp ;

  {
#line 763
  if (! arg) {
#line 764
    return (-1);
  }
#line 766
  i = 0;
  {
#line 766
  while (1) {
    while_continue: /* CIL Label */ ;
#line 766
    if (! (i < (int )arglistsize)) {
#line 766
      goto while_break;
    }
#line 767
    if (isshort) {
#line 768
      if (! arglist[i].shrt) {
#line 769
        goto __Cont;
      }
#line 770
      if ((int )arglist[i].shrt == (int )*arg) {
#line 771
        return (i);
      }
    } else {
#line 773
      if (! arglist[i].lng) {
#line 774
        goto __Cont;
      }
      {
#line 775
      tmp = strcmp((char const   *)arglist[i].lng, (char const   *)arg);
      }
#line 775
      if (! tmp) {
#line 776
        return (i);
      }
    }
    __Cont: /* CIL Label */ 
#line 766
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 780
  return (-1);
}
}
#line 783 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
int string2numvalue(char *string , int *value , stringvalue_t const   *list , stringvalue_t const   *prefixes ) 
{ 
  char *p ;
  int tmp_value ;
  int tmp ;
  int *tmp___0 ;
  long tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  long long tmp___4 ;

  {
#line 789
  if (list) {
    {
#line 790
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 790
      tmp = strcmp((char const   *)string, (char const   *)list->string);
      }
#line 790
      if (! tmp) {
#line 790
        goto while_break;
      }
#line 791
      list ++;
#line 792
      if ((unsigned long )list->string == (unsigned long )((void *)0)) {
#line 793
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 795
    if ((unsigned long )list->string != (unsigned long )((void *)0)) {
#line 796
      *value = (int )list->value;
#line 798
      return (0);
    }
  }
  {
#line 802
  tmp___0 = __errno_location();
#line 802
  *tmp___0 = 0;
#line 803
  tmp___1 = strtol((char const   */* __restrict  */)string, (char **/* __restrict  */)(& p),
                   0);
#line 803
  tmp_value = (int )tmp___1;
#line 804
  tmp___2 = __errno_location();
  }
#line 804
  if (*tmp___2 == 34) {
    {
#line 805
    print((t_printtype )2, "value out of range\n");
    }
#line 806
    return (-1);
  }
#line 808
  if ((unsigned long )p == (unsigned long )string) {
    {
#line 809
    print((t_printtype )2, "invalid parameter value\n");
    }
#line 810
    return (-1);
  }
#line 814
  if (prefixes) {
#line 814
    if (*p) {
      {
#line 815
      print((t_printtype )2, "sdf %d\n", *value);
      }
      {
#line 816
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 816
        tmp___3 = strcmp((char const   *)p, (char const   *)prefixes->string);
        }
#line 816
        if (! tmp___3) {
#line 816
          goto while_break___0;
        }
#line 817
        prefixes ++;
#line 818
        if ((unsigned long )prefixes->string == (unsigned long )((void *)0)) {
#line 819
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 822
      if ((unsigned long )prefixes->string != (unsigned long )((void *)0)) {
#line 826
        tmp___4 = (long long )tmp_value * (long long )prefixes->value;
#line 827
        if (tmp___4 < (-0x7FFFFFFF-1)) {
          {
#line 828
          print((t_printtype )2, "value including prefix out of range\n");
          }
#line 829
          return (-1);
        } else
#line 827
        if (tmp___4 > 2147483647LL) {
          {
#line 828
          print((t_printtype )2, "value including prefix out of range\n");
          }
#line 829
          return (-1);
        }
#line 832
        tmp_value = (int )tmp___4;
      } else {
        {
#line 834
        print((t_printtype )2, "invalid prefix for numerical value\n");
        }
#line 835
        return (-1);
      }
    }
  }
#line 839
  *value = tmp_value;
#line 841
  return (0);
}
}
#line 844 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
int get_argvalue(int priority , int argid , int *argp , int argc , char **argv , char *value ) 
{ 
  int tmpint ;
  int ret ;
  int tmp ;

  {
#line 850
  if (! arglist[argid].var) {
#line 851
    return (-1);
  }
#line 854
  if (argv) {
#line 854
    if ((unsigned long )value == (unsigned long )(*(argv + *argp) + 2)) {
#line 857
      if ((unsigned int )arglist[argid].type == 0U) {
#line 858
        value = (char *)boolvalues[0].string;
      }
    } else {
#line 854
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 860
  if (value) {
#line 860
    if ((unsigned int )arglist[argid].type == 4U) {
      {
#line 861
      print((t_printtype )2, "no value expected\n");
      }
#line 862
      return (-1);
    } else {
#line 860
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 863
  if (! value) {
#line 863
    if ((unsigned int )arglist[argid].type != 4U) {
#line 864
      if (argp) {
#line 865
        if (*argp < argc - 1) {
#line 866
          (*argp) ++;
#line 867
          if (argv) {
#line 867
            if ((int )*(*(argv + *argp) + 0) != 45) {
#line 868
              value = *(argv + *argp);
            }
          }
        }
      }
#line 872
      if (! value) {
        {
#line 873
        print((t_printtype )2, "parameter needs value\n");
        }
#line 874
        return (-1);
      }
    }
  }
  {
#line 879
  if ((unsigned int )arglist[argid].type == 4U) {
#line 879
    goto case_4;
  }
#line 886
  if ((unsigned int )arglist[argid].type == 6U) {
#line 886
    goto case_6;
  }
#line 886
  if ((unsigned int )arglist[argid].type == 3U) {
#line 886
    goto case_6;
  }
#line 886
  if ((unsigned int )arglist[argid].type == 2U) {
#line 886
    goto case_6;
  }
#line 886
  if ((unsigned int )arglist[argid].type == 1U) {
#line 886
    goto case_6;
  }
#line 917
  if ((unsigned int )arglist[argid].type == 5U) {
#line 917
    goto case_5;
  }
#line 929
  if ((unsigned int )arglist[argid].type == 0U) {
#line 929
    goto case_0;
  }
#line 941
  goto switch_default___0;
  case_4: /* CIL Label */ 
#line 879
  if (arglist[argid].set > priority) {
#line 880
    goto switch_break;
  }
#line 881
  *((int *)arglist[argid].var) = 1;
#line 882
  goto switch_break;
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 887
  if ((unsigned int )arglist[argid].type == 1U) {
#line 887
    goto case_1___0;
  }
#line 893
  if ((unsigned int )arglist[argid].type == 2U) {
#line 893
    goto case_2___0;
  }
#line 899
  goto switch_default;
  case_1___0: /* CIL Label */ 
  {
#line 888
  ret = string2numvalue(value, & tmpint, clipvalues, multprefixes);
  }
#line 892
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 894
  ret = string2numvalue(value, & tmpint, colorvalues, multprefixes);
  }
#line 898
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 900
  ret = string2numvalue(value, & tmpint, (stringvalue_t const   *)((void *)0), multprefixes);
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 905
  if (ret) {
#line 906
    return (-1);
  }
#line 908
  if ((unsigned int )arglist[argid].type == 6U) {
#line 908
    if (tmpint < 0) {
      {
#line 909
      print((t_printtype )2, "negative value not allowed for this parameter\n");
      }
#line 911
      return (-1);
    }
  }
#line 913
  if (arglist[argid].set > priority) {
#line 914
    goto switch_break;
  }
#line 915
  *((int *)arglist[argid].var) = tmpint;
#line 916
  goto switch_break;
  case_5: /* CIL Label */ 
#line 917
  if (arglist[argid].set > priority) {
#line 918
    goto switch_break;
  }
#line 919
  if ((unsigned long )*((char **)arglist[argid].var) != (unsigned long )((void *)0)) {
#line 919
    if (arglist[argid].set > 0) {
      {
#line 921
      free((void *)*((char **)arglist[argid].var));
      }
    }
  }
  {
#line 923
  *((char **)arglist[argid].var) = strdup((char const   *)value);
  }
#line 924
  if ((unsigned long )*((char **)arglist[argid].var) == (unsigned long )((void *)0)) {
    {
#line 925
    error_outofmemory();
    }
#line 926
    return (-1);
  }
#line 928
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 929
  tmp = string2numvalue(value, & tmpint, boolvalues, (stringvalue_t const   *)((void *)0));
  }
#line 929
  if (tmp) {
#line 931
    return (-1);
  }
#line 933
  if (tmpint < 0) {
    {
#line 934
    print((t_printtype )2, "invalid boolean value\n");
    }
#line 935
    return (-1);
  } else
#line 933
  if (tmpint > 1) {
    {
#line 934
    print((t_printtype )2, "invalid boolean value\n");
    }
#line 935
    return (-1);
  }
#line 937
  if (arglist[argid].set > priority) {
#line 938
    goto switch_break;
  }
#line 939
  *((int *)arglist[argid].var) = tmpint;
#line 940
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 941
  print((t_printtype )2, "unknown argument type\n");
  }
#line 942
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 945
  if (arglist[argid].set < priority) {
#line 946
    arglist[argid].set = priority;
  }
#line 948
  return (0);
}
}
#line 952 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
int parse_args(int argc , char **argv ) 
{ 
  int i ;
  char *arg ;
  char *value ;
  int argid ;
  int argcount ;
  void *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 958
  argcount = 1;
#line 960
  if (argc < 1) {
    {
#line 961
    print((t_printtype )2, "invalid argument count\n");
    }
#line 962
    return (-1);
  }
  {
#line 967
  tmp = malloc((unsigned long )(argc + 1) * sizeof(*(argv + 0)));
#line 967
  app.argv = (char **)tmp;
  }
#line 968
  if (! app.argv) {
    {
#line 969
    error_outofmemory();
    }
#line 970
    return (-1);
  }
#line 972
  app.argc = 1;
#line 975
  i = 1;
  {
#line 975
  while (1) {
    while_continue: /* CIL Label */ ;
#line 975
    if (! (i < argc)) {
#line 975
      goto while_break;
    }
#line 977
    value = (char *)((void *)0);
#line 978
    if ((int )*(*(argv + i) + 0) == 45) {
#line 979
      if ((int )*(*(argv + i) + 1) == 45) {
        {
#line 980
        arg = *(argv + i) + 2;
#line 982
        tmp___1 = strstr((char const   *)arg, (char const   *)config.argprefix);
        }
#line 982
        if ((unsigned long )tmp___1 == (unsigned long )arg) {
          {
#line 983
          tmp___0 = strlen((char const   *)config.argprefix);
#line 983
          arg += tmp___0;
          }
        } else
#line 985
        if (app.exe) {
#line 986
          *(app.argv + app.argc) = *(argv + i);
#line 987
          (app.argc) ++;
#line 988
          goto __Cont;
        }
        {
#line 992
        value = strchr((char const   *)arg, '=');
        }
#line 992
        if (value) {
#line 993
          *value = (char )'\000';
#line 994
          if (*(value + 1)) {
#line 995
            value ++;
          }
        } else {
#line 1000
          value = *(argv + i) + 2;
        }
        {
#line 1003
        argid = get_argid(arg, 0);
        }
      } else {
#line 1005
        if (app.exe) {
#line 1006
          *(app.argv + app.argc) = *(argv + i);
#line 1007
          (app.argc) ++;
#line 1008
          goto __Cont;
        }
#line 1010
        arg = *(argv + i) + 1;
#line 1011
        if (*(*(argv + i) + 2)) {
#line 1012
          return (argcount);
        }
        {
#line 1014
        argid = get_argid(arg, 1);
        }
      }
#line 1017
      if (argid < 0) {
#line 1018
        return (argcount);
      }
      {
#line 1020
      tmp___2 = get_argvalue(2, argid, & i, argc, argv, value);
      }
#line 1020
      if (tmp___2) {
#line 1021
        return (argcount);
      }
#line 1024
      argcount ++;
    } else {
#line 1026
      if (app.exe) {
#line 1027
        *(app.argv + app.argc) = *(argv + i);
#line 1028
        (app.argc) ++;
#line 1029
        goto __Cont;
      }
#line 1031
      arg = *(argv + i) + 0;
#line 1032
      app.exe = arg;
    }
    __Cont: /* CIL Label */ 
#line 975
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1038
  *(app.argv + 0) = app.exe;
#line 1039
  *(app.argv + app.argc) = (char *)((void *)0);
#line 1041
  if ((unsigned long )app.exe == (unsigned long )((void *)0)) {
#line 1042
    app.argc = 0;
  }
#line 1044
  return (0);
}
}
#line 1051 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
static int lineno  ;
#line 1049 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
int parse_configline(char *line , char **appconfig_section ) 
{ 
  char *name ;
  char *value ;
  char *tmp ;
  int argid ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;

  {
  {
#line 1057
  lineno ++;
#line 1060
  tmp___0 = strspn((char const   *)line, " \t");
#line 1060
  name = line + tmp___0;
#line 1062
  tmp___1 = strlen((char const   *)name);
  }
#line 1062
  if (tmp___1 == 0UL) {
#line 1063
    return (0);
  }
  {
#line 1065
  tmp___2 = strcspn((char const   *)name, " \t=");
#line 1065
  value = name + tmp___2;
#line 1067
  *value = (char )'\000';
#line 1069
  tmp___4 = strlen((char const   *)(value + 1));
  }
#line 1069
  if (tmp___4 > 0UL) {
    {
#line 1070
    tmp___3 = strspn((char const   *)(value + 1), " \t=");
#line 1070
    value = (value + 1) + tmp___3;
    }
  }
#line 1072
  if ((int )*value == 34) {
    {
#line 1073
    value ++;
#line 1074
    tmp = strchr((char const   *)value, '\"');
    }
  } else
#line 1075
  if ((int )*value == 39) {
    {
#line 1076
    value ++;
#line 1077
    tmp = strchr((char const   *)value, '\'');
    }
  } else {
    {
#line 1079
    tmp___5 = strcspn((char const   *)value, " \t");
#line 1079
    tmp = value + tmp___5;
    }
  }
#line 1081
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 1082
    print((t_printtype )1, "unterminated string in config file (line %d)\n", lineno);
    }
#line 1084
    return (-1);
  }
  {
#line 1087
  *tmp = (char )'\000';
#line 1090
  tmp___7 = strlen((char const   *)value);
  }
#line 1090
  if (tmp___7 == 0UL) {
    {
#line 1090
    tmp___8 = strlen((char const   *)name);
    }
#line 1090
    if (tmp___8 > 1UL) {
#line 1090
      if ((int )*(name + 0) == 91) {
        {
#line 1090
        tmp___9 = strlen((char const   *)name);
        }
#line 1090
        if ((int )*(name + (tmp___9 - 1UL)) == 93) {
          {
#line 1092
          name ++;
#line 1093
          tmp___6 = strlen((char const   *)name);
#line 1093
          *(name + (tmp___6 - 1UL)) = (char )'\000';
          }
#line 1094
          if ((unsigned long )*appconfig_section != (unsigned long )((void *)0)) {
            {
#line 1095
            free((void *)*appconfig_section);
            }
          }
          {
#line 1096
          *appconfig_section = strdup((char const   *)name);
          }
#line 1097
          if (! appconfig_section) {
            {
#line 1098
            error_outofmemory();
            }
#line 1099
            return (-1);
          }
#line 1101
          return (0);
        }
      }
    }
  }
#line 1105
  if ((unsigned long )*appconfig_section != (unsigned long )((void *)0)) {
#line 1106
    if ((unsigned long )config.configsection != (unsigned long )((void *)0)) {
      {
#line 1108
      tmp___11 = strchr((char const   *)*appconfig_section, '/');
      }
#line 1108
      if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
        {
#line 1109
        tmp___10 = strrchr((char const   *)config.configsection, '/');
        }
#line 1110
        if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
#line 1111
          tmp___10 = config.configsection;
        } else {
#line 1113
          tmp___10 ++;
        }
      } else {
#line 1115
        tmp___10 = config.configsection;
      }
      {
#line 1117
      tmp___12 = strcmp((char const   *)*appconfig_section, (char const   *)tmp___10);
      }
#line 1117
      if (tmp___12) {
#line 1118
        return (0);
      }
    } else {
#line 1121
      return (0);
    }
  }
  {
#line 1126
  argid = get_argid(name, 0);
  }
#line 1126
  if (argid >= 0) {
    {
#line 1127
    tmp___13 = strlen((char const   *)value);
    }
#line 1127
    if (tmp___13 == 0UL) {
#line 1127
      if ((unsigned int )arglist[argid].type == 4U) {
#line 1128
        value = (char *)((void *)0);
      }
    }
    {
#line 1130
    get_argvalue(1, argid, (int *)((void *)0), 0, (char **)((void *)0), value);
    }
  } else {
    {
#line 1132
    print((t_printtype )1, "unknown parameter in config file (line %d)\n", lineno);
    }
#line 1134
    return (-1);
  }
#line 1137
  return (0);
}
}
#line 1140 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
int get_config(void) 
{ 
  FILE *conffile ;
  char *filename ;
  char *appconfig_section ;
  char linebuf[251] ;
  unsigned int i ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 1142
  conffile = (FILE *)((void *)0);
#line 1144
  appconfig_section = (char *)((void *)0);
#line 1148
  if ((unsigned long )config.custconfigfile == (unsigned long )((void *)0)) {
#line 1150
    i = 0U;
    {
#line 1150
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1150
      if (! ((unsigned long )i < sizeof(configsearchpath) / sizeof(char *))) {
#line 1150
        goto while_break;
      }
      {
#line 1151
      filename = get_longpath((char const   *)configsearchpath[i]);
      }
#line 1153
      if ((unsigned long )filename == (unsigned long )((void *)0)) {
#line 1154
        return (-1);
      }
      {
#line 1156
      conffile = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
      }
#line 1157
      if ((unsigned long )conffile != (unsigned long )((void *)0)) {
#line 1158
        goto while_break;
      }
#line 1150
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1161
    filename = get_longpath((char const   *)config.custconfigfile);
    }
#line 1163
    if ((unsigned long )filename != (unsigned long )((void *)0)) {
      {
#line 1164
      conffile = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
      }
    }
#line 1166
    if ((unsigned long )conffile == (unsigned long )((void *)0)) {
      {
#line 1167
      print((t_printtype )2, "unable to open provided configuration file\n");
      }
#line 1168
      return (-1);
    }
  }
#line 1172
  if ((unsigned long )conffile == (unsigned long )((void *)0)) {
#line 1173
    return (0);
  }
#line 1177
  if ((unsigned long )config.configsection == (unsigned long )((void *)0)) {
#line 1178
    config.configsection = app.exe;
  }
#line 1181
  config.configfile = filename;
  {
#line 1182
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1182
    tmp___1 = fgets((char */* __restrict  */)(linebuf), 251, (FILE */* __restrict  */)conffile);
    }
#line 1182
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 1182
      goto while_break___0;
    }
    {
#line 1183
    tmp = strcspn((char const   *)(linebuf), "#\n");
#line 1183
    linebuf[tmp] = (char )'\000';
#line 1184
    tmp___0 = parse_configline(linebuf, & appconfig_section);
    }
#line 1184
    if (tmp___0) {
#line 1185
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1188
  if (appconfig_section) {
    {
#line 1189
    free((void *)appconfig_section);
    }
  }
  {
#line 1191
  fclose(conffile);
  }
#line 1193
  return (0);
}
}
#line 1197 "/home/wheatley/newnew/temp/logapp-0.15/configuration.c"
int check_for_disable_keywords(void) 
{ 
  int i ;
  int j ;
  int key ;
  char *toksrc ;
  char *tok[50] ;
  char *tmp ;

  {
#line 1204
  if (! config.disable_keywords) {
#line 1205
    return (0);
  }
  {
#line 1207
  toksrc = strdup((char const   *)config.disable_keywords);
#line 1209
  key = 0;
#line 1210
  tok[key] = strtok((char */* __restrict  */)toksrc, (char const   */* __restrict  */)", ");
  }
  {
#line 1211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1211
    if (tok[key]) {
#line 1211
      if (! (key + 1 < 50)) {
#line 1211
        goto while_break;
      }
    } else {
#line 1211
      goto while_break;
    }
    {
#line 1212
    key ++;
#line 1212
    tok[key] = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)", ");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1215
  i = 1;
  {
#line 1215
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1215
    if (i < app.argc) {
#line 1215
      if (! (config.disable == 0)) {
#line 1215
        goto while_break___0;
      }
    } else {
#line 1215
      goto while_break___0;
    }
#line 1216
    j = 0;
    {
#line 1216
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1216
      if (j < key) {
#line 1216
        if (! (config.disable == 0)) {
#line 1216
          goto while_break___1;
        }
      } else {
#line 1216
        goto while_break___1;
      }
      {
#line 1217
      tmp = strstr((char const   *)*(app.argv + i), (char const   *)tok[j]);
      }
#line 1217
      if (tmp) {
#line 1218
        config.disable = 1;
      }
#line 1216
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1215
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1224
  free((void *)toksrc);
  }
#line 1226
  return (0);
}
}
