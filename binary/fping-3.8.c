/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 326 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/seqmap.h"
struct seqmap_value {
   unsigned int host_nr ;
   unsigned int ping_count ;
   struct timeval ping_ts ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/seqmap.h"
typedef struct seqmap_value SEQMAP_VALUE;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 107 "/usr/include/netinet/ip.h"
struct ip {
   unsigned int ip_hl : 4 ;
   unsigned int ip_v : 4 ;
   u_int8_t ip_tos ;
   u_short ip_len ;
   u_short ip_id ;
   u_short ip_off ;
   u_int8_t ip_ttl ;
   u_int8_t ip_p ;
   u_short ip_sum ;
   struct in_addr ip_src ;
   struct in_addr ip_dst ;
};
#line 131 "/usr/include/netinet/ip_icmp.h"
struct icmp_ra_addr {
   u_int32_t ira_addr ;
   u_int32_t ira_preference ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct ih_idseq {
   u_int16_t icd_id ;
   u_int16_t icd_seq ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct ih_pmtu {
   u_int16_t ipm_void ;
   u_int16_t ipm_nextmtu ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct ih_rtradv {
   u_int8_t irt_num_addrs ;
   u_int8_t irt_wpa ;
   u_int16_t irt_lifetime ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
union __anonunion_icmp_hun_62 {
   u_char ih_pptr ;
   struct in_addr ih_gwaddr ;
   struct ih_idseq ih_idseq ;
   u_int32_t ih_void ;
   struct ih_pmtu ih_pmtu ;
   struct ih_rtradv ih_rtradv ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct __anonstruct_id_ts_64 {
   u_int32_t its_otime ;
   u_int32_t its_rtime ;
   u_int32_t its_ttime ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct __anonstruct_id_ip_65 {
   struct ip idi_ip ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
union __anonunion_icmp_dun_63 {
   struct __anonstruct_id_ts_64 id_ts ;
   struct __anonstruct_id_ip_65 id_ip ;
   struct icmp_ra_addr id_radv ;
   u_int32_t id_mask ;
   u_int8_t id_data[1] ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct icmp {
   u_int8_t icmp_type ;
   u_int8_t icmp_code ;
   u_int16_t icmp_cksum ;
   union __anonunion_icmp_hun_62 icmp_hun ;
   union __anonunion_icmp_dun_63 icmp_dun ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 201 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
struct host_entry {
   struct host_entry *ev_prev ;
   struct host_entry *ev_next ;
   struct timeval ev_time ;
   int ev_type ;
   int i ;
   char *name ;
   char *host ;
   char *pad ;
   struct sockaddr_in saddr ;
   int timeout ;
   unsigned char running ;
   unsigned char waiting ;
   struct timeval last_send_time ;
   int num_sent ;
   int num_recv ;
   int num_recv_total ;
   int max_reply ;
   int min_reply ;
   int total_time ;
   int num_sent_i ;
   int num_recv_i ;
   int max_reply_i ;
   int min_reply_i ;
   int total_time_i ;
   int *resp_times ;
};
#line 201 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
typedef struct host_entry HOST_ENTRY;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.h"
void crash_and_burn(char *message ) ;
#line 21
void errno_crash_and_burn(char *message ) ;
#line 357 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/socket4.c"
int open_ping_socket_ipv4(void) 
{ 
  struct protoent *proto ;
  int s___0 ;

  {
  {
#line 48
  proto = getprotobyname("icmp");
  }
#line 48
  if ((unsigned long )proto == (unsigned long )((void *)0)) {
    {
#line 49
    crash_and_burn((char *)"icmp: unknown protocol");
    }
  }
  {
#line 52
  s___0 = socket(2, 3, proto->p_proto);
  }
#line 53
  if (s___0 < 0) {
    {
#line 55
    s___0 = socket(2, 2, proto->p_proto);
    }
#line 56
    if (s___0 < 0) {
      {
#line 57
      errno_crash_and_burn((char *)"can\'t create socket (must run as root?)");
      }
    }
  }
#line 61
  return (s___0);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/socket4.c"
void socket_set_src_addr_ipv4(int s___0 , struct in_addr src_addr___0 ) 
{ 
  struct sockaddr_in sa ;
  int tmp ;

  {
  {
#line 67
  memset((void *)(& sa), 0, sizeof(sa));
#line 68
  sa.sin_family = (sa_family_t )2;
#line 69
  sa.sin_addr = src_addr___0;
#line 71
  tmp = bind(s___0, (struct sockaddr  const  *)((struct sockaddr *)(& sa)), (socklen_t )sizeof(sa));
  }
#line 71
  if (tmp < 0) {
    {
#line 72
    errno_crash_and_burn((char *)"cannot bind source address");
    }
  }
#line 73
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/seqmap.h"
void seqmap_init(void) ;
#line 17
unsigned int seqmap_add(unsigned int host_nr , unsigned int ping_count , struct timeval *now ) ;
#line 18
SEQMAP_VALUE *seqmap_fetch(unsigned int id , struct timeval *now ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/seqmap.c"
static SEQMAP_VALUE *seqmap_map  =    (SEQMAP_VALUE *)((void *)0);
#line 55 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/seqmap.c"
static unsigned int seqmap_next_id  =    0U;
#line 61 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/seqmap.c"
void seqmap_init(void) 
{ 
  void *tmp ;

  {
  {
#line 65
  tmp = calloc((size_t )65535, sizeof(SEQMAP_VALUE ));
#line 65
  seqmap_map = (SEQMAP_VALUE *)tmp;
  }
#line 66
  if ((unsigned long )seqmap_map == (unsigned long )((void *)0)) {
    {
#line 67
    perror("malloc error (can\'t allocate seqmap_map)");
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/seqmap.c"
unsigned int seqmap_add(unsigned int host_nr , unsigned int ping_count , struct timeval *now ) 
{ 
  unsigned int current_id ;
  SEQMAP_VALUE *next_value ;

  {
#line 76
  if (! seqmap_map) {
    {
#line 77
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fping internal error: seqmap not initialized.\n");
#line 78
    exit(4);
    }
  }
#line 83
  next_value = seqmap_map + seqmap_next_id;
#line 84
  if (next_value->ping_ts.tv_sec != 0L) {
#line 84
    if (now->tv_sec - next_value->ping_ts.tv_sec < 10L) {
      {
#line 85
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fping error: not enough sequence numbers available! (expire_timeout=%d, host_nr=%d, ping_count=%d, seqmap_next_id=%d)\n",
              10, host_nr, ping_count, seqmap_next_id);
#line 87
      exit(4);
      }
    }
  }
#line 91
  next_value->host_nr = host_nr;
#line 92
  next_value->ping_count = ping_count;
#line 93
  next_value->ping_ts.tv_sec = now->tv_sec;
#line 94
  next_value->ping_ts.tv_usec = now->tv_usec;
#line 97
  current_id = seqmap_next_id;
#line 98
  seqmap_next_id = (seqmap_next_id + 1U) % 65535U;
#line 100
  return (current_id);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/seqmap.c"
SEQMAP_VALUE *seqmap_fetch(unsigned int id , struct timeval *now ) 
{ 
  SEQMAP_VALUE *value ;

  {
#line 107
  if (id > 65535U) {
#line 108
    return ((SEQMAP_VALUE *)((void *)0));
  }
#line 111
  value = seqmap_map + id;
#line 114
  if (now->tv_sec - value->ping_ts.tv_sec >= 10L) {
#line 115
    return ((SEQMAP_VALUE *)((void *)0));
  }
#line 118
  return (value);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 163 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.h"
int open_ping_socket(void) ;
#line 25
void socket_set_src_addr(int s___0 , struct in_addr src_addr___0 ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 710
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 58
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 64
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __h_errno_location)(void)  __attribute__((__const__)) ;
#line 137
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 662
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 151 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
char *icmp_type_str[19]  = 
#line 151 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
  {      (char *)"ICMP Echo Reply",      (char *)"",      (char *)"",      (char *)"ICMP Unreachable", 
        (char *)"ICMP Source Quench",      (char *)"ICMP Redirect",      (char *)"",      (char *)"", 
        (char *)"ICMP Echo",      (char *)"",      (char *)"",      (char *)"ICMP Time Exceeded", 
        (char *)"ICMP Parameter Problem",      (char *)"ICMP Timestamp Request",      (char *)"ICMP Timestamp Reply",      (char *)"ICMP Information Request", 
        (char *)"ICMP Information Reply",      (char *)"ICMP Mask Request",      (char *)"ICMP Mask Reply"};
#line 174 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
char *icmp_unreach_str[16]  = 
#line 174
  {      (char *)"ICMP Network Unreachable",      (char *)"ICMP Host Unreachable",      (char *)"ICMP Protocol Unreachable",      (char *)"ICMP Port Unreachable", 
        (char *)"ICMP Unreachable (Fragmentation Needed)",      (char *)"ICMP Unreachable (Source Route Failed)",      (char *)"ICMP Unreachable (Destination Network Unknown)",      (char *)"ICMP Unreachable (Destination Host Unknown)", 
        (char *)"ICMP Unreachable (Source Host Isolated)",      (char *)"ICMP Unreachable (Communication with Network Prohibited)",      (char *)"ICMP Unreachable (Communication with Host Prohibited)",      (char *)"ICMP Unreachable (Network Unreachable For Type Of Service)", 
        (char *)"ICMP Unreachable (Host Unreachable For Type Of Service)",      (char *)"ICMP Unreachable (Communication Administratively Prohibited)",      (char *)"ICMP Unreachable (Host Precedence Violation)",      (char *)"ICMP Unreachable (Precedence cutoff in effect)"};
#line 239 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
HOST_ENTRY *rrlist  =    (HOST_ENTRY *)((void *)0);
#line 240 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
HOST_ENTRY **table  =    (HOST_ENTRY **)((void *)0);
#line 245 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
HOST_ENTRY *ev_first  ;
#line 246 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
HOST_ENTRY *ev_last  ;
#line 248 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
char *prog  ;
#line 249 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int ident  ;
#line 250 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int s  ;
#line 251 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
unsigned int debugging  =    0U;
#line 254 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
unsigned int retry  =    3U;
#line 255 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
unsigned int timeout  =    50000U;
#line 256 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
unsigned int interval  =    2500U;
#line 257 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
unsigned int perhost_interval  =    100000U;
#line 258 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
float backoff  =    (float )1.5;
#line 259 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
unsigned int ping_data_size  =    56U;
#line 260 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
unsigned int ping_pkt_size  ;
#line 261 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
unsigned int count  =    1U;
#line 262 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
unsigned int trials  ;
#line 263 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
unsigned int report_interval  =    0U;
#line 264 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
unsigned int ttl  =    0U;
#line 265 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int src_addr_present  =    0;
#line 267 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
struct in_addr src_addr  ;
#line 273 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
long max_reply  =    0L;
#line 274 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
long min_reply  =    0L;
#line 275 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int total_replies  =    0;
#line 276 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
double sum_replies  =    (double )0;
#line 277 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int max_hostname_len  =    0;
#line 278 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int num_jobs  =    0;
#line 279 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int num_hosts  ;
#line 280 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int num_alive  =    0;
#line 280 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int num_unreachable  =    0;
#line 280 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int num_noaddress  =    0;
#line 283 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int num_timeout  =    0;
#line 283 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int num_pingsent  =    0;
#line 283 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int num_pingreceived  =    0;
#line 283 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int num_othericmprcvd  =    0;
#line 288 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
struct timeval current_time  ;
#line 289 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
struct timeval start_time  ;
#line 290 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
struct timeval end_time  ;
#line 291 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
struct timeval last_send_time  ;
#line 292 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
struct timeval last_report_time  ;
#line 293 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
struct timezone tz  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int generate_flag  =    0;
#line 297 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int verbose_flag  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int quiet_flag  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int stats_flag  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int unreachable_flag  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int alive_flag  ;
#line 298 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int elapsed_flag  ;
#line 298 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int version_flag  ;
#line 298 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int count_flag  ;
#line 298 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int loop_flag  ;
#line 299 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int per_recv_flag  ;
#line 299 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int report_all_rtts_flag  ;
#line 299 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int name_flag  ;
#line 299 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int addr_flag  ;
#line 299 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int backoff_flag  ;
#line 300 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int multif_flag  ;
#line 301 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int timestamp_flag  =    0;
#line 307 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
char *filename  =    (char *)((void *)0);
#line 311
void add_name(char *name ) ;
#line 313
void add_addr(char *name , char *host , struct in_addr ipaddr ) ;
#line 320
char *get_host_by_address(struct in_addr in ) ;
#line 321
int in_cksum(unsigned short *p , int n ) ;
#line 322
void u_sleep(int u_sec ) ;
#line 323
int recvfrom_wto(int s___0 , char *buf___0 , int len , struct sockaddr_in *saddr ,
                 long timo ) ;
#line 324
void remove_job(HOST_ENTRY *h ) ;
#line 325
int send_ping(int s___0 , HOST_ENTRY *h ) ;
#line 326
long timeval_diff(struct timeval *a , struct timeval *b ) ;
#line 327
void timeval_add(struct timeval *a , long t_10u ) ;
#line 328
void usage(int is_error ) ;
#line 329
int wait_for_reply(long wait_time ) ;
#line 330
void print_per_system_stats(void) ;
#line 331
void print_per_system_splits(void) ;
#line 332
void print_global_stats(void) ;
#line 333
void main_loop(void) ;
#line 334
void finish(void) ;
#line 335
int handle_random_icmp(struct icmp *p , int psize , struct sockaddr_in *addr ) ;
#line 336
char *sprint_tm(int t ) ;
#line 337
void ev_enqueue(HOST_ENTRY *h ) ;
#line 338
HOST_ENTRY *ev_dequeue(void) ;
#line 339
void ev_remove(HOST_ENTRY *h ) ;
#line 340
void add_cidr(char *addr ) ;
#line 341
void add_range(char *start , char *end ) ;
#line 342
void print_warning(char *format  , ...) ;
#line 360 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  int i ;
  int n ;
  char *buf___0 ;
  uid_t uid ;
  int tos ;
  HOST_ENTRY *cursor ;
  __uid_t tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  long tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  double tmp___11 ;
  int tmp___12 ;
  __uid_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  __uid_t tmp___19 ;
  int tmp___20 ;
  FILE *ping_file ;
  char line[132] ;
  char host[132] ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  void *tmp___24 ;
  size_t tmp___25 ;
  void *tmp___26 ;

  {
  {
#line 365
  tos = 0;
#line 368
  s = open_ping_socket();
#line 370
  uid = getuid();
  }
#line 370
  if (uid) {
    {
#line 371
    tmp = getuid();
#line 371
    seteuid(tmp);
    }
  }
  {
#line 374
  prog = *(argv + 0);
#line 375
  tmp___0 = getpid();
#line 375
  ident = tmp___0 & 65535;
#line 376
  verbose_flag = 1;
#line 377
  backoff_flag = 1;
#line 378
  opterr = 1;
  }
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 382
    c = getopt(argc, (char * const  *)argv, "gedhlmnqusaAvDz:t:H:i:p:f:r:c:b:C:Q:B:S:I:T:O:");
    }
#line 382
    if (! (c != -1)) {
#line 382
      goto while_break;
    }
    {
#line 386
    if (c == 116) {
#line 386
      goto case_116;
    }
#line 392
    if (c == 114) {
#line 392
      goto case_114;
    }
#line 396
    if (c == 105) {
#line 396
      goto case_105;
    }
#line 402
    if (c == 112) {
#line 402
      goto case_112;
    }
#line 408
    if (c == 99) {
#line 408
      goto case_99;
    }
#line 415
    if (c == 67) {
#line 415
      goto case_67;
    }
#line 423
    if (c == 98) {
#line 423
      goto case_98;
    }
#line 431
    if (c == 104) {
#line 431
      goto case_104;
    }
#line 435
    if (c == 113) {
#line 435
      goto case_113;
    }
#line 440
    if (c == 81) {
#line 440
      goto case_81;
    }
#line 448
    if (c == 101) {
#line 448
      goto case_101;
    }
#line 452
    if (c == 109) {
#line 452
      goto case_109;
    }
#line 457
    if (c == 110) {
#line 457
      goto case_110;
    }
#line 457
    if (c == 100) {
#line 457
      goto case_110;
    }
#line 461
    if (c == 65) {
#line 461
      goto case_65;
    }
#line 465
    if (c == 66) {
#line 465
      goto case_66;
    }
#line 471
    if (c == 115) {
#line 471
      goto case_115;
    }
#line 475
    if (c == 68) {
#line 475
      goto case_68;
    }
#line 479
    if (c == 108) {
#line 479
      goto case_108;
    }
#line 484
    if (c == 117) {
#line 484
      goto case_117;
    }
#line 488
    if (c == 97) {
#line 488
      goto case_97;
    }
#line 492
    if (c == 72) {
#line 492
      goto case_72;
    }
#line 505
    if (c == 118) {
#line 505
      goto case_118;
    }
#line 510
    if (c == 102) {
#line 510
      goto case_102;
    }
#line 533
    if (c == 103) {
#line 533
      goto case_103;
    }
#line 539
    if (c == 83) {
#line 539
      goto case_83;
    }
#line 549
    if (c == 73) {
#line 549
      goto case_73;
    }
#line 560
    if (c == 84) {
#line 560
      goto case_84;
    }
#line 564
    if (c == 79) {
#line 564
      goto case_79;
    }
#line 571
    goto switch_default;
    case_116: /* CIL Label */ 
    {
#line 387
    tmp___1 = atoi((char const   *)optarg);
#line 387
    timeout = (unsigned int )tmp___1 * 100U;
    }
#line 387
    if (! timeout) {
      {
#line 388
      usage(1);
      }
    }
#line 390
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 393
    tmp___2 = atoi((char const   *)optarg);
#line 393
    retry = (unsigned int )tmp___2;
    }
#line 394
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 397
    tmp___3 = atoi((char const   *)optarg);
#line 397
    interval = (unsigned int )tmp___3 * 100U;
    }
#line 397
    if (! interval) {
      {
#line 398
      usage(1);
      }
    }
#line 400
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 403
    tmp___4 = atoi((char const   *)optarg);
#line 403
    perhost_interval = (unsigned int )tmp___4 * 100U;
    }
#line 403
    if (! perhost_interval) {
      {
#line 404
      usage(1);
      }
    }
#line 406
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 409
    tmp___5 = atoi((char const   *)optarg);
#line 409
    count = (unsigned int )tmp___5;
    }
#line 409
    if (! count) {
      {
#line 410
      usage(1);
      }
    }
#line 412
    count_flag = 1;
#line 413
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 416
    tmp___6 = atoi((char const   *)optarg);
#line 416
    count = (unsigned int )tmp___6;
    }
#line 416
    if (! count) {
      {
#line 417
      usage(1);
      }
    }
#line 419
    count_flag = 1;
#line 420
    report_all_rtts_flag = 1;
#line 421
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 424
    tmp___7 = __errno_location();
#line 424
    *tmp___7 = 0;
#line 425
    tmp___8 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((char **)((void *)0)),
                     10);
#line 425
    ping_data_size = (unsigned int )tmp___8;
#line 426
    tmp___9 = __errno_location();
    }
#line 426
    if (*tmp___9) {
      {
#line 427
      usage(1);
      }
    }
#line 429
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 432
    usage(0);
    }
#line 433
    goto switch_break;
    case_113: /* CIL Label */ 
#line 436
    verbose_flag = 0;
#line 437
    quiet_flag = 1;
#line 438
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 441
    verbose_flag = 0;
#line 442
    quiet_flag = 1;
#line 443
    tmp___10 = atoi((char const   *)optarg);
#line 443
    report_interval = (unsigned int )tmp___10 * 100000U;
    }
#line 443
    if (! report_interval) {
      {
#line 444
      usage(1);
      }
    }
#line 446
    goto switch_break;
    case_101: /* CIL Label */ 
#line 449
    elapsed_flag = 1;
#line 450
    goto switch_break;
    case_109: /* CIL Label */ 
#line 453
    multif_flag = 1;
#line 454
    goto switch_break;
    case_110: /* CIL Label */ 
    case_100: /* CIL Label */ 
#line 458
    name_flag = 1;
#line 459
    goto switch_break;
    case_65: /* CIL Label */ 
#line 462
    addr_flag = 1;
#line 463
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 466
    tmp___11 = atof((char const   *)optarg);
#line 466
    backoff = (float )tmp___11;
    }
#line 466
    if (! backoff) {
      {
#line 467
      usage(1);
      }
    }
#line 469
    goto switch_break;
    case_115: /* CIL Label */ 
#line 472
    stats_flag = 1;
#line 473
    goto switch_break;
    case_68: /* CIL Label */ 
#line 476
    timestamp_flag = 1;
#line 477
    goto switch_break;
    case_108: /* CIL Label */ 
#line 480
    loop_flag = 1;
#line 481
    backoff_flag = 0;
#line 482
    goto switch_break;
    case_117: /* CIL Label */ 
#line 485
    unreachable_flag = 1;
#line 486
    goto switch_break;
    case_97: /* CIL Label */ 
#line 489
    alive_flag = 1;
#line 490
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 493
    tmp___12 = atoi((char const   *)optarg);
#line 493
    ttl = (u_int )tmp___12;
    }
#line 493
    if (! ttl) {
      {
#line 494
      usage(1);
      }
    }
#line 495
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 506
    printf((char const   */* __restrict  */)"%s: Version %s\n", *(argv + 0), "3.8");
#line 507
    printf((char const   */* __restrict  */)"%s: comments to %s\n", *(argv + 0), "david@schweikert.ch");
#line 508
    exit(0);
    }
    case_102: /* CIL Label */ 
    {
#line 516
    tmp___13 = getuid();
    }
#line 516
    if (tmp___13) {
      {
#line 518
      printf((char const   */* __restrict  */)"%s: this option can only be used by root.\n",
             *(argv + 0));
#line 519
      printf((char const   */* __restrict  */)"%s: fping will read from stdin by default.\n",
             *(argv + 0));
#line 520
      exit(3);
      }
    } else {
#line 525
      filename = optarg;
#line 526
      generate_flag = 0;
    }
#line 530
    goto switch_break;
    case_103: /* CIL Label */ 
#line 536
    generate_flag = 1;
#line 537
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 541
    tmp___14 = inet_pton(2, (char const   */* __restrict  */)optarg, (void */* __restrict  */)(& src_addr));
    }
#line 541
    if (! tmp___14) {
      {
#line 545
      usage(1);
      }
    }
#line 546
    src_addr_present = 1;
#line 547
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 551
    tmp___15 = strlen((char const   *)optarg);
#line 551
    tmp___16 = setsockopt(s, 1, 25, (void const   *)optarg, (socklen_t )tmp___15);
    }
#line 551
    if (tmp___16) {
      {
#line 552
      perror("binding to specific interface (SO_BINTODEVICE)");
      }
    }
#line 558
    goto switch_break;
    case_84: /* CIL Label */ 
#line 562
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 565
    tmp___18 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                      & tos);
    }
#line 565
    if (tmp___18) {
      {
#line 566
      tmp___17 = setsockopt(s, 0, 1, (void const   *)(& tos), (socklen_t )sizeof(tos));
      }
#line 566
      if (tmp___17) {
        {
#line 567
        perror("setting type of service octet IP_TOS");
        }
      }
    }
#line 570
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 572
    usage(1);
    }
#line 573
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 580
  if (ttl > 255U) {
    {
#line 581
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ping: ttl %u out of range\n",
            ttl);
#line 582
    usage(1);
    }
  }
#line 585
  if (unreachable_flag) {
#line 585
    if (alive_flag) {
      {
#line 587
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: specify only one of a, u\n",
              *(argv + 0));
#line 588
      usage(1);
      }
    }
  }
#line 592
  if (count_flag) {
#line 592
    if (loop_flag) {
      {
#line 594
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: specify only one of c, l\n",
              *(argv + 0));
#line 595
      usage(1);
      }
    }
  }
#line 599
  if (interval < 1000U) {
#line 599
    goto _L;
  } else
#line 599
  if (perhost_interval < 2000U) {
#line 599
    goto _L;
  } else
#line 599
  if (retry > 20U) {
#line 599
    goto _L;
  } else
#line 599
  if (timeout < 5000U) {
    _L: /* CIL Label */ 
    {
#line 599
    tmp___19 = getuid();
    }
#line 599
    if (tmp___19) {
      {
#line 605
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: these options are too risky for mere mortals.\n",
              prog);
#line 606
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: You need i >= %u, p >= %u, r < %u, and t >= %u\n",
              prog, 10, 20, 20, 50);
#line 608
      usage(1);
      }
    }
  }
#line 612
  if (ping_data_size > 65508U) {
    {
#line 614
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: data size %u not valid, must be between %u and %u\n",
            prog, ping_data_size, 0U, 65508U);
#line 616
    usage(1);
    }
  } else
#line 612
  if (ping_data_size < 0U) {
    {
#line 614
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: data size %u not valid, must be between %u and %u\n",
            prog, ping_data_size, 0U, 65508U);
#line 616
    usage(1);
    }
  }
#line 620
  if ((double )backoff > 5.0) {
    {
#line 622
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: backoff factor %.1f not valid, must be between %.1f and %.1f\n",
            prog, (double )backoff, 1.0, 5.0);
#line 624
    usage(1);
    }
  } else
#line 620
  if ((double )backoff < 1.0) {
    {
#line 622
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: backoff factor %.1f not valid, must be between %.1f and %.1f\n",
            prog, (double )backoff, 1.0, 5.0);
#line 624
    usage(1);
    }
  }
#line 628
  if (count > 10000U) {
    {
#line 630
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: count %u not valid, must be less than %u\n",
            prog, count, 10000);
#line 632
    usage(1);
    }
  }
#line 636
  if (alive_flag) {
#line 637
    verbose_flag = 0;
  } else
#line 636
  if (unreachable_flag) {
#line 637
    verbose_flag = 0;
  }
#line 639
  if (count_flag) {
#line 641
    if (verbose_flag) {
#line 642
      per_recv_flag = 1;
    }
#line 644
    verbose_flag = 0;
#line 644
    unreachable_flag = verbose_flag;
#line 644
    alive_flag = unreachable_flag;
  }
#line 648
  if (loop_flag) {
#line 650
    if (! report_interval) {
#line 651
      per_recv_flag = 1;
    }
#line 653
    verbose_flag = 0;
#line 653
    unreachable_flag = verbose_flag;
#line 653
    alive_flag = unreachable_flag;
  }
#line 658
  if (count > retry + 1U) {
#line 658
    trials = count;
  } else {
#line 658
    trials = retry + 1U;
  }
#line 718
  if (ttl > 0U) {
    {
#line 719
    tmp___20 = setsockopt(s, 0, 2, (void const   *)(& ttl), (socklen_t )sizeof(ttl));
    }
#line 719
    if (tmp___20) {
      {
#line 720
      perror("setting time to live");
      }
    }
  }
#line 727
  argv += optind;
#line 728
  argc -= optind;
#line 735
  if (*argv) {
#line 735
    if (filename) {
      {
#line 736
      usage(1);
      }
    } else {
#line 735
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 735
  if (filename) {
#line 735
    if (generate_flag) {
      {
#line 736
      usage(1);
      }
    } else {
#line 735
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 735
  if (generate_flag) {
#line 735
    if (! *argv) {
      {
#line 736
      usage(1);
      }
    }
  }
#line 739
  if (! *argv) {
#line 739
    if (! filename) {
#line 739
      if (! generate_flag) {
#line 740
        filename = (char *)"-";
      }
    }
  }
#line 742
  if (*argv) {
#line 742
    if (! generate_flag) {
      {
#line 744
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 744
        if (! *argv) {
#line 744
          goto while_break___0;
        }
        {
#line 746
        add_name(*argv);
#line 747
        argv ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 742
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 751
  if (filename) {
    {
#line 757
    tmp___21 = strcmp((char const   *)filename, "-");
    }
#line 757
    if (tmp___21 == 0) {
      {
#line 758
      ping_file = fdopen(0, "r");
      }
    } else {
      {
#line 760
      ping_file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
      }
    }
#line 762
    if (! ping_file) {
      {
#line 763
      errno_crash_and_burn((char *)"fopen");
      }
    }
    {
#line 766
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 766
      tmp___23 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)ping_file);
      }
#line 766
      if (! tmp___23) {
#line 766
        goto while_break___1;
      }
      {
#line 768
      tmp___22 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%s",
                        host);
      }
#line 768
      if (tmp___22 != 1) {
#line 769
        goto while_continue___1;
      }
#line 771
      if (! host[0]) {
#line 772
        goto while_continue___1;
      } else
#line 771
      if ((int )host[0] == 35) {
#line 772
        goto while_continue___1;
      }
      {
#line 774
      add_name(host);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 777
    fclose(ping_file);
    }
  } else
#line 779
  if (*argv) {
#line 779
    if (generate_flag) {
#line 780
      if (argc == 1) {
        {
#line 782
        add_cidr(*(argv + 0));
        }
      } else
#line 784
      if (argc == 2) {
        {
#line 785
        add_range(*(argv + 0), *(argv + 1));
        }
      } else {
        {
#line 788
        usage(1);
        }
      }
    } else {
      {
#line 792
      usage(1);
      }
    }
  } else {
    {
#line 792
    usage(1);
    }
  }
#line 795
  if (! num_hosts) {
    {
#line 796
    exit(2);
    }
  }
#line 798
  if (src_addr_present) {
    {
#line 799
    socket_set_src_addr(s, src_addr);
    }
  }
  {
#line 804
  tmp___24 = malloc(sizeof(HOST_ENTRY *) * (unsigned long )num_hosts);
#line 804
  table = (HOST_ENTRY **)tmp___24;
  }
#line 805
  if (! table) {
    {
#line 806
    crash_and_burn((char *)"Can\'t malloc array of hosts");
    }
  }
#line 808
  cursor = ev_first;
#line 810
  num_jobs = 0;
  {
#line 810
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 810
    if (! (num_jobs < num_hosts)) {
#line 810
      goto while_break___2;
    }
#line 812
    *(table + num_jobs) = cursor;
#line 813
    cursor->i = num_jobs;
#line 816
    if (count_flag) {
#line 816
      goto _L___3;
    } else
#line 816
    if (loop_flag) {
      _L___3: /* CIL Label */ 
      {
#line 818
      tmp___25 = strlen((char const   *)cursor->host);
#line 818
      n = (int )((size_t )max_hostname_len - tmp___25);
#line 819
      tmp___26 = malloc((size_t )(n + 1));
#line 819
      buf___0 = (char *)tmp___26;
      }
#line 820
      if (! buf___0) {
        {
#line 821
        crash_and_burn((char *)"can\'t malloc host pad");
        }
      }
#line 823
      i = 0;
      {
#line 823
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 823
        if (! (i < n)) {
#line 823
          goto while_break___3;
        }
#line 824
        *(buf___0 + i) = (char )' ';
#line 823
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 826
      *(buf___0 + n) = (char )'\000';
#line 827
      cursor->pad = buf___0;
    }
#line 831
    cursor = cursor->ev_next;
#line 810
    num_jobs ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 835
  ping_pkt_size = ping_data_size + 8U;
#line 837
  signal(2, (void (*)(int  ))(& finish));
#line 839
  gettimeofday((struct timeval */* __restrict  */)(& start_time), (__timezone_ptr_t )(& tz));
#line 840
  current_time = start_time;
  }
#line 842
  if (report_interval) {
#line 843
    last_report_time = start_time;
  }
  {
#line 845
  last_send_time.tv_sec = current_time.tv_sec - 10000L;
#line 852
  seqmap_init();
#line 855
  main_loop();
#line 857
  finish();
  }
#line 859
  return (0);
}
}
#line 862 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void add_cidr(char *addr ) 
{ 
  char *addr_end ;
  char *mask_str ;
  unsigned long mask ;
  unsigned long bitmask ;
  int ret ;
  struct addrinfo addr_hints ;
  struct addrinfo *addr_res ;
  unsigned long net_addr ;
  unsigned long net_last ;
  int tmp ;
  char const   *tmp___0 ;
  uint32_t tmp___1 ;
  struct in_addr in_addr_tmp ;
  char buffer___0[20] ;

  {
  {
#line 875
  addr_end = strchr((char const   *)addr, '/');
  }
#line 876
  if ((unsigned long )addr_end == (unsigned long )((void *)0)) {
    {
#line 877
    usage(1);
    }
  }
  {
#line 879
  *addr_end = (char )'\000';
#line 880
  mask_str = addr_end + 1;
#line 881
  tmp = atoi((char const   *)mask_str);
#line 881
  mask = (unsigned long )tmp;
  }
#line 882
  if (mask < 1UL) {
    {
#line 883
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: netmask must be between 1 and 30 (is: %s)\n",
            mask_str);
#line 884
    exit(2);
    }
  } else
#line 882
  if (mask > 30UL) {
    {
#line 883
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: netmask must be between 1 and 30 (is: %s)\n",
            mask_str);
#line 884
    exit(2);
    }
  }
  {
#line 888
  memset((void *)(& addr_hints), 0, sizeof(struct addrinfo ));
#line 889
  addr_hints.ai_family = 0;
#line 890
  addr_hints.ai_flags = 4;
#line 891
  ret = getaddrinfo((char const   */* __restrict  */)addr, (char const   */* __restrict  */)((void *)0),
                    (struct addrinfo  const  */* __restrict  */)(& addr_hints), (struct addrinfo **/* __restrict  */)(& addr_res));
  }
#line 892
  if (ret) {
    {
#line 893
    tmp___0 = gai_strerror(ret);
#line 893
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: can\'t parse address %s: %s\n",
            addr, tmp___0);
#line 894
    exit(2);
    }
  }
#line 896
  if (addr_res->ai_family != 2) {
    {
#line 897
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: -g works only with IPv4 addresses\n");
#line 898
    exit(2);
    }
  }
  {
#line 900
  tmp___1 = ntohl(((struct sockaddr_in *)addr_res->ai_addr)->sin_addr.s_addr);
#line 900
  net_addr = (unsigned long )tmp___1;
#line 903
  bitmask = 4294967295UL << (32UL - mask);
#line 906
  net_addr &= bitmask;
#line 907
  net_last = (net_addr + (1UL << (32UL - mask))) - 1UL;
  }
  {
#line 910
  while (1) {
    while_continue: /* CIL Label */ ;
#line 910
    net_addr ++;
#line 910
    if (! (net_addr < net_last)) {
#line 910
      goto while_break;
    }
    {
#line 913
    in_addr_tmp.s_addr = htonl((uint32_t )net_addr);
#line 914
    inet_ntop(2, (void const   */* __restrict  */)(& in_addr_tmp), (char */* __restrict  */)(buffer___0),
              (socklen_t )sizeof(buffer___0));
#line 915
    add_name(buffer___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 918
  freeaddrinfo(addr_res);
  }
#line 919
  return;
}
}
#line 921 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void add_range(char *start , char *end ) 
{ 
  struct addrinfo addr_hints ;
  struct addrinfo *addr_res ;
  unsigned long start_long ;
  unsigned long end_long ;
  int ret ;
  char const   *tmp ;
  uint32_t tmp___0 ;
  char const   *tmp___1 ;
  uint32_t tmp___2 ;
  struct in_addr in_addr_tmp ;
  char buffer___0[20] ;

  {
  {
#line 930
  memset((void *)(& addr_hints), 0, sizeof(struct addrinfo ));
#line 931
  addr_hints.ai_family = 0;
#line 932
  addr_hints.ai_flags = 4;
#line 933
  ret = getaddrinfo((char const   */* __restrict  */)start, (char const   */* __restrict  */)((void *)0),
                    (struct addrinfo  const  */* __restrict  */)(& addr_hints), (struct addrinfo **/* __restrict  */)(& addr_res));
  }
#line 934
  if (ret) {
    {
#line 935
    tmp = gai_strerror(ret);
#line 935
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: can\'t parse address %s: %s\n",
            start, tmp);
#line 936
    exit(2);
    }
  }
#line 938
  if (addr_res->ai_family != 2) {
    {
#line 939
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: -g works only with IPv4 addresses\n");
#line 940
    exit(2);
    }
  }
  {
#line 942
  tmp___0 = ntohl(((struct sockaddr_in *)addr_res->ai_addr)->sin_addr.s_addr);
#line 942
  start_long = (unsigned long )tmp___0;
#line 945
  memset((void *)(& addr_hints), 0, sizeof(struct addrinfo ));
#line 946
  addr_hints.ai_family = 0;
#line 947
  addr_hints.ai_flags = 4;
#line 948
  ret = getaddrinfo((char const   */* __restrict  */)end, (char const   */* __restrict  */)((void *)0),
                    (struct addrinfo  const  */* __restrict  */)(& addr_hints), (struct addrinfo **/* __restrict  */)(& addr_res));
  }
#line 949
  if (ret) {
    {
#line 950
    tmp___1 = gai_strerror(ret);
#line 950
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: can\'t parse address %s: %s\n",
            end, tmp___1);
#line 951
    exit(2);
    }
  }
#line 953
  if (addr_res->ai_family != 2) {
    {
#line 954
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: -g works only with IPv4 addresses\n");
#line 955
    exit(2);
    }
  }
  {
#line 957
  tmp___2 = ntohl(((struct sockaddr_in *)addr_res->ai_addr)->sin_addr.s_addr);
#line 957
  end_long = (unsigned long )tmp___2;
  }
  {
#line 960
  while (1) {
    while_continue: /* CIL Label */ ;
#line 960
    if (! (start_long <= end_long)) {
#line 960
      goto while_break;
    }
    {
#line 963
    in_addr_tmp.s_addr = htonl((uint32_t )start_long);
#line 964
    inet_ntop(2, (void const   */* __restrict  */)(& in_addr_tmp), (char */* __restrict  */)(buffer___0),
              (socklen_t )sizeof(buffer___0));
#line 965
    add_name(buffer___0);
#line 966
    start_long ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 968
  return;
}
}
#line 971 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void main_loop(void) 
{ 
  long lt ;
  long wait_time ;
  HOST_ENTRY *h ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 977
  while (1) {
    while_continue: /* CIL Label */ ;
#line 977
    if (! ev_first) {
#line 977
      goto while_break;
    }
#line 979
    if (ev_first->ev_time.tv_sec < current_time.tv_sec) {
#line 979
      goto _L___1;
    } else
#line 979
    if (ev_first->ev_time.tv_sec == current_time.tv_sec) {
#line 979
      if (ev_first->ev_time.tv_usec < current_time.tv_usec) {
        _L___1: /* CIL Label */ 
#line 984
        if (ev_first->ev_type == 1) {
          {
#line 986
          lt = timeval_diff(& current_time, & last_send_time);
          }
#line 987
          if (lt < (long )interval) {
#line 987
            goto wait_for_reply;
          }
          {
#line 990
          h = ev_dequeue();
#line 994
          tmp = send_ping(s, h);
          }
#line 994
          if (! tmp) {
#line 994
            goto wait_for_reply;
          }
#line 997
          if (! loop_flag) {
#line 997
            if (! count_flag) {
#line 999
              if ((unsigned int )h->waiting < retry + 1U) {
                {
#line 1000
                h->ev_type = 1;
#line 1001
                h->ev_time.tv_sec = last_send_time.tv_sec;
#line 1002
                h->ev_time.tv_usec = last_send_time.tv_usec;
#line 1003
                timeval_add(& h->ev_time, (long )h->timeout);
#line 1004
                ev_enqueue(h);
                }
#line 1006
                if (backoff_flag) {
#line 1007
                  h->timeout = (int )((float )h->timeout * backoff);
                }
              } else {
                {
#line 1012
                h->ev_type = 2;
#line 1013
                h->ev_time.tv_sec = last_send_time.tv_sec;
#line 1014
                h->ev_time.tv_usec = last_send_time.tv_usec;
#line 1015
                timeval_add(& h->ev_time, (long )h->timeout);
#line 1016
                ev_enqueue(h);
                }
              }
            } else {
#line 997
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 1020
          if (loop_flag) {
            {
#line 1022
            h->ev_type = 1;
#line 1023
            h->ev_time.tv_sec = last_send_time.tv_sec;
#line 1024
            h->ev_time.tv_usec = last_send_time.tv_usec;
#line 1025
            timeval_add(& h->ev_time, (long )perhost_interval);
#line 1026
            ev_enqueue(h);
            }
          } else
#line 1020
          if (count_flag) {
#line 1020
            if ((unsigned int )h->num_sent < count) {
              {
#line 1022
              h->ev_type = 1;
#line 1023
              h->ev_time.tv_sec = last_send_time.tv_sec;
#line 1024
              h->ev_time.tv_usec = last_send_time.tv_usec;
#line 1025
              timeval_add(& h->ev_time, (long )perhost_interval);
#line 1026
              ev_enqueue(h);
              }
            } else {
#line 1020
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 1029
          if (count_flag) {
#line 1029
            if ((unsigned int )h->num_sent >= count) {
              {
#line 1030
              h->ev_type = 2;
#line 1031
              h->ev_time.tv_sec = last_send_time.tv_sec;
#line 1032
              h->ev_time.tv_usec = last_send_time.tv_usec;
#line 1033
              timeval_add(& h->ev_time, (long )h->timeout);
#line 1034
              ev_enqueue(h);
              }
            }
          }
        } else
#line 1038
        if (ev_first->ev_type == 2) {
          {
#line 1039
          num_timeout ++;
#line 1040
          remove_job(ev_first);
          }
        }
      }
    }
    wait_for_reply: 
#line 1047
    if (ev_first) {
#line 1048
      if (ev_first->ev_time.tv_sec == 0L) {
#line 1049
        wait_time = 0L;
      } else {
        {
#line 1052
        wait_time = timeval_diff(& ev_first->ev_time, & current_time);
        }
#line 1053
        if (wait_time < 0L) {
#line 1053
          wait_time = 0L;
        }
      }
#line 1055
      if (ev_first->ev_type == 1) {
#line 1058
        if (wait_time < (long )interval) {
          {
#line 1059
          lt = timeval_diff(& current_time, & last_send_time);
          }
#line 1060
          if (lt < (long )interval) {
#line 1061
            wait_time = (long )interval - lt;
          } else {
#line 1064
            wait_time = 0L;
          }
        }
      }
    } else {
#line 1076
      wait_time = (long )interval;
    }
    {
#line 1081
    tmp___1 = wait_for_reply(wait_time);
    }
#line 1081
    if (tmp___1) {
      {
#line 1082
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1082
        tmp___0 = wait_for_reply(0L);
        }
#line 1082
        if (! tmp___0) {
#line 1082
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1085
    gettimeofday((struct timeval */* __restrict  */)(& current_time), (__timezone_ptr_t )(& tz));
    }
#line 1088
    if (report_interval) {
#line 1088
      if (loop_flag) {
#line 1088
        goto _L___2;
      } else
#line 1088
      if (count_flag) {
        _L___2: /* CIL Label */ 
        {
#line 1088
        tmp___2 = timeval_diff(& current_time, & last_report_time);
        }
#line 1088
        if (tmp___2 > (long )report_interval) {
          {
#line 1091
          print_per_system_splits();
#line 1092
          last_report_time = current_time;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1095
  return;
}
}
#line 1111 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void finish(void) 
{ 
  int i ;
  HOST_ENTRY *h ;

  {
  {
#line 1116
  gettimeofday((struct timeval */* __restrict  */)(& end_time), (__timezone_ptr_t )(& tz));
#line 1119
  i = 0;
  }
  {
#line 1119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1119
    if (! (i < num_hosts)) {
#line 1119
      goto while_break;
    }
#line 1121
    h = *(table + i);
#line 1123
    if (! h->num_recv) {
#line 1125
      num_unreachable ++;
#line 1127
      if (verbose_flag) {
#line 1127
        goto _L;
      } else
#line 1127
      if (unreachable_flag) {
        _L: /* CIL Label */ 
        {
#line 1129
        printf((char const   */* __restrict  */)"%s", h->host);
        }
#line 1131
        if (verbose_flag) {
          {
#line 1132
          printf((char const   */* __restrict  */)" is unreachable");
          }
        }
        {
#line 1134
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
#line 1119
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1140
  if (count_flag) {
    {
#line 1141
    print_per_system_stats();
    }
  } else
#line 1140
  if (loop_flag) {
    {
#line 1141
    print_per_system_stats();
    }
  }
#line 1147
  if (stats_flag) {
    {
#line 1148
    print_global_stats();
    }
  }
#line 1150
  if (num_noaddress) {
    {
#line 1151
    exit(2);
    }
  } else
#line 1152
  if (num_alive != num_hosts) {
    {
#line 1153
    exit(1);
    }
  }
  {
#line 1155
  exit(0);
  }
}
}
#line 1173 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void print_per_system_stats(void) 
{ 
  int i ;
  int j ;
  int avg ;
  HOST_ENTRY *h ;
  char *buf___0 ;
  int bufsize ;
  int resp ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1181
  bufsize = max_hostname_len + 1;
#line 1182
  tmp = malloc((size_t )bufsize);
#line 1182
  buf___0 = (char *)tmp;
  }
#line 1184
  if (! buf___0) {
    {
#line 1185
    crash_and_burn((char *)"can\'t malloc print buf");
    }
  }
  {
#line 1187
  memset((void *)buf___0, 0, (size_t )bufsize);
#line 1189
  fflush(stdout);
  }
#line 1191
  if (verbose_flag) {
    {
#line 1192
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  } else
#line 1191
  if (per_recv_flag) {
    {
#line 1192
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 1194
  i = 0;
  {
#line 1194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1194
    if (! (i < num_hosts)) {
#line 1194
      goto while_break;
    }
    {
#line 1196
    h = *(table + i);
#line 1197
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s :",
            h->host, h->pad);
    }
#line 1199
    if (report_all_rtts_flag) {
#line 1201
      j = 0;
      {
#line 1201
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1201
        if (! (j < h->num_sent)) {
#line 1201
          goto while_break___0;
        }
#line 1203
        resp = *(h->resp_times + j);
#line 1203
        if (resp >= 0) {
          {
#line 1204
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d.%02d",
                  resp / 100, resp % 100);
          }
        } else {
          {
#line 1206
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -");
          }
        }
#line 1201
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1210
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    } else {
#line 1215
      if (h->num_recv <= h->num_sent) {
#line 1217
        if (h->num_sent > 0) {
#line 1217
          tmp___0 = ((h->num_sent - h->num_recv) * 100) / h->num_sent;
        } else {
#line 1217
          tmp___0 = 0;
        }
        {
#line 1217
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" xmt/rcv/%%loss = %d/%d/%d%%",
                h->num_sent, h->num_recv, tmp___0);
        }
      } else {
        {
#line 1224
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" xmt/rcv/%%return = %d/%d/%d%%",
                h->num_sent, h->num_recv, (h->num_recv * 100) / h->num_sent);
        }
      }
#line 1230
      if (h->num_recv) {
        {
#line 1232
        avg = h->total_time / h->num_recv;
#line 1233
        tmp___1 = sprint_tm(h->min_reply);
#line 1233
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", min/avg/max = %s",
                tmp___1);
#line 1234
        tmp___2 = sprint_tm(avg);
#line 1234
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"/%s",
                tmp___2);
#line 1235
        tmp___3 = sprint_tm(h->max_reply);
#line 1235
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"/%s",
                tmp___3);
        }
      }
      {
#line 1239
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1194
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1260
  free((void *)buf___0);
  }
#line 1262
  return;
}
}
#line 1278 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void print_per_system_splits(void) 
{ 
  int i ;
  int avg ;
  HOST_ENTRY *h ;
  char *buf___0 ;
  int bufsize ;
  struct tm *curr_tm ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1286
  bufsize = max_hostname_len + 1;
#line 1287
  tmp = malloc((size_t )bufsize);
#line 1287
  buf___0 = (char *)tmp;
  }
#line 1288
  if (! buf___0) {
    {
#line 1289
    crash_and_burn((char *)"can\'t malloc print buf");
    }
  }
  {
#line 1291
  memset((void *)buf___0, 0, (size_t )bufsize);
#line 1293
  fflush(stdout);
  }
#line 1295
  if (verbose_flag) {
    {
#line 1296
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  } else
#line 1295
  if (per_recv_flag) {
    {
#line 1296
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1298
  curr_tm = localtime((time_t const   *)(& current_time.tv_sec));
#line 1299
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%2.2d:%2.2d:%2.2d]\n",
          curr_tm->tm_hour, curr_tm->tm_min, curr_tm->tm_sec);
#line 1302
  i = 0;
  }
  {
#line 1302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1302
    if (! (i < num_hosts)) {
#line 1302
      goto while_break;
    }
    {
#line 1304
    h = *(table + i);
#line 1305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s :",
            h->host, h->pad);
    }
#line 1307
    if (h->num_recv_i <= h->num_sent_i) {
#line 1309
      if (h->num_sent_i > 0) {
#line 1309
        tmp___0 = ((h->num_sent_i - h->num_recv_i) * 100) / h->num_sent_i;
      } else {
#line 1309
        tmp___0 = 0;
      }
      {
#line 1309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" xmt/rcv/%%loss = %d/%d/%d%%",
              h->num_sent_i, h->num_recv_i, tmp___0);
      }
    } else {
#line 1316
      if (h->num_sent_i > 0) {
#line 1316
        tmp___1 = (h->num_recv_i * 100) / h->num_sent_i;
      } else {
#line 1316
        tmp___1 = 0;
      }
      {
#line 1316
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" xmt/rcv/%%return = %d/%d/%d%%",
              h->num_sent_i, h->num_recv_i, tmp___1);
      }
    }
#line 1322
    if (h->num_recv_i) {
      {
#line 1324
      avg = h->total_time_i / h->num_recv_i;
#line 1325
      tmp___2 = sprint_tm(h->min_reply_i);
#line 1325
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", min/avg/max = %s",
              tmp___2);
#line 1326
      tmp___3 = sprint_tm(avg);
#line 1326
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"/%s",
              tmp___3);
#line 1327
      tmp___4 = sprint_tm(h->max_reply_i);
#line 1327
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"/%s",
              tmp___4);
      }
    }
    {
#line 1331
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1332
    tmp___8 = 0;
#line 1332
    h->total_time_i = tmp___8;
#line 1332
    tmp___7 = tmp___8;
#line 1332
    h->min_reply_i = tmp___7;
#line 1332
    tmp___6 = tmp___7;
#line 1332
    h->max_reply_i = tmp___6;
#line 1332
    tmp___5 = tmp___6;
#line 1332
    h->num_recv_i = tmp___5;
#line 1332
    h->num_sent_i = tmp___5;
#line 1302
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1337
  free((void *)buf___0);
  }
#line 1339
  return;
}
}
#line 1355 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void print_global_stats(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1357
  fflush(stdout);
#line 1358
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1359
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %7d targets\n",
          num_hosts);
#line 1360
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %7d alive\n",
          num_alive);
#line 1361
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %7d unreachable\n",
          num_unreachable);
#line 1362
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %7d unknown addresses\n",
          num_noaddress);
#line 1363
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1364
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %7d timeouts (waiting for response)\n",
          num_timeout);
#line 1365
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %7d ICMP Echos sent\n",
          num_pingsent);
#line 1366
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %7d ICMP Echo Replies received\n",
          num_pingreceived);
#line 1367
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %7d other ICMP received\n",
          num_othericmprcvd);
#line 1368
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 1370
  if (total_replies == 0) {
#line 1372
    min_reply = 0L;
#line 1373
    max_reply = 0L;
#line 1374
    total_replies = 1;
#line 1375
    sum_replies = (double )0;
  }
  {
#line 1379
  tmp = sprint_tm((int )min_reply);
#line 1379
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s ms (min round trip time)\n",
          tmp);
#line 1380
  tmp___0 = sprint_tm((int )(sum_replies / (double )total_replies));
#line 1380
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s ms (avg round trip time)\n",
          tmp___0);
#line 1382
  tmp___1 = sprint_tm((int )max_reply);
#line 1382
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s ms (max round trip time)\n",
          tmp___1);
#line 1383
  tmp___2 = timeval_diff(& end_time, & start_time);
#line 1383
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %12.3f sec (elapsed real time)\n",
          (double )tmp___2 / 100000.0);
#line 1385
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 1387
  return;
}
}
#line 1408 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int send_ping(int s___0 , HOST_ENTRY *h ) 
{ 
  char *buffer___0 ;
  struct icmp *icp ;
  int n ;
  int myseq ;
  void *tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 1415
  tmp = malloc((size_t )ping_pkt_size);
#line 1415
  buffer___0 = (char *)tmp;
  }
#line 1416
  if (! buffer___0) {
    {
#line 1417
    crash_and_burn((char *)"can\'t malloc ping packet");
    }
  }
  {
#line 1419
  memset((void *)buffer___0, 0, (unsigned long )ping_pkt_size * sizeof(char ));
#line 1420
  icp = (struct icmp *)buffer___0;
#line 1422
  gettimeofday((struct timeval */* __restrict  */)(& h->last_send_time), (__timezone_ptr_t )(& tz));
#line 1423
  tmp___0 = seqmap_add((unsigned int )h->i, (unsigned int )h->num_sent, & h->last_send_time);
#line 1423
  myseq = (int )tmp___0;
#line 1426
  icp->icmp_type = (u_int8_t )8;
#line 1427
  icp->icmp_code = (u_int8_t )0;
#line 1428
  icp->icmp_cksum = (u_int16_t )0;
#line 1429
  icp->icmp_hun.ih_idseq.icd_seq = htons((uint16_t )myseq);
#line 1430
  icp->icmp_hun.ih_idseq.icd_id = htons((uint16_t )ident);
#line 1432
  tmp___1 = in_cksum((unsigned short *)icp, (int )ping_pkt_size);
#line 1432
  icp->icmp_cksum = (u_int16_t )tmp___1;
#line 1446
  tmp___2 = sendto(s___0, (void const   *)buffer___0, (size_t )ping_pkt_size, 0, (struct sockaddr  const  *)((struct sockaddr *)(& h->saddr)),
                   (socklen_t )sizeof(struct sockaddr_in ));
#line 1446
  n = (int )tmp___2;
  }
#line 1449
  if (n < 0) {
#line 1449
    goto _L___0;
  } else
#line 1449
  if ((unsigned int )n != ping_pkt_size) {
    _L___0: /* CIL Label */ 
    {
#line 1449
    tmp___5 = __errno_location();
    }
#line 1449
    if (*tmp___5 != 112) {
#line 1455
      if (verbose_flag) {
#line 1455
        goto _L;
      } else
#line 1455
      if (unreachable_flag) {
        _L: /* CIL Label */ 
        {
#line 1457
        printf((char const   */* __restrict  */)"%s", h->host);
        }
#line 1458
        if (verbose_flag) {
          {
#line 1459
          tmp___3 = __errno_location();
#line 1459
          tmp___4 = strerror(*tmp___3);
#line 1459
          printf((char const   */* __restrict  */)" error while sending ping: %s\n",
                 tmp___4);
          }
        }
        {
#line 1461
        printf((char const   */* __restrict  */)"\n");
        }
      }
      {
#line 1465
      (h->num_sent) ++;
#line 1466
      (h->num_sent_i) ++;
#line 1467
      h->waiting = (unsigned char )((int )h->waiting + 1);
#line 1468
      num_pingsent ++;
#line 1469
      last_send_time = h->last_send_time;
#line 1470
      free((void *)buffer___0);
      }
#line 1471
      return (1);
    }
  }
#line 1475
  if (! loop_flag) {
#line 1476
    *(h->resp_times + h->num_sent) = -1;
  }
  {
#line 1483
  (h->num_sent) ++;
#line 1484
  (h->num_sent_i) ++;
#line 1485
  h->waiting = (unsigned char )((int )h->waiting + 1);
#line 1486
  num_pingsent ++;
#line 1487
  last_send_time = h->last_send_time;
#line 1489
  free((void *)buffer___0);
  }
#line 1490
  return (1);
}
}
#line 1512 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
static char buffer[4096]  ;
#line 1509 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int wait_for_reply(long wait_time ) 
{ 
  int result ;
  struct sockaddr_in response_addr ;
  struct ip *ip ;
  int hlen ;
  struct icmp *icp ;
  int n ;
  int avg ;
  HOST_ENTRY *h ;
  long this_reply ;
  int this_count ;
  struct timeval *sent_time ;
  SEQMAP_VALUE *seqmap_value ;
  char *tmp ;
  int tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 1515
  hlen = 0;
#line 1524
  result = recvfrom_wto(s, buffer, (int )sizeof(buffer), & response_addr, wait_time);
  }
#line 1526
  if (result < 0) {
#line 1527
    return (0);
  }
#line 1538
  ip = (struct ip *)(buffer);
#line 1547
  hlen = (int )(ip->ip_hl << 2);
#line 1549
  if (result < hlen + 8) {
#line 1554
    if (verbose_flag) {
      {
#line 1557
      tmp = inet_ntoa(response_addr.sin_addr);
#line 1557
      printf((char const   */* __restrict  */)"received packet too short for ICMP (%d bytes from %s)\n",
             result, tmp);
      }
    }
#line 1565
    return (1);
  }
  {
#line 1568
  gettimeofday((struct timeval */* __restrict  */)(& current_time), (__timezone_ptr_t )(& tz));
#line 1570
  icp = (struct icmp *)(buffer + hlen);
  }
#line 1572
  if ((int )icp->icmp_type != 0) {
    {
#line 1578
    tmp___0 = handle_random_icmp(icp, result, & response_addr);
    }
#line 1578
    if (tmp___0) {
#line 1579
      num_othericmprcvd ++;
    }
#line 1580
    return (1);
  }
  {
#line 1584
  tmp___1 = ntohs(icp->icmp_hun.ih_idseq.icd_id);
  }
#line 1584
  if ((int )tmp___1 != ident) {
#line 1588
    return (1);
  }
  {
#line 1591
  tmp___2 = ntohs(icp->icmp_hun.ih_idseq.icd_seq);
#line 1591
  seqmap_value = seqmap_fetch((unsigned int )tmp___2, & current_time);
  }
#line 1595
  if ((unsigned long )seqmap_value == (unsigned long )((void *)0)) {
#line 1596
    return (1);
  }
  {
#line 1599
  num_pingreceived ++;
#line 1601
  n = (int )seqmap_value->host_nr;
#line 1602
  h = *(table + n);
#line 1603
  sent_time = & seqmap_value->ping_ts;
#line 1604
  this_count = (int )seqmap_value->ping_count;
#line 1605
  this_reply = timeval_diff(& current_time, sent_time);
  }
#line 1607
  if (loop_flag) {
#line 1607
    goto _L;
  } else
#line 1607
  if (*(h->resp_times + this_count) == -1) {
    _L: /* CIL Label */ 
#line 1610
    h->waiting = (unsigned char)0;
#line 1611
    h->timeout = (int )timeout;
#line 1612
    (h->num_recv) ++;
#line 1613
    (h->num_recv_i) ++;
#line 1615
    if (! max_reply) {
#line 1615
      max_reply = this_reply;
    } else
#line 1615
    if (this_reply > max_reply) {
#line 1615
      max_reply = this_reply;
    }
#line 1616
    if (! min_reply) {
#line 1616
      min_reply = this_reply;
    } else
#line 1616
    if (this_reply < min_reply) {
#line 1616
      min_reply = this_reply;
    }
#line 1617
    if (! h->max_reply) {
#line 1617
      h->max_reply = (int )this_reply;
    } else
#line 1617
    if (this_reply > (long )h->max_reply) {
#line 1617
      h->max_reply = (int )this_reply;
    }
#line 1618
    if (! h->min_reply) {
#line 1618
      h->min_reply = (int )this_reply;
    } else
#line 1618
    if (this_reply < (long )h->min_reply) {
#line 1618
      h->min_reply = (int )this_reply;
    }
#line 1619
    if (! h->max_reply_i) {
#line 1619
      h->max_reply_i = (int )this_reply;
    } else
#line 1619
    if (this_reply > (long )h->max_reply_i) {
#line 1619
      h->max_reply_i = (int )this_reply;
    }
#line 1620
    if (! h->min_reply_i) {
#line 1620
      h->min_reply_i = (int )this_reply;
    } else
#line 1620
    if (this_reply < (long )h->min_reply_i) {
#line 1620
      h->min_reply_i = (int )this_reply;
    }
#line 1621
    sum_replies += (double )this_reply;
#line 1622
    h->total_time = (int )((long )h->total_time + this_reply);
#line 1623
    h->total_time_i = (int )((long )h->total_time_i + this_reply);
#line 1624
    total_replies ++;
  }
#line 1628
  (h->num_recv_total) ++;
#line 1636
  if (! loop_flag) {
#line 1638
    if (this_count >= 0) {
#line 1638
      if ((unsigned int )this_count < trials) {
#line 1640
        if (*(h->resp_times + this_count) != -1) {
#line 1642
          if (! per_recv_flag) {
            {
#line 1644
            tmp___3 = sprint_tm((int )this_reply);
#line 1644
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s : duplicate for [%d], %d bytes, %s ms",
                    h->host, this_count, result, tmp___3);
            }
#line 1647
            if (response_addr.sin_addr.s_addr != h->saddr.sin_addr.s_addr) {
              {
#line 1648
              tmp___4 = inet_ntoa(response_addr.sin_addr);
#line 1648
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [<- %s]",
                      tmp___4);
              }
            }
            {
#line 1658
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
            }
          }
        } else {
#line 1663
          *(h->resp_times + this_count) = (int )this_reply;
        }
      } else {
        {
#line 1669
        tmp___5 = sprint_tm((int )this_reply);
#line 1669
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s : duplicate for [%d], %d bytes, %s ms\n",
                h->host, this_count, result, tmp___5);
        }
      }
    } else {
      {
#line 1669
      tmp___5 = sprint_tm((int )this_reply);
#line 1669
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s : duplicate for [%d], %d bytes, %s ms\n",
              h->host, this_count, result, tmp___5);
      }
    }
  }
#line 1675
  if (h->num_recv == 1) {
#line 1677
    num_alive ++;
#line 1678
    if (verbose_flag) {
#line 1678
      goto _L___0;
    } else
#line 1678
    if (alive_flag) {
      _L___0: /* CIL Label */ 
      {
#line 1680
      printf((char const   */* __restrict  */)"%s", h->host);
      }
#line 1682
      if (verbose_flag) {
        {
#line 1683
        printf((char const   */* __restrict  */)" is alive");
        }
      }
#line 1685
      if (elapsed_flag) {
        {
#line 1686
        tmp___6 = sprint_tm((int )this_reply);
#line 1686
        printf((char const   */* __restrict  */)" (%s ms)", tmp___6);
        }
      }
#line 1688
      if (response_addr.sin_addr.s_addr != h->saddr.sin_addr.s_addr) {
        {
#line 1689
        tmp___7 = inet_ntoa(response_addr.sin_addr);
#line 1689
        printf((char const   */* __restrict  */)" [<- %s]", tmp___7);
        }
      }
      {
#line 1698
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
#line 1703
  if (per_recv_flag) {
#line 1705
    if (timestamp_flag) {
      {
#line 1706
      printf((char const   */* __restrict  */)"[%lu.%06lu] ", (unsigned long )current_time.tv_sec,
             (unsigned long )current_time.tv_usec);
      }
    }
    {
#line 1710
    avg = h->total_time / h->num_recv;
#line 1711
    tmp___8 = sprint_tm((int )this_reply);
#line 1711
    printf((char const   */* __restrict  */)"%s%s : [%d], %d bytes, %s ms", h->host,
           h->pad, this_count, result, tmp___8);
#line 1713
    tmp___9 = sprint_tm(avg);
#line 1713
    printf((char const   */* __restrict  */)" (%s avg, ", tmp___9);
    }
#line 1715
    if (h->num_recv <= h->num_sent) {
      {
#line 1717
      printf((char const   */* __restrict  */)"%d%% loss)", ((h->num_sent - h->num_recv) * 100) / h->num_sent);
      }
    } else {
      {
#line 1723
      printf((char const   */* __restrict  */)"%d%% return)", (h->num_recv_total * 100) / h->num_sent);
      }
    }
#line 1728
    if (response_addr.sin_addr.s_addr != h->saddr.sin_addr.s_addr) {
      {
#line 1729
      tmp___10 = inet_ntoa(response_addr.sin_addr);
#line 1729
      printf((char const   */* __restrict  */)" [<- %s]", tmp___10);
      }
    }
    {
#line 1739
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1744
  if (count_flag) {
#line 1744
    if ((unsigned int )h->num_recv >= count) {
      {
#line 1747
      remove_job(h);
      }
    } else {
#line 1744
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1744
  if (! loop_flag) {
#line 1744
    if (! count_flag) {
#line 1744
      if (h->num_recv) {
        {
#line 1747
        remove_job(h);
        }
      }
    }
  }
  {
#line 1750
  fflush(stdout);
  }
#line 1751
  return (num_jobs);
}
}
#line 1770 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int handle_random_icmp(struct icmp *p , int psize , struct sockaddr_in *addr ) 
{ 
  struct icmp *sent_icmp ;
  unsigned char *c ;
  HOST_ENTRY *h ;
  SEQMAP_VALUE *seqmap_value ;
  uint16_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  in_addr_t tmp___3 ;
  uint16_t tmp___4 ;
  uint16_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  in_addr_t tmp___8 ;
  uint16_t tmp___9 ;

  {
#line 1781
  c = (unsigned char *)p;
  {
#line 1788
  if ((int )p->icmp_type == 3) {
#line 1788
    goto case_3;
  }
#line 1849
  if ((int )p->icmp_type == 12) {
#line 1849
    goto case_12;
  }
#line 1849
  if ((int )p->icmp_type == 11) {
#line 1849
    goto case_12;
  }
#line 1849
  if ((int )p->icmp_type == 5) {
#line 1849
    goto case_12;
  }
#line 1849
  if ((int )p->icmp_type == 4) {
#line 1849
    goto case_12;
  }
#line 1895
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 1789
  sent_icmp = (struct icmp *)(c + 28);
#line 1792
  tmp = ntohs(sent_icmp->icmp_hun.ih_idseq.icd_seq);
#line 1792
  seqmap_value = seqmap_fetch((unsigned int )tmp, & current_time);
  }
#line 1794
  if ((int )sent_icmp->icmp_type == 8) {
    {
#line 1794
    tmp___4 = ntohs(sent_icmp->icmp_hun.ih_idseq.icd_id);
    }
#line 1794
    if ((int )tmp___4 == ident) {
#line 1794
      if ((unsigned long )seqmap_value != (unsigned long )((void *)0)) {
#line 1799
        h = *(table + seqmap_value->host_nr);
#line 1801
        if ((int )p->icmp_code > 15) {
          {
#line 1803
          tmp___0 = inet_ntoa(addr->sin_addr);
#line 1803
          print_warning((char *)"ICMP Unreachable (Invalid Code) from %s for ICMP Echo sent to %s",
                        tmp___0, h->host);
          }
        } else {
          {
#line 1824
          tmp___1 = inet_ntoa(addr->sin_addr);
#line 1824
          print_warning((char *)"%s from %s for ICMP Echo sent to %s", icmp_unreach_str[p->icmp_code],
                        tmp___1, h->host);
          }
        }
        {
#line 1833
        tmp___3 = inet_addr((char const   *)h->host);
        }
#line 1833
        if (tmp___3 == 4294967295U) {
          {
#line 1835
          tmp___2 = inet_ntoa(h->saddr.sin_addr);
#line 1835
          print_warning((char *)" (%s)", tmp___2);
          }
        }
        {
#line 1840
        print_warning((char *)"\n");
        }
      }
    }
  }
#line 1844
  return (1);
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 1850
  sent_icmp = (struct icmp *)(c + 28);
#line 1852
  tmp___5 = ntohs(sent_icmp->icmp_hun.ih_idseq.icd_seq);
#line 1852
  seqmap_value = seqmap_fetch((unsigned int )tmp___5, & current_time);
  }
#line 1854
  if ((int )sent_icmp->icmp_type == 8) {
    {
#line 1854
    tmp___9 = ntohs(sent_icmp->icmp_hun.ih_idseq.icd_id);
    }
#line 1854
    if ((int )tmp___9 == ident) {
#line 1854
      if ((unsigned long )seqmap_value != (unsigned long )((void *)0)) {
        {
#line 1859
        h = *(table + seqmap_value->host_nr);
#line 1860
        tmp___6 = inet_ntoa(addr->sin_addr);
#line 1860
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s from %s for ICMP Echo sent to %s",
                icmp_type_str[p->icmp_type], tmp___6, h->host);
#line 1863
        tmp___8 = inet_addr((char const   *)h->host);
        }
#line 1863
        if (tmp___8 == 4294967295U) {
          {
#line 1864
          tmp___7 = inet_ntoa(h->saddr.sin_addr);
#line 1864
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%s)",
                  tmp___7);
          }
        }
        {
#line 1881
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
    }
  }
#line 1885
  return (2);
  switch_default: /* CIL Label */ 
#line 1896
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1920 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int in_cksum(unsigned short *p , int n ) 
{ 
  register unsigned short answer ;
  register long sum ;
  unsigned short odd_byte ;
  unsigned short *tmp ;

  {
#line 1923
  sum = 0L;
#line 1924
  odd_byte = (unsigned short)0;
  {
#line 1926
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1926
    if (! (n > 1)) {
#line 1926
      goto while_break;
    }
#line 1928
    tmp = p;
#line 1928
    p ++;
#line 1928
    sum += (long )*tmp;
#line 1929
    n -= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 1935
  if (n == 1) {
#line 1937
    *((unsigned char *)(& odd_byte)) = *((unsigned char *)p);
#line 1938
    sum += (long )odd_byte;
  }
#line 1942
  sum = (sum >> 16) + (sum & 65535L);
#line 1943
  sum += sum >> 16;
#line 1944
  answer = (unsigned short )(~ sum);
#line 1946
  return ((int )answer);
}
}
#line 1967 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void add_name(char *name ) 
{ 
  struct hostent *host_ent ;
  unsigned int ipaddress ;
  struct in_addr *ipa ;
  struct in_addr *host_add ;
  char *nm ;
  int i ;
  char namebuf[256] ;
  char *tmp ;
  int *tmp___0 ;
  char namebuf___0[256] ;

  {
  {
#line 1972
  ipa = (struct in_addr *)(& ipaddress);
#line 1975
  i = 0;
#line 1977
  ipaddress = inet_addr((char const   *)name);
  }
#line 1977
  if (ipaddress != 4294967295U) {
#line 1980
    if (name_flag) {
#line 1982
      if (addr_flag) {
        {
#line 1984
        tmp = get_host_by_address(*ipa);
#line 1984
        snprintf((char */* __restrict  */)(namebuf), (size_t )256, (char const   */* __restrict  */)"%s (%s)",
                 tmp, name);
#line 1985
        add_addr(name, namebuf, *ipa);
        }
      } else {
        {
#line 1989
        nm = get_host_by_address(*ipa);
#line 1990
        add_addr(name, nm, *ipa);
        }
      }
    } else {
      {
#line 1995
      add_addr(name, name, *ipa);
      }
    }
#line 1997
    return;
  }
  {
#line 2002
  host_ent = gethostbyname((char const   *)name);
  }
#line 2003
  if ((unsigned long )host_ent == (unsigned long )((void *)0)) {
    {
#line 2005
    tmp___0 = __h_errno_location();
    }
#line 2005
    if (*tmp___0 == 2) {
      {
#line 2007
      u_sleep(1000);
#line 2008
      host_ent = gethostbyname((char const   *)name);
      }
    }
#line 2012
    if ((unsigned long )host_ent == (unsigned long )((void *)0)) {
      {
#line 2037
      print_warning((char *)"%s address not found\n", name);
#line 2039
      num_noaddress ++;
      }
#line 2040
      return;
    }
  }
#line 2045
  if (host_ent->h_addrtype != 2) {
    {
#line 2046
    print_warning((char *)"%s: IPv6 address returned by gethostbyname (options inet6 in resolv.conf?)\n",
                  name);
#line 2047
    num_noaddress ++;
    }
#line 2048
    return;
  }
#line 2051
  host_add = (struct in_addr *)*(host_ent->h_addr_list);
#line 2052
  if ((unsigned long )host_add == (unsigned long )((void *)0)) {
    {
#line 2054
    print_warning((char *)"%s has no address data\n", name);
#line 2056
    num_noaddress ++;
    }
#line 2057
    return;
  } else {
    {
#line 2063
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2063
      if (! host_add) {
#line 2063
        goto while_break;
      }
#line 2065
      if (name_flag) {
#line 2065
        if (addr_flag) {
          {
#line 2067
          nm = inet_ntoa(*host_add);
#line 2068
          snprintf((char */* __restrict  */)(namebuf___0), (size_t )256, (char const   */* __restrict  */)"%s (%s)",
                   name, nm);
#line 2069
          add_addr(name, namebuf___0, *host_add);
          }
        } else {
#line 2065
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2071
      if (addr_flag) {
        {
#line 2073
        nm = inet_ntoa(*host_add);
#line 2074
        add_addr(name, nm, *host_add);
        }
      } else {
        {
#line 2077
        add_addr(name, name, *host_add);
        }
      }
#line 2079
      if (! multif_flag) {
#line 2080
        goto while_break;
      }
#line 2082
      i ++;
#line 2082
      host_add = (struct in_addr *)*(host_ent->h_addr_list + i);
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2156
  return;
}
}
#line 2175 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void add_addr(char *name , char *host , struct in_addr ipaddr ) 
{ 
  HOST_ENTRY *p ;
  int n ;
  int *i ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 2183
  tmp = malloc(sizeof(HOST_ENTRY ));
#line 2183
  p = (HOST_ENTRY *)tmp;
  }
#line 2184
  if (! p) {
    {
#line 2185
    crash_and_burn((char *)"can\'t allocate HOST_ENTRY");
    }
  }
  {
#line 2187
  memset((void *)((char *)p), 0, sizeof(HOST_ENTRY ));
#line 2189
  p->name = strdup((char const   *)name);
#line 2190
  p->host = strdup((char const   *)host);
#line 2192
  p->saddr.sin_family = (sa_family_t )2;
#line 2193
  p->saddr.sin_addr = ipaddr;
#line 2198
  p->timeout = (int )timeout;
#line 2199
  p->running = (unsigned char)1;
#line 2200
  p->min_reply = 0;
#line 2202
  tmp___1 = strlen((char const   *)p->host);
  }
#line 2202
  if (tmp___1 > (size_t )max_hostname_len) {
    {
#line 2203
    tmp___0 = strlen((char const   *)p->host);
#line 2203
    max_hostname_len = (int )tmp___0;
    }
  }
#line 2206
  if (! loop_flag) {
    {
#line 2208
    tmp___2 = malloc((unsigned long )trials * sizeof(int ));
#line 2208
    i = (int *)tmp___2;
    }
#line 2209
    if (! i) {
      {
#line 2210
      crash_and_burn((char *)"can\'t allocate resp_times array");
      }
    }
#line 2212
    n = 1;
    {
#line 2212
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2212
      if (! ((unsigned int )n < trials)) {
#line 2212
        goto while_break;
      }
#line 2213
      *(i + n) = -2;
#line 2212
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2215
    p->resp_times = i;
  }
  {
#line 2236
  p->ev_type = 1;
#line 2237
  p->ev_time.tv_sec = (__time_t )0;
#line 2238
  p->ev_time.tv_usec = (__suseconds_t )0;
#line 2239
  ev_enqueue(p);
#line 2241
  num_hosts ++;
  }
#line 2243
  return;
}
}
#line 2258 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void remove_job(HOST_ENTRY *h ) 
{ 


  {
  {
#line 2265
  h->running = (unsigned char)0;
#line 2266
  h->waiting = (unsigned char)0;
#line 2267
  num_jobs --;
#line 2269
  ev_remove(h);
  }
#line 2271
  return;
}
}
#line 2288 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
char *get_host_by_address(struct in_addr in ) 
{ 
  struct hostent *h ;
  char *tmp ;

  {
  {
#line 2292
  h = gethostbyaddr((void const   *)((char *)(& in)), (__socklen_t )sizeof(struct in_addr ),
                    2);
  }
#line 2297
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 2298
    tmp = inet_ntoa(in);
    }
#line 2298
    return (tmp);
  } else
#line 2297
  if ((unsigned long )h->h_name == (unsigned long )((void *)0)) {
    {
#line 2298
    tmp = inet_ntoa(in);
    }
#line 2298
    return (tmp);
  } else {
#line 2300
    return (h->h_name);
  }
}
}
#line 2316 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void crash_and_burn(char *message ) 
{ 


  {
#line 2318
  if (verbose_flag) {
    {
#line 2319
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            prog, message);
    }
  }
  {
#line 2321
  exit(4);
  }
}
}
#line 2338 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void errno_crash_and_burn(char *message ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 2340
  tmp = __errno_location();
#line 2340
  tmp___0 = strerror(*tmp);
#line 2340
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s : %s\n",
          prog, message, tmp___0);
#line 2341
  exit(4);
  }
}
}
#line 2353 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void print_warning(char *format  , ...) 
{ 
  va_list args ;

  {
#line 2355
  if (! quiet_flag) {
    {
#line 2356
    __builtin_va_start(args, format);
#line 2357
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
             args);
#line 2358
    __builtin_va_end(args);
    }
  }
#line 2360
  return;
}
}
#line 2381 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
long timeval_diff(struct timeval *a , struct timeval *b ) 
{ 
  long sec_diff ;

  {
#line 2383
  sec_diff = a->tv_sec - b->tv_sec;
#line 2384
  if (sec_diff == 0L) {
#line 2385
    return ((a->tv_usec - b->tv_usec) / 10L);
  } else
#line 2387
  if (sec_diff < 100L) {
#line 2388
    return (((sec_diff * 1000000L + a->tv_usec) - b->tv_usec) / 10L);
  } else {
#line 2392
    return (sec_diff * 100000L);
  }
}
}
#line 2401 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void timeval_add(struct timeval *a , long t_10u ) 
{ 


  {
#line 2403
  t_10u *= 10L;
#line 2404
  a->tv_sec += (t_10u + a->tv_usec) / 1000000L;
#line 2405
  a->tv_usec = (t_10u + a->tv_usec) % 1000000L;
#line 2406
  return;
}
}
#line 2427 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
static char buf[10]  ;
#line 2425 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
char *sprint_tm(int t ) 
{ 


  {
#line 2429
  if (t < 0) {
    {
#line 2431
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%.2g",
            (double )t / (double )100);
    }
  } else
#line 2433
  if (t < 100) {
    {
#line 2435
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"0.%02d",
            t);
    }
  } else
#line 2437
  if (t < 1000) {
    {
#line 2439
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d.%02d",
            t / 100, t % 100);
    }
  } else
#line 2441
  if (t < 10000) {
    {
#line 2443
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d.%d",
            t / 100, (t % 100) / 10);
    }
  } else
#line 2445
  if (t < 100000000) {
    {
#line 2447
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d",
            t / 100);
    }
  } else {
    {
#line 2450
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%.2e",
            (double )(t / 100));
    }
  }
#line 2453
  return (buf);
}
}
#line 2468 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void u_sleep(int u_sec ) 
{ 
  int nfound ;
  struct timeval to ;
  fd_set readset ;
  fd_set writeset ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp ;

  {
  select_again: 
#line 2475
  to.tv_sec = (__time_t )(u_sec / 1000000);
#line 2476
  to.tv_usec = (__time_t )u_sec - to.tv_sec * 1000000L;
  {
#line 2478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2478
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readset.__fds_bits[0]): "memory");
#line 2478
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2479
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2479
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& writeset.__fds_bits[0]): "memory");
#line 2479
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2481
  nfound = select(0, (fd_set */* __restrict  */)(& readset), (fd_set */* __restrict  */)(& writeset),
                  (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& to));
  }
#line 2482
  if (nfound < 0) {
    {
#line 2483
    tmp = __errno_location();
    }
#line 2483
    if (*tmp == 4) {
#line 2485
      goto select_again;
    } else {
      {
#line 2488
      errno_crash_and_burn((char *)"select");
      }
    }
  }
#line 2492
  return;
}
}
#line 2515 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
int recvfrom_wto(int s___0 , char *buf___0 , int len , struct sockaddr_in *saddr ,
                 long timo ) 
{ 
  unsigned int slen ;
  int nfound ;
  int n ;
  struct timeval to ;
  fd_set readset ;
  fd_set writeset ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  select_again: 
#line 2523
  if (timo < 100000L) {
#line 2524
    to.tv_sec = (__time_t )0;
#line 2525
    to.tv_usec = timo * 10L;
  } else {
#line 2528
    to.tv_sec = timo / 100000L;
#line 2529
    to.tv_usec = (timo % 100000L) * 10L;
  }
  {
#line 2532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2532
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readset.__fds_bits[0]): "memory");
#line 2532
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2533
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2533
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& writeset.__fds_bits[0]): "memory");
#line 2533
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2534
  readset.__fds_bits[s___0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << s___0 % (8 * (int )sizeof(__fd_mask ));
#line 2536
  nfound = select(s___0 + 1, (fd_set */* __restrict  */)(& readset), (fd_set */* __restrict  */)(& writeset),
                  (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& to));
  }
#line 2537
  if (nfound < 0) {
    {
#line 2538
    tmp = __errno_location();
    }
#line 2538
    if (*tmp == 4) {
#line 2540
      goto select_again;
    } else {
      {
#line 2543
      errno_crash_and_burn((char *)"select");
      }
    }
  }
#line 2547
  if (nfound == 0) {
#line 2548
    return (-1);
  }
  {
#line 2551
  slen = (unsigned int )sizeof(struct sockaddr );
#line 2555
  tmp___0 = recvfrom(s___0, (void */* __restrict  */)buf___0, (size_t )len, 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)saddr),
                     (socklen_t */* __restrict  */)(& slen));
#line 2555
  n = (int )tmp___0;
  }
#line 2556
  if (n < 0) {
    {
#line 2557
    errno_crash_and_burn((char *)"recvfrom");
    }
  }
#line 2559
  return (n);
}
}
#line 2578 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void ev_enqueue(HOST_ENTRY *h ) 
{ 
  HOST_ENTRY *i ;
  HOST_ENTRY *i_prev ;

  {
#line 2591
  if ((unsigned long )ev_last == (unsigned long )((void *)0)) {
#line 2592
    h->ev_next = (struct host_entry *)((void *)0);
#line 2593
    h->ev_prev = (struct host_entry *)((void *)0);
#line 2594
    ev_first = h;
#line 2595
    ev_last = h;
#line 2596
    return;
  }
#line 2600
  if (h->ev_time.tv_sec > ev_last->ev_time.tv_sec) {
#line 2604
    h->ev_next = (struct host_entry *)((void *)0);
#line 2605
    h->ev_prev = ev_last;
#line 2606
    ev_last->ev_next = h;
#line 2607
    ev_last = h;
#line 2608
    return;
  } else
#line 2600
  if (h->ev_time.tv_sec == ev_last->ev_time.tv_sec) {
#line 2600
    if (h->ev_time.tv_usec >= ev_last->ev_time.tv_usec) {
#line 2604
      h->ev_next = (struct host_entry *)((void *)0);
#line 2605
      h->ev_prev = ev_last;
#line 2606
      ev_last->ev_next = h;
#line 2607
      ev_last = h;
#line 2608
      return;
    }
  }
#line 2612
  i = ev_last;
  {
#line 2613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2614
    i_prev = i->ev_prev;
#line 2615
    if ((unsigned long )i_prev == (unsigned long )((void *)0)) {
#line 2615
      goto _L;
    } else
#line 2615
    if (h->ev_time.tv_sec > i_prev->ev_time.tv_sec) {
#line 2615
      goto _L;
    } else
#line 2615
    if (h->ev_time.tv_sec == i_prev->ev_time.tv_sec) {
#line 2615
      if (h->ev_time.tv_usec >= i_prev->ev_time.tv_usec) {
        _L: /* CIL Label */ 
#line 2620
        h->ev_prev = i_prev;
#line 2621
        h->ev_next = i;
#line 2622
        i->ev_prev = h;
#line 2623
        if ((unsigned long )i_prev != (unsigned long )((void *)0)) {
#line 2624
          i_prev->ev_next = h;
        } else {
#line 2627
          ev_first = h;
        }
#line 2629
        return;
      }
    }
#line 2631
    i = i_prev;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2640 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
HOST_ENTRY *ev_dequeue(void) 
{ 
  HOST_ENTRY *dequeued ;

  {
#line 2644
  if ((unsigned long )ev_first == (unsigned long )((void *)0)) {
#line 2645
    return ((HOST_ENTRY *)((void *)0));
  }
  {
#line 2647
  dequeued = ev_first;
#line 2648
  ev_remove(dequeued);
  }
#line 2650
  return (dequeued);
}
}
#line 2658 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void ev_remove(HOST_ENTRY *h ) 
{ 


  {
#line 2660
  if ((unsigned long )ev_first == (unsigned long )h) {
#line 2661
    ev_first = h->ev_next;
  }
#line 2663
  if ((unsigned long )ev_last == (unsigned long )h) {
#line 2664
    ev_last = h->ev_prev;
  }
#line 2666
  if (h->ev_prev) {
#line 2667
    (h->ev_prev)->ev_next = h->ev_next;
  }
#line 2669
  if (h->ev_next) {
#line 2670
    (h->ev_next)->ev_prev = h->ev_prev;
  }
#line 2672
  h->ev_prev = (struct host_entry *)((void *)0);
#line 2673
  h->ev_next = (struct host_entry *)((void *)0);
#line 2674
  return;
}
}
#line 2689 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/fping.c"
void usage(int is_error ) 
{ 
  FILE *out ;
  struct _IO_FILE *tmp ;

  {
#line 2691
  if (is_error) {
#line 2691
    tmp = stderr;
  } else {
#line 2691
    tmp = stdout;
  }
  {
#line 2691
  out = tmp;
#line 2692
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n");
#line 2693
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Usage: %s [options] [targets...]\n",
          prog);
#line 2694
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -a         show targets that are alive\n");
#line 2695
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -A         show targets by address\n");
#line 2696
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -b n       amount of ping data to send, in bytes (default %d)\n",
          56);
#line 2697
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -B f       set exponential backoff factor to f\n");
#line 2698
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -c n       count of pings to send to each target (default %d)\n",
          count);
#line 2699
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -C n       same as -c, report results in verbose format\n");
#line 2700
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -D         print timestamp before each output line\n");
#line 2701
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -e         show elapsed time on return packets\n");
#line 2702
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -f file    read list of targets from a file ( - means stdin) (only if no -g specified)\n");
#line 2703
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -g         generate target list (only if no -f specified)\n");
#line 2704
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"                (specify the start and end IP in the target list, or supply a IP netmask)\n");
#line 2705
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"                (ex. %s -g 192.168.1.0 192.168.1.255 or %s -g 192.168.1.0/24)\n",
          prog, prog);
#line 2706
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -H n       Set the IP TTL value (Time To Live hops)\n");
#line 2707
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -i n       interval between sending ping packets (in millisec) (default %d)\n",
          interval / 100U);
#line 2708
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -l         loop sending pings forever\n");
#line 2709
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -m         ping multiple interfaces on target host\n");
#line 2710
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -n         show targets by name (-d is equivalent)\n");
#line 2711
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -p n       interval between ping packets to one target (in millisec)\n");
#line 2712
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"                (in looping and counting modes, default %d)\n",
          perhost_interval / 100U);
#line 2713
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -q         quiet (don\'t show per-target/per-ping results)\n");
#line 2714
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -Q n       same as -q, but show summary every n seconds\n");
#line 2715
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -r n       number of retries (default %d)\n",
          3);
#line 2716
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -s         print final stats\n");
#line 2718
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -I if      bind to a particular interface\n");
#line 2720
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -S addr    set source address\n");
#line 2721
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -t n       individual target initial timeout (in millisec) (default %d)\n",
          timeout / 100U);
#line 2722
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -T n       ignored (for compatibility with fping 2.4)\n");
#line 2723
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -u         show targets that are unreachable\n");
#line 2724
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -O n       set the type of service (tos) flag on the ICMP packets\n");
#line 2725
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   -v         show version\n");
#line 2726
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   targets    list of targets to check (if no -f specified)\n");
#line 2727
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n");
#line 2728
  exit(is_error);
  }
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/socket.c"
int open_ping_socket(void) 
{ 
  int tmp ;

  {
  {
#line 44
  tmp = open_ping_socket_ipv4();
  }
#line 44
  return (tmp);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/fping-3.8/src/socket.c"
void socket_set_src_addr(int s___0 , struct in_addr src_addr___0 ) 
{ 


  {
  {
#line 53
  socket_set_src_addr_ipv4(s___0, src_addr___0);
  }
#line 57
  return;
}
}
