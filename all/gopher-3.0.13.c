/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 36 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/boolean.h"
typedef int boolean;
#line 37 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/boolean.h"
typedef int BOOLEAN;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 87 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/STRstring.h"
struct string_struct {
   int len ;
   char *data ;
};
#line 92 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/STRstring.h"
typedef struct string_struct String;
#line 38 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/DAarray.h"
struct da_struct {
   char **objects ;
   int Top ;
   int maxsize ;
   char *(*newfn)() ;
   void (*initfn)() ;
   void (*destroyfn)() ;
   char *(*copyfn)() ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/DAarray.h"
typedef struct da_struct DynArray;
#line 48 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/STAarray.h"
typedef DynArray StrArray;
#line 123 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.h"
struct g_struct;
#line 123 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.h"
typedef struct g_struct GopherObj;
#line 61 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.h"
struct block_struct;
#line 61 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.h"
typedef struct block_struct Blockobj;
#line 62 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.h"
typedef DynArray BlockArray;
#line 68
enum blocktype {
    BLOCK_UNKNOWN = 0,
    BLOCK_VIEW = 1,
    BLOCK_ASK = 2,
    BLOCK_ABSTRACT = 3,
    BLOCK_ADMIN = 4
} ;
#line 75 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.h"
typedef enum blocktype BlockType;
#line 82 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.h"
union BlockData_union {
   String *filename ;
   StrArray *text ;
   GopherObj *gs ;
};
#line 88 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.h"
typedef union BlockData_union BlockData;
#line 91
enum blockdatatype {
    BDATA_NONE = 0,
    BDATA_FILE = 1,
    BDATA_TEXT = 2,
    BDATA_GREF = 3
} ;
#line 97 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.h"
typedef enum blockdatatype BlockDataType;
#line 100 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.h"
struct block_struct {
   BlockType btype ;
   String *Blockname ;
   BlockDataType datatype ;
   BlockData data ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.h"
struct view_struct {
   String *Type ;
   String *Lang ;
   String *Size ;
   String *comments ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.h"
typedef struct view_struct VIewobj;
#line 88 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.h"
typedef DynArray VIewArray;
#line 44 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.h"
enum __anonenum_UrlServiceType_2 {
    gopher = 0,
    http = 1,
    ftp = 2,
    telnet = 3,
    tn3270 = 4,
    news = 5,
    unset = 6,
    unknown = 7
} ;
#line 44 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.h"
typedef enum __anonenum_UrlServiceType_2 UrlServiceType;
#line 47 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.h"
struct url_struct {
   String *url ;
   UrlServiceType service ;
   String *Host ;
   int Port ;
   String *Path ;
   String *User ;
   String *Pass ;
   char Gtype ;
};
#line 64 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.h"
typedef struct url_struct Url;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 98 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.h"
struct fileio_struct {
   int bufindex ;
   int bufdatasize ;
   int bytepos ;
   char *buf ;
   boolean issocket ;
   String *filename ;
   int fd ;
   pid_t pid ;
};
#line 112 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.h"
typedef struct fileio_struct FileIO;
#line 170 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.h"
typedef int GSformat;
#line 174 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.h"
struct gplus_struct {
   String *Admin ;
   String *ModDate ;
   VIewArray *Views ;
   BlockArray *OtherBlocks ;
   char **Askdata ;
};
#line 191 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.h"
typedef struct gplus_struct GplusObj;
#line 195 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.h"
struct g_struct {
   char sFileType ;
   String *Title ;
   String *Selstr ;
   String *Host ;
   int iPort ;
   int Itemnum ;
   int weight ;
   int ttl ;
   String *Localfile ;
   String *Localview ;
   boolean isgplus ;
   boolean isask ;
   GplusObj *gplus ;
   Url *url ;
};
#line 299
struct tm;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 89 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Wait.h"
typedef int Portawait;
#line 450 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
union __anonunion_52 {
   Portawait __in ;
   int __i ;
};
#line 450 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
union __anonunion_53 {
   Portawait __in ;
   int __i ;
};
#line 450 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
union __anonunion_54 {
   Portawait __in ;
   int __i ;
};
#line 450 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
union __anonunion_55 {
   Portawait __in ;
   int __i ;
};
#line 450 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
union __anonunion_56 {
   Portawait __in ;
   int __i ;
};
#line 450 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
union __anonunion_57 {
   Portawait __in ;
   int __i ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 31 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.h"
enum direction {
    LEFT = 0,
    RIGHT = 1,
    NOWHERE = 2
} ;
#line 32
enum nodecolor {
    RED = 0,
    BLACK = 1
} ;
#line 34 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.h"
typedef enum direction direction;
#line 35 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.h"
typedef enum nodecolor nodecolor;
#line 37 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.h"
struct RBTree_node_struct {
   char *data ;
   struct RBTree_node_struct *l_child ;
   struct RBTree_node_struct *r_child ;
   nodecolor rb_right ;
   nodecolor rb_left ;
   direction last_pass ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.h"
typedef struct RBTree_node_struct RBTree_node;
#line 73 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.h"
struct RBTree_struct {
   RBTree_node *entry ;
   int (*cmpfn)() ;
   void (*initfn)() ;
   void (*destroyfn)() ;
   char *(*copyfn)() ;
};
#line 83 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.h"
typedef struct RBTree_struct RBTree;
#line 59 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.h"
struct g_dir_struct {
   String *Title ;
   GopherObj *Location ;
   DynArray *Gophers ;
   int currentitem ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.h"
typedef struct g_dir_struct GopherDirObj;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_15 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_15 regmatch_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 146 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.h"
struct CursesStruct {
   WINDOW *Screen ;
   String *Termtype ;
   String *Clearscreen ;
   String *AudibleBell ;
   String *Highlighton ;
   String *Highlightoff ;
   boolean canUseACS ;
   boolean inCurses ;
   int COLS ;
   int ROWS ;
   int Box_ul ;
   int Box_ur ;
   int Box_ll ;
   int Box_lr ;
   int Box_vline ;
   int Box_hline ;
   int Box_tt ;
   int Box_bt ;
   int Box_lt ;
   int Box_rt ;
   int Box_ct ;
   void (*sigtstp)() ;
   void (*sigwinch)() ;
};
#line 178 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.h"
typedef struct CursesStruct CursesObj;
#line 47 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.h"
enum __anonenum_ITEMtype_8 {
    ITEM_UNINIT = 0,
    ITEM_LABEL = 1,
    ITEM_PROMPT = 2,
    ITEM_CHOICE = 3,
    ITEM_SELECT = 4,
    ITEM_PASSWD = 5,
    ITEM_LONG = 6,
    ITEM_FILENAME = 7
} ;
#line 47 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.h"
typedef enum __anonenum_ITEMtype_8 ITEMtype;
#line 51 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.h"
struct ITEM_struct {
   ITEMtype type ;
   String *label ;
   String *response ;
   int chooseitem ;
   StrArray *choices ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.h"
typedef struct ITEM_struct ITEM;
#line 91 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.h"
typedef DynArray FORM;
#line 67 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.h"
struct gopherrcmap_struct {
   String *view ;
   String *displaycmd ;
   String *printcmd ;
};
#line 74 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.h"
typedef struct gopherrcmap_struct RCMapObj;
#line 93 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.h"
typedef DynArray RCMAarray;
#line 109 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.h"
struct RC_struct {
   RCMAarray *commands ;
   GopherDirObj *Bookmarks ;
   GopherObj *Home ;
   boolean SearchBolding ;
   boolean ANSIprinter ;
   boolean ChangedDefs ;
};
#line 121 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.h"
typedef struct RC_struct RCobj;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 216 "../object/GSgopherobj.h"
typedef struct g_struct GopherStruct;
#line 219 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.h"
enum curtype {
    CUR_LABEL = 1,
    CUR_PROMPT = 2,
    CUR_PASSWD = 3,
    CUR_CHOICE = 4,
    CUR_ASKL = 5,
    CUR_FNAME = 6
} ;
#line 227 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.h"
typedef enum curtype Curreqtype;
#line 229 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.h"
struct Requestitem_struct {
   char *prompt ;
   char *stowage ;
   Curreqtype thing ;
   int chooseitem ;
   char **choices ;
};
#line 237 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.h"
typedef struct Requestitem_struct Requestitem;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 450 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
union __anonunion_52___0 {
   Portawait __in ;
   int __i ;
};
#line 450 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
union __anonunion_53___0 {
   Portawait __in ;
   int __i ;
};
#line 450 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
union __anonunion_54___0 {
   Portawait __in ;
   int __i ;
};
#line 450 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
union __anonunion_55___0 {
   Portawait __in ;
   int __i ;
};
#line 450 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
union __anonunion_56___0 {
   Portawait __in ;
   int __i ;
};
#line 450 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
union __anonunion_57___0 {
   Portawait __in ;
   int __i ;
};
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 103 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/STRstring.h"
String *STRnew(void) ;
#line 105
void STRinit(String *st ) ;
#line 106
void STRset(String *st , char *str ) ;
#line 107
void STRdestroy(String *st ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/DAarray.h"
DynArray *DAnew(int size , char *(*newfn)() , void (*initfn)() , void (*destroyfn)() ,
                char *(*copyfn)() ) ;
#line 58
void DAdestroy(DynArray *da ) ;
#line 59
void DAinit(DynArray *da ) ;
#line 60
void DApush(DynArray *da , char *obj ) ;
#line 61
char *DApop(DynArray *da ) ;
#line 65
void DAcpy(DynArray *dest , DynArray *orig ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.h"
int writestring(int fd , char *stringptr ) ;
#line 73
int readrecvbuf(int sockfd , char *buf , int len ) ;
#line 74
int readline(int fd , char *ptr___0 , int maxlen ) ;
#line 75
int readtoken(int fd , char *ptr___0 , int maxlen , char zechar ) ;
#line 77
void ZapCRLF(char *inputline___0 ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.h"
Blockobj *BLnew(void) ;
#line 120
void BLdestroy(Blockobj *bl ) ;
#line 121
void BLinit(Blockobj *bl ) ;
#line 122
void BLcpy(Blockobj *dest , Blockobj *orig ) ;
#line 123
int BLgetNumLines(Blockobj *bl ) ;
#line 125
void BLsetFile(Blockobj *bl , char *filename ) ;
#line 128
char *BLgetLine(Blockobj *bl , int lineno ) ;
#line 129
void BLtoNet(Blockobj *bl , int fd , boolean showheader ) ;
#line 130
int BLfromNet(Blockobj *bl , int fd , char *blockname ) ;
#line 131
int BLAsearch(BlockArray *bla , char *bname ) ;
#line 132
void BLaddText(Blockobj *bl , char *text ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.h"
VIewobj *VInew(void) ;
#line 74
void VIinit(VIewobj *vi ) ;
#line 75
void VIcpy(VIewobj *videst , VIewobj *viorig ) ;
#line 76
void VIdestroy(VIewobj *vi ) ;
#line 77
void VItoLine(VIewobj *vi , char *tmpstr ) ;
#line 99
void VIAfromBL(VIewArray *via , Blockobj *bl ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.h"
UrlServiceType URLgetService(Url *url ) ;
#line 80
Url *URLnew(void) ;
#line 81
void URLdestroy(Url *url ) ;
#line 82
void URLfromGS(Url *url , GopherObj *gs , char *ticket ) ;
#line 85
char *URLgetHost(Url *url ) ;
#line 86
int URLgetPort(Url *url ) ;
#line 88
char URLgetGophType(Url *url ) ;
#line 89
char *URLgetPath(Url *url ) ;
#line 92
char *URLgetUser(Url *url ) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 187 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.h"
int FIOreadlinezap(FileIO *fio , char *ptr___0 , int maxlen ) ;
#line 260 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.h"
char *GSgetModDate(GopherObj *gs ) ;
#line 272
GopherObj *GSnew(void) ;
#line 273
void GSdestroy(GopherObj *gs ) ;
#line 274
void GSinit(GopherObj *gs ) ;
#line 275
void GSplusnew(GopherObj *gs ) ;
#line 276
void GStoNet(GopherObj *gs , int sockfd , GSformat fmt , char *ticket ) ;
#line 278
int GSfromNet(GopherObj *gs , int sockfd ) ;
#line 279
int GSplusfromNet(GopherObj *gs , int fd ) ;
#line 280
int GSfromLink(GopherObj *gs , FileIO *fio , char *host , int port , char *directory ,
               char *peer ) ;
#line 281
void GStoLink(GopherObj *gs , int fd , BOOLEAN AddInfo ) ;
#line 282
void GScpy(GopherObj *dest , GopherObj *orig ) ;
#line 284
void GSsetBlock(GopherObj *gs , char *blockname , char *text , boolean appendIfPoss ) ;
#line 285
void GSsetURL(GopherObj *gs , char *url ) ;
#line 286
void GSsetAdmin(GopherObj *gs , char *admin ) ;
#line 287
void GSsetModDate(GopherObj *gs , char *str ) ;
#line 288
void GSaddView(GopherObj *gs , char *view , char *language , int estsize ) ;
#line 289
void GSaddBlock(GopherObj *gs , char *Blockname , char *file ) ;
#line 290
void GSmerge(GopherObj *gs , GopherObj *overlay ) ;
#line 291
void GSgetginfo(GopherObj *gs , boolean savename ) ;
#line 292
boolean GSisText(GopherObj *gs , char *view ) ;
#line 295
char *GSgetURL(GopherObj *gs , char *ticket ) ;
#line 296
char *GSgetURLhtml(GopherObj *gs , char *ticket ) ;
#line 299
struct tm *GSgetModDateTM(GopherObj *gs ) ;
#line 301
int GSgetNumViews(GopherObj *gs ) ;
#line 302
VIewobj *GSgetView(GopherObj *gs , int viewnum ) ;
#line 304
int GSgetNumBlocks(GopherObj *gs ) ;
#line 305
Blockobj *GSgetBlock(GopherObj *gs , int bnum ) ;
#line 306
Blockobj *GSfindBlock(GopherObj *gs , char *blockname ) ;
#line 308
int GSfromURL(GopherObj *gs , char *urltxt , char *host , int port , int doneflags ) ;
#line 311
int GSconnect(GopherObj *gs ) ;
#line 312
void GStransmit(GopherObj *gs , int sockfd , char *search , char *command , char *view ) ;
#line 313
void GSsendHeader(int sockfd , long size ) ;
#line 314
void GSsendErrorHeader(GopherObj *gs , int sockfd , int errortype , char *errormsg ) ;
#line 315
int GSrecvHeader(GopherObj *gs , int sockfd ) ;
#line 320
void GSplusdestroy(GopherObj *gs ) ;
#line 321
void GSplusInit(GopherObj *gs ) ;
#line 322
void GSplustoNet(GopherObj *gs , int sockfd , char **filter , char *ticket ) ;
#line 323
void GSpluscpy(GopherObj *dest , GopherObj *orig ) ;
#line 326
char **GSsetAskdata(GopherObj *gs , char **askdata ) ;
#line 178 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Regex.h"
char *posix_re_comp(char *regex ) ;
#line 179
int posix_re_exec(char *string ) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Sockets.h"
int SOCKconnect(char *hostname , int port ) ;
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 379 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
GopherObj *GSnew(void) 
{ 
  GopherObj *temp ;
  void *tmp ;

  {
  {
#line 384
  tmp = malloc(sizeof(GopherObj ));
#line 384
  temp = (GopherObj *)tmp;
#line 386
  temp->Selstr = STRnew();
#line 387
  temp->Title = STRnew();
#line 388
  temp->Host = STRnew();
#line 389
  temp->Localfile = STRnew();
#line 390
  temp->Localview = STRnew();
#line 391
  temp->gplus = (GplusObj *)((void *)0);
#line 392
  temp->isask = 0;
#line 393
  temp->url = (Url *)((void *)0);
#line 395
  GSinit(temp);
  }
#line 397
  return (temp);
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSplusnew(GopherObj *gs ) 
{ 
  void *tmp ;

  {
#line 409
  if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
    {
#line 410
    tmp = malloc(sizeof(GplusObj ));
#line 410
    gs->gplus = (GplusObj *)tmp;
    }
  }
  {
#line 413
  (gs->gplus)->Admin = STRnew();
#line 414
  (gs->gplus)->ModDate = STRnew();
#line 416
  (gs->gplus)->Views = DAnew(10, & VInew, & VIinit, & VIdestroy, & VIcpy);
#line 417
  (gs->gplus)->OtherBlocks = DAnew(5, & BLnew, & BLinit, & BLdestroy, & BLcpy);
#line 418
  (gs->gplus)->Askdata = (char **)((void *)0);
  }
#line 419
  return;
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSdestroy(GopherObj *gs ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 427
  STRdestroy(gs->Selstr);
#line 428
  STRdestroy(gs->Title);
#line 429
  STRdestroy(gs->Host);
  }
#line 430
  if ((gs->Localfile)->len < 0) {
#line 430
    tmp___0 = (char *)((void *)0);
  } else {
#line 430
    tmp___0 = (gs->Localfile)->data;
  }
#line 430
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 431
    if ((gs->Localfile)->len < 0) {
#line 431
      tmp = (char *)((void *)0);
    } else {
#line 431
      tmp = (gs->Localfile)->data;
    }
    {
#line 431
    unlink((char const   *)tmp);
    }
  }
  {
#line 432
  STRdestroy(gs->Localfile);
#line 433
  STRdestroy(gs->Localview);
#line 435
  GSplusdestroy(gs);
  }
#line 436
  if ((unsigned long )gs->url != (unsigned long )((void *)0)) {
    {
#line 437
    URLdestroy(gs->url);
    }
  }
  {
#line 438
  free((void *)gs);
  }
#line 439
  return;
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSplusdestroy(GopherObj *gs ) 
{ 


  {
#line 447
  if ((unsigned long )gs->gplus != (unsigned long )((void *)0)) {
    {
#line 448
    STRdestroy((gs->gplus)->Admin);
#line 449
    STRdestroy((gs->gplus)->ModDate);
#line 450
    DAdestroy((gs->gplus)->Views);
#line 451
    DAdestroy((gs->gplus)->OtherBlocks);
#line 453
    GSsetAskdata(gs, (char **)((void *)0));
#line 455
    free((void *)gs->gplus);
#line 456
    gs->gplus = (GplusObj *)((void *)0);
    }
  }
#line 458
  return;
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSinit(GopherObj *gs ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 468
  gs->sFileType = (char )'\000';
#line 470
  STRinit(gs->Title);
#line 471
  STRinit(gs->Selstr);
#line 472
  STRinit(gs->Host);
  }
#line 473
  if ((gs->Localfile)->len < 0) {
#line 473
    tmp___0 = (char *)((void *)0);
  } else {
#line 473
    tmp___0 = (gs->Localfile)->data;
  }
#line 473
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 474
    if ((gs->Localfile)->len < 0) {
#line 474
      tmp = (char *)((void *)0);
    } else {
#line 474
      tmp = (gs->Localfile)->data;
    }
    {
#line 474
    unlink((char const   *)tmp);
    }
  }
  {
#line 475
  STRinit(gs->Localfile);
#line 476
  STRinit(gs->Localview);
#line 478
  gs->ttl = -1;
#line 479
  gs->iPort = 0;
#line 480
  gs->Itemnum = 0;
#line 481
  gs->weight = 0;
#line 483
  gs->isgplus = 0;
#line 484
  gs->isask = 0;
  }
#line 486
  if ((unsigned long )gs->url != (unsigned long )((void *)0)) {
    {
#line 487
    URLdestroy(gs->url);
    }
  }
  {
#line 488
  gs->url = (Url *)((void *)0);
#line 489
  GSplusInit(gs);
  }
#line 490
  return;
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSplusInit(GopherObj *gs ) 
{ 


  {
#line 500
  if ((unsigned long )gs->gplus != (unsigned long )((void *)0)) {
    {
#line 501
    STRinit((gs->gplus)->Admin);
#line 502
    STRinit((gs->gplus)->ModDate);
#line 503
    DAinit((gs->gplus)->Views);
#line 504
    DAinit((gs->gplus)->OtherBlocks);
    }
  }
#line 507
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSsetURL(GopherObj *gs , char *url ) 
{ 


  {
#line 519
  if ((unsigned long )gs->url == (unsigned long )((void *)0)) {
    {
#line 520
    gs->url = URLnew();
    }
  }
  {
#line 522
  STRset((gs->url)->url, url);
  }
#line 523
  return;
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
int GSgetNumBlocks(GopherObj *gs ) 
{ 


  {
#line 528
  if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
#line 529
    return (-1);
  }
#line 531
  return (((gs->gplus)->OtherBlocks)->Top);
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
Blockobj *GSgetBlock(GopherObj *gs , int bnum ) 
{ 


  {
#line 537
  if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
#line 538
    return ((Blockobj *)((void *)0));
  } else
#line 537
  if (bnum < 0) {
#line 538
    return ((Blockobj *)((void *)0));
  }
#line 540
  return ((Blockobj *)*(((gs->gplus)->OtherBlocks)->objects + bnum));
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
int GSgetNumViews(GopherObj *gs ) 
{ 


  {
#line 550
  if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
#line 551
    return (0);
  }
#line 553
  return (((gs->gplus)->Views)->Top);
}
}
#line 560 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
VIewobj *GSgetView(GopherObj *gs , int viewnum ) 
{ 


  {
#line 563
  if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
#line 564
    return ((VIewobj *)((void *)0));
  }
#line 566
  return ((VIewobj *)*(((gs->gplus)->Views)->objects + viewnum));
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
char *GSgetURL(GopherObj *gs , char *ticket ) 
{ 
  char *tmp ;

  {
#line 573
  if ((unsigned long )gs->url == (unsigned long )((void *)0)) {
    {
#line 574
    gs->url = URLnew();
#line 575
    URLfromGS(gs->url, gs, ticket);
    }
  }
#line 578
  if (((gs->url)->url)->len < 0) {
#line 578
    tmp = (char *)((void *)0);
  } else {
#line 578
    tmp = ((gs->url)->url)->data;
  }
#line 578
  return (tmp);
}
}
#line 582 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
char *GSgetURLhtml(GopherObj *gs , char *ticket ) 
{ 
  char *cp ;
  char *tmp ;
  char *cp2 ;
  int views ;
  int tmp___0 ;
  VIewobj *tmp___2 ;
  char *tmp___3 ;
  VIewobj *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 585
  tmp = GSgetURL(gs, ticket);
#line 585
  cp = tmp;
  }
#line 589
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 589
    tmp___10 = strncmp((char const   *)cp, "gopher://", (size_t )9);
    }
#line 589
    if (tmp___10 == 0) {
#line 590
      if ((unsigned long )gs->gplus != (unsigned long )((void *)0)) {
#line 591
        views = 0;
        {
#line 591
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 591
          tmp___6 = GSgetNumViews(gs);
          }
#line 591
          if (! (views < tmp___6)) {
#line 591
            goto while_break;
          }
          {
#line 592
          tmp___4 = GSgetView(gs, views);
          }
#line 592
          if ((tmp___4->Type)->len < 0) {
#line 592
            tmp___3 = (char *)((void *)0);
          } else {
            {
#line 592
            tmp___2 = GSgetView(gs, views);
#line 592
            tmp___3 = (tmp___2->Type)->data;
            }
          }
          {
#line 592
          tmp___5 = strncasecmp((char const   *)tmp___3, "text/html", (size_t )9);
          }
#line 592
          if (! tmp___5) {
            {
#line 595
            cp = strdup((char const   *)cp);
#line 598
            cp2 = strchr((char const   *)(cp + 10), '/');
            }
#line 599
            if ((unsigned long )cp2 != (unsigned long )((void *)0)) {
              {
#line 600
              cp2 ++;
#line 600
              *cp2 = (char )'h';
#line 601
              cp2 ++;
#line 602
              tmp___0 = strncmp((char const   *)cp2, "%2a", (size_t )3);
              }
#line 602
              if (tmp___0 == 0) {
                {
#line 604
                cp2 = strstr((char const   *)cp2, "%20");
                }
#line 605
                if ((unsigned long )cp2 != (unsigned long )((void *)0)) {
                  {
#line 606
                  cp2 += 3;
#line 607
                  cp2 = strstr((char const   *)cp2, "%20");
                  }
#line 608
                  if ((unsigned long )cp2 != (unsigned long )((void *)0)) {
#line 609
                    cp2 += 3;
#line 610
                    *cp2 = (char )'h';
                  }
                }
              } else {
#line 614
                *cp2 = (char )'h';
              }
            }
          }
#line 591
          views ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 619
      tmp___9 = strstr((char const   *)cp, "/1validate%201");
      }
#line 619
      if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
        {
#line 620
        cp = strdup((char const   *)cp);
#line 621
        cp2 = strchr((char const   *)(cp + 10), '/');
        }
#line 622
        if ((unsigned long )cp2 != (unsigned long )((void *)0)) {
#line 623
          cp2 ++;
#line 623
          *cp2 = (char )'h';
#line 624
          cp2 ++;
#line 624
          *cp2 = (char )'h';
#line 625
          *(cp2 + 11) = (char )'h';
        }
      } else {
        {
#line 628
        tmp___8 = strstr((char const   *)cp, "/hhalidate%201");
        }
#line 628
        if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
          {
#line 629
          cp = strdup((char const   *)cp);
#line 630
          cp2 = strchr((char const   *)(cp + 10), '/');
#line 631
          *(cp2 + 13) = (char )'h';
          }
        } else
#line 632
        if ((gs->Selstr)->len < 0) {
#line 632
          tmp___7 = (char *)((void *)0);
        } else {
#line 632
          tmp___7 = (gs->Selstr)->data;
        }
      }
    }
  }
#line 638
  return (cp);
}
}
#line 642 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
static char *GStoNetURL(GopherObj *gs , char *url , char *ticket ) 
{ 
  char *path ;
  char *ftphost ;
  char *ftppath ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 647
  *url = (char )'\000';
#line 648
  if ((gs->Selstr)->len < 0) {
#line 648
    tmp = (char *)((void *)0);
  } else {
#line 648
    tmp = (gs->Selstr)->data;
  }
#line 648
  path = tmp;
#line 651
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 652
    return ((char *)((void *)0));
  }
#line 654
  if ((unsigned long )path != (unsigned long )((void *)0)) {
    {
#line 654
    tmp___1 = strncmp((char const   *)path, "ftp://", (size_t )6);
    }
#line 654
    if (tmp___1 == 0) {
      {
#line 655
      strcpy((char */* __restrict  */)url, (char const   */* __restrict  */)path);
      }
#line 656
      return (url);
    } else {
#line 654
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 658
  if ((unsigned long )path != (unsigned long )((void *)0)) {
    {
#line 658
    tmp___0 = strncmp((char const   *)path, "ftp:", (size_t )4);
    }
#line 658
    if (tmp___0 == 0) {
      {
#line 659
      ftphost = path + 4;
#line 660
      ftppath = strchr((char const   *)ftphost, '@');
      }
#line 662
      if ((unsigned long )ftppath != (unsigned long )((void *)0)) {
        {
#line 664
        sprintf((char */* __restrict  */)url, (char const   */* __restrict  */)"ftp://%.*s/",
                (int )(ftppath - ftphost), ftphost);
#line 666
        ftppath ++;
        }
#line 669
        if ((int )*ftppath == 47) {
#line 670
          ftppath ++;
        }
        {
#line 672
        strcat((char */* __restrict  */)url, (char const   */* __restrict  */)ftppath);
        }
#line 673
        return (url);
      }
    }
  }
  {
#line 676
  tmp___2 = GSgetURLhtml(gs, ticket);
#line 676
  strcpy((char */* __restrict  */)url, (char const   */* __restrict  */)tmp___2);
  }
#line 677
  return (url);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
Blockobj *GSfindBlock(GopherObj *gs , char *blockname ) 
{ 
  int x ;
  BlockArray *tmp ;
  Blockobj *tmp___0 ;

  {
#line 686
  if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
#line 686
    tmp = (BlockArray *)((void *)0);
  } else {
#line 686
    tmp = (gs->gplus)->OtherBlocks;
  }
  {
#line 686
  x = BLAsearch(tmp, blockname);
  }
#line 689
  if (x < 0) {
#line 690
    return ((Blockobj *)((void *)0));
  } else {
    {
#line 692
    tmp___0 = GSgetBlock(gs, x);
    }
#line 692
    return (tmp___0);
  }
}
}
#line 695 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSsetBlock(GopherObj *gs , char *blockname , char *text , boolean appendIfPoss ) 
{ 
  Blockobj *bl ;
  boolean newbl ;

  {
#line 698
  bl = (Blockobj *)((void *)0);
#line 699
  newbl = 0;
#line 704
  if (appendIfPoss) {
    {
#line 705
    bl = GSfindBlock(gs, blockname);
    }
  }
#line 707
  if ((unsigned long )bl == (unsigned long )((void *)0)) {
    {
#line 708
    newbl = 1;
#line 709
    bl = BLnew();
    }
  }
  {
#line 712
  STRset(bl->Blockname, blockname);
#line 713
  BLaddText(bl, text);
  }
#line 719
  if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
    {
#line 720
    GSplusnew(gs);
    }
  }
#line 722
  if (newbl) {
    {
#line 723
    DApush((gs->gplus)->OtherBlocks, (char *)bl);
#line 724
    BLdestroy(bl);
    }
  }
#line 727
  return;
}
}
#line 733 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
char **GSsetAskdata(GopherObj *gs , char **askdata ) 
{ 
  int i ;
  char **Askmoo ;
  int tmp ;

  {
#line 736
  if (! ((unsigned long )gs->gplus != (unsigned long )((void *)0))) {
#line 737
    return ((char **)((void *)0));
  }
#line 740
  if ((unsigned long )(gs->gplus)->Askdata != (unsigned long )((void *)0)) {
#line 741
    i = 0;
#line 742
    Askmoo = (gs->gplus)->Askdata;
    {
#line 744
    while (1) {
      while_continue: /* CIL Label */ ;
#line 744
      if (! ((unsigned long )*(Askmoo + i) != (unsigned long )((void *)0))) {
#line 744
        goto while_break;
      }
      {
#line 745
      tmp = i;
#line 745
      i ++;
#line 745
      free((void *)*(Askmoo + tmp));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 747
    free((void *)Askmoo);
    }
  }
#line 750
  (gs->gplus)->Askdata = askdata;
#line 752
  return (askdata);
}
}
#line 767 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
static struct tm time___0  ;
#line 764 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
struct tm *GSgetModDateTM(GopherObj *gs ) 
{ 
  char *cp ;
  time_t converted ;
  char *tmp ;
  char *tmp___0 ;
  struct tm *tmp___1 ;

  {
#line 773
  if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
#line 774
    return ((struct tm *)((void *)0));
  } else {
#line 773
    if (((gs->gplus)->ModDate)->len < 0) {
#line 773
      tmp = (char *)((void *)0);
    } else {
#line 773
      tmp = ((gs->gplus)->ModDate)->data;
    }
#line 773
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 774
      return ((struct tm *)((void *)0));
    }
  }
#line 776
  if (((gs->gplus)->ModDate)->len < 0) {
#line 776
    tmp___0 = (char *)((void *)0);
  } else {
#line 776
    tmp___0 = ((gs->gplus)->ModDate)->data;
  }
  {
#line 776
  cp = strchr((char const   *)tmp___0, '<');
  }
#line 777
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 778
    return ((struct tm *)((void *)0));
  }
  {
#line 782
  time___0.tm_year = (((((int )*(cp + 1) - 48) * 1000 + ((int )*(cp + 2) - 48) * 100) + ((int )*(cp + 3) - 48) * 10) + ((int )*(cp + 4) - 48)) - 1900;
#line 784
  time___0.tm_mon = (((int )*(cp + 5) - 48) * 10 + ((int )*(cp + 6) - 48)) - 1;
#line 785
  time___0.tm_mday = ((int )*(cp + 7) - 48) * 10 + ((int )*(cp + 8) - 48);
#line 786
  time___0.tm_hour = ((int )*(cp + 9) - 48) * 10 + ((int )*(cp + 10) - 48);
#line 787
  time___0.tm_min = ((int )*(cp + 11) - 48) * 10 + ((int )*(cp + 12) - 48);
#line 788
  time___0.tm_sec = ((int )*(cp + 13) - 48) * 10 + ((int )*(cp + 14) - 48);
#line 789
  time___0.tm_isdst = -1;
#line 794
  converted = mktime(& time___0);
  }
#line 795
  if (converted != -1L) {
    {
#line 796
    tmp___1 = localtime((time_t const   *)(& converted));
    }
#line 796
    return (tmp___1);
  }
#line 798
  return (& time___0);
}
}
#line 809 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
char *GSgetModDate(GopherObj *gs ) 
{ 
  char dateBuf[256] ;
  char *datetime ;
  struct tm *modTime ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
#line 816
  if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
#line 817
    return ((char *)((void *)0));
  } else {
#line 816
    if (((gs->gplus)->ModDate)->len < 0) {
#line 816
      tmp = (char *)((void *)0);
    } else {
#line 816
      tmp = ((gs->gplus)->ModDate)->data;
    }
#line 816
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 817
      return ((char *)((void *)0));
    }
  }
  {
#line 819
  modTime = GSgetModDateTM(gs);
  }
#line 821
  if ((unsigned long )modTime != (unsigned long )((void *)0)) {
    {
#line 821
    tmp___1 = strftime((char */* __restrict  */)(dateBuf), sizeof(dateBuf) - 16UL,
                       (char const   */* __restrict  */)"%c ", (struct tm  const  */* __restrict  */)modTime);
    }
#line 821
    if (tmp___1) {
#line 824
      if (((gs->gplus)->ModDate)->len < 0) {
#line 824
        tmp___0 = (char *)((void *)0);
      } else {
#line 824
        tmp___0 = ((gs->gplus)->ModDate)->data;
      }
      {
#line 824
      datetime = strchr((char const   *)tmp___0, '<');
      }
#line 825
      if ((unsigned long )datetime != (unsigned long )((void *)0)) {
        {
#line 826
        strncat((char */* __restrict  */)(dateBuf), (char const   */* __restrict  */)datetime,
                (size_t )16);
        }
      }
      {
#line 828
      STRset((gs->gplus)->ModDate, dateBuf);
      }
    }
  }
#line 831
  if (((gs->gplus)->ModDate)->len < 0) {
#line 831
    tmp___2 = (char *)((void *)0);
  } else {
#line 831
    tmp___2 = ((gs->gplus)->ModDate)->data;
  }
#line 831
  return (tmp___2);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSsetAdmin(GopherObj *gs , char *admin ) 
{ 


  {
#line 840
  if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
    {
#line 841
    GSplusnew(gs);
    }
  }
  {
#line 843
  STRset((gs->gplus)->Admin, admin);
  }
#line 844
  return;
}
}
#line 848 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSsetModDate(GopherObj *gs , char *str ) 
{ 


  {
#line 851
  if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
    {
#line 851
    GSplusnew(gs);
    }
  }
  {
#line 852
  STRset((gs->gplus)->ModDate, str);
  }
#line 853
  return;
}
}
#line 859 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSaddView(GopherObj *gs , char *view , char *language , int estsize ) 
{ 
  char tmpstr[64] ;
  VIewobj *temp ;

  {
#line 865
  if (estsize > 960) {
    {
#line 866
    snprintf((char */* __restrict  */)(tmpstr), sizeof(tmpstr), (char const   */* __restrict  */)"%dk",
             (estsize + 512) / 1024);
    }
  } else {
    {
#line 868
    snprintf((char */* __restrict  */)(tmpstr), sizeof(tmpstr), (char const   */* __restrict  */)".%dk",
             ((estsize + 64) * 10) / 1024);
    }
  }
  {
#line 870
  temp = VInew();
#line 872
  STRset(temp->Type, view);
#line 873
  STRset(temp->Lang, language);
#line 874
  STRset(temp->Size, tmpstr);
#line 876
  DApush((gs->gplus)->Views, (char *)temp);
#line 877
  VIdestroy(temp);
  }
#line 878
  return;
}
}
#line 880 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSdelTopView(GopherObj *gs ) 
{ 


  {
  {
#line 884
  DApop((gs->gplus)->Views);
  }
#line 885
  return;
}
}
#line 887 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSaddBlock(GopherObj *gs , char *Blockname , char *file ) 
{ 
  Blockobj *bl ;

  {
  {
#line 892
  bl = BLnew();
#line 893
  STRset(bl->Blockname, Blockname);
#line 894
  BLsetFile(bl, file);
  }
#line 896
  if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
    {
#line 897
    GSplusnew(gs);
    }
  }
  {
#line 899
  DApush((gs->gplus)->OtherBlocks, (char *)bl);
#line 901
  BLdestroy(bl);
  }
#line 902
  return;
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
static char *nullword  =    (char *)"(NULL)";
#line 912 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GStoNet(GopherObj *gs , int sockfd , GSformat fmt , char *ticket ) 
{ 
  char buf[1024] ;
  int i ;
  Blockobj *bl ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char url[256] ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  Blockobj *bl___0 ;

  {
#line 919
  if ((unsigned long )ticket == (unsigned long )((void *)0)) {
#line 920
    ticket = (char *)"";
  }
#line 922
  buf[0] = gs->sFileType;
#line 924
  if ((int )buf[0] == 0) {
#line 925
    buf[0] = (char )'3';
  }
#line 927
  if (fmt == 0) {
#line 928
    i = 0;
    {
#line 928
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 928
      tmp___1 = GSgetNumBlocks(gs);
      }
#line 928
      if (! (i < tmp___1)) {
#line 928
        goto while_break;
      }
      {
#line 929
      bl = GSgetBlock(gs, i);
      }
#line 930
      if ((bl->Blockname)->len < 0) {
#line 930
        tmp = (char *)((void *)0);
      } else {
#line 930
        tmp = (bl->Blockname)->data;
      }
      {
#line 930
      tmp___0 = strcasecmp((char const   *)tmp, "ONLYHTML");
      }
#line 930
      if (tmp___0 == 0) {
#line 931
        return;
      }
#line 928
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 933
    if ((gs->Host)->len < 0) {
#line 933
      tmp___5 = (char *)((void *)0);
    } else {
#line 933
      tmp___5 = (gs->Host)->data;
    }
#line 933
    if (tmp___5) {
#line 933
      if ((gs->Host)->len < 0) {
#line 933
        tmp___3 = (char *)((void *)0);
      } else {
#line 933
        tmp___3 = (gs->Host)->data;
      }
#line 933
      tmp___4 = tmp___3;
    } else {
#line 933
      tmp___4 = nullword;
    }
#line 933
    if ((gs->Selstr)->len < 0) {
#line 933
      tmp___9 = (char *)((void *)0);
    } else {
#line 933
      tmp___9 = (gs->Selstr)->data;
    }
#line 933
    if (tmp___9) {
#line 933
      if ((gs->Selstr)->len < 0) {
#line 933
        tmp___7 = (char *)((void *)0);
      } else {
#line 933
        tmp___7 = (gs->Selstr)->data;
      }
#line 933
      tmp___8 = tmp___7;
    } else {
#line 933
      tmp___8 = nullword;
    }
#line 933
    if (ticket) {
#line 933
      tmp___10 = ticket;
    } else {
#line 933
      tmp___10 = nullword;
    }
#line 933
    if ((gs->Title)->len < 0) {
#line 933
      tmp___14 = (char *)((void *)0);
    } else {
#line 933
      tmp___14 = (gs->Title)->data;
    }
#line 933
    if (tmp___14) {
#line 933
      if ((gs->Title)->len < 0) {
#line 933
        tmp___12 = (char *)((void *)0);
      } else {
#line 933
        tmp___12 = (gs->Title)->data;
      }
#line 933
      tmp___13 = tmp___12;
    } else {
#line 933
      tmp___13 = nullword;
    }
    {
#line 933
    snprintf((char */* __restrict  */)(buf + 1), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%s\t%s%s\t%s\t%d",
             tmp___13, tmp___10, tmp___8, tmp___4, gs->iPort);
    }
#line 942
    if (gs->isask) {
      {
#line 943
      strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"\t?\r\n");
      }
    } else
#line 944
    if (gs->isgplus) {
      {
#line 945
      strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"\t+\r\n");
      }
    } else {
      {
#line 947
      strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"\r\n");
      }
    }
    {
#line 949
    writestring(sockfd, buf);
    }
  } else
#line 952
  if (! (fmt == 1)) {
#line 955
    if (fmt == 2) {
#line 957
      i = 0;
      {
#line 957
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 957
        tmp___17 = GSgetNumBlocks(gs);
        }
#line 957
        if (! (i < tmp___17)) {
#line 957
          goto while_break___0;
        }
        {
#line 958
        bl = GSgetBlock(gs, i);
        }
#line 959
        if ((bl->Blockname)->len < 0) {
#line 959
          tmp___15 = (char *)((void *)0);
        } else {
#line 959
          tmp___15 = (bl->Blockname)->data;
        }
        {
#line 959
        tmp___16 = strcmp((char const   *)tmp___15, "NOHTML");
        }
#line 959
        if (tmp___16 == 0) {
#line 960
          return;
        }
#line 957
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 963
      if ((int )gs->sFileType == 105) {
        {
#line 964
        writestring(sockfd, (char *)"<DT>");
        }
#line 965
        if ((gs->Title)->len < 0) {
#line 965
          tmp___19 = (char *)((void *)0);
        } else {
#line 965
          tmp___19 = (gs->Title)->data;
        }
        {
#line 965
        tmp___20 = strncmp((char const   *)tmp___19, "----------------", (size_t )16);
        }
#line 965
        if (tmp___20 == 0) {
          {
#line 966
          writestring(sockfd, (char *)"<HR>");
          }
        } else {
#line 968
          if ((gs->Title)->len < 0) {
#line 968
            tmp___18 = (char *)((void *)0);
          } else {
#line 968
            tmp___18 = (gs->Title)->data;
          }
          {
#line 968
          writestring(sockfd, tmp___18);
          }
        }
        {
#line 969
        writestring(sockfd, (char *)"<BR>");
        }
#line 970
        return;
      }
      {
#line 972
      GStoNetURL(gs, url, ticket);
      }
#line 973
      if ((int )url[0] == 0) {
#line 974
        return;
      }
#line 975
      if ((gs->Title)->len < 0) {
#line 975
        tmp___21 = (char *)((void *)0);
      } else {
#line 975
        tmp___21 = (gs->Title)->data;
      }
      {
#line 975
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"<A HREF=\"%s\">%s</A>\r\n",
               url, tmp___21);
#line 977
      writestring(sockfd, buf);
      }
#line 979
      if ((unsigned long )gs->gplus != (unsigned long )((void *)0)) {
        {
#line 982
        bl___0 = GSfindBlock(gs, (char *)"ABSTRACT");
        }
#line 983
        if ((unsigned long )bl___0 != (unsigned long )((void *)0)) {
          {
#line 984
          writestring(sockfd, (char *)"<DD>");
#line 985
          BLtoNet(bl___0, sockfd, 0);
#line 986
          writestring(sockfd, (char *)"\r\n");
          }
        }
      }
#line 990
      if (gs->weight != 0) {
        {
#line 991
        snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"<DD>Score: %d\r\n",
                 gs->weight);
#line 993
        writestring(sockfd, buf);
        }
      }
    }
  }
#line 997
  return;
}
}
#line 1006 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSplustoNet(GopherObj *gs , int sockfd , char **filter , char *ticket ) 
{ 
  int i ;
  char tmpstr[256] ;
  boolean sendviews ;
  boolean sendadmin ;
  boolean sendothers ;
  Blockobj *tmp___0 ;
  char *tmp___1 ;
  Blockobj *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  VIewobj *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  Blockobj *tmp___20 ;
  int tmp___21 ;

  {
#line 1013
  i = 0;
  {
#line 1013
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1013
    tmp___4 = GSgetNumBlocks(gs);
    }
#line 1013
    if (! (i < tmp___4)) {
#line 1013
      goto while_break;
    }
    {
#line 1014
    tmp___2 = GSgetBlock(gs, i);
    }
#line 1014
    if ((tmp___2->Blockname)->len < 0) {
#line 1014
      tmp___1 = (char *)((void *)0);
    } else {
      {
#line 1014
      tmp___0 = GSgetBlock(gs, i);
#line 1014
      tmp___1 = (tmp___0->Blockname)->data;
      }
    }
    {
#line 1014
    tmp___3 = strcmp((char const   *)tmp___1, "ONLYHTML");
    }
#line 1014
    if (tmp___3 == 0) {
#line 1015
      return;
    }
#line 1013
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1018
  if ((unsigned long )filter == (unsigned long )((void *)0)) {
#line 1019
    sendothers = 1;
#line 1019
    sendadmin = sendothers;
#line 1019
    sendviews = sendadmin;
  } else {
#line 1021
    sendothers = 0;
#line 1021
    sendadmin = sendothers;
#line 1021
    sendviews = sendadmin;
#line 1022
    i = 0;
    {
#line 1022
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1022
      if (! ((unsigned long )*(filter + i) != (unsigned long )((void *)0))) {
#line 1022
        goto while_break___0;
      }
      {
#line 1023
      tmp___6 = strcasecmp((char const   *)*(filter + i), "VIEWS");
      }
#line 1023
      if (tmp___6 == 0) {
#line 1024
        sendviews = 1;
      } else {
        {
#line 1025
        tmp___5 = strcasecmp((char const   *)*(filter + i), "ADMIN");
        }
#line 1025
        if (tmp___5 == 0) {
#line 1026
          sendadmin = 1;
        } else {
#line 1028
          sendothers = 1;
        }
      }
#line 1022
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1034
  writestring(sockfd, (char *)"+INFO: ");
#line 1035
  GStoNet(gs, sockfd, 0, ticket);
#line 1040
  tmp___10 = GSgetURL(gs, ticket);
  }
#line 1040
  if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
    {
#line 1041
    tmp___8 = GSgetURL(gs, ticket);
#line 1041
    tmp___9 = strncmp((char const   *)tmp___8, "gopher:", (size_t )7);
    }
#line 1041
    if (tmp___9 != 0) {
      {
#line 1042
      writestring(sockfd, (char *)"+URL:\r\n ");
#line 1043
      tmp___7 = GSgetURL(gs, ticket);
#line 1043
      writestring(sockfd, tmp___7);
#line 1044
      writestring(sockfd, (char *)"\r\n");
      }
    }
  }
#line 1049
  if ((unsigned long )gs->gplus != (unsigned long )((void *)0)) {
#line 1052
    if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
#line 1052
      tmp___15 = (char *)((void *)0);
    } else {
#line 1052
      if (((gs->gplus)->Admin)->len < 0) {
#line 1052
        tmp___14 = (char *)((void *)0);
      } else {
#line 1052
        tmp___14 = ((gs->gplus)->Admin)->data;
      }
#line 1052
      tmp___15 = tmp___14;
    }
#line 1052
    if ((unsigned long )tmp___15 != (unsigned long )((void *)0)) {
      {
#line 1052
      tmp___16 = GSgetModDate(gs);
      }
#line 1052
      if ((unsigned long )tmp___16 != (unsigned long )((void *)0)) {
#line 1052
        if (sendadmin) {
          {
#line 1053
          writestring(sockfd, (char *)"+ADMIN:\r\n Admin: ");
          }
#line 1054
          if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
#line 1054
            tmp___12 = (char *)((void *)0);
          } else {
#line 1054
            if (((gs->gplus)->Admin)->len < 0) {
#line 1054
              tmp___11 = (char *)((void *)0);
            } else {
#line 1054
              tmp___11 = ((gs->gplus)->Admin)->data;
            }
#line 1054
            tmp___12 = tmp___11;
          }
          {
#line 1054
          writestring(sockfd, tmp___12);
#line 1055
          writestring(sockfd, (char *)"\r\n Mod-Date: ");
#line 1056
          tmp___13 = GSgetModDate(gs);
#line 1056
          writestring(sockfd, tmp___13);
          }
#line 1057
          if (gs->ttl > -1) {
            {
#line 1058
            writestring(sockfd, (char *)"\r\n TTL: ");
#line 1059
            snprintf((char */* __restrict  */)(tmpstr), sizeof(tmpstr), (char const   */* __restrict  */)"%d",
                     gs->ttl);
#line 1060
            writestring(sockfd, tmpstr);
            }
          }
          {
#line 1062
          writestring(sockfd, (char *)"\r\n");
          }
        }
      }
    }
    {
#line 1064
    tmp___19 = GSgetNumViews(gs);
    }
#line 1064
    if (tmp___19 > 0) {
#line 1064
      if (sendviews) {
        {
#line 1065
        writestring(sockfd, (char *)"+VIEWS:\r\n");
#line 1066
        i = 0;
        }
        {
#line 1066
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1066
          tmp___18 = GSgetNumViews(gs);
          }
#line 1066
          if (! (i < tmp___18)) {
#line 1066
            goto while_break___1;
          }
          {
#line 1067
          tmp___17 = GSgetView(gs, i);
#line 1067
          VItoLine(tmp___17, tmpstr);
#line 1068
          writestring(sockfd, tmpstr);
#line 1069
          writestring(sockfd, (char *)"\r\n");
#line 1066
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 1073
    if (sendothers) {
#line 1075
      i = 0;
      {
#line 1075
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1075
        tmp___21 = GSgetNumBlocks(gs);
        }
#line 1075
        if (! (i < tmp___21)) {
#line 1075
          goto while_break___2;
        }
        {
#line 1076
        tmp___20 = GSgetBlock(gs, i);
#line 1076
        BLtoNet(tmp___20, sockfd, 1);
#line 1075
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 1079
  return;
}
}
#line 1091 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
int GSplusfromNet(GopherObj *gs , int fd ) 
{ 
  int result ;
  int readok ;
  int i ;
  boolean nextinfo ;
  char plusfield ;
  Blockobj *bl ;
  char inputline___0[512] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int saveAdminBlock ;
  char *cp ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *cp___0 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 1095
  nextinfo = 0;
#line 1100
  if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
    {
#line 1101
    GSplusnew(gs);
    }
  }
  {
#line 1103
  bl = BLnew();
#line 1106
  readok = GSfromNet(gs, fd);
  }
#line 1108
  if (readok == -2) {
#line 1109
    return (-2);
  }
  {
#line 1117
  result = readrecvbuf(fd, & plusfield, 1);
  }
#line 1117
  if (result < 0) {
#line 1118
    return (-2);
  }
  {
#line 1120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1120
    if (! (! nextinfo)) {
#line 1120
      goto while_break;
    }
#line 1121
    if (result == 0) {
      {
#line 1122
      BLdestroy(bl);
      }
#line 1124
      if (readok == -1) {
#line 1125
        return (-1);
      } else {
#line 1127
        return (0);
      }
    }
    {
#line 1131
    if ((int )plusfield == 46) {
#line 1131
      goto case_46;
    }
#line 1136
    if ((int )plusfield == 43) {
#line 1136
      goto case_43;
    }
#line 1202
    goto switch_default;
    case_46: /* CIL Label */ 
    {
#line 1132
    readline(fd, inputline___0, (int )sizeof(inputline___0));
#line 1133
    result = 0;
    }
#line 1134
    goto switch_break;
    case_43: /* CIL Label */ 
    {
#line 1139
    tmp = readtoken(fd, inputline___0, (int )sizeof(inputline___0), (char )':');
    }
#line 1139
    if (tmp <= 0) {
#line 1140
      return (-2);
    }
    {
#line 1142
    tmp___1 = strcasecmp((char const   *)(inputline___0), "INFO");
    }
#line 1142
    if (tmp___1 == 0) {
      {
#line 1144
      tmp___0 = readrecvbuf(fd, & plusfield, 1);
      }
#line 1144
      if (tmp___0 <= 0) {
#line 1145
        return (-2);
      }
      {
#line 1146
      BLdestroy(bl);
      }
#line 1147
      if (readok == -1) {
#line 1148
        return (-1);
      } else {
#line 1150
        return (1);
      }
    }
    {
#line 1155
    BLinit(bl);
#line 1156
    result = BLfromNet(bl, fd, inputline___0);
    }
#line 1156
    if (result < 0) {
      {
#line 1158
      BLdestroy(bl);
      }
#line 1159
      return (-2);
    } else
#line 1161
    if (result == 0) {
#line 1162
      nextinfo = 1;
    } else {
#line 1164
      nextinfo = 0;
    }
#line 1168
    if ((bl->Blockname)->len < 0) {
#line 1168
      tmp___10 = (char *)((void *)0);
    } else {
#line 1168
      tmp___10 = (bl->Blockname)->data;
    }
    {
#line 1168
    tmp___11 = strcasecmp((char const   *)tmp___10, "VIEWS");
    }
#line 1168
    if (tmp___11 == 0) {
      {
#line 1169
      VIAfromBL((gs->gplus)->Views, bl);
      }
    } else {
#line 1170
      if ((bl->Blockname)->len < 0) {
#line 1170
        tmp___8 = (char *)((void *)0);
      } else {
#line 1170
        tmp___8 = (bl->Blockname)->data;
      }
      {
#line 1170
      tmp___9 = strcasecmp((char const   *)tmp___8, "ADMIN");
      }
#line 1170
      if (tmp___9 == 0) {
#line 1171
        saveAdminBlock = 0;
#line 1173
        i = 0;
        {
#line 1173
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1173
          tmp___5 = BLgetNumLines(bl);
          }
#line 1173
          if (! (i < tmp___5)) {
#line 1173
            goto while_break___0;
          }
          {
#line 1176
          cp = BLgetLine(bl, i);
#line 1178
          tmp___4 = strncasecmp((char const   *)cp, "Admin: ", (size_t )7);
          }
#line 1178
          if (tmp___4 == 0) {
            {
#line 1179
            GSsetAdmin(gs, cp + 7);
            }
          } else {
            {
#line 1180
            tmp___3 = strncasecmp((char const   *)cp, "Mod-Date: ", (size_t )10);
            }
#line 1180
            if (tmp___3 == 0) {
              {
#line 1181
              GSsetModDate(gs, cp + 10);
              }
            } else {
              {
#line 1182
              tmp___2 = strncasecmp((char const   *)cp, "TTL: ", (size_t )5);
              }
#line 1182
              if (tmp___2 == 0) {
                {
#line 1183
                gs->ttl = atoi((char const   *)(cp + 5));
                }
              } else {
#line 1185
                saveAdminBlock = 1;
              }
            }
          }
#line 1173
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1187
        if (saveAdminBlock) {
          {
#line 1188
          DApush((gs->gplus)->OtherBlocks, (char *)bl);
          }
        }
      } else {
#line 1190
        if ((bl->Blockname)->len < 0) {
#line 1190
          tmp___6 = (char *)((void *)0);
        } else {
#line 1190
          tmp___6 = (bl->Blockname)->data;
        }
        {
#line 1190
        tmp___7 = strcasecmp((char const   *)tmp___6, "URL");
        }
#line 1190
        if (tmp___7 == 0) {
          {
#line 1193
          cp___0 = BLgetLine(bl, 0);
          }
#line 1194
          if ((unsigned long )cp___0 != (unsigned long )((void *)0)) {
            {
#line 1195
            GSsetURL(gs, cp___0);
            }
          }
        } else {
          {
#line 1198
          DApush((gs->gplus)->OtherBlocks, (char *)bl);
          }
        }
      }
    }
#line 1200
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1203
    return (-2);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1209
  BLdestroy(bl);
  }
#line 1211
  return (0);
}
}
#line 1252 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
int GSfromNet(GopherObj *gs , int sockfd ) 
{ 
  char foo[1024] ;
  char *cp ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1257
  tmp = readtoken(sockfd, foo, 1024, (char )'\t');
  }
#line 1257
  if (tmp <= 0) {
#line 1259
    return (-2);
  }
#line 1262
  gs->sFileType = foo[0];
  {
#line 1285
  if ((int )gs->sFileType == 33) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 59) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 105) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 73) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 77) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 84) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 104) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 103) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 57) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 115) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 56) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 55) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 50) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 53) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 52) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 49) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 48) {
#line 1285
    goto case_33;
  }
#line 1285
  if ((int )gs->sFileType == 80) {
#line 1285
    goto case_33;
  }
#line 1287
  if ((int )gs->sFileType == 51) {
#line 1287
    goto case_51;
  }
#line 1298
  if ((int )gs->sFileType == 46) {
#line 1298
    goto case_46;
  }
#line 1301
  goto switch_default;
  case_33: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_80: /* CIL Label */ 
#line 1286
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 1288
  STRset(gs->Selstr, (char *)"");
#line 1289
  STRset(gs->Host, (char *)"");
#line 1290
  gs->isgplus = 0;
#line 1291
  ZapCRLF(foo + 1);
#line 1292
  tmp___0 = strlen((char const   *)(foo + 1));
#line 1292
  cp = foo + tmp___0;
  }
  {
#line 1293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1293
    if ((int )*cp == 46) {
#line 1293
      if (! ((int )*(cp - 1) == 10)) {
#line 1293
        if (! ((int )*(cp - 1) == 13)) {
#line 1293
          goto while_break;
        }
      }
    } else {
#line 1293
      goto while_break;
    }
    {
#line 1294
    *cp = (char )'\000';
#line 1295
    ZapCRLF(foo + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1297
  goto switch_break;
  case_46: /* CIL Label */ 
#line 1299
  if ((int )foo[1] == 13) {
#line 1299
    if ((int )foo[2] == 10) {
#line 1300
      return (1);
    }
  }
  switch_default: /* CIL Label */ 
  {
#line 1303
  readline(sockfd, foo, 1024);
  }
#line 1304
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 1308
  cp = foo + 1;
  {
#line 1309
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1309
    if (! ((int )*cp == 10)) {
#line 1309
      if (! ((int )*cp == 13)) {
#line 1309
        goto while_break___0;
      }
    }
#line 1310
    cp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1311
  STRset(gs->Title, cp);
#line 1314
  tmp___2 = readtoken(sockfd, foo, 1024, (char )'\t');
  }
#line 1314
  if (tmp___2 <= 0) {
#line 1315
    if ((int )gs->sFileType == 51) {
#line 1315
      tmp___1 = 0;
    } else {
#line 1315
      tmp___1 = -2;
    }
#line 1315
    return (tmp___1);
  }
  {
#line 1316
  STRset(gs->Selstr, foo);
#line 1319
  tmp___4 = readtoken(sockfd, foo, 1024, (char )'\t');
  }
#line 1319
  if (tmp___4 <= 0) {
#line 1320
    if ((int )gs->sFileType == 51) {
#line 1320
      tmp___3 = 0;
    } else {
#line 1320
      tmp___3 = -2;
    }
#line 1320
    return (tmp___3);
  }
  {
#line 1322
  STRset(gs->Host, foo);
#line 1324
  tmp___6 = readline(sockfd, foo, 1024);
  }
#line 1324
  if (tmp___6 <= 0) {
#line 1325
    if ((int )gs->sFileType == 51) {
#line 1325
      tmp___5 = 0;
    } else {
#line 1325
      tmp___5 = -2;
    }
#line 1325
    return (tmp___5);
  }
  {
#line 1327
  gs->iPort = 0;
#line 1330
  cp = strchr((char const   *)(foo), '\t');
  }
#line 1330
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 1331
    *cp = (char )'\000';
    {
#line 1333
    if ((int )*(cp + 1) == 63) {
#line 1333
      goto case_63;
    }
#line 1335
    if ((int )*(cp + 1) == 43) {
#line 1335
      goto case_43;
    }
#line 1332
    goto switch_break___0;
    case_63: /* CIL Label */ 
#line 1334
    gs->isask = 1;
    case_43: /* CIL Label */ 
#line 1336
    gs->isgplus = 1;
#line 1337
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1341
  gs->iPort = atoi((char const   *)(foo));
  }
#line 1344
  return (0);
}
}
#line 1350 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GScpy(GopherObj *dest , GopherObj *orig ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 1353
  dest->sFileType = orig->sFileType;
#line 1354
  dest->iPort = orig->iPort;
#line 1355
  dest->Itemnum = orig->Itemnum;
#line 1357
  if ((orig->Title)->len < 0) {
#line 1357
    tmp = (char *)((void *)0);
  } else {
#line 1357
    tmp = (orig->Title)->data;
  }
  {
#line 1357
  STRset(dest->Title, tmp);
  }
#line 1358
  if ((orig->Selstr)->len < 0) {
#line 1358
    tmp___0 = (char *)((void *)0);
  } else {
#line 1358
    tmp___0 = (orig->Selstr)->data;
  }
  {
#line 1358
  STRset(dest->Selstr, tmp___0);
  }
#line 1359
  if ((orig->Host)->len < 0) {
#line 1359
    tmp___1 = (char *)((void *)0);
  } else {
#line 1359
    tmp___1 = (orig->Host)->data;
  }
  {
#line 1359
  STRset(dest->Host, tmp___1);
#line 1361
  dest->isgplus = orig->isgplus;
#line 1362
  dest->isask = orig->isask;
  }
#line 1363
  if ((unsigned long )orig->url != (unsigned long )((void *)0)) {
    {
#line 1364
    tmp___2 = GSgetURL(orig, (char *)"");
#line 1364
    GSsetURL(dest, tmp___2);
    }
  }
  {
#line 1365
  dest->ttl = orig->ttl;
#line 1367
  STRinit(dest->Localfile);
#line 1368
  STRinit(dest->Localview);
#line 1369
  GSpluscpy(dest, orig);
  }
#line 1371
  return;
}
}
#line 1373 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSpluscpy(GopherObj *dest , GopherObj *orig ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char **tmp___2 ;

  {
#line 1376
  if ((unsigned long )orig->gplus != (unsigned long )((void *)0)) {
#line 1377
    if (! ((unsigned long )dest->gplus != (unsigned long )((void *)0))) {
      {
#line 1378
      GSplusnew(dest);
      }
    }
#line 1379
    if ((unsigned long )orig->gplus == (unsigned long )((void *)0)) {
#line 1379
      tmp___0 = (char *)((void *)0);
    } else {
#line 1379
      if (((orig->gplus)->Admin)->len < 0) {
#line 1379
        tmp = (char *)((void *)0);
      } else {
#line 1379
        tmp = ((orig->gplus)->Admin)->data;
      }
#line 1379
      tmp___0 = tmp;
    }
    {
#line 1379
    GSsetAdmin(dest, tmp___0);
#line 1380
    tmp___1 = GSgetModDate(orig);
#line 1380
    GSsetModDate(dest, tmp___1);
#line 1381
    DAcpy((dest->gplus)->Views, (orig->gplus)->Views);
#line 1382
    DAcpy((dest->gplus)->OtherBlocks, (orig->gplus)->OtherBlocks);
    }
#line 1383
    if ((unsigned long )orig->gplus != (unsigned long )((void *)0)) {
#line 1383
      tmp___2 = (orig->gplus)->Askdata;
    } else {
#line 1383
      tmp___2 = (char **)((void *)0);
    }
    {
#line 1383
    GSsetAskdata(dest, tmp___2);
    }
  }
#line 1385
  return;
}
}
#line 1390 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSmerge(GopherObj *gs , GopherObj *overlay ) 
{ 
  char *tempstr ;
  char oldFileType ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *vs ;
  char vsize[64] ;
  char *vc ;
  char vcomments[256] ;
  VIewobj *temp ;
  VIewobj *tmp___11 ;
  char *tmp___12 ;
  VIewobj *tmp___13 ;
  VIewobj *tmp___15 ;
  char *tmp___16 ;
  VIewobj *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
#line 1399
  if ((overlay->Host)->len < 0) {
#line 1399
    tmp___20 = (char *)((void *)0);
  } else {
#line 1399
    tmp___20 = (overlay->Host)->data;
  }
#line 1399
  if ((unsigned long )tmp___20 != (unsigned long )((void *)0)) {
#line 1400
    oldFileType = gs->sFileType;
#line 1402
    if ((int )overlay->sFileType != 0) {
#line 1405
      gs->sFileType = overlay->sFileType;
#line 1406
      if ((gs->Selstr)->len < 0) {
#line 1406
        tmp = (char *)((void *)0);
      } else {
#line 1406
        tmp = (gs->Selstr)->data;
      }
#line 1406
      tempstr = tmp;
#line 1408
      if ((int )*tempstr != 49) {
        {
#line 1409
        *(tempstr + 0) = overlay->sFileType;
#line 1410
        STRset(gs->Selstr, tempstr);
        }
      }
#line 1412
      if (overlay->isask) {
#line 1412
        if ((int )overlay->sFileType == 49) {
          {
#line 1413
          GSaddView(gs, (char *)"application/gopher+-menu", (char *)"En_US", 0);
          }
        }
      }
    }
#line 1419
    if ((overlay->Title)->len < 0) {
#line 1419
      tmp___1 = (char *)((void *)0);
    } else {
#line 1419
      tmp___1 = (overlay->Title)->data;
    }
#line 1419
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 1420
      if ((overlay->Title)->len < 0) {
#line 1420
        tmp___0 = (char *)((void *)0);
      } else {
#line 1420
        tmp___0 = (overlay->Title)->data;
      }
      {
#line 1420
      STRset(gs->Title, tmp___0);
      }
    }
#line 1423
    if ((overlay->Host)->len < 0) {
#line 1423
      tmp___3 = (char *)((void *)0);
    } else {
#line 1423
      tmp___3 = (overlay->Host)->data;
    }
#line 1423
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 1424
      if ((overlay->Host)->len < 0) {
#line 1424
        tmp___2 = (char *)((void *)0);
      } else {
#line 1424
        tmp___2 = (overlay->Host)->data;
      }
      {
#line 1424
      STRset(gs->Host, tmp___2);
      }
    }
#line 1425
    if (overlay->iPort != 0) {
#line 1426
      gs->iPort = overlay->iPort;
    }
#line 1427
    if (overlay->Itemnum != -1) {
#line 1428
      gs->Itemnum = overlay->Itemnum;
    }
#line 1429
    if (overlay->weight != 0) {
#line 1430
      gs->weight = overlay->weight;
    }
#line 1432
    if ((unsigned long )overlay->gplus != (unsigned long )((void *)0)) {
#line 1433
      if (! ((unsigned long )gs->gplus != (unsigned long )((void *)0))) {
        {
#line 1434
        GSplusnew(gs);
        }
      }
      {
#line 1435
      DAcpy((gs->gplus)->OtherBlocks, (overlay->gplus)->OtherBlocks);
      }
    }
#line 1439
    if ((unsigned long )overlay->gplus == (unsigned long )((void *)0)) {
#line 1439
      tmp___7 = (char *)((void *)0);
    } else {
#line 1439
      if (((overlay->gplus)->Admin)->len < 0) {
#line 1439
        tmp___6 = (char *)((void *)0);
      } else {
#line 1439
        tmp___6 = ((overlay->gplus)->Admin)->data;
      }
#line 1439
      tmp___7 = tmp___6;
    }
#line 1439
    if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 1440
      if ((unsigned long )overlay->gplus == (unsigned long )((void *)0)) {
#line 1440
        tmp___5 = (char *)((void *)0);
      } else {
#line 1440
        if (((overlay->gplus)->Admin)->len < 0) {
#line 1440
          tmp___4 = (char *)((void *)0);
        } else {
#line 1440
          tmp___4 = ((overlay->gplus)->Admin)->data;
        }
#line 1440
        tmp___5 = tmp___4;
      }
      {
#line 1440
      GSsetAdmin(gs, tmp___5);
      }
    }
    {
#line 1443
    tmp___9 = GSgetModDate(overlay);
    }
#line 1443
    if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
      {
#line 1444
      tmp___8 = GSgetModDate(overlay);
#line 1444
      GSsetModDate(gs, tmp___8);
      }
    }
    {
#line 1445
    tmp___18 = GSgetNumViews(gs);
    }
#line 1445
    if (tmp___18) {
#line 1445
      if ((int )oldFileType == 48) {
#line 1445
        if ((int )gs->sFileType != 48) {
          {
#line 1449
          tmp___13 = GSgetView(gs, 0);
          }
#line 1449
          if ((tmp___13->Size)->len < 0) {
#line 1449
            tmp___12 = (char *)((void *)0);
          } else {
            {
#line 1449
            tmp___11 = GSgetView(gs, 0);
#line 1449
            tmp___12 = (tmp___11->Size)->data;
            }
          }
#line 1449
          vs = tmp___12;
#line 1449
          if (vs) {
            {
#line 1450
            strcpy((char */* __restrict  */)(vsize), (char const   */* __restrict  */)vs);
            }
          }
          {
#line 1451
          tmp___17 = GSgetView(gs, 0);
          }
#line 1451
          if ((tmp___17->comments)->len < 0) {
#line 1451
            tmp___16 = (char *)((void *)0);
          } else {
            {
#line 1451
            tmp___15 = GSgetView(gs, 0);
#line 1451
            tmp___16 = (tmp___15->comments)->data;
            }
          }
#line 1451
          vc = tmp___16;
#line 1451
          if (vc) {
            {
#line 1452
            strcpy((char */* __restrict  */)(vcomments), (char const   */* __restrict  */)vc);
            }
          }
          {
#line 1453
          DAdestroy((gs->gplus)->Views);
#line 1454
          (gs->gplus)->Views = DAnew(10, & VInew, & VIinit, & VIdestroy, & VIcpy);
#line 1455
          temp = VInew();
#line 1456
          STRset(temp->Type, (char *)"");
#line 1457
          STRset(temp->Lang, (char *)"");
#line 1458
          STRset(temp->Size, vsize);
#line 1459
          STRset(temp->comments, vcomments);
#line 1460
          DApush((gs->gplus)->Views, (char *)temp);
#line 1461
          VIdestroy(temp);
          }
        }
      }
    }
    {
#line 1463
    tmp___19 = GSgetNumViews(overlay);
    }
#line 1463
    if (tmp___19) {
      {
#line 1464
      DAcpy((gs->gplus)->Views, (overlay->gplus)->Views);
      }
    }
  }
#line 1468
  return;
}
}
#line 1503 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
int GSconnect(GopherObj *gs ) 
{ 
  int sockfd ;
  char *tmp ;

  {
#line 1511
  if ((gs->Host)->len < 0) {
#line 1511
    tmp = (char *)((void *)0);
  } else {
#line 1511
    tmp = (gs->Host)->data;
  }
  {
#line 1511
  sockfd = SOCKconnect(tmp, gs->iPort);
  }
#line 1513
  return (sockfd);
}
}
#line 1525 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GStransmit(GopherObj *gs , int sockfd , char *search , char *command , char *view ) 
{ 
  char *cp ;
  char **ask ;
  char **tmp ;
  int i ;
  char *tmp___0 ;

  {
#line 1529
  if ((unsigned long )gs->gplus != (unsigned long )((void *)0)) {
#line 1529
    tmp = (gs->gplus)->Askdata;
  } else {
#line 1529
    tmp = (char **)((void *)0);
  }
#line 1529
  ask = tmp;
#line 1532
  if ((gs->Selstr)->len < 0) {
#line 1532
    tmp___0 = (char *)((void *)0);
  } else {
#line 1532
    tmp___0 = (gs->Selstr)->data;
  }
  {
#line 1532
  writestring(sockfd, tmp___0);
  }
#line 1533
  if ((unsigned long )search != (unsigned long )((void *)0)) {
    {
#line 1534
    writestring(sockfd, (char *)"\t");
#line 1535
    writestring(sockfd, search);
    }
  }
#line 1539
  if (! gs->isgplus) {
    {
#line 1540
    writestring(sockfd, (char *)"\r\n");
    }
#line 1541
    return;
  }
#line 1544
  if ((unsigned long )command != (unsigned long )((void *)0)) {
    {
#line 1545
    writestring(sockfd, (char *)"\t");
#line 1546
    writestring(sockfd, command);
    }
  }
#line 1549
  if ((unsigned long )view != (unsigned long )((void *)0)) {
    {
#line 1550
    writestring(sockfd, view);
    }
  }
#line 1552
  if ((unsigned long )ask == (unsigned long )((void *)0)) {
    {
#line 1553
    writestring(sockfd, (char *)"\r\n");
    }
  } else {
    {
#line 1555
    writestring(sockfd, (char *)"\t1\r\n");
#line 1557
    GSsendHeader(sockfd, -1L);
#line 1559
    i = 0;
    }
    {
#line 1559
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1560
      cp = *(ask + i);
#line 1562
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 1563
        goto while_break;
      }
      {
#line 1565
      writestring(sockfd, cp);
#line 1566
      writestring(sockfd, (char *)"\r\n");
#line 1559
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1568
    writestring(sockfd, (char *)".\r\n");
    }
  }
#line 1570
  return;
}
}
#line 1578 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSsendHeader(int sockfd , long size ) 
{ 
  char sizestr[64] ;

  {
  {
#line 1583
  snprintf((char */* __restrict  */)(sizestr), sizeof(sizestr), (char const   */* __restrict  */)"+%ld\r\n",
           size);
#line 1584
  writestring(sockfd, sizestr);
  }
#line 1585
  return;
}
}
#line 1589 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSsendErrorHeader(GopherObj *gs , int sockfd , int errortype , char *errormsg ) 
{ 
  char tmpstr[512] ;

  {
  {
#line 1594
  snprintf((char */* __restrict  */)(tmpstr), sizeof(tmpstr), (char const   */* __restrict  */)"-%d %s\r\n",
           errortype, errormsg);
#line 1595
  writestring(sockfd, tmpstr);
  }
#line 1596
  return;
}
}
#line 1613 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
int GSrecvHeader(GopherObj *gs , int sockfd ) 
{ 
  char headerline[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
#line 1619
  if (gs->isgplus) {
    {
#line 1620
    tmp = readline(sockfd, headerline, (int )sizeof(headerline));
    }
#line 1620
    if (tmp <= 0) {
#line 1621
      return (0);
    }
    {
#line 1622
    ZapCRLF(headerline);
    }
#line 1623
    if ((int )headerline[0] == 43) {
#line 1624
      if ((int )*(headerline + 1) == 45) {
        {
#line 1625
        tmp___0 = atoi((char const   *)(headerline + 2));
        }
#line 1625
        return (- tmp___0);
      } else {
        {
#line 1627
        tmp___1 = atoi((char const   *)(headerline + 1));
        }
#line 1627
        return (tmp___1);
      }
    } else
#line 1629
    if ((int )headerline[0] == 45) {
      {
#line 1631
      tmp___2 = __errno_location();
#line 1631
      *tmp___2 = atoi((char const   *)(headerline + 1));
      }
#line 1632
      return (0);
    }
  } else {
    {
#line 1642
    if ((int )gs->sFileType == 53) {
#line 1642
      goto case_53;
    }
#line 1642
    if ((int )gs->sFileType == 57) {
#line 1642
      goto case_53;
    }
#line 1642
    if ((int )gs->sFileType == 103) {
#line 1642
      goto case_53;
    }
#line 1642
    if ((int )gs->sFileType == 73) {
#line 1642
      goto case_53;
    }
#line 1642
    if ((int )gs->sFileType == 115) {
#line 1642
      goto case_53;
    }
#line 1645
    goto switch_default;
    case_53: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_115: /* CIL Label */ 
#line 1643
    return (-2);
#line 1644
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1646
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 1649
  return (-1);
}
}
#line 1660 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GSgetginfo(GopherObj *gs , boolean savename ) 
{ 
  int sockfd ;
  int bytes ;
  char inputline___0[256] ;
  String *tempname ;
  char temptype ;
  char *tmp ;
  char *tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 1665
  tempname = (String *)((void *)0);
#line 1666
  temptype = (char )'\000';
#line 1668
  if (! gs->isgplus) {
#line 1669
    return;
  }
#line 1673
  if ((unsigned long )gs->gplus != (unsigned long )((void *)0)) {
#line 1674
    if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
#line 1674
      tmp___0 = (char *)((void *)0);
    } else {
#line 1674
      if (((gs->gplus)->Admin)->len < 0) {
#line 1674
        tmp = (char *)((void *)0);
      } else {
#line 1674
        tmp = ((gs->gplus)->Admin)->data;
      }
#line 1674
      tmp___0 = tmp;
    }
#line 1674
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1675
      return;
    }
#line 1676
    if ((unsigned long )gs->gplus != (unsigned long )((void *)0)) {
#line 1676
      tmp___1 = (gs->gplus)->Askdata;
    } else {
#line 1676
      tmp___1 = (char **)((void *)0);
    }
#line 1676
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 1677
      return;
    }
  }
#line 1680
  if (savename) {
    {
#line 1681
    tempname = STRnew();
    }
#line 1682
    if ((gs->Title)->len < 0) {
#line 1682
      tmp___2 = (char *)((void *)0);
    } else {
#line 1682
      tmp___2 = (gs->Title)->data;
    }
    {
#line 1682
    STRset(tempname, tmp___2);
#line 1683
    temptype = gs->sFileType;
    }
  }
  {
#line 1686
  GSplusnew(gs);
#line 1689
  sockfd = GSconnect(gs);
  }
#line 1689
  if (sockfd < 0) {
#line 1691
    return;
  }
  {
#line 1694
  GStransmit(gs, sockfd, (char *)((void *)0), (char *)"!", (char *)((void *)0));
#line 1695
  bytes = GSrecvHeader(gs, sockfd);
  }
#line 1697
  if (bytes == 0) {
#line 1698
    return;
  }
  {
#line 1701
  readtoken(sockfd, inputline___0, (int )sizeof(inputline___0), (char )' ');
#line 1703
  GSplusfromNet(gs, sockfd);
  }
#line 1705
  if (savename) {
#line 1706
    if (tempname->len < 0) {
#line 1706
      tmp___3 = (char *)((void *)0);
    } else {
#line 1706
      tmp___3 = tempname->data;
    }
    {
#line 1706
    STRset(gs->Title, tmp___3);
#line 1707
    gs->sFileType = temptype;
#line 1708
    STRdestroy(tempname);
    }
  }
#line 1711
  return;
}
}
#line 1725 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
int GSfromLink(GopherObj *gs , FileIO *fio , char *host , int port , char *directory ,
               char *peer ) 
{ 
  int doneflags ;
  char buf[1024] ;
  int bytesread ;
  boolean DomainDefault ;
  boolean BadDomain ;
  boolean DidDomain ;
  char tmpstr[256] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *acp ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int peerlen ;
  int domainlen ;
  boolean TestResult ;
  char *host___0 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  char *host___1 ;
  boolean TestResult___0 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 1734
  doneflags = 0;
#line 1738
  DomainDefault = 1;
#line 1739
  BadDomain = 0;
#line 1740
  DidDomain = 0;
#line 1742
  buf[0] = (char )'\000';
  {
#line 1746
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1746
    bytesread = FIOreadlinezap(fio, buf, (int )sizeof(buf));
    }
#line 1746
    if (! (bytesread > 0)) {
#line 1746
      goto while_break;
    }
#line 1747
    if ((int )buf[0] == 35) {
#line 1748
      if (doneflags & 1) {
#line 1749
        goto while_break;
      } else {
#line 1751
        goto while_continue;
      }
    }
    {
#line 1754
    ZapCRLF(buf);
#line 1756
    tmp___23 = strncmp((char const   *)(buf), "Type=", (size_t )5);
    }
#line 1756
    if (tmp___23 == 0) {
#line 1757
      gs->sFileType = buf[5];
#line 1759
      if ((int )buf[6] == 43) {
#line 1760
        gs->isgplus = 1;
      }
#line 1761
      if ((int )buf[6] == 63) {
#line 1762
        gs->isask = 1;
      }
#line 1763
      doneflags |= 2;
    } else {
      {
#line 1766
      tmp___22 = strncmp((char const   *)(buf), "Name=", (size_t )5);
      }
#line 1766
      if (tmp___22 == 0) {
        {
#line 1767
        STRset(gs->Title, buf + 5);
#line 1768
        doneflags |= 4;
        }
      } else {
        {
#line 1771
        tmp___21 = strncmp((char const   *)(buf), "Path=", (size_t )5);
        }
#line 1771
        if (tmp___21 == 0) {
          {
#line 1772
          tmp___0 = strncmp((char const   *)(buf + 5), "~/", (size_t )2);
          }
#line 1772
          if (tmp___0 == 0) {
#line 1772
            goto _L;
          } else {
            {
#line 1772
            tmp___1 = strncmp((char const   *)(buf + 5), "./", (size_t )2);
            }
#line 1772
            if (tmp___1 == 0) {
              _L: /* CIL Label */ 
              {
#line 1776
              tmpstr[0] = (char )'.';
#line 1777
              strcpy((char */* __restrict  */)(tmpstr + 1), (char const   */* __restrict  */)directory);
#line 1778
              tmp = strlen((char const   *)directory);
              }
#line 1778
              if ((int )*(directory + (tmp - 1UL)) == 47) {
                {
#line 1779
                strcat((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)(buf + 7));
                }
              } else {
                {
#line 1781
                strcat((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)(buf + 6));
                }
              }
              {
#line 1782
              STRset(gs->Selstr, tmpstr);
#line 1783
              STRset(gs->Host, host);
              }
            } else {
              {
#line 1785
              STRset(gs->Selstr, buf + 5);
              }
            }
          }
#line 1786
          doneflags |= 1;
        } else {
          {
#line 1789
          tmp___20 = strncmp((char const   *)(buf), "Host=", (size_t )5);
          }
#line 1789
          if (tmp___20 == 0) {
#line 1790
            if ((int )buf[5] == 43) {
#line 1790
              if ((int )buf[6] == 0) {
                {
#line 1791
                STRset(gs->Host, host);
                }
              } else {
                {
#line 1793
                STRset(gs->Host, buf + 5);
                }
              }
            } else {
              {
#line 1793
              STRset(gs->Host, buf + 5);
              }
            }
#line 1795
            doneflags |= 16;
          } else {
            {
#line 1798
            tmp___19 = strncmp((char const   *)(buf), "Port=", (size_t )5);
            }
#line 1798
            if (tmp___19 == 0) {
#line 1799
              if ((int )buf[5] == 43) {
#line 1799
                if ((int )buf[6] == 0) {
#line 1800
                  gs->iPort = port;
                } else {
                  {
#line 1802
                  gs->iPort = atoi((char const   *)(buf + 5));
                  }
                }
              } else {
                {
#line 1802
                gs->iPort = atoi((char const   *)(buf + 5));
                }
              }
#line 1804
              doneflags |= 8;
            } else {
              {
#line 1807
              tmp___18 = strncmp((char const   *)(buf), "Numb=", (size_t )5);
              }
#line 1807
              if (tmp___18 == 0) {
                {
#line 1808
                gs->Itemnum = atoi((char const   *)(buf + 5));
                }
              } else {
                {
#line 1810
                tmp___17 = strncmp((char const   *)(buf), "Abstract=", (size_t )9);
                }
#line 1810
                if (tmp___17 == 0) {
#line 1813
                  acp = buf + 9;
                  {
#line 1815
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
                    {
#line 1815
                    tmp___3 = strlen((char const   *)(buf));
                    }
#line 1815
                    if ((int )*((buf + tmp___3) - 1) == 92) {
#line 1815
                      if (! (bytesread > 0)) {
#line 1815
                        goto while_break___0;
                      }
                    } else {
#line 1815
                      goto while_break___0;
                    }
                    {
#line 1817
                    tmp___2 = strlen((char const   *)(buf));
#line 1817
                    *((buf + tmp___2) - 1) = (char )'\000';
#line 1818
                    GSsetBlock(gs, (char *)"ABSTRACT", acp, 1);
#line 1819
                    bytesread = FIOreadlinezap(fio, buf, (int )sizeof(buf));
#line 1820
                    acp = buf;
                    }
                  }
                  while_break___0: /* CIL Label */ ;
                  }
                  {
#line 1822
                  GSsetBlock(gs, (char *)"ABSTRACT", acp, 1);
                  }
                } else {
                  {
#line 1824
                  tmp___16 = strncmp((char const   *)(buf), "Admin=", (size_t )6);
                  }
#line 1824
                  if (tmp___16 == 0) {
                    {
#line 1825
                    GSsetAdmin(gs, buf + 6);
                    }
                  } else {
                    {
#line 1826
                    tmp___15 = strncmp((char const   *)(buf), "URL=", (size_t )4);
                    }
#line 1826
                    if (tmp___15 == 0) {
                      {
#line 1827
                      tmp___4 = GSfromURL(gs, buf + 4, host, port, doneflags);
#line 1827
                      doneflags |= tmp___4;
                      }
                    } else {
                      {
#line 1828
                      tmp___14 = strncmp((char const   *)(buf), "Domaindef=", (size_t )10);
                      }
#line 1828
                      if (tmp___14 == 0) {
#line 1828
                        if ((unsigned long )peer != (unsigned long )((void *)0)) {
                          {
#line 1829
                          tmp___5 = strcasecmp((char const   *)(buf + 10), "no");
#line 1829
                          DomainDefault = tmp___5 != 0;
                          }
                        } else {
#line 1828
                          goto _L___2;
                        }
                      } else {
                        _L___2: /* CIL Label */ 
                        {
#line 1832
                        tmp___13 = strncmp((char const   *)(buf), "Domain=", (size_t )7);
                        }
#line 1832
                        if (tmp___13 == 0) {
#line 1832
                          if ((unsigned long )peer != (unsigned long )((void *)0)) {
#line 1835
                            TestResult = ! DomainDefault;
#line 1836
                            host___0 = buf + 7;
#line 1838
                            if ((int )*host___0 == 33) {
#line 1839
                              TestResult = 1;
#line 1840
                              host___0 ++;
                            }
                            {
#line 1843
                            tmp___6 = strlen((char const   *)peer);
#line 1843
                            peerlen = (int )tmp___6;
#line 1844
                            tmp___7 = strlen((char const   *)host___0);
#line 1844
                            domainlen = (int )tmp___7;
                            }
#line 1846
                            if (DidDomain == 1) {
#line 1846
                              if (BadDomain == 0) {
#line 1847
                                goto while_break;
                              }
                            }
#line 1849
                            if (domainlen > peerlen) {
#line 1850
                              BadDomain = ! TestResult;
                            } else {
                              {
#line 1851
                              tmp___8 = strncasecmp((char const   *)(buf + 7), (char const   *)((peer + peerlen) - domainlen),
                                                    (size_t )domainlen);
                              }
#line 1851
                              if (tmp___8 == 0) {
#line 1853
                                BadDomain = TestResult;
                              } else {
#line 1855
                                BadDomain = ! TestResult;
                              }
                            }
#line 1857
                            DidDomain = 1;
                          } else {
#line 1832
                            goto _L___1;
                          }
                        } else {
                          _L___1: /* CIL Label */ 
                          {
#line 1860
                          tmp___12 = strncmp((char const   *)(buf), "Domain_pat=",
                                             (size_t )11);
                          }
#line 1860
                          if (tmp___12 == 0) {
#line 1860
                            if ((unsigned long )peer != (unsigned long )((void *)0)) {
#line 1861
                              host___1 = buf + 11;
#line 1862
                              TestResult___0 = ! DomainDefault;
#line 1864
                              if (DidDomain == 1) {
#line 1864
                                if (BadDomain == 0) {
#line 1865
                                  goto while_break;
                                }
                              }
#line 1867
                              if ((int )*host___1 == 33) {
#line 1868
                                host___1 ++;
#line 1869
                                TestResult___0 = 1;
                              }
                              {
#line 1873
                              tmp___9 = posix_re_comp(host___1);
                              }
#line 1873
                              if (tmp___9) {
#line 1874
                                goto while_break;
                              }
                              {
#line 1875
                              tmp___10 = posix_re_exec(peer);
                              }
#line 1875
                              if (tmp___10 == 1) {
#line 1876
                                BadDomain = TestResult___0;
                              } else {
#line 1878
                                BadDomain = ! TestResult___0;
                              }
#line 1880
                              DidDomain = 1;
                            } else {
#line 1860
                              goto _L___0;
                            }
                          } else {
                            _L___0: /* CIL Label */ 
                            {
#line 1883
                            tmp___11 = strncmp((char const   *)(buf), "TTL=", (size_t )4);
                            }
#line 1883
                            if (tmp___11 == 0) {
                              {
#line 1884
                              gs->ttl = atoi((char const   *)(buf + 4));
                              }
                            } else {
#line 1887
                              goto while_break;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1892
  if (BadDomain) {
#line 1893
    return (-1);
  }
#line 1895
  if (bytesread == 0) {
#line 1896
    if (doneflags & 1) {
#line 1897
      return (0);
    } else {
#line 1899
      return (-2);
    }
  }
#line 1902
  if (doneflags & 1) {
#line 1903
    return (1);
  } else {
#line 1905
    return (-1);
  }
}
}
#line 1915 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
int GSfromURL(GopherObj *gs , char *urltxt , char *host , int port , int doneflags ) 
{ 
  char tempbuf[256] ;
  Url *url ;
  UrlServiceType serviceType ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *cp ;
  char const   *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 1922
  url = URLnew();
#line 1923
  STRset(url->url, urltxt);
#line 1926
  GSsetURL(gs, urltxt);
#line 1927
  serviceType = URLgetService(url);
  }
  {
#line 1930
  if ((unsigned int )serviceType == 1U) {
#line 1930
    goto case_1;
  }
#line 1946
  if ((unsigned int )serviceType == 2U) {
#line 1946
    goto case_2;
  }
#line 1957
  if ((unsigned int )serviceType == 3U) {
#line 1957
    goto case_3;
  }
#line 1963
  if ((unsigned int )serviceType == 4U) {
#line 1963
    goto case_4;
  }
#line 1970
  if ((unsigned int )serviceType == 0U) {
#line 1970
    goto case_0;
  }
#line 1979
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1931
  if (! (doneflags & 2)) {
#line 1934
    gs->sFileType = (char )'h';
#line 1935
    doneflags |= 2;
  }
#line 1938
  if (! (doneflags & 1)) {
    {
#line 1939
    tmp = URLgetPath(url);
#line 1939
    snprintf((char */* __restrict  */)(tempbuf), sizeof(tempbuf), (char const   */* __restrict  */)"GET /%s",
             tmp);
#line 1940
    STRset(gs->Selstr, tempbuf);
    }
  }
#line 1942
  doneflags |= 1;
#line 1944
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1947
  if (! (doneflags & 16)) {
    {
#line 1948
    STRset(gs->Host, host);
#line 1949
    doneflags |= 16;
    }
  }
#line 1951
  if (! (doneflags & 8)) {
#line 1952
    gs->iPort = port;
#line 1953
    doneflags |= 8;
  }
#line 1955
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1958
  if (! (doneflags & 2)) {
#line 1959
    gs->sFileType = (char )'8';
#line 1960
    doneflags |= 2;
  }
  case_4: /* CIL Label */ 
#line 1964
  if (! (doneflags & 2)) {
#line 1965
    gs->sFileType = (char )'T';
#line 1966
    doneflags |= 2;
  }
#line 1968
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1972
  if (! (doneflags & 2)) {
    {
#line 1973
    gs->sFileType = URLgetGophType(url);
#line 1974
    doneflags |= 2;
    }
  }
#line 1977
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1981
  return (doneflags);
  switch_break: /* CIL Label */ ;
  }
#line 1984
  if (! (doneflags & 4)) {
#line 1985
    if ((url->url)->len < 0) {
#line 1985
      tmp___0 = (char *)((void *)0);
    } else {
#line 1985
      tmp___0 = (url->url)->data;
    }
    {
#line 1985
    STRset(gs->Title, tmp___0);
#line 1986
    doneflags |= 4;
    }
  }
  {
#line 1992
  if ((unsigned int )serviceType == 4U) {
#line 1992
    goto case_4___0;
  }
#line 1992
  if ((unsigned int )serviceType == 3U) {
#line 1992
    goto case_4___0;
  }
#line 2005
  if ((unsigned int )serviceType == 7U) {
#line 2005
    goto case_7;
  }
#line 2005
  if ((unsigned int )serviceType == 6U) {
#line 2005
    goto case_7;
  }
#line 2005
  if ((unsigned int )serviceType == 5U) {
#line 2005
    goto case_7;
  }
#line 2005
  if ((unsigned int )serviceType == 2U) {
#line 2005
    goto case_7;
  }
#line 2005
  if ((unsigned int )serviceType == 1U) {
#line 2005
    goto case_7;
  }
#line 2005
  if ((unsigned int )serviceType == 0U) {
#line 2005
    goto case_7;
  }
#line 1990
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
  {
#line 1993
  tmp___2 = URLgetUser(url);
  }
#line 1993
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
    {
#line 1994
    tmp___1 = URLgetUser(url);
#line 1994
    STRset(gs->Selstr, tmp___1);
    }
  } else {
    {
#line 1996
    STRset(gs->Selstr, (char *)"");
    }
  }
#line 1997
  doneflags |= 1;
#line 1998
  goto switch_break___0;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
#line 2006
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2009
  if ((unsigned int )serviceType == 2U) {
#line 2010
    if (! (doneflags & 1)) {
      {
#line 2011
      tmp___6 = URLgetPath(url);
      }
#line 2011
      if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
        {
#line 2011
        tmp___7 = URLgetPath(url);
        }
#line 2011
        if ((int )*tmp___7 != 0) {
          {
#line 2012
          tmp___3 = URLgetPath(url);
#line 2012
          tmp___4 = URLgetHost(url);
#line 2012
          snprintf((char */* __restrict  */)(tempbuf), sizeof(tempbuf), (char const   */* __restrict  */)"ftp:%s@/%s",
                   tmp___4, tmp___3);
          }
        } else {
          {
#line 2016
          tmp___5 = URLgetHost(url);
#line 2016
          snprintf((char */* __restrict  */)(tempbuf), sizeof(tempbuf), (char const   */* __restrict  */)"ftp:%s@/",
                   tmp___5);
          }
        }
      } else {
        {
#line 2016
        tmp___5 = URLgetHost(url);
#line 2016
        snprintf((char */* __restrict  */)(tempbuf), sizeof(tempbuf), (char const   */* __restrict  */)"ftp:%s@/",
                 tmp___5);
        }
      }
      {
#line 2019
      STRset(gs->Selstr, tempbuf);
#line 2020
      doneflags |= 1;
      }
    }
#line 2022
    if (! (doneflags & 2)) {
      {
#line 2023
      tmp___8 = URLgetPath(url);
      }
#line 2023
      if ((int )*tmp___8 == 0) {
#line 2025
        gs->sFileType = (char )'1';
      } else {
        {
#line 2023
        tmp___9 = URLgetPath(url);
#line 2023
        tmp___10 = URLgetPath(url);
#line 2023
        tmp___11 = strlen((char const   *)tmp___10);
        }
#line 2023
        if ((int )*((tmp___9 + tmp___11) - 1) == 47) {
#line 2025
          gs->sFileType = (char )'1';
        } else {
#line 2027
          gs->sFileType = (char )'0';
        }
      }
#line 2029
      doneflags |= 2;
    }
  } else {
#line 2032
    if (! (doneflags & 16)) {
      {
#line 2033
      tmp___12 = URLgetHost(url);
#line 2033
      STRset(gs->Host, tmp___12);
#line 2034
      doneflags |= 16;
      }
    }
#line 2036
    if (! (doneflags & 8)) {
      {
#line 2037
      gs->iPort = URLgetPort(url);
#line 2038
      doneflags |= 8;
      }
    }
  }
#line 2043
  if (! (doneflags & 1)) {
#line 2043
    goto _L;
  } else {
#line 2043
    if ((gs->Selstr)->len < 0) {
#line 2043
      tmp___14 = (char *)((void *)0);
    } else {
#line 2043
      tmp___14 = (gs->Selstr)->data;
    }
#line 2043
    if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 2045
      cp = URLgetPath(url);
      }
#line 2045
      if (cp) {
#line 2045
        tmp___13 = (char const   *)cp;
      } else {
#line 2045
        tmp___13 = "";
      }
      {
#line 2045
      STRset(gs->Selstr, (char *)tmp___13);
#line 2046
      doneflags |= 1;
      }
    }
  }
#line 2049
  return (doneflags);
}
}
#line 2055 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
void GStoLink(GopherObj *gs , int fd , BOOLEAN AddInfo ) 
{ 
  char gtype[2] ;
  char portnum[16] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 2061
  gtype[0] = gs->sFileType;
#line 2062
  gtype[1] = (char )'\000';
#line 2064
  writestring(fd, (char *)"#");
#line 2065
  writestring(fd, (char *)"\nType=");
#line 2066
  writestring(fd, gtype);
  }
#line 2067
  if (gs->isgplus) {
    {
#line 2068
    writestring(fd, (char *)"+");
    }
  }
  {
#line 2069
  writestring(fd, (char *)"\nName=");
  }
#line 2070
  if ((gs->Title)->len < 0) {
#line 2070
    tmp = (char *)((void *)0);
  } else {
#line 2070
    tmp = (gs->Title)->data;
  }
  {
#line 2070
  writestring(fd, tmp);
#line 2071
  writestring(fd, (char *)"\nPath=");
  }
#line 2072
  if ((gs->Selstr)->len < 0) {
#line 2072
    tmp___0 = (char *)((void *)0);
  } else {
#line 2072
    tmp___0 = (gs->Selstr)->data;
  }
  {
#line 2072
  writestring(fd, tmp___0);
#line 2073
  writestring(fd, (char *)"\nHost=");
  }
#line 2074
  if ((gs->Host)->len < 0) {
#line 2074
    tmp___1 = (char *)((void *)0);
  } else {
#line 2074
    tmp___1 = (gs->Host)->data;
  }
  {
#line 2074
  writestring(fd, tmp___1);
#line 2075
  writestring(fd, (char *)"\nPort=");
#line 2076
  snprintf((char */* __restrict  */)(portnum), sizeof(portnum), (char const   */* __restrict  */)"%d",
           gs->iPort);
#line 2077
  writestring(fd, portnum);
#line 2078
  writestring(fd, (char *)"\n");
  }
#line 2079
  if (gs->isgplus) {
#line 2079
    if ((unsigned long )gs->gplus != (unsigned long )((void *)0)) {
#line 2079
      if (AddInfo) {
        {
#line 2080
        writestring(fd, (char *)"Admin=");
        }
#line 2081
        if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
#line 2081
          tmp___3 = (char *)((void *)0);
        } else {
#line 2081
          if (((gs->gplus)->Admin)->len < 0) {
#line 2081
            tmp___2 = (char *)((void *)0);
          } else {
#line 2081
            tmp___2 = ((gs->gplus)->Admin)->data;
          }
#line 2081
          tmp___3 = tmp___2;
        }
        {
#line 2081
        writestring(fd, tmp___3);
#line 2082
        writestring(fd, (char *)"\nModDate=");
#line 2083
        tmp___4 = GSgetModDate(gs);
#line 2083
        writestring(fd, tmp___4);
#line 2084
        writestring(fd, (char *)"\n");
        }
      }
    }
  }
#line 2086
  return;
}
}
#line 2089 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
boolean GSisText(GopherObj *gs , char *view ) 
{ 
  char viewstowage[64] ;
  char *cp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2092
  if ((unsigned long )view == (unsigned long )((void *)0)) {
    {
#line 2098
    if ((int )gs->sFileType == 52) {
#line 2098
      goto case_52;
    }
#line 2098
    if ((int )gs->sFileType == 50) {
#line 2098
      goto case_52;
    }
#line 2098
    if ((int )gs->sFileType == 77) {
#line 2098
      goto case_52;
    }
#line 2098
    if ((int )gs->sFileType == 48) {
#line 2098
      goto case_52;
    }
#line 2098
    if ((int )gs->sFileType == 49) {
#line 2098
      goto case_52;
    }
#line 2102
    goto switch_default;
    case_52: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 2099
    return (1);
    switch_default: /* CIL Label */ 
#line 2103
    return (0);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 2109
    strcpy((char */* __restrict  */)(viewstowage), (char const   */* __restrict  */)view);
#line 2110
    cp = strchr((char const   *)(viewstowage), ' ');
    }
#line 2110
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 2111
      *cp = (char )'\000';
#line 2112
      view = viewstowage;
    }
    {
#line 2115
    tmp = strncasecmp((char const   *)view, "Text", (size_t )4);
    }
#line 2115
    if (tmp == 0) {
#line 2124
      return (1);
    } else {
      {
#line 2115
      tmp___0 = strncasecmp((char const   *)view, "message/rfc822", (size_t )14);
      }
#line 2115
      if (tmp___0 == 0) {
#line 2124
        return (1);
      } else {
        {
#line 2115
        tmp___1 = strncasecmp((char const   *)view, "application/postscript", (size_t )21);
        }
#line 2115
        if (tmp___1 == 0) {
#line 2124
          return (1);
        } else {
          {
#line 2115
          tmp___2 = strncasecmp((char const   *)view, "application/mac-binhex40",
                                (size_t )24);
          }
#line 2115
          if (tmp___2 == 0) {
#line 2124
            return (1);
          } else {
            {
#line 2115
            tmp___3 = strncasecmp((char const   *)view, "application/rtf", (size_t )15);
            }
#line 2115
            if (tmp___3 == 0) {
#line 2124
              return (1);
            } else {
              {
#line 2115
              tmp___4 = strncasecmp((char const   *)view, "application/gopher", (size_t )18);
              }
#line 2115
              if (tmp___4 == 0) {
#line 2124
                return (1);
              } else {
#line 2126
                return (0);
              }
            }
          }
        }
      }
    }
  }
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/STRstring.h"
String *STRcpy(String *s1 , String *s2 ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.h"
boolean VIfromLine(VIewobj *vi , char *line ) ;
#line 79
char *VIgetViewnLang(VIewobj *vi , char *line ) ;
#line 80
char *VIgetPrettyView(VIewobj *vi , char *line ) ;
#line 81
char *VIprettyLang(VIewobj *vi , char *currentlang ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
static char *ANSILangs[22]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
  {      (char *)"Da_DK",      (char *)"Nl_BE",      (char *)"Nl_NL",      (char *)"En_GB", 
        (char *)"En_US",      (char *)"Fi_FI",      (char *)"Fr_BE",      (char *)"Fr_CA", 
        (char *)"Fr_CH",      (char *)"Fr_FR",      (char *)"De_CH",      (char *)"De_DE", 
        (char *)"El_GR",      (char *)"Is_IS",      (char *)"It_IT",      (char *)"Jp_JP", 
        (char *)"No_NO",      (char *)"Pt_PT",      (char *)"Es_ES",      (char *)"Sv_SE", 
        (char *)"Tr_TR",      (char *)((void *)0)};
#line 85 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
static char *ANSILangEn[22]  = 
#line 85
  {      (char *)"Danish",      (char *)"Dutch (Belgium)",      (char *)"Dutch",      (char *)"English (Great Britain)", 
        (char *)"English (USA)",      (char *)"Finnish",      (char *)"Fran\347ais (Belgium)",      (char *)"Fran\347ais (Canada)", 
        (char *)"Fran\347ais (Suisse)",      (char *)"Fran\347ais",      (char *)"Deutsch (Suisse)",      (char *)"Deutsch", 
        (char *)"Greek",      (char *)"Icelandic",      (char *)"Italiano",      (char *)"Japanese", 
        (char *)"Norwegian",      (char *)"Portugues",      (char *)"Espa\361ol",      (char *)"Swedish", 
        (char *)"Turkish",      (char *)((void *)0)};
#line 111 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
char *VIprettyLang(VIewobj *vi , char *currentlang ) 
{ 
  int i ;
  char *cp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 115
  if ((vi->Lang)->len < 0) {
#line 115
    tmp = (char *)((void *)0);
  } else {
#line 115
    tmp = (vi->Lang)->data;
  }
#line 115
  cp = tmp;
#line 117
  if ((vi->Lang)->len < 0) {
#line 117
    tmp___0 = (char *)((void *)0);
  } else {
#line 117
    tmp___0 = (vi->Lang)->data;
  }
#line 117
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 118
    return ((char *)((void *)0));
  }
#line 119
  i = 0;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if ((unsigned long )ANSILangs[i] == (unsigned long )((void *)0)) {
#line 121
      return ((char *)((void *)0));
    }
    {
#line 123
    tmp___1 = strcasecmp((char const   *)ANSILangs[i], (char const   *)cp);
    }
#line 123
    if (tmp___1 == 0) {
#line 124
      return (ANSILangEn[i]);
    }
#line 119
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
VIewobj *VInew(void) 
{ 
  VIewobj *temp ;
  void *tmp ;

  {
  {
#line 136
  tmp = malloc(sizeof(VIewobj ));
#line 136
  temp = (VIewobj *)tmp;
#line 138
  temp->Type = STRnew();
#line 139
  temp->Lang = STRnew();
#line 140
  temp->Size = STRnew();
#line 141
  temp->comments = STRnew();
#line 143
  VIinit(temp);
  }
#line 144
  return (temp);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
void VIinit(VIewobj *vi ) 
{ 


  {
  {
#line 152
  STRinit(vi->Type);
#line 153
  STRinit(vi->Lang);
#line 154
  STRinit(vi->Size);
#line 155
  STRinit(vi->comments);
  }
#line 156
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
void VIdestroy(VIewobj *vi ) 
{ 


  {
  {
#line 164
  STRdestroy(vi->Type);
#line 165
  STRdestroy(vi->Lang);
#line 166
  STRdestroy(vi->Size);
#line 167
  STRdestroy(vi->comments);
#line 169
  free((void *)vi);
  }
#line 170
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
void VIcpy(VIewobj *videst , VIewobj *viorig ) 
{ 


  {
  {
#line 178
  STRcpy(videst->Type, viorig->Type);
#line 179
  STRcpy(videst->Lang, viorig->Lang);
#line 180
  STRcpy(videst->Size, viorig->Size);
#line 181
  STRcpy(videst->comments, viorig->comments);
  }
#line 182
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
void VItoLine(VIewobj *vi , char *tmpstr ) 
{ 
  char *cp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 192
  *(tmpstr + 0) = (char )' ';
#line 193
  *(tmpstr + 1) = (char )'\000';
#line 195
  if ((vi->Type)->len < 0) {
#line 195
    tmp = (char *)((void *)0);
  } else {
#line 195
    tmp = (vi->Type)->data;
  }
  {
#line 195
  strcat((char */* __restrict  */)tmpstr, (char const   */* __restrict  */)tmp);
  }
#line 197
  if ((vi->Lang)->len < 0) {
#line 197
    tmp___0 = (char *)((void *)0);
  } else {
#line 197
    tmp___0 = (vi->Lang)->data;
  }
#line 197
  cp = tmp___0;
#line 198
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 198
    if ((int )*cp != 0) {
      {
#line 199
      strcat((char */* __restrict  */)tmpstr, (char const   */* __restrict  */)" ");
#line 200
      strcat((char */* __restrict  */)tmpstr, (char const   */* __restrict  */)cp);
      }
    }
  }
#line 204
  if ((vi->Size)->len < 0) {
#line 204
    tmp___1 = (char *)((void *)0);
  } else {
#line 204
    tmp___1 = (vi->Size)->data;
  }
#line 204
  cp = tmp___1;
#line 205
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 205
    if ((int )*cp != 0) {
      {
#line 206
      strcat((char */* __restrict  */)tmpstr, (char const   */* __restrict  */)": <");
      }
#line 207
      if ((vi->Size)->len < 0) {
#line 207
        tmp___2 = (char *)((void *)0);
      } else {
#line 207
        tmp___2 = (vi->Size)->data;
      }
      {
#line 207
      strcat((char */* __restrict  */)tmpstr, (char const   */* __restrict  */)tmp___2);
#line 208
      strcat((char */* __restrict  */)tmpstr, (char const   */* __restrict  */)">");
      }
    } else {
      {
#line 210
      strcat((char */* __restrict  */)tmpstr, (char const   */* __restrict  */)": ");
      }
    }
  } else {
    {
#line 210
    strcat((char */* __restrict  */)tmpstr, (char const   */* __restrict  */)": ");
    }
  }
#line 214
  if ((vi->comments)->len < 0) {
#line 214
    tmp___3 = (char *)((void *)0);
  } else {
#line 214
    tmp___3 = (vi->comments)->data;
  }
#line 214
  cp = tmp___3;
#line 215
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 215
    if ((int )*cp != 0) {
      {
#line 216
      strcat((char */* __restrict  */)tmpstr, (char const   */* __restrict  */)" ");
#line 217
      strcat((char */* __restrict  */)tmpstr, (char const   */* __restrict  */)cp);
      }
    }
  }
#line 219
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
boolean VIfromLine(VIewobj *vi , char *line ) 
{ 
  char tmpstr[256] ;
  char *cp ;
  int i ;
  size_t tmp ;

  {
  {
#line 230
  tmp = strlen((char const   *)line);
  }
#line 230
  if (tmp >= 200UL) {
#line 233
    return (0);
  }
#line 236
  cp = line;
#line 236
  i = 0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if ((int )*cp != 32) {
#line 236
      if ((int )*cp != 0) {
#line 236
        if (! ((int )*cp != 58)) {
#line 236
          goto while_break;
        }
      } else {
#line 236
        goto while_break;
      }
    } else {
#line 236
      goto while_break;
    }
#line 237
    tmpstr[i] = *cp;
#line 236
    cp ++;
#line 236
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  tmpstr[i] = (char )'\000';
#line 240
  line = cp + 1;
#line 241
  STRset(vi->Type, tmpstr);
  }
#line 243
  if ((int )*line == 0) {
#line 244
    return (0);
  }
#line 248
  if ((int )*line != 58) {
#line 249
    cp = line;
#line 249
    i = 0;
    {
#line 249
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 249
      if ((int )*cp != 32) {
#line 249
        if ((int )*cp != 0) {
#line 249
          if (! ((int )*cp != 58)) {
#line 249
            goto while_break___0;
          }
        } else {
#line 249
          goto while_break___0;
        }
      } else {
#line 249
        goto while_break___0;
      }
#line 250
      tmpstr[i] = *cp;
#line 249
      cp ++;
#line 249
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 251
    tmpstr[i] = (char )'\000';
#line 252
    line = cp + 1;
#line 253
    STRset(vi->Lang, tmpstr);
    }
  }
#line 256
  if ((int )*line == 0) {
#line 257
    return (0);
  }
  {
#line 260
  cp = strchr((char const   *)line, '<');
  }
#line 262
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 263
    cp ++;
#line 263
    i = 0;
    {
#line 263
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 263
      if ((int )*cp != 0) {
#line 263
        if (! ((int )*cp != 62)) {
#line 263
          goto while_break___1;
        }
      } else {
#line 263
        goto while_break___1;
      }
#line 264
      tmpstr[i] = *cp;
#line 263
      cp ++;
#line 263
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 265
    tmpstr[i] = (char )'\000';
#line 266
    line = cp + 1;
#line 267
    STRset(vi->Size, tmpstr);
    }
  }
#line 270
  if ((int )*line != 0) {
    {
#line 271
    STRset(vi->comments, line);
    }
  }
#line 273
  return (1);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
char *VIgetViewnLang(VIewobj *vi , char *line ) 
{ 
  char *cp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 281
  if ((vi->Type)->len < 0) {
#line 281
    tmp = (char *)((void *)0);
  } else {
#line 281
    tmp = (vi->Type)->data;
  }
#line 281
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 282
    return ((char *)"");
  }
#line 283
  if ((vi->Type)->len < 0) {
#line 283
    tmp___0 = (char *)((void *)0);
  } else {
#line 283
    tmp___0 = (vi->Type)->data;
  }
  {
#line 283
  strcpy((char */* __restrict  */)line, (char const   */* __restrict  */)tmp___0);
  }
#line 285
  if ((vi->Lang)->len < 0) {
#line 285
    tmp___1 = (char *)((void *)0);
  } else {
#line 285
    tmp___1 = (vi->Lang)->data;
  }
#line 285
  cp = tmp___1;
#line 286
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 286
    if ((int )*cp != 0) {
      {
#line 287
      strcat((char */* __restrict  */)line, (char const   */* __restrict  */)" ");
      }
#line 288
      if ((vi->Lang)->len < 0) {
#line 288
        tmp___2 = (char *)((void *)0);
      } else {
#line 288
        tmp___2 = (vi->Lang)->data;
      }
      {
#line 288
      strcat((char */* __restrict  */)line, (char const   */* __restrict  */)tmp___2);
      }
    }
  }
#line 290
  return (line);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
void VIAfromBL(VIewArray *via , Blockobj *bl ) 
{ 
  int i ;
  char *cp ;
  VIewobj *vi ;
  char *tmp ;
  int tmp___0 ;
  boolean tmp___1 ;
  int tmp___2 ;

  {
#line 305
  if ((bl->Blockname)->len < 0) {
#line 305
    tmp = (char *)((void *)0);
  } else {
#line 305
    tmp = (bl->Blockname)->data;
  }
  {
#line 305
  tmp___0 = strcasecmp((char const   *)tmp, "VIEWS");
  }
#line 305
  if (tmp___0 != 0) {
#line 306
    return;
  }
  {
#line 308
  vi = VInew();
#line 310
  i = 0;
  }
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 310
    tmp___2 = BLgetNumLines(bl);
    }
#line 310
    if (! (i < tmp___2)) {
#line 310
      goto while_break;
    }
    {
#line 311
    cp = BLgetLine(bl, i);
#line 312
    VIinit(vi);
#line 314
    tmp___1 = VIfromLine(vi, cp);
    }
#line 314
    if (tmp___1) {
      {
#line 315
      DApush(via, (char *)vi);
      }
    }
#line 310
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 317
  VIdestroy(vi);
  }
#line 319
  return;
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
char *VIgetPrettyView(VIewobj *vi , char *line ) 
{ 
  char *cp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 327
  if ((vi->Type)->len < 0) {
#line 327
    tmp = (char *)((void *)0);
  } else {
#line 327
    tmp = (vi->Type)->data;
  }
#line 327
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 328
    return ((char *)"");
  }
#line 329
  if ((vi->Type)->len < 0) {
#line 329
    tmp___0 = (char *)((void *)0);
  } else {
#line 329
    tmp___0 = (vi->Type)->data;
  }
  {
#line 329
  strcpy((char */* __restrict  */)line, (char const   */* __restrict  */)tmp___0);
#line 331
  cp = VIprettyLang(vi, (char *)"");
  }
#line 332
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 332
    if ((int )*cp != 0) {
      {
#line 333
      strcat((char */* __restrict  */)line, (char const   */* __restrict  */)" ");
#line 334
      strcat((char */* __restrict  */)line, (char const   */* __restrict  */)cp);
      }
    }
  }
#line 337
  if ((vi->Size)->len < 0) {
#line 337
    tmp___1 = (char *)((void *)0);
  } else {
#line 337
    tmp___1 = (vi->Size)->data;
  }
#line 337
  cp = tmp___1;
#line 338
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 338
    if ((int )*cp != 0) {
      {
#line 339
      strcat((char */* __restrict  */)line, (char const   */* __restrict  */)" [");
#line 340
      strcat((char */* __restrict  */)line, (char const   */* __restrict  */)cp);
#line 341
      strcat((char */* __restrict  */)line, (char const   */* __restrict  */)"]");
      }
    }
  }
#line 343
  return (line);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.h"
void Fromhexstr(char *input , char *output ) ;
#line 79
void Tohexstr(char *input , char *output ) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.h"
void URLmakeHTML(Url *url ) ;
#line 93
char *URLgetPass(Url *url ) ;
#line 90 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.c"
Url *URLnew(void) 
{ 
  Url *temp ;
  void *tmp ;

  {
  {
#line 95
  tmp = malloc(sizeof(Url ));
#line 95
  temp = (Url *)tmp;
#line 96
  temp->url = STRnew();
#line 97
  temp->Host = STRnew();
#line 98
  temp->Port = -1;
#line 99
  temp->Path = STRnew();
#line 100
  temp->User = STRnew();
#line 101
  temp->Pass = STRnew();
#line 102
  temp->Gtype = (char )'\000';
#line 104
  temp->service = (UrlServiceType )6;
  }
#line 105
  return (temp);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.c"
void URLdestroy(Url *url ) 
{ 


  {
  {
#line 112
  STRdestroy(url->url);
#line 113
  STRdestroy(url->Host);
#line 114
  STRdestroy(url->Path);
#line 115
  STRdestroy(url->User);
#line 116
  STRdestroy(url->Pass);
#line 118
  free((void *)url);
  }
#line 119
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.c"
void URLfromGS(Url *url , GopherObj *gs , char *ticket ) 
{ 
  char u[2048] ;
  char *path ;
  char *cp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char *atsign ;
  char *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 132
  u[0] = (char )'\000';
#line 133
  if ((gs->Selstr)->len < 0) {
#line 133
    tmp = (char *)((void *)0);
  } else {
#line 133
    tmp = (gs->Selstr)->data;
  }
#line 133
  path = tmp;
#line 135
  if ((gs->Host)->len < 0) {
#line 135
    tmp___0 = (char *)((void *)0);
  } else {
#line 135
    tmp___0 = (gs->Host)->data;
  }
#line 135
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 136
    return;
  }
#line 138
  if ((int )gs->sFileType == 84) {
#line 138
    goto _L___0;
  } else
#line 138
  if ((int )gs->sFileType == 56) {
    _L___0: /* CIL Label */ 
#line 140
    if ((int )gs->sFileType == 56) {
      {
#line 141
      strcpy((char */* __restrict  */)(u), (char const   */* __restrict  */)"telnet://");
      }
    } else {
      {
#line 143
      strcpy((char */* __restrict  */)(u), (char const   */* __restrict  */)"tn3270://");
      }
    }
#line 144
    if ((gs->Host)->len < 0) {
#line 144
      tmp___1 = (char *)((void *)0);
    } else {
#line 144
      tmp___1 = (gs->Host)->data;
    }
    {
#line 144
    Tohexstr(tmp___1, u + 9);
    }
#line 145
    if ((unsigned long )path != (unsigned long )((void *)0)) {
#line 145
      if ((int )*path != 0) {
        {
#line 146
        tmp___2 = strlen((char const   *)(u));
#line 146
        cp = u + tmp___2;
#line 147
        tmp___3 = cp;
#line 147
        cp ++;
#line 147
        *tmp___3 = (char )'@';
#line 148
        Tohexstr(path, cp);
        }
      }
    }
    {
#line 150
    tmp___4 = strlen((char const   *)(u));
#line 150
    tmp___5 = strlen((char const   *)(u));
#line 150
    snprintf((char */* __restrict  */)(u + tmp___5), (sizeof(u) - tmp___4) - 1UL,
             (char const   */* __restrict  */)":%d", gs->iPort);
    }
  } else
#line 154
  if ((unsigned long )path != (unsigned long )((void *)0)) {
    {
#line 156
    tmp___17 = strncmp((char const   *)path, "GET /", (size_t )5);
    }
#line 156
    if (tmp___17 == 0) {
      {
#line 158
      strcpy((char */* __restrict  */)(u), (char const   */* __restrict  */)"http://");
      }
#line 159
      if ((gs->Host)->len < 0) {
#line 159
        tmp___6 = (char *)((void *)0);
      } else {
#line 159
        tmp___6 = (gs->Host)->data;
      }
      {
#line 159
      Tohexstr(tmp___6, u + 7);
#line 160
      tmp___7 = strlen((char const   *)(u));
#line 160
      tmp___8 = strlen((char const   *)(u));
#line 160
      snprintf((char */* __restrict  */)(u + tmp___8), (sizeof(u) - tmp___7) - 1UL,
               (char const   */* __restrict  */)":%d", gs->iPort);
#line 163
      tmp___9 = strlen((char const   *)(u));
#line 163
      Tohexstr(path + 4, u + tmp___9);
      }
    } else {
      {
#line 164
      tmp___16 = strncmp((char const   *)path, "ftp:", (size_t )4);
      }
#line 164
      if (tmp___16 == 0) {
#line 167
        if ((int )*(path + 4) == 47) {
#line 167
          if ((int )*(path + 5) == 47) {
            {
#line 168
            strcpy((char */* __restrict  */)(u), (char const   */* __restrict  */)path);
            }
          } else {
#line 167
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 170
          strcpy((char */* __restrict  */)(u), (char const   */* __restrict  */)"ftp://");
#line 171
          strcat((char */* __restrict  */)(u), (char const   */* __restrict  */)(path + 4));
#line 172
          atsign = strchr((char const   *)(u), '@');
          }
#line 173
          if ((unsigned long )atsign != (unsigned long )((void *)0)) {
            {
#line 174
            Tohexstr((path + (atsign - u)) - 1, atsign);
            }
          }
        }
      } else {
        {
#line 178
        strcpy((char */* __restrict  */)(u), (char const   */* __restrict  */)"gopher://");
        }
#line 179
        if ((gs->Host)->len < 0) {
#line 179
          tmp___10 = (char *)((void *)0);
        } else {
#line 179
          tmp___10 = (gs->Host)->data;
        }
        {
#line 179
        Tohexstr(tmp___10, u + 9);
#line 180
        tmp___11 = strlen((char const   *)(u));
#line 180
        tmp___12 = strlen((char const   *)(u));
#line 180
        snprintf((char */* __restrict  */)(u + tmp___12), (sizeof(u) - tmp___11) - 1UL,
                 (char const   */* __restrict  */)":%d/%c", gs->iPort, (int )gs->sFileType);
        }
#line 183
        if ((unsigned long )ticket != (unsigned long )((void *)0)) {
          {
#line 183
          tmp___14 = strlen((char const   *)ticket);
          }
#line 183
          if (tmp___14 > 0UL) {
            {
#line 184
            tmp___13 = strlen((char const   *)(u));
#line 184
            Tohexstr(ticket, u + tmp___13);
            }
          }
        }
        {
#line 185
        tmp___15 = strlen((char const   *)(u));
#line 185
        Tohexstr(path, u + tmp___15);
        }
      }
    }
  }
  {
#line 188
  STRset(url->url, u);
  }
#line 189
  return;
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.c"
void URLmakeHTML(Url *url ) 
{ 
  char *cp ;
  char *tmp ;
  int tmp___0 ;

  {
#line 198
  if ((url->url)->len < 0) {
#line 198
    tmp = (char *)((void *)0);
  } else {
#line 198
    tmp = (url->url)->data;
  }
#line 198
  cp = tmp;
#line 200
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 201
    return;
  }
  {
#line 203
  tmp___0 = strncmp((char const   *)cp, "gopher://", (size_t )9);
  }
#line 203
  if (tmp___0 != 0) {
#line 204
    return;
  }
  {
#line 207
  cp = strchr((char const   *)(cp + 10), '/');
  }
#line 209
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 210
    return;
  }
#line 217
  cp ++;
#line 220
  if ((int )*cp == 49) {
#line 220
    if ((int )*(cp + 1) == 49) {
#line 222
      *cp = (char )'h';
#line 223
      *(cp + 1) = (char )'h';
    }
  }
#line 225
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.c"
UrlServiceType URLgetService(Url *url ) 
{ 
  UrlServiceType st ;
  char *urlcp ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 237
  if ((unsigned int )url->service == 6U) {
#line 240
    if ((url->url)->len < 0) {
#line 240
      tmp = (char *)((void *)0);
    } else {
#line 240
      tmp = (url->url)->data;
    }
#line 240
    urlcp = tmp;
#line 242
    if ((unsigned long )urlcp == (unsigned long )((void *)0)) {
#line 243
      return ((UrlServiceType )7);
    }
    {
#line 245
    st = (UrlServiceType )7;
#line 247
    tmp___4 = strncasecmp("ftp:", (char const   *)urlcp, (size_t )4);
    }
#line 247
    if (tmp___4 == 0) {
#line 248
      st = (UrlServiceType )2;
    } else {
      {
#line 249
      tmp___3 = strncasecmp((char const   *)urlcp, "gopher:", (size_t )7);
      }
#line 249
      if (tmp___3 == 0) {
#line 250
        st = (UrlServiceType )0;
      } else {
        {
#line 251
        tmp___2 = strncasecmp((char const   *)urlcp, "telnet:", (size_t )7);
        }
#line 251
        if (tmp___2 == 0) {
#line 252
          st = (UrlServiceType )3;
        } else {
          {
#line 253
          tmp___1 = strncasecmp((char const   *)urlcp, "tn3270:", (size_t )7);
          }
#line 253
          if (tmp___1 == 0) {
#line 254
            st = (UrlServiceType )4;
          } else {
            {
#line 255
            tmp___0 = strncasecmp((char const   *)urlcp, "http:", (size_t )5);
            }
#line 255
            if (tmp___0 == 0) {
#line 256
              st = (UrlServiceType )1;
            }
          }
        }
      }
    }
#line 258
    url->service = st;
  }
#line 260
  return (url->service);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.c"
static boolean URLparse(Url *url ) 
{ 
  char *cp ;
  char *cp2 ;
  char *cp3 ;
  char *urlcp ;
  UrlServiceType serviceType ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *pass ;

  {
  {
#line 269
  serviceType = URLgetService(url);
  }
#line 271
  if ((unsigned int )serviceType == 7U) {
#line 272
    return (0);
  }
#line 274
  if ((url->url)->len < 0) {
#line 274
    tmp = (char *)((void *)0);
  } else {
#line 274
    tmp = (url->url)->data;
  }
#line 274
  urlcp = tmp;
#line 276
  if ((unsigned long )urlcp == (unsigned long )((void *)0)) {
#line 277
    return (0);
  }
  {
#line 279
  urlcp = strdup((char const   *)urlcp);
#line 281
  cp = strstr((char const   *)urlcp, "://");
  }
#line 283
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 284
    return (0);
  }
  {
#line 286
  cp += 3;
#line 288
  cp3 = strchr((char const   *)cp, '/');
  }
#line 290
  if ((unsigned long )cp3 == (unsigned long )((void *)0)) {
    {
#line 291
    tmp___0 = strlen((char const   *)cp);
#line 291
    cp3 = (cp + tmp___0) + 1;
#line 292
    STRset(url->Path, (char *)"/");
    }
  } else {
    {
#line 294
    Fromhexstr(cp3, cp3);
#line 295
    STRset(url->Path, cp3);
#line 296
    tmp___1 = cp3;
#line 296
    cp3 ++;
#line 296
    *tmp___1 = (char )'\000';
    }
  }
#line 300
  if ((unsigned int )serviceType == 0U) {
#line 301
    if ((unsigned long )cp3 != (unsigned long )((void *)0)) {
      {
#line 301
      tmp___4 = strlen((char const   *)cp3);
      }
#line 301
      if ((int )tmp___4 > 1) {
        {
#line 302
        tmp___2 = cp3;
#line 302
        cp3 ++;
#line 302
        url->Gtype = *tmp___2;
#line 303
        tmp___3 = cp3;
#line 303
        cp3 ++;
#line 303
        STRset(url->Path, tmp___3);
        }
      } else {
#line 305
        url->Gtype = (char )'1';
      }
    } else {
#line 305
      url->Gtype = (char )'1';
    }
  }
  {
#line 314
  cp2 = strchr((char const   *)cp, '@');
  }
#line 315
  if ((unsigned long )cp2 != (unsigned long )((void *)0)) {
#line 315
    if ((unsigned long )cp2 < (unsigned long )cp3) {
      {
#line 319
      *cp2 = (char )'\000';
#line 320
      cp2 ++;
#line 322
      pass = strchr((char const   *)cp, ':');
      }
#line 323
      if ((unsigned long )pass != (unsigned long )((void *)0)) {
#line 323
        if ((unsigned long )pass < (unsigned long )cp3) {
          {
#line 324
          *pass = (char )'\000';
#line 325
          pass ++;
#line 326
          Fromhexstr(pass, pass);
#line 328
          STRset(url->Pass, pass);
          }
        }
      }
      {
#line 331
      STRset(url->User, cp);
#line 333
      cp = cp2;
      }
    }
  }
  {
#line 340
  cp2 = strchr((char const   *)cp, ':');
  }
#line 342
  if ((unsigned long )cp2 != (unsigned long )((void *)0)) {
#line 342
    if ((unsigned long )cp2 < (unsigned long )cp3) {
      {
#line 343
      *cp2 = (char )'\000';
#line 344
      cp2 ++;
#line 345
      url->Port = atoi((char const   *)cp2);
#line 346
      STRset(url->Host, cp);
      }
    } else {
#line 342
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 349
    if ((unsigned int )serviceType == 1U) {
#line 349
      goto case_1;
    }
#line 353
    if ((unsigned int )serviceType == 4U) {
#line 353
      goto case_4;
    }
#line 353
    if ((unsigned int )serviceType == 3U) {
#line 353
      goto case_4;
    }
#line 356
    if ((unsigned int )serviceType == 0U) {
#line 356
      goto case_0;
    }
#line 359
    if ((unsigned int )serviceType == 5U) {
#line 359
      goto case_5;
    }
#line 364
    if ((unsigned int )serviceType == 7U) {
#line 364
      goto case_7;
    }
#line 364
    if ((unsigned int )serviceType == 6U) {
#line 364
      goto case_7;
    }
#line 364
    if ((unsigned int )serviceType == 2U) {
#line 364
      goto case_7;
    }
#line 348
    goto switch_break;
    case_1: /* CIL Label */ 
#line 350
    url->Port = 80;
#line 351
    goto switch_break;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 354
    url->Port = 23;
#line 355
    goto switch_break;
    case_0: /* CIL Label */ 
#line 357
    url->Port = 70;
#line 358
    goto switch_break;
    case_5: /* CIL Label */ 
#line 360
    url->Port = 119;
#line 361
    goto switch_break;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 365
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 367
    STRset(url->Host, cp);
    }
  }
#line 371
  return (1);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.c"
char *URLgetHost(Url *url ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 379
  if ((url->Host)->len < 0) {
#line 379
    tmp = (char *)((void *)0);
  } else {
#line 379
    tmp = (url->Host)->data;
  }
#line 379
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 380
    URLparse(url);
    }
  }
#line 382
  if ((url->Host)->len < 0) {
#line 382
    tmp___0 = (char *)((void *)0);
  } else {
#line 382
    tmp___0 = (url->Host)->data;
  }
#line 382
  return (tmp___0);
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.c"
int URLgetPort(Url *url ) 
{ 


  {
#line 388
  if (url->Port == -1) {
    {
#line 389
    URLparse(url);
    }
  }
#line 391
  return (url->Port);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.c"
char *URLgetPath(Url *url ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 398
  if ((url->Path)->len < 0) {
#line 398
    tmp = (char *)((void *)0);
  } else {
#line 398
    tmp = (url->Path)->data;
  }
#line 398
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 399
    URLparse(url);
    }
  }
#line 400
  if ((url->Path)->len < 0) {
#line 400
    tmp___0 = (char *)((void *)0);
  } else {
#line 400
    tmp___0 = (url->Path)->data;
  }
#line 400
  return (tmp___0);
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.c"
char *URLgetUser(Url *url ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 406
  if ((url->User)->len < 0) {
#line 406
    tmp = (char *)((void *)0);
  } else {
#line 406
    tmp = (url->User)->data;
  }
#line 406
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 407
    URLparse(url);
    }
  }
#line 408
  if ((url->User)->len < 0) {
#line 408
    tmp___0 = (char *)((void *)0);
  } else {
#line 408
    tmp___0 = (url->User)->data;
  }
#line 408
  return (tmp___0);
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.c"
char *URLgetPass(Url *url ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 414
  if ((url->Pass)->len < 0) {
#line 414
    tmp = (char *)((void *)0);
  } else {
#line 414
    tmp = (url->Pass)->data;
  }
#line 414
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 415
    URLparse(url);
    }
  }
#line 416
  if ((url->Pass)->len < 0) {
#line 416
    tmp___0 = (char *)((void *)0);
  } else {
#line 416
    tmp___0 = (url->Pass)->data;
  }
#line 416
  return (tmp___0);
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.c"
char URLgetGophType(Url *url ) 
{ 
  UrlServiceType tmp ;

  {
  {
#line 423
  tmp = URLgetService(url);
  }
#line 423
  if ((unsigned int )tmp != 0U) {
#line 424
    return ((char )'\000');
  }
#line 426
  if ((int )url->Gtype == 0) {
    {
#line 427
    URLparse(url);
    }
  }
#line 428
  return (url->Gtype);
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 70 "../object/util.h"
int readn(int fd , char *ptr___0 , int nbytes ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gophfilt/gophfilt.c"
GopherObj *Oneshot  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gophfilt/gophfilt.c"
int DEBUG  =    0;
#line 22
void timeout(void) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gophfilt/gophfilt.c"
int main(int argc , char **argv___1 ) 
{ 
  int manual ;
  int path ;
  int type ;
  unsigned int timer ;
  char *host ;
  int port ;
  char *item ;
  int c ;
  int x ;
  int numread ;
  int sockfd ;
  char buf[1024] ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 47
  manual = 0;
#line 48
  path = 0;
#line 49
  type = 0;
#line 50
  timer = 10U;
#line 51
  host = (char *)"gopherproject.org";
#line 52
  port = 70;
#line 53
  item = (char *)"";
#line 54
  x = 0;
#line 60
  Oneshot = GSnew();
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 62
    c = getopt(argc, (char * const  *)argv___1, "h:s:p:i:t:T:");
    }
#line 62
    if (! (c != -1)) {
#line 62
      goto while_break;
    }
    {
#line 64
    if (c == 115) {
#line 64
      goto case_115;
    }
#line 68
    if (c == 112) {
#line 68
      goto case_112;
    }
#line 73
    if (c == 104) {
#line 73
      goto case_104;
    }
#line 77
    if (c == 84) {
#line 77
      goto case_84;
    }
#line 80
    if (c == 116) {
#line 80
      goto case_116;
    }
#line 85
    if (c == 105) {
#line 85
      goto case_105;
    }
#line 90
    goto switch_default;
    case_115: /* CIL Label */ 
    {
#line 65
    port = atoi((char const   *)optarg);
#line 66
    manual ++;
    }
#line 67
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 69
    STRset(Oneshot->Selstr, optarg);
#line 70
    manual ++;
#line 71
    path ++;
    }
#line 72
    goto switch_break;
    case_104: /* CIL Label */ 
#line 74
    host = optarg;
#line 75
    manual ++;
#line 76
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 78
    tmp = atoi((char const   *)optarg);
#line 78
    timer = (unsigned int )tmp;
    }
#line 79
    goto switch_break;
    case_116: /* CIL Label */ 
#line 81
    Oneshot->sFileType = *optarg;
#line 82
    manual ++;
#line 83
    type ++;
#line 84
    goto switch_break;
    case_105: /* CIL Label */ 
#line 86
    item = optarg;
#line 87
    manual ++;
#line 88
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 95
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (optind < argc) {
    {
#line 101
    tmp___1 = strchr((char const   *)*(argv___1 + optind), ':');
    }
#line 101
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
#line 103
      x = GSfromURL(Oneshot, *(argv___1 + optind), (char *)"gopher-gw.micro.umn.edu",
                    70, x);
#line 104
      manual += x;
      }
#line 105
      if (x & 1) {
#line 106
        path ++;
      }
#line 107
      if (x & 2) {
#line 108
        type ++;
      }
#line 109
      if (x & 16) {
#line 110
        if ((Oneshot->Host)->len < 0) {
#line 110
          tmp___0 = (char *)((void *)0);
        } else {
#line 110
          tmp___0 = (Oneshot->Host)->data;
        }
#line 110
        host = tmp___0;
      }
#line 111
      if (x & 8) {
#line 112
        port = Oneshot->iPort;
      }
    }
  }
  {
#line 117
  Oneshot->iPort = port;
#line 118
  STRset(Oneshot->Host, host);
  }
#line 122
  if (manual) {
#line 122
    if (! path) {
#line 128
      return (-2);
    } else
#line 122
    if (! type) {
#line 128
      return (-2);
    }
  }
#line 134
  if (! manual) {
    {
#line 135
    tmp___2 = GSfromNet(Oneshot, 0);
    }
#line 135
    if (tmp___2 < 0) {
#line 142
      return (-3);
    }
  }
  {
#line 162
  if ((int )Oneshot->sFileType == 73) {
#line 162
    goto case_73;
  }
#line 162
  if ((int )Oneshot->sFileType == 77) {
#line 162
    goto case_73;
  }
#line 162
  if ((int )Oneshot->sFileType == 104) {
#line 162
    goto case_73;
  }
#line 162
  if ((int )Oneshot->sFileType == 103) {
#line 162
    goto case_73;
  }
#line 162
  if ((int )Oneshot->sFileType == 57) {
#line 162
    goto case_73;
  }
#line 162
  if ((int )Oneshot->sFileType == 115) {
#line 162
    goto case_73;
  }
#line 162
  if ((int )Oneshot->sFileType == 55) {
#line 162
    goto case_73;
  }
#line 162
  if ((int )Oneshot->sFileType == 50) {
#line 162
    goto case_73;
  }
#line 162
  if ((int )Oneshot->sFileType == 53) {
#line 162
    goto case_73;
  }
#line 162
  if ((int )Oneshot->sFileType == 52) {
#line 162
    goto case_73;
  }
#line 162
  if ((int )Oneshot->sFileType == 49) {
#line 162
    goto case_73;
  }
#line 162
  if ((int )Oneshot->sFileType == 48) {
#line 162
    goto case_73;
  }
#line 164
  goto switch_default___0;
  case_73: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_104___0: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_115___0: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 163
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 169
  return (-4);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 175
  sockfd = GSconnect(Oneshot);
  }
#line 175
  if (sockfd < 0) {
#line 181
    return (-5);
  }
#line 187
  if ((Oneshot->Selstr)->len < 0) {
#line 187
    tmp___3 = (char *)((void *)0);
  } else {
#line 187
    tmp___3 = (Oneshot->Selstr)->data;
  }
  {
#line 187
  writestring(sockfd, tmp___3);
#line 188
  tmp___4 = strlen((char const   *)item);
  }
#line 188
  if (tmp___4) {
    {
#line 189
    writestring(sockfd, (char *)"\t");
#line 190
    writestring(sockfd, item);
    }
  }
  {
#line 192
  writestring(sockfd, (char *)"\r\n");
#line 196
  signal(14, (void (*)(int  ))(& timeout));
#line 197
  alarm(timer);
  }
  {
#line 204
  if ((int )Oneshot->sFileType == 55) {
#line 204
    goto case_55___0;
  }
#line 204
  if ((int )Oneshot->sFileType == 52) {
#line 204
    goto case_55___0;
  }
#line 204
  if ((int )Oneshot->sFileType == 49) {
#line 204
    goto case_55___0;
  }
#line 204
  if ((int )Oneshot->sFileType == 48) {
#line 204
    goto case_55___0;
  }
#line 222
  if ((int )Oneshot->sFileType == 53) {
#line 222
    goto case_53___0;
  }
#line 222
  if ((int )Oneshot->sFileType == 57) {
#line 222
    goto case_53___0;
  }
#line 222
  if ((int )Oneshot->sFileType == 103) {
#line 222
    goto case_53___0;
  }
#line 222
  if ((int )Oneshot->sFileType == 73) {
#line 222
    goto case_53___0;
  }
#line 222
  if ((int )Oneshot->sFileType == 115) {
#line 222
    goto case_53___0;
  }
#line 199
  goto switch_break___1;
  case_55___0: /* CIL Label */ 
  case_52___0: /* CIL Label */ 
  case_49___0: /* CIL Label */ 
  case_48___0: /* CIL Label */ 
  {
#line 206
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 206
    tmp___5 = readline(sockfd, buf, (int )sizeof(buf));
    }
#line 206
    if (! (tmp___5 > 0)) {
#line 206
      goto while_break___0;
    }
    {
#line 207
    alarm(0U);
#line 208
    alarm(timer);
#line 209
    ZapCRLF(buf);
    }
#line 210
    if ((int )buf[0] == 46) {
#line 210
      if ((int )*(buf + 1) == 0) {
#line 211
        goto while_break___0;
      }
    }
    {
#line 212
    fputs((char const   */* __restrict  */)(buf), (FILE */* __restrict  */)stdout);
#line 213
    _IO_putc('\n', stdout);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 216
  goto switch_break___1;
  case_53___0: /* CIL Label */ 
  case_57___0: /* CIL Label */ 
  case_103___0: /* CIL Label */ 
  case_73___0: /* CIL Label */ 
  case_115___1: /* CIL Label */ 
  {
#line 224
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 224
    numread = readn(sockfd, buf, (int )sizeof(buf));
    }
#line 224
    if (! (numread > 0)) {
#line 224
      goto while_break___1;
    }
    {
#line 225
    alarm(0U);
#line 226
    alarm(timer);
#line 227
    tmp___6 = fwrite((void const   */* __restrict  */)(buf), (size_t )numread, (size_t )1,
                     (FILE */* __restrict  */)stdout);
    }
#line 227
    if (tmp___6 == 0UL) {
      {
#line 228
      close(sockfd);
      }
#line 232
      return (-6);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 236
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 239
  close(sockfd);
#line 240
  alarm(0U);
  }
#line 244
  return (0);
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gophfilt/gophfilt.c"
void timeout(void) 
{ 


  {
  {
#line 256
  exit(-7);
  }
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 764
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) vfork)(void) ;
#line 97 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.h"
int interruptable_read(int fd , char *ptr___0 , int nbytes ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 177 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.h"
FileIO *FIOopenUFS(char *fname , int flags , int mode ) ;
#line 178
FileIO *FIOopenfd(int fd , int issocket ) ;
#line 179
FileIO *FIOopenProcess(char *prog , char **args , char *rw ) ;
#line 180
FileIO *FIOopenCmdline(char *cmd , char *rw ) ;
#line 181
int FIOclose(FileIO *fio ) ;
#line 182
int FIOwriten(FileIO *fio , char *ptr___0 , int nbytes ) ;
#line 183
int FIOwritestring(FileIO *fio , char *str ) ;
#line 184
int FIOreadbuf(FileIO *fio , char *newbuf , int newbuflen ) ;
#line 185
int FIOreadn(FileIO *fio , char *ptr___0 , int nbytes ) ;
#line 186
int FIOreadline(FileIO *fio , char *ptr___0 , int maxlen ) ;
#line 188
int FIOreadtoken(FileIO *fio , char *ptr___0 , int maxlen , char zechar ) ;
#line 189
int FIOwaitpid(FileIO *fio ) ;
#line 190
int FIOsystem(char *cmd ) ;
#line 191
void FIOdestroy(FileIO *fio ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 94
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) madvise)(void *__addr ,
                                                                              size_t __len ,
                                                                              int __advice ) ;
#line 183 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static char **FIOgetargv(char *cmd ) ;
#line 190 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static FileIO *FIOusedfios[64]  ;
#line 191 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static int FIOnumusedfios  =    -1;
#line 197 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static FileIO *FIOpopUsedfio(void) 
{ 


  {
#line 199
  if (FIOnumusedfios > 0) {
#line 200
    FIOnumusedfios --;
#line 200
    return (FIOusedfios[FIOnumusedfios]);
  } else {
#line 202
    return ((FileIO *)((void *)0));
  }
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static boolean FIOpushUsedfio(FileIO *oldfio ) 
{ 
  int tmp ;

  {
#line 211
  if (FIOnumusedfios < 64) {
#line 212
    tmp = FIOnumusedfios;
#line 212
    FIOnumusedfios ++;
#line 212
    FIOusedfios[tmp] = oldfio;
#line 213
    return (0);
  } else {
#line 215
    return (-1);
  }
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static FileIO *FIOnew(void) 
{ 
  FileIO *temp ;
  int i ;
  void *tmp ;

  {
#line 223
  if (FIOnumusedfios == -1) {
#line 226
    i = 0;
    {
#line 226
    while (1) {
      while_continue: /* CIL Label */ ;
#line 226
      if (! (i < 64)) {
#line 226
        goto while_break;
      }
#line 227
      FIOusedfios[i] = (FileIO *)((void *)0);
#line 226
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 229
    FIOnumusedfios = 0;
  }
  {
#line 232
  temp = FIOpopUsedfio();
  }
#line 233
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 234
    tmp = malloc(sizeof(FileIO ));
#line 234
    temp = (FileIO *)tmp;
#line 235
    temp->filename = STRnew();
    }
  } else {
    {
#line 237
    STRinit(temp->filename);
    }
  }
  {
#line 241
  temp->issocket = -1;
#line 242
  temp->pid = -1;
#line 243
  temp->fd = -1;
#line 244
  temp->buf = (char *)((void *)0);
#line 246
  temp->bufindex = -1;
#line 247
  temp->bufdatasize = -1;
#line 248
  temp->filename = STRnew();
  }
#line 251
  return (temp);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
void FIOdestroy(FileIO *fio ) 
{ 
  boolean tmp ;

  {
  {
#line 262
  tmp = FIOpushUsedfio(fio);
  }
#line 262
  if (tmp) {
    {
#line 264
    free((void *)fio);
    }
  }
#line 266
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
FileIO *FIOopenUFS(char *fname , int flags , int mode ) 
{ 
  int fd ;
  FileIO *fio ;
  struct stat buf ;
  int tmp ;

  {
#line 279
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 280
    return ((FileIO *)((void *)0));
  }
  {
#line 283
  fd = open((char const   *)fname, flags, mode);
  }
#line 285
  if (fd < 0) {
#line 286
    return ((FileIO *)((void *)0));
  }
  {
#line 288
  tmp = fstat(fd, & buf);
  }
#line 288
  if (tmp) {
    {
#line 289
    close(fd);
    }
#line 290
    return ((FileIO *)((void *)0));
  }
  {
#line 293
  fio = FIOnew();
#line 295
  fio->issocket = 0;
#line 296
  STRset(fio->filename, fname);
#line 297
  fio->fd = fd;
  }
#line 299
  return (fio);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
FileIO *FIOopenfd(int fd , int issocket ) 
{ 
  FileIO *fio ;

  {
  {
#line 312
  fio = FIOnew();
#line 314
  fio->fd = fd;
#line 315
  fio->issocket = issocket;
  }
#line 316
  return (fio);
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
FileIO *FIOopenProcess(char *prog , char **args , char *rw ) 
{ 
  int pfd[2] ;
  int pid ;
  FileIO *fio ;
  int tmp ;

  {
#line 326
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
#line 327
    return ((FileIO *)((void *)0));
  }
  {
#line 329
  fio = FIOnew();
#line 331
  dup(0);
#line 333
  tmp = pipe((int *)(pfd));
  }
#line 333
  if (tmp < 0) {
#line 334
    return ((FileIO *)((void *)0));
  }
  {
#line 337
  pid = vfork();
  }
  {
#line 338
  if (pid == -1) {
#line 338
    goto case_neg_1;
  }
#line 342
  if (pid == 0) {
#line 342
    goto case_0;
  }
#line 337
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 339
  close(pfd[0]);
#line 340
  close(pfd[1]);
  }
#line 341
  goto switch_break;
  case_0: /* CIL Label */ 
#line 343
  if ((unsigned long )rw == (unsigned long )((void *)0)) {
    {
#line 345
    close(pfd[0]);
#line 346
    close(pfd[1]);
    }
  } else
#line 343
  if ((int )*rw == 0) {
    {
#line 345
    close(pfd[0]);
#line 346
    close(pfd[1]);
    }
  } else
#line 348
  if ((int )*rw == 114) {
#line 349
    if (pfd[1] != 1) {
      {
#line 350
      dup2(pfd[1], 1);
#line 351
      close(pfd[1]);
      }
    }
    {
#line 354
    close(pfd[0]);
    }
  } else {
#line 356
    if (pfd[0] != 0) {
      {
#line 357
      dup2(pfd[0], 0);
#line 358
      close(pfd[0]);
      }
    }
    {
#line 360
    close(pfd[1]);
    }
  }
#line 367
  if ((int )*prog == 47) {
    {
#line 368
    execv((char const   *)prog, (char * const  *)args);
    }
  } else {
    {
#line 370
    execvp((char const   *)prog, (char * const  *)args);
    }
  }
  {
#line 373
  _exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 377
  if ((unsigned long )rw == (unsigned long )((void *)0)) {
    {
#line 379
    fio->fd = -1;
#line 380
    close(pfd[0]);
#line 381
    close(pfd[1]);
    }
  } else
#line 377
  if ((int )*rw == 0) {
    {
#line 379
    fio->fd = -1;
#line 380
    close(pfd[0]);
#line 381
    close(pfd[1]);
    }
  } else
#line 382
  if ((int )*rw == 114) {
    {
#line 383
    fio->fd = pfd[0];
#line 384
    close(pfd[1]);
    }
  } else {
    {
#line 386
    fio->fd = pfd[1];
#line 387
    close(pfd[0]);
    }
  }
#line 389
  fio->pid = pid;
#line 390
  fio->issocket = 0;
#line 391
  return (fio);
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
int FIOclose(FileIO *fio ) 
{ 
  int result ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 404
  if ((unsigned long )fio == (unsigned long )((void *)0)) {
#line 405
    return (0);
  }
#line 407
  if (fio->pid >= 0) {
    {
#line 409
    close(fio->fd);
#line 410
    result = FIOwaitpid(fio);
#line 411
    FIOdestroy(fio);
    }
#line 413
    return (result);
  }
#line 419
  if ((fio->filename)->len < 0) {
#line 419
    tmp = (char *)((void *)0);
  } else {
#line 419
    tmp = (fio->filename)->data;
  }
#line 419
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 419
    if ((unsigned long )fio->buf != (unsigned long )((void *)0)) {
      {
#line 420
      munmap((void *)fio->buf, (size_t )fio->bufdatasize);
      }
    }
  }
#line 424
  if (fio->issocket) {
    {
#line 424
    tmp___0 = close(fio->fd);
#line 424
    result = tmp___0;
    }
  } else {
    {
#line 424
    tmp___1 = close(fio->fd);
#line 424
    result = tmp___1;
    }
  }
  {
#line 427
  FIOdestroy(fio);
  }
#line 429
  return (result);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
int FIOwaitpid(FileIO *fio ) 
{ 
  Portawait status ;
  pid_t result ;
  int *tmp ;
  int *tmp___0 ;
  union __anonunion_53 __constr_expr_1 ;
  union __anonunion_55 __constr_expr_3 ;
  int tmp___1 ;
  union __anonunion_56 __constr_expr_4 ;
  int tmp___2 ;
  union __anonunion_57 __constr_expr_5 ;

  {
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 446
    tmp = __errno_location();
#line 446
    *tmp = 0;
#line 447
    result = waitpid(fio->pid, & status, 0);
    }
#line 445
    if (result != fio->pid) {
      {
#line 445
      tmp___0 = __errno_location();
      }
#line 445
      if (! (*tmp___0 == 10)) {
#line 445
        goto while_break;
      }
    } else {
#line 445
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  __constr_expr_5.__in = status;
#line 450
  if ((__constr_expr_5.__i & 127) == 0) {
#line 450
    __constr_expr_1.__in = status;
#line 450
    tmp___2 = (__constr_expr_1.__i & 65280) >> 8;
  } else {
#line 450
    __constr_expr_4.__in = status;
#line 450
    if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 450
      __constr_expr_3.__in = status;
#line 450
      tmp___1 = __constr_expr_3.__i & 127;
    } else {
#line 450
      tmp___1 = 0;
    }
#line 450
    tmp___2 = tmp___1;
  }
#line 450
  return (tmp___2 & 15);
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
int FIOwriten(FileIO *fio , char *ptr___0 , int nbytes ) 
{ 
  int nleft ;
  int nwritten ;
  int fd ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 463
  fd = fio->fd;
#line 465
  nleft = nbytes;
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 466
    if (! (nleft > 0)) {
#line 466
      goto while_break;
    }
#line 467
    if (fio->issocket) {
      {
#line 467
      tmp = write(fd, (void const   *)ptr___0, (size_t )nleft);
#line 467
      nwritten = (int )tmp;
      }
    } else {
      {
#line 467
      tmp___0 = write(fd, (void const   *)ptr___0, (size_t )nleft);
#line 467
      nwritten = (int )tmp___0;
      }
    }
#line 470
    if (nwritten <= 0) {
#line 471
      return (nwritten);
    }
#line 473
    nleft -= nwritten;
#line 474
    ptr___0 += nwritten;
  }
  while_break: /* CIL Label */ ;
  }
#line 476
  return (nbytes - nleft);
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
int FIOwritestring(FileIO *fio , char *str ) 
{ 
  int length ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 492
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 493
    return (0);
  }
  {
#line 495
  tmp = strlen((char const   *)str);
#line 495
  length = (int )tmp;
#line 496
  tmp___0 = FIOwriten(fio, str, length);
  }
#line 496
  if (tmp___0 != length) {
#line 498
    return (-1);
  } else {
#line 501
    return (0);
  }
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static int FIOreadbuf_mmap(FileIO *fio , char *newbuf , int newbuflen ) 
{ 
  struct stat buf ;
  char *bytes ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 511
  if ((fio->filename)->len < 0) {
#line 511
    tmp___1 = (char *)((void *)0);
  } else {
#line 511
    tmp___1 = (fio->filename)->data;
  }
#line 511
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 514
    if ((unsigned long )fio->buf == (unsigned long )((void *)0)) {
      {
#line 515
      tmp = fstat(fio->fd, & buf);
      }
#line 515
      if (tmp) {
        {
#line 516
        close(fio->fd);
        }
#line 517
        return (-1);
      }
#line 520
      if (buf.st_size == 0L) {
#line 521
        return (0);
      }
      {
#line 523
      fio->bufdatasize = (int )buf.st_size;
#line 524
      fio->bufindex = 0;
#line 526
      tmp___0 = mmap((void *)0, (size_t )buf.st_size, 1, 1, fio->fd, (__off_t )0);
#line 526
      bytes = (char *)tmp___0;
#line 530
      madvise((void *)bytes, (size_t )buf.st_size, 2);
      }
#line 533
      if ((unsigned long )bytes == (unsigned long )((caddr_t )-1)) {
#line 534
        return (-1);
      }
#line 535
      fio->buf = bytes;
    }
#line 538
    if (fio->bufindex == -1) {
#line 539
      return (0);
    }
#line 542
    if (fio->bufindex >= fio->bufdatasize) {
#line 543
      return (0);
    }
#line 545
    if (fio->bufindex + newbuflen > fio->bufdatasize) {
#line 546
      newbuflen = fio->bufdatasize - fio->bufindex;
    }
    {
#line 548
    memcpy((void */* __restrict  */)newbuf, (void const   */* __restrict  */)(fio->buf + fio->bufindex),
           (size_t )newbuflen);
#line 549
    fio->bufindex += newbuflen;
    }
#line 551
    return (newbuflen);
  }
#line 554
  return (-1);
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
int FIOreadbuf(FileIO *fio , char *newbuf , int newbuflen ) 
{ 
  int len ;
  int fd ;
  char *recvbuf ;
  int bytesread ;
  int tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;

  {
#line 568
  fd = fio->fd;
#line 570
  bytesread = 0;
#line 573
  if ((fio->filename)->len < 0) {
#line 573
    tmp___0 = (char *)((void *)0);
  } else {
#line 573
    tmp___0 = (fio->filename)->data;
  }
#line 573
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 574
    tmp = FIOreadbuf_mmap(fio, newbuf, newbuflen);
    }
#line 574
    return (tmp);
  }
#line 578
  if (fio->bufindex == -1) {
#line 580
    if ((unsigned long )fio->buf == (unsigned long )((void *)0)) {
      {
#line 581
      tmp___1 = malloc(sizeof(char ) * 4096UL);
#line 581
      fio->buf = (char *)tmp___1;
      }
    }
#line 583
    if (fio->issocket) {
      {
#line 583
      tmp___2 = interruptable_read(fd, fio->buf, 4096);
#line 583
      len = tmp___2;
      }
    } else {
      {
#line 583
      tmp___3 = read(fd, (void *)fio->buf, (size_t )4096);
#line 583
      len = (int )tmp___3;
      }
    }
#line 593
    fio->bufdatasize = len;
#line 594
    fio->bufindex = 0;
#line 596
    if (len == 0) {
#line 597
      fio->bufindex = -1;
#line 598
      return (bytesread);
    }
  }
#line 602
  recvbuf = fio->buf;
  {
#line 604
  while (1) {
    while_continue: /* CIL Label */ ;
#line 604
    tmp___8 = newbuflen;
#line 604
    newbuflen --;
#line 604
    if (! tmp___8) {
#line 604
      goto while_break;
    }
#line 605
    tmp___4 = newbuf;
#line 605
    newbuf ++;
#line 605
    tmp___5 = fio->bufindex;
#line 605
    (fio->bufindex) ++;
#line 605
    *tmp___4 = *(recvbuf + tmp___5);
#line 606
    bytesread ++;
#line 608
    if (fio->bufindex == fio->bufdatasize) {
#line 608
      if (newbuflen != 0) {
#line 610
        if (fio->issocket) {
          {
#line 610
          tmp___6 = interruptable_read(fd, fio->buf, 4096);
#line 610
          len = tmp___6;
          }
        } else {
          {
#line 610
          tmp___7 = read(fd, (void *)fio->buf, (size_t )4096);
#line 610
          len = (int )tmp___7;
          }
        }
#line 619
        if (len == 0) {
#line 620
          fio->bufindex = -1;
#line 621
          return (bytesread);
        }
#line 623
        if (len < 0) {
#line 624
          return (len);
        }
#line 626
        fio->bufdatasize = len;
#line 627
        fio->bufindex = 0;
      } else {
#line 608
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 628
    if (fio->bufindex >= fio->bufdatasize) {
#line 630
      fio->bufindex = -1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  return (bytesread);
}
}
#line 638 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
int FIOreadn(FileIO *fio , char *ptr___0 , int nbytes ) 
{ 
  int nleft ;
  int nread ;
  int fd ;
  int tmp ;
  ssize_t tmp___0 ;

  {
#line 642
  fd = fio->fd;
#line 644
  nleft = nbytes;
  {
#line 645
  while (1) {
    while_continue: /* CIL Label */ ;
#line 645
    if (! (nleft > 0)) {
#line 645
      goto while_break;
    }
#line 646
    if (fio->issocket) {
      {
#line 646
      tmp = interruptable_read(fd, ptr___0, nleft);
#line 646
      nread = tmp;
      }
    } else {
      {
#line 646
      tmp___0 = read(fd, (void *)ptr___0, (size_t )nleft);
#line 646
      nread = (int )tmp___0;
      }
    }
#line 655
    if (nread < 0) {
#line 656
      return (nread);
    } else
#line 657
    if (nread == 0) {
#line 658
      goto while_break;
    }
#line 660
    nleft -= nread;
#line 661
    ptr___0 += nread;
  }
  while_break: /* CIL Label */ ;
  }
#line 663
  return (nbytes - nleft);
}
}
#line 676 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
int FIOreadline(FileIO *fio , char *ptr___0 , int maxlen ) 
{ 
  int bytesread ;
  int rc ;
  char c ;
  char *tmp ;

  {
#line 683
  bytesread = 1;
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    if (! (bytesread < maxlen)) {
#line 683
      goto while_break;
    }
    {
#line 684
    rc = FIOreadbuf(fio, & c, 1);
    }
#line 684
    if (rc == 1) {
#line 685
      tmp = ptr___0;
#line 685
      ptr___0 ++;
#line 685
      *tmp = c;
#line 686
      if ((int )c == 10) {
#line 687
        goto while_break;
      }
    } else
#line 689
    if (rc == 0) {
#line 690
      if (bytesread == 1) {
#line 691
        return (0);
      } else {
#line 693
        goto while_break;
      }
    } else {
#line 696
      return (rc);
    }
#line 683
    bytesread ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 699
  *ptr___0 = (char)0;
#line 702
  return (bytesread);
}
}
#line 713 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
int FIOreadlinezap(FileIO *fio , char *ptr___0 , int maxlen ) 
{ 
  int len ;

  {
  {
#line 718
  len = FIOreadtoken(fio, ptr___0, maxlen, (char )'\n');
#line 719
  ptr___0 += len;
#line 720
  ptr___0 --;
  }
#line 722
  if (len) {
#line 722
    if ((int )*ptr___0 == 13) {
#line 723
      *(ptr___0 + len) = (char )'\000';
#line 724
      len --;
    }
  }
#line 726
  return (len);
}
}
#line 737 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
int FIOreadtoken(FileIO *fio , char *ptr___0 , int maxlen , char zechar ) 
{ 
  int bytesread ;
  int rc ;
  char c ;
  char *tmp ;

  {
#line 744
  bytesread = 1;
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 744
    if (! (bytesread < maxlen)) {
#line 744
      goto while_break;
    }
    {
#line 745
    rc = FIOreadbuf(fio, & c, 1);
    }
#line 746
    if (rc == 1) {
#line 747
      tmp = ptr___0;
#line 747
      ptr___0 ++;
#line 747
      *tmp = c;
#line 748
      if ((int )c == (int )zechar) {
#line 749
        *(ptr___0 - 1) = (char )'\000';
#line 750
        goto while_break;
      }
    } else
#line 753
    if (rc == 0) {
#line 754
      if (bytesread == 1) {
#line 755
        return (0);
      } else {
#line 757
        goto while_break;
      }
    } else {
#line 760
      return (rc);
    }
#line 744
    bytesread ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 763
  *ptr___0 = (char)0;
#line 765
  return (bytesread);
}
}
#line 768 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static int FIOexecv(char *prog , char **args ) 
{ 
  FileIO *fio ;
  int result ;

  {
  {
#line 792
  fio = FIOopenProcess(prog, args, (char *)((void *)0));
#line 793
  result = FIOclose(fio);
  }
#line 796
  return (result);
}
}
#line 810 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static char *argv[256]  ;
#line 804 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static char **FIOgetargv(char *cmd ) 
{ 
  int inquote ;
  int insquote ;
  int i ;
  int argc ;
  char buf[256] ;
  char *cp ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 807
  inquote = 0;
#line 808
  insquote = 0;
#line 811
  argc = 0;
#line 813
  cp = buf;
#line 815
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 816
    return ((char **)((void *)0));
  } else {
    {
#line 815
    tmp = strlen((char const   *)cmd);
    }
#line 815
    if (tmp >= 245UL) {
#line 816
      return ((char **)((void *)0));
    }
  }
#line 818
  i = 0;
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! ((int )*(cmd + i) != 0)) {
#line 818
      goto while_break;
    }
    {
#line 822
    if ((int )*(cmd + i) == 9) {
#line 822
      goto case_9;
    }
#line 822
    if ((int )*(cmd + i) == 32) {
#line 822
      goto case_9;
    }
#line 838
    if ((int )*(cmd + i) == 34) {
#line 838
      goto case_34;
    }
#line 843
    if ((int )*(cmd + i) == 39) {
#line 843
      goto case_39;
    }
#line 848
    if ((int )*(cmd + i) == 92) {
#line 848
      goto case_92;
    }
#line 858
    goto switch_default;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 824
    if (insquote) {
#line 825
      *cp = *(cmd + i);
#line 825
      cp ++;
#line 826
      goto switch_break;
    } else
#line 824
    if (inquote) {
#line 825
      *cp = *(cmd + i);
#line 825
      cp ++;
#line 826
      goto switch_break;
    } else {
      {
#line 828
      *cp = (char )'\000';
#line 829
      tmp___0 = argc;
#line 829
      argc ++;
#line 829
      argv[tmp___0] = strdup((char const   *)(buf));
#line 830
      cp = buf;
      }
      {
#line 833
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 833
        if (! ((int )*(cmd + (i + 1)) == 32)) {
#line 833
          if (! ((int )*(cmd + (i + 1)) == 9)) {
#line 833
            goto while_break___0;
          }
        }
#line 834
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 836
    goto switch_break;
    case_34: /* CIL Label */ 
#line 839
    if (! insquote) {
#line 840
      inquote = 1 - inquote;
    }
#line 841
    goto switch_break;
    case_39: /* CIL Label */ 
#line 844
    if (! inquote) {
#line 845
      insquote = 1 - insquote;
    }
#line 846
    goto switch_break;
    case_92: /* CIL Label */ 
#line 850
    if (insquote) {
#line 851
      *cp = *(cmd + i);
#line 851
      cp ++;
    } else
#line 850
    if (inquote) {
#line 851
      *cp = *(cmd + i);
#line 851
      cp ++;
    } else {
#line 853
      *cp = *(cmd + (i + 1));
#line 853
      cp ++;
#line 853
      i ++;
    }
#line 856
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 859
    *cp = *(cmd + i);
#line 859
    cp ++;
#line 860
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 818
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 863
  if ((unsigned long )(buf) != (unsigned long )cp) {
    {
#line 864
    *cp = (char )'\000';
#line 865
    tmp___1 = argc;
#line 865
    argc ++;
#line 865
    argv[tmp___1] = strdup((char const   *)(buf));
    }
  }
#line 867
  argv[argc] = (char *)((void *)0);
#line 869
  return (argv);
}
}
#line 878 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
int FIOsystem(char *cmd ) 
{ 
  char **argv___1 ;
  int result ;
  int i ;

  {
#line 888
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 889
    return (-1);
  } else
#line 888
  if ((int )*cmd == 0) {
#line 889
    return (-1);
  }
  {
#line 891
  argv___1 = FIOgetargv(cmd);
#line 893
  result = FIOexecv(*(argv___1 + 0), argv___1);
#line 895
  i = 0;
  }
  {
#line 895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 895
    if (! ((unsigned long )*(argv___1 + i) != (unsigned long )((void *)0))) {
#line 895
      goto while_break;
    }
    {
#line 896
    free((void *)*(argv___1 + i));
#line 895
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 898
  return (result);
}
}
#line 908 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
FileIO *FIOopenCmdline(char *cmd , char *rw ) 
{ 
  char **argv___1 ;
  FileIO *fio ;

  {
#line 914
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 915
    return ((FileIO *)((void *)0));
  }
#line 917
  if ((int )*cmd == 124) {
#line 918
    cmd ++;
  }
  {
#line 920
  argv___1 = FIOgetargv(cmd);
#line 922
  fio = FIOopenProcess(*(argv___1 + 0), argv___1, rw);
  }
#line 924
  return (fio);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Debug.c"
void Debugf(char const   *fmt  , ...) 
{ 
  va_list args ;

  {
  {
#line 54
  __builtin_va_start(args, fmt);
#line 59
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           args);
  }
#line 60
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.h"
RBTree *RBTnew(int (*cmpfunc)() , void (*destroyfn)() ) ;
#line 93
void RBTdestroy(RBTree *rbt ) ;
#line 94
void RBTtraverse(RBTree *rbt , void (*func)() ) ;
#line 95
char *RBTfind(RBTree *rbt , char *data ) ;
#line 96
void RBTinsert(RBTree *thetree , char *data ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
RBTree *mytree  ;
#line 44
static void RBTleft_right(RBTree *thetree , RBTree_node *child , RBTree_node *parent ,
                          RBTree_node *grandparent , RBTree_node *great_grandparent ) ;
#line 50
static void RBTright_left(RBTree *thetree , RBTree_node *child , RBTree_node *parent ,
                          RBTree_node *grandparent , RBTree_node *great_grandparent ) ;
#line 57
static void RBTright_right(RBTree *thetree , RBTree_node *parent , RBTree_node *grandparent ,
                           RBTree_node *great_grandparent ) ;
#line 63
static void RBTleft_left(RBTree *thetree , RBTree_node *parent , RBTree_node *grandparent ,
                         RBTree_node *great_grandparent ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
RBTree_node *RBTNnew(void) 
{ 
  RBTree_node *temp ;
  void *tmp ;

  {
  {
#line 75
  tmp = malloc(sizeof(RBTree_node ));
#line 75
  temp = (RBTree_node *)tmp;
#line 77
  temp->last_pass = (direction )2;
#line 78
  temp->rb_right = (nodecolor )1;
#line 79
  temp->rb_left = (nodecolor )1;
#line 81
  temp->l_child = (struct RBTree_node_struct *)((void *)0);
#line 82
  temp->r_child = (struct RBTree_node_struct *)((void *)0);
  }
#line 84
  return (temp);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
void RBTdestroy_node(RBTree *thetree , RBTree_node *rbt_node ) 
{ 


  {
#line 91
  if ((unsigned long )rbt_node != (unsigned long )((void *)0)) {
    {
#line 92
    RBTdestroy_node(thetree, rbt_node->l_child);
#line 93
    RBTdestroy_node(thetree, rbt_node->r_child);
#line 95
    (*(thetree->destroyfn))(rbt_node->data);
#line 96
    free((void *)rbt_node);
    }
  }
#line 98
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
static void RBTred_sibling_ck(RBTree_node *child , RBTree_node *parent ) 
{ 


  {
#line 106
  if ((unsigned int )child->rb_right == 0U) {
#line 106
    if ((unsigned int )child->rb_left == 0U) {
#line 109
      child->rb_right = (nodecolor )1;
#line 110
      child->rb_left = (nodecolor )1;
#line 114
      if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 115
        if ((unsigned int )parent->last_pass == 0U) {
#line 116
          parent->rb_left = (nodecolor )0;
        } else {
#line 118
          parent->rb_right = (nodecolor )0;
        }
      }
    }
  }
#line 121
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
static int RBTbalance(RBTree *thetree , RBTree_node *child , RBTree_node *parent ,
                      RBTree_node *grandparent , RBTree_node *great_grandparent ) 
{ 


  {
#line 134
  if ((unsigned long )grandparent != (unsigned long )((void *)0)) {
#line 135
    if ((unsigned int )parent->last_pass == 0U) {
#line 136
      if ((unsigned int )parent->rb_left == 0U) {
#line 137
        if ((unsigned int )grandparent->last_pass == 0U) {
#line 138
          if ((unsigned int )grandparent->rb_left == 0U) {
            {
#line 139
            RBTleft_left(thetree, parent, grandparent, great_grandparent);
            }
#line 141
            return (1);
          }
        } else
#line 144
        if ((unsigned int )grandparent->rb_right == 0U) {
          {
#line 145
          RBTright_left(thetree, child, parent, grandparent, great_grandparent);
          }
#line 147
          return (1);
        }
      }
    } else
#line 151
    if ((unsigned int )parent->rb_right == 0U) {
#line 152
      if ((unsigned int )grandparent->last_pass == 0U) {
#line 153
        if ((unsigned int )grandparent->rb_left == 0U) {
          {
#line 154
          RBTleft_right(thetree, child, parent, grandparent, great_grandparent);
          }
#line 156
          return (1);
        }
      } else
#line 159
      if ((unsigned int )grandparent->rb_right == 0U) {
        {
#line 160
        RBTright_right(thetree, parent, grandparent, great_grandparent);
        }
#line 162
        return (1);
      }
    }
  }
#line 168
  return (0);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
static void RBTleft_right(RBTree *thetree , RBTree_node *child , RBTree_node *parent ,
                          RBTree_node *grandparent , RBTree_node *great_grandparent ) 
{ 
  RBTree_node *temp[2] ;

  {
#line 185
  if ((unsigned long )great_grandparent != (unsigned long )((void *)0)) {
#line 186
    if ((unsigned int )great_grandparent->last_pass == 1U) {
#line 187
      great_grandparent->r_child = child;
    } else {
#line 189
      great_grandparent->l_child = child;
    }
  } else {
#line 191
    thetree->entry = child;
  }
#line 193
  temp[0] = child->l_child;
#line 194
  temp[1] = child->r_child;
#line 196
  grandparent->l_child = temp[1];
#line 197
  parent->r_child = temp[0];
#line 198
  child->r_child = grandparent;
#line 199
  child->l_child = parent;
#line 202
  grandparent->rb_left = (nodecolor )1;
#line 203
  parent->rb_right = (nodecolor )1;
#line 204
  child->rb_left = (nodecolor )0;
#line 205
  child->rb_right = (nodecolor )0;
#line 206
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
static void RBTright_left(RBTree *thetree , RBTree_node *child , RBTree_node *parent ,
                          RBTree_node *grandparent , RBTree_node *great_grandparent ) 
{ 
  RBTree_node *temp[2] ;

  {
#line 222
  if ((unsigned long )great_grandparent != (unsigned long )((void *)0)) {
#line 223
    if ((unsigned int )great_grandparent->last_pass == 1U) {
#line 224
      great_grandparent->r_child = child;
    } else {
#line 226
      great_grandparent->l_child = child;
    }
  } else {
#line 229
    thetree->entry = child;
  }
#line 231
  temp[0] = child->l_child;
#line 232
  temp[1] = child->r_child;
#line 235
  grandparent->r_child = temp[0];
#line 236
  parent->l_child = temp[1];
#line 237
  child->l_child = grandparent;
#line 238
  child->r_child = parent;
#line 242
  grandparent->rb_right = (nodecolor )1;
#line 243
  parent->rb_left = (nodecolor )1;
#line 244
  child->rb_right = (nodecolor )0;
#line 245
  child->rb_left = (nodecolor )0;
#line 246
  return;
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
static void RBTright_right(RBTree *thetree , RBTree_node *parent , RBTree_node *grandparent ,
                           RBTree_node *great_grandparent ) 
{ 
  RBTree_node *temp ;

  {
#line 261
  if ((unsigned long )great_grandparent != (unsigned long )((void *)0)) {
#line 262
    if ((unsigned int )great_grandparent->last_pass == 1U) {
#line 263
      great_grandparent->r_child = parent;
    } else {
#line 265
      great_grandparent->l_child = parent;
    }
  } else {
#line 268
    thetree->entry = parent;
  }
#line 270
  temp = parent->l_child;
#line 271
  grandparent->r_child = temp;
#line 272
  parent->l_child = grandparent;
#line 276
  grandparent->rb_right = (nodecolor )1;
#line 277
  parent->rb_left = (nodecolor )0;
#line 278
  return;
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
static void RBTleft_left(RBTree *thetree , RBTree_node *parent , RBTree_node *grandparent ,
                         RBTree_node *great_grandparent ) 
{ 
  RBTree_node *temp ;

  {
#line 295
  if ((unsigned long )great_grandparent != (unsigned long )((void *)0)) {
#line 296
    great_grandparent->l_child = parent;
  } else {
#line 298
    thetree->entry = parent;
  }
#line 300
  temp = parent->r_child;
#line 301
  grandparent->l_child = temp;
#line 302
  parent->r_child = grandparent;
#line 304
  grandparent->rb_left = (nodecolor )1;
#line 305
  parent->rb_right = (nodecolor )0;
#line 307
  return;
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
void RBTinsert(RBTree *thetree , char *data ) 
{ 
  RBTree_node *data_node ;
  RBTree_node *local_root ;
  RBTree_node *current ;
  RBTree_node *parent ;
  RBTree_node *grandparent ;
  RBTree_node *great_grandparent ;
  boolean balanced ;
  int tmp ;

  {
  {
#line 317
  parent = (RBTree_node *)((void *)0);
#line 318
  grandparent = (RBTree_node *)((void *)0);
#line 319
  great_grandparent = (RBTree_node *)((void *)0);
#line 320
  balanced = 0;
#line 322
  data_node = RBTNnew();
#line 323
  data_node->data = data;
#line 325
  local_root = thetree->entry;
  }
#line 327
  if ((unsigned long )local_root == (unsigned long )((void *)0)) {
#line 328
    thetree->entry = data_node;
#line 329
    return;
  }
#line 333
  current = local_root;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! ((unsigned long )current != (unsigned long )((void *)0))) {
#line 335
      goto while_break;
    }
    {
#line 337
    RBTred_sibling_ck(current, parent);
    }
#line 339
    if (! balanced) {
      {
#line 340
      balanced = RBTbalance(thetree, current, parent, grandparent, great_grandparent);
      }
#line 343
      if (balanced == 0) {
#line 350
        great_grandparent = grandparent;
#line 351
        grandparent = parent;
      }
    }
    {
#line 354
    parent = current;
#line 356
    tmp = (*(thetree->cmpfn))(current->data, data);
    }
#line 356
    if (tmp > 0) {
#line 358
      current->last_pass = (direction )0;
#line 359
      current = current->l_child;
    } else {
#line 362
      current->last_pass = (direction )1;
#line 363
      current = current->r_child;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  if ((unsigned int )parent->last_pass == 0U) {
#line 368
    parent->l_child = data_node;
#line 369
    parent->rb_left = (nodecolor )0;
  } else {
#line 371
    parent->r_child = data_node;
#line 372
    parent->rb_right = (nodecolor )0;
  }
#line 374
  return;
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
RBTree *RBTnew(int (*cmpfunc)() , void (*destroyfn)() ) 
{ 
  RBTree *temp ;
  void *tmp ;

  {
  {
#line 385
  tmp = malloc(sizeof(RBTree ));
#line 385
  temp = (RBTree *)tmp;
  }
#line 387
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 388
    return ((RBTree *)((void *)0));
  }
#line 390
  temp->cmpfn = cmpfunc;
#line 391
  temp->destroyfn = destroyfn;
#line 392
  temp->entry = (RBTree_node *)((void *)0);
#line 394
  return (temp);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
void RBTdestroy(RBTree *rbt ) 
{ 


  {
  {
#line 400
  RBTdestroy_node(rbt, rbt->entry);
#line 401
  free((void *)rbt);
  }
#line 402
  return;
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
static void RBTinorder(RBTree_node *node , void (*func)() ) 
{ 


  {
#line 409
  if ((unsigned long )node != (unsigned long )((void *)0)) {
    {
#line 411
    RBTinorder(node->l_child, func);
#line 413
    (*func)(node->data);
#line 415
    RBTinorder(node->r_child, func);
    }
  }
#line 417
  return;
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
void RBTtraverse(RBTree *rbt , void (*func)() ) 
{ 


  {
  {
#line 422
  RBTinorder(rbt->entry, func);
  }
#line 423
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
char *RBTfind(RBTree *rbt , char *data ) 
{ 
  RBTree_node *rbt_node ;
  int whichway ;

  {
#line 429
  rbt_node = rbt->entry;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    whichway = (*(rbt->cmpfn))(data, rbt_node->data);
    }
#line 432
    if (! (whichway != 0)) {
#line 432
      goto while_break;
    }
#line 433
    if (whichway < 0) {
#line 434
      rbt_node = rbt_node->l_child;
    } else {
#line 436
      rbt_node = rbt_node->r_child;
    }
#line 438
    if ((unsigned long )rbt_node == (unsigned long )((void *)0)) {
#line 439
      return ((char *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return (rbt_node->data);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 126 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.h"
void BLsetGref(Blockobj *bl , GopherObj *gs ) ;
#line 127
void BLsetText(Blockobj *bl , StrArray *sta ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.c"
Blockobj *BLnew(void) 
{ 
  Blockobj *temp ;
  void *tmp ;

  {
  {
#line 92
  tmp = malloc(sizeof(Blockobj ));
#line 92
  temp = (Blockobj *)tmp;
#line 94
  temp->btype = (BlockType )0;
#line 95
  temp->Blockname = STRnew();
#line 96
  temp->datatype = (BlockDataType )0;
  }
#line 98
  return (temp);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.c"
void BLinit(Blockobj *bl ) 
{ 


  {
  {
#line 109
  STRinit(bl->Blockname);
  }
  {
#line 111
  if ((unsigned int )bl->datatype == 1U) {
#line 111
    goto case_1;
  }
#line 114
  if ((unsigned int )bl->datatype == 3U) {
#line 114
    goto case_3;
  }
#line 117
  if ((unsigned int )bl->datatype == 2U) {
#line 117
    goto case_2;
  }
#line 120
  if ((unsigned int )bl->datatype == 0U) {
#line 120
    goto case_0;
  }
#line 110
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 112
  STRinit(bl->data.filename);
  }
#line 113
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 115
  GSinit(bl->data.gs);
  }
#line 116
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 118
  DAinit(bl->data.text);
  }
#line 119
  goto switch_break;
  case_0: /* CIL Label */ 
#line 121
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.c"
static void BLdatadestroy(Blockobj *bl ) 
{ 


  {
  {
#line 135
  if ((unsigned int )bl->datatype == 1U) {
#line 135
    goto case_1;
  }
#line 138
  if ((unsigned int )bl->datatype == 2U) {
#line 138
    goto case_2;
  }
#line 141
  if ((unsigned int )bl->datatype == 3U) {
#line 141
    goto case_3;
  }
#line 144
  if ((unsigned int )bl->datatype == 0U) {
#line 144
    goto case_0;
  }
#line 134
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 136
  STRdestroy(bl->data.filename);
  }
#line 137
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 139
  DAdestroy(bl->data.text);
  }
#line 140
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 142
  GSdestroy(bl->data.gs);
  }
#line 143
  goto switch_break;
  case_0: /* CIL Label */ 
#line 145
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.c"
void BLdestroy(Blockobj *bl ) 
{ 


  {
  {
#line 156
  STRdestroy(bl->Blockname);
#line 157
  BLdatadestroy(bl);
#line 158
  free((void *)bl);
  }
#line 159
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.c"
void BLcpy(Blockobj *dest , Blockobj *orig ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 165
  if ((orig->Blockname)->len < 0) {
#line 165
    tmp = (char *)((void *)0);
  } else {
#line 165
    tmp = (orig->Blockname)->data;
  }
  {
#line 165
  STRset(dest->Blockname, tmp);
#line 166
  dest->btype = orig->btype;
  }
  {
#line 169
  if ((unsigned int )orig->datatype == 1U) {
#line 169
    goto case_1;
  }
#line 172
  if ((unsigned int )orig->datatype == 3U) {
#line 172
    goto case_3;
  }
#line 175
  if ((unsigned int )orig->datatype == 2U) {
#line 175
    goto case_2;
  }
#line 178
  if ((unsigned int )orig->datatype == 0U) {
#line 178
    goto case_0;
  }
#line 168
  goto switch_break;
  case_1: /* CIL Label */ 
#line 170
  if ((orig->data.filename)->len < 0) {
#line 170
    tmp___0 = (char *)((void *)0);
  } else {
#line 170
    tmp___0 = (orig->data.filename)->data;
  }
  {
#line 170
  BLsetFile(dest, tmp___0);
  }
#line 171
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 173
  BLsetGref(dest, orig->data.gs);
  }
#line 174
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 176
  BLsetText(dest, orig->data.text);
  }
#line 177
  goto switch_break;
  case_0: /* CIL Label */ 
#line 179
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 181
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.c"
int BLgetNumLines(Blockobj *bl ) 
{ 


  {
  {
#line 193
  if ((unsigned int )bl->datatype == 2U) {
#line 193
    goto case_2;
  }
#line 195
  goto switch_default;
  case_2: /* CIL Label */ 
#line 194
  return ((bl->data.text)->Top);
  switch_default: /* CIL Label */ 
#line 196
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.c"
char *BLgetLine(Blockobj *bl , int lineno ) 
{ 
  char *tmp ;

  {
  {
#line 210
  if ((unsigned int )bl->datatype == 2U) {
#line 210
    goto case_2;
  }
#line 214
  if ((unsigned int )bl->datatype == 3U) {
#line 214
    goto case_3;
  }
#line 214
  if ((unsigned int )bl->datatype == 1U) {
#line 214
    goto case_3;
  }
#line 214
  if ((unsigned int )bl->datatype == 0U) {
#line 214
    goto case_3;
  }
#line 209
  goto switch_break;
  case_2: /* CIL Label */ 
#line 211
  if (((String *)*((bl->data.text)->objects + lineno))->len < 0) {
#line 211
    tmp = (char *)((void *)0);
  } else {
#line 211
    tmp = ((String *)*((bl->data.text)->objects + lineno))->data;
  }
#line 211
  return (tmp);
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 215
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 217
  return ((char *)((void *)0));
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.c"
void BLsetFile(Blockobj *bl , char *filename ) 
{ 


  {
  {
#line 231
  BLdatadestroy(bl);
#line 233
  bl->datatype = (BlockDataType )1;
#line 234
  bl->data.filename = STRnew();
#line 236
  STRset(bl->data.filename, filename);
  }
#line 237
  return;
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.c"
void BLsetText(Blockobj *bl , StrArray *sta ) 
{ 


  {
#line 249
  if ((unsigned int )bl->datatype != 2U) {
    {
#line 250
    BLdatadestroy(bl);
#line 252
    bl->datatype = (BlockDataType )2;
#line 253
    bl->data.text = DAnew(10, & STRnew, & STRinit, & STRdestroy, & STRcpy);
    }
  }
#line 255
  if ((unsigned long )sta != (unsigned long )((void *)0)) {
    {
#line 256
    DAcpy(bl->data.text, sta);
    }
  }
#line 258
  return;
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.c"
void BLaddText(Blockobj *bl , char *text ) 
{ 
  String *tempstr ;

  {
  {
#line 270
  BLsetText(bl, (StrArray *)((void *)0));
#line 272
  tempstr = STRnew();
#line 274
  STRset(tempstr, text);
#line 275
  DApush(bl->data.text, (char *)tempstr);
#line 277
  STRdestroy(tempstr);
  }
#line 278
  return;
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.c"
void BLsetGref(Blockobj *bl , GopherObj *gs ) 
{ 


  {
  {
#line 288
  BLdatadestroy(bl);
#line 290
  bl->datatype = (BlockDataType )3;
#line 292
  bl->data.gs = GSnew();
#line 294
  GScpy(bl->data.gs, gs);
#line 296
  GSdestroy(gs);
  }
#line 297
  return;
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.c"
void BLtoNet(Blockobj *bl , int fd , boolean showheader ) 
{ 
  FILE *infile ;
  int i ;
  char outputline[512] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 314
  if (showheader) {
#line 315
    if ((bl->Blockname)->len < 0) {
#line 315
      tmp = (char *)((void *)0);
    } else {
#line 315
      tmp = (bl->Blockname)->data;
    }
    {
#line 315
    snprintf((char */* __restrict  */)(outputline), sizeof(outputline), (char const   */* __restrict  */)"+%s:",
             tmp);
#line 316
    writestring(fd, outputline);
    }
  }
  {
#line 321
  if ((unsigned int )bl->datatype == 3U) {
#line 321
    goto case_3;
  }
#line 326
  if ((unsigned int )bl->datatype == 2U) {
#line 326
    goto case_2;
  }
#line 335
  if ((unsigned int )bl->datatype == 1U) {
#line 335
    goto case_1;
  }
#line 349
  if ((unsigned int )bl->datatype == 0U) {
#line 349
    goto case_0;
  }
#line 319
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 322
  writestring(fd, (char *)" ");
#line 323
  GStoNet(bl->data.gs, fd, 0, (char *)((void *)0));
  }
#line 324
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 327
  writestring(fd, (char *)"\r\n");
#line 328
  i = 0;
  }
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! (i < (bl->data.text)->Top)) {
#line 328
      goto while_break;
    }
    {
#line 329
    writestring(fd, (char *)" ");
    }
#line 330
    if (((String *)*((bl->data.text)->objects + i))->len < 0) {
#line 330
      tmp___0 = (char *)((void *)0);
    } else {
#line 330
      tmp___0 = ((String *)*((bl->data.text)->objects + i))->data;
    }
    {
#line 330
    writestring(fd, tmp___0);
#line 331
    writestring(fd, (char *)"\r\n");
#line 328
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 336
  writestring(fd, (char *)"\r\n");
  }
#line 338
  if ((bl->data.filename)->len < 0) {
#line 338
    tmp___1 = (char *)((void *)0);
  } else {
#line 338
    tmp___1 = (bl->data.filename)->data;
  }
  {
#line 338
  infile = fopen((char const   */* __restrict  */)tmp___1, (char const   */* __restrict  */)"r");
  }
#line 338
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
#line 339
    goto switch_break;
  }
  {
#line 341
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 341
    tmp___2 = fgets((char */* __restrict  */)(outputline), (int )sizeof(outputline),
                    (FILE */* __restrict  */)infile);
    }
#line 341
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 341
      goto while_break___0;
    }
    {
#line 342
    ZapCRLF(outputline);
#line 343
    writestring(fd, (char *)" ");
#line 344
    writestring(fd, outputline);
#line 345
    writestring(fd, (char *)"\r\n");
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 347
  fclose(infile);
  }
#line 348
  goto switch_break;
  case_0: /* CIL Label */ 
#line 350
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 352
  return;
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.c"
int BLfromNet(Blockobj *bl , int fd , char *blockname ) 
{ 
  char inputline___0[512] ;
  int err ;
  GopherObj *gs ;

  {
  {
#line 377
  STRset(bl->Blockname, blockname);
#line 380
  err = readrecvbuf(fd, inputline___0, 1);
  }
#line 380
  if (err <= 0) {
#line 381
    return (err);
  }
#line 384
  if ((int )inputline___0[0] == 32) {
    {
#line 388
    gs = GSnew();
#line 389
    GSfromNet(gs, fd);
#line 390
    BLsetGref(bl, gs);
    }
    {
#line 392
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 393
      err = readrecvbuf(fd, inputline___0, 1);
      }
#line 393
      if (err <= 0) {
#line 394
        return (err);
      }
#line 395
      if ((int )inputline___0[0] == 43) {
#line 396
        return (1);
      } else {
        {
#line 398
        err = readline(fd, inputline___0, (int )sizeof(inputline___0));
        }
#line 399
        if (err <= 0) {
#line 400
          return (err);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 408
  readline(fd, inputline___0, (int )sizeof(inputline___0));
  }
  {
#line 412
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 414
    err = readrecvbuf(fd, inputline___0, 1);
    }
#line 414
    if (err <= 0) {
#line 415
      return (err);
    }
#line 417
    if ((int )inputline___0[0] == 43) {
#line 418
      return (1);
    }
#line 421
    if ((int )inputline___0[0] == 46) {
      {
#line 422
      readline(fd, inputline___0, (int )sizeof(inputline___0));
      }
#line 423
      return (0);
    }
#line 426
    if ((int )inputline___0[0] == 32) {
      {
#line 428
      readline(fd, inputline___0, (int )sizeof(inputline___0));
#line 429
      ZapCRLF(inputline___0);
#line 430
      BLaddText(bl, inputline___0);
      }
    } else {
      {
#line 434
      readline(fd, inputline___0, (int )sizeof(inputline___0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.c"
int BLAsearch(BlockArray *bla , char *bname ) 
{ 
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
#line 445
  if ((unsigned long )bla == (unsigned long )((void *)0)) {
#line 446
    return (-1);
  }
#line 448
  i = 0;
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 448
    if (! (i < bla->Top)) {
#line 448
      goto while_break;
    }
#line 449
    if ((((Blockobj *)*(bla->objects + i))->Blockname)->len < 0) {
#line 449
      tmp = (char *)((void *)0);
    } else {
#line 449
      tmp = (((Blockobj *)*(bla->objects + i))->Blockname)->data;
    }
    {
#line 449
    tmp___0 = strcmp((char const   *)tmp, (char const   *)bname);
    }
#line 449
    if (tmp___0 == 0) {
#line 450
      return (i);
    }
#line 448
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  return (-1);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/DAarray.h"
void DAsort(DynArray *da , int (*sortfn)() ) ;
#line 63
void DAgrow(DynArray *da , int size ) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/DAarray.c"
DynArray *DAnew(int size , char *(*newfn)() , void (*initfn)() , void (*destroyfn)() ,
                char *(*copyfn)() ) 
{ 
  DynArray *temp ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 74
  tmp = malloc(sizeof(DynArray ));
#line 74
  temp = (DynArray *)tmp;
#line 75
  tmp___0 = malloc((unsigned long )size * sizeof(char *));
#line 75
  temp->objects = (char **)tmp___0;
#line 76
  temp->newfn = newfn;
#line 77
  temp->initfn = initfn;
#line 78
  temp->destroyfn = destroyfn;
#line 79
  temp->copyfn = copyfn;
#line 80
  temp->Top = 0;
  }
#line 82
  if ((unsigned long )copyfn == (unsigned long )((void *)0)) {
    {
#line 84
    perror("Egad, no copy function in DAnew()!!");
    }
  }
#line 86
  if ((unsigned long )newfn != (unsigned long )((void *)0)) {
#line 87
    i = 0;
    {
#line 87
    while (1) {
      while_continue: /* CIL Label */ ;
#line 87
      if (! (i < size)) {
#line 87
        goto while_break;
      }
      {
#line 88
      tmp___1 = (*newfn)();
#line 88
      *(temp->objects + i) = tmp___1;
#line 87
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 90
  temp->maxsize = size;
#line 91
  return (temp);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/DAarray.c"
void DAdestroy(DynArray *da ) 
{ 
  int i ;

  {
#line 99
  if ((unsigned long )da->destroyfn != (unsigned long )((void *)0)) {
#line 100
    i = 0;
    {
#line 100
    while (1) {
      while_continue: /* CIL Label */ ;
#line 100
      if (! (i < da->maxsize)) {
#line 100
        goto while_break;
      }
      {
#line 101
      (*(da->destroyfn))(*(da->objects + i));
#line 100
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 103
  free((void *)da->objects);
#line 104
  free((void *)da);
  }
#line 105
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/DAarray.c"
void DAinit(DynArray *da ) 
{ 
  int i ;

  {
#line 113
  if ((unsigned long )da->initfn != (unsigned long )((void *)0)) {
#line 114
    i = 0;
    {
#line 114
    while (1) {
      while_continue: /* CIL Label */ ;
#line 114
      if (! (i < da->maxsize)) {
#line 114
        goto while_break;
      }
      {
#line 115
      (*(da->initfn))(*(da->objects + i));
#line 114
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 117
  da->Top = 0;
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/DAarray.c"
void DAgrow(DynArray *da , int size ) 
{ 
  char **temp ;
  int i ;
  void *tmp ;

  {
#line 126
  if (size < da->maxsize) {
#line 127
    return;
  }
  {
#line 129
  tmp = realloc((void *)da->objects, (unsigned long )size * sizeof(char *));
#line 129
  temp = (char **)tmp;
  }
#line 131
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 132
    perror("Out of memory!!!\n");
#line 132
    exit(-1);
    }
  }
#line 134
  if ((unsigned long )temp != (unsigned long )da->objects) {
#line 135
    da->objects = temp;
  }
#line 140
  i = da->maxsize;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < size)) {
#line 140
      goto while_break;
    }
    {
#line 141
    *(da->objects + i) = (*(da->newfn))();
#line 140
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  da->maxsize = size;
#line 144
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/DAarray.c"
void DApush(DynArray *da , char *obj ) 
{ 
  int top ;

  {
#line 156
  top = da->Top;
#line 158
  if (top == da->maxsize) {
    {
#line 159
    DAgrow(da, da->maxsize * 2);
    }
  }
  {
#line 161
  (*(da->copyfn))(*(da->objects + top), obj);
#line 163
  da->Top = top + 1;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/DAarray.c"
char *DApop(DynArray *da ) 
{ 
  int top ;
  char *newobj ;

  {
#line 172
  top = da->Top;
#line 174
  if (top == 0) {
#line 175
    return ((char *)((void *)0));
  }
  {
#line 177
  newobj = (*(da->newfn))();
#line 178
  (*(da->initfn))(newobj);
#line 180
  top --;
#line 181
  (*(da->copyfn))(newobj, *(da->objects + top));
#line 183
  da->Top = top;
  }
#line 185
  return (newobj);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/DAarray.c"
void DAsort(DynArray *da , int (*sortfn)() ) 
{ 
  char *moo ;

  {
  {
#line 193
  moo = (char *)(da->objects + 0);
#line 195
  qsort((void *)moo, (size_t )da->Top, sizeof(char *), (int (*)(void const   * , void const   * ))sortfn);
  }
#line 197
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/DAarray.c"
void DAcpy(DynArray *dest , DynArray *orig ) 
{ 
  int i ;

  {
#line 205
  dest->Top = 0;
#line 206
  dest->newfn = orig->newfn;
#line 207
  dest->initfn = orig->initfn;
#line 208
  dest->destroyfn = orig->destroyfn;
#line 209
  dest->copyfn = dest->copyfn;
#line 211
  i = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i < orig->Top)) {
#line 211
      goto while_break;
    }
    {
#line 212
    DApush(dest, *(orig->objects + i));
#line 211
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return;
}
}
#line 151 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcoll)(char const   *__s1 ,
                                                                                                char const   *__s2 )  __attribute__((__pure__)) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.h"
boolean ControlCpressed ;
#line 84 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.h"
GopherDirObj *GDnew(int size ) ;
#line 85
void GDdestroy(GopherDirObj *gd ) ;
#line 86
void GDinit(GopherDirObj *gd ) ;
#line 87
void GDsetLocation(GopherDirObj *gd , GopherObj *gs ) ;
#line 88
void GDaddGS(GopherDirObj *gd , GopherObj *gs ) ;
#line 89
void GDaddGSmerge(GopherDirObj *gd , GopherObj *gs ) ;
#line 90
void GDsort(GopherDirObj *gd ) ;
#line 91
void GDtoNet(GopherDirObj *gd , int sockfd , GSformat fmt , char *ticket , void (*prefcn)() ) ;
#line 93
void GDplustoNet(GopherDirObj *gd , int sockfd , char **filter , char *ticket ) ;
#line 95
void GDfromNet(GopherDirObj *gd , int sockfd , int (*eachitem)() ) ;
#line 96
int GDplusfromNet(GopherDirObj *gd , int fd , int (*eachitem)() ) ;
#line 98
void GDfromLink(GopherDirObj *gd , FileIO *fio , char *host , int port , char *directory ,
                char *peer ) ;
#line 99
void GDtoLink(GopherDirObj *gd , int fd ) ;
#line 100
GopherDirObj *GDdeleteGS(GopherDirObj *gd , int j ) ;
#line 101
int GDSearch(GopherDirObj *gd , char *text ) ;
#line 172 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
GopherDirObj *GDnew(int size ) 
{ 
  GopherDirObj *temp ;
  void *tmp ;

  {
  {
#line 177
  tmp = malloc(sizeof(GopherDirObj ));
#line 177
  temp = (GopherDirObj *)tmp;
#line 179
  temp->Gophers = DAnew(size, & GSnew, & GSinit, & GSdestroy, & GScpy);
#line 181
  temp->Title = STRnew();
#line 182
  temp->Location = (GopherObj *)((void *)0);
#line 183
  temp->currentitem = 1;
#line 185
  GDinit(temp);
  }
#line 186
  return (temp);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
void GDdestroy(GopherDirObj *gd ) 
{ 


  {
  {
#line 193
  DAdestroy(gd->Gophers);
  }
#line 194
  if ((unsigned long )gd->Location != (unsigned long )((void *)0)) {
    {
#line 195
    GSdestroy(gd->Location);
    }
  }
  {
#line 197
  STRdestroy(gd->Title);
#line 198
  free((void *)gd);
  }
#line 199
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
void GDinit(GopherDirObj *gd ) 
{ 


  {
  {
#line 205
  DAinit(gd->Gophers);
#line 206
  STRinit(gd->Title);
#line 207
  gd->Location = (GopherObj *)((void *)0);
  }
#line 208
  return;
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
void GDsetLocation(GopherDirObj *gd , GopherObj *gs ) 
{ 


  {
#line 214
  if ((unsigned long )gd->Location == (unsigned long )((void *)0)) {
    {
#line 215
    gd->Location = GSnew();
    }
  } else {
    {
#line 217
    GSinit(gd->Location);
    }
  }
  {
#line 219
  GScpy(gd->Location, gs);
  }
#line 220
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
void GDaddGSmerge(GopherDirObj *gd , GopherObj *gs ) 
{ 
  int num ;
  char *tmp ;

  {
#line 232
  if ((gs->Selstr)->len < 0) {
#line 232
    tmp = (char *)((void *)0);
  } else {
#line 232
    tmp = (gs->Selstr)->data;
  }
  {
#line 232
  num = GDSearch(gd, tmp);
  }
#line 234
  if (num == -1) {
    {
#line 235
    GDaddGS(gd, gs);
    }
  } else
#line 237
  if ((int )gs->sFileType == 88) {
    {
#line 238
    gd = GDdeleteGS(gd, num);
    }
  } else {
    {
#line 240
    GSmerge((GopherObj *)*((gd->Gophers)->objects + num), gs);
    }
  }
#line 242
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
void GDaddGS(GopherDirObj *gd , GopherObj *gs ) 
{ 


  {
#line 252
  if ((int )gs->sFileType != 88) {
    {
#line 253
    DApush(gd->Gophers, (char *)gs);
    }
  }
#line 254
  return;
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
static int GSqsortcmp(GopherObj **gs1 , GopherObj **gs2 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 267
  if (((*gs1)->Title)->len < 0) {
#line 267
    tmp = (char *)((void *)0);
  } else {
#line 267
    tmp = ((*gs1)->Title)->data;
  }
#line 267
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 268
    return (1);
  }
#line 269
  if (((*gs2)->Title)->len < 0) {
#line 269
    tmp___0 = (char *)((void *)0);
  } else {
#line 269
    tmp___0 = ((*gs2)->Title)->data;
  }
#line 269
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 270
    return (-1);
  }
#line 275
  if ((*gs1)->Itemnum == (*gs2)->Itemnum) {
#line 276
    if (((*gs2)->Title)->len < 0) {
#line 276
      tmp___1 = (char *)((void *)0);
    } else {
#line 276
      tmp___1 = ((*gs2)->Title)->data;
    }
#line 276
    if (((*gs1)->Title)->len < 0) {
#line 276
      tmp___2 = (char *)((void *)0);
    } else {
#line 276
      tmp___2 = ((*gs1)->Title)->data;
    }
    {
#line 276
    tmp___3 = strcoll((char const   *)tmp___2, (char const   *)tmp___1);
    }
#line 276
    return (tmp___3);
  }
#line 282
  if ((*gs1)->Itemnum == 0) {
#line 282
    tmp___6 = 0;
  } else {
#line 282
    if ((*gs1)->Itemnum < 0) {
#line 282
      tmp___5 = -1;
    } else {
#line 282
      tmp___5 = 1;
    }
#line 282
    tmp___6 = tmp___5;
  }
#line 282
  if ((*gs2)->Itemnum == 0) {
#line 282
    tmp___8 = 0;
  } else {
#line 282
    if ((*gs2)->Itemnum < 0) {
#line 282
      tmp___7 = -1;
    } else {
#line 282
      tmp___7 = 1;
    }
#line 282
    tmp___8 = tmp___7;
  }
#line 282
  if (tmp___6 == tmp___8) {
#line 283
    if ((*gs1)->Itemnum < (*gs2)->Itemnum) {
#line 283
      tmp___4 = -1;
    } else {
#line 283
      tmp___4 = 1;
    }
#line 283
    return (tmp___4);
  }
#line 287
  if ((*gs1)->Itemnum > (*gs2)->Itemnum) {
#line 287
    tmp___9 = -1;
  } else {
#line 287
    tmp___9 = 1;
  }
#line 287
  return (tmp___9);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
void GDsort(GopherDirObj *gd ) 
{ 


  {
  {
#line 298
  DAsort(gd->Gophers, (int (*)())(& GSqsortcmp));
  }
#line 299
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
void GDtoNet(GopherDirObj *gd , int sockfd , GSformat fmt , char *ticket , void (*prefcn)() ) 
{ 
  int i ;
  GopherObj *gs ;

  {
#line 310
  if (fmt == 2) {
    {
#line 311
    writestring(sockfd, (char *)"<DL COMPACT>\r\n");
    }
  }
#line 314
  i = 0;
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (i < (gd->Gophers)->Top)) {
#line 314
      goto while_break;
    }
#line 315
    gs = (GopherObj *)*((gd->Gophers)->objects + i);
#line 316
    if (fmt == 2) {
      {
#line 317
      writestring(sockfd, (char *)"<DT>");
      }
    }
#line 319
    if (prefcn) {
      {
#line 320
      (*prefcn)(gs, sockfd);
      }
    }
    {
#line 321
    GStoNet((GopherObj *)*((gd->Gophers)->objects + i), sockfd, fmt, ticket);
#line 314
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  if (fmt == 2) {
    {
#line 325
    writestring(sockfd, (char *)"</DL>\r\n");
    }
  }
#line 327
  return;
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
void GDplustoNet(GopherDirObj *gd , int sockfd , char **filter , char *ticket ) 
{ 
  int i ;

  {
#line 335
  i = 0;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! (i < (gd->Gophers)->Top)) {
#line 335
      goto while_break;
    }
    {
#line 336
    GSplustoNet((GopherObj *)*((gd->Gophers)->objects + i), sockfd, filter, ticket);
#line 335
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
static GopherObj *TempGopher  =    (GopherObj *)((void *)0);
#line 346 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
int GDplusfromNet(GopherDirObj *gd , int fd , int (*eachitem)() ) 
{ 
  int j ;
  int result ;
  char inputline___0[256] ;
  int tmp ;
  int tmp___0 ;

  {
#line 354
  if ((unsigned long )TempGopher == (unsigned long )((void *)0)) {
    {
#line 355
    TempGopher = GSnew();
    }
  }
  {
#line 359
  result = readrecvbuf(fd, inputline___0, 1);
  }
#line 360
  if (result <= 0) {
#line 361
    return (0);
  } else
#line 362
  if ((int )inputline___0[0] == 46) {
    {
#line 364
    readline(fd, inputline___0, (int )sizeof(inputline___0));
    }
#line 365
    return (0);
  } else
#line 367
  if ((int )inputline___0[0] != 43) {
#line 368
    return (0);
  }
  {
#line 373
  result = readtoken(fd, inputline___0, (int )sizeof(inputline___0), (char )':');
  }
#line 374
  if (result <= 0) {
#line 375
    return (result);
  }
  {
#line 378
  tmp = strcmp((char const   *)(inputline___0), "INFO");
  }
#line 378
  if (tmp != 0) {
#line 379
    return (0);
  }
  {
#line 383
  tmp___0 = readrecvbuf(fd, inputline___0, 1);
  }
#line 383
  if (tmp___0 <= 0) {
#line 384
    return (-2);
  }
#line 388
  j = 0;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! (! ControlCpressed)) {
#line 388
      goto while_break;
    }
    {
#line 392
    GSinit(TempGopher);
#line 393
    result = GSplusfromNet(TempGopher, fd);
    }
    {
#line 396
    if (result == 1) {
#line 396
      goto case_1;
    }
#line 402
    if (result == 0) {
#line 402
      goto case_0;
    }
#line 406
    if (result == -2) {
#line 406
      goto case_neg_2;
    }
#line 409
    if (result == -1) {
#line 409
      goto case_neg_1;
    }
#line 395
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 397
    GDaddGS(gd, TempGopher);
    }
#line 398
    if ((unsigned long )eachitem != (unsigned long )((void *)0)) {
      {
#line 399
      (*eachitem)();
      }
    }
#line 400
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 403
    GDaddGS(gd, TempGopher);
    }
#line 404
    return (j + 1);
    case_neg_2: /* CIL Label */ 
#line 407
    return (j);
    case_neg_1: /* CIL Label */ 
#line 410
    j --;
#line 411
    if (j < 0) {
#line 411
      j = 0;
    }
#line 412
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 388
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  ControlCpressed = 0;
#line 419
  return (j);
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
static GopherObj *TempGopher___0  ;
#line 430 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
void GDfromNet(GopherDirObj *gd , int sockfd , int (*eachitem)() ) 
{ 
  int i ;
  char *cp1 ;
  char *cp2 ;
  GopherObj *TempG2 ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 438
  if ((unsigned long )TempGopher___0 == (unsigned long )((void *)0)) {
    {
#line 439
    TempGopher___0 = GSnew();
    }
  }
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    if (! (! ControlCpressed)) {
#line 441
      goto while_break;
    }
    {
#line 443
    GSinit(TempGopher___0);
#line 444
    i = GSfromNet(TempGopher___0, sockfd);
    }
    {
#line 453
    if (i == 0) {
#line 453
      goto case_0;
    }
#line 475
    if (i == 1) {
#line 475
      goto case_1;
    }
#line 478
    if (i == -1) {
#line 478
      goto case_neg_1;
    }
#line 481
    if (i == -2) {
#line 481
      goto case_neg_2;
    }
#line 451
    goto switch_break;
    case_0: /* CIL Label */ 
#line 454
    if ((int )TempGopher___0->sFileType == 51) {
#line 454
      if ((TempGopher___0->Title)->len < 0) {
#line 454
        tmp___0 = (char *)((void *)0);
      } else {
#line 454
        tmp___0 = (TempGopher___0->Title)->data;
      }
#line 454
      cp1 = tmp___0;
#line 454
      if ((unsigned long )cp1 != (unsigned long )((void *)0)) {
        {
#line 454
        cp2 = strchr((char const   *)cp1, '\n');
        }
#line 454
        if ((unsigned long )cp2 != (unsigned long )((void *)0)) {
          {
#line 458
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 459
            TempG2 = GSnew();
#line 460
            GScpy(TempG2, TempGopher___0);
#line 461
            TempG2->sFileType = (char )'i';
#line 462
            STRset(TempG2->Title, cp2 + 1);
#line 463
            *cp2 = (char )'\000';
#line 464
            STRset(TempGopher___0->Title, cp1);
#line 465
            GDaddGS(gd, TempGopher___0);
#line 466
            TempGopher___0 = TempG2;
            }
#line 467
            if ((TempGopher___0->Title)->len < 0) {
#line 467
              tmp = (char *)((void *)0);
            } else {
#line 467
              tmp = (TempGopher___0->Title)->data;
            }
#line 467
            cp1 = tmp;
#line 467
            if ((unsigned long )cp1 == (unsigned long )((void *)0)) {
#line 468
              goto while_break___0;
            }
            {
#line 458
            cp2 = strchr((char const   *)cp1, '\n');
            }
#line 458
            if (! ((unsigned long )cp2 != (unsigned long )((void *)0))) {
#line 458
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 471
    GDaddGS(gd, TempGopher___0);
    }
#line 472
    if ((unsigned long )eachitem != (unsigned long )((void *)0)) {
      {
#line 472
      (*eachitem)();
      }
    }
#line 473
    goto switch_break;
    case_1: /* CIL Label */ 
#line 476
    return;
    case_neg_1: /* CIL Label */ 
#line 479
    goto switch_break;
    case_neg_2: /* CIL Label */ 
#line 482
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 485
  if (ControlCpressed) {
#line 486
    ControlCpressed = 0;
  }
#line 488
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
void GDfromLink(GopherDirObj *gd , FileIO *fio , char *host , int port , char *directory ,
                char *peer ) 
{ 
  GopherObj *gs ;
  int result ;
  char *cp ;
  char *tmp ;

  {
  {
#line 504
  gs = GSnew();
  }
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 507
    GSinit(gs);
#line 509
    result = GSfromLink(gs, fio, host, port, directory, peer);
    }
#line 511
    if (result == -2) {
#line 512
      goto while_break;
    }
#line 514
    if (result == -1) {
#line 515
      goto while_continue;
    }
#line 517
    if ((gs->Selstr)->len < 0) {
#line 517
      tmp = (char *)((void *)0);
    } else {
#line 517
      tmp = (gs->Selstr)->data;
    }
#line 517
    cp = tmp;
#line 519
    if ((int )*cp == 46) {
      {
#line 520
      GDaddGSmerge(gd, gs);
      }
    } else {
      {
#line 522
      GDaddGS(gd, gs);
      }
    }
#line 524
    if (result == 0) {
#line 525
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 529
  GSdestroy(gs);
  }
#line 530
  return;
}
}
#line 533 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
void GDtoLink(GopherDirObj *gd , int fd ) 
{ 
  int i ;

  {
#line 538
  i = 0;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    if (! (i < (gd->Gophers)->Top)) {
#line 538
      goto while_break;
    }
    {
#line 539
    GStoLink((GopherObj *)*((gd->Gophers)->objects + i), fd, 0);
#line 538
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  return;
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
int GDSearch(GopherDirObj *gd , char *text ) 
{ 
  int i ;
  GopherObj *gs ;
  int cplen ;
  char *cp ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 556
  if ((unsigned long )gd == (unsigned long )((void *)0)) {
#line 557
    return (-1);
  }
#line 559
  if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 560
    return (-1);
  }
  {
#line 562
  tmp = strlen((char const   *)text);
  }
#line 562
  if ((int )tmp <= 1) {
#line 563
    return (-1);
  }
#line 565
  i = 0;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 565
    if (! (i < (gd->Gophers)->Top)) {
#line 565
      goto while_break;
    }
#line 567
    gs = (GopherObj *)*((gd->Gophers)->objects + i);
#line 568
    if ((gs->Selstr)->len < 0) {
#line 568
      tmp___0 = (char *)((void *)0);
    } else {
#line 568
      tmp___0 = (gs->Selstr)->data;
    }
#line 568
    cp = tmp___0;
#line 569
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 570
      tmp___1 = strlen((char const   *)cp);
#line 570
      cplen = (int )tmp___1;
      }
#line 572
      if (cplen > 1) {
        {
#line 572
        tmp___2 = strcmp((char const   *)(text + 1), (char const   *)(cp + 1));
        }
#line 572
        if (tmp___2 == 0) {
#line 574
          return (i);
        }
      }
    }
#line 565
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 579
  return (-1);
}
}
#line 586 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
GopherDirObj *GDdeleteGS(GopherDirObj *gd , int j ) 
{ 
  int i ;

  {
#line 591
  if ((gd->Gophers)->Top == j + 1) {
    {
#line 593
    GSinit((GopherObj *)*((gd->Gophers)->objects + j));
#line 594
    (gd->Gophers)->Top = j;
    }
#line 595
    return (gd);
  }
#line 600
  i = j + 1;
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 600
    if (! (i < (gd->Gophers)->Top)) {
#line 600
      goto while_break;
    }
    {
#line 601
    GScpy((GopherObj *)*((gd->Gophers)->objects + (i - 1)), (GopherObj *)*((gd->Gophers)->objects + i));
#line 600
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  ((gd->Gophers)->Top) --;
#line 606
  if (gd->currentitem > (gd->Gophers)->Top - 1) {
#line 607
    (gd->currentitem) --;
  }
#line 609
  return (gd);
}
}
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Regex.c"
regex_t preg  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Regex.c"
int pregallocated  =    0;
#line 65 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Regex.c"
char *posix_re_comp(char *regex ) 
{ 
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 66
  if (pregallocated) {
    {
#line 67
    regfree(& preg);
    }
  }
  {
#line 70
  pregallocated = 1;
#line 71
  tmp___1 = regcomp((regex_t */* __restrict  */)(& preg), (char const   */* __restrict  */)regex,
                    ((1 << 1) << 1) << 1);
  }
#line 71
  if (tmp___1) {
#line 71
    tmp___0 = "regcomp error";
  } else {
#line 71
    tmp___0 = (char const   *)((void *)0);
  }
#line 71
  return ((char *)tmp___0);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Regex.c"
int posix_re_exec(char *string ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 75
  tmp = regexec((regex_t const   */* __restrict  */)(& preg), (char const   */* __restrict  */)string,
                (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
  }
#line 75
  if (tmp) {
#line 75
    tmp___0 = 0;
  } else {
#line 75
    tmp___0 = 1;
  }
#line 75
  return (tmp___0);
}
}
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 455
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2), __leaf__)) bcopy)(void const   *__src ,
                                                                                               void *__dest ,
                                                                                               size_t __n ) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.h"
jmp_buf Jmpenv ;
#line 96
void controlcJmp(int sig ) ;
#line 100
void reprimeControlc(void) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 141
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 137 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Sockets.h"
void SOCKlinger(int sockfd , boolean onoff ) ;
#line 92
int SOCKbind_to_port(int port ) ;
#line 94
int SOCKlisten(struct sockaddr_in *We ) ;
#line 95
int SOCKaccept(int s , struct sockaddr_in we ) ;
#line 96
void SOCKnetnames(int sockfd , char *host_name , char *ipnum ) ;
#line 97
char *SOCKgetDNSname(char *gdchost ) ;
#line 98
int SOCKgetPort(int fd ) ;
#line 115 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Sockets.c"
void SOCKlinger(int sockfd , boolean onoff ) 
{ 


  {
#line 127
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Sockets.c"
int SOCKbind_to_port(int port ) 
{ 
  struct sockaddr_in serv_addr ;
  int reuseaddr ;
  int sockfd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 140
  reuseaddr = 1;
#line 144
  sockfd = socket(2, 1, 0);
  }
#line 144
  if (sockfd < 0) {
    {
#line 145
    perror("server: can\'t open stream socket");
#line 145
    exit(-1);
    }
  }
  {
#line 149
  bzero((void *)((char *)(& serv_addr)), sizeof(serv_addr));
#line 150
  serv_addr.sin_family = (sa_family_t )2;
#line 151
  serv_addr.sin_addr.s_addr = htonl((in_addr_t )0);
#line 152
  serv_addr.sin_port = htons((uint16_t )port);
#line 154
  tmp = setsockopt(sockfd, 1, 2, (void const   *)((char *)(& reuseaddr)), (socklen_t )sizeof(reuseaddr));
  }
#line 154
  if (tmp < 0) {
    {
#line 156
    perror("server: can\'t set REUSEADDR!");
#line 156
    exit(-1);
    }
  }
  {
#line 158
  tmp___0 = bind(sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& serv_addr)),
                 (socklen_t )sizeof(serv_addr));
  }
#line 158
  if (tmp___0 < 0) {
#line 159
    return (-1);
  }
  {
#line 162
  SOCKlinger(sockfd, 0);
  }
#line 163
  return (sockfd);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Sockets.c"
static char DNSname[64]  ;
#line 177 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Sockets.c"
char *SOCKgetDNSname(char *gdchost ) 
{ 
  struct hostent *hp ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 183
  if ((unsigned long )gdchost != (unsigned long )((void *)0)) {
#line 183
    if ((int )*gdchost != 0) {
#line 184
      return (gdchost);
    }
  }
  {
#line 186
  DNSname[0] = (char )'\000';
#line 189
  tmp = gethostname(DNSname, (size_t )64);
  }
#line 189
  if (tmp != 0) {
    {
#line 190
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot determine the name of this host\n");
#line 191
    exit(-1);
    }
  }
  {
#line 195
  hp = gethostbyname((char const   *)(DNSname));
  }
#line 201
  if ((unsigned long )hp != (unsigned long )((void *)0)) {
    {
#line 201
    tmp___0 = strlen((char const   *)hp->h_name);
#line 201
    tmp___1 = strlen((char const   *)(DNSname));
    }
#line 201
    if (tmp___0 > tmp___1) {
      {
#line 202
      strncpy((char */* __restrict  */)(DNSname), (char const   */* __restrict  */)hp->h_name,
              (size_t )64);
      }
    }
  }
#line 204
  return (DNSname);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Sockets.c"
int SOCKgetPort(int fd ) 
{ 
  struct sockaddr_in serv_addr ;
  socklen_t length ;
  uint16_t tmp ;
  int tmp___0 ;

  {
  {
#line 220
  length = (socklen_t )sizeof(serv_addr);
#line 224
  tmp___0 = getsockname(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& serv_addr)),
                        (socklen_t */* __restrict  */)(& length));
  }
#line 224
  if (tmp___0 == 0) {
    {
#line 225
    tmp = ntohs(serv_addr.sin_port);
    }
#line 225
    return ((int )tmp);
  } else {
#line 227
    return (-1);
  }
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Sockets.c"
int SOCKconnect(char *hostname , int port ) 
{ 
  struct sockaddr_in Server ;
  struct hostent *HostPtr ;
  int sockfd ;
  unsigned int ERRinet ;
  uint16_t tmp ;
  __sighandler_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 251
  sockfd = 0;
#line 252
  ERRinet = 4294967295U;
#line 260
  if ((unsigned long )hostname == (unsigned long )((void *)0)) {
#line 261
    return (-5);
  } else
#line 260
  if ((int )*hostname == 0) {
#line 261
    return (-5);
  }
  {
#line 267
  Server.sin_addr.s_addr = inet_addr((char const   *)hostname);
  }
#line 267
  if (Server.sin_addr.s_addr == ERRinet) {
    {
#line 270
    HostPtr = gethostbyname((char const   *)hostname);
    }
#line 270
    if ((unsigned long )HostPtr != (unsigned long )((void *)0)) {
      {
#line 271
      bzero((void *)((char *)(& Server)), sizeof(Server));
#line 272
      bcopy((void const   *)*(HostPtr->h_addr_list + 0), (void *)((char *)(& Server.sin_addr)),
            (size_t )HostPtr->h_length);
#line 273
      Server.sin_family = (sa_family_t )HostPtr->h_addrtype;
      }
    } else {
#line 275
      return (-2);
    }
  } else {
#line 277
    Server.sin_family = (sa_family_t )2;
  }
  {
#line 279
  tmp = htons((uint16_t )port);
#line 279
  Server.sin_port = tmp;
#line 283
  sockfd = socket(2, 1, 0);
  }
#line 283
  if (sockfd < 0) {
#line 284
    return (-3);
  }
  {
#line 287
  setsockopt(sockfd, 1, ~ 13, (void const   *)0, (socklen_t )0);
#line 290
  setsockopt(sockfd, 1, 2, (void const   *)0, (socklen_t )0);
#line 291
  setsockopt(sockfd, 1, 9, (void const   *)0, (socklen_t )0);
  }
#line 294
  if (ControlCpressed) {
#line 295
    return (-6);
  }
  {
#line 297
  tmp___0 = signal(2, & controlcJmp);
  }
#line 297
  if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 298
    perror("signal died:\n");
#line 298
    exit(-1);
    }
  }
  {
#line 300
  tmp___1 = _setjmp((struct __jmp_buf_tag *)(Jmpenv));
  }
#line 300
  if (tmp___1) {
#line 303
    return (-6);
  }
  {
#line 306
  tmp___2 = connect(sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& Server)),
                    (socklen_t )sizeof(Server));
  }
#line 306
  if (tmp___2 < 0) {
    {
#line 307
    close(sockfd);
#line 308
    reprimeControlc();
    }
#line 309
    return (-4);
  }
  {
#line 311
  reprimeControlc();
  }
#line 313
  return (sockfd);
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Sockets.c"
int SOCKlisten(struct sockaddr_in *We ) 
{ 
  int sockfd ;
  struct hostent *HostPtr ;
  socklen_t len ;
  char name[100] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 396
  sockfd = 0;
#line 398
  len = (socklen_t )sizeof(struct sockaddr );
#line 402
  sockfd = SOCKbind_to_port(sockfd);
#line 403
  tmp = listen(sockfd, 5);
  }
#line 403
  if (tmp) {
    {
#line 404
    close(sockfd);
    }
#line 405
    return (-2);
  } else {
    {
#line 403
    tmp___0 = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)We),
                          (socklen_t */* __restrict  */)(& len));
    }
#line 403
    if (tmp___0) {
      {
#line 404
      close(sockfd);
      }
#line 405
      return (-2);
    }
  }
  {
#line 408
  gethostname(name, (size_t )100);
#line 409
  HostPtr = gethostbyname((char const   *)(name));
  }
#line 409
  if (HostPtr) {
    {
#line 410
    bcopy((void const   *)*(HostPtr->h_addr_list + 0), (void *)((char *)(& We->sin_addr)),
          (size_t )HostPtr->h_length);
    }
  }
#line 411
  return (sockfd);
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Sockets.c"
int SOCKaccept(int s , struct sockaddr_in we ) 
{ 
  int sockfd ;
  socklen_t len ;
  unsigned short tem ;

  {
  {
#line 422
  sockfd = 0;
#line 423
  len = (socklen_t )sizeof(struct sockaddr );
#line 426
  tem = ntohs(we.sin_port);
#line 430
  sockfd = accept(s, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& we)),
                  (socklen_t */* __restrict  */)(& len));
  }
#line 430
  if (sockfd < 0) {
#line 431
    return (-4);
  }
  {
#line 433
  close(s);
  }
#line 435
  return (sockfd);
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Sockets.c"
void SOCKnetnames(int sockfd , char *host_name , char *ipnum ) 
{ 
  struct sockaddr_in sa ;
  socklen_t length ;
  struct hostent *hp ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 462
  length = (socklen_t )sizeof(sa);
#line 463
  tmp = getpeername(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sa)),
                    (socklen_t */* __restrict  */)(& length));
  }
#line 463
  if (tmp) {
#line 465
    return;
  }
#line 467
  if ((unsigned long )ipnum != (unsigned long )((void *)0)) {
    {
#line 468
    tmp___0 = inet_ntoa(sa.sin_addr);
#line 468
    strcpy((char */* __restrict  */)ipnum, (char const   */* __restrict  */)tmp___0);
    }
  }
#line 470
  if ((unsigned long )host_name != (unsigned long )((void *)0)) {
    {
#line 471
    tmp___1 = inet_ntoa(sa.sin_addr);
#line 471
    strcpy((char */* __restrict  */)host_name, (char const   */* __restrict  */)tmp___1);
    }
  }
  {
#line 476
  hp = gethostbyaddr((void const   *)((char *)(& sa.sin_addr)), (__socklen_t )sizeof(sa.sin_addr),
                     2);
  }
#line 479
  if ((unsigned long )hp != (unsigned long )((void *)0)) {
#line 479
    if ((unsigned long )host_name != (unsigned long )((void *)0)) {
      {
#line 480
      strcpy((char */* __restrict  */)host_name, (char const   */* __restrict  */)hp->h_name);
      }
    }
  }
#line 482
  return;
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 74 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.h"
int writen(int fd , char *ptr___0 , int nbytes ) ;
#line 76
int sreadword(char *input , char *output , int maxlen ) ;
#line 80
void Hexall(char *input , char *output ) ;
#line 84
char *skip_whitespace(char *str ) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.h"
jmp_buf Jmpenv  ;
#line 95
void controlc(int sig ) ;
#line 147 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static FileIO *Gfio  =    (FileIO *)((void *)0);
#line 148 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static int Oldsockfd  =    -1;
#line 150 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
boolean ControlCpressed  =    0;
#line 153 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
void controlc(int sig ) 
{ 


  {
  {
#line 156
  ControlCpressed = 1;
#line 157
  reprimeControlc();
  }
#line 158
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
void controlcJmp(int sig ) 
{ 


  {
  {
#line 164
  controlc(sig);
#line 165
  longjmp((struct __jmp_buf_tag *)(Jmpenv), 1);
  }
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
int interruptable_read(int fd , char *ptr___0 , int nbytes ) 
{ 
  int retval ;
  __sighandler_t tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 173
  if (ControlCpressed) {
#line 175
    return (1);
  }
  {
#line 178
  tmp = signal(2, & controlcJmp);
  }
#line 178
  if ((unsigned long )tmp == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 179
    perror("signal died:\n");
#line 179
    exit(-1);
    }
  }
  {
#line 181
  tmp___0 = _setjmp((struct __jmp_buf_tag *)(Jmpenv));
  }
#line 181
  if (tmp___0) {
#line 184
    return (-1);
  }
  {
#line 186
  tmp___1 = read(fd, (void *)ptr___0, (size_t )nbytes);
#line 186
  retval = (int )tmp___1;
#line 187
  reprimeControlc();
  }
#line 188
  return (retval);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
void reprimeControlc(void) 
{ 
  __sighandler_t tmp ;

  {
  {
#line 196
  tmp = signal(2, & controlc);
  }
#line 196
  if ((unsigned long )tmp == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 197
    perror("signal died:\n");
#line 197
    exit(-1);
    }
  }
#line 198
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static void CheckGfio(int fd ) 
{ 


  {
#line 241
  if ((unsigned long )Gfio == (unsigned long )((void *)0)) {
#line 241
    goto _L;
  } else
#line 241
  if (Oldsockfd != fd) {
    _L: /* CIL Label */ 
#line 242
    Oldsockfd = fd;
#line 243
    if ((unsigned long )Gfio != (unsigned long )((void *)0)) {
      {
#line 244
      FIOdestroy(Gfio);
      }
    }
    {
#line 245
    Gfio = FIOopenfd(fd, 1);
    }
  }
#line 247
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
int readn(int fd , char *ptr___0 , int nbytes ) 
{ 
  int nleft ;
  int nread ;
  ssize_t tmp ;

  {
#line 262
  nleft = nbytes;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! (nleft > 0)) {
#line 263
      goto while_break;
    }
    {
#line 270
    tmp = read(fd, (void *)ptr___0, (size_t )nleft);
#line 270
    nread = (int )tmp;
    }
#line 277
    if (nread < 0) {
#line 278
      return (nread);
    } else
#line 279
    if (nread == 0) {
#line 280
      goto while_break;
    }
#line 282
    nleft -= nread;
#line 283
    ptr___0 += nread;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  return (nbytes - nleft);
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
int writen(int fd , char *ptr___0 , int nbytes ) 
{ 
  int nleft ;
  int nwritten ;
  ssize_t tmp ;

  {
#line 302
  nleft = nbytes;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (nleft > 0)) {
#line 303
      goto while_break;
    }
    {
#line 310
    tmp = write(fd, (void const   *)ptr___0, (size_t )nleft);
#line 310
    nwritten = (int )tmp;
    }
#line 313
    if (nwritten <= 0) {
#line 314
      return (nwritten);
    }
#line 316
    nleft -= nwritten;
#line 317
    ptr___0 += nwritten;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return (nbytes - nleft);
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
int writestring(int fd , char *stringptr ) 
{ 
  int length ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 335
  if ((unsigned long )stringptr == (unsigned long )((void *)0)) {
#line 336
    return (0);
  }
  {
#line 338
  tmp = strlen((char const   *)stringptr);
#line 338
  length = (int )tmp;
#line 339
  tmp___0 = writen(fd, stringptr, length);
  }
#line 339
  if (tmp___0 != length) {
#line 341
    return (-1);
  } else {
#line 344
    return (0);
  }
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
int readrecvbuf(int sockfd , char *buf , int len ) 
{ 
  int bytesread ;

  {
  {
#line 358
  CheckGfio(sockfd);
  }
#line 359
  if ((unsigned long )Gfio == (unsigned long )((void *)0)) {
#line 360
    return (-1);
  }
  {
#line 362
  bytesread = FIOreadbuf(Gfio, buf, len);
  }
#line 364
  return (bytesread);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
int readline(int fd , char *ptr___0 , int maxlen ) 
{ 
  int n ;

  {
  {
#line 381
  CheckGfio(fd);
  }
#line 383
  if ((unsigned long )Gfio == (unsigned long )((void *)0)) {
#line 384
    return (-1);
  }
  {
#line 386
  n = FIOreadline(Gfio, ptr___0, maxlen);
  }
#line 389
  return (n);
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
int readtoken(int fd , char *ptr___0 , int maxlen , char zechar ) 
{ 
  int bytesread ;

  {
  {
#line 405
  CheckGfio(fd);
  }
#line 406
  if ((unsigned long )Gfio == (unsigned long )((void *)0)) {
#line 407
    return (-1);
  }
  {
#line 409
  bytesread = FIOreadtoken(Gfio, ptr___0, maxlen, zechar);
  }
#line 412
  return (bytesread);
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
int sreadword(char *input , char *output , int maxlen ) 
{ 
  int n ;
  char c ;
  char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 422
  n = 0;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! (n < maxlen)) {
#line 422
      goto while_break;
    }
    {
#line 423
    tmp = input;
#line 423
    input ++;
#line 423
    c = *tmp;
#line 424
    tmp___0 = output;
#line 424
    output ++;
#line 424
    *tmp___0 = c;
#line 425
    tmp___1 = __ctype_b_loc();
    }
#line 425
    if ((int const   )*(*tmp___1 + (int )c) & 8192) {
#line 426
      *(output - 1) = (char )'\000';
#line 427
      goto while_break;
    }
#line 430
    if ((int )c == 0) {
#line 431
      goto while_break;
    }
#line 422
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  *output = (char )'\000';
#line 436
  return (n);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
void ZapCRLF(char *inputline___0 ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 450
  tmp = strlen((char const   *)inputline___0);
#line 450
  len = (int )tmp;
  }
#line 452
  if (len == 0) {
#line 453
    return;
  }
#line 454
  inputline___0 += len;
#line 455
  inputline___0 --;
#line 457
  if ((int )*inputline___0 == 10) {
#line 457
    goto _L;
  } else
#line 457
  if ((int )*inputline___0 == 13) {
    _L: /* CIL Label */ 
#line 458
    *inputline___0 = (char )'\000';
#line 459
    if (len > 1) {
#line 460
      inputline___0 --;
#line 461
      if ((int )*inputline___0 == 10) {
#line 462
        *inputline___0 = (char )'\000';
      } else
#line 461
      if ((int )*inputline___0 == 13) {
#line 462
        *inputline___0 = (char )'\000';
      }
    }
  }
#line 465
  return;
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static boolean *acceptable  ;
#line 472 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static boolean acceptable_inited  =    0;
#line 474 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static void init_acceptable(void) 
{ 
  unsigned int i ;
  char *good ;
  void *tmp ;

  {
  {
#line 477
  good = (char *)"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";
#line 480
  tmp = malloc(sizeof(boolean ) * 256UL);
#line 480
  acceptable = (boolean *)tmp;
#line 482
  i = 0U;
  }
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 482
    if (! (i < 256U)) {
#line 482
      goto while_break;
    }
#line 483
    *(acceptable + i) = 0;
#line 482
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 484
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 484
    if (! *good) {
#line 484
      goto while_break___0;
    }
#line 485
    *(acceptable + (unsigned int )*good) = 1;
#line 484
    good ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 487
  acceptable_inited = 1;
#line 488
  return;
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static char hex[17]  = 
#line 490
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 492 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static char from_hex(char c ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 495
  if ((int )c >= 48) {
#line 495
    if ((int )c <= 57) {
#line 495
      tmp___1 = (int )c - 48;
    } else {
#line 495
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 495
    if ((int )c >= 65) {
#line 495
      if ((int )c <= 70) {
#line 495
        tmp___0 = ((int )c - 65) + 10;
      } else {
#line 495
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 495
      if ((int )c >= 97) {
#line 495
        if ((int )c <= 102) {
#line 495
          tmp = ((int )c - 97) + 10;
        } else {
#line 495
          tmp = 0;
        }
      } else {
#line 495
        tmp = 0;
      }
#line 495
      tmp___0 = tmp;
    }
#line 495
    tmp___1 = tmp___0;
  }
#line 495
  return ((char )tmp___1);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
void Fromhexstr(char *input , char *output ) 
{ 
  char c ;
  unsigned int b ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! *input) {
#line 535
      goto while_break;
    }
#line 536
    if ((int )*input == 37) {
      {
#line 537
      input ++;
#line 538
      tmp = input;
#line 538
      input ++;
#line 538
      c = *tmp;
#line 539
      tmp___0 = from_hex(c);
#line 539
      b = (unsigned int )tmp___0;
#line 540
      tmp___1 = input;
#line 540
      input ++;
#line 540
      c = *tmp___1;
      }
#line 541
      if (! c) {
#line 541
        goto while_break;
      }
      {
#line 542
      tmp___2 = output;
#line 542
      output ++;
#line 542
      tmp___3 = from_hex(c);
#line 542
      *tmp___2 = (char )((b << 4) + (unsigned int )tmp___3);
      }
    } else {
#line 545
      tmp___4 = output;
#line 545
      output ++;
#line 545
      tmp___5 = input;
#line 545
      input ++;
#line 545
      *tmp___4 = *tmp___5;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  *output = (char )'\000';
#line 548
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
void Tohexstr(char *input , char *output ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 553
  if ((unsigned long )input == (unsigned long )((void *)0)) {
#line 554
    return;
  } else
#line 553
  if ((unsigned long )output == (unsigned long )((void *)0)) {
#line 554
    return;
  }
#line 556
  if (acceptable_inited == 0) {
    {
#line 557
    init_acceptable();
    }
  }
  {
#line 559
  while (1) {
    while_continue: /* CIL Label */ ;
#line 559
    if (! *input) {
#line 559
      goto while_break;
    }
#line 561
    if (*(acceptable + (int )*input) == 1) {
#line 562
      tmp = output;
#line 562
      output ++;
#line 562
      tmp___0 = input;
#line 562
      input ++;
#line 562
      *tmp = *tmp___0;
    } else {
#line 565
      tmp___1 = output;
#line 565
      output ++;
#line 565
      *tmp___1 = (char )'%';
#line 566
      tmp___2 = output;
#line 566
      output ++;
#line 566
      *tmp___2 = hex[(int )*input >> 4];
#line 567
      tmp___3 = output;
#line 567
      output ++;
#line 567
      *tmp___3 = hex[(int )*input & 15];
#line 568
      input ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 572
  *output = (char )'\000';
#line 573
  return;
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
void Hexall(char *input , char *output ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 582
    if (! *input) {
#line 582
      goto while_break;
    }
#line 584
    tmp = output;
#line 584
    output ++;
#line 584
    *tmp = hex[(int )*input >> 4];
#line 585
    tmp___0 = output;
#line 585
    output ++;
#line 585
    *tmp___0 = hex[(int )*input & 15];
#line 586
    input ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 589
  *output = (char )'\000';
#line 590
  return;
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
char *skip_whitespace(char *str ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 626
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 626
    tmp = __ctype_b_loc();
    }
#line 626
    if ((int const   )*(*tmp + (int )*str) & 8192) {
#line 626
      if (! ((int )*str != 0)) {
#line 626
        goto while_break;
      }
    } else {
#line 626
      goto while_break;
    }
#line 627
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  return (str);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/STRstring.h"
String *STRcat(String *st , char *cp ) ;
#line 112
int STRcmp(String *st1 , String *st2 ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/STRstring.c"
String *STRnew(void) 
{ 
  String *temp ;
  void *tmp ;

  {
  {
#line 74
  tmp = malloc(sizeof(String ));
#line 74
  temp = (String *)tmp;
#line 75
  temp->data = (char *)((void *)0);
#line 76
  temp->len = 0;
  }
#line 78
  return (temp);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/STRstring.c"
void STRdestroy(String *st ) 
{ 


  {
#line 88
  if ((unsigned long )st != (unsigned long )((void *)0)) {
#line 89
    if ((unsigned long )st->data != (unsigned long )((void *)0)) {
      {
#line 90
      free((void *)st->data);
      }
    }
    {
#line 91
    free((void *)st);
    }
  } else {
    {
#line 93
    perror("STRdestroy: non existant string!\n");
    }
  }
#line 95
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/STRstring.c"
void STRinit(String *st ) 
{ 


  {
#line 106
  if ((unsigned long )st != (unsigned long )((void *)0)) {
#line 107
    if (st->len > 0) {
#line 108
      st->len = - st->len;
    }
  } else {
    {
#line 114
    perror("STRinit, non existant string!");
    }
  }
#line 115
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/STRstring.c"
void STRset(String *st , char *str ) 
{ 
  register int len ;
  size_t tmp ;
  void *tmp___0 ;
  char *temp ;
  void *tmp___1 ;

  {
#line 128
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    {
#line 129
    STRinit(st);
    }
#line 130
    return;
  }
#line 137
  if (st->len < 0) {
#line 138
    st->len = - st->len;
  }
#line 140
  if ((int )*str == 0) {
#line 141
    len = 1;
  } else {
    {
#line 143
    tmp = strlen((char const   *)str);
#line 143
    len = (int )(tmp + 1UL);
    }
  }
#line 147
  if ((unsigned long )st->data == (unsigned long )((void *)0)) {
    {
#line 148
    tmp___0 = malloc(sizeof(char *) * (unsigned long )len);
#line 148
    st->data = (char *)tmp___0;
#line 149
    st->len = len;
    }
  } else
#line 154
  if (st->len < len) {
    {
#line 157
    tmp___1 = realloc((void *)st->data, sizeof(char ) * (unsigned long )len);
#line 157
    temp = (char *)tmp___1;
    }
#line 159
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
      {
#line 160
      perror("realloc failed...");
      }
    }
#line 162
    st->data = temp;
#line 163
    st->len = len;
  }
  {
#line 166
  strcpy((char */* __restrict  */)st->data, (char const   */* __restrict  */)str);
  }
#line 167
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/STRstring.c"
String *STRcat(String *st , char *cp ) 
{ 
  int len ;
  char *temp ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 179
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 180
    return ((String *)((void *)0));
  }
#line 182
  if (st->len > 0) {
#line 182
    tmp = st->len;
  } else {
#line 182
    tmp = 0;
  }
#line 182
  if (tmp == 0) {
    {
#line 183
    STRset(st, cp);
    }
#line 184
    return (st);
  }
  {
#line 187
  tmp___0 = strlen((char const   *)cp);
  }
#line 187
  if (st->len > 0) {
#line 187
    tmp___1 = st->len;
  } else {
#line 187
    tmp___1 = 0;
  }
  {
#line 187
  len = (int )(tmp___0 + (size_t )tmp___1);
#line 189
  tmp___2 = malloc(sizeof(char ) * (unsigned long )len);
#line 189
  temp = (char *)tmp___2;
  }
#line 190
  if (st->len < 0) {
#line 190
    tmp___3 = (char *)((void *)0);
  } else {
#line 190
    tmp___3 = st->data;
  }
  {
#line 190
  strcpy((char */* __restrict  */)temp, (char const   */* __restrict  */)tmp___3);
#line 191
  strcat((char */* __restrict  */)temp, (char const   */* __restrict  */)cp);
#line 193
  STRset(st, temp);
#line 195
  free((void *)temp);
  }
#line 197
  return (st);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/STRstring.c"
int STRcmp(String *st1 , String *st2 ) 
{ 
  register char *cp1 ;
  register char *cp2 ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 206
  if (st1->len < 0) {
#line 206
    tmp = (char *)((void *)0);
  } else {
#line 206
    tmp = st1->data;
  }
#line 206
  cp1 = tmp;
#line 207
  if (st2->len < 0) {
#line 207
    tmp___0 = (char *)((void *)0);
  } else {
#line 207
    tmp___0 = st2->data;
  }
#line 207
  cp2 = tmp___0;
#line 209
  if ((unsigned long )cp1 == (unsigned long )((void *)0)) {
#line 210
    return (-1);
  } else
#line 211
  if ((unsigned long )cp2 == (unsigned long )((void *)0)) {
#line 212
    return (1);
  } else {
    {
#line 214
    tmp___1 = strcmp((char const   *)cp1, (char const   *)cp2);
    }
#line 214
    return (tmp___1);
  }
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/STRstring.c"
String *STRcpy(String *s1 , String *s2 ) 
{ 
  char *tmp ;

  {
#line 220
  if (s2->len < 0) {
#line 220
    tmp = (char *)((void *)0);
  } else {
#line 220
    tmp = s2->data;
  }
  {
#line 220
  STRset(s1, tmp);
  }
#line 221
  return (s1);
}
}
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 603 "/usr/include/curses.h"
extern int delwin(WINDOW * ) ;
#line 707
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 801
extern int wclear(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 839
extern int wtouchln(WINDOW * , int  , int  , int  ) ;
#line 1390
extern int COLS ;
#line 1392
extern int LINES ;
#line 295 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.h"
int CURgetch(CursesObj *cur ) ;
#line 301
void CURwenter(CursesObj *cur , WINDOW *win ) ;
#line 313
void CURbutton(CursesObj *cur , WINDOW *win , char *Label , boolean bright ) ;
#line 314
void CURbox(CursesObj *cur , WINDOW *win , int height , int width ) ;
#line 315
int CURwgetstr(CursesObj *cur , WINDOW *win , char *inputline___0 , int maxlength ,
               boolean hidden ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.h"
ITEM *ITEMnew(void) ;
#line 80
void ITEMinit(ITEM *item ) ;
#line 81
ITEM *ITEMcpy(ITEM *dest , ITEM *orig ) ;
#line 82
void ITEMdestroy(ITEM *item ) ;
#line 83
void ITEMpushChoice(ITEM *item , char *choice ) ;
#line 102
int CURform(CursesObj *cur , char *Wintitle , FORM *form ) ;
#line 104
boolean FORMaddLabel(FORM *form , char *label ) ;
#line 105
boolean FORMaddPrompt(FORM *form , char *prompt___0 , char *defval ) ;
#line 106
boolean FORMaddPasswd(FORM *form , char *prompt___0 , char *defval ) ;
#line 107
boolean FORMaddFilechoice(FORM *form , char *prompt___0 , char *defval ) ;
#line 108
boolean FORMaddLong(FORM *form , char *prompt___0 , char *defval ) ;
#line 109
boolean FORMaddChoice(FORM *form , char *prompt___0 , char **choices , int defval ) ;
#line 110
boolean FORMaddSelect(FORM *form , char *prompt___0 , int defval ) ;
#line 151 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
CursesObj *CursesScreen ;
#line 68 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.c"
ITEM *ITEMnew(void) 
{ 
  ITEM *temp ;
  void *tmp ;

  {
  {
#line 73
  tmp = malloc(sizeof(ITEM ));
#line 73
  temp = (ITEM *)tmp;
#line 75
  temp->type = (ITEMtype )0;
#line 76
  temp->label = STRnew();
#line 77
  temp->response = STRnew();
#line 79
  temp->chooseitem = -1;
#line 80
  temp->choices = DAnew(3, & STRnew, & STRinit, & STRdestroy, & STRcpy);
  }
#line 82
  return (temp);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.c"
void ITEMinit(ITEM *item ) 
{ 


  {
  {
#line 93
  item->type = (ITEMtype )0;
#line 95
  STRinit(item->label);
#line 96
  STRinit(item->response);
#line 97
  DAinit(item->choices);
#line 98
  item->chooseitem = 0;
  }
#line 99
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.c"
ITEM *ITEMcpy(ITEM *dest , ITEM *orig ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 108
  dest->type = orig->type;
#line 109
  if ((orig->label)->len < 0) {
#line 109
    tmp = (char *)((void *)0);
  } else {
#line 109
    tmp = (orig->label)->data;
  }
  {
#line 109
  STRset(dest->label, tmp);
  }
#line 110
  if ((orig->response)->len < 0) {
#line 110
    tmp___0 = (char *)((void *)0);
  } else {
#line 110
    tmp___0 = (orig->response)->data;
  }
  {
#line 110
  STRset(dest->response, tmp___0);
#line 112
  dest->chooseitem = orig->chooseitem;
#line 113
  DAcpy(dest->choices, orig->choices);
  }
#line 115
  return (dest);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.c"
void ITEMdestroy(ITEM *item ) 
{ 


  {
  {
#line 125
  STRdestroy(item->label);
#line 126
  STRdestroy(item->response);
#line 128
  DAdestroy(item->choices);
#line 129
  free((void *)item);
  }
#line 130
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.c"
void ITEMpushChoice(ITEM *item , char *choice ) 
{ 
  String *str ;

  {
  {
#line 141
  str = STRnew();
#line 143
  STRset(str, choice);
#line 144
  DApush(item->choices, (char *)str);
#line 146
  STRdestroy(str);
  }
#line 147
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.c"
FORM *FORMfromASK(GopherObj *gs ) 
{ 
  int Asknum ;
  Blockobj *bl ;
  char askline[256] ;
  char *defaultval ;
  FORM *form ;
  int tmp ;
  char *askprompt ;
  char *cp ;
  char *tmp___0 ;
  int cnum ;
  char **choices ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int chooseitem ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 169
  GSgetginfo(gs, 1);
#line 171
  bl = GSfindBlock(gs, (char *)"ASK");
  }
#line 173
  if ((unsigned long )bl == (unsigned long )((void *)0)) {
#line 174
    return ((FORM *)((void *)0));
  }
  {
#line 176
  tmp = BLgetNumLines(bl);
#line 176
  form = DAnew(tmp, & ITEMnew, & ITEMinit, & ITEMdestroy, & ITEMcpy);
#line 178
  Asknum = 0;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 178
    tmp___11 = BLgetNumLines(bl);
    }
#line 178
    if (! (Asknum < tmp___11)) {
#line 178
      goto while_break;
    }
    {
#line 181
    tmp___0 = BLgetLine(bl, Asknum);
#line 181
    strcpy((char */* __restrict  */)(askline), (char const   */* __restrict  */)tmp___0);
#line 184
    askprompt = strchr((char const   *)(askline), ':');
    }
#line 186
    if ((unsigned long )askprompt == (unsigned long )((void *)0)) {
      {
#line 188
      FORMaddLabel(form, (char *)"");
      }
#line 189
      goto __Cont;
    }
    {
#line 191
    *(askprompt + 1) = (char )'\000';
#line 192
    askprompt += 2;
#line 195
    cp = strchr((char const   *)askprompt, '\t');
    }
#line 196
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 197
      defaultval = cp + 1;
#line 198
      *cp = (char )'\000';
    } else {
#line 200
      defaultval = (char *)((void *)0);
    }
    {
#line 203
    tmp___10 = strncasecmp((char const   *)(askline), "Note:", (size_t )5);
    }
#line 203
    if (tmp___10 == 0) {
      {
#line 204
      FORMaddLabel(form, askprompt);
      }
    } else {
      {
#line 206
      tmp___9 = strncasecmp((char const   *)(askline), "Choose:", (size_t )7);
      }
#line 206
      if (tmp___9 == 0) {
        {
#line 207
        cnum = 0;
#line 210
        tmp___1 = malloc(sizeof(char *) * 100UL);
#line 210
        choices = (char **)tmp___1;
        }
        {
#line 213
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 213
          cp = strchr((char const   *)defaultval, '\t');
          }
#line 213
          if (! ((unsigned long )cp != (unsigned long )((void *)0))) {
#line 213
            goto while_break___0;
          }
#line 214
          *cp = (char )'\000';
#line 215
          tmp___2 = cnum;
#line 215
          cnum ++;
#line 215
          *(choices + tmp___2) = defaultval;
#line 216
          defaultval = cp + 1;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 218
        if ((unsigned long )defaultval != (unsigned long )((void *)0)) {
          {
#line 219
          tmp___3 = cnum;
#line 219
          cnum ++;
#line 219
          *(choices + tmp___3) = strdup((char const   *)defaultval);
          }
        }
        {
#line 221
        tmp___4 = cnum;
#line 221
        cnum ++;
#line 221
        *(choices + tmp___4) = (char *)((void *)0);
#line 223
        FORMaddChoice(form, askprompt, choices, 0);
        }
      } else {
        {
#line 226
        tmp___8 = strncasecmp((char const   *)(askline), "Select:", (size_t )7);
        }
#line 226
        if (tmp___8 == 0) {
          {
#line 227
          chooseitem = 0;
#line 229
          cp = strrchr((char const   *)askprompt, ':');
          }
#line 230
          if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 231
            *cp = (char )'\000';
#line 232
            cp ++;
#line 233
            if ((int )*cp == 49) {
#line 234
              chooseitem = 1;
            }
          }
          {
#line 237
          FORMaddSelect(form, askprompt, chooseitem);
          }
        } else {
          {
#line 239
          tmp___7 = strncasecmp((char const   *)(askline), "AskP:", (size_t )5);
          }
#line 239
          if (tmp___7 == 0) {
            {
#line 240
            FORMaddPasswd(form, askprompt, defaultval);
            }
          } else {
            {
#line 241
            tmp___6 = strncasecmp((char const   *)(askline), "AskL:", (size_t )5);
            }
#line 241
            if (tmp___6 == 0) {
              {
#line 242
              FORMaddLong(form, askprompt, defaultval);
              }
            } else {
              {
#line 243
              tmp___5 = strncasecmp((char const   *)(askline), "Choosef:", (size_t )8);
              }
#line 243
              if (tmp___5 == 0) {
                {
#line 244
                FORMaddFilechoice(form, askprompt, defaultval);
                }
              } else {
                {
#line 246
                FORMaddPrompt(form, askprompt, defaultval);
                }
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 178
    Asknum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  return (form);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.c"
char **FORMgetAskdata(GopherObj *gs , FORM *form , int Asknum ) 
{ 
  char **responses ;
  int i ;
  ITEM *item ;
  int respnum ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 255
  responses = (char **)((void *)0);
#line 260
  if ((gs->Title)->len < 0) {
#line 260
    tmp___10 = (char *)((void *)0);
  } else {
#line 260
    tmp___10 = (gs->Title)->data;
  }
  {
#line 260
  tmp___11 = CURform(CursesScreen, tmp___10, form);
  }
#line 260
  if (! tmp___11) {
    {
#line 261
    respnum = 0;
#line 263
    tmp = malloc(sizeof(char *) * (unsigned long )(1 + Asknum));
#line 263
    responses = (char **)tmp;
#line 265
    i = 0;
    }
    {
#line 265
    while (1) {
      while_continue: /* CIL Label */ ;
#line 265
      if (! (i < Asknum)) {
#line 265
        goto while_break;
      }
#line 266
      item = (ITEM *)*(form->objects + i);
      {
#line 269
      if ((unsigned int )item->type == 6U) {
#line 269
        goto case_6;
      }
#line 274
      if ((unsigned int )item->type == 4U) {
#line 274
        goto case_4;
      }
#line 282
      if ((unsigned int )item->type == 3U) {
#line 282
        goto case_3;
      }
#line 286
      if ((unsigned int )item->type == 5U) {
#line 286
        goto case_5;
      }
#line 286
      if ((unsigned int )item->type == 2U) {
#line 286
        goto case_5;
      }
#line 290
      if ((unsigned int )item->type == 7U) {
#line 290
        goto case_7;
      }
#line 290
      if ((unsigned int )item->type == 1U) {
#line 290
        goto case_7;
      }
#line 290
      if ((unsigned int )item->type == 0U) {
#line 290
        goto case_7;
      }
#line 268
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 270
      tmp___0 = respnum;
#line 270
      respnum ++;
#line 270
      *(responses + tmp___0) = strdup("1");
#line 271
      tmp___1 = respnum;
#line 271
      respnum ++;
      }
#line 271
      if ((item->response)->len < 0) {
#line 271
        tmp___2 = (char *)((void *)0);
      } else {
#line 271
        tmp___2 = (item->response)->data;
      }
      {
#line 271
      *(responses + tmp___1) = strdup((char const   *)tmp___2);
      }
#line 272
      goto switch_break;
      case_4: /* CIL Label */ 
#line 275
      if (item->chooseitem == 0) {
        {
#line 276
        tmp___3 = respnum;
#line 276
        respnum ++;
#line 276
        *(responses + tmp___3) = strdup("0");
        }
      } else {
        {
#line 278
        tmp___4 = respnum;
#line 278
        respnum ++;
#line 278
        *(responses + tmp___4) = strdup("1");
        }
      }
#line 280
      goto switch_break;
      case_3: /* CIL Label */ 
#line 283
      tmp___5 = respnum;
#line 283
      respnum ++;
#line 283
      if (((String *)*((item->choices)->objects + item->chooseitem))->len < 0) {
#line 283
        tmp___6 = (char *)((void *)0);
      } else {
#line 283
        tmp___6 = ((String *)*((item->choices)->objects + item->chooseitem))->data;
      }
      {
#line 283
      *(responses + tmp___5) = strdup((char const   *)tmp___6);
      }
#line 284
      goto switch_break;
      case_5: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 287
      tmp___7 = respnum;
#line 287
      respnum ++;
#line 287
      if ((item->response)->len < 0) {
#line 287
        tmp___8 = (char *)((void *)0);
      } else {
#line 287
        tmp___8 = (item->response)->data;
      }
      {
#line 287
      *(responses + tmp___7) = strdup((char const   *)tmp___8);
      }
      case_7: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 291
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 265
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 294
    tmp___9 = respnum;
#line 294
    respnum ++;
#line 294
    *(responses + tmp___9) = (char *)((void *)0);
  }
  {
#line 297
  DAdestroy(form);
  }
#line 299
  return (responses);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.c"
boolean FORMaddLabel(FORM *form , char *label ) 
{ 
  ITEM *item ;

  {
  {
#line 308
  item = ITEMnew();
#line 310
  item->type = (ITEMtype )1;
#line 311
  STRset(item->label, label);
#line 313
  DApush(form, (char *)item);
#line 315
  ITEMdestroy(item);
  }
#line 317
  return (1);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.c"
boolean FORMaddPrompt(FORM *form , char *prompt___0 , char *defval ) 
{ 
  ITEM *item ;

  {
  {
#line 326
  item = ITEMnew();
#line 327
  item->type = (ITEMtype )2;
  }
#line 328
  if ((unsigned long )prompt___0 != (unsigned long )((void *)0)) {
    {
#line 329
    STRset(item->label, prompt___0);
    }
  } else {
    {
#line 331
    STRset(item->label, (char *)"");
    }
  }
#line 333
  if ((unsigned long )defval != (unsigned long )((void *)0)) {
    {
#line 334
    STRset(item->response, defval);
    }
  } else {
    {
#line 336
    STRset(item->response, (char *)"");
    }
  }
  {
#line 338
  DApush(form, (char *)item);
#line 340
  ITEMdestroy(item);
  }
#line 342
  return (1);
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.c"
boolean FORMaddPasswd(FORM *form , char *prompt___0 , char *defval ) 
{ 


  {
  {
#line 348
  FORMaddPrompt(form, prompt___0, defval);
#line 349
  ((ITEM *)*(form->objects + (form->Top - 1)))->type = (ITEMtype )5;
  }
#line 351
  return (1);
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.c"
boolean FORMaddFilechoice(FORM *form , char *prompt___0 , char *defval ) 
{ 


  {
  {
#line 357
  FORMaddPrompt(form, prompt___0, defval);
#line 358
  ((ITEM *)*(form->objects + (form->Top - 1)))->type = (ITEMtype )7;
  }
#line 360
  return (1);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.c"
boolean FORMaddLong(FORM *form , char *prompt___0 , char *defval ) 
{ 


  {
  {
#line 367
  FORMaddPrompt(form, prompt___0, defval);
#line 368
  ((ITEM *)*(form->objects + (form->Top - 1)))->type = (ITEMtype )6;
  }
#line 370
  return (1);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.c"
boolean FORMaddChoice(FORM *form , char *prompt___0 , char **choices , int defval ) 
{ 
  ITEM *item ;
  int i ;

  {
  {
#line 381
  i = 0;
#line 383
  FORMaddPrompt(form, prompt___0, (char *)"");
#line 384
  item = (ITEM *)*(form->objects + (form->Top - 1));
#line 386
  item->chooseitem = defval;
#line 387
  item->type = (ITEMtype )3;
  }
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! ((unsigned long )*(choices + i) != (unsigned long )((void *)0))) {
#line 389
      goto while_break;
    }
    {
#line 390
    ITEMpushChoice(item, *(choices + i));
#line 391
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  return (1);
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.c"
boolean FORMaddSelect(FORM *form , char *prompt___0 , int defval ) 
{ 
  ITEM *item ;

  {
  {
#line 403
  FORMaddPrompt(form, prompt___0, (char *)"");
#line 404
  item = (ITEM *)*(form->objects + (form->Top - 1));
#line 406
  item->chooseitem = defval;
#line 408
  ITEMpushChoice(item, (char *)"No");
#line 409
  ITEMpushChoice(item, (char *)"Yes");
#line 410
  item->type = (ITEMtype )4;
  }
#line 412
  return (1);
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/form.c"
int CURform(CursesObj *cur , char *Wintitle , FORM *form ) 
{ 
  WINDOW *tempwin ;
  int i ;
  int j ;
  int totalprompts ;
  int numprompts ;
  int maxpromptwidth ;
  int currentfield ;
  int maxlength ;
  char TrimmedTitle[128] ;
  ITEM *item ;
  int ch ;
  int numforms ;
  int currentform ;
  int pagesize ;
  int thisformdone ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int numchars ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  boolean hidden ;
  int oldchoice ;
  int choice ;
  int done ;
  char *tmp___13 ;
  size_t tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  char tmpbuffer[256] ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 427
  numprompts = 0;
#line 428
  maxpromptwidth = 0;
#line 429
  currentfield = 0;
#line 430
  maxlength = COLS - 7;
#line 434
  numforms = 1;
#line 435
  currentform = 0;
#line 436
  pagesize = LINES - 8;
#line 437
  thisformdone = 0;
#line 441
  totalprompts = 0;
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    if (! (totalprompts < form->Top)) {
#line 441
      goto while_break;
    }
#line 442
    item = (ITEM *)*(form->objects + totalprompts);
#line 445
    if ((unsigned long )item != (unsigned long )((void *)0)) {
#line 445
      if ((unsigned int )item->type != 1U) {
#line 446
        if ((item->label)->len < 0) {
#line 446
          tmp___1 = (char *)((void *)0);
        } else {
#line 446
          tmp___1 = (item->label)->data;
        }
        {
#line 446
        tmp___2 = strlen((char const   *)tmp___1);
        }
#line 446
        if (tmp___2 > (size_t )maxpromptwidth) {
#line 447
          if ((item->label)->len < 0) {
#line 447
            tmp = (char *)((void *)0);
          } else {
#line 447
            tmp = (item->label)->data;
          }
          {
#line 447
          tmp___0 = strlen((char const   *)tmp);
#line 447
          maxpromptwidth = (int )tmp___0;
          }
        }
      }
    }
#line 450
    if (totalprompts != 0) {
#line 450
      if (totalprompts % pagesize == 0) {
#line 451
        numforms ++;
      }
    }
#line 441
    totalprompts ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 454
  if (numforms > 1) {
#line 455
    numprompts = pagesize;
  } else {
#line 457
    numprompts = totalprompts;
  }
#line 459
  if (numprompts == 0) {
#line 460
    return (-1);
  }
  {
#line 463
  maxlength -= maxpromptwidth + 1;
#line 464
  tempwin = newwin(6 + numprompts, COLS - 2, (LINES - (6 + numprompts)) / 2, 1);
#line 465
  CURwenter(cur, tempwin);
  }
  {
#line 467
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 467
    if (! (currentform < numforms)) {
#line 467
      goto while_break___0;
    }
#line 468
    if (currentform == numforms - 1) {
#line 469
      numprompts = totalprompts - pagesize * currentform;
    } else {
#line 471
      numprompts = pagesize;
    }
#line 473
    if (tempwin) {
#line 473
      tempwin->_attrs = 0UL;
    }
    {
#line 474
    CURbox(cur, tempwin, 6 + numprompts, COLS - 2);
#line 476
    currentfield = 0;
    }
#line 479
    if ((unsigned long )Wintitle != (unsigned long )((void *)0)) {
      {
#line 481
      tmp___3 = strlen((char const   *)Wintitle);
      }
#line 481
      if (tmp___3 > (size_t )(COLS - 2)) {
        {
#line 482
        strncpy((char */* __restrict  */)(TrimmedTitle), (char const   */* __restrict  */)Wintitle,
                (size_t )(COLS - 2));
#line 483
        TrimmedTitle[COLS - 5] = (char )'.';
#line 484
        TrimmedTitle[COLS - 4] = (char )'.';
#line 485
        TrimmedTitle[COLS - 3] = (char )'.';
#line 486
        TrimmedTitle[COLS - 2] = (char )'\000';
        }
      } else {
        {
#line 489
        strcpy((char */* __restrict  */)(TrimmedTitle), (char const   */* __restrict  */)Wintitle);
        }
      }
      {
#line 492
      tmp___4 = strlen((char const   *)(TrimmedTitle));
#line 492
      wmove(tempwin, 0, (int )(((size_t )(COLS - 2) - tmp___4) / 2UL));
      }
#line 493
      if (tempwin) {
#line 493
        tempwin->_attrs = 1UL << 16;
      }
      {
#line 494
      waddnstr(tempwin, (char const   *)(TrimmedTitle), -1);
      }
#line 495
      if (tempwin) {
#line 495
        tempwin->_attrs = 0UL;
      }
    }
#line 499
    i = 0;
    {
#line 499
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 499
      if (! (i < numprompts)) {
#line 499
        goto while_break___1;
      }
      {
#line 501
      item = (ITEM *)*(form->objects + (i + currentform * pagesize));
#line 503
      wmove(tempwin, 2 + i, 2);
      }
#line 504
      if ((item->label)->len < 0) {
#line 504
        tmp___5 = (char *)((void *)0);
      } else {
#line 504
        tmp___5 = (item->label)->data;
      }
      {
#line 504
      waddnstr(tempwin, (char const   *)tmp___5, -1);
      }
      {
#line 508
      if ((unsigned int )item->type == 1U) {
#line 508
        goto case_1;
      }
#line 512
      if ((unsigned int )item->type == 3U) {
#line 512
        goto case_3;
      }
#line 512
      if ((unsigned int )item->type == 4U) {
#line 512
        goto case_3;
      }
#line 518
      goto switch_default;
      case_1: /* CIL Label */ 
#line 509
      goto switch_break;
      case_3: /* CIL Label */ 
      case_4: /* CIL Label */ 
      {
#line 514
      wmove(tempwin, 2 + i, maxpromptwidth + 4);
      }
#line 515
      if (((String *)*((item->choices)->objects + item->chooseitem))->len < 0) {
#line 515
        tmp___6 = (char *)((void *)0);
      } else {
#line 515
        tmp___6 = ((String *)*((item->choices)->objects + item->chooseitem))->data;
      }
      {
#line 515
      waddnstr(tempwin, (char const   *)tmp___6, -1);
      }
#line 517
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 522
      wmove(tempwin, 2 + i, maxpromptwidth + 4);
      }
#line 523
      if (tempwin) {
#line 523
        tempwin->_attrs = 1UL << 16;
      }
#line 525
      if ((unsigned int )item->type == 5U) {
#line 526
        if ((item->response)->len < 0) {
#line 526
          tmp___7 = (char *)((void *)0);
        } else {
#line 526
          tmp___7 = (item->response)->data;
        }
        {
#line 526
        tmp___8 = strlen((char const   *)tmp___7);
#line 526
        numchars = (int )tmp___8;
#line 528
        j = 0;
        }
        {
#line 528
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 528
          if (! (j < numchars)) {
#line 528
            goto while_break___2;
          }
          {
#line 529
          waddch(tempwin, (chtype const   )'*');
#line 528
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
#line 531
        if ((item->response)->len < 0) {
#line 531
          tmp___9 = (char *)((void *)0);
        } else {
#line 531
          tmp___9 = (item->response)->data;
        }
        {
#line 531
        waddnstr(tempwin, (char const   *)tmp___9, -1);
        }
      }
#line 533
      if ((item->response)->len < 0) {
#line 533
        tmp___10 = (char *)((void *)0);
      } else {
#line 533
        tmp___10 = (item->response)->data;
      }
      {
#line 533
      tmp___11 = strlen((char const   *)tmp___10);
#line 533
      j = (int )((tmp___11 + (size_t )maxpromptwidth) + 4UL);
      }
      {
#line 533
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 533
        if (! (j < COLS - 6)) {
#line 533
          goto while_break___3;
        }
        {
#line 535
        waddch(tempwin, (chtype const   )' ');
#line 533
        j ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 537
      if (tempwin) {
#line 537
        tempwin->_attrs = 0UL;
      }
      switch_break: /* CIL Label */ ;
      }
#line 499
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 542
    wmove(tempwin, 3 + numprompts, (COLS - 63) / 2);
#line 543
    CURbutton(cur, tempwin, (char *)"Switch Fields: TAB", 0);
#line 545
    CURbutton(cur, tempwin, (char *)"Cancel: ^G", 0);
#line 546
    waddch(tempwin, (chtype const   )' ');
#line 547
    CURbutton(cur, tempwin, (char *)"Erase: ^U", 0);
#line 548
    waddch(tempwin, (chtype const   )' ');
#line 549
    CURbutton(cur, tempwin, (char *)"Accept: Enter", 0);
    }
#line 551
    if (tempwin) {
#line 551
      tmp___12 = (int )tempwin->_maxy + 1;
    } else {
#line 551
      tmp___12 = -1;
    }
    {
#line 551
    wtouchln(tempwin, 0, tmp___12, 1);
#line 552
    wrefresh(tempwin);
#line 554
    thisformdone = 0;
    }
    {
#line 556
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 556
      if (! (! thisformdone)) {
#line 556
        goto while_break___4;
      }
#line 560
      item = (ITEM *)*(form->objects + (currentfield + currentform * pagesize));
#line 562
      if ((unsigned int )item->type == 5U) {
#line 563
        hidden = 1;
      } else {
#line 565
        hidden = 0;
      }
      {
#line 567
      wmove(tempwin, 2 + currentfield, maxpromptwidth + 4);
#line 569
      wrefresh(tempwin);
      }
#line 571
      if ((unsigned int )item->type == 3U) {
#line 571
        goto _L;
      } else
#line 571
      if ((unsigned int )item->type == 4U) {
        _L: /* CIL Label */ 
        {
#line 573
        choice = item->chooseitem;
#line 574
        done = 0;
#line 576
        wmove(tempwin, 4 + numprompts, (COLS - 22) / 2);
#line 577
        CURbutton(cur, tempwin, (char *)"Cycle Values: SPACE", 0);
        }
#line 578
        if (((String *)*((item->choices)->objects + choice))->len < 0) {
#line 578
          tmp___13 = (char *)((void *)0);
        } else {
#line 578
          tmp___13 = ((String *)*((item->choices)->objects + choice))->data;
        }
        {
#line 578
        tmp___14 = strlen((char const   *)tmp___13);
#line 578
        wmove(tempwin, 2 + currentfield, (int )(((size_t )maxpromptwidth + tmp___14) + 4UL));
#line 581
        wrefresh(tempwin);
        }
        {
#line 584
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 584
          if (! (! done)) {
#line 584
            goto while_break___5;
          }
          {
#line 585
          ch = CURgetch(cur);
#line 586
          oldchoice = choice;
          }
#line 587
          if (ch == 32) {
#line 588
            choice ++;
          } else {
#line 590
            done = 1;
          }
#line 592
          if (choice == (item->choices)->Top) {
#line 593
            choice = 0;
          }
          {
#line 596
          wmove(tempwin, 2 + currentfield, maxpromptwidth + 4);
          }
#line 598
          if (((String *)*((item->choices)->objects + oldchoice))->len < 0) {
#line 598
            tmp___15 = (char *)((void *)0);
          } else {
#line 598
            tmp___15 = ((String *)*((item->choices)->objects + oldchoice))->data;
          }
          {
#line 598
          tmp___16 = strlen((char const   *)tmp___15);
#line 598
          i = (int )tmp___16;
          }
          {
#line 598
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 598
            if (! (i > 0)) {
#line 598
              goto while_break___6;
            }
            {
#line 599
            waddch(tempwin, (chtype const   )' ');
#line 598
            i --;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 601
          wmove(tempwin, 2 + currentfield, maxpromptwidth + 4);
          }
#line 603
          if (((String *)*((item->choices)->objects + choice))->len < 0) {
#line 603
            tmp___17 = (char *)((void *)0);
          } else {
#line 603
            tmp___17 = ((String *)*((item->choices)->objects + choice))->data;
          }
          {
#line 603
          waddnstr(tempwin, (char const   *)tmp___17, -1);
#line 604
          item->chooseitem = choice;
#line 605
          wrefresh(tempwin);
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 607
        wmove(tempwin, 4 + numprompts, (COLS - 22) / 2);
#line 608
        waddnstr(tempwin, "                       ", -1);
        }
      } else
#line 610
      if ((unsigned int )item->type == 1U) {
#line 611
        ch = '\t';
      } else {
#line 614
        tmpbuffer[0] = (char )'\000';
#line 616
        if ((item->response)->len < 0) {
#line 616
          tmp___19 = (char *)((void *)0);
        } else {
#line 616
          tmp___19 = (item->response)->data;
        }
#line 616
        if ((unsigned long )tmp___19 != (unsigned long )((void *)0)) {
#line 617
          if ((item->response)->len < 0) {
#line 617
            tmp___18 = (char *)((void *)0);
          } else {
#line 617
            tmp___18 = (item->response)->data;
          }
          {
#line 617
          strcpy((char */* __restrict  */)(tmpbuffer), (char const   */* __restrict  */)tmp___18);
          }
        }
#line 619
        if ((item->response)->len < 0) {
#line 619
          tmp___20 = (char *)((void *)0);
        } else {
#line 619
          tmp___20 = (item->response)->data;
        }
        {
#line 619
        ch = CURwgetstr(cur, tempwin, tmp___20, maxlength, hidden);
#line 622
        STRset(item->response, tmpbuffer);
        }
      }
      {
#line 628
      if (ch == 258) {
#line 628
        goto case_258;
      }
#line 628
      if (ch == 9) {
#line 628
        goto case_258;
      }
#line 638
      if (ch == 259) {
#line 638
        goto case_259;
      }
#line 650
      if (ch == -1) {
#line 650
        goto case_neg_1;
      }
#line 650
      if (ch == 7) {
#line 650
        goto case_neg_1;
      }
#line 655
      if (ch == 10) {
#line 655
        goto case_10;
      }
#line 625
      goto switch_break___0;
      case_258: /* CIL Label */ 
      case_9: /* CIL Label */ 
      {
#line 630
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 631
        currentfield = (currentfield + 1) % numprompts;
#line 630
        if (! (currentfield == numprompts)) {
#line 630
          if (! ((unsigned int )((ITEM *)*(form->objects + (currentfield + currentform * pagesize)))->type == 1U)) {
#line 630
            goto while_break___7;
          }
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 636
      goto switch_break___0;
      case_259: /* CIL Label */ 
      {
#line 639
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 640
        currentfield --;
#line 641
        if (currentfield < 0) {
#line 642
          currentfield = numprompts - 1;
        }
#line 639
        if (! ((unsigned int )((ITEM *)*(form->objects + (currentfield + currentform * pagesize)))->type == 1U)) {
#line 639
          goto while_break___8;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 647
      goto switch_break___0;
      case_neg_1: /* CIL Label */ 
      case_7: /* CIL Label */ 
      {
#line 652
      delwin(tempwin);
      }
#line 653
      return (-1);
      case_10: /* CIL Label */ 
#line 656
      currentform ++;
#line 657
      if (currentform == numforms) {
        {
#line 658
        delwin(tempwin);
        }
#line 659
        return (0);
      } else {
        {
#line 661
        wclear(tempwin);
#line 662
        thisformdone = 1;
        }
      }
#line 664
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 668
  return (0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
static void RBTleft_right___0(RBTree *thetree , RBTree_node *child , RBTree_node *parent ,
                              RBTree_node *grandparent , RBTree_node *great_grandparent ) ;
#line 50
static void RBTright_left___0(RBTree *thetree , RBTree_node *child , RBTree_node *parent ,
                              RBTree_node *grandparent , RBTree_node *great_grandparent ) ;
#line 57
static void RBTright_right___0(RBTree *thetree , RBTree_node *parent , RBTree_node *grandparent ,
                               RBTree_node *great_grandparent ) ;
#line 63
static void RBTleft_left___0(RBTree *thetree , RBTree_node *parent , RBTree_node *grandparent ,
                             RBTree_node *great_grandparent ) ;
#line 103 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
static void RBTred_sibling_ck___0(RBTree_node *child , RBTree_node *parent ) 
{ 


  {
#line 106
  if ((unsigned int )child->rb_right == 0U) {
#line 106
    if ((unsigned int )child->rb_left == 0U) {
#line 109
      child->rb_right = (nodecolor )1;
#line 110
      child->rb_left = (nodecolor )1;
#line 114
      if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 115
        if ((unsigned int )parent->last_pass == 0U) {
#line 116
          parent->rb_left = (nodecolor )0;
        } else {
#line 118
          parent->rb_right = (nodecolor )0;
        }
      }
    }
  }
#line 121
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
static int RBTbalance___0(RBTree *thetree , RBTree_node *child , RBTree_node *parent ,
                          RBTree_node *grandparent , RBTree_node *great_grandparent ) 
{ 


  {
#line 134
  if ((unsigned long )grandparent != (unsigned long )((void *)0)) {
#line 135
    if ((unsigned int )parent->last_pass == 0U) {
#line 136
      if ((unsigned int )parent->rb_left == 0U) {
#line 137
        if ((unsigned int )grandparent->last_pass == 0U) {
#line 138
          if ((unsigned int )grandparent->rb_left == 0U) {
            {
#line 139
            RBTleft_left___0(thetree, parent, grandparent, great_grandparent);
            }
#line 141
            return (1);
          }
        } else
#line 144
        if ((unsigned int )grandparent->rb_right == 0U) {
          {
#line 145
          RBTright_left___0(thetree, child, parent, grandparent, great_grandparent);
          }
#line 147
          return (1);
        }
      }
    } else
#line 151
    if ((unsigned int )parent->rb_right == 0U) {
#line 152
      if ((unsigned int )grandparent->last_pass == 0U) {
#line 153
        if ((unsigned int )grandparent->rb_left == 0U) {
          {
#line 154
          RBTleft_right___0(thetree, child, parent, grandparent, great_grandparent);
          }
#line 156
          return (1);
        }
      } else
#line 159
      if ((unsigned int )grandparent->rb_right == 0U) {
        {
#line 160
        RBTright_right___0(thetree, parent, grandparent, great_grandparent);
        }
#line 162
        return (1);
      }
    }
  }
#line 168
  return (0);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
static void RBTleft_right___0(RBTree *thetree , RBTree_node *child , RBTree_node *parent ,
                              RBTree_node *grandparent , RBTree_node *great_grandparent ) 
{ 
  RBTree_node *temp[2] ;

  {
#line 185
  if ((unsigned long )great_grandparent != (unsigned long )((void *)0)) {
#line 186
    if ((unsigned int )great_grandparent->last_pass == 1U) {
#line 187
      great_grandparent->r_child = child;
    } else {
#line 189
      great_grandparent->l_child = child;
    }
  } else {
#line 191
    thetree->entry = child;
  }
#line 193
  temp[0] = child->l_child;
#line 194
  temp[1] = child->r_child;
#line 196
  grandparent->l_child = temp[1];
#line 197
  parent->r_child = temp[0];
#line 198
  child->r_child = grandparent;
#line 199
  child->l_child = parent;
#line 202
  grandparent->rb_left = (nodecolor )1;
#line 203
  parent->rb_right = (nodecolor )1;
#line 204
  child->rb_left = (nodecolor )0;
#line 205
  child->rb_right = (nodecolor )0;
#line 206
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
static void RBTright_left___0(RBTree *thetree , RBTree_node *child , RBTree_node *parent ,
                              RBTree_node *grandparent , RBTree_node *great_grandparent ) 
{ 
  RBTree_node *temp[2] ;

  {
#line 222
  if ((unsigned long )great_grandparent != (unsigned long )((void *)0)) {
#line 223
    if ((unsigned int )great_grandparent->last_pass == 1U) {
#line 224
      great_grandparent->r_child = child;
    } else {
#line 226
      great_grandparent->l_child = child;
    }
  } else {
#line 229
    thetree->entry = child;
  }
#line 231
  temp[0] = child->l_child;
#line 232
  temp[1] = child->r_child;
#line 235
  grandparent->r_child = temp[0];
#line 236
  parent->l_child = temp[1];
#line 237
  child->l_child = grandparent;
#line 238
  child->r_child = parent;
#line 242
  grandparent->rb_right = (nodecolor )1;
#line 243
  parent->rb_left = (nodecolor )1;
#line 244
  child->rb_right = (nodecolor )0;
#line 245
  child->rb_left = (nodecolor )0;
#line 246
  return;
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
static void RBTright_right___0(RBTree *thetree , RBTree_node *parent , RBTree_node *grandparent ,
                               RBTree_node *great_grandparent ) 
{ 
  RBTree_node *temp ;

  {
#line 261
  if ((unsigned long )great_grandparent != (unsigned long )((void *)0)) {
#line 262
    if ((unsigned int )great_grandparent->last_pass == 1U) {
#line 263
      great_grandparent->r_child = parent;
    } else {
#line 265
      great_grandparent->l_child = parent;
    }
  } else {
#line 268
    thetree->entry = parent;
  }
#line 270
  temp = parent->l_child;
#line 271
  grandparent->r_child = temp;
#line 272
  parent->l_child = grandparent;
#line 276
  grandparent->rb_right = (nodecolor )1;
#line 277
  parent->rb_left = (nodecolor )0;
#line 278
  return;
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
static void RBTleft_left___0(RBTree *thetree , RBTree_node *parent , RBTree_node *grandparent ,
                             RBTree_node *great_grandparent ) 
{ 
  RBTree_node *temp ;

  {
#line 295
  if ((unsigned long )great_grandparent != (unsigned long )((void *)0)) {
#line 296
    great_grandparent->l_child = parent;
  } else {
#line 298
    thetree->entry = parent;
  }
#line 300
  temp = parent->r_child;
#line 301
  grandparent->l_child = temp;
#line 302
  parent->r_child = grandparent;
#line 304
  grandparent->rb_left = (nodecolor )1;
#line 305
  parent->rb_right = (nodecolor )0;
#line 307
  return;
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/RBTree.c"
static void RBTinorder___0(RBTree_node *node , void (*func)() ) 
{ 


  {
#line 409
  if ((unsigned long )node != (unsigned long )((void *)0)) {
    {
#line 411
    RBTinorder___0(node->l_child, func);
#line 413
    (*func)(node->data);
#line 415
    RBTinorder___0(node->r_child, func);
    }
  }
#line 417
  return;
}
}
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 538
extern int getchar(void) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.h"
RCMapObj *RCMnew(void) ;
#line 86
void RCMdestroy(RCMapObj *rcm ) ;
#line 87
void RCMinit(RCMapObj *rcm ) ;
#line 100
int RCMAviewSearch(RCMAarray *rcma , char *view ) ;
#line 101
boolean RCMAfromLine(RCMAarray *rcma , char *line ) ;
#line 102
void RCMAtoFile(RCMAarray *rcma , FileIO *fio ) ;
#line 137
RCobj *RCnew(void) ;
#line 138
void RCsetdefs(RCobj *rc ) ;
#line 139
void RCfromFile(RCobj *rc , FileIO *rcfio ) ;
#line 140
void RCtoFile(RCobj *rc ) ;
#line 141
boolean RCisGlobalNew(void) ;
#line 149
void RCMcpy(RCMapObj *dest , RCMapObj *orig ) ;
#line 150
void RCMdisplayCommand(RCMapObj *rcm , char *filename , char *line ) ;
#line 151
void RCMprintCommand(RCMapObj *rcm , char *filename , char *line ) ;
#line 157
void RCfromENV(RCobj *rc ) ;
#line 158
void RCfromUser(RCobj *rc ) ;
#line 159
void RCreadGlobalRC(RCobj *rc ) ;
#line 162
boolean RCdisplayCommand(RCobj *rc , char *view , char *filename , char *line ) ;
#line 163
boolean RCprintCommand(RCobj *rc , char *view , char *filename , char *line ) ;
#line 134 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
RCobj *GlobalRC ;
#line 140
BOOLEAN SecureMode ;
#line 141
BOOLEAN NoShellMode ;
#line 142
BOOLEAN RemoteUser ;
#line 185
void CursesErrorMsg(char *Message ) ;
#line 229 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
RCMapObj *RCMnew(void) 
{ 
  RCMapObj *rcm ;
  void *tmp ;

  {
  {
#line 234
  tmp = malloc(sizeof(RCMapObj ));
#line 234
  rcm = (RCMapObj *)tmp;
#line 236
  rcm->view = STRnew();
#line 237
  rcm->displaycmd = STRnew();
#line 238
  rcm->printcmd = STRnew();
  }
#line 240
  return (rcm);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
void RCMdestroy(RCMapObj *rcm ) 
{ 


  {
  {
#line 246
  STRdestroy(rcm->view);
#line 247
  STRdestroy(rcm->displaycmd);
#line 248
  STRdestroy(rcm->printcmd);
#line 249
  free((void *)rcm);
  }
#line 250
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
void RCMinit(RCMapObj *rcm ) 
{ 


  {
  {
#line 255
  STRinit(rcm->view);
#line 256
  STRinit(rcm->displaycmd);
#line 257
  STRinit(rcm->printcmd);
  }
#line 258
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
void RCMcpy(RCMapObj *dest , RCMapObj *orig ) 
{ 


  {
  {
#line 264
  STRcpy(dest->view, orig->view);
#line 265
  STRcpy(dest->displaycmd, orig->displaycmd);
#line 266
  STRcpy(dest->printcmd, orig->printcmd);
  }
#line 267
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
static void RCMsubst_percent_s(RCMapObj *rcm , char *filename , char *line , char *zeline ) 
{ 
  size_t tmp ;

  {
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if ((int )*zeline == 0) {
#line 282
      *line = (char )'\000';
#line 283
      return;
    } else
#line 286
    if ((int )*zeline == 37) {
#line 287
      if ((int )*(zeline + 1) == 115) {
        {
#line 288
        strcpy((char */* __restrict  */)line, (char const   */* __restrict  */)filename);
#line 289
        tmp = strlen((char const   *)filename);
#line 289
        line += tmp;
#line 290
        zeline += 2;
        }
      } else {
#line 292
        *line = *zeline;
#line 293
        line ++;
#line 294
        zeline ++;
      }
    } else {
#line 298
      *line = *zeline;
#line 299
      line ++;
#line 300
      zeline ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
void RCMdisplayCommand(RCMapObj *rcm , char *filename , char *line ) 
{ 
  char *zeline ;
  char *tmp ;

  {
#line 318
  if ((rcm->displaycmd)->len < 0) {
#line 318
    tmp = (char *)((void *)0);
  } else {
#line 318
    tmp = (rcm->displaycmd)->data;
  }
  {
#line 318
  zeline = tmp;
#line 319
  RCMsubst_percent_s(rcm, filename, line, zeline);
  }
#line 320
  return;
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
void RCMprintCommand(RCMapObj *rcm , char *filename , char *line ) 
{ 
  char *zeline ;
  char *tmp ;

  {
#line 335
  if ((rcm->printcmd)->len < 0) {
#line 335
    tmp = (char *)((void *)0);
  } else {
#line 335
    tmp = (rcm->printcmd)->data;
  }
  {
#line 335
  zeline = tmp;
#line 336
  RCMsubst_percent_s(rcm, filename, line, zeline);
  }
#line 337
  return;
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
int RCMAviewSearch(RCMAarray *rcma , char *view ) 
{ 
  int i ;
  RCMapObj *temp ;
  char viewstowage[64] ;
  char *tempview ;
  char *cp ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 353
  tempview = view;
#line 355
  cp = strchr((char const   *)view, ' ');
  }
#line 355
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 356
    strcpy((char */* __restrict  */)(viewstowage), (char const   */* __restrict  */)view);
#line 357
    viewstowage[cp - view] = (char )'\000';
#line 358
    tempview = viewstowage;
    }
  }
#line 364
  i = 0;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! (i < rcma->Top)) {
#line 364
      goto while_break;
    }
#line 365
    temp = (RCMapObj *)*(rcma->objects + i);
#line 367
    if ((temp->view)->len < 0) {
#line 367
      tmp = (char *)((void *)0);
    } else {
#line 367
      tmp = (temp->view)->data;
    }
    {
#line 367
    tmp___0 = strcasecmp((char const   *)tempview, (char const   *)tmp);
    }
#line 367
    if (tmp___0 == 0) {
#line 368
      return (i);
    }
#line 364
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  return (-1);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
boolean RCMAfromLine(RCMAarray *rcma , char *line ) 
{ 
  char *cp ;
  RCMapObj *rcm ;
  char *view ;
  char *dcmd ;
  char *pcmd ;
  int num ;

  {
  {
#line 385
  view = line;
#line 387
  cp = strchr((char const   *)line, ',');
  }
#line 388
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 389
    return (0);
  }
  {
#line 391
  *cp = (char )'\000';
#line 392
  dcmd = cp + 1;
#line 394
  cp = strchr((char const   *)dcmd, ',');
  }
#line 395
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 396
    return (0);
  }
  {
#line 398
  *cp = (char )'\000';
#line 399
  pcmd = cp + 1;
#line 401
  num = RCMAviewSearch(rcma, view);
  }
#line 401
  if (num >= 0) {
#line 402
    rcm = (RCMapObj *)*(rcma->objects + num);
  } else {
    {
#line 404
    rcm = RCMnew();
    }
  }
  {
#line 406
  STRset(rcm->view, view);
#line 407
  STRset(rcm->displaycmd, dcmd);
#line 408
  STRset(rcm->printcmd, pcmd);
  }
#line 410
  if (num < 0) {
    {
#line 411
    DApush(rcma, (char *)rcm);
#line 412
    RCMdestroy(rcm);
    }
  }
#line 415
  return (1);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
void RCMAtoFile(RCMAarray *rcma , FileIO *fio ) 
{ 
  int i ;
  RCMapObj *rcm ;
  char tmpstr[512] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 430
  i = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! (i < rcma->Top)) {
#line 430
      goto while_break;
    }
#line 431
    rcm = (RCMapObj *)*(rcma->objects + i);
#line 432
    if ((rcm->printcmd)->len < 0) {
#line 432
      tmp = (char *)((void *)0);
    } else {
#line 432
      tmp = (rcm->printcmd)->data;
    }
#line 432
    if ((rcm->displaycmd)->len < 0) {
#line 432
      tmp___0 = (char *)((void *)0);
    } else {
#line 432
      tmp___0 = (rcm->displaycmd)->data;
    }
#line 432
    if ((rcm->view)->len < 0) {
#line 432
      tmp___1 = (char *)((void *)0);
    } else {
#line 432
      tmp___1 = (rcm->view)->data;
    }
    {
#line 432
    sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"map: %s,%s,%s\n",
            tmp___1, tmp___0, tmp);
#line 434
    FIOwritestring(fio, tmpstr);
#line 430
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 437
  return;
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
RCobj *RCnew(void) 
{ 
  RCobj *rc ;
  void *tmp ;
  DynArray *tmp___0 ;

  {
  {
#line 454
  tmp = malloc(sizeof(RCobj ));
#line 454
  rc = (RCobj *)tmp;
#line 456
  tmp___0 = DAnew(20, & RCMnew, (void *)0, & RCMdestroy, & RCMcpy);
#line 456
  rc->commands = tmp___0;
#line 457
  rc->Bookmarks = (GopherDirObj *)((void *)0);
#line 458
  rc->Home = (GopherObj *)((void *)0);
#line 459
  rc->ChangedDefs = 0;
#line 461
  rc->SearchBolding = 1;
#line 462
  rc->ANSIprinter = 0;
#line 467
  RCsetdefs(rc);
  }
#line 472
  return (rc);
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
static FileIO *rcopen(int flags ) 
{ 
  char rcfilename[256] ;
  FileIO *fio ;
  char *home ;

  {
  {
#line 484
  home = getenv("HOME");
  }
#line 485
  if ((unsigned long )home == (unsigned long )((void *)0)) {
#line 486
    return ((FileIO *)((void *)0));
  }
  {
#line 490
  strcpy((char */* __restrict  */)(rcfilename), (char const   */* __restrict  */)home);
#line 491
  strcat((char */* __restrict  */)(rcfilename), (char const   */* __restrict  */)"/.gopherrc");
#line 497
  fio = FIOopenUFS(rcfilename, flags, 420);
  }
#line 499
  return (fio);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
void RCfromFile(RCobj *rc , FileIO *rcfio ) 
{ 
  char inputline___0[512] ;
  int tmp ;
  int tmp___0 ;
  boolean tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 508
    tmp___7 = FIOreadline(rcfio, inputline___0, (int )sizeof(inputline___0));
    }
#line 508
    if (! tmp___7) {
#line 508
      goto while_break;
    }
#line 510
    if ((int )inputline___0[0] == 35) {
#line 511
      goto while_continue;
    }
    {
#line 513
    ZapCRLF(inputline___0);
#line 514
    tmp___6 = strncasecmp((char const   *)(inputline___0), "bookmarks:", (size_t )9);
    }
#line 514
    if (tmp___6 == 0) {
#line 516
      if ((unsigned long )rc->Bookmarks == (unsigned long )((void *)0)) {
        {
#line 517
        rc->Bookmarks = GDnew(32);
        }
      }
      {
#line 519
      GDfromLink(rc->Bookmarks, rcfio, (char *)"localhost", 70, (char *)"", (char *)"localhost");
#line 521
      STRset((rc->Bookmarks)->Title, (char *)"Bookmarks");
      }
    } else {
      {
#line 522
      tmp___5 = strncasecmp((char const   *)(inputline___0), "home:", (size_t )5);
      }
#line 522
      if (tmp___5 == 0) {
#line 523
        if ((unsigned long )rc->Home == (unsigned long )((void *)0)) {
          {
#line 524
          rc->Home = GSnew();
#line 525
          GSfromLink(rc->Home, rcfio, (char *)"localhost", 70, (char *)"", (char *)"localhost");
          }
        }
      } else {
        {
#line 527
        tmp___4 = strncasecmp((char const   *)(inputline___0), "searchbolding: ",
                              (size_t )15);
        }
#line 527
        if (tmp___4 == 0) {
          {
#line 528
          tmp = strcasecmp((char const   *)(inputline___0 + 15), "yes");
          }
#line 528
          if (tmp == 0) {
#line 529
            rc->SearchBolding = 1;
          } else {
#line 531
            rc->SearchBolding = 0;
          }
        } else {
          {
#line 532
          tmp___3 = strncasecmp((char const   *)(inputline___0), "useansiprinter: ",
                                (size_t )16);
          }
#line 532
          if (tmp___3 == 0) {
            {
#line 533
            tmp___0 = strcasecmp((char const   *)(inputline___0 + 16), "yes");
            }
#line 533
            if (tmp___0 == 0) {
#line 534
              rc->ANSIprinter = 1;
            } else {
#line 536
              rc->ANSIprinter = 0;
            }
          } else {
            {
#line 541
            tmp___2 = strncasecmp((char const   *)(inputline___0), "map: ", (size_t )5);
            }
#line 541
            if (tmp___2 == 0) {
              {
#line 543
              tmp___1 = RCMAfromLine(rc->commands, inputline___0 + 5);
              }
#line 543
              if (tmp___1 == 0) {
                {
#line 545
                printf((char const   */* __restrict  */)"Warning, bad line in gopherrc: %s\n",
                       inputline___0);
#line 546
                sleep(2U);
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 553
  return;
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
void RCfromENV(RCobj *rc ) 
{ 
  char tmpstr[512] ;
  char Printer[128] ;
  char PrinterP[128] ;
  char Pager[128] ;
  char PagerP[128] ;
  boolean PrinterFlag ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  boolean tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  boolean tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  boolean tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  boolean tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;

  {
  {
#line 570
  PrinterFlag = 0;
#line 572
  tmp___6 = getenv("GOPHER_PRINTER");
  }
#line 572
  if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
    {
#line 573
    PrinterFlag = 1;
#line 574
    tmp = getenv("GOPHER_PRINTER");
#line 574
    strcpy((char */* __restrict  */)(Printer), (char const   */* __restrict  */)tmp);
#line 575
    strcpy((char */* __restrict  */)(PrinterP), (char const   */* __restrict  */)(Printer));
    }
  } else {
    {
#line 578
    tmp___2 = RCprintCommand(GlobalRC, (char *)"Text", (char *)"", Printer);
    }
#line 578
    if (tmp___2) {
      {
#line 579
      tmp___1 = strlen((char const   *)(Printer));
      }
#line 579
      if ((int )Printer[tmp___1 - 1UL] == 32) {
        {
#line 580
        tmp___0 = strlen((char const   *)(Printer));
#line 580
        Printer[tmp___0 - 1UL] = (char )'\000';
        }
      }
    } else {
      {
#line 583
      strcpy((char */* __restrict  */)(Printer), (char const   */* __restrict  */)"lpr");
      }
    }
    {
#line 585
    tmp___5 = RCprintCommand(GlobalRC, (char *)"Text/plain", (char *)"", PrinterP);
    }
#line 585
    if (tmp___5) {
      {
#line 586
      tmp___4 = strlen((char const   *)(PrinterP));
      }
#line 586
      if ((int )PrinterP[tmp___4 - 1UL] == 32) {
        {
#line 587
        tmp___3 = strlen((char const   *)(PrinterP));
#line 587
        PrinterP[tmp___3 - 1UL] = (char )'\000';
        }
      }
    } else {
      {
#line 590
      strcpy((char */* __restrict  */)(PrinterP), (char const   */* __restrict  */)"lpr");
      }
    }
  }
  {
#line 593
  tmp___17 = getenv("PAGER");
  }
#line 593
  if ((unsigned long )tmp___17 != (unsigned long )((void *)0)) {
    {
#line 594
    tmp___7 = getenv("PAGER");
#line 594
    sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"Text,%s %%s,%s %%s",
            tmp___7, Printer);
#line 595
    RCMAfromLine(rc->commands, tmpstr);
#line 597
    tmp___8 = getenv("PAGER");
#line 597
    sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"Text/plain,%s %%s,%s %%s",
            tmp___8, PrinterP);
#line 598
    RCMAfromLine(rc->commands, tmpstr);
    }
  } else
#line 600
  if (PrinterFlag) {
    {
#line 601
    tmp___11 = RCdisplayCommand(GlobalRC, (char *)"Text", (char *)"", Pager);
    }
#line 601
    if (tmp___11) {
      {
#line 602
      tmp___10 = strlen((char const   *)(Pager));
      }
#line 602
      if ((int )Pager[tmp___10 - 1UL] == 32) {
        {
#line 603
        tmp___9 = strlen((char const   *)(Pager));
#line 603
        Pager[tmp___9 - 1UL] = (char )'\000';
        }
      }
    } else {
      {
#line 606
      strcpy((char */* __restrict  */)(Pager), (char const   */* __restrict  */)"builtin");
      }
    }
    {
#line 608
    tmp___12 = strncasecmp((char const   *)(Pager), "builtin", (size_t )7);
    }
#line 608
    if (tmp___12 == 0) {
      {
#line 609
      sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"Text,%s,%s %%s",
              Pager, Printer);
      }
    } else {
      {
#line 611
      sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"Text,%s %%s,%s %%s",
              Pager, Printer);
      }
    }
    {
#line 612
    RCMAfromLine(rc->commands, tmpstr);
#line 614
    tmp___15 = RCdisplayCommand(GlobalRC, (char *)"Text/plain", (char *)"", PagerP);
    }
#line 614
    if (tmp___15) {
      {
#line 615
      tmp___14 = strlen((char const   *)(PagerP));
      }
#line 615
      if ((int )PagerP[tmp___14 - 1UL] == 32) {
        {
#line 616
        tmp___13 = strlen((char const   *)(PagerP));
#line 616
        PagerP[tmp___13 - 1UL] = (char )'\000';
        }
      }
    } else {
      {
#line 619
      strcpy((char */* __restrict  */)(PagerP), (char const   */* __restrict  */)"builtin");
      }
    }
    {
#line 621
    tmp___16 = strncasecmp((char const   *)(PagerP), "builtin", (size_t )7);
    }
#line 621
    if (tmp___16 == 0) {
      {
#line 622
      sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"Text/plain,%s,%s %%s",
              PagerP, PrinterP);
      }
    } else {
      {
#line 624
      sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"Text/plain,%s %%s,%s %%s",
              PagerP, PrinterP);
      }
    }
    {
#line 625
    RCMAfromLine(rc->commands, tmpstr);
    }
  }
  {
#line 628
  tmp___19 = getenv("GOPHER_TELNET");
  }
#line 628
  if ((unsigned long )tmp___19 != (unsigned long )((void *)0)) {
    {
#line 629
    tmp___18 = getenv("GOPHER_TELNET");
#line 629
    sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"Terminal/telnet,%s %%s,",
            tmp___18);
#line 630
    RCMAfromLine(rc->commands, tmpstr);
    }
  }
  {
#line 633
  tmp___21 = getenv("GOPHER_TN3270");
  }
#line 633
  if ((unsigned long )tmp___21 != (unsigned long )((void *)0)) {
    {
#line 634
    tmp___20 = getenv("GOPHER_TN3270");
#line 634
    sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"Terminal/tn3270,%s %%s,",
            tmp___20);
#line 635
    RCMAfromLine(rc->commands, tmpstr);
    }
  }
  {
#line 638
  tmp___23 = getenv("GOPHER_HTML");
  }
#line 638
  if ((unsigned long )tmp___23 != (unsigned long )((void *)0)) {
    {
#line 639
    tmp___22 = getenv("GOPHER_HTML");
#line 639
    sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"text/html,%s,",
            tmp___22);
#line 640
    RCMAfromLine(rc->commands, tmpstr);
    }
  }
#line 642
  return;
}
}
#line 650 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
void RCfromUser(RCobj *rc ) 
{ 
  FileIO *rcfile ;
  char *home ;
  int tmp ;

  {
  {
#line 656
  home = getenv("HOME");
  }
#line 658
  if ((unsigned long )home == (unsigned long )((void *)0)) {
#line 659
    return;
  }
  {
#line 661
  rcfile = rcopen(0);
  }
#line 663
  if ((unsigned long )rcfile == (unsigned long )((void *)0)) {
#line 665
    if (! NoShellMode) {
      {
#line 667
      rcfile = rcopen(64);
#line 668
      FIOclose(rcfile);
#line 669
      printf((char const   */* __restrict  */)"Welcome to the wonderful world of Gopher!\n\n");
#line 670
      printf((char const   */* __restrict  */)"Gopher has limitations on its use and comes without\n");
#line 671
      printf((char const   */* __restrict  */)"a warranty.  Please refer to the file \'Copyright\' included\n");
#line 672
      printf((char const   */* __restrict  */)"in the distribution.\n\n");
#line 673
      printf((char const   */* __restrict  */)"Internet Gopher Information Client %s.%s patch%d (%s)\n",
             "3", "0", 12, "FurryTerror");
#line 676
      printf((char const   */* __restrict  */)"Copyright (C) 1991-2000 by the Regents of the University of Minnesota\nCopyright (C) 2000-2005 John Goerzen and the gopher developers\n\n");
#line 677
      printf((char const   */* __restrict  */)"Press RETURN to continue\n");
      }
      {
#line 678
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 678
        tmp = getchar();
        }
#line 678
        if (! (10 != tmp)) {
#line 678
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 681
    return;
  } else {
    {
#line 684
    RCfromFile(GlobalRC, rcfile);
    }
  }
  {
#line 686
  FIOclose(rcfile);
  }
#line 691
  return;
}
}
#line 694 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
void RCreadGlobalRC(RCobj *rc ) 
{ 
  FileIO *rcfile ;

  {
#line 699
  if (RemoteUser) {
    {
#line 700
    rcfile = FIOopenUFS((char *)"//usr/local/etc/gopher/gopherremote.rc", 0, 0);
    }
  } else {
    {
#line 702
    rcfile = FIOopenUFS((char *)"//usr/local/etc/gopher/gopher.rc", 0, 0);
    }
  }
#line 704
  if ((unsigned long )rcfile != (unsigned long )((void *)0)) {
    {
#line 705
    RCfromFile(rc, rcfile);
#line 707
    FIOclose(rcfile);
    }
  }
#line 709
  return;
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
void RCsetdefs(RCobj *rc ) 
{ 
  char tmpstr[512] ;
  int tmp ;

  {
  {
#line 723
  sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"Text,%s,%s %%s",
          "builtin", "lpr");
#line 724
  RCMAfromLine(rc->commands, tmpstr);
#line 726
  sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"Text/plain,%s,%s %%s",
          "builtin", "lpr");
#line 727
  RCMAfromLine(rc->commands, tmpstr);
#line 729
  sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"Audio/basic,%s,",
          "/bin/false");
#line 730
  RCMAfromLine(rc->commands, tmpstr);
#line 732
  tmp = strncasecmp("xv %s", "- none -", (size_t )8);
  }
#line 732
  if (tmp == 0) {
    {
#line 733
    sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"Image,%s,",
            "xv %s");
    }
  } else {
    {
#line 735
    sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"Image,%s,%s %%s",
            "xv %s", "lpr");
    }
  }
  {
#line 736
  RCMAfromLine(rc->commands, tmpstr);
#line 738
  sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"Terminal/telnet,%s %%s,",
          "telnet");
#line 739
  RCMAfromLine(rc->commands, tmpstr);
#line 741
  sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"Terminal/tn3270,%s %%s,",
          "tn3270");
#line 742
  RCMAfromLine(rc->commands, tmpstr);
#line 744
  sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"text/html,%s,",
          "- none -");
#line 745
  RCMAfromLine(rc->commands, tmpstr);
#line 747
  RCreadGlobalRC(rc);
  }
#line 748
  return;
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
void RCtoFile(RCobj *rc ) 
{ 
  FileIO *rcfile ;
  char rcfilename[512] ;
  char oldrcfilename[512] ;
  char *home ;
  int tmp ;

  {
  {
#line 759
  home = getenv("HOME");
  }
#line 761
  if ((unsigned long )home == (unsigned long )((void *)0)) {
#line 762
    return;
  }
#line 766
  if (SecureMode) {
#line 767
    return;
  }
  {
#line 772
  strcpy((char */* __restrict  */)(rcfilename), (char const   */* __restrict  */)home);
#line 773
  strcat((char */* __restrict  */)(rcfilename), (char const   */* __restrict  */)"/.gopherrc");
#line 774
  strcpy((char */* __restrict  */)(oldrcfilename), (char const   */* __restrict  */)home);
#line 775
  strcat((char */* __restrict  */)(oldrcfilename), (char const   */* __restrict  */)"/.gopherrc~");
#line 777
  rcfile = FIOopenUFS(rcfilename, 0, 0);
  }
#line 779
  if ((unsigned long )rcfile != (unsigned long )((void *)0)) {
    {
#line 780
    tmp = rename((char const   *)(rcfilename), (char const   *)(oldrcfilename));
    }
#line 780
    if (tmp < 0) {
      {
#line 781
      CursesErrorMsg((char *)"Aborting gopher configuration save!!");
      }
#line 782
      return;
    }
  }
  {
#line 785
  FIOclose(rcfile);
#line 791
  rcfile = FIOopenUFS(rcfilename, 577, 420);
  }
#line 793
  if ((unsigned long )rcfile == (unsigned long )((void *)0)) {
    {
#line 797
    CursesErrorMsg((char *)"Can\'t write gopher configuration file!!");
    }
#line 799
    return;
  }
  {
#line 802
  FIOwritestring(rcfile, (char *)"RCversion: 1.1\n");
  }
#line 804
  if (! NoShellMode) {
    {
#line 805
    RCMAtoFile(rc->commands, rcfile);
    }
  }
#line 806
  if (! NoShellMode) {
    {
#line 807
    FIOwritestring(rcfile, (char *)"SearchBolding: ");
    }
#line 808
    if (rc->SearchBolding) {
      {
#line 809
      FIOwritestring(rcfile, (char *)"yes\n");
      }
    } else {
      {
#line 811
      FIOwritestring(rcfile, (char *)"no\n");
      }
    }
  }
#line 814
  if (! NoShellMode) {
    {
#line 815
    FIOwritestring(rcfile, (char *)"UseANSIprinter: ");
    }
#line 816
    if (rc->ANSIprinter) {
      {
#line 817
      FIOwritestring(rcfile, (char *)"yes\n");
      }
    } else {
      {
#line 819
      FIOwritestring(rcfile, (char *)"no\n");
      }
    }
  }
#line 822
  if ((unsigned long )rc->Home != (unsigned long )((void *)0)) {
    {
#line 823
    FIOwritestring(rcfile, (char *)"\nhome:\n");
#line 824
    GStoLink(rc->Home, rcfile->fd, 0);
    }
  }
#line 827
  if ((unsigned long )GlobalRC->Bookmarks != (unsigned long )((void *)0)) {
    {
#line 828
    FIOwritestring(rcfile, (char *)"\nbookmarks:\n");
#line 829
    GDtoLink(GlobalRC->Bookmarks, rcfile->fd);
    }
  }
  {
#line 832
  FIOwritestring(rcfile, (char *)"\n");
#line 833
  FIOclose(rcfile);
  }
#line 838
  return;
}
}
#line 848 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
boolean RCdisplayCommand(RCobj *rc , char *view , char *filename , char *line ) 
{ 
  int num ;

  {
  {
#line 853
  num = RCMAviewSearch(rc->commands, view);
  }
#line 855
  if (num >= 0) {
    {
#line 856
    RCMdisplayCommand((RCMapObj *)*((rc->commands)->objects + num), filename, line);
    }
#line 857
    return (1);
  } else {
#line 860
    return (0);
  }
}
}
#line 870 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
boolean RCprintCommand(RCobj *rc , char *view , char *filename , char *line ) 
{ 
  int num ;

  {
  {
#line 875
  num = RCMAviewSearch(rc->commands, view);
  }
#line 877
  if (num >= 0) {
    {
#line 878
    RCMprintCommand((RCMapObj *)*((rc->commands)->objects + num), filename, line);
    }
#line 879
    return (1);
  } else {
#line 882
    return (0);
  }
}
}
#line 890 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopherrc.c"
boolean RCisGlobalNew(void) 
{ 
  FileIO *fiolocal ;
  FileIO *fioglobal ;
  struct stat lbuf ;
  struct stat gbuf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 897
  fiolocal = rcopen(0);
  }
#line 899
  if ((unsigned long )fiolocal == (unsigned long )((void *)0)) {
#line 900
    return (0);
  }
  {
#line 903
  fioglobal = FIOopenUFS((char *)"//usr/local/etc/gopher/gopher.rc", 0, 420);
  }
#line 905
  if ((unsigned long )fioglobal == (unsigned long )((void *)0)) {
    {
#line 906
    FIOclose(fiolocal);
    }
#line 907
    return (0);
  }
  {
#line 910
  tmp = fstat(fiolocal->fd, & lbuf);
  }
#line 910
  if (tmp) {
    {
#line 911
    FIOclose(fiolocal);
#line 912
    FIOclose(fioglobal);
    }
#line 913
    return (0);
  }
  {
#line 916
  tmp___0 = fstat(fioglobal->fd, & gbuf);
  }
#line 916
  if (tmp___0) {
    {
#line 917
    FIOclose(fiolocal);
#line 918
    FIOclose(fioglobal);
    }
#line 919
    return (0);
  }
  {
#line 922
  FIOclose(fioglobal);
#line 923
  FIOclose(fiolocal);
  }
#line 925
  if (gbuf.st_mtim.tv_sec > lbuf.st_mtim.tv_sec) {
#line 926
    return (1);
  } else {
#line 928
    return (0);
  }
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/BLblock.c"
static void BLdatadestroy___0(Blockobj *bl ) 
{ 


  {
  {
#line 135
  if ((unsigned int )bl->datatype == 1U) {
#line 135
    goto case_1;
  }
#line 138
  if ((unsigned int )bl->datatype == 2U) {
#line 138
    goto case_2;
  }
#line 141
  if ((unsigned int )bl->datatype == 3U) {
#line 141
    goto case_3;
  }
#line 144
  if ((unsigned int )bl->datatype == 0U) {
#line 144
    goto case_0;
  }
#line 134
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 136
  STRdestroy(bl->data.filename);
  }
#line 137
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 139
  DAdestroy(bl->data.text);
  }
#line 140
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 142
  GSdestroy(bl->data.gs);
  }
#line 143
  goto switch_break;
  case_0: /* CIL Label */ 
#line 145
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 147
  return;
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 292 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.h"
void CURenter(CursesObj *cur ) ;
#line 293
void CURexit(CursesObj *cur ) ;
#line 311
int CURChoice(CursesObj *cur , char *WinTitle , char **Choices , char *Prompt , int DefaultChoice ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/download.h"
void Download_file(GopherObj *gs ) ;
#line 13
void BuiltinDownload(char *dirname ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.h"
void UNIXfile(char *fname ) ;
#line 24
void Save_file(GopherObj *gs , char *saveto , char *view ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/download.c"
static char *DLnames[7]  = {      (char *)"Zmodem",      (char *)"Ymodem",      (char *)"Xmodem-1K",      (char *)"Xmodem-CRC", 
        (char *)"Kermit",      (char *)"Text",      (char *)((void *)0)};
#line 163 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/download.c"
static char *DLcmds[7]  = {      (char *)"sz ",      (char *)"sb ",      (char *)"sx -k ",      (char *)"sx ", 
        (char *)"kermit -q -s ",      (char *)"cat -v ",      (char *)((void *)0)};
#line 177 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/download.c"
static char *DLcmdB[7]  = {      (char *)"sz ",      (char *)"sb ",      (char *)"sx -k ",      (char *)"sx ", 
        (char *)"kermit -q -i -s ",      (char *)"cat -v ",      (char *)((void *)0)};
#line 191 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/download.c"
void Download_file(GopherObj *gs ) 
{ 
  int choice ;
  char tmpfilename[512] ;
  char *cp ;
  char command[512] ;
  char *curcwd ;
  int start ;
  int end ;
  struct stat buf ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int len ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  boolean tmp___7 ;
  time_t tmp___8 ;
  time_t tmp___9 ;
  int tmp___10 ;

  {
  {
#line 217
  if ((int )gs->sFileType == 33) {
#line 217
    goto case_33;
  }
#line 217
  if ((int )gs->sFileType == 105) {
#line 217
    goto case_33;
  }
#line 217
  if ((int )gs->sFileType == 84) {
#line 217
    goto case_33;
  }
#line 217
  if ((int )gs->sFileType == 56) {
#line 217
    goto case_33;
  }
#line 217
  if ((int )gs->sFileType == 55) {
#line 217
    goto case_33;
  }
#line 217
  if ((int )gs->sFileType == 51) {
#line 217
    goto case_33;
  }
#line 217
  if ((int )gs->sFileType == 50) {
#line 217
    goto case_33;
  }
#line 217
  if ((int )gs->sFileType == 49) {
#line 217
    goto case_33;
  }
#line 209
  goto switch_break;
  case_33: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  {
#line 218
  CursesErrorMsg((char *)"Sorry, can\'t download that!");
  }
#line 219
  return;
  switch_break: /* CIL Label */ ;
  }
#line 222
  if ((gs->Title)->len < 0) {
#line 222
    tmp = (char *)((void *)0);
  } else {
#line 222
    tmp = (gs->Title)->data;
  }
  {
#line 222
  choice = CURChoice(CursesScreen, tmp, DLnames, (char *)"Choose a download method",
                     -1);
  }
#line 225
  if (choice == -1) {
#line 226
    return;
  }
#line 230
  if ((gs->Selstr)->len < 0) {
#line 230
    tmp___0 = (char *)((void *)0);
  } else {
#line 230
    tmp___0 = (gs->Selstr)->data;
  }
#line 230
  cp = tmp___0;
#line 231
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 232
    cp = strrchr((char const   *)cp, '/');
    }
#line 232
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 233
      strcpy((char */* __restrict  */)(tmpfilename), (char const   */* __restrict  */)(cp + 1));
      }
    } else {
#line 235
      if ((gs->Title)->len < 0) {
#line 235
        tmp___1 = (char *)((void *)0);
      } else {
#line 235
        tmp___1 = (gs->Title)->data;
      }
      {
#line 235
      strcpy((char */* __restrict  */)(tmpfilename), (char const   */* __restrict  */)tmp___1);
      }
    }
  } else {
#line 237
    if ((gs->Title)->len < 0) {
#line 237
      tmp___2 = (char *)((void *)0);
    } else {
#line 237
      tmp___2 = (gs->Title)->data;
    }
    {
#line 237
    strcpy((char */* __restrict  */)(tmpfilename), (char const   */* __restrict  */)tmp___2);
    }
  }
  {
#line 244
  UNIXfile(tmpfilename);
#line 247
  cp = tmpfilename;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! ((int )*cp != 0)) {
#line 247
      goto while_break;
    }
    {
#line 253
    if ((int )*cp == 41) {
#line 253
      goto case_41;
    }
#line 253
    if ((int )*cp == 40) {
#line 253
      goto case_41;
    }
#line 253
    if ((int )*cp == 39) {
#line 253
      goto case_41;
    }
#line 253
    if ((int )*cp == 34) {
#line 253
      goto case_41;
    }
#line 253
    if ((int )*cp == 32) {
#line 253
      goto case_41;
    }
#line 248
    goto switch_break___0;
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 254
    *cp = (char )'_';
    switch_break___0: /* CIL Label */ ;
    }
#line 247
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  getcwd(curcwd, (size_t )4096);
#line 274
  tmp___3 = chdir("/tmp");
  }
#line 274
  if (tmp___3 != 0) {
    {
#line 275
    CursesErrorMsg((char *)"Can\'t write to the /tmp directory!");
    }
#line 276
    return;
  }
  {
#line 281
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 281
    tmp___5 = stat((char const   */* __restrict  */)(tmpfilename), (struct stat */* __restrict  */)(& buf));
    }
#line 281
    if (! (tmp___5 == 0)) {
#line 281
      goto while_break___0;
    }
    {
#line 282
    tmp___4 = strlen((char const   *)(tmpfilename));
#line 282
    len = (int )tmp___4;
    }
#line 284
    if ((int )tmpfilename[len - 1] == 45) {
#line 285
      tmpfilename[len] = (char )((int )tmpfilename[len] + 1);
    } else {
      {
#line 287
      strcat((char */* __restrict  */)(tmpfilename), (char const   */* __restrict  */)"-1");
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 291
  Save_file(gs, tmpfilename, (char *)((void *)0));
#line 295
  tmp___6 = stat((char const   */* __restrict  */)(tmpfilename), (struct stat */* __restrict  */)(& buf));
  }
#line 295
  if (tmp___6 < 0) {
    {
#line 296
    CursesErrorMsg((char *)"File didn\'t transfer successfully");
    }
#line 297
    return;
  }
  {
#line 301
  tmp___7 = GSisText(gs, (char *)((void *)0));
  }
#line 301
  if (tmp___7) {
    {
#line 302
    strcpy((char */* __restrict  */)(command), (char const   */* __restrict  */)DLcmds[choice]);
    }
  } else {
    {
#line 304
    strcpy((char */* __restrict  */)(command), (char const   */* __restrict  */)DLcmdB[choice]);
    }
  }
  {
#line 306
  strcat((char */* __restrict  */)(command), (char const   */* __restrict  */)(tmpfilename));
#line 308
  CURexit(CursesScreen);
#line 310
  printf((char const   */* __restrict  */)" Downloading %d bytes", (int )buf.st_size);
#line 311
  printf((char const   */* __restrict  */)"    1200bps: %ld minutes\n", buf.st_size / 7200L);
#line 313
  printf((char const   */* __restrict  */)"    2400bps: %ld minutes\n", buf.st_size / 14400L);
#line 314
  printf((char const   */* __restrict  */)"   14400bps: %ld minutes\n\n", buf.st_size / 86400L);
  }
#line 317
  if (choice == 5) {
    {
#line 318
    printf((char const   */* __restrict  */)"Start your capture now...\n\n");
#line 319
    printf((char const   */* __restrict  */)"Press <RETURN> when you\'re ready\n");
#line 320
    fflush(stdout);
#line 321
    getchar();
    }
  } else {
    {
#line 323
    printf((char const   */* __restrict  */)"Start your download now...\n");
#line 324
    fflush(stdout);
    }
  }
  {
#line 327
  tmp___8 = time((time_t *)((void *)0));
#line 327
  start = (int )tmp___8;
#line 329
  tmp___10 = FIOsystem(command);
  }
#line 329
  if (tmp___10) {
    {
#line 330
    printf((char const   */* __restrict  */)"\nDownload could not be completed, sorry... \n");
    }
  } else {
    {
#line 332
    tmp___9 = time((time_t *)((void *)0));
#line 332
    end = (int )tmp___9;
    }
#line 333
    if (end == start) {
#line 334
      end ++;
    }
    {
#line 336
    printf((char const   */* __restrict  */)"\nDownload Complete. %d total bytes, %d bytes/sec\n",
           (int )buf.st_size, (int )buf.st_size / (end - start));
    }
  }
  {
#line 340
  unlink((char const   *)(tmpfilename));
#line 341
  chdir((char const   *)curcwd);
#line 342
  printf((char const   */* __restrict  */)"Press <RETURN> to continue");
#line 343
  fflush(stdout);
#line 344
  getchar();
#line 345
  CURenter(CursesScreen);
#line 347
  free((void *)curcwd);
  }
#line 350
  return;
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 355 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/download.c"
void BuiltinDownload(char *dirname ) 
{ 
  char *names[99] ;
  DIR *thedir ;
  struct dirent *entry ;
  struct stat buf ;
  int fcount ;
  int choice ;
  char *tmppath ;
  GopherObj *gs ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 360
  entry = (struct dirent *)((void *)0);
#line 362
  fcount = 0;
#line 375
  thedir = opendir((char const   *)dirname);
#line 376
  chdir((char const   *)dirname);
  }
#line 378
  if ((unsigned long )thedir == (unsigned long )((void *)0)) {
    {
#line 379
    CursesErrorMsg((char *)"Cannot Open the directory");
    }
#line 380
    return;
  }
  {
#line 383
  entry = readdir(thedir);
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 383
      goto while_break;
    }
    {
#line 385
    stat((char const   */* __restrict  */)(entry->d_name), (struct stat */* __restrict  */)(& buf));
    }
#line 387
    if ((int )entry->d_name[0] != 46) {
#line 387
      if (! ((buf.st_mode & 61440U) == 16384U)) {
        {
#line 388
        tmp = fcount;
#line 388
        fcount ++;
#line 388
        names[tmp] = strdup((char const   *)(entry->d_name));
        }
      }
    }
    {
#line 383
    entry = readdir(thedir);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 392
  names[fcount] = (char *)((void *)0);
#line 393
  choice = CURChoice(CursesScreen, (char *)"Choose a File to Download", names, (char *)"Choose a File to Download",
                     0);
  }
#line 396
  if (choice == -1) {
#line 397
    return;
  }
  {
#line 399
  gs = GSnew();
#line 400
  GSplusnew(gs);
#line 402
  STRset(gs->Selstr, names[choice]);
#line 405
  getcwd(tmppath, (size_t )4096);
#line 419
  strcat((char */* __restrict  */)tmppath, (char const   */* __restrict  */)"/");
#line 420
  strcat((char */* __restrict  */)tmppath, (char const   */* __restrict  */)names[choice]);
#line 422
  STRset(gs->Localfile, tmppath);
#line 423
  STRset(gs->Localview, (char *)"application/octet-stream");
#line 424
  STRset(gs->Title, names[choice]);
#line 425
  gs->sFileType = (char )'9';
#line 426
  GSaddView(gs, (char *)"application/octet-stream", (char *)"", 0);
#line 427
  Download_file(gs);
#line 429
  fcount = 0;
  }
  {
#line 429
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 429
    if (! ((unsigned long )names[fcount] != (unsigned long )((void *)0))) {
#line 429
      goto while_break___0;
    }
    {
#line 430
    tmp___0 = fcount;
#line 430
    fcount ++;
#line 430
    free((void *)names[tmp___0]);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 433
  free((void *)tmppath);
  }
#line 435
  return;
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
static int GSqsortcmp___0(GopherObj **gs1 , GopherObj **gs2 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 267
  if (((*gs1)->Title)->len < 0) {
#line 267
    tmp = (char *)((void *)0);
  } else {
#line 267
    tmp = ((*gs1)->Title)->data;
  }
#line 267
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 268
    return (1);
  }
#line 269
  if (((*gs2)->Title)->len < 0) {
#line 269
    tmp___0 = (char *)((void *)0);
  } else {
#line 269
    tmp___0 = ((*gs2)->Title)->data;
  }
#line 269
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 270
    return (-1);
  }
#line 275
  if ((*gs1)->Itemnum == (*gs2)->Itemnum) {
#line 276
    if (((*gs2)->Title)->len < 0) {
#line 276
      tmp___1 = (char *)((void *)0);
    } else {
#line 276
      tmp___1 = ((*gs2)->Title)->data;
    }
#line 276
    if (((*gs1)->Title)->len < 0) {
#line 276
      tmp___2 = (char *)((void *)0);
    } else {
#line 276
      tmp___2 = ((*gs1)->Title)->data;
    }
    {
#line 276
    tmp___3 = strcoll((char const   *)tmp___2, (char const   *)tmp___1);
    }
#line 276
    return (tmp___3);
  }
#line 282
  if ((*gs1)->Itemnum == 0) {
#line 282
    tmp___6 = 0;
  } else {
#line 282
    if ((*gs1)->Itemnum < 0) {
#line 282
      tmp___5 = -1;
    } else {
#line 282
      tmp___5 = 1;
    }
#line 282
    tmp___6 = tmp___5;
  }
#line 282
  if ((*gs2)->Itemnum == 0) {
#line 282
    tmp___8 = 0;
  } else {
#line 282
    if ((*gs2)->Itemnum < 0) {
#line 282
      tmp___7 = -1;
    } else {
#line 282
      tmp___7 = 1;
    }
#line 282
    tmp___8 = tmp___7;
  }
#line 282
  if (tmp___6 == tmp___8) {
#line 283
    if ((*gs1)->Itemnum < (*gs2)->Itemnum) {
#line 283
      tmp___4 = -1;
    } else {
#line 283
      tmp___4 = 1;
    }
#line 283
    return (tmp___4);
  }
#line 287
  if ((*gs1)->Itemnum > (*gs2)->Itemnum) {
#line 287
    tmp___9 = -1;
  } else {
#line 287
    tmp___9 = 1;
  }
#line 287
  return (tmp___9);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
static GopherObj *TempGopher___1  =    (GopherObj *)((void *)0);
#line 433 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GDgopherdir.c"
static GopherObj *TempGopher___2  ;
#line 723 "/usr/include/curses.h"
extern int printw(char const   *  , ...) ;
#line 803
extern int wclrtoeol(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 373 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcasestr)(char const   *__haystack ,
                                                                                                     char const   *__needle )  __attribute__((__pure__)) ;
#line 289 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.h"
void CURcenterline(CursesObj *cur , WINDOW *win , char *theline , int yval , int windowidth ,
                   boolean bright ) ;
#line 298
int CURGetOneOption(CursesObj *cur , char *Title , char *OptionName , char *Response ) ;
#line 300
void CURBeep(CursesObj *cur ) ;
#line 303
int CUROldGetOneOption(CursesObj *cur , char *OptionName , char *Response ) ;
#line 139 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
int iLevel ;
#line 8 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/manager.h"
void Draw_Banner(void) ;
#line 9
void Draw_Status(char *textline ) ;
#line 10
void DisplayTitle(GopherObj *gs , int maxlength , boolean dogplus ) ;
#line 11
void Display_Dir_Page(GopherDirObj *gopherdir , int iNewLine , int nNewPage , int nMaxPages ,
                      int iPageLen , int iLastPageLen ) ;
#line 14
int scline(int iOldGopher , int iNewGopher , GopherDirObj *gophersdir ) ;
#line 15
int GetMenu(GopherDirObj *gd , int *typedchar , boolean redisplay ) ;
#line 171 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/manager.c"
void Draw_Banner(void) 
{ 


  {
#line 181
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/manager.c"
void Draw_Status(char *textline ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 191
  tmp = wmove(stdscr, LINES - 1, 0);
  }
#line 191
  if (! (tmp == -1)) {
    {
#line 191
    waddnstr(stdscr, "Press ", -1);
    }
  }
#line 192
  if (stdscr) {
#line 192
    stdscr->_attrs = 1UL << 16;
  }
  {
#line 193
  waddnstr(stdscr, "?", -1);
  }
#line 194
  if (stdscr) {
#line 194
    stdscr->_attrs = 0UL;
  }
  {
#line 196
  waddnstr(stdscr, " for Help, ", -1);
  }
#line 198
  if (stdscr) {
#line 198
    stdscr->_attrs = 1UL << 16;
  }
  {
#line 199
  waddnstr(stdscr, "q", -1);
  }
#line 200
  if (stdscr) {
#line 200
    stdscr->_attrs = 0UL;
  }
  {
#line 201
  waddnstr(stdscr, " to Quit", -1);
  }
#line 204
  if (iLevel != 0) {
    {
#line 205
    waddnstr(stdscr, ", ", -1);
    }
#line 206
    if (stdscr) {
#line 206
      stdscr->_attrs = 1UL << 16;
    }
    {
#line 207
    waddnstr(stdscr, "u", -1);
    }
#line 208
    if (stdscr) {
#line 208
      stdscr->_attrs = 0UL;
    }
    {
#line 209
    waddnstr(stdscr, " to go up a menu", -1);
    }
  }
  {
#line 212
  wclrtoeol(stdscr);
#line 214
  tmp___0 = strlen((char const   *)textline);
#line 214
  tmp___1 = wmove(stdscr, LINES - 1, (int )(((size_t )COLS - tmp___0) - 4UL));
  }
#line 214
  if (! (tmp___1 == -1)) {
    {
#line 214
    waddch(stdscr, (chtype const   )' ');
    }
  }
  {
#line 215
  waddnstr(stdscr, (char const   *)textline, -1);
  }
#line 216
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/manager.c"
void DisplayTitle(GopherObj *gs , int maxlength , boolean dogplus ) 
{ 
  char type ;
  char *c ;
  char *d ;
  char *size ;
  int m ;
  int n ;
  char temp[1024] ;
  char *tmp ;
  VIewobj *tmp___1 ;
  char *tmp___2 ;
  VIewobj *tmp___3 ;
  size_t tmp___4 ;

  {
#line 227
  type = gs->sFileType;
#line 228
  if ((gs->Title)->len < 0) {
#line 228
    tmp = (char *)((void *)0);
  } else {
#line 228
    tmp = (gs->Title)->data;
  }
#line 228
  d = tmp;
#line 230
  if (gs->isgplus) {
#line 230
    if ((unsigned long )gs->gplus != (unsigned long )((void *)0)) {
      {
#line 232
      tmp___3 = GSgetView(gs, 0);
      }
#line 232
      if ((tmp___3->Size)->len < 0) {
#line 232
        tmp___2 = (char *)((void *)0);
      } else {
        {
#line 232
        tmp___1 = GSgetView(gs, 0);
#line 232
        tmp___2 = (tmp___1->Size)->data;
        }
      }
#line 232
      size = tmp___2;
    }
  }
#line 235
  if (gs->isask) {
#line 236
    maxlength -= 5;
  }
  {
#line 240
  if ((int )type == 49) {
#line 240
    goto case_49;
  }
#line 243
  if ((int )type == 115) {
#line 243
    goto case_115;
  }
#line 246
  if ((int )type == 55) {
#line 246
    goto case_55;
  }
#line 253
  if ((int )type == 52) {
#line 253
    goto case_52;
  }
#line 253
  if ((int )type == 57) {
#line 253
    goto case_52;
  }
#line 253
  if ((int )type == 56) {
#line 253
    goto case_52;
  }
#line 253
  if ((int )type == 50) {
#line 253
    goto case_52;
  }
#line 253
  if ((int )type == 80) {
#line 253
    goto case_52;
  }
#line 258
  if ((int )type == 104) {
#line 258
    goto case_104;
  }
#line 258
  if ((int )type == 77) {
#line 258
    goto case_104;
  }
#line 258
  if ((int )type == 84) {
#line 258
    goto case_104;
  }
#line 261
  if ((int )type == 59) {
#line 261
    goto case_59;
  }
#line 264
  if ((int )type == 53) {
#line 264
    goto case_53;
  }
#line 268
  if ((int )type == 73) {
#line 268
    goto case_73;
  }
#line 268
  if ((int )type == 103) {
#line 268
    goto case_73;
  }
#line 238
  goto switch_break;
  case_49: /* CIL Label */ 
#line 241
  maxlength --;
#line 242
  goto switch_break;
  case_115: /* CIL Label */ 
#line 244
  maxlength -= 3;
#line 245
  goto switch_break;
  case_55: /* CIL Label */ 
#line 247
  maxlength -= 4;
#line 248
  goto switch_break;
  case_52: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_80: /* CIL Label */ 
#line 254
  maxlength -= 6;
#line 255
  goto switch_break;
  case_104: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_84: /* CIL Label */ 
#line 259
  maxlength -= 7;
#line 260
  goto switch_break;
  case_59: /* CIL Label */ 
#line 262
  maxlength -= 8;
#line 263
  goto switch_break;
  case_53: /* CIL Label */ 
#line 265
  maxlength -= 9;
#line 266
  goto switch_break;
  case_73: /* CIL Label */ 
  case_103: /* CIL Label */ 
#line 269
  maxlength -= 10;
  switch_break: /* CIL Label */ ;
  }
#line 272
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 273
    d = (char *)"error";
  }
  {
#line 275
  tmp___4 = strlen((char const   *)d);
#line 275
  m = (int )tmp___4;
  }
#line 275
  if (m <= maxlength) {
    {
#line 276
    printw(" %s", d);
    }
  } else {
    {
#line 279
    c = strchr((char const   *)d, '/');
    }
#line 279
    if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 279
      if ((long )maxlength > c - d) {
        {
#line 280
        n = (int )(c - d);
#line 281
        strncpy((char */* __restrict  */)(temp), (char const   */* __restrict  */)d,
                (size_t )n);
#line 282
        strcpy((char */* __restrict  */)(temp + n), (char const   */* __restrict  */)"..");
#line 283
        strcat((char */* __restrict  */)(temp), (char const   */* __restrict  */)(d + ((m + n) - maxlength)));
#line 284
        printw(" %s", temp);
        }
      } else {
        {
#line 287
        strcpy((char */* __restrict  */)(temp), (char const   */* __restrict  */)d);
#line 288
        temp[maxlength] = (char )'\000';
#line 289
        printw(" %s..", temp);
        }
      }
    } else {
      {
#line 287
      strcpy((char */* __restrict  */)(temp), (char const   */* __restrict  */)d);
#line 288
      temp[maxlength] = (char )'\000';
#line 289
      printw(" %s..", temp);
      }
    }
  }
  {
#line 295
  if ((int )type == 49) {
#line 295
    goto case_49___0;
  }
#line 298
  if ((int )type == 50) {
#line 298
    goto case_50___0;
  }
#line 301
  if ((int )type == 84) {
#line 301
    goto case_84___0;
  }
#line 304
  if ((int )type == 56) {
#line 304
    goto case_56___0;
  }
#line 307
  if ((int )type == 55) {
#line 307
    goto case_55___0;
  }
#line 310
  if ((int )type == 115) {
#line 310
    goto case_115___0;
  }
#line 313
  if ((int )type == 53) {
#line 313
    goto case_53___0;
  }
#line 316
  if ((int )type == 57) {
#line 316
    goto case_57___0;
  }
#line 320
  if ((int )type == 103) {
#line 320
    goto case_103___0;
  }
#line 320
  if ((int )type == 73) {
#line 320
    goto case_103___0;
  }
#line 323
  if ((int )type == 52) {
#line 323
    goto case_52___0;
  }
#line 326
  if ((int )type == 77) {
#line 326
    goto case_77___0;
  }
#line 329
  if ((int )type == 104) {
#line 329
    goto case_104___0;
  }
#line 332
  if ((int )type == 59) {
#line 332
    goto case_59___0;
  }
#line 335
  if ((int )type == 80) {
#line 335
    goto case_80___0;
  }
#line 293
  goto switch_break___0;
  case_49___0: /* CIL Label */ 
  {
#line 296
  waddch(stdscr, (chtype const   )'/');
  }
#line 297
  goto switch_break___0;
  case_50___0: /* CIL Label */ 
  {
#line 299
  waddnstr(stdscr, " <CSO>", -1);
  }
#line 300
  goto switch_break___0;
  case_84___0: /* CIL Label */ 
  {
#line 302
  waddnstr(stdscr, " <3270>", -1);
  }
#line 303
  goto switch_break___0;
  case_56___0: /* CIL Label */ 
  {
#line 305
  waddnstr(stdscr, " <TEL>", -1);
  }
#line 306
  goto switch_break___0;
  case_55___0: /* CIL Label */ 
  {
#line 308
  waddnstr(stdscr, " <?>", -1);
  }
#line 309
  goto switch_break___0;
  case_115___0: /* CIL Label */ 
  {
#line 311
  waddnstr(stdscr, " <)", -1);
  }
#line 312
  goto switch_break___0;
  case_53___0: /* CIL Label */ 
  {
#line 314
  waddnstr(stdscr, " <PC Bin>", -1);
  }
#line 315
  goto switch_break___0;
  case_57___0: /* CIL Label */ 
  {
#line 317
  waddnstr(stdscr, " <Bin>", -1);
  }
#line 318
  goto switch_break___0;
  case_103___0: /* CIL Label */ 
  case_73___0: /* CIL Label */ 
  {
#line 321
  waddnstr(stdscr, " <Picture>", -1);
  }
#line 322
  goto switch_break___0;
  case_52___0: /* CIL Label */ 
  {
#line 324
  waddnstr(stdscr, " <HQX>", -1);
  }
#line 325
  goto switch_break___0;
  case_77___0: /* CIL Label */ 
  {
#line 327
  waddnstr(stdscr, " <MIME>", -1);
  }
#line 328
  goto switch_break___0;
  case_104___0: /* CIL Label */ 
  {
#line 330
  waddnstr(stdscr, " <HTML>", -1);
  }
#line 331
  goto switch_break___0;
  case_59___0: /* CIL Label */ 
  {
#line 333
  waddnstr(stdscr, " <Movie>", -1);
  }
#line 334
  goto switch_break___0;
  case_80___0: /* CIL Label */ 
  {
#line 336
  waddnstr(stdscr, " <PDF>", -1);
  }
#line 337
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 340
  if (gs->isask) {
    {
#line 343
    waddnstr(stdscr, " <?", -1);
#line 344
    waddnstr(stdscr, "?>", -1);
    }
  }
#line 346
  return;
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/manager.c"
static char *MenuStyle  =    (char *)((void *)0);
#line 365 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/manager.c"
static int MenuBytePad  ;
#line 353 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/manager.c"
void Display_Dir_Page(GopherDirObj *gopherdir , int iNewLine , int nNewPage , int nMaxPages ,
                      int iPageLen , int iLastPageLen ) 
{ 
  int i ;
  int iLoop ;
  int iOffset ;
  boolean dogplus ;
  GopherObj *gs ;
  int j ;
  size_t tmp ;

  {
  {
#line 362
  dogplus = 0;
#line 370
  wclear(stdscr);
#line 371
  Draw_Banner();
  }
#line 372
  if ((unsigned long )MenuStyle == (unsigned long )((void *)0)) {
    {
#line 373
    MenuStyle = getenv("GOPHERMENUSTYLE");
    }
#line 373
    if ((unsigned long )MenuStyle == (unsigned long )((void *)0)) {
#line 374
      MenuStyle = (char *)"[%d]";
    }
    {
#line 375
    tmp = strlen((char const   *)MenuStyle);
#line 375
    MenuBytePad = (int )(tmp - 2UL);
    }
  }
#line 380
  if (nNewPage == nMaxPages) {
#line 380
    if (iLastPageLen) {
#line 380
      iLoop = iLastPageLen;
    } else {
#line 380
      iLoop = iPageLen;
    }
  } else {
#line 380
    iLoop = iPageLen;
  }
#line 386
  i = 0;
#line 386
  iOffset = (nNewPage - 1) * iPageLen;
  {
#line 386
  while (1) {
    while_continue: /* CIL Label */ ;
#line 386
    if (! (i < iLoop)) {
#line 386
      goto while_break;
    }
    {
#line 387
    gs = (GopherObj *)*((gopherdir->Gophers)->objects + iOffset);
#line 389
    wmove(stdscr, (i + 1) + 1, 6);
    }
#line 391
    if ((int )gs->sFileType == 105) {
#line 392
      j = 0;
      {
#line 392
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 392
        if (! (j <= MenuBytePad)) {
#line 392
          goto while_break___0;
        }
        {
#line 393
        waddch(stdscr, (chtype const   )' ');
#line 392
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 395
      if (iOffset > 9) {
        {
#line 396
        waddch(stdscr, (chtype const   )' ');
        }
      }
#line 397
      if (iOffset > 99) {
        {
#line 398
        waddch(stdscr, (chtype const   )' ');
        }
      }
    } else {
      {
#line 400
      printw((char const   *)MenuStyle, iOffset + 1);
      }
    }
#line 402
    if (iOffset + 1 < 10) {
      {
#line 403
      waddch(stdscr, (chtype const   )' ');
      }
    }
    {
#line 405
    dogplus = ((GopherObj *)*((gopherdir->Gophers)->objects + iOffset))->isgplus;
#line 406
    DisplayTitle((GopherObj *)*((gopherdir->Gophers)->objects + iOffset), COLS - 13,
                 dogplus);
#line 386
    i ++;
#line 386
    iOffset ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 408
  return;
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/manager.c"
int scline(int iOldGopher , int iNewGopher , GopherDirObj *gophersdir ) 
{ 
  int iPageLen ;
  int iLastPageLen ;
  int nMaxPages ;
  int nNewPage ;
  int nOldPage ;
  int iOldLine ;
  int iNewLine ;
  char sPagenum[40] ;
  int iMaxGophers ;
  GopherObj *tempGopher ;
  int Direction ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 422
  Direction = 1;
#line 424
  iMaxGophers = (gophersdir->Gophers)->Top;
#line 426
  if (iNewGopher == 0) {
#line 427
    iNewGopher = (gophersdir->Gophers)->Top;
  }
#line 429
  if (iNewGopher > iMaxGophers) {
#line 430
    iNewGopher = 1;
  }
#line 432
  if (iNewGopher == iOldGopher - 1) {
#line 433
    Direction = -1;
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 435
    if (iNewGopher <= 0) {
#line 436
      goto while_break;
    }
#line 438
    tempGopher = (GopherObj *)*((gophersdir->Gophers)->objects + (iNewGopher - 1));
#line 439
    if ((int )tempGopher->sFileType != 105) {
#line 439
      if ((int )tempGopher->sFileType != 51) {
#line 441
        goto while_break;
      }
    }
#line 442
    iNewGopher += Direction;
#line 443
    if (iNewGopher > iMaxGophers) {
#line 444
      iNewGopher = 1;
#line 445
      if (iOldGopher < 1) {
#line 446
        goto while_break;
      }
    }
#line 448
    if (iNewGopher < 1) {
#line 449
      iNewGopher = iMaxGophers;
    }
#line 450
    if (iOldGopher > iMaxGophers) {
#line 451
      goto while_break;
    }
#line 434
    if (! (iNewGopher != iOldGopher)) {
#line 434
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  iPageLen = LINES - 4;
#line 455
  if (iPageLen) {
#line 455
    nMaxPages = iMaxGophers / iPageLen + (iMaxGophers % iPageLen > 0);
  } else {
#line 455
    nMaxPages = 1;
  }
#line 456
  if (iPageLen) {
#line 456
    nOldPage = iOldGopher / iPageLen + (iOldGopher % iPageLen > 0);
  } else {
#line 456
    nOldPage = 1;
  }
#line 457
  if (iPageLen) {
#line 457
    nNewPage = iNewGopher / iPageLen + (iNewGopher % iPageLen > 0);
  } else {
#line 457
    nNewPage = 1;
  }
#line 459
  if (nNewPage < 1) {
#line 460
    return (iOldGopher);
  } else
#line 459
  if (nNewPage > nMaxPages) {
#line 460
    return (iOldGopher);
  }
#line 462
  iLastPageLen = iMaxGophers % iPageLen;
#line 466
  iOldLine = iOldGopher - (nOldPage - 1) * iPageLen;
#line 467
  iNewLine = iNewGopher - (nNewPage - 1) * iPageLen;
#line 469
  if (iNewLine < 0) {
#line 470
    return (iOldGopher);
  } else
#line 469
  if (iNewLine > iPageLen) {
#line 470
    return (iOldGopher);
  }
#line 472
  if (nOldPage != nNewPage) {
    {
#line 473
    Display_Dir_Page(gophersdir, iNewLine, nNewPage, nMaxPages, iPageLen, iLastPageLen);
    }
#line 477
    if (stdscr) {
#line 477
      stdscr->_attrs = 1UL << 16;
    }
#line 479
    if ((gophersdir->Title)->len < 0) {
#line 479
      tmp = (char *)((void *)0);
    } else {
#line 479
      tmp = (gophersdir->Title)->data;
    }
    {
#line 479
    CURcenterline(CursesScreen, stdscr, tmp, 0, COLS, 0);
    }
#line 481
    if (stdscr) {
#line 481
      stdscr->_attrs = 0UL;
    }
  }
  {
#line 486
  sprintf((char */* __restrict  */)(sPagenum), (char const   */* __restrict  */)"  Page: %d/%d",
          nNewPage, nMaxPages);
#line 487
  Draw_Status(sPagenum);
#line 488
  tmp___0 = wmove(stdscr, iOldLine + 1, 1);
  }
#line 488
  if (! (tmp___0 == -1)) {
    {
#line 488
    waddnstr(stdscr, "   ", -1);
    }
  }
#line 489
  if ((int )((GopherObj *)*((gophersdir->Gophers)->objects + (iNewGopher - 1)))->sFileType == 105) {
#line 489
    goto _L;
  } else
#line 489
  if ((int )((GopherObj *)*((gophersdir->Gophers)->objects + (iNewGopher - 1)))->sFileType == 51) {
    _L: /* CIL Label */ 
    {
#line 491
    tmp___1 = wmove(stdscr, iNewLine + 1, 1);
    }
#line 491
    if (! (tmp___1 == -1)) {
      {
#line 491
      waddnstr(stdscr, "---", -1);
      }
    }
  } else {
    {
#line 493
    tmp___2 = wmove(stdscr, iNewLine + 1, 1);
    }
#line 493
    if (! (tmp___2 == -1)) {
      {
#line 493
      waddnstr(stdscr, "-->", -1);
      }
    }
  }
  {
#line 494
  wrefresh(stdscr);
  }
#line 496
  return (iNewGopher);
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/manager.c"
static int iNewItem  =    1;
#line 509 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/manager.c"
int GetMenu(GopherDirObj *gd , int *typedchar , boolean redisplay ) 
{ 
  int ch ;
  int iItem ;
  char sLinenum[5] ;
  int numitems ;
  char search1[100] ;
  char *search2 ;
  int sfound ;
  int i ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 523
  search1[0] = (char )'\000';
#line 525
  numitems = (gd->Gophers)->Top;
#line 526
  iItem = -1;
#line 527
  iNewItem = gd->currentitem;
#line 529
  if (redisplay == 1) {
#line 533
    if (stdscr) {
#line 533
      stdscr->_attrs = 1UL << 16;
    }
#line 535
    if ((gd->Title)->len < 0) {
#line 535
      tmp = (char *)((void *)0);
    } else {
#line 535
      tmp = (gd->Title)->data;
    }
    {
#line 535
    CURcenterline(CursesScreen, stdscr, tmp, 0, COLS, 0);
    }
#line 537
    if (stdscr) {
#line 537
      stdscr->_attrs = 0UL;
    }
    {
#line 542
    iItem = scline(iItem, iNewItem, gd);
    }
  } else {
#line 544
    iItem = gd->currentitem;
  }
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 556
    ch = CURgetch(CursesScreen);
    }
    {
#line 563
    if (ch == 4) {
#line 563
      goto case_4;
    }
#line 568
    if (ch == 258) {
#line 568
      goto case_258;
    }
#line 568
    if (ch == 14) {
#line 568
      goto case_258;
    }
#line 568
    if (ch == 106) {
#line 568
      goto case_258;
    }
#line 575
    if (ch == 259) {
#line 575
      goto case_259;
    }
#line 575
    if (ch == 16) {
#line 575
      goto case_259;
    }
#line 575
    if (ch == 107) {
#line 575
      goto case_259;
    }
#line 584
    if (ch == 338) {
#line 584
      goto case_338;
    }
#line 584
    if (ch == 32) {
#line 584
      goto case_338;
    }
#line 584
    if (ch == 62) {
#line 584
      goto case_338;
    }
#line 584
    if (ch == 43) {
#line 584
      goto case_338;
    }
#line 599
    if (ch == 98) {
#line 599
      goto case_98;
    }
#line 599
    if (ch == 339) {
#line 599
      goto case_98;
    }
#line 599
    if (ch == 60) {
#line 599
      goto case_98;
    }
#line 599
    if (ch == 45) {
#line 599
      goto case_98;
    }
#line 608
    if (ch == 48) {
#line 608
      goto case_48;
    }
#line 608
    if (ch == 57) {
#line 608
      goto case_48;
    }
#line 608
    if (ch == 56) {
#line 608
      goto case_48;
    }
#line 608
    if (ch == 55) {
#line 608
      goto case_48;
    }
#line 608
    if (ch == 54) {
#line 608
      goto case_48;
    }
#line 608
    if (ch == 53) {
#line 608
      goto case_48;
    }
#line 608
    if (ch == 52) {
#line 608
      goto case_48;
    }
#line 608
    if (ch == 51) {
#line 608
      goto case_48;
    }
#line 608
    if (ch == 50) {
#line 608
      goto case_48;
    }
#line 608
    if (ch == 49) {
#line 608
      goto case_48;
    }
#line 639
    if (ch == 110) {
#line 639
      goto case_110;
    }
#line 639
    if (ch == 47) {
#line 639
      goto case_110;
    }
#line 694
    if (ch == 0) {
#line 694
      goto case_0;
    }
#line 697
    goto switch_default;
    case_4: /* CIL Label */ 
#line 564
    DEBUG = 1 - DEBUG;
#line 565
    goto switch_break;
    case_258: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_106: /* CIL Label */ 
#line 570
    iNewItem = iItem + 1;
#line 571
    goto switch_break;
    case_259: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_107: /* CIL Label */ 
#line 577
    iNewItem = iItem - 1;
#line 578
    goto switch_break;
    case_338: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_62: /* CIL Label */ 
    case_43: /* CIL Label */ 
#line 586
    if (iItem == numitems) {
#line 587
      iNewItem = 1;
    } else {
#line 589
      iNewItem = iItem + (LINES - 4);
#line 590
      if (iNewItem > numitems) {
#line 591
        iNewItem = numitems;
      }
    }
#line 593
    goto switch_break;
    case_98: /* CIL Label */ 
    case_339: /* CIL Label */ 
    case_60: /* CIL Label */ 
    case_45: /* CIL Label */ 
#line 602
    iNewItem = iItem - (LINES - 4);
#line 603
    if (iNewItem < 0) {
#line 604
      iNewItem = 1;
    }
#line 605
    goto switch_break;
    case_48: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    {
#line 610
    sLinenum[0] = (char )ch;
#line 611
    sLinenum[1] = (char )'\000';
#line 613
    tmp___0 = CUROldGetOneOption(CursesScreen, (char *)"View item number: ", sLinenum);
    }
#line 613
    if (tmp___0 < 0) {
      {
#line 616
      scline(iItem, iNewItem, gd);
      }
#line 617
      goto switch_break;
    }
    {
#line 620
    tmp___1 = atoi((char const   *)(sLinenum));
    }
#line 620
    if (tmp___1 <= numitems) {
      {
#line 621
      iNewItem = atoi((char const   *)(sLinenum));
      }
    } else {
      {
#line 623
      CURBeep(CursesScreen);
      }
#line 624
      goto switch_break;
    }
    {
#line 627
    iItem = scline(iItem, iNewItem, gd);
    }
#line 629
    if (iNewItem > 0) {
#line 629
      if (iNewItem <= (gd->Gophers)->Top) {
#line 630
        *typedchar = '\n';
#line 631
        gd->currentitem = iNewItem;
#line 632
        return (iItem);
      }
    }
#line 636
    goto switch_break;
    case_110: /* CIL Label */ 
    case_47: /* CIL Label */ 
#line 640
    sfound = 0;
#line 642
    if ((int )search1[0] == 0) {
#line 642
      if (ch == 110) {
        {
#line 643
        CursesErrorMsg((char *)"Use \'/\' to define a search first...");
#line 644
        iItem = scline(-1, iItem, gd);
        }
#line 645
        goto switch_break;
      }
    }
#line 648
    if ((int )search1[0] == 0) {
#line 648
      goto _L;
    } else
#line 648
    if (ch == 47) {
      _L: /* CIL Label */ 
#line 649
      if ((gd->Title)->len < 0) {
#line 649
        tmp___2 = (char *)((void *)0);
      } else {
#line 649
        tmp___2 = (gd->Title)->data;
      }
      {
#line 649
      tmp___3 = CURGetOneOption(CursesScreen, tmp___2, (char *)"Search directory titles for:",
                                search1);
      }
#line 649
      if (tmp___3 < 0) {
        {
#line 652
        iItem = scline(-1, iItem, gd);
        }
#line 653
        goto switch_break;
      }
    }
    {
#line 655
    tmp___4 = strlen((char const   *)(search1));
    }
#line 655
    if (tmp___4 == 0UL) {
      {
#line 656
      iItem = scline(-1, iItem, gd);
      }
#line 657
      goto switch_break;
    }
#line 664
    i = iItem;
    {
#line 664
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 664
      if (i < numitems) {
#line 664
        if (! (sfound == 0)) {
#line 664
          goto while_break___0;
        }
      } else {
#line 664
        goto while_break___0;
      }
#line 665
      if ((((GopherObj *)*((gd->Gophers)->objects + i))->Title)->len < 0) {
#line 665
        tmp___5 = (char *)((void *)0);
      } else {
#line 665
        tmp___5 = (((GopherObj *)*((gd->Gophers)->objects + i))->Title)->data;
      }
      {
#line 665
      search2 = tmp___5;
#line 666
      tmp___6 = strcasestr((char const   *)search2, (char const   *)(search1));
      }
#line 666
      if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 667
        iNewItem = i + 1;
#line 668
        sfound = 1;
      }
#line 664
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 675
    i = 0;
    {
#line 675
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 675
      if (i < iItem) {
#line 675
        if (! (sfound == 0)) {
#line 675
          goto while_break___1;
        }
      } else {
#line 675
        goto while_break___1;
      }
#line 676
      if ((((GopherObj *)*((gd->Gophers)->objects + i))->Title)->len < 0) {
#line 676
        tmp___7 = (char *)((void *)0);
      } else {
#line 676
        tmp___7 = (((GopherObj *)*((gd->Gophers)->objects + i))->Title)->data;
      }
      {
#line 676
      search2 = tmp___7;
#line 677
      tmp___8 = strcasestr((char const   *)search2, (char const   *)(search1));
      }
#line 677
      if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 678
        iNewItem = i + 1;
#line 679
        sfound = 1;
      }
#line 675
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 682
    if (sfound == 0) {
      {
#line 683
      search1[0] = (char )'\000';
#line 685
      CURBeep(CursesScreen);
#line 686
      CursesErrorMsg((char *)"Search failed...");
      }
    }
#line 689
    if (ch != 110) {
      {
#line 690
      iItem = scline(-1, iNewItem, gd);
      }
    }
#line 691
    goto switch_break;
    case_0: /* CIL Label */ 
#line 695
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 698
    if (ch == 260) {
#line 699
      ch = 'u';
    } else
#line 698
    if (ch == 104) {
#line 699
      ch = 'u';
    } else
#line 698
    if (ch == 2) {
#line 699
      ch = 'u';
    }
#line 700
    if (ch == 261) {
#line 701
      ch = '\n';
    } else
#line 700
    if (ch == 108) {
#line 701
      ch = '\n';
    } else
#line 700
    if (ch == 6) {
#line 701
      ch = '\n';
    }
#line 702
    *typedchar = ch;
#line 703
    gd->currentitem = iItem;
#line 704
    return (iItem);
    switch_break: /* CIL Label */ ;
    }
    {
#line 707
    iItem = scline(iItem, iNewItem, gd);
#line 709
    wrefresh(stdscr);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 285 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 308 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.h"
int CURRequest(CursesObj *cur , char *Wintitle , char **Prompts , char **Stowages ) ;
#line 116 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.h"
void showfile(GopherObj *ZeGopher ) ;
#line 193 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
void check_sock(int sockfd , char *host , int port ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.h"
int twirl(void) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/cso.h"
void do_cso(GopherStruct *ZeGopher ) ;
#line 88 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/cso.c"
void do_cso(GopherStruct *ZeGopher ) 
{ 
  char inputline___0[1024] ;
  char *cp ;
  int sockfd ;
  int len ;
  int numfields ;
  char *Fields[50] ;
  char *Responses[50] ;
  char query[512] ;
  int i ;
  FileIO *sock ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 92
  numfields = 0;
#line 99
  Draw_Status((char *)"Fetching Fields...");
#line 100
  wrefresh(stdscr);
#line 103
  sockfd = GSconnect(ZeGopher);
  }
#line 103
  if (sockfd < 0) {
#line 104
    if ((ZeGopher->Host)->len < 0) {
#line 104
      tmp = (char *)((void *)0);
    } else {
#line 104
      tmp = (ZeGopher->Host)->data;
    }
    {
#line 104
    check_sock(sockfd, tmp, ZeGopher->iPort);
    }
#line 105
    return;
  }
  {
#line 108
  sock = FIOopenfd(sockfd, 1);
#line 110
  FIOwritestring(sock, (char *)"fields\r\n");
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 113
    len = FIOreadline(sock, inputline___0, 1024);
#line 114
    twirl();
    }
#line 115
    if (len <= 0) {
#line 116
      goto while_break;
    } else {
      {
#line 115
      tmp___0 = strncmp((char const   *)(inputline___0), "200", (size_t )3);
      }
#line 115
      if (tmp___0 == 0) {
#line 116
        goto while_break;
      }
    }
    {
#line 118
    cp = inputline___0;
#line 119
    tmp___1 = strstr((char const   *)(inputline___0), "Lookup");
    }
#line 119
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 120
      goto while_continue;
    }
    {
#line 122
    cp = strrchr((char const   *)(inputline___0), ':');
#line 123
    *cp = (char )'\000';
#line 124
    cp --;
#line 125
    tmp___2 = strrchr((char const   *)(inputline___0), ':');
#line 125
    cp = tmp___2 + 1;
#line 128
    tmp___3 = strcmp((char const   *)cp, "name");
    }
#line 128
    if (tmp___3 == 0) {
#line 128
      if (numfields != 0) {
        {
#line 129
        Fields[numfields] = Fields[0];
#line 130
        Fields[0] = strdup((char const   *)cp);
        }
      } else {
        {
#line 133
        Fields[numfields] = strdup((char const   *)cp);
        }
      }
    } else {
      {
#line 133
      Fields[numfields] = strdup((char const   *)cp);
      }
    }
    {
#line 135
    tmp___4 = malloc(sizeof(char ) * (unsigned long )COLS);
#line 135
    Responses[numfields] = (char *)tmp___4;
#line 136
    *(Responses[numfields]) = (char )'\000';
#line 137
    *(Responses[numfields] + 1) = (char )'\000';
#line 138
    numfields ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  Fields[numfields] = (char *)((void *)0);
#line 141
  Responses[numfields] = (char *)((void *)0);
#line 143
  FIOwritestring(sock, (char *)"quit\r\n");
#line 145
  FIOreadline(sock, inputline___0, 1024);
#line 146
  FIOclose(sock);
  }
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 150
    wclear(stdscr);
#line 151
    Draw_Status((char *)"...");
#line 153
    wrefresh(stdscr);
    }
#line 155
    if ((ZeGopher->Title)->len < 0) {
#line 155
      tmp___5 = (char *)((void *)0);
    } else {
#line 155
      tmp___5 = (ZeGopher->Title)->data;
    }
    {
#line 155
    tmp___6 = CURRequest(CursesScreen, tmp___5, Fields, Responses);
    }
#line 155
    if (tmp___6 < 0) {
#line 159
      i = 0;
      {
#line 159
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 159
        if (! (i < numfields)) {
#line 159
          goto while_break___1;
        }
        {
#line 160
        free((void *)Fields[i]);
#line 161
        free((void *)Responses[i]);
#line 159
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 163
      return;
    }
    {
#line 166
    Draw_Status((char *)"Searching...");
#line 167
    wrefresh(stdscr);
#line 168
    strcpy((char */* __restrict  */)(query), (char const   */* __restrict  */)"query ");
#line 170
    i = 0;
    }
    {
#line 170
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 170
      if (! (i < numfields)) {
#line 170
        goto while_break___2;
      }
#line 171
      if ((int )*(Responses[i]) != 0) {
#line 172
        cp = Responses[i];
        {
#line 173
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 174
          tmp___7 = strcspn((char const   *)cp, " ");
#line 174
          len = (int )tmp___7;
          }
#line 175
          if (len != 0) {
            {
#line 176
            strcat((char */* __restrict  */)(query), (char const   */* __restrict  */)Fields[i]);
#line 177
            strcat((char */* __restrict  */)(query), (char const   */* __restrict  */)"=");
#line 178
            strncat((char */* __restrict  */)(query), (char const   */* __restrict  */)cp,
                    (size_t )len);
#line 179
            strcat((char */* __restrict  */)(query), (char const   */* __restrict  */)" ");
            }
          }
          {
#line 181
          cp = strchr((char const   *)cp, ' ');
          }
#line 182
          if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 183
            cp ++;
          }
#line 173
          if (! ((unsigned long )cp != (unsigned long )((void *)0))) {
#line 173
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 170
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 187
    tmp___8 = strlen((char const   *)(query));
    }
#line 187
    if (tmp___8 > 6UL) {
      {
#line 188
      STRset(ZeGopher->Selstr, query);
      }
    } else {
#line 190
      i = 0;
      {
#line 190
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 190
        if (! (i < numfields)) {
#line 190
          goto while_break___4;
        }
        {
#line 191
        free((void *)Fields[i]);
#line 192
        free((void *)Responses[i]);
#line 190
        i ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 194
      return;
    }
    {
#line 197
    wrefresh(stdscr);
#line 198
    showfile(ZeGopher);
    }
#line 199
    if ((ZeGopher->Localfile)->len < 0) {
#line 199
      tmp___9 = (char *)((void *)0);
    } else {
#line 199
      tmp___9 = (ZeGopher->Localfile)->data;
    }
    {
#line 199
    unlink((char const   *)tmp___9);
#line 200
    STRset(ZeGopher->Localfile, (char *)((void *)0));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 642 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
static char *GStoNetURL___0(GopherObj *gs , char *url , char *ticket ) 
{ 
  char *path ;
  char *ftphost ;
  char *ftppath ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 647
  *url = (char )'\000';
#line 648
  if ((gs->Selstr)->len < 0) {
#line 648
    tmp = (char *)((void *)0);
  } else {
#line 648
    tmp = (gs->Selstr)->data;
  }
#line 648
  path = tmp;
#line 651
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 652
    return ((char *)((void *)0));
  }
#line 654
  if ((unsigned long )path != (unsigned long )((void *)0)) {
    {
#line 654
    tmp___1 = strncmp((char const   *)path, "ftp://", (size_t )6);
    }
#line 654
    if (tmp___1 == 0) {
      {
#line 655
      strcpy((char */* __restrict  */)url, (char const   */* __restrict  */)path);
      }
#line 656
      return (url);
    } else {
#line 654
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 658
  if ((unsigned long )path != (unsigned long )((void *)0)) {
    {
#line 658
    tmp___0 = strncmp((char const   *)path, "ftp:", (size_t )4);
    }
#line 658
    if (tmp___0 == 0) {
      {
#line 659
      ftphost = path + 4;
#line 660
      ftppath = strchr((char const   *)ftphost, '@');
      }
#line 662
      if ((unsigned long )ftppath != (unsigned long )((void *)0)) {
        {
#line 664
        sprintf((char */* __restrict  */)url, (char const   */* __restrict  */)"ftp://%.*s/",
                (int )(ftppath - ftphost), ftphost);
#line 666
        ftppath ++;
        }
#line 669
        if ((int )*ftppath == 47) {
#line 670
          ftppath ++;
        }
        {
#line 672
        strcat((char */* __restrict  */)url, (char const   */* __restrict  */)ftppath);
        }
#line 673
        return (url);
      }
    }
  }
  {
#line 676
  tmp___2 = GSgetURLhtml(gs, ticket);
#line 676
  strcpy((char */* __restrict  */)url, (char const   */* __restrict  */)tmp___2);
  }
#line 677
  return (url);
}
}
#line 767 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
static struct tm time___1  ;
#line 910 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/GSgopherobj.c"
static char *nullword___0  =    (char *)"(NULL)";
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 289 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 711
extern int noecho(void) ;
#line 305 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.h"
int CURrequester(CursesObj *cur , char *Wintitle , Requestitem **items ) ;
#line 306
int CURDialog(CursesObj *cur , char *Wintitle , char **Message ) ;
#line 138 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
char *Searchstring ;
#line 184
int outchar(int c ) ;
#line 194
char *Choose_View(GopherObj *gs ) ;
#line 195
char **AskBlock(GopherObj *gs ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/upload.h"
void BuiltinUploadfile(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.h"
void PagerBuiltin(CursesObj *cur , GopherObj *gs ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.h"
void GSmail(GopherObj *gs ) ;
#line 21
Requestitem *REQitemnew(void) ;
#line 22
void REQitemdestroy(Requestitem *req ) ;
#line 25
void Save_list(GopherDirObj *gd ) ;
#line 26
void GSdisplay(GopherObj *gs ) ;
#line 27
boolean GStoFile(GopherObj *gs , FILE *f , char *view , int (*twirlfn)() ) ;
#line 29
void GSprompter(GopherObj *gs , char *view , char *command ) ;
#line 30
void CursesMsg(char *Message , char *title ) ;
#line 32
int logrequest(char *msg , GopherObj *gs ) ;
#line 33
void Gplus_Error(int sockfd ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 768 "/usr/include/term.h"
extern int tputs(char const   * , int  , int (*)(int  ) ) ;
#line 359 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
int outchar(int c ) 
{ 


  {
  {
#line 365
  _IO_putc(c, stdout);
  }
#line 366
  return (c);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
static int twirlnum  =    0;
#line 379 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
static char *twirls  =    (char *)"-/|\\";
#line 375 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
int twirl(void) 
{ 
  int tmp ;

  {
  {
#line 381
  waddch(stdscr, (chtype const   )'\b');
#line 382
  tmp = twirlnum;
#line 382
  twirlnum ++;
#line 382
  waddch(stdscr, (chtype const   )*(twirls + tmp % 4));
#line 383
  wrefresh(stdscr);
  }
#line 385
  return (0);
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
static char *SaveName  =    (char *)((void *)0);
#line 394 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
void GSmail(GopherObj *gs ) 
{ 
  char *Filename ;
  char *tmp ;
  char *Realname ;
  char *tmp___0 ;
  char command[512] ;
  FileIO *infile ;
  FileIO *mailit ;
  char buf[512] ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
#line 397
  if ((gs->Localfile)->len < 0) {
#line 397
    tmp = (char *)((void *)0);
  } else {
#line 397
    tmp = (gs->Localfile)->data;
  }
#line 397
  Filename = tmp;
#line 398
  if ((gs->Title)->len < 0) {
#line 398
    tmp___0 = (char *)((void *)0);
  } else {
#line 398
    tmp___0 = (gs->Title)->data;
  }
#line 398
  Realname = tmp___0;
#line 410
  if ((unsigned long )SaveName == (unsigned long )((void *)0)) {
    {
#line 411
    tmp___1 = malloc(sizeof(char ) * 256UL);
#line 411
    SaveName = (char *)tmp___1;
    }
#line 411
    if ((unsigned long )SaveName == (unsigned long )((void *)0)) {
      {
#line 412
      perror("Out of memory!");
      }
    }
#line 413
    *SaveName = (char )'\000';
  }
  {
#line 416
  tmp___2 = CURGetOneOption(CursesScreen, Realname, (char *)"Mail current document to:",
                            SaveName);
  }
#line 416
  if (tmp___2 < 0) {
#line 419
    return;
  }
#line 421
  if ((int )*SaveName == 0) {
#line 422
    return;
  }
#line 432
  if (SecureMode) {
#line 432
    goto _L___0;
  } else
#line 432
  if (NoShellMode) {
    _L___0: /* CIL Label */ 
    {
#line 433
    tmp___4 = strspn((char const   *)SaveName, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789%.@!-_");
#line 433
    tmp___5 = strlen((char const   *)SaveName);
    }
#line 433
    if (tmp___4 != tmp___5) {
#line 433
      goto _L;
    } else
#line 433
    if ((int )*SaveName == 45) {
      _L: /* CIL Label */ 
#line 436
      if ((CursesScreen->AudibleBell)->len < 0) {
#line 436
        tmp___3 = (char *)((void *)0);
      } else {
#line 436
        tmp___3 = (CursesScreen->AudibleBell)->data;
      }
      {
#line 436
      puts((char const   *)tmp___3);
#line 437
      fflush(stdout);
#line 438
      Draw_Status((char *)"Address syntax rejected...");
#line 439
      wrefresh(stdscr);
      }
#line 440
      return;
    }
  }
  {
#line 443
  tmp___6 = strchr((char const   *)Realname, '\"');
  }
#line 443
  if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 444
    Realname = (char *)"Gopher File";
  }
  {
#line 447
  Draw_Status((char *)"Mailing File...");
#line 448
  wrefresh(stdscr);
#line 466
  sprintf((char */* __restrict  */)(command), (char const   */* __restrict  */)"%s %s",
          "/bin/mail", SaveName);
#line 469
  infile = FIOopenUFS(Filename, 0, 0);
#line 470
  mailit = FIOopenCmdline(command, (char *)"w");
  }
#line 472
  if ((unsigned long )mailit == (unsigned long )((void *)0)) {
    {
#line 473
    CursesErrorMsg((char *)"System problem, unable to mail");
    }
#line 474
    return;
  } else
#line 472
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 473
    CursesErrorMsg((char *)"System problem, unable to mail");
    }
#line 474
    return;
  }
  {
#line 477
  tmp___7 = strlen((char const   *)Realname);
  }
#line 477
  if (tmp___7 > 70UL) {
#line 478
    *(Realname + 70) = (char )'\000';
  }
  {
#line 480
  FIOwritestring(mailit, (char *)"Subject: ");
#line 481
  FIOwritestring(mailit, Realname);
#line 482
  FIOwritestring(mailit, (char *)"\n\n");
  }
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 484
    tmp___8 = FIOreadline(infile, buf, (int )sizeof(buf));
    }
#line 484
    if (! tmp___8) {
#line 484
      goto while_break;
    }
    {
#line 485
    twirl();
#line 486
    FIOwritestring(mailit, buf);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 489
  FIOclose(mailit);
#line 490
  FIOclose(infile);
  }
#line 494
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
static char viewnlang[64]  ;
#line 506 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
char *Choose_View(GopherObj *gs ) 
{ 
  int viewno ;
  char *view ;
  int choice ;
  int default_choice ;
  int langChoice ;
  int viewChoice ;
  char *default_lang ;
  char **views ;
  int tmp ;
  void *tmp___0 ;
  char **choices ;
  int tmp___1 ;
  void *tmp___2 ;
  VIewobj *thisView ;
  VIewobj *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int langMatch ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int viewMatch ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  VIewobj *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 513
  if (gs->isgplus) {
    {
#line 515
    GSgetginfo(gs, 1);
#line 517
    tmp___18 = GSgetNumViews(gs);
    }
#line 517
    if (tmp___18 > 1) {
      {
#line 518
      default_choice = -1;
#line 519
      langChoice = -1;
#line 519
      viewChoice = -1;
#line 520
      default_lang = (char *)"En_US";
#line 521
      tmp = GSgetNumViews(gs);
#line 521
      tmp___0 = malloc((unsigned long )(1 + tmp) * sizeof(char *));
#line 521
      views = (char **)tmp___0;
#line 522
      tmp___1 = GSgetNumViews(gs);
#line 522
      tmp___2 = malloc((unsigned long )(1 + tmp___1) * sizeof(char *));
#line 522
      choices = (char **)tmp___2;
      }
#line 524
      if ((unsigned long )views == (unsigned long )((void *)0)) {
#line 525
        return ((char *)((void *)0));
      } else
#line 524
      if ((unsigned long )choices == (unsigned long )((void *)0)) {
#line 525
        return ((char *)((void *)0));
      }
#line 527
      viewno = 0;
      {
#line 527
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 527
        tmp___12 = GSgetNumViews(gs);
        }
#line 527
        if (! (viewno < tmp___12)) {
#line 527
          goto while_break;
        }
        {
#line 528
        tmp___3 = GSgetView(gs, viewno);
#line 528
        thisView = tmp___3;
#line 530
        tmp___4 = VIgetViewnLang(thisView, viewnlang);
#line 530
        *(views + viewno) = strdup((char const   *)tmp___4);
#line 531
        tmp___5 = VIgetPrettyView(thisView, viewnlang);
#line 531
        *(choices + viewno) = strdup((char const   *)tmp___5);
        }
#line 533
        if (default_choice < 0) {
#line 534
          if ((thisView->Lang)->len < 0) {
#line 534
            tmp___6 = (char *)((void *)0);
          } else {
#line 534
            tmp___6 = (thisView->Lang)->data;
          }
          {
#line 534
          tmp___7 = strcasecmp((char const   *)tmp___6, (char const   *)default_lang);
          }
#line 534
          if (tmp___7) {
#line 534
            tmp___8 = 0;
          } else {
#line 534
            tmp___8 = 1;
          }
#line 534
          langMatch = tmp___8;
#line 535
          if ((thisView->Type)->len < 0) {
#line 535
            tmp___9 = (char *)((void *)0);
          } else {
#line 535
            tmp___9 = (thisView->Type)->data;
          }
          {
#line 535
          tmp___10 = strcasecmp((char const   *)tmp___9, "text/plain");
          }
#line 535
          if (tmp___10) {
#line 535
            tmp___11 = 0;
          } else {
#line 535
            tmp___11 = 1;
          }
#line 535
          viewMatch = tmp___11;
#line 537
          if (langMatch) {
#line 537
            if (viewMatch) {
#line 538
              default_choice = viewno;
            } else {
#line 537
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 540
            if (langMatch) {
#line 540
              if (langChoice < 1) {
#line 541
                langChoice = viewno;
              }
            }
#line 542
            if (viewMatch) {
#line 542
              if (viewChoice < 1) {
#line 543
                viewChoice = viewno;
              }
            }
          }
        }
#line 527
        viewno ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 548
      if (default_choice < 0) {
#line 549
        if (viewChoice >= 0) {
#line 550
          default_choice = viewChoice;
        } else
#line 551
        if (langChoice >= 0) {
#line 552
          default_choice = langChoice;
        } else {
#line 554
          default_choice = 0;
        }
      }
#line 557
      *(choices + viewno) = (char *)((void *)0);
#line 558
      if ((gs->Title)->len < 0) {
#line 558
        tmp___13 = (char *)((void *)0);
      } else {
#line 558
        tmp___13 = (gs->Title)->data;
      }
      {
#line 558
      choice = CURChoice(CursesScreen, tmp___13, choices, (char *)"Choose a document type",
                         default_choice);
      }
#line 562
      if (choice == -1) {
#line 563
        return ((char *)((void *)0));
      }
      {
#line 565
      sprintf((char */* __restrict  */)(viewnlang), (char const   */* __restrict  */)"%s",
              *(views + choice));
#line 567
      viewno = 0;
      }
      {
#line 567
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 567
        tmp___14 = GSgetNumViews(gs);
        }
#line 567
        if (! (viewno < tmp___14)) {
#line 567
          goto while_break___0;
        }
        {
#line 568
        free((void *)*(views + viewno));
#line 570
        free((void *)*(choices + viewno));
#line 567
        viewno ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 573
      free((void *)views);
#line 574
      free((void *)choices);
      }
#line 575
      return (viewnlang);
    } else {
      {
#line 577
      tmp___17 = GSgetNumViews(gs);
      }
#line 577
      if (tmp___17 == 1) {
        {
#line 578
        tmp___15 = GSgetView(gs, 0);
#line 578
        tmp___16 = VIgetViewnLang(tmp___15, viewnlang);
        }
#line 578
        return (tmp___16);
      } else {
#line 580
        return ((char *)((void *)0));
      }
    }
  } else {
    {
#line 585
    if ((int )gs->sFileType == 50) {
#line 585
      goto case_50;
    }
#line 585
    if ((int )gs->sFileType == 48) {
#line 585
      goto case_50;
    }
#line 588
    if ((int )gs->sFileType == 77) {
#line 588
      goto case_77;
    }
#line 591
    if ((int )gs->sFileType == 52) {
#line 591
      goto case_52;
    }
#line 594
    if ((int )gs->sFileType == 104) {
#line 594
      goto case_104;
    }
#line 597
    if ((int )gs->sFileType == 103) {
#line 597
      goto case_103;
    }
#line 600
    if ((int )gs->sFileType == 73) {
#line 600
      goto case_73;
    }
#line 603
    if ((int )gs->sFileType == 59) {
#line 603
      goto case_59;
    }
#line 606
    if ((int )gs->sFileType == 115) {
#line 606
      goto case_115;
    }
#line 609
    if ((int )gs->sFileType == 84) {
#line 609
      goto case_84;
    }
#line 612
    if ((int )gs->sFileType == 56) {
#line 612
      goto case_56;
    }
#line 616
    if ((int )gs->sFileType == 53) {
#line 616
      goto case_53;
    }
#line 616
    if ((int )gs->sFileType == 57) {
#line 616
      goto case_53;
    }
#line 619
    if ((int )gs->sFileType == 80) {
#line 619
      goto case_80;
    }
#line 622
    goto switch_default;
    case_50: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 586
    view = (char *)"text/plain";
#line 587
    goto switch_break;
    case_77: /* CIL Label */ 
#line 589
    view = (char *)"message/rfc822";
#line 590
    goto switch_break;
    case_52: /* CIL Label */ 
#line 592
    view = (char *)"application/mac-binhex40";
#line 593
    goto switch_break;
    case_104: /* CIL Label */ 
#line 595
    view = (char *)"text/html";
#line 596
    goto switch_break;
    case_103: /* CIL Label */ 
#line 598
    view = (char *)"image/gif";
#line 599
    goto switch_break;
    case_73: /* CIL Label */ 
#line 601
    view = (char *)"image";
#line 602
    goto switch_break;
    case_59: /* CIL Label */ 
#line 604
    view = (char *)"video";
#line 605
    goto switch_break;
    case_115: /* CIL Label */ 
#line 607
    view = (char *)"audio/basic";
#line 608
    goto switch_break;
    case_84: /* CIL Label */ 
#line 610
    view = (char *)"terminal/tn3270";
#line 611
    goto switch_break;
    case_56: /* CIL Label */ 
#line 613
    view = (char *)"terminal/telnet";
#line 614
    goto switch_break;
    case_53: /* CIL Label */ 
    case_57: /* CIL Label */ 
#line 617
    view = (char *)"application/octet-stream";
#line 618
    goto switch_break;
    case_80: /* CIL Label */ 
#line 620
    view = (char *)"application/pdf";
#line 621
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 623
    return ((char *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
#line 626
    return (view);
  }
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
Requestitem *REQitemnew(void) 
{ 
  Requestitem *temp ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 636
  tmp = malloc(sizeof(Requestitem ));
#line 636
  temp = (Requestitem *)tmp;
  }
#line 637
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 638
    return ((Requestitem *)((void *)0));
  }
  {
#line 640
  tmp___0 = malloc(sizeof(char ) * (unsigned long )COLS);
#line 640
  temp->stowage = (char *)tmp___0;
#line 641
  *(temp->stowage + 0) = (char )'\000';
#line 642
  temp->choices = (char **)((void *)0);
#line 643
  temp->prompt = (char *)((void *)0);
  }
#line 645
  return (temp);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
void REQitemdestroy(Requestitem *req ) 
{ 
  int j ;

  {
#line 653
  if ((unsigned long )req->stowage != (unsigned long )((char *)((void *)0))) {
    {
#line 654
    free((void *)req->stowage);
    }
  }
#line 656
  if ((unsigned long )req->prompt != (unsigned long )((char *)((void *)0))) {
    {
#line 657
    free((void *)req->prompt);
    }
  }
#line 659
  if ((unsigned long )req->choices != (unsigned long )((char **)((void *)0))) {
#line 660
    j = 0;
    {
#line 660
    while (1) {
      while_continue: /* CIL Label */ ;
#line 660
      if (! ((unsigned long )*(req->choices + j) != (unsigned long )((char *)((void *)0)))) {
#line 660
        goto while_break;
      }
      {
#line 661
      free((void *)*(req->choices + j));
#line 660
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 662
    free((void *)req->choices);
    }
  }
  {
#line 664
  free((void *)req);
  }
#line 666
  return;
}
}
#line 672 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
char **AskBlock(GopherObj *gs ) 
{ 
  int Asknum ;
  int reqnum ;
  int AskLs ;
  Blockobj *bl ;
  Requestitem **items ;
  char **asktypes ;
  char **responses ;
  char askline[1024] ;
  char *defaultval ;
  int i ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *askprompt ;
  char *cp ;
  char *tmp___6 ;
  int cnum ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  int x ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int respnum ;
  void *tmp___18 ;
  int alnum ;
  int extra ;
  char numlinestr[16] ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;

  {
  {
#line 675
  AskLs = 0;
#line 679
  responses = (char **)((void *)0);
#line 684
  GSgetginfo(gs, 1);
#line 686
  bl = GSfindBlock(gs, (char *)"ASK");
  }
#line 688
  if ((unsigned long )bl == (unsigned long )((void *)0)) {
#line 689
    return ((char **)((void *)0));
  }
#line 692
  Asknum = 0;
  {
#line 692
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 692
    tmp___1 = BLgetNumLines(bl);
    }
#line 692
    if (! (Asknum < tmp___1)) {
#line 692
      goto while_break;
    }
    {
#line 693
    tmp = BLgetLine(bl, Asknum);
#line 693
    tmp___0 = strncasecmp((char const   *)tmp, "AskL:", (size_t )5);
    }
#line 693
    if (tmp___0 == 0) {
#line 694
      AskLs ++;
    }
#line 692
    Asknum ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 698
  tmp___2 = BLgetNumLines(bl);
#line 698
  tmp___3 = malloc(sizeof(Requestitem *) * (unsigned long )((tmp___2 + AskLs * 10) + 1));
#line 698
  items = (Requestitem **)tmp___3;
#line 701
  tmp___4 = BLgetNumLines(bl);
#line 701
  tmp___5 = malloc(sizeof(char *) * (unsigned long )((tmp___4 + AskLs * 10) + 1));
#line 701
  asktypes = (char **)tmp___5;
#line 704
  reqnum = 0;
#line 706
  Asknum = 0;
  }
  {
#line 706
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 706
    tmp___17 = BLgetNumLines(bl);
    }
#line 706
    if (! (Asknum < tmp___17)) {
#line 706
      goto while_break___0;
    }
    {
#line 709
    tmp___6 = BLgetLine(bl, Asknum);
#line 709
    strncpy((char */* __restrict  */)(askline), (char const   */* __restrict  */)tmp___6,
            sizeof(askline));
#line 710
    askline[sizeof(askline) - 1UL] = (char )'\000';
#line 711
    *(items + reqnum) = REQitemnew();
#line 714
    askprompt = strchr((char const   *)(askline), ':');
    }
#line 715
    if ((unsigned long )askprompt == (unsigned long )((void *)0)) {
      {
#line 717
      (*(items + reqnum))->prompt = strdup("");
#line 718
      (*(items + reqnum))->thing = (Curreqtype )1;
#line 719
      *(asktypes + reqnum) = strdup("Note:");
      }
#line 720
      goto __Cont;
    }
    {
#line 722
    *(askprompt + 1) = (char )'\000';
#line 723
    askprompt += 2;
#line 726
    cp = strchr((char const   *)askprompt, '\t');
    }
#line 727
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 728
      defaultval = cp + 1;
#line 729
      *cp = (char )'\000';
    } else {
#line 731
      defaultval = (char *)((void *)0);
    }
    {
#line 733
    *(asktypes + reqnum) = strdup((char const   *)(askline));
#line 734
    (*(items + reqnum))->prompt = strdup((char const   *)askprompt);
#line 736
    tmp___16 = strncasecmp((char const   *)(askline), "Note:", (size_t )5);
    }
#line 736
    if (tmp___16 == 0) {
#line 737
      (*(items + reqnum))->thing = (Curreqtype )1;
    } else {
      {
#line 738
      tmp___15 = strncasecmp((char const   *)(askline), "Choose:", (size_t )7);
      }
#line 738
      if (tmp___15 == 0) {
        {
#line 739
        cnum = 0;
#line 741
        (*(items + reqnum))->thing = (Curreqtype )4;
#line 742
        (*(items + reqnum))->chooseitem = 0;
#line 745
        tmp___7 = malloc(sizeof(char *) * 100UL);
#line 745
        (*(items + reqnum))->choices = (char **)tmp___7;
        }
        {
#line 748
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 748
          cp = strchr((char const   *)defaultval, '\t');
          }
#line 748
          if (! ((unsigned long )cp != (unsigned long )((void *)0))) {
#line 748
            goto while_break___1;
          }
          {
#line 749
          *cp = (char )'\000';
#line 750
          tmp___8 = cnum;
#line 750
          cnum ++;
#line 750
          *((*(items + reqnum))->choices + tmp___8) = strdup((char const   *)defaultval);
#line 751
          defaultval = cp + 1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 753
        if ((unsigned long )defaultval != (unsigned long )((void *)0)) {
          {
#line 754
          tmp___9 = cnum;
#line 754
          cnum ++;
#line 754
          *((*(items + reqnum))->choices + tmp___9) = strdup((char const   *)defaultval);
          }
        }
#line 756
        *((*(items + reqnum))->choices + cnum) = (char *)((void *)0);
      } else {
        {
#line 759
        tmp___14 = strncasecmp((char const   *)(askline), "Select:", (size_t )7);
        }
#line 759
        if (tmp___14 == 0) {
          {
#line 760
          (*(items + reqnum))->thing = (Curreqtype )4;
#line 761
          (*(items + reqnum))->chooseitem = 0;
#line 762
          tmp___10 = malloc(sizeof(char *) * 3UL);
#line 762
          (*(items + reqnum))->choices = (char **)tmp___10;
#line 764
          cp = strrchr((char const   *)(*(items + reqnum))->prompt, ':');
          }
#line 765
          if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 766
            *cp = (char )'\000';
#line 767
            cp ++;
#line 768
            if ((int )*cp == 49) {
#line 769
              (*(items + reqnum))->chooseitem = 1;
            }
          }
          {
#line 772
          *((*(items + reqnum))->choices + 0) = strdup("No");
#line 773
          *((*(items + reqnum))->choices + 1) = strdup("Yes");
#line 774
          *((*(items + reqnum))->choices + 2) = (char *)((void *)0);
          }
        } else {
          {
#line 776
          tmp___13 = strncasecmp((char const   *)(askline), "AskP:", (size_t )5);
          }
#line 776
          if (tmp___13 == 0) {
#line 777
            (*(items + reqnum))->thing = (Curreqtype )3;
          } else {
            {
#line 778
            tmp___12 = strncasecmp((char const   *)(askline), "Choosef:", (size_t )8);
            }
#line 778
            if (tmp___12 == 0) {
#line 779
              (*(items + reqnum))->thing = (Curreqtype )6;
            } else {
              {
#line 780
              tmp___11 = strncasecmp((char const   *)(askline), "AskL:", (size_t )5);
              }
#line 780
              if (tmp___11 == 0) {
#line 783
                (*(items + reqnum))->thing = (Curreqtype )1;
#line 787
                x = 0;
                {
#line 787
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 787
                  if (! (x < 10)) {
#line 787
                    goto while_break___2;
                  }
                  {
#line 788
                  reqnum ++;
#line 789
                  *(items + reqnum) = REQitemnew();
#line 790
                  (*(items + reqnum))->prompt = strdup("");
#line 791
                  (*(items + reqnum))->thing = (Curreqtype )5;
#line 792
                  *(asktypes + reqnum) = (char *)((void *)0);
#line 787
                  x ++;
                  }
                }
                while_break___2: /* CIL Label */ ;
                }
              } else {
#line 797
                (*(items + reqnum))->thing = (Curreqtype )2;
              }
            }
          }
        }
      }
    }
#line 799
    if ((unsigned long )defaultval != (unsigned long )((void *)0)) {
      {
#line 800
      strncat((char */* __restrict  */)(*(items + reqnum))->stowage, (char const   */* __restrict  */)defaultval,
              (size_t )(COLS - 1));
      }
    }
    __Cont: /* CIL Label */ 
#line 706
    Asknum ++;
#line 706
    reqnum ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 803
  *(items + reqnum) = (Requestitem *)((void *)0);
#line 805
  if ((gs->Title)->len < 0) {
#line 805
    tmp___28 = (char *)((void *)0);
  } else {
#line 805
    tmp___28 = (gs->Title)->data;
  }
  {
#line 805
  tmp___29 = CURrequester(CursesScreen, tmp___28, items);
  }
#line 805
  if (! tmp___29) {
    {
#line 806
    respnum = 0;
#line 808
    tmp___18 = malloc(sizeof(char *) * (unsigned long )(10 + reqnum));
#line 808
    responses = (char **)tmp___18;
#line 810
    i = 0;
    }
    {
#line 810
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 810
      if (! (i < reqnum)) {
#line 810
        goto while_break___3;
      }
#line 811
      if (*(asktypes + i)) {
        {
#line 811
        tmp___26 = strcasecmp((char const   *)*(asktypes + i), "AskL:");
        }
#line 811
        if (tmp___26 == 0) {
#line 816
          alnum = 9;
          {
#line 816
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 816
            if (! (alnum >= 0)) {
#line 816
              goto while_break___4;
            }
#line 817
            if ((int )*((*(items + (alnum + i)))->stowage) != 0) {
#line 818
              goto while_break___4;
            }
#line 816
            alnum --;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 820
          alnum ++;
#line 821
          sprintf((char */* __restrict  */)(numlinestr), (char const   */* __restrict  */)"%d",
                  alnum);
#line 823
          tmp___19 = respnum;
#line 823
          respnum ++;
#line 823
          *(responses + tmp___19) = strdup((char const   *)(numlinestr));
#line 825
          extra = 10 - alnum;
          }
          {
#line 826
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 826
            if (! alnum) {
#line 826
              goto while_break___5;
            }
            {
#line 827
            tmp___20 = respnum;
#line 827
            respnum ++;
#line 827
            i ++;
#line 827
            *(responses + tmp___20) = strdup((char const   *)(*(items + i))->stowage);
#line 828
            alnum --;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 830
          i += extra;
        } else {
#line 811
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 832
      if (*(asktypes + i)) {
        {
#line 832
        tmp___25 = strcasecmp((char const   *)*(asktypes + i), "Select:");
        }
#line 832
        if (tmp___25 == 0) {
#line 833
          if ((*(items + i))->chooseitem == 0) {
            {
#line 834
            tmp___21 = respnum;
#line 834
            respnum ++;
#line 834
            *(responses + tmp___21) = strdup("0");
            }
          } else {
            {
#line 836
            tmp___22 = respnum;
#line 836
            respnum ++;
#line 836
            *(responses + tmp___22) = strdup("1");
            }
          }
        } else {
#line 832
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 838
      if ((unsigned int )(*(items + i))->thing == 4U) {
        {
#line 839
        tmp___23 = respnum;
#line 839
        respnum ++;
#line 839
        *(responses + tmp___23) = strdup((char const   *)*((*(items + i))->choices + (*(items + i))->chooseitem));
        }
      } else
#line 841
      if ((unsigned int )(*(items + i))->thing == 2U) {
        {
#line 843
        tmp___24 = respnum;
#line 843
        respnum ++;
#line 843
        *(responses + tmp___24) = strdup((char const   *)(*(items + i))->stowage);
        }
      } else
#line 841
      if ((unsigned int )(*(items + i))->thing == 3U) {
        {
#line 843
        tmp___24 = respnum;
#line 843
        respnum ++;
#line 843
        *(responses + tmp___24) = strdup((char const   *)(*(items + i))->stowage);
        }
      }
#line 810
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 845
    tmp___27 = respnum;
#line 845
    respnum ++;
#line 845
    *(responses + tmp___27) = (char *)((void *)0);
  }
#line 848
  i = 0;
  {
#line 848
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 848
    if (! (i < Asknum)) {
#line 848
      goto while_break___6;
    }
    {
#line 850
    REQitemdestroy(*(items + i));
#line 851
    *(items + i) = (Requestitem *)((void *)0);
    }
#line 852
    if ((unsigned long )*(asktypes + i) != (unsigned long )((void *)0)) {
      {
#line 853
      free((void *)*(asktypes + i));
      }
    }
#line 848
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 856
  free((void *)items);
#line 857
  free((void *)asktypes);
  }
#line 859
  return (responses);
}
}
#line 867 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
void Gplus_Error(int sockfd ) 
{ 
  char inputline___0[256] ;
  char *errmsg[25] ;
  int i ;
  char *cp ;
  int tmp ;
  int tmp___0 ;

  {
#line 875
  i = 0;
  {
#line 875
  while (1) {
    while_continue: /* CIL Label */ ;
#line 875
    if (! (i < 25)) {
#line 875
      goto while_break;
    }
    {
#line 878
    tmp = readline(sockfd, inputline___0, (int )sizeof(inputline___0));
    }
#line 878
    if (tmp <= 0) {
#line 879
      goto while_break;
    }
    {
#line 880
    ZapCRLF(inputline___0);
#line 881
    tmp___0 = strcmp((char const   *)(inputline___0), ".");
    }
#line 881
    if (tmp___0 == 0) {
#line 882
      goto while_break;
    }
#line 884
    cp = inputline___0;
    {
#line 885
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 885
      cp = strchr((char const   *)cp, '\t');
      }
#line 885
      if (! ((unsigned long )cp != (unsigned long )((void *)0))) {
#line 885
        goto while_break___0;
      }
#line 886
      *cp = (char )' ';
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 888
    errmsg[i] = strdup((char const   *)(inputline___0));
#line 875
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 891
  errmsg[i] = (char *)((void *)0);
#line 893
  CURDialog(CursesScreen, (char *)"Gopher Transmission Error", errmsg);
#line 894
  i = 0;
  }
  {
#line 894
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 895
    if ((unsigned long )errmsg[i] == (unsigned long )((void *)0)) {
#line 896
      goto while_break___1;
    } else {
      {
#line 898
      free((void *)errmsg[i]);
      }
    }
#line 894
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 901
  return;
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
boolean GStoFile(GopherObj *gs , FILE *f , char *view , int (*twirlfn)() ) 
{ 
  int numread ;
  int sockfd ;
  char buf[1024] ;
  char newbuf[1024] ;
  int bytemethod ;
  int line ;
  int i ;
  char *tmp ;
  char cso_click ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *colonpos ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  boolean tmp___8 ;

  {
  {
#line 916
  line = 0;
#line 921
  sockfd = GSconnect(gs);
  }
#line 921
  if (sockfd < 0) {
#line 922
    if ((gs->Host)->len < 0) {
#line 922
      tmp = (char *)((void *)0);
    } else {
#line 922
      tmp = (gs->Host)->data;
    }
    {
#line 922
    check_sock(sockfd, tmp, gs->iPort);
    }
#line 923
    return (0);
  }
  {
#line 927
  GStransmit(gs, sockfd, (char *)((void *)0), (char *)"+", view);
#line 928
  bytemethod = GSrecvHeader(gs, sockfd);
  }
#line 930
  if (bytemethod == 0) {
    {
#line 931
    Gplus_Error(sockfd);
    }
#line 933
    return (0);
  }
  {
#line 937
  Draw_Status((char *)"Receiving File...");
#line 938
  wrefresh(stdscr);
#line 941
  tmp___8 = GSisText(gs, view);
  }
#line 941
  if (tmp___8) {
#line 942
    cso_click = (char )'\000';
    {
#line 944
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 944
      tmp___5 = readline(sockfd, newbuf, (int )sizeof(newbuf));
      }
#line 944
      if (tmp___5 > 0) {
#line 944
        if (! (! ControlCpressed)) {
#line 944
          goto while_break;
        }
      } else {
#line 944
        goto while_break;
      }
      {
#line 946
      ZapCRLF(newbuf);
      }
#line 947
      if (line) {
#line 947
        if (! ((int )gs->sFileType == 50)) {
          {
#line 949
          fputs((char const   */* __restrict  */)(buf), (FILE */* __restrict  */)f);
#line 952
          tmp___0 = strlen((char const   *)(buf));
          }
#line 952
          if (tmp___0 < sizeof(buf)) {
            {
#line 953
            _IO_putc('\n', f);
            }
          }
        }
      }
      {
#line 955
      line ++;
#line 957
      strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)(newbuf));
      }
#line 958
      if ((int )gs->sFileType == 50) {
#line 959
        if ((int )buf[0] == 50) {
#line 960
          goto while_break;
        }
#line 962
        if ((int )buf[0] >= 51) {
#line 962
          if ((int )buf[0] <= 57) {
#line 963
            if ((gs->Selstr)->len < 0) {
#line 963
              tmp___1 = (char *)((void *)0);
            } else {
#line 963
              tmp___1 = (gs->Selstr)->data;
            }
            {
#line 963
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s\n",
                    tmp___1);
#line 964
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s\n",
                    buf + 4);
            }
#line 965
            goto while_break;
          }
        }
#line 967
        if ((int )buf[0] == 45) {
#line 970
          if ((int )buf[1] >= 51) {
#line 970
            if ((int )buf[1] <= 57) {
#line 971
              if ((gs->Selstr)->len < 0) {
#line 971
                tmp___2 = (char *)((void *)0);
              } else {
#line 971
                tmp___2 = (gs->Selstr)->data;
              }
              {
#line 971
              fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s\n",
                      tmp___2);
#line 972
              fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s\n",
                      buf + 5);
              }
            } else {
#line 970
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 975
            tmp___3 = strchr((char const   *)(buf + 5), ':');
#line 975
            colonpos = tmp___3;
#line 976
            i = '\000';
            }
#line 977
            if ((unsigned long )colonpos != (unsigned long )((void *)0)) {
#line 977
              if ((int )*(colonpos - 1) != (int )cso_click) {
                {
#line 978
                fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"-------------------------------------------------------\n");
#line 979
                cso_click = *(colonpos - 1);
                }
              }
            }
#line 981
            if (colonpos) {
#line 981
              tmp___4 = colonpos + 1;
            } else {
#line 981
              tmp___4 = buf + 6;
            }
            {
#line 981
            fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)f);
#line 982
            fputc('\n', f);
            }
          }
        }
      }
#line 986
      if (line % 25 == 0) {
        {
#line 987
        (*twirlfn)();
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 989
    if (ControlCpressed) {
      {
#line 990
      CursesErrorMsg((char *)"Interrupted by User");
#line 991
      ControlCpressed = 0;
      }
    }
#line 993
    if (line) {
#line 993
      if (! ((int )gs->sFileType == 50)) {
#line 993
        if ((int )buf[0] == 46) {
#line 993
          if (! ((int )*(buf + 1) == 0)) {
#line 993
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 996
          fputs((char const   */* __restrict  */)(buf), (FILE */* __restrict  */)f);
#line 999
          tmp___6 = strlen((char const   *)(buf));
          }
#line 999
          if (tmp___6 < sizeof(buf)) {
            {
#line 1000
            _IO_putc('\n', f);
            }
          }
        }
      }
    }
  } else {
    {
#line 1013
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1013
      numread = readrecvbuf(sockfd, buf, (int )sizeof(buf));
      }
#line 1013
      if (numread > 0) {
#line 1013
        if (! (! ControlCpressed)) {
#line 1013
          goto while_break___0;
        }
      } else {
#line 1013
        goto while_break___0;
      }
      {
#line 1016
      tmp___7 = fwrite((void const   */* __restrict  */)(buf), (size_t )numread, (size_t )1,
                       (FILE */* __restrict  */)f);
      }
#line 1016
      if (tmp___7 == 0UL) {
        {
#line 1018
        CursesErrorMsg((char *)"Problems Writing");
#line 1019
        close(sockfd);
        }
#line 1020
        return (0);
      }
      {
#line 1022
      (*twirlfn)();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1024
    if (ControlCpressed) {
      {
#line 1025
      CursesErrorMsg((char *)"Interrupted by User");
#line 1026
      ControlCpressed = 0;
#line 1027
      close(sockfd);
      }
#line 1028
      return (0);
    }
  }
#line 1033
  if ((int )gs->sFileType == 50) {
    {
#line 1034
    writestring(sockfd, (char *)"quit\r\n");
    }
  }
  {
#line 1036
  close(sockfd);
  }
#line 1037
  return (1);
}
}
#line 1045 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
void VMSfile(char *fname ) 
{ 


  {
#line 1049
  return;
}
}
#line 1197 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
void UNIXfile(char *fname ) 
{ 
  char *cp ;
  size_t tmp ;

  {
#line 1202
  cp = fname;
  {
#line 1202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1202
    if (! ((int )*cp != 0)) {
#line 1202
      goto while_break;
    }
    {
#line 1210
    if ((int )*cp == 38) {
#line 1210
      goto case_38;
    }
#line 1210
    if ((int )*cp == 41) {
#line 1210
      goto case_38;
    }
#line 1210
    if ((int )*cp == 40) {
#line 1210
      goto case_38;
    }
#line 1210
    if ((int )*cp == 32) {
#line 1210
      goto case_38;
    }
#line 1210
    if ((int )*cp == 47) {
#line 1210
      goto case_38;
    }
#line 1210
    if ((int )*cp == 34) {
#line 1210
      goto case_38;
    }
#line 1210
    if ((int )*cp == 39) {
#line 1210
      goto case_38;
    }
#line 1225
    if ((int )*cp == 62) {
#line 1225
      goto case_62;
    }
#line 1225
    if ((int )*cp == 60) {
#line 1225
      goto case_62;
    }
#line 1225
    if ((int )*cp == 92) {
#line 1225
      goto case_62;
    }
#line 1225
    if ((int )*cp == 96) {
#line 1225
      goto case_62;
    }
#line 1225
    if ((int )*cp == 42) {
#line 1225
      goto case_62;
    }
#line 1225
    if ((int )*cp == 63) {
#line 1225
      goto case_62;
    }
#line 1225
    if ((int )*cp == 33) {
#line 1225
      goto case_62;
    }
#line 1225
    if ((int )*cp == 124) {
#line 1225
      goto case_62;
    }
#line 1225
    if ((int )*cp == 125) {
#line 1225
      goto case_62;
    }
#line 1225
    if ((int )*cp == 123) {
#line 1225
      goto case_62;
    }
#line 1225
    if ((int )*cp == 93) {
#line 1225
      goto case_62;
    }
#line 1225
    if ((int )*cp == 91) {
#line 1225
      goto case_62;
    }
#line 1203
    goto switch_break;
    case_38: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_47: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_39: /* CIL Label */ 
#line 1211
    *cp = (char )'-';
#line 1212
    goto switch_break;
    case_62: /* CIL Label */ 
    case_60: /* CIL Label */ 
    case_92: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_124: /* CIL Label */ 
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_91: /* CIL Label */ 
#line 1226
    *cp = (char )'_';
#line 1227
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1202
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1233
  tmp = strlen((char const   *)fname);
  }
#line 1233
  if (tmp > 50UL) {
#line 1234
    *(fname + 50) = (char )'\000';
  }
#line 1238
  if ((int )*(fname + 0) == 45) {
#line 1239
    *(fname + 0) = (char )'_';
  } else
#line 1238
  if ((int )*(fname + 0) == 46) {
#line 1239
    *(fname + 0) = (char )'_';
  }
#line 1241
  return;
}
}
#line 1254 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
void Save_file(GopherObj *gs , char *saveto , char *view ) 
{ 
  char Title[128] ;
  char Userfilename[128] ;
  char *cp ;
  char buf[1024] ;
  boolean Openpipe ;
  boolean GS2FileSucceeded ;
  FILE *f ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  struct passwd *pass ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char tmpstr[256] ;
  char tempstr[128] ;
  int oldfd ;
  int cc ;
  char *tmp___5 ;
  size_t tmp___6 ;
  ssize_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
#line 1260
  Openpipe = 0;
#line 1261
  GS2FileSucceeded = 1;
  {
#line 1271
  if ((int )gs->sFileType == 84) {
#line 1271
    goto case_84;
  }
#line 1271
  if ((int )gs->sFileType == 56) {
#line 1271
    goto case_84;
  }
#line 1271
  if ((int )gs->sFileType == 105) {
#line 1271
    goto case_84;
  }
#line 1271
  if ((int )gs->sFileType == 55) {
#line 1271
    goto case_84;
  }
#line 1271
  if ((int )gs->sFileType == 51) {
#line 1271
    goto case_84;
  }
#line 1271
  if ((int )gs->sFileType == 49) {
#line 1271
    goto case_84;
  }
#line 1271
  if ((int )gs->sFileType == 50) {
#line 1271
    goto case_84;
  }
#line 1264
  goto switch_break;
  case_84: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_50: /* CIL Label */ 
#line 1272
  if ((unsigned long )saveto == (unsigned long )((void *)0)) {
    {
#line 1273
    CursesErrorMsg((char *)"Sorry, can\'t save that item to a file!");
    }
#line 1274
    return;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1279
  if ((unsigned long )view == (unsigned long )((void *)0)) {
    {
#line 1280
    view = Choose_View(gs);
    }
  }
#line 1282
  if ((unsigned long )view == (unsigned long )((void *)0)) {
#line 1283
    return;
  } else
#line 1282
  if ((unsigned long )view == (unsigned long )"") {
#line 1283
    return;
  }
#line 1286
  if ((gs->Title)->len < 0) {
#line 1286
    tmp = (char *)((void *)0);
  } else {
#line 1286
    tmp = (gs->Title)->data;
  }
  {
#line 1286
  strcpy((char */* __restrict  */)(Title), (char const   */* __restrict  */)tmp);
  }
#line 1290
  if ((unsigned long )saveto == (unsigned long )((void *)0)) {
#line 1293
    if (NoShellMode) {
      {
#line 1294
      CursesErrorMsg((char *)"Sorry, you are not allowed to do this");
      }
#line 1295
      return;
    } else
#line 1293
    if (SecureMode) {
      {
#line 1294
      CursesErrorMsg((char *)"Sorry, you are not allowed to do this");
      }
#line 1295
      return;
    }
    {
#line 1298
    strcpy((char */* __restrict  */)(Userfilename), (char const   */* __restrict  */)(Title));
#line 1303
    UNIXfile(Userfilename);
#line 1306
    tmp___0 = CURGetOneOption(CursesScreen, Title, (char *)"Save in file:", Userfilename);
    }
#line 1306
    if (tmp___0 < 0) {
#line 1308
      return;
    }
#line 1310
    saveto = Userfilename;
  }
#line 1313
  if ((int )*saveto == 0) {
#line 1314
    return;
  }
#line 1316
  if ((unsigned long )view == (unsigned long )((void *)0)) {
    {
#line 1317
    view = Choose_View(gs);
    }
  }
#line 1319
  if ((unsigned long )view == (unsigned long )((void *)0)) {
#line 1320
    return;
  } else
#line 1319
  if ((unsigned long )view == (unsigned long )"") {
#line 1320
    return;
  }
#line 1323
  if ((int )*saveto == 124) {
#line 1325
    Openpipe = 1;
#line 1326
    saveto ++;
  }
#line 1329
  if ((int )*saveto == 126) {
#line 1331
    if ((int )*(saveto + 1) == 47) {
      {
#line 1331
      cp = getenv("HOME");
      }
#line 1331
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
        {
#line 1333
        strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)cp);
#line 1334
        tmp___1 = strlen((char const   *)cp);
#line 1334
        buf[tmp___1] = (char )'/';
#line 1335
        tmp___2 = strlen((char const   *)cp);
#line 1335
        strcpy((char */* __restrict  */)((buf + tmp___2) + 1), (char const   */* __restrict  */)(saveto + 2));
#line 1336
        strcpy((char */* __restrict  */)saveto, (char const   */* __restrict  */)(buf));
        }
      } else {
#line 1331
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1341
      cp = strchr((char const   *)saveto, '/');
#line 1342
      *cp = (char )'\000';
#line 1343
      pass = getpwnam((char const   *)(saveto + 1));
      }
#line 1344
      if ((unsigned long )pass != (unsigned long )((void *)0)) {
        {
#line 1346
        strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)pass->pw_dir);
#line 1347
        tmp___3 = strlen((char const   *)pass->pw_dir);
#line 1347
        buf[tmp___3] = (char )'/';
#line 1348
        tmp___4 = strlen((char const   *)pass->pw_dir);
#line 1348
        strcpy((char */* __restrict  */)((buf + tmp___4) + 1), (char const   */* __restrict  */)(cp + 1));
#line 1349
        strcpy((char */* __restrict  */)saveto, (char const   */* __restrict  */)(buf));
        }
      } else {
        {
#line 1353
        sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"No such user \'%s\'",
                saveto + 1);
#line 1354
        CursesErrorMsg(tmpstr);
        }
#line 1355
        return;
      }
    }
  }
#line 1369
  if (Openpipe) {
    {
#line 1370
    f = popen((char const   *)saveto, "w+");
    }
  } else {
    {
#line 1372
    f = fopen((char const   */* __restrict  */)saveto, (char const   */* __restrict  */)"w+");
    }
  }
#line 1375
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 1378
    sprintf((char */* __restrict  */)(tempstr), (char const   */* __restrict  */)"Couldn\'t create \'%s\'",
            saveto);
#line 1379
    CursesErrorMsg(tempstr);
    }
#line 1380
    return;
  }
#line 1383
  if ((gs->Localfile)->len < 0) {
#line 1383
    tmp___8 = (char *)((void *)0);
  } else {
#line 1383
    tmp___8 = (gs->Localfile)->data;
  }
#line 1383
  if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 1383
    if ((gs->Localview)->len < 0) {
#line 1383
      tmp___9 = (char *)((void *)0);
    } else {
#line 1383
      tmp___9 = (gs->Localview)->data;
    }
    {
#line 1383
    tmp___10 = strcmp((char const   *)view, (char const   *)tmp___9);
    }
#line 1383
    if (tmp___10 == 0) {
#line 1387
      if ((gs->Localfile)->len < 0) {
#line 1387
        tmp___5 = (char *)((void *)0);
      } else {
#line 1387
        tmp___5 = (gs->Localfile)->data;
      }
      {
#line 1387
      oldfd = open((char const   *)tmp___5, 0, 0);
      }
#line 1388
      if (oldfd < 0) {
        {
#line 1389
        CursesErrorMsg((char *)"Can\'t open old file..");
        }
#line 1390
        if (Openpipe) {
          {
#line 1391
          pclose(f);
          }
        } else {
          {
#line 1393
          fclose(f);
          }
        }
#line 1394
        return;
      }
      {
#line 1397
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1397
        tmp___7 = read(oldfd, (void *)(buf), sizeof(buf));
#line 1397
        cc = (int )tmp___7;
        }
#line 1397
        if (cc > 0) {
#line 1397
          if (! (! ControlCpressed)) {
#line 1397
            goto while_break;
          }
        } else {
#line 1397
          goto while_break;
        }
        {
#line 1398
        tmp___6 = fwrite((void const   */* __restrict  */)(buf), (size_t )cc, (size_t )1,
                         (FILE */* __restrict  */)f);
        }
#line 1398
        if (tmp___6 <= 0UL) {
          {
#line 1399
          CursesErrorMsg((char *)"Problems Writing");
          }
        }
        {
#line 1400
        twirl();
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1402
      if (ControlCpressed) {
        {
#line 1403
        CursesErrorMsg((char *)"Save Interrupted by user");
#line 1404
        ControlCpressed = 0;
        }
      }
#line 1408
      if (Openpipe) {
        {
#line 1409
        pclose(f);
        }
      } else {
        {
#line 1411
        fclose(f);
        }
      }
      {
#line 1413
      close(oldfd);
      }
#line 1414
      return;
    } else {
#line 1383
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 1419
    GS2FileSucceeded = GStoFile(gs, f, view, & twirl);
    }
#line 1421
    if (Openpipe) {
      {
#line 1422
      pclose(f);
      }
    } else {
      {
#line 1424
      fclose(f);
      }
    }
#line 1426
    if (! GS2FileSucceeded) {
      {
#line 1427
      unlink((char const   *)saveto);
      }
    }
  }
#line 1429
  return;
}
}
#line 1442 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
void Save_list(GopherDirObj *gd ) 
{ 
  char Title[256] ;
  char Userfilename[128] ;
  char *cp ;
  char *saveto ;
  int numitems ;
  int j ;
  char buf[128] ;
  boolean Openpipe ;
  FILE *f ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  struct passwd *pass ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char tmpstr[256] ;
  char tempstr[128] ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 1449
  Openpipe = 0;
#line 1452
  Userfilename[0] = (char )'\000';
#line 1454
  if ((gd->Title)->len < 0) {
#line 1454
    tmp = (char *)((void *)0);
  } else {
#line 1454
    tmp = (gd->Title)->data;
  }
  {
#line 1454
  sprintf((char */* __restrict  */)(Title), (char const   */* __restrict  */)"%s",
          tmp);
#line 1455
  tmp___0 = CURGetOneOption(CursesScreen, Title, (char *)"Save list of items in file:",
                            Userfilename);
  }
#line 1455
  if (tmp___0 < 0) {
#line 1458
    return;
  }
#line 1459
  saveto = Userfilename;
#line 1460
  if ((int )*saveto == 0) {
#line 1461
    return;
  }
#line 1464
  if ((int )*saveto == 124) {
#line 1466
    Openpipe = 1;
#line 1467
    saveto ++;
  }
#line 1470
  if ((int )*saveto == 126) {
#line 1472
    if ((int )*(saveto + 1) == 47) {
      {
#line 1472
      cp = getenv("HOME");
      }
#line 1472
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
        {
#line 1474
        strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)cp);
#line 1475
        tmp___1 = strlen((char const   *)cp);
#line 1475
        buf[tmp___1] = (char )'/';
#line 1476
        tmp___2 = strlen((char const   *)cp);
#line 1476
        strcpy((char */* __restrict  */)((buf + tmp___2) + 1), (char const   */* __restrict  */)(saveto + 2));
#line 1477
        strcpy((char */* __restrict  */)saveto, (char const   */* __restrict  */)(buf));
        }
      } else {
#line 1472
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1482
      cp = strchr((char const   *)saveto, '/');
#line 1483
      *cp = (char )'\000';
#line 1484
      pass = getpwnam((char const   *)(saveto + 1));
      }
#line 1485
      if ((unsigned long )pass != (unsigned long )((void *)0)) {
        {
#line 1487
        strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)pass->pw_dir);
#line 1488
        tmp___3 = strlen((char const   *)pass->pw_dir);
#line 1488
        buf[tmp___3] = (char )'/';
#line 1489
        tmp___4 = strlen((char const   *)pass->pw_dir);
#line 1489
        strcpy((char */* __restrict  */)((buf + tmp___4) + 1), (char const   */* __restrict  */)(cp + 1));
#line 1490
        strcpy((char */* __restrict  */)saveto, (char const   */* __restrict  */)(buf));
        }
      } else {
        {
#line 1494
        sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"No such user \'%s\'",
                saveto + 1);
#line 1495
        CursesErrorMsg(tmpstr);
        }
#line 1496
        return;
      }
    }
  }
#line 1505
  if (Openpipe) {
    {
#line 1506
    f = popen((char const   *)saveto, "w+");
    }
  } else {
    {
#line 1508
    f = fopen((char const   */* __restrict  */)saveto, (char const   */* __restrict  */)"w+");
    }
  }
#line 1511
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 1514
    sprintf((char */* __restrict  */)(tempstr), (char const   */* __restrict  */)"Couldn\'t create \'%s\'",
            saveto);
#line 1516
    CursesErrorMsg(tempstr);
    }
#line 1517
    return;
  }
#line 1522
  if ((gd->Title)->len < 0) {
#line 1522
    tmp___5 = (char *)((void *)0);
  } else {
#line 1522
    tmp___5 = (gd->Title)->data;
  }
  {
#line 1522
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"  %s\n\n",
          tmp___5);
  }
#line 1523
  if ((unsigned long )Searchstring != (unsigned long )((void *)0)) {
    {
#line 1524
    cp = strstr((char const   *)(buf), (char const   *)Searchstring);
    }
#line 1524
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 1525
      *(cp - 1) = (char )'\n';
    }
  }
  {
#line 1526
  tmp___6 = strlen((char const   *)(buf));
#line 1526
  tmp___7 = fwrite((void const   */* __restrict  */)(buf), tmp___6, (size_t )1, (FILE */* __restrict  */)f);
  }
#line 1526
  if (tmp___7 <= 0UL) {
    {
#line 1527
    CursesErrorMsg((char *)"Problems Writing");
    }
  }
  {
#line 1528
  twirl();
#line 1531
  numitems = (gd->Gophers)->Top;
#line 1532
  j = 0;
  }
  {
#line 1532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1532
    if (! (j < numitems)) {
#line 1532
      goto while_break;
    }
#line 1533
    if ((((GopherObj *)*((gd->Gophers)->objects + j))->Title)->len < 0) {
#line 1533
      tmp___8 = (char *)((void *)0);
    } else {
#line 1533
      tmp___8 = (((GopherObj *)*((gd->Gophers)->objects + j))->Title)->data;
    }
    {
#line 1533
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s\n",
            tmp___8);
#line 1534
    tmp___9 = strlen((char const   *)(buf));
#line 1534
    tmp___10 = fwrite((void const   */* __restrict  */)(buf), tmp___9, (size_t )1,
                      (FILE */* __restrict  */)f);
    }
#line 1534
    if (tmp___10 <= 0UL) {
      {
#line 1535
      CursesErrorMsg((char *)"Problems Writing");
      }
    }
    {
#line 1537
    twirl();
#line 1532
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1540
  if (Openpipe) {
    {
#line 1541
    pclose(f);
    }
  } else {
    {
#line 1543
    fclose(f);
    }
  }
#line 1544
  return;
}
}
#line 1554 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
void GSdisplay(GopherObj *gs ) 
{ 
  char command[200] ;
  char *file ;
  char *tmp ;
  char *view ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1558
  if ((gs->Localfile)->len < 0) {
#line 1558
    tmp = (char *)((void *)0);
  } else {
#line 1558
    tmp = (gs->Localfile)->data;
  }
#line 1558
  file = tmp;
#line 1559
  if ((gs->Localview)->len < 0) {
#line 1559
    tmp___0 = (char *)((void *)0);
  } else {
#line 1559
    tmp___0 = (gs->Localview)->data;
  }
  {
#line 1559
  view = tmp___0;
#line 1572
  RCdisplayCommand(GlobalRC, view, file, command);
#line 1579
  tmp___1 = strlen((char const   *)(command));
  }
#line 1579
  if (tmp___1 == 0UL) {
#line 1580
    if (SecureMode) {
      {
#line 1581
      CursesErrorMsg((char *)"Sorry, no viewer for the file....");
      }
    } else
#line 1580
    if (NoShellMode) {
      {
#line 1581
      CursesErrorMsg((char *)"Sorry, no viewer for the file....");
      }
    } else {
      {
#line 1583
      Save_file(gs, (char *)((void *)0), view);
      }
    }
#line 1585
    return;
  }
  {
#line 1616
  tmp___5 = strncasecmp((char const   *)(command), "builtin-upload", (size_t )14);
  }
#line 1616
  if (tmp___5 == 0) {
    {
#line 1617
    BuiltinUploadfile();
    }
#line 1618
    return;
  } else {
    {
#line 1620
    tmp___4 = strncasecmp((char const   *)(command), "builtin-download", (size_t )14);
    }
#line 1620
    if (tmp___4 == 0) {
      {
#line 1621
      tmp___2 = getenv("HOME");
#line 1621
      BuiltinDownload(tmp___2);
      }
#line 1622
      return;
    } else {
      {
#line 1624
      tmp___3 = strncasecmp((char const   *)(command), "builtin", (size_t )7);
      }
#line 1624
      if (tmp___3 == 0) {
        {
#line 1625
        PagerBuiltin(CursesScreen, gs);
        }
#line 1626
        return;
      } else {
        {
#line 1629
        CURexit(CursesScreen);
#line 1630
        FIOsystem(command);
        }
#line 1631
        if ((int )gs->sFileType != 33) {
          {
#line 1632
          GSprompter(gs, view, command);
          }
        }
      }
    }
  }
#line 1636
  return;
}
}
#line 1643 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
void GSprompter(GopherObj *gs , char *view , char *command ) 
{ 
  int ch ;
  char *tmp ;
  char *tmp___0 ;
  boolean tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1676
  printf((char const   */* __restrict  */)"\nPress <RETURN> to continue");
  }
#line 1678
  if (! SecureMode) {
#line 1678
    if (! NoShellMode) {
      {
#line 1679
      printf((char const   */* __restrict  */)",\n   <m> to mail, <D> to download, <s> to save, or <p> to print:");
      }
    } else {
      {
#line 1682
      printf((char const   */* __restrict  */)", <m> to mail, <D> to download:");
      }
    }
  } else {
    {
#line 1682
    printf((char const   */* __restrict  */)", <m> to mail, <D> to download:");
    }
  }
  {
#line 1688
  fflush(stdin);
#line 1689
  fflush(stdout);
#line 1690
  noecho();
#line 1691
  cbreak();
#line 1693
  ch = 0;
  }
  {
#line 1694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1694
    if (! (ch == 0)) {
#line 1694
      goto while_break;
    }
    {
#line 1695
    ch = getchar();
    }
#line 1701
    if (SecureMode) {
#line 1701
      goto _L;
    } else
#line 1701
    if (NoShellMode) {
      _L: /* CIL Label */ 
      {
#line 1708
      if (ch == 81) {
#line 1708
        goto case_81;
      }
#line 1708
      if (ch == 113) {
#line 1708
        goto case_81;
      }
#line 1708
      if (ch == 32) {
#line 1708
        goto case_81;
      }
#line 1708
      if (ch == 343) {
#line 1708
        goto case_81;
      }
#line 1708
      if (ch == 13) {
#line 1708
        goto case_81;
      }
#line 1708
      if (ch == 10) {
#line 1708
        goto case_81;
      }
#line 1714
      if (ch == 109) {
#line 1714
        goto case_109;
      }
#line 1722
      if (ch == 68) {
#line 1722
        goto case_68;
      }
#line 1730
      goto switch_default;
      case_81: /* CIL Label */ 
      case_113: /* CIL Label */ 
      case_32: /* CIL Label */ 
      case_343: /* CIL Label */ 
      case_13: /* CIL Label */ 
      case_10: /* CIL Label */ 
#line 1712
      goto switch_break;
      case_109: /* CIL Label */ 
      {
#line 1718
      CURenter(CursesScreen);
#line 1719
      GSmail(gs);
      }
#line 1720
      goto switch_break;
      case_68: /* CIL Label */ 
      {
#line 1726
      CURenter(CursesScreen);
#line 1727
      Download_file(gs);
      }
#line 1728
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1731
      if ((CursesScreen->AudibleBell)->len < 0) {
#line 1731
        tmp = (char *)((void *)0);
      } else {
#line 1731
        tmp = (CursesScreen->AudibleBell)->data;
      }
      {
#line 1731
      puts((char const   *)tmp);
#line 1732
      fflush(stdout);
#line 1733
      ch = 0;
      }
#line 1734
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1744
      if (ch == 81) {
#line 1744
        goto case_81___0;
      }
#line 1744
      if (ch == 113) {
#line 1744
        goto case_81___0;
      }
#line 1744
      if (ch == 32) {
#line 1744
        goto case_81___0;
      }
#line 1744
      if (ch == 13) {
#line 1744
        goto case_81___0;
      }
#line 1744
      if (ch == 10) {
#line 1744
        goto case_81___0;
      }
#line 1749
      if (ch == 115) {
#line 1749
        goto case_115;
      }
#line 1761
      if (ch == 112) {
#line 1761
        goto case_112;
      }
#line 1772
      if (ch == 109) {
#line 1772
        goto case_109___0;
      }
#line 1780
      if (ch == 68) {
#line 1780
        goto case_68___0;
      }
#line 1788
      goto switch_default___0;
      case_81___0: /* CIL Label */ 
      case_113___0: /* CIL Label */ 
      case_32___0: /* CIL Label */ 
      case_13___0: /* CIL Label */ 
      case_10___0: /* CIL Label */ 
#line 1748
      goto switch_break___0;
      case_115: /* CIL Label */ 
      {
#line 1753
      CURenter(CursesScreen);
#line 1754
      Draw_Status((char *)"Saving File...");
#line 1755
      wrefresh(stdscr);
      }
#line 1757
      if (! SecureMode) {
#line 1757
        if (! NoShellMode) {
          {
#line 1758
          Save_file(gs, (char *)((void *)0), view);
          }
        }
      }
#line 1759
      goto switch_break___0;
      case_112: /* CIL Label */ 
#line 1765
      if ((gs->Localfile)->len < 0) {
#line 1765
        tmp___0 = (char *)((void *)0);
      } else {
#line 1765
        tmp___0 = (gs->Localfile)->data;
      }
      {
#line 1765
      tmp___1 = RCprintCommand(GlobalRC, view, tmp___0, command);
      }
#line 1765
      if (! tmp___1) {
        {
#line 1766
        CursesErrorMsg((char *)"Sorry, cannot print this document");
        }
#line 1767
        return;
      }
      {
#line 1769
      FIOsystem(command);
      }
#line 1770
      goto switch_break___0;
      case_109___0: /* CIL Label */ 
      {
#line 1776
      CURenter(CursesScreen);
#line 1777
      GSmail(gs);
      }
#line 1778
      goto switch_break___0;
      case_68___0: /* CIL Label */ 
      {
#line 1784
      CURenter(CursesScreen);
#line 1785
      Download_file(gs);
      }
#line 1786
      goto switch_break___0;
      switch_default___0: /* CIL Label */ ;
#line 1790
      if ((CursesScreen->AudibleBell)->len < 0) {
#line 1790
        tmp___2 = (char *)((void *)0);
      } else {
#line 1790
        tmp___2 = (CursesScreen->AudibleBell)->data;
      }
      {
#line 1790
      puts((char const   *)tmp___2);
#line 1791
      fflush(stdout);
#line 1792
      ch = 0;
      }
#line 1793
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1798
  if ((CursesScreen->Clearscreen)->len < 0) {
#line 1798
    tmp___3 = (char *)((void *)0);
  } else {
#line 1798
    tmp___3 = (CursesScreen->Clearscreen)->data;
  }
  {
#line 1798
  tputs((char const   *)tmp___3, 1, & outchar);
#line 1799
  fflush(stdout);
  }
#line 1800
  return;
}
}
#line 1808 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
void CursesMsg(char *Message , char *title ) 
{ 
  char *mess[2] ;

  {
  {
#line 1813
  mess[0] = Message;
#line 1814
  mess[1] = (char *)((void *)0);
#line 1817
  CURBeep(CursesScreen);
#line 1819
  CURDialog(CursesScreen, title, mess);
  }
#line 1821
  return;
}
}
#line 1830 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
void CursesErrorMsg(char *Message ) 
{ 


  {
  {
#line 1833
  CursesMsg(Message, (char *)"Gopher Error");
  }
#line 1834
  return;
}
}
#line 1846 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/ourutils.c"
int logrequest(char *msg , GopherObj *gs ) 
{ 


  {
#line 1864
  return (0);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/Sockets.c"
static char DNSname___0[64]  ;
#line 8 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/html2.h"
void do_html(GopherObj *ZeGopher ) ;
#line 101 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/html2.c"
void do_html(GopherObj *ZeGopher ) 
{ 
  char command[256] ;
  char HTMLcmd[128] ;
  char *Dialogmess[7] ;
  size_t tmp ;
  size_t tmp___0 ;
  boolean tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 107
  tmp___1 = RCdisplayCommand(GlobalRC, (char *)"text/html", (char *)"", HTMLcmd);
  }
#line 107
  if (tmp___1) {
    {
#line 107
    tmp___2 = strncasecmp((char const   *)(HTMLcmd), "- none -", (size_t )8);
    }
#line 107
    if (tmp___2) {
#line 107
      if ((unsigned long )(HTMLcmd) == (unsigned long )((void *)0)) {
        {
#line 110
        CursesErrorMsg((char *)"Sorry, this client does not support HTML");
        }
#line 111
        return;
      } else
#line 107
      if ((int )HTMLcmd[0] == 0) {
        {
#line 110
        CursesErrorMsg((char *)"Sorry, this client does not support HTML");
        }
#line 111
        return;
      } else {
        {
#line 114
        tmp___0 = strlen((char const   *)(HTMLcmd));
        }
#line 114
        if ((int )HTMLcmd[tmp___0 - 1UL] == 32) {
          {
#line 115
          tmp = strlen((char const   *)(HTMLcmd));
#line 115
          HTMLcmd[tmp - 1UL] = (char )'\000';
          }
        }
      }
    } else {
      {
#line 110
      CursesErrorMsg((char *)"Sorry, this client does not support HTML");
      }
#line 111
      return;
    }
  } else {
    {
#line 110
    CursesErrorMsg((char *)"Sorry, this client does not support HTML");
    }
#line 111
    return;
  }
  {
#line 117
  tmp___3 = GSgetURLhtml(ZeGopher, (char *)"");
#line 117
  sprintf((char */* __restrict  */)(command), (char const   */* __restrict  */)"%s \"%s\"",
          HTMLcmd, tmp___3);
#line 119
  wclear(stdscr);
#line 123
  Dialogmess[0] = (char *)"Warning!!!!!, you are about to leave the Internet Gopher";
#line 124
  Dialogmess[1] = (char *)"Client and connect to an HTML Browser.  Use the Browser";
#line 125
  Dialogmess[2] = (char *)"Help if you are not familiar with its commands.";
#line 126
  Dialogmess[3] = (char *)"";
#line 127
  Dialogmess[4] = (char *)"Upon quitting from the Browser, you will be returned to";
#line 128
  Dialogmess[5] = (char *)"the Internet Gopher Client.";
#line 129
  Dialogmess[6] = (char *)((void *)0);
  }
#line 131
  if ((ZeGopher->Title)->len < 0) {
#line 131
    tmp___4 = (char *)((void *)0);
  } else {
#line 131
    tmp___4 = (ZeGopher->Title)->data;
  }
  {
#line 131
  tmp___5 = CURDialog(CursesScreen, tmp___4, Dialogmess);
  }
#line 131
  if (tmp___5 < 0) {
#line 132
    return;
  }
  {
#line 134
  CURexit(CursesScreen);
#line 135
  FIOsystem(command);
#line 136
  CURenter(CursesScreen);
  }
#line 138
  return;
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/upload.c"
static char *DLnames___0[7]  = {      (char *)"Zmodem",      (char *)"Ymodem",      (char *)"Xmodem-CRC",      (char *)"Kermit", 
        (char *)"Text",      (char *)"WRQ - Reflection",      (char *)((void *)0)};
#line 23 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/upload.c"
static char *textorbin[3]  = {      (char *)"Binary",      (char *)"ASCII",      (char *)((void *)0)};
#line 30 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/upload.c"
static char *ULtextcmds[7]  = {      (char *)"rz ",      (char *)"rb -a ",      (char *)"rx -ac ",      (char *)"kermit -q -r ", 
        (char *)"false ",      (char *)"unixlnk2",      (char *)((void *)0)};
#line 40 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/upload.c"
static char *ULbincmds[7]  = {      (char *)"rz -b ",      (char *)"rb ",      (char *)"rx ",      (char *)"kermit -q -r -i", 
        (char *)"false ",      (char *)"unxlink2",      (char *)((void *)0)};
#line 53 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/upload.c"
void BuiltinUploadfile(void) 
{ 
  Requestitem *ulmenu[6] ;
  char filename[80] ;
  boolean istext ;
  int ulprotocol ;
  char cmdline[512] ;
  boolean iszmodem ;
  int start ;
  int end ;
  struct stat buf ;
  time_t tmp ;
  FileIO *fio ;
  char inputline___0[256] ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  time_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 65
  filename[0] = (char )'\000';
#line 68
  ulmenu[0] = REQitemnew();
#line 69
  (ulmenu[0])->prompt = (char *)"Supply file information for Upload";
#line 70
  (ulmenu[0])->thing = (Curreqtype )1;
#line 72
  ulmenu[1] = REQitemnew();
#line 73
  (ulmenu[1])->prompt = (char *)"";
#line 74
  (ulmenu[1])->thing = (Curreqtype )1;
#line 76
  ulmenu[2] = REQitemnew();
#line 77
  (ulmenu[2])->thing = (Curreqtype )4;
#line 78
  (ulmenu[2])->prompt = (char *)"Download Protocol";
#line 79
  (ulmenu[2])->choices = DLnames___0;
#line 80
  (ulmenu[2])->chooseitem = 0;
#line 82
  ulmenu[3] = REQitemnew();
#line 83
  (ulmenu[3])->thing = (Curreqtype )4;
#line 84
  (ulmenu[3])->prompt = (char *)"Type of File";
#line 85
  (ulmenu[3])->choices = textorbin;
#line 86
  (ulmenu[3])->chooseitem = 0;
#line 88
  ulmenu[4] = REQitemnew();
#line 89
  (ulmenu[4])->prompt = (char *)"Save file as";
#line 90
  (ulmenu[4])->thing = (Curreqtype )2;
#line 91
  (ulmenu[4])->stowage = filename;
#line 93
  ulmenu[5] = (Requestitem *)((void *)0);
#line 95
  tmp___5 = CURrequester(CursesScreen, (char *)"Upload File", ulmenu);
  }
#line 95
  if (! tmp___5) {
#line 96
    ulprotocol = (ulmenu[2])->chooseitem;
#line 97
    istext = (ulmenu[3])->chooseitem;
#line 98
    iszmodem = ulprotocol == 0;
#line 100
    if (! iszmodem) {
#line 100
      if ((int )filename[0] == 0) {
        {
#line 101
        CursesErrorMsg((char *)"You must supply a filename");
        }
#line 102
        return;
      }
    }
#line 105
    if (istext) {
      {
#line 106
      strcpy((char */* __restrict  */)(cmdline), (char const   */* __restrict  */)ULtextcmds[ulprotocol]);
      }
    } else {
      {
#line 108
      strcpy((char */* __restrict  */)(cmdline), (char const   */* __restrict  */)ULbincmds[ulprotocol]);
      }
    }
#line 111
    if (! iszmodem) {
      {
#line 112
      strcat((char */* __restrict  */)(cmdline), (char const   */* __restrict  */)(filename));
      }
    }
    {
#line 115
    CURexit(CursesScreen);
#line 116
    tmp = time((time_t *)((void *)0));
#line 116
    start = (int )tmp;
    }
#line 118
    if (ulprotocol == 4) {
      {
#line 122
      printf((char const   */* __restrict  */)"Send your text now, enter CTRL-D or a single period to complete upload\n");
#line 123
      fio = FIOopenUFS(filename, 65, 384);
      }
#line 124
      if ((unsigned long )fio == (unsigned long )((void *)0)) {
        {
#line 125
        printf((char const   */* __restrict  */)"Couldn\'t open the file %s for writing\n",
               filename);
#line 126
        CURenter(CursesScreen);
        }
#line 127
        return;
      }
      {
#line 129
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 129
        tmp___1 = fgets((char */* __restrict  */)(inputline___0), (int )sizeof(inputline___0),
                        (FILE */* __restrict  */)stdin);
        }
#line 129
        if (! tmp___1) {
#line 129
          goto while_break;
        }
        {
#line 130
        ZapCRLF(inputline___0);
#line 131
        tmp___0 = strcmp((char const   *)(inputline___0), ".");
        }
#line 131
        if (tmp___0 == 0) {
#line 132
          goto while_break;
        }
        {
#line 133
        FIOwritestring(fio, inputline___0);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 135
      FIOclose(fio);
      }
    } else {
      {
#line 137
      printf((char const   */* __restrict  */)"Executing the following command\n%s\n",
             cmdline);
#line 139
      tmp___2 = FIOsystem(cmdline);
      }
#line 139
      if (tmp___2) {
        {
#line 140
        printf((char const   */* __restrict  */)"Upload failed, sorry...\n");
        }
      }
    }
    {
#line 143
    tmp___3 = time((time_t *)((void *)0));
#line 143
    end = (int )tmp___3;
#line 145
    tmp___4 = stat((char const   */* __restrict  */)(filename), (struct stat */* __restrict  */)(& buf));
    }
#line 145
    if (tmp___4 < 0) {
      {
#line 146
      printf((char const   */* __restrict  */)"Upload failed, try again...\n");
      }
    } else {
      {
#line 148
      printf((char const   */* __restrict  */)"Upload complete. %d total bytes, %d bytes/sec\n",
             (int )buf.st_size, (int )buf.st_size / (end - start));
      }
    }
    {
#line 151
    printf((char const   */* __restrict  */)"Press <RETURN> to continue");
#line 153
    fflush(stdout);
#line 154
    getchar();
#line 155
    CURenter(CursesScreen);
    }
  }
#line 157
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static char **FIOgetargv___0(char *cmd ) ;
#line 190 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static FileIO *FIOusedfios___0[64]  ;
#line 191 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static int FIOnumusedfios___0  =    -1;
#line 197 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static FileIO *FIOpopUsedfio___0(void) 
{ 


  {
#line 199
  if (FIOnumusedfios___0 > 0) {
#line 200
    FIOnumusedfios___0 --;
#line 200
    return (FIOusedfios___0[FIOnumusedfios___0]);
  } else {
#line 202
    return ((FileIO *)((void *)0));
  }
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static boolean FIOpushUsedfio___0(FileIO *oldfio ) 
{ 
  int tmp ;

  {
#line 211
  if (FIOnumusedfios___0 < 64) {
#line 212
    tmp = FIOnumusedfios___0;
#line 212
    FIOnumusedfios___0 ++;
#line 212
    FIOusedfios___0[tmp] = oldfio;
#line 213
    return (0);
  } else {
#line 215
    return (-1);
  }
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static FileIO *FIOnew___0(void) 
{ 
  FileIO *temp ;
  int i ;
  void *tmp ;

  {
#line 223
  if (FIOnumusedfios___0 == -1) {
#line 226
    i = 0;
    {
#line 226
    while (1) {
      while_continue: /* CIL Label */ ;
#line 226
      if (! (i < 64)) {
#line 226
        goto while_break;
      }
#line 227
      FIOusedfios___0[i] = (FileIO *)((void *)0);
#line 226
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 229
    FIOnumusedfios___0 = 0;
  }
  {
#line 232
  temp = FIOpopUsedfio___0();
  }
#line 233
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 234
    tmp = malloc(sizeof(FileIO ));
#line 234
    temp = (FileIO *)tmp;
#line 235
    temp->filename = STRnew();
    }
  } else {
    {
#line 237
    STRinit(temp->filename);
    }
  }
  {
#line 241
  temp->issocket = -1;
#line 242
  temp->pid = -1;
#line 243
  temp->fd = -1;
#line 244
  temp->buf = (char *)((void *)0);
#line 246
  temp->bufindex = -1;
#line 247
  temp->bufdatasize = -1;
#line 248
  temp->filename = STRnew();
  }
#line 251
  return (temp);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static int FIOreadbuf_mmap___0(FileIO *fio , char *newbuf , int newbuflen ) 
{ 
  struct stat buf ;
  char *bytes ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 511
  if ((fio->filename)->len < 0) {
#line 511
    tmp___1 = (char *)((void *)0);
  } else {
#line 511
    tmp___1 = (fio->filename)->data;
  }
#line 511
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 514
    if ((unsigned long )fio->buf == (unsigned long )((void *)0)) {
      {
#line 515
      tmp = fstat(fio->fd, & buf);
      }
#line 515
      if (tmp) {
        {
#line 516
        close(fio->fd);
        }
#line 517
        return (-1);
      }
#line 520
      if (buf.st_size == 0L) {
#line 521
        return (0);
      }
      {
#line 523
      fio->bufdatasize = (int )buf.st_size;
#line 524
      fio->bufindex = 0;
#line 526
      tmp___0 = mmap((void *)0, (size_t )buf.st_size, 1, 1, fio->fd, (__off_t )0);
#line 526
      bytes = (char *)tmp___0;
#line 530
      madvise((void *)bytes, (size_t )buf.st_size, 2);
      }
#line 533
      if ((unsigned long )bytes == (unsigned long )((caddr_t )-1)) {
#line 534
        return (-1);
      }
#line 535
      fio->buf = bytes;
    }
#line 538
    if (fio->bufindex == -1) {
#line 539
      return (0);
    }
#line 542
    if (fio->bufindex >= fio->bufdatasize) {
#line 543
      return (0);
    }
#line 545
    if (fio->bufindex + newbuflen > fio->bufdatasize) {
#line 546
      newbuflen = fio->bufdatasize - fio->bufindex;
    }
    {
#line 548
    memcpy((void */* __restrict  */)newbuf, (void const   */* __restrict  */)(fio->buf + fio->bufindex),
           (size_t )newbuflen);
#line 549
    fio->bufindex += newbuflen;
    }
#line 551
    return (newbuflen);
  }
#line 554
  return (-1);
}
}
#line 768 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static int FIOexecv___0(char *prog , char **args ) 
{ 
  FileIO *fio ;
  int result ;

  {
  {
#line 792
  fio = FIOopenProcess(prog, args, (char *)((void *)0));
#line 793
  result = FIOclose(fio);
  }
#line 796
  return (result);
}
}
#line 810 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static char *argv___0[256]  ;
#line 804 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/fileio.c"
static char **FIOgetargv___0(char *cmd ) 
{ 
  int inquote ;
  int insquote ;
  int i ;
  int argc ;
  char buf[256] ;
  char *cp ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 807
  inquote = 0;
#line 808
  insquote = 0;
#line 811
  argc = 0;
#line 813
  cp = buf;
#line 815
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 816
    return ((char **)((void *)0));
  } else {
    {
#line 815
    tmp = strlen((char const   *)cmd);
    }
#line 815
    if (tmp >= 245UL) {
#line 816
      return ((char **)((void *)0));
    }
  }
#line 818
  i = 0;
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! ((int )*(cmd + i) != 0)) {
#line 818
      goto while_break;
    }
    {
#line 822
    if ((int )*(cmd + i) == 9) {
#line 822
      goto case_9;
    }
#line 822
    if ((int )*(cmd + i) == 32) {
#line 822
      goto case_9;
    }
#line 838
    if ((int )*(cmd + i) == 34) {
#line 838
      goto case_34;
    }
#line 843
    if ((int )*(cmd + i) == 39) {
#line 843
      goto case_39;
    }
#line 848
    if ((int )*(cmd + i) == 92) {
#line 848
      goto case_92;
    }
#line 858
    goto switch_default;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 824
    if (insquote) {
#line 825
      *cp = *(cmd + i);
#line 825
      cp ++;
#line 826
      goto switch_break;
    } else
#line 824
    if (inquote) {
#line 825
      *cp = *(cmd + i);
#line 825
      cp ++;
#line 826
      goto switch_break;
    } else {
      {
#line 828
      *cp = (char )'\000';
#line 829
      tmp___0 = argc;
#line 829
      argc ++;
#line 829
      argv___0[tmp___0] = strdup((char const   *)(buf));
#line 830
      cp = buf;
      }
      {
#line 833
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 833
        if (! ((int )*(cmd + (i + 1)) == 32)) {
#line 833
          if (! ((int )*(cmd + (i + 1)) == 9)) {
#line 833
            goto while_break___0;
          }
        }
#line 834
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 836
    goto switch_break;
    case_34: /* CIL Label */ 
#line 839
    if (! insquote) {
#line 840
      inquote = 1 - inquote;
    }
#line 841
    goto switch_break;
    case_39: /* CIL Label */ 
#line 844
    if (! inquote) {
#line 845
      insquote = 1 - insquote;
    }
#line 846
    goto switch_break;
    case_92: /* CIL Label */ 
#line 850
    if (insquote) {
#line 851
      *cp = *(cmd + i);
#line 851
      cp ++;
    } else
#line 850
    if (inquote) {
#line 851
      *cp = *(cmd + i);
#line 851
      cp ++;
    } else {
#line 853
      *cp = *(cmd + (i + 1));
#line 853
      cp ++;
#line 853
      i ++;
    }
#line 856
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 859
    *cp = *(cmd + i);
#line 859
    cp ++;
#line 860
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 818
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 863
  if ((unsigned long )(buf) != (unsigned long )cp) {
    {
#line 864
    *cp = (char )'\000';
#line 865
    tmp___1 = argc;
#line 865
    argc ++;
#line 865
    argv___0[tmp___1] = strdup((char const   *)(buf));
    }
  }
#line 867
  argv___0[argc] = (char *)((void *)0);
#line 869
  return (argv___0);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
RCobj *GlobalRC  ;
#line 136 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
boolean ChangedDefs  =    0;
#line 138 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
char *Searchstring  =    (char *)((void *)0);
#line 139 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
int iLevel  =    0;
#line 140 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
BOOLEAN SecureMode  =    0;
#line 141 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
BOOLEAN NoShellMode  =    0;
#line 142 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
BOOLEAN RemoteUser  =    0;
#line 144 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
GopherDirObj *CurrentDir  =    (GopherDirObj *)((void *)0);
#line 145 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
GopherDirObj *OldDirs[30]  ;
#line 147 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
GopherDirObj *BookmarkDir  =    (GopherDirObj *)((void *)0);
#line 149 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
char USERCAP[80]  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
int SOUNDCHILD  =    0;
#line 151 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
CursesObj *CursesScreen  ;
#line 153 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
char *Gopenfile  =    (char *)((void *)0);
#line 147 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static FileIO *Gfio___0  =    (FileIO *)((void *)0);
#line 148 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static int Oldsockfd___0  =    -1;
#line 238 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static void CheckGfio___0(int fd ) 
{ 


  {
#line 241
  if ((unsigned long )Gfio___0 == (unsigned long )((void *)0)) {
#line 241
    goto _L;
  } else
#line 241
  if (Oldsockfd___0 != fd) {
    _L: /* CIL Label */ 
#line 242
    Oldsockfd___0 = fd;
#line 243
    if ((unsigned long )Gfio___0 != (unsigned long )((void *)0)) {
      {
#line 244
      FIOdestroy(Gfio___0);
      }
    }
    {
#line 245
    Gfio___0 = FIOopenfd(fd, 1);
    }
  }
#line 247
  return;
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static boolean *acceptable___0  ;
#line 472 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static boolean acceptable_inited___0  =    0;
#line 474 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static void init_acceptable___0(void) 
{ 
  unsigned int i ;
  char *good ;
  void *tmp ;

  {
  {
#line 477
  good = (char *)"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";
#line 480
  tmp = malloc(sizeof(boolean ) * 256UL);
#line 480
  acceptable___0 = (boolean *)tmp;
#line 482
  i = 0U;
  }
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 482
    if (! (i < 256U)) {
#line 482
      goto while_break;
    }
#line 483
    *(acceptable___0 + i) = 0;
#line 482
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 484
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 484
    if (! *good) {
#line 484
      goto while_break___0;
    }
#line 485
    *(acceptable___0 + (unsigned int )*good) = 1;
#line 484
    good ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 487
  acceptable_inited___0 = 1;
#line 488
  return;
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static char hex___0[17]  = 
#line 490
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 492 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/util.c"
static char from_hex___0(char c ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 495
  if ((int )c >= 48) {
#line 495
    if ((int )c <= 57) {
#line 495
      tmp___1 = (int )c - 48;
    } else {
#line 495
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 495
    if ((int )c >= 65) {
#line 495
      if ((int )c <= 70) {
#line 495
        tmp___0 = ((int )c - 65) + 10;
      } else {
#line 495
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 495
      if ((int )c >= 97) {
#line 495
        if ((int )c <= 102) {
#line 495
          tmp = ((int )c - 97) + 10;
        } else {
#line 495
          tmp = 0;
        }
      } else {
#line 495
        tmp = 0;
      }
#line 495
      tmp___0 = tmp;
    }
#line 495
    tmp___1 = tmp___0;
  }
#line 495
  return ((char )tmp___1);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/subprocs.c"
void sig_child(int sig ) 
{ 
  int pid ;
  Portawait status ;

  {
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    pid = waitpid(-1, & status, 3);
    }
#line 80
    if (! (pid > 0)) {
#line 80
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/url.c"
static boolean URLparse___0(Url *url ) 
{ 
  char *cp ;
  char *cp2 ;
  char *cp3 ;
  char *urlcp ;
  UrlServiceType serviceType ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *pass ;

  {
  {
#line 269
  serviceType = URLgetService(url);
  }
#line 271
  if ((unsigned int )serviceType == 7U) {
#line 272
    return (0);
  }
#line 274
  if ((url->url)->len < 0) {
#line 274
    tmp = (char *)((void *)0);
  } else {
#line 274
    tmp = (url->url)->data;
  }
#line 274
  urlcp = tmp;
#line 276
  if ((unsigned long )urlcp == (unsigned long )((void *)0)) {
#line 277
    return (0);
  }
  {
#line 279
  urlcp = strdup((char const   *)urlcp);
#line 281
  cp = strstr((char const   *)urlcp, "://");
  }
#line 283
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 284
    return (0);
  }
  {
#line 286
  cp += 3;
#line 288
  cp3 = strchr((char const   *)cp, '/');
  }
#line 290
  if ((unsigned long )cp3 == (unsigned long )((void *)0)) {
    {
#line 291
    tmp___0 = strlen((char const   *)cp);
#line 291
    cp3 = (cp + tmp___0) + 1;
#line 292
    STRset(url->Path, (char *)"/");
    }
  } else {
    {
#line 294
    Fromhexstr(cp3, cp3);
#line 295
    STRset(url->Path, cp3);
#line 296
    tmp___1 = cp3;
#line 296
    cp3 ++;
#line 296
    *tmp___1 = (char )'\000';
    }
  }
#line 300
  if ((unsigned int )serviceType == 0U) {
#line 301
    if ((unsigned long )cp3 != (unsigned long )((void *)0)) {
      {
#line 301
      tmp___4 = strlen((char const   *)cp3);
      }
#line 301
      if ((int )tmp___4 > 1) {
        {
#line 302
        tmp___2 = cp3;
#line 302
        cp3 ++;
#line 302
        url->Gtype = *tmp___2;
#line 303
        tmp___3 = cp3;
#line 303
        cp3 ++;
#line 303
        STRset(url->Path, tmp___3);
        }
      } else {
#line 305
        url->Gtype = (char )'1';
      }
    } else {
#line 305
      url->Gtype = (char )'1';
    }
  }
  {
#line 314
  cp2 = strchr((char const   *)cp, '@');
  }
#line 315
  if ((unsigned long )cp2 != (unsigned long )((void *)0)) {
#line 315
    if ((unsigned long )cp2 < (unsigned long )cp3) {
      {
#line 319
      *cp2 = (char )'\000';
#line 320
      cp2 ++;
#line 322
      pass = strchr((char const   *)cp, ':');
      }
#line 323
      if ((unsigned long )pass != (unsigned long )((void *)0)) {
#line 323
        if ((unsigned long )pass < (unsigned long )cp3) {
          {
#line 324
          *pass = (char )'\000';
#line 325
          pass ++;
#line 326
          Fromhexstr(pass, pass);
#line 328
          STRset(url->Pass, pass);
          }
        }
      }
      {
#line 331
      STRset(url->User, cp);
#line 333
      cp = cp2;
      }
    }
  }
  {
#line 340
  cp2 = strchr((char const   *)cp, ':');
  }
#line 342
  if ((unsigned long )cp2 != (unsigned long )((void *)0)) {
#line 342
    if ((unsigned long )cp2 < (unsigned long )cp3) {
      {
#line 343
      *cp2 = (char )'\000';
#line 344
      cp2 ++;
#line 345
      url->Port = atoi((char const   *)cp2);
#line 346
      STRset(url->Host, cp);
      }
    } else {
#line 342
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 349
    if ((unsigned int )serviceType == 1U) {
#line 349
      goto case_1;
    }
#line 353
    if ((unsigned int )serviceType == 4U) {
#line 353
      goto case_4;
    }
#line 353
    if ((unsigned int )serviceType == 3U) {
#line 353
      goto case_4;
    }
#line 356
    if ((unsigned int )serviceType == 0U) {
#line 356
      goto case_0;
    }
#line 359
    if ((unsigned int )serviceType == 5U) {
#line 359
      goto case_5;
    }
#line 364
    if ((unsigned int )serviceType == 7U) {
#line 364
      goto case_7;
    }
#line 364
    if ((unsigned int )serviceType == 6U) {
#line 364
      goto case_7;
    }
#line 364
    if ((unsigned int )serviceType == 2U) {
#line 364
      goto case_7;
    }
#line 348
    goto switch_break;
    case_1: /* CIL Label */ 
#line 350
    url->Port = 80;
#line 351
    goto switch_break;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 354
    url->Port = 23;
#line 355
    goto switch_break;
    case_0: /* CIL Label */ 
#line 357
    url->Port = 70;
#line 358
    goto switch_break;
    case_5: /* CIL Label */ 
#line 360
    url->Port = 119;
#line 361
    goto switch_break;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 365
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 367
    STRset(url->Host, cp);
    }
  }
#line 371
  return (1);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
static char *ANSILangs___0[22]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
  {      (char *)"Da_DK",      (char *)"Nl_BE",      (char *)"Nl_NL",      (char *)"En_GB", 
        (char *)"En_US",      (char *)"Fi_FI",      (char *)"Fr_BE",      (char *)"Fr_CA", 
        (char *)"Fr_CH",      (char *)"Fr_FR",      (char *)"De_CH",      (char *)"De_DE", 
        (char *)"El_GR",      (char *)"Is_IS",      (char *)"It_IT",      (char *)"Jp_JP", 
        (char *)"No_NO",      (char *)"Pt_PT",      (char *)"Es_ES",      (char *)"Sv_SE", 
        (char *)"Tr_TR",      (char *)((void *)0)};
#line 85 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/object/VIews.c"
static char *ANSILangEn___0[22]  = 
#line 85
  {      (char *)"Danish",      (char *)"Dutch (Belgium)",      (char *)"Dutch",      (char *)"English (Great Britain)", 
        (char *)"English (USA)",      (char *)"Finnish",      (char *)"Fran\347ais (Belgium)",      (char *)"Fran\347ais (Canada)", 
        (char *)"Fran\347ais (Suisse)",      (char *)"Fran\347ais",      (char *)"Deutsch (Suisse)",      (char *)"Deutsch", 
        (char *)"Greek",      (char *)"Icelandic",      (char *)"Italiano",      (char *)"Japanese", 
        (char *)"Norwegian",      (char *)"Portugues",      (char *)"Espa\361ol",      (char *)"Swedish", 
        (char *)"Turkish",      (char *)((void *)0)};
#line 749 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 590 "/usr/include/curses.h"
extern int clearok(WINDOW * , _Bool  ) ;
#line 826
extern int wprintw(WINDOW * , char const   *  , ...) ;
#line 1384
extern WINDOW *curscr ;
#line 8 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.h"
void PagerHelp(CursesObj *cur ) ;
#line 9
void PagerInitGlobals(void) ;
#line 10
void PagerTitles(CursesObj *cur , GopherObj *gs , int totalbytes ) ;
#line 11
int PagePosAlloc(void) ;
#line 12
int PagePosRealloc(void) ;
#line 13
void PagePosFree(void) ;
#line 14
void PagerPercent(int bytes , int totalbytes ) ;
#line 15
void PagerParseSearchstring(void) ;
#line 16
void PagerPrintLine(char *inputline___0 ) ;
#line 17
void PagerSeekPage(FILE *thefile , int gotopage , int *bytecount ) ;
#line 18
void PagerNextPage(CursesObj *cur , FILE *thefile , char *theline , int *bytecount ,
                   int totalbytes ) ;
#line 20
boolean PagerSearch(FILE *thefile , char *theline , int *bytecount , char *search ) ;
#line 114 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
static char *words[50]  ;
#line 115 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
static int wordcount  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
static char slashstring[128]  ;
#line 122 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
static int *positions  =    (int *)((void *)0);
#line 123 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
static int currentpage  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
static int pos_max  ;
#line 135 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
static char **helpmenu  =    (char **)((void *)0);
#line 132 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
void PagerHelp(CursesObj *cur ) 
{ 
  void *tmp ;

  {
#line 137
  if ((unsigned long )helpmenu == (unsigned long )((void *)0)) {
    {
#line 138
    tmp = malloc(sizeof(char *) * 9UL);
#line 138
    helpmenu = (char **)tmp;
#line 139
    *(helpmenu + 0) = (char *)"u, ^G, left : Return to menu";
#line 140
    *(helpmenu + 1) = (char *)"space, down : Move to the next page";
#line 141
    *(helpmenu + 2) = (char *)"b, up       : Move to the previous page";
#line 142
    *(helpmenu + 3) = (char *)"/           : Search for text";
#line 143
    *(helpmenu + 4) = (char *)"m           : mail current document";
#line 144
    *(helpmenu + 5) = (char *)"s           : save current document";
#line 145
    *(helpmenu + 6) = (char *)"p           : print current document";
#line 146
    *(helpmenu + 7) = (char *)"D           : download current document";
#line 147
    *(helpmenu + 8) = (char *)((void *)0);
    }
  }
  {
#line 150
  CURDialog(cur, (char *)"Pager Help", helpmenu);
  }
#line 151
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
void PagerInitGlobals(void) 
{ 


  {
#line 156
  currentpage = 0;
#line 157
  wordcount = 0;
#line 158
  slashstring[0] = (char )'\000';
#line 159
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
void PagerTitles(CursesObj *cur , GopherObj *gs , int totalbytes ) 
{ 
  int i ;
  int fluff_len ;
  int k_bytes ;
  char *cp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 168
  k_bytes = totalbytes / 1024;
#line 172
  wmove(stdscr, 0, 0);
  }
#line 173
  if (stdscr) {
#line 173
    stdscr->_attrs = 1UL << 16;
  }
#line 175
  fluff_len = 11 + k_bytes / 10;
#line 176
  if ((gs->Title)->len < 0) {
#line 176
    tmp___2 = (char *)((void *)0);
  } else {
#line 176
    tmp___2 = (gs->Title)->data;
  }
  {
#line 176
  tmp___3 = strlen((char const   *)tmp___2);
  }
#line 176
  if (tmp___3 <= (size_t )(COLS - fluff_len)) {
#line 177
    if ((gs->Title)->len < 0) {
#line 177
      tmp = (char *)((void *)0);
    } else {
#line 177
      tmp = (gs->Title)->data;
    }
    {
#line 177
    waddnstr(stdscr, (char const   *)tmp, -1);
    }
  } else {
#line 179
    if ((gs->Title)->len < 0) {
#line 179
      tmp___0 = (char *)((void *)0);
    } else {
#line 179
      tmp___0 = (gs->Title)->data;
    }
#line 179
    cp = tmp___0;
#line 180
    i = 0;
    {
#line 180
    while (1) {
      while_continue: /* CIL Label */ ;
#line 180
      if (! (i < COLS - (fluff_len + 3))) {
#line 180
        goto while_break;
      }
      {
#line 181
      tmp___1 = cp;
#line 181
      cp ++;
#line 181
      waddch(stdscr, (chtype const   )*tmp___1);
#line 180
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 183
    waddnstr(stdscr, "...", -1);
    }
  }
#line 185
  if (stdscr) {
#line 185
    stdscr->_attrs = 0UL;
  }
  {
#line 187
  wprintw(stdscr, " (%dk)", k_bytes);
#line 189
  wmove(stdscr, 1, 0);
#line 190
  waddch(stdscr, (chtype const   )cur->Box_ul);
#line 192
  i = 0;
  }
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 192
    if (! (i < COLS - 2)) {
#line 192
      goto while_break___0;
    }
    {
#line 193
    waddch(stdscr, (chtype const   )cur->Box_hline);
#line 192
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 195
  waddch(stdscr, (chtype const   )cur->Box_ur);
#line 200
  wmove(stdscr, LINES - 2, 0);
#line 201
  waddch(stdscr, (chtype const   )cur->Box_ll);
#line 202
  i = 0;
  }
  {
#line 202
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 202
    if (! (i < COLS - 2)) {
#line 202
      goto while_break___1;
    }
    {
#line 203
    waddch(stdscr, (chtype const   )cur->Box_hline);
#line 202
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 204
  waddch(stdscr, (chtype const   )cur->Box_lr);
#line 207
  wmove(stdscr, LINES - 1, 0);
#line 208
  CURbutton(cur, stdscr, (char *)"PageDown: <SPACE>", 0);
#line 209
  waddch(stdscr, (chtype const   )' ');
#line 210
  CURbutton(cur, stdscr, (char *)"Help: ?", 0);
#line 211
  waddch(stdscr, (chtype const   )' ');
#line 212
  CURbutton(cur, stdscr, (char *)"Return to Menu: u", 0);
  }
#line 213
  return;
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
int PagePosAlloc(void) 
{ 
  size_t MallocSize ;
  void *tmp ;

  {
  {
#line 219
  MallocSize = sizeof(int ) * 10UL;
#line 220
  tmp = malloc(MallocSize);
#line 220
  positions = (int *)tmp;
  }
#line 221
  if (! positions) {
#line 222
    return (0);
  } else {
#line 224
    pos_max = 10;
#line 225
    return (1);
  }
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
int PagePosRealloc(void) 
{ 
  int *temp ;
  size_t MallocSize ;
  void *tmp ;

  {
  {
#line 232
  temp = (int *)((void *)0);
#line 235
  MallocSize = sizeof(int ) * (unsigned long )(pos_max + 10);
#line 236
  temp = positions;
#line 237
  tmp = realloc((void *)positions, MallocSize);
#line 237
  positions = (int *)tmp;
  }
#line 238
  if (! positions) {
#line 239
    positions = temp;
#line 240
    return (0);
  } else {
#line 242
    pos_max += 10;
#line 243
    return (1);
  }
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
void PagePosFree(void) 
{ 


  {
#line 250
  if (positions) {
    {
#line 250
    free((void *)positions);
    }
  }
#line 251
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
void PagerPercent(int bytes , int totalbytes ) 
{ 
  int per ;
  int tmp ;

  {
#line 257
  if (totalbytes) {
#line 257
    tmp = (100 * bytes) / totalbytes;
  } else {
#line 257
    tmp = 0;
  }
  {
#line 257
  per = tmp;
#line 259
  wmove(stdscr, 0, COLS - 5);
  }
#line 260
  if (totalbytes != 0) {
    {
#line 261
    wprintw(stdscr, "%d%%", per);
    }
  }
#line 262
  if (per < 100) {
    {
#line 263
    waddch(stdscr, (chtype const   )' ');
    }
  }
#line 264
  if (per < 10) {
    {
#line 265
    waddch(stdscr, (chtype const   )' ');
    }
  }
#line 266
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
void PagerParseSearchstring(void) 
{ 
  char *MungeSearchstr ;
  int numchars ;
  char theline[256] ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 275
  MungeSearchstr = Searchstring;
#line 279
  wordcount = 0;
#line 281
  if ((unsigned long )Searchstring == (unsigned long )((void *)0)) {
#line 282
    return;
  }
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 284
    tmp = __ctype_b_loc();
    }
#line 284
    if (! ((int const   )*(*tmp + (int )*MungeSearchstr) & 8192)) {
#line 284
      goto while_break;
    }
#line 285
    MungeSearchstr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  wordcount = 0;
  {
#line 287
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 287
    if (! (wordcount < 40)) {
#line 287
      goto while_break___0;
    }
    {
#line 289
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 289
      tmp___0 = __ctype_b_loc();
      }
#line 289
      if (! ((int const   )*(*tmp___0 + (int )*MungeSearchstr) & 8192)) {
#line 289
        goto while_break___1;
      }
#line 290
      MungeSearchstr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 292
    numchars = sreadword(MungeSearchstr, theline, 40);
#line 293
    MungeSearchstr += numchars;
    }
#line 295
    if (numchars == 0) {
#line 296
      goto while_break___0;
    }
    {
#line 298
    tmp___1 = strcasecmp((char const   *)(theline), "and");
    }
#line 298
    if (tmp___1 == 0) {
#line 301
      wordcount --;
    } else {
      {
#line 298
      tmp___2 = strcasecmp((char const   *)(theline), "or");
      }
#line 298
      if (tmp___2 == 0) {
#line 301
        wordcount --;
      } else {
        {
#line 298
        tmp___3 = strcasecmp((char const   *)(theline), "not");
        }
#line 298
        if (tmp___3 == 0) {
#line 301
          wordcount --;
        } else {
#line 303
          if ((unsigned long )words[wordcount] != (unsigned long )((void *)0)) {
            {
#line 304
            free((void *)words[wordcount]);
            }
          }
          {
#line 306
          words[wordcount] = strdup((char const   *)(theline));
          }
        }
      }
    }
#line 287
    wordcount ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 309
  return;
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
void PagerPrintLine(char *inputline___0 ) 
{ 
  int lowwordnum ;
  int i ;
  char *cp ;
  char *lowword ;
  int wlen ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 316
  lowwordnum = -1;
#line 321
  if (wordcount == 0) {
#line 321
    if ((int )slashstring[0] == 0) {
      {
#line 323
      waddnstr(stdscr, (char const   *)inputline___0, -1);
      }
#line 324
      return;
    } else {
#line 321
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 321
  if (GlobalRC->SearchBolding == 0) {
    {
#line 323
    waddnstr(stdscr, (char const   *)inputline___0, -1);
    }
#line 324
    return;
  }
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! ((int )*inputline___0 != 0)) {
#line 329
      goto while_break;
    }
#line 330
    lowword = (char *)((void *)0);
#line 332
    if ((int )slashstring[0] != 0) {
      {
#line 333
      cp = strcasestr((char const   *)inputline___0, (char const   *)(slashstring));
      }
    } else {
#line 335
      cp = (char *)((void *)0);
    }
#line 337
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 338
      lowword = cp;
#line 339
      lowwordnum = -1;
    }
#line 342
    i = 0;
    {
#line 342
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 342
      if (! (i < wordcount)) {
#line 342
        goto while_break___0;
      }
      {
#line 343
      cp = strcasestr((char const   *)inputline___0, (char const   *)words[i]);
      }
#line 344
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 345
        if ((unsigned long )cp < (unsigned long )lowword) {
#line 346
          lowword = cp;
#line 347
          lowwordnum = i;
        } else
#line 345
        if ((unsigned long )lowword == (unsigned long )((void *)0)) {
#line 346
          lowword = cp;
#line 347
          lowwordnum = i;
        }
      }
#line 342
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 351
    if ((unsigned long )lowword == (unsigned long )((void *)0)) {
      {
#line 353
      waddnstr(stdscr, (char const   *)inputline___0, -1);
      }
#line 354
      return;
    } else {
#line 358
      cp = inputline___0;
      {
#line 358
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 358
        if (! ((unsigned long )cp < (unsigned long )lowword)) {
#line 358
          goto while_break___1;
        }
        {
#line 362
        waddch(stdscr, (chtype const   )*cp);
#line 358
        cp ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 365
      inputline___0 = lowword;
#line 368
      if (stdscr) {
#line 368
        stdscr->_attrs = 1UL << 16;
      }
#line 369
      if (lowwordnum == -1) {
        {
#line 370
        tmp = strlen((char const   *)(slashstring));
#line 370
        wlen = (int )tmp;
        }
      } else {
        {
#line 372
        tmp___0 = strlen((char const   *)words[lowwordnum]);
#line 372
        wlen = (int )tmp___0;
        }
      }
#line 374
      cp = inputline___0;
      {
#line 374
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 374
        if (! ((unsigned long )cp < (unsigned long )(inputline___0 + wlen))) {
#line 374
          goto while_break___2;
        }
        {
#line 375
        waddch(stdscr, (chtype const   )*cp);
#line 374
        cp ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 376
      inputline___0 += wlen;
#line 378
      if (stdscr) {
#line 378
        stdscr->_attrs = 0UL;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  return;
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
void PagerSeekPage(FILE *thefile , int gotopage , int *bytecount ) 
{ 


  {
#line 387
  if (gotopage < currentpage) {
    {
#line 388
    fseek(thefile, (long )*(positions + gotopage), 0);
#line 389
    *bytecount = *(positions + gotopage);
#line 390
    currentpage = gotopage;
    }
  }
#line 392
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
void PagerNextPage(CursesObj *cur , FILE *thefile , char *theline , int *bytecount ,
                   int totalbytes ) 
{ 
  int i ;
  char *cp ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 399
  cp = (char *)((void *)0);
#line 405
  tmp = currentpage;
#line 405
  currentpage ++;
#line 405
  *(positions + tmp) = *bytecount;
#line 406
  if (currentpage == pos_max) {
    {
#line 407
    tmp___0 = PagePosRealloc();
    }
#line 407
    if (! tmp___0) {
      {
#line 408
      CursesErrorMsg((char *)"Sorry, can\'t display this file");
      }
#line 409
      return;
    }
  }
  {
#line 412
  wmove(stdscr, 2, 0);
#line 415
  i = 0;
  }
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    if (! (i < LINES - 4)) {
#line 415
      goto while_break;
    }
    {
#line 416
    cp = fgets((char */* __restrict  */)theline, COLS + 1, (FILE */* __restrict  */)thefile);
    }
#line 417
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 418
      goto while_break;
    }
    {
#line 430
    tmp___1 = strlen((char const   *)theline);
#line 430
    *bytecount = (int )((size_t )*bytecount + tmp___1);
#line 433
    ZapCRLF(theline);
#line 436
    wmove(stdscr, i + 2, 0);
#line 437
    wclrtoeol(stdscr);
#line 438
    PagerPrintLine(theline);
#line 415
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 440
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 440
    if (! (i < LINES - 4)) {
#line 440
      goto while_break___0;
    }
    {
#line 441
    wmove(stdscr, i + 2, 0);
#line 442
    wclrtoeol(stdscr);
#line 443
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 447
  wmove(stdscr, LINES - 1, 0);
#line 448
  wclrtoeol(stdscr);
#line 449
  CURbutton(cur, stdscr, (char *)"Help: ?", 0);
#line 450
  waddnstr(stdscr, "  ", -1);
#line 451
  CURbutton(cur, stdscr, (char *)"Exit: u", 0);
#line 452
  waddnstr(stdscr, "  ", -1);
  }
#line 453
  if (*bytecount != totalbytes) {
    {
#line 454
    CURbutton(cur, stdscr, (char *)"PageDown: Space", 0);
#line 455
    waddnstr(stdscr, "  ", -1);
    }
  }
#line 457
  if (currentpage > 1) {
    {
#line 458
    CURbutton(cur, stdscr, (char *)"PageUp: b", 0);
    }
  }
#line 459
  return;
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
boolean PagerSearch(FILE *thefile , char *theline , int *bytecount , char *search ) 
{ 
  int i ;
  char *cp ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
#line 469
  cp = (char *)((void *)0);
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 477
    tmp = currentpage;
#line 477
    currentpage ++;
#line 477
    *(positions + tmp) = *bytecount;
#line 478
    if (currentpage == pos_max) {
      {
#line 479
      tmp___0 = PagePosRealloc();
      }
#line 479
      if (! tmp___0) {
        {
#line 480
        CursesErrorMsg((char *)"Sorry, can\'t display this file");
        }
#line 481
        return (0);
      }
    }
#line 483
    i = 0;
    {
#line 483
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 483
      if (! (i < LINES - 4)) {
#line 483
        goto while_break___0;
      }
      {
#line 484
      cp = fgets((char */* __restrict  */)theline, COLS + 1, (FILE */* __restrict  */)thefile);
      }
#line 485
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 486
        goto while_break___0;
      }
      {
#line 498
      tmp___1 = strlen((char const   *)theline);
#line 498
      *bytecount = (int )((size_t )*bytecount + tmp___1);
#line 501
      tmp___2 = strcasestr((char const   *)cp, (char const   *)search);
      }
#line 501
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 502
        return (1);
      }
#line 483
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 475
    if (! ((unsigned long )cp != (unsigned long )((void *)0))) {
#line 475
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (0);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/pager.c"
void PagerBuiltin(CursesObj *cur , GopherObj *gs ) 
{ 
  int ch ;
  FILE *thefile ;
  char *theline ;
  char *Dialogmess[3] ;
  char command[200] ;
  boolean done ;
  int bytecount ;
  int totalbytes ;
  int savedpagenum ;
  struct stat buf ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  FILE *printit ;
  char *cp ;
  char printtmpstr[512] ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  boolean tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  boolean tmp___24 ;
  int tmp___25 ;

  {
  {
#line 517
  done = 0;
#line 518
  bytecount = 0;
#line 519
  totalbytes = 0;
#line 523
  PagerInitGlobals();
#line 525
  tmp = PagePosAlloc();
  }
#line 525
  if (! tmp) {
    {
#line 526
    CursesErrorMsg((char *)"Sorry, can\'t display this file");
    }
#line 527
    return;
  }
  {
#line 531
  tmp___0 = malloc(sizeof(char ) * (unsigned long )(COLS + 1));
#line 531
  theline = (char *)tmp___0;
#line 532
  *theline = (char )'\000';
  }
#line 534
  if ((gs->Localfile)->len < 0) {
#line 534
    tmp___1 = (char *)((void *)0);
  } else {
#line 534
    tmp___1 = (gs->Localfile)->data;
  }
  {
#line 534
  stat((char const   */* __restrict  */)tmp___1, (struct stat */* __restrict  */)(& buf));
#line 535
  totalbytes = (int )buf.st_size;
#line 537
  PagerParseSearchstring();
#line 539
  wclear(stdscr);
#line 540
  PagerTitles(cur, gs, totalbytes);
#line 541
  wrefresh(stdscr);
  }
#line 543
  if ((gs->Localfile)->len < 0) {
#line 543
    tmp___2 = (char *)((void *)0);
  } else {
#line 543
    tmp___2 = (gs->Localfile)->data;
  }
  {
#line 543
  thefile = fopen((char const   */* __restrict  */)tmp___2, (char const   */* __restrict  */)"r");
  }
#line 545
  if ((unsigned long )thefile == (unsigned long )((void *)0)) {
    {
#line 546
    CursesErrorMsg((char *)"Cannot Open requested file..");
    }
#line 547
    if (theline) {
      {
#line 547
      free((void *)theline);
      }
    }
#line 548
    return;
  }
  {
#line 551
  PagerNextPage(cur, thefile, theline, & bytecount, totalbytes);
#line 553
  wrefresh(stdscr);
  }
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (! (done == 0)) {
#line 556
      goto while_break;
    }
    {
#line 557
    PagerPercent(bytecount, totalbytes);
#line 558
    wrefresh(stdscr);
#line 560
    ch = CURgetch(cur);
    }
    {
#line 569
    if (ch == 7) {
#line 569
      goto case_7;
    }
#line 569
    if (ch == 113) {
#line 569
      goto case_7;
    }
#line 569
    if (ch == 117) {
#line 569
      goto case_7;
    }
#line 569
    if (ch == 260) {
#line 569
      goto case_7;
    }
#line 577
    if (ch == 338) {
#line 577
      goto case_338;
    }
#line 577
    if (ch == 258) {
#line 577
      goto case_338;
    }
#line 577
    if (ch == 32) {
#line 577
      goto case_338;
    }
#line 577
    if (ch == 10) {
#line 577
      goto case_338;
    }
#line 577
    if (ch == 6) {
#line 577
      goto case_338;
    }
#line 586
    if (ch == 98) {
#line 586
      goto case_98;
    }
#line 586
    if (ch == 339) {
#line 586
      goto case_98;
    }
#line 586
    if (ch == 259) {
#line 586
      goto case_98;
    }
#line 586
    if (ch == 2) {
#line 586
      goto case_98;
    }
#line 594
    if (ch == 94) {
#line 594
      goto case_94;
    }
#line 602
    if (ch == 36) {
#line 602
      goto case_36;
    }
#line 614
    if (ch == 63) {
#line 614
      goto case_63;
    }
#line 614
    if (ch == 104) {
#line 614
      goto case_63;
    }
#line 614
    if (ch == 363) {
#line 614
      goto case_63;
    }
#line 614
    if (ch == 31) {
#line 614
      goto case_63;
    }
#line 619
    if (ch == 112) {
#line 619
      goto case_112;
    }
#line 688
    if (ch == 115) {
#line 688
      goto case_115;
    }
#line 697
    if (ch == 68) {
#line 697
      goto case_68;
    }
#line 706
    if (ch == 109) {
#line 706
      goto case_109;
    }
#line 723
    if (ch == 47) {
#line 723
      goto case_47;
    }
#line 733
    if (ch == 110) {
#line 733
      goto case_110;
    }
#line 762
    goto switch_default;
    case_7: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 570
    done = 1;
#line 571
    goto switch_break;
    case_338: /* CIL Label */ 
    case_258: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 578
    if (bytecount < totalbytes) {
      {
#line 579
      PagerNextPage(cur, thefile, theline, & bytecount, totalbytes);
      }
    }
#line 581
    goto switch_break;
    case_98: /* CIL Label */ 
    case_339: /* CIL Label */ 
    case_259: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 587
    if (currentpage > 1) {
      {
#line 588
      PagerSeekPage(thefile, currentpage - 2, & bytecount);
#line 589
      PagerNextPage(cur, thefile, theline, & bytecount, totalbytes);
      }
    }
#line 592
    goto switch_break;
    case_94: /* CIL Label */ 
#line 595
    if (currentpage > 1) {
      {
#line 596
      PagerSeekPage(thefile, 0, & bytecount);
#line 597
      PagerNextPage(cur, thefile, theline, & bytecount, totalbytes);
      }
    }
#line 600
    goto switch_break;
    case_36: /* CIL Label */ 
#line 603
    if (bytecount < totalbytes) {
      {
#line 604
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 605
        PagerNextPage(cur, thefile, theline, & bytecount, totalbytes);
        }
#line 604
        if (! (bytecount < totalbytes)) {
#line 604
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 609
    goto switch_break;
    case_63: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_363: /* CIL Label */ 
    case_31: /* CIL Label */ 
    {
#line 615
    PagerHelp(cur);
    }
#line 616
    if (stdscr) {
#line 616
      tmp___3 = (int )stdscr->_maxy + 1;
    } else {
#line 616
      tmp___3 = -1;
    }
    {
#line 616
    wtouchln(stdscr, 0, tmp___3, 1);
    }
#line 617
    goto switch_break;
    case_112: /* CIL Label */ 
#line 620
    if (SecureMode) {
#line 620
      goto _L;
    } else
#line 620
    if (NoShellMode) {
      _L: /* CIL Label */ 
      {
#line 621
      CursesErrorMsg((char *)"Sorry, you are not allowed to print files");
      }
#line 622
      if (stdscr) {
#line 622
        tmp___4 = (int )stdscr->_maxy + 1;
      } else {
#line 622
        tmp___4 = -1;
      }
      {
#line 622
      wtouchln(stdscr, 0, tmp___4, 1);
      }
#line 623
      goto switch_break;
    }
#line 626
    if (GlobalRC->ANSIprinter == 1) {
#line 631
      if ((gs->Localfile)->len < 0) {
#line 631
        tmp___5 = (char *)((void *)0);
      } else {
#line 631
        tmp___5 = (gs->Localfile)->data;
      }
      {
#line 631
      printit = fopen((char const   */* __restrict  */)tmp___5, (char const   */* __restrict  */)"r");
      }
#line 632
      if ((unsigned long )printit == (unsigned long )((void *)0)) {
        {
#line 633
        CursesErrorMsg((char *)"Cannot Open requested file..");
        }
#line 634
        goto switch_break;
      }
      {
#line 638
      CURexit(CursesScreen);
#line 640
      printf((char const   */* __restrict  */)"Now printing on ANSI attached printer\n");
#line 641
      printf((char const   */* __restrict  */)"\033[5i");
      }
      {
#line 642
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 644
        cp = fgets((char */* __restrict  */)(printtmpstr), (int )sizeof(printtmpstr),
                   (FILE */* __restrict  */)printit);
        }
#line 645
        if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 646
          goto while_break___1;
        }
        {
#line 648
        fputs((char const   */* __restrict  */)cp, (FILE */* __restrict  */)stdout);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 650
      fclose(printit);
#line 652
      printf((char const   */* __restrict  */)"\f\033[4i");
#line 654
      printf((char const   */* __restrict  */)"Press <RETURN> to continue");
#line 655
      getchar();
#line 656
      CURenter(CursesScreen);
      }
#line 657
      if (stdscr) {
#line 657
        tmp___6 = (int )stdscr->_maxy + 1;
      } else {
#line 657
        tmp___6 = -1;
      }
      {
#line 657
      wtouchln(stdscr, 0, tmp___6, 1);
#line 659
      clearok(curscr, (_Bool)1);
      }
#line 660
      goto switch_break;
    }
#line 663
    if ((gs->Localfile)->len < 0) {
#line 663
      tmp___8 = (char *)((void *)0);
    } else {
#line 663
      tmp___8 = (gs->Localfile)->data;
    }
#line 663
    if ((gs->Localview)->len < 0) {
#line 663
      tmp___9 = (char *)((void *)0);
    } else {
#line 663
      tmp___9 = (gs->Localview)->data;
    }
    {
#line 663
    tmp___10 = RCprintCommand(GlobalRC, tmp___9, tmp___8, command);
    }
#line 663
    if (tmp___10) {
      {
#line 663
      tmp___11 = strncasecmp((char const   *)(command), "- none -", (size_t )8);
      }
#line 663
      if (tmp___11) {
        {
#line 663
        tmp___12 = strlen((char const   *)(command));
        }
#line 663
        if (tmp___12 == 0UL) {
          _L___0: /* CIL Label */ 
          {
#line 667
          CursesErrorMsg((char *)"Sorry, no method to print this document");
          }
#line 668
          if (stdscr) {
#line 668
            tmp___7 = (int )stdscr->_maxy + 1;
          } else {
#line 668
            tmp___7 = -1;
          }
          {
#line 668
          wtouchln(stdscr, 0, tmp___7, 1);
          }
#line 669
          goto switch_break;
        }
      } else {
#line 663
        goto _L___0;
      }
    } else {
#line 663
      goto _L___0;
    }
    {
#line 671
    Dialogmess[0] = strdup("The filename is:");
    }
#line 672
    if ((gs->Localfile)->len < 0) {
#line 672
      tmp___13 = (char *)((void *)0);
    } else {
#line 672
      tmp___13 = (gs->Localfile)->data;
    }
    {
#line 672
    Dialogmess[1] = strdup((char const   *)tmp___13);
#line 673
    Dialogmess[2] = (char *)((void *)0);
#line 675
    tmp___15 = CURDialog(cur, (char *)"Print current document", Dialogmess);
    }
#line 675
    if (tmp___15 != -1) {
      {
#line 676
      tmp___14 = FIOsystem(command);
      }
#line 676
      if (tmp___14) {
        {
#line 677
        CursesErrorMsg((char *)"Encountered printing problem, sorry...");
        }
      }
    }
    {
#line 680
    free((void *)Dialogmess[0]);
#line 681
    free((void *)Dialogmess[1]);
    }
#line 683
    if (stdscr) {
#line 683
      tmp___16 = (int )stdscr->_maxy + 1;
    } else {
#line 683
      tmp___16 = -1;
    }
    {
#line 683
    wtouchln(stdscr, 0, tmp___16, 1);
#line 684
    clearok(curscr, (_Bool)1);
    }
#line 686
    goto switch_break;
    case_115: /* CIL Label */ 
#line 689
    if (SecureMode) {
      {
#line 692
      CursesErrorMsg((char *)"Sorry, you are not allowed to save files");
      }
    } else
#line 689
    if (NoShellMode) {
      {
#line 692
      CursesErrorMsg((char *)"Sorry, you are not allowed to save files");
      }
    } else {
#line 690
      if ((gs->Localview)->len < 0) {
#line 690
        tmp___17 = (char *)((void *)0);
      } else {
#line 690
        tmp___17 = (gs->Localview)->data;
      }
      {
#line 690
      Save_file(gs, (char *)((void *)0), tmp___17);
      }
    }
#line 694
    if (stdscr) {
#line 694
      tmp___18 = (int )stdscr->_maxy + 1;
    } else {
#line 694
      tmp___18 = -1;
    }
    {
#line 694
    wtouchln(stdscr, 0, tmp___18, 1);
    }
#line 695
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 698
    Download_file(gs);
#line 699
    wclear(stdscr);
#line 700
    PagerTitles(cur, gs, totalbytes);
#line 701
    PagerSeekPage(thefile, currentpage - 1, & bytecount);
#line 702
    PagerNextPage(cur, thefile, theline, & bytecount, totalbytes);
    }
#line 704
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 716
    GSmail(gs);
#line 717
    wclear(stdscr);
#line 718
    PagerTitles(cur, gs, totalbytes);
#line 719
    PagerSeekPage(thefile, currentpage - 1, & bytecount);
#line 720
    PagerNextPage(cur, thefile, theline, & bytecount, totalbytes);
    }
#line 721
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 725
    tmp___20 = CURGetOneOption(CursesScreen, (char *)"", (char *)"Search text for:",
                               slashstring);
    }
#line 725
    if (tmp___20 < 0) {
#line 725
      goto _L___1;
    } else
#line 725
    if ((int )slashstring[0] == 0) {
      _L___1: /* CIL Label */ 
#line 729
      if (stdscr) {
#line 729
        tmp___19 = (int )stdscr->_maxy + 1;
      } else {
#line 729
        tmp___19 = -1;
      }
      {
#line 729
      wtouchln(stdscr, 0, tmp___19, 1);
      }
#line 730
      goto switch_break;
    }
    case_110: /* CIL Label */ 
#line 735
    if ((int )slashstring[0] == 0) {
      {
#line 736
      CursesErrorMsg((char *)"Use \'/\' to define search a first...");
      }
#line 737
      if (stdscr) {
#line 737
        tmp___21 = (int )stdscr->_maxy + 1;
      } else {
#line 737
        tmp___21 = -1;
      }
      {
#line 737
      wtouchln(stdscr, 0, tmp___21, 1);
      }
#line 738
      goto switch_break;
    }
#line 741
    savedpagenum = currentpage;
#line 743
    if (ch == 47) {
      {
#line 744
      PagerSeekPage(thefile, currentpage - 1, & bytecount);
      }
    }
    {
#line 746
    tmp___24 = PagerSearch(thefile, theline, & bytecount, slashstring);
    }
#line 746
    if (! tmp___24) {
      {
#line 747
      CursesErrorMsg((char *)"Couldn\'t find text");
      }
#line 748
      if (stdscr) {
#line 748
        tmp___22 = (int )stdscr->_maxy + 1;
      } else {
#line 748
        tmp___22 = -1;
      }
      {
#line 748
      wtouchln(stdscr, 0, tmp___22, 1);
#line 749
      PagerSeekPage(thefile, savedpagenum - 1, & bytecount);
#line 750
      PagerNextPage(cur, thefile, theline, & bytecount, totalbytes);
      }
#line 752
      if (stdscr) {
#line 752
        tmp___23 = (int )stdscr->_maxy + 1;
      } else {
#line 752
        tmp___23 = -1;
      }
      {
#line 752
      wtouchln(stdscr, 0, tmp___23, 1);
      }
#line 753
      goto switch_break;
    }
    {
#line 757
    PagerSeekPage(thefile, currentpage - 1, & bytecount);
#line 758
    PagerNextPage(cur, thefile, theline, & bytecount, totalbytes);
    }
#line 759
    if (stdscr) {
#line 759
      tmp___25 = (int )stdscr->_maxy + 1;
    } else {
#line 759
      tmp___25 = -1;
    }
    {
#line 759
    wtouchln(stdscr, 0, tmp___25, 1);
    }
#line 760
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 763
    CURBeep(cur);
    }
#line 764
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 772
  fclose(thefile);
#line 773
  free((void *)theline);
#line 774
  PagePosFree();
  }
#line 775
  return;
}
}
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 756 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 287 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.h"
CursesObj *CURnew(void) ;
#line 296
void CURresize(CursesObj *cur ) ;
#line 307
void CURgetYesorNo(CursesObj *cur , char *OptionName , char *Response ) ;
#line 115 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.h"
void CleanupandExit(int exitval ) ;
#line 188 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/globals.h"
int process_request(GopherObj *ZeGopher ) ;
#line 189
int Load_Dir(GopherObj *ZeGopher ) ;
#line 190
int Load_Index(GopherObj *ZeGopher ) ;
#line 191
int Load_Index_or_Dir(GopherObj *ZeGopher , char *Searchmungestr ) ;
#line 512 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
void describe_gopher(char *banner , GopherStruct *ZeGopher , FILE *gripefile ) ;
#line 520 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
void do_tel_3270(GopherStruct *ZeGopher ) 
{ 
  char *Dialogmess[9] ;
  char sMessage1[128] ;
  char sMessage2[128] ;
  char sTelCmd[128] ;
  char *cp ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 534
  wclear(stdscr);
#line 538
  Dialogmess[0] = (char *)"Warning!!!!!, you are about to leave the Internet";
#line 539
  Dialogmess[1] = (char *)"Gopher program and connect to another host. If";
#line 540
  Dialogmess[2] = (char *)"you get stuck press the control key and the";
#line 544
  Dialogmess[3] = (char *)"] key, and then type quit";
#line 546
  Dialogmess[4] = (char *)"";
  }
#line 548
  if (ZeGopher->iPort != 0) {
#line 549
    if ((int )ZeGopher->sFileType == 84) {
#line 549
      tmp = "tn3270";
    } else {
#line 549
      tmp = "telnet";
    }
#line 549
    if ((ZeGopher->Host)->len < 0) {
#line 549
      tmp___0 = (char *)((void *)0);
    } else {
#line 549
      tmp___0 = (ZeGopher->Host)->data;
    }
    {
#line 549
    sprintf((char */* __restrict  */)(sMessage1), (char const   */* __restrict  */)"Connecting to %.40s, port %d using %s.",
            tmp___0, ZeGopher->iPort, tmp);
    }
  } else {
#line 553
    if ((int )ZeGopher->sFileType == 84) {
#line 553
      tmp___1 = "tn3270";
    } else {
#line 553
      tmp___1 = "telnet";
    }
#line 553
    if ((ZeGopher->Host)->len < 0) {
#line 553
      tmp___2 = (char *)((void *)0);
    } else {
#line 553
      tmp___2 = (ZeGopher->Host)->data;
    }
    {
#line 553
    sprintf((char */* __restrict  */)(sMessage1), (char const   */* __restrict  */)"Connecting to %.40s using %s.",
            tmp___2, tmp___1);
    }
  }
#line 557
  Dialogmess[5] = sMessage1;
#line 559
  if ((ZeGopher->Selstr)->len < 0) {
#line 559
    tmp___3 = (char *)((void *)0);
  } else {
#line 559
    tmp___3 = (ZeGopher->Selstr)->data;
  }
#line 559
  cp = tmp___3;
#line 560
  if ((int )*cp != 0) {
#line 561
    if ((ZeGopher->Selstr)->len < 0) {
#line 561
      tmp___4 = (char *)((void *)0);
    } else {
#line 561
      tmp___4 = (ZeGopher->Selstr)->data;
    }
    {
#line 561
    sprintf((char */* __restrict  */)(sMessage2), (char const   */* __restrict  */)"Use the account name \"%.40s\" to log in",
            tmp___4);
    }
  } else {
#line 565
    sMessage2[0] = (char )'\000';
  }
#line 567
  Dialogmess[6] = (char *)"";
#line 568
  Dialogmess[7] = sMessage2;
#line 569
  Dialogmess[8] = (char *)((void *)0);
#line 571
  if ((ZeGopher->Title)->len < 0) {
#line 571
    tmp___5 = (char *)((void *)0);
  } else {
#line 571
    tmp___5 = (ZeGopher->Title)->data;
  }
  {
#line 571
  tmp___6 = CURDialog(CursesScreen, tmp___5, Dialogmess);
  }
#line 571
  if (tmp___6 < 0) {
#line 572
    return;
  }
  {
#line 574
  CURexit(CursesScreen);
  }
#line 576
  if ((int )ZeGopher->sFileType == 84) {
#line 578
    if ((ZeGopher->Host)->len < 0) {
#line 578
      tmp___7 = (char *)((void *)0);
    } else {
#line 578
      tmp___7 = (ZeGopher->Host)->data;
    }
    {
#line 578
    RCdisplayCommand(GlobalRC, (char *)"Terminal/tn3270", tmp___7, sTelCmd);
    }
  } else {
#line 583
    if ((ZeGopher->Host)->len < 0) {
#line 583
      tmp___8 = (char *)((void *)0);
    } else {
#line 583
      tmp___8 = (ZeGopher->Host)->data;
    }
    {
#line 583
    RCdisplayCommand(GlobalRC, (char *)"Terminal/telnet", tmp___8, sTelCmd);
    }
  }
#line 587
  if (ZeGopher->iPort != 0) {
#line 587
    if (ZeGopher->iPort != 23) {
      {
#line 592
      tmp___9 = strlen((char const   *)(sTelCmd));
#line 592
      sprintf((char */* __restrict  */)(sTelCmd + tmp___9), (char const   */* __restrict  */)" %d",
              ZeGopher->iPort);
      }
    }
  }
  {
#line 595
  CURexit(CursesScreen);
#line 600
  FIOsystem(sTelCmd);
#line 601
  printf((char const   */* __restrict  */)"\n\n");
#line 602
  printf((char const   */* __restrict  */)"\nPress <RETURN> to continue");
#line 603
  fflush(stdout);
#line 604
  fflush(stdin);
#line 605
  fflush(stdin);
#line 606
  getchar();
#line 607
  CURenter(CursesScreen);
  }
#line 608
  return;
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
void Gripe(GopherObj *gs ) 
{ 
  char *gripeprompt[15] ;
  char *gripemess[15] ;
  char *cp ;
  char email[128] ;
  char version[128] ;
  int i ;
  int j ;
  char *mailargv[3] ;
  FileIO *fio ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 723
  cp = (char *)((void *)0);
#line 735
  GSgetginfo(gs, 1);
  }
#line 737
  if (gs->isgplus) {
#line 737
    if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
#line 737
      tmp___2 = (char *)((void *)0);
    } else {
#line 737
      if (((gs->gplus)->Admin)->len < 0) {
#line 737
        tmp___1 = (char *)((void *)0);
      } else {
#line 737
        tmp___1 = ((gs->gplus)->Admin)->data;
      }
#line 737
      tmp___2 = tmp___1;
    }
#line 737
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 738
      if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
#line 738
        tmp___0 = (char *)((void *)0);
      } else {
#line 738
        if (((gs->gplus)->Admin)->len < 0) {
#line 738
          tmp = (char *)((void *)0);
        } else {
#line 738
          tmp = ((gs->gplus)->Admin)->data;
        }
#line 738
        tmp___0 = tmp;
      }
      {
#line 738
      cp = strchr((char const   *)tmp___0, '<');
      }
    }
  }
#line 744
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 756
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
      {
#line 760
      CursesErrorMsg((char *)"Can\'t find an administrator for this item, sorry!");
      }
#line 762
      return;
    }
  }
  {
#line 767
  strncpy((char */* __restrict  */)(email), (char const   */* __restrict  */)(cp + 1),
          sizeof(email));
#line 768
  cp = strrchr((char const   *)(email), '>');
  }
#line 769
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 770
    *cp = (char )'\000';
  }
#line 774
  if (SecureMode) {
#line 774
    goto _L;
  } else
#line 774
  if (NoShellMode) {
    _L: /* CIL Label */ 
    {
#line 775
    tmp___3 = strspn((char const   *)(email), "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789%.@!-_");
#line 775
    tmp___4 = strlen((char const   *)(email));
    }
#line 775
    if (tmp___3 != tmp___4) {
      {
#line 777
      CursesErrorMsg((char *)"Can\'t find an administrator for this item, sorry!");
      }
#line 778
      return;
    } else
#line 775
    if ((int )email[0] == 45) {
      {
#line 777
      CursesErrorMsg((char *)"Can\'t find an administrator for this item, sorry!");
      }
#line 778
      return;
    }
  }
#line 782
  i = 3;
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;
#line 782
    if (! (i < 15)) {
#line 782
      goto while_break;
    }
    {
#line 783
    tmp___5 = malloc(sizeof(char ) * (unsigned long )COLS);
#line 783
    cp = (char *)tmp___5;
#line 784
    bzero((void *)cp, (unsigned long )COLS * sizeof(char ));
#line 785
    gripeprompt[i] = (char *)"";
#line 786
    gripemess[i] = cp;
#line 782
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 789
  i = 0;
  {
#line 789
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 789
    if (! (i < 3)) {
#line 789
      goto while_break___0;
    }
#line 790
    gripemess[i] = (char *)((void *)0);
#line 789
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 794
  gripeprompt[0] = (char *)"Hit the Tab key at the end of each line you type.";
#line 796
  gripeprompt[1] = (char *)"Press Control-X to send your message.";
#line 807
  gripeprompt[2] = (char *)"";
#line 809
  gripeprompt[3] = (char *)"Subject";
#line 810
  gripeprompt[4] = (char *)"Problem";
#line 811
  gripeprompt[14] = (char *)((void *)0);
#line 813
  if ((unsigned long )gs->gplus == (unsigned long )((void *)0)) {
#line 813
    tmp___7 = (char *)((void *)0);
  } else {
#line 813
    if (((gs->gplus)->Admin)->len < 0) {
#line 813
      tmp___6 = (char *)((void *)0);
    } else {
#line 813
      tmp___6 = ((gs->gplus)->Admin)->data;
    }
#line 813
    tmp___7 = tmp___6;
  }
  {
#line 813
  tmp___8 = CURRequest(CursesScreen, tmp___7, gripeprompt, gripemess);
  }
#line 813
  if (tmp___8 != 0) {
#line 814
    return;
  }
  {
#line 816
  tmp___9 = strlen((char const   *)gripemess[3]);
  }
#line 816
  if (tmp___9 == 0UL) {
    {
#line 817
    CursesErrorMsg((char *)"Cannot send, no subject...");
    }
#line 818
    return;
  }
#line 820
  i = 4;
#line 820
  j = 0;
  {
#line 820
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 820
    if (! (i < 14)) {
#line 820
      goto while_break___1;
    }
    {
#line 821
    tmp___10 = strlen((char const   *)gripemess[i]);
#line 821
    j = (int )((size_t )j + tmp___10);
#line 820
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 822
  if (j < 20) {
    {
#line 823
    CursesErrorMsg((char *)"Cannot send, message too small...");
    }
#line 824
    return;
  }
  {
#line 880
  mailargv[0] = (char *)"/bin/mail";
#line 881
  mailargv[1] = email;
#line 882
  mailargv[2] = (char *)((void *)0);
#line 884
  fio = FIOopenProcess(mailargv[0], mailargv, (char *)"w");
  }
#line 886
  if ((unsigned long )fio == (unsigned long )((void *)0)) {
    {
#line 887
    CursesErrorMsg((char *)"Cannot send mail...");
    }
#line 888
    return;
  }
  {
#line 891
  *(gripemess[3] + 71) = (char )'\000';
#line 892
  FIOwritestring(fio, (char *)"Subject: ");
#line 893
  FIOwritestring(fio, gripemess[3]);
#line 894
  FIOwritestring(fio, (char *)"\n\n");
#line 896
  free((void *)gripemess[3]);
#line 899
  FIOwritestring(fio, (char *)"Regarding the following Gopher item:\n");
#line 900
  GStoLink((GopherObj *)*((CurrentDir->Gophers)->objects + (CurrentDir->currentitem - 1)),
           fio->fd, 1);
#line 902
  FIOwritestring(fio, (char *)"\n");
#line 906
  i = 14;
  }
  {
#line 906
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 906
    if (i > 3) {
      {
#line 906
      tmp___11 = strlen((char const   *)gripemess[i]);
      }
#line 906
      if (! (tmp___11 == 0UL)) {
#line 906
        goto while_break___2;
      }
    } else {
#line 906
      goto while_break___2;
    }
    {
#line 907
    free((void *)gripemess[i]);
#line 908
    gripemess[i] = (char *)((void *)0);
#line 906
    i --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 911
  i = 4;
  {
#line 911
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 911
    if (i < 15) {
#line 911
      if (! gripemess[i]) {
#line 911
        goto while_break___3;
      }
    } else {
#line 911
      goto while_break___3;
    }
    {
#line 912
    FIOwritestring(fio, gripemess[i]);
#line 913
    FIOwritestring(fio, (char *)"\n");
#line 914
    free((void *)gripemess[i]);
#line 911
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 917
  FIOwritestring(fio, (char *)"\n[Sent from within the ");
#line 918
  sprintf((char */* __restrict  */)(version), (char const   */* __restrict  */)"Internet Gopher Information Client v%s.%s.%d",
          "3", "0", 12);
#line 920
  FIOwritestring(fio, version);
#line 921
  FIOwritestring(fio, (char *)"]\n");
#line 923
  FIOclose(fio);
  }
#line 925
  return;
}
}
#line 935
char *do_index(GopherObj *ZeGopher ) ;
#line 935 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
static char *inputline  =    (char *)((void *)0);
#line 936 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
static char *prompt[2]  ;
#line 937 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
static char *response[2]  ;
#line 933 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
char *do_index(GopherObj *ZeGopher ) 
{ 
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 939
  if ((unsigned long )inputline == (unsigned long )((void *)0)) {
    {
#line 940
    tmp = malloc(sizeof(char ) * 256UL);
#line 940
    inputline = (char *)tmp;
    }
#line 941
    if ((unsigned long )inputline == (unsigned long )((void *)0)) {
      {
#line 942
      perror("Out of memory");
#line 942
      CleanupandExit(-1);
      }
    }
#line 943
    *inputline = (char )'\000';
  }
#line 946
  prompt[0] = (char *)"Words to search for";
#line 947
  prompt[1] = (char *)((void *)0);
#line 949
  response[0] = inputline;
#line 950
  response[1] = (char *)((void *)0);
#line 952
  if ((ZeGopher->Title)->len < 0) {
#line 952
    tmp___0 = (char *)((void *)0);
  } else {
#line 952
    tmp___0 = (ZeGopher->Title)->data;
  }
  {
#line 952
  tmp___1 = CURRequest(CursesScreen, tmp___0, prompt, response);
  }
#line 952
  if (tmp___1 == -1) {
#line 953
    return ((char *)((void *)0));
  }
#line 955
  if ((int )*inputline == 0) {
#line 956
    return ((char *)((void *)0));
  } else {
#line 958
    return (inputline);
  }
}
}
#line 970 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
void suck_sound(int sockfd ) 
{ 
  FileIO *Play ;
  int j ;
  char buf[1400] ;
  char playCmd[1400] ;
  boolean tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 978
  tmp = RCdisplayCommand(GlobalRC, (char *)"Audio/basic", (char *)"", playCmd);
  }
#line 978
  if (tmp) {
    {
#line 978
    tmp___0 = strncasecmp((char const   *)(playCmd), "- none -", (size_t )8);
    }
#line 978
    if (tmp___0) {
#line 978
      if ((unsigned long )(playCmd) == (unsigned long )((void *)0)) {
#line 985
        return;
      } else
#line 978
      if ((int )playCmd[0] == 0) {
#line 985
        return;
      }
    } else {
#line 985
      return;
    }
  } else {
#line 985
    return;
  }
  {
#line 988
  Play = FIOopenCmdline(playCmd, (char *)"w");
  }
  {
#line 991
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 992
    tmp___1 = read(sockfd, (void *)(buf), (size_t )1400);
#line 992
    j = (int )tmp___1;
    }
#line 994
    if (j == 0) {
#line 995
      goto while_break;
    }
    {
#line 997
    FIOwriten(Play, buf, j);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 999
  return;
}
}
#line 1007 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
void do_sound(GopherStruct *ZeGopher ) 
{ 
  int sockfd ;
  BOOLEAN Waitforchld ;
  char *tmp ;

  {
  {
#line 1014
  Waitforchld = 0;
#line 1016
  sockfd = GSconnect(ZeGopher);
  }
#line 1016
  if (sockfd < 0) {
#line 1017
    if ((ZeGopher->Host)->len < 0) {
#line 1017
      tmp = (char *)((void *)0);
    } else {
#line 1017
      tmp = (ZeGopher->Host)->data;
    }
    {
#line 1017
    check_sock(sockfd, tmp, ZeGopher->iPort);
    }
#line 1018
    return;
  }
  {
#line 1022
  GStransmit(ZeGopher, sockfd, (char *)((void *)0), (char *)((void *)0), (char *)((void *)0));
  }
#line 1026
  if (SOUNDCHILD != 0) {
#line 1027
    Waitforchld = 1;
  }
  {
#line 1029
  SOUNDCHILD = fork();
  }
#line 1029
  if (! (SOUNDCHILD < 0)) {
#line 1032
    if (SOUNDCHILD == 0) {
      {
#line 1033
      suck_sound(sockfd);
#line 1034
      exit(0);
      }
    }
  }
  {
#line 1039
  close(sockfd);
  }
#line 1040
  return;
}
}
#line 1052 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
void showfile(GopherObj *ZeGopher ) 
{ 
  char *tmpfilename ;
  FILE *tmpfile___0 ;
  char inputline___0[512] ;
  char *view ;
  char mkstemp_template[19] ;
  int mkstemp_fd ;
  boolean WritePipe ;
  boolean ForkOff ;
  boolean GS2FileSucceeded ;
  int Child ;
  boolean tmp ;
  int tmp___0 ;
  char buf[75] ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 1055
  tmpfilename = (char *)((void *)0);
#line 1058
  view = (char *)((void *)0);
#line 1059
  mkstemp_template[0] = (char )'/';
#line 1059
  mkstemp_template[1] = (char )'t';
#line 1059
  mkstemp_template[2] = (char )'m';
#line 1059
  mkstemp_template[3] = (char )'p';
#line 1059
  mkstemp_template[4] = (char )'/';
#line 1059
  mkstemp_template[5] = (char )'g';
#line 1059
  mkstemp_template[6] = (char )'o';
#line 1059
  mkstemp_template[7] = (char )'p';
#line 1059
  mkstemp_template[8] = (char )'h';
#line 1059
  mkstemp_template[9] = (char )'e';
#line 1059
  mkstemp_template[10] = (char )'r';
#line 1059
  mkstemp_template[11] = (char )'-';
#line 1059
  mkstemp_template[12] = (char )'X';
#line 1059
  mkstemp_template[13] = (char )'X';
#line 1059
  mkstemp_template[14] = (char )'X';
#line 1059
  mkstemp_template[15] = (char )'X';
#line 1059
  mkstemp_template[16] = (char )'X';
#line 1059
  mkstemp_template[17] = (char )'X';
#line 1059
  mkstemp_template[18] = (char )'\000';
#line 1060
  mkstemp_fd = -1;
#line 1061
  WritePipe = 0;
#line 1061
  ForkOff = 0;
#line 1063
  GS2FileSucceeded = 1;
#line 1068
  view = Choose_View(ZeGopher);
  }
#line 1072
  if ((unsigned long )view == (unsigned long )((void *)0)) {
#line 1073
    return;
  } else
#line 1072
  if ((int )*view == 0) {
#line 1073
    return;
  }
  {
#line 1075
  tmp = RCdisplayCommand(GlobalRC, view, (char *)"", inputline___0);
  }
#line 1075
  if (tmp) {
    {
#line 1075
    tmp___0 = strncasecmp((char const   *)(inputline___0), "- none -", (size_t )8);
    }
#line 1075
    if (tmp___0) {
#line 1075
      if ((unsigned long )(inputline___0) == (unsigned long )((void *)0)) {
        {
#line 1078
        CursesErrorMsg((char *)"No display command is mapped to this view!");
        }
#line 1079
        return;
      } else
#line 1075
      if ((int )inputline___0[0] == 0) {
        {
#line 1078
        CursesErrorMsg((char *)"No display command is mapped to this view!");
        }
#line 1079
        return;
      }
    } else {
      {
#line 1078
      CursesErrorMsg((char *)"No display command is mapped to this view!");
      }
#line 1079
      return;
    }
  } else {
    {
#line 1078
    CursesErrorMsg((char *)"No display command is mapped to this view!");
    }
#line 1079
    return;
  }
#line 1083
  if ((ZeGopher->Localfile)->len < 0) {
#line 1083
    tmp___8 = (char *)((void *)0);
  } else {
#line 1083
    tmp___8 = (ZeGopher->Localfile)->data;
  }
#line 1083
  if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 1083
    goto _L;
  } else {
#line 1083
    if ((ZeGopher->Localview)->len < 0) {
#line 1083
      tmp___9 = (char *)((void *)0);
    } else {
#line 1083
      tmp___9 = (ZeGopher->Localview)->data;
    }
#line 1083
    if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
#line 1083
      goto _L;
    } else {
#line 1083
      if ((ZeGopher->Localview)->len < 0) {
#line 1083
        tmp___10 = (char *)((void *)0);
      } else {
#line 1083
        tmp___10 = (ZeGopher->Localview)->data;
      }
      {
#line 1083
      tmp___11 = strcmp((char const   *)tmp___10, (char const   *)view);
      }
#line 1083
      if (tmp___11 != 0) {
        _L: /* CIL Label */ 
#line 1088
        if ((int )inputline___0[0] == 124) {
          {
#line 1093
          tmpfile___0 = popen((char const   *)(inputline___0 + 1), "w");
          }
#line 1093
          if ((unsigned long )tmpfile___0 == (unsigned long )((void *)0)) {
            {
#line 1095
            snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"Coultn\'t execute %s",
                     inputline___0);
#line 1097
            CursesErrorMsg(buf);
            }
#line 1098
            return;
          }
          {
#line 1100
          WritePipe = 1;
#line 1101
          CURexit(CursesScreen);
          }
        } else {
          {
#line 1108
          mkstemp_fd = mkstemp(mkstemp_template);
#line 1109
          tmpfilename = strdup((char const   *)(mkstemp_template));
#line 1110
          tmpfile___0 = fdopen(mkstemp_fd, "w");
          }
#line 1125
          if ((unsigned long )tmpfile___0 == (unsigned long )((void *)0)) {
            {
#line 1126
            CURexit(CursesScreen);
#line 1127
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t make a tmp file!\n");
#line 1127
            CleanupandExit(-1);
            }
          }
#line 1130
          if ((ZeGopher->Localfile)->len < 0) {
#line 1130
            tmp___2 = (char *)((void *)0);
          } else {
#line 1130
            tmp___2 = (ZeGopher->Localfile)->data;
          }
#line 1130
          if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 1130
            if ((ZeGopher->Localview)->len < 0) {
#line 1130
              tmp___3 = (char *)((void *)0);
            } else {
#line 1130
              tmp___3 = (ZeGopher->Localview)->data;
            }
#line 1130
            if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 1130
              if ((ZeGopher->Localview)->len < 0) {
#line 1130
                tmp___4 = (char *)((void *)0);
              } else {
#line 1130
                tmp___4 = (ZeGopher->Localview)->data;
              }
              {
#line 1130
              tmp___5 = strcmp((char const   *)tmp___4, (char const   *)view);
              }
#line 1130
              if (tmp___5 != 0) {
#line 1133
                if ((ZeGopher->Localfile)->len < 0) {
#line 1133
                  tmp___1 = (char *)((void *)0);
                } else {
#line 1133
                  tmp___1 = (ZeGopher->Localfile)->data;
                }
                {
#line 1133
                unlink((char const   *)tmp___1);
                }
              }
            }
          }
          {
#line 1134
          STRset(ZeGopher->Localfile, tmpfilename);
          }
        }
        {
#line 1137
        tmp___7 = strlen((char const   *)(inputline___0));
        }
#line 1137
        if ((int )inputline___0[tmp___7 - 1UL] == 38) {
          {
#line 1138
          tmp___6 = strlen((char const   *)(inputline___0));
#line 1138
          inputline___0[tmp___6 - 1UL] = (char )'\000';
#line 1139
          ForkOff = 1;
          }
        }
#line 1144
        if (ForkOff) {
          {
#line 1145
          Child = fork();
          }
#line 1145
          if (Child < 0) {
            {
#line 1147
            CursesErrorMsg((char *)"Fork Error!");
            }
          } else
#line 1149
          if (Child > 0) {
            {
#line 1152
            CURenter(CursesScreen);
            }
#line 1153
            return;
          }
        }
        {
#line 1163
        GS2FileSucceeded = GStoFile(ZeGopher, tmpfile___0, view, & twirl);
        }
#line 1165
        if (! GS2FileSucceeded) {
          {
#line 1166
          STRset(ZeGopher->Localfile, (char *)((void *)0));
#line 1167
          STRset(ZeGopher->Localview, (char *)((void *)0));
          }
        } else {
          {
#line 1170
          STRset(ZeGopher->Localview, view);
          }
        }
#line 1173
        if (WritePipe) {
          {
#line 1174
          pclose(tmpfile___0);
          }
        } else {
          {
#line 1176
          fclose(tmpfile___0);
          }
        }
      }
    }
  }
  {
#line 1180
  logrequest((char *)"ARRIVED AT", ZeGopher);
  }
#line 1182
  if (! WritePipe) {
#line 1182
    if (GS2FileSucceeded) {
      {
#line 1183
      GSdisplay(ZeGopher);
      }
    }
  }
#line 1184
  if (! GS2FileSucceeded) {
    {
#line 1185
    unlink((char const   *)tmpfilename);
    }
  }
#line 1196
  if ((unsigned long )tmpfilename != (unsigned long )((void *)0)) {
    {
#line 1196
    free((void *)tmpfilename);
    }
  }
#line 1198
  if (ForkOff) {
    {
#line 1199
    exit(-1);
    }
  }
  {
#line 1201
  CURenter(CursesScreen);
  }
#line 1202
  return;
}
}
#line 1211 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
void do_movie(GopherStruct *ZeGopher ) 
{ 


  {
  {
#line 1214
  showfile(ZeGopher);
  }
#line 1215
  return;
}
}
#line 1224 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
void pushgopher(GopherDirObj *ZeDir ) 
{ 


  {
#line 1228
  OldDirs[iLevel] = ZeDir;
#line 1229
  iLevel ++;
#line 1230
  return;
}
}
#line 1236 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
int popgopher(GopherDirObj **ZeDir ) 
{ 


  {
#line 1240
  if (iLevel == 0) {
#line 1241
    return (-1);
  }
#line 1243
  iLevel --;
#line 1245
  *ZeDir = OldDirs[iLevel];
#line 1247
  return (0);
}
}
#line 1262 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
void check_sock(int sockfd , char *host , int port ) 
{ 
  char DispString[80] ;
  char DispString2[80] ;
  char *DispStrings[4] ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 1269
  DispStrings[3] = (char *)((void *)0);
#line 1271
  if (sockfd < 0) {
    {
#line 1272
    sprintf((char */* __restrict  */)(DispString), (char const   */* __restrict  */)"Cannot connect to host %.40s, port %d.",
            host, port);
    }
    {
#line 1277
    if (sockfd == -2) {
#line 1277
      goto case_neg_2;
    }
#line 1280
    if (sockfd == -3) {
#line 1280
      goto case_neg_3;
    }
#line 1283
    if (sockfd == -4) {
#line 1283
      goto case_neg_4;
    }
#line 1309
    goto switch_default;
    case_neg_2: /* CIL Label */ 
#line 1278
    DispStrings[2] = (char *)"Hostname is unknown.";
#line 1279
    goto switch_break;
    case_neg_3: /* CIL Label */ 
#line 1281
    DispStrings[2] = (char *)"Unable to allocate a socket.";
#line 1282
    goto switch_break;
    case_neg_4: /* CIL Label */ 
    {
#line 1297
    tmp = __errno_location();
#line 1297
    tmp___0 = strerror(*tmp);
#line 1297
    sprintf((char */* __restrict  */)(DispString2), (char const   */* __restrict  */)"Connection failed: %s.",
            tmp___0);
#line 1303
    DispStrings[2] = DispString2;
    }
    switch_default: /* CIL Label */ 
#line 1310
    DispStrings[2] = (char *)"Unknown error.";
    switch_break: /* CIL Label */ ;
    }
    {
#line 1312
    DispStrings[0] = DispString;
#line 1313
    DispStrings[1] = (char *)"";
#line 1314
    DispStrings[3] = (char *)((void *)0);
#line 1316
    CURBeep(CursesScreen);
#line 1318
    CURDialog(CursesScreen, (char *)"Network Error", DispStrings);
    }
  }
#line 1320
  return;
}
}
#line 1323 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
BOOLEAN ReallyQuit(void) 
{ 
  char yesno[3] ;

  {
  {
#line 1328
  yesno[0] = (char )'y';
#line 1329
  yesno[1] = (char )'\000';
#line 1331
  CURgetYesorNo(CursesScreen, (char *)"Really quit (y/n) ?", yesno);
  }
#line 1332
  if ((int )yesno[0] == 121) {
#line 1333
    return (1);
  }
#line 1336
  return (0);
}
}
#line 1340 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
void CleanupandExit(int exitval ) 
{ 
  GopherDirObj *gd ;
  int tmp ;

  {
  {
#line 1349
  signal(28, (void (*)(int  ))1);
#line 1351
  signal(2, (void (*)(int  ))1);
#line 1352
  signal(3, (void (*)(int  ))1);
#line 1353
  signal(13, (void (*)(int  ))1);
#line 1354
  signal(15, (void (*)(int  ))1);
#line 1355
  signal(1, (void (*)(int  ))1);
  }
#line 1358
  if (CursesScreen) {
    {
#line 1359
    CURexit(CursesScreen);
    }
  }
#line 1361
  if (ChangedDefs) {
    {
#line 1362
    RCtoFile(GlobalRC);
    }
  }
  {
#line 1364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1365
    if ((unsigned long )CurrentDir != (unsigned long )((void *)0)) {
#line 1365
      if ((unsigned long )CurrentDir != (unsigned long )GlobalRC->Bookmarks) {
        {
#line 1366
        GDdestroy(CurrentDir);
        }
      }
    }
    {
#line 1364
    tmp = popgopher(& CurrentDir);
    }
#line 1364
    if (! (tmp != -1)) {
#line 1364
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1370
  if (GlobalRC) {
#line 1371
    gd = GlobalRC->Bookmarks;
#line 1372
    if ((unsigned long )gd != (unsigned long )((void *)0)) {
      {
#line 1373
      GDdestroy(gd);
      }
    }
  }
  {
#line 1375
  logrequest((char *)"EXIT", (GopherObj *)((void *)0));
#line 1379
  exit(exitval);
  }
}
}
#line 1388 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
void controlc_old(int sig ) 
{ 
  BOOLEAN tmp ;
  __sighandler_t tmp___0 ;

  {
#line 1402
  if ((unsigned long )CurrentDir == (unsigned long )((void *)0)) {
    {
#line 1403
    CURexit(CursesScreen);
#line 1404
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gopher: Nothing received for main menu, can\'t continue\n");
#line 1405
    CleanupandExit(1);
    }
  } else
#line 1402
  if ((CurrentDir->Gophers)->Top <= 0) {
    {
#line 1403
    CURexit(CursesScreen);
#line 1404
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gopher: Nothing received for main menu, can\'t continue\n");
#line 1405
    CleanupandExit(1);
    }
  }
  {
#line 1408
  tmp = ReallyQuit();
  }
#line 1408
  if (tmp) {
    {
#line 1410
    CleanupandExit(0);
    }
  } else {
    {
#line 1413
    CURresize(CursesScreen);
    }
  }
  {
#line 1422
  tmp___0 = signal(2, & controlc);
  }
#line 1422
  if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 1423
    perror("signal died:\n");
#line 1423
    CleanupandExit(-1);
    }
  }
  {
#line 1427
  longjmp((struct __jmp_buf_tag *)(Jmpenv), 1);
  }
}
}
#line 1435 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
void sizechange(int sig ) 
{ 
  int lines ;
  int cols ;

  {
#line 1444
  lines = LINES;
#line 1445
  cols = COLS;
#line 1472
  return;
}
}
#line 1482 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
void Initialize(void) 
{ 
  char *tmp ;
  int tmp___0 ;
  __sighandler_t tmp___1 ;
  __sighandler_t tmp___2 ;
  __sighandler_t tmp___3 ;
  __sighandler_t tmp___4 ;
  __sighandler_t tmp___5 ;
  __sighandler_t tmp___6 ;
  int result ;
  char *mess[2] ;
  boolean tmp___7 ;

  {
  {
#line 1487
  GlobalRC = RCnew();
#line 1491
  RCfromUser(GlobalRC);
#line 1496
  CursesScreen = CURnew();
  }
#line 1498
  if ((CursesScreen->Termtype)->len < 0) {
#line 1498
    tmp = (char *)((void *)0);
  } else {
#line 1498
    tmp = (CursesScreen->Termtype)->data;
  }
  {
#line 1498
  tmp___0 = strcmp((char const   *)tmp, "unknown");
  }
#line 1498
  if (tmp___0 == 0) {
    {
#line 1499
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"I don\'t understand your terminal type\n");
#line 1499
    CleanupandExit(-1);
    }
  }
  {
#line 1506
  CursesScreen->sigwinch = (void (*)())(& sizechange);
#line 1507
  tmp___1 = signal(28, & sizechange);
  }
#line 1507
  if ((unsigned long )tmp___1 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 1508
    perror("signal died:\n");
#line 1508
    CleanupandExit(-1);
    }
  }
  {
#line 1513
  tmp___2 = signal(2, & controlc);
  }
#line 1513
  if ((unsigned long )tmp___2 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 1514
    perror("signal died:\n");
#line 1514
    CleanupandExit(-1);
    }
  }
  {
#line 1517
  tmp___3 = signal(3, & CleanupandExit);
  }
#line 1517
  if ((unsigned long )tmp___3 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 1518
    perror("signal died:\n");
#line 1518
    CleanupandExit(-1);
    }
  }
  {
#line 1521
  tmp___4 = signal(13, (void (*)(int  ))1);
  }
#line 1521
  if ((unsigned long )tmp___4 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 1522
    perror("signal died:\n");
#line 1522
    CleanupandExit(-1);
    }
  }
  {
#line 1525
  tmp___5 = signal(15, & CleanupandExit);
  }
#line 1525
  if ((unsigned long )tmp___5 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 1526
    perror("signal died:\n");
#line 1526
    CleanupandExit(-1);
    }
  }
  {
#line 1529
  tmp___6 = signal(1, & CleanupandExit);
  }
#line 1529
  if ((unsigned long )tmp___6 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 1530
    perror("signal died:\n");
#line 1530
    CleanupandExit(-1);
    }
  }
  {
#line 1536
  CURenter(CursesScreen);
#line 1540
  tmp___7 = RCisGlobalNew();
  }
#line 1540
  if (tmp___7) {
    {
#line 1543
    mess[0] = (char *)"A new configuration is available.  Load it?";
#line 1544
    mess[1] = (char *)((void *)0);
#line 1547
    result = CURDialog(CursesScreen, (char *)"", mess);
    }
#line 1549
    if (result == 0) {
      {
#line 1551
      RCreadGlobalRC(GlobalRC);
      }
    }
#line 1553
    ChangedDefs = 1;
  }
#line 1556
  return;
}
}
#line 1570
void SetOptions(void) ;
#line 1570 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
static char **OptionNewApp  =    (char **)((void *)0);
#line 1570 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
static char **OptionsMenu  =    (char **)((void *)0);
#line 1571 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
static char **noyes  =    (char **)((void *)0);
#line 1572 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
static char **printchoice  =    (char **)((void *)0);
#line 1564 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
void SetOptions(void) 
{ 
  int choice ;
  int restricted ;
  char *shell ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  Requestitem *items[3] ;
  Requestitem bold ;
  Requestitem printer ;
  int tmp___6 ;
  char **gplusviews ;
  int i ;
  int numoptions ;
  RCMapObj *rcm ;
  char **Responses ;
  char *zetitle ;
  void *tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char tmpstr[512] ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int i___0 ;
  char *Responses___0[4] ;
  void *tmp___17 ;
  char tmpstr___0[512] ;
  int tmp___18 ;

  {
#line 1567
  restricted = 0;
#line 1574
  if ((unsigned long )OptionNewApp == (unsigned long )((void *)0)) {
    {
#line 1575
    tmp = malloc(sizeof(char *) * 4UL);
#line 1575
    OptionNewApp = (char **)tmp;
#line 1576
    *(OptionNewApp + 0) = (char *)"Content-Type Name";
#line 1577
    *(OptionNewApp + 1) = (char *)"Display Application";
#line 1578
    *(OptionNewApp + 2) = (char *)"Printing Application";
#line 1578
    *(OptionNewApp + 3) = (char *)((void *)0);
    }
  }
#line 1582
  if ((unsigned long )OptionsMenu == (unsigned long )((void *)0)) {
    {
#line 1583
    tmp___0 = malloc(sizeof(char *) * 5UL);
#line 1583
    OptionsMenu = (char **)tmp___0;
#line 1584
    *(OptionsMenu + 0) = (char *)"General Options";
#line 1585
    *(OptionsMenu + 1) = (char *)"Configure Display Applications";
#line 1586
    *(OptionsMenu + 2) = (char *)"Configure Printing Applications";
#line 1587
    *(OptionsMenu + 3) = (char *)"Define New Content-Type";
#line 1588
    *(OptionsMenu + 4) = (char *)((void *)0);
    }
  }
#line 1590
  if ((unsigned long )noyes == (unsigned long )((void *)0)) {
    {
#line 1591
    tmp___1 = malloc(sizeof(char *) * 3UL);
#line 1591
    noyes = (char **)tmp___1;
#line 1592
    *(noyes + 0) = (char *)"No";
#line 1593
    *(noyes + 1) = (char *)"Yes";
#line 1594
    *(noyes + 2) = (char *)((void *)0);
    }
  }
#line 1596
  if ((unsigned long )printchoice == (unsigned long )((void *)0)) {
    {
#line 1597
    tmp___2 = malloc(sizeof(char *) * 3UL);
#line 1597
    printchoice = (char **)tmp___2;
#line 1598
    *(printchoice + 0) = (char *)"Default System Printer";
#line 1599
    *(printchoice + 1) = (char *)"ANSI attached Printer";
#line 1600
    *(printchoice + 2) = (char *)((void *)0);
    }
  }
  {
#line 1609
  shell = getenv("SHELL");
  }
#line 1609
  if ((unsigned long )shell == (unsigned long )((void *)0)) {
#line 1609
    tmp___5 = 1;
  } else {
    {
#line 1609
    tmp___3 = strlen((char const   *)shell);
#line 1609
    tmp___4 = strcmp((char const   *)((shell + tmp___3) - 3), "rsh");
    }
#line 1609
    if (tmp___4 == 0) {
#line 1609
      tmp___5 = 1;
    } else {
#line 1609
      tmp___5 = 0;
    }
  }
#line 1609
  restricted = tmp___5;
#line 1614
  if (SecureMode) {
    {
#line 1615
    CursesErrorMsg((char *)"Sorry, you are not allowed to set options in secure mode.");
    }
#line 1616
    return;
  } else
#line 1614
  if (NoShellMode) {
    {
#line 1615
    CursesErrorMsg((char *)"Sorry, you are not allowed to set options in secure mode.");
    }
#line 1616
    return;
  } else
#line 1614
  if (restricted) {
    {
#line 1615
    CursesErrorMsg((char *)"Sorry, you are not allowed to set options in secure mode.");
    }
#line 1616
    return;
  }
  {
#line 1620
  choice = CURChoice(CursesScreen, (char *)"Gopher Options", OptionsMenu, (char *)"Your Choice",
                     -1);
  }
#line 1623
  if (choice == -1) {
#line 1624
    return;
  }
  {
#line 1628
  if (choice == 0) {
#line 1628
    goto case_0;
  }
#line 1661
  if (choice == 2) {
#line 1661
    goto case_2;
  }
#line 1661
  if (choice == 1) {
#line 1661
    goto case_2;
  }
#line 1722
  if (choice == 3) {
#line 1722
    goto case_3;
  }
#line 1626
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1636
  bold.prompt = (char *)"Bold Search words in Builtin Pager";
#line 1637
  bold.thing = (Curreqtype )4;
#line 1638
  bold.choices = noyes;
#line 1639
  bold.chooseitem = GlobalRC->SearchBolding;
#line 1641
  printer.prompt = (char *)"Print to";
#line 1642
  printer.thing = (Curreqtype )4;
#line 1643
  printer.choices = printchoice;
#line 1644
  printer.chooseitem = GlobalRC->ANSIprinter;
#line 1647
  items[0] = & bold;
#line 1648
  items[1] = & printer;
#line 1649
  items[2] = (Requestitem *)((void *)0);
#line 1651
  tmp___6 = CURrequester(CursesScreen, (char *)"General Options", items);
  }
#line 1651
  if (tmp___6 == 0) {
#line 1652
    GlobalRC->SearchBolding = (items[0])->chooseitem;
#line 1653
    GlobalRC->ANSIprinter = (items[1])->chooseitem;
#line 1654
    ChangedDefs = 1;
  }
#line 1657
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1672
  numoptions = (GlobalRC->commands)->Top;
#line 1673
  tmp___7 = malloc(sizeof(char *) * (unsigned long )(numoptions + 1));
#line 1673
  gplusviews = (char **)tmp___7;
#line 1674
  tmp___8 = malloc(sizeof(char *) * (unsigned long )(numoptions + 1));
#line 1674
  Responses = (char **)tmp___8;
#line 1676
  i = 0;
  }
  {
#line 1676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1676
    if (! (i < numoptions)) {
#line 1676
      goto while_break;
    }
#line 1677
    rcm = (RCMapObj *)*((GlobalRC->commands)->objects + i);
#line 1678
    if ((rcm->view)->len < 0) {
#line 1678
      tmp___9 = (char *)((void *)0);
    } else {
#line 1678
      tmp___9 = (rcm->view)->data;
    }
    {
#line 1678
    *(gplusviews + i) = tmp___9;
#line 1679
    tmp___10 = malloc(sizeof(char ) * 200UL);
#line 1679
    *(Responses + i) = (char *)tmp___10;
    }
#line 1680
    if (choice == 1) {
#line 1681
      if ((rcm->displaycmd)->len < 0) {
#line 1681
        tmp___11 = (char *)((void *)0);
      } else {
#line 1681
        tmp___11 = (rcm->displaycmd)->data;
      }
      {
#line 1681
      strcpy((char */* __restrict  */)*(Responses + i), (char const   */* __restrict  */)tmp___11);
      }
    } else {
#line 1683
      if ((rcm->printcmd)->len < 0) {
#line 1683
        tmp___12 = (char *)((void *)0);
      } else {
#line 1683
        tmp___12 = (rcm->printcmd)->data;
      }
      {
#line 1683
      strcpy((char */* __restrict  */)*(Responses + i), (char const   */* __restrict  */)tmp___12);
      }
    }
#line 1676
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1685
  *(gplusviews + i) = (char *)((void *)0);
#line 1686
  *(Responses + i) = (char *)((void *)0);
#line 1688
  if (choice == 1) {
#line 1689
    zetitle = (char *)"Configure Display Applications";
  } else {
#line 1691
    zetitle = (char *)"Configure Printing Applications";
  }
  {
#line 1693
  tmp___16 = CURRequest(CursesScreen, zetitle, gplusviews, Responses);
  }
#line 1693
  if (tmp___16 == 0) {
    {
#line 1697
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1697
      tmp___15 = i;
#line 1697
      i --;
#line 1697
      if (! (tmp___15 > 0)) {
#line 1697
        goto while_break___0;
      }
#line 1698
      rcm = (RCMapObj *)*((GlobalRC->commands)->objects + i);
#line 1699
      if (choice == 1) {
#line 1701
        if ((rcm->printcmd)->len < 0) {
#line 1701
          tmp___13 = (char *)((void *)0);
        } else {
#line 1701
          tmp___13 = (rcm->printcmd)->data;
        }
        {
#line 1701
        sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"%s,%s,%s",
                *(gplusviews + i), *(Responses + i), tmp___13);
        }
      } else {
#line 1705
        if ((rcm->displaycmd)->len < 0) {
#line 1705
          tmp___14 = (char *)((void *)0);
        } else {
#line 1705
          tmp___14 = (rcm->displaycmd)->data;
        }
        {
#line 1705
        sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"%s,%s,%s",
                *(gplusviews + i), tmp___14, *(Responses + i));
        }
      }
      {
#line 1708
      RCMAfromLine(GlobalRC->commands, tmpstr);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1710
    ChangedDefs = 1;
  }
#line 1713
  i = 0;
  {
#line 1713
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1713
    if (! (i <= numoptions)) {
#line 1713
      goto while_break___1;
    }
#line 1714
    if (*(Responses + i)) {
      {
#line 1715
      free((void *)*(Responses + i));
      }
    }
#line 1713
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1716
  free((void *)Responses);
#line 1717
  free((void *)gplusviews);
  }
#line 1719
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1730
  i___0 = 0;
  {
#line 1730
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1730
    if (! (i___0 < 3)) {
#line 1730
      goto while_break___2;
    }
    {
#line 1731
    tmp___17 = malloc(sizeof(char ) * 200UL);
#line 1731
    Responses___0[i___0] = (char *)tmp___17;
#line 1732
    *(Responses___0[i___0] + 0) = (char )'\000';
#line 1730
    i___0 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1734
  Responses___0[3] = (char *)((void *)0);
#line 1736
  tmp___18 = CURRequest(CursesScreen, (char *)"Define New Content-Type", OptionNewApp,
                        Responses___0);
  }
#line 1736
  if (tmp___18 == 0) {
#line 1736
    if ((int )*(Responses___0[0]) != 0) {
      {
#line 1740
      sprintf((char */* __restrict  */)(tmpstr___0), (char const   */* __restrict  */)"%s,%s,%s",
              Responses___0[0], Responses___0[1], Responses___0[2]);
#line 1742
      RCMAfromLine(GlobalRC->commands, tmpstr___0);
#line 1743
      ChangedDefs = 1;
      }
    }
  }
#line 1746
  i___0 = 0;
  {
#line 1746
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1746
    if (! (i___0 < 3)) {
#line 1746
      goto while_break___3;
    }
    {
#line 1747
    free((void *)Responses___0[i___0]);
#line 1746
    i___0 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1748
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1752
  return;
}
}
#line 1756 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
static char *search_string  =    (char *)((void *)0);
#line 2787 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
int Load_Index(GopherObj *ZeGopher ) 
{ 
  int tmp ;

  {
  {
#line 2790
  Draw_Status((char *)"Searching...");
#line 2791
  wrefresh(stdscr);
#line 2793
  tmp = Load_Index_or_Dir(ZeGopher, Searchstring);
  }
#line 2793
  return (tmp);
}
}
#line 2796 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
int Load_Dir(GopherObj *ZeGopher ) 
{ 
  int tmp ;

  {
  {
#line 2799
  Searchstring = (char *)((void *)0);
#line 2800
  tmp = Load_Index_or_Dir(ZeGopher, (char *)((void *)0));
  }
#line 2800
  return (tmp);
}
}
#line 2810 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
static char DirTitle[512]  ;
#line 2804 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
int Load_Index_or_Dir(GopherObj *ZeGopher , char *Searchmungestr ) 
{ 
  int failed ;
  int sockfd ;
  int i ;
  int numbytes ;
  GopherDirObj *NewDir ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 2807
  failed = 0;
#line 2811
  NewDir = (GopherDirObj *)((void *)0);
#line 2814
  NewDir = GDnew(32);
#line 2817
  Draw_Status((char *)"Connecting...");
#line 2817
  wrefresh(stdscr);
#line 2820
  sockfd = GSconnect(ZeGopher);
  }
#line 2820
  if (sockfd < 0) {
#line 2822
    if ((ZeGopher->Host)->len < 0) {
#line 2822
      tmp = (char *)((void *)0);
    } else {
#line 2822
      tmp = (ZeGopher->Host)->data;
    }
    {
#line 2822
    check_sock(sockfd, tmp, ZeGopher->iPort);
#line 2823
    failed = 1;
    }
  } else {
#line 2826
    if ((int )ZeGopher->sFileType == 49) {
      {
#line 2827
      Draw_Status((char *)"Retrieving Directory...");
#line 2827
      wrefresh(stdscr);
#line 2828
      GStransmit(ZeGopher, sockfd, (char *)((void *)0), (char *)"$", (char *)((void *)0));
      }
    } else
#line 2830
    if ((int )ZeGopher->sFileType == 55) {
      {
#line 2831
      Draw_Status((char *)"Searching...");
#line 2831
      wrefresh(stdscr);
#line 2832
      GStransmit(ZeGopher, sockfd, Searchmungestr, (char *)"$", (char *)((void *)0));
      }
    }
    {
#line 2835
    numbytes = GSrecvHeader(ZeGopher, sockfd);
    }
#line 2837
    if (numbytes == 0) {
      {
#line 2839
      Gplus_Error(sockfd);
#line 2840
      failed = 1;
      }
#line 2841
      return (failed);
    }
#line 2844
    if (ZeGopher->isgplus) {
      {
#line 2845
      GDplusfromNet(NewDir, sockfd, & twirl);
      }
    } else {
      {
#line 2847
      GDfromNet(NewDir, sockfd, & twirl);
      }
    }
    {
#line 2849
    logrequest((char *)"ARRIVED AT", ZeGopher);
    }
#line 2852
    if ((NewDir->Gophers)->Top <= 0) {
      {
#line 2853
      CursesErrorMsg((char *)"Nothing available.");
#line 2854
      failed = 1;
#line 2855
      GDdestroy(NewDir);
#line 2856
      close(sockfd);
      }
#line 2857
      return (failed);
    }
#line 2860
    if ((int )ZeGopher->sFileType == 55) {
#line 2861
      if ((ZeGopher->Title)->len < 0) {
#line 2861
        tmp___0 = (char *)((void *)0);
      } else {
#line 2861
        tmp___0 = (ZeGopher->Title)->data;
      }
      {
#line 2861
      sprintf((char */* __restrict  */)(DirTitle), (char const   */* __restrict  */)"%s: %s",
              tmp___0, Searchmungestr);
#line 2862
      STRset(NewDir->Title, DirTitle);
      }
    } else {
#line 2865
      if ((ZeGopher->Title)->len < 0) {
#line 2865
        tmp___1 = (char *)((void *)0);
      } else {
#line 2865
        tmp___1 = (ZeGopher->Title)->data;
      }
      {
#line 2865
      STRset(NewDir->Title, tmp___1);
      }
    }
    {
#line 2867
    GDsetLocation(NewDir, ZeGopher);
    }
#line 2870
    if ((unsigned long )CurrentDir != (unsigned long )((void *)0)) {
      {
#line 2871
      pushgopher(CurrentDir);
      }
    }
#line 2873
    CurrentDir = NewDir;
  }
  {
#line 2876
  i = close(sockfd);
  }
#line 2877
  return (failed);
}
}
#line 2884 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
int process_request(GopherObj *ZeGopher ) 
{ 
  int failed ;
  char ImageCmd[128] ;
  char MovieCmd[128] ;
  char **askdata ;
  char **tmp ;
  boolean tmp___0 ;
  int tmp___1 ;
  char type ;
  char buf[512] ;
  boolean tmp___2 ;
  int tmp___3 ;
  boolean tmp___4 ;
  int tmp___5 ;
  boolean tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 2887
  failed = 0;
#line 2891
  if (ZeGopher->isask) {
    {
#line 2892
    tmp = AskBlock(ZeGopher);
#line 2892
    askdata = tmp;
    }
#line 2894
    if ((unsigned long )askdata == (unsigned long )((void *)0)) {
#line 2895
      return (1);
    }
    {
#line 2896
    GSsetAskdata(ZeGopher, askdata);
    }
  }
  {
#line 2902
  logrequest((char *)"GOING TO", ZeGopher);
  }
  {
#line 2905
  if ((int )ZeGopher->sFileType == -1) {
#line 2905
    goto case_neg_1;
  }
#line 2914
  if ((int )ZeGopher->sFileType == 105) {
#line 2914
    goto case_105;
  }
#line 2918
  if ((int )ZeGopher->sFileType == 48) {
#line 2918
    goto case_48;
  }
#line 2925
  if ((int )ZeGopher->sFileType == 73) {
#line 2925
    goto case_73;
  }
#line 2925
  if ((int )ZeGopher->sFileType == 103) {
#line 2925
    goto case_73;
  }
#line 2940
  if ((int )ZeGopher->sFileType == 77) {
#line 2940
    goto case_77;
  }
#line 2952
  if ((int )ZeGopher->sFileType == 57) {
#line 2952
    goto case_57;
  }
#line 2952
  if ((int )ZeGopher->sFileType == 53) {
#line 2952
    goto case_57;
  }
#line 2952
  if ((int )ZeGopher->sFileType == 52) {
#line 2952
    goto case_57;
  }
#line 2962
  if ((int )ZeGopher->sFileType == 49) {
#line 2962
    goto case_49;
  }
#line 2969
  if ((int )ZeGopher->sFileType == 84) {
#line 2969
    goto case_84;
  }
#line 2969
  if ((int )ZeGopher->sFileType == 56) {
#line 2969
    goto case_84;
  }
#line 2992
  if ((int )ZeGopher->sFileType == 55) {
#line 2992
    goto case_55;
  }
#line 3007
  if ((int )ZeGopher->sFileType == 50) {
#line 3007
    goto case_50;
  }
#line 3011
  if ((int )ZeGopher->sFileType == 115) {
#line 3011
    goto case_115;
  }
#line 3017
  if ((int )ZeGopher->sFileType == 59) {
#line 3017
    goto case_59;
  }
#line 3032
  if ((int )ZeGopher->sFileType == 104) {
#line 3032
    goto case_104;
  }
#line 2904
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 2906
  goto switch_break;
  case_105: /* CIL Label */ 
#line 2916
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 2919
  Draw_Status((char *)"Receiving Information...");
#line 2920
  wrefresh(stdscr);
#line 2921
  showfile(ZeGopher);
  }
#line 2922
  goto switch_break;
  case_73: /* CIL Label */ 
  case_103: /* CIL Label */ 
  {
#line 2926
  tmp___0 = RCdisplayCommand(GlobalRC, (char *)"Image", (char *)"", ImageCmd);
  }
#line 2926
  if (tmp___0) {
    {
#line 2926
    tmp___1 = strncasecmp((char const   *)(ImageCmd), "- none -", (size_t )8);
    }
#line 2926
    if (tmp___1) {
#line 2926
      if ((unsigned long )(ImageCmd) == (unsigned long )((void *)0)) {
        {
#line 2929
        CursesErrorMsg((char *)"Sorry, this machine doesn\'t support images");
        }
#line 2930
        goto switch_break;
      } else
#line 2926
      if ((unsigned long )(ImageCmd) == (unsigned long )((char *)0)) {
        {
#line 2929
        CursesErrorMsg((char *)"Sorry, this machine doesn\'t support images");
        }
#line 2930
        goto switch_break;
      }
    } else {
      {
#line 2929
      CursesErrorMsg((char *)"Sorry, this machine doesn\'t support images");
      }
#line 2930
      goto switch_break;
    }
  } else {
    {
#line 2929
    CursesErrorMsg((char *)"Sorry, this machine doesn\'t support images");
    }
#line 2930
    goto switch_break;
  }
  {
#line 2932
  Draw_Status((char *)"Receiving Image...");
#line 2933
  wrefresh(stdscr);
  }
#line 2934
  if (RemoteUser) {
    {
#line 2935
    Download_file(ZeGopher);
    }
  } else {
    {
#line 2937
    showfile(ZeGopher);
    }
  }
#line 2938
  goto switch_break;
  case_77: /* CIL Label */ 
#line 2941
  if (! SecureMode) {
    {
#line 2942
    Draw_Status((char *)"Receiving MIME File...");
#line 2943
    wrefresh(stdscr);
#line 2944
    showfile(ZeGopher);
    }
  } else {
    {
#line 2947
    CursesErrorMsg((char *)"Sorry, cannot display this file");
    }
  }
#line 2948
  goto switch_break;
  case_57: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
#line 2953
  if (RemoteUser) {
    {
#line 2954
    Draw_Status((char *)"Receiving File...");
#line 2955
    wrefresh(stdscr);
#line 2956
    Download_file(ZeGopher);
    }
  } else
#line 2953
  if (SecureMode) {
    {
#line 2954
    Draw_Status((char *)"Receiving File...");
#line 2955
    wrefresh(stdscr);
#line 2956
    Download_file(ZeGopher);
    }
  } else
#line 2953
  if (NoShellMode) {
    {
#line 2954
    Draw_Status((char *)"Receiving File...");
#line 2955
    wrefresh(stdscr);
#line 2956
    Download_file(ZeGopher);
    }
  } else {
    {
#line 2959
    Save_file(ZeGopher, (char *)((void *)0), (char *)((void *)0));
    }
  }
#line 2960
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 2963
  Draw_Status((char *)"Receiving Directory...");
#line 2964
  wrefresh(stdscr);
#line 2965
  failed = Load_Dir(ZeGopher);
  }
#line 2966
  goto switch_break;
  case_84: /* CIL Label */ 
  case_56: /* CIL Label */ 
#line 2973
  type = ZeGopher->sFileType;
#line 2973
  if ((int )type == 56) {
    {
#line 2973
    tmp___4 = RCdisplayCommand(GlobalRC, (char *)"Terminal/telnet", (char *)"", buf);
    }
#line 2973
    if (tmp___4) {
      {
#line 2973
      tmp___5 = strncasecmp((char const   *)(buf), "- none -", (size_t )8);
      }
#line 2973
      if (tmp___5) {
#line 2973
        if ((unsigned long )(buf) == (unsigned long )((void *)0)) {
          {
#line 2977
          CursesErrorMsg((char *)"Sorry, telnet is not available.");
          }
#line 2978
          goto switch_break;
        } else
#line 2973
        if ((int )buf[0] == 0) {
          {
#line 2977
          CursesErrorMsg((char *)"Sorry, telnet is not available.");
          }
#line 2978
          goto switch_break;
        } else {
#line 2973
          goto _L;
        }
      } else {
        {
#line 2977
        CursesErrorMsg((char *)"Sorry, telnet is not available.");
        }
#line 2978
        goto switch_break;
      }
    } else {
      {
#line 2977
      CursesErrorMsg((char *)"Sorry, telnet is not available.");
      }
#line 2978
      goto switch_break;
    }
  } else
  _L: /* CIL Label */ 
#line 2980
  if ((int )type == 84) {
    {
#line 2980
    tmp___2 = RCdisplayCommand(GlobalRC, (char *)"Terminal/tn3270", (char *)"", buf);
    }
#line 2980
    if (tmp___2) {
      {
#line 2980
      tmp___3 = strncasecmp((char const   *)(buf), "- none -", (size_t )8);
      }
#line 2980
      if (tmp___3) {
#line 2980
        if ((unsigned long )(buf) == (unsigned long )((void *)0)) {
          {
#line 2984
          CursesErrorMsg((char *)"Sorry, tn3270 is not available.");
          }
#line 2985
          goto switch_break;
        } else
#line 2980
        if ((int )buf[0] == 0) {
          {
#line 2984
          CursesErrorMsg((char *)"Sorry, tn3270 is not available.");
          }
#line 2985
          goto switch_break;
        } else {
          {
#line 2988
          do_tel_3270(ZeGopher);
          }
        }
      } else {
        {
#line 2984
        CursesErrorMsg((char *)"Sorry, tn3270 is not available.");
        }
#line 2985
        goto switch_break;
      }
    } else {
      {
#line 2984
      CursesErrorMsg((char *)"Sorry, tn3270 is not available.");
      }
#line 2985
      goto switch_break;
    }
  } else {
    {
#line 2988
    do_tel_3270(ZeGopher);
    }
  }
#line 2990
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 2993
  wrefresh(stdscr);
  }
#line 2994
  if (search_string) {
#line 2995
    Searchstring = search_string;
#line 2996
    search_string = (char *)((void *)0);
  } else {
    {
#line 2998
    Searchstring = do_index(ZeGopher);
    }
  }
  {
#line 3000
  Draw_Status((char *)"Searching Text...");
  }
#line 3001
  if ((unsigned long )Searchstring != (unsigned long )((void *)0)) {
    {
#line 3002
    failed = Load_Index(ZeGopher);
    }
  } else {
#line 3004
    failed = 1;
  }
#line 3005
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 3008
  do_cso(ZeGopher);
  }
#line 3009
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 3012
  Draw_Status((char *)"Receiving Sound...");
#line 3013
  wrefresh(stdscr);
#line 3014
  do_sound(ZeGopher);
  }
#line 3015
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 3018
  tmp___6 = RCdisplayCommand(GlobalRC, (char *)"video", (char *)"", MovieCmd);
  }
#line 3018
  if (tmp___6) {
    {
#line 3018
    tmp___7 = strncasecmp((char const   *)(MovieCmd), "- none -", (size_t )8);
    }
#line 3018
    if (tmp___7) {
#line 3018
      if ((unsigned long )(MovieCmd) == (unsigned long )((void *)0)) {
        {
#line 3021
        CursesErrorMsg((char *)"Sorry, this machine doesn\'t support movies");
        }
#line 3022
        goto switch_break;
      } else
#line 3018
      if ((unsigned long )(MovieCmd) == (unsigned long )((char *)0)) {
        {
#line 3021
        CursesErrorMsg((char *)"Sorry, this machine doesn\'t support movies");
        }
#line 3022
        goto switch_break;
      }
    } else {
      {
#line 3021
      CursesErrorMsg((char *)"Sorry, this machine doesn\'t support movies");
      }
#line 3022
      goto switch_break;
    }
  } else {
    {
#line 3021
    CursesErrorMsg((char *)"Sorry, this machine doesn\'t support movies");
    }
#line 3022
    goto switch_break;
  }
  {
#line 3024
  Draw_Status((char *)"Receiving Movie...");
#line 3025
  wrefresh(stdscr);
  }
#line 3026
  if (RemoteUser) {
    {
#line 3027
    Download_file(ZeGopher);
    }
  } else {
    {
#line 3029
    do_movie(ZeGopher);
    }
  }
#line 3030
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 3033
  Draw_Status((char *)"Receiving HTML page...");
#line 3034
  wrefresh(stdscr);
#line 3035
  do_html(ZeGopher);
  }
#line 3036
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3038
  if (ZeGopher->isask) {
#line 3038
    if ((ZeGopher->Localfile)->len < 0) {
#line 3038
      tmp___9 = (char *)((void *)0);
    } else {
#line 3038
      tmp___9 = (ZeGopher->Localfile)->data;
    }
#line 3038
    if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 3039
      if ((ZeGopher->Localfile)->len < 0) {
#line 3039
        tmp___8 = (char *)((void *)0);
      } else {
#line 3039
        tmp___8 = (ZeGopher->Localfile)->data;
      }
      {
#line 3039
      unlink((char const   *)tmp___8);
#line 3040
      STRset(ZeGopher->Localfile, (char *)((void *)0));
      }
    }
  }
  {
#line 3042
  GSsetAskdata(ZeGopher, (char **)((void *)0));
  }
#line 3043
  return (failed);
}
}
#line 3052 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/gopher.c"
void describe_gopher(char *banner , GopherStruct *ZeGopher , FILE *gripefile ) 
{ 
  char *tmpfilename ;
  char mkstemp_template[19] ;
  int mkstemp_fd ;
  FILE *tmpfile___0 ;
  Blockobj *bl ;
  int i ;
  int j ;
  int views ;
  GopherObj *infogs ;
  int tmp ;
  char *tmp___0 ;
  GopherObj *server ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  Blockobj *tmp___5 ;
  char *tmp___6 ;
  Blockobj *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *cp ;
  VIewobj *ZeView ;
  VIewobj *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *cp___0 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
  {
#line 3063
  mkstemp_template[0] = (char )'/';
#line 3063
  mkstemp_template[1] = (char )'t';
#line 3063
  mkstemp_template[2] = (char )'m';
#line 3063
  mkstemp_template[3] = (char )'p';
#line 3063
  mkstemp_template[4] = (char )'/';
#line 3063
  mkstemp_template[5] = (char )'g';
#line 3063
  mkstemp_template[6] = (char )'o';
#line 3063
  mkstemp_template[7] = (char )'p';
#line 3063
  mkstemp_template[8] = (char )'h';
#line 3063
  mkstemp_template[9] = (char )'e';
#line 3063
  mkstemp_template[10] = (char )'r';
#line 3063
  mkstemp_template[11] = (char )'-';
#line 3063
  mkstemp_template[12] = (char )'X';
#line 3063
  mkstemp_template[13] = (char )'X';
#line 3063
  mkstemp_template[14] = (char )'X';
#line 3063
  mkstemp_template[15] = (char )'X';
#line 3063
  mkstemp_template[16] = (char )'X';
#line 3063
  mkstemp_template[17] = (char )'X';
#line 3063
  mkstemp_template[18] = (char )'\000';
#line 3064
  mkstemp_fd = -1;
#line 3070
  infogs = GSnew();
#line 3071
  infogs->sFileType = (char )'0';
#line 3072
  STRset(infogs->Title, (char *)"Link Info");
#line 3074
  GSgetginfo(ZeGopher, 1);
  }
#line 3077
  if (! gripefile) {
#line 3078
    goto normal_describe;
  }
  {
#line 3079
  tmpfile___0 = gripefile;
#line 3080
  GSdestroy(infogs);
  }
#line 3081
  goto format_description;
  normal_describe: 
  {
#line 3090
  mkstemp_fd = mkstemp(mkstemp_template);
#line 3091
  tmpfilename = strdup((char const   *)(mkstemp_template));
#line 3092
  Gopenfile = tmpfilename;
#line 3093
  tmpfile___0 = fdopen(mkstemp_fd, "w");
#line 3099
  STRset(infogs->Localfile, tmpfilename);
#line 3100
  STRset(infogs->Localview, (char *)"text/plain");
  }
#line 3101
  if ((unsigned long )tmpfile___0 == (unsigned long )((void *)0)) {
    {
#line 3102
    CURexit(CursesScreen);
#line 3103
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t make a tmp file!\n");
#line 3103
    CleanupandExit(-1);
    }
  }
  {
#line 3106
  free((void *)tmpfilename);
  }
  format_description: 
  {
#line 3112
  tmp = fileno(tmpfile___0);
#line 3112
  GStoLink(ZeGopher, tmp, 1);
#line 3114
  tmp___0 = GSgetURL(ZeGopher, (char *)"");
#line 3114
  fprintf((FILE */* __restrict  */)tmpfile___0, (char const   */* __restrict  */)"<URL:%s>\n\n",
          tmp___0);
#line 3115
  fflush(tmpfile___0);
  }
#line 3117
  if (ZeGopher->isgplus) {
    {
#line 3120
    server = GSnew();
#line 3121
    GScpy(server, ZeGopher);
#line 3122
    STRset(server->Selstr, (char *)"");
#line 3123
    STRset(server->Localfile, (char *)"");
#line 3125
    fputc('\n', tmpfile___0);
#line 3127
    i = 0;
    }
    {
#line 3127
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3127
      tmp___9 = GSgetNumBlocks(ZeGopher);
      }
#line 3127
      if (! (i < tmp___9)) {
#line 3127
        goto while_break;
      }
      {
#line 3128
      tmp___7 = GSgetBlock(ZeGopher, i);
      }
#line 3128
      if ((tmp___7->Blockname)->len < 0) {
#line 3128
        tmp___6 = (char *)((void *)0);
      } else {
        {
#line 3128
        tmp___5 = GSgetBlock(ZeGopher, i);
#line 3128
        tmp___6 = (tmp___5->Blockname)->data;
        }
      }
      {
#line 3128
      tmp___8 = strcmp((char const   *)tmp___6, "ABSTRACT");
      }
#line 3128
      if (tmp___8 == 0) {
        {
#line 3129
        bl = GSgetBlock(ZeGopher, i);
        }
#line 3130
        if ((bl->Blockname)->len < 0) {
#line 3130
          tmp___1 = (char *)((void *)0);
        } else {
#line 3130
          tmp___1 = (bl->Blockname)->data;
        }
        {
#line 3130
        fprintf((FILE */* __restrict  */)tmpfile___0, (char const   */* __restrict  */)"%s\n---------\n\n",
                tmp___1);
#line 3131
        j = 0;
        }
        {
#line 3131
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 3131
          tmp___3 = BLgetNumLines(bl);
          }
#line 3131
          if (! (j < tmp___3)) {
#line 3131
            goto while_break___0;
          }
          {
#line 3132
          tmp___2 = BLgetLine(bl, j);
#line 3132
          fprintf((FILE */* __restrict  */)tmpfile___0, (char const   */* __restrict  */)"%s\n",
                  tmp___2);
#line 3131
          j ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 3134
        fprintf((FILE */* __restrict  */)tmpfile___0, (char const   */* __restrict  */)"\n");
        }
#line 3135
        goto while_break;
      }
#line 3127
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3139
    fprintf((FILE */* __restrict  */)tmpfile___0, (char const   */* __restrict  */)"Size       Language      Document Type\n");
#line 3140
    fprintf((FILE */* __restrict  */)tmpfile___0, (char const   */* __restrict  */)"---------- ------------- ----------------------------\n");
#line 3142
    views = 0;
    }
    {
#line 3142
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 3142
      tmp___16 = GSgetNumViews(ZeGopher);
      }
#line 3142
      if (! (views < tmp___16)) {
#line 3142
        goto while_break___1;
      }
      {
#line 3144
      tmp___10 = GSgetView(ZeGopher, views);
#line 3144
      ZeView = tmp___10;
      }
#line 3146
      if ((unsigned long )ZeView == (unsigned long )((void *)0)) {
#line 3147
        goto __Cont;
      }
#line 3149
      if ((ZeView->Size)->len < 0) {
#line 3149
        tmp___11 = (char *)((void *)0);
      } else {
#line 3149
        tmp___11 = (ZeView->Size)->data;
      }
#line 3149
      cp = tmp___11;
#line 3150
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
        {
#line 3151
        fprintf((FILE */* __restrict  */)tmpfile___0, (char const   */* __restrict  */)"%s",
                cp);
        }
      } else {
#line 3153
        cp = (char *)"";
      }
      {
#line 3155
      tmp___12 = strlen((char const   *)cp);
#line 3155
      i = (int )tmp___12;
      }
      {
#line 3155
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3155
        if (! (i < 11)) {
#line 3155
          goto while_break___2;
        }
        {
#line 3156
        fputc(' ', tmpfile___0);
#line 3155
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 3159
      cp = VIprettyLang(ZeView, (char *)"En_US");
      }
#line 3160
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
        {
#line 3161
        fprintf((FILE */* __restrict  */)tmpfile___0, (char const   */* __restrict  */)"%s",
                cp);
        }
      } else {
#line 3163
        if ((ZeView->Lang)->len < 0) {
#line 3163
          tmp___13 = (char *)((void *)0);
        } else {
#line 3163
          tmp___13 = (ZeView->Lang)->data;
        }
#line 3163
        cp = tmp___13;
      }
#line 3164
      if (cp) {
        {
#line 3164
        tmp___14 = strlen((char const   *)cp);
#line 3164
        i = (int )tmp___14;
        }
      } else {
#line 3164
        i = 0;
      }
      {
#line 3164
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3164
        if (! (i < 14)) {
#line 3164
          goto while_break___3;
        }
        {
#line 3165
        fputc(' ', tmpfile___0);
#line 3164
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3167
      if ((ZeView->Type)->len < 0) {
#line 3167
        tmp___15 = (char *)((void *)0);
      } else {
#line 3167
        tmp___15 = (ZeView->Type)->data;
      }
      {
#line 3167
      cp = tmp___15;
#line 3168
      fprintf((FILE */* __restrict  */)tmpfile___0, (char const   */* __restrict  */)"%s\n",
              cp);
      }
      __Cont: /* CIL Label */ 
#line 3142
      views ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3172
    i = 0;
    {
#line 3172
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 3172
      tmp___24 = GSgetNumBlocks(ZeGopher);
      }
#line 3172
      if (! (i < tmp___24)) {
#line 3172
        goto while_break___4;
      }
      {
#line 3173
      bl = GSgetBlock(ZeGopher, i);
      }
#line 3174
      if ((bl->Blockname)->len < 0) {
#line 3174
        tmp___22 = (char *)((void *)0);
      } else {
#line 3174
        tmp___22 = (bl->Blockname)->data;
      }
      {
#line 3174
      tmp___23 = strcmp((char const   *)tmp___22, "ADMIN");
      }
#line 3174
      if (tmp___23 == 0) {
        {
#line 3175
        fprintf((FILE */* __restrict  */)tmpfile___0, (char const   */* __restrict  */)"\n\nServer Information\n");
#line 3176
        fprintf((FILE */* __restrict  */)tmpfile___0, (char const   */* __restrict  */)"------------------\n");
#line 3177
        j = 0;
        }
        {
#line 3177
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 3177
          tmp___21 = BLgetNumLines(bl);
          }
#line 3177
          if (! (j < tmp___21)) {
#line 3177
            goto while_break___5;
          }
          {
#line 3178
          tmp___17 = BLgetLine(bl, j);
#line 3178
          cp___0 = tmp___17;
#line 3180
          tmp___18 = strncmp((char const   *)cp___0, "Admin:", (size_t )5);
          }
#line 3180
          if (tmp___18 != 0) {
            {
#line 3180
            tmp___19 = strncmp((char const   *)cp___0, "Mod-Date:", (size_t )9);
            }
#line 3180
            if (tmp___19 != 0) {
              {
#line 3180
              tmp___20 = strncmp((char const   *)cp___0, "TTL:", (size_t )4);
              }
#line 3180
              if (tmp___20 != 0) {
                {
#line 3183
                fprintf((FILE */* __restrict  */)tmpfile___0, (char const   */* __restrict  */)"%s\n",
                        cp___0);
                }
              }
            }
          }
#line 3177
          j ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 3186
        fprintf((FILE */* __restrict  */)tmpfile___0, (char const   */* __restrict  */)"\n");
        }
#line 3187
        goto while_break___4;
      }
#line 3172
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 3190
    GSdestroy(server);
    }
  }
#line 3194
  if (gripefile) {
#line 3195
    return;
  }
  {
#line 3197
  fclose(tmpfile___0);
#line 3199
  showfile(infogs);
#line 3201
  CURenter(CursesScreen);
#line 3203
  GSdestroy(infogs);
  }
#line 3204
  return;
}
}
#line 267 "/usr/include/curses.h"
extern chtype acs_map[] ;
#line 581
extern int beep(void) ;
#line 608
extern int echo(void) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 642
extern int intrflush(WINDOW * , _Bool  ) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 708
extern int nl(void) ;
#line 710
extern int nodelay(WINDOW * , _Bool  ) ;
#line 712
extern int nonl(void) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 288 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.h"
void CURinit(CursesObj *cur ) ;
#line 291
void CURrightline(CursesObj *cur , char *theline , int yval ) ;
#line 297
int CURoutchar(int c ) ;
#line 302
void CURsetGraphicsChars(CursesObj *cur , char *termtype ) ;
#line 304
int CURwgetch(CursesObj *cur , WINDOW *window ) ;
#line 763 "/usr/include/term.h"
extern char *tgetstr(char const   * , char ** ) ;
#line 765
extern int tgetent(char * , char const   * ) ;
#line 375 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
boolean wordwrap  =    0;
#line 382 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
CursesObj *CURnew(void) 
{ 
  CursesObj *cur ;
  void *tmp ;

  {
  {
#line 387
  tmp = malloc(sizeof(CursesObj ));
#line 387
  cur = (CursesObj *)tmp;
#line 389
  cur->Screen = (WINDOW *)((void *)0);
#line 390
  cur->Termtype = STRnew();
#line 391
  cur->Clearscreen = STRnew();
#line 392
  cur->AudibleBell = STRnew();
#line 393
  cur->Highlighton = STRnew();
#line 394
  cur->Highlightoff = STRnew();
#line 396
  cur->canUseACS = 0;
#line 397
  cur->inCurses = 0;
#line 398
  cur->sigtstp = (void (*)())((void (*)(int  ))-1);
#line 399
  cur->sigwinch = (void (*)())((void (*)(int  ))-1);
#line 401
  CURinit(cur);
  }
#line 403
  return (cur);
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
static char terminal[1024]  ;
#line 420 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
static char capabilities[1024]  ;
#line 421 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
static char *ptr  =    capabilities;
#line 412 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
void CURinit(CursesObj *cur ) 
{ 
  int err ;
  char *cp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 426
  tmp___0 = getenv("TERM");
  }
#line 426
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 427
    tmp = getenv("TERM");
#line 427
    STRset(cur->Termtype, tmp);
    }
  } else {
    {
#line 429
    STRset(cur->Termtype, (char *)"unknown");
    }
  }
#line 431
  if ((cur->Termtype)->len < 0) {
#line 431
    tmp___1 = (char *)((void *)0);
  } else {
#line 431
    tmp___1 = (cur->Termtype)->data;
  }
  {
#line 431
  err = tgetent(terminal, (char const   *)tmp___1);
  }
#line 433
  if (err != 1) {
    {
#line 434
    STRset(cur->Termtype, (char *)"unknown");
    }
  }
  {
#line 437
  tmp___2 = tgetstr("cl", & ptr);
#line 437
  cp = tmp___2;
  }
#line 437
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 438
    STRset(cur->Clearscreen, cp);
    }
  } else {
    {
#line 440
    STRset(cur->Clearscreen, (char *)"");
    }
  }
  {
#line 443
  tmp___3 = tgetstr("bl", & ptr);
#line 443
  cp = tmp___3;
  }
#line 443
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 444
    STRset(cur->AudibleBell, cp);
    }
  } else {
    {
#line 446
    STRset(cur->AudibleBell, (char *)"\a");
    }
  }
  {
#line 449
  tmp___5 = tgetstr("so", & ptr);
#line 449
  cp = tmp___5;
  }
#line 449
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 450
    STRset(cur->Highlighton, cp);
#line 451
    tmp___4 = tgetstr("se", & ptr);
#line 451
    cp = tmp___4;
    }
#line 451
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 452
      STRset(cur->Highlightoff, cp);
      }
    }
  } else {
    {
#line 454
    STRset(cur->Highlighton, (char *)"");
#line 455
    STRset(cur->Highlightoff, (char *)"");
    }
  }
  {
#line 459
  tmp___6 = tgetstr("as", & ptr);
  }
#line 459
  if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 460
    cur->canUseACS = 1;
  }
  {
#line 462
  cur->Screen = initscr();
#line 464
  cur->inCurses = 0;
  }
#line 466
  if ((cur->Termtype)->len < 0) {
#line 466
    tmp___7 = (char *)((void *)0);
  } else {
#line 466
    tmp___7 = (cur->Termtype)->data;
  }
  {
#line 466
  CURsetGraphicsChars(cur, tmp___7);
  }
#line 467
  return;
}
}
#line 475 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
static char *CURgraphicChars[14]  = 
#line 475
  {      (char *)"vtxxx",      (char *)"qxlkmjwvtun",      (char *)"xterm",      (char *)"qxlkmjwvtun", 
        (char *)"z29",      (char *)"aqfcedsuvtb",      (char *)"wyse50",      (char *)"zvrsqupwtyx", 
        (char *)"isc",      (char *)"D3Z?@Y+++++",      (char *)"sun-cmd",      (char *)"-|+++++++++", 
        (char *)((void *)0),      (char *)((void *)0)};
#line 485 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
void CURsetGraphicsChars(CursesObj *cur , char *termtype ) 
{ 
  char *term ;
  char *chars ;
  char termname___0[20] ;
  int count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 488
  cur->Box_hline = '-';
#line 489
  cur->Box_vline = '|';
#line 490
  cur->Box_ul = '+';
#line 491
  cur->Box_ur = '+';
#line 492
  cur->Box_ll = '+';
#line 493
  cur->Box_lr = '+';
#line 494
  cur->Box_tt = '+';
#line 495
  cur->Box_bt = '+';
#line 496
  cur->Box_lt = '+';
#line 497
  cur->Box_rt = '+';
#line 498
  cur->Box_ct = '+';
#line 502
  if (cur->canUseACS) {
    {
#line 506
    count = 0;
#line 508
    strcpy((char */* __restrict  */)(termname___0), (char const   */* __restrict  */)termtype);
#line 511
    tmp = strncasecmp((char const   *)(termname___0), "vt1", (size_t )3);
    }
#line 511
    if (tmp == 0) {
      {
#line 514
      strcpy((char */* __restrict  */)(termname___0), (char const   */* __restrict  */)"vtxxx");
      }
    } else {
      {
#line 511
      tmp___0 = strncasecmp((char const   *)(termname___0), "vt2", (size_t )3);
      }
#line 511
      if (tmp___0 == 0) {
        {
#line 514
        strcpy((char */* __restrict  */)(termname___0), (char const   */* __restrict  */)"vtxxx");
        }
      } else {
        {
#line 511
        tmp___1 = strncasecmp((char const   *)(termname___0), "vt3", (size_t )3);
        }
#line 511
        if (tmp___1 == 0) {
          {
#line 514
          strcpy((char */* __restrict  */)(termname___0), (char const   */* __restrict  */)"vtxxx");
          }
        }
      }
    }
    {
#line 516
    while (1) {
      while_continue: /* CIL Label */ ;
#line 516
      tmp___4 = count;
#line 516
      count ++;
#line 516
      term = CURgraphicChars[tmp___4];
#line 516
      if (! ((unsigned long )term != (unsigned long )((void *)0))) {
#line 516
        goto while_break;
      }
      {
#line 517
      tmp___2 = count;
#line 517
      count ++;
#line 517
      chars = CURgraphicChars[tmp___2];
#line 518
      tmp___3 = strcmp((char const   *)(termname___0), (char const   *)term);
      }
#line 518
      if (tmp___3 == 0) {
#line 520
        cur->Box_hline = (int )acs_map[(unsigned char )'q'];
#line 521
        cur->Box_vline = (int )acs_map[(unsigned char )'x'];
#line 522
        cur->Box_ul = (int )acs_map[(unsigned char )'l'];
#line 523
        cur->Box_ur = (int )acs_map[(unsigned char )'k'];
#line 524
        cur->Box_ll = (int )acs_map[(unsigned char )'m'];
#line 525
        cur->Box_lr = (int )acs_map[(unsigned char )'j'];
#line 526
        cur->Box_tt = (int )acs_map[(unsigned char )'w'];
#line 527
        cur->Box_bt = (int )acs_map[(unsigned char )'v'];
#line 528
        cur->Box_lt = (int )acs_map[(unsigned char )'t'];
#line 529
        cur->Box_rt = (int )acs_map[(unsigned char )'u'];
#line 530
        cur->Box_ct = (int )acs_map[(unsigned char )'n'];
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 549
  return;
}
}
#line 557 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
void CURenter(CursesObj *cur ) 
{ 
  char *tmp ;

  {
#line 561
  if (cur->inCurses == 1) {
#line 562
    return;
  }
#line 568
  if ((cur->Clearscreen)->len < 0) {
#line 568
    tmp = (char *)((void *)0);
  } else {
#line 568
    tmp = (cur->Clearscreen)->data;
  }
  {
#line 568
  tputs((char const   *)tmp, 1, & CURoutchar);
#line 569
  fflush(stdout);
#line 572
  cur->inCurses = 1;
#line 574
  CURwenter(cur, stdscr);
  }
#line 577
  if ((unsigned long )cur->sigwinch != (unsigned long )((void (*)(int  ))-1)) {
    {
#line 578
    signal(28, (void (*)(int  ))cur->sigwinch);
    }
  }
#line 581
  if ((unsigned long )cur->sigtstp != (unsigned long )((void (*)(int  ))-1)) {
    {
#line 582
    signal(20, (void (*)(int  ))cur->sigtstp);
    }
  }
#line 584
  return;
}
}
#line 590 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
void CURwenter(CursesObj *cur , WINDOW *win ) 
{ 


  {
  {
#line 593
  cbreak();
#line 594
  noecho();
#line 595
  nonl();
#line 597
  intrflush(win, (_Bool)0);
#line 598
  nodelay(win, (_Bool)0);
#line 601
  keypad(win, (_Bool)1);
  }
#line 605
  return;
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
void CURexit(CursesObj *cur ) 
{ 
  char *tmp ;
  __sighandler_t tmp___0 ;
  __sighandler_t tmp___1 ;

  {
#line 614
  if (! cur->inCurses) {
#line 615
    return;
  }
  {
#line 616
  cur->inCurses = 0;
#line 617
  echo();
#line 618
  nl();
#line 619
  endwin();
#line 623
  keypad(stdscr, (_Bool)0);
  }
#line 632
  if ((cur->Clearscreen)->len < 0) {
#line 632
    tmp = (char *)((void *)0);
  } else {
#line 632
    tmp = (cur->Clearscreen)->data;
  }
  {
#line 632
  tputs((char const   *)tmp, 1, & CURoutchar);
#line 633
  fflush(stdout);
#line 635
  tmp___0 = signal(20, (void (*)(int  ))0);
#line 635
  cur->sigtstp = (void (*)())tmp___0;
#line 639
  tmp___1 = signal(28, (void (*)(int  ))0);
#line 639
  cur->sigwinch = (void (*)())tmp___1;
  }
#line 642
  return;
}
}
#line 650 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
int CURoutchar(int c ) 
{ 


  {
  {
#line 656
  _IO_putc(c, stdout);
  }
#line 657
  return (c);
}
}
#line 663 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
void CURrightline(CursesObj *cur , char *theline , int yval ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 665
  tmp = strlen((char const   *)theline);
#line 665
  tmp___0 = wmove(stdscr, yval, (int )(((size_t )COLS - tmp) - 1UL));
  }
#line 665
  if (! (tmp___0 == -1)) {
    {
#line 665
    waddnstr(stdscr, (char const   *)theline, -1);
    }
  }
#line 666
  return;
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
void CURcenterline(CursesObj *cur , WINDOW *win , char *theline , int yval , int windowidth ,
                   boolean bright ) 
{ 
  char TrimmedLine[256] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 678
  strcpy((char */* __restrict  */)(TrimmedLine), (char const   */* __restrict  */)theline);
#line 681
  tmp = strlen((char const   *)theline);
  }
#line 681
  if (tmp > (size_t )windowidth) {
#line 682
    TrimmedLine[windowidth - 3] = (char )'.';
#line 683
    TrimmedLine[windowidth - 2] = (char )'.';
#line 684
    TrimmedLine[windowidth - 1] = (char )'.';
#line 685
    TrimmedLine[windowidth] = (char )'\000';
  }
  {
#line 688
  tmp___0 = strlen((char const   *)(TrimmedLine));
#line 688
  wmove(win, yval, (int )(((size_t )windowidth - tmp___0) / 2UL));
  }
#line 690
  if (bright) {
#line 691
    if (win) {
#line 691
      win->_attrs = 1UL << 16;
    }
  }
  {
#line 693
  waddnstr(win, (char const   *)(TrimmedLine), -1);
  }
#line 695
  if (bright) {
#line 696
    if (win) {
#line 696
      win->_attrs = 0UL;
    }
  }
#line 697
  return;
}
}
#line 707 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
int CURwgetstr(CursesObj *cur , WINDOW *win , char *inputline___0 , int maxlength ,
               boolean hidden ) 
{ 
  int pointer ;
  int curpointer ;
  int ch ;
  int y ;
  int x ;
  char *cp ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 710
  pointer = 0;
#line 711
  curpointer = 0;
#line 715
  if (win) {
#line 715
    win->_attrs = 1UL << 16;
  }
  {
#line 718
  while (1) {
    while_continue: /* CIL Label */ ;
#line 718
    if (! ((int )*(inputline___0 + pointer) != 0)) {
#line 718
      goto while_break;
    }
#line 719
    if (hidden) {
      {
#line 720
      waddch(win, (chtype const   )'*');
      }
    } else {
      {
#line 722
      waddch(win, (chtype const   )*(inputline___0 + pointer));
      }
    }
#line 723
    pointer ++;
#line 724
    curpointer ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 727
  wrefresh(win);
  }
  {
#line 729
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 730
    ch = CURwgetch(cur, win);
    }
    {
#line 736
    if (ch == 24) {
#line 736
      goto case_24;
    }
#line 736
    if (ch == 10) {
#line 736
      goto case_24;
    }
#line 743
    if (ch == 8) {
#line 743
      goto case_8;
    }
#line 772
    if (ch == 1) {
#line 772
      goto case_1;
    }
#line 779
    if (ch == 5) {
#line 779
      goto case_5;
    }
#line 786
    if (ch == 7) {
#line 786
      goto case_7;
    }
#line 791
    if (ch == 11) {
#line 791
      goto case_11;
    }
#line 803
    if (ch == 21) {
#line 803
      goto case_21;
    }
#line 817
    if (ch == 260) {
#line 817
      goto case_260;
    }
#line 826
    if (ch == 261) {
#line 826
      goto case_261;
    }
#line 835
    goto switch_default;
    case_24: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 738
    *(inputline___0 + pointer) = (char )'\000';
#line 739
    if (win) {
#line 739
      win->_attrs = 0UL;
    }
#line 740
    return (ch);
#line 741
    goto switch_break;
    case_8: /* CIL Label */ 
#line 744
    if (curpointer > 0) {
#line 747
      if (win) {
#line 747
        y = (int )win->_cury;
      } else {
#line 747
        y = -1;
      }
#line 747
      if (win) {
#line 747
        x = (int )win->_curx;
      } else {
#line 747
        x = -1;
      }
      {
#line 748
      wmove(win, y, x - 1);
#line 752
      cp = (inputline___0 + curpointer) - 1;
      }
      {
#line 752
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 752
        if (! ((int )*cp != 0)) {
#line 752
          goto while_break___1;
        }
#line 753
        *cp = *(cp + sizeof(char ));
#line 754
        if ((int )*cp != 0) {
#line 755
          if (hidden) {
            {
#line 756
            waddch(win, (chtype const   )'*');
            }
          } else {
            {
#line 758
            waddch(win, (chtype const   )*cp);
            }
          }
        }
#line 752
        cp ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 761
      *cp = (char )'\000';
#line 762
      waddch(win, (chtype const   )' ');
#line 764
      pointer --;
#line 765
      curpointer --;
#line 767
      wmove(win, y, x - 1);
#line 768
      wrefresh(win);
      }
    }
#line 770
    goto switch_break;
    case_1: /* CIL Label */ 
#line 773
    if (win) {
#line 773
      y = (int )win->_cury;
    } else {
#line 773
      y = -1;
    }
#line 773
    if (win) {
#line 773
      x = (int )win->_curx;
    } else {
#line 773
      x = -1;
    }
    {
#line 774
    wmove(win, y, x - curpointer);
#line 775
    curpointer = 0;
#line 776
    wrefresh(win);
    }
#line 777
    goto switch_break;
    case_5: /* CIL Label */ 
#line 780
    if (win) {
#line 780
      y = (int )win->_cury;
    } else {
#line 780
      y = -1;
    }
#line 780
    if (win) {
#line 780
      x = (int )win->_curx;
    } else {
#line 780
      x = -1;
    }
    {
#line 781
    wmove(win, y, (x + pointer) - curpointer);
#line 782
    curpointer = pointer;
#line 783
    wrefresh(win);
    }
#line 784
    goto switch_break;
    case_7: /* CIL Label */ 
#line 787
    if (win) {
#line 787
      win->_attrs = 0UL;
    }
#line 788
    return (-1);
#line 789
    goto switch_break;
    case_11: /* CIL Label */ 
#line 792
    if (win) {
#line 792
      y = (int )win->_cury;
    } else {
#line 792
      y = -1;
    }
#line 792
    if (win) {
#line 792
      x = (int )win->_curx;
    } else {
#line 792
      x = -1;
    }
    {
#line 794
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 794
      if (! (curpointer < pointer)) {
#line 794
        goto while_break___2;
      }
      {
#line 795
      waddch(win, (chtype const   )' ');
#line 796
      pointer --;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 798
    *(inputline___0 + pointer) = (char )'\000';
#line 799
    wmove(win, y, x);
#line 800
    wrefresh(win);
    }
#line 801
    goto switch_break;
    case_21: /* CIL Label */ 
#line 804
    if (win) {
#line 804
      y = (int )win->_cury;
    } else {
#line 804
      y = -1;
    }
#line 804
    if (win) {
#line 804
      x = (int )win->_curx;
    } else {
#line 804
      x = -1;
    }
    {
#line 805
    wmove(win, y, x - curpointer);
    }
    {
#line 807
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 807
      if (! (pointer > 0)) {
#line 807
        goto while_break___3;
      }
      {
#line 808
      waddch(win, (chtype const   )' ');
#line 809
      pointer --;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 811
    *(inputline___0 + pointer) = (char )'\000';
#line 812
    wmove(win, y, x - curpointer);
#line 813
    curpointer = 0;
#line 814
    wrefresh(win);
    }
#line 815
    goto switch_break;
    case_260: /* CIL Label */ 
#line 818
    if (curpointer > 0) {
#line 819
      curpointer --;
#line 820
      if (win) {
#line 820
        y = (int )win->_cury;
      } else {
#line 820
        y = -1;
      }
#line 820
      if (win) {
#line 820
        x = (int )win->_curx;
      } else {
#line 820
        x = -1;
      }
      {
#line 821
      wmove(win, y, x - 1);
#line 822
      wrefresh(win);
      }
    }
#line 824
    goto switch_break;
    case_261: /* CIL Label */ 
#line 827
    if (curpointer < pointer) {
#line 828
      curpointer ++;
#line 829
      if (win) {
#line 829
        y = (int )win->_cury;
      } else {
#line 829
        y = -1;
      }
#line 829
      if (win) {
#line 829
        x = (int )win->_curx;
      } else {
#line 829
        x = -1;
      }
      {
#line 830
      wmove(win, y, x + 1);
#line 831
      wrefresh(win);
      }
    }
#line 833
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 836
    if (ch < 256) {
      {
#line 836
      tmp___1 = __ctype_b_loc();
      }
#line 836
      if ((int const   )*(*tmp___1 + ch) & 16384) {
#line 836
        if (curpointer >= maxlength) {
#line 838
          if (wordwrap) {
#line 840
            *(inputline___0 + curpointer) = (char )'\000';
#line 841
            if (win) {
#line 841
              win->_attrs = 0UL;
            }
            {
#line 842
            wrefresh(win);
            }
#line 843
            return (ch);
          } else {
            {
#line 845
            CURBeep(cur);
            }
          }
        } else {
#line 836
          goto _L___1;
        }
      } else {
#line 836
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 848
    if (ch < 256) {
      {
#line 848
      tmp___0 = __ctype_b_loc();
      }
#line 848
      if ((int const   )*(*tmp___0 + ch) & 16384) {
#line 850
        tmp = curpointer;
#line 850
        curpointer ++;
#line 850
        *(inputline___0 + tmp) = (char )ch;
#line 852
        if (curpointer > pointer) {
#line 853
          pointer = curpointer;
#line 854
          *(inputline___0 + (curpointer + 1)) = (char )'\000';
        }
#line 856
        if (hidden) {
          {
#line 857
          waddch(win, (chtype const   )'*');
          }
        } else {
          {
#line 859
          waddch(win, (chtype const   )ch);
          }
        }
        {
#line 860
        wrefresh(win);
        }
      } else {
#line 848
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 863
      if (win) {
#line 863
        win->_attrs = 0UL;
      }
#line 864
      return (ch);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 875 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
int CURwgetch(CursesObj *cur , WINDOW *window ) 
{ 
  int a ;
  int b ;
  int c ;
  __sighandler_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 880
  if (ControlCpressed) {
#line 881
    return ('\a');
  }
  {
#line 884
  tmp = signal(2, & controlcJmp);
  }
#line 884
  if ((unsigned long )tmp == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 885
    perror("signal died:\n");
#line 885
    exit(-1);
    }
  }
  {
#line 887
  tmp___0 = _setjmp((struct __jmp_buf_tag *)(Jmpenv));
  }
#line 887
  if (tmp___0) {
#line 890
    ControlCpressed = 0;
#line 891
    return ('\a');
  }
  {
#line 895
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 897
    c = wgetch(window);
#line 898
    reprimeControlc();
    }
    {
#line 902
    if (c == -1) {
#line 902
      goto case_neg_1;
    }
#line 908
    if (c == 23) {
#line 908
      goto case_23;
    }
#line 908
    if (c == 18) {
#line 908
      goto case_23;
    }
#line 908
    if (c == 12) {
#line 908
      goto case_23;
    }
#line 919
    if (c == 27) {
#line 919
      goto case_27;
    }
#line 967
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    {
#line 903
    CleanupandExit(-1);
    }
#line 904
    goto switch_break;
    case_23: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_12: /* CIL Label */ 
    {
#line 914
    wrefresh(curscr);
    }
#line 917
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 920
    b = wgetch(window);
    }
#line 921
    if (b == 91) {
      {
#line 922
      a = wgetch(window);
      }
    } else
#line 921
    if (b == 79) {
      {
#line 922
      a = wgetch(window);
      }
    } else {
#line 924
      a = b;
    }
    {
#line 927
    if (a == 65) {
#line 927
      goto case_65;
    }
#line 928
    if (a == 66) {
#line 928
      goto case_66;
    }
#line 929
    if (a == 67) {
#line 929
      goto case_67;
    }
#line 930
    if (a == 68) {
#line 930
      goto case_68;
    }
#line 932
    if (a == 77) {
#line 932
      goto case_77;
    }
#line 937
    if (a == 81) {
#line 937
      goto case_81;
    }
#line 942
    if (a == 50) {
#line 942
      goto case_50;
    }
#line 956
    if (a == 53) {
#line 956
      goto case_53;
    }
#line 960
    if (a == 54) {
#line 960
      goto case_54;
    }
#line 926
    goto switch_break___0;
    case_65: /* CIL Label */ 
#line 927
    c = 259;
#line 927
    goto switch_break___0;
    case_66: /* CIL Label */ 
#line 928
    c = 258;
#line 928
    goto switch_break___0;
    case_67: /* CIL Label */ 
#line 929
    c = 261;
#line 929
    goto switch_break___0;
    case_68: /* CIL Label */ 
#line 930
    c = 260;
#line 930
    goto switch_break___0;
    case_77: /* CIL Label */ 
#line 933
    if (b == 79) {
#line 934
      c = 343;
    }
#line 935
    goto switch_break___0;
    case_81: /* CIL Label */ 
#line 938
    if (b == 79) {
#line 939
      c = 363;
    }
#line 940
    goto switch_break___0;
    case_50: /* CIL Label */ 
#line 943
    if (b == 91) {
      {
#line 944
      b = wgetch(window);
      }
    }
    {
#line 946
    if (b == 56) {
#line 946
      goto case_56;
    }
#line 950
    if (b == 57) {
#line 950
      goto case_57;
    }
#line 945
    goto switch_break___1;
    case_56: /* CIL Label */ 
    {
#line 947
    tmp___1 = wgetch(window);
    }
#line 947
    if (tmp___1 == 126) {
#line 948
      c = 363;
    }
#line 949
    goto switch_break___1;
    case_57: /* CIL Label */ 
    {
#line 951
    tmp___2 = wgetch(window);
    }
#line 951
    if (tmp___2 == 126) {
#line 952
      c = 343;
    }
#line 953
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    case_53: /* CIL Label */ 
#line 957
    if (b == 91) {
      {
#line 957
      tmp___3 = wgetch(window);
      }
#line 957
      if (tmp___3 == 126) {
#line 958
        c = 339;
      }
    }
#line 959
    goto switch_break___0;
    case_54: /* CIL Label */ 
#line 961
    if (b == 91) {
      {
#line 961
      tmp___4 = wgetch(window);
      }
#line 961
      if (tmp___4 == 126) {
#line 962
        c = 338;
      }
    }
#line 963
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    switch_default: /* CIL Label */ 
#line 970
    if (c == 343) {
#line 971
      c = '\n';
    } else
#line 970
    if (c == 13) {
#line 971
      c = '\n';
    }
#line 974
    if (c == 8) {
#line 975
      return ('\b');
    } else
#line 974
    if (c == 127) {
#line 975
      return ('\b');
    } else
#line 974
    if (c == 263) {
#line 975
      return ('\b');
    }
#line 977
    return (c);
#line 978
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 984 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
int CURgetch(CursesObj *cur ) 
{ 
  int tmp ;

  {
  {
#line 987
  tmp = CURwgetch(cur, stdscr);
  }
#line 987
  return (tmp);
}
}
#line 994 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
void CURresize(CursesObj *cur ) 
{ 


  {
#line 997
  if (cur->inCurses) {
    {
#line 998
    CURexit(cur);
#line 999
    CURenter(cur);
    }
  }
#line 1001
  return;
}
}
#line 1012 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
int CURGetOneOption(CursesObj *cur , char *Title , char *OptionName , char *Response ) 
{ 
  int i ;
  Requestitem *items[2] ;
  Requestitem item ;

  {
  {
#line 1018
  items[0] = & item;
#line 1019
  items[1] = (Requestitem *)((void *)0);
#line 1021
  item.prompt = OptionName;
#line 1022
  item.stowage = Response;
#line 1023
  item.thing = (Curreqtype )2;
#line 1025
  i = CURrequester(cur, Title, items);
#line 1027
  wrefresh(stdscr);
  }
#line 1028
  return (i);
}
}
#line 1035 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
int CUROldGetOneOption(CursesObj *cur , char *OptionName , char *Response ) 
{ 
  int i ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 1040
  tmp = wmove(stdscr, LINES - 1, 0);
  }
#line 1040
  if (! (tmp == -1)) {
    {
#line 1040
    waddnstr(stdscr, (char const   *)OptionName, -1);
    }
  }
#line 1041
  if (stdscr) {
#line 1041
    stdscr->_attrs = 1UL << 16;
  }
  {
#line 1042
  waddnstr(stdscr, "    ", -1);
  }
#line 1043
  if (stdscr) {
#line 1043
    stdscr->_attrs = 0UL;
  }
  {
#line 1044
  wclrtoeol(stdscr);
#line 1045
  tmp___0 = strlen((char const   *)OptionName);
#line 1045
  wmove(stdscr, LINES - 1, (int )tmp___0);
#line 1047
  wrefresh(stdscr);
#line 1048
  i = CURwgetstr(cur, stdscr, Response, 4, 0);
  }
#line 1050
  return (i);
}
}
#line 1059 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
void CURgetYesorNo(CursesObj *cur , char *OptionName , char *Response ) 
{ 
  int c ;
  int posx ;
  int posy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1065
  tmp = wmove(stdscr, LINES - 1, 0);
  }
#line 1065
  if (! (tmp == -1)) {
    {
#line 1065
    waddnstr(stdscr, (char const   *)OptionName, -1);
    }
  }
  {
#line 1066
  wclrtoeol(stdscr);
  }
#line 1067
  if (cur->Screen) {
#line 1067
    posy = (int )(cur->Screen)->_cury;
  } else {
#line 1067
    posy = -1;
  }
#line 1067
  if (cur->Screen) {
#line 1067
    posx = (int )(cur->Screen)->_curx;
  } else {
#line 1067
    posx = -1;
  }
  {
#line 1068
  waddch(stdscr, (chtype const   )' ');
  }
#line 1070
  if ((int )*Response == 121) {
    {
#line 1071
    tmp___0 = wmove(stdscr, posy, posx + 1);
    }
#line 1071
    if (! (tmp___0 == -1)) {
      {
#line 1071
      waddnstr(stdscr, "y", -1);
      }
    }
  } else {
    {
#line 1073
    *Response = (char )'n';
#line 1074
    tmp___1 = wmove(stdscr, posy, posx + 1);
    }
#line 1074
    if (! (tmp___1 == -1)) {
      {
#line 1074
      waddnstr(stdscr, "n ", -1);
      }
    }
  }
  {
#line 1076
  wmove(stdscr, posy, posx + 1);
#line 1078
  wrefresh(stdscr);
  }
  {
#line 1080
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1081
    c = CURgetch(cur);
    }
#line 1083
    if (c == 121) {
      {
#line 1084
      tmp___2 = wmove(stdscr, posy, posx + 1);
      }
#line 1084
      if (! (tmp___2 == -1)) {
        {
#line 1084
        waddnstr(stdscr, "Yes", -1);
        }
      }
      {
#line 1085
      wmove(stdscr, posy, posx + 1);
#line 1086
      wrefresh(stdscr);
#line 1087
      *Response = (char )'y';
#line 1088
      *(Response + 1) = (char )'\000';
      }
#line 1089
      return;
    } else
#line 1091
    if (c == 110) {
      {
#line 1092
      tmp___3 = wmove(stdscr, posy, posx + 1);
      }
#line 1092
      if (! (tmp___3 == -1)) {
        {
#line 1092
        waddnstr(stdscr, "No ", -1);
        }
      }
      {
#line 1093
      wmove(stdscr, posy, posx + 1);
#line 1094
      wrefresh(stdscr);
#line 1095
      *Response = (char )'n';
#line 1096
      *(Response + 1) = (char )'\000';
      }
#line 1097
      return;
    } else
#line 1100
    if (c == 10) {
#line 1101
      return;
    } else
#line 1100
    if (c == 13) {
#line 1101
      return;
    } else {
      {
#line 1110
      CURBeep(cur);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1115 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
void CURBeep(CursesObj *cur ) 
{ 


  {
  {
#line 1120
  beep();
  }
#line 1126
  return;
}
}
#line 1129 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
void CURbox(CursesObj *cur , WINDOW *win , int height , int width ) 
{ 
  int i ;

  {
  {
#line 1134
  wmove(win, 0, 0);
#line 1135
  waddch(win, (chtype const   )cur->Box_ul);
#line 1136
  i = 0;
  }
  {
#line 1136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1136
    if (! (i < width - 2)) {
#line 1136
      goto while_break;
    }
    {
#line 1137
    waddch(win, (chtype const   )cur->Box_hline);
#line 1136
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1138
  waddch(win, (chtype const   )cur->Box_ur);
#line 1140
  i = 1;
  }
  {
#line 1140
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1140
    if (! (i < height - 1)) {
#line 1140
      goto while_break___0;
    }
    {
#line 1141
    wmove(win, i, 0);
#line 1142
    waddch(win, (chtype const   )cur->Box_vline);
#line 1143
    wmove(win, i, width - 1);
#line 1144
    waddch(win, (chtype const   )cur->Box_vline);
#line 1140
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1147
  wmove(win, height - 1, 0);
#line 1148
  waddch(win, (chtype const   )cur->Box_ll);
#line 1149
  i = 0;
  }
  {
#line 1149
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1149
    if (! (i < width - 2)) {
#line 1149
      goto while_break___1;
    }
    {
#line 1150
    waddch(win, (chtype const   )cur->Box_hline);
#line 1149
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1151
  waddch(win, (chtype const   )cur->Box_lr);
  }
#line 1152
  return;
}
}
#line 1155 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
void CURbutton(CursesObj *cur , WINDOW *win , char *Label , boolean bright ) 
{ 


  {
#line 1160
  if (bright) {
#line 1161
    if (win) {
#line 1161
      win->_attrs = 1UL << 16;
    }
  }
  {
#line 1163
  waddnstr(win, "[", -1);
#line 1164
  waddnstr(win, (char const   *)Label, -1);
#line 1165
  waddnstr(win, "]", -1);
  }
#line 1167
  if (bright) {
#line 1168
    if (win) {
#line 1168
      win->_attrs = 0UL;
    }
  }
#line 1171
  return;
}
}
#line 1175 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
int CURDialog(CursesObj *cur , char *Wintitle , char **Message ) 
{ 
  int i ;
  int messheight ;
  int messlength ;
  WINDOW *tempwin ;
  int winwidth ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int len ;
  size_t tmp___4 ;
  int j ;
  int tmp___5 ;

  {
#line 1179
  messheight = 0;
#line 1180
  messlength = 0;
  {
#line 1184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1184
    if (! ((unsigned long )*(Message + messheight) != (unsigned long )((void *)0))) {
#line 1184
      goto while_break;
    }
    {
#line 1185
    tmp___0 = strlen((char const   *)*(Message + messheight));
    }
#line 1185
    if (tmp___0 > (size_t )messlength) {
      {
#line 1186
      tmp = strlen((char const   *)*(Message + messheight));
#line 1186
      messlength = (int )tmp;
      }
    }
#line 1187
    messheight ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1190
  if (31 > messlength + 6) {
#line 1190
    winwidth = 31;
  } else {
#line 1190
    winwidth = messlength + 6;
  }
  {
#line 1191
  tmp___3 = strlen((char const   *)Wintitle);
  }
#line 1191
  if ((size_t )winwidth > tmp___3 + 6UL) {
#line 1191
    winwidth = winwidth;
  } else {
    {
#line 1191
    tmp___2 = strlen((char const   *)Wintitle);
#line 1191
    winwidth = (int )(tmp___2 + 6UL);
    }
  }
#line 1192
  if (winwidth < COLS - 2) {
#line 1192
    winwidth = winwidth;
  } else {
#line 1192
    winwidth = COLS - 2;
  }
  {
#line 1194
  tempwin = newwin(5 + messheight, winwidth, (LINES - (5 + messheight)) / 2, (COLS - winwidth) / 2);
  }
#line 1197
  if ((unsigned long )tempwin == (unsigned long )((WINDOW *)0)) {
#line 1198
    return (-1);
  }
  {
#line 1200
  CURwenter(cur, tempwin);
#line 1201
  CURbox(cur, tempwin, 5 + messheight, winwidth);
#line 1204
  i = 0;
  }
  {
#line 1204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1204
    if (! (i < messheight)) {
#line 1204
      goto while_break___0;
    }
    {
#line 1205
    tmp___4 = strlen((char const   *)*(Message + i));
#line 1205
    len = (int )tmp___4;
#line 1207
    wmove(tempwin, 2 + i, (winwidth - messlength) / 2);
    }
#line 1209
    if (len > messlength) {
#line 1210
      j = 0;
      {
#line 1210
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1210
        if (! (j < messlength)) {
#line 1210
          goto while_break___1;
        }
        {
#line 1211
        waddch(tempwin, (chtype const   )*(*(Message + i) + j));
#line 1210
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 1214
      waddnstr(tempwin, (char const   *)*(Message + i), -1);
      }
    }
#line 1204
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1221
  if ((unsigned long )Wintitle != (unsigned long )((void *)0)) {
    {
#line 1222
    CURcenterline(cur, tempwin, Wintitle, 0, winwidth, 1);
    }
  }
  {
#line 1225
  wmove(tempwin, 3 + messheight, winwidth - 28);
#line 1226
  CURbutton(cur, tempwin, (char *)"Cancel - ^C", 0);
#line 1227
  waddch(tempwin, (chtype const   )' ');
#line 1228
  CURbutton(cur, tempwin, (char *)"OK: Enter", 0);
#line 1230
  wrefresh(tempwin);
#line 1232
  tmp___5 = CURwgetch(cur, tempwin);
  }
  {
#line 1234
  if (tmp___5 == 7) {
#line 1234
    goto case_7;
  }
#line 1234
  if (tmp___5 == -1) {
#line 1234
    goto case_7;
  }
#line 1237
  goto switch_default;
  case_7: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
  {
#line 1235
  delwin(tempwin);
  }
#line 1236
  return (-1);
  switch_default: /* CIL Label */ 
  {
#line 1238
  delwin(tempwin);
  }
#line 1239
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1243 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
int CURRequest(CursesObj *cur , char *Wintitle , char **Prompts , char **Stowages ) 
{ 
  Requestitem **items ;
  int i ;
  int choice ;
  int numprompts ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1247
  numprompts = 0;
  {
#line 1249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1249
    if (! ((unsigned long )*(Prompts + numprompts) != (unsigned long )((void *)0))) {
#line 1249
      goto while_break;
    }
#line 1250
    numprompts ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1252
  tmp = malloc(sizeof(Requestitem *) * (unsigned long )(numprompts + 1));
#line 1252
  items = (Requestitem **)tmp;
#line 1254
  i = 0;
  }
  {
#line 1254
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1254
    if (! (i < numprompts)) {
#line 1254
      goto while_break___0;
    }
    {
#line 1255
    tmp___0 = malloc(sizeof(Requestitem ));
#line 1255
    *(items + i) = (Requestitem *)tmp___0;
#line 1256
    (*(items + i))->prompt = *(Prompts + i);
#line 1257
    (*(items + i))->stowage = *(Stowages + i);
    }
#line 1259
    if ((unsigned long )*(Stowages + i) == (unsigned long )((void *)0)) {
#line 1260
      (*(items + i))->thing = (Curreqtype )1;
    } else {
#line 1262
      (*(items + i))->thing = (Curreqtype )2;
    }
#line 1254
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1264
  *(items + i) = (Requestitem *)((void *)0);
#line 1266
  choice = CURrequester(cur, Wintitle, items);
#line 1269
  i = 0;
  }
  {
#line 1269
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1269
    if (! (i <= numprompts)) {
#line 1269
      goto while_break___1;
    }
#line 1270
    if (*(items + i)) {
      {
#line 1271
      free((void *)*(items + i));
      }
    }
#line 1269
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1272
  free((void *)items);
  }
#line 1274
  return (choice);
}
}
#line 1299 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
static char **RequestHelp  =    (char **)((void *)0);
#line 1282 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
int CURrequester(CursesObj *cur , char *Wintitle , Requestitem **items ) 
{ 
  int BottomField ;
  int ch ;
  Requestitem *curitem ;
  int currentfield ;
  int FieldsPerPage ;
  boolean Found ;
  int i ;
  int j ;
  int k ;
  int maxlength ;
  int maxpromptwidth ;
  int numprompts ;
  WINDOW *tempwin ;
  int TopField ;
  int WinLines ;
  int WinWidth ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int choice ;
  boolean done ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tempx ;
  int tmp___13 ;
  int zemax ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *p ;
  char addit[2] ;
  size_t tmp___20 ;

  {
#line 1288
  currentfield = 0;
#line 1293
  maxpromptwidth = 0;
#line 1294
  numprompts = 0;
#line 1298
  WinWidth = COLS - 1;
#line 1302
  if ((unsigned long )RequestHelp == (unsigned long )((void *)0)) {
    {
#line 1303
    tmp = malloc(sizeof(char *) * 8UL);
#line 1303
    RequestHelp = (char **)tmp;
#line 1304
    *(RequestHelp + 0) = (char *)"^C      : Cancel";
#line 1305
    *(RequestHelp + 1) = (char *)"Tab, ^N : Move to next field";
#line 1306
    *(RequestHelp + 2) = (char *)"^P      : Move to previous field";
#line 1307
    *(RequestHelp + 3) = (char *)"^F      : Display next page";
#line 1308
    *(RequestHelp + 4) = (char *)"^B      : Display previous page";
#line 1309
    *(RequestHelp + 5) = (char *)"^-      : Help (^/ or ^7 may work)";
#line 1310
    *(RequestHelp + 6) = (char *)"^X      : Accept";
#line 1311
    *(RequestHelp + 7) = (char *)((void *)0);
    }
  }
  {
#line 1315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1315
    tmp___2 = numprompts;
#line 1315
    numprompts ++;
#line 1315
    curitem = *(items + tmp___2);
#line 1315
    if (! ((unsigned long )curitem != (unsigned long )((void *)0))) {
#line 1315
      goto while_break;
    }
#line 1318
    if ((unsigned int )curitem->thing != 1U) {
#line 1319
      if (curitem->prompt) {
        {
#line 1319
        tmp___1 = strlen((char const   *)curitem->prompt);
        }
#line 1319
        if (tmp___1 > (size_t )maxpromptwidth) {
          {
#line 1320
          tmp___0 = strlen((char const   *)curitem->prompt);
#line 1320
          maxpromptwidth = (int )tmp___0;
          }
        }
      }
    } else
#line 1322
    if (currentfield == numprompts - 1) {
#line 1323
      currentfield ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1327
  numprompts --;
#line 1328
  if (numprompts == 0) {
#line 1329
    return (-1);
  }
#line 1331
  TopField = 0;
#line 1332
  if (numprompts < LINES - 5) {
#line 1332
    FieldsPerPage = numprompts;
  } else {
#line 1332
    FieldsPerPage = LINES - 5;
  }
#line 1333
  if (TopField + FieldsPerPage < numprompts) {
#line 1333
    tmp___3 = TopField + FieldsPerPage;
  } else {
#line 1333
    tmp___3 = numprompts;
  }
#line 1333
  BottomField = tmp___3 - 1;
#line 1336
  if (numprompts == 1) {
#line 1336
    if ((unsigned int )(*(items + 0))->thing == 2U) {
#line 1337
      WinLines = 8;
#line 1338
      maxlength = WinWidth - 4;
    } else {
#line 1341
      WinLines = FieldsPerPage + 5;
#line 1342
      maxlength = (WinWidth - maxpromptwidth) - 6;
    }
  } else {
#line 1341
    WinLines = FieldsPerPage + 5;
#line 1342
    maxlength = (WinWidth - maxpromptwidth) - 6;
  }
  {
#line 1346
  tempwin = newwin(WinLines, WinWidth, (LINES - WinLines) / 2, 0);
#line 1347
  CURwenter(cur, tempwin);
#line 1348
  CURbox(cur, tempwin, WinLines, WinWidth);
  }
#line 1351
  if ((unsigned long )Wintitle != (unsigned long )((void *)0)) {
    {
#line 1352
    CURcenterline(cur, tempwin, Wintitle, 0, WinWidth, 1);
    }
  }
  {
#line 1355
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1357
    wmove(tempwin, WinLines - 2, 2);
#line 1358
    waddnstr(tempwin, "[Help: ^-]  [Cancel: ^C] ", -1);
    }
#line 1359
    if ((unsigned int )(*(items + currentfield))->thing == 4U) {
      {
#line 1360
      waddnstr(tempwin, "  [Cycle Values: Space]  [List Values: l]", -1);
      }
    } else {
      {
#line 1363
      waddnstr(tempwin, " [Accept: ^X] ", -1);
#line 1367
      waddnstr(tempwin, " [Next field: TAB] ", -1);
#line 1368
      waddnstr(tempwin, "           ", -1);
      }
    }
#line 1373
    if (numprompts == 1) {
#line 1373
      if ((unsigned int )(*(items + 0))->thing == 2U) {
        {
#line 1374
        wmove(tempwin, 2, 2);
#line 1375
        waddnstr(tempwin, (char const   *)(*(items + 0))->prompt, -1);
#line 1378
        tmp___4 = strlen((char const   *)(*(items + 0))->stowage);
#line 1378
        j = (int )tmp___4;
        }
#line 1378
        if (j > maxlength) {
          {
#line 1379
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1379
            if (! (j > maxlength)) {
#line 1379
              goto while_break___1;
            }
#line 1380
            j --;
#line 1380
            *((*(items + 0))->stowage + j) = (char )'\000';
          }
          while_break___1: /* CIL Label */ ;
          }
        }
        {
#line 1383
        wmove(tempwin, 4, 2);
        }
#line 1384
        if (tempwin) {
#line 1384
          tempwin->_attrs = 1UL << 16;
        }
        {
#line 1385
        waddnstr(tempwin, (char const   *)(*(items + 0))->stowage, -1);
#line 1386
        tmp___5 = strlen((char const   *)(*(items + 0))->stowage);
#line 1386
        j = (int )(tmp___5 + 2UL);
        }
        {
#line 1386
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1386
          if (! (j < WinWidth - 2)) {
#line 1386
            goto while_break___2;
          }
          {
#line 1387
          waddch(tempwin, (chtype const   )' ');
#line 1386
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1388
        if (tempwin) {
#line 1388
          tempwin->_attrs = 0UL;
        }
      } else {
#line 1373
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1391
      i = 0;
#line 1392
      k = TopField;
      {
#line 1392
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1392
        if (! (k <= BottomField)) {
#line 1392
          goto while_break___3;
        }
        {
#line 1393
        wmove(tempwin, 2 + i, 2);
        }
#line 1394
        if ((*(items + k))->prompt) {
          {
#line 1396
          waddnstr(tempwin, (char const   *)(*(items + k))->prompt, -1);
#line 1398
          tmp___6 = strlen((char const   *)(*(items + k))->prompt);
#line 1398
          j = (int )(((size_t )WinWidth - tmp___6) - 4UL);
          }
          {
#line 1398
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1398
            if (! (j > 0)) {
#line 1398
              goto while_break___4;
            }
            {
#line 1399
            waddch(tempwin, (chtype const   )' ');
#line 1398
            j --;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
        }
        {
#line 1404
        if ((unsigned int )(*(items + k))->thing == 1U) {
#line 1404
          goto case_1;
        }
#line 1407
        if ((unsigned int )(*(items + k))->thing == 4U) {
#line 1407
          goto case_4;
        }
#line 1414
        if ((unsigned int )(*(items + k))->thing == 5U) {
#line 1414
          goto case_5;
        }
#line 1426
        goto switch_default;
        case_1: /* CIL Label */ 
#line 1405
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 1409
        wmove(tempwin, 2 + i, maxpromptwidth + 4);
#line 1410
        waddnstr(tempwin, (char const   *)*((*(items + k))->choices + (*(items + k))->chooseitem),
                 -1);
        }
#line 1412
        goto switch_break;
        case_5: /* CIL Label */ 
        {
#line 1415
        wordwrap = 1;
#line 1416
        wmove(tempwin, 2 + i, 2);
        }
#line 1417
        if (tempwin) {
#line 1417
          tempwin->_attrs = 1UL << 16;
        }
        {
#line 1418
        waddnstr(tempwin, (char const   *)(*(items + k))->stowage, -1);
#line 1419
        tmp___7 = strlen((char const   *)(*(items + k))->stowage);
#line 1419
        j = (int )(((size_t )WinWidth - tmp___7) - 4UL);
        }
        {
#line 1419
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1419
          if (! (j > 0)) {
#line 1419
            goto while_break___5;
          }
          {
#line 1421
          waddch(tempwin, (chtype const   )' ');
#line 1419
          j --;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1423
        if (tempwin) {
#line 1423
          tempwin->_attrs = 0UL;
        }
#line 1424
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1429
        wordwrap = 0;
#line 1430
        wmove(tempwin, 2 + i, maxpromptwidth + 4);
        }
#line 1431
        if (tempwin) {
#line 1431
          tempwin->_attrs = 1UL << 16;
        }
#line 1433
        if ((unsigned int )(*(items + k))->thing == 3U) {
          {
#line 1434
          tmp___8 = strlen((char const   *)(*(items + k))->stowage);
#line 1434
          j = (int )tmp___8;
          }
          {
#line 1434
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1434
            if (! (j > 0)) {
#line 1434
              goto while_break___6;
            }
            {
#line 1435
            waddch(tempwin, (chtype const   )'*');
#line 1434
            j --;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
        } else
#line 1436
        if ((*(items + k))->stowage) {
          {
#line 1437
          waddnstr(tempwin, (char const   *)(*(items + k))->stowage, -1);
          }
        }
#line 1441
        if ((*(items + k))->stowage) {
          {
#line 1441
          tmp___9 = strlen((char const   *)(*(items + k))->stowage);
#line 1441
          tmp___10 = tmp___9;
          }
        } else {
#line 1441
          tmp___10 = (size_t )0;
        }
#line 1441
        j = (int )((((size_t )WinWidth - tmp___10) - (size_t )maxpromptwidth) - 6UL);
        {
#line 1441
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1441
          if (! (j > 0)) {
#line 1441
            goto while_break___7;
          }
          {
#line 1444
          waddch(tempwin, (chtype const   )' ');
#line 1441
          j --;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1446
        if (tempwin) {
#line 1446
          tempwin->_attrs = 0UL;
        }
        switch_break: /* CIL Label */ ;
        }
#line 1448
        i ++;
#line 1392
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 1452
    if (numprompts == 1) {
      {
#line 1453
      wmove(tempwin, 4, 2);
      }
    } else {
      {
#line 1455
      wmove(tempwin, (2 + currentfield) - TopField, maxpromptwidth + 4);
      }
    }
#line 1457
    if ((unsigned int )(*(items + currentfield))->thing == 5U) {
      {
#line 1458
      wmove(tempwin, (2 + currentfield) - TopField, 2);
      }
    }
    {
#line 1460
    wrefresh(tempwin);
    }
#line 1462
    if ((unsigned int )(*(items + currentfield))->thing == 4U) {
      {
#line 1463
      choice = (*(items + currentfield))->chooseitem;
#line 1464
      done = 0;
#line 1466
      tmp___11 = strlen((char const   *)*((*(items + currentfield))->choices + choice));
#line 1466
      wmove(tempwin, (2 + currentfield) - TopField, (int )(((size_t )maxpromptwidth + tmp___11) + 4UL));
#line 1469
      wrefresh(tempwin);
      }
      {
#line 1471
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1471
        if (! (! done)) {
#line 1471
          goto while_break___8;
        }
        {
#line 1472
        ch = CURwgetch(cur, tempwin);
#line 1474
        wmove(tempwin, (2 + currentfield) - TopField, maxpromptwidth + 4);
#line 1476
        tmp___12 = strlen((char const   *)*((*(items + currentfield))->choices + choice));
#line 1476
        i = (int )tmp___12;
        }
        {
#line 1476
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1476
          if (! (i > 0)) {
#line 1476
            goto while_break___9;
          }
          {
#line 1478
          waddch(tempwin, (chtype const   )' ');
#line 1476
          i --;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 1480
        if (ch == 32) {
#line 1482
          choice ++;
        } else
#line 1485
        if (ch == 108) {
          {
#line 1487
          tempx = CURChoice(cur, (*(items + currentfield))->prompt, (*(items + currentfield))->choices,
                            (char *)"Select an item", (*(items + currentfield))->chooseitem);
          }
#line 1491
          if (tempwin) {
#line 1491
            tmp___13 = (int )tempwin->_maxy + 1;
          } else {
#line 1491
            tmp___13 = -1;
          }
          {
#line 1491
          wtouchln(tempwin, 0, tmp___13, 1);
          }
#line 1492
          if (tempx != -1) {
#line 1493
            choice = tempx;
          }
        } else {
#line 1497
          done = 1;
        }
#line 1499
        if ((unsigned long )*((*(items + currentfield))->choices + choice) == (unsigned long )((void *)0)) {
#line 1500
          choice = 0;
        }
        {
#line 1502
        wmove(tempwin, (2 + currentfield) - TopField, maxpromptwidth + 4);
#line 1505
        waddnstr(tempwin, (char const   *)*((*(items + currentfield))->choices + choice),
                 -1);
#line 1506
        (*(items + currentfield))->chooseitem = choice;
#line 1507
        wrefresh(tempwin);
        }
      }
      while_break___8: /* CIL Label */ ;
      }
    } else {
#line 1511
      zemax = maxlength;
#line 1513
      if ((unsigned int )(*(items + currentfield))->thing == 5U) {
#line 1514
        zemax = COLS - 6;
      }
      {
#line 1516
      ch = CURwgetstr(cur, tempwin, (*(items + currentfield))->stowage, zemax, (unsigned int )(*(items + currentfield))->thing == 3U);
      }
    }
#line 1521
    if (ch == 10) {
#line 1522
      if (numprompts > 1) {
#line 1523
        ch = '\t';
      } else {
#line 1525
        ch = '\030';
      }
    }
    {
#line 1533
    if (ch == 9) {
#line 1533
      goto case_9;
    }
#line 1533
    if (ch == 14) {
#line 1533
      goto case_9;
    }
#line 1550
    if (ch == 16) {
#line 1550
      goto case_16;
    }
#line 1566
    if (ch == 258) {
#line 1566
      goto case_258;
    }
#line 1612
    if (ch == 259) {
#line 1612
      goto case_259;
    }
#line 1657
    if (ch == 338) {
#line 1657
      goto case_338;
    }
#line 1657
    if (ch == 6) {
#line 1657
      goto case_338;
    }
#line 1677
    if (ch == 339) {
#line 1677
      goto case_339;
    }
#line 1677
    if (ch == 2) {
#line 1677
      goto case_339;
    }
#line 1696
    if (ch == 363) {
#line 1696
      goto case_363;
    }
#line 1696
    if (ch == 31) {
#line 1696
      goto case_363;
    }
#line 1702
    if (ch == -1) {
#line 1702
      goto case_neg_1;
    }
#line 1702
    if (ch == 7) {
#line 1702
      goto case_neg_1;
    }
#line 1708
    if (ch == 24) {
#line 1708
      goto case_24;
    }
#line 1715
    goto switch_default___0;
    case_9: /* CIL Label */ 
    case_14: /* CIL Label */ 
    {
#line 1535
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1536
      currentfield ++;
#line 1537
      if (currentfield > numprompts - 1) {
#line 1538
        TopField = 0;
#line 1539
        if (TopField + FieldsPerPage < numprompts) {
#line 1539
          tmp___14 = TopField + FieldsPerPage;
        } else {
#line 1539
          tmp___14 = numprompts;
        }
#line 1539
        BottomField = tmp___14 - 1;
#line 1541
        currentfield = TopField;
      } else
#line 1543
      if (currentfield > BottomField) {
#line 1544
        TopField ++;
#line 1545
        BottomField ++;
      }
#line 1535
      if (! ((unsigned int )(*(items + currentfield))->thing == 1U)) {
#line 1535
        goto while_break___10;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
#line 1548
    goto switch_break___0;
    case_16: /* CIL Label */ 
    {
#line 1552
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1553
      currentfield --;
#line 1554
      if (currentfield < 0) {
#line 1555
        currentfield = numprompts - 1;
#line 1556
        if (0 > numprompts - FieldsPerPage) {
#line 1556
          TopField = 0;
        } else {
#line 1556
          TopField = numprompts - FieldsPerPage;
        }
#line 1557
        BottomField = currentfield;
      } else
#line 1559
      if (currentfield < TopField) {
#line 1560
        TopField --;
#line 1561
        BottomField --;
      }
#line 1552
      if (! ((unsigned int )(*(items + currentfield))->thing == 1U)) {
#line 1552
        goto while_break___11;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1564
    goto switch_break___0;
    case_258: /* CIL Label */ 
#line 1573
    if (currentfield == BottomField) {
#line 1574
      TopField ++;
#line 1575
      BottomField ++;
#line 1576
      if (BottomField > numprompts - 1) {
#line 1577
        TopField = 0;
#line 1578
        if (TopField + FieldsPerPage < numprompts) {
#line 1578
          tmp___15 = TopField + FieldsPerPage;
        } else {
#line 1578
          tmp___15 = numprompts;
        }
#line 1578
        BottomField = tmp___15 - 1;
#line 1580
        currentfield = TopField;
        {
#line 1581
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1581
          if (! ((unsigned int )(*(items + currentfield))->thing == 1U)) {
#line 1581
            goto while_break___12;
          }
#line 1582
          currentfield ++;
        }
        while_break___12: /* CIL Label */ ;
        }
      } else
#line 1584
      if ((unsigned int )(*(items + BottomField))->thing != 1U) {
#line 1585
        currentfield = BottomField;
      }
    } else {
#line 1588
      Found = 0;
#line 1589
      i = currentfield + 1;
      {
#line 1589
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 1589
        if (! (i <= BottomField)) {
#line 1589
          goto while_break___13;
        }
#line 1590
        if ((unsigned int )(*(items + i))->thing != 1U) {
#line 1591
          currentfield = i;
#line 1592
          Found = 1;
#line 1593
          goto while_break___13;
        }
#line 1589
        i ++;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 1595
      if (! Found) {
#line 1596
        TopField ++;
#line 1597
        BottomField ++;
#line 1598
        if (BottomField > numprompts - 1) {
#line 1599
          TopField = 0;
#line 1600
          if (TopField + FieldsPerPage < numprompts) {
#line 1600
            tmp___16 = TopField + FieldsPerPage;
          } else {
#line 1600
            tmp___16 = numprompts;
          }
#line 1600
          BottomField = tmp___16 - 1;
#line 1602
          currentfield = TopField;
          {
#line 1603
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 1603
            if (! ((unsigned int )(*(items + currentfield))->thing == 1U)) {
#line 1603
              goto while_break___14;
            }
#line 1604
            currentfield ++;
          }
          while_break___14: /* CIL Label */ ;
          }
        } else
#line 1606
        if ((unsigned int )(*(items + BottomField))->thing != 1U) {
#line 1607
          currentfield = BottomField;
        }
      }
    }
#line 1610
    goto switch_break___0;
    case_259: /* CIL Label */ 
#line 1619
    if (currentfield == TopField) {
#line 1620
      TopField --;
#line 1621
      BottomField --;
#line 1622
      if (TopField < 0) {
#line 1623
        if (0 > numprompts - FieldsPerPage) {
#line 1623
          TopField = 0;
        } else {
#line 1623
          TopField = numprompts - FieldsPerPage;
        }
#line 1624
        BottomField = numprompts - 1;
#line 1625
        currentfield = BottomField;
        {
#line 1626
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 1626
          if (! ((unsigned int )(*(items + currentfield))->thing == 1U)) {
#line 1626
            goto while_break___15;
          }
#line 1627
          currentfield --;
        }
        while_break___15: /* CIL Label */ ;
        }
      } else
#line 1629
      if ((unsigned int )(*(items + TopField))->thing != 1U) {
#line 1630
        currentfield = TopField;
      }
    } else {
#line 1633
      Found = 0;
#line 1634
      i = currentfield - 1;
      {
#line 1634
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 1634
        if (! (i >= TopField)) {
#line 1634
          goto while_break___16;
        }
#line 1635
        if ((unsigned int )(*(items + i))->thing != 1U) {
#line 1636
          currentfield = i;
#line 1637
          Found = 1;
#line 1638
          goto while_break___16;
        }
#line 1634
        i --;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 1640
      if (! Found) {
#line 1641
        TopField --;
#line 1642
        BottomField --;
#line 1643
        if (TopField < 0) {
#line 1644
          if (0 > numprompts - FieldsPerPage) {
#line 1644
            TopField = 0;
          } else {
#line 1644
            TopField = numprompts - FieldsPerPage;
          }
#line 1645
          BottomField = numprompts - 1;
#line 1646
          currentfield = BottomField;
          {
#line 1647
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 1647
            if (! ((unsigned int )(*(items + currentfield))->thing == 1U)) {
#line 1647
              goto while_break___17;
            }
#line 1648
            currentfield --;
          }
          while_break___17: /* CIL Label */ ;
          }
        } else
#line 1650
        if ((unsigned int )(*(items + TopField))->thing != 1U) {
#line 1651
          currentfield = TopField;
        }
      }
    }
#line 1654
    goto switch_break___0;
    case_338: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 1659
    if (BottomField == numprompts - 1) {
#line 1660
      currentfield = BottomField;
      {
#line 1661
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 1661
        if (! ((unsigned int )(*(items + currentfield))->thing == 1U)) {
#line 1661
          goto while_break___18;
        }
#line 1662
        currentfield --;
      }
      while_break___18: /* CIL Label */ ;
      }
    } else {
#line 1665
      if (BottomField + FieldsPerPage < numprompts) {
#line 1665
        tmp___17 = BottomField + FieldsPerPage;
      } else {
#line 1665
        tmp___17 = numprompts;
      }
#line 1665
      BottomField = tmp___17 - 1;
#line 1667
      if (0 > (BottomField - FieldsPerPage) + 1) {
#line 1667
        TopField = 0;
      } else {
#line 1667
        TopField = (BottomField - FieldsPerPage) + 1;
      }
#line 1668
      if (currentfield < TopField) {
#line 1669
        currentfield = TopField;
        {
#line 1670
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 1670
          if (! ((unsigned int )(*(items + currentfield))->thing == 1U)) {
#line 1670
            goto while_break___19;
          }
#line 1671
          currentfield ++;
        }
        while_break___19: /* CIL Label */ ;
        }
      }
    }
#line 1674
    goto switch_break___0;
    case_339: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 1679
    if (TopField == 0) {
#line 1680
      currentfield = 0;
      {
#line 1681
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 1681
        if (! ((unsigned int )(*(items + currentfield))->thing == 1U)) {
#line 1681
          goto while_break___20;
        }
#line 1682
        currentfield ++;
      }
      while_break___20: /* CIL Label */ ;
      }
    } else {
#line 1685
      if (0 > (TopField - FieldsPerPage) + 1) {
#line 1685
        TopField = 0;
      } else {
#line 1685
        TopField = (TopField - FieldsPerPage) + 1;
      }
#line 1686
      if (TopField + FieldsPerPage < numprompts) {
#line 1686
        tmp___18 = TopField + FieldsPerPage;
      } else {
#line 1686
        tmp___18 = numprompts;
      }
#line 1686
      BottomField = tmp___18 - 1;
#line 1687
      if (currentfield > BottomField) {
#line 1688
        currentfield = BottomField;
        {
#line 1689
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 1689
          if (! ((unsigned int )(*(items + currentfield))->thing == 1U)) {
#line 1689
            goto while_break___21;
          }
#line 1690
          currentfield --;
        }
        while_break___21: /* CIL Label */ ;
        }
      }
    }
#line 1693
    goto switch_break___0;
    case_363: /* CIL Label */ 
    case_31: /* CIL Label */ 
    {
#line 1697
    CURDialog(cur, (char *)"Form Help", RequestHelp);
    }
#line 1698
    if (tempwin) {
#line 1698
      tmp___19 = (int )tempwin->_maxy + 1;
    } else {
#line 1698
      tmp___19 = -1;
    }
    {
#line 1698
    wtouchln(tempwin, 0, tmp___19, 1);
    }
#line 1699
    goto switch_break___0;
    case_neg_1: /* CIL Label */ 
    case_7: /* CIL Label */ 
    {
#line 1704
    delwin(tempwin);
    }
#line 1705
    return (-1);
    case_24: /* CIL Label */ 
    {
#line 1712
    delwin(tempwin);
    }
#line 1713
    return (0);
    switch_default___0: /* CIL Label */ 
#line 1716
    if (wordwrap) {
#line 1718
      if (currentfield == numprompts - 1) {
        {
#line 1719
        CURBeep(cur);
        }
#line 1720
        goto while_continue___0;
      }
#line 1722
      if ((unsigned int )(*(items + (currentfield + 1)))->thing != 5U) {
        {
#line 1723
        CURBeep(cur);
        }
#line 1724
        goto while_continue___0;
      }
      {
#line 1729
      p = strrchr((char const   *)(*(items + currentfield))->stowage, ' ');
      }
#line 1732
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 1734
        addit[0] = (char )ch;
#line 1735
        *(addit + 1) = (char )'\000';
#line 1736
        strcat((char */* __restrict  */)(p + 1), (char const   */* __restrict  */)(addit));
#line 1738
        strcpy((char */* __restrict  */)(*(items + (currentfield + 1)))->stowage,
               (char const   */* __restrict  */)(p + 1));
#line 1741
        *p = (char )'\000';
#line 1742
        wmove(tempwin, (2 + currentfield) - TopField, 2);
        }
#line 1743
        if (tempwin) {
#line 1743
          tempwin->_attrs = 1UL << 16;
        }
        {
#line 1744
        waddnstr(tempwin, (char const   *)(*(items + currentfield))->stowage, -1);
#line 1745
        tmp___20 = strlen((char const   *)(*(items + currentfield))->stowage);
#line 1745
        j = (int )((tmp___20 + (size_t )maxpromptwidth) + 4UL);
        }
        {
#line 1745
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 1745
          if (! (j < COLS - 6)) {
#line 1745
            goto while_break___22;
          }
          {
#line 1747
          waddch(tempwin, (chtype const   )' ');
#line 1745
          j ++;
          }
        }
        while_break___22: /* CIL Label */ ;
        }
#line 1748
        if (tempwin) {
#line 1748
          tempwin->_attrs = 0UL;
        }
      }
#line 1750
      currentfield ++;
#line 1752
      if (currentfield > BottomField) {
#line 1753
        TopField ++;
#line 1754
        BottomField ++;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 1794 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
static char **ChoiceHelp  =    (char **)((void *)0);
#line 1774 "/home/june/repo/benchmarks/collector/temp/gopher-3.0.13/gopher/CURcurses.c"
int CURChoice(CursesObj *cur , char *WinTitle , char **Choices , char *Prompt , int DefaultChoice ) 
{ 
  int BottomChoice ;
  int ch ;
  int ChoicesPerPage ;
  int CurrentChoice ;
  int CurrentLine ;
  int CurrentPage ;
  int i ;
  char InBuf[3] ;
  int j ;
  int k ;
  int MaxChoiceWidth ;
  int NumChoices ;
  int NumPages ;
  WINDOW *TempWin ;
  int TopChoice ;
  int WinLines ;
  int WinWidth ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 1780
  CurrentChoice = 0;
#line 1787
  MaxChoiceWidth = 0;
#line 1788
  NumChoices = 0;
#line 1796
  if ((unsigned long )ChoiceHelp == (unsigned long )((void *)0)) {
    {
#line 1797
    tmp = malloc(sizeof(char *) * 10UL);
#line 1797
    ChoiceHelp = (char **)tmp;
#line 1798
    *(ChoiceHelp + 0) = (char *)"^C        : Cancel";
#line 1799
    *(ChoiceHelp + 1) = (char *)"Down, ^N  : Move to next choice";
#line 1800
    *(ChoiceHelp + 2) = (char *)"Up, ^P    : Move to previous choice";
#line 1801
    *(ChoiceHelp + 3) = (char *)"Space, ^F : Display next page";
#line 1802
    *(ChoiceHelp + 4) = (char *)"b, ^B     : Display previous page";
#line 1803
    *(ChoiceHelp + 5) = (char *)"^         : Display first page";
#line 1804
    *(ChoiceHelp + 6) = (char *)"$         : Display last page";
#line 1805
    *(ChoiceHelp + 7) = (char *)"0-9       : Select a specific choice";
#line 1806
    *(ChoiceHelp + 8) = (char *)"Enter     : Select current choice";
#line 1807
    *(ChoiceHelp + 9) = (char *)((void *)0);
    }
  }
  {
#line 1812
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1812
    if (! ((unsigned long )*(Choices + NumChoices) != (unsigned long )((void *)0))) {
#line 1812
      goto while_break;
    }
#line 1813
    NumChoices ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1814
  if (NumChoices == 0) {
#line 1815
    return (-1);
  }
#line 1816
  if (NumChoices > 99) {
    {
#line 1817
    CursesErrorMsg((char *)"More than 99 choices!  Please gripe.");
    }
#line 1818
    return (-1);
  }
#line 1821
  if (NumChoices < LINES - 6) {
#line 1821
    ChoicesPerPage = NumChoices;
  } else {
#line 1821
    ChoicesPerPage = LINES - 6;
  }
#line 1822
  NumPages = NumChoices / ChoicesPerPage + 1;
#line 1823
  WinLines = ChoicesPerPage + 6;
#line 1825
  if (DefaultChoice > -1) {
#line 1825
    CurrentChoice = DefaultChoice;
  } else {
#line 1825
    CurrentChoice = 0;
  }
#line 1826
  CurrentPage = CurrentChoice / ChoicesPerPage;
#line 1827
  if (CurrentPage * ChoicesPerPage + ChoicesPerPage < NumChoices) {
#line 1827
    tmp___0 = CurrentPage * ChoicesPerPage + ChoicesPerPage;
  } else {
#line 1827
    tmp___0 = NumChoices;
  }
#line 1827
  BottomChoice = tmp___0 - 1;
#line 1829
  if (0 > (BottomChoice - ChoicesPerPage) + 1) {
#line 1829
    TopChoice = 0;
  } else {
#line 1829
    TopChoice = (BottomChoice - ChoicesPerPage) + 1;
  }
#line 1830
  CurrentLine = (CurrentChoice - TopChoice) + 2;
#line 1833
  i = 0;
  {
#line 1833
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1833
    if (! (i < NumChoices)) {
#line 1833
      goto while_break___0;
    }
#line 1834
    if (i == DefaultChoice) {
      {
#line 1835
      tmp___3 = strlen((char const   *)*(Choices + i));
      }
#line 1835
      if (tmp___3 + 10UL > (size_t )MaxChoiceWidth) {
        {
#line 1835
        tmp___2 = strlen((char const   *)*(Choices + i));
#line 1835
        MaxChoiceWidth = (int )(tmp___2 + 10UL);
        }
      } else {
#line 1835
        MaxChoiceWidth = MaxChoiceWidth;
      }
    } else {
      {
#line 1837
      tmp___6 = strlen((char const   *)*(Choices + i));
      }
#line 1837
      if (tmp___6 > (size_t )MaxChoiceWidth) {
        {
#line 1837
        tmp___5 = strlen((char const   *)*(Choices + i));
#line 1837
        MaxChoiceWidth = (int )tmp___5;
        }
      } else {
#line 1837
        MaxChoiceWidth = MaxChoiceWidth;
      }
    }
#line 1833
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1839
  tmp___9 = strlen((char const   *)Prompt);
  }
#line 1839
  if (tmp___9 + 17UL > (size_t )(MaxChoiceWidth + 15)) {
    {
#line 1839
    tmp___8 = strlen((char const   *)Prompt);
#line 1839
    WinWidth = (int )(tmp___8 + 17UL);
    }
  } else {
#line 1839
    WinWidth = MaxChoiceWidth + 15;
  }
  {
#line 1840
  tmp___12 = strlen((char const   *)WinTitle);
  }
#line 1840
  if (tmp___12 + 8UL > (size_t )WinWidth) {
    {
#line 1840
    tmp___11 = strlen((char const   *)WinTitle);
#line 1840
    WinWidth = (int )(tmp___11 + 8UL);
    }
  } else {
#line 1840
    WinWidth = WinWidth;
  }
#line 1841
  if (29 > WinWidth) {
#line 1841
    WinWidth = 29;
  } else {
#line 1841
    WinWidth = WinWidth;
  }
#line 1842
  if (COLS - 2 < WinWidth) {
#line 1842
    WinWidth = COLS - 2;
  } else {
#line 1842
    WinWidth = WinWidth;
  }
  {
#line 1845
  TempWin = newwin(WinLines, WinWidth, (LINES - WinLines) / 2, (COLS - WinWidth) / 2);
#line 1847
  CURwenter(cur, TempWin);
#line 1848
  CURbox(cur, TempWin, WinLines, WinWidth);
  }
#line 1851
  if ((unsigned long )WinTitle != (unsigned long )((void *)0)) {
    {
#line 1852
    CURcenterline(cur, TempWin, WinTitle, 0, WinWidth, 1);
    }
  }
  {
#line 1855
  wmove(TempWin, ChoicesPerPage + 3, 3);
#line 1856
  wprintw(TempWin, "%s (1-%d): ", Prompt, NumChoices);
#line 1859
  wmove(TempWin, ChoicesPerPage + 4, 3);
#line 1860
  CURbutton(cur, TempWin, (char *)"Help: ?", 0);
#line 1861
  waddnstr(TempWin, "  ", -1);
#line 1862
  CURbutton(cur, TempWin, (char *)"Cancel - ^C", 0);
  }
  {
#line 1865
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1867
    i = 0;
#line 1868
    j = TopChoice;
    {
#line 1868
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1868
      if (! (j <= BottomChoice)) {
#line 1868
        goto while_break___2;
      }
      {
#line 1869
      wmove(TempWin, 2 + i, 8);
#line 1870
      k = 0;
      }
      {
#line 1870
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1870
        if (! (k < WinWidth - 10)) {
#line 1870
          goto while_break___3;
        }
        {
#line 1871
        waddch(TempWin, (chtype const   )' ');
#line 1870
        k ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1872
      wmove(TempWin, 2 + i, 8);
#line 1873
      wprintw(TempWin, "%2d.", j + 1);
#line 1874
      wmove(TempWin, 2 + i, 12);
#line 1875
      wprintw(TempWin, "%s", *(Choices + j));
      }
#line 1876
      if (j == DefaultChoice) {
        {
#line 1877
        waddnstr(TempWin, " (default)", -1);
        }
      }
#line 1878
      i ++;
#line 1868
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1882
    wmove(TempWin, CurrentLine, 3);
#line 1883
    waddnstr(TempWin, "-->", -1);
#line 1886
    wrefresh(TempWin);
#line 1889
    ch = CURwgetch(cur, TempWin);
    }
    {
#line 1893
    if (ch == 258) {
#line 1893
      goto case_258;
    }
#line 1893
    if (ch == 14) {
#line 1893
      goto case_258;
    }
#line 1912
    if (ch == 259) {
#line 1912
      goto case_259;
    }
#line 1912
    if (ch == 16) {
#line 1912
      goto case_259;
    }
#line 1932
    if (ch == 338) {
#line 1932
      goto case_338;
    }
#line 1932
    if (ch == 43) {
#line 1932
      goto case_338;
    }
#line 1932
    if (ch == 32) {
#line 1932
      goto case_338;
    }
#line 1932
    if (ch == 6) {
#line 1932
      goto case_338;
    }
#line 1947
    if (ch == 339) {
#line 1947
      goto case_339;
    }
#line 1947
    if (ch == 45) {
#line 1947
      goto case_339;
    }
#line 1947
    if (ch == 98) {
#line 1947
      goto case_339;
    }
#line 1947
    if (ch == 2) {
#line 1947
      goto case_339;
    }
#line 1959
    if (ch == 94) {
#line 1959
      goto case_94;
    }
#line 1967
    if (ch == 36) {
#line 1967
      goto case_36;
    }
#line 1977
    if (ch == 63) {
#line 1977
      goto case_63;
    }
#line 1977
    if (ch == 104) {
#line 1977
      goto case_63;
    }
#line 1977
    if (ch == 363) {
#line 1977
      goto case_63;
    }
#line 1977
    if (ch == 31) {
#line 1977
      goto case_63;
    }
#line 1984
    if (ch == 48) {
#line 1984
      goto case_48;
    }
#line 1984
    if (ch == 57) {
#line 1984
      goto case_48;
    }
#line 1984
    if (ch == 56) {
#line 1984
      goto case_48;
    }
#line 1984
    if (ch == 55) {
#line 1984
      goto case_48;
    }
#line 1984
    if (ch == 54) {
#line 1984
      goto case_48;
    }
#line 1984
    if (ch == 53) {
#line 1984
      goto case_48;
    }
#line 1984
    if (ch == 52) {
#line 1984
      goto case_48;
    }
#line 1984
    if (ch == 51) {
#line 1984
      goto case_48;
    }
#line 1984
    if (ch == 50) {
#line 1984
      goto case_48;
    }
#line 1984
    if (ch == 49) {
#line 1984
      goto case_48;
    }
#line 2009
    if (ch == 7) {
#line 2009
      goto case_7;
    }
#line 2015
    if (ch == 24) {
#line 2015
      goto case_24;
    }
#line 2015
    if (ch == 10) {
#line 2015
      goto case_24;
    }
#line 2020
    goto switch_default;
    case_258: /* CIL Label */ 
    case_14: /* CIL Label */ 
#line 1895
    if (CurrentChoice == BottomChoice) {
#line 1896
      TopChoice ++;
#line 1897
      BottomChoice ++;
#line 1898
      if (BottomChoice > NumChoices - 1) {
#line 1899
        CurrentChoice = 0;
#line 1900
        TopChoice = 0;
#line 1901
        if (TopChoice + ChoicesPerPage < NumChoices) {
#line 1901
          tmp___13 = TopChoice + ChoicesPerPage;
        } else {
#line 1901
          tmp___13 = NumChoices;
        }
#line 1901
        BottomChoice = tmp___13 - 1;
      } else {
#line 1905
        CurrentChoice ++;
      }
    } else {
#line 1908
      CurrentChoice ++;
    }
#line 1909
    goto switch_break;
    case_259: /* CIL Label */ 
    case_16: /* CIL Label */ 
#line 1914
    if (CurrentChoice == TopChoice) {
#line 1915
      TopChoice --;
#line 1916
      BottomChoice --;
#line 1917
      if (TopChoice < 0) {
#line 1918
        CurrentChoice = NumChoices - 1;
#line 1919
        if (0 > NumChoices - ChoicesPerPage) {
#line 1919
          TopChoice = 0;
        } else {
#line 1919
          TopChoice = NumChoices - ChoicesPerPage;
        }
#line 1920
        BottomChoice = CurrentChoice;
      } else {
#line 1923
        CurrentChoice --;
      }
    } else {
#line 1926
      CurrentChoice --;
    }
#line 1927
    goto switch_break;
    case_338: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 1934
    if (BottomChoice == NumChoices - 1) {
#line 1935
      CurrentChoice = BottomChoice;
    } else {
#line 1937
      if (BottomChoice + ChoicesPerPage < NumChoices) {
#line 1937
        tmp___14 = BottomChoice + ChoicesPerPage;
      } else {
#line 1937
        tmp___14 = NumChoices;
      }
#line 1937
      BottomChoice = tmp___14 - 1;
#line 1939
      if (0 > (BottomChoice - ChoicesPerPage) + 1) {
#line 1939
        TopChoice = 0;
      } else {
#line 1939
        TopChoice = (BottomChoice - ChoicesPerPage) + 1;
      }
#line 1940
      if (TopChoice > CurrentChoice) {
#line 1940
        CurrentChoice = TopChoice;
      } else {
#line 1940
        CurrentChoice = CurrentChoice;
      }
    }
#line 1942
    goto switch_break;
    case_339: /* CIL Label */ 
    case_45: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 1949
    if (TopChoice == 0) {
#line 1950
      CurrentChoice = TopChoice;
    } else {
#line 1952
      if (0 > (TopChoice - ChoicesPerPage) + 1) {
#line 1952
        TopChoice = 0;
      } else {
#line 1952
        TopChoice = (TopChoice - ChoicesPerPage) + 1;
      }
#line 1953
      if (TopChoice + ChoicesPerPage < NumChoices) {
#line 1953
        tmp___15 = TopChoice + ChoicesPerPage;
      } else {
#line 1953
        tmp___15 = NumChoices;
      }
#line 1953
      BottomChoice = tmp___15 - 1;
#line 1955
      if (CurrentChoice < BottomChoice) {
#line 1955
        CurrentChoice = CurrentChoice;
      } else {
#line 1955
        CurrentChoice = BottomChoice;
      }
    }
#line 1957
    goto switch_break;
    case_94: /* CIL Label */ 
#line 1961
    TopChoice = 0;
#line 1962
    if (TopChoice + ChoicesPerPage < NumChoices) {
#line 1962
      tmp___16 = TopChoice + ChoicesPerPage;
    } else {
#line 1962
      tmp___16 = NumChoices;
    }
#line 1962
    BottomChoice = tmp___16 - 1;
#line 1964
    CurrentChoice = TopChoice;
#line 1965
    goto switch_break;
    case_36: /* CIL Label */ 
#line 1969
    BottomChoice = NumChoices - 1;
#line 1970
    if (0 > (BottomChoice - ChoicesPerPage) + 1) {
#line 1970
      TopChoice = 0;
    } else {
#line 1970
      TopChoice = (BottomChoice - ChoicesPerPage) + 1;
    }
#line 1971
    CurrentChoice = BottomChoice;
#line 1972
    goto switch_break;
    case_63: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_363: /* CIL Label */ 
    case_31: /* CIL Label */ 
    {
#line 1979
    CURDialog(cur, (char *)"Choice Dialog Help", ChoiceHelp);
    }
#line 1980
    if (TempWin) {
#line 1980
      tmp___17 = (int )TempWin->_maxy + 1;
    } else {
#line 1980
      tmp___17 = -1;
    }
    {
#line 1980
    wtouchln(TempWin, 0, tmp___17, 1);
    }
#line 1981
    goto switch_break;
    case_48: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    {
#line 1986
    InBuf[0] = (char )ch;
#line 1987
    InBuf[1] = (char )'\000';
#line 1988
    InBuf[2] = (char )'\000';
#line 1990
    tmp___18 = strlen((char const   *)Prompt);
    }
#line 1990
    if (NumChoices < 10) {
#line 1990
      tmp___19 = 11;
    } else {
#line 1990
      tmp___19 = 12;
    }
    {
#line 1990
    i = (int )(tmp___18 + (size_t )tmp___19);
#line 1991
    j = ChoicesPerPage + 3;
#line 1992
    wmove(TempWin, j, i);
    }
#line 1994
    if (NumChoices < 10) {
#line 1994
      tmp___20 = 1;
    } else {
#line 1994
      tmp___20 = 2;
    }
    {
#line 1994
    ch = CURwgetstr(cur, TempWin, InBuf, tmp___20, 0);
#line 1995
    k = atoi((char const   *)(InBuf));
    }
#line 1997
    if (ch == 10) {
#line 1997
      if (0 < k) {
#line 1997
        if (k <= NumChoices) {
          {
#line 1998
          delwin(TempWin);
          }
#line 1999
          return (k - 1);
        } else {
#line 1997
          goto _L___0;
        }
      } else {
#line 1997
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 2002
      wmove(TempWin, j, i);
#line 2003
      waddnstr(TempWin, "  ", -1);
      }
#line 2004
      if (ch != -1) {
        {
#line 2005
        CURBeep(cur);
        }
      }
#line 2006
      goto switch_break;
    }
    case_7: /* CIL Label */ 
    {
#line 2011
    delwin(TempWin);
    }
#line 2012
    return (-1);
    case_24: /* CIL Label */ 
    case_10: /* CIL Label */ 
    {
#line 2017
    delwin(TempWin);
    }
#line 2018
    return (CurrentChoice);
    switch_default: /* CIL Label */ 
    {
#line 2021
    CURBeep(cur);
    }
#line 2022
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 2024
    wmove(TempWin, CurrentLine, 3);
#line 2025
    waddnstr(TempWin, "   ", -1);
#line 2026
    CurrentPage = CurrentChoice / ChoicesPerPage;
#line 2027
    CurrentLine = (CurrentChoice - TopChoice) + 2;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
