/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 107 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.h"
enum callback_types {
    ERROR_HANDLER = 1,
    CONTEXT_CHECKER = 2
} ;
#line 112 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.h"
typedef enum callback_types callback_types;
#line 113
struct configfile_t;
#line 113 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.h"
typedef struct configfile_t configfile_t;
#line 114
struct configoption_t;
#line 114 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.h"
typedef struct configoption_t configoption_t;
#line 116
struct command_t;
#line 116 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.h"
typedef struct command_t command_t;
#line 117 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.h"
typedef void context_t;
#line 118 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.h"
typedef void info_t;
#line 126 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.h"
struct configfile_t {
   FILE *stream ;
   char eof ;
   size_t size ;
   context_t *context ;
   configoption_t const   **config_options ;
   int config_option_count ;
   char *filename ;
   unsigned long line ;
   unsigned long flags ;
   char *includepath ;
   int (*errorhandler)(configfile_t * , int  , unsigned long  , char const   * ) ;
   char const   *(*contextchecker)(command_t * , unsigned long  ) ;
   int (*cmp_func)(char const   * , char const   * , size_t  ) ;
};
#line 152 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.h"
struct configoption_t {
   char const   *name ;
   int type ;
   char const   *(*callback)(command_t * , context_t * ) ;
   info_t *info ;
   unsigned long context ;
};
#line 160 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.h"
struct __anonstruct_data_30 {
   long value ;
   char *str ;
   char **list ;
   double dvalue ;
};
#line 160 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.h"
struct command_t {
   char const   *name ;
   configoption_t *option ;
   configfile_t *configfile ;
   context_t *context ;
   int arg_count ;
   struct __anonstruct_data_30 data ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 179 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.h"
configfile_t *dotconf_create(char *fname , configoption_t const   *options , context_t *context ,
                             unsigned long flags ) ;
#line 183
void dotconf_cleanup(configfile_t *configfile ) ;
#line 186
int dotconf_command_loop(configfile_t *configfile ) ;
#line 189
char const   *dotconf_command_loop_until_error(configfile_t *configfile ) ;
#line 192
int dotconf_continue_line(char *buffer , size_t length ) ;
#line 195
int dotconf_get_next_line(char *buffer , size_t bufsize , configfile_t *configfile ) ;
#line 199
char *dotconf_get_here_document(configfile_t *configfile , char const   *delimit ) ;
#line 203
char const   *dotconf_invoke_command(configfile_t *configfile , command_t *cmd ) ;
#line 207
configoption_t *dotconf_find_command(configfile_t *configfile , char const   *command ) ;
#line 215
char *dotconf_read_arg(configfile_t *configfile , signed char **line ) ;
#line 218
char const   *dotconf_handle_command(configfile_t *configfile , char *buffer ) ;
#line 222
int dotconf_register_options(configfile_t *configfile , configoption_t const   *options ) ;
#line 226
int dotconf_warning(configfile_t *configfile , int type , unsigned long errnum , char const   *fmt 
                    , ...) ;
#line 230
void dotconf_callback(configfile_t *configfile , callback_types type , char const   *(*callback)(command_t * ,
                                                                                                 context_t * ) ) ;
#line 234
char *dotconf_substitute_env(configfile_t *configfile , char *str ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf_priv.h"
int dotconf_is_wild_card(char value ) ;
#line 8
int dotconf_handle_wild_card(command_t *cmd , char wild_card , char *path , char *pre ,
                             char *ext ) ;
#line 12
void dotconf_wild_card_cleanup(char *path , char *pre ) ;
#line 16
int dotconf_find_wild_card(char *filename , char *wildcard , char **path , char **pre ,
                           char **ext ) ;
#line 20
int dotconf_strcmp_from_back(char const   *s1 , char const   *s2 ) ;
#line 23
int dotconf_question_mark_match(char *dir_name , char *pre , char *ext ) ;
#line 26
int dotconf_star_match(char *dir_name , char *pre , char *ext ) ;
#line 30
int dotconf_handle_question_mark(command_t *cmd , char *path , char *pre , char *ext ) ;
#line 35
int dotconf_handle_star(command_t *cmd , char *path , char *pre , char *ext ) ;
#line 38
char *get_cwd(void) ;
#line 40
char *get_path(char *name___0 ) ;
#line 74 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
static char name[33]  ;
#line 80
static char const   *dotconf_cb_include(command_t *cmd , context_t *ctx ) ;
#line 81
static char const   *dotconf_cb_includepath(command_t *cmd , context_t *ctx ) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
static configoption_t dotconf_options[3]  = {      {"Include", 2, & dotconf_cb_include, (void *)0, 0UL}, 
        {"IncludePath", 2, & dotconf_cb_includepath, (void *)0, 0UL}, 
        {"", 0, (char const   *(*)(command_t * , context_t * ))((void *)0), (void *)0,
      0UL}};
#line 89 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
static void skip_whitespace(signed char **cp , int n , char term ) 
{ 
  signed char *cp1 ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 91
  cp1 = *cp;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 92
    tmp = __ctype_b_loc();
    }
#line 92
    if ((int const   )*(*tmp + (int )*cp1) & 8192) {
#line 92
      if ((int )*cp1 != (int )term) {
#line 92
        tmp___0 = n;
#line 92
        n --;
#line 92
        if (! tmp___0) {
#line 92
          goto while_break;
        }
      } else {
#line 92
        goto while_break;
      }
    } else {
#line 92
      goto while_break;
    }
#line 93
    cp1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  *cp = cp1;
#line 95
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
static void copy_word(signed char **dest , signed char **src , int max , char term ) 
{ 
  signed char *cp1 ;
  signed char *cp2 ;
  signed char *tmp ;
  signed char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 99
  cp1 = *src;
#line 100
  cp2 = *dest;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    tmp___1 = max;
#line 101
    max --;
#line 101
    if (tmp___1) {
      {
#line 101
      tmp___2 = __ctype_b_loc();
      }
#line 101
      if ((int const   )*(*tmp___2 + (int )*cp1) & 8192) {
#line 101
        goto while_break;
      } else
#line 101
      if (! ((int )*cp1 != (int )term)) {
#line 101
        goto while_break;
      }
    } else {
#line 101
      goto while_break;
    }
#line 102
    tmp = cp2;
#line 102
    cp2 ++;
#line 102
    tmp___0 = cp1;
#line 102
    cp1 ++;
#line 102
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  *cp2 = (signed char)0;
#line 105
  *src = cp1;
#line 106
  *dest = cp2;
#line 107
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
static configoption_t const   *get_argname_fallback(configoption_t const   *options ) 
{ 
  int i ;

  {
#line 114
  i = 0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if ((options + i)->name) {
#line 114
      if (! *((options + i)->name + 0)) {
#line 114
        goto while_break;
      }
    } else {
#line 114
      goto while_break;
    }
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  if ((options + i)->type == 4) {
#line 115
    if ((options + i)->callback) {
#line 116
      return (options + i);
    }
  }
#line 117
  return ((configoption_t const   *)((void *)0));
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
char *dotconf_substitute_env(configfile_t *configfile , char *str ) 
{ 
  char *cp1 ;
  char *cp2 ;
  char *cp3 ;
  char *eos ;
  char *eob ;
  char *env_value ;
  char env_name[4065] ;
  char env_default[4065] ;
  char tmp_value[4065] ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 128
  memset((void *)(env_name), 0, (size_t )4065);
#line 129
  memset((void *)(env_default), 0, (size_t )4065);
#line 130
  memset((void *)(tmp_value), 0, (size_t )4065);
#line 132
  cp1 = str;
#line 133
  tmp = strlen((char const   *)str);
#line 133
  eob = (cp1 + tmp) + 1;
#line 134
  cp2 = tmp_value;
#line 135
  eos = (cp2 + 4064) + 1;
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if ((unsigned long )cp1 < (unsigned long )eob) {
#line 137
      if ((unsigned long )cp2 < (unsigned long )eos) {
#line 137
        if (! ((int )*cp1 != 0)) {
#line 137
          goto while_break;
        }
      } else {
#line 137
        goto while_break;
      }
    } else {
#line 137
      goto while_break;
    }
#line 139
    if ((int )*cp1 == 36) {
#line 139
      if ((int )*(cp1 + 1) == 123) {
#line 140
        cp1 += 2;
#line 141
        cp3 = env_name;
        {
#line 142
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 142
          if ((unsigned long )cp1 < (unsigned long )eob) {
#line 142
            if ((int )*cp1 == 125) {
#line 142
              goto while_break___0;
            } else
#line 142
            if ((int )*cp1 == 58) {
#line 142
              goto while_break___0;
            }
          } else {
#line 142
            goto while_break___0;
          }
#line 143
          tmp___0 = cp3;
#line 143
          cp3 ++;
#line 143
          tmp___1 = cp1;
#line 143
          cp1 ++;
#line 143
          *tmp___0 = *tmp___1;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 144
        *cp3 = (char )'\000';
#line 147
        if ((int )*cp1 == 58) {
#line 147
          if ((int )*(cp1 + 1) == 45) {
#line 148
            cp1 += 2;
#line 149
            cp3 = env_default;
            {
#line 150
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 150
              if ((unsigned long )cp1 < (unsigned long )eob) {
#line 150
                if (! ((int )*cp1 != 125)) {
#line 150
                  goto while_break___1;
                }
              } else {
#line 150
                goto while_break___1;
              }
#line 151
              tmp___2 = cp3;
#line 151
              cp3 ++;
#line 151
              tmp___3 = cp1;
#line 151
              cp1 ++;
#line 151
              *tmp___2 = *tmp___3;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 152
            *cp3 = (char )'\000';
          } else {
#line 147
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 154
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 154
            if ((unsigned long )cp1 < (unsigned long )eob) {
#line 154
              if (! ((int )*cp1 != 125)) {
#line 154
                goto while_break___2;
              }
            } else {
#line 154
              goto while_break___2;
            }
#line 155
            cp1 ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 158
        if ((int )*cp1 != 125) {
          {
#line 159
          dotconf_warning(configfile, 4, 1UL, "Unbalanced \'{\'");
          }
        } else {
          {
#line 163
          cp1 ++;
#line 164
          env_value = getenv((char const   *)(env_name));
          }
#line 164
          if ((unsigned long )env_value != (unsigned long )((void *)0)) {
            {
#line 165
            strncat((char */* __restrict  */)cp2, (char const   */* __restrict  */)env_value,
                    (size_t )(eos - cp2));
#line 166
            tmp___4 = strlen((char const   *)env_value);
#line 166
            cp2 += tmp___4;
            }
          } else {
            {
#line 168
            strncat((char */* __restrict  */)cp2, (char const   */* __restrict  */)(env_default),
                    (size_t )(eos - cp2));
#line 169
            tmp___5 = strlen((char const   *)(env_default));
#line 169
            cp2 += tmp___5;
            }
          }
        }
      }
    }
#line 175
    tmp___6 = cp2;
#line 175
    cp2 ++;
#line 175
    tmp___7 = cp1;
#line 175
    cp1 ++;
#line 175
    *tmp___6 = *tmp___7;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  *cp2 = (char )'\000';
#line 179
  free((void *)str);
#line 180
  tmp___8 = strdup((char const   *)(tmp_value));
  }
#line 180
  return (tmp___8);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
int dotconf_warning(configfile_t *configfile , int type , unsigned long errnum , char const   *fmt 
                    , ...) 
{ 
  va_list args ;
  int retval ;
  char msg[4096] ;

  {
  {
#line 187
  retval = 0;
#line 189
  __builtin_va_start(args, fmt);
  }
#line 190
  if ((unsigned long )configfile->errorhandler != (unsigned long )((int (*)(configfile_t * ,
                                                                            int  ,
                                                                            unsigned long  ,
                                                                            char const   * ))0)) {
    {
#line 192
    vsnprintf((char */* __restrict  */)(msg), (size_t )4096, (char const   */* __restrict  */)fmt,
              args);
#line 193
    retval = (*(configfile->errorhandler))(configfile, type, errnum, (char const   *)(msg));
    }
  } else {
    {
#line 197
    retval = 0;
#line 198
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%ld: ",
            configfile->filename, configfile->line);
#line 200
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             args);
#line 201
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 203
  __builtin_va_end(args);
  }
#line 205
  return (retval);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
int dotconf_register_options(configfile_t *configfile , configoption_t const   *options ) 
{ 
  int num ;
  int ret ;
  configoption_t const   **temp ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 211
  num = configfile->config_option_count;
#line 212
  ret = 0;
#line 213
  temp = configfile->config_options;
#line 218
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 219
    tmp = malloc(sizeof(configoption_t *) * 11UL);
#line 219
    temp = (configoption_t const   **)tmp;
    }
  } else
#line 221
  if (! (num % 10)) {
    {
#line 222
    tmp___0 = realloc((void *)temp, sizeof(configoption_t *) * (unsigned long )((num + 10) + 1));
#line 222
    temp = (configoption_t const   **)tmp___0;
    }
  }
#line 230
  if ((unsigned long )temp != (unsigned long )((void *)0)) {
#line 233
    *(temp + configfile->config_option_count) = options;
#line 234
    configfile->config_options = temp;
#line 235
    (configfile->config_option_count) ++;
#line 235
    *(configfile->config_options + configfile->config_option_count) = (configoption_t const   *)0;
#line 237
    ret = 1;
  }
#line 240
  return (ret);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
void dotconf_callback(configfile_t *configfile , callback_types type , char const   *(*callback)(command_t * ,
                                                                                                 context_t * ) ) 
{ 


  {
  {
#line 247
  if ((unsigned int )type == 1U) {
#line 247
    goto case_1;
  }
#line 250
  if ((unsigned int )type == 2U) {
#line 250
    goto case_2;
  }
#line 254
  goto switch_default;
  case_1: /* CIL Label */ 
#line 248
  configfile->errorhandler = (int (*)(configfile_t * , int  , unsigned long  , char const   * ))callback;
#line 249
  goto switch_break;
  case_2: /* CIL Label */ 
#line 251
  configfile->contextchecker = (char const   *(*)(command_t * , unsigned long  ))callback;
#line 253
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 255
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 257
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
int dotconf_continue_line(char *buffer , size_t length ) 
{ 
  char *cp1 ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 262
  cp1 = (buffer + length) - 1;
#line 264
  if (length < 2UL) {
#line 265
    return (0);
  }
#line 267
  tmp = cp1;
#line 267
  cp1 --;
#line 267
  if ((int )*tmp != 10) {
#line 268
    return (0);
  }
#line 270
  if ((int )*cp1 == 13) {
#line 271
    cp1 --;
  }
#line 273
  tmp___0 = cp1;
#line 273
  cp1 --;
#line 273
  if ((int )*tmp___0 != 92) {
#line 274
    return (0);
  }
#line 276
  *(cp1 + 1) = (char)0;
#line 277
  return ((int )*cp1 != 92);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
int dotconf_get_next_line(char *buffer , size_t bufsize , configfile_t *configfile ) 
{ 
  char *cp1 ;
  char *cp2 ;
  char buf2[4096] ;
  int length ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 287
  if (configfile->eof) {
#line 288
    return (1);
  }
  {
#line 290
  cp1 = fgets((char */* __restrict  */)buffer, 4096, (FILE */* __restrict  */)configfile->stream);
  }
#line 292
  if (! cp1) {
#line 293
    configfile->eof = (char)1;
#line 294
    return (1);
  }
  {
#line 297
  (configfile->line) ++;
#line 298
  tmp = strlen((char const   *)cp1);
#line 298
  length = (int )tmp;
  }
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 299
    tmp___1 = dotconf_continue_line(cp1, (size_t )length);
    }
#line 299
    if (! tmp___1) {
#line 299
      goto while_break;
    }
    {
#line 300
    cp2 = fgets((char */* __restrict  */)(buf2), 4096, (FILE */* __restrict  */)configfile->stream);
    }
#line 301
    if (! cp2) {
      {
#line 302
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[dotconf] Parse error. Unexpected end of file at line %ld in file %s\n",
              configfile->line, configfile->filename);
#line 306
      configfile->eof = (char)1;
      }
#line 307
      return (1);
    }
    {
#line 309
    (configfile->line) ++;
#line 310
    strcpy((char */* __restrict  */)((cp1 + length) - 2), (char const   */* __restrict  */)cp2);
#line 311
    tmp___0 = strlen((char const   *)cp1);
#line 311
    length = (int )tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  return (0);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
char *dotconf_get_here_document(configfile_t *configfile , char const   *delimit ) 
{ 
  unsigned int limit_len ;
  char here_string ;
  char buffer[4096] ;
  char *here_doc ;
  char here_limit[9] ;
  struct stat finfo ;
  int offset ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;

  {
#line 323
  here_doc = (char *)0;
#line 326
  offset = 0;
#line 328
  if (configfile->size <= 0UL) {
    {
#line 329
    tmp = stat((char const   */* __restrict  */)configfile->filename, (struct stat */* __restrict  */)(& finfo));
    }
#line 329
    if (tmp) {
      {
#line 330
      dotconf_warning(configfile, 0, 5UL, "[emerg] could not stat currently read file (%s)\n",
                      configfile->filename);
      }
#line 333
      return ((char *)((void *)0));
    }
#line 335
    configfile->size = (size_t )finfo.st_size;
  }
  {
#line 342
  tmp___0 = malloc(configfile->size);
#line 342
  here_doc = (char *)tmp___0;
#line 343
  memset((void *)here_doc, 0, configfile->size);
#line 345
  here_string = (char)1;
#line 346
  tmp___1 = snprintf((char */* __restrict  */)(here_limit), (size_t )9, (char const   */* __restrict  */)"%s",
                     delimit);
#line 346
  limit_len = (unsigned int )tmp___1;
  }
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 347
    tmp___4 = dotconf_get_next_line(buffer, (size_t )4096, configfile);
    }
#line 347
    if (tmp___4) {
#line 347
      goto while_break;
    }
    {
#line 348
    tmp___2 = strncmp((char const   *)(here_limit), (char const   *)(buffer), (size_t )(limit_len - 1U));
    }
#line 348
    if (! tmp___2) {
#line 349
      here_string = (char)0;
#line 350
      goto while_break;
    }
    {
#line 352
    tmp___3 = snprintf((char */* __restrict  */)(here_doc + offset), (configfile->size - (size_t )offset) - 1UL,
                       (char const   */* __restrict  */)"%s", buffer);
#line 352
    offset += tmp___3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  if (here_string) {
    {
#line 357
    dotconf_warning(configfile, 4, 1UL, "Unterminated here-document!");
    }
  }
  {
#line 360
  *(here_doc + (offset - 1)) = (char )'\000';
#line 362
  tmp___5 = realloc((void *)here_doc, (size_t )offset);
  }
#line 362
  return ((char *)tmp___5);
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
char const   *dotconf_invoke_command(configfile_t *configfile , command_t *cmd ) 
{ 
  char const   *error ;

  {
  {
#line 367
  error = (char const   *)0;
#line 369
  error = (*((cmd->option)->callback))(cmd, configfile->context);
  }
#line 370
  return (error);
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
char *dotconf_read_arg(configfile_t *configfile , signed char **line ) 
{ 
  int sq ;
  int dq ;
  int done ;
  signed char *cp1 ;
  char *cp2 ;
  char *eos ;
  char buf[4064] ;
  char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 375
  sq = 0;
#line 375
  dq = 0;
#line 377
  cp1 = *line;
#line 381
  memset((void *)(buf), 0, (size_t )4064);
#line 382
  done = 0;
#line 383
  cp2 = buf;
#line 384
  eos = (cp2 + 4064) - 1;
  }
#line 386
  if ((int )*cp1 == 35) {
#line 387
    return ((char *)((void *)0));
  } else
#line 386
  if (! *cp1) {
#line 387
    return ((char *)((void *)0));
  }
  {
#line 389
  skip_whitespace(& cp1, 4064, (char)0);
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if ((int )*cp1 != 0) {
#line 391
      if ((unsigned long )cp2 != (unsigned long )eos) {
#line 391
        if (! (! done)) {
#line 391
          goto while_break;
        }
      } else {
#line 391
        goto while_break;
      }
    } else {
#line 391
      goto while_break;
    }
    {
#line 393
    if ((int )*cp1 == 39) {
#line 393
      goto case_39;
    }
#line 401
    if ((int )*cp1 == 34) {
#line 401
      goto case_34;
    }
#line 409
    if ((int )*cp1 == 92) {
#line 409
      goto case_92;
    }
#line 416
    goto switch_default;
    case_39: /* CIL Label */ 
#line 394
    if (dq) {
#line 395
      goto switch_break;
    }
#line 396
    if (sq) {
#line 397
      sq --;
    } else
#line 398
    if (! sq) {
#line 399
      sq ++;
    }
#line 400
    goto switch_break;
    case_34: /* CIL Label */ 
#line 402
    if (sq) {
#line 403
      goto switch_break;
    }
#line 404
    if (dq) {
#line 405
      dq --;
    } else
#line 406
    if (! dq) {
#line 407
      dq ++;
    }
#line 408
    goto switch_break;
    case_92: /* CIL Label */ 
#line 410
    if (! *(cp1 + 1)) {
#line 411
      goto switch_break;
    }
#line 412
    tmp = cp2;
#line 412
    cp2 ++;
#line 412
    cp1 ++;
#line 412
    *tmp = (char )*cp1;
#line 413
    cp1 ++;
#line 414
    goto while_continue;
#line 415
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 417
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 421
    tmp___2 = __ctype_b_loc();
    }
#line 421
    if ((int const   )*(*tmp___2 + (int )*cp1) & 8192) {
#line 421
      if (! dq) {
#line 421
        if (! sq) {
#line 422
          *cp2 = (char )'\000';
#line 423
          goto while_break;
        } else {
#line 421
          goto _L___8;
        }
      } else {
#line 421
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 426
    if ((int )*cp1 == 35) {
#line 426
      if (! dq) {
#line 426
        if (! sq) {
#line 426
          if (! (configfile->flags & (unsigned long )(1 << 2))) {
#line 433
            *cp2 = (char)0;
#line 434
            *cp1 = (signed char)0;
#line 435
            *line = cp1;
#line 436
            return ((char *)((void *)0));
          } else {
#line 426
            goto _L___6;
          }
        } else {
#line 426
          goto _L___6;
        }
      } else {
#line 426
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
      {
#line 439
      tmp___1 = __ctype_b_loc();
      }
#line 439
      if ((int const   )*(*tmp___1 + (int )*cp1) & 8192) {
        _L___3: /* CIL Label */ 
#line 439
        if (dq) {
#line 439
          if ((int )*cp1 != 34) {
#line 442
            tmp___0 = cp2;
#line 442
            cp2 ++;
#line 442
            *tmp___0 = (char )*cp1;
          } else {
#line 439
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 439
        if (sq) {
#line 439
          if ((int )*cp1 != 39) {
#line 442
            tmp___0 = cp2;
#line 442
            cp2 ++;
#line 442
            *tmp___0 = (char )*cp1;
          }
        }
      } else
#line 439
      if (! dq) {
#line 439
        if (! sq) {
#line 439
          if ((int )*cp1 != 34) {
#line 439
            if ((int )*cp1 != 39) {
#line 442
              tmp___0 = cp2;
#line 442
              cp2 ++;
#line 442
              *tmp___0 = (char )*cp1;
            } else {
#line 439
              goto _L___3;
            }
          } else {
#line 439
            goto _L___3;
          }
        } else {
#line 439
          goto _L___3;
        }
      } else {
#line 439
        goto _L___3;
      }
    }
#line 445
    cp1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  *line = cp1;
#line 454
  if ((configfile->flags & (unsigned long )(1 << 1)) == (unsigned long )(1 << 1)) {
#line 455
    if (buf[0]) {
      {
#line 455
      tmp___3 = strdup((char const   *)(buf));
#line 455
      tmp___4 = tmp___3;
      }
    } else {
#line 455
      tmp___4 = (char *)((void *)0);
    }
#line 455
    return (tmp___4);
  }
#line 456
  if (buf[0]) {
    {
#line 456
    tmp___5 = strdup((char const   *)(buf));
#line 456
    tmp___6 = dotconf_substitute_env(configfile, tmp___5);
#line 456
    tmp___7 = tmp___6;
    }
  } else {
#line 456
    tmp___7 = (char *)((void *)0);
  }
#line 456
  return (tmp___7);
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
configoption_t *dotconf_find_command(configfile_t *configfile , char const   *command ) 
{ 
  configoption_t *option ;
  int i ;
  int mod ;
  int done ;
  int tmp ;

  {
#line 467
  i = 0;
#line 467
  mod = 0;
#line 467
  done = 0;
#line 469
  option = (configoption_t *)0;
#line 469
  mod = 0;
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 469
    if (*(configfile->config_options + mod)) {
#line 469
      if (! (! done)) {
#line 469
        goto while_break;
      }
    } else {
#line 469
      goto while_break;
    }
#line 471
    i = 0;
    {
#line 471
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 471
      if (! *((*(configfile->config_options + mod) + i)->name + 0)) {
#line 471
        goto while_break___0;
      }
      {
#line 472
      tmp = (*(configfile->cmp_func))((char const   *)(name), (char const   *)(*(configfile->config_options + mod) + i)->name,
                                      (size_t )32);
      }
#line 472
      if (! tmp) {
#line 476
        option = (configoption_t *)(*(configfile->config_options + mod) + i);
#line 480
        done = 1;
#line 481
        goto while_break___0;
      }
#line 471
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 469
    mod ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  if (option) {
#line 486
    if ((int const   )*(option->name + 0) == 0) {
#line 488
      option = (configoption_t *)(*(configfile->config_options + (mod - 1)) + i);
    } else {
#line 486
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 486
  if ((*(configfile->config_options + (mod - 1)) + i)->type == 4) {
#line 488
    option = (configoption_t *)(*(configfile->config_options + (mod - 1)) + i);
  }
#line 492
  return (option);
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
void dotconf_set_command(configfile_t *configfile , configoption_t const   *option ,
                         signed char *args , command_t *cmd ) 
{ 
  signed char *eob ;
  size_t tmp ;
  void *tmp___0 ;
  signed char *cp ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 499
  tmp = strlen((char const   *)args);
#line 499
  eob = args + tmp;
  }
#line 502
  if (option->type == 4) {
#line 502
    cmd->name = (char const   *)(name);
  } else {
#line 502
    cmd->name = (char const   *)option->name;
  }
  {
#line 503
  cmd->option = (configoption_t *)option;
#line 504
  cmd->context = configfile->context;
#line 505
  cmd->configfile = configfile;
#line 506
  tmp___0 = calloc((size_t )16, sizeof(char *));
#line 506
  cmd->data.list = (char **)tmp___0;
#line 507
  cmd->data.str = (char *)0;
  }
#line 509
  if (option->type == 5) {
    {
#line 512
    cmd->data.str = strdup((char const   *)args);
    }
  } else
#line 513
  if (option->type == 2) {
    {
#line 514
    cp = args;
#line 517
    skip_whitespace(& cp, (int )(eob - cp), (char)0);
#line 519
    tmp___1 = strncmp("<<", (char const   *)cp, (size_t )2);
    }
#line 519
    if (! tmp___1) {
      {
#line 520
      cmd->data.str = dotconf_get_here_document(configfile, (char const   *)(cp + 2));
#line 522
      cmd->arg_count = 1;
      }
    }
  }
#line 526
  if (option->type == 2) {
#line 526
    if (! ((unsigned long )cmd->data.str != (unsigned long )((char *)0))) {
#line 526
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 529
    skip_whitespace(& args, (int )(eob - args), (char)0);
#line 531
    cmd->arg_count = 0;
    }
    {
#line 532
    while (1) {
      while_continue: /* CIL Label */ ;
#line 532
      if (cmd->arg_count < 15) {
        {
#line 532
        tmp___2 = dotconf_read_arg(configfile, & args);
#line 532
        *(cmd->data.list + cmd->arg_count) = tmp___2;
        }
#line 532
        if (! tmp___2) {
#line 532
          goto while_break;
        }
      } else {
#line 532
        goto while_break;
      }
#line 535
      (cmd->arg_count) ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 538
    skip_whitespace(& args, (int )(eob - args), (char)0);
    }
#line 540
    if (cmd->arg_count) {
#line 540
      if (*(cmd->data.list + (cmd->arg_count - 1))) {
#line 540
        if (*args) {
          {
#line 542
          tmp___3 = cmd->arg_count;
#line 542
          (cmd->arg_count) ++;
#line 542
          *(cmd->data.list + tmp___3) = strdup((char const   *)args);
          }
        }
      }
    }
#line 545
    if (option->name) {
#line 545
      if ((int const   )*(option->name + 0) > 32) {
#line 545
        goto _L___0;
      } else {
#line 545
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 545
    if (option->type == 4) {
      _L___0: /* CIL Label */ 
      {
#line 549
      if (option->type == 0) {
#line 549
        goto case_0;
      }
#line 563
      if (option->type == 1) {
#line 563
        goto case_1;
      }
#line 577
      if (option->type == 7) {
#line 577
        goto case_7;
      }
#line 590
      if (option->type == 2) {
#line 590
        goto case_2;
      }
#line 606
      goto switch_default;
      case_0: /* CIL Label */ 
#line 551
      if (cmd->arg_count < 1) {
        {
#line 552
        dotconf_warning(configfile, 4, 3UL, "Missing argument to option \'%s\'", name);
        }
#line 557
        return;
      }
#line 560
      if ((int )*(*(cmd->data.list + 0) + 0) == 89) {
#line 560
        tmp___4 = 1;
      } else
#line 560
      if ((int )*(*(cmd->data.list + 0) + 0) == 121) {
#line 560
        tmp___4 = 1;
      } else
#line 560
      if ((int )*(*(cmd->data.list + 0) + 0) == 49) {
#line 560
        tmp___4 = 1;
      } else
#line 560
      if ((int )*(*(cmd->data.list + 0) + 0) == 111) {
#line 560
        goto _L;
      } else
#line 560
      if ((int )*(*(cmd->data.list + 0) + 0) == 79) {
        _L: /* CIL Label */ 
#line 560
        if ((int )*(*(cmd->data.list + 0) + 1) == 110) {
#line 560
          tmp___4 = 1;
        } else
#line 560
        if ((int )*(*(cmd->data.list + 0) + 1) == 78) {
#line 560
          tmp___4 = 1;
        } else {
#line 560
          tmp___4 = 0;
        }
      } else {
#line 560
        tmp___4 = 0;
      }
#line 560
      cmd->data.value = (long )tmp___4;
#line 562
      goto switch_break;
      case_1: /* CIL Label */ 
#line 564
      if (cmd->arg_count < 1) {
        {
#line 565
        dotconf_warning(configfile, 4, 3UL, "Missing argument to option \'%s\'", name);
        }
#line 570
        return;
      }
      {
#line 573
      sscanf((char const   */* __restrict  */)*(cmd->data.list + 0), (char const   */* __restrict  */)"%li",
             & cmd->data.value);
      }
#line 575
      goto switch_break;
      case_7: /* CIL Label */ 
#line 578
      if (cmd->arg_count < 1) {
        {
#line 579
        dotconf_warning(configfile, 4, 3UL, "Missing argument to option \'%s\'", name);
        }
#line 584
        return;
      }
      {
#line 587
      cmd->data.dvalue = strtod((char const   */* __restrict  */)*(cmd->data.list + 0),
                                (char **/* __restrict  */)0);
      }
#line 588
      goto switch_break;
      case_2: /* CIL Label */ 
#line 591
      if (cmd->arg_count < 1) {
        {
#line 592
        dotconf_warning(configfile, 4, 3UL, "Missing argument to option \'%s\'", name);
        }
#line 597
        return;
      }
      {
#line 600
      cmd->data.str = strdup((char const   *)*(cmd->data.list + 0));
      }
#line 601
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 607
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 611
  return;
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
void dotconf_free_command(command_t *command ) 
{ 
  int i ;

  {
#line 617
  if (command->data.str) {
    {
#line 618
    free((void *)command->data.str);
    }
  }
#line 620
  i = 0;
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 620
    if (! (i < command->arg_count)) {
#line 620
      goto while_break;
    }
    {
#line 621
    free((void *)*(command->data.list + i));
#line 620
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 622
  free((void *)command->data.list);
  }
#line 623
  return;
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
char const   *dotconf_handle_command(configfile_t *configfile , char *buffer ) 
{ 
  signed char *cp1 ;
  signed char *cp2 ;
  signed char *eob ;
  char const   *error ;
  char const   *context_error ;
  command_t command ;
  int mod ;
  int next_opt_idx ;
  size_t tmp ;
  long tmp___0 ;
  configoption_t const   *option ;
  int done ;
  int opt_idx ;
  int tmp___1 ;

  {
  {
#line 634
  mod = 0;
#line 635
  next_opt_idx = 0;
#line 637
  memset((void *)(& command), 0, sizeof(command_t ));
#line 638
  name[0] = (char)0;
#line 639
  error = (char const   *)0;
#line 640
  context_error = (char const   *)0;
#line 642
  cp1 = (signed char *)buffer;
#line 643
  tmp = strlen((char const   *)cp1);
#line 643
  eob = cp1 + tmp;
#line 645
  skip_whitespace(& cp1, (int )(eob - cp1), (char)0);
  }
#line 648
  if (! cp1) {
#line 649
    return ((char const   *)((void *)0));
  } else
#line 648
  if (! *cp1) {
#line 649
    return ((char const   *)((void *)0));
  } else
#line 648
  if ((int )*cp1 == 35) {
#line 649
    return ((char const   *)((void *)0));
  } else
#line 648
  if ((int )*cp1 == 10) {
#line 649
    return ((char const   *)((void *)0));
  } else
#line 648
  if ((int )*cp1 == -1) {
#line 649
    return ((char const   *)((void *)0));
  }
#line 652
  if ((unsigned long )cp1 == (unsigned long )eob) {
#line 653
    return ((char const   *)((void *)0));
  }
#line 656
  cp2 = (signed char *)(name);
#line 657
  if (eob - cp1 < 32L) {
#line 657
    tmp___0 = eob - cp1;
  } else {
#line 657
    tmp___0 = 32L;
  }
  {
#line 657
  copy_word(& cp2, & cp1, (int )tmp___0, (char)0);
  }
  {
#line 659
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    done = 0;
#line 662
    opt_idx = 0;
#line 664
    option = (configoption_t const   *)0;
    {
#line 664
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 664
      if (*(configfile->config_options + mod)) {
#line 664
        if (! (! done)) {
#line 664
          goto while_break___0;
        }
      } else {
#line 664
        goto while_break___0;
      }
#line 666
      opt_idx = next_opt_idx;
      {
#line 666
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 666
        if (! *((*(configfile->config_options + mod) + opt_idx)->name + 0)) {
#line 666
          goto while_break___1;
        }
        {
#line 669
        tmp___1 = (*(configfile->cmp_func))((char const   *)(name), (char const   *)(*(configfile->config_options + mod) + opt_idx)->name,
                                            (size_t )32);
        }
#line 669
        if (! tmp___1) {
#line 675
          option = (configoption_t const   *)((configoption_t *)(*(configfile->config_options + mod) + opt_idx));
#line 678
          done = 1;
#line 679
          goto while_break___1;
        }
#line 666
        opt_idx ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 664
      mod ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 684
    if (! option) {
      {
#line 685
      option = get_argname_fallback(*(configfile->config_options + 1));
      }
    }
#line 688
    if (! option) {
#line 688
      goto _L;
    } else
#line 688
    if (! option->callback) {
      _L: /* CIL Label */ 
#line 689
      if (error) {
#line 690
        return (error);
      }
      {
#line 691
      dotconf_warning(configfile, 6, 2UL, "Unknown Config-Option: \'%s\'", name);
      }
#line 694
      return ((char const   *)((void *)0));
    }
    {
#line 698
    dotconf_set_command(configfile, option, cp1, & command);
    }
#line 700
    if (configfile->contextchecker) {
      {
#line 701
      context_error = (*(configfile->contextchecker))(& command, (command.option)->context);
      }
    }
#line 705
    if (! context_error) {
      {
#line 706
      error = dotconf_invoke_command(configfile, & command);
      }
    } else
#line 708
    if (! error) {
#line 711
      error = context_error;
    }
    {
#line 715
    dotconf_free_command(& command);
    }
#line 717
    if (! context_error) {
#line 720
      goto while_break;
    } else
#line 717
    if (! (configfile->flags & (unsigned long )(1 << 3))) {
#line 720
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 724
  return (error);
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
char const   *dotconf_command_loop_until_error(configfile_t *configfile ) 
{ 
  char buffer[4096] ;
  char const   *error ;
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 731
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 731
    tmp___0 = dotconf_get_next_line(buffer, (size_t )4096, configfile);
    }
#line 731
    if (tmp___0) {
#line 731
      goto while_break;
    }
    {
#line 732
    tmp = dotconf_handle_command(configfile, buffer);
#line 732
    error = tmp;
    }
#line 733
    if (error) {
#line 734
      return (error);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 736
  return ((char const   *)((void *)0));
}
}
#line 739 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
int dotconf_command_loop(configfile_t *configfile ) 
{ 
  char buffer[4096] ;
  char const   *error ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 744
    tmp___1 = dotconf_get_next_line(buffer, (size_t )4096, configfile);
    }
#line 744
    if (tmp___1) {
#line 744
      goto while_break;
    }
    {
#line 745
    tmp = dotconf_handle_command(configfile, buffer);
#line 745
    error = tmp;
    }
#line 746
    if ((unsigned long )error != (unsigned long )((void *)0)) {
      {
#line 747
      tmp___0 = dotconf_warning(configfile, 3, 0UL, error);
      }
#line 747
      if (tmp___0) {
#line 748
        return (0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 751
  return (1);
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
void dotconf_cleanup(configfile_t *configfile ) 
{ 


  {
#line 756
  if (configfile->stream) {
    {
#line 757
    fclose(configfile->stream);
    }
  }
#line 759
  if (configfile->filename) {
    {
#line 760
    free((void *)configfile->filename);
    }
  }
#line 762
  if (configfile->config_options) {
    {
#line 763
    free((void *)configfile->config_options);
    }
  }
#line 765
  if (configfile->includepath) {
    {
#line 766
    free((void *)configfile->includepath);
    }
  }
  {
#line 768
  free((void *)configfile);
  }
#line 769
  return;
}
}
#line 771 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
configfile_t *dotconf_create(char *fname , configoption_t const   *options , context_t *context ,
                             unsigned long flags ) 
{ 
  char *dc_env ;
  int registered ;
  configfile_t *new_cfg ;
  void *tmp ;
  char *path ;
  char *cwd ;
  void *tmp___0 ;

  {
  {
#line 774
  dc_env = (char *)((void *)0);
#line 775
  registered = 0;
#line 776
  tmp = calloc((size_t )1, sizeof(configfile_t ));
#line 776
  new_cfg = (configfile_t *)tmp;
#line 777
  path = (char *)((void *)0);
#line 778
  cwd = (char *)((void *)0);
  }
#line 780
  if (! new_cfg) {
#line 781
    return ((configfile_t *)((void *)0));
  }
#line 791
  new_cfg->context = context;
#line 792
  new_cfg->flags = flags;
#line 793
  if (new_cfg->flags & 1UL) {
#line 794
    new_cfg->cmp_func = (int (*)(char const   * , char const   * , size_t  ))(& strncasecmp);
  } else {
#line 796
    new_cfg->cmp_func = (int (*)(char const   * , char const   * , size_t  ))(& strncmp);
  }
  {
#line 798
  new_cfg->stream = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
#line 799
  if ((unsigned long )new_cfg->stream == (unsigned long )((void *)0)) {
    {
#line 800
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening configuration file \'%s\'\n",
            fname);
#line 802
    dotconf_cleanup(new_cfg);
    }
#line 803
    return ((configfile_t *)((void *)0));
  }
  {
#line 806
  registered = dotconf_register_options(new_cfg, (configoption_t const   *)(dotconf_options));
  }
#line 807
  if (! registered) {
    {
#line 808
    dotconf_cleanup(new_cfg);
    }
#line 809
    return ((configfile_t *)((void *)0));
  }
  {
#line 812
  registered = dotconf_register_options(new_cfg, options);
  }
#line 813
  if (! registered) {
    {
#line 814
    dotconf_cleanup(new_cfg);
    }
#line 815
    return ((configfile_t *)((void *)0));
  }
  {
#line 818
  new_cfg->filename = strdup((char const   *)fname);
  }
#line 819
  if (! new_cfg->filename) {
    {
#line 820
    dotconf_cleanup(new_cfg);
    }
#line 821
    return ((configfile_t *)((void *)0));
  }
  {
#line 824
  tmp___0 = malloc((size_t )256);
#line 824
  new_cfg->includepath = (char *)tmp___0;
  }
#line 825
  if (! new_cfg->includepath) {
    {
#line 826
    dotconf_cleanup(new_cfg);
    }
#line 827
    return ((configfile_t *)((void *)0));
  }
  {
#line 830
  *(new_cfg->includepath + 0) = (char)0;
#line 837
  dc_env = getenv("DC_INCLUDEPATH");
  }
#line 838
  if ((unsigned long )dc_env != (unsigned long )((void *)0)) {
    {
#line 839
    snprintf((char */* __restrict  */)new_cfg->includepath, (size_t )256, (char const   */* __restrict  */)"%s",
             dc_env);
    }
  } else {
    {
#line 841
    path = get_path(fname);
    }
#line 842
    if ((unsigned long )path != (unsigned long )((void *)0)) {
#line 843
      if ((int )*(path + 0) == 47) {
        {
#line 844
        snprintf((char */* __restrict  */)new_cfg->includepath, (size_t )256, (char const   */* __restrict  */)"%s",
                 path);
        }
      } else {
        {
#line 846
        cwd = get_cwd();
        }
#line 847
        if ((unsigned long )cwd != (unsigned long )((void *)0)) {
          {
#line 848
          snprintf((char */* __restrict  */)new_cfg->includepath, (size_t )256, (char const   */* __restrict  */)"%s/%s",
                   cwd, path);
#line 850
          free((void *)cwd);
          }
        }
      }
      {
#line 853
      free((void *)path);
      }
    }
  }
#line 856
  return (new_cfg);
}
}
#line 860 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
int dotconf_is_wild_card(char value ) 
{ 
  int retval ;
  int i ;
  int wildcards_len ;
  size_t tmp ;

  {
  {
#line 862
  retval = 0;
#line 864
  tmp = strlen("*?");
#line 864
  wildcards_len = (int )tmp;
#line 866
  i = 0;
  }
  {
#line 866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 866
    if (! (i < wildcards_len)) {
#line 866
      goto while_break;
    }
#line 867
    if ((int )value == (int )*("*?" + i)) {
#line 868
      retval = 1;
#line 869
      goto while_break;
    }
#line 866
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 873
  return (retval);
}
}
#line 877 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
int dotconf_handle_wild_card(command_t *cmd , char wild_card , char *path , char *pre ,
                             char *ext ) 
{ 
  int retval ;

  {
#line 880
  retval = 0;
  {
#line 883
  if ((int )wild_card == 42) {
#line 883
    goto case_42;
  }
#line 889
  if ((int )wild_card == 63) {
#line 889
    goto case_63;
  }
#line 895
  goto switch_default;
  case_42: /* CIL Label */ 
  {
#line 885
  retval = dotconf_handle_star(cmd, path, pre, ext);
  }
#line 887
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 891
  retval = dotconf_handle_question_mark(cmd, path, pre, ext);
  }
#line 893
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 896
  retval = -1;
  switch_break: /* CIL Label */ ;
  }
#line 899
  return (retval);
}
}
#line 903 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
void dotconf_wild_card_cleanup(char *path , char *pre ) 
{ 


  {
#line 906
  if ((unsigned long )path != (unsigned long )((void *)0)) {
    {
#line 907
    free((void *)path);
    }
  }
#line 910
  if ((unsigned long )pre != (unsigned long )((void *)0)) {
    {
#line 911
    free((void *)pre);
    }
  }
#line 914
  return;
}
}
#line 918 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
int dotconf_find_wild_card(char *filename , char *wildcard , char **path , char **pre ,
                           char **ext ) 
{ 
  int retval ;
  int prefix_len ;
  int tmp_count ;
  char *tmp ;
  int found_path ;
  int len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 921
  retval = -1;
#line 922
  prefix_len = 0;
#line 923
  tmp_count = 0;
#line 924
  tmp = (char *)0;
#line 925
  found_path = 0;
#line 927
  tmp___0 = strlen((char const   *)filename);
#line 927
  len = (int )tmp___0;
  }
#line 929
  if ((unsigned long )wildcard != (unsigned long )((void *)0)) {
#line 929
    if (len > 0) {
#line 929
      if ((unsigned long )path != (unsigned long )((void *)0)) {
#line 929
        if ((unsigned long )pre != (unsigned long )((void *)0)) {
#line 929
          if ((unsigned long )ext != (unsigned long )((void *)0)) {
            {
#line 931
            tmp___1 = strcspn((char const   *)filename, "*?");
#line 931
            prefix_len = (int )tmp___1;
            }
#line 933
            if (prefix_len < len) {
#line 934
              tmp = filename + prefix_len;
#line 935
              tmp_count = prefix_len + 1;
              {
#line 937
              while (1) {
                while_continue: /* CIL Label */ ;
#line 937
                if ((unsigned long )tmp != (unsigned long )filename) {
#line 937
                  if (! ((int )*tmp != 47)) {
#line 937
                    goto while_break;
                  }
                } else {
#line 937
                  goto while_break;
                }
#line 938
                tmp --;
#line 939
                tmp_count --;
              }
              while_break: /* CIL Label */ ;
              }
#line 942
              if ((int )*tmp == 47) {
                {
#line 943
                tmp___2 = malloc((size_t )(tmp_count + 1));
#line 943
                *path = (char *)tmp___2;
#line 944
                found_path = 1;
                }
              } else {
                {
#line 948
                tmp___3 = malloc((size_t )1);
#line 948
                *path = (char *)tmp___3;
                }
              }
#line 950
              if (found_path) {
#line 950
                tmp___4 = 0;
              } else {
#line 950
                tmp___4 = 1;
              }
              {
#line 950
              tmp___5 = malloc((size_t )((prefix_len - (tmp_count - tmp___4)) + 1));
#line 950
              *pre = (char *)tmp___5;
              }
#line 955
              if (*path) {
#line 955
                if (*pre) {
#line 956
                  if (found_path) {
                    {
#line 957
                    strncpy((char */* __restrict  */)*path, (char const   */* __restrict  */)filename,
                            (size_t )tmp_count);
                    }
                  }
#line 958
                  *(*path + tmp_count) = (char )'\000';
#line 960
                  if (found_path) {
#line 960
                    tmp___6 = 0;
                  } else {
#line 960
                    tmp___6 = 1;
                  }
#line 960
                  if (found_path) {
#line 960
                    tmp___7 = 1;
                  } else {
#line 960
                    tmp___7 = 0;
                  }
                  {
#line 960
                  strncpy((char */* __restrict  */)*pre, (char const   */* __restrict  */)(tmp + tmp___7),
                          (size_t )(prefix_len - (tmp_count - tmp___6)));
                  }
#line 963
                  if (found_path) {
#line 963
                    tmp___8 = 0;
                  } else {
#line 963
                    tmp___8 = 1;
                  }
#line 963
                  *(*pre + (prefix_len - (tmp_count - tmp___8))) = (char )'\000';
#line 967
                  *ext = filename + prefix_len;
#line 968
                  *wildcard = *(*ext);
#line 969
                  (*ext) ++;
#line 971
                  retval = prefix_len;
                }
              }
            }
          }
        }
      }
    }
  }
#line 979
  return (retval);
}
}
#line 983 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
int dotconf_strcmp_from_back(char const   *s1 , char const   *s2 ) 
{ 
  int retval ;
  int i ;
  int j ;
  int len_1 ;
  size_t tmp ;
  int len_2 ;
  size_t tmp___0 ;

  {
  {
#line 985
  retval = 0;
#line 987
  tmp = strlen(s1);
#line 987
  len_1 = (int )tmp;
#line 988
  tmp___0 = strlen(s2);
#line 988
  len_2 = (int )tmp___0;
#line 990
  i = len_1;
#line 990
  j = len_2;
  }
  {
#line 990
  while (1) {
    while_continue: /* CIL Label */ ;
#line 990
    if (i >= 0) {
#line 990
      if (! (j >= 0)) {
#line 990
        goto while_break;
      }
    } else {
#line 990
      goto while_break;
    }
#line 991
    if ((int const   )*(s1 + i) != (int const   )*(s2 + j)) {
#line 992
      retval = -1;
#line 993
      goto while_break;
    }
#line 990
    i --;
#line 990
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 997
  return (retval);
}
}
#line 1001 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
int dotconf_question_mark_match(char *dir_name , char *pre , char *ext ) 
{ 
  int retval ;
  int dir_name_len ;
  size_t tmp ;
  int pre_len ;
  size_t tmp___0 ;
  int ext_len ;
  size_t tmp___1 ;
  int w_card_check ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1003
  retval = -1;
#line 1004
  tmp = strlen((char const   *)dir_name);
#line 1004
  dir_name_len = (int )tmp;
#line 1005
  tmp___0 = strlen((char const   *)pre);
#line 1005
  pre_len = (int )tmp___0;
#line 1006
  tmp___1 = strlen((char const   *)ext);
#line 1006
  ext_len = (int )tmp___1;
#line 1007
  tmp___2 = strcspn((char const   *)ext, "*?");
#line 1007
  w_card_check = (int )tmp___2;
  }
#line 1009
  if (w_card_check < ext_len) {
    {
#line 1009
    tmp___6 = strncmp((char const   *)dir_name, (char const   *)pre, (size_t )pre_len);
    }
#line 1009
    if (tmp___6 == 0) {
      {
#line 1009
      tmp___7 = strcmp((char const   *)dir_name, ".");
      }
#line 1009
      if (tmp___7 != 0) {
        {
#line 1009
        tmp___8 = strcmp((char const   *)dir_name, "..");
        }
#line 1009
        if (tmp___8 != 0) {
#line 1011
          retval = 1;
        } else {
#line 1009
          goto _L___1;
        }
      } else {
#line 1009
        goto _L___1;
      }
    } else {
#line 1009
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1015
  if (dir_name_len >= pre_len) {
    {
#line 1015
    tmp___3 = strncmp((char const   *)dir_name, (char const   *)pre, (size_t )pre_len);
    }
#line 1015
    if (tmp___3 == 0) {
      {
#line 1015
      tmp___4 = strcmp((char const   *)dir_name, ".");
      }
#line 1015
      if (tmp___4 != 0) {
        {
#line 1015
        tmp___5 = strcmp((char const   *)dir_name, "..");
        }
#line 1015
        if (tmp___5 != 0) {
#line 1019
          retval = 0;
        }
      }
    }
  }
#line 1024
  return (retval);
}
}
#line 1028 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
int dotconf_star_match(char *dir_name , char *pre , char *ext ) 
{ 
  int retval ;
  int dir_name_len ;
  size_t tmp ;
  int pre_len ;
  size_t tmp___0 ;
  int ext_len ;
  size_t tmp___1 ;
  int w_card_check ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1030
  retval = -1;
#line 1031
  tmp = strlen((char const   *)dir_name);
#line 1031
  dir_name_len = (int )tmp;
#line 1032
  tmp___0 = strlen((char const   *)pre);
#line 1032
  pre_len = (int )tmp___0;
#line 1033
  tmp___1 = strlen((char const   *)ext);
#line 1033
  ext_len = (int )tmp___1;
#line 1034
  tmp___2 = strcspn((char const   *)ext, "*?");
#line 1034
  w_card_check = (int )tmp___2;
  }
#line 1036
  if (w_card_check < ext_len) {
    {
#line 1036
    tmp___7 = strncmp((char const   *)dir_name, (char const   *)pre, (size_t )pre_len);
    }
#line 1036
    if (tmp___7 == 0) {
      {
#line 1036
      tmp___8 = strcmp((char const   *)dir_name, ".");
      }
#line 1036
      if (tmp___8 != 0) {
        {
#line 1036
        tmp___9 = strcmp((char const   *)dir_name, "..");
        }
#line 1036
        if (tmp___9 != 0) {
#line 1038
          retval = 1;
        } else {
#line 1036
          goto _L___1;
        }
      } else {
#line 1036
        goto _L___1;
      }
    } else {
#line 1036
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1042
  if (dir_name_len >= ext_len + pre_len) {
    {
#line 1042
    tmp___3 = dotconf_strcmp_from_back((char const   *)dir_name, (char const   *)ext);
    }
#line 1042
    if (tmp___3 == 0) {
      {
#line 1042
      tmp___4 = strncmp((char const   *)dir_name, (char const   *)pre, (size_t )pre_len);
      }
#line 1042
      if (tmp___4 == 0) {
        {
#line 1042
        tmp___5 = strcmp((char const   *)dir_name, ".");
        }
#line 1042
        if (tmp___5 != 0) {
          {
#line 1042
          tmp___6 = strcmp((char const   *)dir_name, "..");
          }
#line 1042
          if (tmp___6 != 0) {
#line 1047
            retval = 0;
          }
        }
      }
    }
  }
#line 1052
  return (retval);
}
}
#line 1057 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
int dotconf_handle_question_mark(command_t *cmd , char *path , char *pre , char *ext ) 
{ 
  configfile_t *included ;
  DIR *dh ;
  struct dirent *dirptr ;
  int i ;
  char new_pre[256] ;
  char already_matched[256] ;
  char wc ;
  char *new_path ;
  char *wc_path ;
  char *wc_pre ;
  char *wc_ext ;
  char *temp ;
  int pre_len ;
  int new_path_len ;
  int name_len ;
  int alloced ;
  int match_state ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 1061
  dh = (DIR *)0;
#line 1062
  dirptr = (struct dirent *)0;
#line 1068
  wc = (char )'\000';
#line 1070
  new_path = (char *)0;
#line 1071
  wc_path = (char *)0;
#line 1072
  wc_pre = (char *)0;
#line 1073
  wc_ext = (char *)0;
#line 1074
  temp = (char *)((void *)0);
#line 1078
  name_len = 0;
#line 1079
  alloced = 0;
#line 1080
  match_state = 0;
#line 1082
  tmp = strlen((char const   *)pre);
#line 1082
  pre_len = (int )tmp;
#line 1084
  dh = opendir((char const   *)path);
  }
#line 1084
  if ((unsigned long )dh != (unsigned long )((void *)0)) {
    {
#line 1085
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1085
      dirptr = readdir(dh);
      }
#line 1085
      if (! ((unsigned long )dirptr != (unsigned long )((void *)0))) {
#line 1085
        goto while_break;
      }
      {
#line 1086
      match_state = dotconf_question_mark_match(dirptr->d_name, pre, ext);
      }
#line 1090
      if (match_state >= 0) {
        {
#line 1091
        tmp___0 = strlen((char const   *)(dirptr->d_name));
#line 1091
        name_len = (int )tmp___0;
#line 1092
        tmp___1 = strlen((char const   *)path);
#line 1092
        tmp___2 = strlen((char const   *)ext);
#line 1092
        new_path_len = (int )(((tmp___1 + (size_t )name_len) + tmp___2) + 1UL);
        }
#line 1095
        if (! alloced) {
          {
#line 1096
          tmp___3 = malloc((size_t )new_path_len);
#line 1096
          new_path = (char *)tmp___3;
          }
#line 1096
          if ((unsigned long )new_path == (unsigned long )((void *)0)) {
#line 1099
            return (-1);
          }
#line 1102
          alloced = new_path_len;
        } else
#line 1106
        if (new_path_len > alloced) {
          {
#line 1107
          tmp___4 = realloc((void *)new_path, (size_t )new_path_len);
#line 1107
          temp = (char *)tmp___4;
          }
#line 1110
          if ((unsigned long )temp == (unsigned long )((void *)0)) {
            {
#line 1111
            free((void *)new_path);
            }
#line 1112
            return (-1);
          }
#line 1114
          new_path = temp;
#line 1115
          alloced = new_path_len;
        }
#line 1121
        if (match_state == 1) {
#line 1123
          if (name_len > pre_len) {
#line 1123
            tmp___5 = pre_len + 1;
          } else {
#line 1123
            tmp___5 = pre_len;
          }
          {
#line 1123
          strncpy((char */* __restrict  */)(new_pre), (char const   */* __restrict  */)(dirptr->d_name),
                  (size_t )tmp___5);
          }
#line 1127
          if (name_len > pre_len) {
#line 1127
            tmp___6 = pre_len + 1;
          } else {
#line 1127
            tmp___6 = pre_len;
          }
          {
#line 1127
          new_pre[tmp___6] = (char )'\000';
#line 1132
          sprintf((char */* __restrict  */)new_path, (char const   */* __restrict  */)"%s%s%s",
                  path, new_pre, ext);
#line 1135
          tmp___7 = strcmp((char const   *)new_path, (char const   *)(already_matched));
          }
#line 1135
          if (tmp___7 == 0) {
#line 1137
            goto while_continue;
          } else {
            {
#line 1141
            strcpy((char */* __restrict  */)(already_matched), (char const   */* __restrict  */)new_path);
            }
          }
          {
#line 1146
          tmp___9 = dotconf_find_wild_card(new_path, & wc, & wc_path, & wc_pre, & wc_ext);
          }
#line 1146
          if (tmp___9 >= 0) {
            {
#line 1149
            tmp___8 = dotconf_handle_wild_card(cmd, wc, wc_path, wc_pre, wc_ext);
            }
#line 1149
            if (tmp___8 < 0) {
              {
#line 1152
              dotconf_warning(cmd->configfile, 4, 4UL, "Error occured while processing wildcard %c\nFilename is \'%s\'\n",
                              (int )wc, new_path);
#line 1161
              free((void *)new_path);
#line 1162
              dotconf_wild_card_cleanup(wc_path, wc_pre);
              }
#line 1164
              return (-1);
            }
            {
#line 1167
            dotconf_wild_card_cleanup(wc_path, wc_pre);
            }
#line 1169
            goto while_continue;
          }
        }
        {
#line 1174
        sprintf((char */* __restrict  */)new_path, (char const   */* __restrict  */)"%s%s",
                path, dirptr->d_name);
#line 1176
        tmp___10 = access((char const   *)new_path, 4);
        }
#line 1176
        if (tmp___10) {
          {
#line 1177
          dotconf_warning(cmd->configfile, 4, 4UL, "Cannot open %s for inclusion.\nIncludePath is \'%s\'\n",
                          new_path, (cmd->configfile)->includepath);
          }
#line 1185
          return (-1);
        }
        {
#line 1188
        included = dotconf_create(new_path, *((cmd->configfile)->config_options + 1),
                                  (cmd->configfile)->context, (cmd->configfile)->flags);
        }
#line 1194
        if (included) {
#line 1195
          i = 2;
          {
#line 1195
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1195
            if (! *((cmd->configfile)->config_options + i)) {
#line 1195
              goto while_break___0;
            }
            {
#line 1198
            dotconf_register_options(included, *((cmd->configfile)->config_options + i));
#line 1195
            i ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 1202
          included->errorhandler = (cmd->configfile)->errorhandler;
#line 1204
          included->contextchecker = (cmd->configfile)->contextchecker;
#line 1206
          dotconf_command_loop(included);
#line 1207
          dotconf_cleanup(included);
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1214
    closedir(dh);
#line 1215
    free((void *)new_path);
    }
  }
#line 1219
  return (0);
}
}
#line 1224 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
int dotconf_handle_star(command_t *cmd , char *path , char *pre , char *ext ) 
{ 
  configfile_t *included ;
  DIR *dh ;
  struct dirent *dirptr ;
  char new_pre[256] ;
  char new_ext[256] ;
  char already_matched[256] ;
  char wc ;
  char *new_path ;
  char *s_ext ;
  char *t_ext ;
  char *sub ;
  char *wc_path ;
  char *wc_pre ;
  char *wc_ext ;
  char *temp ;
  int pre_len ;
  int new_path_len ;
  int name_len ;
  int alloced ;
  int match_state ;
  int t_ext_count ;
  int sub_count ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 1227
  dh = (DIR *)0;
#line 1228
  dirptr = (struct dirent *)0;
#line 1234
  wc = (char )'\000';
#line 1236
  new_path = (char *)0;
#line 1237
  s_ext = (char *)0;
#line 1238
  t_ext = (char *)0;
#line 1239
  sub = (char *)0;
#line 1240
  wc_path = (char *)0;
#line 1241
  wc_pre = (char *)0;
#line 1242
  wc_ext = (char *)0;
#line 1243
  temp = (char *)((void *)0);
#line 1247
  name_len = 0;
#line 1248
  alloced = 0;
#line 1249
  match_state = 0;
#line 1250
  t_ext_count = 0;
#line 1251
  sub_count = 0;
#line 1253
  tmp = strlen((char const   *)pre);
#line 1253
  pre_len = (int )tmp;
#line 1254
  memset((void *)(already_matched), 0, (size_t )256);
#line 1255
  s_ext = ext;
  }
  {
#line 1257
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1257
    tmp___0 = dotconf_is_wild_card(*s_ext);
    }
#line 1257
    if (! tmp___0) {
#line 1257
      goto while_break;
    }
#line 1258
    s_ext ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1261
  t_ext = s_ext;
  {
#line 1263
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1263
    if ((unsigned long )t_ext != (unsigned long )((void *)0)) {
      {
#line 1263
      tmp___1 = dotconf_is_wild_card(*t_ext);
      }
#line 1263
      if (tmp___1) {
#line 1263
        goto while_break___0;
      } else
#line 1263
      if (! ((int )*t_ext != 0)) {
#line 1263
        goto while_break___0;
      }
    } else {
#line 1263
      goto while_break___0;
    }
#line 1265
    t_ext ++;
#line 1266
    t_ext_count ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1269
  strncpy((char */* __restrict  */)(new_ext), (char const   */* __restrict  */)s_ext,
          (size_t )t_ext_count);
#line 1270
  new_ext[t_ext_count] = (char )'\000';
#line 1272
  dh = opendir((char const   *)path);
  }
#line 1272
  if ((unsigned long )dh != (unsigned long )((void *)0)) {
    {
#line 1273
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1273
      dirptr = readdir(dh);
      }
#line 1273
      if (! ((unsigned long )dirptr != (unsigned long )((void *)0))) {
#line 1273
        goto while_break___1;
      }
      {
#line 1274
      sub_count = 0;
#line 1275
      t_ext_count = 0;
#line 1277
      match_state = dotconf_star_match(dirptr->d_name, pre, s_ext);
      }
#line 1280
      if (match_state >= 0) {
        {
#line 1281
        tmp___2 = strlen((char const   *)(dirptr->d_name));
#line 1281
        name_len = (int )tmp___2;
#line 1282
        tmp___3 = strlen((char const   *)path);
#line 1282
        tmp___4 = strlen((char const   *)s_ext);
#line 1282
        new_path_len = (int )(((tmp___3 + (size_t )name_len) + tmp___4) + 1UL);
        }
#line 1285
        if (! alloced) {
          {
#line 1286
          tmp___5 = malloc((size_t )new_path_len);
#line 1286
          new_path = (char *)tmp___5;
          }
#line 1286
          if ((unsigned long )new_path == (unsigned long )((void *)0)) {
#line 1289
            return (-1);
          }
#line 1292
          alloced = new_path_len;
        } else
#line 1296
        if (new_path_len > alloced) {
          {
#line 1297
          tmp___6 = realloc((void *)new_path, (size_t )new_path_len);
#line 1297
          temp = (char *)tmp___6;
          }
#line 1300
          if ((unsigned long )temp == (unsigned long )((void *)0)) {
            {
#line 1301
            free((void *)new_path);
            }
#line 1302
            return (-1);
          }
#line 1304
          new_path = temp;
#line 1305
          alloced = new_path_len;
        }
#line 1311
        if (match_state == 1) {
          {
#line 1313
          sub = strstr((char const   *)(dirptr->d_name + pre_len), (char const   *)(new_ext));
          }
#line 1313
          if ((unsigned long )sub == (unsigned long )((void *)0)) {
#line 1316
            goto while_continue___1;
          }
          {
#line 1319
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1319
            if (! ((unsigned long )sub != (unsigned long )(dirptr->d_name))) {
#line 1319
              goto while_break___2;
            }
#line 1320
            sub --;
#line 1321
            sub_count ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1324
          if (sub_count + t_ext_count > name_len) {
#line 1325
            goto while_continue___1;
          }
          {
#line 1328
          strncpy((char */* __restrict  */)(new_pre), (char const   */* __restrict  */)(dirptr->d_name),
                  (size_t )(sub_count + t_ext_count));
#line 1330
          new_pre[sub_count + t_ext_count] = (char )'\000';
#line 1331
          strcat((char */* __restrict  */)(new_pre), (char const   */* __restrict  */)(new_ext));
#line 1333
          sprintf((char */* __restrict  */)new_path, (char const   */* __restrict  */)"%s%s%s",
                  path, new_pre, t_ext);
#line 1336
          tmp___7 = strcmp((char const   *)new_path, (char const   *)(already_matched));
          }
#line 1336
          if (tmp___7 == 0) {
#line 1338
            goto while_continue___1;
          } else {
            {
#line 1342
            strcpy((char */* __restrict  */)(already_matched), (char const   */* __restrict  */)new_path);
            }
          }
          {
#line 1347
          tmp___9 = dotconf_find_wild_card(new_path, & wc, & wc_path, & wc_pre, & wc_ext);
          }
#line 1347
          if (tmp___9 >= 0) {
            {
#line 1350
            tmp___8 = dotconf_handle_wild_card(cmd, wc, wc_path, wc_pre, wc_ext);
            }
#line 1350
            if (tmp___8 < 0) {
              {
#line 1353
              dotconf_warning(cmd->configfile, 4, 4UL, "Error occured while processing wildcard %c\nFilename is \'%s\'\n",
                              (int )wc, new_path);
#line 1362
              free((void *)new_path);
#line 1363
              dotconf_wild_card_cleanup(wc_path, wc_pre);
              }
#line 1365
              return (-1);
            }
            {
#line 1368
            dotconf_wild_card_cleanup(wc_path, wc_pre);
            }
#line 1370
            goto while_continue___1;
          }
        }
        {
#line 1375
        sprintf((char */* __restrict  */)new_path, (char const   */* __restrict  */)"%s%s",
                path, dirptr->d_name);
#line 1377
        tmp___10 = access((char const   *)new_path, 4);
        }
#line 1377
        if (tmp___10) {
          {
#line 1378
          dotconf_warning(cmd->configfile, 4, 4UL, "Cannot open %s for inclusion.\nIncludePath is \'%s\'\n",
                          new_path, (cmd->configfile)->includepath);
          }
#line 1386
          return (-1);
        }
        {
#line 1389
        included = dotconf_create(new_path, *((cmd->configfile)->config_options + 1),
                                  (cmd->configfile)->context, (cmd->configfile)->flags);
        }
#line 1395
        if (included) {
          {
#line 1396
          included->errorhandler = (cmd->configfile)->errorhandler;
#line 1398
          included->contextchecker = (cmd->configfile)->contextchecker;
#line 1400
          dotconf_command_loop(included);
#line 1401
          dotconf_cleanup(included);
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1408
    closedir(dh);
#line 1409
    free((void *)new_path);
    }
  }
#line 1413
  return (0);
}
}
#line 1416 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
char *get_cwd(void) 
{ 
  char *buf ;
  void *tmp ;

  {
  {
#line 1418
  tmp = calloc((size_t )1, (size_t )256);
#line 1418
  buf = (char *)tmp;
  }
#line 1420
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 1421
    return ((char *)((void *)0));
  }
  {
#line 1422
  getcwd(buf, (size_t )256);
  }
#line 1423
  return (buf);
}
}
#line 1426 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
char *get_path(char *name___0 ) 
{ 
  char *tmp ;
  char *buf ;
  int len ;
  void *tmp___0 ;

  {
  {
#line 1429
  buf = (char *)((void *)0);
#line 1430
  len = 0;
#line 1432
  tmp = strrchr((char const   *)name___0, '/');
  }
#line 1433
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1434
    return ((char *)((void *)0));
  }
  {
#line 1435
  tmp___0 = calloc((size_t )1, (size_t )256);
#line 1435
  buf = (char *)tmp___0;
  }
#line 1436
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 1437
    return ((char *)((void *)0));
  }
#line 1438
  if ((unsigned long )tmp == (unsigned long )name___0) {
    {
#line 1439
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"/");
    }
  } else {
#line 1441
    len = (int )((tmp - name___0) + 1L);
#line 1442
    if (len > 256) {
#line 1443
      len = 256;
    }
  }
  {
#line 1445
  snprintf((char */* __restrict  */)buf, (size_t )len, (char const   */* __restrict  */)"%s",
           name___0);
  }
#line 1446
  return (buf);
}
}
#line 1450 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
static char const   *dotconf_cb_include(command_t *cmd , context_t *ctx ) 
{ 
  char *filename ;
  configfile_t *included ;
  char wild_card ;
  char *path ;
  char *pre ;
  char *ext ;
  int len ;
  int inclen ;
  char *sl ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1452
  filename = (char *)0;
#line 1456
  path = (char *)0;
#line 1457
  pre = (char *)0;
#line 1458
  ext = (char *)0;
#line 1460
  if ((cmd->configfile)->includepath) {
#line 1460
    if ((int )*(cmd->data.str + 0) != 47) {
#line 1460
      if ((int )*((cmd->configfile)->includepath + 0) != 0) {
        {
#line 1467
        tmp = strlen((char const   *)(cmd->configfile)->includepath);
#line 1467
        inclen = (int )tmp;
#line 1468
        tmp___0 = strlen((char const   *)cmd->data.str);
#line 1468
        len = (int )((tmp___0 + (size_t )inclen) + 1UL);
        }
#line 1468
        if (len == 256) {
          {
#line 1471
          dotconf_warning(cmd->configfile, 4, 4UL, "Absolute filename too long (>%d)",
                          256);
          }
#line 1475
          return ((char const   *)((void *)0));
        }
#line 1478
        if ((int )*((cmd->configfile)->includepath + (inclen - 1)) == 47) {
#line 1479
          sl = (char *)"";
        } else {
#line 1481
          sl = (char *)"/";
#line 1482
          len ++;
        }
        {
#line 1485
        tmp___1 = malloc((size_t )len);
#line 1485
        filename = (char *)tmp___1;
#line 1486
        snprintf((char */* __restrict  */)filename, (size_t )len, (char const   */* __restrict  */)"%s%s%s",
                 (cmd->configfile)->includepath, sl, cmd->data.str);
        }
      } else {
        {
#line 1489
        filename = strdup((char const   *)cmd->data.str);
        }
      }
    } else {
      {
#line 1489
      filename = strdup((char const   *)cmd->data.str);
      }
    }
  } else {
    {
#line 1489
    filename = strdup((char const   *)cmd->data.str);
    }
  }
  {
#line 1492
  tmp___3 = dotconf_find_wild_card(filename, & wild_card, & path, & pre, & ext);
  }
#line 1492
  if (tmp___3 >= 0) {
    {
#line 1494
    tmp___2 = dotconf_handle_wild_card(cmd, wild_card, path, pre, ext);
    }
#line 1494
    if (tmp___2 < 0) {
      {
#line 1496
      dotconf_warning(cmd->configfile, 4, 4UL, "Error occured while attempting to process %s for inclusion.\nIncludePath is \'%s\'\n",
                      filename, (cmd->configfile)->includepath);
      }
    }
    {
#line 1503
    dotconf_wild_card_cleanup(path, pre);
#line 1504
    free((void *)filename);
    }
#line 1505
    return ((char const   *)((void *)0));
  }
  {
#line 1508
  tmp___4 = access((char const   *)filename, 4);
  }
#line 1508
  if (tmp___4) {
    {
#line 1509
    dotconf_warning(cmd->configfile, 4, 4UL, "Cannot open %s for inclusion.\nIncludePath is \'%s\'\n",
                    filename, (cmd->configfile)->includepath);
#line 1514
    free((void *)filename);
    }
#line 1515
    return ((char const   *)((void *)0));
  }
  {
#line 1518
  included = dotconf_create(filename, *((cmd->configfile)->config_options + 1), (cmd->configfile)->context,
                            (cmd->configfile)->flags);
  }
#line 1521
  if (included) {
    {
#line 1522
    included->contextchecker = (cmd->configfile)->contextchecker;
#line 1524
    included->errorhandler = (cmd->configfile)->errorhandler;
#line 1527
    dotconf_command_loop(included);
#line 1528
    dotconf_cleanup(included);
    }
  }
  {
#line 1531
  free((void *)filename);
  }
#line 1532
  return ((char const   *)((void *)0));
}
}
#line 1535 "/home/june/repo/benchmarks/collector/temp/dotconf-1.3/src/dotconf.c"
static char const   *dotconf_cb_includepath(command_t *cmd , context_t *ctx ) 
{ 
  char *env ;
  char *tmp ;

  {
  {
#line 1537
  tmp = getenv("DC_INCLUDEPATH");
#line 1537
  env = tmp;
  }
#line 1539
  if (! env) {
    {
#line 1540
    snprintf((char */* __restrict  */)(cmd->configfile)->includepath, (size_t )256,
             (char const   */* __restrict  */)"%s", cmd->data.str);
    }
  }
#line 1542
  return ((char const   *)((void *)0));
}
}
