/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 48 "/home/wheatley/newnew/temp/multitee-3.0/ralloc.c"
struct funlist {
   struct funlist *next ;
   int (*data)() ;
};
#line 48 "/home/wheatley/newnew/temp/multitee-3.0/ralloc.c"
typedef struct funlist *funlist;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 307 "/usr/include/signal.h"
struct sigvec {
   void (*sv_handler)(int  ) ;
   int sv_mask ;
   int sv_flags ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 4 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.h"
union __anonunion_u_39 {
   int n ;
   char *c ;
};
#line 4 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.h"
struct __anonstruct_ss_sig_38 {
   int type ;
   union __anonunion_u_39 u ;
};
#line 4 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.h"
typedef struct __anonstruct_ss_sig_38 ss_sig;
#line 11 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.h"
union __anonunion_u_41 {
   int n ;
   char *c ;
};
#line 11 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.h"
struct __anonstruct_ss_extern_40 {
   int (*sched)() ;
   int (*unsched)() ;
   union __anonunion_u_41 u ;
};
#line 11 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.h"
typedef struct __anonstruct_ss_extern_40 ss_extern;
#line 19 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.h"
typedef void ss_thread();
#line 20 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.h"
typedef int ss_id;
#line 21 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.h"
typedef char *ss_idptr;
#line 33 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
typedef int sigc_set;
#line 83 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
struct __anonstruct_ss_sigplus_42 {
   ss_sig s ;
   int r ;
};
#line 83 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
typedef struct __anonstruct_ss_sigplus_42 ss_sigplus;
#line 128 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
union __anonunion_id_43 {
   ss_id i ;
   ss_idptr p ;
};
#line 128 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
struct sched {
   ss_sig *sig ;
   ss_thread *t ;
   union __anonunion_id_43 id ;
   int flagi ;
   int wait ;
};
#line 138 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
struct schedlist {
   struct schedlist *next ;
   struct sched data ;
};
#line 138 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
typedef struct schedlist *schedlist;
#line 205 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
struct oncestuff {
   ss_sig *sig ;
   ss_thread *t ;
   ss_id i ;
};
#line 359 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
struct recvlist {
   struct recvlist *next ;
   schedlist data ;
};
#line 359 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
typedef struct recvlist *recvlist;
#line 86 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
struct iosc {
   int in ;
   int out ;
   int flagsched ;
   int startpos ;
   int breakpipe ;
   int dead ;
};
#line 97 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
struct intstack {
   struct intstack *next ;
   int data ;
};
#line 97 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
typedef struct intstack *intstack;
#line 98 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
struct ioscstack {
   struct ioscstack *next ;
   struct iosc data ;
};
#line 98 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
typedef struct ioscstack *ioscstack;
#line 280 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
struct __anonstruct_data_41 {
   int fdin ;
   int fd ;
   int special ;
};
#line 280 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
struct opstack {
   struct opstack *next ;
   struct __anonstruct_data_41 data ;
};
#line 280 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
typedef struct opstack *opstack;
#line 7 "/home/wheatley/newnew/temp/multitee-3.0/fmt.h"
unsigned int fmt_uint(char *s , unsigned int u ) ;
#line 8
unsigned int fmt_xint(char *s , unsigned int u ) ;
#line 9
unsigned int fmt_nbbint(char *s , unsigned int n , unsigned int base , unsigned int bext ,
                        unsigned int u ) ;
#line 10
unsigned int fmt_ushort(char *s , unsigned short u ) ;
#line 11
unsigned int fmt_xshort(char *s , unsigned short u ) ;
#line 12
unsigned int fmt_nbbshort(char *s , unsigned int n , unsigned int base , unsigned int bext ,
                          unsigned short u ) ;
#line 13
unsigned int fmt_ulong(char *s , unsigned long u ) ;
#line 14
unsigned int fmt_xlong(char *s , unsigned long u ) ;
#line 15
unsigned int fmt_nbblong(char *s , unsigned int n , unsigned int base , unsigned int bext ,
                         unsigned long u ) ;
#line 17
unsigned int fmt_plusminus(char *s , int sign ) ;
#line 18
unsigned int fmt_minus(char *s , int sign ) ;
#line 19
unsigned int fmt_0x(char *s , int base ) ;
#line 21
unsigned int fmt_strncpy(char *s , char *t , unsigned int n ) ;
#line 22
unsigned int fmt_memcpy(char *s , char *t , unsigned int n ) ;
#line 23
unsigned int fmt_vis(char *s , char *t , unsigned int n ) ;
#line 24
unsigned int fmt_nvis(char *s , char *t , unsigned int n ) ;
#line 25
unsigned int fmt_rvis(char *s , char *t , unsigned int n ) ;
#line 26
unsigned int fmt_unrvis(char *s , char *t , unsigned int n ) ;
#line 26 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_ulong(char *s , unsigned long u ) 
{ 
  unsigned int len ;
  unsigned long q ;

  {
#line 29
  len = 1U;
#line 29
  q = u;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (q > 9UL)) {
#line 30
      goto while_break;
    }
#line 30
    len ++;
#line 30
    q /= 10UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 31
  if (s) {
#line 33
    s += len;
    {
#line 34
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 34
      s --;
#line 34
      *s = (char )(48UL + u % 10UL);
#line 34
      u /= 10UL;
#line 34
      if (! u) {
#line 34
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 36
  return (len);
}
}
#line 39 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_xlong(char *s , unsigned long u ) 
{ 
  unsigned int len ;
  unsigned long q ;
  unsigned long c ;
  int tmp ;

  {
#line 42
  len = 1U;
#line 42
  q = u;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (q > 15UL)) {
#line 43
      goto while_break;
    }
#line 43
    len ++;
#line 43
    q /= 16UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  if (s) {
#line 46
    s += len;
    {
#line 47
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 47
      c = u & 15UL;
#line 47
      s --;
#line 47
      if (c > 9UL) {
#line 47
        tmp = 87;
      } else {
#line 47
        tmp = '0';
      }
#line 47
      *s = (char )((unsigned long )tmp + c);
#line 47
      u /= 16UL;
#line 47
      if (! u) {
#line 47
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 49
  return (len);
}
}
#line 52 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_nbblong(char *s , unsigned int n , unsigned int base , unsigned int bext ,
                         unsigned long u ) 
{ 
  unsigned int len ;
  unsigned long q ;
  unsigned long c ;
  unsigned int tmp ;

  {
#line 57
  len = 1U;
#line 57
  q = u;
#line 57
  bext += base;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (q > (unsigned long )(bext - 1U))) {
#line 58
      goto while_break;
    }
#line 58
    len ++;
#line 58
    q /= (unsigned long )bext;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  if (len < n) {
#line 58
    len = n;
  }
#line 59
  if (s) {
#line 61
    s += len;
    {
#line 62
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 62
      c = u % (unsigned long )bext;
#line 62
      s --;
#line 62
      if (c >= (unsigned long )base) {
#line 62
        tmp = 97U - base;
      } else {
#line 62
        tmp = (unsigned int )'0';
      }
#line 62
      *s = (char )((unsigned long )tmp + c);
#line 62
      u /= (unsigned long )bext;
#line 62
      if (! u) {
#line 62
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 65
  return (len);
}
}
#line 68 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_ushort(char *s , unsigned short u ) 
{ 
  unsigned long l ;
  unsigned int tmp ;

  {
  {
#line 70
  l = (unsigned long )u;
#line 70
  tmp = fmt_ulong(s, l);
  }
#line 70
  return (tmp);
}
}
#line 73 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_xshort(char *s , unsigned short u ) 
{ 
  unsigned long l ;
  unsigned int tmp ;

  {
  {
#line 75
  l = (unsigned long )u;
#line 75
  tmp = fmt_xlong(s, l);
  }
#line 75
  return (tmp);
}
}
#line 78 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_nbbshort(char *s , unsigned int n , unsigned int base , unsigned int bext ,
                          unsigned short u ) 
{ 
  unsigned long l ;
  unsigned int tmp ;

  {
  {
#line 81
  l = (unsigned long )u;
#line 81
  tmp = fmt_nbblong(s, n, base, bext, l);
  }
#line 81
  return (tmp);
}
}
#line 84 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_uint(char *s , unsigned int u ) 
{ 
  unsigned long l ;
  unsigned int tmp ;

  {
  {
#line 86
  l = (unsigned long )u;
#line 86
  tmp = fmt_ulong(s, l);
  }
#line 86
  return (tmp);
}
}
#line 89 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_xint(char *s , unsigned int u ) 
{ 
  unsigned long l ;
  unsigned int tmp ;

  {
  {
#line 91
  l = (unsigned long )u;
#line 91
  tmp = fmt_xlong(s, l);
  }
#line 91
  return (tmp);
}
}
#line 94 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_nbbint(char *s , unsigned int n , unsigned int base , unsigned int bext ,
                        unsigned int u ) 
{ 
  unsigned long l ;
  unsigned int tmp ;

  {
  {
#line 97
  l = (unsigned long )u;
#line 97
  tmp = fmt_nbblong(s, n, base, bext, l);
  }
#line 97
  return (tmp);
}
}
#line 100 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_plusminus(char *s , int sign ) 
{ 


  {
#line 102
  if (s) {
#line 102
    if (sign < 0) {
#line 102
      *s = (char )'-';
    } else {
#line 102
      *s = (char )'+';
    }
  }
#line 102
  return (1U);
}
}
#line 105 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_minus(char *s , int sign ) 
{ 


  {
#line 107
  if (sign > 0) {
#line 107
    return (0U);
  }
#line 108
  if (s) {
#line 108
    *s = (char )'-';
  }
#line 108
  return (1U);
}
}
#line 111 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_0x(char *s , int base ) 
{ 


  {
#line 113
  if (base == 10) {
#line 113
    return (0U);
  }
#line 114
  if (s) {
#line 114
    *s = (char )'0';
  }
#line 114
  if (base == 8) {
#line 114
    return (1U);
  }
#line 115
  if (s) {
#line 115
    *(s + 1) = (char )'x';
  }
#line 115
  return (2U);
}
}
#line 118 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_strncpy(char *s , char *t , unsigned int n ) 
{ 
  unsigned int len ;
  char tmp ;

  {
#line 121
  len = 0U;
#line 122
  if (s) {
    {
#line 122
    while (1) {
      while_continue: /* CIL Label */ ;
#line 122
      tmp = *(t + len);
#line 122
      *(s + len) = tmp;
#line 122
      if (! tmp) {
#line 122
        goto while_break;
      }
#line 122
      len ++;
#line 122
      if (len == n) {
#line 122
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 123
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 123
      if (! *(t + len)) {
#line 123
        goto while_break___0;
      }
#line 123
      len ++;
#line 123
      if (len == n) {
#line 123
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 124
  return (len);
}
}
#line 127 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_memcpy(char *s , char *t , unsigned int n ) 
{ 
  unsigned int len ;

  {
#line 131
  if (s) {
#line 132
    len = 0U;
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 132
      if (! (len < n)) {
#line 132
        goto while_break;
      }
#line 133
      *(s + len) = *(t + len);
#line 132
      len ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 134
  return (n);
}
}
#line 137 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
static unsigned int fmt_xvis(char *s , char *t , unsigned int n , int x ) 
{ 
  unsigned int len ;
  int ch ;

  {
#line 140
  len = 0U;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! n) {
#line 140
      goto while_break;
    }
#line 143
    ch = (int )((unsigned int )((unsigned char )*t));
#line 145
    if (ch > 127) {
#line 146
      if (s) {
#line 146
        *(s + len) = (char )'M';
#line 146
        *(s + (len + 1U)) = (char )'-';
      }
#line 146
      len += 2U;
#line 146
      ch -= 128;
    }
#line 147
    if (ch >= 32) {
#line 147
      if (ch <= 126) {
#line 147
        goto _L;
      } else {
#line 147
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 147
    if (ch == x) {
      _L: /* CIL Label */ 
#line 148
      if (s) {
#line 148
        *(s + len) = (char )ch;
      }
#line 148
      len ++;
#line 148
      goto __Cont;
    }
#line 149
    if (s) {
#line 149
      *(s + len) = (char )'^';
    }
#line 149
    len ++;
#line 150
    if (s) {
#line 150
      *(s + len) = (char )((64 + (ch & 31)) - 32 * (ch == 127));
    }
#line 150
    len ++;
    __Cont: /* CIL Label */ 
#line 140
    n --;
#line 140
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return (len);
}
}
#line 155 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_vis(char *s , char *t , unsigned int n ) 
{ 
  unsigned int tmp ;

  {
  {
#line 157
  tmp = fmt_xvis(s, t, n, -1);
  }
#line 157
  return (tmp);
}
}
#line 160 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_nvis(char *s , char *t , unsigned int n ) 
{ 
  unsigned int tmp ;

  {
  {
#line 162
  tmp = fmt_xvis(s, t, n, '\n');
  }
#line 162
  return (tmp);
}
}
#line 166 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_rvis(char *s , char *t , unsigned int n ) 
{ 
  unsigned int len ;
  int ch ;

  {
#line 169
  len = 0U;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! n) {
#line 169
      goto while_break;
    }
#line 172
    ch = (int )((unsigned int )((unsigned char )*t));
#line 174
    if (ch >= 32) {
#line 174
      if (ch <= 126) {
#line 174
        if (ch != 94) {
#line 175
          if (s) {
#line 175
            *(s + len) = (char )ch;
          }
#line 175
          len ++;
#line 175
          goto __Cont;
        }
      }
    }
#line 176
    if (ch == 127) {
#line 177
      if (s) {
#line 177
        *(s + len) = (char )'^';
#line 177
        *(s + (len + 1U)) = (char )'?';
      }
#line 177
      len += 2U;
#line 177
      goto __Cont;
    }
#line 178
    if (ch == 94) {
#line 179
      if (s) {
#line 179
        *(s + len) = (char )'^';
#line 179
        *(s + (len + 1U)) = (char )' ';
      }
#line 179
      len += 2U;
#line 179
      goto __Cont;
    }
#line 180
    if (ch == 10) {
#line 181
      if (s) {
#line 181
        *(s + len) = (char )'^';
#line 181
        *(s + (len + 1U)) = (char )'$';
      }
#line 181
      len += 2U;
#line 181
      goto __Cont;
    }
#line 182
    if (ch >= 0) {
#line 182
      if (ch <= 31) {
#line 183
        if (s) {
#line 183
          *(s + len) = (char )'^';
#line 183
          *(s + (len + 1U)) = (char )(64 + (ch & 31));
        }
#line 183
        len += 2U;
#line 183
        goto __Cont;
      }
    }
#line 184
    if (s) {
#line 184
      *(s + len) = (char )'^';
#line 184
      *(s + (len + 1U)) = (char )'x';
    }
#line 184
    len += 2U;
#line 185
    if (s) {
#line 185
      if (ch >= 160) {
#line 185
        *(s + len) = (char )(97 + (ch / 16 - 10));
      } else {
#line 185
        *(s + len) = (char )(48 + ch / 16);
      }
    }
#line 186
    len ++;
#line 186
    ch &= 15;
#line 187
    if (s) {
#line 187
      if (ch >= 10) {
#line 187
        *(s + len) = (char )(97 + (ch - 10));
      } else {
#line 187
        *(s + len) = (char )(48 + ch);
      }
    }
#line 188
    len ++;
    __Cont: /* CIL Label */ 
#line 169
    n --;
#line 169
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  *(s + len) = (char )'\n';
#line 191
  return (len + 1U);
}
}
#line 194 "/home/wheatley/newnew/temp/multitee-3.0/fmt.c"
unsigned int fmt_unrvis(char *s , char *t , unsigned int n ) 
{ 
  unsigned int len ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 197
  len = 0U;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! n) {
#line 197
      goto while_break;
    }
#line 199
    if ((int )*t == 10) {
#line 200
      goto __Cont;
    }
#line 201
    if ((int )*t != 94) {
#line 203
      if (s) {
#line 203
        tmp = s;
#line 203
        s ++;
#line 203
        *tmp = *t;
      }
#line 203
      len ++;
#line 204
      goto __Cont;
    }
#line 206
    if (n < 2U) {
#line 207
      return (len);
    }
#line 208
    t ++;
#line 208
    n --;
#line 209
    if ((int )*t == 63) {
#line 210
      if (s) {
#line 210
        tmp___0 = s;
#line 210
        s ++;
#line 210
        *tmp___0 = (char)127;
      }
#line 210
      len ++;
#line 210
      goto __Cont;
    }
#line 211
    if ((int )*t == 32) {
#line 212
      if (s) {
#line 212
        tmp___1 = s;
#line 212
        s ++;
#line 212
        *tmp___1 = (char )'^';
      }
#line 212
      len ++;
#line 212
      goto __Cont;
    }
#line 213
    if ((int )*t >= 64) {
#line 213
      if ((int )*t <= 95) {
#line 214
        if (s) {
#line 214
          tmp___2 = s;
#line 214
          s ++;
#line 214
          *tmp___2 = (char )((int )*t - 64);
        }
#line 214
        len ++;
#line 214
        goto __Cont;
      }
    }
#line 215
    if ((int )*t == 36) {
#line 216
      if (s) {
#line 216
        tmp___3 = s;
#line 216
        s ++;
#line 216
        *tmp___3 = (char)10;
      }
#line 216
      len ++;
#line 216
      goto __Cont;
    }
#line 217
    if (n < 3U) {
#line 218
      return (len);
    }
#line 219
    if ((int )*t != 120) {
#line 220
      return (len);
    }
#line 221
    t ++;
#line 222
    if (s) {
#line 223
      if ((int )*t < 97) {
#line 224
        *s = (char )((int )*t - 48);
      } else {
#line 226
        *s = (char )(((int )*t - 97) + 10);
      }
    }
#line 227
    if (s) {
#line 228
      *s = (char )((int )*s << 4);
    }
#line 229
    t ++;
#line 230
    if (s) {
#line 231
      if ((int )*t < 97) {
#line 232
        *s = (char )((int )*s + ((int )*t - 48));
      } else {
#line 234
        *s = (char )((int )*s + (((int )*t - 97) + 10));
      }
    }
#line 235
    if (s) {
#line 235
      s ++;
    }
#line 236
    len ++;
#line 236
    n -= 2U;
    __Cont: /* CIL Label */ 
#line 197
    n --;
#line 197
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return (len);
}
}
#line 4 "/home/wheatley/newnew/temp/multitee-3.0/ralloc.h"
char *ralloc(unsigned int n ) ;
#line 5
void rfree(char *s ) ;
#line 6
int rcount(void) ;
#line 7
int rallocinstall(int (*f)() ) ;
#line 8
void rallocneverfail(int (*f)() ) ;
#line 43 "/home/wheatley/newnew/temp/multitee-3.0/ralloc.c"
extern char *malloc() ;
#line 44
extern void free() ;
#line 50 "/home/wheatley/newnew/temp/multitee-3.0/ralloc.c"
static funlist funhead  =    (funlist )0;
#line 51 "/home/wheatley/newnew/temp/multitee-3.0/ralloc.c"
static funlist funlast  =    (funlist )0;
#line 53 "/home/wheatley/newnew/temp/multitee-3.0/ralloc.c"
static int ralloccount  =    0;
#line 55 "/home/wheatley/newnew/temp/multitee-3.0/ralloc.c"
int rcount(void) 
{ 


  {
#line 57
  return (ralloccount);
}
}
#line 60 "/home/wheatley/newnew/temp/multitee-3.0/ralloc.c"
void rfree(char *s ) 
{ 


  {
  {
#line 65
  ralloccount --;
#line 66
  free(s);
  }
#line 67
  return;
}
}
#line 69 "/home/wheatley/newnew/temp/multitee-3.0/ralloc.c"
static int crit  =    0;
#line 71 "/home/wheatley/newnew/temp/multitee-3.0/ralloc.c"
static int (*neverfail)()  =    (int (*)())0;
#line 78
extern int ( /* missing proto */  _exit)() ;
#line 73 "/home/wheatley/newnew/temp/multitee-3.0/ralloc.c"
static void die(unsigned int n ) 
{ 


  {
#line 76
  if (neverfail) {
    {
#line 77
    (*neverfail)(n);
    }
  }
  {
#line 78
  _exit(1);
  }
#line 79
  return;
}
}
#line 81 "/home/wheatley/newnew/temp/multitee-3.0/ralloc.c"
char *ralloc(unsigned int n ) 
{ 
  char *t ;
  funlist fun ;
  int tmp ;

  {
  {
#line 87
  t = malloc(n);
  }
#line 87
  if (t) {
#line 89
    ralloccount ++;
#line 90
    return (t);
  }
#line 92
  if (crit) {
#line 93
    if (neverfail) {
      {
#line 94
      die(n);
      }
    } else {
#line 96
      return ((char *)0);
    }
  }
#line 97
  if (! funhead) {
#line 98
    if (neverfail) {
      {
#line 99
      die(n);
      }
    } else {
#line 101
      return ((char *)0);
    }
  }
#line 102
  crit = 1;
#line 103
  if (funlast) {
#line 103
    fun = funlast->next;
  } else {
#line 103
    fun = funhead;
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! fun) {
#line 107
      fun = funhead;
    }
    {
#line 108
    tmp = (*(fun->data))();
    }
#line 108
    if (tmp) {
#line 109
      funlast = fun;
    } else
#line 111
    if ((unsigned long )fun == (unsigned long )funlast) {
#line 113
      crit = 0;
#line 114
      if (neverfail) {
        {
#line 115
        die(n);
        }
      } else {
#line 117
        return ((char *)0);
      }
    }
    {
#line 119
    fun = fun->next;
#line 120
    t = malloc(n);
    }
#line 104
    if (! (! t)) {
#line 104
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  ralloccount ++;
#line 124
  crit = 0;
#line 125
  return (t);
}
}
#line 128 "/home/wheatley/newnew/temp/multitee-3.0/ralloc.c"
void rallocneverfail(int (*f)() ) 
{ 


  {
#line 131
  neverfail = f;
#line 132
  return;
}
}
#line 136 "/home/wheatley/newnew/temp/multitee-3.0/ralloc.c"
int rallocinstall(int (*f)() ) 
{ 
  funlist fun ;
  char *tmp ;

  {
  {
#line 141
  tmp = ralloc((unsigned int )sizeof(*fun));
#line 141
  fun = (funlist )tmp;
  }
#line 142
  if (! fun) {
#line 143
    return (-1);
  }
#line 144
  fun->data = f;
#line 145
  fun->next = funhead;
#line 145
  funhead = fun;
#line 147
  funlast = funhead;
#line 149
  return (0);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 15 "/home/wheatley/newnew/temp/multitee-3.0/getopt.h"
int getoptmine(int argc , char **argv , char *opts ) ;
#line 16
char *getoptarg ;
#line 17
int getoptind ;
#line 18
int getopterr ;
#line 19
int getoptpos ;
#line 20
int getoptproblem ;
#line 21
char *getoptprogname ;
#line 22
int getopteof ;
#line 35 "/home/wheatley/newnew/temp/multitee-3.0/getopt.c"
int getoptind  =    1;
#line 36 "/home/wheatley/newnew/temp/multitee-3.0/getopt.c"
int getoptpos  =    0;
#line 37 "/home/wheatley/newnew/temp/multitee-3.0/getopt.c"
int getopterr  =    1;
#line 38 "/home/wheatley/newnew/temp/multitee-3.0/getopt.c"
char *getoptarg  =    (char *)0;
#line 39 "/home/wheatley/newnew/temp/multitee-3.0/getopt.c"
int getoptproblem  =    0;
#line 40 "/home/wheatley/newnew/temp/multitee-3.0/getopt.c"
char *getoptprogname  =    (char *)0;
#line 41 "/home/wheatley/newnew/temp/multitee-3.0/getopt.c"
int getopteof  =    -1;
#line 43 "/home/wheatley/newnew/temp/multitee-3.0/getopt.c"
int getoptmine(int argc , char **argv , char *opts ) 
{ 
  int c ;
  char *s ;

  {
#line 51
  getoptarg = (char *)0;
#line 52
  if (! getoptprogname) {
#line 54
    getoptprogname = *argv;
#line 55
    if (! getoptprogname) {
#line 56
      getoptprogname = (char *)"";
    }
#line 57
    s = getoptprogname;
    {
#line 57
    while (1) {
      while_continue: /* CIL Label */ ;
#line 57
      if (! *s) {
#line 57
        goto while_break;
      }
#line 58
      if ((int )*s == 47) {
#line 59
        getoptprogname = s + 1;
      }
#line 57
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 61
  if (! argv) {
#line 62
    return (getopteof);
  } else
#line 61
  if (getoptind >= argc) {
#line 62
    return (getopteof);
  } else
#line 61
  if (! *(argv + getoptind)) {
#line 62
    return (getopteof);
  }
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (getoptpos) {
#line 63
      if (! (! *(*(argv + getoptind) + getoptpos))) {
#line 63
        goto while_break___0;
      }
    } else {
#line 63
      goto while_break___0;
    }
#line 66
    getoptind ++;
#line 67
    getoptpos = 0;
#line 68
    if (getoptind >= argc) {
#line 69
      return (getopteof);
    } else
#line 68
    if (! *(argv + getoptind)) {
#line 69
      return (getopteof);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 71
  if (! getoptpos) {
#line 73
    if ((int )*(*(argv + getoptind) + 0) != 45) {
#line 74
      return (getopteof);
    }
#line 75
    getoptpos ++;
#line 76
    c = (int )*(*(argv + getoptind) + 1);
#line 77
    if (c == 45) {
#line 77
      goto _L;
    } else
#line 77
    if (c == 0) {
      _L: /* CIL Label */ 
#line 80
      if (c) {
#line 81
        getoptind ++;
      }
#line 82
      getoptpos = 0;
#line 83
      return (getopteof);
    }
  }
#line 87
  c = (int )*(*(argv + getoptind) + getoptpos);
#line 88
  getoptpos ++;
#line 89
  s = opts;
  {
#line 90
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 90
    if (! *s) {
#line 90
      goto while_break___1;
    }
#line 92
    if (c == (int )*s) {
#line 94
      if ((int )*(s + 1) == 58) {
#line 96
        getoptarg = *(argv + getoptind) + getoptpos;
#line 97
        getoptind ++;
#line 98
        getoptpos = 0;
#line 99
        if (! *getoptarg) {
#line 101
          getoptarg = *(argv + getoptind);
#line 102
          if (getoptind >= argc) {
#line 102
            goto _L___0;
          } else
#line 102
          if (! getoptarg) {
            _L___0: /* CIL Label */ 
#line 104
            getoptproblem = c;
#line 105
            if (getopterr) {
              {
#line 106
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option requires an argument -- %c\n",
                      getoptprogname, c);
              }
            }
#line 108
            return ('?');
          }
#line 110
          getoptind ++;
        }
      }
#line 113
      return (c);
    }
#line 115
    s ++;
#line 116
    if ((int )*s == 58) {
#line 117
      s ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 119
  getoptproblem = c;
#line 120
  if (getopterr) {
    {
#line 121
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: illegal option -- %c\n",
            getoptprogname, c);
    }
  }
#line 122
  return ('?');
}
}
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 189
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigblock)(int __mask )  __attribute__((__deprecated__)) ;
#line 192
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigsetmask)(int __mask )  __attribute__((__deprecated__)) ;
#line 327
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigvec)(int __sig ,
                                                                             struct sigvec  const  *__vec ,
                                                                             struct sigvec *__ovec ) ;
#line 4 "/home/wheatley/newnew/temp/multitee-3.0/sigdfl.h"
int sigdfl(int sig ) ;
#line 6
int sigdfl_tstp(void) ;
#line 7
int sigdfl_stop(void) ;
#line 8
int sigdfl_ttin(void) ;
#line 9
int sigdfl_ttou(void) ;
#line 11
int sigdfl_abrt(void) ;
#line 19 "/home/wheatley/newnew/temp/multitee-3.0/sigdfl.c"
static int cont  =    0;
#line 21 "/home/wheatley/newnew/temp/multitee-3.0/sigdfl.c"
static int sigcont(void) 
{ 


  {
#line 23
  cont = 1;
#line 24
  return (0);
}
}
#line 61
extern int ( /* missing proto */  getpid)() ;
#line 26 "/home/wheatley/newnew/temp/multitee-3.0/sigdfl.c"
int sigdfl(int sig ) 
{ 
  int oldmask ;
  struct sigvec oldvec ;
  struct sigvec vec ;
  struct sigvec contvec ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 34
  if (sig == 18) {
#line 35
    return (0);
  }
#line 36
  if (sig == 23) {
#line 41
    return (0);
  } else
#line 36
  if (sig == 17) {
#line 41
    return (0);
  } else
#line 36
  if (sig == 29) {
#line 41
    return (0);
  } else
#line 36
  if (sig == 28) {
#line 41
    return (0);
  }
  {
#line 46
  oldmask = sigblock(0);
#line 47
  sigblock(~ 0);
#line 49
  vec.sv_handler = (void (*)(int  ))0;
#line 50
  vec.sv_mask = ~ 0;
#line 51
  vec.sv_flags = 0;
#line 52
  tmp = sigvec(sig, (struct sigvec  const  *)(& vec), & oldvec);
  }
#line 52
  if (tmp == -1) {
#line 53
    if (sig != 19) {
#line 53
      if (sig != 9) {
#line 54
        return (-1);
      }
    }
  }
  {
#line 55
  vec.sv_handler = (void (*)(int  ))(& sigcont);
#line 56
  vec.sv_mask = ~ 0;
#line 57
  vec.sv_flags = 0;
#line 58
  tmp___0 = sigvec(18, (struct sigvec  const  *)(& vec), & contvec);
  }
#line 58
  if (tmp___0 == -1) {
#line 59
    return (-1);
  }
  {
#line 60
  cont = 0;
#line 61
  tmp___1 = getpid();
#line 61
  tmp___2 = kill(tmp___1, sig);
  }
#line 61
  if (tmp___2 == -1) {
#line 62
    return (-1);
  }
  {
#line 69
  sigsetmask((int )(~ ((1UL << (unsigned long )(sig - 1) % (8UL * sizeof(unsigned long ))) | (1UL << 17UL % (8UL * sizeof(unsigned long ))))));
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (! cont)) {
#line 71
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 73
  sigblock(~ 0);
#line 75
  sigvec(sig, (struct sigvec  const  *)(& oldvec), & vec);
#line 76
  sigvec(18, (struct sigvec  const  *)(& contvec), & vec);
#line 78
  sigsetmask(oldmask);
  }
#line 79
  return (0);
}
}
#line 82 "/home/wheatley/newnew/temp/multitee-3.0/sigdfl.c"
int sigdfl_tstp(void) 
{ 
  int tmp ;

  {
  {
#line 84
  tmp = sigdfl(20);
  }
#line 84
  return (tmp);
}
}
#line 87 "/home/wheatley/newnew/temp/multitee-3.0/sigdfl.c"
int sigdfl_stop(void) 
{ 
  int tmp ;

  {
  {
#line 89
  tmp = sigdfl(19);
  }
#line 89
  return (tmp);
}
}
#line 92 "/home/wheatley/newnew/temp/multitee-3.0/sigdfl.c"
int sigdfl_ttin(void) 
{ 
  int tmp ;

  {
  {
#line 94
  tmp = sigdfl(21);
  }
#line 94
  return (tmp);
}
}
#line 97 "/home/wheatley/newnew/temp/multitee-3.0/sigdfl.c"
int sigdfl_ttou(void) 
{ 
  int tmp ;

  {
  {
#line 99
  tmp = sigdfl(22);
  }
#line 99
  return (tmp);
}
}
#line 102 "/home/wheatley/newnew/temp/multitee-3.0/sigdfl.c"
int sigdfl_abrt(void) 
{ 
  int tmp ;

  {
  {
#line 104
  tmp = sigdfl(6);
  }
#line 104
  return (tmp);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 23 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.h"
ss_sig *ss_asap(void) ;
#line 24
ss_sig *ss_signal(int i ) ;
#line 25
ss_sig *ss_sigread(int fd ) ;
#line 26
ss_sig *ss_sigwrite(int fd ) ;
#line 27
ss_sig *ss_sigexcept(int fd ) ;
#line 29
int ss_addsig(int i ) ;
#line 31
void ss_externsetsig(ss_sig *sig , ss_extern *x ) ;
#line 33
int ss_schedvwait(ss_sig *sig , ss_thread *t , int flagi , ss_id i , ss_idptr p ,
                  int wait ) ;
#line 34
int ss_schedwait(ss_sig *sig , ss_thread *t , ss_id i , int wait ) ;
#line 35
int ss_sched(ss_sig *sig , ss_thread *t , ss_id i ) ;
#line 36
int ss_schedonce(ss_sig *sig , ss_thread *t , ss_id i ) ;
#line 37
int ss_unschedv(ss_sig *sig , ss_thread *t , int flagi , ss_id i , ss_idptr p ) ;
#line 38
int ss_unsched(ss_sig *sig , ss_thread *t , ss_id i ) ;
#line 40
void ss_forcewait(void) ;
#line 41
void ss_unforcewait(void) ;
#line 43
int ss_exec(void) ;
#line 85 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static ss_sigplus asap  ;
#line 86 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static ss_sigplus sigs[65]  ;
#line 87 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static ss_sigplus reads[1024]  ;
#line 88 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static ss_sigplus writes[1024]  ;
#line 89 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static ss_sigplus excepts[1024]  ;
#line 90 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static ss_sigplus junk  ;
#line 92 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static void initsigs(void) 
{ 
  int i ;

  {
#line 95
  asap.s.type = 1;
#line 95
  asap.s.u.n = 0;
#line 95
  asap.r = 0;
#line 96
  i = 0;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (i < 65)) {
#line 96
      goto while_break;
    }
#line 97
    sigs[i].s.type = 2;
#line 97
    sigs[i].s.u.n = i;
#line 97
    sigs[i].r = 0;
#line 96
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 98
    if (! (i < 1024)) {
#line 98
      goto while_break___0;
    }
#line 99
    reads[i].s.type = 3;
#line 99
    reads[i].s.u.n = i;
#line 99
    reads[i].r = 0;
#line 98
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 100
    if (! (i < 1024)) {
#line 100
      goto while_break___1;
    }
#line 101
    writes[i].s.type = 4;
#line 101
    writes[i].s.u.n = i;
#line 101
    writes[i].r = 0;
#line 100
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 102
  i = 0;
  {
#line 102
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 102
    if (! (i < 1024)) {
#line 102
      goto while_break___2;
    }
#line 103
    excepts[i].s.type = 5;
#line 103
    excepts[i].s.u.n = i;
#line 103
    excepts[i].r = 0;
#line 102
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 104
  junk.s.type = 6;
#line 104
  junk.s.u.n = 0;
#line 104
  junk.r = 0;
#line 105
  return;
}
}
#line 107 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
ss_sig *ss_asap(void) 
{ 


  {
#line 108
  return (& asap.s);
}
}
#line 110 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
ss_sig *ss_signal(int i ) 
{ 


  {
#line 111
  if (i >= 0) {
#line 111
    if (! (i < 65)) {
#line 111
      return ((ss_sig *)0);
    }
  } else {
#line 111
    return ((ss_sig *)0);
  }
#line 111
  return (& sigs[i].s);
}
}
#line 113 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
ss_sig *ss_sigread(int fd ) 
{ 


  {
#line 114
  if (fd >= 0) {
#line 114
    if (! (fd < 1024)) {
#line 114
      return ((ss_sig *)0);
    }
  } else {
#line 114
    return ((ss_sig *)0);
  }
#line 114
  return (& reads[fd].s);
}
}
#line 115 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
ss_sig *ss_sigwrite(int fd ) 
{ 


  {
#line 116
  if (fd >= 0) {
#line 116
    if (! (fd < 1024)) {
#line 116
      return ((ss_sig *)0);
    }
  } else {
#line 116
    return ((ss_sig *)0);
  }
#line 116
  return (& writes[fd].s);
}
}
#line 117 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
ss_sig *ss_sigexcept(int fd ) 
{ 


  {
#line 118
  if (fd >= 0) {
#line 118
    if (! (fd < 1024)) {
#line 118
      return ((ss_sig *)0);
    }
  } else {
#line 118
    return ((ss_sig *)0);
  }
#line 118
  return (& excepts[fd].s);
}
}
#line 120 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
void ss_externsetsig(ss_sig *sig , ss_extern *x ) 
{ 


  {
#line 124
  sig->type = 7;
#line 125
  sig->u.c = (char *)x;
#line 126
  return;
}
}
#line 140 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static schedlist schedhead  =    (schedlist )0;
#line 141 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static int schednum  =    0;
#line 142 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static int schedjunked  =    0;
#line 143 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static int numwait  =    0;
#line 145 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
void ss_forcewait(void) 
{ 


  {
#line 147
  numwait ++;
#line 148
  return;
}
}
#line 150 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
void ss_unforcewait(void) 
{ 


  {
#line 152
  numwait --;
#line 153
  return;
}
}
#line 155 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
int ss_schedvwait(ss_sig *sig , ss_thread *t , int flagi , ss_id i , ss_idptr p ,
                  int wait ) 
{ 
  schedlist s ;
  ss_extern *x ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 165
  if (sig->type == 7) {
    {
#line 168
    x = (ss_extern *)sig->u.c;
#line 169
    tmp = (*(x->sched))(x, t, flagi, i, p, wait);
    }
#line 169
    return (tmp);
  }
  {
#line 171
  tmp___0 = ralloc(sizeof(*s));
#line 171
  s = (schedlist )tmp___0;
  }
#line 172
  if (! s) {
#line 173
    return (-1);
  }
#line 174
  s->data.sig = sig;
#line 175
  s->data.t = t;
#line 176
  tmp___1 = flagi;
#line 176
  s->data.flagi = tmp___1;
#line 176
  if (tmp___1) {
#line 177
    s->data.id.i = i;
  } else {
#line 179
    s->data.id.p = p;
  }
#line 180
  s->data.wait = wait;
#line 181
  s->next = schedhead;
#line 181
  schedhead = s;
#line 182
  schednum ++;
#line 183
  if (wait) {
#line 184
    numwait ++;
  }
#line 185
  return (0);
}
}
#line 188 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
int ss_schedwait(ss_sig *sig , ss_thread *t , ss_id i , int wait ) 
{ 
  int tmp ;

  {
  {
#line 194
  tmp = ss_schedvwait(sig, t, 1, i, (ss_idptr )0, wait);
  }
#line 194
  return (tmp);
}
}
#line 197 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
int ss_sched(ss_sig *sig , ss_thread *t , ss_id i ) 
{ 
  int tmp ;

  {
  {
#line 202
  tmp = ss_schedvwait(sig, t, 1, i, (ss_idptr )0, 0);
  }
#line 202
  return (tmp);
}
}
#line 208 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static void once(ss_idptr p ) 
{ 
  struct oncestuff *os ;
  int tmp ;

  {
  {
#line 212
  os = (struct oncestuff *)p;
#line 213
  tmp = ss_unschedv(os->sig, & once, 0, 0, p);
#line 215
  (*(os->t))(os->i);
#line 216
  rfree((char *)os);
  }
#line 217
  return;
}
}
#line 219 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
int ss_schedonce(ss_sig *sig , ss_thread *t , ss_id i ) 
{ 
  struct oncestuff *os ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 226
  tmp = ralloc(sizeof(struct oncestuff ));
#line 226
  os = (struct oncestuff *)tmp;
  }
#line 227
  if (! os) {
#line 228
    return (-1);
  }
  {
#line 229
  os->sig = sig;
#line 229
  os->t = t;
#line 229
  os->i = i;
#line 230
  tmp___0 = ss_schedvwait(sig, (ss_thread *)(& once), 0, 0, (ss_idptr )os, 1);
  }
#line 230
  return (tmp___0);
}
}
#line 235 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static int schedcleanup(void) 
{ 
  schedlist s ;
  schedlist t ;
  schedlist sprev ;

  {
#line 243
  if (! schedjunked) {
#line 244
    return (0);
  }
#line 246
  sprev = (schedlist )0;
#line 247
  s = schedhead;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! s) {
#line 248
      goto while_break;
    }
#line 250
    if ((unsigned long )s->data.sig == (unsigned long )(& junk.s)) {
#line 252
      if (sprev) {
#line 254
        t = sprev->next;
#line 254
        sprev->next = (sprev->next)->next;
#line 255
        s = sprev->next;
      } else {
#line 259
        t = s;
#line 259
        s = s->next;
#line 260
        schedhead = s;
      }
      {
#line 262
      rfree((char *)t);
#line 263
      schednum --;
#line 264
      schedjunked --;
      }
    } else {
#line 268
      sprev = s;
#line 269
      s = s->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return (1);
}
}
#line 278 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static void nothing(ss_id id ) 
{ 


  {
#line 282
  return;
}
}
#line 284 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
int ss_unschedv(ss_sig *sig , ss_thread *t , int flagi , ss_id i , ss_idptr p ) 
{ 
  schedlist s ;
  ss_extern *x ;
  int tmp ;
  int tmp___0 ;

  {
#line 293
  if (sig->type == 7) {
    {
#line 296
    x = (ss_extern *)sig->u.c;
#line 297
    tmp = (*(x->unsched))(x, t, flagi, i, p);
    }
#line 297
    return (tmp);
  }
#line 299
  s = schedhead;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! s) {
#line 299
      goto while_break;
    }
#line 300
    if ((unsigned long )s->data.sig == (unsigned long )sig) {
#line 300
      if ((unsigned long )s->data.t == (unsigned long )t) {
#line 301
        if (s->data.flagi == flagi) {
#line 302
          if (flagi) {
#line 302
            tmp___0 = s->data.id.i == i;
          } else {
#line 302
            tmp___0 = (unsigned long )s->data.id.p == (unsigned long )p;
          }
#line 302
          if (tmp___0) {
#line 304
            s->data.sig = & junk.s;
#line 305
            s->data.t = (ss_thread *)(& nothing);
#line 306
            if (s->data.wait) {
#line 307
              numwait --;
            }
#line 308
            s->data.wait = 0;
#line 309
            schedjunked ++;
#line 310
            return (0);
          }
        }
      }
    }
#line 299
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  return (1);
}
}
#line 315 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
int ss_unsched(ss_sig *sig , ss_thread *t , ss_id i ) 
{ 
  int tmp ;

  {
  {
#line 320
  tmp = ss_unschedv(sig, t, 1, i, (ss_idptr )0);
  }
#line 320
  return (tmp);
}
}
#line 323 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static struct timeval timeout  ;
#line 324 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static struct timeval instant  =    {(__time_t )0, (__suseconds_t )0};
#line 325 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static struct timeval forever  =    {(__time_t )3600, (__suseconds_t )0};
#line 328 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static void handle(int i ) 
{ 


  {
#line 331
  timeout = instant;
#line 332
  sigs[i].r = 1;
#line 333
  return;
}
}
#line 335 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static sigc_set sigstorage  ;
#line 336 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static sigc_set *xxxx  =    (sigc_set *)0;
#line 338 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
int ss_addsig(int i ) 
{ 


  {
#line 341
  if (i >= 0) {
#line 341
    if (! (i < 65)) {
#line 342
      return (-1);
    }
  } else {
#line 342
    return (-1);
  }
#line 343
  if (! xxxx) {
#line 345
    xxxx = & sigstorage;
#line 346
    *xxxx = 0;
  }
#line 348
  *xxxx |= 1 << (i - 1);
#line 349
  return (0);
}
}
#line 352 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static int isopen(int fd ) 
{ 
  int tmp ;

  {
  {
#line 356
  tmp = fcntl(fd, 3, 0);
  }
#line 356
  return (tmp != -1);
}
}
#line 445 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static fd_set rfds  ;
#line 446 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static fd_set wfds  ;
#line 447 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static fd_set efds  ;
#line 448 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
static int maxfd  ;
#line 361 "/home/wheatley/newnew/temp/multitee-3.0/sigsched.c"
int ss_exec(void) 
{ 
  int i ;
  struct sigvec sv ;
  recvlist recvhead ;
  recvlist temp ;
  schedlist sch ;
  int tmp ;
  int w ;
  schedlist sp ;
  int r ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int __d0___1 ;
  int __d1___1 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int __d0___2 ;
  int __d1___2 ;
  int __d0___3 ;
  int __d1___3 ;
  int __d0___4 ;
  int __d1___4 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 369
  initsigs();
  }
#line 371
  if (xxxx) {
    {
#line 373
    sigblock(*xxxx);
#line 375
    sv.sv_handler = & handle;
#line 376
    sv.sv_mask = *xxxx;
#line 377
    sv.sv_flags = 0;
#line 381
    i = 0;
    }
    {
#line 381
    while (1) {
      while_continue: /* CIL Label */ ;
#line 381
      if (! (i < 65)) {
#line 381
        goto while_break;
      }
#line 383
      if (*xxxx & (1 << (i - 1))) {
        {
#line 384
        tmp = sigvec(i, (struct sigvec  const  *)(& sv), (struct sigvec *)0);
        }
      }
#line 381
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 389
  recvhead = (recvlist )0;
  {
#line 391
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 391
    if (! numwait) {
#line 391
      goto while_break___0;
    }
#line 393
    if (recvhead) {
#line 396
      temp = recvhead;
#line 396
      recvhead = recvhead->next;
#line 397
      sch = temp->data;
      {
#line 408
      if ((sch->data.sig)->type == 6) {
#line 408
        goto case_6;
      }
#line 410
      if ((sch->data.sig)->type == 1) {
#line 410
        goto case_1;
      }
#line 413
      if ((sch->data.sig)->type == 3) {
#line 413
        goto case_3;
      }
#line 418
      if ((sch->data.sig)->type == 4) {
#line 418
        goto case_4;
      }
#line 423
      if ((sch->data.sig)->type == 5) {
#line 423
        goto case_5;
      }
#line 428
      if ((sch->data.sig)->type == 2) {
#line 428
        goto case_2;
      }
#line 434
      if ((sch->data.sig)->type == 7) {
#line 434
        goto case_7;
      }
#line 437
      goto switch_default;
      case_6: /* CIL Label */ 
#line 409
      goto switch_break;
      case_1: /* CIL Label */ 
#line 411
      if (sch->data.flagi) {
        {
#line 411
        (*(sch->data.t))(sch->data.id.i);
        }
      } else {
        {
#line 411
        (*(sch->data.t))(sch->data.id.p);
        }
      }
#line 412
      goto switch_break;
      case_3: /* CIL Label */ 
#line 414
      w = (sch->data.sig)->u.n;
#line 414
      if (reads[w].r) {
#line 415
        if (sch->data.flagi) {
          {
#line 415
          (*(sch->data.t))(sch->data.id.i);
          }
        } else {
          {
#line 415
          (*(sch->data.t))(sch->data.id.p);
          }
        }
      }
#line 416
      reads[w].r = 0;
#line 417
      goto switch_break;
      case_4: /* CIL Label */ 
#line 419
      w = (sch->data.sig)->u.n;
#line 419
      if (writes[w].r) {
#line 420
        if (sch->data.flagi) {
          {
#line 420
          (*(sch->data.t))(sch->data.id.i);
          }
        } else {
          {
#line 420
          (*(sch->data.t))(sch->data.id.p);
          }
        }
      }
#line 421
      writes[w].r = 0;
#line 422
      goto switch_break;
      case_5: /* CIL Label */ 
#line 424
      w = (sch->data.sig)->u.n;
#line 424
      if (excepts[w].r) {
#line 425
        if (sch->data.flagi) {
          {
#line 425
          (*(sch->data.t))(sch->data.id.i);
          }
        } else {
          {
#line 425
          (*(sch->data.t))(sch->data.id.p);
          }
        }
      }
#line 426
      excepts[w].r = 0;
#line 427
      goto switch_break;
      case_2: /* CIL Label */ 
#line 429
      w = (sch->data.sig)->u.n;
#line 429
      if (sigs[w].r) {
#line 430
        if (sch->data.flagi) {
          {
#line 430
          (*(sch->data.t))(sch->data.id.i);
          }
        } else {
          {
#line 430
          (*(sch->data.t))(sch->data.id.p);
          }
        }
      }
#line 431
      sigs[w].r = 0;
#line 433
      goto switch_break;
      case_7: /* CIL Label */ 
#line 436
      goto switch_break;
      switch_default: /* CIL Label */ ;
      switch_break: /* CIL Label */ ;
      }
      {
#line 440
      rfree((char *)temp);
      }
    } else {
#line 451
      if (schedjunked > 100) {
#line 452
        if (schednum / schedjunked < 3) {
          {
#line 453
          schedcleanup();
          }
        }
      }
#line 455
      timeout = forever;
      {
#line 456
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 456
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& rfds.__fds_bits[0]): "memory");
#line 456
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 457
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 457
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& wfds.__fds_bits[0]): "memory");
#line 457
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 458
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 458
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& efds.__fds_bits[0]): "memory");
#line 458
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 459
      maxfd = -1;
#line 461
      sp = schedhead;
      {
#line 461
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 461
        if (! sp) {
#line 461
          goto while_break___4;
        }
        {
#line 465
        if ((sp->data.sig)->type == 6) {
#line 465
          goto case_6___0;
        }
#line 467
        if ((sp->data.sig)->type == 1) {
#line 467
          goto case_1___0;
        }
#line 470
        if ((sp->data.sig)->type == 2) {
#line 470
          goto case_2___0;
        }
#line 474
        if ((sp->data.sig)->type == 3) {
#line 474
          goto case_3___0;
        }
#line 480
        if ((sp->data.sig)->type == 4) {
#line 480
          goto case_4___0;
        }
#line 486
        if ((sp->data.sig)->type == 5) {
#line 486
          goto case_5___0;
        }
#line 492
        if ((sp->data.sig)->type == 7) {
#line 492
          goto case_7___0;
        }
#line 494
        goto switch_default___0;
        case_6___0: /* CIL Label */ 
#line 466
        goto switch_break___0;
        case_1___0: /* CIL Label */ 
#line 468
        timeout = instant;
#line 469
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
#line 471
        if (sigs[(sp->data.sig)->u.n].r) {
#line 472
          timeout = instant;
        }
#line 473
        goto switch_break___0;
        case_3___0: /* CIL Label */ 
        {
#line 475
        tmp___0 = isopen((sp->data.sig)->u.n);
        }
#line 475
        if (tmp___0) {
#line 476
          rfds.__fds_bits[(sp->data.sig)->u.n / (8 * (int )sizeof(__fd_mask ))] |= 1L << (sp->data.sig)->u.n % (8 * (int )sizeof(__fd_mask ));
        }
#line 477
        if ((sp->data.sig)->u.n > maxfd) {
#line 478
          maxfd = (sp->data.sig)->u.n;
        }
#line 479
        goto switch_break___0;
        case_4___0: /* CIL Label */ 
        {
#line 481
        tmp___1 = isopen((sp->data.sig)->u.n);
        }
#line 481
        if (tmp___1) {
#line 482
          wfds.__fds_bits[(sp->data.sig)->u.n / (8 * (int )sizeof(__fd_mask ))] |= 1L << (sp->data.sig)->u.n % (8 * (int )sizeof(__fd_mask ));
        }
#line 483
        if ((sp->data.sig)->u.n > maxfd) {
#line 484
          maxfd = (sp->data.sig)->u.n;
        }
#line 485
        goto switch_break___0;
        case_5___0: /* CIL Label */ 
        {
#line 487
        tmp___2 = isopen((sp->data.sig)->u.n);
        }
#line 487
        if (tmp___2) {
#line 488
          efds.__fds_bits[(sp->data.sig)->u.n / (8 * (int )sizeof(__fd_mask ))] |= 1L << (sp->data.sig)->u.n % (8 * (int )sizeof(__fd_mask ));
        }
#line 489
        if ((sp->data.sig)->u.n > maxfd) {
#line 490
          maxfd = (sp->data.sig)->u.n;
        }
#line 491
        goto switch_break___0;
        case_7___0: /* CIL Label */ 
#line 493
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 495
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 461
        sp = sp->next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 499
      if (xxxx) {
        {
#line 500
        tmp___3 = sigblock(0);
#line 500
        sigsetmask(tmp___3 & ~ *xxxx);
        }
      }
      {
#line 509
      r = select(maxfd + 1, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)(& wfds),
                 (fd_set */* __restrict  */)(& efds), (struct timeval */* __restrict  */)(& timeout));
      }
#line 511
      if (xxxx) {
        {
#line 512
        sigblock(*xxxx);
        }
      }
#line 514
      if (r == -1) {
        {
#line 516
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 516
          __asm__  volatile   ("cld; rep; "
                               "stosq": "=c" (__d0___2), "=D" (__d1___2): "a" (0),
                               "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& rfds.__fds_bits[0]): "memory");
#line 516
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 517
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 517
          __asm__  volatile   ("cld; rep; "
                               "stosq": "=c" (__d0___3), "=D" (__d1___3): "a" (0),
                               "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& wfds.__fds_bits[0]): "memory");
#line 517
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 518
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 518
          __asm__  volatile   ("cld; rep; "
                               "stosq": "=c" (__d0___4), "=D" (__d1___4): "a" (0),
                               "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& efds.__fds_bits[0]): "memory");
#line 518
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 519
        tmp___4 = __errno_location();
        }
        {
#line 521
        if (*tmp___4 == 4) {
#line 521
          goto case_4___1;
        }
#line 522
        if (*tmp___4 == 9) {
#line 522
          goto case_9;
        }
#line 523
        if (*tmp___4 == 22) {
#line 523
          goto case_22;
        }
#line 524
        goto switch_default___1;
        case_4___1: /* CIL Label */ 
#line 521
        goto switch_break___1;
        case_9: /* CIL Label */ 
#line 522
        goto switch_break___1;
        case_22: /* CIL Label */ 
#line 523
        goto switch_break___1;
        switch_default___1: /* CIL Label */ ;
        switch_break___1: /* CIL Label */ ;
        }
      }
#line 529
      sp = schedhead;
      {
#line 529
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 529
        if (! sp) {
#line 529
          goto while_break___8;
        }
        {
#line 533
        if ((sp->data.sig)->type == 6) {
#line 533
          goto case_6___1;
        }
#line 535
        if ((sp->data.sig)->type == 1) {
#line 535
          goto case_1___1;
        }
#line 542
        if ((sp->data.sig)->type == 2) {
#line 542
          goto case_2___1;
        }
#line 552
        if ((sp->data.sig)->type == 3) {
#line 552
          goto case_3___1;
        }
#line 564
        if ((sp->data.sig)->type == 4) {
#line 564
          goto case_4___2;
        }
#line 576
        if ((sp->data.sig)->type == 5) {
#line 576
          goto case_5___1;
        }
#line 588
        if ((sp->data.sig)->type == 7) {
#line 588
          goto case_7___1;
        }
#line 590
        goto switch_default___2;
        case_6___1: /* CIL Label */ 
#line 534
        goto switch_break___2;
        case_1___1: /* CIL Label */ 
        {
#line 536
        tmp___5 = ralloc(sizeof(*temp));
#line 536
        temp = (recvlist )tmp___5;
        }
#line 537
        if (! temp) {
#line 538
          return (-1);
        }
#line 539
        temp->data = sp;
#line 540
        temp->next = recvhead;
#line 540
        recvhead = temp;
#line 541
        goto switch_break___2;
        case_2___1: /* CIL Label */ 
#line 543
        if (sigs[(sp->data.sig)->u.n].r) {
          {
#line 545
          tmp___6 = ralloc(sizeof(*temp));
#line 545
          temp = (recvlist )tmp___6;
          }
#line 546
          if (! temp) {
#line 547
            return (-1);
          }
#line 548
          temp->data = sp;
#line 549
          temp->next = recvhead;
#line 549
          recvhead = temp;
        }
#line 551
        goto switch_break___2;
        case_3___1: /* CIL Label */ 
#line 553
        if ((rfds.__fds_bits[(sp->data.sig)->u.n / (8 * (int )sizeof(__fd_mask ))] & (1L << (sp->data.sig)->u.n % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 555
          rfds.__fds_bits[(sp->data.sig)->u.n / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << (sp->data.sig)->u.n % (8 * (int )sizeof(__fd_mask )));
#line 556
          reads[(sp->data.sig)->u.n].r = 1;
#line 557
          tmp___7 = ralloc(sizeof(*temp));
#line 557
          temp = (recvlist )tmp___7;
          }
#line 558
          if (! temp) {
#line 559
            return (-1);
          }
#line 560
          temp->data = sp;
#line 561
          temp->next = recvhead;
#line 561
          recvhead = temp;
        }
#line 563
        goto switch_break___2;
        case_4___2: /* CIL Label */ 
#line 565
        if ((wfds.__fds_bits[(sp->data.sig)->u.n / (8 * (int )sizeof(__fd_mask ))] & (1L << (sp->data.sig)->u.n % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 567
          wfds.__fds_bits[(sp->data.sig)->u.n / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << (sp->data.sig)->u.n % (8 * (int )sizeof(__fd_mask )));
#line 568
          writes[(sp->data.sig)->u.n].r = 1;
#line 569
          tmp___8 = ralloc(sizeof(*temp));
#line 569
          temp = (recvlist )tmp___8;
          }
#line 570
          if (! temp) {
#line 571
            return (-1);
          }
#line 572
          temp->data = sp;
#line 573
          temp->next = recvhead;
#line 573
          recvhead = temp;
        }
#line 575
        goto switch_break___2;
        case_5___1: /* CIL Label */ 
#line 577
        if ((efds.__fds_bits[(sp->data.sig)->u.n / (8 * (int )sizeof(__fd_mask ))] & (1L << (sp->data.sig)->u.n % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 579
          efds.__fds_bits[(sp->data.sig)->u.n / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << (sp->data.sig)->u.n % (8 * (int )sizeof(__fd_mask )));
#line 580
          excepts[(sp->data.sig)->u.n].r = 1;
#line 581
          tmp___9 = ralloc(sizeof(*temp));
#line 581
          temp = (recvlist )tmp___9;
          }
#line 582
          if (! temp) {
#line 583
            return (-1);
          }
#line 584
          temp->data = sp;
#line 585
          temp->next = recvhead;
#line 585
          recvhead = temp;
        }
#line 587
        goto switch_break___2;
        case_7___1: /* CIL Label */ 
#line 589
        goto switch_break___2;
        switch_default___2: /* CIL Label */ 
#line 591
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
#line 529
        sp = sp->next;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 596
  if (xxxx) {
    {
#line 597
    tmp___10 = sigblock(0);
#line 597
    sigsetmask(tmp___10 & ~ *xxxx);
    }
  }
#line 599
  return (0);
}
}
#line 4 "/home/wheatley/newnew/temp/multitee-3.0/scan.h"
unsigned int scan_uint(char *s , unsigned int *u ) ;
#line 5
unsigned int scan_xint(char *s , unsigned int *u ) ;
#line 6
unsigned int scan_nbbint(char *s , unsigned int n , unsigned int base , unsigned int bext ,
                         unsigned int *u ) ;
#line 7
unsigned int scan_ushort(char *s , unsigned short *u ) ;
#line 8
unsigned int scan_xshort(char *s , unsigned short *u ) ;
#line 9
unsigned int scan_nbbshort(char *s , unsigned int n , unsigned int base , unsigned int bext ,
                           unsigned short *u ) ;
#line 10
unsigned int scan_ulong(char *s , unsigned long *u ) ;
#line 11
unsigned int scan_xlong(char *s , unsigned long *u ) ;
#line 12
unsigned int scan_nbblong(char *s , unsigned int n , unsigned int base , unsigned int bext ,
                          unsigned long *u ) ;
#line 14
unsigned int scan_plusminus(char *s , int *sign ) ;
#line 15
unsigned int scan_0x(char *s , unsigned int *base ) ;
#line 17
unsigned int scan_whitenskip(char *s , unsigned int n ) ;
#line 18
unsigned int scan_nonwhitenskip(char *s , unsigned int n ) ;
#line 19
unsigned int scan_charsetnskip(char *s , char *chars , unsigned int n ) ;
#line 20
unsigned int scan_noncharsetnskip(char *s , char *chars , unsigned int n ) ;
#line 23
unsigned int scan_strncmp(char *s , char *t , unsigned int n ) ;
#line 24
unsigned int scan_memcmp(char *s , char *t , unsigned int n ) ;
#line 29 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_plusminus(char *s , int *sign ) 
{ 


  {
#line 31
  if ((int )*s == 43) {
#line 31
    *sign = 1;
#line 31
    return (1U);
  }
#line 32
  if ((int )*s == 45) {
#line 32
    *sign = -1;
#line 32
    return (1U);
  }
#line 33
  *sign = 1;
#line 33
  return (0U);
}
}
#line 36 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_0x(char *s , unsigned int *base ) 
{ 


  {
#line 38
  if ((int )*s == 48) {
#line 40
    if ((int )*(s + 1) == 120) {
#line 41
      *base = 16U;
#line 41
      return (2U);
    } else
#line 40
    if ((int )*(s + 1) == 120) {
#line 41
      *base = 16U;
#line 41
      return (2U);
    }
#line 42
    *base = 8U;
#line 42
    return (1U);
  }
#line 44
  *base = 10U;
#line 44
  return (0U);
}
}
#line 47 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_ulong(char *s , unsigned long *u ) 
{ 
  unsigned int pos ;
  unsigned long result ;
  unsigned long c ;

  {
#line 50
  pos = 0U;
#line 50
  result = 0UL;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    c = (unsigned long )((unsigned char )((int )*(s + pos) - 48));
#line 51
    if (! (c < 10UL)) {
#line 51
      goto while_break;
    }
#line 52
    result = result * 10UL + c;
#line 52
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  *u = result;
#line 53
  return (pos);
}
}
#line 56 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_xlong(char *s , unsigned long *u ) 
{ 
  unsigned int pos ;
  unsigned long result ;
  unsigned long c ;

  {
#line 59
  pos = 0U;
#line 59
  result = 0UL;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    c = (unsigned long )((unsigned char )((int )*(s + pos) - 48));
#line 60
    if (! (c < 10UL)) {
#line 60
      c = (unsigned long )((unsigned char )((int )*(s + pos) - 97));
#line 60
      if (c < 6UL) {
#line 60
        c += 10UL;
#line 60
        if (! c) {
#line 60
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 60
        c = (unsigned long )((unsigned char )((int )*(s + pos) - 65));
#line 60
        if (c < 6UL) {
#line 60
          c += 10UL;
#line 60
          if (! c) {
#line 60
            goto while_break;
          }
        } else {
#line 60
          goto while_break;
        }
      }
    }
#line 66
    result = result * 16UL + c;
#line 66
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  *u = result;
#line 67
  return (pos);
}
}
#line 70 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_nbblong(char *s , unsigned int n , unsigned int base , unsigned int bext ,
                          unsigned long *u ) 
{ 
  unsigned int pos ;
  unsigned long result ;
  unsigned long c ;

  {
#line 75
  pos = 0U;
#line 75
  result = 0UL;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    c = (unsigned long )((unsigned char )((int )*(s + pos) - 48));
#line 76
    if (! (c < (unsigned long )base)) {
#line 76
      c = (unsigned long )((unsigned char )((int )*(s + pos) - 97));
#line 76
      if (c < (unsigned long )bext) {
#line 76
        c += (unsigned long )base;
#line 76
        if (! c) {
#line 76
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 76
        c = (unsigned long )((unsigned char )((int )*(s + pos) - 65));
#line 76
        if (c < (unsigned long )bext) {
#line 76
          c += (unsigned long )base;
#line 76
          if (! c) {
#line 76
            goto while_break;
          }
        } else {
#line 76
          goto while_break;
        }
      }
    }
#line 82
    result = result * (unsigned long )(base + bext) + c;
#line 82
    pos ++;
#line 82
    if (pos == n) {
#line 82
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  *u = result;
#line 83
  return (pos);
}
}
#line 86 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_uint(char *s , unsigned int *u ) 
{ 
  unsigned int pos ;
  unsigned long result ;

  {
  {
#line 89
  pos = scan_ulong(s, & result);
#line 90
  *u = (unsigned int )result;
  }
#line 90
  return (pos);
}
}
#line 93 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_xint(char *s , unsigned int *u ) 
{ 
  unsigned int pos ;
  unsigned long result ;

  {
  {
#line 96
  pos = scan_xlong(s, & result);
#line 97
  *u = (unsigned int )result;
  }
#line 97
  return (pos);
}
}
#line 100 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_nbbint(char *s , unsigned int n , unsigned int base , unsigned int bext ,
                         unsigned int *u ) 
{ 
  unsigned int pos ;
  unsigned long result ;

  {
  {
#line 104
  pos = scan_nbblong(s, n, base, bext, & result);
#line 105
  *u = (unsigned int )result;
  }
#line 105
  return (pos);
}
}
#line 108 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_ushort(char *s , unsigned short *u ) 
{ 
  unsigned int pos ;
  unsigned long result ;

  {
  {
#line 111
  pos = scan_ulong(s, & result);
#line 112
  *u = (unsigned short )result;
  }
#line 112
  return (pos);
}
}
#line 115 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_xshort(char *s , unsigned short *u ) 
{ 
  unsigned int pos ;
  unsigned long result ;

  {
  {
#line 118
  pos = scan_xlong(s, & result);
#line 119
  *u = (unsigned short )result;
  }
#line 119
  return (pos);
}
}
#line 122 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_nbbshort(char *s , unsigned int n , unsigned int base , unsigned int bext ,
                           unsigned short *u ) 
{ 
  unsigned int pos ;
  unsigned long result ;

  {
  {
#line 126
  pos = scan_nbblong(s, n, base, bext, & result);
#line 127
  *u = (unsigned short )result;
  }
#line 127
  return (pos);
}
}
#line 130 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_charsetnskip(char *s , char *chars , unsigned int n ) 
{ 
  unsigned int pos ;

  {
#line 133
  pos = 0U;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! *(chars + *(s + pos))) {
#line 134
      goto while_break;
    }
#line 135
    pos ++;
#line 135
    if (pos == n) {
#line 136
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  return (pos);
}
}
#line 140 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_noncharsetnskip(char *s , char *chars , unsigned int n ) 
{ 
  unsigned int pos ;

  {
#line 143
  pos = 0U;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (! *(chars + *(s + pos)))) {
#line 144
      goto while_break;
    }
#line 145
    pos ++;
#line 145
    if (pos == n) {
#line 146
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return (pos);
}
}
#line 150 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_whitenskip(char *s , unsigned int n ) 
{ 
  unsigned int pos ;
  char c ;

  {
#line 153
  pos = 0U;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    c = *(s + pos);
#line 154
    if (! ((int )c == 32)) {
#line 154
      if (! ((int )c == 9)) {
#line 154
        goto while_break;
      }
    }
#line 155
    pos ++;
#line 155
    if (pos == n) {
#line 156
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return (pos);
}
}
#line 160 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_nonwhitenskip(char *s , unsigned int n ) 
{ 
  unsigned int pos ;
  char c ;

  {
#line 163
  pos = 0U;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    c = *(s + pos);
#line 166
    if (c) {
#line 166
      if ((int )c != 32) {
#line 166
        if (! ((int )c != 9)) {
#line 166
          goto while_break;
        }
      } else {
#line 166
        goto while_break;
      }
    } else {
#line 166
      goto while_break;
    }
#line 167
    pos ++;
#line 167
    if (pos == n) {
#line 168
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  return (pos);
}
}
#line 172 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_strncmp(char *s , char *t , unsigned int n ) 
{ 
  unsigned int pos ;
  char c ;

  {
#line 175
  pos = 0U;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    c = *(s + pos);
#line 176
    if (c) {
#line 176
      if (! ((int )c == (int )*(t + pos))) {
#line 176
        goto while_break;
      }
    } else {
#line 176
      goto while_break;
    }
#line 177
    pos ++;
#line 177
    if (pos == n) {
#line 178
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  return (pos);
}
}
#line 182 "/home/wheatley/newnew/temp/multitee-3.0/scan.c"
unsigned int scan_memcmp(char *s , char *t , unsigned int n ) 
{ 
  unsigned int pos ;

  {
#line 186
  pos = 0U;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! n) {
#line 187
      goto while_break;
    }
#line 187
    if ((int )*(s + pos) != (int )*(t + pos)) {
#line 187
      goto while_break;
    } else {
#line 187
      n --;
#line 187
      pos ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return (pos);
}
}
#line 33 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
static int bufsize  =    8192;
#line 51 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
int flagverbose  ;
#line 55
void outofmem(void) ;
#line 55 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
static char mfoom[32]  = 
#line 55
  {      (char )'m',      (char )'u',      (char )'l',      (char )'t', 
        (char )'i',      (char )'t',      (char )'e',      (char )'e', 
        (char )':',      (char )' ',      (char )'f',      (char )'a', 
        (char )'t',      (char )'a',      (char )'l',      (char )':', 
        (char )' ',      (char )'o',      (char )'u',      (char )'t', 
        (char )' ',      (char )'o',      (char )'f',      (char )' ', 
        (char )'m',      (char )'e',      (char )'m',      (char )'o', 
        (char )'r',      (char )'y',      (char )'\n',      (char )'\000'};
#line 57
extern int ( /* missing proto */  write)() ;
#line 59
extern int ( /* missing proto */  exit)() ;
#line 53 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
void outofmem(void) 
{ 


  {
#line 56
  if (flagverbose) {
    {
#line 57
    write(2, mfoom, sizeof(mfoom));
    }
  }
  {
#line 59
  exit(3);
  }
}
}
#line 65 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
static char mwre[139]  ;
#line 71
extern int ( /* missing proto */  perror)() ;
#line 62 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
void readerr(int fd ) 
{ 
  char *t ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 66
  if (! flagverbose) {
#line 67
    return;
  }
  {
#line 68
  tmp = fmt_strncpy(mwre, "multitee: warning: cannot read descriptor ");
#line 68
  t = mwre + tmp;
#line 69
  tmp___0 = fmt_uint(t, fd);
#line 69
  t += tmp___0;
#line 70
  *t = (char)0;
#line 71
  perror(mwre);
  }
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
static char mwwe[139]  ;
#line 74 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
void writeerr(int fd ) 
{ 
  char *t ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 78
  if (! flagverbose) {
#line 79
    return;
  }
  {
#line 80
  tmp = fmt_strncpy(mwwe, "multitee: warning: cannot write descriptor ");
#line 80
  t = mwwe + tmp;
#line 81
  tmp___0 = fmt_uint(t, fd);
#line 81
  t += tmp___0;
#line 82
  *t = (char)0;
#line 83
  perror(mwwe);
  }
#line 84
  return;
}
}
#line 100 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
ioscstack *fdio  ;
#line 101 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
intstack *fdeof  ;
#line 102 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
int *fdlive  ;
#line 103 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
int *fdendpos  ;
#line 104 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
int *fdschedcnt  ;
#line 105 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
char **fdbuf  ;
#line 106 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
int fdinmax  ;
#line 108 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
void nomorewrite(int fdout ) 
{ 
  int i ;
  ioscstack iosc ;

  {
#line 113
  i = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (i <= fdinmax)) {
#line 113
      goto while_break;
    }
#line 114
    if (*(fdlive + i)) {
#line 115
      iosc = *(fdio + i);
      {
#line 115
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 115
        if (! iosc) {
#line 115
          goto while_break___0;
        }
#line 116
        if (iosc->data.out == fdout) {
#line 117
          iosc->data.dead = 1;
        }
#line 115
        iosc = iosc->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 113
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 122
void donoread(int fd ) ;
#line 123
void checksched(int fd ) ;
#line 124
void doeof(int fd ) ;
#line 125
void dowritesched(struct iosc *ioscp ) ;
#line 126
void dowriteunsched(struct iosc *ioscp ) ;
#line 140
extern int ( /* missing proto */  read)() ;
#line 130 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
void readit(int fd ) 
{ 
  int r ;
  int endpos ;
  ioscstack iosc ;
  int *tmp ;

  {
#line 137
  endpos = *(fdendpos + fd);
#line 138
  if (*(fdlive + fd)) {
    {
#line 140
    r = read(fd, *(fdbuf + fd) + endpos, bufsize - endpos);
    }
#line 142
    if (r == -1) {
      {
#line 144
      tmp = __errno_location();
      }
#line 144
      if (*tmp == 11) {
#line 145
        return;
      }
      {
#line 147
      readerr(fd);
#line 148
      r = 0;
      }
    }
  } else {
#line 152
    r = 0;
  }
#line 153
  if (r == 0) {
    {
#line 155
    donoread(fd);
#line 156
    doeof(fd);
    }
#line 157
    return;
  }
#line 159
  *(fdendpos + fd) = endpos + r;
#line 160
  if (*(fdio + fd)) {
#line 162
    iosc = *(fdio + fd);
    {
#line 162
    while (1) {
      while_continue: /* CIL Label */ ;
#line 162
      if (! iosc) {
#line 162
        goto while_break;
      }
#line 163
      if (iosc->data.flagsched == 0) {
        {
#line 165
        dowritesched(& iosc->data);
        }
      }
#line 162
      iosc = iosc->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 170
    *(fdendpos + fd) = 0;
  }
#line 171
  if (*(fdendpos + fd) >= bufsize) {
    {
#line 172
    donoread(fd);
    }
  }
#line 173
  return;
}
}
#line 175 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
void writeit(ss_idptr p ) 
{ 
  struct iosc *ioscp ;
  int in ;
  int w ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 182
  ioscp = (struct iosc *)((ioscstack )p);
#line 183
  in = ioscp->in;
#line 185
  if (ioscp->dead) {
#line 186
    w = *(fdendpos + in) - ioscp->startpos;
  } else {
    {
#line 188
    w = write(ioscp->out, *(fdbuf + in) + ioscp->startpos, *(fdendpos + in) - ioscp->startpos);
    }
  }
#line 190
  if (w == -1) {
    {
#line 192
    tmp = __errno_location();
    }
#line 192
    if (*tmp == 11) {
      {
#line 193
      w = write(ioscp->out, *(fdbuf + in), 1);
      }
    }
#line 194
    if (w == -1) {
      {
#line 196
      tmp___0 = __errno_location();
      }
#line 196
      if (*tmp___0 == 32) {
#line 196
        if (ioscp->breakpipe) {
          {
#line 197
          sigdfl(13);
          }
        }
      }
      {
#line 198
      writeerr(ioscp->out);
#line 199
      nomorewrite(ioscp->out);
#line 200
      w = 0;
      }
    }
  }
#line 205
  ioscp->startpos += w;
#line 207
  if (ioscp->startpos == *(fdendpos + in)) {
    {
#line 209
    dowriteunsched(ioscp);
    }
  }
#line 210
  return;
}
}
#line 214 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
void donoread(int fd ) 
{ 
  ss_sig *tmp ;

  {
  {
#line 217
  tmp = ss_sigread(fd);
#line 217
  ss_unsched(tmp, & readit, fd);
  }
#line 218
  return;
}
}
#line 220 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
void checksched(int fd ) 
{ 
  ioscstack iosc ;
  ss_sig *tmp ;
  int tmp___0 ;

  {
#line 225
  if (! *(fdschedcnt + fd)) {
#line 227
    if (*(fdendpos + fd) == bufsize) {
      {
#line 228
      tmp = ss_sigread(fd);
#line 228
      tmp___0 = ss_schedwait(tmp, & readit, fd, 1);
      }
#line 228
      if (tmp___0 == -1) {
        {
#line 229
        outofmem();
        }
      }
    }
#line 230
    *(fdendpos + fd) = 0;
#line 231
    iosc = *(fdio + fd);
    {
#line 231
    while (1) {
      while_continue: /* CIL Label */ ;
#line 231
      if (! iosc) {
#line 231
        goto while_break;
      }
#line 232
      iosc->data.startpos = 0;
#line 231
      iosc = iosc->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 234
  return;
}
}
#line 236 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
void doeof(int fd ) 
{ 
  intstack eof ;
  ss_sig *tmp ;
  int tmp___0 ;

  {
#line 240
  *(fdlive + fd) = 0;
#line 241
  eof = *(fdeof + fd);
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! eof) {
#line 241
      goto while_break;
    }
#line 242
    if (*(fdlive + eof->data)) {
      {
#line 244
      *(fdlive + eof->data) = 0;
#line 245
      donoread(eof->data);
#line 246
      tmp = ss_asap();
#line 246
      tmp___0 = ss_schedonce(tmp, & readit, eof->data);
      }
#line 246
      if (tmp___0 == -1) {
        {
#line 247
        outofmem();
        }
      }
    }
#line 241
    eof = eof->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  return;
}
}
#line 251 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
void dowritesched(struct iosc *ioscp ) 
{ 
  ss_sig *tmp ;
  int tmp___0 ;

  {
#line 254
  if (! ioscp->flagsched) {
#line 255
    (*(fdschedcnt + ioscp->in)) ++;
  }
  {
#line 256
  ioscp->flagsched = 1;
#line 258
  tmp = ss_sigwrite(ioscp->out);
#line 258
  tmp___0 = ss_schedvwait(tmp, & writeit, 0, 0, (ss_idptr )ioscp, 1);
  }
#line 258
  if (tmp___0 == -1) {
    {
#line 259
    outofmem();
    }
  }
#line 264
  return;
}
}
#line 266 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
void dowriteunsched(struct iosc *ioscp ) 
{ 
  int in ;
  ss_sig *tmp ;

  {
  {
#line 271
  tmp = ss_sigwrite(ioscp->out);
#line 271
  ss_unschedv(tmp, & writeit, 0, 0, (ss_idptr )ioscp);
#line 272
  in = ioscp->in;
#line 273
  ioscp->flagsched = 0;
#line 274
  (*(fdschedcnt + in)) --;
#line 275
  checksched(in);
  }
#line 276
  return;
}
}
#line 282 "/home/wheatley/newnew/temp/multitee-3.0/multitee.c"
int main(int argc , char **argv ) 
{ 
  int opt ;
  char ch ;
  char *t ;
  int fd ;
  intstack fdinhead ;
  intstack fdin ;
  opstack iohead ;
  opstack eofhead ;
  opstack op ;
  ioscstack iosc ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  ss_sig *tmp___13 ;
  int tmp___14 ;

  {
#line 299
  fdinhead = (intstack )0;
#line 300
  iohead = (opstack )0;
#line 301
  eofhead = (opstack )0;
#line 303
  flagverbose = 1;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 305
    opt = getoptmine(argc, argv, "b:vqQ");
    }
#line 305
    if (! (opt != getopteof)) {
#line 305
      goto while_break;
    }
    {
#line 308
    if (opt == 98) {
#line 308
      goto case_98;
    }
#line 312
    if (opt == 118) {
#line 312
      goto case_118;
    }
#line 315
    if (opt == 113) {
#line 315
      goto case_113;
    }
#line 318
    if (opt == 81) {
#line 318
      goto case_81;
    }
#line 322
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 309
    tmp = scan_uint(getoptarg, & bufsize);
    }
#line 311
    goto switch_break;
    case_118: /* CIL Label */ 
#line 313
    flagverbose = 2;
#line 314
    goto switch_break;
    case_113: /* CIL Label */ 
#line 316
    flagverbose = 0;
#line 317
    goto switch_break;
    case_81: /* CIL Label */ 
#line 319
    flagverbose = 1;
#line 320
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 323
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  argc -= getoptind;
#line 326
  argv += getoptind;
  {
#line 328
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 328
    if (! *argv) {
#line 328
      goto while_break___0;
    }
    {
#line 330
    tmp___0 = ralloc(sizeof(*fdin));
#line 330
    fdin = (intstack )tmp___0;
    }
#line 331
    if (! fdin) {
      {
#line 332
      outofmem();
      }
    }
    {
#line 333
    t = *argv;
#line 334
    tmp___1 = scan_uint(t, & fdin->data);
#line 334
    t += tmp___1;
#line 335
    fdin->next = fdinhead;
#line 335
    fdinhead = fdin;
    }
    {
#line 336
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 336
      ch = *t;
#line 336
      if (! ch) {
#line 336
        goto while_break___1;
      }
      {
#line 338
      tmp___2 = ralloc(sizeof(*op));
#line 338
      op = (opstack )tmp___2;
      }
#line 339
      if (! op) {
        {
#line 340
        outofmem();
        }
      }
      {
#line 341
      op->data.fdin = fdin->data;
#line 342
      op->data.special = 0;
#line 343
      t ++;
#line 344
      tmp___3 = scan_uint(t, & op->data.fd);
#line 344
      t += tmp___3;
      }
      {
#line 347
      if ((int )ch == 58) {
#line 347
        goto case_58;
      }
#line 350
      if ((int )ch == 44) {
#line 350
        goto case_44;
      }
#line 350
      if ((int )ch == 45) {
#line 350
        goto case_44;
      }
#line 353
      if ((int )ch == 101) {
#line 353
        goto case_101;
      }
#line 357
      goto switch_default___0;
      case_58: /* CIL Label */ 
#line 348
      op->data.special = 1;
      case_44: /* CIL Label */ 
      case_45: /* CIL Label */ 
#line 351
      op->next = iohead;
#line 351
      iohead = op;
#line 352
      goto switch_break___0;
      case_101: /* CIL Label */ 
#line 354
      op->next = eofhead;
#line 354
      eofhead = op;
#line 355
      goto switch_break___0;
      switch_default___0: /* CIL Label */ ;
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 362
    argv ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 365
  if (! fdinhead) {
    {
#line 366
    exit(0);
    }
  }
#line 367
  fdinmax = fdinhead->data;
#line 368
  fdin = fdinhead;
  {
#line 368
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 368
    if (! fdin) {
#line 368
      goto while_break___2;
    }
#line 370
    fd = fdin->data;
#line 371
    if (fd > fdinmax) {
#line 372
      fdinmax = fd;
    }
#line 368
    fdin = fdin->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 375
  tmp___4 = ralloc((unsigned long )(fdinmax + 1) * sizeof(ioscstack ));
#line 375
  fdio = (ioscstack *)tmp___4;
  }
#line 376
  if (! fdio) {
    {
#line 376
    outofmem();
    }
  }
#line 377
  fd = 0;
  {
#line 377
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 377
    if (! (fd <= fdinmax)) {
#line 377
      goto while_break___3;
    }
#line 377
    *(fdio + fd) = (ioscstack )0;
#line 377
    fd ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 378
  tmp___5 = ralloc((unsigned long )(fdinmax + 1) * sizeof(intstack ));
#line 378
  fdeof = (intstack *)tmp___5;
  }
#line 379
  if (! fdeof) {
    {
#line 379
    outofmem();
    }
  }
#line 380
  fd = 0;
  {
#line 380
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 380
    if (! (fd <= fdinmax)) {
#line 380
      goto while_break___4;
    }
#line 380
    *(fdeof + fd) = (intstack )0;
#line 380
    fd ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 381
  tmp___6 = ralloc((unsigned long )(fdinmax + 1) * sizeof(int ));
#line 381
  fdlive = (int *)tmp___6;
  }
#line 382
  if (! fdlive) {
    {
#line 382
    outofmem();
    }
  }
#line 383
  fd = 0;
  {
#line 383
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 383
    if (! (fd <= fdinmax)) {
#line 383
      goto while_break___5;
    }
#line 383
    *(fdlive + fd) = 0;
#line 383
    fd ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 384
  tmp___7 = ralloc((unsigned long )(fdinmax + 1) * sizeof(int ));
#line 384
  fdendpos = (int *)tmp___7;
  }
#line 385
  if (! fdendpos) {
    {
#line 385
    outofmem();
    }
  }
#line 386
  fd = 0;
  {
#line 386
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 386
    if (! (fd <= fdinmax)) {
#line 386
      goto while_break___6;
    }
#line 386
    *(fdendpos + fd) = 0;
#line 386
    fd ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 387
  tmp___8 = ralloc((unsigned long )(fdinmax + 1) * sizeof(int ));
#line 387
  fdschedcnt = (int *)tmp___8;
  }
#line 388
  if (! fdschedcnt) {
    {
#line 388
    outofmem();
    }
  }
#line 389
  fd = 0;
  {
#line 389
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 389
    if (! (fd <= fdinmax)) {
#line 389
      goto while_break___7;
    }
#line 389
    *(fdschedcnt + fd) = 0;
#line 389
    fd ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 390
  tmp___9 = ralloc((unsigned long )(fdinmax + 1) * sizeof(char *));
#line 390
  fdbuf = (char **)tmp___9;
  }
#line 391
  if (! fdbuf) {
    {
#line 391
    outofmem();
    }
  }
  {
#line 394
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 394
    if (! fdinhead) {
#line 394
      goto while_break___8;
    }
    {
#line 396
    fdin = fdinhead;
#line 396
    fdinhead = fdinhead->next;
#line 397
    *(fdlive + fdin->data) = 1;
#line 398
    rfree((char *)fdin);
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 401
  fd = 0;
  {
#line 401
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 401
    if (! (fd <= fdinmax)) {
#line 401
      goto while_break___9;
    }
#line 402
    if (*(fdlive + fd)) {
      {
#line 403
      tmp___10 = ralloc(bufsize);
#line 403
      *(fdbuf + fd) = tmp___10;
      }
#line 403
      if (! tmp___10) {
        {
#line 404
        outofmem();
        }
      }
    }
#line 401
    fd ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 406
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 406
    if (! iohead) {
#line 406
      goto while_break___10;
    }
    {
#line 408
    op = iohead;
#line 408
    iohead = iohead->next;
#line 409
    tmp___11 = ralloc(sizeof(*iosc));
#line 409
    iosc = (ioscstack )tmp___11;
    }
#line 410
    if (! iosc) {
      {
#line 411
      outofmem();
      }
    }
    {
#line 412
    iosc->data.in = op->data.fdin;
#line 413
    iosc->data.out = op->data.fd;
#line 414
    iosc->data.dead = 0;
#line 415
    iosc->data.breakpipe = op->data.special;
#line 416
    iosc->data.startpos = 0;
#line 417
    iosc->data.flagsched = 0;
#line 418
    iosc->next = *(fdio + op->data.fdin);
#line 418
    *(fdio + op->data.fdin) = iosc;
#line 419
    rfree((char *)op);
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 422
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 422
    if (! eofhead) {
#line 422
      goto while_break___11;
    }
    {
#line 424
    op = eofhead;
#line 424
    eofhead = eofhead->next;
#line 425
    tmp___12 = ralloc(sizeof(*fdin));
#line 425
    fdin = (intstack )tmp___12;
    }
#line 426
    if (! fdin) {
      {
#line 427
      outofmem();
      }
    }
    {
#line 428
    fdin->data = op->data.fd;
#line 429
    fdin->next = *(fdeof + op->data.fdin);
#line 429
    *(fdeof + op->data.fdin) = fdin;
#line 430
    rfree((char *)op);
    }
  }
  while_break___11: /* CIL Label */ ;
  }
#line 433
  fd = 0;
  {
#line 433
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 433
    if (! (fd <= fdinmax)) {
#line 433
      goto while_break___12;
    }
#line 434
    if (*(fdlive + fd)) {
      {
#line 435
      tmp___13 = ss_sigread(fd);
#line 435
      ss_schedwait(tmp___13, & readit, fd, 1);
      }
    }
#line 433
    fd ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 437
  ss_addsig(13);
#line 439
  tmp___14 = ss_exec();
  }
#line 439
  if (tmp___14 == -1) {
    {
#line 440
    outofmem();
    }
  }
  {
#line 442
  exit(0);
  }
}
}
