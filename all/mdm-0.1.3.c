/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 46 "include/middleman.h"
struct __anonstruct_sv_24 {
   char *buffer ;
   char **svec ;
};
#line 46 "include/middleman.h"
typedef struct __anonstruct_sv_24 sv;
#line 51 "include/middleman.h"
struct __anonstruct_job_25 {
   sv cmd ;
   sv env ;
   int cwd ;
};
#line 51 "include/middleman.h"
typedef struct __anonstruct_job_25 job;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 242 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_un;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 35 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
struct __anonstruct_iospec_33 {
   char *name ;
   char *resources ;
   int res_count ;
};
#line 35 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
typedef struct __anonstruct_iospec_33 iospec;
#line 150 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
struct __anonstruct_util_34 {
   char usage ;
   char *name ;
   int count ;
};
#line 150 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
typedef struct __anonstruct_util_34 util;
#line 89 "include/middleman.h"
struct __anonstruct_proc_24 {
   char state ;
   pid_t ppid ;
   unsigned long utime ;
   time_t start_time ;
};
#line 89 "include/middleman.h"
typedef struct __anonstruct_proc_24 proc;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 46 "/usr/include/err.h"
extern  __attribute__((__noreturn__)) void ( /* format attribute */  err)(int __status ,
                                                                          char const   *__format 
                                                                          , ...) ;
#line 50
extern  __attribute__((__noreturn__)) void ( /* format attribute */  errx)(int __status ,
                                                                           char const   *__format 
                                                                           , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 77 "include/middleman.h"
void *xmalloc(size_t size ) ;
#line 78
char *path_join(char const   *path , char const   *name___0 ) ;
#line 79
char *xstrdup(char const   *s ) ;
#line 80
void release_sv(sv *sv___0 ) ;
#line 81
void release_job(job *job___0 ) ;
#line 82
void flatten_sv(sv *sv___0 ) ;
#line 27 "/home/wheatley/newnew/temp/mdm-0.1.3/library/buffer.c"
void *xmalloc(size_t size ) 
{ 
  void *ptr___0 ;
  void *tmp ;

  {
  {
#line 29
  tmp = malloc(size);
#line 29
  ptr___0 = tmp;
  }
#line 30
  if (size > 0UL) {
#line 30
    if ((unsigned long )ptr___0 == (unsigned long )((void *)0)) {
      {
#line 31
      errx(100, "Memory allocation failure (%u bytes)", size);
      }
    }
  }
#line 32
  return (ptr___0);
}
}
#line 35 "/home/wheatley/newnew/temp/mdm-0.1.3/library/buffer.c"
char *path_join(char const   *path , char const   *name___0 ) 
{ 
  int path_len ;
  int name_len ;
  char *pathname ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 40
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 41
    errx(101, "NULL argument in path_join");
    }
  } else
#line 40
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
    {
#line 41
    errx(101, "NULL argument in path_join");
    }
  }
#line 42
  if ((int const   )*(path + 0) != 47) {
    {
#line 43
    errx(102, "Relative path argument 1 in path_join");
    }
  }
  {
#line 44
  tmp = strchr(name___0, '/');
  }
#line 44
  if (tmp) {
    {
#line 45
    errx(103, "Relative path argument 2 in path_join");
    }
  }
  {
#line 47
  tmp___0 = strlen(path);
#line 47
  path_len = (int )tmp___0;
#line 48
  tmp___1 = strlen(name___0);
#line 48
  name_len = (int )tmp___1;
#line 49
  tmp___2 = xmalloc((size_t )((path_len + name_len) + 2));
#line 49
  pathname = (char *)tmp___2;
#line 51
  strcpy((char */* __restrict  */)pathname, (char const   */* __restrict  */)path);
  }
#line 52
  if ((int )*(pathname + (path_len - 1)) != 47) {
#line 53
    tmp___3 = path_len;
#line 53
    path_len ++;
#line 53
    *(pathname + tmp___3) = (char )'/';
  }
  {
#line 54
  strcpy((char */* __restrict  */)(pathname + path_len), (char const   */* __restrict  */)name___0);
  }
#line 55
  return (pathname);
}
}
#line 58 "/home/wheatley/newnew/temp/mdm-0.1.3/library/buffer.c"
char *xstrdup(char const   *s ) 
{ 
  char *dup___0 ;
  char *tmp ;

  {
  {
#line 60
  tmp = strdup(s);
#line 60
  dup___0 = tmp;
  }
#line 61
  if ((unsigned long )dup___0 == (unsigned long )((void *)0)) {
    {
#line 61
    err(104, "strdup");
    }
  }
#line 62
  return (dup___0);
}
}
#line 65 "/home/wheatley/newnew/temp/mdm-0.1.3/library/buffer.c"
void release_sv(sv *sv___0 ) 
{ 


  {
  {
#line 67
  free((void *)sv___0->buffer);
#line 68
  free((void *)sv___0->svec);
#line 69
  sv___0->buffer = (char *)((void *)0);
#line 70
  sv___0->svec = (char **)((void *)0);
  }
#line 71
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/mdm-0.1.3/library/buffer.c"
void release_job(job *job___0 ) 
{ 


  {
  {
#line 75
  release_sv(& job___0->cmd);
#line 76
  release_sv(& job___0->env);
  }
#line 77
  return;
}
}
#line 79 "/home/wheatley/newnew/temp/mdm-0.1.3/library/buffer.c"
void flatten_sv(sv *sv___0 ) 
{ 
  char *vp ;
  char *bp ;
  int index___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 84
  if ((unsigned long )sv___0->buffer != (unsigned long )((void *)0)) {
#line 84
    if (! ((unsigned long )sv___0->svec != (unsigned long )((void *)0))) {
      {
#line 84
      __assert_fail("sv->buffer != ((void *)0) && sv->svec != ((void *)0)", "/home/wheatley/newnew/temp/mdm-0.1.3/library/buffer.c",
                    84U, "flatten_sv");
      }
    }
  } else {
    {
#line 84
    __assert_fail("sv->buffer != ((void *)0) && sv->svec != ((void *)0)", "/home/wheatley/newnew/temp/mdm-0.1.3/library/buffer.c",
                  84U, "flatten_sv");
    }
  }
#line 85
  if (! ((unsigned long )*(sv___0->svec + 0) == (unsigned long )sv___0->buffer)) {
    {
#line 85
    __assert_fail("sv->svec[0] == sv->buffer", "/home/wheatley/newnew/temp/mdm-0.1.3/library/buffer.c",
                  85U, "flatten_sv");
    }
  }
#line 87
  index___0 = 0;
#line 87
  bp = sv___0->buffer;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! *(sv___0->svec + index___0)) {
#line 87
      goto while_break;
    }
#line 88
    vp = *(sv___0->svec + index___0);
    {
#line 89
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 89
      if (! *vp) {
#line 89
        goto while_break___0;
      }
#line 89
      tmp = bp;
#line 89
      bp ++;
#line 89
      tmp___0 = vp;
#line 89
      vp ++;
#line 89
      *tmp = *tmp___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 90
    tmp___1 = bp;
#line 90
    bp ++;
#line 90
    *tmp___1 = (char )' ';
#line 87
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  bp --;
#line 92
  *bp = (char )'\000';
#line 93
  free((void *)sv___0->svec);
#line 94
  sv___0->svec = (char **)((void *)0);
  }
#line 95
  return;
}
}
#line 34 "/usr/include/err.h"
extern void ( /* format attribute */  warn)(char const   *__format  , ...) ;
#line 40
extern void ( /* format attribute */  warnx)(char const   *__format  , ...) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 184
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 56 "include/middleman.h"
int serv_listen(char const   *name___0 ) ;
#line 57
int serv_accept(int listenfd ) ;
#line 58
int cli_conn(char const   *name___0 ) ;
#line 60
int send_fd(int sockfd , int fd ) ;
#line 61
int recv_fd(int sockfd ) ;
#line 63
void check_sockdir(char const   *path ) ;
#line 65
ssize_t readn(int fd , void *vptr , size_t n ) ;
#line 66
ssize_t writen(int fd , void const   *vptr , size_t n ) ;
#line 67
ssize_t write_int(int fd , int v ) ;
#line 68
ssize_t write_pid(int fd , pid_t v ) ;
#line 69
ssize_t write_time(int fd , time_t v ) ;
#line 31 "/home/wheatley/newnew/temp/mdm-0.1.3/library/socket.c"
int serv_listen(char const   *name___0 ) 
{ 
  int sockfd ;
  int addrlen ;
  struct sockaddr_un unix_addr ;
  struct sockaddr *sock_addr ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 37
  sockfd = socket(1, 1, 0);
  }
#line 38
  if (sockfd < 0) {
    {
#line 39
    warn("socket");
    }
#line 40
    return (-1);
  }
  {
#line 43
  tmp = strlen(name___0);
#line 43
  addrlen = (int )tmp;
  }
#line 44
  if ((unsigned long )addrlen >= sizeof(unix_addr.sun_path)) {
    {
#line 45
    warnx("serv_listen: socket name too long");
    }
#line 46
    return (-2);
  }
  {
#line 48
  addrlen = (int )((unsigned long )addrlen + sizeof(unix_addr.sun_family));
#line 50
  memset((void *)(& unix_addr), 0, sizeof(unix_addr));
#line 51
  unix_addr.sun_family = (sa_family_t )1;
#line 52
  strcpy((char */* __restrict  */)(unix_addr.sun_path), (char const   */* __restrict  */)name___0);
#line 54
  unlink(name___0);
#line 55
  sock_addr = (struct sockaddr *)(& unix_addr);
#line 56
  tmp___0 = bind(sockfd, (struct sockaddr  const  */* __restrict  */)sock_addr, (socklen_t )addrlen);
  }
#line 56
  if (tmp___0 < 0) {
    {
#line 57
    warn("bind");
    }
#line 58
    return (-3);
  }
  {
#line 61
  tmp___1 = listen(sockfd, 5);
  }
#line 61
  if (tmp___1 < 0) {
    {
#line 62
    warn("listen");
    }
#line 63
    return (-4);
  }
#line 65
  return (sockfd);
}
}
#line 70 "/home/wheatley/newnew/temp/mdm-0.1.3/library/socket.c"
int serv_accept(int listenfd ) 
{ 
  int connfd ;

  {
  {
#line 74
  connfd = accept(listenfd, (struct sockaddr */* __restrict  */)((void *)0), (socklen_t */* __restrict  */)((void *)0));
  }
#line 75
  if (connfd < 0) {
    {
#line 76
    warn("accept");
    }
  }
#line 77
  return (connfd);
}
}
#line 82 "/home/wheatley/newnew/temp/mdm-0.1.3/library/socket.c"
int cli_conn(char const   *name___0 ) 
{ 
  int sockfd ;
  int addrlen ;
  struct sockaddr_un unix_addr ;
  struct sockaddr *sock_addr ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 88
  sockfd = socket(1, 1, 0);
  }
#line 89
  if (sockfd < 0) {
    {
#line 90
    warn("socket");
    }
#line 91
    return (-1);
  }
  {
#line 94
  tmp = strlen(name___0);
#line 94
  addrlen = (int )tmp;
  }
#line 95
  if ((unsigned long )addrlen >= sizeof(unix_addr.sun_path)) {
    {
#line 96
    warnx("serv_listen: socket name too long");
    }
#line 97
    return (-2);
  }
  {
#line 99
  addrlen = (int )((unsigned long )addrlen + sizeof(unix_addr.sun_family));
#line 101
  memset((void *)(& unix_addr), 0, sizeof(unix_addr));
#line 102
  unix_addr.sun_family = (sa_family_t )1;
#line 103
  strcpy((char */* __restrict  */)(unix_addr.sun_path), (char const   */* __restrict  */)name___0);
#line 105
  sock_addr = (struct sockaddr *)(& unix_addr);
#line 106
  tmp___0 = connect(sockfd, (struct sockaddr  const  */* __restrict  */)sock_addr,
                    (socklen_t )addrlen);
  }
#line 106
  if (tmp___0 < 0) {
    {
#line 107
    warn("connect");
    }
#line 108
    return (-3);
  }
#line 110
  return (sockfd);
}
}
#line 115 "/home/wheatley/newnew/temp/mdm-0.1.3/library/socket.c"
ssize_t readn(int fd , void *vptr , size_t n ) 
{ 
  size_t remaining ;
  ssize_t received ;
  char *ptr___0 ;

  {
#line 121
  remaining = n;
#line 122
  ptr___0 = (char *)vptr;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! (remaining > 0UL)) {
#line 123
      goto while_break;
    }
    {
#line 124
    received = read(fd, (void *)ptr___0, remaining);
    }
#line 125
    if (received <= 0L) {
#line 126
      if (received < 0L) {
        {
#line 126
        warn("read");
        }
      }
#line 127
      return (received);
    }
#line 129
    remaining -= (size_t )received;
#line 130
    ptr___0 += received;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return ((ssize_t )n);
}
}
#line 137 "/home/wheatley/newnew/temp/mdm-0.1.3/library/socket.c"
ssize_t writen(int fd , void const   *vptr , size_t n ) 
{ 
  size_t remaining ;
  ssize_t written ;
  char const   *ptr___0 ;

  {
#line 143
  remaining = n;
#line 144
  ptr___0 = (char const   *)vptr;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (remaining > 0UL)) {
#line 145
      goto while_break;
    }
    {
#line 146
    written = write(fd, (void const   *)ptr___0, remaining);
    }
#line 147
    if (written <= 0L) {
#line 148
      if (written < 0L) {
        {
#line 148
        warn("write");
        }
      }
#line 149
      return (written);
    }
#line 151
    remaining -= (size_t )written;
#line 152
    ptr___0 += written;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return ((ssize_t )n);
}
}
#line 161 "/home/wheatley/newnew/temp/mdm-0.1.3/library/socket.c"
static struct cmsghdr *cmptr  =    (struct cmsghdr *)((void *)0);
#line 163 "/home/wheatley/newnew/temp/mdm-0.1.3/library/socket.c"
int send_fd(int sockfd , int fd ) 
{ 
  struct iovec iov ;
  struct msghdr msg ;
  char ch ;
  void *tmp ;
  ssize_t tmp___0 ;

  {
#line 169
  ch = (char)0;
#line 170
  iov.iov_base = (void *)(& ch);
#line 171
  iov.iov_len = (size_t )1;
#line 172
  msg.msg_iov = & iov;
#line 173
  msg.msg_iovlen = (size_t )1;
#line 174
  msg.msg_name = (void *)0;
#line 175
  msg.msg_namelen = (socklen_t )0;
#line 177
  if (! cmptr) {
    {
#line 177
    tmp = xmalloc(sizeof(struct cmsghdr ) + sizeof(int ));
#line 177
    cmptr = (struct cmsghdr *)tmp;
    }
  }
  {
#line 178
  cmptr->cmsg_level = 1;
#line 179
  cmptr->cmsg_type = 1;
#line 180
  cmptr->cmsg_len = sizeof(struct cmsghdr ) + sizeof(int );
#line 181
  msg.msg_control = (void *)((caddr_t )cmptr);
#line 182
  msg.msg_controllen = sizeof(struct cmsghdr ) + sizeof(int );
#line 183
  *((int *)(cmptr->__cmsg_data)) = fd;
#line 185
  tmp___0 = sendmsg(sockfd, (struct msghdr  const  *)(& msg), 0);
  }
#line 185
  if (tmp___0 != 1L) {
    {
#line 186
    warn("send_fd sendmsg");
    }
#line 187
    return (-1);
  }
#line 189
  return (0);
}
}
#line 194 "/home/wheatley/newnew/temp/mdm-0.1.3/library/socket.c"
int recv_fd(int sockfd ) 
{ 
  struct cmsghdr *cmptr___3 ;
  struct iovec iov ;
  struct msghdr msg ;
  char ch ;
  int nread ;
  void *tmp ;
  ssize_t tmp___0 ;

  {
#line 196
  cmptr___3 = (struct cmsghdr *)((void *)0);
#line 202
  iov.iov_base = (void *)(& ch);
#line 203
  iov.iov_len = (size_t )1;
#line 204
  msg.msg_iov = & iov;
#line 205
  msg.msg_iovlen = (size_t )1;
#line 206
  msg.msg_name = (void *)0;
#line 207
  msg.msg_namelen = (socklen_t )0;
#line 209
  if (! cmptr___3) {
    {
#line 209
    tmp = xmalloc(sizeof(struct cmsghdr ) + sizeof(int ));
#line 209
    cmptr___3 = (struct cmsghdr *)tmp;
    }
  }
  {
#line 210
  msg.msg_control = (void *)((caddr_t )cmptr___3);
#line 211
  msg.msg_controllen = sizeof(struct cmsghdr ) + sizeof(int );
#line 212
  tmp___0 = recvmsg(sockfd, & msg, 0);
#line 212
  nread = (int )tmp___0;
  }
#line 214
  if (nread < 0) {
    {
#line 215
    warn("recv_fd recvmsg");
    }
#line 216
    return (-1);
  }
#line 218
  if (nread == 0) {
    {
#line 219
    warnx("recv_fd: connection closed by server");
    }
#line 220
    return (-2);
  }
#line 222
  if ((int )ch == 0) {
#line 223
    if (msg.msg_controllen == sizeof(struct cmsghdr ) + sizeof(int )) {
#line 224
      return (*((int *)(cmptr___3->__cmsg_data)));
    }
  }
  {
#line 226
  warnx("recv_fd: protocol error");
  }
#line 227
  return (-3);
}
}
#line 232 "/home/wheatley/newnew/temp/mdm-0.1.3/library/socket.c"
ssize_t write_int(int fd , int v ) 
{ 
  ssize_t tmp ;

  {
  {
#line 234
  tmp = writen(fd, (void const   *)(& v), sizeof(int ));
  }
#line 234
  return (tmp);
}
}
#line 237 "/home/wheatley/newnew/temp/mdm-0.1.3/library/socket.c"
ssize_t write_pid(int fd , pid_t v ) 
{ 
  ssize_t tmp ;

  {
  {
#line 239
  tmp = writen(fd, (void const   *)(& v), sizeof(pid_t ));
  }
#line 239
  return (tmp);
}
}
#line 242 "/home/wheatley/newnew/temp/mdm-0.1.3/library/socket.c"
ssize_t write_time(int fd , time_t v ) 
{ 
  ssize_t tmp ;

  {
  {
#line 244
  tmp = writen(fd, (void const   *)(& v), sizeof(time_t ));
  }
#line 244
  return (tmp);
}
}
#line 249 "/home/wheatley/newnew/temp/mdm-0.1.3/library/socket.c"
void check_sockdir(char const   *path ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 253
  tmp = lstat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
  }
#line 253
  if (tmp < 0) {
    {
#line 254
    err(110, "stat(\"%s\")", path);
    }
  }
#line 255
  if (! ((st.st_mode & 61440U) == 16384U)) {
    {
#line 256
    errx(111, "%s is not a directory", path);
    }
  }
#line 257
  if (st.st_mode & (unsigned int )((128 >> 3) >> 3)) {
    {
#line 258
    errx(112, "%s is world-writable", path);
    }
  }
#line 259
  return;
}
}
#line 71 "include/middleman.h"
void read_job(int fd , job *job___0 ) ;
#line 72
void write_job(int fd , job const   *job___0 ) ;
#line 74
int read_sv(int fd , sv *sv___0 ) ;
#line 75
int write_sv(int fd , char * const  *svec ) ;
#line 28 "/home/wheatley/newnew/temp/mdm-0.1.3/library/comms.c"
static int read_block(int fd , char **buffer___0 ) 
{ 
  int size ;
  void *tmp ;

  {
  {
#line 30
  size = 0;
#line 32
  readn(fd, (void *)(& size), sizeof(int ));
  }
#line 33
  if (size == 0) {
#line 34
    *buffer___0 = (char *)((void *)0);
#line 35
    return (0);
  }
  {
#line 37
  tmp = xmalloc((size_t )size);
#line 37
  *buffer___0 = (char *)tmp;
#line 38
  readn(fd, (void *)*buffer___0, (size_t )size);
  }
#line 39
  if (*(*buffer___0 + (size - 1))) {
    {
#line 40
    warnx("read_block: input is not null-terminated");
    }
#line 41
    return (-2);
  }
#line 43
  return (size);
}
}
#line 48 "/home/wheatley/newnew/temp/mdm-0.1.3/library/comms.c"
static int unpack_svec(sv *sv___0 , int size ) 
{ 
  int ch ;
  int seg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 52
  seg = 0;
#line 52
  ch = seg;
#line 53
  tmp = seg;
#line 53
  seg ++;
#line 53
  *(sv___0->svec + tmp) = sv___0->buffer;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (ch < size)) {
#line 54
      goto while_break;
    }
#line 55
    tmp___0 = ch;
#line 55
    ch ++;
#line 55
    if (*(sv___0->buffer + tmp___0)) {
#line 55
      goto while_continue;
    }
#line 56
    tmp___1 = seg;
#line 56
    seg ++;
#line 56
    *(sv___0->svec + tmp___1) = sv___0->buffer + ch;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  seg --;
#line 58
  *(sv___0->svec + seg) = (char *)((void *)0);
#line 59
  return (seg);
}
}
#line 64 "/home/wheatley/newnew/temp/mdm-0.1.3/library/comms.c"
int read_sv(int fd , sv *sv___0 ) 
{ 
  int size ;
  int count___0 ;
  void *tmp ;

  {
  {
#line 68
  readn(fd, (void *)(& count___0), sizeof(int ));
#line 69
  count___0 ++;
#line 69
  tmp = xmalloc((unsigned long )count___0 * sizeof(char *));
#line 69
  sv___0->svec = (char **)tmp;
#line 70
  size = read_block(fd, & sv___0->buffer);
  }
#line 71
  if (size > 0) {
    {
#line 71
    unpack_svec(sv___0, size);
    }
  }
#line 72
  return (size);
}
}
#line 77 "/home/wheatley/newnew/temp/mdm-0.1.3/library/comms.c"
int write_string(int fd , char const   *buffer___0 ) 
{ 
  int size ;
  size_t tmp ;

  {
  {
#line 81
  tmp = strlen(buffer___0);
#line 81
  size = (int )(tmp + 1UL);
#line 82
  write_int(fd, size);
#line 83
  writen(fd, (void const   *)buffer___0, (size_t )size);
  }
#line 84
  return (size);
}
}
#line 89 "/home/wheatley/newnew/temp/mdm-0.1.3/library/comms.c"
int write_sv(int fd , char * const  *svec ) 
{ 
  int index___0 ;
  int size ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 93
  index___0 = 0;
#line 93
  size = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! *(svec + index___0)) {
#line 93
      goto while_break;
    }
    {
#line 94
    tmp = strlen((char const   *)*(svec + index___0));
#line 94
    size = (int )((size_t )size + tmp);
#line 93
    index___0 ++;
#line 93
    size ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  write_int(fd, index___0);
#line 96
  write_int(fd, size);
#line 97
  index___0 = 0;
  }
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (! *(svec + index___0)) {
#line 97
      goto while_break___0;
    }
    {
#line 98
    tmp___0 = strlen((char const   *)*(svec + index___0));
#line 98
    writen(fd, (void const   *)*(svec + index___0), tmp___0 + 1UL);
#line 97
    index___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  return (0);
}
}
#line 102 "/home/wheatley/newnew/temp/mdm-0.1.3/library/comms.c"
void read_job(int fd , job *job___0 ) 
{ 


  {
  {
#line 104
  readn(fd, (void *)(& job___0->cwd), sizeof(int ));
#line 105
  read_sv(fd, & job___0->cmd);
#line 106
  read_sv(fd, & job___0->env);
  }
#line 107
  return;
}
}
#line 109 "/home/wheatley/newnew/temp/mdm-0.1.3/library/comms.c"
void write_job(int fd , job const   *job___0 ) 
{ 


  {
  {
#line 111
  write_int(fd, (int )job___0->cwd);
#line 112
  write_sv(fd, (char * const  *)job___0->cmd.svec);
#line 113
  write_sv(fd, (char * const  *)job___0->env.svec);
  }
#line 114
  return;
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 34 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 84 "include/middleman.h"
void init_iospec(char const   *config_name ) ;
#line 85
_Bool validate_job(sv *cmd ) ;
#line 86
void register_job(sv *cmd ) ;
#line 87
void unregister_job(sv *cmd ) ;
#line 41 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static void read_iospec(char const   *spec , iospec *ios___1 ) 
{ 
  int count___0 ;
  _Bool new_token___0 ;
  char *cp___0 ;
  unsigned short const   **tmp ;

  {
  {
#line 47
  ios___1->resources = (char *)((void *)0);
#line 48
  ios___1->name = xstrdup(spec);
#line 50
  new_token___0 = (_Bool)0;
#line 51
  cp___0 = ios___1->name;
#line 51
  count___0 = 0;
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! *cp___0) {
#line 51
      goto while_break;
    }
    {
#line 52
    tmp = __ctype_b_loc();
    }
#line 52
    if ((int const   )*(*tmp + (int )*cp___0) & 8192) {
#line 53
      new_token___0 = (_Bool)1;
#line 54
      *cp___0 = (char )'\000';
#line 55
      goto __Cont;
    }
#line 57
    if (new_token___0) {
#line 58
      if ((unsigned long )ios___1->resources == (unsigned long )((void *)0)) {
#line 59
        ios___1->resources = cp___0;
      }
#line 60
      new_token___0 = (_Bool)0;
#line 61
      count___0 ++;
    }
    __Cont: /* CIL Label */ 
#line 51
    cp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  ios___1->res_count = count___0;
#line 65
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static iospec iost[4096]  ;
#line 68 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static int ios_count  ;
#line 70 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
void init_iospec(char const   *config_name ) 
{ 
  char buffer___0[1024] ;
  FILE *config ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 75
  config = fopen((char const   */* __restrict  */)config_name, (char const   */* __restrict  */)"r");
  }
#line 76
  if ((unsigned long )config == (unsigned long )((void *)0)) {
    {
#line 77
    err(120, "Cannot open config file %s", config_name);
    }
  }
#line 79
  ios_count = 0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    tmp___2 = fgets((char */* __restrict  */)(buffer___0), 1024, (FILE */* __restrict  */)config);
    }
#line 80
    if (! tmp___2) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = strlen((char const   *)(buffer___0));
    }
#line 81
    if (tmp == 1023UL) {
      {
#line 82
      err(121, "Line too long in config file");
      }
    }
#line 83
    if ((int )buffer___0[0] == 35) {
#line 84
      goto while_continue;
    }
    {
#line 85
    tmp___0 = __ctype_b_loc();
    }
#line 85
    if ((int const   )*(*tmp___0 + (int )buffer___0[0]) & 8192) {
      {
#line 86
      errx(122, "Line begins with space");
      }
    }
#line 87
    if (ios_count == 4096) {
      {
#line 88
      errx(123, "Too many lines in config file");
      }
    }
    {
#line 89
    tmp___1 = ios_count;
#line 89
    ios_count ++;
#line 89
    read_iospec((char const   *)(buffer___0), & iost[tmp___1]);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 91
  fclose(config);
  }
#line 92
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static iospec *find_iospec(char const   *name___0 ) 
{ 
  int index___0 ;
  int tmp ;

  {
#line 98
  index___0 = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (index___0 < ios_count)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp = strcmp(name___0, (char const   *)iost[index___0].name);
    }
#line 99
    if (tmp == 0) {
#line 100
      return (iost + index___0);
    }
#line 98
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return ((iospec *)((void *)0));
}
}
#line 106
static _Bool iterate_spec(iospec *ios_arg , char **res ) ;
#line 106 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static iospec *ios  =    (iospec *)((void *)0);
#line 107 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static int count  ;
#line 108 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static _Bool new_token  ;
#line 109 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static char *cp  ;
#line 104 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static _Bool iterate_spec(iospec *ios_arg , char **res ) 
{ 


  {
#line 111
  if (ios_arg) {
#line 112
    ios = ios_arg;
#line 113
    count = 0;
#line 114
    new_token = (_Bool)1;
#line 115
    cp = ios->resources;
#line 116
    return ((_Bool)0);
  }
#line 118
  if ((unsigned long )ios == (unsigned long )((void *)0)) {
#line 119
    return ((_Bool)0);
  }
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (count < ios->res_count)) {
#line 121
      goto while_break;
    }
#line 122
    if ((int )*cp == 0) {
#line 123
      new_token = (_Bool)1;
#line 124
      goto __Cont;
    }
#line 126
    if (new_token) {
#line 127
      new_token = (_Bool)0;
#line 128
      count ++;
#line 129
      *res = cp;
#line 130
      return ((_Bool)1);
    }
    __Cont: /* CIL Label */ 
#line 121
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return ((_Bool)0);
}
}
#line 136 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static char calc_usage(char const   *opt___0 , iospec *ios___1 ) 
{ 
  char *cp___0 ;
  char tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 140
  iterate_spec(ios___1, (char **)((void *)0));
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 141
    tmp___1 = iterate_spec((iospec *)((void *)0), & cp___0);
    }
#line 141
    if (! tmp___1) {
#line 141
      goto while_break;
    }
    {
#line 142
    tmp___0 = strcmp(opt___0, (char const   *)(cp___0 + 1));
    }
#line 142
    if (tmp___0 == 0) {
#line 143
      if ((int )*cp___0 == 48) {
#line 143
        if ((int const   )*opt___0 == 45) {
          {
#line 144
          tmp = calc_usage("", ios___1);
          }
#line 144
          return (tmp);
        }
      }
#line 145
      return (*cp___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return ((char )'-');
}
}
#line 156 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static util utit[4096]  ;
#line 157 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static int uti_count  ;
#line 159 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static _Bool conflict(char c1 , char c2 ) 
{ 
  int tmp ;

  {
#line 161
  if ((int )c1 == 87) {
#line 161
    tmp = 1;
  } else
#line 161
  if ((int )c1 != (int )c2) {
#line 161
    tmp = 1;
  } else {
#line 161
    tmp = 0;
  }
#line 161
  return ((_Bool )tmp);
}
}
#line 164 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static _Bool check_conflict(char usage , char const   *name___0 ) 
{ 
  int index___0 ;
  _Bool tmp ;
  int tmp___0 ;

  {
#line 168
  index___0 = 0;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (index___0 < uti_count)) {
#line 168
      goto while_break;
    }
    {
#line 169
    tmp___0 = strcmp(name___0, (char const   *)utit[index___0].name);
    }
#line 169
    if (tmp___0 == 0) {
      {
#line 170
      tmp = conflict(usage, utit[index___0].usage);
      }
#line 170
      if (tmp) {
#line 171
        return ((_Bool)1);
      }
    }
#line 168
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return ((_Bool)0);
}
}
#line 175 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static void add_utilization(char usage , char const   *name___0 ) 
{ 
  int index___0 ;
  int tmp ;

  {
#line 179
  index___0 = 0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (index___0 < uti_count)) {
#line 179
      goto while_break;
    }
    {
#line 180
    tmp = strcmp(name___0, (char const   *)utit[index___0].name);
    }
#line 180
    if (tmp == 0) {
#line 181
      if ((int )usage == (int )utit[index___0].usage) {
#line 182
        goto while_break;
      }
    }
#line 179
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  if (index___0 == 4096) {
    {
#line 185
    errx(124, "Utilization table is full");
    }
  }
#line 187
  if (index___0 < uti_count) {
#line 188
    (utit[index___0].count) ++;
  } else {
    {
#line 190
    utit[index___0].usage = usage;
#line 191
    utit[index___0].name = xstrdup(name___0);
#line 192
    utit[index___0].count = 1;
#line 193
    uti_count ++;
    }
  }
#line 195
  return;
}
}
#line 197 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static void del_utilization(char usage , char const   *name___0 ) 
{ 
  int index___0 ;
  int tmp ;

  {
#line 201
  index___0 = 0;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (index___0 < uti_count)) {
#line 201
      goto while_break;
    }
    {
#line 202
    tmp = strcmp(name___0, (char const   *)utit[index___0].name);
    }
#line 202
    if (tmp == 0) {
#line 203
      if ((int )usage == (int )utit[index___0].usage) {
#line 204
        goto while_break;
      }
    }
#line 201
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  if (! (index___0 < uti_count)) {
    {
#line 206
    __assert_fail("index < uti_count", "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c",
                  206U, "del_utilization");
    }
  }
#line 207
  (utit[index___0].count) --;
#line 207
  if (utit[index___0].count == 0) {
    {
#line 208
    free((void *)utit[index___0].name);
#line 209
    uti_count --;
#line 209
    utit[index___0] = utit[uti_count];
    }
  }
#line 211
  return;
}
}
#line 215 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static char *name  ;
#line 215 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static char *base  ;
#line 216 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static char *opt  ;
#line 216 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static char **ptr  ;
#line 216
static _Bool iterate_usage(sv *cmd , char **ar , char *au ) ;
#line 216 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static char *nul  =    (char *)"";
#line 217 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static iospec *ios___0  ;
#line 218 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static _Bool fixed  ;
#line 218 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static _Bool initial  ;
#line 213 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
static _Bool iterate_usage(sv *cmd , char **ar , char *au ) 
{ 
  char *spec ;
  _Bool tmp ;
  char usage ;
  char tmp___0 ;

  {
#line 221
  if (cmd) {
    {
#line 222
    free((void *)name);
#line 223
    name = xstrdup((char const   *)*(cmd->svec + 0));
#line 224
    base = __xpg_basename(name);
#line 226
    ios___0 = find_iospec((char const   *)base);
#line 227
    opt = nul;
#line 228
    ptr = cmd->svec;
#line 229
    fixed = (_Bool)1;
#line 230
    initial = (_Bool)1;
    }
#line 231
    if (ios___0) {
      {
#line 231
      iterate_spec(ios___0, (char **)((void *)0));
      }
    }
#line 232
    return ((_Bool)0);
  }
#line 234
  if (ar) {
#line 234
    if (! au) {
      {
#line 234
      __assert_fail("ar && au", "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c",
                    234U, "iterate_usage");
      }
    }
  } else {
    {
#line 234
    __assert_fail("ar && au", "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c",
                  234U, "iterate_usage");
    }
  }
#line 236
  if (fixed) {
#line 237
    *ar = (char *)"global";
#line 238
    *au = (char )'R';
#line 239
    fixed = (_Bool)0;
#line 240
    return ((_Bool)1);
  }
#line 243
  if ((unsigned long )ios___0 == (unsigned long )((void *)0)) {
#line 243
    return ((_Bool)0);
  }
#line 245
  if (initial) {
    {
#line 246
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 246
      tmp = iterate_spec((iospec *)((void *)0), & spec);
      }
#line 246
      if (! tmp) {
#line 246
        goto while_break;
      }
#line 247
      if ((int )*(spec + 1) != 45) {
#line 247
        if ((int )*(spec + 1) != 0) {
#line 248
          *ar = spec + 1;
#line 249
          *au = *spec;
#line 250
          return ((_Bool)1);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 252
    initial = (_Bool)0;
  }
  {
#line 255
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 255
    ptr ++;
#line 255
    if (! *ptr) {
#line 255
      goto while_break___0;
    }
#line 256
    if ((int )*(*ptr) != 45) {
      {
#line 257
      tmp___0 = calc_usage((char const   *)opt, ios___0);
#line 257
      usage = tmp___0;
#line 258
      opt = nul;
      }
#line 259
      if ((int )usage != 45) {
#line 260
        *ar = *ptr;
#line 261
        *au = usage;
#line 262
        return ((_Bool)1);
      }
    } else {
#line 265
      opt = *ptr;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 267
  ptr --;
#line 268
  return ((_Bool)0);
}
}
#line 271 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
_Bool validate_job(sv *cmd ) 
{ 
  char *res ;
  char usage ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 275
  if (! cmd->buffer) {
    {
#line 275
    __assert_fail("cmd->buffer", "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c",
                  275U, "validate_job");
    }
  }
  {
#line 276
  iterate_usage(cmd, (char **)((void *)0), (char *)((void *)0));
  }
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 277
    tmp___0 = iterate_usage((sv *)((void *)0), & res, & usage);
    }
#line 277
    if (! tmp___0) {
#line 277
      goto while_break;
    }
    {
#line 278
    tmp = check_conflict(usage, (char const   *)res);
    }
#line 278
    if (tmp) {
#line 279
      return ((_Bool)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return ((_Bool)1);
}
}
#line 283 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
void register_job(sv *cmd ) 
{ 
  char *res ;
  char usage ;
  _Bool tmp ;

  {
#line 287
  if (! cmd->buffer) {
    {
#line 287
    __assert_fail("cmd->buffer", "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c",
                  287U, "register_job");
    }
  }
  {
#line 288
  iterate_usage(cmd, (char **)((void *)0), (char *)((void *)0));
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 289
    tmp = iterate_usage((sv *)((void *)0), & res, & usage);
    }
#line 289
    if (! tmp) {
#line 289
      goto while_break;
    }
    {
#line 290
    add_utilization(usage, (char const   *)res);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  return;
}
}
#line 293 "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c"
void unregister_job(sv *cmd ) 
{ 
  char *res ;
  char usage ;
  _Bool tmp ;

  {
#line 297
  if (! cmd->buffer) {
    {
#line 297
    __assert_fail("cmd->buffer", "/home/wheatley/newnew/temp/mdm-0.1.3/library/hazard.c",
                  297U, "unregister_job");
    }
  }
  {
#line 298
  iterate_usage(cmd, (char **)((void *)0), (char *)((void *)0));
  }
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 299
    tmp = iterate_usage((sv *)((void *)0), & res, & usage);
    }
#line 299
    if (! tmp) {
#line 299
      goto while_break;
    }
    {
#line 300
    del_utilization(usage, (char const   *)res);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return;
}
}
#line 161 "/home/wheatley/newnew/temp/mdm-0.1.3/library/socket.c"
static struct cmsghdr *cmptr___0  =    (struct cmsghdr *)((void *)0);
#line 28 "/home/wheatley/newnew/temp/mdm-0.1.3/library/comms.c"
static int read_block___0(int fd , char **buffer___0 ) 
{ 
  int size ;
  void *tmp ;

  {
  {
#line 30
  size = 0;
#line 32
  readn(fd, (void *)(& size), sizeof(int ));
  }
#line 33
  if (size == 0) {
#line 34
    *buffer___0 = (char *)((void *)0);
#line 35
    return (0);
  }
  {
#line 37
  tmp = xmalloc((size_t )size);
#line 37
  *buffer___0 = (char *)tmp;
#line 38
  readn(fd, (void *)*buffer___0, (size_t )size);
  }
#line 39
  if (*(*buffer___0 + (size - 1))) {
    {
#line 40
    warnx("read_block: input is not null-terminated");
    }
#line 41
    return (-2);
  }
#line 43
  return (size);
}
}
#line 48 "/home/wheatley/newnew/temp/mdm-0.1.3/library/comms.c"
static int unpack_svec___0(sv *sv___0 , int size ) 
{ 
  int ch ;
  int seg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 52
  seg = 0;
#line 52
  ch = seg;
#line 53
  tmp = seg;
#line 53
  seg ++;
#line 53
  *(sv___0->svec + tmp) = sv___0->buffer;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (ch < size)) {
#line 54
      goto while_break;
    }
#line 55
    tmp___0 = ch;
#line 55
    ch ++;
#line 55
    if (*(sv___0->buffer + tmp___0)) {
#line 55
      goto while_continue;
    }
#line 56
    tmp___1 = seg;
#line 56
    seg ++;
#line 56
    *(sv___0->svec + tmp___1) = sv___0->buffer + ch;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  seg --;
#line 58
  *(sv___0->svec + seg) = (char *)((void *)0);
#line 59
  return (seg);
}
}
#line 161 "/home/wheatley/newnew/temp/mdm-0.1.3/library/socket.c"
static struct cmsghdr *cmptr___1  =    (struct cmsghdr *)((void *)0);
#line 28 "/home/wheatley/newnew/temp/mdm-0.1.3/library/comms.c"
static int read_block___1(int fd , char **buffer___0 ) 
{ 
  int size ;
  void *tmp ;

  {
  {
#line 30
  size = 0;
#line 32
  readn(fd, (void *)(& size), sizeof(int ));
  }
#line 33
  if (size == 0) {
#line 34
    *buffer___0 = (char *)((void *)0);
#line 35
    return (0);
  }
  {
#line 37
  tmp = xmalloc((size_t )size);
#line 37
  *buffer___0 = (char *)tmp;
#line 38
  readn(fd, (void *)*buffer___0, (size_t )size);
  }
#line 39
  if (*(*buffer___0 + (size - 1))) {
    {
#line 40
    warnx("read_block: input is not null-terminated");
    }
#line 41
    return (-2);
  }
#line 43
  return (size);
}
}
#line 48 "/home/wheatley/newnew/temp/mdm-0.1.3/library/comms.c"
static int unpack_svec___1(sv *sv___0 , int size ) 
{ 
  int ch ;
  int seg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 52
  seg = 0;
#line 52
  ch = seg;
#line 53
  tmp = seg;
#line 53
  seg ++;
#line 53
  *(sv___0->svec + tmp) = sv___0->buffer;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (ch < size)) {
#line 54
      goto while_break;
    }
#line 55
    tmp___0 = ch;
#line 55
    ch ++;
#line 55
    if (*(sv___0->buffer + tmp___0)) {
#line 55
      goto while_continue;
    }
#line 56
    tmp___1 = seg;
#line 56
    seg ++;
#line 56
    *(sv___0->svec + tmp___1) = sv___0->buffer + ch;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  seg --;
#line 58
  *(sv___0->svec + seg) = (char *)((void *)0);
#line 59
  return (seg);
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 96 "include/middleman.h"
_Bool proc_stat(pid_t pid , proc *pptr ) ;
#line 97
char *time_string(unsigned long seconds ) ;
#line 32 "/home/wheatley/newnew/temp/mdm-0.1.3/library/procfs.c"
static time_t boot_time(void) ;
#line 32 "/home/wheatley/newnew/temp/mdm-0.1.3/library/procfs.c"
static unsigned long boot  =    0UL;
#line 30 "/home/wheatley/newnew/temp/mdm-0.1.3/library/procfs.c"
static time_t boot_time(void) 
{ 
  char buffer___0[1024] ;
  FILE *stat_fp ;
  FILE *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  if (boot == 0UL) {
    {
#line 36
    tmp = fopen((char const   */* __restrict  */)"/proc/stat", (char const   */* __restrict  */)"r");
#line 36
    stat_fp = tmp;
    }
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 37
      tmp___1 = fgets((char */* __restrict  */)(buffer___0), (int )sizeof(buffer___0),
                      (FILE */* __restrict  */)stat_fp);
      }
#line 37
      if (! tmp___1) {
#line 37
        goto while_break;
      }
      {
#line 38
      tmp___0 = strncmp((char const   *)(buffer___0), "btime ", (size_t )6);
      }
#line 38
      if (tmp___0 == 0) {
        {
#line 39
        sscanf((char const   */* __restrict  */)(buffer___0 + 6), (char const   */* __restrict  */)"%lu",
               & boot);
        }
#line 40
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 42
    fclose(stat_fp);
    }
#line 43
    if (! (boot != 0UL)) {
      {
#line 43
      __assert_fail("boot != 0", "/home/wheatley/newnew/temp/mdm-0.1.3/library/procfs.c",
                    43U, "boot_time");
      }
    }
  }
#line 45
  return ((time_t )boot);
}
}
#line 50 "/home/wheatley/newnew/temp/mdm-0.1.3/library/procfs.c"
static unsigned long long clk_tck  ;
#line 48 "/home/wheatley/newnew/temp/mdm-0.1.3/library/procfs.c"
static time_t jiffy_to_sec(unsigned long long jiffy ) 
{ 
  long tmp ;

  {
#line 52
  if (clk_tck == 0ULL) {
    {
#line 53
    tmp = sysconf(2);
#line 53
    clk_tck = (unsigned long long )tmp;
    }
  }
#line 54
  return ((time_t )(jiffy / clk_tck));
}
}
#line 57
#pragma GCC diagnostic ignored "-Wformat"
#line 59 "/home/wheatley/newnew/temp/mdm-0.1.3/library/procfs.c"
_Bool proc_stat(pid_t pid , proc *pptr ) 
{ 
  unsigned long long start_jiffies ;
  char path[40] ;
  char buffer___0[1024] ;
  char *start ;
  int stat_fd ;
  int num ;
  ssize_t tmp ;
  char *tmp___0 ;
  time_t tmp___1 ;
  time_t tmp___2 ;
  time_t tmp___3 ;

  {
  {
#line 65
  snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"/proc/%d/stat",
           pid);
#line 66
  stat_fd = open((char const   *)(path), 0);
  }
#line 67
  if (stat_fd < 0) {
#line 67
    return ((_Bool)0);
  }
  {
#line 69
  tmp = read(stat_fd, (void *)(buffer___0), sizeof(buffer___0) - 1UL);
#line 69
  num = (int )tmp;
#line 70
  close(stat_fd);
  }
#line 71
  if (num < 0) {
#line 71
    return ((_Bool)0);
  }
  {
#line 72
  buffer___0[num] = (char )'\000';
#line 74
  tmp___0 = strrchr((char const   *)(buffer___0), ')');
#line 74
  start = tmp___0 + 2;
  }
#line 75
  if ((unsigned long )start == (unsigned long )((void *)0)) {
#line 75
    return ((_Bool)0);
  }
  {
#line 77
  num = sscanf((char const   */* __restrict  */)start, (char const   */* __restrict  */)"%c %d %*d %*d %*d %*d %*u %*lu %*lu %*lu %*lu %lu %*lu %*ld %*ld %*ld %*ld %*ld %*ld %llu",
               & pptr->state, & pptr->ppid, & pptr->utime, & start_jiffies);
  }
#line 88
  if (num != 4) {
#line 88
    return ((_Bool)0);
  }
  {
#line 90
  tmp___1 = jiffy_to_sec((unsigned long long )pptr->utime);
#line 90
  pptr->utime = (unsigned long )tmp___1;
#line 91
  tmp___2 = boot_time();
#line 91
  tmp___3 = jiffy_to_sec(start_jiffies);
#line 91
  pptr->start_time = tmp___2 + tmp___3;
  }
#line 92
  return ((_Bool)1);
}
}
#line 97 "/home/wheatley/newnew/temp/mdm-0.1.3/library/procfs.c"
static char buffer[10]  ;
#line 95 "/home/wheatley/newnew/temp/mdm-0.1.3/library/procfs.c"
char *time_string(unsigned long seconds ) 
{ 
  unsigned long minutes ;

  {
#line 100
  minutes = seconds / 60UL;
#line 101
  seconds %= 60UL;
#line 103
  if (minutes > 99UL) {
#line 104
    return ((char *)"99:59+");
  }
  {
#line 105
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%2lu:%02lu ",
          minutes, seconds);
  }
#line 106
  return (buffer);
}
}
#line 161 "/home/wheatley/newnew/temp/mdm-0.1.3/library/socket.c"
static struct cmsghdr *cmptr___2  =    (struct cmsghdr *)((void *)0);
#line 28 "/home/wheatley/newnew/temp/mdm-0.1.3/library/comms.c"
static int read_block___2(int fd , char **buffer___0 ) 
{ 
  int size ;
  void *tmp ;

  {
  {
#line 30
  size = 0;
#line 32
  readn(fd, (void *)(& size), sizeof(int ));
  }
#line 33
  if (size == 0) {
#line 34
    *buffer___0 = (char *)((void *)0);
#line 35
    return (0);
  }
  {
#line 37
  tmp = xmalloc((size_t )size);
#line 37
  *buffer___0 = (char *)tmp;
#line 38
  readn(fd, (void *)*buffer___0, (size_t )size);
  }
#line 39
  if (*(*buffer___0 + (size - 1))) {
    {
#line 40
    warnx("read_block: input is not null-terminated");
    }
#line 41
    return (-2);
  }
#line 43
  return (size);
}
}
#line 48 "/home/wheatley/newnew/temp/mdm-0.1.3/library/comms.c"
static int unpack_svec___2(sv *sv___0 , int size ) 
{ 
  int ch ;
  int seg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 52
  seg = 0;
#line 52
  ch = seg;
#line 53
  tmp = seg;
#line 53
  seg ++;
#line 53
  *(sv___0->svec + tmp) = sv___0->buffer;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (ch < size)) {
#line 54
      goto while_break;
    }
#line 55
    tmp___0 = ch;
#line 55
    ch ++;
#line 55
    if (*(sv___0->buffer + tmp___0)) {
#line 55
      goto while_continue;
    }
#line 56
    tmp___1 = seg;
#line 56
    seg ++;
#line 56
    *(sv___0->svec + tmp___1) = sv___0->buffer + ch;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  seg --;
#line 58
  *(sv___0->svec + seg) = (char *)((void *)0);
#line 59
  return (seg);
}
}
